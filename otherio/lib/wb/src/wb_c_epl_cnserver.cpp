/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* wb_c_epl_mn.c -- work bench methods of the Epl_MN class. */

#include <stdlib.h>
#include <unistd.h>

#include "pwr_baseclasses.h"
#include "pwr_basecomponentclasses.h"
#include "pwr_otherioclasses.h"

#include "co_string.h"

#include "wb_pwrs.h"
#include "wb_ldh_msg.h"
#include "wb_pwrb_msg.h"
#include "wb_wnav.h"
#include "wb_wsx.h"
#include "wb_session.h"

using namespace std;

static pwr_tStatus GenerateXddFile(ldh_sMenuCall* ip)
{
  pwr_tFileName finname = "$pwr_exe/cn_template.xdd";
  pwr_tFileName foutname = "$pwrp_exe/cn.xdd";
  FILE* fin;
  FILE* fout;
  char line[400];
  char l2[400];

  wb_session* sp = (wb_session*)ip->PointedSession;

  wb_object o = sp->object(ip->Pointed.Objid);

  dcli_translate_filename(finname, finname);
  fin = fopen(finname, "r");
  if (!fin)
    return 0;

  sprintf(foutname, "$pwrp_cnf/%s.xdd", o.name());
  str_ToLower(foutname, foutname);
  dcli_translate_filename(foutname, foutname);
  fout = fopen(foutname, "w");
  if (!fout) {
    fclose(fin);
    return 0;
  }

  while (dcli_read_line(line, sizeof(line), fin)) {
    str_trim(l2, line);

    if (streq(l2, "</ObjectList>")) {
      pwr_tEnum representation;
      pwr_tUInt16 number;
      unsigned short mv_index;
      unsigned short mv_subindex;
      unsigned short mv_offset;
      unsigned short mv_size;
      int di_entries = 0;
      int do_entries = 0;
      int ai8_entries = 0;
      int ai16_entries = 0;
      int ai32_entries = 0;
      int ao8_entries = 0;
      int ao16_entries = 0;
      int ao32_entries = 0;
      int rx_entries;
      int tx_entries;

      // Count entries
      for (wb_object child = o.first(); child; child = child.after()) {
        for (wb_object grandchild = child.first(); grandchild;
             grandchild = grandchild.after()) {
          switch (grandchild.cid()) {
          case pwr_cClass_ChanDi: {
            wb_attribute a
                = sp->attribute(grandchild.oid(), "RtBody", "Representation");
            if (!a) {
              fclose(fin);
              fclose(fout);
              return a.sts();
            }

            a.value(&representation);
            if (!a) {
              fclose(fin);
              fclose(fout);
              return a.sts();
            }

            a = sp->attribute(grandchild.oid(), "RtBody", "Number");
            if (!a) {
              fclose(fin);
              fclose(fout);
              return a.sts();
            }

            a.value(&number);
            if (!a) {
              fclose(fin);
              fclose(fout);
              return a.sts();
            }

            if (number == 0) {
              switch (representation) {
              case pwr_eDataRepEnum_Bit8:
                di_entries += 1;
                break;
              case pwr_eDataRepEnum_Bit16:
                di_entries += 2;
                break;
              case pwr_eDataRepEnum_Bit32:
                di_entries += 4;
                break;
              case pwr_eDataRepEnum_Bit64:
                di_entries += 8;
                break;
              }
            }
            break;
          }
          case pwr_cClass_ChanDo: {
            wb_attribute a
                = sp->attribute(grandchild.oid(), "RtBody", "Representation");
            if (!a) {
              fclose(fin);
              fclose(fout);
              return a.sts();
            }

            a.value(&representation);
            if (!a) {
              fclose(fin);
              fclose(fout);
              return a.sts();
            }

            a = sp->attribute(grandchild.oid(), "RtBody", "Number");
            if (!a) {
              fclose(fin);
              fclose(fout);
              return a.sts();
            }

            a.value(&number);
            if (!a) {
              fclose(fin);
              fclose(fout);
              return a.sts();
            }

            if (number == 0) {
              switch (representation) {
              case pwr_eDataRepEnum_Bit8:
                do_entries += 1;
                break;
              case pwr_eDataRepEnum_Bit16:
                do_entries += 2;
                break;
              case pwr_eDataRepEnum_Bit32:
                do_entries += 4;
                break;
              case pwr_eDataRepEnum_Bit64:
                do_entries += 8;
                break;
              }
            }
            break;
          }
          case pwr_cClass_ChanAi:
          case pwr_cClass_ChanIi: {
            wb_attribute a
                = sp->attribute(grandchild.oid(), "RtBody", "Representation");
            if (!a) {
              fclose(fin);
              fclose(fout);
              return a.sts();
            }

            a.value(&representation);
            if (!a) {
              fclose(fin);
              fclose(fout);
              return a.sts();
            }

            switch (representation) {
            case pwr_eDataRepEnum_Int8:
            case pwr_eDataRepEnum_UInt8:
              ai8_entries++;
              break;
            case pwr_eDataRepEnum_Int16:
            case pwr_eDataRepEnum_UInt16:
              ai16_entries++;
              break;
            case pwr_eDataRepEnum_Int32:
            case pwr_eDataRepEnum_UInt32:
              ai32_entries++;
              break;
            default:;
            }
            break;
          }
          case pwr_cClass_ChanIo:
          case pwr_cClass_ChanAo: {
            wb_attribute a
                = sp->attribute(grandchild.oid(), "RtBody", "Representation");
            if (!a) {
              fclose(fin);
              fclose(fout);
              return a.sts();
            }

            a.value(&representation);
            if (!a) {
              fclose(fin);
              fclose(fout);
              return a.sts();
            }

            switch (representation) {
            case pwr_eDataRepEnum_Int8:
            case pwr_eDataRepEnum_UInt8:
              ao8_entries++;
              break;
            case pwr_eDataRepEnum_Int16:
            case pwr_eDataRepEnum_UInt16:
              ao16_entries++;
              break;
            case pwr_eDataRepEnum_Int32:
            case pwr_eDataRepEnum_UInt32:
              ao32_entries++;
              break;
            default:;
            }
            break;
          }
          default:;
          }
        }
      }

      // Rx mapping
      rx_entries = di_entries + ai8_entries + ai16_entries + ai32_entries;
      if (rx_entries > 0) {
        int di_cnt = 0;
        int ai8_cnt = 0;
        int ai16_cnt = 0;
        int ai32_cnt = 0;
        int rx_cnt = 0;
        int entries = 0;
        int rx_offset = 0;

        fprintf(fout, "          <Object index=\"1600\" "
                      "name=\"PDO_RxMappParam_00h_AU64\" objectType=\"8\" "
                      "CDCFlag=\"TRUE\">\n");
        fprintf(fout,
            "            <SubObject subIndex=\"00\" name=\"NumberOfEntries\" "
            "objectType=\"7\" dataType=\"0005\" accessType=\"rw\" "
            "defaultValue=\"0x00\" actualValue=\"0x%02x\" CDCFlag=\"TRUE\"/>\n",
            rx_entries);
        rx_cnt++;

        for (wb_object child = o.first(); child; child = child.after()) {
          for (wb_object grandchild = child.first(); grandchild;
               grandchild = grandchild.after()) {
            switch (grandchild.cid()) {
            case pwr_cClass_ChanDi: {
              wb_attribute a
                  = sp->attribute(grandchild.oid(), "RtBody", "Representation");
              if (!a) {
                fclose(fin);
                fclose(fout);
                return a.sts();
              }

              a.value(&representation);
              if (!a) {
                fclose(fin);
                fclose(fout);
                return a.sts();
              }

              a = sp->attribute(grandchild.oid(), "RtBody", "Number");
              if (!a) {
                fclose(fin);
                fclose(fout);
                return a.sts();
              }

              a.value(&number);
              if (!a) {
                fclose(fin);
                fclose(fout);
                return a.sts();
              }

              if (number == 0) {
                switch (representation) {
                case pwr_eDataRepEnum_Bit8:
                  entries = 1;
                  break;
                case pwr_eDataRepEnum_Bit16:
                  entries = 2;
                  break;
                case pwr_eDataRepEnum_Bit32:
                  entries = 4;
                  break;
                case pwr_eDataRepEnum_Bit64:
                  entries = 8;
                  break;
                }
                for (int i = 0; i < entries; i++) {
                  mv_index = 0x6200;
                  mv_subindex = di_cnt + 1;
                  mv_size = 8;
                  fprintf(fout, "            <SubObject subIndex=\"%02x\" "
                                "name=\"ObjectMapping\" objectType=\"7\" "
                                "dataType=\"001B\" accessType=\"rw/ro\" "
                                "defaultValue=\"0\" "
                                "actualValue=\"0x%04x%04x%04x%04x\" "
                                "CDCFlag=\"TRUE\"/>\n",
                      rx_cnt, mv_size, rx_offset, mv_subindex, mv_index);
                  rx_offset += mv_size;
                  di_cnt++;
                  rx_cnt++;
                }
              }
              break;
            }
            case pwr_cClass_ChanAi:
            case pwr_cClass_ChanIi: {
              wb_attribute a
                  = sp->attribute(grandchild.oid(), "RtBody", "Representation");
              if (!a) {
                fclose(fin);
                fclose(fout);
                return a.sts();
              }

              a.value(&representation);
              if (!a) {
                fclose(fin);
                fclose(fout);
                return a.sts();
              }

              switch (representation) {
              case pwr_eDataRepEnum_Int8:
              case pwr_eDataRepEnum_UInt8:
                mv_index = 0x6410;
                mv_subindex = ai8_cnt + 1;
                mv_size = 8;
                fprintf(fout,
                    "            <SubObject subIndex=\"%02x\" "
                    "name=\"ObjectMapping\" objectType=\"7\" dataType=\"001B\" "
                    "accessType=\"rw/ro\" defaultValue=\"0\" "
                    "actualValue=\"0x%04x%04x%04x%04x\" CDCFlag=\"TRUE\"/>\n",
                    rx_cnt, mv_size, rx_offset, mv_subindex, mv_index);
                rx_offset += mv_size;
                ai8_cnt++;
                rx_cnt++;
                break;
              case pwr_eDataRepEnum_Int16:
              case pwr_eDataRepEnum_UInt16:
                mv_index = 0x6411;
                mv_subindex = ai16_cnt + 1;
                mv_size = 16;
                fprintf(fout,
                    "            <SubObject subIndex=\"%02x\" "
                    "name=\"ObjectMapping\" objectType=\"7\" dataType=\"001B\" "
                    "accessType=\"rw/ro\" defaultValue=\"0\" "
                    "actualValue=\"0x%04x%04x%04x%04x\" CDCFlag=\"TRUE\"/>\n",
                    rx_cnt, mv_size, rx_offset, mv_subindex, mv_index);
                rx_offset += mv_size;
                ai16_cnt++;
                rx_cnt++;
                break;
              case pwr_eDataRepEnum_Int32:
              case pwr_eDataRepEnum_UInt32:
                mv_index = 0x6412;
                mv_subindex = ai32_cnt + 1;
                mv_size = 32;
                fprintf(fout,
                    "            <SubObject subIndex=\"%02x\" "
                    "name=\"ObjectMapping\" objectType=\"7\" dataType=\"001B\" "
                    "accessType=\"rw/ro\" defaultValue=\"0\" "
                    "actualValue=\"0x%04x%04x%04x%04x\" CDCFlag=\"TRUE\"/>\n",
                    rx_cnt, mv_size, rx_offset, mv_subindex, mv_index);
                rx_offset += mv_size;
                ai32_cnt++;
                rx_cnt++;
                break;
              default:;
              }
              break;
            }
            default:;
            }
          }
        }

        fprintf(fout, "          </Object>\n");
      }

      // Tx mapping
      tx_entries = do_entries + ao8_entries + ao16_entries + ao32_entries;
      if (tx_entries > 0) {
        int do_cnt = 0;
        int ao8_cnt = 0;
        int ao16_cnt = 0;
        int ao32_cnt = 0;
        int tx_cnt = 0;
        int tx_offset = 0;
        int entries = 0;

        fprintf(fout, "          <Object index=\"1A00\" "
                      "name=\"PDO_TxMappParam_00h_AU64\" objectType=\"8\" "
                      "CDCFlag=\"TRUE\">\n");
        fprintf(fout,
            "            <SubObject subIndex=\"00\" name=\"NumberOfEntries\" "
            "objectType=\"7\" dataType=\"0005\" accessType=\"rw\" "
            "defaultValue=\"0x00\" actualValue=\"0x%x\" CDCFlag=\"TRUE\"/>\n",
            tx_entries);
        tx_cnt++;

        for (wb_object child = o.first(); child; child = child.after()) {
          for (wb_object grandchild = child.first(); grandchild;
               grandchild = grandchild.after()) {
            switch (grandchild.cid()) {
            case pwr_cClass_ChanDo: {
              wb_attribute a
                  = sp->attribute(grandchild.oid(), "RtBody", "Representation");
              if (!a) {
                fclose(fin);
                fclose(fout);
                return a.sts();
              }

              a.value(&representation);
              if (!a) {
                fclose(fin);
                fclose(fout);
                return a.sts();
              }

              a = sp->attribute(grandchild.oid(), "RtBody", "Number");
              if (!a) {
                fclose(fin);
                fclose(fout);
                return a.sts();
              }

              a.value(&number);
              if (!a) {
                fclose(fin);
                fclose(fout);
                return a.sts();
              }

              if (number == 0) {
                switch (representation) {
                case pwr_eDataRepEnum_Bit8:
                  entries = 1;
                  break;
                case pwr_eDataRepEnum_Bit16:
                  entries = 2;
                  break;
                case pwr_eDataRepEnum_Bit32:
                  entries = 4;
                  break;
                case pwr_eDataRepEnum_Bit64:
                  entries = 8;
                  break;
                }
                for (int i = 0; i < entries; i++) {
                  mv_index = 0x6000;
                  mv_subindex = do_cnt + 1;
                  mv_offset = do_cnt * 8;
                  mv_size = 8;
                  fprintf(fout, "            <SubObject subIndex=\"%02x\" "
                                "name=\"ObjectMapping\" objectType=\"7\" "
                                "dataType=\"001B\" accessType=\"rw/ro\" "
                                "defaultValue=\"0\" "
                                "actualValue=\"0x%04x%04x%04x%04x\" "
                                "CDCFlag=\"TRUE\"/>\n",
                      tx_cnt, mv_size, tx_offset, mv_subindex, mv_index);
                  tx_offset += mv_size;
                  do_cnt++;
                  tx_cnt++;
                }
              }
              break;
            }
            case pwr_cClass_ChanIo:
            case pwr_cClass_ChanAo: {
              wb_attribute a
                  = sp->attribute(grandchild.oid(), "RtBody", "Representation");
              if (!a) {
                fclose(fin);
                fclose(fout);
                return a.sts();
              }

              a.value(&representation);
              if (!a) {
                fclose(fin);
                fclose(fout);
                return a.sts();
              }

              switch (representation) {
              case pwr_eDataRepEnum_Int8:
              case pwr_eDataRepEnum_UInt8:
                mv_index = 0x6400;
                mv_subindex = ao8_cnt + 1;
                mv_size = 8;
                fprintf(fout,
                    "            <SubObject subIndex=\"%02x\" "
                    "name=\"ObjectMapping\" objectType=\"7\" dataType=\"001B\" "
                    "accessType=\"rw/ro\" defaultValue=\"0\" "
                    "actualValue=\"0x%04x%04x%04x%04x\" CDCFlag=\"TRUE\"/>\n",
                    tx_cnt, mv_size, tx_offset, mv_subindex, mv_index);
                tx_offset += mv_size;
                ao8_cnt++;
                tx_cnt++;
                break;
              case pwr_eDataRepEnum_Int16:
              case pwr_eDataRepEnum_UInt16:
                mv_index = 0x6401;
                mv_subindex = ao16_cnt + 1;
                mv_size = 16;
                fprintf(fout,
                    "            <SubObject subIndex=\"%02x\" "
                    "name=\"ObjectMapping\" objectType=\"7\" dataType=\"001B\" "
                    "accessType=\"rw/ro\" defaultValue=\"0\" "
                    "actualValue=\"0x%04x%04x%04x%04x\" CDCFlag=\"TRUE\"/>\n",
                    tx_cnt, mv_size, tx_offset, mv_subindex, mv_index);
                tx_offset += mv_size;
                ao16_cnt++;
                tx_cnt++;
                break;
              case pwr_eDataRepEnum_Int32:
              case pwr_eDataRepEnum_UInt32:
                mv_index = 0x6402;
                mv_subindex = ao32_cnt + 1;
                mv_size = 32;
                fprintf(fout,
                    "            <SubObject subIndex=\"%02x\" "
                    "name=\"ObjectMapping\" objectType=\"7\" dataType=\"001B\" "
                    "accessType=\"rw/ro\" defaultValue=\"0\" "
                    "actualValue=\"0x%04x%04x%04x%04x\" CDCFlag=\"TRUE\"/>\n",
                    tx_cnt, mv_size, tx_offset, mv_subindex, mv_index);
                tx_offset += mv_size;
                ao32_cnt++;
                tx_cnt++;
                break;
              default:;
              }
              break;
            }
            default:;
            }
          }
        }

        fprintf(fout, "          </Object>\n");
      }
      fprintf(fout, "%s\n", line);
    } else {
      fprintf(fout, "%s\n", line);
    }
  }
  fclose(fin);
  fclose(fout);

  char msg[300];
  sprintf(msg, "Xdd file generated, %s", foutname);
  ip->wnav->message('I', msg);

  return 1;
}

static pwr_tStatus GenerateXddFileFilter(ldh_sMenuCall* ip)
{
  return 1;
}

/*----------------------------------------------------------------------------*\
  Every method to be exported to the workbench should be registred here.
\*----------------------------------------------------------------------------*/

pwr_dExport pwr_BindMethods(Epl_CNServer) = { pwr_BindMethod(GenerateXddFile),
  pwr_BindMethod(GenerateXddFileFilter), pwr_NullMethod };
