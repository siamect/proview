/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2013 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include "pwr.h"
#include "pwr_basecomponentclasses.h"
#include "co_dcli.h"
#include "rt_io_base.h"
#include "rt_io_rack_init.h"
#include "rt_io_rack_close.h"
#include "rt_io_rack_read.h"
#include "rt_io_rack_write.h"
#include "rt_io_msg.h"
#include "rt_iom_msg.h"
#include "pwr_otherioclasses.h"
#include "rt_io_m_epl.h"
#include "rt_io_bus.h"

#if defined PWRE_CONF_EPL && defined PWRE_CONF_LIBPCAP

#include "Epl.h"
#include <errno.h>
#include <math.h>
#include <rt_pwr_msg.h>

/***************************************************************************/
/*                                                                         */
/*                                                                         */
/*          G L O B A L   D E F I N I T I O N S                            */
/*                                                                         */
/*                                                                         */
/***************************************************************************/
//---------------------------------------------------------------------------
// module global vars
//---------------------------------------------------------------------------
static int debug = 0;
static const char abMacAddr[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
static unsigned int uiCycleLen_g = 0;
static unsigned int uiCurCycleLen_g = 0;

// process image stuff
static tEplApiProcessImageCopyJob AppProcessImageCopyJob_g;
static void *AppProcessImageIn_g;
static void *AppProcessImageOut_g;
 
/*----------------------------------------------------------------------------*/

//---------------------------------------------------------------------------
// local function prototypes
//---------------------------------------------------------------------------

// This function is the entry point for your object dictionary. It is defined
// in OBJDICT.C by define EPL_OBD_INIT_RAM_NAME. Use this function name to define
// this function prototype here. If you want to use more than one Epl
// instances then the function name of each object dictionary has to differ.
tEplKernel PUBLIC  EplObdInitRam (tEplObdInitParam MEM* pInitParam_p);
static tEplKernel AppCbEvent(
			     tEplApiEventType        EventType_p,   // IN: event type (enum)
			     tEplApiEventArg*        pEventArg_p,   // IN: event argument (union)
			     io_sAgent*           pUserArg_p);
static tEplKernel AppCbSync(void);

//---------------------------------------------------------------------------
//
// Function:    AppCbEvent
//
// Description: event callback function called by EPL API layer within
//              user part (low priority).
//
// Parameters:  EventType_p     = event type
//              pEventArg_p     = pointer to union, which describes
//                                the event in detail
//              pUserArg_p      = user specific argument
//
// Returns:     tEplKernel      = error code,
//                                kEplSuccessful = no error
//                                kEplReject = reject further processing
//                                otherwise = post error event to API layer
//
// State:
//
//---------------------------------------------------------------------------
tEplKernel PUBLIC AppCbEvent (
			      tEplApiEventType EventType_p,   // IN: event type (enum)
			      tEplApiEventArg* pEventArg_p,   // IN: event argument (union)
			      io_sAgent* pUserArg_p    
			      )
{
    
  UINT uiVarLen;
  tEplKernel EplRet = kEplSuccessful;
  pwr_sClass_Epl_CNServer *op = (pwr_sClass_Epl_CNServer *)pUserArg_p->op;
	
  // check if NMT_GS_OFF is reached
  switch (EventType_p) {
  case kEplApiEventNmtStateChange: {
    op->NmtState = pEventArg_p->m_NmtStateChange.m_NewNmtState;
    switch ( op->NmtState) {
    case pwr_eEplNmtState_EplNmtCsOperational:
      op->Status = IOM__EPL_OPER;
      break;
    case pwr_eEplNmtState_EplNmtGsOff:
      op->Status = IOM__EPL_OFF;
      break;
    case pwr_eEplNmtState_EplNmtCsBasicEthernet:
      op->Status = IOM__EPL_BASICETHERNET;
      break;
    case pwr_eEplNmtState_EplNmtCsPreOperational1:
      op->Status = IOM__EPL_PREOPER1;
      break;
    case pwr_eEplNmtState_EplNmtCsPreOperational2:
      op->Status = IOM__EPL_PREOPER2;
      break;
    default:
      op->Status = IOM__EPL_NOOPER;
    }
			
    switch (pEventArg_p->m_NmtStateChange.m_NewNmtState) {
    case kEplNmtGsOff: {
      // NMT state machine was shut down,
      // because of user signal (CTRL-C) or critical EPL stack error
      // -> also shut down EplApiProcess() and main()
      EplRet = kEplShutdown;
					
      errh_Fatal("Event:kEplNmtGsOff originating event = 0x%X (%s)", pEventArg_p->m_NmtStateChange.m_NmtEvent,
		 EplGetNmtEventStr(pEventArg_p->m_NmtStateChange.m_NmtEvent));
                    
      break;
    }

    case kEplNmtGsResetCommunication: {
      break;
    }

    case kEplNmtGsResetConfiguration: {
      if (uiCycleLen_g != 0) {
	EplRet = EplApiWriteLocalObject(0x1006, 0x00, &uiCycleLen_g, sizeof (uiCycleLen_g));
	uiCurCycleLen_g = uiCycleLen_g;
      }
      else {
	uiVarLen = sizeof(uiCurCycleLen_g);
	EplApiReadLocalObject(0x1006, 0x00, &uiCurCycleLen_g, &uiVarLen);
      }
      break;
    }
    case kEplNmtCsPreOperational1:
    case kEplNmtMsPreOperational1: {
      errh_Info("AppCbEvent(0x%X) originating event = 0x%X (%s)", pEventArg_p->m_NmtStateChange.m_NewNmtState, pEventArg_p->m_NmtStateChange.m_NmtEvent, EplGetNmtEventStr(pEventArg_p->m_NmtStateChange.m_NmtEvent));
      break;
    }
				
    case kEplNmtCsPreOperational2:
    case kEplNmtMsPreOperational2: {
      break;
    }
    case kEplNmtCsReadyToOperate:
    case kEplNmtMsReadyToOperate: {
      break;
    }
    case kEplNmtGsInitialising: {
      break;
    }
    case kEplNmtGsResetApplication: {
      break;
    }
    case kEplNmtMsNotActive:
    case kEplNmtCsNotActive: {
      break;
    }
    case kEplNmtCsOperational:
    case kEplNmtMsOperational: {
      break;
    }
    case kEplNmtCsBasicEthernet:
    case kEplNmtMsBasicEthernet: {
      break;
    }

    default: {
    }
    }
            

    break;
  }

  case kEplApiEventCriticalError:
  case kEplApiEventWarning: {   
    // error or warning occurred within the stack or the application
    // on error the API layer stops the NMT state machine
			
    errh_Error( "%s(Err/Warn): Source = %s (%02X) EplError = %s (0x%03X)",
		__func__,
		EplGetEventSourceStr(pEventArg_p->m_InternalError.m_EventSource),
		pEventArg_p->m_InternalError.m_EventSource,
		EplGetEplKernelStr(pEventArg_p->m_InternalError.m_EplError),
		pEventArg_p->m_InternalError.m_EplError);
            
    // check additional argument
    switch (pEventArg_p->m_InternalError.m_EventSource) {
    case kEplEventSourceEventk:
    case kEplEventSourceEventu: {   
      // error occurred within event processing
      // either in kernel or in user part
                    
      errh_Error(" OrgSource = %s %02X",  EplGetEventSourceStr(pEventArg_p->m_InternalError.m_Arg.m_EventSource),
		 pEventArg_p->m_InternalError.m_Arg.m_EventSource);
                    
      break;
    }

    case kEplEventSourceDllk: {   
      // error occurred within the data link layer (e.g. interrupt processing)
      // the DWORD argument contains the DLL state and the NMT event
                    
      errh_Error(" val = %X", pEventArg_p->m_InternalError.m_Arg.m_dwArg);
                    
      break;
    }

    default: {
      break;
    }
    }
    break;
  }

  case kEplApiEventHistoryEntry: {   
    // new history entry
			
    errh_Info("%s(HistoryEntry): Type=0x%04X Code=0x%04X (0x%02X %02X %02X %02X %02X %02X %02X %02X)",
	      __func__,
	      pEventArg_p->m_ErrHistoryEntry.m_wEntryType,
	      pEventArg_p->m_ErrHistoryEntry.m_wErrorCode,
	      (WORD) pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[0],
	      (WORD) pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[1],
	      (WORD) pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[2],
	      (WORD) pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[3],
	      (WORD) pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[4],
	      (WORD) pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[5],
	      (WORD) pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[6],
	      (WORD) pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[7]);
            
    break;
  }
        
  case kEplApiEventNode: {
    switch (pEventArg_p->m_Node.m_NodeEvent) {
    case kEplNmtNodeEventCheckConf: {
      errh_Info("%s(Node=0x%X, CheckConf)", __func__, pEventArg_p->m_Node.m_uiNodeId);
      break;
    }

    case kEplNmtNodeEventUpdateConf: {
      errh_Info("%s(Node=0x%X, UpdateConf)", __func__, pEventArg_p->m_Node.m_uiNodeId);
      break;
    }

    case kEplNmtNodeEventFound: {
                    
      break;
    }

    case kEplNmtNodeEventNmtState: {
					
      switch (pEventArg_p->m_Node.m_NmtState) {
      case kEplNmtGsOff:
      case kEplNmtGsInitialising:
      case kEplNmtGsResetApplication:
      case kEplNmtGsResetCommunication:
      case kEplNmtGsResetConfiguration:
      case kEplNmtCsNotActive: {
                           
	break;
      }
      case kEplNmtCsPreOperational1:
      case kEplNmtCsPreOperational2:
      case kEplNmtCsReadyToOperate: {
                            
	break;
      }
      case kEplNmtCsOperational: {
                            
	break;
      }
      case kEplNmtCsBasicEthernet:
      case kEplNmtCsStopped:
      default: {
                            
	break;
      }
      }
      break;
    }

    case kEplNmtNodeEventError: {
                    
      errh_Error("AppCbEvent (Node=0x%X): Error = %s (0x%.4X)",
		 pEventArg_p->m_Node.m_uiNodeId,
		 EplGetEmergErrCodeStr(pEventArg_p->m_Node.m_wErrorCode),
		 pEventArg_p->m_Node.m_wErrorCode);
      break;
    }

    default: {
      break;
    }
    }
    break;
  }

  case kEplApiEventCfmProgress: {
    errh_Info("%s(Node=0x%X, CFM-Progress: Object 0x%X/%u,  %lu/%lu Bytes", __func__, pEventArg_p->m_CfmProgress.m_uiNodeId, pEventArg_p->m_CfmProgress.m_uiObjectIndex, pEventArg_p->m_CfmProgress.m_uiObjectSubIndex, (ULONG) pEventArg_p->m_CfmProgress.m_dwBytesDownloaded, (ULONG) pEventArg_p->m_CfmProgress.m_dwTotalNumberOfBytes);

    if ((pEventArg_p->m_CfmProgress.m_dwSdoAbortCode != 0)
	|| (pEventArg_p->m_CfmProgress.m_EplError != kEplSuccessful)) {
      errh_Error(" -> SDO Abort=0x%lX, Error=0x%X)", (unsigned long) pEventArg_p->m_CfmProgress.m_dwSdoAbortCode,
		 pEventArg_p->m_CfmProgress.m_EplError);
    }
    else {

    }
    break;
  }

  case kEplApiEventCfmResult: {
    switch (pEventArg_p->m_CfmResult.m_NodeCommand) {
    case kEplNmtNodeCommandConfOk: {
      errh_Info("%s(Node=0x%X, ConfOk)", __func__, pEventArg_p->m_CfmResult.m_uiNodeId);
      break;
    }

    case kEplNmtNodeCommandConfErr: {
      errh_Info("%s(Node=0x%X, ConfErr)", __func__, pEventArg_p->m_CfmResult.m_uiNodeId);
      break;
    }

    case kEplNmtNodeCommandConfReset: {
      errh_Info("%s(Node=0x%X, ConfReset)", __func__, pEventArg_p->m_CfmResult.m_uiNodeId);
      break;
    }

    case kEplNmtNodeCommandConfRestored: {
      errh_Info("%s(Node=0x%X, ConfRestored)", __func__, pEventArg_p->m_CfmResult.m_uiNodeId);
      break;
    }

    default: {
      errh_Info("%s(Node=0x%X, CfmResult=0x%X)", __func__, pEventArg_p->m_CfmResult.m_uiNodeId, pEventArg_p->m_CfmResult.m_NodeCommand);
      break;
    }
    }
    break;
  }

  default:
    break;
  }

  return EplRet;
}
//---------------------------------------------------------------------------
//
// Function:    AppCbSync
//
// Description: sync event callback function called by event module within
//              kernel part (high priority).
//              This function sets the outputs, reads the inputs and runs
//              the control loop.
//
// Parameters:  void
//
// Returns:     tEplKernel      = error code,
//                                kEplSuccessful = no error
//                                otherwise = post error event to API layer
//
// State:
//
//---------------------------------------------------------------------------
tEplKernel PUBLIC AppCbSync(void)
{
  tEplKernel EplRet = kEplSuccessful;
  EplRet = EplApiProcessImageExchange(&AppProcessImageCopyJob_g);
    
  if (EplRet != kEplSuccessful) {
    return EplRet;
  }
  return EplRet;
}

static pwr_tStatus IoRackInit (
			       io_tCtx	ctx,
			       io_sAgent	*ap,
			       io_sRack	*rp
			       ) 
{
  io_sLocalEpl_CNServer *local;
  pwr_sClass_Epl_CNServer *op = (pwr_sClass_Epl_CNServer *)rp->op;
	
  local = (io_sLocalEpl_CNServer *) calloc( 1, sizeof(io_sLocalEpl_CNServer));
  rp->Local = local;
  local->inputResetEnabled = 0;
	
  static tEplApiInitParam EplApiInitParam;
  tEplKernel EplRet = kEplSuccessful;
  char* sHostname = malloc(1023);
    
  gethostname(sHostname, 1023);
	
  if ( op->StallAction == pwr_eStallActionEnum_ResetInputs)
    local->inputResetEnabled = 1;
	
  // Init the I/O area
  unsigned int input_area_offset = 0;
  unsigned int input_area_chansize = 0;
  unsigned int output_area_offset = 0;
  unsigned int output_area_chansize = 0;
  io_sCard *cp;
  pwr_tCid cid;
  int obd_size;
  unsigned int obd_entries;
  int obd_offset;
  int i;
		
  if ( op->StallAction == pwr_eStallActionEnum_ResetInputs)
    local->inputResetEnabled = 1;
		
  // Show device offset and size
  if ( rp->Class == pwr_cClass_Epl_CN && rp->op) {
    ((pwr_sClass_Epl_CN *)rp->op)->InputAreaOffset = input_area_offset + input_area_chansize;
    ((pwr_sClass_Epl_CN *)rp->op)->OutputAreaOffset = output_area_offset + output_area_chansize;
  }
		
  // Get byte ordering
  local->byte_ordering = pwr_eByteOrderingEnum_LittleEndian;

  for ( cp = rp->cardlist; cp; cp = cp->next) {			
    cid = cp->Class;
    while ( ODD( gdh_GetSuperClass( cid, &cid, cp->Objid))) ;

    if ( cid != pwr_cClass_Epl_CNServerModule || !cp->op)
      continue;

    cp->MethodDisabled = 1;

    // Show module offset and size
    ((pwr_sClass_Epl_CNServerModule *)cp->op)->InputAreaOffset = 
      input_area_offset + input_area_chansize;
    ((pwr_sClass_Epl_CNServerModule *)cp->op)->OutputAreaOffset = 
      output_area_offset + output_area_chansize;
    
    io_bus_card_init( ctx, cp, &input_area_offset, &input_area_chansize, 
		      &output_area_offset, &output_area_chansize, local->byte_ordering, 
		      io_eAlignment_Powerlink);
			
    // Show module offset and size
    ((pwr_sClass_Epl_CNServerModule *)cp->op)->InputAreaSize = 
      input_area_offset + input_area_chansize - ((pwr_sClass_Epl_CNServerModule *)cp->op)->InputAreaOffset;
    ((pwr_sClass_Epl_CNServerModule *)cp->op)->OutputAreaSize = 
      output_area_offset + output_area_chansize - ((pwr_sClass_Epl_CNServerModule *)cp->op)->OutputAreaOffset;
			
    if( cp->next == NULL) {
      ((pwr_sClass_Epl_CNServerModule *)cp->op)->InputAreaSize += 
	pwr_Align(input_area_offset + input_area_chansize, 4) - 
	(input_area_offset + input_area_chansize);
      ((pwr_sClass_Epl_CNServerModule *)cp->op)->OutputAreaSize += 
	pwr_Align(output_area_offset + output_area_chansize, 4) - 
	(output_area_offset + output_area_chansize);
    }
  }
    
  // This is the calculated in- and outputarea size
  local->input_area_size = pwr_Align(input_area_offset + input_area_chansize, 4);
  local->output_area_size = pwr_Align(output_area_offset + output_area_chansize, 4);
	
  // Show agent in- and output area size
  op->InputAreaSize = local->input_area_size;
  op->OutputAreaSize = local->output_area_size;
	
  struct sched_param          schedParam;

  // adjust process priority
  // push nice level in case we have no RTPreempt
  if (nice (-20) == -1) {
    errh_Error("%s() couldn't set nice value! (%s)", __func__, strerror(errno));
  }
  //schedParam.sched_priority = MIN(sched_get_priority_max(SCHED_FIFO), 
  //				  sched_get_priority_min(SCHED_FIFO) + op->Priority);
  schedParam.__sched_priority = op->Priority;
  if (pthread_setschedparam(pthread_self(), SCHED_RR, &schedParam) != 0) {
    errh_Error("%s() couldn't set thread scheduling parameters! %d", __func__, schedParam.__sched_priority);
  }
    
  // binds all openPOWERLINK threads to the second CPU core
  cpu_set_t                   affinity;

  CPU_ZERO(&affinity);
  CPU_SET(1, &affinity);
  sched_setaffinity(0, sizeof(cpu_set_t), &affinity);
		
  // Initialize target specific stuff
  EplTgtInit();

  EPL_MEMSET(&EplApiInitParam, 0, sizeof (EplApiInitParam));
  EplApiInitParam.m_uiSizeOfStruct = sizeof (EplApiInitParam);
  EplApiInitParam.m_pEventUserArg = rp;

  // Get devicename from attribute in agent
  EplApiInitParam.m_HwParam.m_pszDevName = op->Device;

  // Get nodeid from attribute in agent
  EplApiInitParam.m_uiNodeId = op->NodeId;
  EplApiInitParam.m_dwIpAddress = ntohl( inet_addr( op->IpAddress));

  // write 00:00:00:00:00:00 to MAC address, so that the driver uses the real hardware address 
  EPL_MEMCPY(EplApiInitParam.m_abMacAddress, abMacAddr, sizeof (EplApiInitParam.m_abMacAddress));

  EplApiInitParam.m_fAsyncOnly = FALSE;

  EplApiInitParam.m_dwFeatureFlags            = -1;
  // required for error detection
  EplApiInitParam.m_dwCycleLen                = 0; // 5000;
  // const     
  EplApiInitParam.m_uiIsochrTxMaxPayload      = 256;
  // const              
  EplApiInitParam.m_uiIsochrRxMaxPayload      = 256;
  // const; only required for IdentRes              
  EplApiInitParam.m_dwPresMaxLatency          = 50000; 
  // required for initialisation (+28 bytes)           
  EplApiInitParam.m_uiPreqActPayloadLimit     = 36;
  // required for initialisation of Pres frame (+28 bytes)               
  EplApiInitParam.m_uiPresActPayloadLimit     = 36;
  // const; only required for IdentRes               
  EplApiInitParam.m_dwAsndMaxLatency          = 150000;
  // required for error detection           
  EplApiInitParam.m_uiMultiplCycleCnt         = 0;
  // required to set up max frame size                
  EplApiInitParam.m_uiAsyncMtu                = 1500;
  // required for sync             
  EplApiInitParam.m_uiPrescaler               = 2;                
  EplApiInitParam.m_dwLossOfFrameTolerance    = 500000;
  EplApiInitParam.m_dwAsyncSlotTimeout        = 3000000;
  EplApiInitParam.m_dwWaitSocPreq             = 150000;
  // NMT_DeviceType_U32
  EplApiInitParam.m_dwDeviceType              = -1;
  // NMT_IdentityObject_REC.VendorId_U32               
  EplApiInitParam.m_dwVendorId                = -1;
  // NMT_IdentityObject_REC.ProductCode_U32               
  EplApiInitParam.m_dwProductCode             = -1;
  // NMT_IdentityObject_REC.RevisionNo_U32               
  EplApiInitParam.m_dwRevisionNumber          = -1;
  // NMT_IdentityObject_REC.SerialNo_U32               
  EplApiInitParam.m_dwSerialNumber            = -1;              
  EplApiInitParam.m_dwApplicationSwDate       = 0;
  EplApiInitParam.m_dwApplicationSwTime       = 0;

  EplApiInitParam.m_dwSubnetMask              = ntohl( inet_addr( op->IpNetmask));
  EplApiInitParam.m_dwDefaultGateway          = 0;
  EPL_MEMCPY(EplApiInitParam.m_sHostname, sHostname, sizeof(EplApiInitParam.m_sHostname));
  EplApiInitParam.m_uiSyncNodeId              = EPL_C_ADR_SYNC_ON_SOA;
  EplApiInitParam.m_fSyncOnPrcNode            = FALSE;

  // set callback functions
  EplApiInitParam.m_pfnCbEvent = (tEplApiCbEvent)AppCbEvent;

  EplApiInitParam.m_pfnObdInitRam = EplObdInitRam;
  EplApiInitParam.m_pfnCbSync  = AppCbSync;

  // initialize POWERLINK stack
  EplRet = EplApiInitialize(&EplApiInitParam);
  if(EplRet != kEplSuccessful) {
    errh_Error("EplApiInitialize() failed (Error:0x%x!", EplRet);
    goto Exit;
  }

  // Allocate memory for the in- and outputareas
  if( local->output_area_size > 0)
    AppProcessImageIn_g = malloc(local->output_area_size);
  if( local->input_area_size > 0) {
    AppProcessImageOut_g = malloc(local->input_area_size);
  }
	
  // Save pointer to in- and outputareas in THIS agent object
  local->input_area = AppProcessImageOut_g;
  local->output_area = AppProcessImageIn_g; 

  if( local->inputResetEnabled && local->input_area_size > 0)
    local->tmp_area = malloc(local->input_area_size);
  else
    local->tmp_area = local->input_area;	
 
  AppProcessImageCopyJob_g.m_fNonBlocking = FALSE;
  AppProcessImageCopyJob_g.m_uiPriority = 0;
  AppProcessImageCopyJob_g.m_In.m_pPart = AppProcessImageIn_g;
  AppProcessImageCopyJob_g.m_In.m_uiOffset = 0;
  AppProcessImageCopyJob_g.m_In.m_uiSize = local->output_area_size;
  AppProcessImageCopyJob_g.m_Out.m_pPart = AppProcessImageOut_g;
  AppProcessImageCopyJob_g.m_Out.m_uiOffset = 0;
  AppProcessImageCopyJob_g.m_Out.m_uiSize = local->input_area_size;

  EplRet = EplApiProcessImageAlloc(local->output_area_size, local->input_area_size, 2, 2);
  if (EplRet != kEplSuccessful) {
    goto Exit;
  }


  // Link area values to object dictionary
  FILE *fp;
  if ( debug) {
    pwr_tFileName fname = "$pwrp_load/cnserver_dbg.txt";
    dcli_translate_filename( fname, fname);
    fp = fopen( fname, "w");
    fprintf( fp, "Index  subindex  offset  size entries\n");
  }

  int prev_in_offs = -1;
  int prev_out_offs = -1;
  int di_subidx = 0x01;
  int do_subidx = 0x01;
  int ai8_subidx = 0x01;
  int ai16_subidx = 0x01;
  int ai32_subidx = 0x01;
  int ao8_subidx = 0x01;
  int ao16_subidx = 0x01;
  int ao32_subidx = 0x01;
  for ( cp = rp->cardlist; cp; cp = cp->next) {			
    for ( i = 0; i < cp->ChanListSize; i++) {
      io_sChannel *chanp = &cp->chanlist[i];

      if ( !chanp->sop || !chanp->size)
	continue;

      switch (chanp->ChanClass) {
      case pwr_cClass_ChanDi: {
	if ( chanp->offset == prev_in_offs)
	  break;

	obd_size = 1;
	obd_entries = chanp->size;
	obd_offset = chanp->offset;

	EplRet = EplApiProcessImageLinkObject(0x6200, di_subidx,
					      obd_offset, TRUE, obd_size, &obd_entries);
	if (EplRet != kEplSuccessful) {
	  goto Exit;
	}
	if ( debug)
	  fprintf( fp, "0x%04x   0x%02x  0x%04x  0x%04x  %d\n", 0x6200, di_subidx, obd_offset, obd_size, obd_entries);

	di_subidx += obd_entries;
	prev_in_offs = chanp->offset;
	break;
      }
      case pwr_cClass_ChanAi:
      case pwr_cClass_ChanAit:
      case pwr_cClass_ChanIi: {
	if ( chanp->offset == prev_in_offs)
	  break;

	obd_size = chanp->size;
	obd_entries = 1;
	obd_offset = chanp->offset;

	if ( chanp->size == 1) {
	  EplRet = EplApiProcessImageLinkObject(0x6410, ai8_subidx++,
						obd_offset, TRUE, obd_size, &obd_entries);
	  if ( debug)
	    fprintf( fp, "0x%04x   0x%02x  0x%04x  0x%04x  %d\n", 0x6410, ai8_subidx-1, obd_offset, obd_size, obd_entries);
	}
	else if ( chanp->size == 2) {
	  EplRet = EplApiProcessImageLinkObject(0x6411, ai16_subidx++,
						obd_offset, TRUE, obd_size, &obd_entries);
	  if ( debug)
	    fprintf( fp, "0x%04x   0x%02x  0x%04x  0x%04x  %d\n", 0x6411, ai16_subidx-1, obd_offset, obd_size, obd_entries);
	}
	else if ( chanp->size == 4) {
	  EplRet = EplApiProcessImageLinkObject(0x6412, ai32_subidx++,
						obd_offset, TRUE, obd_size, &obd_entries);
	  if ( debug)
	    fprintf( fp, "0x%04x   0x%02x  0x%04x  0x%04x  %d\n", 0x6412, ai32_subidx-1, obd_offset, obd_size, obd_entries);
	}
	else
	  break;

	if (EplRet != kEplSuccessful) {
	  goto Exit;
	}
	prev_in_offs = chanp->offset;
	break;
      }
      case pwr_cClass_ChanDo: {
	if ( chanp->offset == prev_out_offs)
	  break;

	obd_size = 1;
	obd_entries = chanp->size;
	obd_offset = chanp->offset;
	EplRet = EplApiProcessImageLinkObject(0x6000, do_subidx,
					      obd_offset, FALSE, obd_size, &obd_entries);
	if (EplRet != kEplSuccessful) {
	  goto Exit;
	}
	if ( debug)
	  fprintf( fp, "0x%04x   0x%02x  0x%04x  0x%04x  %d\n", 0x6200, do_subidx, obd_offset, obd_size, obd_entries);
	do_subidx += obd_entries;
	prev_out_offs = chanp->offset;
	break;
      }
      case pwr_cClass_ChanAo:
      case pwr_cClass_ChanIo: {
	if ( chanp->offset == prev_out_offs)
	  break;

	obd_size = chanp->size;
	obd_entries = 1;
	obd_offset = chanp->offset;

	if ( chanp->size == 1) {
	  EplRet = EplApiProcessImageLinkObject(0x6400, ao8_subidx++,
						obd_offset, FALSE, obd_size, &obd_entries);
	  if ( debug)
	    fprintf( fp, "0x%04x   0x%02x  0x%04x  0x%04x  %d\n", 0x6400, ao8_subidx-1, obd_offset, obd_size, obd_entries);
	}
	else if ( chanp->size == 2) {
	  EplRet = EplApiProcessImageLinkObject(0x6401, ao16_subidx++,
						obd_offset, FALSE, obd_size, &obd_entries);
	  if ( debug)
	    fprintf( fp, "0x%04x   0x%02x  0x%04x  0x%04x  %d\n", 0x6401, ao16_subidx-1, obd_offset, obd_size, obd_entries);
	}
	else if ( chanp->size == 4) {
	  EplRet = EplApiProcessImageLinkObject(0x6402, ao32_subidx++,
						obd_offset, FALSE, obd_size, &obd_entries);
	  if ( debug)
	    fprintf( fp, "0x%04x   0x%02x  0x%04x  0x%04x  %d\n", 0x6402, ao32_subidx-1, obd_offset, obd_size, obd_entries);
	}
	else
	  break;

	if (EplRet != kEplSuccessful) {
	  goto Exit;
	}
	prev_out_offs = chanp->offset;
	break;
      }
      case pwr_cClass_ChanD: {
	pwr_sClass_ChanD *chan_d = (pwr_sClass_ChanD *) chanp->cop;
	if ( chan_d->Type == pwr_eDChanTypeEnum_Di) {
	  /* Di type */
	  if ( chanp->offset == prev_in_offs)
	    break;

	  obd_size = 1;
	  obd_entries = chanp->size;
	  obd_offset = chanp->offset;

	  EplRet = EplApiProcessImageLinkObject(0x6000, di_subidx,
						obd_offset, FALSE, obd_size, &obd_entries);
	  if (EplRet != kEplSuccessful) {
	    goto Exit;
	  }
	  di_subidx += obd_entries;
	  prev_in_offs = chanp->offset;
	}
	else {
	  /* Do type */
	  if ( chanp->offset == prev_out_offs)
	    break;

	  obd_size = 1;
	  obd_entries = chanp->size;
	  obd_offset = chanp->offset;
	  EplRet = EplApiProcessImageLinkObject(0x6200, do_subidx,
						obd_offset, TRUE, obd_size, &obd_entries);
	  if (EplRet != kEplSuccessful) {
	    goto Exit;
	  }
	  break;
	  do_subidx += obd_entries;
	  prev_out_offs = chanp->offset;
	}
	break;
      }
      case pwr_cClass_ChanBi:
      case pwr_cClass_ChanBo:
      case pwr_cClass_ChanBiBlob:
      case pwr_cClass_ChanBoBlob: {
	// TODO
	break;
      }
      }
    }
  }

  if ( debug)
    fclose( fp);

  // start processing
  EplRet = EplApiExecNmtCommand(kEplNmtEventSwReset);
  if (EplRet != kEplSuccessful) {
    IoRackClose( ctx, ap, rp);
    goto Exit;
  }
    
  errh_Success ("Powerlink init successfull");
  return IO__SUCCESS;
    

 Exit:
  errh_Error("IoCardInit: returns 0x%X", EplRet);
  return IO__SUCCESS;
}

static pwr_tStatus IoRackClose (
				io_tCtx	ctx,
				io_sAgent	*ap,
				io_sRack	*rp
				) 
{
  tEplKernel EplRet = kEplSuccessful;
  io_sLocalEpl_CNServer *local = (io_sLocalEpl_CNServer *)rp->Local;
	
  free(local);
	
  // halt the NMT state machine
  // so the processing of POWERLINK frames stops
  EplRet = EplApiExecNmtCommand(kEplNmtEventSwitchOff);

  // delete process image
  EplRet = EplApiProcessImageFree();
  // delete instance for all modules
  EplRet = EplApiShutdown();
  return IO__SUCCESS;
}

static pwr_tStatus IoRackRead (
			       io_tCtx	ctx,
			       io_sAgent	*ap,
			       io_sRack	*rp
			       ) 
{
  io_sLocalEpl_CNServer *local = (io_sLocalEpl_CNServer *)rp->Local;
  pwr_sClass_Epl_CNServer *op = (pwr_sClass_Epl_CNServer *)rp->op;
  io_sCard *cp;
  pwr_tUInt32 error_count = 0;
  
  

  int ret = IO__SUCCESS;
	
  if(!rp->Local)
    return ret;
	
  // Remeber the time when this functions was called the first time
  if( local->init == 0) {
    clock_gettime(CLOCK_REALTIME, &local->boot);
    local->init = 1;
  }
  	
  // Time now (tps = time when bad state occurred)
  clock_gettime(CLOCK_REALTIME, &local->tpe);
  
  error_count = op->ErrorCount;
  // Add to error count if server changed from good to bad state and setup is complete
  if( local->prevState == pwr_eEplNmtState_EplNmtCsOperational && op->NmtState != pwr_eEplNmtState_EplNmtCsOperational && ( (local->tpe).tv_sec - (local->boot).tv_sec) >= op->StartupTimeout)
    op->ErrorCount++;
  
  // Copy Powerlink process image to temp memory (only if stallaction=resetinputs else tmp_area=input_area)
  if( op->StallAction == pwr_eStallActionEnum_ResetInputs)
    memcpy( local->tmp_area , local->input_area, local->input_area_size);


  // If no bad state and were still in startup there can be no error (else remember when error occurred)
  if( op->NmtState == pwr_eEplNmtState_EplNmtMsOperational || ( (local->tpe).tv_sec - (local->boot).tv_sec) < op->StartupTimeout) {
    (local->tps).tv_sec = 0;
    local->timeoutStatus = 0;
  }
  else if( (local->tps).tv_sec == 0) {
    clock_gettime(CLOCK_REALTIME, &local->tps);
  }

  // Server error soft limit reached, tell log (once)
  if ( op->ErrorCount >= op->ErrorSoftLimit && error_count < op->ErrorSoftLimit) {
    errh_Warning( "IO Server ErrorSoftLimit reached, '%s'", rp->Name);
  }	
	
  // Server error hard limit reached, tell log (once)	
  if ( op->ErrorCount >= op->ErrorHardLimit && error_count < op->ErrorHardLimit) {
		
    if( op->StallAction == pwr_eStallActionEnum_EmergencyBreak) {
      errh_Error( "IO Server ErrorHardLimit reached '%s', IO stopped", rp->Name);
    }
    else
      errh_Error( "IO Server ErrorHardLimit reached '%s'", rp->Name);
  }
  
  // Server timeout has elapsed, tell log (once)	
  if( ( (local->tpe).tv_sec - (local->tps).tv_sec) >= op->Timeout && local->timeoutStatus == 0 && (local->tps).tv_sec != 0) {
	  
    local->timeoutStatus = 1;
    if( op->StallAction == pwr_eStallActionEnum_EmergencyBreak) {
      errh_Error( "IO Server timeout time elapsed '%s', IO stopped", rp->Name);
    }
    else if( op->StallAction == pwr_eStallActionEnum_ResetInputs) {
      errh_Error( "IO Server timeout time elapsed '%s', IO input area reset", rp->Name);
    }
    else
      errh_Error( "IO Server timeout time elapsed '%s'", rp->Name);
  }
  
  // Server error hard limit reached, take action (always)	
  if ( op->ErrorCount >= op->ErrorHardLimit) {
    if( op->StallAction == pwr_eStallActionEnum_EmergencyBreak) {
      ctx->Node->EmergBreakTrue = 1;
      errh_SetStatus(PWR__SRVFATAL);
      IoRackClose(ctx, ap, rp);
    }
    ret = IO__ERRDEVICE;
  }
  
  // Server timeout time elapsed, take action (always)	
  if ( ( (local->tpe).tv_sec - (local->tps).tv_sec) >= op->Timeout && (local->tps).tv_sec != 0) {
    if( op->StallAction == pwr_eStallActionEnum_EmergencyBreak) {
      ctx->Node->EmergBreakTrue = 1;
      errh_SetStatus(PWR__SRVFATAL);
      IoRackClose(ctx, ap, rp);
    }
    else if( op->StallAction == pwr_eStallActionEnum_ResetInputs) {
      memset( local->tmp_area, 0, local->input_area_size);
    }
    ret = IO__ERRDEVICE;
  }
  
  // Remember server state til next scan
  local->prevState = op->NmtState;
		
  // Update Proview chan-objects with data from Powerlink process image
  for ( cp = rp->cardlist; cp; cp = cp->next) {
    io_bus_card_read( ctx, rp, cp, local->tmp_area, 0, local->byte_ordering, 
		      pwr_eFloatRepEnum_FloatIEEE);
  }

  return ret;
}

static pwr_tStatus IoRackWrite (
				io_tCtx	ctx,
				io_sAgent	*ap,
				io_sRack	*rp
				) 
{
  io_sLocalEpl_CNServer *local = (io_sLocalEpl_CNServer *)rp->Local;
  io_sCard *cp;
  
  if(!rp->Local)
    return IO__SUCCESS;
    
  for ( cp = rp->cardlist; cp; cp = cp->next) {
    io_bus_card_write( ctx, cp, local->output_area, local->byte_ordering, pwr_eFloatRepEnum_FloatIEEE);
  }

  return IO__SUCCESS;
}

#else
static pwr_tStatus IoRackInit( io_tCtx ctx, io_sAgent *ap, io_sRack *rp) { return IO__RELEASEBUILD;}
static pwr_tStatus IoRackClose( io_tCtx ctx, io_sAgent *ap, io_sRack *rp) { return IO__RELEASEBUILD;}
static pwr_tStatus IoRackRead( io_tCtx ctx, io_sAgent *ap, io_sRack *rp) { return IO__RELEASEBUILD;}
static pwr_tStatus IoRackWrite( io_tCtx ctx, io_sAgent *ap, io_sRack *rp) { return IO__RELEASEBUILD;}
#endif



/*----------------------------------------------------------------------------*\
  Every method to be exported to the workbench should be registred here.
  \*----------------------------------------------------------------------------*/
pwr_dExport pwr_BindIoMethods(Epl_CNServer) = {
  pwr_BindIoMethod(IoRackInit),
  pwr_BindIoMethod(IoRackClose),
  pwr_BindIoMethod(IoRackRead),
  pwr_BindIoMethod(IoRackWrite),
  pwr_NullMethod
};

