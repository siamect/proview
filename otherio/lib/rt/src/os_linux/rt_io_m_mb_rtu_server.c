/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2013 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

/* rt_io_m_mb_rtu_server.c -- io methods for Modbus/RTU Server */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
#include <termios.h>
#if defined OS_LINUX
#include <termio.h>
#endif
#if defined OS_LINUX || defined OS_MACOS
#include <sgtty.h>
#endif
#include <sys/ioctl.h>

#include "pwr.h"
#include "co_cdh.h"
#include "pwr_baseclasses.h"
#include "pwr_basecomponentclasses.h"
#include "pwr_otherioclasses.h"
#include "pwr_version.h"
#include "rt_gdh.h"
#include "rt_io_base.h"
#include "rt_io_bus.h"
#include "rt_io_msg.h"
#include "rt_errh.h"
#include "co_cdh.h"
#include "co_time.h"
#include "rt_mb_msg.h"

#include "rt_io_mb_rtu.h"

char rcv_buffer[512];
static pwr_tStatus mb_init_channels( io_tCtx ctx, io_sAgent *ap, io_sRack *rp);
static void mb_shift_write( unsigned char *in, unsigned char *out, int sh, int quant);
static void mb_shift_read( unsigned char *in, unsigned char *out, int sh, int quant);

typedef struct {
  io_sRack *rp;
} mb_sCondata;

static void float_to_timeval(struct timeval *tv, float t)
{
  tv->tv_sec = t;
  tv->tv_usec = (t-(float)tv->tv_sec) * 1000000;
}
static void float_to_timespec(struct timespec *tv, float t)
{
  tv->tv_sec = t;
  tv->tv_nsec = (t-(float)tv->tv_sec) * 1000000000;
}

static void generate_crc( unsigned char *buf, int size, unsigned char *result)
{
  unsigned short int crc;
  unsigned short int gen_polynomial = 0xA001;
  unsigned short int flag_mask = 0x0001;
  unsigned short int flag;
  int i, j;  

  crc = 0xFFFF;

  for ( i = 0; i < size; i++) {
    crc = crc^buf[i];

    for ( j = 0; j < 8; j++) {
      flag = crc & flag_mask;
      crc = crc >> 1;
      if ( flag) 
	crc = crc ^ gen_polynomial;
    }
  }
  
  result[0] = (unsigned char) (crc & 0x00FF);
  result[1] = (unsigned char) ((crc >> 8) & 0x00FF);
}

static pwr_tStatus rtu_send( io_sServerLocal *local_master,
			     pwr_sClass_Modbus_RTU_Server *op,
			     void *bufp,
			     int buffer_size)
{
  int sts;
  unsigned char *buf = (unsigned char *)bufp;
  struct timespec tf;

  generate_crc( buf, buffer_size, &buf[buffer_size]);  

  if ( op->Debug) { 
    int i;
    pwr_tTime current;
    char timstr[40];
    time_GetTime( &current);
    time_AtoAscii( &current, time_eFormat_Time, timstr, sizeof(timstr));
    
    printf( "Snd: %s %2d  ", timstr, buffer_size + 2);
    for ( i = 0; i < buffer_size + 2; i++)
      printf( "%02d ", buf[i]);
    printf( "\n");
  }

  float_to_timespec( &tf, op->FrameTimeout);
  nanosleep( &tf, NULL);

  sts = write( local_master->fd, buf, buffer_size + 2);  
  if (sts <= 0) {
    op->ErrorCount++;
    return 0;
  }
  return 1;
}

static void *mb_receive( void *data)
{
  io_sRack *rp = ((mb_sCondata *)data)->rp;
  io_sServerLocal* local_master = rp->Local;
  pwr_sClass_Modbus_RTU_Server *op = (pwr_sClass_Modbus_RTU_Server *) rp->op;
  int data_size = 0;
  rec_buf *rb;
  unsigned char fc;
  unsigned char exception_code;
  ssize_t ssts;
  struct timeval tv = {0,0};
  int sts;
  fd_set read_fd;
  unsigned char crc[2];
  unsigned char telegram[512];

  free( data);

  tcflush( local_master->fd, TCIOFLUSH);

  while ( 1) {
    sts = 1;
    data_size = 0;

    float_to_timeval( &tv, op->CharTimeout);

    FD_ZERO(&read_fd);
    FD_SET( local_master->fd, &read_fd);
    sts = select( local_master->fd + 1, &read_fd, NULL, NULL, &tv);
    if ( sts == 0)
      continue;
    sts = read( local_master->fd, telegram, 1);

    if (sts <= 0) {
      op->Status = MB__CONNLOST;
      continue;
    }

    while( sts > 0) {
      data_size++;

      if ( data_size > 256) {
	data_size = 0;
	break;
      }
      float_to_timeval( &tv, op->CharTimeout);
      
      FD_ZERO( &read_fd);
      FD_SET( local_master->fd, &read_fd);
      sts = select( local_master->fd + 1, &read_fd, NULL, NULL, &tv);
      if ( sts == 0) {
	break;
      }
      sts = read( local_master->fd, telegram + data_size, 1);
    }

    if ( data_size < 2) {
      op->ErrorCount++;
      continue;
    }

    if ( op->Debug) { 
      int i;
      pwr_tTime current;
      char timstr[40];
      time_GetTime( &current);
      time_AtoAscii( &current, time_eFormat_Time, timstr, sizeof(timstr));

      printf( "Rcv: %s %2d  ", timstr, data_size);
      for ( i = 0; i < data_size; i++)
	printf( "%02d ", telegram[i]);
      printf( "\n");
    }
      
    generate_crc( telegram, data_size - 2, crc);
    if ( crc[0] != telegram[data_size-2] || crc[1] != telegram[data_size-1]) {
      op->ErrorCount++;
      continue;
    }
  
    op->RX_packets++;

    rb = (rec_buf *) telegram;

    fc = rb->fc;

    time_GetTime( &local_master->last_req_time);
    exception_code = 0;

    switch ( fc) {
    case pwr_eModbus_FCEnum_ReadHoldingRegisters: {
      io_sCard *cardp;
      io_sServerModuleLocal *local_card;
      pwr_sClass_Modbus_RTU_ServerModule *mp;
      read_req *rmsg = (read_req *)rb;
      rsp_read msg;
      int found;

      short addr = ntohs( rmsg->addr);
      short quant = ntohs( rmsg->quant);
      unsigned char unit_id = rmsg->unit_id;

      if ( quant < 1 || quant >= 0x07d0) {
	exception_code = 3;
	break;
      }

      /* Check the address */
      found = 0;
      for ( cardp = rp->cardlist; cardp; cardp = cardp->next) {
	mp = (pwr_sClass_Modbus_RTU_ServerModule *) cardp->op;
	if ( mp->UnitId == unit_id) {
	  local_card = cardp->Local;
	  found = 1;
	  break;
	}	
      }

      if ( !found) {
	exception_code = 2;
	break;
      }

      addr -= mp->ReadAddress;

      if ( addr < 0 || 
	   addr + quant * 2 > local_card->output_size) {
	exception_code = 2;
	break;
      }

      msg.fc = fc;
      msg.bc = quant * 2;
      msg.unit_id = rmsg->unit_id;
      thread_MutexLock( &local_master->mutex);
      memcpy( msg.buf, (char *)local_card->output_area + addr, quant * 2);
      thread_MutexUnlock( &local_master->mutex);

      ssts = rtu_send( local_master, op, &msg, sizeof(msg) - sizeof(msg.buf) + quant * 2 - 2);
      if (ssts < 0) {
	op->Status = MB__CONNLOST;
	break;
      }
      op->Status = MB__NORMAL;
      op->TX_packets++;      
      
      break;
    }
    case pwr_eModbus_FCEnum_ReadCoils:
    case pwr_eModbus_FCEnum_ReadDiscreteInputs: {
      io_sCard *cardp;
      io_sServerModuleLocal *local_card;
      pwr_sClass_Modbus_RTU_ServerModule *mp;
      read_req *rmsg = (read_req *)rb;
      rsp_read msg;
      int found;
      unsigned char mask;
      unsigned int bytes;
      int i;
      int offs;

      short addr = ntohs( rmsg->addr);
      short quant = ntohs( rmsg->quant);
      unsigned char unit_id = rmsg->unit_id;

      if ( quant < 1 || quant >= 0x07d0) {
	exception_code = 3;
	break;
      }

      /* Check the address */
      found = 0;
      for ( cardp = rp->cardlist; cardp; cardp = cardp->next) {
	mp = (pwr_sClass_Modbus_RTU_ServerModule *) cardp->op;
	if ( mp->UnitId == unit_id) {
	  local_card = cardp->Local;
	  found = 1;
	  break;
	}	
      }

      if ( !found) {
	exception_code = 2;
	break;
      }

      offs = addr / 8;
      bytes = (addr + quant) / 8 +  (((addr + quant) % 8 == 0) ? 0 : 1) - offs;

      if ( addr < 0 || 
	   offs + bytes + local_card->do_offset > local_card->output_size || 
	   offs + bytes > local_card->do_size) {
	exception_code = 2;
	break;
      }

      memset( &msg, 0, sizeof(msg));
      msg.fc = fc;
      msg.bc = bytes;
      msg.unit_id = rmsg->unit_id;
      
      thread_MutexLock( &local_master->mutex);
      if ( addr % 8 == 0) {
	memcpy( msg.buf, (char *)local_card->output_area + local_card->do_offset + addr/8, bytes);      

	mask = 0;
	for ( i = 0; i < quant % 8; i++)
	  mask |= 1 << i;

	if ( quant % 8 != 0) {
	  unsigned char *b = (unsigned char *) msg.buf;
	  b[bytes - 1] &= mask;
	}
      }
      else {
	mb_shift_read( (unsigned char *)local_card->output_area + local_card->do_offset + addr / 8,
		       (unsigned char *)msg.buf,
		       addr % 8, quant);
      }
      thread_MutexUnlock( &local_master->mutex);

      ssts = rtu_send( local_master, op, &msg, sizeof(msg) - sizeof(msg.buf) + bytes - 2);
      if (ssts < 0) {
	op->Status = MB__CONNLOST;
	break;
      }
      op->Status = MB__NORMAL;
      op->TX_packets++;      
      
      break;
    }
    case pwr_eModbus_FCEnum_WriteSingleRegister: {
      io_sCard *cardp;
      io_sServerModuleLocal *local_card;
      pwr_sClass_Modbus_RTU_ServerModule *mp;
      write_single_req *rmsg = (write_single_req *)rb;
      rsp_single_write msg;
      int found;
      
      short addr = ntohs( rmsg->addr);
      unsigned char unit_id = rmsg->unit_id;

      /* Check the address */
      found = 0;
      for ( cardp = rp->cardlist; cardp; cardp = cardp->next) {
	mp = (pwr_sClass_Modbus_RTU_ServerModule *) cardp->op;
	if ( mp->UnitId == unit_id) {
	  local_card = cardp->Local;
	  found = 1;
	  break;
	}	
      }

      if ( !found) {
	exception_code = 2;
	break;
      }

      addr -= mp->WriteAddress;

      if ( addr < 0 || 
	   addr + 2 > local_card->input_size) {
	exception_code = 2;
	break;
      }

      thread_MutexLock( &local_master->mutex);
      memcpy( (char *)local_card->input_area + addr, &rmsg->value, 2);
      thread_MutexUnlock( &local_master->mutex);

      msg.fc = fc;
      msg.addr = rmsg->addr;
      msg.value = rmsg->value;
      msg.unit_id = rmsg->unit_id;

      ssts = rtu_send( local_master, op, &msg, sizeof(msg) - 2);
      if (ssts < 0) {
	op->Status = MB__CONNLOST;
	break;
      }
      op->Status = MB__NORMAL;
      op->TX_packets++;      
      
      break;
    }
    case pwr_eModbus_FCEnum_WriteMultipleRegisters: {
      io_sCard *cardp;
      io_sServerModuleLocal *local_card;
      pwr_sClass_Modbus_RTU_ServerModule *mp;
      write_reg_req *rmsg = (write_reg_req *)rb;
      rsp_write msg;
      int found;

      short addr = ntohs( rmsg->addr);
      short quant = ntohs( rmsg->quant);
      unsigned char unit_id = rmsg->unit_id;

      if ( quant < 1 || quant >= 0x07d0) {
	exception_code = 3;
	break;
      }

      /* Check the address */
      found = 0;
      for ( cardp = rp->cardlist; cardp; cardp = cardp->next) {
	mp = (pwr_sClass_Modbus_RTU_ServerModule *) cardp->op;
	if ( mp->UnitId == unit_id) {
	  local_card = cardp->Local;
	  found = 1;
	  break;
	}	
      }

      if ( !found) {
	exception_code = 2;
	break;
      }

      addr -= mp->WriteAddress;

      if ( addr < 0 || 
	   addr + quant * 2 > local_card->input_size) {
	exception_code = 2;
	break;
      }

      thread_MutexLock( &local_master->mutex);
      memcpy( (char *)local_card->input_area + addr, rmsg->reg, quant * 2);
      thread_MutexUnlock( &local_master->mutex);

      msg.fc = fc;
      msg.addr = rmsg->addr;
      msg.quant = rmsg->quant;
      msg.unit_id = rmsg->unit_id;

      ssts = rtu_send( local_master, op, &msg, sizeof(msg) - 2);
      if (ssts < 0) {
	op->Status = MB__CONNLOST;
	break;
      }
      op->Status = MB__NORMAL;
      op->TX_packets++;      
      
      break;
    }
    case pwr_eModbus_FCEnum_WriteSingleCoil: {
      io_sCard *cardp;
      io_sServerModuleLocal *local_card;
      pwr_sClass_Modbus_RTU_ServerModule *mp;
      write_single_req *rmsg = (write_single_req *)rb;
      rsp_single_write msg;
      int found;
      unsigned char mask;
      int offs;

      short addr = ntohs( rmsg->addr);
      unsigned short value = ntohs( rmsg->value);
      unsigned char unit_id = rmsg->unit_id;

      /* Check the address */
      found = 0;
      for ( cardp = rp->cardlist; cardp; cardp = cardp->next) {
	mp = (pwr_sClass_Modbus_RTU_ServerModule *) cardp->op;
	if ( mp->UnitId == unit_id) {
	  local_card = cardp->Local;
	  found = 1;
	  break;
	}	
      }

      if ( !found) {
	exception_code = 2;
	break;
      }

      offs = addr / 8;

      if ( addr < 0 || 
	   offs + local_card->di_offset >= local_card->input_size || 
	   offs >= local_card->di_size) {
	exception_code = 2;
	break;
      }

      mask = 1 << (addr % 8);
      if ( value == 0xFF00 || value == 0) {
	thread_MutexLock( &local_master->mutex);
	if ( value == 0xFF00)
	  *((char *)local_card->input_area + local_card->di_offset + offs) |= mask;
	else
	  *((char *)local_card->input_area + local_card->di_offset + offs) &= ~mask;
	thread_MutexUnlock( &local_master->mutex);
      }
      msg.fc = fc;
      msg.addr = rmsg->addr;
      msg.value = rmsg->value;
      msg.unit_id = rmsg->unit_id;

      ssts = rtu_send( local_master, op, &msg, sizeof(msg) - 2);
      if (ssts < 0) {
	op->Status = MB__CONNLOST;
	break;
      }
      op->Status = MB__NORMAL;
      op->TX_packets++;      
      
      break;
    }
    case pwr_eModbus_FCEnum_WriteMultipleCoils: {
      io_sCard *cardp;
      io_sServerModuleLocal *local_card;
      pwr_sClass_Modbus_RTU_ServerModule *mp;
      write_reg_req *rmsg = (write_reg_req *)rb;
      rsp_write msg;
      int found;
      unsigned char mask;
      unsigned int bytes;
      int i;
      int offs;

      short addr = ntohs( rmsg->addr);
      short quant = ntohs( rmsg->quant);
      unsigned char unit_id = rmsg->unit_id;

      if ( quant < 1 || quant >= 0x07d0) {
	exception_code = 3;
	break;
      }

      /* Check the address */
      found = 0;
      for ( cardp = rp->cardlist; cardp; cardp = cardp->next) {
	mp = (pwr_sClass_Modbus_RTU_ServerModule *) cardp->op;
	if ( mp->UnitId == unit_id) {
	  local_card = cardp->Local;
	  found = 1;
	  break;
	}	
      }

      if ( !found) {
	exception_code = 2;
	break;
      }

      thread_MutexLock( &local_master->mutex);
      offs = addr / 8;
      bytes = (addr + quant) / 8 +  (((addr + quant) % 8 == 0) ? 0 : 1) - offs;

      if ( addr < 0 || 
	   offs + bytes + local_card->di_offset > local_card->input_size || 
	   offs + bytes > local_card->di_size) {
	exception_code = 2;
	break;
      }

      if ( addr % 8 == 0) {
	if ( quant % 8 != 0) {
	  mask = 0;
	  for ( i = 0; i < quant % 8; i++)
	    mask |= 1 << i;
	  
	  memcpy( (char *)local_card->input_area + local_card->di_offset + addr / 8, 
		  rmsg->reg, bytes - 1);
	  *((char *)local_card->input_area + local_card->di_offset + addr / 8 + bytes - 1) &= ~mask;
	  *((char *)local_card->input_area + local_card->di_offset + addr / 8 + bytes - 1) |= *((char *)rmsg->reg + bytes - 1) & mask;
	}
	else
	  memcpy( (char *)local_card->input_area + local_card->di_offset + addr / 8, 
		  rmsg->reg, bytes);
      }
      else {
	mb_shift_write( (unsigned char *)rmsg->reg, 
			(unsigned char *)local_card->input_area + local_card->di_offset + addr / 8,
			addr % 8, quant);
      }
      thread_MutexUnlock( &local_master->mutex);
	
      msg.fc = fc;
      msg.addr = rmsg->addr;
      msg.quant = rmsg->quant;
      msg.unit_id = rmsg->unit_id;
      
      ssts = rtu_send( local_master, op, &msg, sizeof(msg) - 2);
      if (ssts < 0) {
	op->Status = MB__CONNLOST;
	break;
      }
      op->Status = MB__NORMAL;
      op->TX_packets++;      
      
      break;
    }
    case 43: {
      /* Encapsulated Interface Transport, Read Device Identification */
      read_dev_id_req *rmsg = (read_dev_id_req *)rb;
      rsp_dev_id msg;
      int i;
      int len;

      if ( rmsg->mei_type != 0x2b) {
	exception_code = 1;
	break;
      }

      if ( rmsg->id_code != 1) {
	exception_code = 1;
	break;
      }

      if ( rmsg->object_id != 0) {
	exception_code = 1;
	break;
      }

      msg.fc = rmsg->fc;
      msg.mei_type = rmsg->mei_type;
      msg.id_code = rmsg->id_code;
      msg.conformity_level = 1;
      msg.more_follows = 0;
      msg.next_object_id = 0;
      msg.number_of_objects = 3;

      i = 0;

      /* Vendor name */
      msg.list[i++] = 0;
      len = strlen("Proview");
      msg.list[i++] = len;
      strncpy( (char *)&msg.list[i], "Proview", len);
      i += len;

      /* Product code */
      msg.list[i++] = 0;
      len = strlen("-");
      msg.list[i++] = len;
      strncpy( (char *)&msg.list[i], "-", len);
      i += len;

      /* Major Minor Revision */
      msg.list[i++] = 0;
      len = strlen(pwrv_cPwrVersionStr);
      msg.list[i++] = len;
      strncpy( (char *)&msg.list[i], pwrv_cPwrVersionStr, len);
      i += len;

      msg.unit_id = rmsg->unit_id;
	
      ssts = rtu_send( local_master, op, &msg, sizeof(msg) - sizeof(msg.list) + 1 - 2);
      if (ssts < 0) {
	op->Status = MB__CONNLOST;
	break;
      }
      op->Status = MB__NORMAL;
      op->TX_packets++;      
      
      break;
    }
    default:
      exception_code = 1;
    }

    if ( exception_code) {
      rsp_fault rsp_f;

      rsp_f.fc = fc + 0x80;
      rsp_f.ec = exception_code;
      rsp_f.unit_id = rb->unit_id;

      ssts = rtu_send( local_master, op, &rsp_f, sizeof(rsp_f) - 2);
      if (ssts < 0) {
	op->Status = MB__CONNLOST;
	break;
      }
      op->Status = MB__NORMAL;
      op->TX_packets++;
    }
  }    
  return 0;
}


/*----------------------------------------------------------------------------*\
   Init method for the Modbus/RTU server
\*----------------------------------------------------------------------------*/

static pwr_tStatus IoRackInit (
  io_tCtx	ctx,
  io_sAgent	*ap,
  io_sRack	*rp
) 
{
  struct termios tty_attributes;
  io_sServerLocal *local;
  pwr_tStatus   sts;
  pwr_sClass_Modbus_RTU_Server *op;
  pwr_tOName 	name;
  mb_sCondata 	*condata;
    
  op = (pwr_sClass_Modbus_RTU_Server *) rp->op;

  sts = gdh_ObjidToName( rp->Objid, (char *) &name, sizeof(name), cdh_mNName);
  errh_Info( "Init of Modbus RTU Server %s", name);

  rp->Local = calloc(1, sizeof(io_sServerLocal));
  local = rp->Local;

  if ( op->DisableServer)
    return IO__SUCCESS;

  local->fd = open( op->Device, O_RDWR | O_NDELAY | O_NOCTTY);
  if ( local->fd == -1) {
    errh_Error( "Modbus RTU Master, open device error, %s", ap->Name);
    return IO__ERRINIDEVICE;
  }

  tcgetattr( local->fd, &tty_attributes);
  tty_attributes.c_cc[VMIN] = 1;
  tty_attributes.c_cc[VTIME] = 0;
  tty_attributes.c_lflag &= ~(ICANON | ISIG | ECHO | IEXTEN);
  tty_attributes.c_cflag |= (CLOCAL | CREAD);
  tty_attributes.c_oflag &= ~(OPOST);
  tty_attributes.c_oflag &= ~(ONLCR);
  tty_attributes.c_iflag &= ~(INLCR | ICRNL);

  /* Speed */

#if defined OS_LINUX
  tty_attributes.c_cflag &= ~CBAUD;
#endif
  switch( op->Speed) {
  case 300:
    tty_attributes.c_cflag |= B300;
    break;
  case 1200:
    tty_attributes.c_cflag |= B1200;
    break;
  case 2400:
    tty_attributes.c_cflag |= B2400;
    break;
  case 4800:
    tty_attributes.c_cflag |= B4800;
    break;
  case 9600:
    tty_attributes.c_cflag |= B9600;
    break;
  case 19200:
    tty_attributes.c_cflag |= B19200;
    break;
  case 38400:
    tty_attributes.c_cflag |= B38400;
    break;
  case 57600:
    tty_attributes.c_cflag |= B57600;
    break;
  case 115200:
    tty_attributes.c_cflag |= B115200;
    break;
  default:
    errh_Error( "Modbus RTU Master, unsupported speed, %s", ap->Name);
    tty_attributes.c_cflag |= B9600;
    break;
  }
  
  
  /* DataBits 5, 6, 7 or 8 */
  tty_attributes.c_cflag &= ~CSIZE;
  switch ( op->DataBits) {
  case pwr_eDataBitsEnum_5:
    tty_attributes.c_cflag |= CS5;
    break;
  case pwr_eDataBitsEnum_6:
    tty_attributes.c_cflag |= CS6;
    break;
  case pwr_eDataBitsEnum_7:
    tty_attributes.c_cflag |= CS7;
    break;
  case pwr_eDataBitsEnum_8:
    tty_attributes.c_cflag |= CS8;
    break;
  default:
    errh_Error( "Modbus RTU Master, unsupported DataBits, %s", ap->Name);
    tty_attributes.c_cflag |= CS8;
  }  
  //tty_attributes.c_iflag |=ISTRIP;
  
  /* Parity */
  switch ( op->Parity) {
  case pwr_eParityEnum_Odd:
  case pwr_eParityEnum_Even:
    tty_attributes.c_cflag |= PARENB;
    tty_attributes.c_iflag |= IGNPAR;
    if ( op->Parity == pwr_eParityEnum_Even)
      tty_attributes.c_cflag &= ~PARODD;
    else
      tty_attributes.c_cflag |= PARODD;
    break;
  default:
    tty_attributes.c_cflag &= ~PARENB;
  }

  /* stopbitsval */

  switch ( op->StopBits) {
  case pwr_eStopBitsEnum_2:
    tty_attributes.c_cflag |=CSTOPB;
    break;
  case pwr_eStopBitsEnum_1:
    tty_attributes.c_cflag &=~CSTOPB;
    break;
  case pwr_eStopBitsEnum_0:
    errh_Error( "Modbus RTU Master, unsupported StopBits, %s", ap->Name);
    tty_attributes.c_cflag &=~CSTOPB;
    break;
  }

  tty_attributes.c_iflag &= ~IXON;  //ingen XON/XOFF in
  
  //tty_attributes.c_iflag &= (V_IGNCR);
  //tty_attributes.c_iflag &= (IGNPAR | V_IGNCR);
  //tty_attributes.c_iflag &= ~(BRKINT | IXON | V_INLCR | V_ICRNL);
  //tty_attributes.c_cflag &= ~(CSIZE | CSTOPB | PARENB);  //fippla om värden lite granna

  sts = tcsetattr( local->fd, TCSANOW, &tty_attributes);

  if ( sts < 0) {
    errh_Error( "Modbus RTU Master, set device attributes error, %s", ap->Name);
    return IO__ERRINIDEVICE;
  }
  
  sts = mb_init_channels( ctx, ap, rp);
  if ( EVEN(sts)) return sts;

  /* Create mutex */
  sts = thread_MutexInit( &local->mutex);
  if ( EVEN(sts)) {
    errh_Error( "Error creating mutex IO modbus rtu server %s", rp->Name);
    return IO__ERRINIDEVICE;
  }

  /* Create a thread for receive */
  condata = (mb_sCondata *) malloc( sizeof(mb_sCondata));
  condata->rp = rp;
    

  sts = thread_Create( &local->receive_thread, 0, mb_receive, (void *)condata);
  if ( EVEN(sts)) {
    errh_Error( "Error creating receive thread IO modbus rtu server %s", rp->Name);
    free( condata);
    return IO__ERRINIDEVICE;
  }

  op->Status = MB__NORMAL;

  return IO__SUCCESS;
}


static pwr_tStatus mb_init_channels( io_tCtx ctx, io_sAgent *ap, io_sRack *rp) 
{
  io_sServerModuleLocal *local_card;
  io_sCard *cardp;
  io_sServerLocal *local;
  short input_counter;
  short output_counter;
  short card_input_counter;
  short card_output_counter;
  pwr_sClass_Modbus_RTU_Server *op;
  pwr_sClass_Modbus_RTU_ServerModule *mp;
  char name[196];
  pwr_tStatus sts;
  pwr_tCid cid;
  
  io_sChannel *chanp;
  int i, latent_input_counter, latent_output_counter;
  pwr_tInt32 chan_size;
  pwr_sClass_ChanDi *chan_di;
  pwr_sClass_ChanDo *chan_do;
  pwr_sClass_ChanAi *chan_ai;
  pwr_sClass_ChanAit *chan_ait;
  pwr_sClass_ChanIi *chan_ii;
  pwr_sClass_ChanAo *chan_ao;
  pwr_sClass_ChanIo *chan_io;

  sts = gdh_ObjidToName(rp->Objid, (char *) &name, sizeof(name), cdh_mNName);

  op = (pwr_sClass_Modbus_RTU_Server *) rp->op;
  
  local = rp->Local;

  /* Create socket, store in local struct */
  
  /* Do configuration check and initialize modules. */

  cardp = rp->cardlist;

  input_counter = 0;
  output_counter = 0;
  card_input_counter = 0;
  card_output_counter = 0;
  latent_input_counter = 0;
  latent_output_counter = 0;

  while(cardp) {
    local_card = calloc(1, sizeof(*local_card));
    cardp->Local = local_card;
    input_counter = input_counter + card_input_counter + latent_input_counter;
    output_counter = output_counter + card_output_counter + latent_output_counter;
    local_card->input_area = (void *) &(op->Inputs) + input_counter;
    local_card->output_area = (void *) &(op->Outputs) + output_counter;
    card_input_counter = 0;
    card_output_counter = 0;
    latent_input_counter = 0;
    latent_output_counter = 0;

    /* From v4.1.3 we can have subclasses, find the super class */
    
    cid = cardp->Class;
    while ( ODD( gdh_GetSuperClass( cid, &cid, cardp->Objid))) ;

    switch (cid) {

      case pwr_cClass_Modbus_RTU_ServerModule:
        mp = (pwr_sClass_Modbus_RTU_ServerModule *) cardp->op;
        mp->Status = pwr_eModbusModule_StatusEnum_StatusUnknown;
        for (i = 0; i < cardp->ChanListSize; i++) {
          chanp = &cardp->chanlist[i];

	  if ( is_diag( &chanp->ChanAref)) {
	    chanp->udata |= PB_UDATA_DIAG;
	    switch (chanp->ChanClass) {	    
            case pwr_cClass_ChanIi:
	      chanp->offset = ((pwr_sClass_ChanIi *)chanp->cop)->Number;
	      chanp->size = GetChanSize( ((pwr_sClass_ChanIi *)chanp->cop)->Representation);
	      break;
	    default:
	      errh_Error( "Diagnostic channel class, card %s", cardp->Name);
	    }
	    continue;
	  }

          if (chanp->ChanClass != pwr_cClass_ChanDi) {
            card_input_counter += latent_input_counter;
	    latent_input_counter = 0;
          }

          if (chanp->ChanClass != pwr_cClass_ChanDo) {
            card_output_counter += latent_output_counter;
	    latent_output_counter = 0;
          }
      
          switch (chanp->ChanClass) {
      
            case pwr_cClass_ChanDi:
	      chan_di = (pwr_sClass_ChanDi *) chanp->cop;
              if (chan_di->Number == 0) {
	        card_input_counter += latent_input_counter;
	        latent_input_counter = 0;
	      }
              chanp->offset = card_input_counter;
	      chanp->mask = 1 << chan_di->Number;
	      if (chan_di->Representation == pwr_eDataRepEnum_Bit16) 
	        chanp->mask = swap16(chanp->mask);
	      if (chan_di->Representation == pwr_eDataRepEnum_Bit32)
	        chanp->mask = swap32((unsigned short) chanp->mask);
	      if (chan_di->Number == 0) latent_input_counter = GetChanSize(chan_di->Representation);
	      if (local_card->di_size == 0)
		local_card->di_offset = chanp->offset;
	      if (chan_di->Number == 0 || local_card->di_size == 0)
		local_card->di_size += GetChanSize(chan_di->Representation);
//	      printf("Di channel found in %s, Number %d, Offset %d\n", cardp->Name, chan_di->Number, chanp->offset);
	      break;
	  
            case pwr_cClass_ChanAi:
	      chan_ai = (pwr_sClass_ChanAi *) chanp->cop;
              chanp->offset = card_input_counter;
	      chan_size = GetChanSize(chan_ai->Representation);
              chanp->size = chan_size;
	      chanp->mask = 0;
	      card_input_counter += chan_size;
              io_AiRangeToCoef(chanp);
//	      printf("Ai channel found in %s, Number %d, Offset %d\n", cardp->Name, chan_ai->Number, chanp->offset);
	      break;
	  
            case pwr_cClass_ChanAit:
	      chan_ait = (pwr_sClass_ChanAit *) chanp->cop;
              chanp->offset = card_input_counter;
	      chan_size = GetChanSize(chan_ait->Representation);
              chanp->size = chan_size;
	      chanp->mask = 0;
	      card_input_counter += chan_size;
              io_AiRangeToCoef(chanp);
	      break;
	  
            case pwr_cClass_ChanIi:
	      chan_ii = (pwr_sClass_ChanIi *) chanp->cop;
              chanp->offset = card_input_counter;
	      chan_size = GetChanSize(chan_ii->Representation);
              chanp->size = chan_size;
	      chanp->mask = 0;
	      card_input_counter += chan_size;
//	      printf("Ii channel found in %s, Number %d, Offset %d\n", cardp->Name, chan_ii->Number, chanp->offset);
	      break;
	  
            case pwr_cClass_ChanDo:
	      chan_do = (pwr_sClass_ChanDo *) chanp->cop;
              if (chan_do->Number == 0) {
	        card_output_counter += latent_output_counter;
	        latent_output_counter = 0;
	      }
              chanp->offset = card_output_counter;
	      chan_size = GetChanSize(chan_do->Representation);
	      chanp->mask = 1 << chan_do->Number;
	      if (chan_do->Representation == pwr_eDataRepEnum_Bit16) 
	        chanp->mask = swap16(chanp->mask);
	      if (chan_do->Representation == pwr_eDataRepEnum_Bit32)
	        chanp->mask = swap32((unsigned short) chanp->mask);
	      if (chan_do->Number == 0) latent_output_counter = GetChanSize(chan_do->Representation);
	      if (local_card->do_size == 0)
		local_card->do_offset = chanp->offset;
	      if (chan_do->Number == 0 || local_card->do_size == 0)
		local_card->do_size += GetChanSize(chan_do->Representation);
//	      printf("Do channel found in %s, Number %d, Offset %d\n", cardp->Name, chan_do->Number, chanp->offset);
	      break;
	  
	    case pwr_cClass_ChanAo:
	      chan_ao = (pwr_sClass_ChanAo *) chanp->cop;
              chanp->offset = card_output_counter;
	      chan_size = GetChanSize(chan_ao->Representation);
              chanp->size = chan_size;
	      chanp->mask = 0;
	      card_output_counter += chan_size;
              io_AoRangeToCoef(chanp);
//	      printf("Ao channel found in %s, Number %d, Offset %d\n", cardp->Name, chan_ao->Number, chanp->offset);
	      break;
	  
            case pwr_cClass_ChanIo:
	      chan_io = (pwr_sClass_ChanIo *) chanp->cop;
              chanp->offset = card_output_counter;
	      chan_size = GetChanSize(chan_io->Representation);
              chanp->size = chan_size;
	      chanp->mask = 0;
	      card_output_counter += chan_size;
//	      printf("Io channel found in %s, Number %d, Offset %d\n", cardp->Name, chan_io->Number, chanp->offset);
	      break;
          }
        } /* End - for ... */
        
        break;
    } /* End - switch ... */

    local_card->input_size = card_input_counter + latent_input_counter;
    local_card->output_size = card_output_counter + latent_output_counter;

    cardp = cardp->next;
  }

  local->input_size = input_counter + card_input_counter + latent_input_counter;
  local->output_size = output_counter + card_output_counter + latent_output_counter;

  return IO__SUCCESS;
}

static void mb_shift_write( unsigned char *in, unsigned char *out, int sh, int quant)
{
  int i;

  if ( sh + quant <= 8) {
    unsigned char mask = 0;
    for ( i = sh; i < sh + quant; i++)
      mask |= 1 << i;
    out[0] &= ~mask;
    out[0] |= mask & (in[0] << sh);
    return;
  }

  for ( i = 0; i < (quant + sh)/ 8; i++) {
    if ( i == 0) {
      unsigned char mask = ~0 << sh;

      out[0] &= ~mask;
      out[0] |= mask & (in[0] << sh);
    }
    else {
      out[i] = in[i] << sh;
      out[i] |= in[i-1] >> (8 - sh);
    }
  }
  if ( (quant + sh) % 8 != 0) {
    unsigned char mask = ~0 << ((quant + sh) % 8);
    mask = ~mask;

    out[i] &= ~mask;
    out[i] |= mask & (in[i] << sh);
    out[i] |= mask & (in[i-1] >> (8 - sh));
  }
}

void mb_shift_read( unsigned char *in, unsigned char *out, int sh, int quant)
{
  int i;

  if ( sh + quant <= 8) {
    unsigned char mask = ~0;
    mask = mask >> (8 - quant);

    out[0] = mask & (in[0] >> sh);
    return;
  }

  for ( i = 0; i < quant / 8; i++) {
    out[i] = in[i] >> sh;
    out[i] |= in[i+1] << (8 - sh);
  }

  out[i] = in[i] >> sh;
  if ( (quant + sh) / 8 > quant / 8) 
    out[i] |= in[i+1] << (8 - sh);

  if ( quant % 8 != 0) {
    unsigned char mask = ~0;
    mask = mask >> (8 - (quant % 8));
    out[i] &= mask;
  }
}


/*----------------------------------------------------------------------------*\
   Read method for the Modbus RTU server
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoRackRead (
  io_tCtx	ctx,
  io_sAgent	*ap,
  io_sRack	*rp
) 
{
  return IO__SUCCESS;
}


/*----------------------------------------------------------------------------*\
   Write method for the Modbus_RTU server
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoRackWrite (
  io_tCtx	ctx,
  io_sAgent	*ap,
  io_sRack	*rp
) 
{
  return IO__SUCCESS;
}


/*----------------------------------------------------------------------------*\
  
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoRackClose (
  io_tCtx	ctx,
  io_sAgent	*ap,
  io_sRack	*rp
) 
{
  io_sServerLocal* local = rp->Local;

  close( local->fd);

  return IO__SUCCESS;
}


/*----------------------------------------------------------------------------*\
  Every method to be exported to the workbench should be registred here.
\*----------------------------------------------------------------------------*/

pwr_dExport pwr_BindIoMethods(Modbus_RTU_Server) = {
  pwr_BindIoMethod(IoRackInit),
  pwr_BindIoMethod(IoRackRead),
  pwr_BindIoMethod(IoRackWrite),
  pwr_BindIoMethod(IoRackClose),
  pwr_NullMethod
};
