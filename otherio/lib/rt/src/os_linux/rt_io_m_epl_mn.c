/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2012 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/
 
 /****************************************************************************

  (c) SYSTEC electronic GmbH, D-07973 Greiz, August-Bebel-Str. 29
      www.systec-electronic.com

  (c) Bernecker + Rainer Industrie-Elektronik Ges.m.b.H.
      B&R Strasse 1, A-5142 Eggelsberg
      www.br-automation.com

  License:

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

    1. Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

    3. Neither the name of the copyright holders nor the names of its
       contributors may be used to endorse or promote products derived
       from this software without prior written permission. For written
       permission, please contact info@systec-electronic.com.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.

    Severability Clause:

        If a provision of this License is or becomes illegal, invalid or
        unenforceable in any jurisdiction, that shall not affect:
        1. the validity or enforceability in that jurisdiction of any other
           provision of this License; or
        2. the validity or enforceability in other jurisdictions of that or
           any other provision of this License.

****************************************************************************/
#include "pwr.h"
#include "pwr_basecomponentclasses.h"
#include "co_dcli.h"
#include "rt_io_base.h"
#include "rt_io_agent_init.h"
#include "rt_io_agent_close.h"
#include "rt_io_msg.h"
#include "rt_iom_msg.h"
#include "pwr_otherioclasses.h"
#include "rt_io_m_epl.h"
#include "rt_io_bus.h"

#if defined PWRE_CONF_EPL

#include "Epl.h"
#include <errno.h>
#include <math.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <rt_pwr_msg.h>


#define pl_Align(offs, align) ((offs + (align - 1)) & ~(align - 1))

/***************************************************************************/
/*                                                                         */
/*                                                                         */
/*          G L O B A L   D E F I N I T I O N S                            */
/*                                                                         */
/*                                                                         */
/***************************************************************************/

//---------------------------------------------------------------------------
// module global vars
//---------------------------------------------------------------------------
CONST BYTE abMacAddr[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
static unsigned int uiCycleLen_g = 0;
static unsigned int uiCurCycleLen_g = 0;

// process image stuff
static void *AppProcessImageIn_g;
static void *AppProcessImageOut_g;
static tEplApiProcessImageCopyJob AppProcessImageCopyJob_g;

/*----------------------------------------------------------------------------*/

//---------------------------------------------------------------------------
// local function prototypes
//---------------------------------------------------------------------------

// This function is the entry point for your object dictionary. It is defined
// in OBJDICT.C by define EPL_OBD_INIT_RAM_NAME. Use this function name to define
// this function prototype here. If you want to use more than one Epl
// instances then the function name of each object dictionary has to differ.
tEplKernel PUBLIC  EplObdInitRam (tEplObdInitParam MEM* pInitParam_p);
tEplKernel PUBLIC AppCbEvent(
			     tEplApiEventType        EventType_p,   // IN: event type (enum)
			     tEplApiEventArg*        pEventArg_p,   // IN: event argument (union)
			     io_sAgent*           pUserArg_p);
tEplKernel PUBLIC AppCbSync(void);


/*----------------------------------------------------------------------------*\
  Init method for the Powerlink module
  \*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentInit (io_tCtx ctx, io_sAgent *ap) {
  io_sLocalEpl_MN *local;
  int sts;
  pwr_sClass_Epl_MN *op = (pwr_sClass_Epl_MN *)ap->op;
	
  local = (io_sLocalEpl_MN *) calloc( 1, sizeof(io_sLocalEpl_MN));
  ap->Local = local;
  local->inputResetEnabled = 0;
  op->NumberOfSlaves = 0;
	
  static tEplApiInitParam EplApiInitParam;
  tEplKernel EplRet = kEplSuccessful;
  pwr_tFileName cdc_file;
  char* sHostname = malloc(1023);
    
  if ( strchr(op->CDCfile, '/') != 0)
    strcpy( cdc_file, op->CDCfile);
  else {
    strcpy( cdc_file, "$pwrp_load/");
    strcat( cdc_file, op->CDCfile);
  }
  dcli_translate_filename( cdc_file, cdc_file);
  gethostname(sHostname, 1023);
	
  if( op->StallAction == pwr_eStallActionEnum_ResetInputs)
    local->inputResetEnabled = 1;
	
  // Init the I/O area
  unsigned int input_area_offset = 0;
  unsigned int input_area_chansize = 0;
  unsigned int output_area_offset = 0;
  unsigned int output_area_chansize = 0;
  io_sRack *rp;
  io_sCard *cp;
  pwr_tCid cid;

  for ( rp = ap->racklist; rp; rp = rp->next) {
    rp->Local =  calloc( 1, sizeof(io_sLocalEpl_CN));
    rp->MethodDisabled = 1;
    op->NumberOfSlaves++;
		
    if( ((pwr_sClass_Epl_CN *)rp->op)->StallAction == pwr_eStallActionEnum_ResetInputs)
      local->inputResetEnabled = 1;
		
    // Show device offset and size
    if ( rp->Class == pwr_cClass_Epl_CN && rp->op) {
      ((pwr_sClass_Epl_CN *)rp->op)->InputAreaOffset = input_area_offset + input_area_chansize;
      ((pwr_sClass_Epl_CN *)rp->op)->OutputAreaOffset = output_area_offset + output_area_chansize;
    }
		
    // Get byte ordering
    pwr_tAName name;
    pwr_tEnum byte_ordering;

    strcpy( name, rp->Name);
    strcat( name, ".ByteOrdering");
    sts = gdh_GetObjectInfo( name, &byte_ordering, sizeof(byte_ordering));
    if ( ODD(sts))
      ((io_sLocalEpl_CN *)rp->Local)->byte_ordering = byte_ordering;
    else
      ((io_sLocalEpl_CN *)rp->Local)->byte_ordering = 
	pwr_eByteOrderingEnum_LittleEndian;

    for ( cp = rp->cardlist; cp; cp = cp->next) {			
      cid = cp->Class;
      while ( ODD( gdh_GetSuperClass( cid, &cid, cp->Objid))) ;

      cp->MethodDisabled = 1;

      // Show module offset and size
      if ( cid == pwr_cClass_Epl_Module && cp->op) {
	((pwr_sClass_Epl_Module *)cp->op)->InputAreaOffset = 
	  input_area_offset + input_area_chansize;
	((pwr_sClass_Epl_Module *)cp->op)->OutputAreaOffset = 
	  output_area_offset + output_area_chansize;
      }
			
      io_bus_card_init( ctx, cp, &input_area_offset, &input_area_chansize, 
			&output_area_offset, &output_area_chansize, byte_ordering, 
			io_eAlignment_Powerlink);
			
      // Show module offset and size
      if ( cid == pwr_cClass_Epl_Module && cp->op) {
	((pwr_sClass_Epl_Module *)cp->op)->InputAreaSize = 
	  input_area_offset + input_area_chansize - ((pwr_sClass_Epl_Module *)cp->op)->InputAreaOffset;
	((pwr_sClass_Epl_Module *)cp->op)->OutputAreaSize = 
	  output_area_offset + output_area_chansize - ((pwr_sClass_Epl_Module *)cp->op)->OutputAreaOffset;
      }
			
      if(rp->next == NULL) {
	if(cp->next == NULL) {
	  ((pwr_sClass_Epl_Module *)cp->op)->InputAreaSize += 
	    pwr_Align(input_area_offset + input_area_chansize, 4) - 
	    (input_area_offset + input_area_chansize);
	  ((pwr_sClass_Epl_Module *)cp->op)->OutputAreaSize += 
	    pwr_Align(output_area_offset + output_area_chansize, 4) - 
	    (output_area_offset + output_area_chansize);
	}
      }
    }

    // Show slave offset and size
    if ( rp->Class == pwr_cClass_Epl_CN && rp->op) {
      ((pwr_sClass_Epl_CN *)rp->op)->InputAreaSize = input_area_offset + 
	input_area_chansize - ((pwr_sClass_Epl_CN *)rp->op)->InputAreaOffset;
      ((pwr_sClass_Epl_CN *)rp->op)->OutputAreaSize = output_area_offset + 
	output_area_chansize - ((pwr_sClass_Epl_CN *)rp->op)->OutputAreaOffset;
      if(rp->next == NULL) {
	((pwr_sClass_Epl_CN *)rp->op)->InputAreaSize += 
	  pwr_Align(input_area_offset + input_area_chansize, 4) - (input_area_offset + input_area_chansize);
	((pwr_sClass_Epl_CN *)rp->op)->OutputAreaSize += 
	  pwr_Align(output_area_offset + output_area_chansize, 4) - (output_area_offset + output_area_chansize);	
      }
    }		
  }

	
  // This is the calculated in- and outputarea size
  local->input_area_size = pwr_Align(input_area_offset + input_area_chansize, 4);
  local->output_area_size = pwr_Align(output_area_offset + output_area_chansize, 4);
	
  // Show agent in- and output area size
  op->InputAreaSize = local->input_area_size;
  op->OutputAreaSize = local->output_area_size;
	
  struct sched_param          schedParam;

  // adjust process priority
  // push nice level in case we have no RTPreempt
  if (nice (-20) == -1) {
    errh_Error("%s() couldn't set nice value! (%s)", __func__, strerror(errno));
  }
  //schedParam.sched_priority = MIN(sched_get_priority_max(SCHED_FIFO), 
  //				  sched_get_priority_min(SCHED_FIFO) + op->Priority);
  schedParam.__sched_priority = op->Priority;
  if (pthread_setschedparam(pthread_self(), SCHED_RR, &schedParam) != 0) {
    errh_Error("%s() couldn't set thread scheduling parameters! %d", __func__, schedParam.__sched_priority);
  }
    
  // binds all openPOWERLINK threads to the second CPU core
  cpu_set_t                   affinity;

  CPU_ZERO(&affinity);
  CPU_SET(1, &affinity);
  sched_setaffinity(0, sizeof(cpu_set_t), &affinity);
		
  // Initialize target specific stuff
  EplTgtInit();

  EPL_MEMSET(&EplApiInitParam, 0, sizeof (EplApiInitParam));
  EplApiInitParam.m_uiSizeOfStruct = sizeof (EplApiInitParam);
  EplApiInitParam.m_pEventUserArg = ap;

  // Get devicename from attribute in agent
  EplApiInitParam.m_HwParam.m_pszDevName = op->Device;

  // Get nodeid from attribute in agent
  EplApiInitParam.m_uiNodeId = op->NodeId;
  
  EplApiInitParam.m_dwIpAddress = ntohl( inet_addr( op->IpAddress));

  // write 00:00:00:00:00:00 to MAC address, so that the driver uses the real hardware address 
  EPL_MEMCPY(EplApiInitParam.m_abMacAddress, abMacAddr, sizeof (EplApiInitParam.m_abMacAddress));

  EplApiInitParam.m_fAsyncOnly = FALSE;

  EplApiInitParam.m_dwFeatureFlags            = -1;
  // required for error detection
  EplApiInitParam.m_dwCycleLen                = uiCycleLen_g;
  // const     
  EplApiInitParam.m_uiIsochrTxMaxPayload      = 256;
  // const              
  EplApiInitParam.m_uiIsochrRxMaxPayload      = 256;
  // const; only required for IdentRes              
  EplApiInitParam.m_dwPresMaxLatency          = 50000; 
  // required for initialisation (+28 bytes)           
  EplApiInitParam.m_uiPreqActPayloadLimit     = 36;
  // required for initialisation of Pres frame (+28 bytes)               
  EplApiInitParam.m_uiPresActPayloadLimit     = 36;
  // const; only required for IdentRes               
  EplApiInitParam.m_dwAsndMaxLatency          = 150000;
  // required for error detection           
  EplApiInitParam.m_uiMultiplCycleCnt         = 0;
  // required to set up max frame size                
  EplApiInitParam.m_uiAsyncMtu                = 1500;
  // required for sync             
  EplApiInitParam.m_uiPrescaler               = 2;                
  EplApiInitParam.m_dwLossOfFrameTolerance    = 500000;
  EplApiInitParam.m_dwAsyncSlotTimeout        = 3000000;
  EplApiInitParam.m_dwWaitSocPreq             = 150000;
  // NMT_DeviceType_U32
  EplApiInitParam.m_dwDeviceType              = -1;
  // NMT_IdentityObject_REC.VendorId_U32               
  EplApiInitParam.m_dwVendorId                = -1;
  // NMT_IdentityObject_REC.ProductCode_U32               
  EplApiInitParam.m_dwProductCode             = -1;
  // NMT_IdentityObject_REC.RevisionNo_U32               
  EplApiInitParam.m_dwRevisionNumber          = -1;
  // NMT_IdentityObject_REC.SerialNo_U32               
  EplApiInitParam.m_dwSerialNumber            = -1;              

  EplApiInitParam.m_dwSubnetMask              = ntohl( inet_addr( op->IpNetmask));
  EplApiInitParam.m_dwDefaultGateway          = 0;
  EPL_MEMCPY(EplApiInitParam.m_sHostname, sHostname, sizeof(EplApiInitParam.m_sHostname));
  EplApiInitParam.m_uiSyncNodeId              = EPL_C_ADR_SYNC_ON_SOA;
  EplApiInitParam.m_fSyncOnPrcNode            = FALSE;

  // set callback functions
  EplApiInitParam.m_pfnCbEvent = (tEplApiCbEvent)AppCbEvent;

  EplApiInitParam.m_pfnObdInitRam = EplObdInitRam;
  EplApiInitParam.m_pfnCbSync  = AppCbSync;

  // initialize POWERLINK stack
  EplRet = EplApiInitialize(&EplApiInitParam);
  if(EplRet != kEplSuccessful)
    {
      errh_Error("EplApiInitialize() failed (Error:0x%x!", EplRet);
      goto Exit;
    }

  EplRet = EplApiSetCdcFilename(cdc_file);
  if(EplRet != kEplSuccessful)
    {
      goto Exit;
    }

  // Allocate memory for the in- and outputareas
  if( local->output_area_size > 0)
    AppProcessImageIn_g = malloc(local->output_area_size);
  if( local->input_area_size > 0) {
    AppProcessImageOut_g = malloc(local->input_area_size);
  }

  // Save pointer to in- and outputareas in THIS agent object
  local->input_area = AppProcessImageOut_g;
  local->output_area = AppProcessImageIn_g;
	
  if( local->inputResetEnabled && local->input_area_size > 0)
    local->tmp_area = malloc(local->input_area_size);
  else
    local->tmp_area = local->input_area;
		
  AppProcessImageCopyJob_g.m_fNonBlocking = FALSE;
  AppProcessImageCopyJob_g.m_uiPriority = 0;
  AppProcessImageCopyJob_g.m_In.m_pPart = AppProcessImageIn_g;
  AppProcessImageCopyJob_g.m_In.m_uiOffset = 0;
  AppProcessImageCopyJob_g.m_In.m_uiSize = local->output_area_size;
  AppProcessImageCopyJob_g.m_Out.m_pPart = AppProcessImageOut_g;
  AppProcessImageCopyJob_g.m_Out.m_uiOffset = 0;
  AppProcessImageCopyJob_g.m_Out.m_uiSize = local->input_area_size;

  EplRet = EplApiProcessImageAlloc(local->output_area_size, local->input_area_size, 2, 2);
  if (EplRet != kEplSuccessful)
    {
      goto Exit;
    }

  EplRet = EplApiProcessImageSetup();
  if (EplRet != kEplSuccessful)
    {
      goto Exit;
    }

  // start processing
  EplRet = EplApiExecNmtCommand(kEplNmtEventSwReset);
  if (EplRet != kEplSuccessful)
    {
      IoAgentClose(NULL, NULL);
      goto Exit;
    }
    
  errh_Success ("Powerlink init successfull");
  return IO__SUCCESS;
    

 Exit:
  errh_Error("IoCardInit: returns 0x%X", EplRet);
  return IO__SUCCESS;

}
//---------------------------------------------------------------------------
//
// Function:    AppCbEvent
//
// Description: event callback function called by EPL API layer within
//              user part (low priority).
//
// Parameters:  EventType_p     = event type
//              pEventArg_p     = pointer to union, which describes
//                                the event in detail
//              pUserArg_p      = user specific argument
//
// Returns:     tEplKernel      = error code,
//                                kEplSuccessful = no error
//                                kEplReject = reject further processing
//                                otherwise = post error event to API layer
//
// State:
//
//---------------------------------------------------------------------------
tEplKernel PUBLIC AppCbEvent (
			      tEplApiEventType EventType_p,   // IN: event type (enum)
			      tEplApiEventArg* pEventArg_p,   // IN: event argument (union)
			      io_sAgent* pUserArg_p    
			      )
{
    
  UINT uiVarLen;
  tEplKernel EplRet = kEplSuccessful;
  pwr_sClass_Epl_MN *op = (pwr_sClass_Epl_MN *)pUserArg_p->op;
  io_sRack *rp;
	
  // check if NMT_GS_OFF is reached
  switch (EventType_p)
    {
    case kEplApiEventNmtStateChange:
      {
	op->NmtState = pEventArg_p->m_NmtStateChange.m_NewNmtState;
	op->Status = op->NmtState == pwr_eEplNmtState_EplNmtMsOperational ? IOM__EPL_OPER : IOM__EPL_NOOPER;
			
	switch (pEventArg_p->m_NmtStateChange.m_NewNmtState)
	  {
	  case kEplNmtGsOff:
	    {
	      // NMT state machine was shut down,
	      // because of user signal (CTRL-C) or critical EPL stack error
	      // -> also shut down EplApiProcess() and main()
	      EplRet = kEplShutdown;
					
	      errh_Fatal("Event:kEplNmtGsOff originating event = 0x%X (%s)", pEventArg_p->m_NmtStateChange.m_NmtEvent,
			 EplGetNmtEventStr(pEventArg_p->m_NmtStateChange.m_NmtEvent));
                    
	      break;
	    }

	  case kEplNmtGsResetCommunication:
	    {
	      break;
	    }

	  case kEplNmtGsResetConfiguration:
	    {
	      if (uiCycleLen_g != 0)
		{
		  EplRet = EplApiWriteLocalObject(0x1006, 0x00, &uiCycleLen_g, sizeof (uiCycleLen_g));
		  uiCurCycleLen_g = uiCycleLen_g;
		}
	      else
		{
		  uiVarLen = sizeof(uiCurCycleLen_g);
		  EplApiReadLocalObject(0x1006, 0x00, &uiCurCycleLen_g, &uiVarLen);
		}
	      break;
	    }
	  case kEplNmtCsPreOperational1:
	  case kEplNmtMsPreOperational1:
	    {
	      errh_Info("AppCbEvent(0x%X) originating event = 0x%X (%s)", pEventArg_p->m_NmtStateChange.m_NewNmtState, pEventArg_p->m_NmtStateChange.m_NmtEvent, EplGetNmtEventStr(pEventArg_p->m_NmtStateChange.m_NmtEvent));
	      break;
	    }
				
	  case kEplNmtCsPreOperational2:
	  case kEplNmtMsPreOperational2:
	    {
	      break;
	    }
	  case kEplNmtCsReadyToOperate:
	  case kEplNmtMsReadyToOperate:
	    {
	      break;
	    }
	  case kEplNmtGsInitialising:
	    {
	      break;
	    }
	  case kEplNmtGsResetApplication:
	    {
	      break;
	    }
	  case kEplNmtMsNotActive:
	  case kEplNmtCsNotActive:
	    {
	      break;
	    }
	  case kEplNmtCsOperational:
	  case kEplNmtMsOperational:
	    {
	      break;
	    }
	  case kEplNmtCsBasicEthernet:
	  case kEplNmtMsBasicEthernet:
	    {
	      break;
	    }

	  default:
	    {
	    }
	  }
            

	break;
      }

    case kEplApiEventCriticalError:
    case kEplApiEventWarning:
      {   // error or warning occurred within the stack or the application
	// on error the API layer stops the NMT state machine
			
	errh_Error( "%s(Err/Warn): Source = %s (%02X) EplError = %s (0x%03X)",
		    __func__,
		    EplGetEventSourceStr(pEventArg_p->m_InternalError.m_EventSource),
		    pEventArg_p->m_InternalError.m_EventSource,
		    EplGetEplKernelStr(pEventArg_p->m_InternalError.m_EplError),
		    pEventArg_p->m_InternalError.m_EplError);
            
	// check additional argument
	switch (pEventArg_p->m_InternalError.m_EventSource)
	  {
	  case kEplEventSourceEventk:
	  case kEplEventSourceEventu:
	    {   // error occurred within event processing
	      // either in kernel or in user part
                    
	      errh_Error(" OrgSource = %s %02X",  EplGetEventSourceStr(pEventArg_p->m_InternalError.m_Arg.m_EventSource),
			 pEventArg_p->m_InternalError.m_Arg.m_EventSource);
                    
	      break;
	    }

	  case kEplEventSourceDllk:
	    {   // error occurred within the data link layer (e.g. interrupt processing)
	      // the DWORD argument contains the DLL state and the NMT event
                    
	      errh_Error(" val = %X", pEventArg_p->m_InternalError.m_Arg.m_dwArg);
                    
	      break;
	    }

	  default:
	    {
	      break;
	    }
	  }
	break;
      }

    case kEplApiEventHistoryEntry:
      {   // new history entry
			
	errh_Info("%s(HistoryEntry): Type=0x%04X Code=0x%04X (0x%02X %02X %02X %02X %02X %02X %02X %02X)",
		  __func__,
		  pEventArg_p->m_ErrHistoryEntry.m_wEntryType,
		  pEventArg_p->m_ErrHistoryEntry.m_wErrorCode,
		  (WORD) pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[0],
		  (WORD) pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[1],
		  (WORD) pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[2],
		  (WORD) pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[3],
		  (WORD) pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[4],
		  (WORD) pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[5],
		  (WORD) pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[6],
		  (WORD) pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[7]);
            
	break;
      }
        
    case kEplApiEventNode:
      {
	switch (pEventArg_p->m_Node.m_NodeEvent)
	  {
	  case kEplNmtNodeEventCheckConf:
	    {
	      errh_Info("%s(Node=0x%X, CheckConf)", __func__, pEventArg_p->m_Node.m_uiNodeId);
	      break;
	    }

	  case kEplNmtNodeEventUpdateConf:
	    {
	      errh_Info("%s(Node=0x%X, UpdateConf)", __func__, pEventArg_p->m_Node.m_uiNodeId);
	      break;
	    }

	  case kEplNmtNodeEventFound:
	    {
                    
	      break;
	    }

	  case kEplNmtNodeEventNmtState:
	    {
	      for ( rp = pUserArg_p->racklist; rp; rp = rp->next)
		if(((pwr_sClass_Epl_CN *)rp->op)->NodeId == pEventArg_p->m_Node.m_uiNodeId) {
		  ((pwr_sClass_Epl_CN *)rp->op)->NmtState = pEventArg_p->m_Node.m_NmtState;
		  
		}
					
	      switch (pEventArg_p->m_Node.m_NmtState)
		{
		case kEplNmtGsOff:
		case kEplNmtGsInitialising:
		case kEplNmtGsResetApplication:
		case kEplNmtGsResetCommunication:
		case kEplNmtGsResetConfiguration:
		case kEplNmtCsNotActive:
		  {
                           
		    break;
		  }
		case kEplNmtCsPreOperational1:
		case kEplNmtCsPreOperational2:
		case kEplNmtCsReadyToOperate:
		  {
                            
		    break;
		  }
		case kEplNmtCsOperational:
		  {
                            
		    break;
		  }
		case kEplNmtCsBasicEthernet:
		case kEplNmtCsStopped:
		default:
		  {
                            
		    break;
		  }
		}
	      break;
	    }

	  case kEplNmtNodeEventError:
	    {
                    
	      errh_Error("AppCbEvent (Node=0x%X): Error = %s (0x%.4X)",
			 pEventArg_p->m_Node.m_uiNodeId,
			 EplGetEmergErrCodeStr(pEventArg_p->m_Node.m_wErrorCode),
			 pEventArg_p->m_Node.m_wErrorCode);
	      break;
	    }

	  default:
	    {
	      break;
	    }
	  }
	break;
      }

    case kEplApiEventCfmProgress:
      {
	errh_Info("%s(Node=0x%X, CFM-Progress: Object 0x%X/%u,  %lu/%lu Bytes", __func__, pEventArg_p->m_CfmProgress.m_uiNodeId, pEventArg_p->m_CfmProgress.m_uiObjectIndex, pEventArg_p->m_CfmProgress.m_uiObjectSubIndex, (ULONG) pEventArg_p->m_CfmProgress.m_dwBytesDownloaded, (ULONG) pEventArg_p->m_CfmProgress.m_dwTotalNumberOfBytes);

	if ((pEventArg_p->m_CfmProgress.m_dwSdoAbortCode != 0)
	    || (pEventArg_p->m_CfmProgress.m_EplError != kEplSuccessful))
	  {
	    errh_Error(" -> SDO Abort=0x%lX, Error=0x%X)", (unsigned long) pEventArg_p->m_CfmProgress.m_dwSdoAbortCode,
		       pEventArg_p->m_CfmProgress.m_EplError);
	  }
	else
	  {

	  }
	break;
      }

    case kEplApiEventCfmResult:
      {
	switch (pEventArg_p->m_CfmResult.m_NodeCommand)
	  {
	  case kEplNmtNodeCommandConfOk:
	    {
	      errh_Info("%s(Node=0x%X, ConfOk)", __func__, pEventArg_p->m_CfmResult.m_uiNodeId);
	      break;
	    }

	  case kEplNmtNodeCommandConfErr:
	    {
	      errh_Info("%s(Node=0x%X, ConfErr)", __func__, pEventArg_p->m_CfmResult.m_uiNodeId);
	      break;
	    }

	  case kEplNmtNodeCommandConfReset:
	    {
	      errh_Info("%s(Node=0x%X, ConfReset)", __func__, pEventArg_p->m_CfmResult.m_uiNodeId);
	      break;
	    }

	  case kEplNmtNodeCommandConfRestored:
	    {
	      errh_Info("%s(Node=0x%X, ConfRestored)", __func__, pEventArg_p->m_CfmResult.m_uiNodeId);
	      break;
	    }

	  default:
	    {
	      errh_Info("%s(Node=0x%X, CfmResult=0x%X)", __func__, pEventArg_p->m_CfmResult.m_uiNodeId, pEventArg_p->m_CfmResult.m_NodeCommand);
	      break;
	    }
	  }
	break;
      }

    default:
      break;
    }

  return EplRet;
}
//---------------------------------------------------------------------------
//
// Function:    AppCbSync
//
// Description: sync event callback function called by event module within
//              kernel part (high priority).
//              This function sets the outputs, reads the inputs and runs
//              the control loop.
//
// Parameters:  void
//
// Returns:     tEplKernel      = error code,
//                                kEplSuccessful = no error
//                                otherwise = post error event to API layer
//
// State:
//
//---------------------------------------------------------------------------
tEplKernel PUBLIC AppCbSync(void)
{
  tEplKernel EplRet = kEplSuccessful;
  EplRet = EplApiProcessImageExchange(&AppProcessImageCopyJob_g);
    
  if (EplRet != kEplSuccessful)
    {
      return EplRet;
    }
  return EplRet;
}
/*----------------------------------------------------------------------------*\
  Close method for the Powerlink master
  \*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentClose( io_tCtx ctx, io_sAgent *ap) {
  tEplKernel EplRet = kEplSuccessful;
  io_sLocalEpl_MN *local = (io_sLocalEpl_MN *)ap->Local;
  io_sRack *rp;
	
  free(local);
  ap->Local = 0;
  for ( rp = ap->racklist; rp; rp = rp->next) 
    free( (io_sLocalEpl_CN *)rp->Local);
	
  // halt the NMT state machine
  // so the processing of POWERLINK frames stops
  EplRet = EplApiExecNmtCommand(kEplNmtEventSwitchOff);

  // delete process image
  EplRet = EplApiProcessImageFree();
  // delete instance for all modules
  EplRet = EplApiShutdown();
	
  return IO__SUCCESS;
}
/*----------------------------------------------------------------------------*\
  Read method for the Powerlink master
  \*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentRead( io_tCtx ctx, io_sAgent *ap) {	
  io_sLocalEpl_MN *local = (io_sLocalEpl_MN *)ap->Local;
  io_sLocalEpl_CN *local1;
  pwr_sClass_Epl_MN *op = (pwr_sClass_Epl_MN *)ap->op;
  io_sRack *rp;
  io_sCard *cp;
  pwr_tUInt32 error_count = 0;
  int ret = IO__SUCCESS;
  
  if(!ap->Local)
	return ret;
	
  // Remeber the time when this functions was called the first time
  if( local->init == 0) {
    clock_gettime(CLOCK_REALTIME, &local->boot);
    local->init = 1;
  }

  // Time now (tps = time when bad state occurred)
  clock_gettime(CLOCK_REALTIME, &local->tpe);
  
   error_count = op->ErrorCount;
  // Add to error count if agent changed from good to bad state and setup is complete
  if( local->prevState == pwr_eEplNmtState_EplNmtMsOperational && op->NmtState != pwr_eEplNmtState_EplNmtMsOperational && ( (local->tpe).tv_sec - (local->boot).tv_sec) >= op->StartupTimeout)
    op->ErrorCount++;
  
  // Copy Powerlink process image to temp memory (only if stallaction=resetinputs else tmp_area=input_area)
  if( op->StallAction == pwr_eStallActionEnum_ResetInputs)
    memcpy( local->tmp_area , local->input_area, local->input_area_size);
	
  // If no bad state and were still in startup there can be no error (else remember when error occurred)
  if( op->NmtState == pwr_eEplNmtState_EplNmtMsOperational || ( (local->tpe).tv_sec - (local->boot).tv_sec) < op->StartupTimeout) {
      (local->tps).tv_sec = 0;
      local->timeoutStatus = 0;
  }
  else if( (local->tps).tv_sec == 0) {
      clock_gettime(CLOCK_REALTIME, &local->tps);
  }

  // Agent error soft limit reached, tell log (once)
  if ( op->ErrorCount >= op->ErrorSoftLimit && error_count < op->ErrorSoftLimit) {
    errh_Warning( "IO Agent ErrorSoftLimit reached, '%s'", ap->Name);
  }	
	
  // Agent error hard limit reached, tell log (once)	
  if ( op->ErrorCount >= op->ErrorHardLimit && error_count < op->ErrorHardLimit) {
		
    if( op->StallAction == pwr_eStallActionEnum_EmergencyBreak) {
      errh_Error( "IO Agent ErrorHardLimit reached '%s', IO stopped", ap->Name);
    }
    else
      errh_Error( "IO Agent ErrorHardLimit reached '%s'", ap->Name);
  }

  // Agent timeout has elapsed, tell log (once)	
  if( ( (local->tpe).tv_sec - (local->tps).tv_sec) >= op->Timeout && local->timeoutStatus == 0 && (local->tps).tv_sec != 0) {
	  
	local->timeoutStatus = 1;
	if( op->StallAction == pwr_eStallActionEnum_EmergencyBreak) {
      errh_Error( "IO Agent timeout time elapsed '%s', IO stopped", ap->Name);
    }
    else if( op->StallAction == pwr_eStallActionEnum_ResetInputs) {
      errh_Error( "IO Agent timeout time elapsed '%s', IO input area reset", ap->Name);
    }
    else
      errh_Error( "IO Agent timeout time elapsed '%s'", ap->Name);
	
  }
		
  // Agent error hard limit reached, take action (always)	
  if ( op->ErrorCount >= op->ErrorHardLimit) {
		
    if( op->StallAction == pwr_eStallActionEnum_EmergencyBreak) {
      ctx->Node->EmergBreakTrue = 1;
      errh_SetStatus(PWR__SRVFATAL);
      IoAgentClose(ctx, ap);
    }
    else if( op->StallAction == pwr_eStallActionEnum_ResetInputs) {
      memset( local->tmp_area, 0, local->input_area_size);
    }
    ret = IO__ERRDEVICE;
  }
  
  // Agent timeout time elapsed, take action (always)	
  if ( ( (local->tpe).tv_sec - (local->tps).tv_sec) >= op->Timeout && (local->tps).tv_sec != 0) {
		
    if( op->StallAction == pwr_eStallActionEnum_EmergencyBreak) {
      ctx->Node->EmergBreakTrue = 1;
      errh_SetStatus(PWR__SRVFATAL);
      IoAgentClose(ctx, ap);
    }
    ret = IO__ERRDEVICE;
  }
  
  // Remember agent state til next scan
  local->prevState = op->NmtState;
	
  // Loop through all slaves
  for ( rp = ap->racklist; rp; rp = rp->next) {
		
    ((pwr_sClass_Epl_CN *)rp->op)->Status = ((pwr_sClass_Epl_CN *)rp->op)->NmtState == pwr_eEplNmtState_EplNmtCsOperational ? IOM__EPL_OPER : IOM__EPL_NOOPER;
    local1 = (io_sLocalEpl_CN *)rp->Local;
    // Time now (tps = time when bad state occurred)
    clock_gettime(CLOCK_REALTIME, &local1->tpe);
		
    error_count = ((pwr_sClass_Epl_CN *)rp->op)->ErrorCount;
	// Add to error count if slave changed from good to bad state and setup is complete
	if( local1->prevState == pwr_eEplNmtState_EplNmtCsOperational && ((pwr_sClass_Epl_CN *)rp->op)->NmtState != pwr_eEplNmtState_EplNmtCsOperational && ( (local1->tpe).tv_sec - (local->boot).tv_sec) >= op->StartupTimeout)
		((pwr_sClass_Epl_CN *)rp->op)->ErrorCount++;
	  	
    // Save time when bad state occurs
    if( ( (pwr_sClass_Epl_CN *)rp->op)->NmtState == pwr_eEplNmtState_EplNmtCsOperational || ( (local1->tpe).tv_sec - (local->boot).tv_sec) < op->StartupTimeout) {
      (local1->tps).tv_sec = 0;
      local1->timeoutStatus = 0;	
    }
    else if( (local1->tps).tv_sec == 0)
      clock_gettime(CLOCK_REALTIME, &local1->tps);
						
    // Slave error soft limit reached, tell log (once)
    if ( ((pwr_sClass_Epl_CN *)rp->op)->ErrorCount >= ((pwr_sClass_Epl_CN *)rp->op)->ErrorSoftLimit && error_count < ((pwr_sClass_Epl_CN *)rp->op)->ErrorSoftLimit) {
      errh_Warning( "IO Rack ErrorSoftLimit reached, '%s'", rp->Name);
    }
			
    // Slave error hard limit reached, tell log (once)
    if ( ((pwr_sClass_Epl_CN *)rp->op)->ErrorCount >= ((pwr_sClass_Epl_CN *)rp->op)->ErrorHardLimit && error_count < ((pwr_sClass_Epl_CN *)rp->op)->ErrorHardLimit) {
		
      if( ((pwr_sClass_Epl_CN *)rp->op)->StallAction == pwr_eStallActionEnum_EmergencyBreak) {
				errh_Error( "IO Rack ErrorHardLimit reached '%s', IO stopped", rp->Name);
      }
      else
				errh_Error( "IO Rack ErrorHardLimit reached '%s'", rp->Name);
    }
    
    // Slave timeout has elapsed, tell log (once)	
    if( ( (local1->tpe).tv_sec - (local1->tps).tv_sec) >= ((pwr_sClass_Epl_CN *)rp->op)->Timeout && local1->timeoutStatus == 0 && (local1->tps).tv_sec != 0) {
	  local1->timeoutStatus = 1;	
	  if( ((pwr_sClass_Epl_CN *)rp->op)->StallAction == pwr_eStallActionEnum_EmergencyBreak) {
	    errh_Error( "Rack timeout time elapsed '%s', IO stopped", rp->Name);
      }
      else if( ((pwr_sClass_Epl_CN *)rp->op)->StallAction == pwr_eStallActionEnum_ResetInputs) {
	    errh_Error( "Rack timeout time elapsed '%s', IO input area reset", rp->Name);
      }
      else
	    errh_Error( "Rack timeout time elapsed '%s'", rp->Name);
    }
		
    // Slave error hard limit reached, take action (always)
    if ( ((pwr_sClass_Epl_CN *)rp->op)->ErrorCount >= ((pwr_sClass_Epl_CN *)rp->op)->ErrorHardLimit) {
      if( ((pwr_sClass_Epl_CN *)rp->op)->StallAction == pwr_eStallActionEnum_EmergencyBreak) {
	    ctx->Node->EmergBreakTrue = 1;
	    errh_SetStatus(PWR__SRVFATAL);
	    IoAgentClose(ctx, ap);
      }
      else if( ((pwr_sClass_Epl_CN *)rp->op)->StallAction == pwr_eStallActionEnum_ResetInputs) {
	    memset( local->tmp_area + ((pwr_sClass_Epl_CN *)rp->op)->InputAreaOffset, 0, ((pwr_sClass_Epl_CN *)rp->op)->InputAreaSize);
      }
      ret = IO__ERRDEVICE;
    }
    
    // Slave timeout elapsed, take action (always)
    if( ( (local1->tpe).tv_sec - (local1->tps).tv_sec) >= ((pwr_sClass_Epl_CN *)rp->op)->Timeout && (local1->tps).tv_sec != 0) {
			if( ((pwr_sClass_Epl_CN *)rp->op)->StallAction == pwr_eStallActionEnum_EmergencyBreak) {
				ctx->Node->EmergBreakTrue = 1;
				errh_SetStatus(PWR__SRVFATAL);
				IoAgentClose(ctx, ap);
      }
      else if( ((pwr_sClass_Epl_CN *)rp->op)->StallAction == pwr_eStallActionEnum_ResetInputs) {
				memset( local->tmp_area + ((pwr_sClass_Epl_CN *)rp->op)->InputAreaOffset, 0, ((pwr_sClass_Epl_CN *)rp->op)->InputAreaSize);
      }
      ret = IO__ERRDEVICE;
    }
	
	// Remeber slave state til next scan	
	local1->prevState = ((pwr_sClass_Epl_CN *)rp->op)->NmtState;
		
    // Update Proview chan-objects with data from Powerlink process image
    for ( cp = rp->cardlist; cp; cp = cp->next) {
      io_bus_card_read( ctx, rp, cp, local->tmp_area, 0, ((io_sLocalEpl_CN *)rp->Local)->byte_ordering, pwr_eFloatRepEnum_FloatIEEE);
    }					
  }

  return ret;
}
/*----------------------------------------------------------------------------*\
  Write method for the Powerlink master
  \*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentWrite( io_tCtx ctx, io_sAgent *ap) {
  io_sLocalEpl_MN *local = (io_sLocalEpl_MN *)ap->Local;
  //pwr_sClass_Epl_MN *op = (pwr_sClass_Epl_MN *)ap->op;
  io_sRack *rp;
  io_sCard *cp;
  
  if(!ap->Local)
	return IO__SUCCESS;
    
  for ( rp = ap->racklist; rp; rp = rp->next) {
    for ( cp = rp->cardlist; cp; cp = cp->next) {
      io_bus_card_write( ctx, cp, local->output_area, ((io_sLocalEpl_CN *)rp->Local)->byte_ordering, pwr_eFloatRepEnum_FloatIEEE);
    }
  }

  return IO__SUCCESS;	
}
/*----------------------------------------------------------------------------*\
  Initialization of a bus card.
  \*----------------------------------------------------------------------------*/

#else
static pwr_tStatus IoAgentInit( io_tCtx ctx, io_sAgent *ap) { return IO__RELEASEBUILD;}
static pwr_tStatus IoAgentClose( io_tCtx ctx, io_sAgent *ap) { return IO__RELEASEBUILD;}
static pwr_tStatus IoAgentRead( io_tCtx ctx, io_sAgent *ap) { return IO__RELEASEBUILD;}
static pwr_tStatus IoAgentWrite( io_tCtx ctx, io_sAgent *ap) { return IO__RELEASEBUILD;}
#endif



/*----------------------------------------------------------------------------*\
  Every method to be exported to the workbench should be registred here.
  \*----------------------------------------------------------------------------*/
pwr_dExport pwr_BindIoMethods(Epl_MN) = {
  pwr_BindIoMethod(IoAgentInit),
  pwr_BindIoMethod(IoAgentClose),
  pwr_BindIoMethod(IoAgentRead),
  pwr_BindIoMethod(IoAgentWrite),
  pwr_NullMethod
};

