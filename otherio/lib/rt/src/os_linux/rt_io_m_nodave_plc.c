/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2012 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

/* rt_io_m_nodave_plc.c -- io methods for a libnodave PLC
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <float.h>

#include "pwr.h"
#include "co_cdh.h"
#include "pwr_baseclasses.h"
#include "pwr_basecomponentclasses.h"
#include "pwr_otherioclasses.h"
#include "rt_gdh.h"
#include "rt_io_base.h"
#include "rt_io_bus.h"
#include "rt_io_msg.h"
#include "rt_io_rack_init.h"
#include "rt_io_rack_close.h"
#include "rt_io_rack_read.h"
#include "rt_io_rack_write.h"
#include "rt_errh.h"
#include "co_cdh.h"
#include "co_time.h"

#if defined PWRE_CONF_NODAVE

#if defined OS_LINUX
#define LINUX
#endif
#include "nodave.h"
#include "openSocket.h"
#include "setport.h"
#include "rt_io_m_nodave.h"


/*----------------------------------------------------------------------------*\
   Init method for the libnodave PLC  
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoRackInit (
  io_tCtx	ctx,
  io_sAgent	*ap,
  io_sRack	*rp
) 
{
  io_sRackLocal *local;
  pwr_sClass_Nodave_PLC *op = (pwr_sClass_Nodave_PLC *)rp->op;
  pwr_tObjName name;
  int sts;
  int speed;
  int protocol;
  int res;
  io_sCard *cardp;
  pwr_tCid cid;
  io_sCardLocal *local_card;
 
  sts = gdh_ObjidToName( rp->Objid, name, sizeof(name), cdh_mName_object);
  if ( EVEN(sts)) return sts;
  
  /* Allocate area for local data structure */
  rp->Local = calloc(1, sizeof(io_sRackLocal));
  local = rp->Local;

  if ( op->Connection == pwr_eNodave_ConnectionEnum_Serial) {
    /* Serial connection */
    char serial_parity;
    char serial_speed[40];

    switch ( op->SerialParity) {
    case pwr_eParityEnum_None:
      serial_parity = 'N';
      break;
    case pwr_eParityEnum_Odd:
      serial_parity = 'O';
      break;
    case pwr_eParityEnum_Even:
      serial_parity = 'E';
      break;
    }

    snprintf( serial_speed, sizeof(serial_speed), "%d", op->SerialSpeed);

    local->fds.rfd = setPort( op->SerialDevice, serial_speed, serial_parity);
    if ( local->fds.rfd <= 0) {
      errh_Error( "Nodave PLC, open device error, %s", rp->Name);
      strcpy( op->Status, "No such device");      
      return IO__ERRINIDEVICE;
    }
  }
  else {
    /* TCP connection */
    local->fds.rfd = openSocket( op->Port, op->IP_Address);
    local->fds.wfd = local->fds.rfd;
    if ( local->fds.rfd <= 0) {
      errh_Error( "Nodave PLC, open socket error, %s", rp->Name);
      return IO__ERRINIDEVICE;
    }
  }

  switch ( op->Protocol) {
  case pwr_eNodave_ProtocolEnum_MPI:
    protocol = daveProtoMPI;
    break;
  case pwr_eNodave_ProtocolEnum_MPI2:
    protocol = daveProtoMPI2;
    break;
  case pwr_eNodave_ProtocolEnum_MPI3:
    protocol = daveProtoMPI3;
    break;
  case pwr_eNodave_ProtocolEnum_MPI4:
    protocol = daveProtoMPI4;
    break;
  case pwr_eNodave_ProtocolEnum_PPI:
    protocol = daveProtoPPI;
    break;
  case pwr_eNodave_ProtocolEnum_AS511:
    protocol = daveProtoAS511;
    break;
  case pwr_eNodave_ProtocolEnum_S7online:
    protocol = daveProtoS7online;
    break;
  case pwr_eNodave_ProtocolEnum_ISOTCP:
    protocol = daveProtoISOTCP;
    break;
  case pwr_eNodave_ProtocolEnum_ISOTCP243:
    protocol = daveProtoISOTCP243;
    break;
  case pwr_eNodave_ProtocolEnum_ISOTCPR:
    protocol = daveProtoISOTCPR;
    break;
  case pwr_eNodave_ProtocolEnum_MPI_IBH:
    protocol = daveProtoMPI_IBH;
    break;
  case pwr_eNodave_ProtocolEnum_PPI_IBH:
    protocol = daveProtoPPI_IBH;
    break;
  case pwr_eNodave_ProtocolEnum_UserTransport:
    protocol = daveProtoUserTransport;
    break;
  }

  switch ( op->Speed) {
  case pwr_eNodave_SpeedEnum_9k:
    speed = daveSpeed9k;
    break;
  case pwr_eNodave_SpeedEnum_19k:
    speed = daveSpeed19k;
    break;
  case pwr_eNodave_SpeedEnum_187k:
    speed = daveSpeed187k;
    break;
  case pwr_eNodave_SpeedEnum_500k:
    speed = daveSpeed500k;
    break;
  case pwr_eNodave_SpeedEnum_1500k:
    speed = daveSpeed1500k;
    break;
  case pwr_eNodave_SpeedEnum_45k:
    speed = daveSpeed45k;
    break;
  case pwr_eNodave_SpeedEnum_93k:
    speed = daveSpeed93k;
    break;
  }

  local->di = daveNewInterface( local->fds, name, op->MPI_Local, protocol, speed);

  res = daveInitAdapter( local->di);
  if ( res != 0) {
    errh_Error( "Nodave PLC, new interface error, %s (%d), %s", daveStrerror(res), res, rp->Name);
    strncpy( op->Status, daveStrerror(res), sizeof(op->Status));
    local->status = IO__ERRINIDEVICE;
    return IO__ERRINIDEVICE;
  }

  local->dc = daveNewConnection( local->di, op->MPI_Address, op->Rack, op->Slot);

  res = daveConnectPLC( local->dc);
  if ( res != 0) {
    errh_Error( "Nodave PLC, new connection error, %s (%d), %s", daveStrerror(res), res, rp->Name);
    strncpy( op->Status, daveStrerror(res), sizeof(op->Status));
    local->status = IO__ERRINIDEVICE;
    return IO__ERRINIDEVICE;
  }

  if ( op->Timeout > FLT_EPSILON)
    daveSetTimeout( local->di, op->Timeout * 1000000);

  /* Do configuration check and initialize modules. */

  unsigned int prev_input_area_offset = 0;
  unsigned int prev_output_area_offset = 0;
  unsigned int input_area_offset = 0;
  unsigned int output_area_offset = 0;
  unsigned int input_area_chansize = 0;
  unsigned int output_area_chansize = 0;
 

  /* Calculate total input and output area size */
  cardp = rp->cardlist;
  while(cardp) {

    cid = cardp->Class;
    /* Find the super class */
    while ( ODD( gdh_GetSuperClass( cid, &cid, cardp->Objid))) ;

    switch (cid) {
    case pwr_cClass_Nodave_Transaction: {

      io_bus_card_init( ctx, cardp, &input_area_offset, &input_area_chansize,
			&output_area_offset, &output_area_chansize, 
			op->ByteOrdering);
      break;
    }      
    }

    cardp = cardp->next;
  }

  local->input_size = input_area_offset + input_area_chansize;
  local->output_size = output_area_offset + output_area_chansize;

  local->input_area = calloc( 1, local->input_size);
  local->output_area = calloc( 1, local->output_size);

  /* Initialize transactions */
  prev_input_area_offset = 0;
  prev_output_area_offset = 0;
  input_area_offset = 0;
  output_area_offset = 0;
  input_area_chansize = 0;
  output_area_chansize = 0; 

  cardp = rp->cardlist;
  while(cardp) {
    local_card = calloc(1, sizeof(*local_card));

    cid = cardp->Class;
    /* Find the super class */
    while ( ODD( gdh_GetSuperClass( cid, &cid, cardp->Objid))) ;

    switch (cid) {
    case pwr_cClass_Nodave_Transaction: {
      pwr_sClass_Nodave_Transaction *tp;

      cardp->Local = local_card;

      local_card->input_area = local->input_area + input_area_offset + 
	input_area_chansize;
      local_card->output_area = local->output_area + output_area_offset + 
	output_area_chansize;

    
      tp = (pwr_sClass_Nodave_Transaction *) cardp->op;
      strcpy( tp->Status, "Starting...");

      io_bus_card_init( ctx, cardp, &input_area_offset, &input_area_chansize,
			&output_area_offset, &output_area_chansize, 
			op->ByteOrdering);

      local_card->input_size = input_area_offset + input_area_chansize - 
	prev_input_area_offset;
      local_card->output_size = output_area_offset + output_area_chansize - 
	prev_output_area_offset;
      
      break;
    }
      
    } /* End - switch ... */


    prev_input_area_offset = input_area_offset + input_area_chansize;
    prev_output_area_offset = output_area_offset + output_area_chansize;

    cardp = cardp->next;
  }

  local->input_size = input_area_offset + input_area_chansize;
  local->output_size = output_area_offset + output_area_chansize;


  local->status = IO__SUCCESS;
  strcpy( op->Status, "Running");
  return IO__SUCCESS;
}



/*----------------------------------------------------------------------------*\
   Read method for the libnodave PLC  
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoRackRead (
  io_tCtx	ctx,
  io_sAgent	*ap,
  io_sRack	*rp
)
{
  io_sRackLocal *local = (io_sRackLocal *) rp->Local;
  pwr_sClass_Nodave_PLC *op = (pwr_sClass_Nodave_PLC *)rp->op;

  if ( op->Debug) {
    int size = sizeof(op->Inputs);
    if ( local->input_size < size)
      size = local->input_size;
    
    memcpy( op->Inputs, local->input_area, size);
  }
  return IO__SUCCESS;
}


/*----------------------------------------------------------------------------*\
   Write method for nodave PLC  
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoRackWrite (
  io_tCtx	ctx,
  io_sAgent	*ap,
  io_sRack	*rp
) 
{
  io_sRackLocal *local = (io_sRackLocal *) rp->Local;
  pwr_sClass_Nodave_PLC *op = (pwr_sClass_Nodave_PLC *)rp->op;

  if ( op->Debug) {
    int size = sizeof(op->Outputs);
    if ( local->output_size < size)
      size = local->output_size;
    
    memcpy( op->Outputs, local->output_area, size);
  }
  return IO__SUCCESS;
}

/*----------------------------------------------------------------------------*\
  
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoRackClose (
  io_tCtx	ctx,
  io_sAgent	*ap,
  io_sRack	*rp
) 
{
  io_sRackLocal *local = (io_sRackLocal *) rp->Local;
  pwr_sClass_Nodave_PLC *op = (pwr_sClass_Nodave_PLC *)rp->op;

  strcpy( op->Status, "Closed down");

  if ( local->dc)
    daveDisconnectPLC( local->dc);
  if ( local->di)
    daveDisconnectAdapter( local->di);
  if ( local->fds.rfd)
    closeSocket( local->fds.rfd);

  if ( local->input_area)
    free( local->input_area);
  if ( local->output_area)
    free( local->output_area);
  free( local);

  return IO__SUCCESS;
}

#else
static pwr_tStatus IoRackInit( io_tCtx ctx, io_sAgent *ap, io_sRack *rp) { return IO__RELEASEBUILD;}
static pwr_tStatus IoRackClose( io_tCtx ctx, io_sAgent *ap, io_sRack *rp) { return IO__RELEASEBUILD;}
static pwr_tStatus IoRackRead( io_tCtx ctx, io_sAgent *ap, io_sRack *rp) { return IO__RELEASEBUILD;}
static pwr_tStatus IoRackWrite( io_tCtx ctx, io_sAgent *ap, io_sRack *rp) { return IO__RELEASEBUILD;}
#endif

/*----------------------------------------------------------------------------*\
  Every method to be exported to the workbench should be registred here.
\*----------------------------------------------------------------------------*/

pwr_dExport pwr_BindIoMethods(Nodave_PLC) = {
  pwr_BindIoMethod(IoRackInit),
  pwr_BindIoMethod(IoRackRead),
  pwr_BindIoMethod(IoRackWrite),
  pwr_BindIoMethod(IoRackClose),
  pwr_NullMethod
};
