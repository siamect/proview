/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2014 SSAB AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

/* rt_io_m_pb_dp_slave.c -- io methods for a profibus DP slave */


#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/socket.h>

#include "pwr.h"
#include "co_cdh.h"
#include "pwr_baseclasses.h"
#include "pwr_basecomponentclasses.h"
#include "pwr_otherioclasses.h"
#include "rt_gdh.h"
#include "rt_io_base.h"
#include "rt_io_bus.h"
#include "rt_io_msg.h"
#include "rt_errh.h"
#include "rt_net.h"
#include "co_cdh.h"
#include "co_time.h"
#include "rt_mb_msg.h"

#include "rt_io_mb_locals.h"

//char rcv_buffer[65536];

/* Check if channel should be fetched from diagnostic area, 
   i.e. channel name starts with "Diag_" */

static int connect_slave( io_sRackLocal *local, io_sRack *rp)
{
  pwr_tStatus sts;
  pwr_sClass_Modbus_TCP_Slave *op;
  int buffsize = 10000;
  int flags;
  fd_set fdr;				/* For select call */
  fd_set fdw;				/* For select call */
  struct timeval tv;
  unsigned short port;

  time_GetTimeMonotonic( &local->last_try_connect_time);

  op = (pwr_sClass_Modbus_TCP_Slave *) rp->op;

  /* Create socket, store in local struct */
  port = op->Port == 0 ? 502 : op->Port;
  
  local->s = socket(AF_INET, SOCK_STREAM, 0);
  if (local->s < 0) { 
    errh_Error( "Error creating socket for IO modbus tcp slave %s, %d", rp->Name, local->s);
    return local->s;
  }

  sts = setsockopt(local->s, SOL_SOCKET, SO_RCVBUF, &buffsize, sizeof(buffsize)); 

  if (sts < 0) { 
    printf( "Error setting receive buffer size \n");
  }
  
  /* Initialize remote address structure */

  local->rem_addr.sin_family = AF_INET;
  local->rem_addr.sin_port = htons(port);
  // local->rem_addr.sin_addr.s_addr = inet_addr((char *) &(op->Address));
  sts = net_StringToAddr( op->Address, &local->rem_addr.sin_addr);
  if ( EVEN(sts)) {
    errh_Error( "Address error for IO modbus tcp slave %s %s", rp->Name, op->Address);
    return sts;
  }
  local->rem_addr.sin_addr.s_addr = ntohl(local->rem_addr.sin_addr.s_addr);
  
  /* Connect to remote address */

  fcntl(local->s, F_SETFL, (flags = fcntl(local->s, F_GETFL)) | O_NONBLOCK);
  
  sts = connect(local->s, (struct sockaddr *) &local->rem_addr, sizeof(local->rem_addr)); 

  if (sts < 0) { 
    FD_ZERO(&fdr);
    FD_ZERO(&fdw);
    FD_SET(local->s, &fdr);
    FD_SET(local->s, &fdw);
    
    if (op->ReconnectLimit > 200) {
      tv.tv_sec = 0;
      tv.tv_usec = 1000 * op->ReconnectLimit;
    } else {
      tv.tv_sec = 0;
      tv.tv_usec = 200000;
    }

    sts = select((int)local->s+1, &fdr, &fdw, NULL, &tv);
    
    if (sts <= 0) {
      close(local->s);
      errh_Error( "Error connecting remote socket for IO modbus slave %s, %d", rp->Name, sts);
      return -1;
    }
  }

  fcntl(local->s, F_SETFL, (flags = fcntl(local->s, F_GETFL)) ^ O_NONBLOCK);
  
  return sts;
}

pwr_tStatus mb_recv_data(io_sRackLocal *local, 
                             io_sRack      *rp,
			     pwr_sClass_Modbus_TCP_Slave *sp)
{
  io_sCardLocalMsg *local_card;
  io_sCard *cardp;
  pwr_sClass_Modbus_ModuleMsg *mp;
  pwr_tStatus sts;
  fd_set fdr;				/* For select call */
  struct timeval tv;
  pwr_tBoolean found;
  int data_size;
  rec_buf *rb;
  char rcv_buffer[260];
  pwr_tCid cid;
  unsigned char fc;
  short int trans_id;
  short int size_of_msg;
  int modules;
  int i;
  
	short int remaining_data; // Data we have to get from the socket.
	short int received_data;  // Data that has been received.

	sts = 1;
	rb = (rec_buf *) rcv_buffer;

	while (sts > 0) { /* Receive answer */
		
		size_of_msg = 0;
		remaining_data = sizeof(mbap_header);
		received_data = 0;
		
		/*
		First read at least the MBAP header, and no more.
		Then, read the remaining bytes indicaterd in the header, but no more.
		We control the amount of data because could be more than one message in the socket buffer or
		only the first bytes of a packet.
		*/
		
		while ( (remaining_data > 0) && (sts > 0) ) { // if there is data to read and everything is ok, receive.
			
			FD_ZERO(&fdr);
			FD_SET(local->s, &fdr);
			
			if (local->expected_msgs > 0) {
			  tv.tv_sec = 0;
			  tv.tv_usec = sp->ResponseTime * 1000;
			} else {
			  tv.tv_sec = 0;
			  tv.tv_usec = 0;
			}
		
			sts = select((int)local->s+1, &fdr, NULL, NULL, &tv);
			
			if (sts<=0) { // Timeout or error.
				if ((sts == 0) && (local->expected_msgs > 0)) { // Timeout but there are messages pending
					local->msgs_lost++;
					if (local->msgs_lost > MAX_MSGS_LOST) {
						sp->Status = MB__CONNDOWN;
						close(local->s);
						errh_Error( "Data expected but timeout. Connection down to modbus slave, %s", rp->Name);
					}
					return IO__SUCCESS;
				}
				
				if (sts < 0) { // Error in the socket
					sp->Status = MB__CONNLOST;
					close(local->s);
					errh_Error( "Socket Error. Connection lost to modbus slave, %s", rp->Name);
					return IO__SUCCESS;
				}
				
			} else { // There are something to read (no timeout and no error). Could be a closed socket too, so we have to check later anyway.
				data_size = recv(local->s, &rcv_buffer[received_data], remaining_data, 0);

				if (data_size < 0) {
					sp->Status = MB__CONNLOST;
					close(local->s);
					errh_Error( "Error reading data. Connection lost to modbus slave, %s", rp->Name);
					return IO__SUCCESS;
				}
				
				if (data_size == 0) {
					sp->Status = MB__CONNDOWN;
					close(local->s);
					errh_Error( "Error reading data. Connection down to modbus slave, %s", rp->Name);
					return IO__SUCCESS;
				}

				remaining_data = remaining_data - data_size;
				received_data = received_data + data_size;
				
				if ( (received_data >= sizeof(mbap_header)) && (size_of_msg == 0 )) {
					// Compute the complete header
					trans_id = ntohs(rb->head.trans_id);
					size_of_msg = ntohs(rb->head.length) + 6;
					
					// Check header data
					if ((ntohs(rb->head.proto_id)!=0) || (size_of_msg>260)) { // Invalid modbus packet
						sp->Status = MB__CONNDOWN;
						close(local->s);
						errh_Error( "Invalid Modbus packet. Connection down to modbus slave, %s", rp->Name);
						return IO__SUCCESS;
					}
					
					// Update remaining data
					remaining_data = size_of_msg - received_data;
				}
			}
		} // while

		if (sts > 0) { // processing packet...
		
			local->msgs_lost = 0;
			sp->RX_packets++;
			local->expected_msgs--;
			cardp = rp->cardlist;
			
			while(cardp) {
				/* From v4.1.3 we can have subclasses, find the super class */
				found = FALSE;
				cid = cardp->Class;
				while ( ODD( gdh_GetSuperClass( cid, &cid, cardp->Objid))) ;
				
					switch (cid) {
						case pwr_cClass_Modbus_Module:
							mp = (pwr_sClass_Modbus_ModuleMsg *) &((pwr_sClass_Modbus_Module *) cardp->op)->FunctionCode;
							modules = 1;
							local_card = ((io_sCardLocal *)cardp->Local)->msg;
							break;
						case pwr_cClass_Modbus_ModuleReadWrite:
							mp = &((pwr_sClass_Modbus_ModuleReadWrite *) cardp->op)->Read;
							modules = 2;
							local_card = ((io_sCardLocal *)cardp->Local)->msg;
							break;
						default:
							modules = 0;
					}

				if ( !modules) {
					cardp = cardp->next;
					continue;
				}

				for ( i = 0; i < modules; i++) {

					if (local_card->trans_id == trans_id) {

						fc = (unsigned char) *rb->buf;
						if (fc > 0x80) {
							res_fault *res_f;
							res_f = (res_fault *) rb->buf;
							mp->Status = res_f->ec;
							mp++;
							local_card++;
							continue;
						}

						if (fc != mp->FunctionCode) {
							mp->Status = pwr_eModbusModule_StatusEnum_StatusUnknown;
							mp++;
							local_card++;
							continue;
						}

						mp->Status = pwr_eModbusModule_StatusEnum_OK;

						switch (fc) {
							case pwr_eModbus_FCEnum_ReadCoils: {
								res_read *res_r;
								res_r = (res_read *) rb->buf;
								memcpy(local_card->input_area, res_r->buf, MIN(res_r->bc, local_card->input_size));
								break;
							}

							case pwr_eModbus_FCEnum_ReadDiscreteInputs: {
								res_read *res_r;
								res_r = (res_read *) rb->buf;
								memcpy(local_card->input_area, res_r->buf, MIN(res_r->bc, local_card->input_size));
								break;
							}

							case pwr_eModbus_FCEnum_ReadHoldingRegisters: {
								res_read *res_r;
								res_r = (res_read *) rb->buf;
								memcpy(local_card->input_area, res_r->buf, MIN(res_r->bc, local_card->input_size));
								break;
							}

							case pwr_eModbus_FCEnum_ReadInputRegisters: { 
								res_read *res_r;
								res_r = (res_read *) rb->buf;
								memcpy(local_card->input_area, res_r->buf, MIN(res_r->bc, local_card->input_size));
								break;
							}

							case pwr_eModbus_FCEnum_WriteMultipleCoils:
							case pwr_eModbus_FCEnum_WriteMultipleRegisters:
							case pwr_eModbus_FCEnum_WriteSingleRegister:
							// Nothing good to do here
							break;
						}
						found = TRUE;
					}
					mp++;
					local_card++;
				} // for ( i = 0; i < modules; i++)
				if (found)
				break;
				cardp = cardp->next;
			} /* End - while(cardp) ... */
		} // if (sts > 0) processing packet...
	} // while (sts > 0)  Receive answer

  return IO__SUCCESS;
}

pwr_tStatus mb_send_data(io_sRackLocal *local, 
                             io_sRack      *rp,
			     pwr_sClass_Modbus_TCP_Slave *sp, 
			     mb_tSendMask   mask)
{
  io_sCardLocalMsg *local_card;
  io_sCard *cardp;
  pwr_sClass_Modbus_ModuleMsg *mp;
  pwr_tStatus sts;
  pwr_tCid cid;
  int modules;
  int i;

  /* Send messages to slave */

  cardp = rp->cardlist;

  while(cardp) {

    /* From v4.1.3 we can have subclasses, find the super class */
    cid = cardp->Class;
    while ( ODD( gdh_GetSuperClass( cid, &cid, cardp->Objid))) ;

    switch (cid) {
    case pwr_cClass_Modbus_Module:
      mp = (pwr_sClass_Modbus_ModuleMsg *) &((pwr_sClass_Modbus_Module *) cardp->op)->FunctionCode;
      modules = 1;
      break;
    case pwr_cClass_Modbus_ModuleReadWrite:
      mp = &((pwr_sClass_Modbus_ModuleReadWrite *) cardp->op)->Read;
      modules = 2;
      break;
    default:
      modules = 0;
    }

    if ( !modules) {
      cardp = cardp->next;
      continue;
    }

    for ( i = 0; i < modules; i++) {
      sts = 1;
      
      if (!mp->Continous && !mp->SendOp) {
	break;
      }
      
      local_card = &((io_sCardLocal *)cardp->Local)->msg[i];
      if ( mp->ScanInterval > 1 && local_card->interval_cnt != 0) {
	cardp = cardp->next;
	continue;
      }
      
      if (mask & mb_mSendMask_ReadReq) {
	switch (mp->FunctionCode) {
	case pwr_eModbus_FCEnum_ReadCoils:
	case pwr_eModbus_FCEnum_ReadDiscreteInputs: {
	  read_req rr;
	  
	  mp->SendOp = FALSE;
	  
	  local->trans_id++;
	  local_card->trans_id = local->trans_id;

	  rr.head.trans_id = htons(local->trans_id);
	  rr.head.proto_id = 0;
	  rr.head.length = htons(sizeof(read_req) - 6);
	  rr.head.unit_id = mp->UnitId;
	  rr.fc = mp->FunctionCode;
	  rr.addr = htons(mp->Address);
	  rr.quant = htons(local_card->no_di);
	  //              rr.quant = ntohs(local_card->input_size * 8);

	  sts = send(local->s, &rr, sizeof(read_req), MSG_DONTWAIT);
	  if (sts < 0) {
	    sp->Status = MB__CONNDOWN;
	    close(local->s);
	    errh_Error( "Connection down to modbus slave, %s", rp->Name);
	    return IO__SUCCESS;
	  }
	      
	  local->expected_msgs++;
	  sp->TX_packets++;
	  break;
	}

	case pwr_eModbus_FCEnum_ReadHoldingRegisters:
	case pwr_eModbus_FCEnum_ReadInputRegisters: {
	  read_req rr;

	  mp->SendOp = FALSE;

	  local->trans_id++;
	  local_card->trans_id = local->trans_id;

	  rr.head.trans_id = htons(local->trans_id);
	  rr.head.proto_id = 0;
	  rr.head.length = htons(sizeof(read_req) - 6);
	  rr.head.unit_id = mp->UnitId;
	  rr.fc = mp->FunctionCode;
	  rr.addr = htons(mp->Address);
	  rr.quant = ntohs((local_card->input_size + 1) / 2);

	  sts = send(local->s, &rr, sizeof(read_req), MSG_DONTWAIT);
	  if (sts < 0) {
	    sp->Status = MB__CONNDOWN;
	    close(local->s);
	    errh_Error( "Connection down to modbus slave, %s", rp->Name);
	    return IO__SUCCESS;
	  }
	  sp->TX_packets++;
	  local->expected_msgs++;
	  break;
	}
	} /* End - switch FC ... */
      }

      if (mask & mb_mSendMask_WriteReq) {
	switch (mp->FunctionCode) {

	case pwr_eModbus_FCEnum_WriteSingleCoil: {
	  write_single_req wsr;

	  mp->SendOp = FALSE;

	  local->trans_id++;
	  local_card->trans_id = local->trans_id;
	  
	  wsr.head.trans_id = htons(local->trans_id);
	  wsr.head.proto_id = 0;
	  wsr.head.length = htons(sizeof(wsr) - 6); 
	  wsr.head.unit_id = mp->UnitId;
	  wsr.fc = mp->FunctionCode;
	  wsr.addr = htons(mp->Address);
	  if (local_card->output_size == 4) {
	    if (*(int *)local_card->output_area)
	      wsr.value = ntohs(0xFF00);
	    else wsr.value = 0;
	  } else if (local_card->output_size == 2) {
	    if (*(short int *)local_card->output_area)
	      wsr.value = ntohs(0xFF00);
	    else wsr.value = 0;
	  } else if (local_card->output_size == 1) {
	    if (*(char *)local_card->output_area)
	      wsr.value = ntohs(0xFF00);
	    else wsr.value = 0;
	  } else wsr.value = 0;

	  sts = send(local->s, &wsr, ntohs(wsr.head.length) + 6, MSG_DONTWAIT);
	  if (sts < 0) {
	    sp->Status = MB__CONNDOWN;
	    close(local->s);
	    errh_Error( "Connection down to modbus slave, %s", rp->Name);
	    return IO__SUCCESS;
	  }
	  local->expected_msgs++;
	  sp->TX_packets++;
	  break;
	}

	case pwr_eModbus_FCEnum_WriteMultipleCoils: {
	  write_coils_req wcr;

	  mp->SendOp = FALSE;

	  local->trans_id++;
	  local_card->trans_id = local->trans_id;

	  wcr.head.trans_id = htons(local->trans_id);
	  wcr.head.proto_id = 0;
	  wcr.head.length = htons(sizeof(wcr) - 6 - 
				  sizeof(wcr.reg) + local_card->output_size);
	  wcr.head.unit_id = mp->UnitId;
	  wcr.fc = mp->FunctionCode;
	  wcr.addr = htons(mp->Address);
	  wcr.quant = htons(local_card->no_do);
	  //              wcr.quant = ntohs((local_card->output_size) * 8);
	  wcr.bc = local_card->output_size;
	  memcpy(wcr.reg, local_card->output_area, local_card->output_size);

	  sts = send(local->s, &wcr, ntohs(wcr.head.length) + 6, MSG_DONTWAIT);
	  if (sts < 0) {
	    sp->Status = MB__CONNDOWN;
	    close(local->s);
	    errh_Error( "Connection down to modbus slave, %s", rp->Name);
	    return IO__SUCCESS;
	  }
	  local->expected_msgs++;
	  sp->TX_packets++;
	  break;
	}

	case pwr_eModbus_FCEnum_WriteMultipleRegisters: {
	  write_reg_req wrr;

	  mp->SendOp = FALSE;

	  local->trans_id++;
	  local_card->trans_id = local->trans_id;

	  wrr.head.trans_id = htons(local->trans_id);
	  wrr.head.proto_id = 0;
	  wrr.head.length = htons(sizeof(wrr) - 6 - 
				  sizeof(wrr.reg) + local_card->output_size);
	  wrr.head.unit_id = mp->UnitId;
	  wrr.fc = mp->FunctionCode;
	  wrr.addr = htons(mp->Address);
	  wrr.quant = ntohs((local_card->output_size) / 2);
	  wrr.bc = local_card->output_size;
	  memcpy(wrr.reg, local_card->output_area, local_card->output_size);

	  sts = send(local->s, &wrr, ntohs(wrr.head.length) + 6, MSG_DONTWAIT);
	  if (sts < 0) {
	    sp->Status = MB__CONNDOWN;
	    close(local->s);
	    errh_Error( "Connection down to modbus slave, %s", rp->Name);
	    return IO__SUCCESS;
	  }
	  sp->TX_packets++;
	  local->expected_msgs++;
	  break;
	}
	case pwr_eModbus_FCEnum_WriteSingleRegister: {
	  write_single_req wrr;

	  mp->SendOp = FALSE;

	  local->trans_id++;
	  local_card->trans_id = local->trans_id;

	  wrr.head.trans_id = htons(local->trans_id);
	  wrr.head.proto_id = 0;
	  wrr.head.length = htons(sizeof(wrr) - 6);
	  wrr.head.unit_id = mp->UnitId;
	  wrr.fc = mp->FunctionCode;
	  wrr.addr = htons(mp->Address);
	  memcpy(&wrr.value, local_card->output_area, sizeof(wrr.value));

	  sts = send(local->s, &wrr, ntohs(wrr.head.length) + 6, MSG_DONTWAIT);
	  if (sts < 0) {
	    sp->Status = MB__CONNDOWN;
	    close(local->s);
	    errh_Error( "Connection down to modbus slave, %s", rp->Name);
	    return IO__SUCCESS;
	  }
	  sp->TX_packets++;
	  local->expected_msgs++;
	  break;
	}
	} /* End - switch FC ... */
      }
      if ( sts < 0)
	break;
      mp++;
    }

    if (sts < 0) {
      sp->Status = MB__CONNDOWN;
      close(local->s);
      errh_Error( "Connection down to modbus slave, %s", rp->Name);
      return IO__SUCCESS;
    }

    if (sp->SingleOp)    
      sts = mb_recv_data(local, rp, sp);

    if (sp->Status != MB__NORMAL) return IO__SUCCESS;

    cardp = cardp->next;

  } /* End - while cardp ... */

  return IO__SUCCESS;
}
/*----------------------------------------------------------------------------*\
   Init method for the Modbus_TCP slave 
\*----------------------------------------------------------------------------*/

static pwr_tStatus IoRackInit (
  io_tCtx	ctx,
  io_sAgent	*ap,
  io_sRack	*rp
) 
{
  io_sCardLocal *local_card;
  io_sCard *cardp;
  io_sRackLocal *local;
  int no_di;
  int no_do;
  pwr_sClass_Modbus_TCP_Slave *op;
  char name[196];
  pwr_tStatus sts;
  pwr_tCid cid;
  
  io_sChannel *chanp;
  int i;

  sts = gdh_ObjidToName(rp->Objid, (char *) &name, sizeof(name), cdh_mNName);
  errh_Info( "Init of Modbus TCP Slave and Modules %s", name);

  op = (pwr_sClass_Modbus_TCP_Slave *) rp->op;
  
  rp->Local = calloc(1, sizeof(io_sRackLocal));
  local = rp->Local;

  /* Create socket, store in local struct */
  
  sts = connect_slave(local, rp);
  
  if (sts < 0) {
    op->Status = MB__CONNDOWN;
  } else {
    op->Status = MB__NORMAL;
  }
  
  /* Do configuration check and initialize modules. */

  cardp = rp->cardlist;

  unsigned int prev_input_area_offset = 0;
  unsigned int prev_output_area_offset = 0;
  unsigned int input_area_offset = 0;
  unsigned int output_area_offset = 0;
  unsigned int input_area_chansize = 0;
  unsigned int output_area_chansize = 0;

  while(cardp) {
    local_card = calloc(1, sizeof(*local_card));

    cid = cardp->Class;
    /* Find the super class */
    while ( ODD( gdh_GetSuperClass( cid, &cid, cardp->Objid))) ;

    switch (cid) {
    case pwr_cClass_Modbus_Module: {
      pwr_sClass_Modbus_Module *mp;

      cardp->Local = local_card;
      no_di = 0;
      no_do = 0;

      local_card->msg[0].input_area = (void *) &(op->Inputs) + input_area_offset + 
	input_area_chansize;
      local_card->msg[0].output_area = (void *) &(op->Outputs) + output_area_offset + 
	output_area_chansize;

    
      mp = (pwr_sClass_Modbus_Module *) cardp->op;
      mp->Status = pwr_eModbusModule_StatusEnum_StatusUnknown;

      io_bus_card_init( ctx, cardp, &input_area_offset, &input_area_chansize,
			&output_area_offset, &output_area_chansize, 
			pwr_eByteOrderingEnum_BigEndian);

      /* Count number of di and do */
      for (i = 0; i < cardp->ChanListSize; i++) {
	chanp = &cardp->chanlist[i];
	switch (chanp->ChanClass) {      
	case pwr_cClass_ChanDi:
	  no_di++;
	  break;
	case pwr_cClass_ChanDo:
	  no_do++;
	  break;
	case pwr_cClass_ChanD:
	  if ( ((pwr_sClass_ChanD *)chanp->cop)->Type == pwr_eDChanTypeEnum_Di)
	    no_di++;
	  else
	    no_do++;
	  break;
	}
      }	   
      local_card->msg[0].input_size = input_area_offset + input_area_chansize - 
	prev_input_area_offset;
      local_card->msg[0].output_size = output_area_offset + output_area_chansize - 
	prev_output_area_offset;
      local_card->msg[0].no_di = no_di;
      local_card->msg[0].no_do = no_do;
      
      break;
    }
    case pwr_cClass_Modbus_ModuleReadWrite: {
      pwr_sClass_Modbus_ModuleReadWrite *mp;

      cardp->Local = local_card;
      no_di = 0;
      no_do = 0;

      local_card->msg[0].input_area = (void *) &(op->Inputs) + input_area_offset + 
	input_area_chansize;
      local_card->msg[0].output_area = (void *) &(op->Outputs) + output_area_offset + 
	output_area_chansize;
      local_card->msg[1].input_area = (void *) &(op->Inputs) + input_area_offset + 
	input_area_chansize;
      local_card->msg[1].output_area = (void *) &(op->Outputs) + output_area_offset + 
	output_area_chansize;

    
      mp = (pwr_sClass_Modbus_ModuleReadWrite *) cardp->op;
      mp->Read.Status = pwr_eModbusModule_StatusEnum_StatusUnknown;
      mp->Write.Status = pwr_eModbusModule_StatusEnum_StatusUnknown;

      io_bus_card_init( ctx, cardp, &input_area_offset, &input_area_chansize,
			&output_area_offset, &output_area_chansize, 
			pwr_eByteOrderingEnum_BigEndian);

      /* Count number of di and do */
      for (i = 0; i < cardp->ChanListSize; i++) {
	chanp = &cardp->chanlist[i];
	switch (chanp->ChanClass) {      
	case pwr_cClass_ChanDi:
	  no_di++;
	  break;
	case pwr_cClass_ChanDo:
	  no_do++;
	  break;
	case pwr_cClass_ChanD:
	  if ( ((pwr_sClass_ChanD *)chanp->cop)->Type == pwr_eDChanTypeEnum_Di)
	    no_di++;
	  else
	    no_do++;
	}
      }	   
      local_card->msg[0].input_size = input_area_offset + input_area_chansize - 
	prev_input_area_offset;
      local_card->msg[0].output_size = 0;
      local_card->msg[0].no_di = no_di;
      local_card->msg[0].no_do = 0;
      local_card->msg[1].input_size = 0;
      local_card->msg[1].output_size = output_area_offset + output_area_chansize - 
	prev_output_area_offset;
      local_card->msg[1].no_di = 0;
      local_card->msg[1].no_do = no_do;
        
      break;
    }
      
    } /* End - switch ... */


    prev_input_area_offset = input_area_offset + input_area_chansize;
    prev_output_area_offset = output_area_offset + output_area_chansize;

    cardp = cardp->next;
  }

  local->input_size = input_area_offset + input_area_chansize;
  local->output_size = output_area_offset + output_area_chansize;

  return IO__SUCCESS;
}


/*----------------------------------------------------------------------------*\
   Read method for the Modbus_TCP slave 
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoRackRead (
  io_tCtx	ctx,
  io_sAgent	*ap,
  io_sRack	*rp
) 
{
  io_sRackLocal *local;
  pwr_sClass_Modbus_TCP_Slave *sp;
  pwr_tStatus sts;
  pwr_tTime now;
  pwr_tDeltaTime dt;
  
  local = rp->Local;
  
  sp = (pwr_sClass_Modbus_TCP_Slave *) rp->op;

  if (((sp->Status == MB__CONNDOWN) || (sp->Status == MB__CONNLOST)) && sp->DisableSlave != 1) {
    /* Reconnect */

    time_GetTimeMonotonic( &now);
    time_Adiff(&dt, &now, &local->last_try_connect_time);
    if (dt.tv_sec >= (1 << MIN(sp->ReconnectCount, 6))) {
      sts = connect_slave(local, rp);
      if (sts >= 0) {
	sp->ReconnectCount = 0;
        sp->Status = MB__NORMAL;
      } else {
        sp->ReconnectCount++;
        memset(&sp->Inputs, 0, local->input_size);
      }
    }
  }

  /* Receive data */
  if ((sp->Status == MB__NORMAL) && !sp->SingleOp) {
    sts = mb_recv_data(local, rp, sp);
  }  
  
  if (sp->DisableSlave != 1) {
  
    if (sp->Status == MB__NORMAL) {
      sp->ErrorCount = 0;
    }
    else {
      sp->ErrorCount++;
    }

    if (sp->ErrorCount > sp->ErrorLimit) {
      memset(&sp->Inputs, 0, local->input_size);
    }
  }
  else {
    sp->ErrorCount = 0;
    sp->Status = MB__DISABLED;
  }
  
  return IO__SUCCESS;
}


/*----------------------------------------------------------------------------*\
   Write method for the Modbus_TCP slave
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoRackWrite (
  io_tCtx	ctx,
  io_sAgent	*ap,
  io_sRack	*rp
) 
{
  io_sRackLocal *local;
  pwr_sClass_Modbus_TCP_Slave *sp;
  pwr_tStatus sts;

  local = rp->Local;
  
  sp = (pwr_sClass_Modbus_TCP_Slave *) rp->op;
  
  local->expected_msgs = 0;

  if (sp->Status == MB__NORMAL && sp->DisableSlave != 1) {
    sts = mb_send_data(local, rp, sp, mb_mSendMask_WriteReq);
  }

  if (sp->DisableSlave == 1) sp->Status = MB__DISABLED;

  return IO__SUCCESS;
}


/*----------------------------------------------------------------------------*\
  
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoRackClose (
  io_tCtx	ctx,
  io_sAgent	*ap,
  io_sRack	*rp
) 
{
  return IO__SUCCESS;
}


/*----------------------------------------------------------------------------*\
  Every method to be exported to the workbench should be registred here.
\*----------------------------------------------------------------------------*/

pwr_dExport pwr_BindIoMethods(Modbus_TCP_Slave) = {
  pwr_BindIoMethod(IoRackInit),
  pwr_BindIoMethod(IoRackRead),
  pwr_BindIoMethod(IoRackWrite),
  pwr_BindIoMethod(IoRackClose),
  pwr_NullMethod
};
