/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_io_m_nodave_plc.c -- io methods for a libnodave PLC
*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>

#include "co_cdh.h"
#include "pwr_basecomponentclasses.h"
#include "pwr_otherioclasses.h"
#include "rt_io_base.h"
#include "rt_io_bus.h"
#include "rt_io_msg.h"
#include "rt_io_rack_init.h"
#include "rt_io_rack_close.h"
#include "rt_io_rack_read.h"
#include "rt_io_rack_write.h"
#include "co_cdh.h"
#include "co_time.h"

#if defined PWRE_CONF_NODAVE

#if defined OS_LINUX
#define LINUX
#endif
#include "nodave.h"
#include "openSocket.h"
#include "setport.h"
#include "rt_io_m_nodave.h"

/*----------------------------------------------------------------------------*\
   Init method for the libnodave PLC
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoRackInit(io_tCtx ctx, io_sAgent* ap, io_sRack* rp)
{
  io_sRackLocal* local;
  pwr_sClass_Nodave_PLC* op = (pwr_sClass_Nodave_PLC*)rp->op;
  pwr_tObjName name;
  int sts;
  int speed;
  int protocol;
  int res;
  io_sCard* cardp;
  pwr_tCid cid;
  io_sCardLocal* local_card;

  sts = gdh_ObjidToName(rp->Objid, name, sizeof(name), cdh_mName_object);
  if (EVEN(sts))
    return sts;

  /* Allocate area for local data structure */
  rp->Local = calloc(1, sizeof(io_sRackLocal));
  local = rp->Local;

  if (op->Connection == pwr_eNodave_ConnectionEnum_Serial) {
    /* Serial connection */
    char serial_parity;
    char serial_speed[40];

    switch (op->SerialParity) {
    case pwr_eParityEnum_None:
      serial_parity = 'N';
      break;
    case pwr_eParityEnum_Odd:
      serial_parity = 'O';
      break;
    case pwr_eParityEnum_Even:
      serial_parity = 'E';
      break;
    }

    snprintf(serial_speed, sizeof(serial_speed), "%d", op->SerialSpeed);

    local->fds.rfd = setPort(op->SerialDevice, serial_speed, serial_parity);
    if (local->fds.rfd <= 0) {
      errh_Error("Nodave PLC, open device error, %s", rp->Name);
      strcpy(op->Status, "No such device");
      return IO__ERRINIDEVICE;
    }
  } else {
    /* TCP connection */
    local->fds.rfd = openSocket(op->Port, op->IP_Address);
    local->fds.wfd = local->fds.rfd;
    if (local->fds.rfd <= 0) {
      errh_Error("Nodave PLC, open socket error, %s", rp->Name);
      return IO__ERRINIDEVICE;
    }
  }

  switch (op->Protocol) {
  case pwr_eNodave_ProtocolEnum_MPI:
    protocol = daveProtoMPI;
    break;
  case pwr_eNodave_ProtocolEnum_MPI2:
    protocol = daveProtoMPI2;
    break;
  case pwr_eNodave_ProtocolEnum_MPI3:
    protocol = daveProtoMPI3;
    break;
  case pwr_eNodave_ProtocolEnum_MPI4:
    protocol = daveProtoMPI4;
    break;
  case pwr_eNodave_ProtocolEnum_PPI:
    protocol = daveProtoPPI;
    break;
  case pwr_eNodave_ProtocolEnum_AS511:
    protocol = daveProtoAS511;
    break;
  case pwr_eNodave_ProtocolEnum_S7online:
    protocol = daveProtoS7online;
    break;
  case pwr_eNodave_ProtocolEnum_ISOTCP:
    protocol = daveProtoISOTCP;
    break;
  case pwr_eNodave_ProtocolEnum_ISOTCP243:
    protocol = daveProtoISOTCP243;
    break;
  case pwr_eNodave_ProtocolEnum_ISOTCPR:
    protocol = daveProtoISOTCP;
    break;
  case pwr_eNodave_ProtocolEnum_MPI_IBH:
    protocol = daveProtoMPI_IBH;
    break;
  case pwr_eNodave_ProtocolEnum_PPI_IBH:
    protocol = daveProtoPPI_IBH;
    break;
  case pwr_eNodave_ProtocolEnum_UserTransport:
    protocol = daveProtoUserTransport;
    break;
  }

  switch (op->Speed) {
  case pwr_eNodave_SpeedEnum_9k:
    speed = daveSpeed9k;
    break;
  case pwr_eNodave_SpeedEnum_19k:
    speed = daveSpeed19k;
    break;
  case pwr_eNodave_SpeedEnum_187k:
    speed = daveSpeed187k;
    break;
  case pwr_eNodave_SpeedEnum_500k:
    speed = daveSpeed500k;
    break;
  case pwr_eNodave_SpeedEnum_1500k:
    speed = daveSpeed1500k;
    break;
  case pwr_eNodave_SpeedEnum_45k:
    speed = daveSpeed45k;
    break;
  case pwr_eNodave_SpeedEnum_93k:
    speed = daveSpeed93k;
    break;
  }

  local->di
      = daveNewInterface(local->fds, name, op->MPI_Local, protocol, speed);

  res = daveInitAdapter(local->di);
  if (res != 0) {
    errh_Error("Nodave PLC, new interface error, %s (%d), %s",
        daveStrerror(res), res, rp->Name);
    strncpy(op->Status, daveStrerror(res), sizeof(op->Status));
    local->status = IO__ERRINIDEVICE;
    return IO__ERRINIDEVICE;
  }

  local->dc = daveNewConnection(local->di, op->MPI_Address, op->Rack, op->Slot);

  res = daveConnectPLC(local->dc);
  if (res != 0) {
    errh_Error("Nodave PLC, new connection error, %s (%d), %s",
        daveStrerror(res), res, rp->Name);
    strncpy(op->Status, daveStrerror(res), sizeof(op->Status));
    local->status = IO__ERRINIDEVICE;
    return IO__ERRINIDEVICE;
  }

  if (op->Timeout > FLT_EPSILON)
    daveSetTimeout(local->di, op->Timeout * 1000000);

  /* Do configuration check and initialize modules. */

  unsigned int prev_input_area_offset = 0;
  unsigned int prev_output_area_offset = 0;
  unsigned int input_area_offset = 0;
  unsigned int output_area_offset = 0;
  unsigned int input_area_chansize = 0;
  unsigned int output_area_chansize = 0;

  /* Calculate total input and output area size */
  cardp = rp->cardlist;
  while (cardp) {
    cid = cardp->Class;
    /* Find the super class */
    while (ODD(gdh_GetSuperClass(cid, &cid, cardp->Objid)))
      ;

    switch (cid) {
    case pwr_cClass_Nodave_Transaction: {
      io_bus_card_init(ctx, cardp, &input_area_offset, &input_area_chansize,
          &output_area_offset, &output_area_chansize, op->ByteOrdering,
          io_eAlignment_Packed);
      break;
    }
    }

    cardp = cardp->next;
  }

  local->input_size = input_area_offset + input_area_chansize;
  local->output_size = output_area_offset + output_area_chansize;

  local->input_area = calloc(1, local->input_size);
  local->output_area = calloc(1, local->output_size);

  /* Initialize transactions */
  prev_input_area_offset = 0;
  prev_output_area_offset = 0;
  input_area_offset = 0;
  output_area_offset = 0;
  input_area_chansize = 0;
  output_area_chansize = 0;

  cardp = rp->cardlist;
  while (cardp) {
    local_card = calloc(1, sizeof(*local_card));

    cid = cardp->Class;
    /* Find the super class */
    while (ODD(gdh_GetSuperClass(cid, &cid, cardp->Objid)))
      ;

    switch (cid) {
    case pwr_cClass_Nodave_Transaction: {
      pwr_sClass_Nodave_Transaction* tp;

      cardp->Local = local_card;

      local_card->input_area
          = local->input_area + input_area_offset + input_area_chansize;
      local_card->output_area
          = local->output_area + output_area_offset + output_area_chansize;

      tp = (pwr_sClass_Nodave_Transaction*)cardp->op;
      strcpy(tp->Status, "Starting...");

      io_bus_card_init(ctx, cardp, &input_area_offset, &input_area_chansize,
          &output_area_offset, &output_area_chansize, op->ByteOrdering,
          io_eAlignment_Packed);

      local_card->input_size
          = input_area_offset + input_area_chansize - prev_input_area_offset;
      local_card->output_size
          = output_area_offset + output_area_chansize - prev_output_area_offset;

      break;
    }

    } /* End - switch ... */

    prev_input_area_offset = input_area_offset + input_area_chansize;
    prev_output_area_offset = output_area_offset + output_area_chansize;

    cardp = cardp->next;
  }

  local->input_size = input_area_offset + input_area_chansize;
  local->output_size = output_area_offset + output_area_chansize;

  local->status = IO__SUCCESS;
  strcpy(op->Status, "Running");
  return IO__SUCCESS;
}

/*----------------------------------------------------------------------------*\
   Read method for the libnodave PLC
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoRackRead(io_tCtx ctx, io_sAgent* ap, io_sRack* rp)
{
  io_sRackLocal* local = (io_sRackLocal*)rp->Local;
  pwr_sClass_Nodave_PLC* op = (pwr_sClass_Nodave_PLC*)rp->op;

  if (op->Debug) {
    int size = sizeof(op->Inputs);
    if (local->input_size < size)
      size = local->input_size;

    memcpy(op->Inputs, local->input_area, size);
  }
  return IO__SUCCESS;
}

/*----------------------------------------------------------------------------*\
   Write method for nodave PLC
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoRackWrite(io_tCtx ctx, io_sAgent* ap, io_sRack* rp)
{
  io_sRackLocal* local = (io_sRackLocal*)rp->Local;
  pwr_sClass_Nodave_PLC* op = (pwr_sClass_Nodave_PLC*)rp->op;

  if (op->Debug) {
    int size = sizeof(op->Outputs);
    if (local->output_size < size)
      size = local->output_size;

    memcpy(op->Outputs, local->output_area, size);
  }
  return IO__SUCCESS;
}

/*----------------------------------------------------------------------------*\

\*----------------------------------------------------------------------------*/
static pwr_tStatus IoRackClose(io_tCtx ctx, io_sAgent* ap, io_sRack* rp)
{
  io_sRackLocal* local = (io_sRackLocal*)rp->Local;
  pwr_sClass_Nodave_PLC* op = (pwr_sClass_Nodave_PLC*)rp->op;

  strcpy(op->Status, "Closed down");

  if (local->dc)
    daveDisconnectPLC(local->dc);
  if (local->di)
    daveDisconnectAdapter(local->di);
  if (local->fds.rfd)
    closeSocket(local->fds.rfd);

  if (local->input_area)
    free(local->input_area);
  if (local->output_area)
    free(local->output_area);
  free(local);

  return IO__SUCCESS;
}

#else
static pwr_tStatus IoRackInit(io_tCtx ctx, io_sAgent* ap, io_sRack* rp)
{
  return IO__RELEASEBUILD;
}
static pwr_tStatus IoRackClose(io_tCtx ctx, io_sAgent* ap, io_sRack* rp)
{
  return IO__RELEASEBUILD;
}
static pwr_tStatus IoRackRead(io_tCtx ctx, io_sAgent* ap, io_sRack* rp)
{
  return IO__RELEASEBUILD;
}
static pwr_tStatus IoRackWrite(io_tCtx ctx, io_sAgent* ap, io_sRack* rp)
{
  return IO__RELEASEBUILD;
}
#endif

/*----------------------------------------------------------------------------*\
  Every method to be exported to the workbench should be registred here.
\*----------------------------------------------------------------------------*/

pwr_dExport pwr_BindIoMethods(Nodave_PLC) = { pwr_BindIoMethod(IoRackInit),
  pwr_BindIoMethod(IoRackRead), pwr_BindIoMethod(IoRackWrite),
  pwr_BindIoMethod(IoRackClose), pwr_NullMethod };
