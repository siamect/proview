/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 **/

#include "pwr_basecomponentclasses.h"
#include "co_dcli.h"
#include "co_cdh.h"
#include "rt_io_base.h"
#include "rt_io_agent_init.h"
#include "rt_io_agent_close.h"
#include "rt_io_msg.h"
#include "rt_iom_msg.h"
#include "pwr_otherioclasses.h"
#include "rt_io_m_epl.h"
#include "rt_io_bus.h"

#if defined PWRE_CONF_EPL && defined PWRE_CONF_LIBPCAP

#include "Epl.h"
#include <errno.h>
#include <math.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <rt_pwr_msg.h>

/***************************************************************************/
/*                                                                         */
/*                                                                         */
/*          G L O B A L   D E F I N I T I O N S                            */
/*                                                                         */
/*                                                                         */
/***************************************************************************/

//---------------------------------------------------------------------------
// module global vars
//---------------------------------------------------------------------------
CONST BYTE abMacAddr[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
static unsigned int uiCycleLen_g = 0;
static unsigned int uiCurCycleLen_g = 0;

// process image stuff
static void* AppProcessImageIn_g;
static void* AppProcessImageOut_g;
static tEplApiProcessImageCopyJob AppProcessImageCopyJob_g;

/*----------------------------------------------------------------------------*/

//---------------------------------------------------------------------------
// local function prototypes
//---------------------------------------------------------------------------

// This function is the entry point for your object dictionary. It is defined
// in OBJDICT.C by define EPL_OBD_INIT_RAM_NAME. Use this function name to
// define
// this function prototype here. If you want to use more than one Epl
// instances then the function name of each object dictionary has to differ.
tEplKernel PUBLIC EplObdInitRam(tEplObdInitParam MEM* pInitParam_p);
tEplKernel PUBLIC AppCbEvent(
    tEplApiEventType EventType_p, // IN: event type (enum)
    tEplApiEventArg* pEventArg_p, // IN: event argument (union)
    io_sAgent* pUserArg_p);
tEplKernel PUBLIC AppCbSync(void);

/*----------------------------------------------------------------------------*\
  Init method for the Powerlink module
  \*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentInit(io_tCtx ctx, io_sAgent* ap)
{
  io_sLocalEpl_MN* local;
  int sts;
  pwr_sClass_Epl_MN* op = (pwr_sClass_Epl_MN*)ap->op;

  local = (io_sLocalEpl_MN*)calloc(1, sizeof(io_sLocalEpl_MN));
  ap->Local = local;
  local->inputResetEnabled = 0;
  op->NumberOfSlaves = 0;

  static tEplApiInitParam EplApiInitParam;
  tEplKernel EplRet = kEplSuccessful;
  pwr_tFileName cdc_file;
  char* sHostname = malloc(1023);

  if (strchr(op->CDCfile, '/') != 0)
    strcpy(cdc_file, op->CDCfile);
  else {
    strcpy(cdc_file, "$pwrp_load/");
    strcat(cdc_file, op->CDCfile);
  }
  dcli_translate_filename(cdc_file, cdc_file);
  gethostname(sHostname, 1023);

  if (op->StallAction == pwr_eStallActionEnum_ResetInputs)
    local->inputResetEnabled = 1;

  // Init the I/O area
  unsigned int input_area_offset = 0;
  unsigned int input_area_chansize = 0;
  unsigned int output_area_offset = 0;
  unsigned int output_area_chansize = 0;
  io_sRack* rp;
  io_sCard* cp;
  pwr_tCid cid;

  for (rp = ap->racklist; rp; rp = rp->next) {
    rp->Local = calloc(1, sizeof(io_sLocalEpl_CN));
    rp->MethodDisabled = 1;
    op->NumberOfSlaves++;

    if (((pwr_sClass_Epl_CN*)rp->op)->StallAction
        == pwr_eStallActionEnum_ResetInputs)
      local->inputResetEnabled = 1;

    // Show device offset and size
    if (rp->Class == pwr_cClass_Epl_CN && rp->op) {
      ((pwr_sClass_Epl_CN*)rp->op)->InputAreaOffset
          = input_area_offset + input_area_chansize;
      ((pwr_sClass_Epl_CN*)rp->op)->OutputAreaOffset
          = output_area_offset + output_area_chansize;
    }

    // Get byte ordering
    pwr_tAName name;
    pwr_tEnum byte_ordering;

    strcpy(name, rp->Name);
    strcat(name, ".ByteOrdering");
    sts = gdh_GetObjectInfo(name, &byte_ordering, sizeof(byte_ordering));
    if (ODD(sts))
      ((io_sLocalEpl_CN*)rp->Local)->byte_ordering = byte_ordering;
    else
      ((io_sLocalEpl_CN*)rp->Local)->byte_ordering
          = pwr_eByteOrderingEnum_LittleEndian;

    for (cp = rp->cardlist; cp; cp = cp->next) {
      cid = cp->Class;
      while (ODD(gdh_GetSuperClass(cid, &cid, cp->Objid)))
        ;

      cp->MethodDisabled = 1;

      // Show module offset and size
      if (cid == pwr_cClass_Epl_Module && cp->op) {
        ((pwr_sClass_Epl_Module*)cp->op)->InputAreaOffset
            = input_area_offset + input_area_chansize;
        ((pwr_sClass_Epl_Module*)cp->op)->OutputAreaOffset
            = output_area_offset + output_area_chansize;
      }

      io_bus_card_init(ctx, cp, &input_area_offset, &input_area_chansize,
          &output_area_offset, &output_area_chansize, byte_ordering,
          io_eAlignment_Powerlink);

      // Show module offset and size
      if (cid == pwr_cClass_Epl_Module && cp->op) {
        ((pwr_sClass_Epl_Module*)cp->op)->InputAreaSize = input_area_offset
            + input_area_chansize
            - ((pwr_sClass_Epl_Module*)cp->op)->InputAreaOffset;
        ((pwr_sClass_Epl_Module*)cp->op)->OutputAreaSize = output_area_offset
            + output_area_chansize
            - ((pwr_sClass_Epl_Module*)cp->op)->OutputAreaOffset;
      }

      if (rp->next == NULL) {
        if (cp->next == NULL) {
          ((pwr_sClass_Epl_Module*)cp->op)->InputAreaSize
              += pwr_Align(input_area_offset + input_area_chansize, 4)
              - (input_area_offset + input_area_chansize);
          ((pwr_sClass_Epl_Module*)cp->op)->OutputAreaSize
              += pwr_Align(output_area_offset + output_area_chansize, 4)
              - (output_area_offset + output_area_chansize);
        }
      }
    }

    // Show slave offset and size
    if (rp->Class == pwr_cClass_Epl_CN && rp->op) {
      ((pwr_sClass_Epl_CN*)rp->op)->InputAreaSize = input_area_offset
          + input_area_chansize - ((pwr_sClass_Epl_CN*)rp->op)->InputAreaOffset;
      ((pwr_sClass_Epl_CN*)rp->op)->OutputAreaSize = output_area_offset
          + output_area_chansize
          - ((pwr_sClass_Epl_CN*)rp->op)->OutputAreaOffset;
      if (rp->next == NULL) {
        ((pwr_sClass_Epl_CN*)rp->op)->InputAreaSize
            += pwr_Align(input_area_offset + input_area_chansize, 4)
            - (input_area_offset + input_area_chansize);
        ((pwr_sClass_Epl_CN*)rp->op)->OutputAreaSize
            += pwr_Align(output_area_offset + output_area_chansize, 4)
            - (output_area_offset + output_area_chansize);
      }
    }
  }

  // This is the calculated in- and outputarea size
  local->input_area_size
      = pwr_Align(input_area_offset + input_area_chansize, 4);
  local->output_area_size
      = pwr_Align(output_area_offset + output_area_chansize, 4);

  // Show agent in- and output area size
  op->InputAreaSize = local->input_area_size;
  op->OutputAreaSize = local->output_area_size;

  struct sched_param schedParam;

  // adjust process priority
  // push nice level in case we have no RTPreempt
  if (nice(-20) == -1) {
    errh_Error("%s() couldn't set nice value! (%s)", __func__, strerror(errno));
  }
  // schedParam.sched_priority = MIN(sched_get_priority_max(SCHED_FIFO),
  //				  sched_get_priority_min(SCHED_FIFO) +
  //op->Priority);
  schedParam.__sched_priority = op->Priority;
  if (pthread_setschedparam(pthread_self(), SCHED_RR, &schedParam) != 0) {
    errh_Error("%s() couldn't set thread scheduling parameters! %d", __func__,
        schedParam.__sched_priority);
  }

  // binds all openPOWERLINK threads to the second CPU core
  cpu_set_t affinity;

  CPU_ZERO(&affinity);
  CPU_SET(1, &affinity);
  sched_setaffinity(0, sizeof(cpu_set_t), &affinity);

  // Initialize target specific stuff
  EplTgtInit();

  EPL_MEMSET(&EplApiInitParam, 0, sizeof(EplApiInitParam));
  EplApiInitParam.m_uiSizeOfStruct = sizeof(EplApiInitParam);
  EplApiInitParam.m_pEventUserArg = ap;

  // Get devicename from attribute in agent
  EplApiInitParam.m_HwParam.m_pszDevName = op->Device;

  // Get nodeid from attribute in agent
  EplApiInitParam.m_uiNodeId = op->NodeId;

  EplApiInitParam.m_dwIpAddress = ntohl(inet_addr(op->IpAddress));

  // write 00:00:00:00:00:00 to MAC address, so that the driver uses the real
  // hardware address
  EPL_MEMCPY(EplApiInitParam.m_abMacAddress, abMacAddr,
      sizeof(EplApiInitParam.m_abMacAddress));

  EplApiInitParam.m_fAsyncOnly = FALSE;

  EplApiInitParam.m_dwFeatureFlags = -1;
  // required for error detection
  EplApiInitParam.m_dwCycleLen = uiCycleLen_g;
  // const
  EplApiInitParam.m_uiIsochrTxMaxPayload = 256;
  // const
  EplApiInitParam.m_uiIsochrRxMaxPayload = 256;
  // const; only required for IdentRes
  EplApiInitParam.m_dwPresMaxLatency = 50000;
  // required for initialisation (+28 bytes)
  EplApiInitParam.m_uiPreqActPayloadLimit = 36;
  // required for initialisation of Pres frame (+28 bytes)
  EplApiInitParam.m_uiPresActPayloadLimit = 36;
  // const; only required for IdentRes
  EplApiInitParam.m_dwAsndMaxLatency = 150000;
  // required for error detection
  EplApiInitParam.m_uiMultiplCycleCnt = 0;
  // required to set up max frame size
  EplApiInitParam.m_uiAsyncMtu = 1500;
  // required for sync
  EplApiInitParam.m_uiPrescaler = 2;
  EplApiInitParam.m_dwLossOfFrameTolerance = 500000;
  EplApiInitParam.m_dwAsyncSlotTimeout = 3000000;
  EplApiInitParam.m_dwWaitSocPreq = 150000;
  // NMT_DeviceType_U32
  EplApiInitParam.m_dwDeviceType = -1;
  // NMT_IdentityObject_REC.VendorId_U32
  EplApiInitParam.m_dwVendorId = -1;
  // NMT_IdentityObject_REC.ProductCode_U32
  EplApiInitParam.m_dwProductCode = -1;
  // NMT_IdentityObject_REC.RevisionNo_U32
  EplApiInitParam.m_dwRevisionNumber = -1;
  // NMT_IdentityObject_REC.SerialNo_U32
  EplApiInitParam.m_dwSerialNumber = -1;

  EplApiInitParam.m_dwSubnetMask = ntohl(inet_addr(op->IpNetmask));
  EplApiInitParam.m_dwDefaultGateway = 0;
  EPL_MEMCPY(EplApiInitParam.m_sHostname, sHostname,
      sizeof(EplApiInitParam.m_sHostname));
  EplApiInitParam.m_uiSyncNodeId = EPL_C_ADR_SYNC_ON_SOA;
  EplApiInitParam.m_fSyncOnPrcNode = FALSE;

  // set callback functions
  EplApiInitParam.m_pfnCbEvent = (tEplApiCbEvent)AppCbEvent;

  EplApiInitParam.m_pfnObdInitRam = EplObdInitRam;
  EplApiInitParam.m_pfnCbSync = AppCbSync;

  // initialize POWERLINK stack
  EplRet = EplApiInitialize(&EplApiInitParam);
  if (EplRet != kEplSuccessful) {
    errh_Error("EplApiInitialize() failed (Error:0x%x!", EplRet);
    goto Exit;
  }

  EplRet = EplApiSetCdcFilename(cdc_file);
  if (EplRet != kEplSuccessful) {
    goto Exit;
  }

  // Allocate memory for the in- and outputareas
  if (local->output_area_size > 0)
    AppProcessImageIn_g = malloc(local->output_area_size);
  if (local->input_area_size > 0) {
    AppProcessImageOut_g = malloc(local->input_area_size);
  }

  // Save pointer to in- and outputareas in THIS agent object
  local->input_area = AppProcessImageOut_g;
  local->output_area = AppProcessImageIn_g;

  if (local->inputResetEnabled && local->input_area_size > 0)
    local->tmp_area = malloc(local->input_area_size);
  else
    local->tmp_area = local->input_area;

  AppProcessImageCopyJob_g.m_fNonBlocking = FALSE;
  AppProcessImageCopyJob_g.m_uiPriority = 0;
  AppProcessImageCopyJob_g.m_In.m_pPart = AppProcessImageIn_g;
  AppProcessImageCopyJob_g.m_In.m_uiOffset = 0;
  AppProcessImageCopyJob_g.m_In.m_uiSize = local->output_area_size;
  AppProcessImageCopyJob_g.m_Out.m_pPart = AppProcessImageOut_g;
  AppProcessImageCopyJob_g.m_Out.m_uiOffset = 0;
  AppProcessImageCopyJob_g.m_Out.m_uiSize = local->input_area_size;

  EplRet = EplApiProcessImageAlloc(
      local->output_area_size, local->input_area_size, 2, 2);
  if (EplRet != kEplSuccessful) {
    goto Exit;
  }

  EplRet = EplApiProcessImageSetup();
  if (EplRet != kEplSuccessful) {
    goto Exit;
  }

  // start processing
  EplRet = EplApiExecNmtCommand(kEplNmtEventSwReset);
  if (EplRet != kEplSuccessful) {
    IoAgentClose(NULL, NULL);
    goto Exit;
  }

  errh_Success("Powerlink init successful");
  return IO__SUCCESS;

Exit:
  errh_Error("IoCardInit: returns 0x%X", EplRet);
  return IO__SUCCESS;
}
//---------------------------------------------------------------------------
//
// Function:    AppCbEvent
//
// Description: event callback function called by EPL API layer within
//              user part (low priority).
//
// Parameters:  EventType_p     = event type
//              pEventArg_p     = pointer to union, which describes
//                                the event in detail
//              pUserArg_p      = user specific argument
//
// Returns:     tEplKernel      = error code,
//                                kEplSuccessful = no error
//                                kEplReject = reject further processing
//                                otherwise = post error event to API layer
//
// State:
//
//---------------------------------------------------------------------------
tEplKernel PUBLIC AppCbEvent(
    tEplApiEventType EventType_p, // IN: event type (enum)
    tEplApiEventArg* pEventArg_p, // IN: event argument (union)
    io_sAgent* pUserArg_p)
{
  UINT uiVarLen;
  tEplKernel EplRet = kEplSuccessful;
  pwr_sClass_Epl_MN* op = (pwr_sClass_Epl_MN*)pUserArg_p->op;
  io_sRack* rp;

  // check if NMT_GS_OFF is reached
  switch (EventType_p) {
  case kEplApiEventNmtStateChange: {
    op->NmtState = pEventArg_p->m_NmtStateChange.m_NewNmtState;
    op->Status = op->NmtState == pwr_eEplNmtState_EplNmtMsOperational
        ? IOM__EPL_OPER
        : IOM__EPL_NOOPER;

    switch (pEventArg_p->m_NmtStateChange.m_NewNmtState) {
    case kEplNmtGsOff: {
      // NMT state machine was shut down,
      // because of user signal (CTRL-C) or critical EPL stack error
      // -> also shut down EplApiProcess() and main()
      EplRet = kEplShutdown;

      errh_Fatal("Event:kEplNmtGsOff originating event = 0x%X (%s)",
          pEventArg_p->m_NmtStateChange.m_NmtEvent,
          EplGetNmtEventStr(pEventArg_p->m_NmtStateChange.m_NmtEvent));

      break;
    }

    case kEplNmtGsResetCommunication: {
      break;
    }

    case kEplNmtGsResetConfiguration: {
      if (uiCycleLen_g != 0) {
        EplRet = EplApiWriteLocalObject(
            0x1006, 0x00, &uiCycleLen_g, sizeof(uiCycleLen_g));
        uiCurCycleLen_g = uiCycleLen_g;
      } else {
        uiVarLen = sizeof(uiCurCycleLen_g);
        EplApiReadLocalObject(0x1006, 0x00, &uiCurCycleLen_g, &uiVarLen);
      }
      break;
    }
    case kEplNmtCsPreOperational1:
    case kEplNmtMsPreOperational1: {
      errh_Info("AppCbEvent(0x%X) originating event = 0x%X (%s)",
          pEventArg_p->m_NmtStateChange.m_NewNmtState,
          pEventArg_p->m_NmtStateChange.m_NmtEvent,
          EplGetNmtEventStr(pEventArg_p->m_NmtStateChange.m_NmtEvent));
      break;
    }

    case kEplNmtCsPreOperational2:
    case kEplNmtMsPreOperational2: {
      break;
    }
    case kEplNmtCsReadyToOperate:
    case kEplNmtMsReadyToOperate: {
      break;
    }
    case kEplNmtGsInitialising: {
      break;
    }
    case kEplNmtGsResetApplication: {
      break;
    }
    case kEplNmtMsNotActive:
    case kEplNmtCsNotActive: {
      break;
    }
    case kEplNmtCsOperational:
    case kEplNmtMsOperational: {
      break;
    }
    case kEplNmtCsBasicEthernet:
    case kEplNmtMsBasicEthernet: {
      break;
    }

    default: {
    }
    }

    break;
  }

  case kEplApiEventCriticalError:
  case kEplApiEventWarning: {
    // error or warning occurred within the stack or the application
    // on error the API layer stops the NMT state machine

    errh_Error("%s(Err/Warn): Source = %s (%02X) EplError = %s (0x%03X)",
        __func__,
        EplGetEventSourceStr(pEventArg_p->m_InternalError.m_EventSource),
        pEventArg_p->m_InternalError.m_EventSource,
        EplGetEplKernelStr(pEventArg_p->m_InternalError.m_EplError),
        pEventArg_p->m_InternalError.m_EplError);

    // check additional argument
    switch (pEventArg_p->m_InternalError.m_EventSource) {
    case kEplEventSourceEventk:
    case kEplEventSourceEventu: {
      // error occurred within event processing
      // either in kernel or in user part

      errh_Error(" OrgSource = %s %02X",
          EplGetEventSourceStr(
              pEventArg_p->m_InternalError.m_Arg.m_EventSource),
          pEventArg_p->m_InternalError.m_Arg.m_EventSource);

      break;
    }

    case kEplEventSourceDllk: {
      // error occurred within the data link layer (e.g. interrupt processing)
      // the DWORD argument contains the DLL state and the NMT event

      errh_Error(" val = %X", pEventArg_p->m_InternalError.m_Arg.m_dwArg);

      break;
    }

    default: {
      break;
    }
    }
    break;
  }

  case kEplApiEventHistoryEntry: {
    // new history entry

    errh_Info("%s(HistoryEntry): Type=0x%04X Code=0x%04X (0x%02X %02X %02X "
              "%02X %02X %02X %02X %02X)",
        __func__, pEventArg_p->m_ErrHistoryEntry.m_wEntryType,
        pEventArg_p->m_ErrHistoryEntry.m_wErrorCode,
        (WORD)pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[0],
        (WORD)pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[1],
        (WORD)pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[2],
        (WORD)pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[3],
        (WORD)pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[4],
        (WORD)pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[5],
        (WORD)pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[6],
        (WORD)pEventArg_p->m_ErrHistoryEntry.m_abAddInfo[7]);

    break;
  }

  case kEplApiEventNode: {
    switch (pEventArg_p->m_Node.m_NodeEvent) {
    case kEplNmtNodeEventCheckConf: {
      errh_Info(
          "%s(Node=0x%X, CheckConf)", __func__, pEventArg_p->m_Node.m_uiNodeId);
      break;
    }

    case kEplNmtNodeEventUpdateConf: {
      errh_Info("%s(Node=0x%X, UpdateConf)", __func__,
          pEventArg_p->m_Node.m_uiNodeId);
      break;
    }

    case kEplNmtNodeEventFound: {
      break;
    }

    case kEplNmtNodeEventNmtState: {
      for (rp = pUserArg_p->racklist; rp; rp = rp->next)
        if (((pwr_sClass_Epl_CN*)rp->op)->NodeId
            == pEventArg_p->m_Node.m_uiNodeId) {
          ((pwr_sClass_Epl_CN*)rp->op)->NmtState
              = pEventArg_p->m_Node.m_NmtState;
        }

      switch (pEventArg_p->m_Node.m_NmtState) {
      case kEplNmtGsOff:
      case kEplNmtGsInitialising:
      case kEplNmtGsResetApplication:
      case kEplNmtGsResetCommunication:
      case kEplNmtGsResetConfiguration:
      case kEplNmtCsNotActive: {
        break;
      }
      case kEplNmtCsPreOperational1:
      case kEplNmtCsPreOperational2:
      case kEplNmtCsReadyToOperate: {
        break;
      }
      case kEplNmtCsOperational: {
        break;
      }
      case kEplNmtCsBasicEthernet:
      case kEplNmtCsStopped:
      default: {
        break;
      }
      }
      break;
    }

    case kEplNmtNodeEventError: {
      errh_Error("AppCbEvent (Node=0x%X): Error = %s (0x%.4X)",
          pEventArg_p->m_Node.m_uiNodeId,
          EplGetEmergErrCodeStr(pEventArg_p->m_Node.m_wErrorCode),
          pEventArg_p->m_Node.m_wErrorCode);
      break;
    }

    default: {
      break;
    }
    }
    break;
  }

  case kEplApiEventCfmProgress: {
    errh_Info("%s(Node=0x%X, CFM-Progress: Object 0x%X/%u,  %lu/%lu Bytes",
        __func__, pEventArg_p->m_CfmProgress.m_uiNodeId,
        pEventArg_p->m_CfmProgress.m_uiObjectIndex,
        pEventArg_p->m_CfmProgress.m_uiObjectSubIndex,
        (ULONG)pEventArg_p->m_CfmProgress.m_dwBytesDownloaded,
        (ULONG)pEventArg_p->m_CfmProgress.m_dwTotalNumberOfBytes);

    if ((pEventArg_p->m_CfmProgress.m_dwSdoAbortCode != 0)
        || (pEventArg_p->m_CfmProgress.m_EplError != kEplSuccessful)) {
      errh_Error(" -> SDO Abort=0x%lX, Error=0x%X)",
          (unsigned long)pEventArg_p->m_CfmProgress.m_dwSdoAbortCode,
          pEventArg_p->m_CfmProgress.m_EplError);
    } else {
    }
    break;
  }

  case kEplApiEventCfmResult: {
    switch (pEventArg_p->m_CfmResult.m_NodeCommand) {
    case kEplNmtNodeCommandConfOk: {
      errh_Info("%s(Node=0x%X, ConfOk)", __func__,
          pEventArg_p->m_CfmResult.m_uiNodeId);
      break;
    }

    case kEplNmtNodeCommandConfErr: {
      errh_Info("%s(Node=0x%X, ConfErr)", __func__,
          pEventArg_p->m_CfmResult.m_uiNodeId);
      break;
    }

    case kEplNmtNodeCommandConfReset: {
      errh_Info("%s(Node=0x%X, ConfReset)", __func__,
          pEventArg_p->m_CfmResult.m_uiNodeId);
      break;
    }

    case kEplNmtNodeCommandConfRestored: {
      errh_Info("%s(Node=0x%X, ConfRestored)", __func__,
          pEventArg_p->m_CfmResult.m_uiNodeId);
      break;
    }

    default: {
      errh_Info("%s(Node=0x%X, CfmResult=0x%X)", __func__,
          pEventArg_p->m_CfmResult.m_uiNodeId,
          pEventArg_p->m_CfmResult.m_NodeCommand);
      break;
    }
    }
    break;
  }

  default:
    break;
  }

  return EplRet;
}

//---------------------------------------------------------------------------
//
// Function:    AppCbSync
//
// Description: sync event callback function called by event module within
//              kernel part (high priority).
//              This function sets the outputs, reads the inputs and runs
//              the control loop.
//
// Parameters:  void
//
// Returns:     tEplKernel      = error code,
//                                kEplSuccessful = no error
//                                otherwise = post error event to API layer
//
// State:
//
//---------------------------------------------------------------------------
tEplKernel PUBLIC AppCbSync(void)
{
  tEplKernel EplRet = kEplSuccessful;
  EplRet = EplApiProcessImageExchange(&AppProcessImageCopyJob_g);

  if (EplRet != kEplSuccessful) {
    return EplRet;
  }
  return EplRet;
}
/*----------------------------------------------------------------------------*\
  Close method for the Powerlink master
  \*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentClose(io_tCtx ctx, io_sAgent* ap)
{
  tEplKernel EplRet = kEplSuccessful;
  io_sLocalEpl_MN* local = (io_sLocalEpl_MN*)ap->Local;
  io_sRack* rp;

  free(local);
  ap->Local = 0;
  for (rp = ap->racklist; rp; rp = rp->next)
    free((io_sLocalEpl_CN*)rp->Local);

  // halt the NMT state machine
  // so the processing of POWERLINK frames stops
  EplRet = EplApiExecNmtCommand(kEplNmtEventSwitchOff);

  // delete process image
  EplRet = EplApiProcessImageFree();
  // delete instance for all modules
  EplRet = EplApiShutdown();

  return IO__SUCCESS;
}
/*----------------------------------------------------------------------------*\
  Read method for the Powerlink master
  \*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentRead(io_tCtx ctx, io_sAgent* ap)
{
  io_sLocalEpl_MN* local = (io_sLocalEpl_MN*)ap->Local;
  io_sLocalEpl_CN* local1;
  pwr_sClass_Epl_MN* op = (pwr_sClass_Epl_MN*)ap->op;
  io_sRack* rp;
  io_sCard* cp;
  pwr_tUInt32 error_count = 0;
  int ret = IO__SUCCESS;

  if (!ap->Local)
    return ret;

  // Remeber the time when this functions was called the first time
  if (local->init == 0) {
    clock_gettime(CLOCK_REALTIME, &local->boot);
    local->init = 1;
  }

  // Time now (tps = time when bad state occurred)
  clock_gettime(CLOCK_REALTIME, &local->tpe);

  error_count = op->ErrorCount;
  // Add to error count if agent changed from good to bad state and setup is
  // complete
  if (local->prevState == pwr_eEplNmtState_EplNmtMsOperational
      && op->NmtState != pwr_eEplNmtState_EplNmtMsOperational
      && ((local->tpe).tv_sec - (local->boot).tv_sec) >= op->StartupTimeout)
    op->ErrorCount++;

  // Copy Powerlink process image to temp memory (only if
  // stallaction=resetinputs else tmp_area=input_area)
  if (local->inputResetEnabled)
    memcpy(local->tmp_area, local->input_area, local->input_area_size);

  // If no bad state and were still in startup there can be no error (else
  // remember when error occurred)
  if (op->NmtState == pwr_eEplNmtState_EplNmtMsOperational
      || ((local->tpe).tv_sec - (local->boot).tv_sec) < op->StartupTimeout) {
    (local->tps).tv_sec = 0;
    local->timeoutStatus = 0;
  } else if ((local->tps).tv_sec == 0) {
    clock_gettime(CLOCK_REALTIME, &local->tps);
  }

  // Agent error soft limit reached, tell log (once)
  if (op->ErrorCount >= op->ErrorSoftLimit
      && error_count < op->ErrorSoftLimit) {
    errh_Warning("IO Agent ErrorSoftLimit reached, '%s'", ap->Name);
    ctx->IOHandler->CardErrorSoftLimit = 1;
    ctx->IOHandler->ErrorSoftLimitObject = cdh_ObjidToAref(ap->Objid);
  }

  // Agent error hard limit reached, tell log (once)
  if (op->ErrorCount >= op->ErrorHardLimit
      && error_count < op->ErrorHardLimit) {
    ctx->IOHandler->CardErrorHardLimit = 1;
    ctx->IOHandler->ErrorHardLimitObject = cdh_ObjidToAref(ap->Objid);

    if (op->StallAction == pwr_eStallActionEnum_EmergencyBreak) {
      errh_Error("IO Agent ErrorHardLimit reached '%s', IO stopped", ap->Name);
    } else
      errh_Error("IO Agent ErrorHardLimit reached '%s'", ap->Name);
  }

  // Agent timeout has elapsed, tell log (once)
  if (((local->tpe).tv_sec - (local->tps).tv_sec) >= op->Timeout
      && local->timeoutStatus == 0 && (local->tps).tv_sec != 0) {
    local->timeoutStatus = 1;
    if (op->StallAction == pwr_eStallActionEnum_EmergencyBreak) {
      errh_Error("IO Agent timeout time elapsed '%s', IO stopped", ap->Name);
    } else if (op->StallAction == pwr_eStallActionEnum_ResetInputs) {
      errh_Error(
          "IO Agent timeout time elapsed '%s', IO input area reset", ap->Name);
    } else
      errh_Error("IO Agent timeout time elapsed '%s'", ap->Name);
  }

  // Agent error hard limit reached, take action (always)
  if (op->ErrorCount >= op->ErrorHardLimit) {
    if (op->StallAction == pwr_eStallActionEnum_EmergencyBreak) {
      ctx->Node->EmergBreakTrue = 1;
      errh_SetStatus(PWR__SRVFATAL);
      IoAgentClose(ctx, ap);
    }
    ret = IO__ERRDEVICE;
  }

  // Agent timeout time elapsed, take action (always)
  if (((local->tpe).tv_sec - (local->tps).tv_sec) >= op->Timeout
      && (local->tps).tv_sec != 0) {
    if (op->StallAction == pwr_eStallActionEnum_EmergencyBreak) {
      ctx->Node->EmergBreakTrue = 1;
      errh_SetStatus(PWR__SRVFATAL);
      IoAgentClose(ctx, ap);
    } else if (op->StallAction == pwr_eStallActionEnum_ResetInputs) {
      memset(local->tmp_area, 0, local->input_area_size);
    }
    ret = IO__ERRDEVICE;
  }

  // Remember agent state til next scan
  local->prevState = op->NmtState;

  // Loop through all slaves
  for (rp = ap->racklist; rp; rp = rp->next) {
    ((pwr_sClass_Epl_CN*)rp->op)->Status
        = ((pwr_sClass_Epl_CN*)rp->op)->NmtState
            == pwr_eEplNmtState_EplNmtCsOperational
        ? IOM__EPL_OPER
        : IOM__EPL_NOOPER;
    local1 = (io_sLocalEpl_CN*)rp->Local;
    // Time now (tps = time when bad state occurred)
    clock_gettime(CLOCK_REALTIME, &local1->tpe);

    error_count = ((pwr_sClass_Epl_CN*)rp->op)->ErrorCount;
    // Add to error count if slave changed from good to bad state and setup is
    // complete
    if (local1->prevState == pwr_eEplNmtState_EplNmtCsOperational
        && ((pwr_sClass_Epl_CN*)rp->op)->NmtState
            != pwr_eEplNmtState_EplNmtCsOperational
        && ((local1->tpe).tv_sec - (local->boot).tv_sec) >= op->StartupTimeout)
      ((pwr_sClass_Epl_CN*)rp->op)->ErrorCount++;

    // Save time when bad state occurs
    if (((pwr_sClass_Epl_CN*)rp->op)->NmtState
            == pwr_eEplNmtState_EplNmtCsOperational
        || ((local1->tpe).tv_sec - (local->boot).tv_sec) < op->StartupTimeout) {
      (local1->tps).tv_sec = 0;
      local1->timeoutStatus = 0;
    } else if ((local1->tps).tv_sec == 0)
      clock_gettime(CLOCK_REALTIME, &local1->tps);

    // Slave error soft limit reached, tell log (once)
    if (((pwr_sClass_Epl_CN*)rp->op)->ErrorCount
            >= ((pwr_sClass_Epl_CN*)rp->op)->ErrorSoftLimit
        && error_count < ((pwr_sClass_Epl_CN*)rp->op)->ErrorSoftLimit) {
      errh_Warning("IO Rack ErrorSoftLimit reached, '%s'", rp->Name);
      ctx->IOHandler->CardErrorSoftLimit = 1;
      ctx->IOHandler->ErrorSoftLimitObject = cdh_ObjidToAref(ap->Objid);
    }

    // Slave error hard limit reached, tell log (once)
    if (((pwr_sClass_Epl_CN*)rp->op)->ErrorCount
            >= ((pwr_sClass_Epl_CN*)rp->op)->ErrorHardLimit
        && error_count < ((pwr_sClass_Epl_CN*)rp->op)->ErrorHardLimit) {
      ctx->IOHandler->CardErrorHardLimit = 1;
      ctx->IOHandler->ErrorHardLimitObject = cdh_ObjidToAref(ap->Objid);

      if (((pwr_sClass_Epl_CN*)rp->op)->StallAction
          == pwr_eStallActionEnum_EmergencyBreak) {
        errh_Error("IO Rack ErrorHardLimit reached '%s', IO stopped", rp->Name);
      } else
        errh_Error("IO Rack ErrorHardLimit reached '%s'", rp->Name);
    }

    // Slave timeout has elapsed, tell log (once)
    if (((local1->tpe).tv_sec - (local1->tps).tv_sec)
            >= ((pwr_sClass_Epl_CN*)rp->op)->Timeout
        && local1->timeoutStatus == 0 && (local1->tps).tv_sec != 0) {
      local1->timeoutStatus = 1;
      if (((pwr_sClass_Epl_CN*)rp->op)->StallAction
          == pwr_eStallActionEnum_EmergencyBreak) {
        errh_Error("Rack timeout time elapsed '%s', IO stopped", rp->Name);
      } else if (((pwr_sClass_Epl_CN*)rp->op)->StallAction
          == pwr_eStallActionEnum_ResetInputs) {
        errh_Error(
            "Rack timeout time elapsed '%s', IO input area reset", rp->Name);
      } else
        errh_Error("Rack timeout time elapsed '%s'", rp->Name);
    }

    // Slave error hard limit reached, take action (always)
    if (((pwr_sClass_Epl_CN*)rp->op)->ErrorCount
        >= ((pwr_sClass_Epl_CN*)rp->op)->ErrorHardLimit) {
      if (((pwr_sClass_Epl_CN*)rp->op)->StallAction
          == pwr_eStallActionEnum_EmergencyBreak) {
        ctx->Node->EmergBreakTrue = 1;
        errh_SetStatus(PWR__SRVFATAL);
        IoAgentClose(ctx, ap);
      }
      ret = IO__ERRDEVICE;
    }

    // Slave timeout elapsed, take action (always)
    if (((local1->tpe).tv_sec - (local1->tps).tv_sec)
            >= ((pwr_sClass_Epl_CN*)rp->op)->Timeout
        && (local1->tps).tv_sec != 0) {
      if (((pwr_sClass_Epl_CN*)rp->op)->StallAction
          == pwr_eStallActionEnum_EmergencyBreak) {
        ctx->Node->EmergBreakTrue = 1;
        errh_SetStatus(PWR__SRVFATAL);
        IoAgentClose(ctx, ap);
      } else if (((pwr_sClass_Epl_CN*)rp->op)->StallAction
          == pwr_eStallActionEnum_ResetInputs) {
        memset(local->tmp_area + ((pwr_sClass_Epl_CN*)rp->op)->InputAreaOffset,
            0, ((pwr_sClass_Epl_CN*)rp->op)->InputAreaSize);
      }
      ret = IO__ERRDEVICE;
    }

    // Remeber slave state til next scan
    local1->prevState = ((pwr_sClass_Epl_CN*)rp->op)->NmtState;

    // Update Proview chan-objects with data from Powerlink process image
    for (cp = rp->cardlist; cp; cp = cp->next) {
      io_bus_card_read(ctx, rp, cp, local->tmp_area, 0,
          ((io_sLocalEpl_CN*)rp->Local)->byte_ordering,
          pwr_eFloatRepEnum_FloatIEEE);
    }
  }

  return ret;
}
/*----------------------------------------------------------------------------*\
  Write method for the Powerlink master
  \*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentWrite(io_tCtx ctx, io_sAgent* ap)
{
  io_sLocalEpl_MN* local = (io_sLocalEpl_MN*)ap->Local;
  // pwr_sClass_Epl_MN *op = (pwr_sClass_Epl_MN *)ap->op;
  io_sRack* rp;
  io_sCard* cp;

  if (!ap->Local)
    return IO__SUCCESS;

  for (rp = ap->racklist; rp; rp = rp->next) {
    for (cp = rp->cardlist; cp; cp = cp->next) {
      io_bus_card_write(ctx, cp, local->output_area,
          ((io_sLocalEpl_CN*)rp->Local)->byte_ordering,
          pwr_eFloatRepEnum_FloatIEEE);
    }
  }

  return IO__SUCCESS;
}
/*----------------------------------------------------------------------------*\
  Initialization of a bus card.
  \*----------------------------------------------------------------------------*/

#else
static pwr_tStatus IoAgentInit(io_tCtx ctx, io_sAgent* ap)
{
  return IO__RELEASEBUILD;
}
static pwr_tStatus IoAgentClose(io_tCtx ctx, io_sAgent* ap)
{
  return IO__RELEASEBUILD;
}
static pwr_tStatus IoAgentRead(io_tCtx ctx, io_sAgent* ap)
{
  return IO__RELEASEBUILD;
}
static pwr_tStatus IoAgentWrite(io_tCtx ctx, io_sAgent* ap)
{
  return IO__RELEASEBUILD;
}
#endif

/*----------------------------------------------------------------------------*\
  Every method to be exported to the workbench should be registred here.
  \*----------------------------------------------------------------------------*/
pwr_dExport pwr_BindIoMethods(Epl_MN) = { pwr_BindIoMethod(IoAgentInit),
  pwr_BindIoMethod(IoAgentClose), pwr_BindIoMethod(IoAgentRead),
  pwr_BindIoMethod(IoAgentWrite), pwr_NullMethod };
