/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_io_m_arduino_uno.c -- I/O methods for class Arduino_Uno. */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

#include <termios.h>

#include "pwr_basecomponentclasses.h"
#include "pwr_otherioclasses.h"
#include "co_time.h"
#include "co_cdh.h"
#include "rt_io_base.h"
#include "rt_io_card_init.h"
#include "rt_io_card_close.h"
#include "rt_io_card_read.h"
#include "rt_io_card_write.h"
#include "rt_io_msg.h"

#define D_MAX_SIZE 10
#define AI_MAX_SIZE 4
#define AO_MAX_SIZE 4

typedef enum {
  ard_eMsgType_No = 0,
  ard_eMsgType_DoWrite = 1,
  ard_eMsgType_DiRead = 2,
  ard_eMsgType_AiRead = 3,
  ard_eMsgType_AoWrite = 4,
  ard_eMsgType_Configure = 5,
  ard_eMsgType_Status = 6,
  ard_eMsgType_Debug = 7,
  ard_eMsgType_WriteAll = 8,
  ard_eMsgType_ReadAll = 9,
  ard_eMsgType_ConnectReq = 10,
  ard_eMsgType_ConnectRes = 11
} ard_eMsgType;

typedef struct {
  pwr_tTime ErrTime;
  int fd;
  int DiSize;
  int DoSize;
  int AiSize;
  int AoSize;
  int AiNum;
  int AoNum;
  unsigned char DiMask[D_MAX_SIZE];
  unsigned char DoMask[D_MAX_SIZE];
  unsigned char AiMask[AI_MAX_SIZE];
  unsigned char AoMask[AO_MAX_SIZE];
  int IdCnt;
  int DiPollId;
  int DiPendingPoll;
  ard_eMsgType PendingMsgType;
  int ReceiveWriteRespons;
  int WriteId;
  int AiIntervalCnt;
  int AoIntervalCnt;
  int Reopendev;
  int ReopendevCnt;
  int Reconnect;
  int ReconnectCnt;
  int VersionMajor;
  int VersionMinor;
  io_sChannel* DChanList[D_MAX_SIZE * 8];
  io_sChannel* AiChanList[AI_MAX_SIZE * 8];
  io_sChannel* AoChanList[AO_MAX_SIZE * 8];
} io_sLocal;

#define ARD__SUCCESS 1
/*
#define ARD__DICONFIG 2
#define ARD__DOCONFIG 4
#define ARD__AICONFIG 6
#define ARD__AOCONFIG 8
#define ARD__COMMERROR 10
#define ARD__MSGSIZE 12
*/
#define ARD__NOMSG 14
#define ARD__CHECKSUM 16

typedef struct {
  unsigned char size __attribute__((aligned(1)));
  unsigned char id __attribute__((aligned(1)));
  unsigned char type __attribute__((aligned(1)));
  unsigned char data[100] __attribute__((aligned(1)));
} ard_sMsg;

static void add_checksum(void* buf);
static int check_checksum(void* buf);
static int receive(int fd, int id, ard_sMsg* rmsg, int size, float tmo,
    pwr_sClass_Arduino_Uno* op);

static int close_device(io_sLocal* local)
{
  close(local->fd);
  return IO__SUCCESS;
}

static int open_device(
    io_sLocal* local, pwr_sClass_Arduino_Uno* op, io_sCard* cp)
{
  struct termios tty_attributes;
  int sts;

  // Open device
  local->fd = open(op->Device, O_RDWR | O_NDELAY | O_NOCTTY);
  if (local->fd == -1) {
    errh_Error(
        "IO Init Card '%s', unable to open device %s", cp->Name, op->Device);
    op->Status = pwr_eArduino_StatusEnum_NoSuchDevice;
    return IO__INITFAIL;
  }

  tcgetattr(local->fd, &tty_attributes);
#if defined OS_LINUX
  tty_attributes.c_cflag &= ~CBAUD; // maska bort all hastighet
#endif
  switch (op->BaudRate) {
  case 300:
    tty_attributes.c_cflag |= B300;
    break;
  case 1200:
    tty_attributes.c_cflag |= B1200;
    break;
  case 2400:
    tty_attributes.c_cflag |= B2400;
    break;
  case 4800:
    tty_attributes.c_cflag |= B4800;
    break;
  case 9600:
    tty_attributes.c_cflag |= B9600;
    break;
  case 19200:
    tty_attributes.c_cflag |= B19200;
    break;
  case 38400:
    tty_attributes.c_cflag |= B38400;
    break;
  case 57600:
    tty_attributes.c_cflag |= B57600;
    break;
  case 115200:
    tty_attributes.c_cflag |= B115200;
    break;
  default:
    tty_attributes.c_cflag |= B9600;
    break;
  }

  tty_attributes.c_iflag &= ~(BRKINT | ICRNL | IMAXBEL);
  tty_attributes.c_oflag &= ~(OPOST | ONLCR);
  tty_attributes.c_lflag
      &= ~(ISIG | ICANON | IEXTEN | ECHO | ECHOE | ECHOK | ECHOCTL | ECHOKE);
  tty_attributes.c_cc[VMIN] = 1;
  tty_attributes.c_cc[VTIME] = 0;
  tty_attributes.c_cc[VEOF] = 1;
  sts = tcsetattr(local->fd, TCSANOW, &tty_attributes);
  if (sts < 0) {
    errh_Error("IO Init Card '%s', unable to set baud rate on device %s",
        cp->Name, op->Device);
    op->Status = pwr_eArduino_StatusEnum_DeviceSetupError;
    return IO__INITFAIL;
  }

  tcflush(local->fd, TCIOFLUSH);

  sleep(5);

  return IO__SUCCESS;
}

static int send_configuration(
    io_sLocal* local, pwr_sClass_Arduino_Uno* op, io_sCard* cp)
{
  unsigned char wdg;
  int i;
  int sts;

  // Configure Watchdog
  if (feqf(op->WatchdogTime, 0.0f))
    wdg = 0;
  else if (op->WatchdogTime > 255)
    wdg = 255;
  else {
    wdg = op->WatchdogTime * 10;
    if (wdg < 1)
      wdg = 1;
  }

  // Send config message
  ard_sMsg msg, rmsg;
  int offs = 0;

  msg.size = 3;
  msg.id = local->IdCnt++;
  msg.type = ard_eMsgType_Configure;

  msg.data[offs++] = wdg;

  msg.data[offs++] = local->DiSize;
  for (i = 0; i < local->DiSize; i++)
    msg.data[offs++] = local->DiMask[i];

  msg.data[offs++] = local->DoSize;
  for (i = 0; i < local->DoSize; i++)
    msg.data[offs++] = local->DoMask[i];

  msg.data[offs++] = local->AiSize;
  for (i = 0; i < local->AiSize; i++)
    msg.data[offs++] = local->AiMask[i];

  msg.data[offs++] = local->AoSize;
  for (i = 0; i < local->AoSize; i++)
    msg.data[offs++] = local->AoMask[i];

  msg.size += offs;

  printf("Config (size=%d, id= %d): ", offs, msg.id);
  for (i = 0; i < offs; i++)
    printf("%u ", msg.data[i]);
  printf("\n");

  if (op->Options & pwr_mArduino_OptionsMask_Checksum)
    add_checksum(&msg);

  sts = write(local->fd, &msg, msg.size);

  sts = receive(local->fd, msg.id, &rmsg, 1, op->Timeout, op);
  if (sts & 1) {
    op->Status = rmsg.data[0];
  } else {
    errh_Error("IO Init Card '%s', config error: %d", cp->Name, sts);
    op->Status = sts;
    if (sts == pwr_eArduino_StatusEnum_NoMessage)
      sts = pwr_eArduino_StatusEnum_ConnectionTimeout;
    return IO__INITFAIL;
  }

  return IO__SUCCESS;
}

static int send_connect_request(
    io_sLocal* local, pwr_sClass_Arduino_Uno* op, io_sCard* cp)
{
  int sts;

  // Send connect request
  ard_sMsg msg, rmsg;

  msg.size = 3;
  msg.id = local->IdCnt++;
  msg.type = ard_eMsgType_ConnectReq;

  if (op->Options & pwr_mArduino_OptionsMask_Checksum)
    add_checksum(&msg);

  sts = write(local->fd, &msg, msg.size);

  sts = receive(local->fd, msg.id, &rmsg, 23, op->Timeout, op);
  if (sts & 1) {
    if (rmsg.type != ard_eMsgType_ConnectRes)
      return IO__INITFAIL;

    op->Status = rmsg.data[0];
    local->VersionMajor = rmsg.data[1];
    local->VersionMinor = rmsg.data[2];
    snprintf(op->FirmwareVersion, sizeof(op->FirmwareVersion), "%s",
        (char*)&rmsg.data[3]);
  } else {
    return IO__INITFAIL;
  }

  return IO__SUCCESS;
}

static int open_and_connect(
    io_sLocal* local, pwr_sClass_Arduino_Uno* op, io_sCard* cp)
{
  int sts;

  sts = open_device(local, op, cp);
  if (EVEN(sts))
    return sts;

  if (op->Options & pwr_mArduino_OptionsMask_ConnectionRequest) {
    sts = send_connect_request(local, op, cp);
    if (EVEN(sts))
      return sts;
  }

  sts = send_configuration(local, op, cp);
  if (EVEN(sts))
    return sts;

  return IO__SUCCESS;
}

static void add_checksum(void* buf)
{
  int i;
  unsigned char sum = 0;
  unsigned char* b = (unsigned char*)buf;

  b[0]++;
  for (i = 0; i < b[0] - 1; i++)
    sum ^= b[i];

  b[b[0] - 1] = sum;
}

static int check_checksum(void* buf)
{
  int i;
  unsigned char sum = 0;
  unsigned char* b = (unsigned char*)buf;

  for (i = 0; i < b[0] - 1; i++)
    sum ^= b[i];

  if (b[b[0] - 1] == sum)
    return 1;
  return 0;
}

static void get_tv(struct timeval* tv, float t)
{
  if (t < FLT_EPSILON) {
    tv->tv_sec = 1;
    tv->tv_usec = 0;
  } else {
    tv->tv_sec = t;
    tv->tv_usec = (t - (float)tv->tv_sec) * 1000000;
  }
}

static int receive(int fd, int id, ard_sMsg* rmsg, int size, float tmo,
    pwr_sClass_Arduino_Uno* op)
{
  fd_set rfd;
  struct timeval tv;
  int sts;
  int msize;
  int ret;

  if (op->Options & pwr_mArduino_OptionsMask_Checksum)
    size++;

  FD_ZERO(&rfd);
  FD_SET(fd, &rfd);
  while (1) {
    get_tv(&tv, tmo);
    sts = select(fd + 1, &rfd, NULL, NULL, &tv);
    if (sts == 0)
      return ARD__NOMSG;

    msize = 0;
    msize += read(fd, rmsg, 1);

    // logg( "Receive read");
    if (msize == 0)
      return ARD__NOMSG;

    while (msize < rmsg->size) {
      get_tv(&tv, tmo);
      sts = select(fd + 1, &rfd, NULL, NULL, &tv);
      if (sts == 0)
        return ARD__NOMSG;

      ret = read(fd, (char*)rmsg + msize, rmsg->size - msize);
      if (ret == 0)
        return ARD__NOMSG;

      msize += ret;

      // logg( "Receive read ++");
    }

    if (rmsg->type == ard_eMsgType_Debug) {
      int i;
      printf("Debug (id %d, size %d, type %d): ", rmsg->id, rmsg->size - 3,
          rmsg->type);
      for (i = 0; i < rmsg->size - 3; i++)
        printf("%u ", rmsg->data[i]);
      printf("\n");
    } else {
      if (rmsg->size == size + 3 && rmsg->id == id) {
        if (op->Options & pwr_mArduino_OptionsMask_Checksum) {
          if (!check_checksum(rmsg))
            return ARD__CHECKSUM;

          rmsg->size--;
        }
        return ARD__SUCCESS;
      }
    }
  }
  return ARD__NOMSG;
}

static int apoll(ard_sMsg* msg, io_sLocal* local, ard_eMsgType mtype,
    pwr_sClass_Arduino_Uno* op)
{
  int sts;

  local->PendingMsgType = mtype;
  if (mtype == ard_eMsgType_No)
    return 1;

  msg->size = 3;
  msg->id = local->IdCnt++;
  msg->type = mtype;

  // logg( "Poll Di");
  if (op->Options & pwr_mArduino_OptionsMask_Checksum)
    add_checksum(msg);

  sts = write(local->fd, msg, msg->size);
  local->DiPollId = msg->id;
  local->DiPendingPoll = 1;
  local->PendingMsgType = mtype;
  return sts;
}

static pwr_tStatus IoCardInit(
    io_tCtx ctx, io_sAgent* ap, io_sRack* rp, io_sCard* cp)
{
  io_sLocal* local;
  pwr_sClass_Arduino_Uno* op = (pwr_sClass_Arduino_Uno*)cp->op;
  unsigned int number, number_byte, number_bit;
  pwr_tStatus sts;
  int i;

  // fp = fopen( "/home/claes/ard.log", "w"); // Test

  local = (io_sLocal*)calloc(1, sizeof(io_sLocal));
  cp->Local = local;
  local->IdCnt = 1;

  for (i = 0; i < cp->ChanListSize; i++) {
    if (cp->chanlist[i].cop && cp->chanlist[i].sop
        && cp->chanlist[i].ChanClass == pwr_cClass_ChanDi) {
      number = ((pwr_sClass_ChanDi*)cp->chanlist[i].cop)->Number;
      number_byte = number / 8;
      number_bit = number % 8;
      if (number_byte >= D_MAX_SIZE) {
        errh_Error("IO Init Card '%s', max number exceeded", cp->Name);
        op->Status = pwr_eArduino_StatusEnum_DiConfigureError;
        return IO__INITFAIL;
      } else if (local->DChanList[number]) {
        errh_Error("IO Init Card '%s', number already configured", cp->Name);
        op->Status = pwr_eArduino_StatusEnum_DiConfigureError;
        return IO__INITFAIL;
      } else {
        if (local->DiSize < number_byte + 1)
          local->DiSize = number_byte + 1;
        local->DiMask[number_byte] |= 1 << number_bit;
        local->DChanList[number] = &cp->chanlist[i];
      }
    } else if (cp->chanlist[i].cop && cp->chanlist[i].sop
        && cp->chanlist[i].ChanClass == pwr_cClass_ChanDo) {
      number = ((pwr_sClass_ChanDo*)cp->chanlist[i].cop)->Number;
      number_byte = number / 8;
      number_bit = number % 8;
      if (number_byte >= D_MAX_SIZE) {
        errh_Error("IO Init Card '%s', max number exceeded", cp->Name);
        op->Status = pwr_eArduino_StatusEnum_DoConfigureError;
        return IO__INITFAIL;
      } else if (local->DChanList[number]) {
        errh_Error("IO Init Card '%s', number already configured", cp->Name);
        op->Status = pwr_eArduino_StatusEnum_DoConfigureError;
        return IO__INITFAIL;
      } else {
        if (local->DoSize < number_byte + 1)
          local->DoSize = number_byte + 1;
        local->DoMask[number_byte] |= 1 << number_bit;
        local->DChanList[number] = &cp->chanlist[i];
      }
    } else if (cp->chanlist[i].cop && cp->chanlist[i].sop
        && cp->chanlist[i].ChanClass == pwr_cClass_ChanAi) {
      number = ((pwr_sClass_ChanAi*)cp->chanlist[i].cop)->Number;
      number_byte = number / 8;
      number_bit = number % 8;
      if (number_byte >= AI_MAX_SIZE) {
        errh_Error("IO Init Card '%s', max number exceeded", cp->Name);
        op->Status = pwr_eArduino_StatusEnum_AiConfigureError;
        return IO__INITFAIL;
      } else if (local->AiChanList[number]) {
        errh_Error("IO Init Card '%s', number already configured", cp->Name);
        op->Status = pwr_eArduino_StatusEnum_AiConfigureError;
        return IO__INITFAIL;
      } else {
        if (local->AiSize < number_byte + 1)
          local->AiSize = number_byte + 1;
        local->AiMask[number_byte] |= 1 << number_bit;
        local->AiNum++;
        local->AiChanList[number] = &cp->chanlist[i];

        // Calculate conversion coefficients
        io_AiRangeToCoef(&cp->chanlist[i]);
      }
    } else if (cp->chanlist[i].cop && cp->chanlist[i].sop
        && cp->chanlist[i].ChanClass == pwr_cClass_ChanAo) {
      number = ((pwr_sClass_ChanAo*)cp->chanlist[i].cop)->Number;
      number_byte = number / 8;
      number_bit = number % 8;
      if (number_byte >= AO_MAX_SIZE) {
        errh_Error("IO Init Card '%s', max number exceeded", cp->Name);
        op->Status = pwr_eArduino_StatusEnum_AoConfigureError;
        return IO__INITFAIL;
      } else if (local->AoChanList[number]) {
        errh_Error("IO Init Card '%s', number already configured", cp->Name);
        op->Status = pwr_eArduino_StatusEnum_AoConfigureError;
        return IO__INITFAIL;
      } else {
        if (local->AoSize < number_byte + 1)
          local->AoSize = number_byte + 1;
        local->AoMask[number_byte] |= 1 << number_bit;
        local->AoChanList[number] = &cp->chanlist[i];
        local->AoNum++;

        // Calculate conversion coefficients
        io_AoRangeToCoef(&cp->chanlist[i]);
      }
    }
  }

  sts = open_and_connect(local, op, cp);
  if (EVEN(sts))
    return sts;

  errh_Info("Init of Arduino card '%s'", cp->Name);

  return IO__SUCCESS;
}

static pwr_tStatus IoCardClose(
    io_tCtx ctx, io_sAgent* ap, io_sRack* rp, io_sCard* cp)
{
  io_sLocal* local = cp->Local;

  close_device(local);
  free(cp->Local);

  // fclose(fp); //Test

  return IO__SUCCESS;
}

static pwr_tStatus IoCardRead(
    io_tCtx ctx, io_sAgent* ap, io_sRack* rp, io_sCard* cp)
{
  io_sLocal* local = cp->Local;
  pwr_sClass_Arduino_Uno* op = (pwr_sClass_Arduino_Uno*)cp->op;
  int i, j;
  unsigned int m;
  pwr_tUInt32 error_count = op->ErrorCount;
  int sts;
  int skip_ai;
  ard_eMsgType mtype;
  ard_sMsg msg;
  io_sChannel* chanp;

  if (local->Reopendev || local->Reconnect)
    return IO__SUCCESS;

  if (local->ReceiveWriteRespons) {
    local->ReceiveWriteRespons = 0;
  }

  if (local->AiSize) {
    skip_ai = 0;

    if (op->AiScanInterval > 1) {
      skip_ai = local->AiIntervalCnt;

      local->AiIntervalCnt++;
      if (local->AiIntervalCnt >= op->AiScanInterval)
        local->AiIntervalCnt = 0;
    }
  } else
    skip_ai = 1;

  if (local->DiSize && skip_ai)
    mtype = ard_eMsgType_DiRead;
  else if (local->DiSize && !skip_ai)
    mtype = ard_eMsgType_ReadAll;
  else if (!skip_ai)
    mtype = ard_eMsgType_AiRead;
  else
    mtype = ard_eMsgType_No;

  if (!local->DiPendingPoll)
    apoll(&msg, local, mtype, op);
  else
    mtype = local->PendingMsgType;

  local->DiPendingPoll = 0;

  if (mtype == ard_eMsgType_ReadAll) {
    // Both Ai and Di

    ard_sMsg rmsg;
    int sts;
    int i, j;
    unsigned char m;
    pwr_tInt32 ivalue;
    pwr_tFloat32 actvalue;

    sts = receive(local->fd, local->DiPollId, &rmsg,
        local->DiSize + local->AiNum * 2, op->Timeout, op);
    op->Status = sts;
    if (EVEN(sts)) {
      op->ErrorCount++;
      if (sts == ARD__NOMSG
          && op->Options & pwr_mArduino_OptionsMask_SerialPort) {
        local->Reconnect = 1;
      }
    } else {
      // printf( "Read: %u %u  (%d)\n", rmsg.data[0], rmsg.data[1], sts);

      for (i = 0; i < local->DiSize; i++) {
        for (j = 0; j < 8; j++) {
          m = 1 << j;
          if (local->DiMask[i] & m) {
            chanp = local->DChanList[i * 8 + j];
            pwr_sClass_ChanDi* cop = (pwr_sClass_ChanDi*)chanp->cop;

            if (cop->ConversionOn)
              *(pwr_tBoolean*)chanp->vbp = ((rmsg.data[i] & m) != 0);
          }
        }
      }
    }

    int ai_cnt = 0;
    for (i = 0; i < local->AiSize; i++) {
      for (j = 0; j < 8; j++) {
        m = 1 << j;
        if (local->AiMask[i] & m) {
          io_sChannel* chanp = local->AiChanList[i * 8 + j];
          pwr_sClass_ChanAi* cop = (pwr_sClass_ChanAi*)chanp->cop;
          pwr_sClass_Ai* sop = (pwr_sClass_Ai*)chanp->sop;

          if (cop->ConversionOn) {
            if (cop->CalculateNewCoef)
              // Request to calculate new coefficients
              io_AiRangeToCoef(chanp);

            ivalue = rmsg.data[local->DiSize + ai_cnt * 2] * 256
                + rmsg.data[local->DiSize + ai_cnt * 2 + 1];
            io_ConvertAi(cop, ivalue, &actvalue);

            // Filter
            if (sop->FilterType == 1 && sop->FilterAttribute[0] > 0
                && sop->FilterAttribute[0] > ctx->ScanTime) {
              actvalue = *(pwr_tFloat32*)chanp->vbp
                  + ctx->ScanTime / sop->FilterAttribute[0]
                      * (actvalue - *(pwr_tFloat32*)chanp->vbp);
            }

            *(pwr_tFloat32*)chanp->vbp = actvalue;
            sop->SigValue
                = cop->SigValPolyCoef1 * ivalue + cop->SigValPolyCoef0;
            sop->RawValue = ivalue;
          }
          ai_cnt++;
        }
      }
    }
  } else if (mtype == ard_eMsgType_DiRead) {
    // Only Di, no Ai

    ard_sMsg rmsg;
    int sts;
    int i, j;
    unsigned char m;

    sts = receive(
        local->fd, local->DiPollId, &rmsg, local->DiSize, op->Timeout, op);
    op->Status = sts;
    if (EVEN(sts)) {
      if (sts == ARD__NOMSG
          && op->Options & pwr_mArduino_OptionsMask_SerialPort) {
        local->Reconnect = 1;
      }
      op->ErrorCount++;
    } else {
      // printf( "Read: %u %u  (%d)\n", rmsg.data[0], rmsg.data[1], sts);

      for (i = 0; i < local->DiSize; i++) {
        for (j = 0; j < 8; j++) {
          m = 1 << j;
          if (local->DiMask[i] & m) {
            chanp = local->DChanList[i * 8 + j];
            pwr_sClass_ChanDi* cop = (pwr_sClass_ChanDi*)chanp->cop;

            if (cop->ConversionOn)
              *(pwr_tBoolean*)chanp->vbp = ((rmsg.data[i] & m) != 0);
          }
        }
      }
    }
  } else if (mtype == ard_eMsgType_AiRead) {
    // Only Ai, no Di

    if (!skip_ai) {
      ard_sMsg rmsg;
      pwr_tInt32 ivalue;
      pwr_tFloat32 actvalue;

      sts = receive(
          local->fd, local->DiPollId, &rmsg, local->AiNum * 2, op->Timeout, op);
      if (EVEN(sts)) {
      } else {
        int ai_cnt = 0;
        for (i = 0; i < local->AiSize; i++) {
          for (j = 0; j < 8; j++) {
            m = 1 << j;
            if (local->AiMask[i] & m) {
              io_sChannel* chanp = local->AiChanList[i * 8 + j];
              pwr_sClass_ChanAi* cop = (pwr_sClass_ChanAi*)chanp->cop;
              pwr_sClass_Ai* sop = (pwr_sClass_Ai*)chanp->sop;

              if (cop->ConversionOn) {
                if (cop->CalculateNewCoef)
                  // Request to calculate new coefficients
                  io_AiRangeToCoef(chanp);

                ivalue
                    = rmsg.data[ai_cnt * 2] * 256 + rmsg.data[ai_cnt * 2 + 1];
                io_ConvertAi(cop, ivalue, &actvalue);

                // Filter
                if (sop->FilterType == 1 && sop->FilterAttribute[0] > 0
                    && sop->FilterAttribute[0] > ctx->ScanTime) {
                  actvalue = *(pwr_tFloat32*)chanp->vbp
                      + ctx->ScanTime / sop->FilterAttribute[0]
                          * (actvalue - *(pwr_tFloat32*)chanp->vbp);
                }

                *(pwr_tFloat32*)chanp->vbp = actvalue;
                sop->SigValue
                    = cop->SigValPolyCoef1 * ivalue + cop->SigValPolyCoef0;
                sop->RawValue = ivalue;
              }
              ai_cnt++;
            }
          }
        }
      }
    }
  }

  if (op->ErrorCount >= op->ErrorSoftLimit
      && error_count < op->ErrorSoftLimit) {
    errh_Warning("IO Card ErrorSoftLimit reached, '%s'", cp->Name);
    ctx->IOHandler->CardErrorSoftLimit = 1;
    ctx->IOHandler->ErrorSoftLimitObject = cdh_ObjidToAref(cp->Objid);
  }
  if (op->ErrorCount >= op->ErrorHardLimit) {
    errh_Error("IO Card ErrorHardLimit reached '%s', IO stopped", cp->Name);
    ctx->Node->EmergBreakTrue = 1;
    ctx->IOHandler->CardErrorHardLimit = 1;
    ctx->IOHandler->ErrorHardLimitObject = cdh_ObjidToAref(cp->Objid);
    return IO__ERRDEVICE;
  }

  return IO__SUCCESS;
}

static pwr_tStatus IoCardWrite(
    io_tCtx ctx, io_sAgent* ap, io_sRack* rp, io_sCard* cp)
{
  io_sLocal* local = cp->Local;
  pwr_sClass_Arduino_Uno* op = (pwr_sClass_Arduino_Uno*)cp->op;
  int i, j;
  unsigned char m;
  pwr_tUInt32 error_count = op->ErrorCount;
  ard_sMsg msg;
  int sts = 0;
  int skip_ao;
  io_sChannel* chanp;

  if (local->Reopendev) {
    local->ReopendevCnt++;
    if (local->ReopendevCnt * ctx->ScanTime > 5.0) {
      close_device(local);
      sts = open_and_connect(local, op, cp);
      if (EVEN(sts)) {
        local->Reopendev = 1;
        local->ReopendevCnt = 0;
        return IO__SUCCESS;
      } else
        local->Reopendev = 0;
    } else
      return IO__SUCCESS;
  } else if (local->Reconnect) {
    local->ReconnectCnt++;
    if (local->ReconnectCnt * ctx->ScanTime > 5.0) {
      if (op->Options & pwr_mArduino_OptionsMask_ConnectionRequest) {
        sts = send_connect_request(local, op, cp);
        if (EVEN(sts)) {
          local->Reconnect = 1;
          local->ReconnectCnt = 0;
          return IO__SUCCESS;
        } else
          local->Reconnect = 0;
      } else
        local->Reconnect = 0;
    } else
      return IO__SUCCESS;
  }

  if (local->AoSize) {
    skip_ao = 0;

    if (op->AoScanInterval > 1) {
      skip_ao = local->AoIntervalCnt;

      local->AoIntervalCnt++;
      if (local->AoIntervalCnt >= op->AoScanInterval)
        local->AoIntervalCnt = 0;
    }
  } else
    skip_ao = 1;

  if (local->DoSize && skip_ao) {
    memset(&msg, 0, sizeof(msg));
    msg.size = local->DoSize + 3;
    msg.id = local->IdCnt++;
    msg.type = ard_eMsgType_DoWrite;

    for (i = 0; i < local->DoSize; i++) {
      for (j = 0; j < 8; j++) {
        m = 1 << j;
        if (local->DoMask[i] & m) {
          chanp = local->DChanList[i * 8 + j];
          pwr_sClass_ChanDo* cop = (pwr_sClass_ChanDo*)chanp->cop;
          pwr_tInt32 do_actval;

          if (cop->TestOn != 0)
            do_actval = cop->TestValue;
          else
            do_actval = *(pwr_tInt32*)chanp->vbp;

          if (do_actval)
            msg.data[i] |= m;
        }
      }
    }

    // logg( "Write Do");
    if (op->Options & pwr_mArduino_OptionsMask_Checksum)
      add_checksum(&msg);

    sts = write(local->fd, &msg, msg.size);
    if (sts > 0) {
      local->ReceiveWriteRespons = 1;
      local->WriteId = msg.id;
    }
  } else if (local->AoSize && !local->DoSize) {
    if (!skip_ao) {
      ard_sMsg msg;
      int value;

      memset(&msg, 0, sizeof(msg));
      if (op->Options & pwr_mArduino_OptionsMask_Ao16Bit)
        msg.size = local->AoNum * 2 + 3;
      else
        msg.size = local->AoNum + 3;
      msg.id = local->IdCnt++;
      msg.type = ard_eMsgType_AoWrite;

      int ao_cnt = 0;
      for (i = 0; i < local->AoSize; i++) {
        for (j = 0; j < 8; j++) {
          m = 1 << j;
          if (local->AoMask[i] & m) {
            io_sChannel* chanp = local->AoChanList[i * 8 + j];
            pwr_sClass_ChanAo* cop = (pwr_sClass_ChanAo*)chanp->cop;
            pwr_sClass_Ao* sop = (pwr_sClass_Ao*)chanp->sop;

            if (cop->CalculateNewCoef)
              // Request to calculate new coefficients
              io_AoRangeToCoef(chanp);

            if (cop->TestOn)
              value = cop->TestValue * cop->OutPolyCoef1 + cop->OutPolyCoef0
                  + 0.49;
            else
              value = *(pwr_tFloat32*)chanp->vbp * cop->OutPolyCoef1
                  + cop->OutPolyCoef0 + 0.49;

            if (op->Options & pwr_mArduino_OptionsMask_Ao16Bit) {
              if (value < 0)
                value = 0;
              else if (value > 65535)
                value = 65535;

              msg.data[ao_cnt * 2] = value / 256;
              msg.data[ao_cnt * 2 + 1] = value % 256;
            } else {
              if (value < 0)
                value = 0;
              else if (value > 255)
                value = 255;

              msg.data[ao_cnt] = value;
            }

            sop->SigValue = cop->SigValPolyCoef1 * *(pwr_tFloat32*)chanp->vbp
                + cop->SigValPolyCoef0;
            sop->RawValue = value;
            ao_cnt++;
          }
        }
      }
      // logg( "Write Ao");

      if (op->Options & pwr_mArduino_OptionsMask_Checksum)
        add_checksum(&msg);

      sts = write(local->fd, &msg, msg.size);
      if (sts > 0) {
        local->ReceiveWriteRespons = 1;
        local->WriteId = msg.id;
      }
    }
  } else if (local->DoSize && !skip_ao) {
    memset(&msg, 0, sizeof(msg));
    if (op->Options & pwr_mArduino_OptionsMask_Ao16Bit)
      msg.size = local->DoSize + local->AoNum * 2 + 3;
    else
      msg.size = local->DoSize + local->AoNum + 3;
    msg.id = local->IdCnt++;
    msg.type = ard_eMsgType_WriteAll;

    for (i = 0; i < local->DoSize; i++) {
      for (j = 0; j < 8; j++) {
        m = 1 << j;
        if (local->DoMask[i] & m) {
          chanp = local->DChanList[i * 8 + j];
          pwr_sClass_ChanDo* cop = (pwr_sClass_ChanDo*)chanp->cop;
          pwr_tInt32 do_actval;

          if (cop->TestOn != 0)
            do_actval = cop->TestValue;
          else
            do_actval = *(pwr_tInt32*)chanp->vbp;

          if (do_actval)
            msg.data[i] |= m;
        }
      }
    }

    int value;

    int ao_cnt = 0;
    for (i = 0; i < local->AoSize; i++) {
      for (j = 0; j < 8; j++) {
        m = 1 << j;
        if (local->AoMask[i] & m) {
          io_sChannel* chanp = local->AoChanList[i * 8 + j];
          pwr_sClass_ChanAo* cop = (pwr_sClass_ChanAo*)chanp->cop;
          pwr_sClass_Ao* sop = (pwr_sClass_Ao*)chanp->sop;

          if (cop->CalculateNewCoef)
            // Request to calculate new coefficients
            io_AoRangeToCoef(chanp);

          if (cop->TestOn)
            value
                = cop->TestValue * cop->OutPolyCoef1 + cop->OutPolyCoef0 + 0.49;
          else
            value = *(pwr_tFloat32*)chanp->vbp * cop->OutPolyCoef1
                + cop->OutPolyCoef0 + 0.49;

          if (op->Options & pwr_mArduino_OptionsMask_Ao16Bit) {
            if (value < 0)
              value = 0;
            else if (value > 65535)
              value = 65535;

            msg.data[local->DoSize + ao_cnt * 2] = value / 256;
            msg.data[local->DoSize + ao_cnt * 2 + 1] = value % 256;
          } else {
            if (value < 0)
              value = 0;
            else if (value > 255)
              value = 255;

            msg.data[local->DoSize + ao_cnt] = value;
          }

          if (value < 0)
            value = 0;
          else if (value > 255)
            value = 255;

          sop->SigValue = cop->SigValPolyCoef1 * *(pwr_tFloat32*)chanp->vbp
              + cop->SigValPolyCoef0;
          sop->RawValue = value;
          ao_cnt++;
        }
      }
    }
    // logg( "Write All");

    if (op->Options & pwr_mArduino_OptionsMask_Checksum)
      add_checksum(&msg);

    sts = write(local->fd, &msg, msg.size);
    if (sts > 0) {
      local->ReceiveWriteRespons = 1;
      local->WriteId = msg.id;
    }
  }
  if (sts < 0) {
    /* Connection lost, open device again */
    local->Reopendev = 1;
    local->ReopendevCnt = 0;
    return IO__SUCCESS;
  }

  if (op->ErrorCount >= op->ErrorSoftLimit
      && error_count < op->ErrorSoftLimit) {
    errh_Warning("IO Card ErrorSoftLimit reached, '%s'", cp->Name);
    ctx->IOHandler->CardErrorSoftLimit = 1;
    ctx->IOHandler->ErrorSoftLimitObject = cdh_ObjidToAref(cp->Objid);
  }
  if (op->ErrorCount >= op->ErrorHardLimit) {
    errh_Error("IO Card ErrorHardLimit reached '%s', IO stopped", cp->Name);
    ctx->Node->EmergBreakTrue = 1;
    ctx->IOHandler->CardErrorHardLimit = 1;
    ctx->IOHandler->ErrorHardLimitObject = cdh_ObjidToAref(cp->Objid);
    return IO__ERRDEVICE;
  }

  if (op->Options & pwr_mArduino_OptionsMask_OptimizedDiPoll) {
    ard_sMsg msg;
    int skip_ai;
    ard_eMsgType mtype;

    if (local->AiSize) {
      skip_ai = 0;

      if (op->AiScanInterval > 1)
        skip_ai = local->AiIntervalCnt;
    } else
      skip_ai = 1;

    if (local->DiSize && skip_ai)
      mtype = ard_eMsgType_DiRead;
    else if (local->DiSize && !skip_ai)
      mtype = ard_eMsgType_ReadAll;
    else if (!skip_ai)
      mtype = ard_eMsgType_AiRead;
    else
      mtype = ard_eMsgType_No;

    apoll(&msg, local, mtype, op);
  }

  return IO__SUCCESS;
}

/*  Every method should be registred here. */

pwr_dExport pwr_BindIoMethods(Arduino_Uno) = { pwr_BindIoMethod(IoCardInit),
  pwr_BindIoMethod(IoCardClose), pwr_BindIoMethod(IoCardRead),
  pwr_BindIoMethod(IoCardWrite), pwr_NullMethod };
