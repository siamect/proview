/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2013 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

/* rt_io_m_arduino_uno.c -- I/O methods for class Arduino_Uno. */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <float.h>

#include <termios.h>

#include "pwr.h"
#include "pwr_basecomponentclasses.h"
#include "pwr_otherioclasses.h"
#include "co_time.h"
#include "rt_io_base.h"
#include "rt_io_card_init.h"
#include "rt_io_card_close.h"
#include "rt_io_card_read.h"
#include "rt_io_card_write.h"
#include "rt_io_msg.h"

#define D_MAX_SIZE 10
#define AI_MAX_SIZE 4
#define AO_MAX_SIZE 4

typedef enum {
  ard_eMsgType_No 	= 0,
  ard_eMsgType_DoWrite 	= 1,
  ard_eMsgType_DiRead 	= 2,
  ard_eMsgType_AiRead 	= 3,
  ard_eMsgType_AoWrite 	= 4,
  ard_eMsgType_Configure = 5,
  ard_eMsgType_Status 	= 6,
  ard_eMsgType_Debug 	= 7,
  ard_eMsgType_WriteAll = 8,
  ard_eMsgType_ReadAll	= 9,
  ard_eMsgType_ConnectReq = 10,
  ard_eMsgType_ConnectRes = 11
} ard_eMsgType;

typedef struct {
  pwr_tTime ErrTime;
  int fd;
  int DiSize;
  int DoSize;
  int AiSize;
  int AoSize;
  int AiNum;
  int AoNum;
  unsigned char DiMask[D_MAX_SIZE];
  unsigned char DoMask[D_MAX_SIZE];
  unsigned char AiMask[AI_MAX_SIZE];
  unsigned char AoMask[AO_MAX_SIZE];
  int IdCnt;
  int DiPollId;
  int DiPendingPoll;
  ard_eMsgType PendingMsgType;
  int ReceiveWriteRespons;
  int WriteId;
  int AiIntervalCnt;
  int AoIntervalCnt;
  int Reopendev;
  int ReopendevCnt;
  int Reconnect;
  int ReconnectCnt;
  int VersionMajor;
  int VersionMinor;
  io_sChannel *DChanList[D_MAX_SIZE * 8];
  io_sChannel *AiChanList[AI_MAX_SIZE * 8];
  io_sChannel *AoChanList[AO_MAX_SIZE * 8];
} io_sLocal;

// static FILE *fp;

#if 0
static void logg( const char *str)
{
  pwr_tTime t;
  char timstr[40];

  time_GetTime( &t);
  time_AtoAscii( 0, time_eFormat_Time, timstr, sizeof(timstr));
  timstr[9] = 0;

  fprintf( fp, "%s%04lld %s\n", timstr, t.tv_nsec/100000, str);
}
#endif

#define ARD__SUCCESS 1
#define ARD__DICONFIG 2
#define ARD__DOCONFIG 4
#define ARD__AICONFIG 6
#define ARD__AOCONFIG 8
#define ARD__COMMERROR 10
#define ARD__MSGSIZE 12
#define ARD__NOMSG 14
#define ARD__CHECKSUM 16

typedef struct {
  unsigned char size __attribute__ ((aligned(1)));
  unsigned char id __attribute__ ((aligned(1)));
  unsigned char type __attribute__ ((aligned(1)));
  unsigned char data[100] __attribute__ ((aligned(1)));
} ard_sMsg;

static void add_checksum( void *buf);
static int check_checksum( void *buf);
static int receive( int fd, int id, ard_sMsg *rmsg, int size, float tmo, pwr_sClass_Arduino_Uno *op);

static int close_device( io_sLocal *local)
{
  close( local->fd);
  return IO__SUCCESS;
}

static int open_device( io_sLocal *local, pwr_sClass_Arduino_Uno *op, io_sCard *cp)
{
  struct termios tty_attributes;
  int sts;

  // Open device
  local->fd = open( op->Device, O_RDWR | O_NDELAY | O_NOCTTY);
  if ( local->fd == -1) {
    errh_Error( "IO Init Card '%s', unable to open device %s", cp->Name, op->Device);
    op->Status = pwr_eArduino_StatusEnum_NoSuchDevice;
    return IO__INITFAIL;
  }

  tcgetattr( local->fd, &tty_attributes); 
#if defined OS_LINUX
  tty_attributes.c_cflag &= ~CBAUD;  //maska bort all hastighet
#endif
  switch( op->BaudRate) {
    case 300:
      tty_attributes.c_cflag |= B300;
      break;
    case 1200:
      tty_attributes.c_cflag |= B1200;
      break;
    case 2400:
      tty_attributes.c_cflag |= B2400;
      break;
    case 4800:
      tty_attributes.c_cflag |= B4800;
      break;
    case 9600:
      tty_attributes.c_cflag |= B9600;
      break;
    case 19200:
      tty_attributes.c_cflag |= B19200;
      break;
    case 38400:
      tty_attributes.c_cflag |= B38400;
      break;
    case 57600:
      tty_attributes.c_cflag |= B57600;
      break;
    case 115200:
      tty_attributes.c_cflag |= B115200;
      break;
    default:
      tty_attributes.c_cflag |= B9600;
      break;
  }

  tty_attributes.c_iflag &= ~(BRKINT | ICRNL | IMAXBEL);
  tty_attributes.c_oflag &= ~(OPOST | ONLCR);
  tty_attributes.c_lflag &= ~(ISIG | ICANON | IEXTEN | ECHO | ECHOE | ECHOK | ECHOCTL | ECHOKE);
  tty_attributes.c_cc[VMIN] = 1;
  tty_attributes.c_cc[VTIME] = 0;
  tty_attributes.c_cc[VEOF] = 1;
  sts = tcsetattr( local->fd, TCSANOW, &tty_attributes);
  if ( sts < 0) {
    errh_Error( "IO Init Card '%s', unable to set baud rate on device %s", cp->Name, op->Device);
    op->Status = pwr_eArduino_StatusEnum_DeviceSetupError;
    return IO__INITFAIL;
  }

  tcflush( local->fd, TCIOFLUSH);

  sleep(5);

  return IO__SUCCESS;
}

static int send_configuration( io_sLocal *local, pwr_sClass_Arduino_Uno *op, io_sCard *cp)
{
  unsigned char wdg;
  int i;
  int sts;

  // Configure Watchdog
  if ( op->WatchdogTime == 0)
    wdg = 0;
  else if ( op->WatchdogTime > 255)
    wdg = 255;
  else {
    wdg = op->WatchdogTime * 10;
    if ( wdg < 1)
      wdg = 1;    
  }  

  // Send config message
  ard_sMsg msg, rmsg;
  int offs = 0;

  msg.size = 3;
  msg.id = local->IdCnt++;
  msg.type = ard_eMsgType_Configure;

  msg.data[offs++] = wdg;

  msg.data[offs++] = local->DiSize;
  for ( i = 0; i < local->DiSize; i++)
    msg.data[offs++] = local->DiMask[i];

  msg.data[offs++] = local->DoSize;
  for ( i = 0; i < local->DoSize; i++)
    msg.data[offs++] = local->DoMask[i];

  msg.data[offs++] = local->AiSize;
  for ( i = 0; i < local->AiSize; i++)
    msg.data[offs++] = local->AiMask[i];

  msg.data[offs++] = local->AoSize;
  for ( i = 0; i < local->AoSize; i++)
    msg.data[offs++] = local->AoMask[i];

  msg.size += offs;

  printf( "Config (size=%d, id= %d): ", offs, msg.id);
  for ( i = 0; i < offs; i++)
    printf( "%u ", msg.data[i]);
  printf( "\n");

  if ( op->Options & pwr_mArduino_OptionsMask_Checksum)
    add_checksum( &msg);

  sts = write( local->fd, &msg, msg.size);
      
  sts = receive( local->fd, msg.id, &rmsg, 1, op->Timeout, op);
  if ( sts & 1) {
    op->Status = rmsg.data[0];    
  }
  else {
    errh_Error( "IO Init Card '%s', config error: %d", cp->Name, sts);
    op->Status = sts;
    if ( sts == pwr_eArduino_StatusEnum_NoMessage)
      sts = pwr_eArduino_StatusEnum_ConnectionTimeout;
    return IO__INITFAIL;
    printf( "Config read error %d\n", sts);
  }

  return IO__SUCCESS;
}

static int send_connect_request( io_sLocal *local, pwr_sClass_Arduino_Uno *op, io_sCard *cp)
{
  int sts;

  // Send connect request
  ard_sMsg msg, rmsg;

  msg.size = 3;
  msg.id = local->IdCnt++;
  msg.type = ard_eMsgType_ConnectReq;

  if ( op->Options & pwr_mArduino_OptionsMask_Checksum)
    add_checksum( &msg);

  sts = write( local->fd, &msg, msg.size);
      
  sts = receive( local->fd, msg.id, &rmsg, 23, op->Timeout, op);
  if ( sts & 1) {
    if ( rmsg.type != ard_eMsgType_ConnectRes)
      return IO__INITFAIL;

    op->Status = rmsg.data[0];
    local->VersionMajor = rmsg.data[1];
    local->VersionMinor = rmsg.data[2];
    snprintf( op->FirmwareVersion, sizeof(op->FirmwareVersion), "%s", 
	      (char *)&rmsg.data[3]);
  }
  else {
    return IO__INITFAIL;
  }

  return IO__SUCCESS;
}

static int open_and_connect( io_sLocal *local, pwr_sClass_Arduino_Uno *op, io_sCard *cp)
{
  int sts;

  sts = open_device( local, op, cp);
  if ( EVEN(sts)) return sts;

  if ( op->Options & pwr_mArduino_OptionsMask_ConnectionRequest) {
    sts = send_connect_request( local, op, cp);
    if ( EVEN(sts)) return sts;
  }

  sts = send_configuration( local, op, cp);
  if ( EVEN(sts)) return sts;
  
  return IO__SUCCESS;
}

static void add_checksum( void *buf)
{
  int i;
  unsigned char sum = 0;
  unsigned char *b = (unsigned char *)buf;

  b[0]++;
  for ( i = 0; i < b[0] - 1; i++)
    sum ^= b[i];

  b[b[0]-1] = sum;
}

static int check_checksum( void *buf)
{
  int i;
  unsigned char sum = 0;
  unsigned char *b = (unsigned char *)buf;

  for ( i = 0; i < b[0] - 1; i++)
    sum ^= b[i];

  if ( b[b[0]-1] == sum)
    return 1;
  return 0;
}

static void get_tv(struct timeval *tv, float t)
{
  if ( t < FLT_EPSILON) {
    tv->tv_sec = 1;
    tv->tv_usec = 0;
  }
  else {
    tv->tv_sec = t;
    tv->tv_usec = (t-(float)tv->tv_sec) * 1000000;
  }
}

static int receive( int fd, int id, ard_sMsg *rmsg, int size, float tmo, pwr_sClass_Arduino_Uno *op)
{
  fd_set rfd;
  struct timeval tv;
  int sts;
  int msize;
  int ret;

  if ( op->Options & pwr_mArduino_OptionsMask_Checksum)
    size++;

  FD_ZERO(&rfd);
  FD_SET(fd, &rfd);
  while ( 1) {
    get_tv( &tv, tmo);
    sts = select(fd+1, &rfd, NULL, NULL, &tv);
    if ( sts == 0) return ARD__NOMSG;
    
    msize = 0;
    msize += read( fd, rmsg, 1);

    // logg( "Receive read");
    if ( msize == 0) return ARD__NOMSG;

    while ( msize < rmsg->size) {
      get_tv( &tv, tmo);
      sts = select(fd+1, &rfd, NULL, NULL, &tv);
      if ( sts == 0) return ARD__NOMSG;

      ret = read( fd, (char *)rmsg + msize, rmsg->size - msize);
      if ( ret == 0) return ARD__NOMSG;

      msize += ret;

      // logg( "Receive read ++");

    }

    if ( rmsg->type == ard_eMsgType_Debug) {
      int i;
      printf( "Debug (id %d, size %d, type %d): ", rmsg->id, rmsg->size - 3,
	      rmsg->type);
      for ( i = 0; i < rmsg->size - 3; i++)
	printf( "%u ", rmsg->data[i]);
      printf( "\n");
    }
    else {
      if ( rmsg->size == size + 3 && rmsg->id == id) {
	if ( op->Options & pwr_mArduino_OptionsMask_Checksum) {
	  if ( !check_checksum( rmsg))
	    return ARD__CHECKSUM;
	     
	  rmsg->size--;
	}
	return ARD__SUCCESS;
      }
    }
  }
  return ARD__NOMSG;
}

static int apoll( ard_sMsg *msg, io_sLocal *local, ard_eMsgType mtype, pwr_sClass_Arduino_Uno *op)
{
  int sts;

  local->PendingMsgType = mtype;
  if ( mtype == ard_eMsgType_No)
    return 1;

  msg->size = 3;
  msg->id = local->IdCnt++;
  msg->type = mtype;

  // logg( "Poll Di");
  if ( op->Options & pwr_mArduino_OptionsMask_Checksum)
    add_checksum( msg);

  sts = write( local->fd, msg, msg->size);
  local->DiPollId = msg->id;
  local->DiPendingPoll = 1;
  local->PendingMsgType = mtype;
  return sts;
}      


static pwr_tStatus IoCardInit( io_tCtx ctx,
			       io_sAgent *ap,
			       io_sRack *rp,
			       io_sCard *cp)
{
  io_sLocal *local;
  pwr_sClass_Arduino_Uno *op = (pwr_sClass_Arduino_Uno *)cp->op;
  unsigned int number, number_byte, number_bit;
  pwr_tStatus sts;
  int i;

  // fp = fopen( "/home/claes/ard.log", "w"); // Test

  local = (io_sLocal *) calloc( 1, sizeof(io_sLocal));
  cp->Local = local;
  local->IdCnt = 1;

  for ( i = 0; i < cp->ChanListSize; i++) {
    if ( cp->chanlist[i].cop && 
	 cp->chanlist[i].sop && 
	 cp->chanlist[i].ChanClass == pwr_cClass_ChanDi) {
      number = ((pwr_sClass_ChanDi *)cp->chanlist[i].cop)->Number;
      number_byte = number / 8;
      number_bit = number % 8;
      if ( number_byte >= D_MAX_SIZE) {
	errh_Error( "IO Init Card '%s', max number exceeded", cp->Name);
	op->Status = pwr_eArduino_StatusEnum_DiConfigureError;
	return IO__INITFAIL;
      }
      else if ( local->DChanList[number]) {
	errh_Error( "IO Init Card '%s', number already configured", cp->Name);
	op->Status = pwr_eArduino_StatusEnum_DiConfigureError;
	return IO__INITFAIL;
      }
      else {
	if ( local->DiSize < number_byte + 1)
	  local->DiSize = number_byte + 1;
	local->DiMask[number_byte] |= 1 << number_bit;
	local->DChanList[number] = &cp->chanlist[i];
      }
    }
    else if ( cp->chanlist[i].cop && 
	      cp->chanlist[i].sop && 
	      cp->chanlist[i].ChanClass == pwr_cClass_ChanDo) {
      number = ((pwr_sClass_ChanDo *)cp->chanlist[i].cop)->Number;
      number_byte = number / 8;
      number_bit = number % 8;
      if ( number_byte >= D_MAX_SIZE) {
	errh_Error( "IO Init Card '%s', max number exceeded", cp->Name);
	op->Status = pwr_eArduino_StatusEnum_DoConfigureError;
	return IO__INITFAIL;
      }
      else if ( local->DChanList[number]) {
	errh_Error( "IO Init Card '%s', number already configured", cp->Name);
	op->Status = pwr_eArduino_StatusEnum_DoConfigureError;
	return IO__INITFAIL;
      }
      else {
	if ( local->DoSize < number_byte + 1)
	  local->DoSize = number_byte + 1;
	local->DoMask[number_byte] |= 1 << number_bit;
	local->DChanList[number] = &cp->chanlist[i];
      }
    }
    else if ( cp->chanlist[i].cop && 
	      cp->chanlist[i].sop && 
	      cp->chanlist[i].ChanClass == pwr_cClass_ChanAi) {
      number = ((pwr_sClass_ChanAi *)cp->chanlist[i].cop)->Number;
      number_byte = number / 8;
      number_bit = number % 8;
      if ( number_byte >= AI_MAX_SIZE) {
	errh_Error( "IO Init Card '%s', max number exceeded", cp->Name);
	op->Status = pwr_eArduino_StatusEnum_AiConfigureError;
	return IO__INITFAIL;
      }
      else if ( local->AiChanList[number]) {
	errh_Error( "IO Init Card '%s', number already configured", cp->Name);
	op->Status = pwr_eArduino_StatusEnum_AiConfigureError;
	return IO__INITFAIL;
      }
      else {
	if ( local->AiSize < number_byte + 1)
	  local->AiSize = number_byte + 1;
	local->AiMask[number_byte] |= 1 << number_bit;
	local->AiNum++;
	local->AiChanList[number] = &cp->chanlist[i];

	// Calculate conversion coefficients
	io_AiRangeToCoef( &cp->chanlist[i]);
      }
    }
    else if ( cp->chanlist[i].cop && 
	      cp->chanlist[i].sop && 
	      cp->chanlist[i].ChanClass == pwr_cClass_ChanAo) {
      number = ((pwr_sClass_ChanAo *)cp->chanlist[i].cop)->Number;
      number_byte = number / 8;
      number_bit = number % 8;
      if ( number_byte >= AO_MAX_SIZE) {
	errh_Error( "IO Init Card '%s', max number exceeded", cp->Name);
	op->Status = pwr_eArduino_StatusEnum_AoConfigureError;
	return IO__INITFAIL;
      }
      else if ( local->AoChanList[number]) {
	errh_Error( "IO Init Card '%s', number already configured", cp->Name);
	op->Status = pwr_eArduino_StatusEnum_AoConfigureError;
	return IO__INITFAIL;
      }
      else {
	if ( local->AoSize < number_byte + 1)
	  local->AoSize = number_byte + 1;
	local->AoMask[number_byte] |= 1 << number_bit;
	local->AoChanList[number] = &cp->chanlist[i];
	local->AoNum++;

	// Calculate conversion coefficients
	io_AoRangeToCoef( &cp->chanlist[i]);
      }
    }
  }

  sts = open_and_connect( local, op, cp);
  if ( EVEN(sts)) return sts;

  errh_Info( "Init of Arduino card '%s'", cp->Name);

  return IO__SUCCESS;
}

static pwr_tStatus IoCardClose( io_tCtx ctx,
			        io_sAgent *ap,
			        io_sRack *rp,
			        io_sCard *cp)
{
  io_sLocal *local = cp->Local;

  close_device( local);
  free( cp->Local);

  // fclose(fp); //Test

  return IO__SUCCESS;
}

static pwr_tStatus IoCardRead( io_tCtx ctx,
			       io_sAgent *ap,
			       io_sRack	*rp,
			       io_sCard	*cp)
{
  io_sLocal *local = cp->Local;
  pwr_sClass_Arduino_Uno *op = (pwr_sClass_Arduino_Uno *)cp->op;
  int i, j;
  unsigned int m;
  pwr_tUInt32 error_count = op->ErrorCount;
  int sts;
  int skip_ai;
  ard_eMsgType mtype;
  ard_sMsg msg;
  io_sChannel *chanp;
 
  if ( local->Reopendev || local->Reconnect)
    return IO__SUCCESS;

  if ( local->ReceiveWriteRespons) {
#if 0
    // Receive response status from last write
    ard_sMsg rmsg;

    sts = receive( local->fd, local->WriteId, &rmsg, 1, op->Timeout, op);
    if ( EVEN(sts))
      op->ErrorCount++;
    else {
      op->Status = rmsg.data[0];
      if ( EVEN(op->Status))
	op->ErrorCount++;
    }    
#endif
    local->ReceiveWriteRespons = 0;
  }

  if ( local->AiSize) {
    skip_ai = 0;

    if ( op->AiScanInterval > 1) {
      skip_ai = local->AiIntervalCnt;

      local->AiIntervalCnt++;
      if ( local->AiIntervalCnt >= op->AiScanInterval)
	local->AiIntervalCnt = 0;
    }
  }
  else
    skip_ai = 1;

  if ( local->DiSize && skip_ai)
    mtype = ard_eMsgType_DiRead;
  else if ( local->DiSize && !skip_ai)
    mtype = ard_eMsgType_ReadAll;
  else if ( !skip_ai)
    mtype = ard_eMsgType_AiRead;
  else
    mtype = ard_eMsgType_No;

  if ( !local->DiPendingPoll)
    apoll( &msg, local, mtype, op);
  else
    mtype = local->PendingMsgType;

  local->DiPendingPoll = 0;  

  if ( mtype == ard_eMsgType_ReadAll ) {
    // Both Ai and Di

    ard_sMsg rmsg;
    int sts;
    int i, j;
    unsigned char m;
    pwr_tInt32 ivalue;
    pwr_tFloat32 actvalue;


    sts = receive( local->fd, local->DiPollId, &rmsg, local->DiSize + local->AiNum * 2,
		   op->Timeout, op);
    op->Status = sts;
    if ( EVEN(sts)) {
      op->ErrorCount++;
      if ( sts == ARD__NOMSG &&
	   op->Options & pwr_mArduino_OptionsMask_SerialPort) {
	local->Reconnect = 1;
      }
    }
    else {
      // printf( "Read: %u %u  (%d)\n", rmsg.data[0], rmsg.data[1], sts);

      for ( i = 0; i < local->DiSize; i++) {
	for ( j = 0; j < 8; j++) {
	  m = 1 << j;
	  if ( local->DiMask[i] & m) {
	    chanp = local->DChanList[i*8+j];
	    pwr_sClass_ChanDi *cop = (pwr_sClass_ChanDi *) chanp->cop;

	    if ( cop->ConversionOn)
	      *(pwr_tBoolean *)chanp->vbp = ((rmsg.data[i] & m) != 0);
	  }
	}
      }
    }

    int ai_cnt = 0;
    for ( i = 0; i < local->AiSize; i++) {
      for ( j = 0; j < 8; j++) {
	m = 1 << j;
	if ( local->AiMask[i] & m) {
	  io_sChannel *chanp = local->AiChanList[i*8+j];
	  pwr_sClass_ChanAi *cop = (pwr_sClass_ChanAi *)chanp->cop;
	  pwr_sClass_Ai *sop = (pwr_sClass_Ai *)chanp->sop;
	  
	  if ( cop->ConversionOn) {
	    if ( cop->CalculateNewCoef)
	      // Request to calculate new coefficients
	      io_AiRangeToCoef( chanp);
	      
	    ivalue = rmsg.data[local->DiSize + ai_cnt*2] * 256 + 
	      rmsg.data[local->DiSize+ai_cnt*2 + 1];
	    io_ConvertAi( cop, ivalue, &actvalue);
	  
	    // Filter
	    if ( sop->FilterType == 1 &&
		 sop->FilterAttribute[0] > 0 &&
		 sop->FilterAttribute[0] > ctx->ScanTime) {
	      actvalue = *(pwr_tFloat32 *)chanp->vbp + ctx->ScanTime / sop->FilterAttribute[0] *
		(actvalue - *(pwr_tFloat32 *)chanp->vbp);
	    }
	      
	    *(pwr_tFloat32 *)chanp->vbp = actvalue;
	    sop->SigValue = cop->SigValPolyCoef1 * ivalue + cop->SigValPolyCoef0;
	    sop->RawValue = ivalue;
	  }
	  ai_cnt++;
	}	    
      }
    }
  }
  else if ( mtype == ard_eMsgType_DiRead) {
    // Only Di, no Ai

    ard_sMsg rmsg;
    int sts;
    int i, j;
    unsigned char m;

    sts = receive( local->fd, local->DiPollId, &rmsg, local->DiSize, op->Timeout, op);
    op->Status = sts;
    if ( EVEN(sts)) {
      if ( sts == ARD__NOMSG &&
	   op->Options & pwr_mArduino_OptionsMask_SerialPort) {
	local->Reconnect = 1;
      }
      op->ErrorCount++;
    }
    else {
      // printf( "Read: %u %u  (%d)\n", rmsg.data[0], rmsg.data[1], sts);

      for ( i = 0; i < local->DiSize; i++) {
	for ( j = 0; j < 8; j++) {
	  m = 1 << j;
	  if ( local->DiMask[i] & m) {
	    chanp = local->DChanList[i*8+j];
	    pwr_sClass_ChanDi *cop = (pwr_sClass_ChanDi *) chanp->cop;

	    if ( cop->ConversionOn)
	      *(pwr_tBoolean *)chanp->vbp = ((rmsg.data[i] & m) != 0);
	  }
	}
      }
    }
  }
  else if ( mtype == ard_eMsgType_AiRead) {
    // Only Ai, no Di

    if ( !skip_ai) {
      ard_sMsg rmsg;
      pwr_tInt32 ivalue;
      pwr_tFloat32 actvalue;

      sts = receive( local->fd, local->DiPollId, &rmsg, local->AiNum * 2, op->Timeout, op);
      if ( EVEN(sts)) {
      }
      else {
	int ai_cnt = 0;
	for ( i = 0; i < local->AiSize; i++) {
	  for ( j = 0; j < 8; j++) {
	    m = 1 << j;
	    if ( local->AiMask[i] & m) {
	      io_sChannel *chanp = local->AiChanList[i*8+j];
	      pwr_sClass_ChanAi *cop = (pwr_sClass_ChanAi *)chanp->cop;
	      pwr_sClass_Ai *sop = (pwr_sClass_Ai *)chanp->sop;
	      
	      if ( cop->ConversionOn) {
		if ( cop->CalculateNewCoef)
		  // Request to calculate new coefficients
		  io_AiRangeToCoef( chanp);
	      
		ivalue = rmsg.data[ai_cnt*2] * 256 + rmsg.data[ai_cnt*2+1];
		io_ConvertAi( cop, ivalue, &actvalue);

		// Filter
		if ( sop->FilterType == 1 &&
		     sop->FilterAttribute[0] > 0 &&
		     sop->FilterAttribute[0] > ctx->ScanTime) {
		  actvalue = *(pwr_tFloat32 *)chanp->vbp + ctx->ScanTime / sop->FilterAttribute[0] *
		    (actvalue - *(pwr_tFloat32 *)chanp->vbp);
		}
	      
		*(pwr_tFloat32 *)chanp->vbp = actvalue;
		sop->SigValue = cop->SigValPolyCoef1 * ivalue + cop->SigValPolyCoef0;
		sop->RawValue = ivalue;
	      }
	      ai_cnt++;
	    }	    
	  }
	}
      }
    }
  }

  if ( op->ErrorCount >= op->ErrorSoftLimit && 
       error_count < op->ErrorSoftLimit) {
    errh_Warning( "IO Card ErrorSoftLimit reached, '%s'", cp->Name);
  }
  if ( op->ErrorCount >= op->ErrorHardLimit) {
    errh_Error( "IO Card ErrorHardLimit reached '%s', IO stopped", cp->Name);
    ctx->Node->EmergBreakTrue = 1;
    return IO__ERRDEVICE;
  }

  return IO__SUCCESS;
}

static pwr_tStatus IoCardWrite( io_tCtx ctx,
			       io_sAgent *ap,
			       io_sRack	*rp,
			       io_sCard	*cp)
{
  io_sLocal *local = cp->Local;
  pwr_sClass_Arduino_Uno *op = (pwr_sClass_Arduino_Uno *)cp->op;
  int i, j;
  unsigned char m;
  pwr_tUInt32 error_count = op->ErrorCount;
  ard_sMsg msg;
  int sts;
  int skip_ao;
  io_sChannel *chanp;

  if ( local->Reopendev) {
    local->ReopendevCnt++;
    if ( local->ReopendevCnt * ctx->ScanTime > 5.0) {
      close_device( local);
      sts = open_and_connect( local, op, cp);
      if ( EVEN(sts)) {
	local->Reopendev = 1;
	local->ReopendevCnt = 0;
	return IO__SUCCESS;
      }
      else
	local->Reopendev = 0;
    }
    else
      return IO__SUCCESS;
  }
  else if ( local->Reconnect) {
    local->ReconnectCnt++;
    if ( local->ReconnectCnt * ctx->ScanTime > 5.0) {
      if ( op->Options & pwr_mArduino_OptionsMask_ConnectionRequest) {
	sts = send_connect_request( local, op, cp);
	if ( EVEN(sts)) {
	  local->Reconnect = 1;
	  local->ReconnectCnt = 0;
	  return IO__SUCCESS;
	}
	else
	  local->Reconnect = 0;
      }
      else
	local->Reconnect = 0;
    }
    else
      return IO__SUCCESS;
  }

  if ( local->AoSize) {
    skip_ao = 0;

    if ( op->AoScanInterval > 1) {
      skip_ao = local->AoIntervalCnt;

      local->AoIntervalCnt++;
      if ( local->AoIntervalCnt >= op->AoScanInterval)
	local->AoIntervalCnt = 0;
    }
  }
  else
    skip_ao = 1;

  if ( local->DoSize && skip_ao) {

    memset( &msg, 0, sizeof(msg));
    msg.size = local->DoSize + 3;
    msg.id = local->IdCnt++;
    msg.type = ard_eMsgType_DoWrite;

    for ( i = 0; i < local->DoSize; i++) {
      for ( j = 0; j < 8; j++) {
	m = 1 << j;
	if ( local->DoMask[i] & m) {
	  chanp = local->DChanList[i*8+j];
	  pwr_sClass_ChanDo *cop = (pwr_sClass_ChanDo *) chanp->cop;
	  pwr_tInt32 do_actval;

          if ( cop->TestOn != 0)
	    do_actval = cop->TestValue;
	  else
	    do_actval = *(pwr_tInt32 *) chanp->vbp;

	  if ( do_actval)
	    msg.data[i] |= m;
	}
      }
    }


    // logg( "Write Do");
    if ( op->Options & pwr_mArduino_OptionsMask_Checksum)
      add_checksum( &msg);

    sts = write( local->fd, &msg, msg.size);
    if ( sts > 0) {
      local->ReceiveWriteRespons = 1;
      local->WriteId = msg.id;
    }
  } 
  else if ( local->AoSize && !local->DoSize) {

    if ( !skip_ao) {
      ard_sMsg msg;
      int value;

      memset( &msg, 0, sizeof(msg));
      if ( op->Options & pwr_mArduino_OptionsMask_Ao16Bit)
	msg.size = local->AoNum + 3;
      else
	msg.size = local->AoNum * 2 + 3;
      msg.id = local->IdCnt++;
      msg.type = ard_eMsgType_AoWrite;

      int ao_cnt = 0;
      for ( i = 0; i < local->AoSize; i++) {
	for ( j = 0; j < 8; j++) {
	  m = 1 << j;
	  if ( local->AoMask[i] & m) {
	    io_sChannel *chanp = local->AoChanList[i*8+j];
	    pwr_sClass_ChanAo *cop = (pwr_sClass_ChanAo *)chanp->cop;
	    pwr_sClass_Ao *sop = (pwr_sClass_Ao *)chanp->sop;
	      
	    if ( cop->CalculateNewCoef)
	      // Request to calculate new coefficients
	      io_AoRangeToCoef( chanp);
	      

	    if ( cop->TestOn)
	      value = cop->TestValue * cop->OutPolyCoef1 + 
		cop->OutPolyCoef0 + 0.49;
	    else
	      value = *(pwr_tFloat32 *)chanp->vbp * cop->OutPolyCoef1 + 
		cop->OutPolyCoef0 + 0.49;

	    if ( op->Options & pwr_mArduino_OptionsMask_Ao16Bit) {
	      if ( value < 0)
		value = 0;
	      else if (value > 65535)
		value = 65535;

	      msg.data[ao_cnt * 2]  = value / 256;
	      msg.data[ao_cnt * 2 + 1]  = value % 256;
	    }
	    else {
	      if ( value < 0)
		value = 0;
	      else if (value > 255)
		value = 255;

	      msg.data[ao_cnt]  = value;
	    }	      

	    sop->SigValue = cop->SigValPolyCoef1 * *(pwr_tFloat32 *)chanp->vbp + 
	      cop->SigValPolyCoef0;
	    sop->RawValue = value;
	    ao_cnt++;
	  }
	}
      }
      // logg( "Write Ao");

      if ( op->Options & pwr_mArduino_OptionsMask_Checksum)
	add_checksum( &msg);

      sts = write( local->fd, &msg, msg.size);
      if ( sts > 0) {
	local->ReceiveWriteRespons = 1;
	local->WriteId = msg.id;
      }
    }
  }
  else if ( local->DoSize && !skip_ao) {
    memset( &msg, 0, sizeof(msg));
    if ( op->Options & pwr_mArduino_OptionsMask_Ao16Bit)
      msg.size = local->DoSize + local->AoNum * 2 + 3;
    else
      msg.size = local->DoSize + local->AoNum + 3;
    msg.id = local->IdCnt++;
    msg.type = ard_eMsgType_WriteAll;

    for ( i = 0; i < local->DoSize; i++) {
      for ( j = 0; j < 8; j++) {
	m = 1 << j;
	if ( local->DoMask[i] & m) {
	  chanp = local->DChanList[i*8+j];
	  pwr_sClass_ChanDo *cop = (pwr_sClass_ChanDo *) chanp->cop;
	  pwr_tInt32 do_actval;

          if ( cop->TestOn != 0)
	    do_actval = cop->TestValue;
	  else
	    do_actval = *(pwr_tInt32 *) chanp->vbp;

	  if ( do_actval)
	    msg.data[i] |= m;
	}
      }
    }


    int value;

    int ao_cnt = 0;
    for ( i = 0; i < local->AoSize; i++) {
      for ( j = 0; j < 8; j++) {
	m = 1 << j;
	if ( local->AoMask[i] & m) {
	  io_sChannel *chanp = local->AoChanList[i*8+j];
	  pwr_sClass_ChanAo *cop = (pwr_sClass_ChanAo *)chanp->cop;
	  pwr_sClass_Ao *sop = (pwr_sClass_Ao *)chanp->sop;
	      
	  if ( cop->CalculateNewCoef)
	    // Request to calculate new coefficients
	    io_AoRangeToCoef( chanp);
	      

	  if ( cop->TestOn)
	    value = cop->TestValue * cop->OutPolyCoef1 + 
	      cop->OutPolyCoef0 + 0.49;
	  else
	    value = *(pwr_tFloat32 *)chanp->vbp * cop->OutPolyCoef1 + 
	      cop->OutPolyCoef0 + 0.49;

	  if ( op->Options & pwr_mArduino_OptionsMask_Ao16Bit) {
	    if ( value < 0)
	      value = 0;
	    else if (value > 65535)
	      value = 65535;

	    msg.data[local->DoSize + ao_cnt * 2]  = value / 256;
	    msg.data[local->DoSize + ao_cnt * 2 + 1]  = value % 256;
	  }
	  else {
	    if ( value < 0)
	      value = 0;
	    else if (value > 255)
	      value = 255;
	    
	    msg.data[local->DoSize + ao_cnt]  = value;
	  }

	  if ( value < 0)
	    value = 0;
	  else if (value > 255)
	    value = 255;


	  sop->SigValue = cop->SigValPolyCoef1 * *(pwr_tFloat32 *)chanp->vbp + 
	    cop->SigValPolyCoef0;
	  sop->RawValue = value;
	  ao_cnt++;
	}
      }
    }
    // logg( "Write All");

    if ( op->Options & pwr_mArduino_OptionsMask_Checksum)
      add_checksum( &msg);

    sts = write( local->fd, &msg, msg.size);
    if ( sts > 0) {
      local->ReceiveWriteRespons = 1;
      local->WriteId = msg.id;
    }
 
  }
  if ( sts < 0) {
    /* Connection lost, open device again */
    local->Reopendev = 1;
    local->ReopendevCnt = 0;
    return IO__SUCCESS;
  }
 
  if ( op->ErrorCount >= op->ErrorSoftLimit && 
       error_count < op->ErrorSoftLimit) {
    errh_Warning( "IO Card ErrorSoftLimit reached, '%s'", cp->Name);
  }    
  if ( op->ErrorCount >= op->ErrorHardLimit) {
    errh_Error( "IO Card ErrorHardLimit reached '%s', IO stopped", cp->Name);
    ctx->Node->EmergBreakTrue = 1;
    return IO__ERRDEVICE;
  }    

  if ( op->Options & pwr_mArduino_OptionsMask_OptimizedDiPoll) {
    ard_sMsg msg;
    int skip_ai;
    ard_eMsgType mtype;

    if ( local->AiSize) {
      skip_ai = 0;
      
      if ( op->AiScanInterval > 1)
	skip_ai = local->AiIntervalCnt;
    }
    else
      skip_ai = 1;

    if ( local->DiSize && skip_ai)
      mtype = ard_eMsgType_DiRead;
    else if ( local->DiSize && !skip_ai)
      mtype = ard_eMsgType_ReadAll;
    else if ( !skip_ai)
      mtype = ard_eMsgType_AiRead;
    else
      mtype = ard_eMsgType_No;

    apoll( &msg, local, mtype, op);
  }

  return IO__SUCCESS;
}

/*  Every method should be registred here. */

pwr_dExport pwr_BindIoMethods(Arduino_Uno) = {
  pwr_BindIoMethod(IoCardInit),
  pwr_BindIoMethod(IoCardClose),
  pwr_BindIoMethod(IoCardRead),
  pwr_BindIoMethod(IoCardWrite),
  pwr_NullMethod
};
