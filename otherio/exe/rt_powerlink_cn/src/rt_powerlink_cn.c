/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 **/

#if defined PWRE_CONF_EPL && defined PWRE_CONF_LIBPCAP

#include "pwr.h"
#include "pwr_basecomponentclasses.h"
#include "pwr_otherioclasses.h"

#include "co_string.h"

#include "rt_io_msg.h"
#include "rt_pwr_msg.h"
#include "rt_gdh.h"
#include "rt_io_base.h"
#include "rt_errh.h"
#include "rt_qcom.h"
#include "rt_aproc.h"
#include "rt_ini_event.h"
#include "rt_qcom_msg.h"

// Test for CN build
#include "Epl.h"
tEplKernel EplApiSetCdcFilename(char* pszCdcFilename_p)
{
  return 0;
}

pwr_tStatus io_get_plhandler_object(pwr_sClass_EplHandler** o, pwr_tObjid* roid)
{
  pwr_tStatus sts;
  pwr_tObjid oid;

  // Get EplHandler object
  sts = gdh_GetClassList(pwr_cClass_EplHandler, &oid);
  if (EVEN(sts))
    return sts;

  sts = gdh_ObjidToPointer(oid, (void*)o);
  if (EVEN(sts))
    return sts;

  if (roid != NULL)
    *roid = oid;
  return IO__SUCCESS;
}

static void usage()
{
  printf("\
rt_powerlink_cn I/O Powerlink Controlled node server\n\
\n\
     -m         Print loaded I/O methods\n\
\n");
}

int main(int argc, char** argv)
{
  pwr_tStatus sts;
  io_tCtx io_ctx;
  float ctime = 1;

  pwr_sClass_EplHandler* plhp;
  pwr_tOid oid;
  int tmo;
  char mp[2000];
  qcom_sGet get;
  qcom_sQattr qAttr;
  qcom_sQid qini;
  qcom_sQid qid = qcom_cNQid;

  if (argc > 1) {
    if (streq(argv[1], "-m")) {
      io_methods_print();
      exit(0);
    }
    if (streq(argv[1], "-h")) {
      usage();
      exit(0);
    }
  }

  // Make connection to error handler
  errh_Init("pwr_powerlink", errh_eAnix_powerlink);
  errh_SetStatus(PWR__SRVSTARTUP);

  if (!qcom_Init(&sts, 0, "pwr_powerlink")) {
    errh_Fatal("qcom_Init, %m", sts);
    exit(sts);
  }

  qAttr.type = qcom_eQtype_private;
  qAttr.quota = 100;
  if (!qcom_CreateQ(&sts, &qid, &qAttr, "events")) {
    errh_Fatal("qcom_CreateQ, %m", sts);
    exit(sts);
  }

  qini = qcom_cQini;
  if (!qcom_Bind(&sts, &qid, &qini)) {
    errh_Fatal("qcom_Bind(Qini), %m", sts);
    exit(-1);
  }

  // Make connection to realtime database
  sts = gdh_Init("rt_powerlink");
  if (EVEN(sts)) {
    errh_Fatal("rt_powerlink aborted, gdh_Init failed\n%m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  // Get Powerlink handler object
  sts = io_get_plhandler_object(&plhp, &oid);
  if (EVEN(sts)) {
    errh_SetStatus(0);
    errh_Info("rt_powerlink terminated, no EplHandler object found");
    exit(sts);
  }

  // Create context and call init functions of all agent,
  // rack and cardobjects
  sts = io_init(io_mProcess_Powerlink, pwr_cNObjid, &io_ctx, 1, ctime);
  if (EVEN(sts)) {
    errh_SetStatus(PWR__SRVTERM);
    errh_Fatal("rt_powerlink aborted, io_init() failed\n%m", sts);
    exit(sts);
  }

  tmo = (plhp->CycleTime) * 1000;

  aproc_TimeStamp(plhp->CycleTime, 5.0);
  errh_SetStatus(PWR__SRUN);
  aproc_RegisterObject(oid);

  // Call IoAgentRead() IoAgentWrite() IoCardRead() IoCardWrite()
  // IoModuleRead() IoModuleWrite() forever
  for (;;) {
    get.maxSize = sizeof(mp);
    get.data = mp;
    qcom_Get(&sts, &qid, &get, tmo);
    if (sts == QCOM__TMO || sts == QCOM__QEMPTY) {
      sts = io_read(io_ctx);
      sts = io_write(io_ctx);

      aproc_TimeStamp(plhp->CycleTime, 5.0);
    } else {
      ini_mEvent new_event;
      qcom_sEvent* ep = (qcom_sEvent*)get.data;

      new_event.m = ep->mask;
      if (new_event.b.oldPlcStop) {
        // TODO
      } else if (new_event.b.swapDone) {
        // TODO
      } else if (new_event.b.terminate) {
        // io_close(io_ctx);
        exit(0);
      }
    }
  }
}

#else

#include <stdio.h>

int main(int argc, char** argv)
{
  printf("** Not built with Powerlink\n");
  return 0;
}
#endif
