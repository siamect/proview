/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_io_m_pb_profiboard.c -- io methods for the profibus master object
   The PbMaster object serves as agent for one Profibus DP bus
   The board we use is Profiboard from Softing
*/

#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/file.h>
#include <sys/ioctl.h>

#include "keywords.h"

#pragma pack(1)
#include "pb_type.h"
#include "pb_conf.h"
#include "pb_if.h"
#include "pb_err.h"
#include "pb_fmb.h"
#include "pb_dp.h"
#include "pb_fdl.h"
#pragma pack(0)

#include "co_cdh.h"
#include "pwr_profibusclasses.h"
#include "rt_io_base.h"
#include "rt_io_bus.h"
#include "rt_io_msg.h"
#include "rt_io_agent_init.h"
#include "rt_pb_msg.h"

#include "rt_io_profiboard.h"

#include "rt_io_pb_locals.h"

#define DP_MAX_SERVICE_RETRY 10

static int count;

static pwr_tStatus IoAgentInit(io_tCtx ctx, io_sAgent* ap);
static pwr_tStatus IoAgentRead(io_tCtx ctx, io_sAgent* ap);
static pwr_tStatus IoAgentWrite(io_tCtx ctx, io_sAgent* ap);
static pwr_tStatus IoAgentClose(io_tCtx ctx, io_sAgent* ap);

/*----------------------------------------------------------------------------*\
  Sends request to Profiboard for setting FMB parameters
\*----------------------------------------------------------------------------*/
static short try_profi_rcv_con_ind(T_PROFI_SERVICE_DESCR* con_ind_sdb,
                                   USIGN8* con_ind_buffer,
                                   USIGN16* con_ind_buffer_len, INT16* result)
{
  int retry_counter;
  struct timespec rqtp = {0, 10000000}; // 10 ms
  retry_counter = DP_MAX_SERVICE_RETRY;

  do
  {
    nanosleep(&rqtp, NULL);
    *result =
        profi_rcv_con_ind(con_ind_sdb, con_ind_buffer, con_ind_buffer_len);
  } while ((*result == NO_CON_IND_RECEIVED) && (retry_counter-- > 0));

  if (*result == E_IF_FATAL_ERROR)
    return (PB_FALSE);

  return (PB_TRUE);
}
/*----------------------------------------------------------------------------*\
  Sends request to Profiboard for setting FMB parameters
\*----------------------------------------------------------------------------*/
static short fmb_set_configuration(io_sAgent* ap)
{
  T_PROFI_SERVICE_DESCR sdb;
  T_FMB_SET_CONFIGURATION_REQ data;

  USIGN8 con_ind_buffer[256];
  USIGN16 con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR con_ind_sdb;
  INT16 result; /* !!! local result variable !!! */
  io_sRack* slave_list;
  pwr_sClass_Pb_Profiboard* op;
  pwr_tCid cid;

  slave_list = ap->racklist;
  op = ap->op;

  memset(&data, 0, sizeof(T_FMB_SET_CONFIGURATION_REQ));

  /* Iterate over the slaves.  */
  for (slave_list = ap->racklist; slave_list != NULL;
       slave_list = slave_list->next)
  {
    cid = slave_list->Class;

    while (ODD(gdh_GetSuperClass(cid, &cid, pwr_cNOid)))
      ;

    if (cid == pwr_cClass_Pb_DP_Slave)
      ((io_sAgentLocal*)ap->Local)->dp = PB_TRUE;
    if (cid == pwr_cClass_Pb_FDL_SAP)
      ((io_sAgentLocal*)ap->Local)->fdl = PB_TRUE;
  }

  sdb.comm_ref = 0;
  sdb.layer = FMB;
  sdb.service = FMB_SET_CONFIGURATION;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;
  sdb.result = 0;

  data.fms_active = PB_FALSE;
  data.dp_active = ((io_sAgentLocal*)ap->Local)->dp;
  data.fdlif_active = ((io_sAgentLocal*)ap->Local)->fdl;
  data.fdl_evt_receiver = FMB_USR;
  data.sm7_active = PB_FALSE;
  data.data_buffer_length = 256;

  data.dp.max_number_slaves = op->MaxNumberSlaves;
  data.dp.max_slave_output_len = op->MaxSlaveOutputLen;
  data.dp.max_slave_input_len = op->MaxSlaveInputLen;
  data.dp.max_slave_diag_entries = op->MaxNumberSlaves * 4;
  data.dp.max_slave_diag_len = op->MaxSlaveDiagLen;
  if (data.dp.max_slave_diag_len == 0)
    data.dp.max_slave_diag_len = 60;
  data.dp.max_bus_para_len = 1024;
  data.dp.max_slave_para_len = 1024;

  data.fdlif.send_req_credits = 20;
  data.fdlif.srd_req_credits = 20;
  data.fdlif.receive_credits = 20;
  data.fdlif.max_no_resp_saps = 20;

  profi_snd_req_res(&sdb, &data, PB_FALSE);

  try_profi_rcv_con_ind(&con_ind_sdb, con_ind_buffer, &con_ind_buffer_len,
                        &result);

  if ((con_ind_sdb.service == FMB_SET_CONFIGURATION) &&
      (con_ind_sdb.primitive == CON) && (con_ind_sdb.result == POS))
  {
    return (PB_TRUE);
  }

  return (PB_FALSE);
}

/*----------------------------------------------------------------------------*\
  Sends request to Profiboard for setting DP master parameters
\*----------------------------------------------------------------------------*/
static short dp_init_master()
{
  T_PROFI_SERVICE_DESCR sdb;
  T_DP_INIT_MASTER_REQ data;

  USIGN8 con_ind_buffer[256];
  USIGN16 con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR con_ind_sdb;
  INT16 result; /* !!! local result variable !!! */

  sdb.comm_ref = 0;
  sdb.layer = DP;
  sdb.service = DP_INIT_MASTER;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;
  sdb.result = 0;

  data.master_default_address = 0;
  data.master_class2 = PB_FALSE;
  data.lowest_slave_address = 2;
  data.slave_io_address_mode =
      DP_AAM_IO_BLOCKS; // only mode possible with Linux-driver DP_AAM_ARRAY;
  data.clear_outputs = PB_TRUE;
  data.auto_remote_services = DP_AUTO_REMOTE_SERVICES;
  data.cyclic_data_transfer = PB_TRUE;

  profi_snd_req_res(&sdb, &data, PB_FALSE);

  try_profi_rcv_con_ind(&con_ind_sdb, con_ind_buffer, &con_ind_buffer_len,
                        &result);

  if ((con_ind_sdb.service == DP_INIT_MASTER) &&
      (con_ind_sdb.primitive == CON) && (con_ind_sdb.result == POS))
  {
    return (PB_TRUE);
  }

  return (PB_FALSE);
}

/*----------------------------------------------------------------------------*\
  Sends request to Profiboard for setting DP bus parameters
\*----------------------------------------------------------------------------*/
static short dp_download_bus(pwr_sClass_Pb_Profiboard* op)
{
  T_PROFI_SERVICE_DESCR sdb;
  struct
  {
    T_DP_DOWNLOAD_REQ drp;
    T_DP_BUS_PARA_SET dbp;
  } data;
  int i;

  USIGN8 con_ind_buffer[256];
  USIGN16 con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR con_ind_sdb;
  INT16 result; /* !!! local result variable !!! */

  sdb.comm_ref = 0;
  sdb.layer = DP;
  sdb.service = DP_DOWNLOAD_LOC;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;
  sdb.result = 0;

  data.drp.data_len = 66;
  data.drp.rem_add = 0;
  data.drp.area_code = DP_AREA_BUS_PARAM;
  data.drp.add_offset = 0;

  data.dbp.bus_para_len = swap16(66);
  data.dbp.fdl_add = 0;

  switch (op->BaudRate)
  {
  case 500:
    data.dbp.baud_rate = DP_KBAUD_500;
    break;
  case 750:
    data.dbp.baud_rate = DP_KBAUD_750;
    break;
  case 1500:
    data.dbp.baud_rate = DP_KBAUD_1500;
    break;
  case 3000:
    data.dbp.baud_rate = DP_KBAUD_3000;
    break;
  case 6000:
    data.dbp.baud_rate = DP_KBAUD_6000;
    break;
  case 12000:
    data.dbp.baud_rate = DP_KBAUD_12000;
    break;
  default:
    data.dbp.baud_rate = DP_KBAUD_1500;
    break;
  }

  data.dbp.tsl = swap16(op->Tsl);
  data.dbp.min_tsdr = swap16(op->MinTsdr);
  data.dbp.max_tsdr = swap16(op->MaxTsdr);
  data.dbp.tqui = op->Tqui;
  data.dbp.tset = op->Tset;
  data.dbp.ttr = swap32(op->Ttr);
  data.dbp.g = op->G;
  data.dbp.hsa = op->Hsa;
  data.dbp.max_retry_limit = op->MaxRetryLimit;
  data.dbp.bp_flag = op->BpFlag;
  data.dbp.min_slave_interval = swap16(op->MinSlaveInterval);
  data.dbp.poll_timeout = swap16(op->PollTimeout);
  data.dbp.data_control_time = swap16(op->DataControlTime);
  for (i = 0; i < 6; i++)
    data.dbp.reserved[i] = 0;
  data.dbp.master_user_data_len = swap16(DP_MASTER_USER_DATA_LEN);
  for (i = 0; i < 32; i++)
    data.dbp.master_class2_name[i] = 0;

  profi_snd_req_res(&sdb, &data, PB_FALSE);

  try_profi_rcv_con_ind(&con_ind_sdb, con_ind_buffer, &con_ind_buffer_len,
                        &result);

  if ((con_ind_sdb.service == DP_DOWNLOAD_LOC) &&
      (con_ind_sdb.primitive == CON) && (con_ind_sdb.result == POS))
  {
    return (PB_TRUE);
  }

  return (PB_FALSE);
}

/*********************** FMB_SET_BUSPARAMETER ******************************/

static short fmb_set_busparameter(pwr_sClass_Pb_Profiboard* op)
/* ------------------------------------------------------------------------ */
/* FUNCTIONAL_DESCRIPTION:                                                  */
/*                                                                          */
/* Set Busparameters for a DP/V1 network                                    */
/* ------------------------------------------------------------------------ */
{
  T_FMB_SET_BUSPARAMETER_REQ bus_par_req;
  T_PROFI_SERVICE_DESCR sdb;

  USIGN8 con_ind_buffer[256];
  USIGN16 con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR con_ind_sdb;
  INT16 result; /* !!! local result variable !!! */

  /* set data block parameters */

  bus_par_req.loc_add = op->SlaveAddress;

  bus_par_req.in_ring_desired = 255;
  bus_par_req.loc_segm = 255;
  bus_par_req.medium_red = 0;

  switch (op->BaudRate)
  {
  case 500:
    bus_par_req.baud_rate = DP_KBAUD_500;
    break;
  case 750:
    bus_par_req.baud_rate = DP_KBAUD_750;
    break;
  case 1500:
    bus_par_req.baud_rate = DP_KBAUD_1500;
    break;
  case 3000:
    bus_par_req.baud_rate = DP_KBAUD_3000;
    break;
  case 6000:
    bus_par_req.baud_rate = DP_KBAUD_6000;
    break;
  case 12000:
    bus_par_req.baud_rate = DP_KBAUD_12000;
    break;
  default:
    bus_par_req.baud_rate = DP_KBAUD_1500;
    break;
  }

  bus_par_req.tset = op->Tset;
  bus_par_req.tsl = op->Tsl;
  bus_par_req.min_tsdr = op->MinTsdr;
  bus_par_req.max_tsdr = op->MaxTsdr;
  bus_par_req.tqui = op->Tqui;
  bus_par_req.max_retry_limit = op->MaxRetryLimit;

  bus_par_req.ttr = op->Ttr;
  bus_par_req.g = op->G;
  bus_par_req.hsa = op->Hsa;

  /* Set Description block */

  sdb.comm_ref = 0;
  sdb.layer = FMB;
  sdb.service = FMB_SET_BUSPARAMETER;
  sdb.primitive = REQ;

  /* Send Request */

  profi_snd_req_res(&sdb, &bus_par_req, PB_FALSE);

  try_profi_rcv_con_ind(&con_ind_sdb, con_ind_buffer, &con_ind_buffer_len,
                        &result);

  if ((con_ind_sdb.service == FMB_SET_BUSPARAMETER) &&
      (con_ind_sdb.primitive == CON) && (con_ind_sdb.result == POS))
  {
    return (PB_TRUE);
  }

  return (PB_FALSE);

} /* fmb_set_busparameter */

/*********************** DP_SET_BUSPARAMETER ******************************/

static short dp_set_busparameter(pwr_sClass_Pb_Profiboard* op)
/* ------------------------------------------------------------------------ */
/* FUNCTIONAL_DESCRIPTION:                                                  */
/*                                                                          */
/* Set Busparameters for a DP/V1 network                                    */
/* ------------------------------------------------------------------------ */
{
  T_DP_SET_BUSPARAMETER_REQ bus_par_req;
  T_PROFI_SERVICE_DESCR sdb;

  USIGN8 con_ind_buffer[256];
  USIGN16 con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR con_ind_sdb;
  INT16 result; /* !!! local result variable !!! */

  memset(&bus_par_req, 0, sizeof(T_DP_SET_BUSPARAMETER_REQ));

  /* set data block parameters */

  bus_par_req.bp_flag = op->BpFlag;
  bus_par_req.min_slave_interval = op->MinSlaveInterval;
  bus_par_req.poll_timeout = op->PollTimeout;
  bus_par_req.data_control_time = op->DataControlTime;
  bus_par_req.master_user_data_len = DP_MASTER_USER_DATA_LEN;

  /* Set Description block */

  sdb.comm_ref = 0;
  sdb.layer = DP;
  sdb.service = DP_SET_BUSPARAMETER;
  sdb.primitive = REQ;

  /* Send Request */

  profi_snd_req_res(&sdb, &bus_par_req, PB_FALSE);

  con_ind_sdb.service = 0;
  while (con_ind_sdb.service != DP_SET_BUSPARAMETER)
    try_profi_rcv_con_ind(&con_ind_sdb, con_ind_buffer, &con_ind_buffer_len,
                          &result);

  if ((con_ind_sdb.service == DP_SET_BUSPARAMETER) &&
      (con_ind_sdb.primitive == CON) && (con_ind_sdb.result == POS))
  {
    return (PB_TRUE);
  }

  return (PB_FALSE);

} /* dp_set_busparameter */

static short fdlif_sap_activate_req(pwr_sClass_Pb_FDL_SAP* op)

/*-----------------------------------------------------------------------------
    FUNCTIONAL_DESCRIPTION

    this function is used to activate a SAP

possible return values:

    - == E_OK    -> no error
    - != E_OK    -> error

    -----------------------------------------------------------------------------*/
{
  // LOCAL_VARIABLES

  T_PROFI_SERVICE_DESCR sdb;
  T_FDLIF_SAP_ACTIVATE_REQ sap;
  USIGN8 con_ind_buffer[256];
  USIGN16 con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR con_ind_sdb;
  INT16 result; /* !!! local result variable !!! */

  // FUNCTION_BODY

  sap.sap_nr = op->SAP_Nr;

  /* --- set data block parameters ------------------------------------ */
  sap.max_l_sdu_length_req = 244;
  sap.max_l_sdu_length_con_ind = 244;
  sap.access_sap = ALL;
  sap.access_station = ALL;
  sap.sda = BOTH_ROLES;
  sap.sdn = BOTH_ROLES;
  sap.srd = BOTH_ROLES;
  sap.csrd = SERVICE_NOT_ACTIVATED;
  sap.data_mode = NORMAL_MODE;
  sap.credits = 2;

  /* --- set parameter block parameters --------------------------------------
   */
  sdb.comm_ref = 0;
  sdb.layer = FDLIF;
  sdb.service = FDLIF_SAP_ACTIVATE;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;

  /* Send Request */

  profi_snd_req_res(&sdb, &sap, PB_FALSE);

  con_ind_sdb.service = 0;

  while (con_ind_sdb.service != FDLIF_SAP_ACTIVATE)
    try_profi_rcv_con_ind(&con_ind_sdb, con_ind_buffer, &con_ind_buffer_len,
                          &result);

  if ((con_ind_sdb.service == FDLIF_SAP_ACTIVATE) &&
      (con_ind_sdb.primitive == CON) && (con_ind_sdb.result == POS))
  {
    return (PB_TRUE);
  }

  return (PB_FALSE);
}

static short fdlif_rsap_activate_req(pwr_sClass_Pb_FDL_SAP* op)

/*-----------------------------------------------------------------------------
    FUNCTIONAL_DESCRIPTION

    this function is used to activate a RSAP

possible return values:

    - == E_OK    -> no error
    - != E_OK    -> error

    -----------------------------------------------------------------------------*/
{
  // LOCAL_VARIABLES

  T_PROFI_SERVICE_DESCR sdb;
  T_FDLIF_RSAP_ACTIVATE_REQ rsap;
  USIGN8 con_ind_buffer[256];
  USIGN16 con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR con_ind_sdb;
  INT16 result; /* !!! local result variable !!! */

  // FUNCTION_BODY

  rsap.sap_nr = op->SAP_Nr;

  /* --- set data block parameters ------------------------------------ */
  rsap.max_l_sdu_length_req = 244;
  rsap.max_l_sdu_length_ind = 244;
  rsap.access_sap = ALL;
  rsap.access_station = ALL;
  rsap.data_mode = NORMAL_MODE;
  rsap.credits = 2;

  /* --- set parameter block parameters --------------------------------------
   */
  sdb.comm_ref = 0;
  sdb.layer = FDLIF;
  sdb.service = FDLIF_RSAP_ACTIVATE;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;

  /* Send Request */

  profi_snd_req_res(&sdb, &rsap, PB_FALSE);

  con_ind_sdb.service = 0;

  while (con_ind_sdb.service != FDLIF_RSAP_ACTIVATE)
    try_profi_rcv_con_ind(&con_ind_sdb, con_ind_buffer, &con_ind_buffer_len,
                          &result);

  if ((con_ind_sdb.service == FDLIF_RSAP_ACTIVATE) &&
      (con_ind_sdb.primitive == CON) && (con_ind_sdb.result == POS))
  {
    return (PB_TRUE);
  }

  return (PB_FALSE);
}

/*----------------------------------------------------------------------------*\
  Sends request for selecting operation mode to the Profiboard
\*----------------------------------------------------------------------------*/
static short dp_act_param_loc(short arg)
{
  T_PROFI_SERVICE_DESCR sdb;
  T_DP_ACT_PARAM_REQ apr;
  pwr_tUInt16 retval;

  /* Fill the service description block */
  sdb.comm_ref = 0;
  sdb.layer = DP;
  sdb.service = DP_ACT_PARAM_LOC;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;
  sdb.result = 0;

  apr.rem_add = 0;
  apr.area_code = DP_AREA_SET_MODE;
  apr.activate = arg;
  apr.dummy = 0;

  retval = profi_snd_req_res(&sdb, &apr, PB_FALSE);

  return retval;
}

/*----------------------------------------------------------------------------*\
  Sends request for getting slave diagnostics
\*----------------------------------------------------------------------------*/
static pwr_tBoolean dp_get_slave_diag()
{
  T_PROFI_SERVICE_DESCR sdb;
  pwr_tUInt16 retval;

  /* Fill the service description block */
  sdb.comm_ref = 0;
  sdb.layer = DP;
  sdb.service = DP_GET_SLAVE_DIAG;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;
  sdb.result = 0;

  retval = profi_snd_req_res(&sdb, &sdb, PB_FALSE);

  return ((pwr_tBoolean)(retval == E_OK));
}

/*----------------------------------------------------------------------------*\
  Get slave diagnostics
\*----------------------------------------------------------------------------*/
static void
dp_get_slave_diag_con(T_DP_GET_SLAVE_DIAG_CON* get_slave_diag_con_ptr,
                      io_sRack* slave_list, char log)
{
  T_DP_DIAG_DATA FAR* diag_data_ptr;
  char s[128];
  pwr_sClass_Pb_DP_Slave* sp;

  if (get_slave_diag_con_ptr->diag_data_len >= DP_MIN_SLAVE_DIAG_LEN)
  {
    diag_data_ptr = (T_DP_DIAG_DATA FAR*)(get_slave_diag_con_ptr + 1);

    while (slave_list != NULL)
    {
      sp = (pwr_sClass_Pb_DP_Slave*)slave_list->op;

      if (sp->SlaveAddress == get_slave_diag_con_ptr->rem_add)
      {
        sp->StationStatus1 = diag_data_ptr->station_status_1;
        sp->StationStatus2 = diag_data_ptr->station_status_2;
        sp->StationStatus3 = diag_data_ptr->station_status_3;

        sp->BytesOfDiag =
            get_slave_diag_con_ptr->diag_data_len - DP_MIN_SLAVE_DIAG_LEN;

        memcpy(
            sp->Diag, diag_data_ptr + 1,
            MIN(get_slave_diag_con_ptr->diag_data_len - DP_MIN_SLAVE_DIAG_LEN,
                DP_MAX_EXT_DIAG_DATA_LEN));

        /* Update slave status */

        if (!(sp->StationStatus1 & ~pwr_mPbStationStatus1Mask_ExternalDiag) &&
            !(sp->StationStatus2 &
              ~(pwr_mPbStationStatus2Mask_Default |
                pwr_mPbStationStatus2Mask_ResponseMonitoringOn)))
        {
          sp->Status = PB__NORMAL;
        }
        else if (sp->StationStatus1 & pwr_mPbStationStatus1Mask_NonExistent)
        {
          sp->Status = PB__NOCONN;
        }
        else if ((sp->StationStatus1 &
                  (pwr_mPbStationStatus1Mask_ConfigFault |
                   pwr_mPbStationStatus1Mask_ParamFault)) ||
                 (sp->StationStatus2 &
                  pwr_mPbStationStatus2Mask_NewParamsRequested))
        {
          sp->Status = PB__CONFIGERR;
        }
        else if (sp->StationStatus1 & pwr_mPbStationStatus1Mask_MasterLock)
        {
          sp->Status = PB__MASTERLOCK;
        }
        else // if (sp->StationStatus1 & pwr_mPbStationStatus1Mask_NotReady)
        {
          sp->Status = PB__NOTREADY;
        }

        break;
      }

      slave_list = slave_list->next;
    }

    if (log)
    {
      sprintf(
          s, "Slave [%3hhu] [0x%04hX]: Status = 0x%02hhX 0x%02hhX 0x%02hhX, "
             "Master = %3hhu, Ext = %u, Diags = %hu",
          get_slave_diag_con_ptr->rem_add, swap16(diag_data_ptr->ident_number),
          diag_data_ptr->station_status_1, diag_data_ptr->station_status_2,
          diag_data_ptr->station_status_3, diag_data_ptr->master_add,
          get_slave_diag_con_ptr->diag_data_len - DP_MIN_SLAVE_DIAG_LEN,
          get_slave_diag_con_ptr->diag_entries);

      errh_Info("PROFIBUS: DP slave diag - %s", s);
    }

  } /* diag_data_len */
}

static void fdlif_sda_sdn_srd_ind(INT8 invoke_id,
                                  T_FDLIF_SDN_SDA_SRD_REQ* ind_ptr,
                                  io_sRack* slave_list)

/*-----------------------------------------------------------------------------
    FUNCTIONAL_DESCRIPTION

    this function is used to receive a SDN, SDA or SRD indication

possible return values:
    - NONE

    -----------------------------------------------------------------------------*/
{
  USIGN8* data_ptr;
  pwr_sClass_Pb_FDL_SAP* sp;

  if (ind_ptr->length > 0)
  {
    data_ptr = (USIGN8*)(ind_ptr + 1);

    //    print_data (data_ptr, cnf_ptr->length);
    while (slave_list != NULL)
    {
      if (((io_sRackLocal*)slave_list->Local)->fdl)
      {
        sp = (pwr_sClass_Pb_FDL_SAP*)slave_list->op;

        if (sp->SAP_Nr == ind_ptr->ssap)
        {
          io_sCard* card_list = slave_list->cardlist;
          pwr_sClass_Pb_FDL_DataTransfer* cp;
          io_sFDLCardLocal* local_card;

          if (card_list != NULL)
          {
            cp = (pwr_sClass_Pb_FDL_DataTransfer*)card_list->op;
            local_card = (io_sFDLCardLocal*)card_list->Local;

            if (local_card->input_area_size > 0)
              memcpy(local_card->input_area, data_ptr,
                     MIN(local_card->input_area_size, ind_ptr->length));
          }

          break;
        }
      }
      slave_list = slave_list->next;
    }
  }

  return;
}

static void fdlif_srd_con(INT16 result, INT8 invoke_id,
                          T_FDLIF_SRD_CNF* cnf_ptr, io_sRack* slave_list)

/*-----------------------------------------------------------------------------
    FUNCTIONAL_DESCRIPTION

    this function is used to receive a SRD confirmation

possible return values:
    - NONE

    -----------------------------------------------------------------------------*/
{
  // LOCAL_VARIABLES

  USIGN8 FAR* data_ptr;
  pwr_sClass_Pb_FDL_SAP* sp;
  USIGN8 res;

  if (result == POS)
  {
    res = 0;
  }
  else
  {
    res = cnf_ptr->status;
  }

  data_ptr = (USIGN8*)(cnf_ptr + 1);

  while (slave_list != NULL)
  {
    if (((io_sRackLocal*)slave_list->Local)->fdl)
    {
      sp = (pwr_sClass_Pb_FDL_SAP*)slave_list->op;

      if (!sp->Responder)
      {
        io_sCard* card_list = slave_list->cardlist;
        pwr_sClass_Pb_FDL_DataTransfer* cp;
        io_sFDLCardLocal* local_card;

        while (card_list != NULL)
        {
          cp = (pwr_sClass_Pb_FDL_DataTransfer*)card_list->op;
          local_card = (io_sFDLCardLocal*)card_list->Local;

          if ((local_card->invoke_id == invoke_id) &&
              (cp->Type == pwr_ePbFDLDataTransferTypeEnum_FDLIF_SRD))
          {
            cp->Result = res;
            if (cnf_ptr->length > 0)
              memcpy(local_card->input_area, data_ptr,
                     MIN(local_card->input_area_size, cnf_ptr->length));
            break;
          }
          card_list = card_list->next;
        }

        if (card_list != NULL)
          break;
      }
    }
    slave_list = slave_list->next;
  }

  return;
}

static void fdlif_sda_sdn_con(INT8 invoke_id, INT16 result,
                              T_FDLIF_ERROR* err_ptr, io_sRack* slave_list)
{
  pwr_sClass_Pb_FDL_SAP* sp;
  USIGN8 res;

  if (result == POS)
  {
    res = 0;
  }
  else
  {
    res = err_ptr->result;
  }

  //    print_data (data_ptr, cnf_ptr->length);
  while (slave_list != NULL)
  {
    if (((io_sRackLocal*)slave_list->Local)->fdl)
    {
      sp = (pwr_sClass_Pb_FDL_SAP*)slave_list->op;

      if (!sp->Responder)
      {
        io_sCard* card_list = slave_list->cardlist;
        pwr_sClass_Pb_FDL_DataTransfer* cp;
        io_sFDLCardLocal* local_card;

        while (card_list != NULL)
        {
          cp = (pwr_sClass_Pb_FDL_DataTransfer*)card_list->op;
          local_card = (io_sFDLCardLocal*)card_list->Local;

          if (local_card->invoke_id == invoke_id)
          {
            cp->Result = res;
            break;
          }
          card_list = card_list->next;
        }

        if (card_list != NULL)
          break;
      }
    }
    slave_list = slave_list->next;
  }

  return;
}

/*----------------------------------------------------------------------------*\
  Starts download sequence of prm data to one slave
\*----------------------------------------------------------------------------*/
static pwr_tStatus start_download_seq(pwr_sClass_Pb_DP_Slave* op)
{
  T_PROFI_SERVICE_DESCR sdb;
  T_DP_START_SEQ_REQ ssrp;

  USIGN8 con_ind_buffer[256];
  USIGN16 con_ind_buffer_len = 256;
  USIGN16 timeout = 400;
  T_PROFI_SERVICE_DESCR con_ind_sdb;
  INT16 result; /* !!! local result variable !!! */

  sdb.comm_ref = 0;
  sdb.layer = DP;
  sdb.service = DP_START_SEQ_LOC;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;
  sdb.result = 0;

  ssrp.rem_add = 0;
  ssrp.area_code = op->SlaveAddress;
  ssrp.timeout = timeout;

  profi_snd_req_res(&sdb, &ssrp, PB_FALSE);

  try_profi_rcv_con_ind(&con_ind_sdb, con_ind_buffer, &con_ind_buffer_len,
                        &result);

  if ((con_ind_sdb.service == DP_START_SEQ_LOC) &&
      (con_ind_sdb.primitive == CON) && (con_ind_sdb.result == POS))
  {
    op->Status = PB__NOCONN;
    return (PB_TRUE);
  }

  op->Status = PB__INITFAIL;

  return (PB_FALSE);
}

/*----------------------------------------------------------------------------*\
  Starts download sequence of prm data to one slave
\*----------------------------------------------------------------------------*/
static pwr_tStatus end_download_seq(pwr_sClass_Pb_DP_Slave* op)
{
  T_PROFI_SERVICE_DESCR sdb;
  T_DP_END_SEQ_REQ esrp;

  USIGN8 con_ind_buffer[256];
  USIGN16 con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR con_ind_sdb;
  INT16 result; /* !!! local result variable !!! */

  sdb.comm_ref = 0;
  sdb.layer = DP;
  sdb.service = DP_END_SEQ_LOC;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;
  sdb.result = 0;

  esrp.rem_add = 0;
  esrp.dummy = 0;

  profi_snd_req_res(&sdb, &esrp, PB_FALSE);

  try_profi_rcv_con_ind(&con_ind_sdb, con_ind_buffer, &con_ind_buffer_len,
                        &result);

  if ((con_ind_sdb.service == DP_END_SEQ_LOC) &&
      (con_ind_sdb.primitive == CON) && (con_ind_sdb.result == POS))
  {
    op->Status = PB__NOCONN;
    return (PB_TRUE);
  }

  op->Status = PB__INITFAIL;

  return (PB_FALSE);
}

/*----------------------------------------------------------------------------*\
  Initializes one DP slave in the master card
\*----------------------------------------------------------------------------*/
static pwr_tStatus dp_download_slave(pwr_sClass_Pb_DP_Slave* op)
{
  int i;
  T_PROFI_SERVICE_DESCR sdb;
  struct
  {
    T_DP_DOWNLOAD_REQ drp;
    unsigned char param[512];
  } slave_data;

  char* send_buf;

  T_DP_SLAVE_PARA_SET prm_head;
  T_DP_PRM_DATA prm_data;
  T_DP_AAT_DATA aat_data;
  T_DP_SLAVE_USER_DATA user_data;
  USIGN16 download_data_size;
  USIGN16 data_len;
  pwr_tBoolean failure = FALSE;

  USIGN8 con_ind_buffer[256];
  USIGN16 con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR con_ind_sdb;
  INT16 result; /* !!! local result variable !!! */

  op->Status = PB__NOTINIT;

  download_data_size = sizeof(prm_head) + sizeof(prm_data) +
                       op->PrmUserDataLen + op->ConfigDataLen +
                       sizeof(aat_data) + sizeof(user_data);

  data_len = download_data_size;

  sdb.comm_ref = 0;
  sdb.layer = DP;
  sdb.service = DP_DOWNLOAD_LOC;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;
  sdb.result = 0;

  prm_head.slave_para_len = swap16(download_data_size);
  prm_head.sl_flag = DP_SL_NEW_PRM | DP_SL_ACTIVE;
  prm_head.slave_type = DP_SLAVE_TYPE_DP;
  for (i = 0; i < 12; i++)
    prm_head.reserved[i] = 0;

  i = 0;
  memcpy(&slave_data.param[i], &prm_head, sizeof(prm_head));
  i += sizeof(prm_head);

  prm_data.prm_data_len = swap16(sizeof(prm_data) + op->PrmUserDataLen);
  prm_data.station_status = DP_PRM_LOCK_REQ | DP_PRM_WD_ON;
  prm_data.wd_fact_1 = op->WdFact1;
  prm_data.wd_fact_2 = op->WdFact2;
  prm_data.min_tsdr = 0;
  prm_data.ident_number = swap16(op->PNOIdent);
  prm_data.group_ident = op->GroupIdent;

  memcpy(&slave_data.param[i], &prm_data, sizeof(prm_data));
  i += sizeof(prm_data);

  memcpy(&slave_data.param[i], op->PrmUserData, op->PrmUserDataLen);
  i += op->PrmUserDataLen;

  memcpy(&slave_data.param[i], op->ConfigData, op->ConfigDataLen);
  i += op->ConfigDataLen;

  aat_data.aat_data_len = swap16(4); // AAT data not used in array mode
  aat_data.number_inputs = 0;
  aat_data.number_outputs = 0;
  //  aat_data.offset_inputs = 0;
  //  aat_data.offset_outputs = 0;

  memcpy(&slave_data.param[i], &aat_data, sizeof(aat_data));
  i += sizeof(aat_data);

  user_data.slave_user_data_len = swap16(2);

  memcpy(&slave_data.param[i], &user_data, sizeof(user_data));
  i += sizeof(user_data);

  slave_data.drp.rem_add = 0;
  slave_data.drp.area_code = op->SlaveAddress;
  slave_data.drp.add_offset = 0;

  send_buf = (char*)slave_data.param;

  if (data_len > DP_MAX_DOWNLOAD_DATA_LEN)
  {
    if (!start_download_seq(op))
    {
      op->Status = PB__INITFAIL;
      return (PB_FALSE);
    }
  }
  while (download_data_size > 0)
  {
    slave_data.drp.data_len = MIN(download_data_size, DP_MAX_DOWNLOAD_DATA_LEN);

    profi_snd_req_res(&sdb, &slave_data, PB_FALSE);

    try_profi_rcv_con_ind(&con_ind_sdb, con_ind_buffer, &con_ind_buffer_len,
                          &result);

    if (con_ind_sdb.service == DP_DOWNLOAD_LOC)
    {
      if ((con_ind_sdb.primitive == CON) && (con_ind_sdb.result == POS))
      {
        op->Status = PB__NOCONN;
      }
      else
      {
        op->Status = PB__INITFAIL;
        failure = TRUE;
        break;
      }
    }

    if (download_data_size > DP_MAX_DOWNLOAD_DATA_LEN)
    {
      download_data_size -= DP_MAX_DOWNLOAD_DATA_LEN;
      slave_data.drp.add_offset += DP_MAX_DOWNLOAD_DATA_LEN;
      send_buf += DP_MAX_DOWNLOAD_DATA_LEN;
      memcpy(slave_data.param, send_buf,
             MIN(download_data_size, DP_MAX_DOWNLOAD_DATA_LEN));
    }
    else
      download_data_size = 0;
  }

  if (data_len > DP_MAX_DOWNLOAD_DATA_LEN)
  {
    if (!end_download_seq(op))
    {
      op->Status = PB__INITFAIL;
      return (PB_FALSE);
    }
  }

  if (failure)
    return (PB_FALSE);
  else
    return (PB_TRUE);
}

/*----------------------------------------------------------------------------*\
  Calculate offsets of inputs and outputs for a slave
\*----------------------------------------------------------------------------*/
static pwr_tStatus dp_io_offsets(pwr_sClass_Pb_DP_Slave* op)
{
  T_PROFI_SERVICE_DESCR sdb;
  T_DP_GET_SLAVE_PARAM_REQ get_slave_param_req;
  T_DP_GET_SLAVE_PARAM_CON FAR* get_slave_param_con_ptr;
  T_DP_SLAVE_PARAM_SLAVE_INFO FAR* slave_info_ptr;

  USIGN8 con_ind_buffer[256];
  USIGN16 con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR con_ind_sdb;
  INT16 result; /* !!! local result variable !!! */

  sdb.comm_ref = 0;
  sdb.layer = DP;
  sdb.service = DP_GET_SLAVE_PARAM;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;
  sdb.result = 0;

  get_slave_param_req.identifier = DP_SLAVE_PARAM_SLAVE_INFO;
  get_slave_param_req.rem_add = op->SlaveAddress;

  result = profi_snd_req_res(&sdb, &get_slave_param_req, PB_FALSE);

  if (result != E_OK)
    return (result);

  try_profi_rcv_con_ind(&con_ind_sdb, con_ind_buffer, &con_ind_buffer_len,
                        &result);

  get_slave_param_con_ptr = (T_DP_GET_SLAVE_PARAM_CON FAR*)con_ind_buffer;

  if ((con_ind_sdb.service == DP_GET_SLAVE_PARAM) &&
      (con_ind_sdb.primitive == CON) && (con_ind_sdb.result == POS))
  {
    slave_info_ptr =
        (T_DP_SLAVE_PARAM_SLAVE_INFO FAR*)(get_slave_param_con_ptr + 1);

    op->BytesOfInput = slave_info_ptr->number_inputs;
    op->BytesOfOutput = slave_info_ptr->number_outputs;
    op->OffsetInputs = slave_info_ptr->offset_inputs;
    op->OffsetOutputs = slave_info_ptr->offset_outputs;

    return (PB_TRUE);
  }

  return (PB_FALSE);
}

/* Supervision thread */

void* handle_events(void* ptr)
{
  agent_args* args;
  io_sAgentLocal* local;
  io_sAgent* ap;
  short sts;
  pwr_sClass_Pb_Profiboard* op;
  char s[128];

  USIGN8 con_ind_buffer[256];
  USIGN16 con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR con_ind_sdb;
  T_DP_GET_SLAVE_DIAG_CON* get_slave_diag_con_ptr;
  struct timespec rqtp = {0, 10000000}; // 10 ms

  args = (agent_args*)ptr;
  local = (io_sAgentLocal*)args->local;
  ap = args->ap;

  op = (pwr_sClass_Pb_Profiboard*)ap->op;

  /* If everything is fine we should be in state OPERATE
     Make a poll to see if there are diagnostics, the answer also tell us
     if there are any hardware faults. In that case, make a reset and a new
     init. */

  while (1)
  {
    if (op->DisableBus)
      exit(0);

    pthread_mutex_lock(&local->mutex);

    con_ind_buffer_len = 256;
    sts = profi_rcv_con_ind(&con_ind_sdb, con_ind_buffer, &con_ind_buffer_len);

    if (sts == CON_IND_RECEIVED)
    {
      switch (con_ind_sdb.layer)
      {
      case DP_USR:
      {
        if (con_ind_sdb.primitive == CON)
        {
          if (con_ind_sdb.result == POS)
          {
            switch (con_ind_sdb.service)
            {
            /*--------------------------------------------------------------*/

            case DP_ACT_PARAM_LOC:
            {
              if (op->Status == PB__NOTINIT)
              {
                op->Status = PB__STOPPED;
                errh_Info("PROFIBUS: DP Master %s to state STOPPED", ap->Name);
                dp_act_param_loc(DP_OP_MODE_CLEAR);
              }
              else if (op->Status == PB__STOPPED)
              {
                op->Status = PB__CLEARED;
                errh_Info("PROFIBUS: DP Master %s to state CLEARED", ap->Name);
                dp_act_param_loc(DP_OP_MODE_OPERATE);
              }
              else if (op->Status == PB__CLEARED)
              {
                errh_Info("PROFIBUS: DP Master %s to state OPERATE", ap->Name);
                op->Status = PB__NORMAL;

                if (!local->slave_diag_requested && local->parallel_service)
                {
                  if (dp_get_slave_diag())
                  {
                    local->slave_diag_requested = op->Diag[3] = PB_TRUE;
                    local->parallel_service = PB_FALSE;
                  }
                }
              }

              break;
            } /* case DP_ACT_PARAM_LOC */

            /*--------------------------------------------------------------*/

            case DP_GET_SLAVE_DIAG:
            {
              get_slave_diag_con_ptr =
                  (T_DP_GET_SLAVE_DIAG_CON FAR*)con_ind_buffer;

              dp_get_slave_diag_con(get_slave_diag_con_ptr, ap->racklist,
                                    op->Diag[1]);
              op->Diag[2]++;

              local->slave_diag_requested = op->Diag[3] = PB_FALSE;

              if (get_slave_diag_con_ptr->diag_entries < 0)
              {
                errh_Warning("PROFIBUS: Diagnostic circular buffer owerflow");
              }

              if (get_slave_diag_con_ptr->diag_entries)
              {
                local->slave_diag_requested = op->Diag[3] = PB_TRUE;
                dp_get_slave_diag();
              }
              break;
            } /* case DP_GET_SLAVE_DIAG */

            /*--------------------------------------------------------------*/

            default:
            {
              break;
            } /* deafult service */
            } /* switch */
          }   /* if POS */
          else
          {
            op->Status = PB__NOTINIT;
            errh_Error("PROFIBUS: DP Master %s - %x neg con rec", ap->Name,
                       *((unsigned short*)con_ind_buffer));
          } /* else POS */
        }   /* if CON */
        else if (con_ind_sdb.primitive == IND)
        {
          if (con_ind_sdb.result == POS)
          {
            switch (con_ind_sdb.service)
            {
            /*--------------------------------------------------------------*/

            case DP_ACT_PARAM_LOC:
            {
              USIGN8 usif_state;
              usif_state = ((T_DP_ACT_PARAM_IND FAR*)con_ind_buffer)->activate;

              switch (usif_state)
              {
              case DP_OP_MODE_STOP:
              {
                op->Status = PB__STOPPED;
                sprintf(s, "Mode changed to STOP");
                break;
              }
              case DP_OP_MODE_CLEAR:
              {
                op->Status = PB__CLEARED;
                sprintf(s, "Mode changed to CLEAR");
                break;
              }
              case DP_OP_MODE_OPERATE:
              {
                op->Status = PB__NORMAL;
                sprintf(s, "Mode changed to OPERATE");
                break;
              }
              }

              errh_Info("PROFIBUS: DP Master %s - %s", ap->Name, s);

              if (usif_state == DP_OP_MODE_STOP)
              {
                usif_state = DP_OP_MODE_CLEAR;

                dp_act_param_loc(DP_OP_MODE_CLEAR);
              }
              else if (usif_state == DP_OP_MODE_CLEAR)
              {
                usif_state = DP_OP_MODE_OPERATE;

                dp_act_param_loc(DP_OP_MODE_OPERATE);
              }

              break;
            } /* case DP_ACT_PARAM_LOC */

            /*--------------------------------------------------------------*/

            case DP_GET_SLAVE_DIAG:
            {
              get_slave_diag_con_ptr =
                  (T_DP_GET_SLAVE_DIAG_CON FAR*)con_ind_buffer;

              dp_get_slave_diag_con(get_slave_diag_con_ptr, ap->racklist,
                                    op->Diag[1]);

              op->Diag[0]++;

              if (get_slave_diag_con_ptr->diag_entries < 0)
              {
                errh_Warning("PROFIBUS: Diagnostic circular buffer owerflow");
              }

              if ((get_slave_diag_con_ptr->diag_entries) &&
                  (!local->slave_diag_requested))
              {
                if (op->Status == PB__NORMAL)
                {
                  if (dp_get_slave_diag())
                  {
                    local->slave_diag_requested = op->Diag[3] = PB_TRUE;
                  }
                  else
                  {
                    errh_Warning("PROFIBUS: Request for diag failed");
                  }
                }
                else
                {
                  local->parallel_service = PB_TRUE;
                }
              }

              break;
            } /* case DP_GET_SLAVE_DIAG */

            /*--------------------------------------------------------------*/

            default:
            {
              break;
            } /* deafult service */
            } /* switch */
          }   /* if POS */
          else
          {
            op->Status = PB__NOTINIT;
            errh_Error("PROPFIBUS: DP Master %s - %x neg ind rec", ap->Name,
                       *((unsigned short*)con_ind_buffer));
          } /* else POS */
        }   /* if IND */
        break;
      }

      case FMB_USR:
      {
        switch (con_ind_sdb.service)
        {
        /*--------------------------------------------------------------*/
        /*--------------------------------------------------------------*/
        case FMB_SET_CONFIGURATION:
        case FMB_EXIT:
        case FMB_RESET:
        {
          break;
        }
        case FMB_FM2_EVENT:
        {
          switch (((T_FMB_FM2_EVENT_IND FAR*)con_ind_buffer)->reason)
          {
          case FM2_FAULT_ADDRESS:
            sprintf(s, "Duplicate address recognized");
            break;
          case FM2_FAULT_PHY:
            sprintf(s, "Phys.layer is malfunctioning");
            break;
          case FM2_FAULT_TTO:
            sprintf(s, "Time out on bus detected    ");
            break;
          case FM2_FAULT_SYN:
            sprintf(s, "No receiver synchronization ");
            break;
          case FM2_FAULT_OUT_OF_RING:
            sprintf(s, "Station out of ring         ");
            break;
          case FM2_GAP_EVENT:
            sprintf(s, "New station in ring         ");
            break;

          default:
            sprintf(s, "Unknown reason code received");

          } /* switch reason */

          errh_Info("PROFIBUS: DP Master %s - %s", ap->Name, s);

          break;
        } /* case FMB_FM2_EVENT */

        default:
        {
          printf("\nnot supported FMB service received\n");
          printf("service: %d primitive: %d\n", con_ind_sdb.service,
                 con_ind_sdb.primitive);
          break;
        } /* deafult service */
        } /* switch */
        break;
      }
      case FDLIF_USR:
      {
        switch (con_ind_sdb.service)
        {
        case FDLIF_EVENT:
        case FDLIF_SET_BUSPARAMETER:
        case FDLIF_READ_BUSPARAMETER:
        case FDLIF_SAP_ACTIVATE:
        case FDLIF_RSAP_ACTIVATE:
        case FDLIF_SAP_DEACTIVATE:
        case FDLIF_SAP_CHANGE_ACCESS:
        case FDLIF_REPLY_UPDATE:
        case FDLIF_REPLY_UPDATE_MULTIPLE:
        case FDLIF_EXIT:
          break;

        case FDLIF_SDN:
          if (con_ind_sdb.primitive == IND)
          {
            fdlif_sda_sdn_srd_ind(con_ind_sdb.invoke_id,
                                  (T_FDLIF_SDN_SDA_SRD_REQ FAR*)con_ind_buffer,
                                  ap->racklist);
          }
          else
          {
            fdlif_sda_sdn_con(con_ind_sdb.invoke_id, con_ind_sdb.result,
                              (T_FDLIF_ERROR*)con_ind_buffer, ap->racklist);
          }
          break;

        case FDLIF_SDA:
          if (con_ind_sdb.primitive == IND)
          {
            fdlif_sda_sdn_srd_ind(con_ind_sdb.invoke_id,
                                  (T_FDLIF_SDN_SDA_SRD_REQ FAR*)con_ind_buffer,
                                  ap->racklist);
          }
          else
          {
            fdlif_sda_sdn_con(con_ind_sdb.invoke_id, con_ind_sdb.result,
                              (T_FDLIF_ERROR*)con_ind_buffer, ap->racklist);
          }
          break;

        case FDLIF_SRD:
          if (con_ind_sdb.primitive == IND)
          {
            fdlif_sda_sdn_srd_ind(con_ind_sdb.invoke_id,
                                  (T_FDLIF_SDN_SDA_SRD_REQ FAR*)con_ind_buffer,
                                  ap->racklist);
          }
          else
          {
            fdlif_srd_con(con_ind_sdb.result, con_ind_sdb.invoke_id,
                          (T_FDLIF_SRD_CNF*)con_ind_buffer, ap->racklist);
          }
          break;

        default:
          printf("\nnot supported FDLIF service received\n");
          printf("service: %d primitive: %d\n", con_ind_sdb.service,
                 con_ind_sdb.primitive);
        }
        break;
      }

      default:
        printf("\nnot supported layer service received\n");
        printf("layer: %d service: %d primitive: %d\n", con_ind_sdb.layer,
               con_ind_sdb.service, con_ind_sdb.primitive);
        break;
      }
    }
    else if (sts != NO_CON_IND_RECEIVED)
    {
      op->Status = PB__NOTINIT;
    }
    else
    {
      if (local->slave_diag_requested)
      {
        //	errh_Info( "Profibus - Diag re-request");
        //	dp_get_slave_diag(hDevice);
      }
    }
    pthread_mutex_unlock(&local->mutex);

    nanosleep(&rqtp, NULL);
  }
}
/*----------------------------------------------------------------------------*\
   Init method for the Pb_profiboard agent
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentInit(io_tCtx ctx, io_sAgent* ap)
{
  pwr_sClass_Pb_Profiboard* op;
  pwr_tUInt16 sts;
  pwr_tStatus status;
  io_sAgentLocal* local;

  pwr_tCid cid;

  char ok;

  pwr_tObjid slave_objid;
  pwr_tClassId slave_class;

  void* sop;

  char name[196];

  struct timespec rqtp = {0, 20000000}; // 20 ms

  int retry;

  count = 0;

  /* Allocate area for local data structure */
  ap->Local = calloc(1, sizeof(io_sAgentLocal));
  if (!ap->Local)
  {
    errh_Error("PROFIBUS: ERROR config DP Master %s - %s", ap->Name, "calloc");
    return IO__ERRINIDEVICE;
  }

  local = (io_sAgentLocal*)ap->Local;

  op = (pwr_sClass_Pb_Profiboard*)ap->op;

  op->Status = PB__NOTINIT;

  /* Initialize interface */

  if (ctx->Node->Restarts > 0)
  {
    nanosleep(&rqtp, NULL);
  }

  errh_Info("PROFIBUS: Initializing interface for DP Master %s", ap->Name);
  sts = profi_init((unsigned char)op->BusNumber - 1, 0, 0);

  if (sts != E_OK)
  {
    /* Can't open driver */
    op->Status = PB__INITFAIL;
    errh_Error("PROFIBUS: ERROR config DP Master %s - %s", ap->Name,
               "open device");
    ctx->Node->EmergBreakTrue = 1;
    return IO__ERRDEVICE;
  }

  /* If this is not the Profibus I/O process, return */

  if ((op->Process & io_mProcess_Profibus) &&
      (ctx->Process != io_mProcess_Profibus))
  {
    op->Status = PB__NOTINIT;
    errh_Info("PROFIBUS: Init template I/O agent for DP Master %s, %d",
              ap->Name, ctx->Process);
    return IO__SUCCESS;
  }

  if (ctx->Node->Restarts > 0)
  {
    errh_Info("PROFIBUS: Warm restart - Skipping config of DP Master %s",
              ap->Name);
    op->Status = PB__NORMAL;
    //    return IO__SUCCESS;
  }

  errh_Info("PROFIBUS: Config of DP Master %s", ap->Name);

  if (op->DisableBus != 1)
  {
    ok = FALSE;

    if (ctx->Node->Restarts == 0)
    {
      retry = 0;
      while (!ok)
      {
        op->Status = PB__NOTINIT;

        /* Set FMB configuration */

        sts = fmb_set_configuration(ap);
        if (!sts)
        {
          op->Status = PB__INITFAIL;
          errh_Error("PROFIBUS: ERROR config DP Master %s - %s", ap->Name,
                     "fmb set configuration");
          retry++;
          if (retry < 2)
          {
            nanosleep(&rqtp, NULL);
            continue;
          }
          return IO__ERRINIDEVICE;
        }

        /* Set DP master parameters */

        if (local->dp)
        {
          sts = dp_init_master();
          if (!sts)
          {
            op->Status = PB__INITFAIL;
            errh_Error("PROFIBUS: ERROR config DP Master %s - %s", ap->Name,
                       "dp init master");
            return IO__ERRINIDEVICE;
          }
        }

        /* Download DP bus parameters */

        if (local->dp && !local->fdl)
        {
          sts = dp_download_bus(op);
          if (!sts)
          {
            op->Status = PB__INITFAIL;
            errh_Error("PROFIBUS: ERROR config DP Master %s - %s", ap->Name,
                       "dp download bus");
            return IO__ERRINIDEVICE;
          }
        }
        else if (!local->dp && local->fdl)
        {
          sts = fmb_set_busparameter(op);
          if (!sts)
          {
            op->Status = PB__INITFAIL;
            errh_Error("PROFIBUS: ERROR config FDL Master %s - %s", ap->Name,
                       "fmb set busparam");
            return IO__ERRINIDEVICE;
          }
          else
            op->Status = PB__NORMAL;
        }
        else
        {
          sts = fmb_set_busparameter(op);
          if (!sts)
          {
            op->Status = PB__INITFAIL;
            errh_Error("PROFIBUS: ERROR config Master %s - %s", ap->Name,
                       "fmb set busparam");
            return IO__ERRINIDEVICE;
          }
          sts = dp_set_busparameter(op);
          if (!sts)
          {
            op->Status = PB__INITFAIL;
            errh_Error("PROFIBUS: ERROR config DP Master %s - %s", ap->Name,
                       "dp set busparam");
            return IO__ERRINIDEVICE;
          }
        }

        /* Loop through all slaves (traverse agent's children) and initialize
         * them */

        op->NumberSlaves = 0;
        status = gdh_GetChild(ap->Objid, &slave_objid);

        while (ODD(status))
        {
          status = gdh_GetObjectClass(slave_objid, &slave_class);

          cid = slave_class;

          while (ODD(gdh_GetSuperClass(cid, &cid, pwr_cNOid)))
            ;

          status = gdh_ObjidToPointer(slave_objid, (pwr_tAddress*)&sop);
          status = gdh_ObjidToName(slave_objid, (char*)&name, sizeof(name),
                                   cdh_mNName);

          if (cid == pwr_cClass_Pb_DP_Slave)
          {
            errh_Info("PROFIBUS: Download DP Slave config - %s", name);

            status = dp_download_slave((pwr_sClass_Pb_DP_Slave*)sop);

            if (!status)
            {
              errh_Error("PROFIBUS: ERROR Init DP slave %s", name);
            }

            op->NumberSlaves++;
          }

          if (cid == pwr_cClass_Pb_FDL_SAP)
          {
            errh_Info("PROFIBUS: Download FDL SAP config - %s", name);

            if (!((pwr_sClass_Pb_FDL_SAP*)sop)->Responder)
              status = fdlif_sap_activate_req((pwr_sClass_Pb_FDL_SAP*)sop);
            else
              status = fdlif_rsap_activate_req((pwr_sClass_Pb_FDL_SAP*)sop);

            if (!status)
            {
              ((pwr_sClass_Pb_FDL_SAP*)sop)->Status = PB__INITFAIL;
              errh_Error("PROFIBUS: ERROR Init FDL SAP %s", name);
            }
            else
              ((pwr_sClass_Pb_FDL_SAP*)sop)->Status = PB__NORMAL;
          }

          status = gdh_GetNextSibling(slave_objid, &slave_objid);
        }

        /* Calculate offsets of inputs and outputs for a slave */

        status = gdh_GetChild(ap->Objid, &slave_objid);

        while (ODD(status))
        {
          status = gdh_GetObjectClass(slave_objid, &slave_class);

          cid = slave_class;

          while (ODD(gdh_GetSuperClass(cid, &cid, pwr_cNOid)))
            ;

          if (cid == pwr_cClass_Pb_DP_Slave)
          {
            status = gdh_ObjidToPointer(slave_objid, (pwr_tAddress*)&sop);
            status = dp_io_offsets(sop);
          }
          status = gdh_GetNextSibling(slave_objid, &slave_objid);
        }

        /* Move to STOP mode, this will fix the DPRAM layout */

        if (local->dp)
        {
          sts = dp_act_param_loc(DP_OP_MODE_STOP);
          if (sts != E_OK)
          {
            op->Status = PB__INITFAIL;
            errh_Error("PROFIBUS: ERROR config DP Master %s - %s", ap->Name,
                       "act param loc to STOPPED");
            return IO__ERRINIDEVICE;
          }
        }

        ok = TRUE;

      } /* End - While !ok */
    }   /* End - Initialization only if not restart   */
    /*    else {
           Move to STOP mode, this will fix the DPRAM layout

          sts = dp_act_param_loc(hDevice, DP_OP_MODE_STOP);
          if (sts != E_OK) {
            op->Status = PB__INITFAIL;
            errh_Error( "ERROR config Profibus DP Master %s - %s", ap->Name,
       "act param loc to STOPPED");
            return IO__ERRINIDEVICE;
          }
        } */
  }
  else
    op->Status = PB__DISABLED;

  return IO__SUCCESS;
}

/*----------------------------------------------------------------------------*\
   Read method for the Pb_Profiboard agent
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentRead(io_tCtx ctx, io_sAgent* ap)
{
  io_sAgentLocal* local;
  pwr_sClass_Pb_Profiboard* op;
  pwr_tUInt16 sts;

  pwr_sClass_Pb_Profiboard* mp;
  pwr_sClass_Pb_DP_Slave* sp;
  pwr_tUInt16 data_len;
  io_sRack* slave_list;

  local = (io_sAgentLocal*)ap->Local;
  op = (pwr_sClass_Pb_Profiboard*)ap->op;

  /* Activate supervision thread, first cycle */

  if (!local->args.local)
  {
    pthread_attr_t attr;
    pthread_mutexattr_t mutexattr;

    local->args.local = local;
    local->args.ap = ap;
    local->args.ctx = ctx;

    pthread_mutexattr_init(&mutexattr);
    pthread_mutex_init(&local->mutex, &mutexattr);
    pthread_mutexattr_destroy(&mutexattr);
    pthread_attr_init(&attr);
    pthread_attr_setinheritsched(&attr, PTHREAD_INHERIT_SCHED);
    pthread_create(&local->events, &attr, handle_events, &local->args);
  }

  pthread_mutex_lock(&local->mutex);

  /* Iterate over the slaves.  */
  for (slave_list = ap->racklist; slave_list != NULL;
       slave_list = slave_list->next)
  {
    if (((io_sRackLocal*)slave_list->Local)->dp)
    {
      sp = (pwr_sClass_Pb_DP_Slave*)slave_list->op;
      mp = (pwr_sClass_Pb_Profiboard*)ap->op;

      /* Read process data.  */
      if (sp->Status == PB__NORMAL && mp->Status == PB__NORMAL &&
          sp->DisableSlave != 1 && mp->DisableBus != 1)
      {
        data_len = sp->BytesOfInput;
        sts = profi_get_data(ID_DP_SLAVE_IO_IMAGE, sp->OffsetInputs, &data_len,
                             &sp->Inputs);
      }
    }
  }

  pthread_mutex_unlock(&local->mutex);

  return IO__SUCCESS;
}

/*----------------------------------------------------------------------------*\
   Write method for the Pb_Profiboard agent
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentWrite(io_tCtx ctx, io_sAgent* ap)
{
  io_sAgentLocal* local;
  pwr_tUInt16 sts;

  pwr_sClass_Pb_Profiboard* mp;
  pwr_sClass_Pb_DP_Slave* sp;
  io_sRack* slave_list;

  local = (io_sAgentLocal*)ap->Local;

  pthread_mutex_lock(&local->mutex);

  /* Iterate over the slaves.  */
  for (slave_list = ap->racklist; slave_list != NULL;
       slave_list = slave_list->next)
  {
    if (((io_sRackLocal*)slave_list->Local)->dp)
    {
      sp = (pwr_sClass_Pb_DP_Slave*)slave_list->op;
      mp = (pwr_sClass_Pb_Profiboard*)ap->op;

      // Write the whole I/O output area from local area

      if ((sp->Status == PB__NORMAL || sp->Status == PB__NOCONN) &&
          mp->Status == PB__NORMAL && (sp->DisableSlave != 1) &&
          (mp->DisableBus != 1))
      {
        if (sp->BytesOfOutput > 0)
        {
          sts = profi_set_data(ID_DP_SLAVE_IO_IMAGE, sp->OffsetOutputs,
                               sp->BytesOfOutput, &sp->Outputs);

          if (sts != E_OK)
            sp->ErrorCount++;
        }
      }
    }
  }

  pthread_mutex_unlock(&local->mutex);

  return IO__SUCCESS;
}

/*----------------------------------------------------------------------------*\

\*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentClose(io_tCtx ctx, io_sAgent* ap)
{
  io_sAgentLocal* local;
  pwr_tStatus sts = PB_FALSE;

  T_PROFI_SERVICE_DESCR sdb;

  USIGN8 con_ind_buffer[256];
  USIGN16 con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR con_ind_sdb;
  INT16 result; /* !!! local result variable !!! */

  if (ctx->Node->EmergBreakTrue == 1)
    errh_Fatal("PROFIBUS: Emergency break detected! Shutting down PROFIBUS!");

  local = (io_sAgentLocal*)ap->Local;
  if (!local)
    return IO__SUCCESS;

  pthread_cancel(local->events);

  pthread_mutex_lock(&local->mutex);

  sdb.comm_ref = 0;
  sdb.layer = DP;
  sdb.service = DP_EXIT_MASTER;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;
  sdb.result = 0;

  profi_snd_req_res(&sdb, &sdb, PB_FALSE);

  try_profi_rcv_con_ind(&con_ind_sdb, con_ind_buffer, &con_ind_buffer_len,
                        &result);

  if ((con_ind_sdb.service == DP_EXIT_MASTER) &&
      (con_ind_sdb.primitive == CON) && (con_ind_sdb.result == POS))
  {
    sts = PB_TRUE;
  }

  profi_end();

  pthread_mutex_unlock(&local->mutex);
  // Iterate through all devices and propagate stopped state to all children
  if (ap)
  {
    ((pwr_sClass_Pb_Profiboard*)ap->op)->Status = PB__STOPPED;
    io_sRack* device;
    io_sCard* module;
    pwr_sClass_Pb_DP_Slave* dev;
    pwr_sClass_Pb_Module* mod;
    for (device = ap->racklist; device != NULL; device = device->next)
    {
      dev = (pwr_sClass_Pb_DP_Slave*)device->op;
      dev->Status = PB__STOPPED;
      for (module = device->cardlist; module != NULL; module = module->next)
      {
        mod = (pwr_sClass_Pb_Module*)module->op;
        mod->Status = PB__STOPPED;
      }
    }
  }

  free((char*)local);

  return sts;
}

static pwr_tStatus IoAgentSwap(io_tCtx ctx, io_sAgent* ap, io_eEvent event)
{
  switch (event) {
  case io_eEvent_EmergencyBreak:
    IoAgentClose(ctx, ap);
    break;
  case io_eEvent_IoCommEmergencyBreak:
  default:
    break;
  }


  return IO__SUCCESS;
}

/*----------------------------------------------------------------------------*\
  Every method to be exported to the workbench should be registred here.
\*----------------------------------------------------------------------------*/

pwr_dExport pwr_BindIoMethods(Pb_Profiboard) = {
    pwr_BindIoMethod(IoAgentInit), pwr_BindIoMethod(IoAgentRead),
    pwr_BindIoMethod(IoAgentWrite), pwr_BindIoMethod(IoAgentClose),
    pwr_BindIoMethod(IoAgentSwap), pwr_NullMethod};
