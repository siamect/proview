/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2014 SSAB AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

/* rt_io_m_pb_profiboard.c -- io methods for the profibus master object
   The PbMaster object serves as agent for one Profibus DP bus
   The board we use is Profiboard from Softing
*/


#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <sys/file.h>
#include <sys/ioctl.h>

#include "keywords.h"

#pragma pack(1)
#include "pb_type.h"
#include "pb_conf.h"
#include "pb_if.h"
#include "pb_err.h"
#include "pb_fmb.h"
#include "pb_dp.h"
#include "pb_fdl.h"
#pragma pack(0)

#include "pwr.h"
#include "co_cdh.h"
#include "pwr_baseclasses.h"
#include "pwr_profibusclasses.h"
#include "rt_io_base.h"
#include "rt_io_bus.h"
#include "rt_io_msg.h"
#include "rt_errh.h"
#include "rt_io_agent_init.h"
#include "rt_pb_msg.h"

#include "rt_io_profiboard.h"

#include "rt_io_pb_locals.h"

#define DP_MAX_SERVICE_RETRY    10



static int count;

static pwr_tStatus IoAgentInit (
  io_tCtx	ctx,
  io_sAgent	*ap
);
static pwr_tStatus IoAgentRead (
  io_tCtx	ctx,
  io_sAgent	*ap
);
static pwr_tStatus IoAgentWrite (
  io_tCtx	ctx,
  io_sAgent	*ap
);
static pwr_tStatus IoAgentClose (
  io_tCtx	ctx,
  io_sAgent	*ap
);
static pwr_tStatus IoAgentSwap (
  io_tCtx	ctx,
  io_sAgent	*ap,
  io_eEvent     event
);



/*----------------------------------------------------------------------------*\
  Sends request to Profiboard for setting FMB parameters
\*----------------------------------------------------------------------------*/
static short try_profi_rcv_con_ind(T_PROFI_DEVICE_HANDLE *hDevice,
                                   T_PROFI_SERVICE_DESCR  *con_ind_sdb,  
				   USIGN8  *con_ind_buffer,
				   USIGN16 *con_ind_buffer_len,
				   INT16   *result) 
{
  int retry_counter;
  struct timespec rqtp = {0, 10000000}; // 10 ms  
  retry_counter = DP_MAX_SERVICE_RETRY;

  do {
    nanosleep(&rqtp, NULL);
    *result = profi_rcv_con_ind (hDevice, con_ind_sdb, con_ind_buffer, con_ind_buffer_len);
  } while ((*result == NO_CON_IND_RECEIVED) && (retry_counter-- > 0));

  if (*result == E_IF_FATAL_ERROR) return (PB_FALSE);

  return (PB_TRUE);
}
/*----------------------------------------------------------------------------*\
  Sends request to Profiboard for setting FMB parameters
\*----------------------------------------------------------------------------*/
static short fmb_set_configuration(T_PROFI_DEVICE_HANDLE *hDevice,  
				   io_sAgent  *ap) 
{
  T_PROFI_SERVICE_DESCR sdb;
  T_FMB_SET_CONFIGURATION_REQ data;

  USIGN8                   con_ind_buffer [256];
  USIGN16                  con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR    con_ind_sdb;
  INT16                    result;              /* !!! local result variable !!! */
  io_sRack                 *slave_list;
  pwr_sClass_Pb_Profiboard *op;
  pwr_tCid                 cid;

  slave_list = ap->racklist;
  op = ap->op;

  memset(&data, 0, sizeof(T_FMB_SET_CONFIGURATION_REQ));

  /* Iterate over the slaves.  */
  for (slave_list = ap->racklist; slave_list != NULL;
      slave_list = slave_list->next) {
    cid = slave_list->Class;

    while ( ODD( gdh_GetSuperClass( cid, &cid, pwr_cNOid))) ;

    if (cid == pwr_cClass_Pb_DP_Slave) ((io_sAgentLocal *) ap->Local)->dp = PB_TRUE;
    if (cid == pwr_cClass_Pb_FDL_SAP) ((io_sAgentLocal *) ap->Local)->fdl = PB_TRUE;
  }

  sdb.comm_ref = 0;
  sdb.layer = FMB;
  sdb.service = FMB_SET_CONFIGURATION;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;
  sdb.result = 0;

  data.fms_active = PB_FALSE;
  data.dp_active = ((io_sAgentLocal *) ap->Local)->dp;
  data.fdlif_active = ((io_sAgentLocal *) ap->Local)->fdl;
  data.fdl_evt_receiver = FMB_USR;
  data.sm7_active = PB_FALSE;
  data.data_buffer_length = 256;

  data.dp.max_number_slaves = op->MaxNumberSlaves;
  data.dp.max_slave_output_len = op->MaxSlaveOutputLen;
  data.dp.max_slave_input_len = op->MaxSlaveInputLen;
  data.dp.max_slave_diag_entries = op->MaxNumberSlaves * 4;
  data.dp.max_slave_diag_len = op->MaxSlaveDiagLen;
  if ( data.dp.max_slave_diag_len == 0)
    data.dp.max_slave_diag_len = 60;
  data.dp.max_bus_para_len = 1024;
  data.dp.max_slave_para_len = 1024;

  data.fdlif.send_req_credits = 20;
  data.fdlif.srd_req_credits  = 20;
  data.fdlif.receive_credits  = 20;
  data.fdlif.max_no_resp_saps = 20;



  profi_snd_req_res(hDevice, &sdb, &data, PB_FALSE);

  try_profi_rcv_con_ind(hDevice, &con_ind_sdb, con_ind_buffer, &con_ind_buffer_len, &result);
  
  if ((con_ind_sdb.service   == FMB_SET_CONFIGURATION) &&
      (con_ind_sdb.primitive == CON                  ) &&
      (con_ind_sdb.result    == POS                  )) {
    return (PB_TRUE);
  }

  return (PB_FALSE);

}


/*----------------------------------------------------------------------------*\
  Sends request to Profiboard for setting DP master parameters
\*----------------------------------------------------------------------------*/
static short dp_init_master(T_PROFI_DEVICE_HANDLE *hDevice)
{
  T_PROFI_SERVICE_DESCR sdb;
  T_DP_INIT_MASTER_REQ data;

  USIGN8                   con_ind_buffer [256];
  USIGN16                  con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR    con_ind_sdb;
  INT16                    result;              /* !!! local result variable !!! */

  sdb.comm_ref = 0;
  sdb.layer = DP;
  sdb.service = DP_INIT_MASTER;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;
  sdb.result = 0;

  data.master_default_address = 0;
  data.master_class2 = PB_FALSE;
  data.lowest_slave_address = 2;
  data.slave_io_address_mode = DP_AAM_IO_BLOCKS; // only mode possible with Linux-driver DP_AAM_ARRAY;
  data.clear_outputs = PB_TRUE;
  data.auto_remote_services = DP_AUTO_REMOTE_SERVICES;
  data.cyclic_data_transfer = PB_TRUE;

  profi_snd_req_res(hDevice, &sdb, &data, PB_FALSE);

  try_profi_rcv_con_ind(hDevice, &con_ind_sdb, con_ind_buffer, &con_ind_buffer_len, &result);
  
  if ((con_ind_sdb.service   == DP_INIT_MASTER) &&
      (con_ind_sdb.primitive == CON                  ) &&
      (con_ind_sdb.result    == POS                  )) {
    return (PB_TRUE);
  }

  return (PB_FALSE);
}


/*----------------------------------------------------------------------------*\
  Sends request to Profiboard for setting DP bus parameters
\*----------------------------------------------------------------------------*/
static short dp_download_bus(T_PROFI_DEVICE_HANDLE *hDevice,  
			    pwr_sClass_Pb_Profiboard *op)
{
  T_PROFI_SERVICE_DESCR sdb;
  struct {
    T_DP_DOWNLOAD_REQ drp; 
    T_DP_BUS_PARA_SET dbp;
  } data;
  int i;

  USIGN8                   con_ind_buffer [256];
  USIGN16                  con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR    con_ind_sdb;
  INT16                    result;              /* !!! local result variable !!! */

  sdb.comm_ref = 0;
  sdb.layer = DP;
  sdb.service = DP_DOWNLOAD_LOC;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;
  sdb.result = 0;

  data.drp.data_len =  66;
  data.drp.rem_add = 0;
  data.drp.area_code = DP_AREA_BUS_PARAM;
  data.drp.add_offset = 0;

  data.dbp.bus_para_len = swap16(66);
  data.dbp.fdl_add = 0;

  switch (op->BaudRate) {
    case 500:
      data.dbp.baud_rate = DP_KBAUD_500;
      break;
    case 750:
      data.dbp.baud_rate = DP_KBAUD_750;
      break;
    case 1500:
      data.dbp.baud_rate = DP_KBAUD_1500;
      break;
    case 3000:
      data.dbp.baud_rate = DP_KBAUD_3000;
      break;
    case 6000:
      data.dbp.baud_rate = DP_KBAUD_6000;
      break;
    case 12000:
      data.dbp.baud_rate = DP_KBAUD_12000;
      break;
    default:
      data.dbp.baud_rate = DP_KBAUD_1500;
      break;
  }

  data.dbp.tsl = swap16(op->Tsl);
  data.dbp.min_tsdr = swap16(op->MinTsdr);
  data.dbp.max_tsdr = swap16(op->MaxTsdr);
  data.dbp.tqui = op->Tqui;
  data.dbp.tset = op->Tset;
  data.dbp.ttr = swap32(op->Ttr);
  data.dbp.g = op->G;
  data.dbp.hsa = op->Hsa;
  data.dbp.max_retry_limit = op->MaxRetryLimit;
  data.dbp.bp_flag = op->BpFlag;
  data.dbp.min_slave_interval = swap16(op->MinSlaveInterval);
  data.dbp.poll_timeout = swap16(op->PollTimeout);
  data.dbp.data_control_time = swap16(op->DataControlTime);
  for (i=0; i<6; i++) 
    data.dbp.reserved[i] = 0;
  data.dbp.master_user_data_len = swap16(DP_MASTER_USER_DATA_LEN);
  for (i=0; i<32; i++) 
    data.dbp.master_class2_name[i] = 0;

  profi_snd_req_res(hDevice, &sdb, &data, PB_FALSE);

  try_profi_rcv_con_ind(hDevice, &con_ind_sdb, con_ind_buffer, &con_ind_buffer_len, &result);

  if ((con_ind_sdb.service   == DP_DOWNLOAD_LOC) &&
      (con_ind_sdb.primitive == CON                  ) &&
      (con_ind_sdb.result    == POS                  )) {
    return (PB_TRUE);
  }

  return (PB_FALSE);

}

/*********************** FMB_SET_BUSPARAMETER ******************************/

static short fmb_set_busparameter(T_PROFI_DEVICE_HANDLE *hDevice,  
			    pwr_sClass_Pb_Profiboard *op)
/* ------------------------------------------------------------------------ */
/* FUNCTIONAL_DESCRIPTION:                                                  */
/*                                                                          */
/* Set Busparameters for a DP/V1 network                                    */
/* ------------------------------------------------------------------------ */
{

  T_FMB_SET_BUSPARAMETER_REQ  bus_par_req;
  T_PROFI_SERVICE_DESCR       sdb;

  USIGN8                   con_ind_buffer [256];
  USIGN16                  con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR    con_ind_sdb;
  INT16                    result;              /* !!! local result variable !!! */


  /* set data block parameters */

  bus_par_req.loc_add         = op->SlaveAddress;

  bus_par_req.in_ring_desired = 255;
  bus_par_req.loc_segm        = 255;
  bus_par_req.medium_red      = 0;

  switch (op->BaudRate) {
    case 500:
      bus_par_req.baud_rate = DP_KBAUD_500;
      break;
    case 750:
      bus_par_req.baud_rate = DP_KBAUD_750;
      break;
    case 1500:
      bus_par_req.baud_rate = DP_KBAUD_1500;
      break;
    case 3000:
      bus_par_req.baud_rate = DP_KBAUD_3000;
      break;
    case 6000:
      bus_par_req.baud_rate = DP_KBAUD_6000;
      break;
    case 12000:
      bus_par_req.baud_rate = DP_KBAUD_12000;
      break;
    default:
      bus_par_req.baud_rate = DP_KBAUD_1500;
      break;
  }

  bus_par_req.tset            = op->Tset;
  bus_par_req.tsl             = op->Tsl;
  bus_par_req.min_tsdr        = op->MinTsdr;
  bus_par_req.max_tsdr        = op->MaxTsdr;
  bus_par_req.tqui            = op->Tqui;
  bus_par_req.max_retry_limit = op->MaxRetryLimit;

  bus_par_req.ttr             = op->Ttr;
  bus_par_req.g               = op->G;
  bus_par_req.hsa             = op->Hsa;

  /* Set Description block */

  sdb.comm_ref   = 0;
  sdb.layer      = FMB;
  sdb.service    = FMB_SET_BUSPARAMETER;
  sdb.primitive  = REQ;

  /* Send Request */

  profi_snd_req_res(hDevice, &sdb, &bus_par_req, PB_FALSE);

  try_profi_rcv_con_ind(hDevice, &con_ind_sdb, con_ind_buffer, &con_ind_buffer_len, &result);

  if ((con_ind_sdb.service   == FMB_SET_BUSPARAMETER) &&
      (con_ind_sdb.primitive == CON                  ) &&
      (con_ind_sdb.result    == POS                  )) {
    return (PB_TRUE);
  }

  return (PB_FALSE);


} /* fmb_set_busparameter */

/*********************** DP_SET_BUSPARAMETER ******************************/

static short dp_set_busparameter(T_PROFI_DEVICE_HANDLE *hDevice,  
			    pwr_sClass_Pb_Profiboard *op)
/* ------------------------------------------------------------------------ */
/* FUNCTIONAL_DESCRIPTION:                                                  */
/*                                                                          */
/* Set Busparameters for a DP/V1 network                                    */
/* ------------------------------------------------------------------------ */
{

  T_DP_SET_BUSPARAMETER_REQ  bus_par_req;
  T_PROFI_SERVICE_DESCR       sdb;

  USIGN8                   con_ind_buffer [256];
  USIGN16                  con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR    con_ind_sdb;
  INT16                    result;              /* !!! local result variable !!! */


  memset(&bus_par_req, 0, sizeof(T_DP_SET_BUSPARAMETER_REQ));

  /* set data block parameters */

  bus_par_req.bp_flag = op->BpFlag;
  bus_par_req.min_slave_interval = op->MinSlaveInterval;
  bus_par_req.poll_timeout = op->PollTimeout;
  bus_par_req.data_control_time = op->DataControlTime;
  bus_par_req.master_user_data_len = DP_MASTER_USER_DATA_LEN;

  /* Set Description block */

  sdb.comm_ref   = 0;
  sdb.layer      = DP;
  sdb.service    = DP_SET_BUSPARAMETER;
  sdb.primitive  = REQ;

  /* Send Request */

  profi_snd_req_res(hDevice, &sdb, &bus_par_req, PB_FALSE);

  con_ind_sdb.service = 0;
  while (con_ind_sdb.service != DP_SET_BUSPARAMETER)
    try_profi_rcv_con_ind(hDevice, &con_ind_sdb, con_ind_buffer, &con_ind_buffer_len, &result);

  if ((con_ind_sdb.service   == DP_SET_BUSPARAMETER) &&
      (con_ind_sdb.primitive == CON                  ) &&
      (con_ind_sdb.result    == POS                  )) {
    return (PB_TRUE);
  }

  return (PB_FALSE);


} /* dp_set_busparameter */

static short fdlif_sap_activate_req(T_PROFI_DEVICE_HANDLE *hDevice,  
			    pwr_sClass_Pb_FDL_SAP *op)

/*-----------------------------------------------------------------------------
    FUNCTIONAL_DESCRIPTION

    this function is used to activate a SAP

possible return values:

    - == E_OK    -> no error
    - != E_OK    -> error

    -----------------------------------------------------------------------------*/
{
// LOCAL_VARIABLES

  T_PROFI_SERVICE_DESCR    sdb;
  T_FDLIF_SAP_ACTIVATE_REQ sap;
  USIGN8                   con_ind_buffer [256];
  USIGN16                  con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR    con_ind_sdb;
  INT16                    result;              /* !!! local result variable !!! */

// FUNCTION_BODY

  sap.sap_nr = op->SAP_Nr;

  /* --- set data block parameters ------------------------------------ */
  sap.max_l_sdu_length_req      = 244;
  sap.max_l_sdu_length_con_ind  = 244;
  sap.access_sap                = ALL;
  sap.access_station            = ALL;
  sap.sda                       = BOTH_ROLES;
  sap.sdn                       = BOTH_ROLES;
  sap.srd                       = BOTH_ROLES;
  sap.csrd                      = SERVICE_NOT_ACTIVATED;
  sap.data_mode                 = NORMAL_MODE;
  sap.credits                   = 2;

  /* --- set parameter block parameters -------------------------------------- */
  sdb.comm_ref   = 0;
  sdb.layer      = FDLIF;
  sdb.service    = FDLIF_SAP_ACTIVATE;
  sdb.primitive  = REQ;
  sdb.invoke_id  = 0;

  /* Send Request */

  profi_snd_req_res(hDevice, &sdb, &sap, PB_FALSE);

  con_ind_sdb.service = 0;

  while (con_ind_sdb.service != FDLIF_SAP_ACTIVATE)
    try_profi_rcv_con_ind(hDevice, &con_ind_sdb, con_ind_buffer, &con_ind_buffer_len, &result);

  if ((con_ind_sdb.service   == FDLIF_SAP_ACTIVATE) &&
      (con_ind_sdb.primitive == CON                  ) &&
      (con_ind_sdb.result    == POS                  )) {
    return (PB_TRUE);
  }

  return (PB_FALSE);


}

static short fdlif_rsap_activate_req(T_PROFI_DEVICE_HANDLE *hDevice,  
			    pwr_sClass_Pb_FDL_SAP *op)

/*-----------------------------------------------------------------------------
    FUNCTIONAL_DESCRIPTION

    this function is used to activate a RSAP

possible return values:

    - == E_OK    -> no error
    - != E_OK    -> error

    -----------------------------------------------------------------------------*/
{
// LOCAL_VARIABLES

  T_PROFI_SERVICE_DESCR     sdb;
  T_FDLIF_RSAP_ACTIVATE_REQ rsap;
  USIGN8                   con_ind_buffer [256];
  USIGN16                  con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR    con_ind_sdb;
  INT16                    result;              /* !!! local result variable !!! */

// FUNCTION_BODY

  rsap.sap_nr = op->SAP_Nr;

  /* --- set data block parameters ------------------------------------ */
  rsap.max_l_sdu_length_req      = 244;
  rsap.max_l_sdu_length_ind      = 244;
  rsap.access_sap                = ALL;
  rsap.access_station            = ALL;
  rsap.data_mode                 = NORMAL_MODE;
  rsap.credits                   = 2;

  /* --- set parameter block parameters -------------------------------------- */
  sdb.comm_ref   = 0;
  sdb.layer      = FDLIF;
  sdb.service    = FDLIF_RSAP_ACTIVATE;
  sdb.primitive  = REQ;
  sdb.invoke_id  = 0;

  /* Send Request */

  profi_snd_req_res(hDevice, &sdb, &rsap, PB_FALSE);

  con_ind_sdb.service = 0;

  while (con_ind_sdb.service != FDLIF_RSAP_ACTIVATE)
    try_profi_rcv_con_ind(hDevice, &con_ind_sdb, con_ind_buffer, &con_ind_buffer_len, &result);

  if ((con_ind_sdb.service   == FDLIF_RSAP_ACTIVATE) &&
      (con_ind_sdb.primitive == CON                  ) &&
      (con_ind_sdb.result    == POS                  )) {
    return (PB_TRUE);
  }

  return (PB_FALSE);


}


/*----------------------------------------------------------------------------*\
  Sends request for selecting operation mode to the Profiboard
\*----------------------------------------------------------------------------*/
static short dp_act_param_loc(T_PROFI_DEVICE_HANDLE *hDevice, 
			   short arg) {
  T_PROFI_SERVICE_DESCR sdb;
  T_DP_ACT_PARAM_REQ apr;
  pwr_tUInt16 retval;
    
  /* Fill the service description block */
  sdb.comm_ref = 0;
  sdb.layer = DP;
  sdb.service = DP_ACT_PARAM_LOC;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;
  sdb.result = 0;

  apr.rem_add = 0;
  apr.area_code = DP_AREA_SET_MODE;
  apr.activate = arg;
  apr.dummy = 0;

  retval = profi_snd_req_res(hDevice, &sdb, &apr, PB_FALSE);

  return retval;
}

/*----------------------------------------------------------------------------*\
  Sends request for getting slave diagnostics
\*----------------------------------------------------------------------------*/
static pwr_tBoolean dp_get_slave_diag(T_PROFI_DEVICE_HANDLE *hDevice) 
{
  T_PROFI_SERVICE_DESCR sdb;
  pwr_tUInt16 retval;
    
  /* Fill the service description block */
  sdb.comm_ref = 0;
  sdb.layer = DP;
  sdb.service = DP_GET_SLAVE_DIAG;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;
  sdb.result = 0;

  retval = profi_snd_req_res(hDevice, &sdb, &sdb, PB_FALSE);

  return ((pwr_tBoolean) (retval == E_OK));
}

/*----------------------------------------------------------------------------*\
  Get slave diagnostics
\*----------------------------------------------------------------------------*/
static void dp_get_slave_diag_con(T_DP_GET_SLAVE_DIAG_CON * get_slave_diag_con_ptr, io_sRack *slave_list, char log) 
{
  T_DP_DIAG_DATA    FAR *diag_data_ptr;
  char                     s [128];
  pwr_sClass_Pb_DP_Slave  *sp;

  if (get_slave_diag_con_ptr->diag_data_len >= DP_MIN_SLAVE_DIAG_LEN)
  {
    diag_data_ptr = (T_DP_DIAG_DATA FAR*) (get_slave_diag_con_ptr + 1);

    while (slave_list != NULL) {
      sp = (pwr_sClass_Pb_DP_Slave *) slave_list->op;
      
      if (sp->SlaveAddress == get_slave_diag_con_ptr->rem_add) {
        sp->StationStatus1 = diag_data_ptr->station_status_1;
        sp->StationStatus2 = diag_data_ptr->station_status_2;
        sp->StationStatus3 = diag_data_ptr->station_status_3;
	
	sp->BytesOfDiag = get_slave_diag_con_ptr->diag_data_len - DP_MIN_SLAVE_DIAG_LEN;
	
	memcpy(sp->Diag, diag_data_ptr + 1, MIN(get_slave_diag_con_ptr->diag_data_len - DP_MIN_SLAVE_DIAG_LEN, DP_MAX_EXT_DIAG_DATA_LEN));	
	
	/* Update slave status */
	
	if (!(sp->StationStatus1 & ~pwr_mPbStationStatus1Mask_ExternalDiag) &&
	    !(sp->StationStatus2 & ~(pwr_mPbStationStatus2Mask_Default |
		                     pwr_mPbStationStatus2Mask_ResponseMonitoringOn))) {
	  sp->Status = PB__NORMAL;
	}
	else if (sp->StationStatus1 & pwr_mPbStationStatus1Mask_NonExistent) {
	  sp->Status = PB__NOCONN;
	}
	else if ((sp->StationStatus1 & (pwr_mPbStationStatus1Mask_ConfigFault |
	                                pwr_mPbStationStatus1Mask_ParamFault)) ||
	         (sp->StationStatus2 & pwr_mPbStationStatus2Mask_NewParamsRequested)) {
	  sp->Status = PB__CONFIGERR;
        } 
	else if (sp->StationStatus1 & pwr_mPbStationStatus1Mask_MasterLock) {
	  sp->Status = PB__MASTERLOCK;
	}
	else //if (sp->StationStatus1 & pwr_mPbStationStatus1Mask_NotReady) 
	{
	  sp->Status = PB__NOTREADY;
	}
	
	
	break;
      }
      
      slave_list = slave_list->next;
    }

    if (log) {
      sprintf (s, "Slave [%3hu] [0x%04hX]: Status = 0x%02hX 0x%02hX 0x%02hX, Master = %3hu, Ext = %hu, Diags = %hu",
	       get_slave_diag_con_ptr->rem_add,
	       swap16 (diag_data_ptr->ident_number),
	       diag_data_ptr->station_status_1,
	       diag_data_ptr->station_status_2,
	       diag_data_ptr->station_status_3,
	       diag_data_ptr->master_add,
	       get_slave_diag_con_ptr->diag_data_len - DP_MIN_SLAVE_DIAG_LEN,
	       get_slave_diag_con_ptr->diag_entries);
      
      errh_Info( "Profibus DP slave diag - %s", s);
    }

  } /* diag_data_len */

}

static void fdlif_sda_sdn_srd_ind(INT8   invoke_id,
                                  T_FDLIF_SDN_SDA_SRD_REQ *ind_ptr,
                                  io_sRack *slave_list
                                 )

/*-----------------------------------------------------------------------------
    FUNCTIONAL_DESCRIPTION

    this function is used to receive a SDN, SDA or SRD indication

possible return values:
    - NONE

    -----------------------------------------------------------------------------*/
{

  USIGN8                  *data_ptr;
  pwr_sClass_Pb_FDL_SAP  *sp;

  if (ind_ptr->length > 0) {

    data_ptr = (USIGN8 *) (ind_ptr + 1);

    //    print_data (data_ptr, cnf_ptr->length);
    while (slave_list != NULL) {

      if (((io_sRackLocal *) slave_list->Local)->fdl) {

        sp = (pwr_sClass_Pb_FDL_SAP *) slave_list->op;

        if (sp->SAP_Nr == ind_ptr->ssap) {
          io_sCard *card_list = slave_list->cardlist;
          pwr_sClass_Pb_FDL_DataTransfer *cp;
          io_sFDLCardLocal *local_card;

          if (card_list != NULL) {
            cp = (pwr_sClass_Pb_FDL_DataTransfer *) card_list->op;
            local_card = (io_sFDLCardLocal *) card_list->Local;

            if (local_card->input_area_size > 0)            
              memcpy(local_card->input_area, data_ptr, MIN(local_card->input_area_size, ind_ptr->length));
          }
          
          break;
        }
      }
      slave_list = slave_list->next;
    }
  }

  return;
}

static void fdlif_srd_con(
                                   INT16               result,
                                   INT8                invoke_id,
                                   T_FDLIF_SRD_CNF *cnf_ptr, 
                                   io_sRack *slave_list
                                  )

/*-----------------------------------------------------------------------------
    FUNCTIONAL_DESCRIPTION

    this function is used to receive a SRD confirmation

possible return values:
    - NONE

    -----------------------------------------------------------------------------*/
{
// LOCAL_VARIABLES

  USIGN8  FAR *data_ptr;
  pwr_sClass_Pb_FDL_SAP  *sp;
  USIGN8 res;

  if (result == POS) {
    res = 0;
  } else {
    res = cnf_ptr->status;
  }

  data_ptr = (USIGN8 *) (cnf_ptr + 1);
    
  while (slave_list != NULL) {

    if (((io_sRackLocal *) slave_list->Local)->fdl) {
      
      sp = (pwr_sClass_Pb_FDL_SAP *) slave_list->op;
      
      if (!sp->Responder) {
        io_sCard *card_list = slave_list->cardlist;
        pwr_sClass_Pb_FDL_DataTransfer *cp;
        io_sFDLCardLocal *local_card;
          
        while (card_list != NULL) {
          cp = (pwr_sClass_Pb_FDL_DataTransfer *) card_list->op;
          local_card = (io_sFDLCardLocal *) card_list->Local;
          
          if ((local_card->invoke_id == invoke_id) && (cp->Type == pwr_ePbFDLDataTransferTypeEnum_FDLIF_SRD)) {
            cp->Result = res;
            if (cnf_ptr->length > 0)
              memcpy(local_card->input_area, data_ptr, MIN(local_card->input_area_size, cnf_ptr->length));
            break;
            
          }
          card_list = card_list->next;
        }
        
        if (card_list != NULL) break;
      }
    }
    slave_list = slave_list->next;
  }
  
  return;
}

static void fdlif_sda_sdn_con(INT8   invoke_id,
                              INT16  result,
                              T_FDLIF_ERROR *err_ptr,
                              io_sRack *slave_list
                              )
{
  pwr_sClass_Pb_FDL_SAP  *sp;
  USIGN8                 res;

  if (result == POS) {
    res = 0;
  } else {
    res = err_ptr->result;
  }

  //    print_data (data_ptr, cnf_ptr->length);
  while (slave_list != NULL) {

    if (((io_sRackLocal *) slave_list->Local)->fdl) {

      sp = (pwr_sClass_Pb_FDL_SAP *) slave_list->op;
      
      if (!sp->Responder) {
        io_sCard *card_list = slave_list->cardlist;
        pwr_sClass_Pb_FDL_DataTransfer *cp;
        io_sFDLCardLocal *local_card;
        
        while (card_list != NULL) {
          cp = (pwr_sClass_Pb_FDL_DataTransfer *) card_list->op;
          local_card = (io_sFDLCardLocal *) card_list->Local;
            
          if (local_card->invoke_id == invoke_id) {
            cp->Result = res;
            break;
              
          }
          card_list = card_list->next;
        }
          
        if (card_list != NULL) break;
      }
    }
    slave_list = slave_list->next;
  }
  
  return;
}


/*----------------------------------------------------------------------------*\
  Starts download sequence of prm data to one slave
\*----------------------------------------------------------------------------*/
static pwr_tStatus start_download_seq (
  T_PROFI_DEVICE_HANDLE *hDevice,
  pwr_sClass_Pb_DP_Slave *op
)
{
  T_PROFI_SERVICE_DESCR   sdb;
  T_DP_START_SEQ_REQ      ssrp;

  USIGN8                   con_ind_buffer [256];
  USIGN16                  con_ind_buffer_len = 256;
  USIGN16                  timeout = 400;
  T_PROFI_SERVICE_DESCR    con_ind_sdb;
  INT16                    result;              /* !!! local result variable !!! */

  sdb.comm_ref = 0;
  sdb.layer = DP;
  sdb.service = DP_START_SEQ_LOC;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;
  sdb.result = 0;

  ssrp.rem_add = 0;
  ssrp.area_code = op->SlaveAddress;
  ssrp.timeout = timeout;

  profi_snd_req_res(hDevice, &sdb, &ssrp, PB_FALSE);

  try_profi_rcv_con_ind(hDevice, &con_ind_sdb, con_ind_buffer, &con_ind_buffer_len, &result);

  if ((con_ind_sdb.service   == DP_START_SEQ_LOC) &&
      (con_ind_sdb.primitive == CON                  ) &&
      (con_ind_sdb.result    == POS                  )) {
    op->Status = PB__NOCONN;
    return (PB_TRUE);
  }

  op->Status = PB__INITFAIL;

  return (PB_FALSE);

}

/*----------------------------------------------------------------------------*\
  Starts download sequence of prm data to one slave
\*----------------------------------------------------------------------------*/
static pwr_tStatus end_download_seq (
  T_PROFI_DEVICE_HANDLE *hDevice,
  pwr_sClass_Pb_DP_Slave *op
)
{
  T_PROFI_SERVICE_DESCR   sdb;
  T_DP_END_SEQ_REQ        esrp;

  USIGN8                   con_ind_buffer [256];
  USIGN16                  con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR    con_ind_sdb;
  INT16                    result;              /* !!! local result variable !!! */

  sdb.comm_ref = 0;
  sdb.layer = DP;
  sdb.service = DP_END_SEQ_LOC;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;
  sdb.result = 0;

  esrp.rem_add = 0;
  esrp.dummy = 0;

  profi_snd_req_res(hDevice, &sdb, &esrp, PB_FALSE);

  try_profi_rcv_con_ind(hDevice, &con_ind_sdb, con_ind_buffer, &con_ind_buffer_len, &result);

  if ((con_ind_sdb.service   == DP_END_SEQ_LOC) &&
      (con_ind_sdb.primitive == CON                  ) &&
      (con_ind_sdb.result    == POS                  )) {
    op->Status = PB__NOCONN;
    return (PB_TRUE);
  }

  op->Status = PB__INITFAIL;

  return (PB_FALSE);

}

/*----------------------------------------------------------------------------*\
  Initializes one DP slave in the master card
\*----------------------------------------------------------------------------*/
static pwr_tStatus dp_download_slave (
  T_PROFI_DEVICE_HANDLE *hDevice,
  pwr_sClass_Pb_DP_Slave *op
)
{

  int i;
  T_PROFI_SERVICE_DESCR   sdb;
  struct {
    T_DP_DOWNLOAD_REQ drp; 
    unsigned char param[512];
  } slave_data;

  char  *send_buf;

  T_DP_SLAVE_PARA_SET prm_head;
  T_DP_PRM_DATA prm_data;
  T_DP_AAT_DATA aat_data;
  T_DP_SLAVE_USER_DATA user_data;
  USIGN16 download_data_size;
  USIGN16 data_len;
  pwr_tBoolean failure = FALSE;

  USIGN8                   con_ind_buffer [256];
  USIGN16                  con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR    con_ind_sdb;
  INT16                    result;              /* !!! local result variable !!! */

  op->Status = PB__NOTINIT;
 
  download_data_size = sizeof(prm_head) + sizeof(prm_data) + 
			op->PrmUserDataLen + op->ConfigDataLen +
			sizeof(aat_data) + sizeof(user_data);

  data_len = download_data_size;

  sdb.comm_ref = 0;
  sdb.layer = DP;
  sdb.service = DP_DOWNLOAD_LOC;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;
  sdb.result = 0;

  prm_head.slave_para_len = swap16(download_data_size);
  prm_head.sl_flag = DP_SL_NEW_PRM | DP_SL_ACTIVE;
  prm_head.slave_type = DP_SLAVE_TYPE_DP;
  for (i = 0; i < 12; i++) prm_head.reserved[i] = 0;
  
  i = 0;
  memcpy(&slave_data.param[i], &prm_head, sizeof(prm_head));
  i += sizeof(prm_head);

  prm_data.prm_data_len = swap16(sizeof(prm_data) + op->PrmUserDataLen);
  prm_data.station_status = DP_PRM_LOCK_REQ | DP_PRM_WD_ON;
  prm_data.wd_fact_1 = op->WdFact1;
  prm_data.wd_fact_2 = op->WdFact2;
  prm_data.min_tsdr = 0;
  prm_data.ident_number = swap16(op->PNOIdent);
  prm_data.group_ident = op->GroupIdent;

  memcpy(&slave_data.param[i], &prm_data, sizeof(prm_data));
  i += sizeof(prm_data);

  memcpy(&slave_data.param[i], op->PrmUserData, op->PrmUserDataLen);
  i += op->PrmUserDataLen;

  memcpy(&slave_data.param[i], op->ConfigData, op->ConfigDataLen);
  i += op->ConfigDataLen;

  aat_data.aat_data_len = swap16(4);		// AAT data not used in array mode
  aat_data.number_inputs = 0;
  aat_data.number_outputs = 0;
//  aat_data.offset_inputs = 0;
//  aat_data.offset_outputs = 0;

  memcpy(&slave_data.param[i], &aat_data, sizeof(aat_data));
  i += sizeof(aat_data);

  user_data.slave_user_data_len = swap16(2);

  memcpy(&slave_data.param[i], &user_data, sizeof(user_data));
  i += sizeof(user_data);

  slave_data.drp.rem_add = 0;
  slave_data.drp.area_code = op->SlaveAddress;
  slave_data.drp.add_offset = 0;

  send_buf = (char *) slave_data.param;

  if (data_len > DP_MAX_DOWNLOAD_DATA_LEN) {
    if (!start_download_seq(hDevice, op)) {
      op->Status = PB__INITFAIL;      
      return (PB_FALSE);
    }
  }
  while (download_data_size > 0) {
    
    slave_data.drp.data_len = MIN(download_data_size, DP_MAX_DOWNLOAD_DATA_LEN);
    
    profi_snd_req_res(hDevice, &sdb, &slave_data, PB_FALSE);
    
    try_profi_rcv_con_ind(hDevice, &con_ind_sdb, con_ind_buffer, &con_ind_buffer_len, &result);
    
    if (con_ind_sdb.service   == DP_DOWNLOAD_LOC) { 
      if ((con_ind_sdb.primitive == CON                  ) &&
	  (con_ind_sdb.result    == POS                  )) {
	op->Status = PB__NOCONN;
      } else {
	op->Status = PB__INITFAIL;
	failure = TRUE;
	break;
      }
    }
    
    if (download_data_size >  DP_MAX_DOWNLOAD_DATA_LEN) {
      download_data_size -= DP_MAX_DOWNLOAD_DATA_LEN;
      slave_data.drp.add_offset += DP_MAX_DOWNLOAD_DATA_LEN;
      send_buf += DP_MAX_DOWNLOAD_DATA_LEN;
      memcpy(slave_data.param, send_buf, MIN(download_data_size, DP_MAX_DOWNLOAD_DATA_LEN));
    }
    else
      download_data_size = 0;
  }

  if (data_len > DP_MAX_DOWNLOAD_DATA_LEN) {
    if (!end_download_seq(hDevice, op)) {
      op->Status = PB__INITFAIL;      
      return (PB_FALSE);
    }
  }
  
  if (failure)
    return (PB_FALSE);
  else
    return (PB_TRUE);

}


/*----------------------------------------------------------------------------*\
  Calculate offsets of inputs and outputs for a slave
\*----------------------------------------------------------------------------*/
static pwr_tStatus dp_io_offsets (
  T_PROFI_DEVICE_HANDLE *hDevice,
  pwr_sClass_Pb_DP_Slave *op
)
{
  T_PROFI_SERVICE_DESCR         sdb;
  T_DP_GET_SLAVE_PARAM_REQ      get_slave_param_req;
  T_DP_GET_SLAVE_PARAM_CON      FAR *get_slave_param_con_ptr;
  T_DP_SLAVE_PARAM_SLAVE_INFO   FAR *slave_info_ptr;

  USIGN8                   con_ind_buffer [256];
  USIGN16                  con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR    con_ind_sdb;
  INT16                    result;              /* !!! local result variable !!! */

  sdb.comm_ref = 0;
  sdb.layer = DP;
  sdb.service = DP_GET_SLAVE_PARAM;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;
  sdb.result = 0;

  get_slave_param_req.identifier = DP_SLAVE_PARAM_SLAVE_INFO;
  get_slave_param_req.rem_add    = op->SlaveAddress;

  result = profi_snd_req_res (hDevice, &sdb, &get_slave_param_req, PB_FALSE);

  if (result != E_OK) return (result);
  
  try_profi_rcv_con_ind(hDevice, &con_ind_sdb, con_ind_buffer, &con_ind_buffer_len, &result);

  get_slave_param_con_ptr = (T_DP_GET_SLAVE_PARAM_CON FAR*) con_ind_buffer;

  if ( (con_ind_sdb.service   == DP_GET_SLAVE_PARAM) &&
       (con_ind_sdb.primitive == CON               ) &&
       (con_ind_sdb.result    == POS               ) )
  {
    slave_info_ptr = (T_DP_SLAVE_PARAM_SLAVE_INFO FAR*) (get_slave_param_con_ptr + 1);
    
    op->BytesOfInput  = slave_info_ptr->number_inputs;
    op->BytesOfOutput = slave_info_ptr->number_outputs;
    op->OffsetInputs  = slave_info_ptr->offset_inputs;
    op->OffsetOutputs = slave_info_ptr->offset_outputs;

    return (PB_TRUE);

  } 
  
  return (PB_FALSE);
}

/* Supervision thread */

void *handle_events(void *ptr) {
  agent_args           *args;
  io_sAgentLocal       *local;
  io_sAgent            *ap;
  short                          sts;
  T_PROFI_DEVICE_HANDLE *hDevice;
  pwr_sClass_Pb_Profiboard *op;
  char                     s [128];

  USIGN8                   con_ind_buffer [256];
  USIGN16                  con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR    con_ind_sdb;
  T_DP_GET_SLAVE_DIAG_CON  *get_slave_diag_con_ptr;
  struct timespec rqtp = {0, 10000000}; // 10 ms  

  args = (agent_args *) ptr;
  local = (io_sAgentLocal *) args->local;
  ap = args->ap;

  hDevice = (T_PROFI_DEVICE_HANDLE *) ap->Local;
  op = (pwr_sClass_Pb_Profiboard *) ap->op;

  /* If everything is fine we should be in state OPERATE
     Make a poll to see if there are diagnostics, the answer also tell us
     if there are any hardware faults. In that case, make a reset and a new init. */
    
  while (1) {
    
    if (op->DisableBus) exit(0);

    pthread_mutex_lock(&local->mutex);

    con_ind_buffer_len = 256;
    sts = profi_rcv_con_ind (  hDevice, &con_ind_sdb, con_ind_buffer, &con_ind_buffer_len);
    
    if (sts == CON_IND_RECEIVED) {

      switch(con_ind_sdb.layer) {

      case DP_USR: {

        
        if (con_ind_sdb.primitive == CON) {
          if (con_ind_sdb.result == POS) {
            switch (con_ind_sdb.service) {
	    /*--------------------------------------------------------------*/
	    
            case DP_ACT_PARAM_LOC: {
	    
              if (op->Status == PB__NOTINIT) {
                op->Status = PB__STOPPED;
                errh_Info( "Profibus DP Master %s to state STOPPED", ap->Name);
                dp_act_param_loc(hDevice, DP_OP_MODE_CLEAR);
              }
              else if (op->Status == PB__STOPPED) {
                op->Status = PB__CLEARED;
                errh_Info( "Profibus DP Master %s to state CLEARED", ap->Name);
                dp_act_param_loc(hDevice, DP_OP_MODE_OPERATE);
              }
              else if (op->Status == PB__CLEARED) {
                errh_Info( "Profibus DP Master %s to state OPERATE", ap->Name);
                op->Status = PB__NORMAL;
                
                if (!local->slave_diag_requested && local->parallel_service) {
                  if (dp_get_slave_diag(hDevice)) {
                    local->slave_diag_requested = op->Diag[3] = PB_TRUE;
                    local->parallel_service = PB_FALSE;
                  } 
                }
                
              }
              
              break;
            } /* case DP_ACT_PARAM_LOC */
	    
              /*--------------------------------------------------------------*/
              
            case DP_GET_SLAVE_DIAG: {
              get_slave_diag_con_ptr = (T_DP_GET_SLAVE_DIAG_CON FAR*) con_ind_buffer;
              
              dp_get_slave_diag_con (get_slave_diag_con_ptr, ap->racklist, op->Diag[1]);
              op->Diag[2]++;
              
              local->slave_diag_requested = op->Diag[3] = PB_FALSE;
              
              if (get_slave_diag_con_ptr->diag_entries < 0) {
                errh_Warning( "Profibus - diagnostic circular buffer owerflow.");
              }
              
              if (get_slave_diag_con_ptr->diag_entries) {
                local->slave_diag_requested = op->Diag[3] = PB_TRUE;
                dp_get_slave_diag (hDevice);
              }
              break;
            } /* case DP_GET_SLAVE_DIAG */
              
              /*--------------------------------------------------------------*/
              
            default: {
              break;
            } /* deafult service */
            } /* switch */
          } /* if POS */
          else {
            op->Status = PB__NOTINIT;
            errh_Error( "Profibus DP Master %s - %x neg con rec", ap->Name, *((unsigned short *) con_ind_buffer) );      
          } /* else POS */
        } /* if CON */
        else if (con_ind_sdb.primitive == IND) {
          if (con_ind_sdb.result == POS) {
            switch (con_ind_sdb.service) {
              
              /*--------------------------------------------------------------*/
              
            case DP_ACT_PARAM_LOC: {
              USIGN8 usif_state;
              usif_state = ((T_DP_ACT_PARAM_IND FAR*) con_ind_buffer)->activate;
              
              switch (usif_state) {
              case DP_OP_MODE_STOP   : {
                op->Status = PB__STOPPED;
                sprintf (s, "Mode changed to STOP");
                break;
              }
              case DP_OP_MODE_CLEAR  : {
                op->Status = PB__CLEARED;
                sprintf (s, "Mode changed to CLEAR");
                break;
              }
              case DP_OP_MODE_OPERATE: { 
                op->Status = PB__NORMAL;
                sprintf (s, "Mode changed to OPERATE");
                break;
              }
              }
	    
              errh_Info( "Profibus DP Master %s - %s", ap->Name, s );      
              
              if (usif_state == DP_OP_MODE_STOP) {
                usif_state = DP_OP_MODE_CLEAR;
                
                dp_act_param_loc(hDevice, DP_OP_MODE_CLEAR);
              }
              else if (usif_state == DP_OP_MODE_CLEAR) {
                usif_state = DP_OP_MODE_OPERATE;
                
                dp_act_param_loc (hDevice, DP_OP_MODE_OPERATE);
              }
              
              break;
            } /* case DP_ACT_PARAM_LOC */
	    
	    /*--------------------------------------------------------------*/
              
            case DP_GET_SLAVE_DIAG: {
              get_slave_diag_con_ptr = (T_DP_GET_SLAVE_DIAG_CON FAR*) con_ind_buffer;
              
              dp_get_slave_diag_con (get_slave_diag_con_ptr, ap->racklist, op->Diag[1]);
              
              op->Diag[0]++;
              
              if (get_slave_diag_con_ptr->diag_entries < 0) {
                errh_Warning( "Profibus - diagnostic circular buffer owerflow.");
              }
              
              if ( (get_slave_diag_con_ptr->diag_entries) &&
                   (! local->slave_diag_requested              ) ) {
                if (op->Status == PB__NORMAL) {
                  if (dp_get_slave_diag(hDevice)) {
                    local->slave_diag_requested = op->Diag[3] = PB_TRUE;
                  } else {
                    errh_Warning( "Profibus - Request for diag failed.");
                  }
                } else {
                  local->parallel_service = PB_TRUE;
                }
              }
              
              break;
            } /* case DP_GET_SLAVE_DIAG */
	    
              /*--------------------------------------------------------------*/
              
            default: {
              break;
            } /* deafult service */
            } /* switch */
          } /* if POS */
          else {
            op->Status = PB__NOTINIT;
            errh_Error( "Profibus DP Master %s - %x neg ind rec", ap->Name,  *((unsigned short *) con_ind_buffer) );      
          } /* else POS */
        } /* if IND */
        break;
      }

      case FMB_USR: {
        switch (con_ind_sdb.service) {
	    /*--------------------------------------------------------------*/
              /*--------------------------------------------------------------*/
        case FMB_SET_CONFIGURATION:
        case FMB_EXIT: 
        case FMB_RESET: {
          break;
        }
        case FMB_FM2_EVENT: {
          switch (((T_FMB_FM2_EVENT_IND FAR*) con_ind_buffer)->reason) {
          case FM2_FAULT_ADDRESS     : sprintf (s, "Duplicate address recognized"); break;
          case FM2_FAULT_PHY         : sprintf (s, "Phys.layer is malfunctioning"); break;
          case FM2_FAULT_TTO         : sprintf (s, "Time out on bus detected    "); break;
          case FM2_FAULT_SYN         : sprintf (s, "No receiver synchronization "); break;
          case FM2_FAULT_OUT_OF_RING : sprintf (s, "Station out of ring         "); break;
          case FM2_GAP_EVENT         : sprintf (s, "New station in ring         "); break;
            
          default                    : sprintf (s, "Unknown reason code received");
            
          } /* switch reason */
              
          errh_Info( "Profibus DP Master %s - %s", ap->Name, s );      
              
          break;
        } /* case FMB_FM2_EVENT */
              
        default: {
          printf("\nnot supported FMB service received\n");
          printf("service: %d primitive: %d\n",con_ind_sdb.service,con_ind_sdb.primitive);
          break;
        } /* deafult service */
        } /* switch */
        break;
      }
      case FDLIF_USR: {
        switch(con_ind_sdb.service) {
        case FDLIF_EVENT:
        case FDLIF_SET_BUSPARAMETER:
        case FDLIF_READ_BUSPARAMETER:
        case FDLIF_SAP_ACTIVATE:
        case FDLIF_RSAP_ACTIVATE:
        case FDLIF_SAP_DEACTIVATE:
        case FDLIF_SAP_CHANGE_ACCESS:
        case FDLIF_REPLY_UPDATE:
        case FDLIF_REPLY_UPDATE_MULTIPLE:
        case FDLIF_EXIT:
          break;

        case FDLIF_SDN:
          if (con_ind_sdb.primitive == IND) {
            fdlif_sda_sdn_srd_ind(con_ind_sdb.invoke_id, (T_FDLIF_SDN_SDA_SRD_REQ FAR*) con_ind_buffer, ap->racklist);
          }
          else {
            fdlif_sda_sdn_con(con_ind_sdb.invoke_id, con_ind_sdb.result, (T_FDLIF_ERROR *) con_ind_buffer, ap->racklist);
          }
          break;
          
        case FDLIF_SDA:
          if (con_ind_sdb.primitive == IND) {
            fdlif_sda_sdn_srd_ind(con_ind_sdb.invoke_id, (T_FDLIF_SDN_SDA_SRD_REQ FAR*) con_ind_buffer, ap->racklist);
          }
          else {
            fdlif_sda_sdn_con(con_ind_sdb.invoke_id, con_ind_sdb.result, (T_FDLIF_ERROR *) con_ind_buffer, ap->racklist);
          }
          break;
          
        case FDLIF_SRD:
          if (con_ind_sdb.primitive == IND) {
            fdlif_sda_sdn_srd_ind(con_ind_sdb.invoke_id, (T_FDLIF_SDN_SDA_SRD_REQ FAR*) con_ind_buffer, ap->racklist);
          }
          else {
            fdlif_srd_con(con_ind_sdb.result, con_ind_sdb.invoke_id, (T_FDLIF_SRD_CNF *) con_ind_buffer, ap->racklist);
          }
          break;

        default:
          printf("\nnot supported FDLIF service received\n");
          printf("service: %d primitive: %d\n",con_ind_sdb.service, con_ind_sdb.primitive);
        }
        break;
      }

      default:
        printf("\nnot supported layer service received\n");
        printf("layer: %d service: %d primitive: %d\n", con_ind_sdb.layer, con_ind_sdb.service, con_ind_sdb.primitive);
        break;
      }

    } else if (sts != NO_CON_IND_RECEIVED) {
      op->Status = PB__NOTINIT;
    } else {
      if (local->slave_diag_requested) {
	//	errh_Info( "Profibus - Diag re-request");
	//	dp_get_slave_diag(hDevice);
      }
    }    
    pthread_mutex_unlock(&local->mutex);

    nanosleep(&rqtp, NULL);
  }
  

}
/*----------------------------------------------------------------------------*\
   Init method for the Pb_profiboard agent  
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentInit (
  io_tCtx	ctx,
  io_sAgent	*ap
) 
{
  pwr_sClass_Pb_Profiboard *op;
  pwr_tUInt16 sts;
  pwr_tStatus status;
  T_PROFI_DEVICE_HANDLE *hDevice;
  io_sAgentLocal	*local;

  pwr_tCid cid;

  char ok;

  pwr_tObjid slave_objid;
  pwr_tClassId slave_class;

  void *sop;

  char name[196];

  struct timespec rqtp = {0, 20000000}; // 20 ms  
  
  int retry;
    
  count=0;

  /* Allocate area for local data structure */
  ap->Local = calloc(1, sizeof(io_sAgentLocal));
  if (!ap->Local) {
    errh_Error( "ERROR config Profibus DP Master %s - %s", ap->Name, "calloc");
    return IO__ERRINIDEVICE;
  }
    
  hDevice = (T_PROFI_DEVICE_HANDLE *) ap->Local;

  local = (io_sAgentLocal *) ap->Local;

  op = (pwr_sClass_Pb_Profiboard *) ap->op;

  op->Status = PB__NOTINIT;

  /* Initialize interface */
  
  if (ctx->Node->Restarts > 0) {
    nanosleep(&rqtp, NULL);
  }
  
  errh_Info( "Initializing interface for Profibus DP Master %s", ap->Name);
  sts = profi_init(hDevice, (unsigned char) op->BusNumber - 1, 0, 0);

  if (sts != E_OK)
  {
    /* Can't open driver */
    op->Status = PB__INITFAIL;
    errh_Error( "ERROR config Profibus DP Master %s - %s", ap->Name, "open device");
    ctx->Node->EmergBreakTrue = 1;
    return IO__ERRDEVICE;
  }

  /* If this is not the Profibus I/O process, return */
  
  if ((op->Process & io_mProcess_Profibus) && (ctx->Process != io_mProcess_Profibus)) {
    op->Status = PB__NOTINIT;
    errh_Info( "Init template I/O agent for Profibus DP Master %s, %d", ap->Name, ctx->Process );
    return IO__SUCCESS;
  }
  
  if (ctx->Node->Restarts > 0) {
    errh_Info( "Warm restart - Skipping config of Profibus DP Master %s", ap->Name);
    op->Status = PB__NORMAL;
//    return IO__SUCCESS;
  }
  
  errh_Info( "Config of Profibus DP Master %s", ap->Name);
      
  if (op->DisableBus != 1) {
  
    ok = FALSE;
    
    if (ctx->Node->Restarts == 0) {

      retry = 0;
      while (!ok) {
    
        op->Status = PB__NOTINIT;
      
        /* Set FMB configuration */

        sts = fmb_set_configuration(hDevice,  ap); 
        if (!sts) {
          op->Status = PB__INITFAIL;
          errh_Error( "ERROR config Profibus DP  Master %s - %s", ap->Name, "fmb set configuration");
	  retry++;
	  if (retry < 2) {
            nanosleep(&rqtp, NULL);
	    continue;
	  } 
          return IO__ERRINIDEVICE;
        }

        /* Set DP master parameters */

        if (local->dp) {

          sts = dp_init_master(hDevice); 
          if (!sts) {
            op->Status = PB__INITFAIL;
            errh_Error( "ERROR config Profibus DP Master %s - %s", ap->Name, "dp init master");
            return IO__ERRINIDEVICE;
          }
        }

        /* Download DP bus parameters */

        if (local->dp && !local->fdl) {
          sts = dp_download_bus(hDevice,  op); 
          if (!sts) {
            op->Status = PB__INITFAIL;
            errh_Error( "ERROR config Profibus DP Master %s - %s", ap->Name, "dp download bus");
            return IO__ERRINIDEVICE;
          }
        }
        else if (!local->dp && local->fdl) {
          sts = fmb_set_busparameter(hDevice,  op); 
          if (!sts) {
            op->Status = PB__INITFAIL;
            errh_Error( "ERROR config Profibus FDL Master %s - %s", ap->Name, "fmb set busparam");
            return IO__ERRINIDEVICE;
          }
          else op->Status = PB__NORMAL;
        }
        else {
          sts = fmb_set_busparameter(hDevice,  op); 
          if (!sts) {
            op->Status = PB__INITFAIL;
            errh_Error( "ERROR config Profibus Master %s - %s", ap->Name, "fmb set busparam");
            return IO__ERRINIDEVICE;
          }
          sts = dp_set_busparameter(hDevice,  op); 
          if (!sts) {
            op->Status = PB__INITFAIL;
            errh_Error( "ERROR config Profibus DP Master %s - %s", ap->Name, "dp set busparam");
            return IO__ERRINIDEVICE;
          }

        }
      
        /* Loop through all slaves (traverse agent's children) and initialize them */

        op->NumberSlaves = 0;
        status = gdh_GetChild(ap->Objid, &slave_objid);
  
        while (ODD(status)) {
          status = gdh_GetObjectClass(slave_objid, &slave_class);

          cid = slave_class;

          while ( ODD( gdh_GetSuperClass( cid, &cid, pwr_cNOid))) ;

          status = gdh_ObjidToPointer(slave_objid, (pwr_tAddress *) &sop);
          status = gdh_ObjidToName(slave_objid, (char *) &name, sizeof(name), cdh_mNName);

          if (cid == pwr_cClass_Pb_DP_Slave) {
            
            errh_Info( "Download Profibus DP Slave config - %s", name );

            status = dp_download_slave(hDevice, (pwr_sClass_Pb_DP_Slave *) sop);

            if (!status) {
              errh_Error( "ERROR Init Profibus DP slave %s", name);
            }
            
            op->NumberSlaves++; 
          }

          if (cid == pwr_cClass_Pb_FDL_SAP) {

            errh_Info( "Download Profibus FDL SAP config - %s", name );

            if (!((pwr_sClass_Pb_FDL_SAP *) sop)->Responder)
              status = fdlif_sap_activate_req(hDevice, (pwr_sClass_Pb_FDL_SAP *) sop);
            else
              status = fdlif_rsap_activate_req(hDevice, (pwr_sClass_Pb_FDL_SAP *) sop);

            if (!status) {
              ((pwr_sClass_Pb_FDL_SAP *) sop)->Status = PB__INITFAIL;
              errh_Error( "ERROR Init Profibus FDL SAP %s", name);
            }
            else ((pwr_sClass_Pb_FDL_SAP *) sop)->Status = PB__NORMAL;
          }

          status = gdh_GetNextSibling(slave_objid, &slave_objid);
        }

        /* Calculate offsets of inputs and outputs for a slave */
      
        status = gdh_GetChild(ap->Objid, &slave_objid);
  
        while (ODD(status)) {
          status = gdh_GetObjectClass(slave_objid, &slave_class);

          cid = slave_class;

          while ( ODD( gdh_GetSuperClass( cid, &cid, pwr_cNOid))) ;

          if (cid == pwr_cClass_Pb_DP_Slave) {
            status = gdh_ObjidToPointer(slave_objid, (pwr_tAddress *) &sop);            
            status = dp_io_offsets(hDevice, sop);
          }
          status = gdh_GetNextSibling(slave_objid, &slave_objid);
        }

        /* Move to STOP mode, this will fix the DPRAM layout */

        if (local->dp) {
          sts = dp_act_param_loc(hDevice, DP_OP_MODE_STOP);
          if (sts != E_OK) {
            op->Status = PB__INITFAIL;
            errh_Error( "ERROR config Profibus DP Master %s - %s", ap->Name, "act param loc to STOPPED");
            return IO__ERRINIDEVICE;
          }
        }
	      
        ok = TRUE;
	
      }  /* End - While !ok */
    }  /* End - Initialization only if not restart   */
/*    else {
       Move to STOP mode, this will fix the DPRAM layout 

      sts = dp_act_param_loc(hDevice, DP_OP_MODE_STOP);
      if (sts != E_OK) {
        op->Status = PB__INITFAIL;
        errh_Error( "ERROR config Profibus DP Master %s - %s", ap->Name, "act param loc to STOPPED");
        return IO__ERRINIDEVICE;
      }
    } */
  }    
  else
    op->Status = PB__DISABLED;
  
  return IO__SUCCESS;
}

/*----------------------------------------------------------------------------*\
   Swap method for the Pb_profiboard agent  
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentSwap (
  io_tCtx	ctx,
  io_sAgent	*ap,
  io_eEvent	event
) 
{

  switch ( event) {
  case io_eEvent_IoCommSwapInit:
  case io_eEvent_IoCommSwap: {
    pwr_sClass_Pb_Profiboard *op;
    char DeviceName[64];
    io_sAgentLocal *local;
  
    if (ap->Local == NULL) {
      /* Allocate area for local data structure */
      ap->Local = calloc(1, sizeof(io_sAgentLocal));
      if (!ap->Local) {
	errh_Error( "ERROR swap init Profibus DP Master %s - %s", ap->Name, "calloc");
	return IO__ERRINIDEVICE;
      }
    
      local = (io_sAgentLocal *) ap->Local;
      
      errh_Info( "Swap init interface for Profibus DP Master %s", ap->Name);

      op = (pwr_sClass_Pb_Profiboard *) ap->op;
    
      sprintf(DeviceName, "/dev/pbboard%u", op->BusNumber - 1);
      local->hDpsBoardDevice = open(DeviceName, O_RDONLY | O_NONBLOCK);
    
      if (local->hDpsBoardDevice == -1) {
	errh_Error( "ERROR swap init Profibus DP Master %s - %s", ap->Name, "open");
	return IO__ERRINIDEVICE;
      }
    }
    break;
  }
  case io_eEvent_EmergencyBreak:
  case io_eEvent_IoCommEmergencyBreak:
    IoAgentClose( ctx, ap);
    break;
  }

    
  return IO__SUCCESS;
}


/*----------------------------------------------------------------------------*\
   Read method for the Pb_Profiboard agent  
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentRead (
  io_tCtx	ctx,
  io_sAgent	*ap
)
{
  io_sAgentLocal *local;
  T_PROFI_DEVICE_HANDLE *hDevice;
  pwr_sClass_Pb_Profiboard *op;
  pwr_tUInt16 sts;

  pwr_sClass_Pb_Profiboard *mp;
  pwr_sClass_Pb_DP_Slave *sp;
  pwr_tUInt16 data_len;
  io_sRack *slave_list;

  hDevice = (T_PROFI_DEVICE_HANDLE *) ap->Local;
  local = (io_sAgentLocal *) ap->Local;
  op = (pwr_sClass_Pb_Profiboard *) ap->op;

  /* Activate supervision thread, first cycle */

  if (!local->args.local) {
  
    pthread_attr_t attr;
    pthread_mutexattr_t mutexattr;
  
    local->args.local = local;
    local->args.ap = ap;
    
    pthread_mutexattr_init(&mutexattr);
    pthread_mutex_init(&local->mutex, &mutexattr);
    pthread_mutexattr_destroy(&mutexattr);
    pthread_attr_init(&attr);
    pthread_attr_setinheritsched(&attr, PTHREAD_INHERIT_SCHED);
    pthread_create(&local->events, &attr, handle_events, &local->args);    
  }

  pthread_mutex_lock(&local->mutex);

  /* Iterate over the slaves.  */
  for (slave_list = ap->racklist; slave_list != NULL;
      slave_list = slave_list->next) {

    if (((io_sRackLocal *) slave_list->Local)->dp) {
      sp = (pwr_sClass_Pb_DP_Slave *) slave_list->op;
      mp = (pwr_sClass_Pb_Profiboard *) ap->op;
      
      /* Read process data.  */
      if (sp->Status == PB__NORMAL && mp->Status == PB__NORMAL && sp->DisableSlave != 1 && mp->DisableBus != 1) {
        
        data_len = sp->BytesOfInput;
        sts = profi_get_data(hDevice, ID_DP_SLAVE_IO_IMAGE, sp->OffsetInputs, &data_len, &sp->Inputs );
      }
      
    }
  }

  pthread_mutex_unlock(&local->mutex);
           
  return IO__SUCCESS;
}


/*----------------------------------------------------------------------------*\
   Write method for the Pb_Profiboard agent  
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentWrite (
  io_tCtx	ctx,
  io_sAgent	*ap
) 
{
  io_sAgentLocal *local;
  T_PROFI_DEVICE_HANDLE *hDevice;
  pwr_tUInt16 sts;

  pwr_sClass_Pb_Profiboard *mp;
  pwr_sClass_Pb_DP_Slave *sp;
  io_sRack *slave_list;

  hDevice = (T_PROFI_DEVICE_HANDLE *) ap->Local;
  local = (io_sAgentLocal *) ap->Local;

  pthread_mutex_lock(&local->mutex);

  /* Iterate over the slaves.  */
  for (slave_list = ap->racklist; slave_list != NULL;
      slave_list = slave_list->next) {

    if (((io_sRackLocal *) slave_list->Local)->dp) {
      sp = (pwr_sClass_Pb_DP_Slave *) slave_list->op;
      mp = (pwr_sClass_Pb_Profiboard *) ap->op;

      // Write the whole I/O output area from local area

      if ((sp->Status == PB__NORMAL || sp->Status == PB__NOCONN) && 
          mp->Status == PB__NORMAL && (sp->DisableSlave != 1) && (mp->DisableBus != 1)) {
        
        if (sp->BytesOfOutput > 0) {
          
          sts = profi_set_data(hDevice, ID_DP_SLAVE_IO_IMAGE, sp->OffsetOutputs, sp->BytesOfOutput, &sp->Outputs);
          
          if (sts != E_OK) sp->ErrorCount++;
        }
      }
    }
  }

  pthread_mutex_unlock(&local->mutex);

  return IO__SUCCESS;
}


/*----------------------------------------------------------------------------*\
  
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentClose (
  io_tCtx	ctx,
  io_sAgent	*ap
) 
{
  io_sAgentLocal 	*local;
  T_PROFI_DEVICE_HANDLE *hDevice;
  pwr_tStatus            sts = PB_FALSE;

  T_PROFI_SERVICE_DESCR sdb;

  USIGN8                   con_ind_buffer [256];
  USIGN16                  con_ind_buffer_len = 256;
  T_PROFI_SERVICE_DESCR    con_ind_sdb;
  INT16                    result;              /* !!! local result variable !!! */

  local = (io_sAgentLocal *) ap->Local;
  if ( !local) return IO__SUCCESS;

  pthread_cancel(local->events);

  pthread_mutex_lock(&local->mutex);

  hDevice = (T_PROFI_DEVICE_HANDLE *) ap->Local;
  sdb.comm_ref = 0;
  sdb.layer = DP;
  sdb.service = DP_EXIT_MASTER;
  sdb.primitive = REQ;
  sdb.invoke_id = 0;
  sdb.result = 0;

  profi_snd_req_res(hDevice, &sdb, &sdb, PB_FALSE);

  try_profi_rcv_con_ind(hDevice, &con_ind_sdb, con_ind_buffer, &con_ind_buffer_len, &result);
    
  if ((con_ind_sdb.service   == DP_EXIT_MASTER) &&
      (con_ind_sdb.primitive == CON                  ) &&
      (con_ind_sdb.result    == POS                  )) {
    sts = PB_TRUE;
  }

  close(local->hServiceReadDevice);
  close(local->hServiceWriteDevice);
  close(local->hDpDataDevice);
  close(local->hDpsInputDataDevice);
  close(local->hDpsOutputDataDevice);
  close(local->hDpsBoardDevice);

  pthread_mutex_unlock(&local->mutex);

  free( (char *)local);

  return sts;
}


/*----------------------------------------------------------------------------*\
  Every method to be exported to the workbench should be registred here.
\*----------------------------------------------------------------------------*/

pwr_dExport pwr_BindIoMethods(Pb_Profiboard) = {
  pwr_BindIoMethod(IoAgentInit),
  pwr_BindIoMethod(IoAgentRead),
  pwr_BindIoMethod(IoAgentWrite),
  pwr_BindIoMethod(IoAgentClose),
  pwr_BindIoMethod(IoAgentSwap),
  pwr_NullMethod
};
