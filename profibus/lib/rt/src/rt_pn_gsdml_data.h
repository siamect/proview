/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#ifndef rt_pn_gsdml_data_h
#define rt_pn_gsdml_data_h

/* cow_pn_gsdml_data.h -- Profinet configurator data file. */

#include <vector>

#include "co_xml_parser.h"

class GsdmlDataRecord
{
public:
  GsdmlDataRecord()
      : record_idx(0), data(0), data_reversed_endianess(0), data_length(0),
        index(0), transfer_sequence(0)
  {
  }

  unsigned int record_idx;
  unsigned char* data;
  unsigned char* data_reversed_endianess;
  unsigned int data_length;
  unsigned short index;
  unsigned short transfer_sequence;

  ~GsdmlDataRecord()
  {
    if (data)
      free(data);
    if (data_reversed_endianess)
      free(data_reversed_endianess);
  }
  GsdmlDataRecord(const GsdmlDataRecord& x);

  int print(std::ofstream& fp, bool reverse_endianess);
};

class GsdmlIOCRData
{
public:
  GsdmlIOCRData()
      : type(0), properties(0), send_clock_factor(0), phase(0), api(0)
  {
  }

  unsigned short type;
  unsigned int properties;
  unsigned short send_clock_factor;
  unsigned short reduction_ratio;
  unsigned int phase;
  unsigned int api;

  int print(std::ofstream& fp);
};

class GsdmlSubslotData
{
public:
  GsdmlSubslotData()
      : subslot_number(0), subslot_idx(0), submodule_enum_number(0),
        submodule_ident_number(0), api(0), io_input_length(0),
        io_output_length(0)
  {
  }

  std::vector<GsdmlDataRecord*> data_record;
  unsigned int subslot_number;
  unsigned int subslot_idx;
  unsigned int submodule_enum_number;
  unsigned int submodule_ident_number;
  unsigned int api;
  unsigned int io_input_length;
  unsigned int io_output_length;

  ~GsdmlSubslotData()
  {
    for (unsigned int i = 0; i < data_record.size(); i++)
      delete data_record[i];
  }
  GsdmlSubslotData(const GsdmlSubslotData& x)
      : subslot_number(x.subslot_number), subslot_idx(x.subslot_idx)
  {
    for (unsigned int i = 0; i < x.data_record.size(); i++)
    {
      data_record.push_back(new GsdmlDataRecord(*x.data_record[i]));
    }
  }
  int print(std::ofstream& fp, bool reverse_endianess);
};

class GsdmlSlotData
{
public:
  GsdmlSlotData()
      : module_enum_number(0), dap_fixed_slot(0), module_class(0), module_oid(pwr_cNOid),
        slot_number(0), slot_idx(0)
  {
    module_text[0] = 0;
  }
  unsigned int module_enum_number;
  unsigned int module_ident_number;

  unsigned int dap_fixed_slot;
  pwr_tCid module_class;
  pwr_tOid module_oid;
  char module_text[160];
  unsigned int slot_number;

  unsigned int slot_idx;
  std::vector<GsdmlSubslotData*> subslot_data;

  ~GsdmlSlotData()
  {
    for (unsigned int i = 0; i < subslot_data.size(); i++)
      delete subslot_data[i];
  }
  void slot_reset()
  {
    for (unsigned int i = 0; i < subslot_data.size(); i++)
      delete subslot_data[i];
    subslot_data.clear();
  }
  GsdmlSlotData(const GsdmlSlotData& x)
      : module_enum_number(x.module_enum_number), module_class(x.module_class),
        module_oid(pwr_cNObjid), slot_number(x.slot_number),
        slot_idx(x.slot_idx)
  {
    for (unsigned int i = 0; i < x.subslot_data.size(); i++)
    {
      subslot_data.push_back(new GsdmlSubslotData(*x.subslot_data[i]));
    }
  }
  int print(std::ofstream& fp, bool reverse_endianess);
};

class GsdmlChannelDiag
{
public:
  GsdmlChannelDiag();
  unsigned short error_type;
  char name[200];
  char help[4096]; // We need a large buffer for most of the help text in the
                   // diagnostics...

  int print(std::ofstream& fp);
};

class GsdmlDeviceData
{
public:
  GsdmlDeviceData()
      : device_num(0), vendor_id(0), device_id(0), byte_order(0),
        read_data_is_native_ordered(1), instance(0)
  {
    device_name[0] = 0;
    ip_address[0] = 0;
    subnet_mask[0] = 0;
    mac_address[0] = 0;
    device_text[0] = 0;
    version[0] = 0;
    gsdmlfile[0] = 0;
  }
  char device_name[80];
  char ip_address[20];
  char subnet_mask[20];
  char mac_address[20];
  int device_num;
  char device_text[160];
  unsigned short vendor_id;
  unsigned short device_id;
  char version[20];
  int byte_order;
  int read_data_is_native_ordered;
  unsigned short instance;
  pwr_tFileName gsdmlfile;
  std::vector<GsdmlSlotData*> slot_data;
  std::vector<GsdmlIOCRData*> iocr_data;
  static GsdmlSlotData* paste_slotdata;
  std::vector<GsdmlChannelDiag*> channel_diag;

  ~GsdmlDeviceData()
  {
    device_reset();
    channel_diag_reset();
  }
  void device_reset()
  {
    for (unsigned int i = 0; i < slot_data.size(); i++)
      delete slot_data[i];
    slot_data.clear();
    for (unsigned int i = 0; i < iocr_data.size(); i++)
      delete iocr_data[i];
    iocr_data.clear();
  }
  void channel_diag_reset()
  {
    for (unsigned int i = 0; i < channel_diag.size(); i++)
      delete channel_diag[i];
    channel_diag.clear();
  }
  int print(const char* filename);
  int read(const char* filename, int new_filename = 0);
  int copy_slot(unsigned int slot_idx);
  int cut_slot(unsigned int slot_idx);
  int paste_slot(unsigned int slot_idx);
  int modify_value(const char* attr, const char* value);
  int get_value(const char* attr, char* buf, int bufsize);
};

class GsdmlDataReader : public co_xml_interpreter
{
public:
  GsdmlDataReader(GsdmlDeviceData* d) : data(d), new_filename(0) {}
  int tag(const char* name);
  int metatag(const char* name);
  int tag_end(const char* name);
  int metatag_end(const char* name);
  int tag_value(const char* value);
  int tag_attribute(const char* name, const char* value);

  int tag_name_to_id(const char* name, unsigned int* id);

  unsigned int current_tag;
  GsdmlDeviceData* data;
  int new_filename;
};

#endif
