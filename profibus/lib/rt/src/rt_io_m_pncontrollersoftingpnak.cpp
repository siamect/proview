/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2019 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_io_m_pncontrollersoftingpnak.cpp -- io methods for the profinet master
   object
   The PnControllerSoftingPNAK object serves as agent for one Profinet network
   The profinet stack we use is a Profinet stack from Softing
*/

#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <iostream>

#include <arpa/inet.h>
#include <net/if.h>
#include <netinet/in.h>
#include <sys/ioctl.h>
#include <sys/socket.h>

#include "co_cdh.h"
#include "co_dcli.h"
#include "pwr_profibusclasses.h"

#include "rt_io_base.h"
#include "rt_io_bus.h"
#include "rt_io_msg.h"
#include "rt_io_agent_init.h"
#include "rt_pb_msg.h"
#include "rt_io_pnak_locals.h"
#include "rt_pn_iface.h"

static pwr_tStatus IoAgentInit(io_tCtx ctx, io_sAgent* ap);
static pwr_tStatus IoAgentRead(io_tCtx ctx, io_sAgent* ap);
static pwr_tStatus IoAgentWrite(io_tCtx ctx, io_sAgent* ap);
static pwr_tStatus IoAgentClose(io_tCtx ctx, io_sAgent* ap);
static pwr_tStatus IoAgentSwap(io_tCtx ctx, io_sAgent* ap, io_eEvent event);

/*----------------------------------------------------------------------------*\
   Init method for the Pb_profiboard agent
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentInit(io_tCtx ctx, io_sAgent* ap)
{
  io_sAgentLocal* local;
  pwr_sClass_PnControllerSoftingPNAK* op;

  /* Allocate area for local data structure */
  ap->Local = (io_sAgentLocal*)new io_sAgentLocal;
  if (!ap->Local)
  {
    //    errh_Error( "ERROR config Profibus DP Master %s - %s", ap->Name,
    //    "calloc");
    return IO__ERRINIDEVICE;
  }

  local = (io_sAgentLocal*)ap->Local;
  op = (pwr_sClass_PnControllerSoftingPNAK*)ap->op;

  pnak_init();

  /* Active supervision thread */

  pthread_attr_t attr;

  local->args.local = local;
  local->args.ap = ap;

  op->Status = PB__NOTINIT;

  pthread_mutexattr_t mutexattr;
  pthread_condattr_t condattr;

  pthread_mutexattr_init(&mutexattr);
  pthread_mutex_init(&local->mutex, &mutexattr);
  pthread_mutexattr_destroy(&mutexattr);

  pthread_condattr_init(&condattr);
  pthread_cond_init(&local->cond, &condattr);
  pthread_condattr_destroy(&condattr);

  pthread_mutex_lock(&local->mutex);

  pthread_attr_init(&attr);
  pthread_attr_setinheritsched(&attr, PTHREAD_INHERIT_SCHED);
  pthread_create(&local->handle_events, &attr, handle_events, &local->args);

  pthread_cond_wait(&local->cond, &local->mutex);
  pthread_mutex_unlock(&local->mutex);
  op->Status = PB__NORMAL;

  return IO__SUCCESS;
}

/*----------------------------------------------------------------------------*\
   Read method for the Pb_Profiboard agent
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentRead(io_tCtx ctx, io_sAgent* ap)
{
  io_sAgentLocal* local;
  PnIOCRData* pn_iocr_data;
  pwr_tUInt16 sts;
  unsigned char* io_datap;
  unsigned char* clean_io_datap;
  unsigned char status_data = 0;
  PnSubmoduleData* submodule;
  unsigned char ioxs;

  unsigned short data_length, ii, jj, kk, ll;

  local = (io_sAgentLocal*)ap->Local;

  //  handle_events(&local->args);
  /* Read i/o for all devices and move it to clean io data area */

  //  pthread_mutex_lock(&local->mutex);

  for (ii = 1; ii < local->device_data.size(); ii++)
  {
    if (local->device_data[ii]->device_state == PNAK_DEVICE_STATE_CONNECTED)
    {
      for (jj = 0; jj < local->device_data[ii]->iocr_data.size(); jj++)
      {
        pn_iocr_data = local->device_data[ii]->iocr_data[jj];

        if (pn_iocr_data->type == PROFINET_IO_CR_TYPE_INPUT)
        {
          data_length = pn_iocr_data->io_data_length;

          sts = pnak_get_iocr_data(0, pn_iocr_data->identifier,
                                   pn_iocr_data->io_data, &data_length, &ioxs,
                                   &status_data);

          if (sts == PNAK_OK)
          {
            for (kk = 0; kk < local->device_data[ii]->module_data.size(); kk++)
            {
              for (ll = 0; ll < local->device_data[ii]
                                    ->module_data[kk]
                                    ->submodule_data.size();
                   ll++)
              {
                submodule =
                    local->device_data[ii]->module_data[kk]->submodule_data[ll];
                if ((submodule->type == PROFINET_IO_SUBMODULE_TYPE_INPUT) ||
                    (submodule->type ==
                     PROFINET_IO_SUBMODULE_TYPE_INPUT_AND_OUTPUT))
                {
                  io_datap = (pn_iocr_data->io_data + submodule->offset_io_in);
                  clean_io_datap = (pn_iocr_data->clean_io_data +
                                    submodule->offset_clean_io_in);
                  memcpy(clean_io_datap, io_datap,
                         submodule->io_in_data_length);
                }
              }
            }
          }
          else
          {
            printf("pnak_get_iocr_data failed!\n");
          }
        }
      }
    }
  }

  //  pthread_mutex_unlock(&local->mutex);

  return IO__SUCCESS;
}

/*----------------------------------------------------------------------------*\
   Write method for the Pb_Profiboard agent
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentWrite(io_tCtx ctx, io_sAgent* ap)
{
  io_sAgentLocal* local;
  PnIOCRData* pn_iocr_data;
  pwr_tUInt16 sts;
  unsigned char* io_datap;
  unsigned char* clean_io_datap;
  PnSubmoduleData* submodule;
  io_sRack* slave_list;
  pwr_sClass_PnDevice* sp = NULL;

  unsigned short data_length, ii, jj, kk, ll;
  // unsigned char *status_datap;

  local = (io_sAgentLocal*)ap->Local;

  /* Write i/o for all devices fetch it first from clean io data area */

  /* Iterate over the slaves.  */
  slave_list = ap->racklist;

  //  pthread_mutex_lock(&local->mutex);

  for (ii = 1; ii < local->device_data.size(); ii++)
  {
    if (slave_list != NULL)
    {
      sp = (pwr_sClass_PnDevice*)slave_list->op;
      slave_list = slave_list->next;
    }

    if (local->device_data[ii]->device_state == PNAK_DEVICE_STATE_CONNECTED)
    {
      for (jj = 0; jj < local->device_data[ii]->iocr_data.size(); jj++)
      {
        pn_iocr_data = local->device_data[ii]->iocr_data[jj];

        if (pn_iocr_data->type == PROFINET_IO_CR_TYPE_OUTPUT)
        {
          data_length = pn_iocr_data->io_data_length;

          /* Set io status to good */

          memset(pn_iocr_data->io_data, 0x80,
                 data_length); // 0x80 is PNAK_IOXS_STATUS_DATA_GOOD

          for (kk = 0; kk < local->device_data[ii]->module_data.size(); kk++)
          {
            for (ll = 0;
                 ll <
                 local->device_data[ii]->module_data[kk]->submodule_data.size();
                 ll++)
            {
              submodule =
                  local->device_data[ii]->module_data[kk]->submodule_data[ll];
              if ((submodule->type == PROFINET_IO_SUBMODULE_TYPE_OUTPUT) ||
                  (submodule->type ==
                   PROFINET_IO_SUBMODULE_TYPE_INPUT_AND_OUTPUT))
              {
                io_datap = (pn_iocr_data->io_data + submodule->offset_io_out);
                clean_io_datap = (pn_iocr_data->clean_io_data +
                                  submodule->offset_clean_io_out);
                memcpy(io_datap, clean_io_datap, submodule->io_out_data_length);

                /*status_datap = io_datap + submodule->io_out_data_length;
                 *status_datap = PNAK_IOXS_STATUS_NO_EXTENTION_FOLLOWS |
                 *PNAK_IOXS_STATUS_DATA_GOOD;
                 */
              }
            }
          }
          char ioxs = CYCLIC_DATA_STATUS_DATA_VALID |
                      CYCLIC_DATA_STATUS_STATE_PRIMARY |
                      CYCLIC_DATA_STATUS_STATE_RUN |
                      CYCLIC_DATA_STATUS_NORMAL_OPERATION;
          sts = pnak_set_iocr_data(0, pn_iocr_data->identifier,
                                   pn_iocr_data->io_data,
                                   pn_iocr_data->io_data_length, ioxs);
          if (sts != PNAK_OK)
          {
            printf("pnak_set_iocr_data failed!\n");
          }
        }
      }

      if (slave_list != NULL)
      {
        /* Check if there is a write request pending ?? */

        if (sp->WriteReq.SendReq)
        {
          if ((sp->WriteReq.Length > 0) &&
              (sp->WriteReq.Length <= sizeof(sp->WriteReq.Data)))
          {
            for (jj = 0; jj < local->device_data[ii]->module_data.size(); jj++)
            {
              if (local->device_data[ii]->module_data[jj]->slot_number ==
                  sp->WriteReq.SlotNumber)
              {
                for (kk = 0; kk < local->device_data[ii]
                                      ->module_data[jj]
                                      ->submodule_data.size();
                     kk++)
                {
                  if (local->device_data[ii]
                          ->module_data[jj]
                          ->submodule_data[kk]
                          ->subslot_number == sp->WriteReq.SubslotNumber)
                  {
                    if (local->device_data[ii]
                            ->module_data[jj]
                            ->submodule_data[kk]
                            ->api > 0)
                    {
                      sp->WriteReq.Api = local->device_data[ii]
                                             ->module_data[jj]
                                             ->submodule_data[kk]
                                             ->api;
                    }
                    pack_write_req(&local->service_req_res,
                                   local->device_data[ii]->device_ref,
                                   &sp->WriteReq);
                    sts = pnak_send_service_req_res(0, &local->service_req_res);
                    errh_Info("Profinet - Asynch write, dev: %d",
                              local->device_data[ii]->device_ref);
                    break;
                  }
                }
                break;
              }
            }
          }
          sp->WriteReq.SendReq = 0;
        }
      }
    }
  }

  //  pthread_mutex_unlock(&local->mutex);

  return IO__SUCCESS;
}

/*----------------------------------------------------------------------------*\

\*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentClose(io_tCtx ctx, io_sAgent* ap)
{
  io_sAgentLocal* local;
  pwr_tStatus sts = PB__NOTINIT;

  local = (io_sAgentLocal*)ap->Local;

  /* Stop profistack */

  pnak_init();

  sts = pnak_stop_profistack(0);

  pnak_term();

  /* Clean data areas .... */

  return sts;
}

static pwr_tStatus IoAgentSwap(io_tCtx ctx, io_sAgent* ap, io_eEvent event)
{
  switch (event) {
  case io_eEvent_EmergencyBreak:
  case io_eEvent_IoCommEmergencyBreak:
    errh_Fatal("Emergency break detected shutting down profinet");
    IoAgentClose(ctx, ap);
    break;
  default:
    break;
  }

  return IO__SUCCESS;
}

/*----------------------------------------------------------------------------*\
  Every method to be exported to the workbench should be registred here.
\*----------------------------------------------------------------------------*/

pwr_dExport pwr_BindIoMethods(PnControllerSoftingPNAK)
    = { pwr_BindIoMethod(IoAgentInit), pwr_BindIoMethod(IoAgentRead),
        pwr_BindIoMethod(IoAgentWrite), pwr_BindIoMethod(IoAgentClose),
        pwr_BindIoMethod(IoAgentSwap), pwr_NullMethod };
