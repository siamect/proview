/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_io_m_pncontrollersoftingpnak.cpp -- io methods for the profinet master
   object
   The PnControllerSoftingPNAK object serves as agent for one Profinet network
   The profinet stack we use is a Profinet stack from Softing
*/

#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <iostream>

#include <arpa/inet.h>
#include <net/if.h>
#include <netinet/in.h>
#include <sys/ioctl.h>
#include <sys/socket.h>

#include "co_cdh.h"
#include "co_dcli.h"
#include "pwr_profibusclasses.h"

#include "rt_io_base.h"
#include "rt_io_bus.h"
#include "rt_io_msg.h"
#include "rt_io_agent_init.h"
#include "rt_pb_msg.h"
#include "rt_io_pnak_locals.h"
#include "rt_pn_iface.h"

static pwr_tStatus IoAgentInit(io_tCtx ctx, io_sAgent* ap);
static pwr_tStatus IoAgentRead(io_tCtx ctx, io_sAgent* ap);
static pwr_tStatus IoAgentWrite(io_tCtx ctx, io_sAgent* ap);
static pwr_tStatus IoAgentClose(io_tCtx ctx, io_sAgent* ap);
static pwr_tStatus IoAgentSwap(io_tCtx ctx, io_sAgent* ap, io_eEvent event);

/*----------------------------------------------------------------------------*\
   Init method for the Pb_profiboard agent
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentInit(io_tCtx ctx, io_sAgent* ap)
{
  io_sAgentLocal* local;
  pwr_sClass_PnControllerSoftingPNAK* op;

  /* Allocate area for local data structure */
  ap->Local = (io_sAgentLocal*)new io_sAgentLocal;
  if (!ap->Local) {
    //    errh_Error( "ERROR config Profibus DP Master %s - %s", ap->Name,
    //    "calloc");
    return IO__ERRINIDEVICE;
  }

  local = (io_sAgentLocal*)ap->Local;
  op = (pwr_sClass_PnControllerSoftingPNAK*)ap->op;

  pnak_init();

  /* Active supervision thread */

  pthread_attr_t attr;

  local->args.local = local;
  local->args.ap = ap;

  op->Status = PB__NOTINIT;

  pthread_mutexattr_t mutexattr;
  pthread_condattr_t condattr;

  pthread_mutexattr_init(&mutexattr);
  pthread_mutex_init(&local->mutex, &mutexattr);
  pthread_mutexattr_destroy(&mutexattr);

  pthread_condattr_init(&condattr);
  pthread_cond_init(&local->cond, &condattr);
  pthread_condattr_destroy(&condattr);

  pthread_mutex_lock(&local->mutex);

  pthread_attr_init(&attr);
  pthread_attr_setinheritsched(&attr, PTHREAD_INHERIT_SCHED);
  pthread_create(&local->handle_events, &attr, handle_events, &local->args);

  pthread_cond_wait(&local->cond, &local->mutex);
  pthread_mutex_unlock(&local->mutex);
  op->Status = PB__NORMAL;

  return IO__SUCCESS;
}

/*----------------------------------------------------------------------------*\
   Read method for the Pb_Profiboard agent
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentRead(io_tCtx ctx, io_sAgent* ap)
{
  io_sAgentLocal* local;
  PnIOCRData* pn_iocr_data;
  pwr_tUInt16 sts;
  unsigned char* io_datap;
  unsigned char* clean_io_datap;
  unsigned char status_data = 0;
  PnSubmoduleData* submodule;
  unsigned char ioxs;

  unsigned short data_length, ii, jj, kk, ll;

  local = (io_sAgentLocal*)ap->Local;

  //  handle_events(&local->args);
  /* Read i/o for all devices and move it to clean io data area */

  //  pthread_mutex_lock(&local->mutex);

  for (ii = 1; ii < local->device_data.size(); ii++) {
    if (local->device_data[ii]->device_state == PNAK_DEVICE_STATE_CONNECTED) {
      for (jj = 0; jj < local->device_data[ii]->iocr_data.size(); jj++) {
        pn_iocr_data = local->device_data[ii]->iocr_data[jj];

        if (pn_iocr_data->type == PROFINET_IO_CR_TYPE_INPUT) {
          data_length = pn_iocr_data->io_data_length;

          sts = pnak_get_iocr_data(0, pn_iocr_data->identifier,
              pn_iocr_data->io_data, &data_length, &ioxs, &status_data);

          if (sts == PNAK_OK) {
            for (kk = 0; kk < local->device_data[ii]->module_data.size();
                 kk++) {
              for (ll = 0; ll < local->device_data[ii]
                                    ->module_data[kk]
                                    ->submodule_data.size();
                   ll++) {
                submodule = local->device_data[ii]
                                ->module_data[kk]
                                ->submodule_data[ll];
                if ((submodule->type == PROFINET_IO_SUBMODULE_TYPE_INPUT)
                    || (submodule->type
                           == PROFINET_IO_SUBMODULE_TYPE_INPUT_AND_OUTPUT)) {
                  io_datap = (pn_iocr_data->io_data + submodule->offset_io_in);
                  clean_io_datap = (pn_iocr_data->clean_io_data
                      + submodule->offset_clean_io_in);
                  memcpy(
                      clean_io_datap, io_datap, submodule->io_in_data_length);
                }
              }
            }
          } else {
            printf("pnak_get_iocr_data failed!\n");
          }
        }
      }
    }
  }

  //  pthread_mutex_unlock(&local->mutex);

  return IO__SUCCESS;
}

/*----------------------------------------------------------------------------*\
   Write method for the Pb_Profiboard agent
\*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentWrite(io_tCtx ctx, io_sAgent* ap)
{
  io_sAgentLocal* local;
  PnIOCRData* pn_iocr_data;
  pwr_tUInt16 sts;
  unsigned char* io_datap;
  unsigned char* clean_io_datap;
  PnSubmoduleData* submodule;
  io_sRack* slave_list;
  pwr_sClass_PnDevice* sp = NULL;

  unsigned short data_length, ii, jj, kk, ll;
  // unsigned char *status_datap;

  local = (io_sAgentLocal*)ap->Local;

  /* Write i/o for all devices fetch it first from clean io data area */

  /* Iterate over the slaves.  */
  slave_list = ap->racklist;

  //  pthread_mutex_lock(&local->mutex);

  for (ii = 1; ii < local->device_data.size(); ii++) {
    if (slave_list != NULL) {
      sp = (pwr_sClass_PnDevice*)slave_list->op;
      slave_list = slave_list->next;
    }

    if (local->device_data[ii]->device_state == PNAK_DEVICE_STATE_CONNECTED) {
      for (jj = 0; jj < local->device_data[ii]->iocr_data.size(); jj++) {
        pn_iocr_data = local->device_data[ii]->iocr_data[jj];

        if (pn_iocr_data->type == PROFINET_IO_CR_TYPE_OUTPUT) {
          data_length = pn_iocr_data->io_data_length;

          /* Set io status to good */

          memset(pn_iocr_data->io_data, 0x80,
              data_length); // 0x80 is PNAK_IOXS_STATUS_DATA_GOOD

          for (kk = 0; kk < local->device_data[ii]->module_data.size(); kk++) {
            for (ll = 0; ll < local->device_data[ii]
                                  ->module_data[kk]
                                  ->submodule_data.size();
                 ll++) {
              submodule
                  = local->device_data[ii]->module_data[kk]->submodule_data[ll];
              if ((submodule->type == PROFINET_IO_SUBMODULE_TYPE_OUTPUT)
                  || (submodule->type
                         == PROFINET_IO_SUBMODULE_TYPE_INPUT_AND_OUTPUT)) {
                io_datap = (pn_iocr_data->io_data + submodule->offset_io_out);
                clean_io_datap = (pn_iocr_data->clean_io_data
                    + submodule->offset_clean_io_out);
                memcpy(io_datap, clean_io_datap, submodule->io_out_data_length);

                /*status_datap = io_datap + submodule->io_out_data_length;
                 *status_datap = PNAK_IOXS_STATUS_NO_EXTENTION_FOLLOWS |
                 *PNAK_IOXS_STATUS_DATA_GOOD;
                 */
              }
            }
          }
          char ioxs = CYCLIC_DATA_STATUS_DATA_VALID
              | CYCLIC_DATA_STATUS_STATE_PRIMARY | CYCLIC_DATA_STATUS_STATE_RUN
              | CYCLIC_DATA_STATUS_NORMAL_OPERATION;
          sts = pnak_set_iocr_data(0, pn_iocr_data->identifier,
              pn_iocr_data->io_data, pn_iocr_data->io_data_length, ioxs);
          if (sts != PNAK_OK) {
            printf("pnak_set_iocr_data failed!\n");
          }
        }
      }

      if (slave_list != NULL) {
        /* Check if there is a write request pending ?? */

        if (sp->WriteReq.SendReq) {
          if ((sp->WriteReq.Length > 0)
              && (sp->WriteReq.Length <= sizeof(sp->WriteReq.Data))) {
            for (jj = 0; jj < local->device_data[ii]->module_data.size();
                 jj++) {
              if (local->device_data[ii]->module_data[jj]->slot_number
                  == sp->WriteReq.SlotNumber) {
                for (kk = 0; kk < local->device_data[ii]
                                      ->module_data[jj]
                                      ->submodule_data.size();
                     kk++) {
                  if (local->device_data[ii]
                          ->module_data[jj]
                          ->submodule_data[kk]
                          ->subslot_number
                      == sp->WriteReq.SubslotNumber) {
                    if (local->device_data[ii]
                            ->module_data[jj]
                            ->submodule_data[kk]
                            ->api
                        > 0) {
                      sp->WriteReq.Api = local->device_data[ii]
                                             ->module_data[jj]
                                             ->submodule_data[kk]
                                             ->api;
                    }
                    pack_write_req(&local->service_req_res,
                        local->device_data[ii]->device_ref, &sp->WriteReq);
                    sts = pnak_send_service_req_res(0, &local->service_req_res);
                    errh_Info("PROFINET: Async write, dev: %d",
                              local->device_data[ii]->device_ref);
                    break;
                  }
                }
                break;
              }
            }
          }
          sp->WriteReq.SendReq = 0;
        }
      }
    }
  }

  //  pthread_mutex_unlock(&local->mutex);

  return IO__SUCCESS;
}

/*----------------------------------------------------------------------------*\

\*----------------------------------------------------------------------------*/
static pwr_tStatus IoAgentClose(io_tCtx ctx, io_sAgent* ap)
{
  io_sAgentLocal* local;
  int *exitcodep;
  int error;

  local = (io_sAgentLocal*)ap->Local;

  // Stop the supervision thread before shutting down PROFINET.
  local = (io_sAgentLocal*)ap->Local;
  if (!local) return IO__SUCCESS;

  // Start taking the stack down. A PNAK_WAIT_OBJECT_CHANNEL_CLOSED event will
  // be emitted and the supervision thread will exit
  pnak_stop_stack(0);

  // Wait for the thread to exit
  if ((error = pthread_join(local->handle_events, (void**)&exitcodep)))
    errh_Warning("PROFINET: Unable to wait for supervision thread!");
  else
    errh_Info("PROFINET: Supervision thread has exited. PROFINET stopped...");

  free(local);
  local = NULL;

  /* Clean data areas .... */

  return IO__SUCCESS;
}

static pwr_tStatus IoAgentSwap(io_tCtx ctx, io_sAgent* ap, io_eEvent event)
{
  switch (event)
  {
  // For now we just shut down regardless of what EmergBreakSelect says...safety
  // first :)
  case io_eEvent_EmergencyBreak:
    errh_Fatal("PROFINET: Emergency break detected! Shutting down PROFINET!");
    IoAgentClose(ctx, ap);
    // TODO We need a complete overhaul of EmergencyBreakTrue / EmergBreakSelect
    // / IOReadWriteFlag
    // switch (ctx->Node->EmergBreakSelect)
    // {
    // case pwr_eEmergBreakSelectEnum_StopIO:
    // case pwr_eEmergBreakSelectEnum_Reboot:
    //   errh_Fatal("PROFINET: Emergency break action (StopIO/Reboot) shutting
    //   down PROFINET"); IoAgentClose(ctx, ap); break;
    // case pwr_eEmergBreakSelectEnum_NoAction:
    //   errh_Warning("PROFINET: Emergency break action (NoAction).
    //   Continuing..."); break;
    // case pwr_eEmergBreakSelectEnum_FixedOutputValues:
    //   errh_Warning("PROFINET: Behaviour of FixedOutputValues should be
    //   configured on device level"); errh_Fatal("PROFINET: Emergency break
    //   action (Fixed Output Values)."); break;
    // }

    break;
  case io_eEvent_IoCommEmergencyBreak:
    break;
  default:
    break;
  }

  return IO__SUCCESS;
}

/*----------------------------------------------------------------------------*\
  Every method to be exported to the workbench should be registred here.
\*----------------------------------------------------------------------------*/

pwr_dExport pwr_BindIoMethods(PnControllerSoftingPNAK)
    = { pwr_BindIoMethod(IoAgentInit), pwr_BindIoMethod(IoAgentRead),
        pwr_BindIoMethod(IoAgentWrite), pwr_BindIoMethod(IoAgentClose),
        pwr_BindIoMethod(IoAgentSwap), pwr_NullMethod };
