/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2018 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* xtt_c_pndevice.cpp -- xtt methods for PnDevice. */

#include "pwr_profibusclasses.h"
#include "co_cdh.h"
#include "rt_pb_msg.h"
#include "rt_xnav_msg.h"

#include "xtt_xnav.h"

#include "cow_pn_gsdml_attr.h"

#include "xtt_c_pndevice.h"

static void get_subcid(pwr_tCid cid, std::vector<pwr_tCid>& v)
{
  pwr_tCid subcid;
  pwr_tStatus sts;

  for (sts = gdh_GetSubClassList(cid, &subcid); ODD(sts);
       sts = gdh_GetNextSubClass(cid, subcid, &subcid)) {
    v.push_back(subcid);
    get_subcid(subcid, v);
  }
}

int xtt_pndevice_help_cb(void* sctx, const char* text)
{
  pwr_tCmd cmd;
  xtt_pndevice_sCtx* ctx = (xtt_pndevice_sCtx*)sctx;

  strcpy(cmd, "help ");
  strcat(cmd, text);
  return ((XNav*)ctx->editor_ctx)->command(cmd);
}

void xtt_pndevice_close_cb(void* sctx)
{
  xtt_pndevice_sCtx* ctx = (xtt_pndevice_sCtx*)sctx;
  delete ctx->attr;
  delete ctx->gsdml;
  free((char*)ctx);
}

int xtt_pndevice_save_cb(void* sctx)
{
  return 1;
}

pwr_tStatus xtt_pndevice_create_ctx(
    pwr_tAttrRef aref, void* editor_ctx, xtt_pndevice_sCtx** ctxp)
{
  pwr_tOName name;
  pwr_tString80 gsdmlfile;
  int sts;
  pwr_tFileName fname;
  std::vector<pwr_tCid> mcv;
  pwr_tAttrRef aaref;

  sts = gdh_ObjidToName(aref.Objid, name, sizeof(name), cdh_mName_volumeStrict);
  if (EVEN(sts))
    return sts;

  sts = gdh_ArefANameToAref(&aref, "GSDMLFile", &aaref);
  if (EVEN(sts))
    return sts;

  sts = gdh_GetObjectInfoAttrref(&aaref, gsdmlfile, sizeof(gsdmlfile));
  if (EVEN(sts))
    return sts;
  if (strcmp(gsdmlfile, "") == 0) {
    return PB__GSDATTR;
  }

  xtt_pndevice_sCtx* ctx
      = (xtt_pndevice_sCtx*)calloc(1, sizeof(xtt_pndevice_sCtx));
  ctx->aref = aref;
  ctx->editor_ctx = editor_ctx;

  get_subcid(pwr_cClass_PnModule, mcv);
  ctx->mc
      = (gsdml_sModuleClass*)calloc(mcv.size() + 2, sizeof(gsdml_sModuleClass));

  ctx->mc[0].cid = pwr_cClass_PnModule;
  sts = gdh_ObjidToName(cdh_ClassIdToObjid(ctx->mc[0].cid), ctx->mc[0].name,
      sizeof(ctx->mc[0].name), cdh_mName_object);
  if (EVEN(sts))
    return sts;

  for (int i = 1; i <= (int)mcv.size(); i++) {
    ctx->mc[i].cid = mcv[i - 1];
    sts = gdh_ObjidToName(cdh_ClassIdToObjid(ctx->mc[i].cid), ctx->mc[i].name,
        sizeof(ctx->mc[0].name), cdh_mName_object);
    if (EVEN(sts))
      return sts;
  }

  if (strchr(gsdmlfile, '/') == 0) {
    strcpy(fname, "$pwrp_exe/");
    strcat(fname, gsdmlfile);
  } else
    strcpy(fname, gsdmlfile);

  ctx->gsdml = new pn_gsdml();
  sts = ctx->gsdml->read(fname);
  if (EVEN(sts))
    return sts;
  ctx->gsdml->build();
  ctx->gsdml->set_classes(ctx->mc);

  *ctxp = ctx;
  return 1;
}
