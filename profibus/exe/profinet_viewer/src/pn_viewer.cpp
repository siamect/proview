/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* pn_viewer.cpp -- Profinet viewer */

#ifdef PWRE_CONF_PNAK

#include <stdlib.h>

#include "co_cdh.h"
#include "co_dcli.h"
#include "co_error.h"
#include "co_lng.h"
#include "co_string.h"
#include "co_time.h"

#include "cow_xhelp.h"

#include "pn_viewer_pnac.h"
#include "pn_viewer.h"

static int test = 0;

PnViewer::PnViewer(void* v_parent_ctx, const char* v_name, const char* v_device,
                   pwr_tStatus* status)
    : parent_ctx(v_parent_ctx), viewernav(NULL), viewernavconf(NULL), wow(0),
      input_open(0), pnet(0), close_cb(0)
{
  strcpy(name, v_name);
  strcpy(device, v_device);

  if (!test)
    pnet = new PnViewerPNAC(status, device);
}

PnViewer::~PnViewer() { delete pnet; }

void PnViewer::update_devices()
{
  int sts;

  if (!test)
  {
    dev_vect.clear();
    pnet->fetch_devices(dev_vect);

    conf_vect.clear();
    sts = fetch_config(conf_vect);
    if (EVEN(sts))
      printf("Error reading configuration file\n");

    viewernav->set(dev_vect);
    viewernavconf->set(conf_vect);
  }
  else
  {
    dev_vect.clear();
    sts = fetch_config(dev_vect);
    if (EVEN(sts))
      printf("Error reading configuration file\n");
    viewernav->set(dev_vect);

    strcpy(device, "test"); // Test
    conf_vect.clear();
    sts = fetch_config(conf_vect);
    if (EVEN(sts))
      printf("Error reading configuration file\n");
    viewernavconf->set(conf_vect);
  }
}

void PnViewer::filter(viewer_eFilterType filtertype)
{
  switch (filtertype)
  {
  case viewer_eFilterType_No:
    for (unsigned int i = 0; i < dev_vect.size(); i++)
      dev_vect[i].hide = false;
    for (unsigned int i = 0; i < conf_vect.size(); i++)
      conf_vect[i].hide = false;
    break;
  case viewer_eFilterType_NotMatching:
    // Compare dev_vect and conf_vect and display device that doesn't match
    // Set all
    for (unsigned int i = 0; i < dev_vect.size(); i++)
      dev_vect[i].hide = false;
    for (unsigned int i = 0; i < conf_vect.size(); i++)
      conf_vect[i].hide = false;

    for (unsigned int i = 0; i < dev_vect.size(); i++)
    {
      for (unsigned int j = 0; j < conf_vect.size(); j++)
      {
        if (streq(dev_vect[i].devname, conf_vect[j].devname) &&
            dev_vect[i].vendorid == conf_vect[j].vendorid &&
            dev_vect[i].deviceid == conf_vect[j].deviceid &&
            dev_vect[i].ipaddress[0] == conf_vect[j].ipaddress[0] &&
            dev_vect[i].ipaddress[1] == conf_vect[j].ipaddress[1] &&
            dev_vect[i].ipaddress[2] == conf_vect[j].ipaddress[2] &&
            dev_vect[i].ipaddress[3] == conf_vect[j].ipaddress[3])
        {
          dev_vect[i].hide = true;
          conf_vect[j].hide = true;
          break;
        }
      }
    }
    break;
  }

  viewernav->set(dev_vect);
  viewernavconf->set(conf_vect);
}

int PnViewer::fetch_config(std::vector<PnDevice>& vect)
{
  PnDevice pndevice;
  pwr_tFileName fname;
  char edev[20];
  FILE* fp;
  char line[500];
  char elemv[7][100];
  int nr;
  int sts;

  str_ToLower(edev, device);
  sprintf(fname, "$pwrp_load/pwr_pnviewer_%s.dat", edev);
  dcli_translate_filename(fname, fname);

  fp = fopen(fname, "r");
  if (!fp)
    return 0;

  while (dcli_read_line(line, sizeof(line), fp))
  {
    nr = dcli_parse(line, " ", "", (char*)elemv,
                    sizeof(elemv) / sizeof(elemv[0]), sizeof(elemv[0]), 0);
    if (nr != 6)
      continue;

    strncpy(pndevice.devname, elemv[1], sizeof(pndevice.devname));

    sts = sscanf(elemv[2], "%hhu.%hhu.%hhu.%hhu", &pndevice.ipaddress[3],
                 &pndevice.ipaddress[2], &pndevice.ipaddress[1],
                 &pndevice.ipaddress[0]);
    if (sts != 4)
    {
      printf("Not a valid IP address: %s\n", elemv[2]);
      pndevice.ipaddress[0] = 0;
      pndevice.ipaddress[1] = 0;
      pndevice.ipaddress[2] = 0;
      pndevice.ipaddress[3] = 0;
    }

    sts = sscanf(elemv[3], "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
                 &pndevice.macaddress[5], &pndevice.macaddress[4],
                 &pndevice.macaddress[3], &pndevice.macaddress[2],
                 &pndevice.macaddress[1], &pndevice.macaddress[0]);
    if (sts != 6)
    {
      printf("Not a valid MAC address: %s\n", elemv[3]);
      pndevice.macaddress[0] = 0;
      pndevice.macaddress[1] = 0;
      pndevice.macaddress[2] = 0;
      pndevice.macaddress[3] = 0;
      pndevice.macaddress[4] = 0;
      pndevice.macaddress[5] = 0;
    }

    sts = sscanf(elemv[4], "%u", &pndevice.vendorid);
    if (sts != 1)
      return 0;
    sts = sscanf(elemv[5], "%u", &pndevice.deviceid);
    if (sts != 1)
      return 0;
    vect.push_back(pndevice);
  }
  fclose(fp);

  return 1;
}

void PnViewer::set_device_properties(unsigned char* macaddress,
                                     unsigned char* ipaddress, char* devname)
{
  pnet->set_device_properties(macaddress, ipaddress, devname);
}

void PnViewer::change_value(void* ctx)
{
  PnViewer* viewer = (PnViewer*)ctx;

  viewer->open_change_value();
}

void PnViewer::message_cb(void* ctx, int severity, const char* msg)
{
  PnViewer* viewer = (PnViewer*)ctx;

  viewer->message(severity, msg);
}

void PnViewer::activate_update()
{
  try
  {
    update_devices();
  }
  catch (co_error& e)
  {
    printf("** Update exception: %s\n", e.what().c_str());
  }
}

void PnViewer::activate_filter(viewer_eFilterType filtertype)
{
  filter(filtertype);
}

void PnViewer::activate_setdevice()
{
  pwr_tStatus sts;
  ItemDevice* dev;

  sts = viewernav->get_selected_device(&dev);
  if (EVEN(sts))
  {
    message('E', "Select a device");
    return;
  }

  try
  {
    set_device_properties(dev->macaddress, dev->ipaddress, dev->devname);
  }
  catch (co_error& e)
  {
    printf("** Exception, %s\n", e.what().c_str());
  }
}

void PnViewer::activate_changevalue() { open_change_value(); }

void PnViewer::activate_close()
{
  if (close_cb)
    close_cb(parent_ctx);
  else
  {
    delete this;
    exit(0);
  }
}

void PnViewer::activate_help()
{
  CoXHelp::dhelp("profinet_viewer", 0, navh_eHelpFile_Other,
                 "$pwr_lang/man_pb.dat", true);
}

#endif
