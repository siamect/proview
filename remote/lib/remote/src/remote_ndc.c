/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2020 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* remote_ndc.c -- Network data conversion.  */

#include <string.h>

#include "rt_gdh_msg.h"
#include "rt_vol.h"
#include "rt_cvolc.h"
#include "rt_ndc.h"
#include "rt_ndc_msg.h"
#include "rt_cmvolc.h"

/* Vax f-float on a little endian machine.


   3             2 2             1 1 1           0 0 0           0
   1             4 3             6 5 4           8 7 6           0
  +---------------+---------------+-+-------------+-+-------------+
  |       fraction 15 <- 0        |s|  exponent   : | f 22 <- 16  |
  +---------------+---------------+-+-------------+-+-------------+
   1             0 0             0   0           0 0 2           1
   5             8 7             0   7           1 0 2           6


*/

union vax_f_le {
  unsigned int i;
  struct {
    unsigned int f22_16 : 7;
    unsigned int exp : 8;
    unsigned int sign : 1;
    unsigned int f15_0 : 16;
  } b;
};

/* Vax f-float on a big endian machine.



  +-+-------------+   +-+-------------+   +---------------+   +---------------+
  : | f 22 <- 16  |   |s|  exponent   :   : 15 <- 0       |   |      fraction :
  +-+-------------+   +-+-------------+   +---------------+   +---------------+
   0 2           1       0           0     0             0     1             0
   0 2           6       7           1     7             0     5             8

   0             0 0             1 1 1           2 2             3
   0             7 8             5 6 7           3 4             1
  +---------------+---------------+-+-------------+-+-------------+
  |       fraction 0 -> 15        |s|  exponent   : | f 16 -> 22  |
  +---------------+---------------+-+-------------+-+-------------+
   0             0 0             1   0             0 1           2
   0             7 8             5   0             7 6           2

*/

union vax_f_be {
  unsigned int i;
  struct {
    unsigned int f0_15 : 16;
    unsigned int sign : 1;
    unsigned int exp : 8;
    unsigned int f16_22 : 7;
  } b;
};

/* IEEE single on a little endian machine.

   3             2 2             1 1             0 0             0
   1             4 3             6 5             8 7             0
  +-+-------------+-+-------------+---------------+---------------+
  |s|  exponent   : |        fraction 22 <- 0     :               |
  +-+-------------+-+-------------+---------------+---------------+
     0             0 2           1 1                             0
     7             0 2           6 5                             0

*/

union i3e_s_le {
  unsigned int i;
  struct {
    unsigned int f22_0 : 23;
    unsigned int exp : 8;
    unsigned int sign : 1;
  } b;
  struct {
    unsigned int f15_0 : 16;
    unsigned int f22_16 : 7;
    unsigned int exp : 8;
    unsigned int sign : 1;
  } v;
};

/* IEEE single on a big endian machine.

   0             0 0             1 1             2 2             3
   0             7 8             5 6             3 4             1
  +-+-------------+-+-------------+---------------+---------------+
  |s|  exponent   : |        fraction 0 -> 22     :               |
  +-+-------------+-+-------------+---------------+---------------+
     0           0 0 0           0 0                             2
     0           6 7 0           6 7                             2

*/

union i3e_s_be {
  unsigned int i;
  struct {
    unsigned int sign : 1;
    unsigned int exp : 8;
    unsigned int f0_22 : 23;
  } b;
  struct {
    unsigned int sign : 1;
    unsigned int exp : 8;
    unsigned int f0_6 : 7;
    unsigned int f7_22 : 16;
  } v;
};

union {
  float ff;
  int ii;
  short int sii;
  char cc[4];
} intern;
union {
  unsigned int ii;
  char cc[4];
} tmp;

/**
 * @note There is no support for double.
 *       if we want to implement it we have too look at the OS to decide what
 *       format to use. Because for backward compatibility is the float format
 * set
 *       to vaxF for VAX to AXP and not vaxD and vaxG.
 */

pwr_tBoolean rndc_ConvertData(pwr_tStatus* sts, const gdb_sNode* np,
    gdb_sClass* cp, void* tp, /* Address of target.  */
    const void* sp, /* Address of source.  */
    pwr_tUInt32* size, /* Size of source.  */
    ndc_eOp op, pwr_tUInt32 offset, pwr_tUInt32 offs)
{
  int i;
  int base;
  gdb_sAttribute* ap;
  pwr_tUInt32 aoffs;
  pwr_tUInt32 count;

  /* The new way, convert if different co_mFormat
   * The old way, always convert if different OS
   */

  if ((np->netver >= net_cFirstCclassVersion
          && np->fm.m == gdbroot->my_node->fm.m)
      || (np->netver < net_cFirstCclassVersion && np->os == gdbroot->my_node->os
             && np->fm.b.bo == gdbroot->my_node->fm.b.bo)) {
    if (tp != sp)
      memcpy(tp, sp, *size);
    return 1;
  }

  /* Find attribute.  */

  for (i = 0, ap = cp->attr; i < cp->acount; i++, ap++)
    if (offset <= ap->moffset)
      break;

  if (i >= cp->acount)
    pwr_Return(NO, sts, NDC__OFFSET);

  if (offset == 0)
    base = 0;
  else
    base = ap->offs;

  switch (op) {
  case ndc_eOp_encode:
    for (; i<cp->acount&& * size> 0; i++, ap++) {
      if (ap->flags.b.isclass) {
        gdb_sClass* lcp;

        lcp = hash_Search(sts, gdbroot->cid_ht, &ap->tid);

        /* Single attribute or array */
        /* Loop n:o element */

        aoffs = 0; /* Attribute offset - source */

        for (count = ap->elem; count > 0 && *size > 0; count--) {
          rndc_ConvertData(sts, np, lcp, tp, sp, size, op,
              (offset - ap->offs) % (ap->size / ap->elem),
              ap->offs - base + aoffs + offs);
          aoffs += ap->size / ap->elem;
        }
      }
    }
    break;
  case ndc_eOp_decode:
    for (; i<cp->acount&& * size> 0; i++, ap++) {
      if (ap->flags.b.isclass) {
        gdb_sClass* lcp;

        lcp = hash_Search(sts, gdbroot->cid_ht, &ap->tid);

        /* Single attribute or array */
        /* Loop n:o element */

        aoffs = 0; /* Attribute offset - source */

        for (count = ap->elem; count > 0 && *size > 0; count--) {
          rndc_ConvertData(sts, np, lcp, tp, sp, size, op,
              (offset - ap->offs) % (ap->size / ap->elem),
              ap->offs - base + aoffs + offs);
          aoffs += ap->size / ap->elem;
        }
      }
    }
    break;
  default: {
    char ebuf[80];
    sprintf(ebuf, "unknown op: %d", op);
    errh_Bugcheck(NDC__OP, ebuf);
  }
  }

  pwr_Return(YES, sts, NDC__SUCCESS);
}
