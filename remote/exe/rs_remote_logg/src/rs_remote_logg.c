/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/*************************************************************************
*
* 	PROGRAM		rs_remote_logg
*
*       Modifierad
*		950301	Claes Sjöfors	Skapad
*		010402	Claes Jurstrand	Qcom istf DMQ från v3.0b
*		040630	Claes Jurstrand	v4.0.0
*
*
*	Funktion:
*		Tar emot transar med loggar från remote och loggar på fil.
*
**************************************************************************/

/*_Include filer_________________________________________________________*/

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>

#include "pwr_baseclasses.h"
#include "pwr_remoteclasses.h"
#include "co_time.h"
#include "co_dcli.h"
#include "co_cdh.h"
#include "rt_gdh.h"
#include "rt_gdh_msg.h"
#include "rt_hash_msg.h"
#include "rt_ini_event.h"
#include "rt_qcom_msg.h"
#include "remote.h"
#include "rs_remote_msg.h"

/*_Globala variabler______________________________________________________*/

qcom_sQid remlogg_qid = { rs_pwr_logg_qix, 0 };
qcom_sQattr remlogg_qattr;
qcom_sGet remlogg_get;

/* Global functions________________________________________________________*/

#define LogAndExit(status)                                                     \
  {                                                                            \
    errh_CErrLog(REM__LOGGEXIT, errh_ErrArgMsg(status), NULL);                 \
    exit(status);                                                              \
  }

#define Log(status1, status2)                                                  \
  {                                                                            \
    errh_CErrLog(status1, errh_ErrArgMsg(status2), NULL);                      \
  }

#define LOGG_FILE_EXT ".log"
#define LOGG_MAX_SIZE 32000

typedef struct {
  pwr_tObjid objid;
  pwr_sClass_LoggConfig* loggconf;
  gdh_tDlid subid;
  FILE* outfile;
  int file_open;
  int wait_count;
} logg_t_loggconf_list;

typedef struct {
  logg_t_loggconf_list* loggconflist;
  int loggconf_count;
} * logg_ctx;

/*_Local functions________________________________________________________*/
static pwr_tStatus logg_loggconflist_add(logg_ctx loggctx, pwr_tObjid objid,
    logg_t_loggconf_list** loggconflist, int* loggconflist_count);
static int logg_get_filename(char* inname, char* outname, char* ext);
static pwr_tStatus logg_open_file(
    logg_t_loggconf_list* conflist_ptr, int first_time);
static pwr_tStatus logg_print(logg_ctx loggctx, pwr_tUInt32 ident, char* msg);
static pwr_tStatus logg_get_message(
    logg_ctx loggctx, pwr_tUInt32* ident, char** msg);
static pwr_tStatus logg_init(logg_ctx loggctx);
static pwr_tStatus logg_free_message(void);

/****************************************************************************
* Name:		exit_hdlr()
*
* Type		void
*
* Type		Parameter	IOGF	Description
*
* Description:
*		Called at exit
*
**************************************************************************/
void exit_hdlr()
{
  gdh_DLUnrefObjectInfoAll();
  errh_Info("Exiting\n");
}

/****************************************************************************
* Name:		interrupt_hdlr()
*
* Type		void
*
* Type		Parameter	IOGF	Description
*
* Description:
*		Called at interrupt
*
**************************************************************************/
void interrupt_hdlr()
{
  exit(0);
}

/****************************************************************************
* Name:		logg_loggconflist_add()
*
* Type		pwr_tStatus
*
* Type		Parameter	IOGF	Description
*
* Description:
*		Add a conversion config object to the list.
*
**************************************************************************/
static pwr_tStatus logg_loggconflist_add(logg_ctx loggctx, pwr_tObjid objid,
    logg_t_loggconf_list** loggconflist, int* loggconflist_count)
{
  logg_t_loggconf_list* loggconflist_ptr;
  logg_t_loggconf_list* new_loggconflist;
  pwr_sAttrRef attrref;
  int i;
  pwr_tStatus sts;
  pwr_sClass_LoggConfig* loggconf;

  /* Syntax check */
  sts = gdh_ObjidToPointer(objid, (pwr_tAddress*)&loggconf);
  if (EVEN(sts))
    return sts;

  /* Check that there is some filename */
  if (!strcmp(loggconf->LoggFile, ""))
    return REM__LOGGFILE;

  /* Check that identity is unique */
  loggconflist_ptr = *loggconflist;
  for (i = 0; i < *loggconflist_count; i++) {
    if (loggconflist_ptr->loggconf->Identity == loggconf->Identity)
      return REM__DUPLIDENT;
    loggconflist_ptr++;
  }

  if (*loggconflist_count == 0) {
    *loggconflist = calloc(1, sizeof(logg_t_loggconf_list));
    if (*loggconflist == 0)
      return REM__NOMEMORY;
  } else {
    new_loggconflist
        = calloc(*loggconflist_count + 1, sizeof(logg_t_loggconf_list));
    if (new_loggconflist == 0)
      return REM__NOMEMORY;
    memcpy(new_loggconflist, *loggconflist,
        *loggconflist_count * sizeof(logg_t_loggconf_list));
    free(*loggconflist);
    *loggconflist = new_loggconflist;
  }
  loggconflist_ptr = *loggconflist + *loggconflist_count;
  loggconflist_ptr->objid = objid;

  /* Direct link to the cell */
  memset(&attrref, 0, sizeof(attrref));
  attrref = cdh_ObjidToAref(objid);
  sts = gdh_DLRefObjectInfoAttrref(&attrref,
      (pwr_tAddress*)&loggconflist_ptr->loggconf, &loggconflist_ptr->subid);
  if (EVEN(sts))
    return sts;

  (*loggconflist_count)++;

  return REM__SUCCESS;
}

/*************************************************************************
*
* Name:		logg_get_filename
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Adderar extention till filname om det saknas.
*
**************************************************************************/
static int logg_get_filename(char* inname, char* outname, char* ext)
{
  char* s;
  char* s2;
  pwr_tFileName timestr;
  char comp_timestr[80];
  pwr_tTime time;

  dcli_translate_filename(outname, inname);

  /* Look for extension in filename */
  if (ext != NULL) {
    s = strrchr(outname, ':');
    if (s == 0)
      s = outname;

    s2 = strrchr(s, '>');
    if (s2 == 0) {
      s2 = strrchr(s, ']');
      if (s2 == 0)
        s2 = s;
    }

    s = strrchr(s2, '.');
    if (s != 0)
      *s = 0;
    strcat(outname, ext);
  }

  /* Get current time to use as "version number" */

  time_GetTime(&time);
  time_AtoAscii(&time, time_eFormat_ComprDateAndTime, timestr, sizeof(timestr));
  comp_timestr[0] = '.';
  memcpy(&comp_timestr[1], &timestr[0], 2);
  memcpy(&comp_timestr[3], &timestr[3], 2);
  memcpy(&comp_timestr[5], &timestr[6], 2);
  memcpy(&comp_timestr[7], &timestr[9], 2);
  memcpy(&comp_timestr[9], &timestr[12], 2);
  memcpy(&comp_timestr[11], &timestr[15], 2);
  comp_timestr[13] = 0;
//	  strcat(outname, comp_timestr);

  return REM__SUCCESS;
}

/*************************************************************************
*
* Name:		logg_open_file
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Open current logg file and write a file header.
*
**************************************************************************/

static pwr_tStatus logg_open_file(
    logg_t_loggconf_list* conflist_ptr, int first_time)
{
  int csts;
  char filename[80];
  pwr_tTime time;
  char timestr[80];

  if (!first_time) {
    /* Check if it's time for a new try to open the file */
    conflist_ptr->wait_count++;
    if (conflist_ptr->wait_count < 10)
      return REM__SUCCESS;
    conflist_ptr->wait_count = 0;
  }

  /* Open file */
  logg_get_filename(conflist_ptr->loggconf->LoggFile, filename, LOGG_FILE_EXT);

  conflist_ptr->outfile = fopen(filename, "a+");
  if (conflist_ptr->outfile != NULL) {
    /* Write a file header */
    time_GetTime(&time);
    time_AtoAscii(&time, time_eFormat_DateAndTime, timestr, sizeof(timestr));
    csts = fprintf(
        conflist_ptr->outfile, "RemLogg file opened at %s\n\n", timestr);
    if (csts >= 0) {
      conflist_ptr->loggconf->FileOpenCount++;
      errh_CErrLog(REM__LOGGFILEOPEN, errh_ErrArgAF(filename), NULL);
      conflist_ptr->file_open = 1;
      return REM__SUCCESS;
    } else {
      fclose(conflist_ptr->outfile);
    }
  }
  errh_CErrLog(REM__LOGGFILE, errh_ErrArgAF(filename), NULL);
  return REM__LOGGFILE;
}

/*************************************************************************
*
* Name:		logg_print
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Skrivning av logg meddelande på fil.
*
**************************************************************************/

static pwr_tStatus logg_print(logg_ctx loggctx, pwr_tUInt32 ident, char* msg)
{
  int csts;
  int found;
  int i;
  logg_t_loggconf_list* conflist_ptr;
  logg_t_loggconf_list* garbage_conflist_ptr = NULL;
  int garbage_loggconf_found;

  if (loggctx->loggconf_count == 0)
    /* Not configured */
    return REM__SUCCESS;

  /* Identify the identity */
  found = 0;
  garbage_loggconf_found = 0;
  conflist_ptr = loggctx->loggconflist;
  for (i = 0; i < loggctx->loggconf_count; i++) {
    if (conflist_ptr->loggconf->Identity == 0) {
      /* This is the garbage loggfile */
      garbage_conflist_ptr = conflist_ptr;
      garbage_loggconf_found = 1;
    }
    if (conflist_ptr->loggconf->Identity == ident) {
      found = 1;
      break;
    }
    conflist_ptr++;
  }
  if (!found) {
    if (garbage_loggconf_found) {
      /* Write the logg on the garbage file */
      conflist_ptr = garbage_conflist_ptr;
    } else {
      errh_CErrLog(REM__LOGGIDEN, NULL);
      return REM__SUCCESS;
    }
  }
  /*	csts = fwrite( msg, MIN( strlen(msg),LOGG_MAX_SIZE), 1,
                  conflist_ptr->outfile);
          if (csts == 0)
  */
  if (conflist_ptr->outfile) {
    csts = fprintf(conflist_ptr->outfile, "%s\n", msg);
    if (csts < 0) {
      /* File error, close file and try to open it later */
      errh_CErrLog(REM__LOGGWRITE, NULL);
      fclose(conflist_ptr->outfile);
      conflist_ptr->file_open = 0;
    } else {
      csts = fflush(conflist_ptr->outfile);
      if (csts != 0) {
        /* File error, close file and try to open it later */
        errh_CErrLog(REM__LOGGWRITE, NULL);
        fclose(conflist_ptr->outfile);
        conflist_ptr->file_open = 0;
      } else
        conflist_ptr->loggconf->LoggCount++;
    }
  }
  return REM__SUCCESS;
}

/*************************************************************************
*
* Name:		logg_get_message
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Reads message from qcom with timeout
*
**************************************************************************/

static pwr_tStatus logg_get_message(
    logg_ctx loggctx, pwr_tUInt32* ident, char** msg)
{
  pwr_tStatus sts;
  unsigned int timeout = 200; /* 200 ms */

  memset(&remlogg_get, 0, sizeof(remlogg_get));
  remlogg_get.maxSize = LOGG_MAX_SIZE;

  qcom_Get(&sts, &remlogg_qid, &remlogg_get, timeout);

  if (sts == QCOM__TMO)
    return REM__TIMEOUT;
  else if (EVEN(sts) || (sts == QCOM__QEMPTY))
    return sts;
  else {
    if (remlogg_get.type.b == qcom_eBtype_event) {
      qcom_sEvent* ep = (qcom_sEvent*)remlogg_get.data;
      ini_mEvent new_event;

      if (remlogg_get.type.s == qcom_cIini) {
        new_event.m = ep->mask;
        if (new_event.b.terminate) {
          exit(0);
        }
      }
      logg_free_message();
      return QCOM__QEMPTY;
    } else {
      *ident = *(pwr_tUInt32*)remlogg_get.data;
      *msg = (char*)remlogg_get.data + sizeof(pwr_tUInt32);
    }
  }
  return REM__SUCCESS;
}

/*************************************************************************
*
* Name:		logg_free_message
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Frees qcom message
*
**************************************************************************/

static pwr_tStatus logg_free_message(void)
{
  pwr_tStatus sts = 0;

  if (remlogg_get.data != 0)
    qcom_Free(&sts, remlogg_get.data);

  if (EVEN(sts))
    return sts;

  return REM__SUCCESS;
}

/*************************************************************************
*
* Name:		logg_init
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Initiering av loggfunktionen.
*
**************************************************************************/

static pwr_tStatus logg_init(logg_ctx loggctx)
{
  pwr_tStatus sts;
  pwr_tObjid objid;
  logg_t_loggconf_list* conflist_ptr;
  int i;

  /* Get the logg config objects on this node */
  sts = gdh_GetClassList(pwr_cClass_LoggConfig, &objid);
  while (ODD(sts)) {
    /* Store and direct link the LoggConfig objects */
    sts = logg_loggconflist_add(
        loggctx, objid, &loggctx->loggconflist, &loggctx->loggconf_count);
    if (EVEN(sts))
      Log(REM__CONFINIT, sts);

    sts = gdh_GetNextObject(objid, &objid);
  }

  /* Open the files */
  conflist_ptr = loggctx->loggconflist;
  for (i = 0; i < loggctx->loggconf_count; i++) {
    sts = logg_open_file(conflist_ptr, 1);
    conflist_ptr++;
  }

  return REM__SUCCESS;
}

int main()
{
  logg_ctx loggctx;
  pwr_tStatus sts;
  pwr_tUInt32 ident;
  char* msg;
  logg_t_loggconf_list* conflist_ptr;
  int i;

  /* Exit handler */

  atexit(&exit_hdlr);
  signal(SIGINT, interrupt_hdlr);

  sts = gdh_Init("rs_remote_logg");
  if (EVEN(sts))
    LogAndExit(sts);

  /* Errh init */

  errh_Init("rs_remote_logg", 0);

  /* Initialize qcom que attributes */

  remlogg_qattr.type = qcom_eQtype_private;
  remlogg_qattr.quota = 100;

  /* Delete the queue if it exists */

  qcom_DeleteQ(&sts, &remlogg_qid);

  /* Create the remlogg queue */

  if (!qcom_CreateQ(&sts, &remlogg_qid, &remlogg_qattr, "Logg")) {
    LogAndExit(sts);
  }

  /* Bind it to rt_ini event-queue */

  if (!qcom_Bind(&sts, &remlogg_qid, &qcom_cQini)) {
    errh_Fatal("qcom_Bind, %m", sts);
    //          errh_SetStatus( PWR__SRVTERM);
    exit(-1);
  }

  loggctx = calloc(1, sizeof(*loggctx));
  if (loggctx == 0)
    LogAndExit(REM__NOMEMORY);

  sts = logg_init(loggctx);
  if (EVEN(sts))
    LogAndExit(sts);

  for (;;) {
    /* Get logg message */
    sts = logg_get_message(loggctx, &ident, &msg);
    if (EVEN(sts)) {
      Log(REM__LOGGRCV, sts);
    } else if (sts != REM__TIMEOUT) {
      logg_print(loggctx, ident, msg);
      sts = logg_free_message();
    }

    /* Check if its time to open any file... */
    conflist_ptr = loggctx->loggconflist;
    for (i = 0; i < loggctx->loggconf_count; i++) {
      if (conflist_ptr->loggconf->NewVersion) {
        conflist_ptr->loggconf->NewVersion = 0;
        if (conflist_ptr->file_open) {
          if (conflist_ptr->outfile)
            fclose(conflist_ptr->outfile);
          conflist_ptr->file_open = 0;
          sts = logg_open_file(conflist_ptr, 1);
        }
      } else if (!conflist_ptr->file_open) {
        sts = logg_open_file(conflist_ptr, 0);
      }
      conflist_ptr++;
    }
  }
}
