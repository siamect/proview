/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <locale.h>

#include <fstream>

#include "cow_gtk.h"

#include "co_error.h"
#include "co_string.h"

#include "co_dcli.h"
#include "co_time.h"

#include "rt_errh.h"

#include "xtt_log_gtk.h"

void log_close_cb(void* log)
{
  XttLogGtk* xttlog = (XttLogGtk*)log;

  delete xttlog;
  exit(0);
}

void set_severity(LogNav_hier *hier)
{
  for (int i = 0; i < hier->child.size(); i++) {
    if (hier->child[i].type == lognav_eItemType_Hier)
      set_severity(&hier->child[i]);
    if (hier->child[i].severity > hier->severity)
      hier->severity = hier->child[i].severity;
  }
}

LogNav_hier *get_hier(LogNav_hier *parent, char *hier)
{
  char *s;
  char h1[100], h2[100];
  int last = 0;

  strncpy(h1, hier, sizeof(h1));
  if ((s = strchr(h1, '-'))) {
    *s = 0;
    strncpy(h2, s+1, sizeof(h2));
  }	
  else
    last = 1;

  for (int i = 0; i < parent->child.size(); i++) {
    if (str_NoCaseStrcmp(h1, parent->child[i].text) == 0) {
      if (last)
	return &parent->child[i];
      else
	return get_hier(&parent->child[i], h2);
    }
  }

  // Not found, create
  LogNav_hier item;
  strcpy(item.text, h1);
  item.severity = lognav_eSeverity_No;
  item.type = lognav_eItemType_Hier;
  parent->child.push_back(item);
  if (last)
    return &parent->child[parent->child.size()-1];
  return get_hier(&parent->child[parent->child.size()-1], h2);
}

void file_read(pwr_tStatus *sts, LogNav_hier *tree, char *filename)
{
  FILE *fp;
  char line[200];
  lognav_eSeverity severity;
  char timstr[40];
  char hier[150];
  std::vector<LogNav_hier> store;

  fp = fopen(filename, "r");
  if (!fp) {
    *sts = 0;
    return;
  }
  while (dcli_read_line(line, sizeof(line), fp)) {
    switch (line[0]) {
    case 'S':
      if (line[1] != ' ')
	continue;
      severity = lognav_eSeverity_Success;
      break;
    case 'I':
      if (line[1] != ' ')
	continue;
      severity = lognav_eSeverity_Info;
      break;
    case 'W':
      if (line[1] != ' ')
	continue;
      severity = lognav_eSeverity_Warning;
      break;
    case 'E':
      if (line[1] != ' ')
	continue;
      severity = lognav_eSeverity_Error;
      break;
    case 'F':
      if (line[1] != ' ')
	continue;
      severity = lognav_eSeverity_Fatal;
      break;
    case 'D':
      if (line[1] != ' ')
	continue;
      severity = lognav_eSeverity_Detail;
      break;
    case 'X':
      if (line[1] != ' ')
	continue;
      severity = lognav_eSeverity_DetailError;
      break;
    case 'Z':
      if (line[1] != ' ')
	continue;
      severity = lognav_eSeverity_DetailWarning;
      break;
    default:
      continue;
    }

    LogNav_hier item;
    item.severity = severity;

    char *s = strchr(&line[26], ',');
    if (!s)
      continue;
    *s = 0;
    strncpy(hier, &line[26], sizeof(hier));
    strncpy(item.text, s+2, sizeof(item.text));    
    item.text[sizeof(item.text)-1] = 0;
    item.type = lognav_eItemType_Entry;

    strncpy(timstr, &line[2], 23);
    timstr[23] = 0;
    time_AsciiToA(timstr, &item.time);

    if (severity == lognav_eSeverity_Detail ||
	severity == lognav_eSeverity_DetailError ||
	severity == lognav_eSeverity_DetailWarning) {
      // Store and insert as child to next 'real' item
      store.push_back(item);
      continue;
    }

    LogNav_hier *h = get_hier(tree, hier);
    if (severity > h->severity)
      h->severity = severity;
    h->child.push_back(item);
    if (store.size() != 0) {
      for (int i = 0; i < store.size(); i++) {
	h->child[h->child.size()-1].child.push_back(store[i]);
      }
      store.clear();
    }
  }

  set_severity(tree);
}

void log_read(pwr_tStatus *status, LogNav_hier *tree, char *filename) 
{
  pwr_tFileName found_file;
  pwr_tStatus sts;

  sts = dcli_search_file(filename, found_file, DCLI_DIR_SEARCH_INIT);
  while (ODD(sts)) {
    
    file_read(&sts, tree, found_file);
    sts = dcli_search_file(filename, found_file, DCLI_DIR_SEARCH_NEXT);
  }
  dcli_search_file(filename, found_file, DCLI_DIR_SEARCH_END);
}

int main(int argc, char* argv[])
{
  pwr_tStatus sts;
  pwr_tFileName filename;
  LogNav_hier *tree = 0;

  // Get options
  for (int i = 1; i < argc; i++) {
    if (streq(argv[i], "-f") && i + 1 < argc) {
      strncpy(filename, argv[i + 1], sizeof(filename));
      i++;
    }
  }

  // Read logfiles
  tree = new LogNav_hier();
  log_read(&sts, tree, filename);

  gtk_init(&argc, &argv);

  setlocale(LC_NUMERIC, "POSIX");
  setlocale(LC_TIME, "en_US");

  XttLogGtk* log = new XttLogGtk(0, 0, tree);
  log->close_cb = log_close_cb;

  gtk_main();
  return 1;
}
