/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* xtt_lognav_command.cpp
   This module contains routines for handling of command line in test_xtt. */

#include <ctype.h>
#include <stdlib.h>

#include "co_api_user.h"
#include "co_ccm.h"
#include "co_ccm_msg.h"
#include "co_dbs.h"
#include "co_dcli.h"
#include "co_dcli_msg.h"
#include "co_error.h"
#include "co_string.h"
#include "co_syi.h"
#include "co_user.h"

#include "cow_login.h"
#include "cow_wow.h"
#include "cow_xhelp.h"

#include "flow_msg.h"

#include "glow_curvectx.h"

#include "xtt_log.h"
#include "xtt_lognav.h"
#include "xtt_sevhist.h"

#define XTTLOG__HOLDCOMMAND 21;
#define XTTLOG__SUCCESS 23;

static pwr_tStatus command_sts = 1;
static XttLog* current_xttlog;

static int xttlog_exit_func(void* client_data, void* client_flag);
static int xttlog_help_func(void* client_data, void* client_flag);
static int xttlog_open_func(void* client_data, void* client_flag);
static int xttlog_show_func(void* client_data, void* client_flag);

dcli_tCmdTable xttlog_command_table[] = {
  { "OPEN", &xttlog_open_func, { "dcli_arg1", "dcli_arg2", "/NAME", "" } },
  { "SHOW", &xttlog_show_func, { "dcli_arg1", "" } },
  { "EXIT", &xttlog_exit_func,
      {
          "",
      } },
  { "QUIT", &xttlog_exit_func,
      {
          "",
      } },
  { "HELP", &xttlog_help_func,
      { "dcli_arg1", "dcli_arg2", "dcli_arg3", "dcli_arg4", "/HELPFILE",
          "/POPNAVIGATOR", "/BOOKMARK", "/INDEX", "/BASE", "/RETURNCOMMAND",
          "/WIDTH", "/HEIGHT", "/VERSION", "" } },
  { "", NULL, { "" } }
};

static void xttlog_store_xttlog(XttLog* xttlog)
{
  current_xttlog = xttlog;
}

static int xttlog_help_func(void* client_data, void* client_flag)
{
  XttLog* xttlog = (XttLog*)client_data;
  int sts;
  char arg_str[80];
  char file_str[80];
  char bookmark_str[80];
  char key[80];
  char return_str[80];
  int pop;
  int width, height;
  int nr;

  if (ODD(dcli_get_qualifier("/INDEX", file_str, sizeof(file_str)))) {
    if (ODD(dcli_get_qualifier("/HELPFILE", file_str, sizeof(file_str)))) {
      sts = CoXHelp::dhelp_index(navh_eHelpFile_Other, file_str);
      if (EVEN(sts))
        xttlog->message('E', "Unable to find file");
    } else {
      if (ODD(dcli_get_qualifier("/BASE", 0, 0)))
        sts = CoXHelp::dhelp_index(navh_eHelpFile_Base, NULL);
      else
        sts = CoXHelp::dhelp_index(navh_eHelpFile_Project, NULL);
    }
    return 1;
  }

  if (ODD(dcli_get_qualifier("/VERSION", 0, 0))) {
    sts = CoXHelp::dhelp("version", "", navh_eHelpFile_Other,
        "$pwr_load/xtt_version_help.dat", 0);
    if (EVEN(sts)) {
      sts = CoXHelp::dhelp("version", "", navh_eHelpFile_Other,
          "$pwr_load/sev_xtt_version_help.dat", 0);
      if (EVEN(sts))
        xttlog->message('E', "No help on this subject");
    }
    return sts;
  }

  int strict = 0;
  if (EVEN(dcli_get_qualifier("dcli_arg1", arg_str, sizeof(arg_str)))) {
    sts = CoXHelp::dhelp("help command", "", navh_eHelpFile_Base, NULL, strict);
    return 1;
  }
  if (EVEN(dcli_get_qualifier("/BOOKMARK", bookmark_str, sizeof(bookmark_str))))
    strcpy(bookmark_str, "");

  strcpy(key, arg_str);
  if (ODD(dcli_get_qualifier("dcli_arg2", arg_str, sizeof(arg_str)))) {
    strcat(key, " ");
    strcat(key, arg_str);
    if (ODD(dcli_get_qualifier("dcli_arg3", arg_str, sizeof(arg_str)))) {
      strcat(key, " ");
      strcat(key, arg_str);
      if (ODD(dcli_get_qualifier("dcli_arg3", arg_str, sizeof(arg_str)))) {
        strcat(key, " ");
        strcat(key, arg_str);
        if (ODD(dcli_get_qualifier("dcli_arg4", arg_str, sizeof(arg_str)))) {
          strcat(key, " ");
          strcat(key, arg_str);
        }
      }
    }
  }
  if (!ODD(
          dcli_get_qualifier("/RETURNCOMMAND", return_str, sizeof(return_str))))
    strcpy(return_str, "");

  if (ODD(dcli_get_qualifier("/WIDTH", arg_str, sizeof(arg_str)))) {
    // convert to integer
    nr = sscanf(arg_str, "%d", &width);
    if (nr != 1) {
      xttlog->message('E', "Width syntax error");
      return XTTLOG__HOLDCOMMAND;
    }
  } else
    width = 0;

  if (ODD(dcli_get_qualifier("/HEIGHT", arg_str, sizeof(arg_str)))) {
    // convert to integer
    nr = sscanf(arg_str, "%d", &height);
    if (nr != 1) {
      xttlog->message('E', "Height syntax error");
      return XTTLOG__HOLDCOMMAND;
    }
  } else
    height = 0;

  pop = ODD(dcli_get_qualifier("/POPNAVIGATOR", 0, 0));

  if (ODD(dcli_get_qualifier("/HELPFILE", file_str, sizeof(file_str)))) {
    sts = CoXHelp::dhelp(
        key, bookmark_str, navh_eHelpFile_Other, file_str, strict);
    if (EVEN(sts))
      xttlog->message('E', "No help on this subject");
  } else if (ODD(dcli_get_qualifier("/BASE", 0, 0))) {
    sts = CoXHelp::dhelp(key, bookmark_str, navh_eHelpFile_Base, 0, strict);
    if (EVEN(sts))
      xttlog->message('E', "No help on this subject");
  } else {
    sts = CoXHelp::dhelp(key, bookmark_str, navh_eHelpFile_Base, 0, strict);
    if (EVEN(sts)) {
      sts = CoXHelp::dhelp(
          key, bookmark_str, navh_eHelpFile_Project, 0, strict);
      if (EVEN(sts))
        xttlog->message('E', "No help on this subject");
    }
  }

  return 1;
}

static int xttlog_exit_func(void* client_data, void* client_flag)
{
  XttLog* xttlog = (XttLog*)client_data;

  if (xttlog->close_cb)
    (xttlog->close_cb)(xttlog->parent_ctx);
  else
    exit(1);
  return 1;
}

static int xttlog_open_func(void* client_data, void* client_flag)
{
  XttLog* xttlog = (XttLog*)client_data;

  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_StartsWith(arg1_str, "GRAPH")) {
  } else
    xttlog->message('E', "Syntax error");

  return XTTLOG__SUCCESS;
}

static int xttlog_show_func(void* client_data, void* client_flag)
{
  XttLog* xttlog = (XttLog*)client_data;

  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_StartsWith(arg1_str, "USER")) {
  } else
    xttlog->message('E', "Syntax error");

  return 1;
}

int XttLog::command(char* input_str)
{
  char command[1000];
  int sts, sym_sts;
  char symbol_value[DCLI_SYM_VALUE_SIZE];

  if (input_str[0] == '@') {
    sts = dcli_replace_symbol(input_str, command, sizeof(command));
    if (EVEN(sts))
      return sts;

    /* Read command file */
    sts = readcmdfile(&command[1]);
    if (sts == DCLI__NOFILE) {
      char tmp[1030];
      snprintf(tmp, sizeof(tmp), "Unable to open file \"%s\"", &command[1]);
      message('E', tmp);
      return DCLI__SUCCESS;
    } else if (EVEN(sts))
      return sts;
    return DCLI__SUCCESS;
  }
  dcli_toupper(input_str, input_str);
  sts = dcli_replace_symbol(input_str, command, sizeof(command));
  if (EVEN(sts))
    return sts;

  sts = dcli_cli(
      (dcli_tCmdTable*)&xttlog_command_table, command, (void*)this, 0);
  if (sts == DCLI__COM_NODEF) {
    /* Try to find a matching symbol */
    sym_sts = dcli_get_symbol_cmd(command, symbol_value);
    if (ODD(sym_sts)) {
      if (symbol_value[0] == '@') {
        /* Read command file */
        sts = readcmdfile(&symbol_value[1]);
        if (sts == DCLI__NOFILE) {
          char tmp[230];
          snprintf(tmp, sizeof(tmp), "Unable to open file \"%s\"", &symbol_value[1]);
          message('E', tmp);
          return DCLI__SUCCESS;
        } else if (EVEN(sts))
          return sts;
        return DCLI__SUCCESS;
      }
      sts = dcli_cli(
          (dcli_tCmdTable*)&xttlog_command_table, symbol_value, (void*)this, 0);
    } else if (sym_sts == DCLI__SYMBOL_AMBIG)
      sts = sym_sts;
  }
  if (sts == DCLI__COM_AMBIG)
    message('E', "Ambiguous command");
  else if (sts == DCLI__COM_NODEF)
    message('E', "Undefined command");
  else if (sts == DCLI__QUAL_AMBIG)
    message('E', "Ambiguous qualifier");
  else if (sts == DCLI__QUAL_NODEF)
    message('E', "Undefined qualifier");
  else if (sts == DCLI__SYMBOL_AMBIG)
    message('E', "Ambiguous symbol abbrevation");

  command_sts = sts;
  return DCLI__SUCCESS;
}

static int xttlog_ccm_errormessage_func(
    char* msg, int severity, void* client_data)
{
  XttLog* xttlog = (XttLog*)client_data;

  if (EVEN(severity))
    xttlog->message('I', msg);
  else
    xttlog->message('E', msg);
  return 1;
}

static int xttlog_ccm_deffilename_func(
    char* outfile, char* infile, void* client_data)
{
  pwr_tFileName fname;

  dcli_translate_filename(fname, infile);
  dcli_get_defaultfilename(fname, outfile, ".rtt_com");
  return 1;
}

int xttlog_externcmd_func(char* cmd, void* client_data)
{
  XttLog* xttlog = (XttLog*)client_data;

  return xttlog->command(cmd);
}

int XttLog::readcmdfile(char* incommand)
{
  char input_str[160];
  int sts;
  int appl_sts;

  if (!ccm_func_registred) {
    ccm_func_registred = 1;
  }

  strcpy(input_str, incommand);
  str_trim(input_str, input_str);
  xttlog_store_xttlog(this);

  /* Read and execute the command file */
  sts = ccm_file_exec(input_str, xttlog_externcmd_func,
      xttlog_ccm_deffilename_func, xttlog_ccm_errormessage_func, &appl_sts,
      verify, 0, NULL, 0, 0, NULL, (void*)this);
  if (EVEN(sts))
    return sts;

  return 1;
}

