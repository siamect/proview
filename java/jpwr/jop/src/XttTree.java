/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2012 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jop;
import java.awt.*;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.awt.event.*;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Enumeration;
import java.util.NoSuchElementException;
import java.util.Vector;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.plaf.basic.BasicTreeUI;
import javax.swing.tree.*;
import java.beans.SimpleBeanInfo;
import jpwr.rt.*;

/**
 *@author     Jonas Nylund
 *@created    November 12, 2002
 *@version    1.0
 */

public class XttTree extends JPanel
{
  boolean findFieldEnable = false;
    /*Mats förändringar ny boolean för enterComm tillagd (enterFieldEnable)*/
  boolean enterFieldEnable = false; 
  JPanel userPanel = new JPanel();
  BorderLayout borderLayout1 = new BorderLayout();
  JPanel messagePanel = new JPanel();
   /**  Description of the Field */
  JTextField textUser = new JTextField(10);
  /**  Description of the Field */
  JTextField userValue = new JTextField(25);
  /**  Description of the Field */
  JLabel userValueLabel = new JLabel("Value input: ");    
  JLabel userCommandLabel = new JLabel("Command:");
  JLabel labelMessage = new JLabel("");
  Dimension size;
  /**  Description of the Field */
  JTree tree;
  Object root;
  /**  Description of the Field */
  private JopSession session;
  /**  Description of the Field */
  private JopEngine engine;
  /**  Description of the Field */
  private boolean firstTime = true;
  /**  Description of the Field */
  private Gdh gdh;
  /**  Description of the Field */
  private DefaultMutableTreeNode rootNode;
  /**  Description of the Field */
  private boolean sim = false;
  /**  Description of the Field */
  private DefaultMutableTreeNode tNodeRoot;
  /**  Description of the Field */
  private DefaultTreeModel treeModel;
  private URL url;
  
    //Mats förändringar: popup borttagen
    //final JPopupMenu popup = new JPopupMenu();
  
  InputMap inputMap = new InputMap();
  ActionMap actionMap = new ActionMap();
  JMenuBar menubar = new JMenuBar();
  
  Image XttOpenCloseIcon;
  Image XttOpenIcon;
  Image XttCloseIcon;
  Image XttClosedLeafIcon;
  Image XttOpenLeafIcon;
  Image XttClosedNodeIcon;
  Image XttOpenNodeIcon;
  Image XttObjAttrOpenNodeIcon;
  Image XttObjAttrIcon;
  Image XttObjAttrPointerIcon;
  Image XttObjAttrArrayIcon;
  Image XttObjAttrArrayElementIcon;
  
  String functions_EN = "Functions";
  String functions_SW = "Funktioner";
  String functions;
    
  String language_EN = "Language";
  String language_SW = "Språk";
  String language;
    
  String swedish = "Svenska";
  String english = "English";

  String openObject_EN = "open object";
  String openObject_SW = "öppna objekt";
  String openObject;
    
  String changeValue_EN = "change value";
  String changeValue_SW = "ändra värde";
  String changeValue;
    
  String debug_EN = "debug";
  String debug_SW = "avlusa";
  String debug;
  
  String working_EN = "Working.........";
  String working_SW = "Arbetar.........";
  String working;

  String openPlc_EN = "open PLC";
  String openPlc_SW = "öppna PLC";
  String openPlc;

  String showCross_EN = "show cross";
  String showCross_SW = "visa korsref";
  String showCross;

  String find_EN = "find...";
  String find_SW = "sök...";
  String find;
    //Mats förändringar: strängar för enterComm
  String enterComm_EN = "enter command";
  String enterComm_SW = "kommandorad";
  String enterComm;

  
  static final int SWEDISH = 0;
  static final int ENGLISH = 1;
  int currentLanguage = SWEDISH;
  

  
  /**
   *@param  engine  JopEngine-instansen som trädet använder för uppkopling.
   */
  public XttTree(JopSession session, URL url, Object root)
  {
    Logg.text_lbl = this.labelMessage;
    Logg.logg("ver 1.9.7", 0);
    
    this.session = session;
    this.root = root;
    this.url = url;
    this.engine = session.getEngine();
    session.setNavigator( (Object) this);
    this.gdh = engine.gdh;

    //construct the messagepanel and add it to the panel
    setLayout(borderLayout1);
    Dimension d = messagePanel.getSize();
    d.height += 20;
    messagePanel.setPreferredSize(d);
    add(messagePanel, BorderLayout.SOUTH);
    userValue.setPreferredSize(d);
    messagePanel.setLayout(new BorderLayout());
    messagePanel.add(labelMessage, BorderLayout.CENTER);
    setOpaque(true);
    userPanel.setLayout(new GridBagLayout());

    //get all icons that is to be used in the tree
    XttOpenCloseIcon = JopSpider.getImage(session, "jpwr/jop/xttopencloseicon.gif");
    XttOpenIcon = JopSpider.getImage(session, "jpwr/jop/xttopenicon.gif");
    XttCloseIcon = JopSpider.getImage(session, "jpwr/jop/xttcloseicon.gif");
    XttClosedLeafIcon = JopSpider.getImage(session, "jpwr/jop/xttclosedleaficon.png");
    XttOpenLeafIcon = JopSpider.getImage(session, "jpwr/jop/xttopenleaficon.png");
    XttClosedNodeIcon = JopSpider.getImage(session, "jpwr/jop/xttclosednodeicon.png");
    XttOpenNodeIcon = JopSpider.getImage(session, "jpwr/jop/xttopennodeicon.png");
    XttObjAttrOpenNodeIcon = JopSpider.getImage(session, "jpwr/jop/xttobjattropennodeicon.png");
    XttObjAttrIcon = JopSpider.getImage(session, "jpwr/jop/xttobjattricon.png");
    XttObjAttrPointerIcon = JopSpider.getImage(session, "jpwr/jop/xttobjattrpointericon.png");
    XttObjAttrArrayIcon = JopSpider.getImage(session, "jpwr/jop/xttobjattrarrayicon.png");
    XttObjAttrArrayElementIcon = JopSpider.getImage(session, "jpwr/jop/xttobjattrarrayelementicon.png");

    //create the JTree component
    rootNode = new DefaultMutableTreeNode("DATABAS");
    treeModel = new DefaultTreeModel(rootNode);
    tree = new JTree(treeModel);
    tree.setEditable(false);
    this.tree.setFont(new Font("monospaced", Font.PLAIN, 14));
    this.tree.setCellRenderer(new MyRenderer());
    
    //ugly way to letting all nodes to be able to update the tree when their
    //values change...
    XttObjAttr.treeModel = treeModel;
    //ugly way to letting all objects that wants subscription to get a handle to gdh
    DynamicObj.init(engine);
    
    //get the icons that is for the + and - signs to the left of every node
    BasicTreeUI tui = (BasicTreeUI)tree.getUI();
    ImageIcon OpenCloseIcon = new ImageIcon(XttOpenCloseIcon);
    ImageIcon OpenIcon = new ImageIcon(XttOpenIcon);
    ImageIcon CloseIcon = new ImageIcon(XttCloseIcon);
    // tui.setCollapsedIcon(OpenIcon);
    // tui.setExpandedIcon(CloseIcon);
    tui.setCollapsedIcon(null);
    tui.setExpandedIcon(null);
    tui.setRightChildIndent(5);
    tui.setLeftChildIndent(5);

    tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);

    final JopScrollPane scrollPane = new JopScrollPane();
    scrollPane.setViewportView(tree);
    scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
    add(scrollPane, BorderLayout.CENTER);

    tree.addTreeWillExpandListener(new MyTreeWillExpandListener());
    tree.addTreeExpansionListener(new MyTreeExpansionListener());

    /*---Bygg upp trädet--------------------------------------------------------------*/
    CdhrObjid r = gdh.getRootList();
    if(r.evenSts())
    {
      Logg.logg("XttTree: Kan inte hitta roten avslutar initieringen av trädet", 1);
      return;
    }
    tNodeRoot = new DefaultMutableTreeNode(createXttObj(r));
    rootNode.add(tNodeRoot);
    this.addFirstChild(tNodeRoot);
    int rootRow = 0;
    Vector v = gdh.getAllXttSiblings(r.objid);
    if(v == null)
    {
      Logg.loggToApplet(JopLang.transl("Communication error with GdhServer"));
    }
    else
    {
      for(int i = 0; i < v.size(); i++)
      {
        //String loggStr = new String("XttTree: Börjar bygga root " + rootRow++);
        //Logg.logg(loggStr, 0);
        
	GdhrGetXttObj gdhr = (GdhrGetXttObj)v.get(i);
        XttObj xttObj = new XttObj(gdhr, this.gdh, this.engine);
        tNodeRoot = new DefaultMutableTreeNode(xttObj);
        xttObj.treeNode = tNodeRoot;
        xttObj.init(false);
        if(xttObj.refObj != null)
	{
	  AttrObj.treeModel = this.treeModel;
        }
        rootNode.add(tNodeRoot);
        if(gdhr.hasChildren)
        {
          DefaultMutableTreeNode childNode = new DefaultMutableTreeNode(new XttObj("DummyXttObj"));
          tNodeRoot.add(childNode);
        }
      }
    }
    /*---slut på bygg upp trädet--------------------------------------------------------*/
    
    //make the root invisible(it's just there becasue the JTree component must have exactly 1 root)
    //then expand row 0 so we can se the rootlevel in the system
    tree.expandRow(0);
    
    tree.setScrollsOnExpand(true);
    tree.setRootVisible(false);
    tree.setShowsRootHandles(true);
    tree.setSelectionRow(0);

    
    //add an actionlistener that responds to userinput in the messagepanel
    this.userValue.addActionListener(
      new ActionListener()
      {
        public void actionPerformed(ActionEvent evt)
        {

	    /*Mats förändringar: Omstrukturering av ifsatser + en tillagd ifsats
	      för enterFieldEnable*/
	    if(enterFieldEnable)
	  {
            Logg.logg("XttTree: innan enterCommand:(" + userValue.getText() + ");", 6);
            enterComm(userValue.getText());
	    messagePanel.remove(userValue);
	    messagePanel.remove(userCommandLabel);
	    enterFieldEnable=false;
          }
	    else if(findFieldEnable)
	  {
            Logg.logg("XttTree: innan find(" + userValue.getText() + ");", 6);
            find(userValue.getText());
	    messagePanel.remove(userValue);
	    messagePanel.remove(userValueLabel);
	    findFieldEnable=false;
          }
	  else
	  {
            Logg.logg("XttTree: innan changeValue(" + userValue.getText() + ");", 6);
            changeValue(userValue.getText());
	    messagePanel.remove(userValue);
	    messagePanel.remove(userValueLabel);
	  }         
	  tree.setRequestFocusEnabled(true);

          messagePanel.add(labelMessage, BorderLayout.CENTER);
          messagePanel.doLayout();
          repaint();

          tree.requestFocus();
        }
      });
    Logg.logg("XttTree ready", 0);
  }
  
  /**
   *  Adderar alla barn till en nod i trädet. Kontrollerar också om barnen har
   *  barn, om så är fallet adderas det första barnet till barnet!!!
   *
   *@param  tN  noden vars eventuella barn skall adderas.
   *@param  tC  nodens första barn som alltid måste finnas qqq
   */
  public void addChildren(DefaultMutableTreeNode tN, DefaultMutableTreeNode tC)
  {
    tN.remove(tC);
    XttObj obj = (XttObj)tN.getUserObject();
    Vector v = this.gdh.getAllXttChildren(obj.objId.objid);
    if(!(v instanceof Vector))
    {
      Logg.logg("XttTree: getAllXttChildren returnerar annat än Vector", 1);
      return;
    }
    //används utifall användaren angett debug
    //Vector<String> ref_vec = new Vector<String>();
    Vector ref_vec = new Vector();
    //används utifall användaren angett debug
    //Vector<XttRefObj> o_vec = new Vector<XttRefObj>();
    Vector o_vec = new Vector();

    //loopa igenom resultat-vektorn
    for(int i = 0; i < v.size(); i++)
    {
      GdhrGetXttObj gdhr = (GdhrGetXttObj)v.get(i);
      if(gdhr.evenSts())
      {
        Logg.logg("XttTree: getAllXttChildren har returnerat ett objekt med felstatus", 1);
        break;
      }
      XttObj o = new XttObj(gdhr, this.gdh, this.engine);
      DefaultMutableTreeNode childNode = new DefaultMutableTreeNode(o);
      o.treeNode = childNode;
      o.init(obj.debug);
      if(obj.debug && o.refObj != null)
      {
        ref_vec.add(((XttObjAttr)(o.refObj.getXttObjAttr())).fullName);
        o_vec.add(o.refObj);
      }
      tN.add(childNode);
      if(gdhr.hasChildren)
      {
        DefaultMutableTreeNode c = new DefaultMutableTreeNode(new XttObj("DummyXttObj"));
        childNode.add(c);
      }
    }
    if(obj.debug)
    {
      Vector ret_vec = engine.gdh.refObjectInfo_Vector(ref_vec);
      if(ret_vec == null)
      {
        Logg.logg("refObjectInfo_Vector returnerar null vid debug", 1);
        return;
      }
      for(int i = 0; i < o_vec.size() && i < ret_vec.size(); i++)
      {
        ((XttRefObj)(o_vec.get(i))).objAttr.refObj = (GdhrRefObjectInfo)ret_vec.get(i);
      }
      if(!engine.isReady())
      {
        engine.setFrameReady();
        //firstTime = false;
      }
    }
  }

  /**
   *  Kontrollerar om en nod har barn, om så är fallet adderas det första barnet
   *  till noden.
   *
   *@param  tN  Noden vars eventuella barn skall adderas. qqq
   */
  public void addFirstChild(DefaultMutableTreeNode tN)
  {
    Object obj = tN.getUserObject();
    if(obj instanceof XttObj)
    {
      //we must do this for the first node in the tree
      if(firstTime)
      {
        firstTime = false;
        CdhrObjid child = this.gdh.getChild(((XttObj)obj).objId.objid);
        if(child.oddSts())
        {
          //we must know if the node has children
          ((XttObj)obj).hasChildren = true;
          DefaultMutableTreeNode childNode = new DefaultMutableTreeNode(new XttObj("DummyXttObj"));
          tN.add(childNode);
        }
      }
      else if(((XttObj)obj).hasChildren)
      {
        //we must know if the node has children
        //((XttObj)obj).hasChildren = true;
        DefaultMutableTreeNode childNode = new DefaultMutableTreeNode(new XttObj("DummyXttObj"));
        tN.add(childNode);
      }
    }
    else
    {
      Logg.logg("XttTree: addFirstChild anropades med en nod som ej har ett XttObj utan ett "
           + obj.getClass().getName(), 3);
    }
  }

  /**
   *  Raderar alla barn för en nod, skapar sedan nya med annat innehåll
   *
   *@param  treePath  The feature to be added to the ObjectInfo attribute
   */
  public void addObjectInfo(TreePath treePath)
  {
    TreePath tp;
    if(treePath == null)
    {
      tp = this.tree.getSelectionPath();
      if(tp == null)
      {
        return;
      }
    }
    else
    {
      tp = treePath;
    }

    DefaultMutableTreeNode tN = (DefaultMutableTreeNode)(tp.getLastPathComponent());
    if(tN.getUserObject() instanceof XttObj)
    {
      XttObj obj = (XttObj)tN.getUserObject();
      if(obj.hasBeenReferenced)
      {
        return;
      }
      if(obj.debug && this.tree.isExpanded(tp))
      {
        this.handleTreeCollapsed(tp);
      }
      tN.removeAllChildren();
      Logg.logg("XttTree: Barnen borttagna", 6);

      Logg.logg("XttTree: Före getObjectAttributes", 6);
      PwrtObjid pwrobjid = new PwrtObjid(0, 0);

      Vector v = (Vector)gdh.getAllClassAttributes(obj.fullName);
      Logg.logg("XttTree: Efter getAllClassAttributes", 6);
      if(v == null)
      {
        Logg.logg("XttTree: Vector == null efter getAllClassAttributes", 4);
        return;
      }
      Vector xttObjAttrVec = new Vector();
      for(int i = 0; i < v.size(); i++)
      {
	
        CdhrObjAttr cdhrobjattr = (CdhrObjAttr)v.get(i);
	/*
	if(((cdhrobjattr.flags & Pwr.mAdef_class) > 0) &&
	   ((cdhrobjattr.flags & Pwr.mAdef_array) <= 0))
	*/
	if((cdhrobjattr.flags & Pwr.mAdef_class) > 0)
	{
	  Logg.logg("XttTree:  Hittat klass, vad ska jag göra nu?? " + obj.fullName + " " + cdhrobjattr.name , 1);
	  CdhrObjid cdhrObjid = gdh.classIdToObjid(cdhrobjattr.type);
       
       	  CdhrAttrRef aref = gdh.nameToAttrRef(obj.fullName + "." + cdhrobjattr.name);

	  String className = gdh.objidToName(cdhrObjid.objid, Cdh.mName_object).str;

          XttObj classObj = new XttObj(this.engine.gdh, 
                                     this.engine, 
                                     obj.fullName + "." + cdhrobjattr.name, 
                                     cdhrobjattr.name,
				     className,
				       cdhrObjid,//  co, new CdhrObjid(aref.aref.getObjid(),aref.getSts()),
				      new CdhrClassId(cdhrobjattr.type, 1)); 
          DefaultMutableTreeNode classObjTreeNode = new DefaultMutableTreeNode(classObj);
          classObj.treeNode = classObjTreeNode;
          tN.add(classObjTreeNode);

	  
	  if((cdhrobjattr.flags & Pwr.mAdef_array) > 0)
	  {
	    classObj.hasChildren = true;
            DefaultMutableTreeNode c = new DefaultMutableTreeNode(new XttObj("DummyXttObj"));
            classObjTreeNode.add(c);
          }
	  
	  
	}
	else {
          XttObjAttr xttObjAttr = new XttObjAttr(cdhrobjattr);
	  xttObjAttrVec.add(xttObjAttr);
	  DefaultMutableTreeNode objAttrTreeNode = new DefaultMutableTreeNode(xttObjAttr);
	  xttObjAttr.treeNode = objAttrTreeNode;
	  tN.add(objAttrTreeNode);
	}
      }
      obj.addAttrVector(xttObjAttrVec);
      Logg.logg("XttTree: Efter getObjectAttributes", 6);
      treeModel.reload(tN);
      this.tree.expandPath(tp);
    }
  }

  /**
   *  Ändrar värde på markerat objekt till valueString Om det ej går att ändra
   *  värde anropas Logg.loggToApplet() med felmeddelande.
   *
   *@param  valueString  Önskat värde i strängform
   */
  public void changeValue(String valueString)
  {
    Logg.logg("XttTree: Användare vill ändra värde", 6);

    TreePath tp = this.tree.getSelectionPath();
    //inget objekt är markerat
    if(tp == null)
    {
      Logg.loggToApplet(JopLang.transl("Select an object"));
      return;
    }
    DefaultMutableTreeNode tn = (DefaultMutableTreeNode)(tp.getLastPathComponent());
    //inget objekt är markerat
    if(tn == null)
    {
      Logg.loggToApplet(JopLang.transl("Select an object"));
      return;
    }
    Object userObject = tn.getUserObject();
    String name = null;
    int type = 0;

    if(userObject instanceof XttObjAttr)
    {
      XttObjAttr obj = (XttObjAttr)userObject;
      name = obj.fullName;
      type = obj.type;
    }
    else if(userObject instanceof XttArrayAttr)
    {
      XttArrayAttr obj = (XttArrayAttr)userObject;
      name = obj.fullName;
      type = obj.type;
    }
    //Markerat objekt kan ej ändra värde
    if(name == null)
    {
      Logg.loggToApplet(JopLang.transl("Unable to change value on selected object"));
      return;
    }
    Logg.logg("XttTree: Användren vill ändra värde på " + name, 6);
    PwrtStatus sts = new PwrtStatus(1);
    switch (type)
    {
      case Pwr.eType_Float32:
      case Pwr.eType_Float64:
        Logg.logg("XttTree.changeValue: innan setObjectInfo(string, float);", 6);
        try
        {
          Float f = new Float(valueString);
          sts = gdh.setObjectInfo(name, f.floatValue());
        }
        catch(NumberFormatException e)
        {
          Logg.loggToApplet(JopLang.transl("Syntax error"));
          return;
        }

        break;
      case Pwr.eType_Int8:
      case Pwr.eType_Int16:
      case Pwr.eType_Int32:
      case Pwr.eType_Int64:
      case Pwr.eType_UInt8:
      case Pwr.eType_UInt16:
      case Pwr.eType_UInt32:
      case Pwr.eType_UInt64:
      case Pwr.eType_Status:
      case Pwr.eType_NetStatus:
      case Pwr.eType_Enum:
      case Pwr.eType_Mask:
        Logg.logg("XttTree.changeValue: innan setObjectInfo(string, int);", 6);
        try
        {
          Integer i = new Integer(valueString);
          sts = gdh.setObjectInfo(name, i.intValue());
        }
        catch(NumberFormatException e)
        {
	  Logg.loggToApplet(JopLang.transl("Syntax error"));
          return;
        }

        break;
      case Pwr.eType_Boolean:
        Logg.logg("XttTree.changeValue: innan setObjectInfo(string, boolean);", 6);
        try
        {
          Integer i = new Integer(valueString);
          if(i.intValue() == 1)
          {
            sts = gdh.setObjectInfo(name, true);
            //Logg.logg("XttTree.changeValue(" + valueString + ");" + "gav true", 6);
          }
          else if(i.intValue() == 0)
          {
            sts = gdh.setObjectInfo(name, false);
            //Logg.logg("XttTree.changeValue(" + valueString + ");" + "gav false", 6);
          }
          else
          {
	    Logg.loggToApplet(JopLang.transl("Syntax error"));
            return;
          }
        }
        catch(NumberFormatException e)
        {
	  Logg.loggToApplet(JopLang.transl("Syntax error"));
          return;
        }
        break;
      //the rest is treated like strings...
//        case Pwr.eType_String:
//          obj.setValue(en.gdh.getObjectRefInfoString(obj.refObj.id, obj.type));
//          break;
      default:
        Logg.logg("XttTree.changeValue: innan setObjectInfo(string, string);", 6);
        //qqq borde kolla så att det gick bra
        sts = gdh.setObjectInfo(name, valueString);
        Logg.logg("efter setObjectInfo(string, string)", 4);
        break;
    }
    if(sts.evenSts())
    {
      CdhrString sret = gdh.getMsg( sts.getSts());
      Logg.loggToApplet(sret.str);
    }
  }

  /**
   *  Anropas då en nod, oavsett typ, skall stängas. Kontrollerar om noden är
   *  expanderad och i så fall stänger då noden. Om noden ej är expanderad så
   *  stängs föräldernoden.
   */
  public void collapseNode()
  {
    TreePath tpc = tree.getSelectionPath();
    if(tpc == null)
    {
      return;
    }
    TreePath tp = tpc.getParentPath();

    //om vi har en nod vars barn är är synliga
    if(!treeModel.isLeaf(tpc.getLastPathComponent()) && tree.isExpanded(tpc))
    {
      Logg.logg("XttTree: Förälderkollapsering " + tpc.toString(), 6);
      tree.collapsePath(tpc);
      tree.setSelectionPath(tpc);
      tree.scrollPathToVisible(tpc);
    }
    //vi är ej på rootnivån
    else if(tp.getPathCount() > 1)
    {
      tree.collapsePath(tp);
      tree.setSelectionPath(tp);
      tree.scrollPathToVisible(tp);
    }
  }

  /**
   *  Skapar ett XttObj genom några Gdh-anrop
   *
   *@param  c  CdhrObjid för det objektet som skall skapa XttObj.
   *@return    Det nya XttObj som skapats
   */
  public XttObj createXttObj(CdhrObjid c)
  {
    CdhrClassId clId = this.gdh.getObjectClass(c.objid);
    if(clId.evenSts())
    {
      Logg.logg("XttTree: Gdh returnerar fel vid getObjectClass, objekt: " + c.toString(), 3);
    }
    CdhrObjid classObj = this.gdh.classIdToObjid(clId.classId);
    if(classObj.evenSts())
    {
      Logg.logg("XttTree: Gdh returnerar fel vid classIdToObjId, objekt: " + c.toString(), 3);
    }
    String className = this.gdh.objidToName(classObj.objid, Cdh.mName_object).str;
    return new XttObj(this.gdh, this.engine, this.gdh.objidToName(c.objid, Cdh.mName_pathStrict).str,
        this.gdh.objidToName(c.objid, Cdh.mName_object).str, className, c, clId);
  }

  /**
   *  Anropas då användaren vill göra debug på en hierarki. Sätter debug-flaggan
   *  i XttObj-objektet som är userObject is treePath
   *
   *@param  treePath  Hierarki som skall "debuggas"
   */
  public void debugNode(TreePath treePath)
  {
    TreePath tp;
    if(treePath == null)
    {
      tp = this.tree.getSelectionPath();
      if(tp == null)
      {
        return;
      }
    }
    else
    {
      tp = treePath;
    }

    DefaultMutableTreeNode tN = (DefaultMutableTreeNode)(tp.getLastPathComponent());
    if(tN.getUserObject() instanceof XttObj)
    {
      XttObj obj = (XttObj)tN.getUserObject();
      obj.debug = true;
      this.tree.expandPath(tp);
    }
  }

//----------------code for searching the tree------------------------------------------------------- x 
  public void find(PwrtObjid objid)
  {
    String str = this.gdh.objidToName(objid, Cdh.mName_pathStrict).str;
    if(str != null)
      this.find(str);
    TreePath selectedPath = this.tree.getSelectionPath();
    if(selectedPath != null)
      this.tree.scrollPathToVisible(selectedPath);
  }
  
  public void find(String userStr)
  {
    this.findPathAndSetExpanded(userStr);
  }
            
  public void findPathAndSetExpanded(String objectName)
  {
    //save selected path so that we can set it selected if we don't find
    //what we are looking for
    TreePath selectedPath = this.tree.getSelectionPath();
    
    //Vector<String> pathVec = createPathVec(objectName);
    Vector pathVec = createPathVec(objectName);
    int ret = 1;
    DefaultMutableTreeNode tn = this.rootNode;
    TreePath tp;
    for(int i = 0;i < pathVec.size();i++)
    {
      tp = expandPath(tn,(String)pathVec.get(i));
      if(tp == null)
        break;
      tn = (DefaultMutableTreeNode)tp.getLastPathComponent();
    }
    if(tn == null)
    {
      Logg.loggToApplet("Kunde ej hitta:" + objectName);
    }      
  }

  //public Vector<String> createPathVec(String name)
  public Vector createPathVec(String name)
  {
    //Vector<String> pathVec = new Vector<String>();
    Vector pathVec = new Vector();
    int strIndex;
    int i = 0;
    strIndex = name.indexOf('-');
    if(strIndex < 0)
    {
      strIndex = name.indexOf('.');
    }
    if(strIndex < 0)
    {
      pathVec.add(name);
      return pathVec;
    }
    while(strIndex >= 0)
    {
      pathVec.add(name.substring(0, strIndex));
      i = name.indexOf('-', strIndex+1);
      if(i < 0)
      {
        i = name.indexOf('.', strIndex+1);
      }
      if(i < 0)
      {
        pathVec.add(name);
      }
      strIndex = i;
    }
    return pathVec;
  }

  public TreePath expandPath(DefaultMutableTreeNode treeNode, String pathName)
  {
    int nrOfChildren = treeNode.getChildCount();
    DefaultMutableTreeNode tn;
    TreeObj obj;
    String str;
    for(int i = 0;i < nrOfChildren;i++)
    {
      tn = (DefaultMutableTreeNode)treeNode.getChildAt(i);
      try
      {
        obj = (TreeObj)tn.getUserObject();
      }
      catch(Exception e)
      {return null;}
      //cut the name before #(when the searched object is
      //an attribute ex rt-rtt-Dv1.ActualValue##Boolean)
      int ind = obj.fullName.indexOf('#');
      if(ind > 0)
      {
        str = obj.fullName.substring(0,ind);
      }
      else
        str = obj.fullName;
      if(str.compareToIgnoreCase(pathName) == 0)
      {
        
	TreePath tp = new TreePath(tn.getPath());
//	if(tn.isLeaf())
//	{
//	  addObjectInfo(tp);
//	}
//	else
	  this.tree.expandPath(tp);
	this.tree.setSelectionPath(tp);
	return tp;
      }
    }
    return null;
  }
//----------------end code for searching the tree-------------------------------------------------------


  /**
   *  Description of the Method
   *
   *@param  tp  Description of the Parameter
   */
  public void handleTreeCollapsed(TreePath tp)
  {

    DefaultMutableTreeNode tn = (DefaultMutableTreeNode)(tp.getLastPathComponent());
    DefaultMutableTreeNode tc;
    try
    {
      tc = (DefaultMutableTreeNode)tn.getFirstChild();
    }
    catch(NoSuchElementException e)
    {
      tc = new DefaultMutableTreeNode("Dummy");
    }
    if((tn != null) &&
        (tree.getSelectionPath() != null))
    {

      Logg.logg("XttTree: Har kollapsat", 6);
      if(tn.getUserObject() instanceof XttObj && !(tc.getUserObject() instanceof XttObj))
      {
        Logg.logg("XttTree: Tar bort attrVector", 6);
        ((XttObj)tn.getUserObject()).removeAttrVector();
        ((XttObj)tn.getUserObject()).debug = false;
        tn.removeAllChildren();
        Logg.logg("XttTree: Barnen borttagna", 6);
        addFirstChild(tn);
        treeModel.reload(tn);
      }

      else if(tn.getUserObject() instanceof XttObj && (tc.getUserObject() instanceof XttObj))
      {
        Logg.logg("XttTree: XttObj-barnen borttagna", 6);
        XttObj obj = ((XttObj)tn.getUserObject());
        if(obj.debug)
        {
	  //Vector<PwrtRefId> unref_vec = new Vector<PwrtRefId>();
          Vector unref_vec = new Vector();
          obj.debug = false;
          Enumeration enm = tn.children();
          while(enm.hasMoreElements())
          {
            DefaultMutableTreeNode child = (DefaultMutableTreeNode)enm.nextElement();
            XttObj childObj = (XttObj)child.getUserObject();
            if(childObj.refObj != null)
            {
              unref_vec.add(childObj.refObj.getPwrtRefId());
              engine.remove(childObj.refObj);
	    }
            
          }
          engine.gdh.unrefObjectInfo_Vector(unref_vec);
        }
        tn.removeAllChildren();
        addFirstChild(tn);
        treeModel.reload(tn);
      }
    }
  }

  AbstractAction ADDOBJECTINFO = new AbstractAction("ADDOBJECTINFO")
                                 {
                                   public void actionPerformed(ActionEvent evt)
                                   {
                                     Logg.logg("XttTree: innan addObjectInfo();", 4);
                                     addObjectInfo((TreePath)null);
                                   }
                                 };

  AbstractAction COLLAPSENODE = new AbstractAction("COLLAPSENODE")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
                                    Logg.logg("XttTree: innan collapseNode();", 4);
                                    collapseNode();
                                  }
                                };

  AbstractAction CHANGEVALUE =  new AbstractAction("CHANGEVALUE")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
                                    Logg.logg("XttTree: innan changeValue();", 4);
                                    changeValue();
                                  }
                                };
  AbstractAction OPENPLC =      new AbstractAction("OPENPLC")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
                                    Logg.logg("XttTree: innan openPLC();", 4);
                                    openPLC();
                                  }
                                };

  AbstractAction OPENGRAPH =      new AbstractAction("OPENGRAPH")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
                                    Logg.logg("XttTree: innan openGraph();", 4);
                                    openGraph();
                                  }
                                };

  AbstractAction SHOWCROSS =    new AbstractAction("SHOWCROSS")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
                                    Logg.logg("XttTree: innan showCross();", 4);
                                    showCross();
                                  }
                                };

  AbstractAction DEBUG =        new AbstractAction("DEBUG")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
                                    Logg.logg("XttTree: innan debug();", 0);
                                    debugNode((TreePath)null);
                                  }
                                };

  AbstractAction INCLOG =       new AbstractAction("INCLOG")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
                                    Logg.loggPrio++;
                                    Logg.logg("LoggPrio changed to: " + Logg.loggPrio, 0);
                                  }
                                };
  AbstractAction DECLOG =       new AbstractAction("DECLOG")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
				    if(Logg.loggPrio > 0);
                                      Logg.loggPrio--;
                                    Logg.logg("LoggPrio changed to: " + Logg.loggPrio, 0);
                                  }
                                };
  AbstractAction FIND =         new AbstractAction("FIND")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
				    find();
                                  }
                                };

  AbstractAction COMM =         new AbstractAction("COMM")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
				    enterComm();
                                  }
                                };

  AbstractAction CLOSE =         new AbstractAction("CLOSE")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
				    close();
                                  }
                                };



  /**
   *  Creates menuitem and keyboardbinding for a "method"
   *
   *@param  name           The string that is to be shown in the menu's
   *@param  action         The action who should be associated with the method
   *@param  actionName     The name of the action
   *@param  toPopup        If true the method will be added to the popupmenu 
   *@param  toMenu         The index of the menu where the method will be, if -1 the method won't be added to any menu
   *@param  keyStroke      A string representing the key-combination that is to be associated with the method
   *@return                Void
   */

  // Mats förändringar: booelan toPopup borttagen.
  public void newMethod(String name, Action action, String actionName, /*boolean toPopup,*/ int toMenu, String keyStroke) {
    if ( action != null) {
      actionMap.put(actionName, action);
    }
    if ( keyStroke != null) {
      inputMap.put(KeyStroke.getKeyStroke(keyStroke), actionName);
    }
    if ( toMenu >= 0) {
      menubar.getMenu(toMenu).add(menuItem(JopLang.transl(name), action, keyStroke));
    }
  }
  

  /**
  * Creates all input possibilities that the user can use
  */
  public void createUserInputs()
  {

    JMenu file = new JMenu(JopLang.transl("File"));
    file.setMnemonic('F');
    JMenu edit = new JMenu(JopLang.transl("Edit"));
    edit.setMnemonic('E');
    JMenu functions = new JMenu(JopLang.transl("Functions"));
    functions.setMnemonic('u');
    JMenu languageSel = new JMenu(language);
    languageSel.setMnemonic('S');

    // Skapa en menylist och lägg till ovan skapade "panes" i denna.
    menubar.add(file);
    menubar.add(edit);
    menubar.add(functions);
    menubar.add(languageSel);
    
    this.getRootPane().setJMenuBar(menubar);
    
    // Create some keystrokes and bind them to an action
    this.newMethod("Open Object", ADDOBJECTINFO, "ADDOBJECTINFO", 2, "ctrl A");
    this.newMethod("Open Object", ADDOBJECTINFO, "ADDOBJECTINFO", -1, "shift RIGHT");
    this.newMethod("COLLAPSENODE", COLLAPSENODE, "COLLAPSENODE", -1, "LEFT");
    this.newMethod("Open Plc", OPENPLC, "OPENPLC", 2, "ctrl L");
    this.newMethod("Open Object Graph", OPENGRAPH, "OPENGRAPH", 2, "ctrl G");
    this.newMethod("Show Crossreferences", SHOWCROSS, "SHOWCROSS", 2, "ctrl R");
    this.newMethod("Change Value", CHANGEVALUE, "CHANGEVALUE", 2, "ctrl Q");
    // this.newMethod("Debug", DEBUG, "DEBUG", 2, "ctrl RIGHT");
    this.newMethod("Search", FIND, "FIND", 1, "ctrl F");
    this.newMethod("INCLOG", INCLOG, "INCLOG", -1, "ctrl O");
    this.newMethod("DECLOG", DECLOG, "DECLOG", -1, "ctrl P");
    this.newMethod("Command", COMM,"COMM",2,"ctrl B");
    this.newMethod("Close", CLOSE,"CLOSE",0,"ctrl W");

    inputMap.setParent(this.tree.getInputMap(JComponent.WHEN_FOCUSED));
    this.tree.setInputMap(JComponent.WHEN_FOCUSED, inputMap);

    actionMap.setParent(this.tree.getActionMap());
    this.tree.setActionMap(actionMap);
    
    
    // Ordna så att snabbmenyn visas då man klickar i huvudfönstret.
    //och så att SHIFT + musklick ger "öppna objekt" 
    this.tree.addMouseListener(
      new MouseAdapter()
      {
        public void mousePressed(MouseEvent e)
        {
          int selRow = tree.getRowForLocation(e.getX(), e.getY());
          TreePath selPath = tree.getPathForLocation(e.getX(), e.getY());
          if(selRow != -1)
          {
            if(e.getClickCount() == 1 && e.isShiftDown())
            {
              //TreePath oldSelectedPath = tree.getSelectionPath();
              selPath = tree.getPathForRow(selRow);
              tree.setSelectionPath(selPath);
              addObjectInfo(selPath);
            }
            else if(e.getClickCount() == 1 && e.isControlDown())
            {
              selPath = tree.getPathForRow(selRow);
              tree.setSelectionPath(selPath);
              debugNode(selPath);
            }
            else if(e.getClickCount() == 1)
            {
              selPath = tree.getPathForRow(selRow);
              tree.setSelectionPath(selPath);
            }
            if(e.isPopupTrigger())
            {
	      //Mats förändringar: popup borttagen, JopMethodsMenu tillagd.
	      TreePath tp = tree.getSelectionPath();
	      if(tp == null) return;
	      DefaultMutableTreeNode tn = (DefaultMutableTreeNode)(tp.getLastPathComponent());
	      if(tn == null) return;
	      try {
		TreeObj obj = (TreeObj)tn.getUserObject();
		String name = obj.fullName;

		if(name == null)
		  return;

		// Remove any type suffix
		String str;
		int idx1 = name.indexOf('#');
		if ( idx1 != -1) {
		  int idx2 = name.indexOf('[');
		  if ( idx2 != -1)
		    str = name.substring( 0, idx1) + name.substring(idx2);
		  else
		    str = name.substring( 0, idx1);
		}
		else
		  str = name;

		new JopMethodsMenu( session, str, 
				    JopUtility.NAVIGATOR, (Component) tree, 
				    e.getX(), e.getY());
		      
	      }
	      catch(Exception ex) {
		 Logg.logg("Error in showCross() " + ex.toString(),0);
	      }
	      Logg.loggToApplet("");
              //popup.show((Component)e.getSource(), e.getX(), e.getY());
            }
          }
        }


        public void mouseReleased(MouseEvent e)
        {
          // Kontrollera om detta är rätt typ av händelse för att visa en snabbmeny

          if(e.isPopupTrigger())
          {
	    //Mats förändringar: popup borttagen, JopMethodsMenu tillagd.
	    TreePath tp = tree.getSelectionPath();
	    if(tp == null) return;
	    DefaultMutableTreeNode tn = (DefaultMutableTreeNode)(tp.getLastPathComponent());
	    if(tn == null) return;
	    try {
	      TreeObj obj = (TreeObj)tn.getUserObject();
	      String name = obj.fullName;
	      if(name == null)
		return;

	      new JopMethodsMenu( session, name, 
				  JopUtility.NAVIGATOR,(Component) tree, 
				  e.getX(), e.getY());
	      
	    }
	    catch(Exception ex) {
	      Logg.logg("Error in showCross() " + ex.toString(),0);
	    }
	    Logg.loggToApplet("");
	    // popup.show((Component)e.getSource(), e.getX(), e.getY());
          }
        }
      });
  }

  // En hjälpmethod för att skapa menyobjekt.
  /**
   *  Description of the Method
   *
   *@param  label           Description of the Parameter
   *@param  listener        Description of the Parameter
   *@param  command         Description of the Parameter
   *@param  mnemonic        Description of the Parameter
   *@param  acceleratorKey  Description of the Parameter
   *@return                 Description of the Return Value
   */
  public static JMenuItem menuItem(String label,
      Action action,
      String keyStroke)
  {
    JMenuItem item = new JMenuItem(label);
    item.setAction(action);
    item.setText(label);
    if(keyStroke != null)
    {
      item.setAccelerator(KeyStroke.getKeyStroke(keyStroke));
    }
    return item;
  }

  public void close() {
  }

  public void showCross()
  {
    TreePath tp = tree.getSelectionPath();
    if(tp == null) return;
    DefaultMutableTreeNode tn = (DefaultMutableTreeNode)(tp.getLastPathComponent());
    if(tn == null) return;
    try
    {
      TreeObj obj = (TreeObj)tn.getUserObject();
      String name = obj.fullName;
      if(name == null)
      {
        Logg.loggToApplet("Select an object or attribute");
        return;
      }
      session.openCrrFrame(name);
    }
    catch(Exception e)
    {
      Logg.logg("Error in showCross() " + e.toString(),0);
    }
  }

  
  public void openPLC()
  {
    TreePath tp = tree.getSelectionPath();
    DefaultMutableTreeNode tn = (DefaultMutableTreeNode)(tp.getLastPathComponent());
    GetPLCWindowObjRet ret = getPLCWindowObj(tn);
    if(ret.oid == null)
    {
      Logg.loggToApplet("Unable to open Plc trace for this object");
      return;
    }
    session.openFlowFrame(ret.oid, ret.name);
  }

  public void openGraph()
  {
    TreePath tp = tree.getSelectionPath();
    if(tp == null) return;
    DefaultMutableTreeNode tn = (DefaultMutableTreeNode)(tp.getLastPathComponent());
    if(tn == null) return;
    try {
      TreeObj obj = (TreeObj)tn.getUserObject();
      String name = obj.fullName;
      if(name == null) {
        Logg.loggToApplet("Select an object");
        return;
      }
      String cmd = "open graph/class/inst=" + name;
      session.executeCommand(cmd);
    }
    catch(Exception e) {
      Logg.logg("Error in open graph" + e.toString(),0);
    }
  }

    public PwrtObjid getPLCWindowObjid(DefaultMutableTreeNode tn)
    {
      DefaultMutableTreeNode tc = null;
      PwrtObjid oid = null;
      XttObj obj;
      try
      {
         obj = (XttObj)tn.getUserObject();
      }
      catch(ClassCastException e)
      {
        return oid;
      }
      switch(obj.classId.classId)
      {
        case Pwrb.cClass_windowplc:
	  oid = obj.objId.objid;
	  break;
	case Pwrb.cClass_plc:
	  try
	  {
	    CdhrObjid gdhr = gdh.getChild(obj.objId.objid);
	    if(gdhr.oddSts())
	    {
	      oid = gdhr.objid;
	    }
	  }
	  catch(NoSuchElementException e)
	  {
	  }
	  break;
	default:
	  DefaultMutableTreeNode tParent = (DefaultMutableTreeNode)tn.getParent();
	  if(tParent != null) 
	    return getPLCWindowObjid(tParent);
	  break;
      }
      return oid;
    }
    
    public String getPLCWindowObjName(DefaultMutableTreeNode tn)
    {
      XttObj obj;
      String ret = null;
      try
      {
         obj = (XttObj)tn.getUserObject();
	 ret = obj.name;
      }
      catch(ClassCastException e)
      {
      }
      return ret;
    }

    public GetPLCWindowObjRet getPLCWindowObj(DefaultMutableTreeNode tn)
    {
      DefaultMutableTreeNode tc = null;
      GetPLCWindowObjRet ret = new GetPLCWindowObjRet();      
      XttObj obj;
      try
      {
         obj = (XttObj)tn.getUserObject();
      }
      catch(ClassCastException e)
      {
        return ret;
      }
      switch(obj.classId.classId)
      {
        case Pwrb.cClass_windowplc:
	case Pwrb.cClass_plc:
	  ret.oid = getPLCWindowObjid(tn);
	  break;
	default:
            ret.oid = getPLCWindowObjid(tn);
	    ret.name = getPLCWindowObjName(tn);
	  break;
      }
      return ret;
    }
    
    private class GetPLCWindowObjRet
    {
      String name = null;
      PwrtObjid oid = null;
    }
  

  public void changeValue()
  {
    if(this.engine.gdh.isAuthorized(Pwr.mPrv_RtWrite | Pwr.mPrv_System))
    {
      Logg.loggToApplet(" ");
      Logg.logg("JopXttApplet: changeValue()", 6);
      userValue.setText(null);
      this.tree.setRequestFocusEnabled(false);
      if (enterFieldEnable){
	  enterFieldEnable = false;
	  this.messagePanel.remove(userCommandLabel);
      }
      else this.messagePanel.remove(labelMessage);
      this.messagePanel.add(this.userValueLabel, BorderLayout.WEST);
      this.messagePanel.add(this.userValue, BorderLayout.CENTER);
      messagePanel.doLayout();
      messagePanel.repaint();

      this.userValue.requestFocus();
    }
    else
    {
      Logg.loggToApplet("Not authorized for this action");
    }
  }

  public void find()
  {
      Logg.loggToApplet(" ");
      Logg.logg("JopXttApplet: find()", 6);
      userValue.setText(null);
      this.tree.setRequestFocusEnabled(false);
      //Mats förändringar: Hantering av om enterFieldEnable =true
      if (enterFieldEnable){
	  enterFieldEnable = false;
	  this.messagePanel.remove(userCommandLabel);
      }
      else this.messagePanel.remove(labelMessage);
      this.messagePanel.add(this.userValueLabel, BorderLayout.WEST);
      this.messagePanel.add(this.userValue, BorderLayout.CENTER);
      messagePanel.doLayout();
      messagePanel.repaint();

      this.userValue.requestFocus();
      this.findFieldEnable = true;
  }
    //Mats förändringar: Ny metod enterComm för att hantera manuellt inskrivna kommandon.
 public void enterComm()
  {
      Logg.loggToApplet(" ");
      Logg.logg("JopXttApplet: enterComm()", 6);
      userValue.setText(null);
      this.tree.setRequestFocusEnabled(false);
      if (userValueLabel.isVisible()){
	  findFieldEnable = false;
	  this.messagePanel.remove(userValueLabel);
      }
      else this.messagePanel.remove(labelMessage);
      this.messagePanel.add(this.userCommandLabel, BorderLayout.WEST);
      this.messagePanel.add(this.userValue, BorderLayout.CENTER);
      messagePanel.doLayout();
      messagePanel.repaint();

      this.userValue.requestFocus();
      this.enterFieldEnable = true;
  }
    //Mats förändringar: ny metod som exekverar kommandot com.
    public void enterComm(String com){
	session.executeCommand(com);
    }


  /**
   *  Description of the Class
   *
   *@author     JN3920
   *@created    November 12, 2002
   */
  class MyTreeExpansionListener implements TreeExpansionListener
  {
    /**
     *  Description of the Method
     *
     *@param  e  Description of the Parameter
     */
    public void treeCollapsed(TreeExpansionEvent e)
    {
      TreePath tp = e.getPath();
      handleTreeCollapsed(tp);
    }


    /**
     *  Description of the Method
     *
     *@param  e  Description of the Parameter
     */
    public void treeExpanded(TreeExpansionEvent e)
    {
      //pga bugg som jag ej kan lösa för tillfället
      try
      {
        TreePath tp = e.getPath();
        if(tree.getSelectionPath() == null)
        {
          tree.setSelectionPath(tp);
        }
        DefaultMutableTreeNode tn = (DefaultMutableTreeNode)(tp.getLastPathComponent());
        DefaultMutableTreeNode tc = (DefaultMutableTreeNode)tn.getFirstChild();
        if((tn != null) &&
            (tc != null) && tc.getUserObject() instanceof XttObj)
        {
          XttObj obj = (XttObj)tc.getUserObject();
          //XttObj parentObj = (XttObj) tn.getUserObject();
          if(obj.name.compareTo("DummyXttObj") == 0)
          {
            Logg.logg("XttTree: innan collapsePath() pga DummyXttObj", 1);
            tree.collapsePath(tp);
            treeModel.reload(tn);
          }
        }
      }
      catch(NoSuchElementException exception)
      {
      }
    }
  }


  /**
   *  Description of the Class
   *
   *@author     JN3920
   *@created    November 12, 2002
   */
  class MyTreeWillExpandListener implements TreeWillExpandListener
  {

    /**
     *  Ser till att alla grenar under den kollapserande noden också
     *  kollapseras.
     *
     *@param  e  Description of the Parameter
     */
    public void treeWillCollapse(TreeExpansionEvent e)
    {
      TreePath tp = e.getPath();
      if(tp != null)
      {
        int row = tree.getRowForPath(tp);
        row++;
        TreePath descendant = tree.getPathForRow(row);
        while(tp.isDescendant(descendant))
        {
          tree.collapsePath(descendant);
          DefaultMutableTreeNode tn = (DefaultMutableTreeNode)(descendant.getLastPathComponent());
          Object obj = tn.getUserObject();
          if(obj instanceof XttObj)
          {
            ((XttObj)(obj)).removeAttrVector();
          }
          row++;
          descendant = tree.getPathForRow(row);
          //just in case...
          if(row > 50000)
          {
            break;
          }
        }
      }
    }


    /**
     *  Description of the Method
     *
     *@param  e  Description of the Parameter
     */
    public void treeWillExpand(TreeExpansionEvent e)
    {
      Logg.logg("XttTree.treeWillExpand", 7);
      //qqq bör läggas i en egen metod
      TreePath tp = e.getPath();
      if(tree.hasBeenExpanded(tp))
      {
        Logg.logg("XttTree: Har varit expanderad fel!!", 1);
        tree.collapsePath(tp);
        return;
      }
      Cursor defCursor = getCursor();
      setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

      DefaultMutableTreeNode tn = (DefaultMutableTreeNode)(tp.getLastPathComponent());
      DefaultMutableTreeNode tc = (DefaultMutableTreeNode)tn.getFirstChild();
      if((tn != null) && (tree.getSelectionPath() != null) &&
          (tc != null) && !tree.hasBeenExpanded(tp) && tc.getUserObject() instanceof XttObj &&
	 tn.getUserObject() instanceof XttObjAttr)
      {
        XttObj obj = (XttObj)tc.getUserObject();
        Logg.logg("XttTree: Skall expanderas addChildrenClass", 1);
        addObjectInfo(tp);
        Logg.logg("XttTree: Expandering klar", 1);
      }
      else if((tn != null) && (tree.getSelectionPath() != null) &&
          (tc != null) && !tree.hasBeenExpanded(tp) && tc.getUserObject() instanceof XttObj )
      {
        XttObj obj = (XttObj)tc.getUserObject();
        Logg.logg("XttTree: Skall expanderas1", 1);
        addChildren(tn, tc);
        Logg.logg("XttTree: Expandering klar", 1);
      }
      else if((tn != null) && (tree.getSelectionPath() != null)
           && tn.getUserObject() instanceof XttObjAttr)
      {
        String s = ((XttArrayAttr)(tc.getUserObject())).name;
        tn.remove(tc);
        GdhrRefObjectInfo ret;
        XttObjAttr obj = (XttObjAttr)tn.getUserObject();
        //Vector<String> ref_vec = new Vector<String>();
        Vector ref_vec = new Vector();
        Vector ret_vec;
        //Vector<XttArrayAttr> attr_vec = new Vector<XttArrayAttr>();
        Vector attr_vec = new Vector();
        //qqq borde läggas i egen tråd???
        for(int j = 0; j < obj.elements; j++)
        {
          XttArrayAttr arrayAttr = new XttArrayAttr(obj.name + "[" + j + "]", s + "#" + obj.elements + "[" + j + "]", obj.type,
              obj.elements);
          DefaultMutableTreeNode arrayChildNode = new DefaultMutableTreeNode(arrayAttr);
          arrayAttr.treeNode = arrayChildNode;
          XttArrayAttr.treeModel = XttObjAttr.treeModel;
          obj.treeNode.add(arrayChildNode);
          Logg.logg("XttObj: arrayAttr.fullName= " + arrayAttr.fullName, 8);
          String str = arrayAttr.fullName;
          attr_vec.add(arrayAttr);
          ref_vec.add(str);

        }
        Logg.logg("refObjectInfo_Vector()", 6);
        ret_vec = gdh.refObjectInfo_Vector(ref_vec);
        if(ret_vec == null)
        {
          Logg.logg("XttTree : refObjectInfo_Vector returnerar null", 1);
          setCursor(defCursor);
	  return;
        }
        for(int i = 0; i < attr_vec.size() && i < ret_vec.size(); i++)
        {
          ret = (GdhrRefObjectInfo)ret_vec.get(i);
          if(ret.evenSts())
          {
            Logg.logg("XttObj:  ObjectInfoError ", 4);
          }
          ((XttArrayAttr)(attr_vec.get(i))).refObj = ret;
        }
      }
      setCursor(defCursor);
    }
  }

  /**
   *  Description of the Class
   *
   *@author     JN3920
   *@created    November 12, 2002
   */
  private class MyRenderer extends DefaultTreeCellRenderer
  {
    /**  Description of the Field */
    ImageIcon ClosedLeafIcon;

    /**  Description of the Field */
    ImageIcon ClosedNodeIcon;
    /**  Description of the Field */
    ImageIcon ObjAttrArrayElementIcon;

    /**  Description of the Field */
    ImageIcon ObjAttrArrayIcon;
    /**  Description of the Field */
    ImageIcon ObjAttrIcon;
    /**  Description of the Field */
    ImageIcon ObjAttrOpenNodeIcon;
    /**  Description of the Field */
    ImageIcon ObjAttrPointerIcon;
    /**  Description of the Field */
    ImageIcon OpenLeafIcon;
    /**  Description of the Field */
    ImageIcon OpenNodeIcon;


    /**  Constructor for the MyRenderer object */
    public MyRenderer()
    {
        ClosedLeafIcon = new ImageIcon(XttClosedLeafIcon);
        OpenLeafIcon = new ImageIcon(XttOpenLeafIcon);

        ClosedNodeIcon = new ImageIcon(XttClosedNodeIcon);
        OpenNodeIcon = new ImageIcon(XttOpenNodeIcon);
        ObjAttrOpenNodeIcon = new ImageIcon(XttObjAttrOpenNodeIcon);

        ObjAttrIcon = new ImageIcon(XttObjAttrIcon);
        ObjAttrPointerIcon = new ImageIcon(XttObjAttrPointerIcon);

        ObjAttrArrayIcon = new ImageIcon(XttObjAttrArrayIcon);
        ObjAttrArrayElementIcon = new ImageIcon(XttObjAttrArrayElementIcon);
    }


    /**
     *  Gets the treeCellRendererComponent attribute of the MyRenderer object
     *
     *@param  tree      Description of the Parameter
     *@param  value     Description of the Parameter
     *@param  sel       Description of the Parameter
     *@param  expanded  Description of the Parameter
     *@param  leaf      Description of the Parameter
     *@param  row       Description of the Parameter
     *@param  hasFocus  Description of the Parameter
     *@return           The treeCellRendererComponent value
     */
    public Component getTreeCellRendererComponent(
        JTree tree,
        Object value,
        boolean sel,
        boolean expanded,
        boolean leaf,
        int row,
        boolean hasFocus)
    {

      super.getTreeCellRendererComponent(
          tree, value, sel,
          expanded, leaf, row,
          hasFocus);

      DefaultMutableTreeNode node = (DefaultMutableTreeNode)value;
      Object userObject = node.getUserObject();

      if(userObject instanceof XttObj)
      {
        if(leaf)
        {
          setIcon(ClosedLeafIcon);
        }
        else if(((XttObj)(userObject)).hasBeenReferenced &&
            !((XttObj)(userObject)).hasChildren)
        {
          setIcon(OpenLeafIcon);
        }
        else if(((XttObj)(userObject)).hasBeenReferenced &&
            ((XttObj)(userObject)).hasChildren)
        {
          setIcon(ObjAttrOpenNodeIcon);
        }
        else if(expanded)
        {
          setIcon(OpenNodeIcon);
        }
        else
        {
          setIcon(ClosedNodeIcon);
        }
      }
      else if(userObject instanceof XttObjAttr)
      {
        int flags = ((XttObjAttr)(userObject)).flags;
        int type = ((XttObjAttr)(userObject)).type;
        if((flags & Pwr.mAdef_class) > 0)
        {
          setIcon(ObjAttrIcon);
        }

        else if((flags & Pwr.mAdef_array) > 0)
        {
          setIcon(ObjAttrArrayIcon);
        }
        //qqq ändra flgga så att actual value visas rätt
        else if(((flags & (Pwr.mAdef_rtdbref | Pwr.mAdef_devbodyref)) > 0) || type == Pwr.eType_Objid)
        {
          setIcon(ObjAttrPointerIcon);
        }
        else
        {
          setIcon(ObjAttrIcon);
        }
      }
      else if(userObject instanceof XttArrayAttr)
      {
        setIcon(ObjAttrArrayElementIcon);
      }
      //just in case....
      else if(!leaf)
      {
        setIcon(ClosedNodeIcon);
      }
      else
      {
        setIcon(ClosedLeafIcon);
      }
      setBackgroundSelectionColor(Color.black);
      setTextSelectionColor(Color.white);
      return this;
    }
  }

  public Object getRoot() {
    return root;
  }
}


















