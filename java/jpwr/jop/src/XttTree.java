/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jop;
import java.awt.*;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.awt.event.*;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Enumeration;
import java.util.NoSuchElementException;
import java.util.Vector;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.plaf.basic.BasicTreeUI;
import javax.swing.tree.*;
import java.beans.SimpleBeanInfo;
import jpwr.rt.*;

/**
 *  Xtt tree object.
 *  @author     Jonas Nylund
 */

@SuppressWarnings("serial")

public class XttTree extends JPanel
{
  boolean findFieldEnable = false;
    /* Mats modification */
  boolean enterFieldEnable = false; 
  JPanel userPanel = new JPanel();
  BorderLayout borderLayout1 = new BorderLayout();
  JPanel messagePanel = new JPanel();
  JTextField textUser = new JTextField(10);
  JTextField userValue = new JTextField(25);
  JLabel userValueLabel = new JLabel("Value input: ");    
  JLabel userCommandLabel = new JLabel("Command:");
  JLabel labelMessage = new JLabel("");
  Dimension size;
  JTree tree;
  Object root;
  private JopSession session;
  private JopEngine engine;
  private boolean firstTime = true;
  private Gdh gdh;
  private DefaultMutableTreeNode rootNode;
  private boolean sim = false;
  private DefaultMutableTreeNode tNodeRoot;
  private DefaultTreeModel treeModel;
  private URL url;
  
  InputMap inputMap = new InputMap();
  ActionMap actionMap = new ActionMap();
  JMenuBar menubar = new JMenuBar();
  
  Image XttOpenCloseIcon;
  Image XttOpenIcon;
  Image XttCloseIcon;
  Image XttClosedLeafIcon;
  Image XttOpenLeafIcon;
  Image XttClosedNodeIcon;
  Image XttOpenNodeIcon;
  Image XttObjAttrOpenNodeIcon;
  Image XttObjAttrIcon;
  Image XttObjAttrPointerIcon;
  Image XttObjAttrArrayIcon;
  Image XttObjAttrArrayElementIcon;
  
  String functions_EN = "Functions";
  String functions_SW = "Funktioner";
  String functions;
    
  String language_EN = "Language";
  String language_SW = "Sprak";
  String language;
    
  String swedish = "Svenska";
  String english = "English";

  String openObject_EN = "open object";
  String openObject_SW = "Oppna objekt";
  String openObject;
    
  String changeValue_EN = "change value";
  String changeValue_SW = "Andra varde";
  String changeValue;
    
  String debug_EN = "debug";
  String debug_SW = "avlusa";
  String debug;
  
  String working_EN = "Working.........";
  String working_SW = "Arbetar.........";
  String working;

  String openPlc_EN = "open PLC";
  String openPlc_SW = "Oppna PLC";
  String openPlc;

  String showCross_EN = "show cross";
  String showCross_SW = "visa korsref";
  String showCross;

  String find_EN = "find...";
  String find_SW = "sok...";
  String find;
    // Mats modifications: stings enterComm
  String enterComm_EN = "enter command";
  String enterComm_SW = "kommandorad";
  String enterComm;

  
  static final int SWEDISH = 0;
  static final int ENGLISH = 1;
  int currentLanguage = SWEDISH;
  

  
  public XttTree(JopSession session, URL url, Object root)
  {
    Logg.text_lbl = this.labelMessage;
    Logg.logg("ver 1.9.7", 0);
    
    this.session = session;
    this.root = root;
    this.url = url;
    this.engine = session.getEngine();
    session.setNavigator( (Object) this);
    this.gdh = engine.gdh;

    //construct the messagepanel and add it to the panel
    setLayout(borderLayout1);
    Dimension d = messagePanel.getSize();
    d.height += 20;
    messagePanel.setPreferredSize(d);
    add(messagePanel, BorderLayout.SOUTH);
    userValue.setPreferredSize(d);
    messagePanel.setLayout(new BorderLayout());
    messagePanel.add(labelMessage, BorderLayout.CENTER);
    setOpaque(true);
    userPanel.setLayout(new GridBagLayout());

    //get all icons that is to be used in the tree
    XttOpenCloseIcon = JopSpider.getImage(session, "jpwr/jop/xttopencloseicon.gif");
    XttOpenIcon = JopSpider.getImage(session, "jpwr/jop/xttopenicon.gif");
    XttCloseIcon = JopSpider.getImage(session, "jpwr/jop/xttcloseicon.gif");
    XttClosedLeafIcon = JopSpider.getImage(session, "jpwr/jop/xttclosedleaficon.png");
    XttOpenLeafIcon = JopSpider.getImage(session, "jpwr/jop/xttopenleaficon.png");
    XttClosedNodeIcon = JopSpider.getImage(session, "jpwr/jop/xttclosednodeicon.png");
    XttOpenNodeIcon = JopSpider.getImage(session, "jpwr/jop/xttopennodeicon.png");
    XttObjAttrOpenNodeIcon = JopSpider.getImage(session, "jpwr/jop/xttobjattropennodeicon.png");
    XttObjAttrIcon = JopSpider.getImage(session, "jpwr/jop/xttobjattricon.png");
    XttObjAttrPointerIcon = JopSpider.getImage(session, "jpwr/jop/xttobjattrpointericon.png");
    XttObjAttrArrayIcon = JopSpider.getImage(session, "jpwr/jop/xttobjattrarrayicon.png");
    XttObjAttrArrayElementIcon = JopSpider.getImage(session, "jpwr/jop/xttobjattrarrayelementicon.png");

    //create the JTree component
    rootNode = new DefaultMutableTreeNode("DATABAS");
    treeModel = new DefaultTreeModel(rootNode);
    tree = new JTree(treeModel);
    tree.setEditable(false);
    this.tree.setFont(new Font("monospaced", Font.PLAIN, 14));
    this.tree.setCellRenderer(new MyRenderer());
    
    //ugly way to letting all nodes to be able to update the tree when their
    //values change...
    XttObjAttr.treeModel = treeModel;
    //ugly way to letting all objects that wants subscription to get a handle to gdh
    DynamicObj.init(engine);
    
    //get the icons that is for the + and - signs to the left of every node
    BasicTreeUI tui = (BasicTreeUI)tree.getUI();
    ImageIcon OpenCloseIcon = new ImageIcon(XttOpenCloseIcon);
    ImageIcon OpenIcon = new ImageIcon(XttOpenIcon);
    ImageIcon CloseIcon = new ImageIcon(XttCloseIcon);
    // tui.setCollapsedIcon(OpenIcon);
    // tui.setExpandedIcon(CloseIcon);
    tui.setCollapsedIcon(null);
    tui.setExpandedIcon(null);
    tui.setRightChildIndent(5);
    tui.setLeftChildIndent(5);

    tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);

    final JopScrollPane scrollPane = new JopScrollPane();
    scrollPane.setViewportView(tree);
    scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
    add(scrollPane, BorderLayout.CENTER);

    tree.addTreeWillExpandListener(new MyTreeWillExpandListener());
    tree.addTreeExpansionListener(new MyTreeExpansionListener());

    /*---Build the tree--------------------------------------------------------------*/
    CdhrObjid r = gdh.getRootList();
    if(r.evenSts())
    {
      Logg.logg("XttTree: Can't find the root, stopping the initialization", 1);
      return;
    }
    tNodeRoot = new DefaultMutableTreeNode(createXttObj(r));
    rootNode.add(tNodeRoot);
    this.addFirstChild(tNodeRoot);
    int rootRow = 0;
    Vector v = gdh.getAllXttSiblings(r.objid);
    if(v == null)
    {
      Logg.loggToApplet(JopLang.transl("Communication error with GdhServer"));
    }
    else
    {
      for(int i = 0; i < v.size(); i++)
      {
        //String loggStr = new String("XttTree: Borjar bygga root " + rootRow++);
        //Logg.logg(loggStr, 0);
        
	GdhrGetXttObj gdhr = (GdhrGetXttObj)v.get(i);
        XttObj xttObj = new XttObj(gdhr, this.gdh, this.engine);
        tNodeRoot = new DefaultMutableTreeNode(xttObj);
        xttObj.treeNode = tNodeRoot;
        xttObj.init(false);
        if(xttObj.refObj != null)
	{
	  AttrObj.treeModel = this.treeModel;
        }
        rootNode.add(tNodeRoot);
        if(gdhr.hasChildren)
        {
          DefaultMutableTreeNode childNode = new DefaultMutableTreeNode(new XttObj("DummyXttObj"));
          tNodeRoot.add(childNode);
        }
      }
    }
    /*---End build tree--------------------------------------------------------*/
    
    //make the root invisible(it's just there becasue the JTree component must have exactly 1 root)
    //then expand row 0 so we can se the rootlevel in the system
    tree.expandRow(0);
    
    tree.setScrollsOnExpand(true);
    tree.setRootVisible(false);
    tree.setShowsRootHandles(true);
    tree.setSelectionRow(0);

    
    //add an actionlistener that responds to userinput in the messagepanel
    this.userValue.addActionListener(
      new ActionListener()
      {
        public void actionPerformed(ActionEvent evt)
        {

	  if(enterFieldEnable)
	  {
            Logg.logg("XttTree: innan enterCommand:(" + userValue.getText() + ");", 6);
            enterComm(userValue.getText());
	    messagePanel.remove(userValue);
	    messagePanel.remove(userCommandLabel);
	    enterFieldEnable=false;
          }
	    else if(findFieldEnable)
	  {
            Logg.logg("XttTree: innan find(" + userValue.getText() + ");", 6);
            find(userValue.getText());
	    messagePanel.remove(userValue);
	    messagePanel.remove(userValueLabel);
	    findFieldEnable=false;
          }
	  else
	  {
            Logg.logg("XttTree: innan changeValue(" + userValue.getText() + ");", 6);
            changeValue(userValue.getText());
	    messagePanel.remove(userValue);
	    messagePanel.remove(userValueLabel);
	  }         
	  tree.setRequestFocusEnabled(true);

          messagePanel.add(labelMessage, BorderLayout.CENTER);
          messagePanel.doLayout();
          repaint();

          tree.requestFocus();
        }
      });
    Logg.logg("XttTree ready", 0);
  }
  
  /**
   * Adds all children to a node in the tree. Checks that if the children has
   * children, and if so addes the first child of the child.
   *
   *  @param  tN  The node which children should be added.
   *  @param  tC  The first child of the node, which allways has to exist.
   */
  public void addChildren(DefaultMutableTreeNode tN, DefaultMutableTreeNode tC)
  {
    tN.remove(tC);
    XttObj obj = (XttObj)tN.getUserObject();
    Vector v = this.gdh.getAllXttChildren(obj.objId.objid);
    if(!(v instanceof Vector))
    {
      Logg.logg("XttTree: getAllXttChildren returns object that is not a Vector", 1);
      return;
    }
    // Used if the user has specified debug
    Vector<String> ref_vec = new Vector<String>();
    //Vector ref_vec = new Vector();
    // Used if the user has specified debug
    Vector<XttRefObj> o_vec = new Vector<XttRefObj>();
    //Vector o_vec = new Vector();

    //loopa igenom resultat-vektorn
    for(int i = 0; i < v.size(); i++)
    {
      GdhrGetXttObj gdhr = (GdhrGetXttObj)v.get(i);
      if(gdhr.evenSts())
      {
        Logg.logg("XttTree: getAllXttChildren har returnerat ett objekt med felstatus", 1);
        break;
      }
      XttObj o = new XttObj(gdhr, this.gdh, this.engine);
      DefaultMutableTreeNode childNode = new DefaultMutableTreeNode(o);
      o.treeNode = childNode;
      o.init(obj.debug);
      if(obj.debug && o.refObj != null)
      {
        ref_vec.add(o.refObj.getXttObjAttr().fullName);
        o_vec.add(o.refObj);
      }
      tN.add(childNode);
      if(gdhr.hasChildren)
      {
        DefaultMutableTreeNode c = new DefaultMutableTreeNode(new XttObj("DummyXttObj"));
        childNode.add(c);
      }
    }
    if(obj.debug)
    {
      Vector ret_vec = engine.gdh.refObjectInfo_Vector(ref_vec);
      if(ret_vec == null)
      {
        Logg.logg("refObjectInfo_Vector returnerar null vid debug", 1);
        return;
      }
      for(int i = 0; i < o_vec.size() && i < ret_vec.size(); i++)
      {
        o_vec.get(i).objAttr.refObj = (GdhrRefObjectInfo)ret_vec.get(i);
      }
      if(!engine.isReady())
      {
        engine.setFrameReady();
        //firstTime = false;
      }
    }
  }

  /**
   *  Checks if a node has children, if so addes the first child of the node.
   *
   *  @param  tN  The node which children should be added.
   */
  public void addFirstChild(DefaultMutableTreeNode tN)
  {
    Object obj = tN.getUserObject();
    if(obj instanceof XttObj)
    {
      //we must do this for the first node in the tree
      if(firstTime)
      {
        firstTime = false;
        CdhrObjid child = this.gdh.getChild(((XttObj)obj).objId.objid);
        if(child.oddSts())
        {
          //we must know if the node has children
          ((XttObj)obj).hasChildren = true;
          DefaultMutableTreeNode childNode = new DefaultMutableTreeNode(new XttObj("DummyXttObj"));
          tN.add(childNode);
        }
      }
      else if(((XttObj)obj).hasChildren)
      {
        //we must know if the node has children
        //((XttObj)obj).hasChildren = true;
        DefaultMutableTreeNode childNode = new DefaultMutableTreeNode(new XttObj("DummyXttObj"));
        tN.add(childNode);
      }
    }
    else
    {
      Logg.logg("XttTree: addFirstChild anropades med en nod som ej har ett XttObj utan ett "
           + obj.getClass().getName(), 3);
    }
  }

  /**
   *  Deletes all children to a node, and creates new ones with new content.
   *
   *  @param  treePath  The feature to be added to the ObjectInfo attribute
   */
  public void addObjectInfo(TreePath treePath)
  {
    TreePath tp;
    if(treePath == null)
    {
      tp = this.tree.getSelectionPath();
      if(tp == null)
      {
        return;
      }
    }
    else
    {
      tp = treePath;
    }

    DefaultMutableTreeNode tN = (DefaultMutableTreeNode)(tp.getLastPathComponent());
    if(tN.getUserObject() instanceof XttObj)
    {
      XttObj obj = (XttObj)tN.getUserObject();
      if(obj.hasBeenReferenced)
      {
        return;
      }
      if(obj.debug && this.tree.isExpanded(tp))
      {
        this.handleTreeCollapsed(tp);
      }
      tN.removeAllChildren();
      Logg.logg("XttTree: Barnen borttagna", 6);

      Logg.logg("XttTree: Less getObjectAttributes", 6);
      PwrtObjid pwrobjid = new PwrtObjid(0, 0);

      Vector v = gdh.getAllClassAttributes(obj.fullName);
      Logg.logg("XttTree: Efter getAllClassAttributes", 6);
      if(v == null)
      {
        Logg.logg("XttTree: Vector == null efter getAllClassAttributes", 4);
        return;
      }
      Vector<XttObjAttr> xttObjAttrVec = new Vector<XttObjAttr>();
      for(int i = 0; i < v.size(); i++)
      {
	
        CdhrObjAttr cdhrobjattr = (CdhrObjAttr)v.get(i);
	/*
	if(((cdhrobjattr.flags & Pwr.mAdef_class) > 0) &&
	   ((cdhrobjattr.flags & Pwr.mAdef_array) <= 0))
	*/
	if((cdhrobjattr.flags & Pwr.mAdef_class) > 0)
	{
	  Logg.logg("XttTree: Found class, what to do now?? " + obj.fullName + " " + cdhrobjattr.name , 1);
	  CdhrObjid cdhrObjid = gdh.classIdToObjid(cdhrobjattr.type);
       
       	  CdhrAttrRef aref = gdh.nameToAttrRef(obj.fullName + "." + cdhrobjattr.name);

	  String className = gdh.objidToName(cdhrObjid.objid, Cdh.mName_object).str;

          XttObj classObj = new XttObj(this.engine.gdh, 
                                     this.engine, 
                                     obj.fullName + "." + cdhrobjattr.name, 
                                     cdhrobjattr.name,
				     className,
				       cdhrObjid,//  co, new CdhrObjid(aref.aref.getObjid(),aref.getSts()),
				      new CdhrClassId(cdhrobjattr.type, 1)); 
          DefaultMutableTreeNode classObjTreeNode = new DefaultMutableTreeNode(classObj);
          classObj.treeNode = classObjTreeNode;
          tN.add(classObjTreeNode);

	  
	  if((cdhrobjattr.flags & Pwr.mAdef_array) > 0)
	  {
	    classObj.hasChildren = true;
            DefaultMutableTreeNode c = new DefaultMutableTreeNode(new XttObj("DummyXttObj"));
            classObjTreeNode.add(c);
          }
	  
	  
	}
	else {
          XttObjAttr xttObjAttr = new XttObjAttr(cdhrobjattr);
	  xttObjAttrVec.add(xttObjAttr);
	  DefaultMutableTreeNode objAttrTreeNode = new DefaultMutableTreeNode(xttObjAttr);
	  xttObjAttr.treeNode = objAttrTreeNode;
	  tN.add(objAttrTreeNode);
	}
      }
      obj.addAttrVector(xttObjAttrVec);
      Logg.logg("XttTree: Efter getObjectAttributes", 6);
      treeModel.reload(tN);
      this.tree.expandPath(tp);
    }
  }

  /**
   *  Changes the value of selected object to valueString. If it's not possible to 
   *  change the value Logg.loggToApplet() is called with an error message.
   *
   *@param  valueString  Desired string value.
   */
  public void changeValue(String valueString)
  {
    Logg.logg("XttTree: User wants to change value", 6);

    TreePath tp = this.tree.getSelectionPath();
    // No object selected
    if(tp == null)
    {
      Logg.loggToApplet(JopLang.transl("Select an object"));
      return;
    }
    DefaultMutableTreeNode tn = (DefaultMutableTreeNode)(tp.getLastPathComponent());
    // No object selected
    if(tn == null)
    {
      Logg.loggToApplet(JopLang.transl("Select an object"));
      return;
    }
    Object userObject = tn.getUserObject();
    String name = null;
    int type = 0;

    if(userObject instanceof XttObjAttr)
    {
      XttObjAttr obj = (XttObjAttr)userObject;
      name = obj.fullName;
      type = obj.type;
    }
    else if(userObject instanceof XttArrayAttr)
    {
      XttArrayAttr obj = (XttArrayAttr)userObject;
      name = obj.fullName;
      type = obj.type;
    }
    // Nothing to change on selected object
    if(name == null)
    {
      Logg.loggToApplet(JopLang.transl("Unable to change value on selected object"));
      return;
    }
    Logg.logg("XttTree: The user wants to change value of " + name, 6);
    PwrtStatus sts = new PwrtStatus(1);
    switch (type)
    {
      case Pwr.eType_Float32:
      case Pwr.eType_Float64:
        Logg.logg("XttTree.changeValue: innan setObjectInfo(string, float);", 6);
        try
        {
          Float f = new Float(valueString);
          sts = gdh.setObjectInfo(name, f.floatValue());
        }
        catch(NumberFormatException e)
        {
          Logg.loggToApplet(JopLang.transl("Syntax error"));
          return;
        }

        break;
      case Pwr.eType_Int8:
      case Pwr.eType_Int16:
      case Pwr.eType_Int32:
      case Pwr.eType_Int64:
      case Pwr.eType_UInt8:
      case Pwr.eType_UInt16:
      case Pwr.eType_UInt32:
      case Pwr.eType_UInt64:
      case Pwr.eType_Status:
      case Pwr.eType_NetStatus:
      case Pwr.eType_Enum:
      case Pwr.eType_Mask:
        Logg.logg("XttTree.changeValue: innan setObjectInfo(string, int);", 6);
        try
        {
          Integer i = new Integer(valueString);
          sts = gdh.setObjectInfo(name, i.intValue());
        }
        catch(NumberFormatException e)
        {
	  Logg.loggToApplet(JopLang.transl("Syntax error"));
          return;
        }

        break;
      case Pwr.eType_Boolean:
        Logg.logg("XttTree.changeValue: innan setObjectInfo(string, boolean);", 6);
        try
        {
          Integer i = new Integer(valueString);
          if(i.intValue() == 1)
          {
            sts = gdh.setObjectInfo(name, true);
            //Logg.logg("XttTree.changeValue(" + valueString + ");" + "gav true", 6);
          }
          else if(i.intValue() == 0)
          {
            sts = gdh.setObjectInfo(name, false);
            //Logg.logg("XttTree.changeValue(" + valueString + ");" + "gav false", 6);
          }
          else
          {
	    Logg.loggToApplet(JopLang.transl("Syntax error"));
            return;
          }
        }
        catch(NumberFormatException e)
        {
	  Logg.loggToApplet(JopLang.transl("Syntax error"));
          return;
        }
        break;
      //the rest is treated like strings...
//        case Pwr.eType_String:
//          obj.setValue(en.gdh.getObjectRefInfoString(obj.refObj.id, obj.type));
//          break;
      default:
        Logg.logg("XttTree.changeValue: innan setObjectInfo(string, string);", 6);
        // return status should be checked...
        sts = gdh.setObjectInfo(name, valueString);
        Logg.logg("efter setObjectInfo(string, string)", 4);
        break;
    }
    if(sts.evenSts())
    {
      CdhrString sret = gdh.getMsg( sts.getSts());
      Logg.loggToApplet(sret.str);
    }
  }

  /**
   *  Called when a node is closed. Checks if the node is expanded and in that case
   *  closes the node. If the node isn't expanded the parent node is closed.
   */
  public void collapseNode()
  {
    TreePath tpc = tree.getSelectionPath();
    if(tpc == null)
    {
      return;
    }
    TreePath tp = tpc.getParentPath();

    // If this is a node with visible children
    if(!treeModel.isLeaf(tpc.getLastPathComponent()) && tree.isExpanded(tpc))
    {
      Logg.logg("XttTree: Parenet collapsing " + tpc.toString(), 6);
      tree.collapsePath(tpc);
      tree.setSelectionPath(tpc);
      tree.scrollPathToVisible(tpc);
    }
    // We are not on root leve
    else if(tp.getPathCount() > 1)
    {
      tree.collapsePath(tp);
      tree.setSelectionPath(tp);
      tree.scrollPathToVisible(tp);
    }
  }

  /**
   *  Creating an XttObj with some Gdh calls.
   *
   *@param  c  CdhrObjid for the object that will be created.
   *@return    The new XttObj
   */
  public XttObj createXttObj(CdhrObjid c)
  {
    CdhrClassId clId = this.gdh.getObjectClass(c.objid);
    if(clId.evenSts())
    {
      Logg.logg("XttTree: Gdh returnerar fel vid getObjectClass, objekt: " + c.toString(), 3);
    }
    CdhrObjid classObj = this.gdh.classIdToObjid(clId.classId);
    if(classObj.evenSts())
    {
      Logg.logg("XttTree: Gdh returnerar fel vid classIdToObjId, objekt: " + c.toString(), 3);
    }
    String className = this.gdh.objidToName(classObj.objid, Cdh.mName_object).str;
    return new XttObj(this.gdh, this.engine, this.gdh.objidToName(c.objid, Cdh.mName_pathStrict).str,
        this.gdh.objidToName(c.objid, Cdh.mName_object).str, className, c, clId);
  }

  /**
   *  Is called when the user wants to debug an hierarchy. Sets the debug flag in
   *  the XttObj object that is userObject in treePath.
   *
   *@param  treePath  Hierarchy to debug
   */
  public void debugNode(TreePath treePath)
  {
    TreePath tp;
    if(treePath == null)
    {
      tp = this.tree.getSelectionPath();
      if(tp == null)
      {
        return;
      }
    }
    else
    {
      tp = treePath;
    }

    DefaultMutableTreeNode tN = (DefaultMutableTreeNode)(tp.getLastPathComponent());
    if(tN.getUserObject() instanceof XttObj)
    {
      XttObj obj = (XttObj)tN.getUserObject();
      obj.debug = true;
      this.tree.expandPath(tp);
    }
  }

//----------------code for searching the tree------------------------------------------------------- x 
  public void find(PwrtObjid objid)
  {
    String str = this.gdh.objidToName(objid, Cdh.mName_pathStrict).str;
    if(str != null)
      this.find(str);
    TreePath selectedPath = this.tree.getSelectionPath();
    if(selectedPath != null)
      this.tree.scrollPathToVisible(selectedPath);
  }
  
  public void find(String userStr)
  {
    this.findPathAndSetExpanded(userStr);
  }
            
  public void findPathAndSetExpanded(String objectName)
  {
    //save selected path so that we can set it selected if we don't find
    //what we are looking for
    TreePath selectedPath = this.tree.getSelectionPath();
    
    Vector<String> pathVec = createPathVec(objectName);
    //Vector pathVec = createPathVec(objectName);
    int ret = 1;
    DefaultMutableTreeNode tn = this.rootNode;
    TreePath tp;
    for(int i = 0;i < pathVec.size();i++)
    {
      tp = expandPath(tn,pathVec.get(i));
      if(tp == null)
        break;
      tn = (DefaultMutableTreeNode)tp.getLastPathComponent();
    }
    if(tn == null)
    {
      Logg.loggToApplet("Kunde ej hitta:" + objectName);
    }      
  }

  public Vector<String> createPathVec(String name)
  //public Vector createPathVec(String name)
  {
    Vector<String> pathVec = new Vector<String>();
    //Vector pathVec = new Vector();
    int strIndex;
    int i = 0;
    strIndex = name.indexOf('-');
    if(strIndex < 0)
    {
      strIndex = name.indexOf('.');
    }
    if(strIndex < 0)
    {
      pathVec.add(name);
      return pathVec;
    }
    while(strIndex >= 0)
    {
      pathVec.add(name.substring(0, strIndex));
      i = name.indexOf('-', strIndex+1);
      if(i < 0)
      {
        i = name.indexOf('.', strIndex+1);
      }
      if(i < 0)
      {
        pathVec.add(name);
      }
      strIndex = i;
    }
    return pathVec;
  }

  public TreePath expandPath(DefaultMutableTreeNode treeNode, String pathName)
  {
    int nrOfChildren = treeNode.getChildCount();
    DefaultMutableTreeNode tn;
    TreeObj obj;
    String str;
    for(int i = 0;i < nrOfChildren;i++)
    {
      tn = (DefaultMutableTreeNode)treeNode.getChildAt(i);
      try
      {
        obj = (TreeObj)tn.getUserObject();
      }
      catch(Exception e)
      {return null;}
      //cut the name before #(when the searched object is
      //an attribute ex rt-rtt-Dv1.ActualValue##Boolean)
      int ind = obj.fullName.indexOf('#');
      if(ind > 0)
      {
        str = obj.fullName.substring(0,ind);
      }
      else
        str = obj.fullName;
      if(str.compareToIgnoreCase(pathName) == 0)
      {
        
	TreePath tp = new TreePath(tn.getPath());
//	if(tn.isLeaf())
//	{
//	  addObjectInfo(tp);
//	}
//	else
	  this.tree.expandPath(tp);
	this.tree.setSelectionPath(tp);
	return tp;
      }
    }
    return null;
  }
//----------------end code for searching the tree-------------------------------------------------------


  /**
   *  Description of the Method
   *
   *@param  tp  Description of the Parameter
   */
  public void handleTreeCollapsed(TreePath tp)
  {

    DefaultMutableTreeNode tn = (DefaultMutableTreeNode)(tp.getLastPathComponent());
    DefaultMutableTreeNode tc;
    try
    {
      tc = (DefaultMutableTreeNode)tn.getFirstChild();
    }
    catch(NoSuchElementException e)
    {
      tc = new DefaultMutableTreeNode("Dummy");
    }
    if((tn != null) &&
        (tree.getSelectionPath() != null))
    {

      Logg.logg("XttTree: Har kollapsat", 6);
      if(tn.getUserObject() instanceof XttObj && !(tc.getUserObject() instanceof XttObj))
      {
        Logg.logg("XttTree: Tar bort attrVector", 6);
        ((XttObj)tn.getUserObject()).removeAttrVector();
        ((XttObj)tn.getUserObject()).debug = false;
        tn.removeAllChildren();
        Logg.logg("XttTree: Barnen borttagna", 6);
        addFirstChild(tn);
        treeModel.reload(tn);
      }

      else if(tn.getUserObject() instanceof XttObj && (tc.getUserObject() instanceof XttObj))
      {
        Logg.logg("XttTree: XttObj-barnen borttagna", 6);
        XttObj obj = ((XttObj)tn.getUserObject());
        if(obj.debug)
        {
	  Vector<PwrtRefId> unref_vec = new Vector<PwrtRefId>();
          //Vector unref_vec = new Vector();
          obj.debug = false;
          Enumeration enm = tn.children();
          while(enm.hasMoreElements())
          {
            DefaultMutableTreeNode child = (DefaultMutableTreeNode)enm.nextElement();
            XttObj childObj = (XttObj)child.getUserObject();
            if(childObj.refObj != null)
            {
              unref_vec.add(childObj.refObj.getPwrtRefId());
              engine.remove(childObj.refObj);
	    }
            
          }
          engine.gdh.unrefObjectInfo_Vector(unref_vec);
        }
        tn.removeAllChildren();
        addFirstChild(tn);
        treeModel.reload(tn);
      }
    }
  }

  AbstractAction ADDOBJECTINFO = new AbstractAction("ADDOBJECTINFO")
                                 {
                                   public void actionPerformed(ActionEvent evt)
                                   {
                                     Logg.logg("XttTree: innan addObjectInfo();", 4);
                                     addObjectInfo((TreePath)null);
                                   }
                                 };

  AbstractAction COLLAPSENODE = new AbstractAction("COLLAPSENODE")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
                                    Logg.logg("XttTree: innan collapseNode();", 4);
                                    collapseNode();
                                  }
                                };

  AbstractAction CHANGEVALUE =  new AbstractAction("CHANGEVALUE")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
                                    Logg.logg("XttTree: innan changeValue();", 4);
                                    changeValue();
                                  }
                                };
  AbstractAction OPENPLC =      new AbstractAction("OPENPLC")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
                                    Logg.logg("XttTree: innan openPLC();", 4);
                                    openPLC();
                                  }
                                };

  AbstractAction OPENGRAPH =      new AbstractAction("OPENGRAPH")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
                                    Logg.logg("XttTree: innan openGraph();", 4);
                                    openGraph();
                                  }
                                };

  AbstractAction SHOWCROSS =    new AbstractAction("SHOWCROSS")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
                                    Logg.logg("XttTree: innan showCross();", 4);
                                    showCross();
                                  }
                                };

  AbstractAction DEBUG =        new AbstractAction("DEBUG")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
                                    Logg.logg("XttTree: innan debug();", 0);
                                    debugNode((TreePath)null);
                                  }
                                };

  AbstractAction INCLOG =       new AbstractAction("INCLOG")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
                                    Logg.loggPrio++;
                                    Logg.logg("LoggPrio changed to: " + Logg.loggPrio, 0);
                                  }
                                };
  AbstractAction DECLOG =       new AbstractAction("DECLOG")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
				    if(Logg.loggPrio > 0)
                                      Logg.loggPrio--;
                                    Logg.logg("LoggPrio changed to: " + Logg.loggPrio, 0);
                                  }
                                };
  AbstractAction FIND =         new AbstractAction("FIND")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
				    find();
                                  }
                                };

  AbstractAction COMM =         new AbstractAction("COMM")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
				    enterComm();
                                  }
                                };

  AbstractAction CLOSE =         new AbstractAction("CLOSE")
                                {
                                  public void actionPerformed(ActionEvent evt)
                                  {
				    close();
                                  }
                                };



  /**
   *  Creates menuitem and keyboardbinding for a "method"
   *
   *  @param  name           The string that is to be shown in the menu's
   *  @param  action         The action who should be associated with the method
   *  @param  actionName     The name of the action
   *  @param  toMenu         The index of the menu where the method will be, if -1 the method won't be added to any menu
   *  @param  keyStroke      A string representing the key-combination that is to be associated with the method
   */

  public void newMethod(String name, Action action, String actionName, /*boolean toPopup,*/ int toMenu, String keyStroke) {
    if ( action != null) {
      actionMap.put(actionName, action);
    }
    if ( keyStroke != null) {
      inputMap.put(KeyStroke.getKeyStroke(keyStroke), actionName);
    }
    if ( toMenu >= 0) {
      menubar.getMenu(toMenu).add(menuItem(JopLang.transl(name), action, keyStroke));
    }
  }
  

  /**
  * Creates all input possibilities that the user can use
  */
  public void createUserInputs()
  {

    JMenu file = new JMenu(JopLang.transl("File"));
    file.setMnemonic('F');
    JMenu edit = new JMenu(JopLang.transl("Edit"));
    edit.setMnemonic('E');
    JMenu functions = new JMenu(JopLang.transl("Functions"));
    functions.setMnemonic('u');
    JMenu languageSel = new JMenu(language);
    languageSel.setMnemonic('S');

    // Create a menu bar and add the created panes to this
    menubar.add(file);
    menubar.add(edit);
    menubar.add(functions);
    menubar.add(languageSel);
    
    this.getRootPane().setJMenuBar(menubar);
    
    // Create some keystrokes and bind them to an action
    this.newMethod("Open Object", ADDOBJECTINFO, "ADDOBJECTINFO", 2, "ctrl A");
    this.newMethod("Open Object", ADDOBJECTINFO, "ADDOBJECTINFO", -1, "shift RIGHT");
    this.newMethod("COLLAPSENODE", COLLAPSENODE, "COLLAPSENODE", -1, "LEFT");
    this.newMethod("Open Plc", OPENPLC, "OPENPLC", 2, "ctrl L");
    this.newMethod("Open Object Graph", OPENGRAPH, "OPENGRAPH", 2, "ctrl G");
    this.newMethod("Show Crossreferences", SHOWCROSS, "SHOWCROSS", 2, "ctrl R");
    this.newMethod("Change Value", CHANGEVALUE, "CHANGEVALUE", 2, "ctrl Q");
    // this.newMethod("Debug", DEBUG, "DEBUG", 2, "ctrl RIGHT");
    this.newMethod("Search", FIND, "FIND", 1, "ctrl F");
    this.newMethod("INCLOG", INCLOG, "INCLOG", -1, "ctrl O");
    this.newMethod("DECLOG", DECLOG, "DECLOG", -1, "ctrl P");
    this.newMethod("Command", COMM,"COMM",2,"ctrl B");
    this.newMethod("Close", CLOSE,"CLOSE",0,"ctrl W");

    inputMap.setParent(this.tree.getInputMap(JComponent.WHEN_FOCUSED));
    this.tree.setInputMap(JComponent.WHEN_FOCUSED, inputMap);

    actionMap.setParent(this.tree.getActionMap());
    this.tree.setActionMap(actionMap);
    
    
    // Manage the fast menu to be shown when you click in the main window.
    // Shift Click will give "Open object"
    this.tree.addMouseListener(
      new MouseAdapter()
      {
        public void mousePressed(MouseEvent e)
        {
          int selRow = tree.getRowForLocation(e.getX(), e.getY());
          TreePath selPath = tree.getPathForLocation(e.getX(), e.getY());
          if(selRow != -1)
          {
            if(e.getClickCount() == 1 && e.isShiftDown())
            {
              //TreePath oldSelectedPath = tree.getSelectionPath();
              selPath = tree.getPathForRow(selRow);
              tree.setSelectionPath(selPath);
              addObjectInfo(selPath);
            }
            else if(e.getClickCount() == 1 && e.isControlDown())
            {
              selPath = tree.getPathForRow(selRow);
              tree.setSelectionPath(selPath);
              debugNode(selPath);
            }
            else if(e.getClickCount() == 1)
            {
              selPath = tree.getPathForRow(selRow);
              tree.setSelectionPath(selPath);
            }
            if(e.isPopupTrigger())
            {
	      TreePath tp = tree.getSelectionPath();
	      if(tp == null) return;
	      DefaultMutableTreeNode tn = (DefaultMutableTreeNode)(tp.getLastPathComponent());
	      if(tn == null) return;
	      try {
		TreeObj obj = (TreeObj)tn.getUserObject();
		String name = obj.fullName;

		if(name == null)
		  return;

		// Remove any type suffix
		String str;
		int idx1 = name.indexOf('#');
		if ( idx1 != -1) {
		  int idx2 = name.indexOf('[');
		  if ( idx2 != -1)
		    str = name.substring( 0, idx1) + name.substring(idx2);
		  else
		    str = name.substring( 0, idx1);
		}
		else
		  str = name;

		new JopMethodsMenu( session, str, 
				    JopUtility.NAVIGATOR, (Component) tree, 
				    e.getX(), e.getY());
		      
	      }
	      catch(Exception ex) {
		 Logg.logg("Error in showCross() " + ex.toString(),0);
	      }
	      Logg.loggToApplet("");
              //popup.show((Component)e.getSource(), e.getX(), e.getY());
            }
          }
        }


        public void mouseReleased(MouseEvent e)
        {
          // Check if this is the correct type of event to display a fast menu.

          if(e.isPopupTrigger())
          {
	    TreePath tp = tree.getSelectionPath();
	    if(tp == null) return;
	    DefaultMutableTreeNode tn = (DefaultMutableTreeNode)(tp.getLastPathComponent());
	    if(tn == null) return;
	    try {
	      TreeObj obj = (TreeObj)tn.getUserObject();
	      String name = obj.fullName;
	      if(name == null)
		return;

	      new JopMethodsMenu( session, name, 
				  JopUtility.NAVIGATOR,(Component) tree, 
				  e.getX(), e.getY());
	      
	    }
	    catch(Exception ex) {
	      Logg.logg("Error in showCross() " + ex.toString(),0);
	    }
	    Logg.loggToApplet("");
	    // popup.show((Component)e.getSource(), e.getX(), e.getY());
          }
        }
      });
  }

  // A help method to create the menu object
  public static JMenuItem menuItem(String label,
      Action action,
      String keyStroke)
  {
    JMenuItem item = new JMenuItem(label);
    item.setAction(action);
    item.setText(label);
    if(keyStroke != null)
    {
      item.setAccelerator(KeyStroke.getKeyStroke(keyStroke));
    }
    return item;
  }

  public void close() {
  }

  public void showCross()
  {
    TreePath tp = tree.getSelectionPath();
    if(tp == null) return;
    DefaultMutableTreeNode tn = (DefaultMutableTreeNode)(tp.getLastPathComponent());
    if(tn == null) return;
    try
    {
      TreeObj obj = (TreeObj)tn.getUserObject();
      String name = obj.fullName;
      if(name == null)
      {
        Logg.loggToApplet("Select an object or attribute");
        return;
      }
      session.openCrrFrame(name);
    }
    catch(Exception e)
    {
      Logg.logg("Error in showCross() " + e.toString(),0);
    }
  }

  
  public void openPLC()
  {
    TreePath tp = tree.getSelectionPath();
    DefaultMutableTreeNode tn = (DefaultMutableTreeNode)(tp.getLastPathComponent());
    GetPLCWindowObjRet ret = getPLCWindowObj(tn);
    if(ret.oid == null)
    {
      Logg.loggToApplet("Unable to open Plc trace for this object");
      return;
    }
    session.openFlowFrame(ret.oid, ret.name);
  }

  public void openGraph()
  {
    TreePath tp = tree.getSelectionPath();
    if(tp == null) return;
    DefaultMutableTreeNode tn = (DefaultMutableTreeNode)(tp.getLastPathComponent());
    if(tn == null) return;
    try {
      TreeObj obj = (TreeObj)tn.getUserObject();
      String name = obj.fullName;
      if(name == null) {
        Logg.loggToApplet("Select an object");
        return;
      }
      
      int cid = 0;
      CdhrAttrRef aret = gdh.nameToAttrRef(name);
      if ( aret.oddSts()) {
	  CdhrTypeId cret = gdh.getAttrRefTid(aret.aref);
	  if ( cret.oddSts())
	      cid = cret.getTypeId();
      }
      String cmd;
      switch ( cid) {
      case Pwrs.cClass_PlantHier:
	  String attr = name + ".DefGraph";
	  CdhrString xttgraph = gdh.getObjectInfoString( attr);
	  if ( xttgraph.evenSts() || xttgraph.str.isEmpty()) return;

	  cmd = "open graph/object=" + xttgraph.str;
          break;
      case Pwrb.cClass_DsTrend:
      case Pwrb.cClass_DsTrendCurve:
      case Pwrb.cClass_PlotGroup:
	  cmd = "open trend/name=" + name;
	  break;
      case Pwrb.cClass_DsFastCurve:
	  cmd = "open fast/name=" + name;
	  break;
      default:
	  cmd = "open graph/class/inst=" + name;
      }
      session.executeCommand(cmd);
    }
    catch(Exception e) {
      Logg.logg("Error in open graph" + e.toString(),0);
    }
  }

    public PwrtObjid getPLCWindowObjid(DefaultMutableTreeNode tn)
    {
      DefaultMutableTreeNode tc = null;
      PwrtObjid oid = null;
      XttObj obj;
      try
      {
         obj = (XttObj)tn.getUserObject();
      }
      catch(ClassCastException e)
      {
        return oid;
      }
      switch(obj.classId.classId)
      {
        case Pwrb.cClass_windowplc:
	  oid = obj.objId.objid;
	  break;
	case Pwrb.cClass_plc:
	  try
	  {
	    CdhrObjid gdhr = gdh.getChild(obj.objId.objid);
	    if(gdhr.oddSts())
	    {
	      oid = gdhr.objid;
	    }
	  }
	  catch(NoSuchElementException e)
	  {
	  }
	  break;
	default:
	  DefaultMutableTreeNode tParent = (DefaultMutableTreeNode)tn.getParent();
	  if(tParent != null) 
	    return getPLCWindowObjid(tParent);
	  break;
      }
      return oid;
    }
    
    public String getPLCWindowObjName(DefaultMutableTreeNode tn)
    {
      XttObj obj;
      String ret = null;
      try
      {
         obj = (XttObj)tn.getUserObject();
	 ret = obj.name;
      }
      catch(ClassCastException e)
      {
      }
      return ret;
    }

    public GetPLCWindowObjRet getPLCWindowObj(DefaultMutableTreeNode tn)
    {
      DefaultMutableTreeNode tc = null;
      GetPLCWindowObjRet ret = new GetPLCWindowObjRet();      
      XttObj obj;
      try
      {
         obj = (XttObj)tn.getUserObject();
      }
      catch(ClassCastException e)
      {
        return ret;
      }
      switch(obj.classId.classId)
      {
        case Pwrb.cClass_windowplc:
	case Pwrb.cClass_plc:
	  ret.oid = getPLCWindowObjid(tn);
	  break;
	default:
            ret.oid = getPLCWindowObjid(tn);
	    ret.name = getPLCWindowObjName(tn);
	  break;
      }
      return ret;
    }
    
    private class GetPLCWindowObjRet
    {
      String name = null;
      PwrtObjid oid = null;
    }
  

  public void changeValue()
  {
    if(this.engine.gdh.isAuthorized(Pwr.mPrv_RtWrite | Pwr.mPrv_System))
    {
      Logg.loggToApplet(" ");
      Logg.logg("JopXttApplet: changeValue()", 6);
      userValue.setText(null);
      this.tree.setRequestFocusEnabled(false);
      if (enterFieldEnable){
	  enterFieldEnable = false;
	  this.messagePanel.remove(userCommandLabel);
      }
      else this.messagePanel.remove(labelMessage);
      this.messagePanel.add(this.userValueLabel, BorderLayout.WEST);
      this.messagePanel.add(this.userValue, BorderLayout.CENTER);
      messagePanel.doLayout();
      messagePanel.repaint();

      this.userValue.requestFocus();
    }
    else
    {
      Logg.loggToApplet("Not authorized for this action");
    }
  }

  public void find()
  {
      Logg.loggToApplet(" ");
      Logg.logg("JopXttApplet: find()", 6);
      userValue.setText(null);
      this.tree.setRequestFocusEnabled(false);

      if (enterFieldEnable){
	  enterFieldEnable = false;
	  this.messagePanel.remove(userCommandLabel);
      }
      else this.messagePanel.remove(labelMessage);
      this.messagePanel.add(this.userValueLabel, BorderLayout.WEST);
      this.messagePanel.add(this.userValue, BorderLayout.CENTER);
      messagePanel.doLayout();
      messagePanel.repaint();

      this.userValue.requestFocus();
      this.findFieldEnable = true;
  }

  // Method to handle manual typed commands.
  public void enterComm()
  {
      Logg.loggToApplet(" ");
      Logg.logg("JopXttApplet: enterComm()", 6);
      userValue.setText(null);
      this.tree.setRequestFocusEnabled(false);
      if (userValueLabel.isVisible()){
	  findFieldEnable = false;
	  this.messagePanel.remove(userValueLabel);
      }
      else this.messagePanel.remove(labelMessage);
      this.messagePanel.add(this.userCommandLabel, BorderLayout.WEST);
      this.messagePanel.add(this.userValue, BorderLayout.CENTER);
      messagePanel.doLayout();
      messagePanel.repaint();

      this.userValue.requestFocus();
      this.enterFieldEnable = true;
  }

    // Execute a comand
    public void enterComm(String com){
	session.executeCommand(com);
    }


  /**
   *  Description of the Class
   *
   *@author     JN3920
   *@created    November 12, 2002
   */
  class MyTreeExpansionListener implements TreeExpansionListener
  {
    /**
     *  Description of the Method
     *
     *@param  e  Description of the Parameter
     */
    public void treeCollapsed(TreeExpansionEvent e)
    {
      TreePath tp = e.getPath();
      handleTreeCollapsed(tp);
    }


    /**
     *  Description of the Method
     *
     *@param  e  Description of the Parameter
     */
    public void treeExpanded(TreeExpansionEvent e)
    {
      // fix for bug that I can't solve for the moment
      try
      {
        TreePath tp = e.getPath();
        if(tree.getSelectionPath() == null)
        {
          tree.setSelectionPath(tp);
        }
        DefaultMutableTreeNode tn = (DefaultMutableTreeNode)(tp.getLastPathComponent());
        DefaultMutableTreeNode tc = (DefaultMutableTreeNode)tn.getFirstChild();
        if((tn != null) &&
            (tc != null) && tc.getUserObject() instanceof XttObj)
        {
          XttObj obj = (XttObj)tc.getUserObject();
          //XttObj parentObj = (XttObj) tn.getUserObject();
          if(obj.name.compareTo("DummyXttObj") == 0)
          {
            Logg.logg("XttTree: innan collapsePath() pga DummyXttObj", 1);
            tree.collapsePath(tp);
            treeModel.reload(tn);
          }
        }
      }
      catch(NoSuchElementException exception)
      {
      }
    }
  }


  /**
   *  Description of the Class
   *
   *@author     JN3920
   *@created    November 12, 2002
   */
  class MyTreeWillExpandListener implements TreeWillExpandListener
  {

    /**
     *  Collaps all branches below the collapsing node.
     *
     *@param  e  Description of the Parameter
     */
    public void treeWillCollapse(TreeExpansionEvent e)
    {
      TreePath tp = e.getPath();
      if(tp != null)
      {
        int row = tree.getRowForPath(tp);
        row++;
        TreePath descendant = tree.getPathForRow(row);
        while(tp.isDescendant(descendant))
        {
          tree.collapsePath(descendant);
          DefaultMutableTreeNode tn = (DefaultMutableTreeNode)(descendant.getLastPathComponent());
          Object obj = tn.getUserObject();
          if(obj instanceof XttObj)
          {
            ((XttObj)(obj)).removeAttrVector();
          }
          row++;
          descendant = tree.getPathForRow(row);
          //just in case...
          if(row > 50000)
          {
            break;
          }
        }
      }
    }


    /**
     *  Description of the Method
     *
     *@param  e  Description of the Parameter
     */
    public void treeWillExpand(TreeExpansionEvent e)
    {
      Logg.logg("XttTree.treeWillExpand", 7);
      // should be in a separate method...
      TreePath tp = e.getPath();
      if(tree.hasBeenExpanded(tp))
      {
        Logg.logg("XttTree: Har varit expanderad fel!!", 1);
        tree.collapsePath(tp);
        return;
      }
      Cursor defCursor = getCursor();
      setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

      DefaultMutableTreeNode tn = (DefaultMutableTreeNode)(tp.getLastPathComponent());
      DefaultMutableTreeNode tc = (DefaultMutableTreeNode)tn.getFirstChild();
      if((tn != null) && (tree.getSelectionPath() != null) &&
          (tc != null) && !tree.hasBeenExpanded(tp) && tc.getUserObject() instanceof XttObj &&
	 tn.getUserObject() instanceof XttObjAttr)
      {
        XttObj obj = (XttObj)tc.getUserObject();
        Logg.logg("XttTree: Skall expanderas addChildrenClass", 1);
        addObjectInfo(tp);
        Logg.logg("XttTree: Expandering klar", 1);
      }
      else if((tn != null) && (tree.getSelectionPath() != null) &&
          (tc != null) && !tree.hasBeenExpanded(tp) && tc.getUserObject() instanceof XttObj )
      {
        XttObj obj = (XttObj)tc.getUserObject();
        Logg.logg("XttTree: Skall expanderas1", 1);
        addChildren(tn, tc);
        Logg.logg("XttTree: Expandering klar", 1);
      }
      else if((tn != null) && (tree.getSelectionPath() != null)
           && tn.getUserObject() instanceof XttObjAttr)
      {
        String s = ((XttArrayAttr)(tc.getUserObject())).name;
        tn.remove(tc);
        GdhrRefObjectInfo ret;
        XttObjAttr obj = (XttObjAttr)tn.getUserObject();
        Vector<String> ref_vec = new Vector<String>();
        //Vector ref_vec = new Vector();
        Vector ret_vec;
        Vector<XttArrayAttr> attr_vec = new Vector<XttArrayAttr>();
        //Vector attr_vec = new Vector();
        // should be in a separate tree??
        for(int j = 0; j < obj.elements; j++)
        {
          XttArrayAttr arrayAttr = new XttArrayAttr(obj.name + "[" + j + "]", s + "#" + obj.elements + "[" + j + "]", obj.type,
              obj.elements);
          DefaultMutableTreeNode arrayChildNode = new DefaultMutableTreeNode(arrayAttr);
          arrayAttr.treeNode = arrayChildNode;
          XttArrayAttr.treeModel = XttObjAttr.treeModel;
          obj.treeNode.add(arrayChildNode);
          Logg.logg("XttObj: arrayAttr.fullName= " + arrayAttr.fullName, 8);
          String str = arrayAttr.fullName;
          attr_vec.add(arrayAttr);
          ref_vec.add(str);

        }
        Logg.logg("refObjectInfo_Vector()", 6);
        ret_vec = gdh.refObjectInfo_Vector(ref_vec);
        if(ret_vec == null)
        {
          Logg.logg("XttTree : refObjectInfo_Vector returnerar null", 1);
          setCursor(defCursor);
	  return;
        }
        for(int i = 0; i < attr_vec.size() && i < ret_vec.size(); i++)
        {
          ret = (GdhrRefObjectInfo)ret_vec.get(i);
          if(ret.evenSts())
          {
            Logg.logg("XttObj:  ObjectInfoError ", 4);
          }
          attr_vec.get(i).refObj = ret;
        }
      }
      setCursor(defCursor);
    }
  }

  /**
   *  Description of the Class
   *
   *@author     JN3920
   *@created    November 12, 2002
   */
  private class MyRenderer extends DefaultTreeCellRenderer
  {
    /**  Description of the Field */
    ImageIcon ClosedLeafIcon;

    /**  Description of the Field */
    ImageIcon ClosedNodeIcon;
    /**  Description of the Field */
    ImageIcon ObjAttrArrayElementIcon;

    /**  Description of the Field */
    ImageIcon ObjAttrArrayIcon;
    /**  Description of the Field */
    ImageIcon ObjAttrIcon;
    /**  Description of the Field */
    ImageIcon ObjAttrOpenNodeIcon;
    /**  Description of the Field */
    ImageIcon ObjAttrPointerIcon;
    /**  Description of the Field */
    ImageIcon OpenLeafIcon;
    /**  Description of the Field */
    ImageIcon OpenNodeIcon;


    /**  Constructor for the MyRenderer object */
    public MyRenderer()
    {
        ClosedLeafIcon = new ImageIcon(XttClosedLeafIcon);
        OpenLeafIcon = new ImageIcon(XttOpenLeafIcon);

        ClosedNodeIcon = new ImageIcon(XttClosedNodeIcon);
        OpenNodeIcon = new ImageIcon(XttOpenNodeIcon);
        ObjAttrOpenNodeIcon = new ImageIcon(XttObjAttrOpenNodeIcon);

        ObjAttrIcon = new ImageIcon(XttObjAttrIcon);
        ObjAttrPointerIcon = new ImageIcon(XttObjAttrPointerIcon);

        ObjAttrArrayIcon = new ImageIcon(XttObjAttrArrayIcon);
        ObjAttrArrayElementIcon = new ImageIcon(XttObjAttrArrayElementIcon);
    }


    /**
     *  Gets the treeCellRendererComponent attribute of the MyRenderer object
     *
     *@param  tree      Description of the Parameter
     *@param  value     Description of the Parameter
     *@param  sel       Description of the Parameter
     *@param  expanded  Description of the Parameter
     *@param  leaf      Description of the Parameter
     *@param  row       Description of the Parameter
     *@param  hasFocus  Description of the Parameter
     *@return           The treeCellRendererComponent value
     */
    public Component getTreeCellRendererComponent(
        JTree tree,
        Object value,
        boolean sel,
        boolean expanded,
        boolean leaf,
        int row,
        boolean hasFocus)
    {

      super.getTreeCellRendererComponent(
          tree, value, sel,
          expanded, leaf, row,
          hasFocus);

      DefaultMutableTreeNode node = (DefaultMutableTreeNode)value;
      Object userObject = node.getUserObject();

      if(userObject instanceof XttObj)
      {
        if(leaf)
        {
          setIcon(ClosedLeafIcon);
        }
        else if(((XttObj)(userObject)).hasBeenReferenced &&
            !((XttObj)(userObject)).hasChildren)
        {
          setIcon(OpenLeafIcon);
        }
        else if(((XttObj)(userObject)).hasBeenReferenced &&
            ((XttObj)(userObject)).hasChildren)
        {
          setIcon(ObjAttrOpenNodeIcon);
        }
        else if(expanded)
        {
          setIcon(OpenNodeIcon);
        }
        else
        {
          setIcon(ClosedNodeIcon);
        }
      }
      else if(userObject instanceof XttObjAttr)
      {
        int flags = ((XttObjAttr)(userObject)).flags;
        int type = ((XttObjAttr)(userObject)).type;
        if((flags & Pwr.mAdef_class) > 0)
        {
          setIcon(ObjAttrIcon);
        }

        else if((flags & Pwr.mAdef_array) > 0)
        {
          setIcon(ObjAttrArrayIcon);
        }
        // Change flag to show actual value correct
        else if(((flags & (Pwr.mAdef_rtdbref | Pwr.mAdef_devbodyref)) > 0) || type == Pwr.eType_Objid)
        {
          setIcon(ObjAttrPointerIcon);
        }
        else
        {
          setIcon(ObjAttrIcon);
        }
      }
      else if(userObject instanceof XttArrayAttr)
      {
        setIcon(ObjAttrArrayElementIcon);
      }
      //just in case....
      else if(!leaf)
      {
        setIcon(ClosedNodeIcon);
      }
      else
      {
        setIcon(ClosedLeafIcon);
      }
      setBackgroundSelectionColor(Color.black);
      setTextSelectionColor(Color.white);
      return this;
    }
  }

  public Object getRoot() {
    return root;
  }
}


















