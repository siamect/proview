/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jop;
import java.util.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.image.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import javax.swing.table.*;
import javax.swing.border.*;
import javax.swing.Timer;
import java.net.URL;
import jpwr.rt.*;

/**
   Jop trend curve.
   <b>
   Displays trend curves configured with DsTrend or DsTrendCruve objects.
 */
public class JopXttTrend implements ActionListener, JopCurveIfc, GdhApplIfc {
    public static final int XTT_TREND_MAX = 20;

    JopSession session;
    JopEngine engine;
    Object root;
    DsTrend[] tp;
    DsTrendCurve[] tcp;
    Timer timer;
    JopCurve curve;
    int trend_cnt = 2;
    int min_interval_idx;
    int max_points;
    int max_time;
    int min_interval;
    String[] trend_name = new String[XTT_TREND_MAX];
    int[] interval = new int[XTT_TREND_MAX];
    int[] last_buffer = new int[XTT_TREND_MAX];
    int[] last_next_index = new int[XTT_TREND_MAX];
    JopCurveData gcd;
    int trend_tid;
    String[] buffers = new String[XTT_TREND_MAX];
    int[] element_type = new int[XTT_TREND_MAX];
    int update_time;
    CircBuffInfo[] cb_info = new CircBuffInfo[XTT_TREND_MAX];

    private class DsTrend {
	public String DataName;
	public String Unit;
	public int NoOfBuffers;
	public int ScanTime;
	public int Multiple;
	public int NoOfSample;
	public int WriteBuffer;
	public int[] NextWriteIndex = new int[2];
	public float[] DataBuffer = new float[478];

	public DsTrend() {}
    }

    private class DsTrendCurve {
	public PwrtAttrRef AttrRef;
	public String AttrName;
	public String TimeBuffer;
	public float DisplayTime;
	public float DisplayUpdateTime;
	public float ScanTime;
	public int NoOfSample;
	public int DisplayResolution;
	public int TimeResolution;
	public String Buffer;
	public int ElementType;
	public int ActualDataSize;
	public String Unit;

	public DsTrendCurve() {}
    }

    public JopXttTrend( String[] trendList) {
	engine = new JopEngine( 1000, this);
	session = new JopSession( engine, (Object)this);

	init( trendList);
    }

    public JopXttTrend( JopSession session, String[] trendList) {
	this.session = session;
	engine = session.getEngine();
	
	init( trendList);
    }

    public void close() {
	timer.stop();
    }

    void init( String[] trendList) {

	int i, j, k;
	int start_idx;
	int trend_buff_size = 478;

	timer = new Timer( 1000, this); 

	if ( trendList.length == 0) {
	    System.out.println("Error in trend  configuration");
	    return;
	}

	CdhrAttrRef aret = engine.gdh.nameToAttrRef( trendList[0]);
	if ( aret.evenSts()) {
	    System.out.println("Error in trend  configuration");
	    return;
	}
	CdhrTypeId cret = engine.gdh.getAttrRefTid( aret.aref);
	if ( cret.evenSts()) {
	    System.out.println("Error in trend  configuration");
	    return;
	}
	trend_tid = cret.typeId;

	if ( trend_tid == Pwrb.cClass_PlotGroup) {
	    // Plotgroup as input
	    CdhrString ret;
	    trend_cnt = 0;
	    for ( i = 0; i < 20; i ++) {
		ret = engine.gdh.getObjectInfoString( trendList[0] + ".YObjectName["+i+"]");
		if ( ret.evenSts() || ret.str.equals(""))
		    continue;
		trend_name[trend_cnt++] = ret.str;
	    }


	    aret = engine.gdh.nameToAttrRef( trend_name[0]);
	    if ( aret.evenSts()) {
		System.out.println("Error in trend  configuration");
		return;
	    }
	    cret = engine.gdh.getAttrRefTid( aret.aref);
	    if ( cret.evenSts()) {
		System.out.println("Error in trend  configuration");
		return;
	    }
	    trend_tid = cret.typeId;
	}
	else {
	    // DsTrend or DsTrendCurve as input
	    trend_name = trendList;
	    trend_cnt = trend_name.length;
	}	

	if ( trend_tid == Pwrb.cClass_DsTrend) {

	    tp = new DsTrend[trend_cnt];
	    for ( i = 0; i < trend_cnt; i++) {
		tp[i] = new DsTrend();
		
		CdhrString sret = engine.gdh.getObjectInfoString( trend_name[i] + ".DataName");
		if ( sret.evenSts()) {
		    System.out.println("Trend object error, " + trend_name[i]);
		    return;
		}
		tp[i].DataName = sret.str;

		int offs = tp[i].DataName.lastIndexOf('.');
		if ( offs != -1) {
		    sret = engine.gdh.getObjectInfoString( tp[i].DataName.substring(0,offs) + ".Unit");
		    if ( sret.oddSts())
			tp[i].Unit = sret.str;
		    else
			tp[i].Unit = new String();
		}
		else
		    tp[i].Unit = new String();

		CdhrInt ret = engine.gdh.getObjectInfoInt( trend_name[i] + ".ScanTime");
		if ( ret.oddSts()) {
		    tp[i].ScanTime = ret.value;
		    ret = engine.gdh.getObjectInfoInt( trend_name[i] + ".NoOfBuffers");
		    if ( ret.oddSts()) {
			tp[i].NoOfBuffers = ret.value;
			ret = engine.gdh.getObjectInfoInt( trend_name[i] + ".NoOfSample");
			if ( ret.oddSts()) {
			    tp[i].NoOfSample = ret.value;
			    ret = engine.gdh.getObjectInfoInt( trend_name[i] + ".Multiple");
			    if ( ret.oddSts()) {
				tp[i].Multiple = ret.value;
				ret = engine.gdh.getObjectInfoInt( trend_name[i] + ".WriteBuffer");
				if ( ret.oddSts()) {
				    tp[i].WriteBuffer = ret.value;
				    ret = engine.gdh.getObjectInfoInt( trend_name[i] + ".NextWriteIndex[0]");
				    if ( ret.oddSts()) {
					tp[i].NextWriteIndex[0] = ret.value;
					ret = engine.gdh.getObjectInfoInt( trend_name[i] + ".NextWriteIndex[1]");
					if ( ret.oddSts()) {
					    tp[i].NextWriteIndex[1] = ret.value;
					}
				    }
				}
			    }
			}
		    }
		}
		if ( ret.evenSts()) {
		    System.out.println("Trend object error, " + trend_name[i]);
		    return;
		}

		CdhrFloatArray faret = engine.gdh.getObjectInfoFloatArray( trend_name[i] + ".DataBuffer", 478);
		if ( faret.evenSts()) {
		    System.out.println("Trend object error, " + trend_name[i]);
		    return;
		}
		tp[i].DataBuffer = faret.value;	    
	    
	    }

	    // Calculate number of points
	    max_time = 0;
	    min_interval = 100000;
	    int time;
	    for ( i = 0; i < trend_cnt; i++) {
		time = tp[i].Multiple * tp[i].ScanTime * tp[i].NoOfBuffers *
		    tp[i].NoOfSample;
		if ( time > max_time)
		    max_time = time;
		
		if ( (tp[i].Multiple * tp[i].ScanTime) < min_interval) {
		    min_interval = tp[i].Multiple * tp[i].ScanTime;
		    min_interval_idx = i;
		}
	    }
	    
	    if ( min_interval == 0) {
		System.out.println( "XNAV__TRENDCONFIG");
		return;
	    }
    
	    max_points = max_time / min_interval;
	    
	    for ( i = 0; i < trend_cnt; i++) {
		interval[i] = tp[i].Multiple * tp[i].ScanTime / min_interval;
	    }

	    // Create data for time axis
	    gcd = new JopCurveData( JopCurveData.eDataType_DsTrend);
	    gcd.x_data[0] = new double[max_points];
	    gcd.x_name = new String("Time");
	    for ( j = 0; j < max_points; j++) {
		gcd.x_data[0][j] = (double) (j * min_interval);
	    }
	    gcd.x_axis_type[0] = JopCurveData.eAxis_x;
	    
	    for ( i = 0; i < trend_cnt; i++) {
		gcd.y_data[i] = new double[max_points];
		
		int write_buffer = tp[i].WriteBuffer;
		start_idx = write_buffer * trend_buff_size / 2
		    + ( tp[i].NextWriteIndex[write_buffer]);
		if ( start_idx == 0) {
		    start_idx = tp[i].NoOfSample - 1 + trend_buff_size / 2;
		    write_buffer = 1;
		}
		else if ( start_idx == trend_buff_size / 2) {
		    start_idx = tp[i].NoOfSample - 1;
		    write_buffer = 0;
		}
		else
		    start_idx--;
      
		int idx = 0;
		for ( j = start_idx; j >= write_buffer * trend_buff_size/2; j--) {
		    for ( k = 0; k < interval[i]; k++) {
			gcd.y_data[i][idx] = tp[i].DataBuffer[j];
			idx++;
		    }
		}
		for ( j = tp[i].NoOfSample - 1 + (write_buffer == 0 ? 1 : 0) * trend_buff_size/2;
		      j >= (write_buffer == 0 ? 1 : 0) * trend_buff_size/2; j--) {
		    for ( k = 0; k < interval[i]; k++) {
			gcd.y_data[i][idx] = tp[i].DataBuffer[j];
			idx++;
		    }
		}
		if ( start_idx != tp[i].NoOfSample - 1 + 
		     write_buffer * trend_buff_size/2) {
		    for ( j = tp[i].NoOfSample - 1 + write_buffer * trend_buff_size/2; 
			  j > start_idx; j--) {
			for ( k = 0; k < interval[i]; k++) {
			    gcd.y_data[i][idx] = tp[i].DataBuffer[j];
			    idx++;
			}
		    }
		}
		last_buffer[i] = tp[i].WriteBuffer;
		last_next_index[i] = tp[i].NextWriteIndex[last_buffer[i]];
		gcd.y_axis_type[i] = JopCurveData.eAxis_y;
	    
		gcd.y_name[i] = tp[i].DataName;
		gcd.y_unit[i] = tp[i].Unit;
		gcd.rows[i] = max_points;
	    }

	    gcd.cols = trend_cnt;
	}	
	else if ( trend_tid == Pwrb.cClass_DsTrendCurve) {
	    int[] actual_data_size = new int[XTT_TREND_MAX];
	    double fmin_interval = 0;
	    int tcp_i;
	    int object_cnt = trend_cnt;
	    String[] object_names = trend_name;
	    trend_name = new String[XTT_TREND_MAX];
	    trend_cnt = 0;
	    
    
	    // Get current status of the trend objects
	    i = 0;
	    tcp_i = 0;
	    max_points = 0;    
	    
	    tcp = new DsTrendCurve[XTT_TREND_MAX];
	    for ( i = 0; i < object_cnt; i++) {
		float displayTime;
		float displayUpdateTime;
		float scanTime;
		int noOfSample;
		int displayResolution;
		int timeResolution;
		String unit;

		tcp[object_cnt] = new DsTrendCurve();

		CdhrFloat fret = engine.gdh.getObjectInfoFloat( object_names[i] + ".DisplayTime");
		if ( fret.evenSts())
		    continue;
		displayTime = fret.value;

		fret = engine.gdh.getObjectInfoFloat( object_names[i] + ".DisplayUpdateTime");
		if ( fret.evenSts())
		    continue;
		displayUpdateTime = fret.value;

		fret = engine.gdh.getObjectInfoFloat( object_names[i] + ".ScanTime");
		if ( fret.evenSts())
		    continue;
		scanTime = fret.value;

		CdhrInt iret = engine.gdh.getObjectInfoInt( object_names[i] + ".NoOfSample");
		if ( iret.evenSts())
		    continue;
		noOfSample = iret.value;

		iret = engine.gdh.getObjectInfoInt( object_names[i] + ".DisplayResolution");
		if ( iret.evenSts())
		    continue;
		displayResolution = iret.value;

		iret = engine.gdh.getObjectInfoInt( object_names[i] + ".TimeResolution");
		if ( iret.evenSts())
		    continue;
		timeResolution = iret.value;
		
		CdhrString sret = engine.gdh.getObjectInfoString( object_names[i] + ".Unit");
		if ( sret.oddSts())
		    unit = sret.str;
		else
		    unit = new String();

		for ( j = 0; j < 10; j++) {
		    sret = engine.gdh.getObjectInfoString( object_names[i] + ".Attribute["+j+"]");
		    if ( sret.oddSts() && !sret.str.equals("")) {
			tcp[tcp_i] = new DsTrendCurve();

			tcp[tcp_i].AttrName = sret.str;
			tcp[tcp_i].DisplayUpdateTime = displayUpdateTime;
			tcp[tcp_i].ScanTime = scanTime;
			tcp[tcp_i].DisplayTime = displayTime;
			tcp[tcp_i].NoOfSample = noOfSample;
			tcp[tcp_i].DisplayResolution = displayResolution;
			tcp[tcp_i].TimeResolution = timeResolution;
			tcp[tcp_i].Unit = unit;
			
			int offs = tcp[tcp_i].AttrName.lastIndexOf('.');
			if ( offs != -1) {
			    sret = engine.gdh.getObjectInfoString( tcp[tcp_i].AttrName.substring(0,offs) + ".Unit");
			    if ( sret.oddSts())
				tcp[tcp_i].Unit = sret.str;
			    else
				tcp[tcp_i].Unit = new String();
			}
			else
			    tcp[tcp_i].Unit = new String();

			sret = engine.gdh.getObjectInfoString( object_names[i] + ".Buffers["+j+"]");
			if ( sret.evenSts() || sret.str.equals(""))
			    continue;			
		        tcp[tcp_i].Buffer = sret.str;

			aret = engine.gdh.nameToAttrRef( tcp[tcp_i].Buffer);
			if ( aret.evenSts())
			    continue;
			tcp[tcp_i].AttrRef = aret.aref;

			iret = engine.gdh.getObjectInfoInt( object_names[i] + ".AttributeType["+j+"]");
			if ( iret.evenSts())
			    continue;
			tcp[tcp_i].ElementType = iret.value;

			tcp_i++;

			if ( tcp_i >= XTT_TREND_MAX)
			    break;
		    }		
		}
		if ( tcp_i >= XTT_TREND_MAX)
		    break;
	    }
	    trend_cnt = tcp_i;

	    if ( trend_cnt == 0)
		return;
	   

	    for ( i = 0; i < trend_cnt; i++) {

		cb_info[i] = new CircBuffInfo();
		cb_info[i].circAref = tcp[i].AttrRef;
		cb_info[i].resolution = tcp[i].DisplayResolution;
		cb_info[i].elementType = tcp[i].ElementType;
		cb_info[i].samples = (int)(tcp[i].DisplayTime / tcp[i].ScanTime / cb_info[i].resolution);

		engine.gdh.getCircBuffInfo( cb_info[i]);

		tcp[i].ActualDataSize = cb_info[i].size;

		if ( i == 0) {
		    update_time = (int)(tcp[0].DisplayUpdateTime * 1000F);
		    fmin_interval = tcp[0].ScanTime;
		}

	    }


	    for ( i = 0; i < trend_cnt; i++) {
		if ( cb_info[i].samples > max_points)
		    max_points = cb_info[i].samples;
	    }
	    
	    // Create data for time axis
	    gcd = new JopCurveData( JopCurveData.eDataType_DsTrend);
	    gcd.x_data[0] = new double[max_points];
	    gcd.x_name = new String("Time");
	    for ( j = 0; j < max_points; j++) {
		gcd.x_data[0][j] = ( fmin_interval * j * tcp[0].DisplayResolution);
	    }
	    gcd.x_axis_type[0] = JopCurveData.eAxis_x;
	    
	    for ( i = 0; i < trend_cnt; i++) {
		gcd.y_data[i] = new double[max_points];

		switch ( tcp[i].ElementType) {
		case Pwr.eType_Float32:
		    for (  j = 0; j < tcp[i].ActualDataSize; j++) {
			gcd.y_data[i][j] = (double)((float[])cb_info[i].bufp)[ tcp[i].ActualDataSize - j - 1];
		    }
		    break;
		case Pwr.eType_Int32:
		case Pwr.eType_UInt32:
		case Pwr.eType_Int16:
		case Pwr.eType_UInt16:
		case Pwr.eType_Int8:
		case Pwr.eType_UInt8:
		    for (  j = 0; j < tcp[i].ActualDataSize; j++) {
			gcd.y_data[i][j] = (double)((int[])cb_info[i].bufp)[ tcp[i].ActualDataSize - j - 1];
		    }
		    break;
		default: ;
		}
      
		cb_info[i].bufp = null;
		gcd.y_axis_type[i] = JopCurveData.eAxis_y;
		gcd.y_name[i] = tcp[i].AttrName;      
		gcd.rows[i] = max_points;
		gcd.y_unit[i] = tcp[i].Unit;
	    }

	    gcd.cols = trend_cnt;

	    /*
	    if ( !trend_list) {
		// Use axis values from plotgroup object
		for ( i = 0; i < trend_cnt; i++) {
		    if ( plot.YMinValue[i] != plot.YMaxValue[i])
			gcd->scale( gcd->y_axis_type[i], gcd->y_value_type[i], 
				    plot.YMinValue[i],  plot.YMaxValue[i], 
				    &gcd->y_min_value_axis[i], &gcd->y_max_value_axis[i], 
				    &gcd->y_trend_lines[i], &gcd->y_axis_lines[i], &gcd->y_axis_linelongq[i], 
				    &gcd->y_axis_valueq[i], gcd->y_format[i], 
				    &gcd->y_axis_width[i], 1, 1);
		}
	    }
	    */	    
	}

	gcd.x_reverse = true;
	gcd.get_borders();
	gcd.get_default_axis();
	gcd.select_color(false);

	curve = new JopCurve( session, this, gcd);
	curve.setFillCurve(false);

	timer.start();
    }

    public void actionPerformed( ActionEvent e) {
	trend_scan();
    }

    private void trend_scan() {

	if ( trend_tid == Pwrb.cClass_DsTrend) {
	    int write_buffer;
	    int idx;
	    int values;
	    int trend_buff_size = 478;
	    int i, j, k;

	    for ( i = 0; i < trend_cnt; i++) {

		CdhrInt ret = engine.gdh.getObjectInfoInt( trend_name[i] + ".NoOfSample");
		if ( ret.oddSts()) {
		    tp[i].NoOfSample = ret.value;
		    ret = engine.gdh.getObjectInfoInt( trend_name[i] + ".WriteBuffer");
		    if ( ret.oddSts()) {
			tp[i].WriteBuffer = ret.value;
			ret = engine.gdh.getObjectInfoInt( trend_name[i] + ".NextWriteIndex[0]");
			if ( ret.oddSts()) {
			    tp[i].NextWriteIndex[0] = ret.value;
			    ret = engine.gdh.getObjectInfoInt( trend_name[i] + ".NextWriteIndex[1]");
			    if ( ret.oddSts()) {
				tp[i].NextWriteIndex[1] = ret.value;
			    }
			}
		    }
		}
		if ( ret.evenSts()) {
		    System.out.println("Trend object error, " + trend_name[i]);
		    return;
		}
		CdhrFloatArray faret = engine.gdh.getObjectInfoFloatArray( trend_name[i] + ".DataBuffer", 478);
		if ( faret.evenSts()) {
		    System.out.println("Trend object error, " + trend_name[i]);
		    return;
		}
		tp[i].DataBuffer = faret.value;	    	    

	    }

	    // Check if any new value
	    i = min_interval_idx;
	    if ( tp[i].NextWriteIndex[tp[i].WriteBuffer] !=
		 last_next_index[i]) {
		values = tp[i].NextWriteIndex[tp[i].WriteBuffer]
		    - last_next_index[i];
		if ( values < 0)
		    values = values + tp[i].NoOfSample;
		
		last_next_index[i] =
		    tp[i].NextWriteIndex[tp[i].WriteBuffer];
		
		for ( k = 0; k < values; k++) {
		    // Add new points
		    for ( i = 0; i < trend_cnt; i++) {
			// Shift data
			for ( j = max_points - 1; j > 0; j--)
			    gcd.y_data[i][j] = gcd.y_data[i][j-1];
			// Insert new value
			write_buffer = tp[i].WriteBuffer;
			idx = write_buffer * trend_buff_size / 2
			    + ( tp[i].NextWriteIndex[write_buffer]) - (values - 1 - k);
			if ( idx == 0 || idx == trend_buff_size/2)
			    idx = tp[i].NoOfSample - 1 + (write_buffer == 0 ? 1:  0) *
				trend_buff_size/2;
			else
			    idx--;
			
			gcd.y_data[i][0] = tp[i].DataBuffer[idx];
		    }
		    curve.updateChart();
		}
	    }    
	}
	else if ( trend_tid == Pwrb.cClass_DsTrendCurve) {
	    int size = 0;
	    int i, j;

	    engine.gdh.updateCircBuffInfo( cb_info, trend_cnt);

	    for ( i = 0; i < trend_cnt; i++) {

		size = cb_info[i].size;
		if ( size > 0) {
 
		    // Shift data
		    for ( j = cb_info[i].samples - 1; j >= size; j--)
			gcd.y_data[i][j] = gcd.y_data[i][j-size];
		    // Insert new value
		    switch ( tcp[i].ElementType) {
		    case Pwr.eType_Float32:
			for ( j = 0; j < size; j++) {
			    gcd.y_data[i][j] = ((float[])cb_info[i].bufp)[size - j - 1];
			}
			break;
		    case Pwr.eType_Int32:
		    case Pwr.eType_UInt32:
		    case Pwr.eType_Int16:
		    case Pwr.eType_UInt16:
		    case Pwr.eType_Int8:
		    case Pwr.eType_UInt8:
			for ( j = 0; j < size; j++) {
			    gcd.y_data[i][j] = ((int[])cb_info[i].bufp)[size - j - 1];
			}
			break;
		    default: ;
		    }
		}
	    }
	    if ( size > 0)
		curve.updateChart();
	}
    }

    // GdhApplIfc function
    public String getPwrHost() {
	return (String)null;
    }

    public static void main(String[] args)
    {
	boolean debug = false;
	for(int i = 0; i < args.length; i++)
	    {
		if(args[i].equals("-d") || args[i].equals("-D"))
		    {
			debug = true;
		    }
	    }
	
	
	
	JopXttTrend trend = new JopXttTrend(new String[] {"H28-Plot2"});
    }
}

