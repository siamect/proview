/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jop;
import java.util.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.image.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import java.net.URL;
import jpwr.rt.*;

/**
   Contains data for the curve window.
 */
public class JopCurveData
{
    public static final int CURVE_MAX_COLS   	= 20;
    public static final int eDataType_LogFile   = 0;
    public static final int eDataType_DsTrend   = 1;
    public static final int eDataType_MultiTrend = 2;
    public static final int eAxis_x = 0;
    public static final int eAxis_y = 1;
    public static final int eTimeFormat_Float = 0;
    public static final int eTimeFormat_HourMinute = 1;
    public static final int eTimeFormat_DayHour = 2;

    int type;
    int[]   rows = new int[CURVE_MAX_COLS];
    int     cols;
    String[] y_name = new String[CURVE_MAX_COLS];
    String x_name;
    String[] y_unit = new String[CURVE_MAX_COLS];
    String[] x_unit = new String[CURVE_MAX_COLS];
    double[][]  y_data = new double[CURVE_MAX_COLS][];
    double[][]  x_data = new double[CURVE_MAX_COLS][];
    double[] y_max_value = new double[CURVE_MAX_COLS];
    double[] y_min_value = new double[CURVE_MAX_COLS];
    double[] x_max_value = new double[CURVE_MAX_COLS];
    double[] x_min_value = new double[CURVE_MAX_COLS];
    double[] y_max_value_axis = new double[CURVE_MAX_COLS];
    double[]  y_min_value_axis = new double[CURVE_MAX_COLS];
    int[]     y_trend_lines = new int[CURVE_MAX_COLS];
    int[]     y_axis_lines = new int[CURVE_MAX_COLS];
    int[]     y_axis_linelongq = new int[CURVE_MAX_COLS];
    int[]     y_axis_valueq = new int[CURVE_MAX_COLS];
    double[]  x_max_value_axis = new double[CURVE_MAX_COLS];
    double[]  x_min_value_axis = new double[CURVE_MAX_COLS];
    int[]     x_trend_lines = new int[CURVE_MAX_COLS];
    int[]     x_axis_lines = new int[CURVE_MAX_COLS];
    int[]     x_axis_linelongq = new int[CURVE_MAX_COLS];
    int[]     x_axis_valueq = new int[CURVE_MAX_COLS];
    int[] color = new int[CURVE_MAX_COLS];
    int[] fillcolor = new int[CURVE_MAX_COLS];
    int[] axiscolor = new int[CURVE_MAX_COLS];
    int[] y_value_type = new int[CURVE_MAX_COLS];
    int[] x_value_type = new int[CURVE_MAX_COLS];
    int[] y_axis_type = new int[CURVE_MAX_COLS];
    int[] x_axis_type = new int[CURVE_MAX_COLS];
    double[]  y_axis_width = new double[CURVE_MAX_COLS];
    String[]    y_format = new String[CURVE_MAX_COLS];
    String[]    x_format = new String[CURVE_MAX_COLS];
    boolean x_reverse;
    int     time_format;

    public JopCurveData() {}
    public JopCurveData( int type) {
	this.type = type;
    }
    /*
    void get_borders();
    void get_default_axis();
    void select_color( bool dark_bg);
    */


    public void get_borders() {
      for ( int i = 0; i < cols; i++) {
	y_max_value[i] = 1e-37;
	y_min_value[i] = 1e37;

	y_value_type[i] = Pwr.eType_Boolean;

	for ( int j = 0; j < rows[i]; j++) {
	  if ( y_data[i][j] < y_min_value[i])
	    y_min_value[i] = y_data[i][j];
	  if ( y_data[i][j] > y_max_value[i])
	    y_max_value[i] = y_data[i][j];
	  if ( y_value_type[i] == Pwr.eType_Boolean && 
	       !( y_data[i][j] == 1 || y_data[i][j] == 0)) {
	    y_value_type[i] = Pwr.eType_Float64;
	    // printf( "Not Boolean %s: %f\n", name[i], data[i][j]);
	  }
	}
      } 
      
      if ( type == eDataType_MultiTrend) {
	for ( int i = 0; i < cols; i++) {
	  x_max_value[i] = 1e-37;
	  x_min_value[i] = 1e37;

	  x_value_type[i] = Pwr.eType_Float64;

	  for ( int j = 0; j < rows[i]; j++) {
	    if ( x_data[i][j] < x_min_value[i])
	      x_min_value[i] = x_data[i][j];
	    if ( x_data[i][j] > x_max_value[i])
	      x_max_value[i] = x_data[i][j];
	  }
	}
      } 
      else {
	for ( int i = 0; i < 1; i++) {
	  x_max_value[i] = 1e-37;
	  x_min_value[i] = 1e37;

	  x_value_type[i] = Pwr.eType_Float64;

	  for ( int j = 0; j < rows[0]; j++) {
	    // System.out.println( "x_data[" + i + "] " + x_data[i][j]);
	    if ( x_data[i][j] < x_min_value[i])
	      x_min_value[i] = x_data[i][j];
	    if ( x_data[i][j] > x_max_value[i])
	      x_max_value[i] = x_data[i][j];
	  }
	}
      } 
    }

    public void get_default_axis() {

      for ( int i = 0; i < cols; i++) {

	scale( y_axis_type[i], i, y_value_type[i], y_min_value[i],  y_max_value[i], false, false);
      }
      int i = 0;
      double axis_width;

      if ( type != eDataType_MultiTrend) {
	scale( x_axis_type[i], i, x_value_type[i], x_min_value[i],  x_max_value[i], false, false);
      }
      else {
	double min_value = 1e37;
	double max_value = -1e37;

	for ( i = 0; i < cols; i++) {
	  if ( x_min_value[i] < min_value)
	    min_value = x_min_value[i];
	  if ( x_max_value[i] > max_value)
	    max_value = x_max_value[i];
	}
	scale( x_axis_type[0], 0, x_value_type[0], min_value, max_value, false, false);
	for ( i = 1; i < cols; i++) {
	  x_min_value_axis[i] = x_min_value_axis[0];
	  x_max_value_axis[i] = x_max_value_axis[0];
	}
      }
    }

    public void select_color( boolean dark_bg) {
      int j;

      for ( int i = 0; i < cols; i++) {
	j = i % 9;
	switch( j) {
	case 0:
	  // Orange
	  if ( dark_bg)
	    color[i] = GeColor.COLOR_144;
	  else
	    color[i] = GeColor.COLOR_146;
	  axiscolor[i] = GeColor.COLOR_135;
	  if ( dark_bg)
	    fillcolor[i] = GeColor.COLOR_137;
	  else
	    fillcolor[i] = GeColor.COLOR_133;
	  break;
	case 1:
	  // YellowGreen
	  if ( dark_bg)
	    color[i] = GeColor.COLOR_85;
	  else
	    color[i] = GeColor.COLOR_87;
	  axiscolor[i] = GeColor.COLOR_75;
	  if ( dark_bg)
	    fillcolor[i] = GeColor.COLOR_67;
	  else
	    fillcolor[i] = GeColor.COLOR_64;
	  break;
	case 2:
	  // Yellow
	  if ( dark_bg)
	    color[i] = GeColor.COLOR_115;
	  else
	    color[i] = GeColor.COLOR_117;
	  axiscolor[i] = GeColor.COLOR_105;
	  if ( dark_bg)
	    fillcolor[i] = GeColor.COLOR_107;
	  else
	    fillcolor[i] = GeColor.COLOR_104;
	  break;
	case 3:
	  // Blue
	  color[i] = GeColor.COLOR_235;
	  axiscolor[i] = GeColor.COLOR_225;
	  if ( dark_bg)
	    fillcolor[i] = GeColor.COLOR_227;
	  else
	    fillcolor[i] = GeColor.COLOR_214;
	  break;
	case 4:
	  // Violet
	  color[i] = GeColor.COLOR_205;
	  axiscolor[i] = GeColor.COLOR_195;
	  if ( dark_bg)
	    fillcolor[i] = GeColor.COLOR_197;
	  else
	    fillcolor[i] = GeColor.COLOR_184;
	  break;
	case 5:
	  // Red
	  color[i] = GeColor.COLOR_175;
	  axiscolor[i] = GeColor.COLOR_165;
	  if ( dark_bg)
	    fillcolor[i] = GeColor.COLOR_167;
	  else
	    fillcolor[i] = GeColor.COLOR_154;
	  break;
	case 6:
	  // Green
	  color[i] = GeColor.COLOR_295;
	  axiscolor[i] = GeColor.COLOR_285;
	  if ( dark_bg)
	    fillcolor[i] = GeColor.COLOR_287;
	  else
	    fillcolor[i] = GeColor.COLOR_274;
	  break;
	case 7:
	  // Gray
	  color[i] = GeColor.COLOR_35;
	  axiscolor[i] = GeColor.COLOR_35;
	  if ( dark_bg)
	    fillcolor[i] = GeColor.COLOR_37;
	  else
	    fillcolor[i] = GeColor.COLOR_34;
	  break;
	case 8:
	  // Seablue
	  color[i] = GeColor.COLOR_265;
	  axiscolor[i] = GeColor.COLOR_255;
	  if ( dark_bg)
	    fillcolor[i] = GeColor.COLOR_257;
	  else
	    fillcolor[i] = GeColor.COLOR_254;
	  break;
	}
      }
    }

    public void scale( int axis_type, int idx, int value_type, 
		       double min_value, double max_value, boolean not_zero, boolean allow_odd) {
      double value;
      double maxval = 0;
      double minval = 0;
      int i_value;
      int n, max_n, min_n;
      int min_lines = 0;
      int max_lines = 0;
      boolean min_zero, max_zero;
      int format_int, format_dec;
      int trendlinequot = 2;
      int axlinequot = 2;
      int axvaluequot = 2;
      double axis_width = 0;
      String format = new String();
      
      time_format = eTimeFormat_Float;

      // Scale 0 - 10 for boolean
      if ( value_type == Pwr.eType_Boolean) {
	maxval = 10;
	minval = 0;
	i_value = 10;
	max_lines = i_value;
	min_lines = 0;
	n = 0;
      }
      else {      
	n = 0;
	if ( (type == eDataType_LogFile || type == eDataType_DsTrend || 
	      type == eDataType_MultiTrend) 
	     && axis_type == eAxis_x) {
	  // Time axis
	  if ( max_value - min_value < 300) {
	    i_value = (int)(max_value + 1);
	    maxval = i_value;
	    max_lines = i_value;
	    
	    if ( min_value == 0)
	      i_value = 0;
	    else
	      i_value = (int)(min_value - 1);
	    minval = i_value;
	    min_lines = i_value;
	  }
	  else if ( max_value - min_value < 1000) {
	    i_value = (int)(max_value/10) * 10 + 10;
	    maxval = i_value;
	    max_lines = i_value / 10;
	    
	    if ( min_value == 0)
	      i_value = 0;
	    else
	      i_value = (int)(min_value/10) * 10 - 10;
	    minval = i_value;
	    min_lines = i_value / 10;
	  }
	  else if ( max_value - min_value < 3000) {
	    i_value = (int)(max_value/50) * 50 + 50;
	    maxval = i_value;
	    max_lines = i_value / 50;

	    if ( min_value == 0)
	      i_value = 0;
	    else
	      i_value = (int)(min_value/50) * 50 - 50;
	    minval = i_value;
	    min_lines = i_value / 50;
	  }
	  else if ( max_value - min_value < 10000) {
	    i_value = (int)(max_value/100) * 100 + 100;
	    maxval = i_value;
	    max_lines = i_value / 100;

	    if ( min_value == 0)
	      i_value = 0;
	    else
	      i_value = (int)(min_value/100) * 100 - 100;
	    minval = i_value;
	    min_lines = i_value / 100;
	  }
	  else if ( max_value - min_value < 30000) {
	    i_value = (int)(max_value/600) * 600 + 600;
	    maxval = i_value;
	    max_lines = i_value / 60;

	    if ( min_value == 0)
	      i_value = 0;
	    else
	      i_value = (int)(min_value/60) * 60 - 60;
	    minval = i_value;
	    min_lines = i_value / 60;
	    time_format = eTimeFormat_HourMinute;
	    trendlinequot = 2;
	    axlinequot = 10;
	    axvaluequot = 10;
	  }
	  else if ( max_value - min_value < 60000) {
	    i_value = (int)(max_value/600) * 600 + 600;
	    maxval = i_value;
	    max_lines = i_value / 600;

	    if ( min_value == 0)
	      i_value = 0;
	    else
	      i_value = (int)(min_value/600) * 600 - 600;
	    minval = i_value;
	    min_lines = i_value / 600;
	    axlinequot = 6;
	    axvaluequot = 2;
	    time_format = eTimeFormat_HourMinute;
	  }
	  else if ( max_value - min_value < 140000) {
	    i_value = (int)(max_value/600) * 600 + 600;
	    maxval = i_value;
	    max_lines = i_value / 600;

	    if ( min_value == 0)
	      i_value = 0;
	    else
	      i_value = (int)(min_value/600) * 600 - 600;
	    minval = i_value;
	    min_lines = i_value / 600;
	    axlinequot = 6;
	    axvaluequot = 12;
	    time_format = eTimeFormat_HourMinute;
	  }
	  else {
	    i_value = (int)(max_value/3600) * 3600 + 3600;
	    maxval = i_value;
	    max_lines = i_value / 3600;
	    
	    if ( min_value == 0)
	      i_value = 0;
	    else
	      i_value = (int)(min_value/3600) * 3600 - 3600;
	    minval = i_value;
	    min_lines = i_value / 3600;
	    axlinequot = 2 * (int)((max_value - min_value)/140000);
	    axvaluequot = 2 * (int)((max_value - min_value)/140000);
	    time_format = eTimeFormat_DayHour;
	  }
	}
	else {
	  min_zero = false;
	  max_zero = false;

	  // Power for max_value
	  if ( (max_value <= 0 && !not_zero) ||
	       max_value == 0) {
	    maxval = 0;
	    max_lines = 0;
	    max_n = 0;
	    max_zero = true;
	  }
	  else {
	    value = Math.abs(max_value);
	    n = 0;
	    if ( value >= 1) {
	      while ( value / 10 > 1) {
		value = value / 10;
		n++;
	      }
	      max_n = n;
	    }
	    else {
	      while ( value * 10 < 10) {
		value = value * 10;
		n++;
	      }
	      max_n = -n;
	    }
	  }

	  // Power for min_value
	  if ( (min_value >= 0  && !not_zero) ||
	       min_value == 0) {
	    minval = 0;
	    min_lines = 0;
	    min_n = 0;
	    min_zero = true;
	  }
	  else {
	    value = Math.abs(min_value);
	    n = 0;
	    if ( value >= 1) {
	      while ( value / 10 > 1) {
		value = value / 10;
		n++;
	      }
	      min_n = n;
	    }
	    else {
	      while ( value * 10 < 10) {
		value = value * 10;
		n++;
	      }
	      min_n = -n;
	    }
	  }

	  if ( min_zero) {
	    // Use power for max_value
	    
	    i_value = (int)( max_value * Math.pow(10, -max_n)) + 1;
	    if ( Math.abs((double)(i_value-1) - max_value * Math.pow(10, -n)) < 1e-10)
	      i_value--;
	    if ( ((i_value & 1) == 1) && (i_value != 5) && !allow_odd) 
	      i_value += 1;
	    maxval = (double)(i_value) * Math.pow( 10, max_n);
	    max_lines = i_value;
	    n = max_n;
	  }
	  else if ( max_zero) {
	    // Use power for min_value

	    i_value = (int)( min_value * Math.pow(10, -min_n)) + ((min_value < 0) ? -1 : 1);
	    if ( Math.abs((double)(i_value+1) - min_value * Math.pow(10, -n)) < 1e-10)
	      i_value++;
	    if ( ((i_value & 1) == 1) && i_value != 5 && !allow_odd) 
	      i_value += 1;
	    minval = (double)(i_value) * Math.pow( 10, min_n);
	    min_lines = i_value;
	    n = min_n;
	  }
	  else {
	    // Use largest power of min and max
	    if ( max_n > min_n)
	      n = max_n;
	    else
	      n = min_n;

	    if ( max_value > 0) {
	      i_value = (int)( max_value * Math.pow(10, -n)) + 1;
	      if ( Math.abs((double)(i_value-1) - max_value * Math.pow(10, -n)) < 1e-10)
		i_value--;
	    }
	    else
	      i_value = (int)( max_value * Math.pow(10, -n));
	    if ( ((i_value & 1) == 1) && i_value != 5 && !allow_odd) 
	      i_value += 1;
	    maxval = (double)(i_value) * Math.pow( 10, n);
	    max_lines = i_value;

	    if ( min_value < 0) {
	      i_value = (int)( min_value * Math.pow(10, -n)) - 1;
	      if ( Math.abs((double)(i_value+1) - min_value * Math.pow(10, -n)) < 1e-10)
		i_value++;
	    }
	    else
	      i_value = (int)( min_value * Math.pow(10, -n));
	    if ( ((i_value & 1) == 1) && i_value != 5 && !allow_odd) 
	      i_value -= 1;
	    minval = (double)(i_value) * Math.pow( 10, n);
	    min_lines = i_value;
	  }
	}
      }

      switch ( time_format) {
      case eTimeFormat_Float:
	// Float format
	format_int = Math.abs(n) + 1;
	if ( n > 0)
	  format_dec = 0;
	else {
	  format_dec = Math.abs(n);
	  format_int++;
	}
	if ( minval < 0)
	  format_int++;
    
	format = new String( "%" + format_int + "." +  format_dec + "f");
	axis_width = 0.65 * format_int + 0.4;
	break;
      case eTimeFormat_HourMinute:
	// Hour and minute format
	format_int = Math.abs(n) + 1;
	format = new String("%2t");
	axis_width = 0.65 * format_int + 0.4;
	break;
      case eTimeFormat_DayHour:
	// Days and hour format
	format_int = Math.abs(n) + 1;
	format = new String("%3t");
	axis_width = 0.65 * format_int + 0.4;
	break;
      }
      if ( axis_type == eAxis_y) {
	y_max_value_axis[idx] = maxval;
	y_min_value_axis[idx] = minval;
	y_trend_lines[idx] = Math.abs(max_lines - min_lines) + 1;
	y_axis_lines[idx] = (y_trend_lines[idx] - 1) * trendlinequot + 1;
	y_axis_linelongq[idx] = axlinequot;
	y_axis_valueq[idx] = axvaluequot;
	y_axis_width[idx] = axis_width;
	y_format[idx] = format;
      }
      else {
	x_max_value_axis[idx] = maxval;
	x_min_value_axis[idx] = minval;
	x_trend_lines[idx] = Math.abs(max_lines - min_lines) + 1;
	x_axis_lines[idx] = (x_trend_lines[idx] - 1) * trendlinequot + 1;
	x_axis_linelongq[idx] = axlinequot;
	x_axis_valueq[idx] = axvaluequot;
	x_format[idx] = format;
      }
    }


    /*
    public void x_to_points( double x, double *t, double *values) {
      int row;
      double time;

      if ( cd->type != eDataType_MultiTrend) {
	// Time is a date
	if ( !cd->x_reverse)
	  time = cd->x_min_value_axis[0] + x *
	    (cd->x_max_value_axis[0] - cd->x_min_value_axis[0]) / 200;
	else
	  time = cd->x_min_value_axis[0] + (200.0 - x) *
	    (cd->x_max_value_axis[0] - cd->x_min_value_axis[0]) / 200;
      
	// Approximate row
	row = int ((time - cd->x_min_value[0]) / 
		   (cd->x_max_value[0] - cd->x_min_value[0]) *
		   (cd->rows[0] - 1) + 0.5);
	if ( row > cd->rows[0] - 1)
	  row = cd->rows[0] - 1;
	else if ( row < 0)
	  row = 0;
	else {
	  // Find exact row
	  double b1, b2;
	  int r = row;
	  for (int i = 0;; i++) {
	    if ( r == 0) {
	      b2 = (cd->x_data[0][row] + cd->x_data[0][r+1]) / 2;
	      if ( time < b2)
		break;
	      r++;
	    }
	    else if ( r == cd->rows[0] - 1) {
	      b1 = (cd->x_data[0][r] + cd->x_data[0][r-1]) / 2;
	      if ( time >= b1)
		break;
	      r--;
	    }
	    else {
	      b1 = (cd->x_data[0][r] + cd->x_data[0][r-1]) / 2;
	      b2 = (cd->x_data[0][r] + cd->x_data[0][r+1]) / 2;
	      if ( b1 <= time && time < b2)
		break;
	      if ( b1 <= time)
		r++;
	      else
		r--;
	    }
	    if ( i > cd->rows[0]) {
	      // Corrupt data, se original row
	      r = row;
	      break;
	    }	  
	  }
	  row = r;
	}
	for ( int i = 0; i < cd->cols; i++)
	  values[i] = cd->y_data[i][row];
      
	*t = cd->x_data[0][row];
      }
      else {
	// Time is a date
	if ( !cd->x_reverse)
	  time = cd->x_min_value_axis[0] + x *
	    (cd->x_max_value_axis[0] - cd->x_min_value_axis[0]) / 200;
	else
	  time = cd->x_min_value_axis[0] + (200.0 - x) *
	    (cd->x_max_value_axis[0] - cd->x_min_value_axis[0]) / 200;
	
	// Approximate row
	for ( int j = 0; j < cd->cols; j++) {
	  row = int ((time - cd->x_min_value[j]) / 
		     (cd->x_max_value[j] - cd->x_min_value[j]) *
		     (cd->rows[j] - 1) + 0.5);
	  if ( row > cd->rows[j] - 1)
	    row = cd->rows[j] - 1;
	  else if ( row < 0)
	    row = 0;
	  else {
	    // Find exact row
	    double b1, b2;
	    int r = row;
	    for (int i = 0;; i++) {
	      if ( r == 0) {
		b2 = (cd->x_data[j][row] + cd->x_data[j][r+1]) / 2;
		if ( time < b2)
		  break;
		r++;
	      }
	      else if ( r == cd->rows[j] - 1) {
		b1 = (cd->x_data[j][r] + cd->x_data[0][r-1]) / 2;
		if ( time >= b1)
		  break;
		r--;
	      }
	      else {
		b1 = (cd->x_data[j][r] + cd->x_data[j][r-1]) / 2;
		b2 = (cd->x_data[j][r] + cd->x_data[j][r+1]) / 2;
		if ( b1 <= time && time < b2)
		  break;
		if ( b1 <= time)
		  r++;
		else
		  r--;
	      }
	      if ( i > cd->rows[j]) {
		// Corrupt data, se original row
		r = row;
		break;
	      }
	    }
	    row = r;
	  }
	  values[j] = cd->y_data[j][row];
	  if ( j == 0)
	    *t = cd->x_data[j][row];
	}
      }
    }
    */

    void add_points( int idx, int num, double[] values) {
	for ( int i = rows[idx] - num - 1; i >= 0; i--)
	    y_data[idx][i + num] = y_data[idx][i];
	for ( int i = 0; i < num; i++)
	    y_data[idx][i] = values[i];
    }
}

