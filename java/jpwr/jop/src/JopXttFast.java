/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2012 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jop;
import java.util.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.image.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import javax.swing.table.*;
import javax.swing.border.*;
import javax.swing.Timer;
import java.net.URL;
import jpwr.rt.*;

public class JopXttFast implements ActionListener, JopCurveIfc {
    public static final int XTT_FAST_MAX = 20;
    public static final int FAST_CURVES = 10;

    public static final int mFunction_ManTrigg 		= 1;
    public static final int mFunction_LevelTrigg 	= 2;
    public static final int mFunction_BeforeTrigg 	= 4;
    public static final int mFunction_AlwaysPrepared 	= 8;
    public static final int mFunction_User 		= 16;

    JopSession session;
    JopEngine engine;
    Object root;
    Timer timer;
    JopCurve curve;
    int fast_cnt = 2;
    int min_interval_idx;
    int max_time;
    int min_interval;
    int[] interval = new int[XTT_FAST_MAX];
    int[] last_buffer = new int[XTT_FAST_MAX];
    int[] last_next_index = new int[XTT_FAST_MAX];
    JopCurveData gcd;
    int fast_tid;
    String[] buffers = new String[XTT_FAST_MAX];
    String timeBuffer;
    int[] element_type = new int[XTT_FAST_MAX];
    float[] yMinValue = new float[XTT_FAST_MAX];
    float[] yMaxValue = new float[XTT_FAST_MAX];
    boolean[] fixScale = new boolean[XTT_FAST_MAX];
    int update_time;
    String fastObject;

    int noOfPoints;
    int fastFunction;
    boolean newCurve;
    boolean oldNewCurve;

    public JopXttFast( String fastObject) {
	engine = new JopEngine( 1000, (Object)this);
	session = new JopSession( engine, (Object)this);

	this.fastObject = fastObject;
	init();
    }

    public JopXttFast( JopSession session, String fastObject) {
	this.session = session;
	engine = session.getEngine();
	
	this.fastObject = fastObject;
	init();
    }

    public void close() {
	timer.stop();
    }

    void init() {

	int i, j, k;
	int start_idx;
	int fast_buff_size = 478;

	timer = new Timer( 1000, this); 

	if ( fast_cnt == 0) {
	    System.out.println("Error in fast  configuration");
	    return;
	}

	CdhrObjid oret = engine.gdh.nameToObjid( fastObject);
	if ( oret.evenSts()) {
	    System.out.println("Error in fast  configuration");
	    return;
	}
	CdhrClassId cret = engine.gdh.getObjectClass( oret.objid);
	if ( cret.evenSts()) {
	    System.out.println("Error in fast  configuration");
	    return;
	}
	fast_tid = cret.classId;

	if ( fast_tid == Pwrb.cClass_DsFastCurve) {
	    int[] actual_data_size = new int[XTT_FAST_MAX];
	    double fmin_interval = 0;
	    int tcp_i;
	    int object_cnt = fast_cnt;    
	    float displayTime;
	    float displayUpdateTime;
	    float scanTime;
	    int noOfSample;
	    int displayResolution;
	    int timeResolution;
	    CdhrFloat fret;

	    // Get current status of the fast object

	    CdhrInt iret = engine.gdh.getObjectInfoInt( fastObject + ".NoOfPoints");
	    if ( iret.evenSts())
		return;
	    noOfPoints = iret.value;

	    iret = engine.gdh.getObjectInfoInt( fastObject + ".Function");
	    if ( iret.evenSts()) return;
	    fastFunction = iret.value;

	    CdhrBoolean bret = engine.gdh.getObjectInfoBoolean( fastObject + ".Active");
	    if ( bret.evenSts()) return;
	    boolean active = bret.value;
	    
	    CdhrString sret = engine.gdh.getObjectInfoString( fastObject + ".TimeBuffer");
	    if ( sret.evenSts()) return;
	    timeBuffer = sret.str;
	    
	    // Create data for time axis
	    gcd = new JopCurveData( JopCurveData.eDataType_DsTrend);
	    gcd.x_data[0] = new double[noOfPoints];
	    gcd.x_name = new String("Time");
	    gcd.x_axis_type[0] = JopCurveData.eAxis_x;

	    CdhrFloatArray faret;
	    if ( !active) {
		faret = engine.gdh.getObjectInfoFloatArray( timeBuffer, noOfPoints);
		if ( faret.evenSts()) {
		    System.out.println("Time buffer error, " + timeBuffer);
		    return;
		}
		for ( j = 0; j < noOfPoints; j++) {
		    gcd.x_data[0][j] = faret.value[j];	    	    		
		}	    
	    }
	    fast_cnt = 0;
	    for ( i = 0; i < FAST_CURVES; i++) {
		bret = engine.gdh.getObjectInfoBoolean( fastObject + ".CurveValid[" + i + "]");
		if ( bret.evenSts())
		    return;
		boolean curveValid = bret.value;		
		    
		if ( curveValid) {
		    gcd.y_data[fast_cnt] = new double[noOfPoints];

		    fret = engine.gdh.getObjectInfoFloat( fastObject + ".YMinValue[" + fast_cnt + "]");
		    if ( fret.evenSts()) return;
		    yMinValue[fast_cnt] = fret.value;		

		    fret = engine.gdh.getObjectInfoFloat( fastObject + ".YMaxValue[" + fast_cnt + "]");
		    if ( fret.evenSts()) return;
		    yMaxValue[fast_cnt] = fret.value;		

		    sret = engine.gdh.getObjectInfoString( fastObject + ".Attribute[" + fast_cnt + "]");
		    if ( sret.evenSts()) return;
		    String attrName = sret.str;		
		    
		    int offs = attrName.lastIndexOf('.');
		    String Unit;
		    if ( offs != -1) {
			sret = engine.gdh.getObjectInfoString( attrName.substring(0,offs) + ".Unit");
			if ( sret.oddSts())
			    Unit = sret.str;
			else
			    Unit = new String();
		    }
		    else
			Unit = new String();

		    sret = engine.gdh.getObjectInfoString( fastObject + ".Buffers[" + fast_cnt + "]");
		    if ( sret.evenSts()) return;
		    buffers[fast_cnt] = sret.str;		
		    
		    gcd.y_axis_type[fast_cnt] = JopCurveData.eAxis_y;
		    gcd.y_name[fast_cnt] = attrName;
		    gcd.rows[fast_cnt] = noOfPoints;
		    gcd.y_unit[i] = Unit;

		    if ( !active) {
			faret = engine.gdh.getObjectInfoFloatArray( buffers[fast_cnt], noOfPoints);
			if ( faret.evenSts()) {
			    System.out.println("Fast object error, " + fastObject);
			    return;
			}
			for ( j = 0; j < noOfPoints; j++)
			    gcd.y_data[fast_cnt][j] = faret.value[j];	    	    		
		    }
		    fast_cnt++;
		}
	    }
	    gcd.cols = fast_cnt;
	}

	gcd.x_reverse = true;
	gcd.get_borders();
	gcd.get_default_axis();
	gcd.select_color(false);

	for ( i = 0; i < fast_cnt; i++) {
	    if ( !(yMinValue[i] == 0F && yMaxValue[i] == 0F)) {
		fixScale[i] = true;
		gcd.scale( gcd.y_axis_type[i], i, gcd.y_value_type[i], 
			   yMinValue[i],  yMaxValue[i], false, false);
		
	    }
	}

	curve = new JopCurve( session, this, gcd);
	curve.setFillCurve(false);

	timer.start();
    }

    public void actionPerformed( ActionEvent e) {
	fast_scan();
    }

    private void fast_scan() {
	if ( fast_tid == Pwrb.cClass_DsFastCurve) {
	    int size = 0;
	    int i, j;
	    boolean active;

	    CdhrBoolean bret = engine.gdh.getObjectInfoBoolean( fastObject + ".New");
	    if ( bret.evenSts())
		return;
	    newCurve = bret.value;

	    if ( newCurve && !oldNewCurve) {
		bret = engine.gdh.getObjectInfoBoolean( fastObject + ".Active");
		if ( bret.evenSts())
		    return;
		active = bret.value;
		if ( active) return;
		
		CdhrFloatArray faret;
		faret = engine.gdh.getObjectInfoFloatArray( timeBuffer, noOfPoints);
		if ( faret.evenSts()) {
		    System.out.println("Time buffer error, " + timeBuffer);
		    return;
		}
		for ( j = 0; j < noOfPoints; j++) {
		    gcd.x_data[0][j] = faret.value[j];	    	    		
		}	    
		
		for ( i = 0; i < fast_cnt; i++) {
		    faret = engine.gdh.getObjectInfoFloatArray( buffers[i], noOfPoints);
		    if ( faret.evenSts()) {
			System.out.println("Fast object error, " + fastObject);
			return;
		    }
		    for ( j = 0; j < noOfPoints; j++)
			gcd.y_data[i][j] = faret.value[j];	    	    		

		}
		gcd.get_borders();
		gcd.get_default_axis();
		for ( i = 0; i < fast_cnt; i++) {
		    if ( fixScale[i])
			gcd.scale( gcd.y_axis_type[i], i, gcd.y_value_type[i], 
				   yMinValue[i],  yMaxValue[i], false, false);
		}
		curve.updateAxis();
	    }
	    oldNewCurve = newCurve;
	}	
    }


    public static void main(String[] args)
    {
	boolean debug = false;
	for(int i = 0; i < args.length; i++)
	    {
		if(args[i].equals("-d") || args[i].equals("-D"))
		    {
			debug = true;
		    }
	    }
	
	
	
	JopXttFast fast = new JopXttFast("H28-Fast");
    }
}

