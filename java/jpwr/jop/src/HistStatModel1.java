/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jop;
import java.util.*;
import javax.swing.table.AbstractTableModel;
import jpwr.rt.*;

/**
   Event statistics model.
   The HistStatModel1 class is used to derive how many times an Alarm has been
   set off during the interval of the search provided in a MhData.
*/

public class HistStatModel1 extends AbstractTableModel{
    static final long serialVersionUID = -3275322604785285866L;
    // The List storing the resulting statistics.
    public List<MhrEvent> result;
    //public List result;
    private String[][] freqNames={{"Object", "Nr. of alarms" },{"Objekt","Antal larm"}};
    int lang;
    
    public HistStatModel1(MhData m, int l ){
        lang=l;
	clearData();
	setData(m);
        sortData();
    }

    public void clearData(){
	result = new ArrayList<MhrEvent>(); 
	//result = new ArrayList(); 
    }
    
    public void setData(MhData m){
    /* The MhData is Stepped through. If an Alarm is found which eventName
       is not yet present in the result List, a copy of the Alarm's 
       MhrEvent is added to the result List. If an alarm is found that is 
       present in the result List the nr of times the alarm has been found
       is increased by one. The nr of times is stored in the int 
       eventFlags of each MhrEvent in the result List*/
 
    for(int i=0; i<m.eventVec.size();i++){
            boolean found=false;
            for ( int j = 0; j<result.size();j++){
                if ( m.eventVec.get(i).eventName.equals(result.get(j).eventName)){
                    if ( m.eventVec.get(i).eventType == Mh.mh_eEvent_Alarm ||
			 m.eventVec.get(i).eventType == Mh.mh_eEvent_MaintenanceAlarm ||
			 m.eventVec.get(i).eventType == Mh.mh_eEvent_SystemAlarm ||
			 m.eventVec.get(i).eventType == Mh.mh_eEvent_UserAlarm1 ||
			 m.eventVec.get(i).eventType == Mh.mh_eEvent_UserAlarm2 ||
			 m.eventVec.get(i).eventType == Mh.mh_eEvent_UserAlarm3 ||
			 m.eventVec.get(i).eventType == Mh.mh_eEvent_UserAlarm4){
                        result.get(j).eventFlags++;
                        found=true;
                    }
                }
                if (found) break;
            }
            if (! found){
		if ( m.eventVec.get(i).eventType == Mh.mh_eEvent_Alarm ||
		     m.eventVec.get(i).eventType == Mh.mh_eEvent_MaintenanceAlarm ||
		     m.eventVec.get(i).eventType == Mh.mh_eEvent_SystemAlarm ||
		     m.eventVec.get(i).eventType == Mh.mh_eEvent_UserAlarm1 ||
		     m.eventVec.get(i).eventType == Mh.mh_eEvent_UserAlarm2 ||
		     m.eventVec.get(i).eventType == Mh.mh_eEvent_UserAlarm3 ||
		     m.eventVec.get(i).eventType == Mh.mh_eEvent_UserAlarm4){
		    result.add(m.eventVec.get(i).getCopy());
		    result.get(result.size()-1).eventFlags=1;
		}
	    }      
	    
    }
    }
    
    
    public Object getValueAt(int r,int c){
        if (c==0) return result.get(r).eventName;
        else return new Integer(result.get(r).eventFlags);
    } 
    
    public int getRowCount(){
        return result.size();
    }   
    
    public int getColumnCount(){
        return freqNames.length;
    }
    
    public String getColumnName(int i){
        return freqNames[lang][i];
    }
    
    public void sortData(){
    //sortData sorts the result List. Largest number of times found first.
    
    Collections.sort(result, new Comparator<MhrEvent>(){
          public int compare(MhrEvent o1, MhrEvent o2){
        if (o1.eventFlags < o2.eventFlags) 
        return 1;
        else if (o1.eventFlags > o2.eventFlags) 
    //Collections.sort(result, new Comparator(){
    //      public int compare(Object o1, Object o2){
    //    if (((MhrEvent)o1).eventFlags < ((MhrEvent)o2).eventFlags) 
    //    return 1;
    //    else if (((MhrEvent)o1).eventFlags > ((MhrEvent)o2).eventFlags) 
        return -1;
        else return 0;
        }
        }); 
    
    }  
}
