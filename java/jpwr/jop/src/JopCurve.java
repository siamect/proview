/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2014 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jop;
import java.util.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.image.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import javax.swing.table.*;
import javax.swing.border.*;
import java.net.URL;
import jpwr.rt.*;

public class JopCurve extends JFrame implements GdhApplIfc
{

    static final int COLUMN_COLOR		= 0;
    static final int COLUMN_VIEW		= 1;
    static final int COLUMN_UNIT		= 2;
    static final int COLUMN_SCALE		= 3;
    static final int COLUMN_ATTRIBUTE    	= 4;
    static final int COLUMNS    		= 5;
    static final float ZOOM_FACTOR = 1.2F;

    JopSession session;
    JopEngine engine;
    Object root;

    private JTable names;
    private JToolBar toolbar;
    private JScrollPane chartScrollPane;
    private AxisPanel axisPanel;
    private Chart  chart;
    private Chart  navigator;
    private JopCurveAxis[] yaxis = new JopCurveAxis[JopCurveData.CURVE_MAX_COLS];
    private CurveAxis xaxis;
    private JopCurveData gcd;
    boolean fillCurve = false;
    int chartWidth = 5000;
    boolean[] viewChart;
    private JCheckBox namesCheckBox;
    String[] namesHeader = new String[] {"", "View", "Unit", "Scale", "Attribute"};
    JopCurveIfc caller;

    public JopCurve( JopSession session, JopCurveIfc caller, JopCurveData gcd) {
	this.caller = caller;
	this.gcd = gcd;

	this.session = session;
	engine = session.getEngine();

	init();
    }

    public JopCurve( JopCurveIfc caller, JopCurveData gcd) {
	this.caller = caller;
	this.gcd = gcd;

	engine = new JopEngine( 1000, this);
	session = new JopSession( engine, (Object)this);

	init();
    }

    protected void processWindowEvent(WindowEvent e) {
	super.processWindowEvent(e);
	if (e.getID() == WindowEvent.WINDOW_CLOSING) {
	    if ( caller != null)
		caller.close();
	}
    }

    public void updateChart() {
	chart.repaint();
	navigator.repaint();
    }

    public void updateAxis() {
	xaxis.setMinValue((float)gcd.x_min_value_axis[0]);
	xaxis.setMaxValue((float)gcd.x_max_value_axis[0]);
	xaxis.setMinValue((float)gcd.x_min_value_axis[0]);
	xaxis.setMaxValue((float)gcd.x_max_value_axis[0]);
	xaxis.setLines(gcd.x_axis_lines[0]);
	xaxis.setLongQuotient(gcd.x_axis_linelongq[0]);
	xaxis.setValueQuotient(gcd.x_axis_valueq[0]);
	xaxis.setFormat(gcd.x_format[0]);
	xaxis.reconfigure();
	xaxis.repaint();
	for ( int i = 0; i < gcd.cols; i++) {
	    yaxis[i].setMinValue((float)gcd.y_min_value_axis[i]);
	    yaxis[i].setMaxValue((float)gcd.y_max_value_axis[i]);
	    yaxis[i].setMinValue((float)gcd.y_min_value_axis[i]);
	    yaxis[i].setMaxValue((float)gcd.y_max_value_axis[i]);
	    yaxis[i].setLines(gcd.y_axis_lines[i]);
	    yaxis[i].setLongQuotient(gcd.y_axis_linelongq[i]);
	    yaxis[i].setValueQuotient(gcd.y_axis_valueq[i]);
	    yaxis[i].setFormat(gcd.y_format[i]);
	    yaxis[i].reconfigure();
	    yaxis[i].repaint();
	}
	chart.setVerticalLines(gcd.x_trend_lines[0]-2);
	chart.setHorizontalLines(gcd.y_trend_lines[0]-2);
	chart.repaint();
	navigator.repaint();
    }


    public void init() {
	Dimension size = new Dimension( 1200, 900);
	setPreferredSize(size);
	//addWindowListener( new BasicWindowMonitor());

	JPanel panel1 = new JPanel(new BorderLayout());
	JPanel panel2 = new JPanel(new BorderLayout());
	JPanel panel3 = new JPanel(new BorderLayout());

	panel1.setMinimumSize(new Dimension(20, 20));
	panel2.setMinimumSize(new Dimension(20, 20));
	panel3.setMinimumSize(new Dimension(20, 20));

	init_toolbar();
	init_names();
	init_chart();
	xaxis = new CurveAxis();
	xaxis.setBounds(new Rectangle(0,0,chartWidth,30));
	// xaxis.setFixHeight(30);
	xaxis.setBorderColor(0);
	xaxis.setTextColor(0);
	xaxis.setMinValue((float)gcd.x_min_value_axis[0]);
	xaxis.setMaxValue((float)gcd.x_max_value_axis[0]);
	xaxis.setLines(gcd.x_axis_lines[0]);
	xaxis.setLongQuotient(gcd.x_axis_linelongq[0]);
	xaxis.setValueQuotient(gcd.x_axis_valueq[0]);
	xaxis.setLineLength(15);
	xaxis.setLineWidth(1);
	xaxis.setRotate(270);
	xaxis.setFont(new Font("Helvetica", Font.PLAIN, 14));
	xaxis.setFormat(gcd.x_format[0]);

	for ( int i = 0; i < gcd.cols; i++) {
	    yaxis[i] = new JopCurveAxis();
	    yaxis[i].setBounds(new Rectangle( i*40, 0, 40, 700));
	    // yaxis[i].setFixHeight(30);
	    yaxis[i].setFillColor(gcd.axiscolor[i]);
	    yaxis[i].setBorderColor(0);
	    yaxis[i].setTextColor(0);
	    yaxis[i].setMinValue((float)gcd.y_min_value_axis[i]);
	    yaxis[i].setMaxValue((float)gcd.y_max_value_axis[i]);
	    yaxis[i].setLines(gcd.y_axis_lines[i]);
	    yaxis[i].setLongQuotient(gcd.y_axis_linelongq[i]);
	    yaxis[i].setValueQuotient(gcd.y_axis_valueq[i]);
	    yaxis[i].setLineLength(15);
	    yaxis[i].setLineWidth(1);
	    yaxis[i].setRotate(180);
	    yaxis[i].setFont(new Font("Helvetica", Font.PLAIN, 12));
	    yaxis[i].setFormat(gcd.y_format[i]);
	    yaxis[i].setOpaque(true);
	}

	init_navigator();

	JScrollPane scp1 = new JScrollPane(names);
	panel1.add(scp1);

	// Y axes
        axisPanel = new AxisPanel();

	Dimension dsize = new Dimension( gcd.cols * 40, 700);
	axisPanel.setSize(dsize);
	// axisPanel.addComponentListener(new AspectRatioListener(this, dsize));
	axisPanel.setLayout( new JopCurveAxisLayout());
	for ( int i = 0; i < gcd.cols; i++) {
	    axisPanel.add( yaxis[i]);
	}

	// Scrolled chart
	ChartPanel panel4 = new ChartPanel();
	panel4.setLayout( new JopCurveChartLayout());
	panel4.add( chart);
	panel4.add( xaxis);
    
	chartScrollPane = new JScrollPane(panel4);
	chartScrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);
	chartScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
	chartScrollPane.setBounds(new Rectangle( gcd.cols*40, 0, 1000, 700));
	axisPanel.add( chartScrollPane);
	panel2.add( axisPanel);

	panel3.add( navigator);

	JSplitPane sp1 = new JSplitPane(JSplitPane.VERTICAL_SPLIT, false, panel1, panel2);
	sp1.setOneTouchExpandable(true);
	sp1.setDividerLocation(150);
	JSplitPane sp2 = new JSplitPane(JSplitPane.VERTICAL_SPLIT, false, sp1, panel3);
	sp2.setOneTouchExpandable(true);
	sp2.setDividerLocation(750);

	this.getContentPane().add(toolbar, BorderLayout.NORTH);
	this.getContentPane().add(sp2, BorderLayout.CENTER);

	setTitle(JopLang.transl("Curve"));
	enableEvents(AWTEvent.WINDOW_EVENT_MASK);

	pack();
	setVisible(true);

	if ( gcd.type == JopCurveData.eDataType_DsTrend) {
	    JScrollBar sb = chartScrollPane.getHorizontalScrollBar();
	    int value = sb.getMaximum();
	    sb.setValue( value);
	}
    }

    public void init_toolbar()
    {
	toolbar = new JToolBar("Curve toolbar");
	MenuAction zoomInAction = new MenuAction("Zoom In", new ImageIcon( JopSpider.getImage( session, "jpwr/jop/xtt_zoom_in.png")));
	MenuAction zoomOutAction = new MenuAction("Zoom Out", new ImageIcon( JopSpider.getImage( session, "jpwr/jop/xtt_zoom_out.png")));
	MenuAction zoomResetAction = new MenuAction("Zoom Reset", new ImageIcon( JopSpider.getImage( session, "jpwr/jop/xtt_zoom_reset.png")));
	MenuAction pageLeftAction = new MenuAction("Page Left", new ImageIcon( JopSpider.getImage( session, "jpwr/jop/ge_page_left.png")));
	MenuAction scrollLeftAction = new MenuAction("Scroll Left", new ImageIcon( JopSpider.getImage( session, "jpwr/jop/ge_scroll_left.png")));
	MenuAction scrollRightAction = new MenuAction("Scroll Right", new ImageIcon( JopSpider.getImage( session, "jpwr/jop/ge_scroll_right.png")));
	MenuAction pageRightAction = new MenuAction("Page Right", new ImageIcon( JopSpider.getImage( session, "jpwr/jop/ge_page_right.png")));
	JButton button;

	button = toolbar.add(zoomInAction);
	button.setActionCommand((String)zoomInAction.getValue(Action.NAME));
	button.setToolTipText((String)zoomInAction.getValue(Action.NAME));

	button = toolbar.add(zoomOutAction);
	button.setActionCommand((String)zoomOutAction.getValue(Action.NAME));
	button.setToolTipText((String)zoomOutAction.getValue(Action.NAME));

	button = toolbar.add(zoomResetAction);
	button.setActionCommand((String)zoomResetAction.getValue(Action.NAME));
	button.setToolTipText((String)zoomResetAction.getValue(Action.NAME));

	button = toolbar.add(pageLeftAction);
	button.setActionCommand((String)pageLeftAction.getValue(Action.NAME));
	button.setToolTipText((String)pageLeftAction.getValue(Action.NAME));

	button = toolbar.add(scrollLeftAction);
	button.setActionCommand((String)scrollLeftAction.getValue(Action.NAME));
	button.setToolTipText((String)scrollLeftAction.getValue(Action.NAME));

	button = toolbar.add(scrollRightAction);
	button.setActionCommand((String)scrollRightAction.getValue(Action.NAME));
	button.setToolTipText((String)scrollRightAction.getValue(Action.NAME));

	button = toolbar.add(pageRightAction);
	button.setActionCommand((String)pageRightAction.getValue(Action.NAME));
	button.setToolTipText((String)pageRightAction.getValue(Action.NAME));
    }


    JButton button = new JButton();
    int currentNamesScale = 0;

    public void init_names() {

	viewChart = new boolean[gcd.cols];
	for ( int i = 0; i < gcd.cols; i++)
	    viewChart[i] = true;

	TableModel model=new NamesTableModel(gcd.cols, COLUMNS);

	names =new JTable( model );
	names.getColumnModel().getColumn(COLUMN_COLOR).setCellRenderer(new NamesTableCellRenderer());
	names.setColumnSelectionAllowed( false);
	names.getTableHeader().setReorderingAllowed(false);
	names.setRowSelectionAllowed( false);
	names.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
	names.getColumnModel().getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);

	names.getColumnModel().getColumn(COLUMN_COLOR).setPreferredWidth( 30);
	names.getColumnModel().getColumn(COLUMN_VIEW).setPreferredWidth( 40);
	names.getColumnModel().getColumn(COLUMN_UNIT).setPreferredWidth( 70);
	names.getColumnModel().getColumn(COLUMN_SCALE).setPreferredWidth( 40);
	names.getColumnModel().getColumn(COLUMN_ATTRIBUTE).setPreferredWidth( 1000);
	names.setAutoResizeMode( JTable.AUTO_RESIZE_OFF);
	names.setIntercellSpacing( new Dimension( 10, 2));

	names.getColumnModel().getColumn(COLUMN_SCALE).setCellRenderer(new NamesButtonRenderer());
	names.getColumnModel().getColumn(COLUMN_SCALE).setCellEditor(new NamesButtonEditor(new JCheckBox()));
	button.addActionListener(
				 new ActionListener()
				 {
				     public void actionPerformed(ActionEvent event)
				     {
					 maxMinDialog( currentNamesScale);
				     }
				 }
				 );
    }

    void maxMinDialog( int col) {
	JTextField minField = new JTextField( String.format( "%f", gcd.y_min_value_axis[col]));
	JTextField maxField = new JTextField( String.format( "%f", gcd.y_max_value_axis[col]));
	JPanel maxMinPanel = new JPanel();
	maxMinPanel.add(new JLabel("MinValue"));
	maxMinPanel.add(minField);
	maxMinPanel.add(Box.createHorizontalStrut(15)); // a spacer
	maxMinPanel.add(new JLabel("MaxValue"));
	maxMinPanel.add(maxField);
        int result = JOptionPane.showConfirmDialog(null, maxMinPanel, 
						   "Axis Limits", JOptionPane.OK_CANCEL_OPTION);

	if (result == JOptionPane.OK_OPTION) {
	    float minValue = new Float( minField.getText()).floatValue();
	    float maxValue = new Float( maxField.getText()).floatValue();

	    gcd.scale( gcd.y_axis_type[col], col, gcd.y_value_type[col], 
		       minValue,  maxValue, false, false);

	    yaxis[col].setMinValue((float)gcd.y_min_value_axis[col]);
	    yaxis[col].setMaxValue((float)gcd.y_max_value_axis[col]);
	    yaxis[col].setMinValue((float)gcd.y_min_value_axis[col]);
	    yaxis[col].setMaxValue((float)gcd.y_max_value_axis[col]);
	    yaxis[col].setLines(gcd.y_axis_lines[col]);
	    yaxis[col].setLongQuotient(gcd.y_axis_linelongq[col]);
	    yaxis[col].setValueQuotient(gcd.y_axis_valueq[col]);
	    yaxis[col].reconfigure();
	    yaxis[col].repaint();
	    updateChart();
	}
    }

    class NamesButtonRenderer extends JButton implements TableCellRenderer {
	public NamesButtonRenderer() {
	    setOpaque(true);
	}
	public Component getTableCellRendererComponent(JTable table, Object value,
						       boolean isSelected, boolean hasFocus, int row, int column) {
	    setText((value == null) ? "" : value.toString());
	    return this;
	}
    }
    class NamesButtonEditor extends DefaultCellEditor {
	private String label;
	public NamesButtonEditor(JCheckBox checkBox) {
	    super(checkBox);
	}

	public Component getTableCellEditorComponent(JTable table, Object value,
						     boolean isSelected, int row, int column) {
	    label = (value == null) ? "" : value.toString();
	    currentNamesScale = row;
	    button.setText(label);
	    return button;
	}
	public Object getCellEditorValue() {
	    return new String(label);
	}
    }

    public class NamesTableCellRenderer extends DefaultTableCellRenderer {
	public Component getTableCellRendererComponent(JTable table,
						       Object value,
						       boolean isSelected,
						       boolean hasFocus,
						       int row,
						       int column) {
	    Component c = 
		super.getTableCellRendererComponent(table, value,
						    isSelected, hasFocus,
						    row, column);

	    if ( column == COLUMN_COLOR) 
		c.setBackground( GeColor.getColor( 0, gcd.color[row]));
	    return c;
	}
    }

    class NamesTableModel extends AbstractTableModel {   
  
	public NamesTableModel(int rows, int cols){   
	    super();
	}   
  
	public int getColumnCount() {          
	    return COLUMNS;   
	}   
  
	public int getRowCount() {         
	    return gcd.cols;   
	}   
  
	public Object getValueAt(int row, int column) {   
	    switch ( column) {
	    case COLUMN_COLOR:
		return new String("");
	    case COLUMN_VIEW:
		return viewChart[row];
	    case COLUMN_UNIT:
		return gcd.y_unit[row];
	    case COLUMN_SCALE:
		return new String("");
	    case COLUMN_ATTRIBUTE:
		return gcd.y_name[row];
	    default:
		return null;   
	    }
	}   
  
	public Class<?> getColumnClass(int columnIndex) {   
	    if(columnIndex == COLUMN_VIEW) {   
		return Boolean.class;   
	    }   
	    return String.class;   
	}   
  
	public void setValueAt(Object aValue, int rowIndex, int columnIndex) {   
	    if(columnIndex == COLUMN_VIEW){   
		boolean view = (Boolean)aValue;   
		viewChart[rowIndex] = view;
		chart.repaint();
		navigator.repaint();
	    }   
	    super.setValueAt(aValue, rowIndex, columnIndex);   
	}   
  
	public String getColumnName(int column) {
	    return namesHeader[column];
	}   
  
	public boolean isCellEditable(int rowIndex, int columnIndex) {   
	    if( columnIndex == COLUMN_VIEW){   
		return true;   
	    }   
	    else if( columnIndex == COLUMN_SCALE){   
		return true;   
	    }   
	    return super.isCellEditable(rowIndex, columnIndex);   
	}      
	
    }   

    
    public void init_chart() {
	chart = new Chart();
	chart.setVerticalLines(gcd.x_trend_lines[0]-2);
	chart.setHorizontalLines(gcd.y_trend_lines[0]-2);
	chart.setFixWidth(chartWidth);
    }

    public void init_navigator() {
	navigator = new Chart();
	navigator.setVerticalLines(gcd.x_trend_lines[0]-2);
	navigator.setHorizontalLines(gcd.y_trend_lines[0]-2);
    }

    public void setFillCurve( boolean fillCurve) {
	this.fillCurve = fillCurve;
    }

    private class NamesViewAction extends AbstractAction {
	public NamesViewAction( String text, Icon icon) {
	    super( text, icon);
	}
	public void actionPerformed( ActionEvent e) {
	    int idx = Integer.parseInt( e.getActionCommand());

	    viewChart[idx] = !viewChart[idx];
	}
    }


    // Time task used to adjust scroll value for zoom in when the scroll value is larger
    // than the old maximum value.
    // This has to be done in a timer task as the revalidation doesn't have immediate effect.
    java.util.Timer timer;
    int scrollValue;
    class ScrollSet extends TimerTask {
	public void run() {
	    JScrollBar sb = chartScrollPane.getHorizontalScrollBar();
	    int value = sb.getValue();
	    int extent = sb.getVisibleAmount();
	    float new_value = ZOOM_FACTOR * value + (ZOOM_FACTOR - 1) * extent / 2;
	    sb.setValue( scrollValue);
	}
    }

    private class MenuAction extends AbstractAction {
	public MenuAction( String text, Icon icon) {
	    super( text, icon);
	}
	public void actionPerformed( ActionEvent e) {

	    if ( e.getActionCommand() == "Zoom In") {
		JScrollBar sb = chartScrollPane.getHorizontalScrollBar();
		int value = sb.getValue();
		int extent = sb.getVisibleAmount();

		chartWidth *= ZOOM_FACTOR;
		Dimension d = chartScrollPane.getSize();
		xaxis.setBounds(new Rectangle(0,d.height - JopCurveChartLayout.AXIS_HEIGHT, chartWidth,30));
		chart.setFixWidth(chartWidth);
		chart.setVerticalLines(gcd.x_trend_lines[0]-2);
		chart.setHorizontalLines(gcd.y_trend_lines[0]-2);
		chart.repaint();
		axisPanel.revalidate();
		float new_value = ZOOM_FACTOR * value + (ZOOM_FACTOR - 1) * extent / 2;
		sb.setValue( (int)new_value);
		if ( new_value + extent > chartWidth / ZOOM_FACTOR) {
		    // Maximum value is not changed yet, and a value > old width can't be set.
		    scrollValue = (int)new_value;
		    timer = new java.util.Timer();
		    timer.schedule( new ScrollSet(), 1);
		}
	    }
	    else if ( e.getActionCommand() == "Zoom Out") {
		JScrollBar sb = chartScrollPane.getHorizontalScrollBar();
		int value = sb.getValue();
		int extent = sb.getVisibleAmount();
		chartWidth /= ZOOM_FACTOR;
		Dimension d = chartScrollPane.getSize();
		xaxis.setBounds(new Rectangle(0,d.height - JopCurveChartLayout.AXIS_HEIGHT, chartWidth,30));
		chart.setFixWidth(chartWidth);
		chart.setVerticalLines(gcd.x_trend_lines[0]-2);
		chart.setHorizontalLines(gcd.y_trend_lines[0]-2);
		chart.repaint();
		axisPanel.revalidate();
		float new_value = 1F/ZOOM_FACTOR * value + (1F/ZOOM_FACTOR - 1) * extent / 2;
		sb.setValue( (int)new_value);
	    }
	    else if ( e.getActionCommand() == "Zoom Reset") {
		chartWidth = 5000;
		Dimension d = chartScrollPane.getSize();
		xaxis.setBounds(new Rectangle(0,d.height - JopCurveChartLayout.AXIS_HEIGHT, chartWidth,30));
		chart.setFixWidth(chartWidth);
		// chartScrollPane.setPreferredSize( new Dimension( chartWidth, chartScrollPane.getHeight()));
		chart.setVerticalLines(gcd.x_trend_lines[0]-2);
		chart.setHorizontalLines(gcd.y_trend_lines[0]-2);
		chart.repaint();
		axisPanel.revalidate();
		JScrollBar sb = chartScrollPane.getHorizontalScrollBar();
	    }
	    else if ( e.getActionCommand() == "Page Left") {
		JScrollBar sb = chartScrollPane.getHorizontalScrollBar();
		int value = sb.getValue();
		sb.setValue( value - sb.getVisibleAmount());	   
	    }
	    else if ( e.getActionCommand() == "Scroll Left") {
		JScrollBar sb = chartScrollPane.getHorizontalScrollBar();
		int value = sb.getValue();
		sb.setValue( value - 100);	   
	    }
	    else if ( e.getActionCommand() == "Scroll Right") {
		JScrollBar sb = chartScrollPane.getHorizontalScrollBar();
		int value = sb.getValue();
		sb.setValue( value + 100);	   
	    }
	    else if ( e.getActionCommand() == "Page Right") {
		JScrollBar sb = chartScrollPane.getHorizontalScrollBar();
		int value = sb.getValue();
		sb.setValue( value + sb.getVisibleAmount());	   
	    }

	}
    }

    private class CurveAxis extends JopAxis 
    {
	public CurveAxis() { super(); };
	public Dimension getMininumSize() { return getPreferredSize();}
	public Dimension getMaxinumSize() { return getPreferredSize();}
	public Dimension getPreferredSize() { return new Dimension( chartWidth, 40);}
    }

    private class AxisPanel extends JPanel
    {
	int origHeight = 0;
      
	public AxisPanel() { super(); }
	public void paintComponent(Graphics g1) {
	    super.paintComponent(g1);
	    int h = getHeight();
	    Graphics2D g = (Graphics2D) g1;
	    Component c;

	}

	public Dimension getPreferredSize() {
	    float height = getParent().getHeight();
	    float width = getWidth();
	    return new Dimension( (int)width, (int)height);      
	}
    }

    private class ChartPanel extends JPanel
    {
	int origHeight = 0;
      
	public ChartPanel() { super(); }
	public void paintComponent(Graphics g1) {
	    super.paintComponent(g1);
	    Graphics2D g = (Graphics2D) g1;
	    Component c;
	    for ( int i = 0; i < getComponentCount(); i++) {
		c = getComponent(i);
		c.paint(g);
	    }
	}
	public Dimension getPreferredSize() {
	    float height = getParent().getHeight();
	    return new Dimension( chartWidth, (int)height);      
	}

    }

    private class Chart extends JComponent
    {
	public Chart() {}

	Shape[] lineShapes;
	float original_width = 0;
	float original_height = 0;
	float oldWidth;
	float oldHeight;
	float fixWidth = 0;
	boolean update = true;
	boolean updateLines = true;
	int verticalLines = 0;
	int horizontalLines = 0;
	int lineColor = GeColor.COLOR_37;
	int fillColor = GeColor.COLOR_39;
	int borderColor = 9999;

	public void setVerticalLines( int verticalLines) {
	    this.verticalLines = verticalLines;
	    updateLines = true;
	}
	public void setHorizontalLines( int horizontalLines) {
	    this.horizontalLines = horizontalLines;
	    updateLines = true;
	}
	public void setFixWidth( float fixWidth) {
	    this.fixWidth = fixWidth;
	    float height = getHeight();
	    //setSize(new Dimension((int)fixWidth, (int)height));
	    setBounds(new Rectangle(0,0,(int)fixWidth,(int)height));
	}

	public Dimension getPreferredSize() {
	    if ( fixWidth == 0)
		return super.getPreferredSize();

	    float height = getHeight();
	    return new Dimension((int)fixWidth, (int)height);      
	}
	public void paint(Graphics g1) {
	    super.paint(g1);
	    Graphics2D g = (Graphics2D)g1;
	    float width = getWidth();
	    float height = getHeight();
	    AffineTransform save = g.getTransform();
	    int i;
	    int j;
	    boolean updateSize = false;
	    GeneralPath[] path = new GeneralPath[gcd.cols];
	
	    if ( original_width == 0 && original_height == 0) {
		original_width = width;
		original_height = height;
	    }
	    if ( updateLines) {
		lineShapes = new Shape[1 + horizontalLines + verticalLines];
		updateLines = false;
	    }

	    if ( fixWidth == 0) {
		if ( oldWidth != width || oldHeight != height) {
		    oldWidth = width;
		    oldHeight = height;
		    updateSize = true;
		}
	    }
	    else {
		width = fixWidth;
		if ( oldHeight != height) {
		    oldWidth = width;
		    oldHeight = height;
		    updateSize = true;
		}
	    }

	    if ( updateSize || lineShapes[0] == null) {
		lineShapes[0] = new Rectangle2D.Float( 0F, 0F, width, height);
		for ( i = 0; i < verticalLines; i++)
		    lineShapes[1+i] = new Line2D.Float( width / (verticalLines + 1) * (i+1), 0F, 
							width / (verticalLines + 1) * (i+1), height);
		for ( i = 0; i < horizontalLines; i++)
		    lineShapes[1+verticalLines+i] = new Line2D.Float( 0F, height / (horizontalLines + 1) * (i+1),
								      width, height / (horizontalLines + 1) * (i+1));
	    }

	    //g.transform( AffineTransform.getScaleInstance( width/original_width,
	    //						   height/original_height));

	    g.setColor(GeColor.getColor( 0, fillColor)); 
	    g.fill( lineShapes[0]);

	    g.setColor(GeColor.getColor(0, lineColor));
	    for ( i = 0; i < verticalLines; i++)
		g.draw( lineShapes[1+i]);
	    for ( i = 0; i < horizontalLines; i++)
		g.draw( lineShapes[1+verticalLines+i]);

	    for ( j = 0; j < gcd.cols; j++) {
		if ( !viewChart[j])
		    continue;
		path[j] = new GeneralPath(GeneralPath.WIND_EVEN_ODD);
		path[j].reset();
		if ( gcd.x_reverse) {
		    path[j].moveTo(width - (gcd.x_data[0][0] - gcd.x_min_value_axis[0]) * width / (gcd.x_max_value_axis[0] - gcd.x_min_value_axis[0]), height);

		    for ( i = 0; i < gcd.rows[j]; i++) {
			path[j].lineTo( width - (gcd.x_data[0][i] - gcd.x_min_value_axis[0]) * width / (gcd.x_max_value_axis[0] - gcd.x_min_value_axis[0]), 
					height - (gcd.y_data[j][i] - gcd.y_min_value_axis[j]) * height / (gcd.y_max_value_axis[j] - gcd.y_min_value_axis[j]));
			// System.out.println( "(" + (width - (gcd.x_data[0][i] - gcd.x_min_value_axis[0]) * width / (gcd.x_max_value_axis[0] - gcd.x_min_value_axis[0])) + "," + (height - (gcd.y_data[j][i] - gcd.y_min_value_axis[j]) * height / (gcd.y_max_value_axis[j] - gcd.y_min_value_axis[j])) + ")  y:" + gcd.y_data[j][i]);
		    }
		    path[j].lineTo( width - (gcd.x_data[0][gcd.rows[j]-1] - gcd.x_min_value_axis[0]) * width / (gcd.x_max_value_axis[0] - gcd.x_min_value_axis[0]), height);
		}
		else {
		    path[j].moveTo((gcd.x_data[0][0] - gcd.x_min_value_axis[0]) * width / (gcd.x_max_value_axis[0] - gcd.x_min_value[0]), height);

		    for ( i = 0; i < gcd.rows[j]; i++)
			path[j].lineTo( (gcd.x_data[0][i] - gcd.x_min_value_axis[0]) * width / (gcd.x_max_value_axis[0] - gcd.x_min_value[0]), 
					height - (gcd.y_data[j][i] - gcd.y_min_value_axis[j]) * height / (gcd.y_max_value_axis[j] - gcd.y_min_value_axis[j]));
		    path[j].lineTo( (gcd.x_data[0][gcd.rows[j]-1] - gcd.x_min_value_axis[0]) * width / (gcd.x_max_value_axis[0] - gcd.x_min_value[0]), height);
		}
	    }

	    if ( fillCurve) {
		for ( j = 0; j < gcd.cols; j++) {
		    if ( !viewChart[j])
			continue;
		    g.setColor(GeColor.getColor(0, gcd.fillcolor[j]));
		    g.fill( path[j]);
		}
	    }
	    for ( j = 0; j < gcd.cols; j++) {
		if ( !viewChart[j])
		    continue;
		g.setColor(GeColor.getColor(0, gcd.color[j]));
		g.setStroke( new BasicStroke(1F));
		g.draw( path[j]);
	    }

	    g.setColor(GeColor.getColor(0, borderColor));
	    g.draw( lineShapes[0]);
    
	    //g.setTransform(save);
	}
    }

    public static void main(String[] args)
    {
	boolean debug = false;
	for(int i = 0; i < args.length; i++)
	    {
		if(args[i].equals("-d") || args[i].equals("-D"))
		    {
			debug = true;
		    }
	    }

	JopCurveData gcd = new JopCurveData();
	gcd.cols = 3;
	gcd.y_name[0] = new String("H1-Av1.ActualValue");
	gcd.y_name[1] = new String("H2-Av1.ActualValue");
	gcd.y_name[2] = new String("H3-Av1.ActualValue");
	gcd.y_unit[0] = new String("m/s");
	gcd.y_unit[1] = new String("%");
	gcd.y_unit[2] = new String("mm");
	for ( int j = 0; j < 3; j++) {
	    gcd.rows[j] = 100;
	    gcd.x_data[j] = new double[gcd.rows[j]];
	    gcd.y_data[j] = new double[gcd.rows[j]];
	    for ( int i = 0; i < gcd.rows[j]; i++) {
		gcd.x_data[j][i] = i;
		if ( j == 0)
		    gcd.y_data[j][i] = Math.sin(2F * i / 20);
		else if ( j == 1)
		    gcd.y_data[j][i] = 5 * Math.cos(2F * i / 20);
		else if ( j == 2)
		    gcd.y_data[j][i] = - 20 * Math.sin(2F * i / 20);
	    }
	    gcd.x_axis_type[j] = JopCurveData.eAxis_x;
	    gcd.y_axis_type[j] = JopCurveData.eAxis_y;
	}

	gcd.type = JopCurveData.eDataType_DsTrend;
	gcd.x_reverse = true;
	gcd.get_borders();
	gcd.get_default_axis();
	gcd.select_color(false);

	for ( int j = 0; j < gcd.cols; j++) {
	    System.out.println("gcd.y_max_value " + j + "  " + gcd.y_max_value_axis[j]);
	    System.out.println("gcd.y_min_value " + j + "  " + gcd.y_min_value_axis[j]);
	    System.out.println("gcd.x_max_value " + j + "  " + gcd.x_max_value_axis[j]);
	    System.out.println("gcd.x_min_value " + j + "  " + gcd.x_min_value_axis[j]);
	}

	JopCurve frame = new JopCurve(null, gcd);
	frame.setFillCurve(false);

	for ( int j = 0; j < 10; j++) {
	    try {
		Thread.sleep(2000);
	    }
	    catch ( InterruptedException e) {
	    }
	    System.out.println( "Woke upp");
	    gcd.add_points( 1, 2, new double[] {0.6,5.4});
	    frame.updateChart();
	}
	

    }

    // GdhApplIfc function
    public String getPwrHost() {
	return (String)null;
    }
}

