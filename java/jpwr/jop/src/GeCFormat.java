/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jop;
import java.text.*;

/**
   String formating with c-printf format.
*/
public class GeCFormat {
    public GeCFormat( String format) {
      int f_idx, p_idx;
    
      try {
        if ( (f_idx = format.indexOf('o')) != -1) {
	  if ( f_idx >= 1 && format.charAt(f_idx-1) == '1')
	    format_type = FRM_1O;
	  else if ( f_idx >= 1 && format.charAt(f_idx-1) == '2')
	    format_type = FRM_2O;
	  else
	    format_type = FRM_O;
	}
        else if ( (f_idx = format.indexOf('t')) != -1) {
	  if ( f_idx >= 1 && format.charAt(f_idx-1) == '1')
	    format_type = FRM_1T;
	  else if ( f_idx >= 1 && format.charAt(f_idx-1) == '2')
	    format_type = FRM_2T;
	  else if ( f_idx >= 1 && format.charAt(f_idx-1) == '3')
	    format_type = FRM_3T;
	  else
	    format_type = FRM_T;
	}
        else if ( (f_idx = format.indexOf('m')) != -1) {
	  if ( f_idx >= 1 && format.charAt(f_idx-1) == '1')
	    format_type = FRM_1M;
	  else
	    format_type = FRM_M;
	}
	else
	  pfo = new PrintfFormat( format);
      }
      catch ( NumberFormatException e) {
        System.out.println( "NumberFormatException: " + format);
        h = -1;
      }
    }
    int d;
    int h;
    int no_space = 0;
    int format_type;
    PrintfFormat pfo;

    public static final int FRM_S  = 0;  // String
    public static final int FRM_O  = 1;  // Objid object name
    public static final int FRM_1O = 2;  // Objid path
    public static final int FRM_2O = 3;  // Objid volume and path
    public static final int FRM_T  = 4;   // Time, date and time
    public static final int FRM_1T = 5;  // Time, only time, no hundredth
    public static final int FRM_2T = 6;  // Time, only time with hundreth
    public static final int FRM_3T = 7;  // Time, commpressed date and time, no hundredth
    public static final int FRM_M  = 8;  // Message
    public static final int FRM_1M = 9;  // Message, text only
    public static final int FRM_D  = 10; // Integer
    public static final int FRM_F  = 11; // Float


    public int type() {
      return format_type;
    }
    public StringBuffer format( float value, StringBuffer buff) {
      if ( pfo != null) {
	try {
          return pfo.sprintf( value, buff);
        }
	catch ( IllegalArgumentException e) {
	  buff.setLength(0);
	  buff.append("format error");
	  return buff;
	}
      }
      else 
        return buff;
    }
    public StringBuffer format( int value, StringBuffer buff) {
      if ( pfo != null) {
	try {
          return pfo.sprintf( value, buff);
        }
	catch ( IllegalArgumentException e) {
	  buff.setLength(0);
	  buff.append("format error");
	  return buff;
	}
      }
      else 
        return buff;
    }

    public StringBuffer format( boolean value, StringBuffer buff) {
      buff.setLength(0);
      if ( value)
        buff.append('1');
      else
	buff.append('0');
      return buff;
    }

    public StringBuffer format( String value, StringBuffer buff) {
      switch( format_type) {
      case FRM_S: {
      if ( pfo != null) {
	try {
          return pfo.sprintf( value, buff);
        }
	catch ( IllegalArgumentException e) {
	  buff.setLength(0);
	  buff.append("format error");
	  return buff;
	}
      }
      else 
        return buff;
      }
      case FRM_O: {
	int idx, j, len;

	len = value.length();
	idx = value.lastIndexOf('-');
	if ( idx == -1)
	  idx = 0;
	else
	  idx++;

	buff.setLength(0);
	for ( j = idx; j < len; j++)
	  buff.append(value.charAt(j));
	return buff;	
      }
      case FRM_1O: 
      case FRM_2O: {
	int j, len;

	len = value.length();
	buff.setLength(0);
	for ( j = 0; j < len; j++)
	  buff.append(value.charAt(j));
	return buff;	
      }
      case FRM_T: 
      case FRM_1T: 
      case FRM_2T: 
      case FRM_3T: {
	int j, len;

	len = value.length();
	buff.setLength(0);
	for ( j = 0; j < len; j++)
	  buff.append(value.charAt(j));
	return buff;	
      }
      case FRM_M: 
      case FRM_1M: {
	int j, len;

	len = value.length();
	buff.setLength(0);
	for ( j = 0; j < len; j++)
	  buff.append(value.charAt(j));
	return buff;	
      }
      }
      buff.setLength(0);
      return buff;
    }
}

