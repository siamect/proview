/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

/**
 *  Title: Mh.java Description: Klass som fungerar som en port mot
 *  meddelandehanteraren Copyright: <p>
 *
 *  Company SSAB<p>
 *
 *
 *
 *@author     JN
 *@version    1.0
 */

package jpwr.rt;
import java.util.Vector;
/**
 *  Description of the Class
 *
 *  @author     Jonas Nylund
 */
public class Mh
{
  static
  {
    System.loadLibrary("jpwr_rt_gdh");
    initIDs();  
  }

  public static final int mh_mEventFlags_Return = 0x01;
  public static final int mh_mEventFlags_Ack = 0x02;
  public static final int mh_mEventFlags_Bell = 0x04;
  public static final int mh_mEventFlags_Force = 0x08;
  public static final int mh_mEventFlags_InfoWindow = 0x10;
  public static final int mh_mEventFlags_Returned = 0x20;
  public static final int mh_mEventFlags_NoObject = 0x40;
  
  
  public static final  int mh_mEventStatus_NotRet = (1 << 0);
  public static final  int mh_mEventStatus_NotAck = (1 << 1);
  public static final  int mh_mEventStatus_Block  = (1 << 2);
  
  public static final int mh_eEventPrio__ = 0;   
  public static final int mh_eEventPrio_A = 67;  
  public static final int mh_eEventPrio_B = 66; 
  public static final int mh_eEventPrio_C = 65;
  public static final int mh_eEventPrio_D = 64;
  public static final int mh_eEventPrio_  = 63;
  
  public static final int mh_eEvent__		= 0;    
  public static final int mh_eEvent_Ack		= 1;
  public static final int mh_eEvent_Block	= 2;
  public static final int mh_eEvent_Cancel	= 3;
  public static final int mh_eEvent_CancelBlock	= 4;
  public static final int mh_eEvent_Missing	= 5;
  public static final int mh_eEvent_Reblock	= 6;
  public static final int mh_eEvent_Return	= 7;
  public static final int mh_eEvent_Unblock	= 8;
  public static final int mh_eEvent_InfoSuccess	= 32;
  public static final int mh_eEvent_Alarm	= 64;
  public static final int mh_eEvent_MaintenanceAlarm = 128;
  public static final int mh_eEvent_SystemAlarm	= 256;
  public static final int mh_eEvent_UserAlarm1	= 512;
  public static final int mh_eEvent_UserAlarm2	= 1024;
  public static final int mh_eEvent_UserAlarm3	= 2048;
  public static final int mh_eEvent_UserAlarm4	= 4096;
  public static final int mh_eEvent_Info	= 8192;
  public static final int mh_eEvent_   		= 8193;
  
  public static final int EventType_ClearAlarmList = 66;
  //public static final int EventType_Return = 1;
  //public static final int EventType_Ack = 2;
  //public static final int EventType_Alarm = 3;

  static MhrEvent lastMhrEvent;
  static boolean newAlarmArrived = false;
  static boolean newEventArrived = false;
  static boolean clearAlarmList = false;
  static int nrOfAlarmsArrived = 0;
  
  static int maxNoOfAlarms;
  static int maxNoOfEvents;
  
  private boolean keepRunning = true;
  
  private String mess = "dummymess";
  private static boolean initDone = false;

  private static String currentSystemGroup = null;
  private static String currentUser = null;
  private static String currentPassword = null;
  private static int currentPrivilege = Pwr.mAccess_AllPwr;



  /**
   *  Constructor for the Mh object
   */
  public Mh(Object root, int maxNoOfAlarms, int maxNoOfEvents)
  {
    
    if(!initDone)
    {
      Mh.maxNoOfAlarms = maxNoOfAlarms;
      Mh.maxNoOfEvents = maxNoOfEvents;
      initDone = true;
    }
  }

  public void close()
  {
  }


  public void printStatistics(int lockRejected)
  {
  }


  public int login(String user, String password)
  {
    // Get system group
    String systemGroup = "SSAB";
    CdhrInt ret = RtSecurity.checkUser(systemGroup, user,
      password);
    if(ret.evenSts())
    {
      logout();
      return ret.getSts();
    }
    currentSystemGroup = systemGroup;
    currentUser = user;
    currentPassword = password;
    currentPrivilege = ret.value;
    return 1;
  }


  public void logout()
  {
    currentSystemGroup = null;
    currentUser = null;
    currentPassword = null;
    currentPrivilege = Pwr.mAccess_AllPwr;
  }


  public int checkUser()
  {
    return 1;
  }


  /**
   *  Get the user attribute of the Mh object
   *
   *  @return    The user value
   */
  public String getUser()
  {
    return currentUser;
  }


  /**
   *  Gets the authorized attribute of the Mh object
   *
   *  @param  access  Description of the Parameter
   *  @return         The authorized value
   */
  public boolean isAuthorized(int access)
  {
    return (access & currentPrivilege) != 0;
  }


  public PwrtStatus createInstanceFile(String from, String to,
                                       String instance)
  {
    // Dummy
    return new PwrtStatus(0);
  }


  public void logString(String str)
  {
    // Dummy
  }


  public static void callBack()
  {
    System.out.println("callback funkar ju");
  }
  /**
   *  Callback function for received messages.
   */
  public static void messReceived(String messString, String nameString, String timeString)
  {
    //System.out.println("Larm " + timeString + " " + messString + " " + nameString);
    //hantera det mottagna meddelandet
    //this.newMessArrived = true;
    //notify();

  }

  public static void messReceived(String messString, 
                                  String nameString, 
				  String timeString, 
				  int flags, 
				  int prio, 
				  int status, 
				  int eventId_nix, 
				  String eventId_birthTime, 
				  int eventId_idx, 
				  int targetId_nix, 
				  String targetId_birthTime, 
				  int targetId_idx, 
				  int eventType, 
				  PwrtAttrRef object,
				  PwrtAttrRef supObject,
				  String moreText)
  {
    //hantera det mottagna meddelandet
    MhrEvent evItem =  new MhrEvent(messString, 
                                    nameString,
                                    timeString, 
				    flags, 
				    prio, 
				    status, 
				    eventId_nix, eventId_birthTime, eventId_idx, 
				    targetId_nix, targetId_birthTime, targetId_idx, 
				    eventType, object, supObject, moreText);
    lastMhrEvent = evItem;
    newAlarmArrived = true;
    
    nrOfAlarmsArrived++; // not needed

  }

  public boolean hasNewMessArrived()
  {
    if(!newAlarmArrived)
      return newAlarmArrived;
    newAlarmArrived = false;
    return true; 
    
  }


  /**
   *  Returns the new messsage that has arrived. Should only be called if
   *  <code>hasNewMessArrived()</code> returns <code>true</code>.
   *
   *  @return    The new message.
   */
  public MhrEvent getNewMess()
  { 
    return lastMhrEvent;
  }


  //public native PwrtStatus outunitBlock(PwrtObjid object, MheEventPrio prio);


  private native static void initIDs();

  /**
   *  Sends an acknowledge message to the message handler.
   *
   *  @param  id  Identity for the aknowledged event.
   *  @return     Status. <code>%MH-S-SUCCES</code> or <code>%MH-S-ACKBUFF</code>.
   */
  public native PwrtStatus outunitAck(MhrsEventId id);



  /**
   *  Connects an outunit to the lcoal message handler.
   *
   *  @param  outunit  The object identity for the outunit object.
   *  @return          Status. <code>%MH-S-SUCCESS</code>.
   */
  public native PwrtStatus outunitConnect(PwrtObjid outunit);


  /**
   *  Disconnects an outunit from the local message handler.
   *
   *  @return    Status. <code>%MH-S-SUCCESS</code>.
   */
  public native PwrtStatus outunitDisConnect();


  /**
   *  Reads the message queue for an outunit. If there is a message messReceived() will be
   *  called.
   *
   *@return    Status, <code>%MH-S-SUCCESS</code>.
   */
  public native PwrtStatus outunitReceive();


  /**
   *  See Programmer's Reference Manual for description.
   *
   *  @param  object  Identity for the object that should be blocked.
   *  @return         Status, <code>%MH-S-SUCCES</code>, <code>%MH-W-NOTBLOCK</code> 
   *  already unblocked, <code>%GDH-F-NOSUCHOBJ</code> object is not available.
   */
  public native PwrtStatus outunitUnBlock(PwrtObjid object);


  /**
   *  See Programmer's Reference Manual for description.
   *
   *  @return    Status, <code>%MH-S-SUCCESS</code>.
   */
  public native PwrtStatus outunitUpdate();

  public native static String translateFilename(String filename);
}


