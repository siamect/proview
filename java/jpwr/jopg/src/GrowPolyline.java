 /* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jopg;
import jpwr.rt.*;
import java.io.*;
import java.util.*;

public class GrowPolyline extends GlowArrayElem {
    GrowCmn cmn;
    String n_name;
    double x_right;
    double x_left;
    double y_high;
    double y_low;
    int original_border_drawtype;
    int original_fill_drawtype;
    int fill_drawtype;
    int background_drawtype;
    int border;
    int fill_eq_border;
    double shadow_width;
    int shadow_contrast;
    int shadow;
    int relief;
    int disable_shadow;
    int fixcolor;
    int fixposition;
    int gradient;
    int gradient_contrast;
    int disable_gradient;
    int fill_eq_light;
    int fill_eq_shadow;
    int fill_eq_bglight;
    int fill_eq_bgshadow;
    int fill_eq_background;
    int dynamicsize;
    GlowTransform trf;

    Vector<GlowArrayElem> a_points = new Vector<GlowArrayElem>();
    GlowPointX[] points;
    int draw_type;
    int line_width;
    int fill;
    int closed_line;

    public class GlowShadowInfo {
	public int drawtype;
	public int x;
	public int y;

	public GlowShadowInfo() {}
    }

    public GrowPolyline(GrowCmn cmn) {
	this.cmn = cmn;
	trf = new GlowTransform();
    }


    public GrowPolyline( GrowCmn cmn, String name, 
			 GlowPoint[] pointarray, int point_cnt,
			 int border_d_type, int line_w, 
			 int fix_line_w, int fill, int display_border, int display_shadow,
			 int fill_d_type) {
	this.cmn = cmn;
	original_border_drawtype = border_d_type;
	fill_drawtype = fill_d_type;
	border = display_border;
	shadow = display_shadow;
	shadow_width = 5;
	relief = Glow.eRelief_Up;
	shadow_contrast = 2;
	gradient = Glow.eGradient_No;
	gradient_contrast = 4;
	n_name = name;
	draw_type = border_d_type;
	line_width = line_w;
	this.fill = fill;
	background_drawtype = Glow.eDrawType_No;

	for ( int i = 0; i < point_cnt; i++)
	    a_points.add(new GlowPoint(pointarray[i]));

	points = new GlowPointX[a_points.size()];
	for ( int i = 0; i < a_points.size(); i++)
	    points[i] = new GlowPointX();

	trf = new GlowTransform();
    }

    public int type() {
	return Glow.eObjectType_GrowPolyLine;
    }

    public void open(BufferedReader reader) {
	String line;
	StringTokenizer token;
	boolean end_found = false;

	try {
	    while( (line = reader.readLine()) != null) {
		token = new StringTokenizer(line);
		int key = Integer.valueOf(token.nextToken());
		if ( cmn.debug) System.out.println( "GrowPolyline : " + line);

		switch ( key) {
		case Glow.eSave_GrowPolyLine: 
		    break;
		case Glow.eSave_GrowPolyLine_n_name:
		    if ( token.hasMoreTokens())
			n_name = token.nextToken();
		    break;
		case Glow.eSave_GrowPolyLine_x_right: 
		    x_right = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_GrowPolyLine_x_left: 
		    x_left = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_GrowPolyLine_y_high: 
		    y_high = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_GrowPolyLine_y_low: 
		    y_low = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_GrowPolyLine_original_border_drawtype: 
		    original_border_drawtype = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowPolyLine_original_fill_drawtype: 
		    original_fill_drawtype = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowPolyLine_fill_drawtype: 
		    fill_drawtype = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowPolyLine_background_drawtype: 
		    background_drawtype = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowPolyLine_border: 
		    border = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowPolyLine_shadow_width: 
		    shadow_width = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_GrowPolyLine_shadow_contrast: 
		    shadow_contrast = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowPolyLine_shadow: 
		    shadow = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowPolyLine_relief: 
		    relief = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowPolyLine_disable_shadow: 
		    disable_shadow = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowPolyLine_fixcolor:
		    fixcolor = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowPolyLine_fixposition:
		    fixposition = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowPolyLine_gradient:
		    gradient = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowPolyLine_gradient_contrast:
		    gradient_contrast = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowPolyLine_disable_gradient:
		    disable_gradient = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowPolyLine_fill_eq_border:
		    fill_eq_border = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowPolyLine_fill_eq_light:
		    fill_eq_light = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowPolyLine_fill_eq_shadow:
		    fill_eq_shadow = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowPolyLine_fill_eq_bglight:
		    fill_eq_bglight = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowPolyLine_fill_eq_bgshadow:
		    fill_eq_bgshadow = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowPolyLine_fill_eq_background:
		    fill_eq_background = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowPolyLine_dynamicsize:
		    dynamicsize = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowPolyLine_dynamic:
		    if ( cmn.dynamicsize > 0) {
			for ( int j = 0; j < cmn.dynamicsize; j++) 
			    line = reader.readLine();  // TODO handle backslash and citationmarks
		    }
		    break;
		case Glow.eSave_GrowPolyLine_polyline_part: 
		    glowpolyline_open( reader);
		    break;
		case Glow.eSave_GrowPolyLine_trf: 
		    trf.open( reader);
		    break;
		case Glow.eSave_End:
		    end_found = true;
		    break;
		default:
		    System.out.println( "Syntax error in GrowPolyline");
		    break;
		}
		if ( end_found)
		    break;
	    }
		
	    points = new GlowPointX[a_points.size()];
	    for ( int i = 0; i < a_points.size(); i++)
		points[i] = new GlowPointX();

	} catch ( Exception e) {
	    System.out.println( "IOException GrowPolyline");
	}
    }

    public void glowpolyline_open(BufferedReader reader) {
	String line;
	StringTokenizer token;
	boolean end_found = false;

	try {
	    while( (line = reader.readLine()) != null) {
		token = new StringTokenizer(line);
		int key = Integer.valueOf(token.nextToken());
		if ( cmn.debug) System.out.println( "GlowPolyline : " + line);

		switch ( key) {

		case Glow.eSave_PolyLine: 
		    break;
		case Glow.eSave_PolyLine_draw_type: 
		    draw_type = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_PolyLine_line_width:
		    line_width = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_PolyLine_fill:
		    fill = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_PolyLine_closed_line:
		    closed_line = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_PolyLine_a_points:
		    cmn.ctx.openVector( reader, cmn, a_points);
		    break;
		case Glow.eSave_End:
		    end_found = true;
		    break;
		default:
		    System.out.println( "Syntax error in GlowPolyline");
		    break;
		}
		if ( end_found)
		    break;

	    }

	} catch ( Exception e) {
	    System.out.println( "IOException GlowPolyline");
	}
    }

    public int eventHandler( GlowEvent event, double fx, double fy) {
	/*
	GlowPointDX rp;

	switch ( event.event) {
	case Glow.eEvent_CursorMotion:		
	    return 0;
	default: ;
	}

	rp = trf.reverse( fx, fy);
	//rp = new GlowPoint();
	//rp.x = fx;
	//rp.y = fy;
	if ( ll.x <= rp.x && rp.x <= ur.x &&
	     ll.y <= rp.y && rp.y <= ur.y) {
	    System.out.println( "Event handler: Hit in polyline");
	    return 1;
	}  
	else
	*/
	    return 0;
    }

    public void draw() {
	draw( null, 0, 0, null, null);
    }


    public void draw(GlowTransform t, int highlight, int hot, Object node, Object colornode) {
	if ( cmn.nodraw != 0)
	    return;

	int chot = 0;
	if ( hot != 0) {
	    if ( cmn.hot_indication == Glow.eHotIndication_No)
		hot = 0;
	    else if ( cmn.hot_indication == Glow.eHotIndication_DarkColor) {
		chot = hot;
		hot = 0;
	    }
	    else if ( cmn.hot_indication == Glow.eHotIndication_LightColor) {
		chot = -hot;
		hot = 0;
	    }
	}
	int i;
	int drawtype;
	int idx;

	if ( fixcolor != 0)
	    colornode = null;

	if ( node != null && ((GrowNode)node).line_width != 0)
	    idx = (int)( cmn.mw.zoom_factor_y / cmn.mw.base_zoom_factor * 
			 ((GrowNode)node).line_width - 1);
	else
	    idx = (int)( cmn.mw.zoom_factor_y / cmn.mw.base_zoom_factor * line_width - 1);
	idx += hot;
	idx = Math.max( 0, idx);
	idx = Math.min( idx, Glow.DRAW_TYPE_SIZE-1);
	double x1, y1;

	for ( i = 0; i < a_points.size(); i++) {
	    if (t == null) {
		x1 = trf.x( ((GlowPoint)a_points.get(i)).x, ((GlowPoint)a_points.get(i)).y);
		y1 = trf.y( ((GlowPoint)a_points.get(i)).x, ((GlowPoint)a_points.get(i)).y);
	    }
	    else {
		x1 = trf.x( t, ((GlowPoint)a_points.get(i)).x, ((GlowPoint)a_points.get(i)).y);
		y1 = trf.y( t, ((GlowPoint)a_points.get(i)).x, ((GlowPoint)a_points.get(i)).y);
	    }
	    points[i].x = (int)( x1 * cmn.mw.zoom_factor_x + 0.5) - cmn.mw.offset_x;
	    points[i].y = (int)( y1 * cmn.mw.zoom_factor_y + 0.5) - cmn.mw.offset_y;
	}
	if ( fill != 0) {
	    int grad = gradient;
	    if ( gradient == Glow.eGradient_No && 
		 (node != null && ((GrowNode)node).gradient != Glow.eGradient_No) && disable_gradient == 0)
		grad = ((GrowNode)node).gradient;
    
	    if ( fill_eq_border != 0)
		drawtype = GlowColor.get_drawtype( draw_type, Glow.eDrawType_LineHighlight,
						   highlight, colornode, 0, 0);
	    else if ( fill_eq_background != 0)
		drawtype = GlowColor.get_drawtype( background_drawtype, Glow.eDrawType_FillHighlight,
						   highlight, colornode, 3, 0);
	    else      
		drawtype = GlowColor.get_drawtype( fill_drawtype, Glow.eDrawType_FillHighlight,
						   highlight, colornode, 1, 0);
	    if ( fill_eq_light != 0 && node != null && ((GrowNode)node).shadow != 0)
		drawtype = GlowColor.shift_drawtype( drawtype, -shadow_contrast + chot, 
						     colornode);
	    else if ( fill_eq_bglight != 0) {
		if ( colornode != null && ((GrowNode)node).background_drawtype != Glow.eDrawType_No)
		    drawtype = GlowColor.shift_drawtype( ((GrowNode)colornode).background_drawtype, 
							 -shadow_contrast + chot, colornode);
		else
		    drawtype = GlowColor.shift_drawtype( original_fill_drawtype, -shadow_contrast + chot, 
							 colornode);
	    }
	    else if ( fill_eq_shadow != 0 && node != null && ((GrowNode)node).shadow != 0)
		drawtype = GlowColor.shift_drawtype( drawtype, shadow_contrast + chot, 
						     colornode);
	    else if ( fill_eq_bgshadow != 0) {
		if ( colornode != null && ((GrowNode)node).background_drawtype != Glow.eDrawType_No)
		    drawtype = GlowColor.shift_drawtype( ((GrowNode)colornode).background_drawtype, 
							 shadow_contrast + chot, colornode);
		else
		    drawtype = GlowColor.shift_drawtype( original_fill_drawtype, shadow_contrast + chot, 
							 colornode);
	    }
	    else if ( chot != 0)
		drawtype = GlowColor.shift_drawtype( drawtype, chot, null);

	    if ( grad == Glow.eGradient_No || drawtype == Glow.eDrawType_ColorRed)
		cmn.gdraw.fill_polyline( points, a_points.size(), drawtype, 0);
	    else {
		int f1, f2;
		double rotation;
		if ( t != null)
		    rotation = trf.rot( t);
		else
		    rotation = trf.rot();

		if ( gradient_contrast >= 0) {
		    f2 = GlowColor.shift_drawtype( drawtype, -gradient_contrast/2, null);
		    f1 = GlowColor.shift_drawtype( drawtype, (int)((float)(gradient_contrast)/2+0.6), null);
		}
		else {
		    f2 = GlowColor.shift_drawtype( drawtype, -(int)((float)(gradient_contrast)/2-0.6), null);
		    f1 = GlowColor.shift_drawtype( drawtype, gradient_contrast/2, null);
		}
		cmn.gdraw.gradient_fill_polyline( points, a_points.size(),
						  drawtype, f1, f2, cmn.gdraw.gradient_rotate( rotation, grad));	
	    }
	}

	boolean display_shadow = ((node != null && ((GrowNode)node).shadow != 0) || shadow != 0) && disable_shadow == 0 &&
	    fill_eq_light == 0 && fill_eq_shadow == 0;

	if ( display_shadow && shadow_width != 0) {
	    GlowShadowInfo[] sp;
	    int p_num;

	    double trf_scale = trf.vertical_scale( t);
	    int ish = (int)( shadow_width / 100 * trf_scale * 
			   Math.min((x_right - x_left)*cmn.mw.zoom_factor_x, (y_high - y_low)*cmn.mw.zoom_factor_y) + 0.5);

	    if ( ish >= 1) {
		sp = calculate_shadow( ish, highlight, colornode, 0, chot);
		p_num = sp.length;

		GlowPointX[] p = new GlowPointX[4];
		p[0] = new GlowPointX();
		p[1] = new GlowPointX();
		p[2] = new GlowPointX();
		p[3] = new GlowPointX();
		for ( i = 0; i < p_num - 1; i++) {
		    p[0].x = points[i].x;
		    p[0].y = points[i].y;
		    p[1].x = sp[i].x;
		    p[1].y = sp[i].y;
		    p[3].x = points[i+1].x;
		    p[3].y = points[i+1].y;
		    p[2].x = sp[i+1].x;
		    p[2].y = sp[i+1].y;

		    cmn.gdraw.fill_polyline( p, 4, sp[i].drawtype, 0);
		}
	    }
	}
	if ( border != 0 || !(fill != 0 || (display_shadow && shadow_width != 0))) {
	    drawtype = GlowColor.get_drawtype( draw_type, Glow.eDrawType_LineHighlight,
					       highlight, colornode, 0, 0);
	    cmn.gdraw.polyline( points, a_points.size(), drawtype, idx, 0);
	}
    }

    GlowShadowInfo[] calculate_shadow( int ish, int highlight, 
				     Object colornode, int javaexport, int chot) {
	GlowShadowInfo sp[];
	double x;
	int pos01;
	int pos12;
	int i;
	int light_drawtype;
	int dark_drawtype;
    
	int p_num = a_points.size();
	if ( points[0].x == points[p_num-1].x && points[0].y == points[p_num-1].y)
	    p_num--;

	if ( points[0].x == points[a_points.size()-1].x && points[0].y == points[a_points.size()-1].y)
	    sp = new GlowShadowInfo[p_num + 1];
	else
	    sp = new GlowShadowInfo[p_num];

	int fillcolor = GlowColor.get_drawtype( fill_drawtype, Glow.eDrawType_FillHighlight,
						highlight, colornode, 1, 0);

	int drawtype_incr = shadow_contrast;
	if ( relief == Glow.eRelief_Down)
	    drawtype_incr = -shadow_contrast;
	light_drawtype = GlowColor.shift_drawtype( fillcolor, -drawtype_incr + chot, 
						   colornode);
	dark_drawtype = GlowColor.shift_drawtype( fillcolor, drawtype_incr + chot, 
						  colornode);

	pos01 = shadow_direction();

	for ( i = 0; i < p_num; i++) {
	    double sx0, sx1, sx2, sy0, sy1, sy2;
	    double k01, m01, k12, m12;

	    sp[i] = new GlowShadowInfo();

	    if ( i == 0) {
		sx0 = points[p_num - 1].x;
		sy0 = points[p_num - 1].y;
	    }
	    else {
		sx0 = points[i-1].x;
		sy0 = points[i-1].y;
	    }
	    sx1 = points[i].x;
	    sy1 = points[i].y;
	    if ( i == p_num - 1) {
		sx2 = points[0].x;
		sy2 = points[0].y;
	    }
	    else {
		sx2 = points[i+1].x;
		sy2 = points[i+1].y;
	    }

	    pos12 = pos01;
	    if ( i == -1) {
	    }
	    else {
		if ( Math.abs( sx0 - sx1) < Double.MIN_VALUE) {
		    if (sx1 > sx2 && sy1 < sy0)
			pos12 = - pos01;
		    else if ( sx1 < sx2 && sy1 > sy0)
			pos12 = - pos01;
		}
		else if ( Math.abs( sx1 - sx2) < Double.MIN_VALUE) {
		    if ( sx0 < sx1 && sy2 > sy1)
			pos12 = - pos01;
		    else if (  sx0 > sx1 && sy2 < sy1)
			pos12 = - pos01;
		}
		else if ( sx1 > sx0 && sx2 < sx1)
		    pos12 = -pos01;
		else if ( sx1 < sx0 && sx2 > sx1)
		    pos12 = -pos01;
	    }
    
	    if ( Math.abs( sx0 - sx1) < Double.MIN_VALUE)  {
		if ( Math.abs( sx1 - sx2) < Double.MIN_VALUE) {
		    x = sx1 + pos01 * ish;
		    sp[i].x = (int)( x + 0.5);
		    sp[i].y = (int)( sy1 + 0.5);
		}
		else {
		    k12 = (sy2 - sy1)/(sx2 - sx1);
		    m12 = sy1 - sx1 * k12 + pos12 * ish / Math.abs(Math.cos(Math.atan(k12)));
      
		    x = sx1 + pos01 * ish;
		    sp[i].x = (int)( x + 0.5);
		    sp[i].y = (int)( k12 * x + m12 + 0.5);
		}
	    }
	    else if ( Math.abs( sx1 - sx2) < Double.MIN_VALUE) {
		k01 = (sy1 - sy0)/(sx1 - sx0);
		m01 = sy0 - sx0 * k01 + pos01 * ish / Math.abs(Math.cos(Math.atan(k01)));

		x = sx1 + pos12 * ish;
		sp[i].x = (int)(  x + 0.5);
		sp[i].y = (int)( k01 * x + m01 + 0.5);
	    }
	    else {
		k01 = (sy1 - sy0)/(sx1 - sx0);
		k12 = (sy2 - sy1)/(sx2 - sx1);
		m01 = sy0 - sx0 * k01 + pos01 * ish / Math.abs(Math.cos(Math.atan(k01)));
		m12 = sy1 - sx1 * k12 + pos12 * ish / Math.abs(Math.cos(Math.atan(k12)));
		if ( Math.abs( k01 - k12) < Double.MIN_VALUE) {
		    // Identical lines
		    if ( Math.abs( k01) < Double.MIN_VALUE) {
			sp[i].x = (int)( sx1 + 0.5);
			sp[i].y = (int)( m01 + 0.5);
		    }
		    else {
			k12 = -k12;
			m12 = sy2 - k12 * sx2;

			x = (m12 - m01)/(k01 - k12);
			sp[i].x = (int)( x + 0.5);
			sp[i].y = (int)( k12 * x + m12 + 0.5);
			k12 = k01;
			m12 = m01;
		    }
		}
		else {
		    x = (m12 - m01)/(k01 - k12);
		    sp[i].x = (int)( x + 0.5);
		    sp[i].y = (int)( k12 * x + m12 + 0.5);
		}
	    }
	    if ( pos12 == 1)
		sp[i].drawtype = light_drawtype;
	    else
		sp[i].drawtype = dark_drawtype;
	    pos01 = pos12;
	}
	if ( points[0].x == points[a_points.size()-1].x && points[0].y == points[a_points.size()-1].y) {
	    sp[p_num] = new GlowShadowInfo();
	    sp[p_num].x = sp[0].x;
	    sp[p_num].y = sp[0].y;
	}

	return sp;
    }

    public int shadow_direction() {
	double a1, a2, a1_old, a0_old;
	double a_sum1 = 0;
	double a_sum2 = 0;
	int p_num = a_points.size();
	a1_old = 0;
	a0_old = 0;

	if ( (points[p_num - 1].x == points[0].x && points[p_num - 1].y == points[0].y))
	    p_num--;

	for ( int i = 0; i < p_num; i++) {
	    if ( i == p_num - 1) {
		if ( points[0].x == points[i].x) {
		    a1 = 90;
		    if ( points[0].y < points[i].y)
			a1 += 180;
		}
		else
		    a1 = Math.atan((double)(points[0].y - points[i].y)/(points[0].x - points[i].x)) * 180 / Math.PI;
		if ( points[0].x < points[i].x)
		    a1 += 180;
	    }
	    else {
		if ( points[i+1].x == points[i].x) {
		    a1 = 90;
		    if ( points[i+1].y < points[i].y)
			a1 += 180;
		}
		else
		    a1 = Math.atan((double)(points[i+1].y - points[i].y)/(points[i+1].x - points[i].x)) * 180 / Math.PI;
		if ( points[i+1].x < points[i].x)
		    a1 += 180;
	    }
	    if ( i == 0) {
		a0_old = a1;
	    }
	    else if ( i > 0) {
		a2 = a1 - (a1_old - 180);
		if ( a2 < 0)
		    a2 += 360;
		else if ( a2 >= 360)
		    a2 -= 360;
		a_sum1 += a2;
		a_sum2 += 360 - a2;

	    }
	    if ( i == p_num - 1) {
		a2 = a0_old - (a1 - 180);
		if ( a2 < 0)
		    a2 += 360;
		else if ( a2 >= 360)
		    a2 -= 360;
		a_sum1 += a2;
		a_sum2 += 360 - a2;
	    }
	    a1_old = a1;
	}
	int dir;
	GlowPointX last_point;
	if ( points[0].x == points[a_points.size()-1].x && points[0].y == points[a_points.size()-1].y)
	    last_point = points[a_points.size()-2];
	else
	    last_point = points[a_points.size()-1];

	if ( a_sum2 - a_sum1 < 0) {
	    if ( points[0].x == last_point.x) {
		if ( points[0].x < points[1].x)
		    dir = 1;
		else
		    dir = -1;
	    }
	    else if ( points[0].x > last_point.x)
		dir = 1;
	    else
		dir = -1;
	}
	else {
	    if ( points[0].x == last_point.x) {
		if ( points[0].x < points[1].x)
		    dir = 1;
		else
		    dir = -1;
	    }
	    else if ( points[0].x < last_point.x)
		dir = 1;
	    else
		dir = -1;
	}
	return dir;
    }

    public void add_and_shift_y_value( double value) {
	for ( int i = a_points.size() - 1; i > 0; i--) {
	    ((GlowPoint)a_points.get(i)).y = ((GlowPoint)a_points.get(i-1)).y;
	}
	((GlowPoint)a_points.get(0)).y = value;
    }

    public void add_and_shift_y_value_filled( double value) {
	for ( int i = a_points.size() - 2; i > 1; i--) {
	    ((GlowPoint)a_points.get(i)).y = ((GlowPoint)a_points.get(i-1)).y;
	}
	((GlowPoint)a_points.get(1)).y = value;
    }

    public void get_borders( GlowTransform t, GlowGeometry g) {
	int i;
	double x1, y1, x2=0, y2=0;

	for ( i = 0; i < a_points.size() - 1; i++) {
	    if  ( t != null) {
		if ( i == 0) {
		    x1 = trf.x( t, ((GlowPoint)a_points.get(i)).x, ((GlowPoint)a_points.get(i)).y);
		    y1 = trf.y( t, ((GlowPoint)a_points.get(i)).x, ((GlowPoint)a_points.get(i)).y);
		}
		else {
		    x1 = x2;
		    y1 = y2;
		}
		x2 = trf.x( t, ((GlowPoint)a_points.get(i)).x, ((GlowPoint)a_points.get(i)).y);
		y2 = trf.y( t, ((GlowPoint)a_points.get(i)).x, ((GlowPoint)a_points.get(i)).y);
	    }
	    else {
		if ( i == 0) {
		    x1 = trf.x( ((GlowPoint)a_points.get(i)).x, ((GlowPoint)a_points.get(i)).y);
		    y1 = trf.y( ((GlowPoint)a_points.get(i)).x, ((GlowPoint)a_points.get(i)).y);
		}
		else {
		    x1 = x2;
		    y1 = y2;
		}
		x2 = trf.x( ((GlowPoint)a_points.get(i+1)).x, ((GlowPoint)a_points.get(i+1)).y);
		y2 = trf.y( ((GlowPoint)a_points.get(i+1)).x, ((GlowPoint)a_points.get(i+1)).y);
	    }

	    if ( x1 < g.ll_x)
		g.ll_x = x1;
	    if ( x2 < g.ll_x)
		g.ll_x = x2;
	    if ( x1 > g.ur_x)
		g.ur_x = x1;
	    if ( x2 > g.ur_x)
		g.ur_x = x2;
	    if ( y1 < g.ll_y)
		g.ll_y = y1;
	    if ( y2 < g.ll_y)
		g.ll_y = y2;
	    if ( y1 > g.ur_y)
		g.ur_y = y1;
	    if ( y2 > g.ur_y)
		g.ur_y = y2;
	}
    }

    public String getName() {
	return n_name;
    }
}
