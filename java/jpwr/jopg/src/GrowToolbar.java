/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jopg;
import jpwr.rt.*;
import java.io.*;
import java.util.*;

public class GrowToolbar extends GrowNode {

    public static final float TOOLBAR_SPACING = 0.2F;

    int tools1_mask;
    int tools2_mask;


    public GrowToolbar(GrowCmn cmn) {
	super(cmn);
    }

    public int type() {
	return Glow.eObjectType_GrowToolbar;
    }

    public void open(BufferedReader reader) {
	String line;
	StringTokenizer token;
	boolean end_found = false;

	try {
	    while( (line = reader.readLine()) != null) {
		token = new StringTokenizer(line);
		int key = Integer.valueOf(token.nextToken());
		if ( cmn.debug) System.out.println( "GrowToolbar : " + line);

		switch ( key) {
		case Glow.eSave_GrowToolbar: 
		    break;
		case Glow.eSave_GrowToolbar_grownode_part: 
		    super.open(reader); 
		    break;
		case Glow.eSave_End:
		    end_found = true;
		    break;
		default:
		    System.out.println( "Syntax error in GrowToolbar");
		    break;
		}
		if ( end_found)
		    break;
	    }
		
	} catch ( Exception e) {
	    System.out.println( "IOException GrowToolbar");
	}
    }

    public void draw() {
	super.draw();
    }

    public int eventHandler( GlowEvent event, double fx, double fy) {
	GlowPointDX rp;
	int sts;
	int idx;

	if ( visible == 0 || dimmed != 0)
	    return 0;

	switch ( event.event) {
	case Glow.eEvent_CursorMotion:		
	    return 0;
	default: ;
	}

	rp = trf.reverse( fx, fy);

	switch ( event.event) {
	case Glow.eEvent_MB1Down:			
	    sts = nc_eventHandler(event, rp.x, rp.y);
	    if ( sts != 0) {
		idx = sts - 1;
		((GrowNode)nc.a.get(idx)).setColorInverse(1);
	    }
	    break;
	case Glow.eEvent_MB1Up:
	    sts = nc_eventHandler(event, rp.x, rp.y);
	    if ( sts != 0) {
		idx = sts - 1;
		((GrowNode)nc.a.get(idx)).setColorInverse(0);
	    }
	    break;
	case Glow.eEvent_MB1Click:
	    sts = nc_eventHandler(event, rp.x, rp.y);
	    if ( sts != 0) {
		idx = sts - 1;
		int[] lsts = get_mask_index(idx);
		if ( lsts == null)
		    break;

		int category = lsts[0];
		int mask_idx = lsts[1];

		System.out.println( "MB1 Click category: " + category + " idx " + mask_idx);

		int csts = cmn.ctx.send_toolbar_callback( this, category, mask_idx, 
							  Glow.eEvent_MB1Click, fx, fy);
	    }
	    break;
	default:
	    sts = nc.eventHandler(event, rp.x, rp.y);
	    if ( sts != 0) {
		return sts;
	    }
	}
	return 0;
    }
    
    public int nc_eventHandler( GlowEvent event, double x, double y) {
	int		i;
	int		sts;

	for ( i = 0; i < nc.a.size(); i++) {
	    sts = ((GrowNode)nc.a.get(i)).eventHandler( event, x, y);
	    if ( sts != 0) {
		return i + 1;
	    }
	}
	return 0;
    }

    public void configure( String[] tools1, String[] tools2, int tools1_cnt, int tools2_cnt,
			   int show_mask1, int show_mask2, 
			   int insensitive_mask1, int insensitive_mask2) {
	double x1, y1;
	double ll_x, ll_y, ur_x, ur_y;

	GlowNodeClass nc1;
	String subg_name;
	int mask;
	int sts;

	System.out.println( "Configure show_mask " + show_mask1 + " " + show_mask2);
	x1 = 0;
	y1 = 0;
	
	// Clear nc
	nc.a.clear();
	
	tools1_mask = 0;
	mask = 1;
	for ( int i = 0; i < tools1_cnt; i++) {
	    if ( (mask & show_mask1) != 0) {
		if ( tools1[i].isEmpty()) {
		    mask = mask << 1;
		    continue;
		}

		subg_name = tools1[i];
		
		nc1 = (GlowNodeClass)cmn.ctx.get_nodeclass_from_name( subg_name);
		if ( nc1 == null) {
		    String fname = subg_name + ".pwsg";
		    sts = cmn.ctx.loadSubgraph( fname);
		    if ( (sts & 1) != 0)
			nc1 = (GlowNodeClass)cmn.ctx.get_nodeclass_from_name( subg_name);
		}
		if ( nc1 != null) {    
		    GrowNode n1;
		    n1 = new GrowNode( cmn);
		    n1.n_name = subg_name;
		    System.out.println( "Button " + subg_name + " " + x1);
		    n1.nc = nc1;
		    n1.move_to( x1, y1);
		    // n1.disable_callback();
		    nc.a.add(n1);
      
		    if ( (mask & insensitive_mask1) != 0)
			n1.setVisibility( Glow.eVis_Dimmed);

		    GlowGeometry g = n1.measure();  
		    x1 += g.ur_x - g.ll_x + TOOLBAR_SPACING;
		    tools1_mask |= mask;
		}      
	    }
	    mask = mask << 1;
	}
	if ( x1 != 0)
	    x1 += TOOLBAR_SPACING * 2;
  
	tools2_mask = 0;
	mask = 1;
	for ( int i = 0; i < tools2_cnt; i++) {
	    if ( (mask & show_mask2) != 0) {
		if ( tools2[i].isEmpty()) {
		    mask = mask << 1;
		    continue;
		}
		
		subg_name = tools2[i];

		nc1 = (GlowNodeClass)cmn.ctx.get_nodeclass_from_name( subg_name);
		if ( nc1 == null) {
		    String fname = subg_name + ".pwsg";
		    sts = cmn.ctx.loadSubgraph( fname);
		    if ( (sts & 1) != 0)
			nc1 = (GlowNodeClass)cmn.ctx.get_nodeclass_from_name( subg_name);
		}
		if ( nc1 != null) {    
		    GrowNode n1;
		    n1 = new GrowNode( cmn);
		    n1.n_name = subg_name;
		    n1.nc = nc1;
		    System.out.println( "Button " + subg_name + " " + x1);
		    n1.move_to( x1, y1);
		    // n1.disable_callback();
		    nc.a.add(n1);
      
		    if ( (mask & insensitive_mask2) != 0)
			n1.setVisibility( Glow.eVis_Dimmed);

		    GlowGeometry g = n1.measure();  
		    x1 += g.ur_x - g.ll_x + TOOLBAR_SPACING;
		    tools2_mask |= mask;
		}      
	    }
	    mask = mask << 1;
	}
	
	get_node_borders();
	scale();

	System.out.println("Toolbar configure tools_mask " + tools1_mask + " " + tools2_mask);
    }

    public int[] get_mask_index( int idx) {
	// Calculate category and index
	int mask;
	int category;
	int mask_idx;
	int cnt = 0;
	int i;
	for ( i = 0; i < 64; i++) {
	    if ( i < 32)
		mask = 1 << i;
	    else
		mask = 1 << (i - 32);
	    if ( (i < 32 && (tools1_mask & mask) != 0) ||
		 (i >= 32 && (tools2_mask & mask) != 0))
		cnt++;
	    if ( cnt == idx + 1) {
		mask_idx = i % 32;
		category = i / 32 + 1;
		int[] ret = new int[2];
		ret[0] = category;
		ret[1] = mask_idx;
		return ret;
	    }
	}
	return null;
    }

    public void scale() {
	double scale;

	if ( cmn.mw.window_width == 0)
	    return;

	System.out.println( "Toolbar.scale offset_x " + cmn.mw.offset_x + " wwidth " + cmn.mw.window_width);
	if ( x_right * cmn.mw.zoom_factor_x - cmn.mw.offset_x > cmn.mw.window_width) {
	    scale = (cmn.mw.window_width - ( x_left * cmn.mw.zoom_factor_x - cmn.mw.offset_x) - 10) /
		(( x_right - x_left) * cmn.mw.zoom_factor_x);
	    
	    trf.scale( scale, 1, x_left, y_low);
	    get_node_borders();
	}
    }

}
