/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jopg;
import jpwr.rt.*;
import java.io.*;
import java.util.*;

public class GlowNodeClass extends GlowArrayElem {
    GrowCmn cmn;
    Vector<GlowArrayElem> a = new Vector<GlowArrayElem>();

    String nc_name;
    int group;
    int slider;
    String next_nodeclass;
    int animation_count;
    int cycle;
    double x0;
    double y0;
    double x1;
    double y1;
    int input_focus_mark;
    int dynamicsize;
    Object userdata;
    public int dyn_type1;
    public int dyn_type2;
    public int action_type1;
    public int action_type2;
    public int[] dyn_color = new int[4];
    public int[] dyn_attr = new int[4];
    GlowArrayElem next_nc;
    GlowArrayElem prev_nc;
    int recursive_trace;

    public GlowNodeClass(GrowCmn cmn) {
	this.cmn = cmn;
    }

    public void open(BufferedReader reader) {
	String line;
	StringTokenizer token;
	boolean end_found = false;

	try {
	    while( (line = reader.readLine()) != null) {
		token = new StringTokenizer(line);
		int key = Integer.valueOf(token.nextToken());
		if ( cmn.debug) System.out.println( "GlowNodeClass : " + line);

		switch ( key) {
		case Glow.eSave_NodeClass: 
		    break;
		case Glow.eSave_NodeClass_nc_name:
		    nc_name = token.nextToken();
		    break;
		case Glow.eSave_NodeClass_a:
		    cmn.ctx.openVector(reader, cmn, a);
		    break;
		case Glow.eSave_NodeClass_group:
		    group = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_NodeClass_arg_cnt:
		case Glow.eSave_NodeClass_argname:
		case Glow.eSave_NodeClass_argtype:
		case Glow.eSave_NodeClass_no_con_obstacle:
		    break;
		case Glow.eSave_NodeClass_dyn_type1:		    
		    dyn_type1 = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_NodeClass_dyn_type2:
		    dyn_type2 = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_NodeClass_dyn_action_type1:
		    action_type1 = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_NodeClass_dyn_action_type2:
		    action_type2 = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_NodeClass_dyn_color1:
		    dyn_color[0] = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_NodeClass_dyn_color2:
		    dyn_color[1] = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_NodeClass_dyn_color3:
		    dyn_color[2] = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_NodeClass_dyn_color4:
		    if ( token.hasMoreTokens())
			dyn_color[3] = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_NodeClass_dyn_attr1:
		    if ( token.hasMoreTokens())
			dyn_attr[0] = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_NodeClass_dyn_attr2:
		    if ( token.hasMoreTokens())
			dyn_attr[1] = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_NodeClass_dyn_attr3:
		    if ( token.hasMoreTokens())
			dyn_attr[2] = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_NodeClass_dyn_attr4:
		    if ( token.hasMoreTokens())
			dyn_attr[3] = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_NodeClass_java_name:
		    break;
		case Glow.eSave_NodeClass_slider:
		    slider = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_NodeClass_next_nodeclass:
		    if ( token.hasMoreTokens())
			next_nodeclass = token.nextToken();
		    break;
		case Glow.eSave_NodeClass_animation_count:
		    animation_count = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_NodeClass_cycle:
		    cycle = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_NodeClass_y0:
		    y0 = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_NodeClass_y1:
		    y1 = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_NodeClass_x0:
		    x0 = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_NodeClass_x1:
		    x1 = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_NodeClass_input_focus_mark:
		    input_focus_mark = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_NodeClass_recursive_trace:
		    recursive_trace = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_NodeClass_dynamicsize:
		    dynamicsize = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_NodeClass_dynamic:
		    if ( cmn.dynamicsize > 0) {
			for ( int j = 0; j < cmn.dynamicsize; j++) 
			    line = reader.readLine();  // TODO handle backslash and citationmarks
		    }
		    break;
		case Glow.eSave_NodeClass_userdata_cb:
		    if ( cmn.appl != null)
			userdata = cmn.appl.growUserdataOpen( reader, this, Glow.eUserdataCbType_NodeClass);
		    break;
		case Glow.eSave_End:
		    end_found = true;
		    break;
		default:
		    System.out.println( "Syntax error in GlowNodeClass");
		    break;
		}
		if ( end_found)
		    break;
	    }
		
	} catch ( Exception e) {
	    System.out.println( "IOException GlowNodeClass");
	}

	if (next_nodeclass != null && !next_nodeclass.equals("")) {
	    next_nc = (GlowNodeClass)cmn.ctx.get_nodeclass_from_name( next_nodeclass);
	    if ( next_nc == null) {
		System.out.println( "GlowNode:next_nodeclass not found: " + nc_name + " " +
				    next_nodeclass);
		System.out.println( "Note! nodeclass has to be intern");
	    }
	    else if ( ((GlowNodeClass)next_nc).prev_nc != null) {
		next_nc = null;
		System.out.println( "GlowNode:next_nodeclass already chained: " + nc_name + " " +
				    next_nodeclass);
	    }
	    else
		((GlowNodeClass)next_nc).prev_nc = (GlowArrayElem) this;
	}

    }

    public void draw(GlowTransform t, int highlight, int hot, Object node, Object colornode) {
	for ( int i = 0; i < a.size(); i++) {
	    a.get(i).draw(t, highlight, hot, node, colornode);
	}
    }

    public int eventHandler( GlowEvent event, double fx, double fy) {
	int sts;

	for ( int i = 0; i < a.size(); i++) {
	    sts = a.get(i).eventHandler(event, fx, fy);
	    if ( sts != 0)
		return sts;
	}
	return 0;
    }

    public void get_borders( GlowTransform t, GlowGeometry g) {
	GlowNodeClass base = get_base_nc();

	if ( (t == null || ( t != null && Math.abs( t.rotation/90 - (int)(t.rotation/90)) < Double.MIN_VALUE)) &&
	     !(Math.abs( base.x0 - base.x1) < Double.MIN_VALUE || 
	       Math.abs( base.y0 - base.y1) < Double.MIN_VALUE)) {
	    // Borders are given i x0, y0, x1, y1 
	    // Will not work in rotated nodes
	    double ll_x, ur_x, ll_y, ur_y, kx1, kx2, ky1, ky2;

	    if ( t != null) {
		kx1 = t.x( base.x0, base.y0);
		kx2 = t.x( base.x1, base.y1);
		ky1 = t.y( base.x0, base.y0);
		ky2 = t.y( base.x1, base.y1);
	    }
	    else {
		kx1 = base.x0;
		kx2 = base.x1;
		ky1 = base.y0;
		ky2 = base.y1;
	    }

	    ll_x = Math.min( kx1, kx2);
	    ur_x = Math.max( kx1, kx2);
	    ll_y = Math.min( ky1, ky2);
	    ur_y = Math.max( ky1, ky2);

	    if ( ll_x < g.ll_x)
		g.ll_x = ll_x;
	    if ( ur_x > g.ur_x)
		g.ur_x = ur_x;
	    if ( ll_y < g.ll_y)
		g.ll_y = ll_y;
	    if ( ur_y > g.ur_y)
		g.ur_y = ur_y;
	}
	else {
	    for ( int i = 0; i < a.size(); i++)
		a.get(i).get_borders(t, g);
	}
    }

    GlowNodeClass get_base_nc() {
	GlowNodeClass base;

	for ( base = this; base.prev_nc != null; base = (GlowNodeClass)base.prev_nc)
	    ;
	return base;
    }

    GlowDimensionD getAnnotationTextExtent( GlowTransform t, Object node, int num) {
	int i;

	for ( i = 0; i < a.size(); i++) {
	    if ( a.get(i).type() == Glow.eObjectType_GrowAnnot && ((GrowAnnotIfc)a.get(i)).getNumber() == num)
		return ((GrowAnnotIfc)a.get(i)).getTextExtent( t, node);
	}
	return null;
    }
}
