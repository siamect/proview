/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jopg;
import jpwr.rt.*;
import java.io.*;
import java.util.*;

public class GrowMenu extends GrowRect {

    GlowMenuInfo info;			//!< Button text and types.
    int	       	text_size;		//!< Button text size.
    int		text_drawtype;		//!< Drawtype  for button text.
    int		text_color;		//!< Color for button text.
    int		text_color_disabled;	//!< Color for disabled button text.
    int	       	item_cnt;		//!< Number of menu items.
    double     	item_height;		//!< Menu item height in pixel.
    int	       	current_item = -1;     	//!< Hot item.
    int		current_idx = -1;       //!< Hot index.
    int	       	new_item;		//!< New current item.
    int	       	old_item;		//!< Current item in previous event.
    GlowArrayElem parent_menu;		//!< Parent menu.
    double	min_width;		//!< Minimum width of menu.
    int	       	input_focus;		//!< This menu has input focus.
    int 	font;			//!< Text font.
    int		hot;

    public GrowMenu(GrowCmn cmn) {
	super(cmn);
    }

    public GrowMenu( GrowCmn cmn, String n_name, GlowMenuInfo menu_info, double x, double y, 
		     double min_w, int draw_type, int line_width, 
		     int fill, int border, 
		     int fill_drawtype, int text_size, 
		     int text_drawtype, int text_color, 
		     int text_color_disabled, int text_font) {

	super(cmn, n_name, x, y, 10, 10, draw_type, line_width,
	      fill, border, 0, fill_drawtype);
	this.info = menu_info;
	this.text_size = text_size;
	this.text_drawtype = text_drawtype;
	this.text_color = text_color;
	this.text_color_disabled = text_color_disabled;
	this.font = text_font;

	draw(null, 0, 0, null, null);
    }

    public int type() { 
	return Glow.eObjectType_GrowMenu;
    }

    public void draw(GlowTransform t, int highlight, int hot, Object node, Object colornode) {
	if ( cmn.nodraw != 0)
	    return;

	int idx;
	int text_idx = (int)( trf.vertical_scale(t) * cmn.mw.zoom_factor_y / cmn.mw.base_zoom_factor * (text_size +4) - 4);
	double tsize =  trf.vertical_scale(t) * cmn.mw.zoom_factor_y / cmn.mw.base_zoom_factor * (8+2*text_size);
	text_idx = Math.min( text_idx, Glow.DRAW_TYPE_SIZE-1);
	text_idx = Math.max( 0, text_idx);

	idx = (int)( cmn.mw.zoom_factor_y / cmn.mw.base_zoom_factor * line_width - 1);
	idx += hot;

	idx = Math.max( 0, idx);
	idx = Math.min( idx, Glow.DRAW_TYPE_SIZE-1);
	int ll_x, ll_y, ur_x, ur_y;

	int z_width, z_descent;
	int z_height = 0;
	int max_z_width = 0;
	double tot_z_height = 0;
	int i;
	int pulldown_found = 0;
	item_cnt = 0;
	for ( i = 0; i < info.item.length; i++) {
	    if ( info.item[i].occupied) {
		GlowDimension dim = cmn.gdraw.getTextExtent( info.item[i].text, Math.max( 0, text_idx), font, text_drawtype);
		z_width = dim.width;
		z_height = dim.height;
		z_descent = z_height/4;		
		if ( z_width > max_z_width)
		    max_z_width = z_width;
		tot_z_height += (int)( 1.6 * z_height);
		if ( info.item[i].type == Glow.eMenuItem_PulldownMenu)
		    pulldown_found = 1;
		item_cnt++;
	    }
	}
	if ( item_cnt == 0)
	    return;

	int arrow_size = z_height * 4 / 5;
	ll_x = (int)( ll.x * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	ll_y = (int)( ll.y * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	ur_x = ll_x + max_z_width + 15 + (pulldown_found * arrow_size);
	if ( ur_x - ll_x < (int)(min_width * cmn.mw.zoom_factor_x))
	    ur_x = ll_x + (int)(min_width * cmn.mw.zoom_factor_x);
	ur_y = ll_y + (int)(tot_z_height);

	if ( ur_y > cmn.getHeight()  + cmn.mw.subwindow_y) {
	    // Outside window border
	    ur_y = cmn.getHeight() + cmn.mw.subwindow_y;
	    ll_y = ur_y - (int)(tot_z_height);
	    ll.posit( ll.x, (ll_y  + cmn.mw.offset_y) / cmn.mw.zoom_factor_x);
	    ur.posit( ur.x, (ur_y + cmn.mw.offset_y) / cmn.mw.zoom_factor_y); // Might not always be correct?
	    ll_x = (int)( ll.x * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	    ll_y = (int)( ll.y * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	    ur_x = ll_x + max_z_width + 15 + (pulldown_found * arrow_size);
	    ur_y = ll_y + (int)(tot_z_height);
	}
	else
	    ur.posit( (ur_x  + cmn.mw.offset_x)/ cmn.mw.zoom_factor_x, (ur_y  + cmn.mw.offset_y)/ cmn.mw.zoom_factor_y);
	ll_y = (int)( ll.y * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	get_node_borders();

	if ( fill != 0) {
	    cmn.gdraw.fill_rect(ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, fill_drawtype);
	}
	item_height = tot_z_height / item_cnt;
	int x_text = ll_x + 3;
	int y_text;
	int drawtype;

	int item_idx = 0;
	for ( i = 0; i < info.item.length; i++) {
	    if ( info.item[i].occupied) {
		y_text = ll_y + (int)( item_height * item_idx + z_height + 1);
		if ( i == current_item) {
		    if ( fill_drawtype % 10 < 7)
			drawtype = GlowColor.shift_drawtype( fill_drawtype, 2, null);
		    else
			drawtype = GlowColor.shift_drawtype( fill_drawtype, -2, null);
		    cmn.gdraw.fill_rect(ll_x, (int)(ll_y + item_idx * item_height), ur_x - ll_x, 
					(int)(item_height), drawtype);
		}
		if ( info.item[i].type == Glow.eMenuItem_ButtonDisabled)
		    cmn.gdraw.text(x_text, y_text, info.item[i].text, text_drawtype, 
				      text_color_disabled, text_idx, highlight, 0, font, tsize, 0);
		else
		    cmn.gdraw.text(x_text, y_text, info.item[i].text, text_drawtype, 
				      text_color, text_idx, highlight, 0, font, tsize, 0);
		if ( info.item[i].type == Glow.eMenuItem_PulldownMenu) {
		    // Draw arrow
		    GlowPointX[] p = new GlowPointX[4];
		    for ( int j = 0; j < 4; j++)
			p[j] = new GlowPointX();
		    p[0].x = ur_x - arrow_size - 2;
		    p[0].y = (int)(ll_y + item_idx * item_height + item_height/2 - arrow_size/2);
		    p[1].x = ur_x - 2;
		    p[1].y = (int)(ll_y + item_idx * item_height + item_height/2);
		    p[2].x = ur_x - arrow_size - 2;
		    p[2].y = (int)(ll_y + item_idx * item_height + item_height/2 + arrow_size/2);
		    p[3].x = ur_x - arrow_size - 2;
		    p[3].y = (int)(ll_y + item_idx * item_height + item_height/2 - arrow_size/2);
      
		    cmn.gdraw.fill_polyline(p, 4, Glow.eDrawType_MediumGray, 0);
		}
		item_idx++;
	    }
	}
	if ( border != 0) {
	    cmn.gdraw.rect(ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, draw_type, idx, 0);
	}
    }

    int local_event_handler(GlowEvent event, double x, double y) {
	double ll_x, ur_x, ll_y, ur_y;

	ll_x = Math.min( ll.x, ur.x);
	ur_x = Math.max( ll.x, ur.x);
	ll_y = Math.min( ll.y, ur.y);
	ur_y = Math.max( ll.y, ur.y);

	if ( ll_x <= x && x <= ur_x &&
	     ll_y <= y && y <= ur_y) {
	    int item;
	    double vscale = trf.vertical_scale(null);

	    item = (int)((y - ll.y) / ( item_height / vscale / cmn.mw.zoom_factor_y));
	    if ( item > item_cnt - 1)
		item = item_cnt - 1;
	    if ( item < 0)
		item = 0;
	    if ( item != current_idx) {
		new_item = 1;
		old_item = current_item;
		current_idx = item;
		for ( int i = 0, item_idx = 0; i < 32; i++) {
		    if ( !info.item[i].occupied)
			continue;
		    if ( item_idx == item) {
			current_item = i;
			break;
		    }
		    item_idx++;
		}
	    }
	    else {
		new_item = 0;
		old_item = current_item;
	    }
	    return 1;
	}
	else {
	    new_item = 0;
	    return 0;
	}
    }

    public int eventHandler( GlowEvent event, double fx, double fy) {
	int sts;
	int csts;

	double rx, ry;

	// Convert koordinates to local koordinates
	GlowPointDX rp = trf.reverse( fx, fy);

	sts = 0;
	switch ( event.event) {
	case Glow.eEvent_CursorMotion: {
	    int redraw = 0;
	    sts = local_event_handler( event, rp.x, rp.y);
	    if ( sts != 0) {
		cmn.hot_found = 1;
		redraw = 1;
	    }
	    if ( sts != 0 && hot == 0) {
		hot = 1;
		redraw = 1;
	    }
	    if ( sts == 0 && hot != 0) {
		if ( cmn.hot_found == 0)
		hot = 0;
		redraw = 1;
	    }
	    if ( redraw != 0) {
		cmn.ctx.draw( x_left * cmn.mw.zoom_factor_x - cmn.mw.offset_x - Glow.DRAW_MP,
			      y_low * cmn.mw.zoom_factor_y - cmn.mw.offset_y - Glow.DRAW_MP,
			      x_right * cmn.mw.zoom_factor_x - cmn.mw.offset_x + Glow.DRAW_MP,
			      y_high * cmn.mw.zoom_factor_y - cmn.mw.offset_y + Glow.DRAW_MP);
	    }
	    if ( old_item != current_item && old_item != -1) {
		if ( info.item[old_item].type == Glow.eMenuItem_PulldownMenu) {
		    // Delete all child menu objects.
		    // TODO ctx->delete_menu_child( this);
		}
	    }
	    if ( hot != 0 && new_item != 0) {
		if ( info.item[current_item].type == Glow.eMenuItem_PulldownMenu)
		    cmn.ctx.send_menu_callback( this, current_item, Glow.eEvent_MenuCreate,
					     ur.x, ll.y + item_height / cmn.mw.zoom_factor_y * current_item);
	    }
	    break;
	}
	case Glow.eEvent_MB1Click: {
	    sts = local_event_handler( event, rp.x, rp.y);
	    if ( sts != 0 && current_item != -1) {
		if ( info.item[current_item].type == Glow.eMenuItem_Button) {
		    csts = cmn.ctx.send_menu_callback( this, current_item, Glow.eEvent_MenuActivated, fx, fy);
		    if ( csts == Glow.GLOW__TERMINATED)
			return csts;

		    // Send delete callback for the root menu of this node
		    GrowMenu e;
		    for ( e = this; e.parent_menu != null; e = (GrowMenu)e.parent_menu) 
			;
		    cmn.ctx.send_menu_callback( e, 0, Glow.eEvent_MenuDelete, 0, 0);
		    return Glow.GLOW__NO_PROPAGATE;
		}
	    }
	    break;
	}
	default:
	    sts = local_event_handler( event, rp.x, rp.y);
	}
	if ( sts != 0)
	    cmn.ctx.register_callback_object( Glow.eObjectType_Node, this);
	return sts;
    }
}
