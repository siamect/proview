/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jopg;
import jpwr.rt.*;
import java.io.*;
import java.util.*;

public class GrowNode extends GlowArrayElem implements GlowColorNode {
    public static final int MAX_CONPOINTS = 32;
    
    public int original_border_drawtype;
    public int border_drawtype;
    public int background_drawtype;
    public int original_fill_drawtype;
    public int original_text_drawtype;
    public int original_background_drawtype;
    public int original_color_tone;
    public int original_color_lightness;
    public int original_color_intensity;
    public int original_color_shift;
    public int color_inverse;
    public int color_lightness;
    public int color_intensity;
    public int color_shift;
    public int color_tone;
    public int fill_drawtype;
    public int text_drawtype;
    public int draw_type;
    public int dimmed;
    public int invisible;
    int flip_horizontal;
    int flip_vertical;
    int dynamicsize;
    GlowTransform trf = new GlowTransform();
    int arg_cnt;
    public int line_width;
    public int shadow;
    public int gradient;
    public int text_type;
    public int text_font;
    public int disable_cb;

    String nc_name;
    GlowNodeClass nc;
    GlowNodeClass nc_root;
    String n_name;
    double x_right;
    double x_left;
    double y_high;
    double y_low;
    int annotsize[] = new int[10];
    public String annotv[] = new String[10];
    GlowPoint pos;
    public int access;
    public int cycle;
    String ref_object;
    Object userdata;

    public int visible;
    public int highlight;
    public int hot;
    public int input_selected;
    public int annotv_inputmode[] = new int[10];
    public double fill_level = 1;
    public int level_fill_drawtype;
    public int level_color_tone;
    public int level_direction;    
    public int annot_scrollingtext = -1;
    public double annot_offset_x = 0;
    public double annot_offset_y = 0;

    GrowCmn cmn;

    public GrowNode(GrowCmn cmn) {
	this.cmn = cmn;
	pos = new GlowPoint();
	visible = 1;
	original_border_drawtype = Glow.eDrawType_No;
	original_text_drawtype = Glow.eDrawType_No;
	original_fill_drawtype = Glow.eDrawType_No;	
	original_background_drawtype = Glow.eDrawType_No;	
	fill_drawtype = Glow.eDrawType_No;
	level_fill_drawtype = Glow.eDrawType_No;
	background_drawtype = Glow.eDrawType_No;
	original_color_tone = Glow.eDrawTone_No;
	color_tone = Glow.eDrawTone_No;
	level_color_tone = Glow.eDrawTone_No;
	text_type = Glow.eDrawType_TextHelvetica;
	text_font = Glow.eFont_No;
    }

    public int type() {
	return Glow.eObjectType_GrowNode;
    }
    public Object getCmn() { 
	return cmn;
    }

    public void open(BufferedReader reader) {
	String line;
	StringTokenizer token;
	boolean end_found = false;

	try {
	    while( (line = reader.readLine()) != null) {
		token = new StringTokenizer(line);
		int key = Integer.valueOf(token.nextToken());
		if ( cmn.debug) System.out.println( "GrowNode : " + line);

		switch ( key) {
		case Glow.eSave_GrowNode: 
		    break;
		case Glow.eSave_GrowNode_original_border_drawtype: 
		    original_border_drawtype = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_original_fill_drawtype: 
		    original_fill_drawtype = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_fill_drawtype: 
		    fill_drawtype = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_text_drawtype: 
		    text_drawtype = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_original_text_drawtype: 
		    original_text_drawtype = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_draw_type: 
		    draw_type = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_original_color_tone: 
		    original_color_tone = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_original_background_drawtype: 
		    original_background_drawtype = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_background_drawtype: 
		    background_drawtype = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_color_tone: 
		    color_tone = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_original_color_lightness: 
		    original_color_lightness = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_color_lightness: 
		    color_lightness = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_original_color_intensity: 
		    original_color_intensity = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_color_intensity: 
		    color_intensity = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_original_color_shift: 
		    original_color_shift = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_color_shift: 
		    color_shift = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_invisible: 
		    invisible = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_flip_horizontal: 
		    flip_horizontal = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_flip_vertical: 
		    flip_vertical = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_dynamicsize:
		    dynamicsize = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowNode_dynamic:
		    if ( dynamicsize > 0) {
			for ( int j = 0; j < cmn.dynamicsize; j++) 
			    reader.readLine();  // TODO handle backslash and citationmarks
		    }
		    break;
		case Glow.eSave_GrowNode_node_part: 
		    glownode_open( reader);
		    break;
		case Glow.eSave_GrowNode_trf: 
		    trf.open( reader);
		    break;
		case Glow.eSave_GrowNode_arg_cnt:
		    arg_cnt = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowNode_argsize:
		    for ( int j = 0; j < arg_cnt; j++) 
			reader.readLine();
		    break;
		case Glow.eSave_GrowNode_argv:
		    for ( int j = 0; j < arg_cnt; j++) 
			reader.readLine();
		    break;
		case Glow.eSave_GrowNode_line_width: 
		    line_width = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_shadow: 
		    shadow = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowNode_gradient:
		    gradient = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowNode_text_type:
		    text_type = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowNode_text_font:
		    text_font = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowNode_disable_cb:
		    disable_cb = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowNode_userdata_cb:
		    if ( cmn.appl != null)
			userdata = cmn.appl.growUserdataOpen( reader, this, Glow.eUserdataCbType_Node);
		    break;
		case Glow.eSave_End:
		    end_found = true;
		    break;
		default:
		    System.out.println( "Syntax error in GrowNode");
		    break;
		}
		if ( end_found)
		    break;
	    }
		
	} catch ( Exception e) {
	    System.out.println( "IOException GrowNode");
	}
    }

    public void glownode_open(BufferedReader reader) {
	String line;
	StringTokenizer token;
	boolean end_found = false;

	try {
	    while( (line = reader.readLine()) != null) {
		token = new StringTokenizer(line);
		int key = Integer.valueOf(token.nextToken());
		if ( cmn.debug) System.out.println( "GlowNode : " + line);

		switch ( key) {

		case Glow.eSave_Node: 
		    break;
		case Glow.eSave_Node_nc:
		    nc_name = token.nextToken();
		    if ( type() != Glow.eObjectType_GrowGroup) {
			nc = (GlowNodeClass)cmn.ctx.get_nodeclass_from_name( nc_name);
			nc_root = nc;
			if ( nc == null)
			    System.out.println( "GlowNode : " + line + ", node class not found: " + nc_name);
		    }
		    break;
		case Glow.eSave_Node_n_name:
		    if ( token.hasMoreTokens())
			n_name = token.nextToken();
		    break;
		case Glow.eSave_Node_refcon_cnt: 
		    for ( int i = 0; i < MAX_CONPOINTS; i++)
			reader.readLine();
		    break;
		case Glow.eSave_Node_x_right: 
		    x_right = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_Node_x_left: 
		    x_left = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_Node_y_high: 
		    y_high = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_Node_y_low: 
		    y_low = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_Node_obst_x_right: 
		case Glow.eSave_Node_obst_x_left: 
		case Glow.eSave_Node_obst_y_high: 
		case Glow.eSave_Node_obst_y_low:
		    break;
		case Glow.eSave_Node_annotsize: 
		    for ( int i = 0; i < 10; i++) {
			line = reader.readLine();
			token = new StringTokenizer(line);
			annotsize[i] = Integer.valueOf(token.nextToken());
			if (cmn.debug)
			    System.out.println("GlowNode  annotsize: " + annotsize[i]);
		    }
		    break;
		case Glow.eSave_Node_annotv: 
		    for ( int i = 0; i < 10; i++) {
			if ( annotsize[i] != 0) {
			    line = reader.readLine();			
			    annotv[i] = line.substring(1, line.length()-1);
			    if ( cmn.debug)
				System.out.println("GrowNode  annotv: " + annotv[i]);
			}
		    }
		    break;
		case Glow.eSave_Node_pos: 
		    pos.open( reader);
		    break;
		case Glow.eSave_Node_trace_data1: 
		case Glow.eSave_Node_trace_data2: 
		case Glow.eSave_Node_trace_data3: 
		case Glow.eSave_Node_trace_data4: 
		case Glow.eSave_Node_trace_data5: 
		case Glow.eSave_Node_trace_data6: 
		case Glow.eSave_Node_trace_data7: 
		case Glow.eSave_Node_trace_data8: 
		case Glow.eSave_Node_trace_data9: 
		case Glow.eSave_Node_trace_data10: 
		case Glow.eSave_Node_trace_attr_type: 
		case Glow.eSave_Node_trace_color: 
		case Glow.eSave_Node_trace_color2: 
		    break;
		case Glow.eSave_Node_access:
		    access = Long.valueOf(token.nextToken()).intValue();
		    break;
		case Glow.eSave_Node_cycle:
		    cycle = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_Node_ref_object:
		    if ( token.hasMoreTokens())
			ref_object = token.nextToken();
		    break;
		case Glow.eSave_End:
		    end_found = true;
		    break;
		default:
		    System.out.println( "Syntax error in GlowNode");
		    break;
		}
		if ( end_found)
		    break;

	    }

	} catch ( Exception e) {
	    System.out.println( "IOException GlowNode");
	}
    }

    public int eventHandler( GlowEvent event, double fx, double fy) {
	GlowPointDX rp;
	int sts;

	if ( visible == 0 || dimmed != 0)
	    return 0;

	switch ( event.event) {
	case Glow.eEvent_CursorMotion:		
	    return 0;
	default: ;
	}

	rp = trf.reverse( fx, fy);
	sts = nc.eventHandler(event, rp.x, rp.y);
	if ( sts != 0) {
	    if ( !(type() == Glow.eObjectType_GrowGroup && cmn.callback_object != null))
		cmn.ctx.register_callback_object(Glow.eObjectType_Node, this);
	    return sts;
	}
	/*
	if ( ll.x <= rp.x && rp.x <= ur.x &&
	     ll.y <= rp.y && rp.y <= ur.y) {
	    System.out.println( "Event handler: Hit in rect");
	    return 1;
	}  
	else
	*/
	return 0;
    }

    public void draw() {
	if ( visible != 0)
	    //nc.draw( trf, highlight, hot, this, this);
	    draw(null, highlight, hot, null, null);
    }
    public void draw(GlowTransform t, int highlight, int hot, Object node, Object colornode) {
	if ( cmn.nodraw != 0)
	    return;

	if ( node == null)
	    node = this;
	if ( colornode == null)
	    colornode = this;
	else if ( ((GrowNode)colornode).fill_drawtype == Glow.eDrawType_No && 
		  ((GrowNode)colornode).color_tone == Glow.eDrawTone_No)
	    colornode = this;

	if ( ((GrowNode)node).invisible != 0 || invisible != 0)
	    return;

	if ( annot_scrollingtext != -1)
	    cmn.gdraw.set_clip_rectangle( (int)(x_left * cmn.mw.zoom_factor_x - cmn.mw.offset_x), 
					  (int)(y_low * cmn.mw.zoom_factor_y - cmn.mw.offset_y),
					  (int)(x_right * cmn.mw.zoom_factor_x - cmn.mw.offset_x), 
					  (int)(y_high * cmn.mw.zoom_factor_y - cmn.mw.offset_y));

	if ( fill_level == 1) {
	    if ( t != null) {
		GlowTransform trf_tot = t.multiply(trf);

		nc.draw( trf_tot, highlight, hot, this, this);
	    }
	    else
		nc.draw( trf, highlight, hot, node, node);
	}
	else {
	    int x1, x2, y1, y2;
	    int x_level = 0;
	    int y_level = 0;
	    int clip_sts = 0;
	    int old_color_tone = 0;
	    int old_fill_drawtype = 0;
	    
	    if (t == null) {
		x1 = (int)( x_left * cmn.mw.zoom_factor_x + 0.5) - cmn.mw.offset_x;
		y1 = (int)( y_low * cmn.mw.zoom_factor_y + 0.5) - cmn.mw.offset_y;
		x2 = (int)( x_right * cmn.mw.zoom_factor_x + 0.5) - cmn.mw.offset_x;
		y2 = (int)( y_high * cmn.mw.zoom_factor_y + 0.5) - cmn.mw.offset_y;
	    }
	    else {
		x1 = (int)( t.x( x_left, y_low) * cmn.mw.zoom_factor_x + 0.5) - cmn.mw.offset_x;
		y1 = (int)( t.y( x_left, y_low) * cmn.mw.zoom_factor_y + 0.5) - cmn.mw.offset_y;
		x2 = (int)( t.x( x_right, y_high) * cmn.mw.zoom_factor_x + 0.5) - cmn.mw.offset_x;
		y2 = (int)( t.y( x_right, y_high) * cmn.mw.zoom_factor_y + 0.5) - cmn.mw.offset_y;
	    }
	    switch ( level_direction) {
	    case Glow.eDirection_Right:
		x_level = (int)( fill_level * (x2 - x1) + 0.5);
		clip_sts = cmn.gdraw.set_clip_rectangle( x1 - 1, y1 - 1, x1 + x_level, y2 + 1);
		break;
	    case Glow.eDirection_Left:
		x_level = (int)( (1 - fill_level) * ( x2 - x1) + 0.5);
		clip_sts = cmn.gdraw.set_clip_rectangle( x1 - 1, y1 - 1, x1 + x_level, y2 + 1);
		if ( level_color_tone != Glow.eDrawTone_No) {
		    old_color_tone = color_tone;
		    color_tone = level_color_tone;
		}
		else if ( level_fill_drawtype != Glow.eDrawType_No) {
		    old_fill_drawtype = fill_drawtype;
		    fill_drawtype = level_fill_drawtype;
		}
		break;
	    case Glow.eDirection_Up:
		y_level = (int)( fill_level * (y2 - y1) + 0.5);
		clip_sts = cmn.gdraw.set_clip_rectangle( x1 - 1, y1 - 1, x2 + 1, y1 + y_level);
		break;
	    case Glow.eDirection_Down:
		y_level = (int)( (1 - fill_level) * ( y2 - y1) + 0.5);
		clip_sts = cmn.gdraw.set_clip_rectangle( x1 - 1, y1 - 1, x2 + 1, y1 + y_level);
		if ( level_color_tone != Glow.eDrawTone_No) {
		    old_color_tone = color_tone;
		    color_tone = level_color_tone;
		}
		else if ( level_fill_drawtype != Glow.eDrawType_No) {
		    old_fill_drawtype = fill_drawtype;
		    fill_drawtype = level_fill_drawtype;
		}
		break;
	    default: ;
	    }
	    
	    if ( t != null) {
		GlowTransform trf_tot = t.multiply( trf);

		// If this node has a trace pointer, use colors for this node
		nc.draw( trf_tot, highlight, hot, this, this);
	    }
	    else
		nc.draw( trf, highlight, hot, node, node);
	    if ( (clip_sts & 1) != 0)
		cmn.gdraw.reset_clip_rectangle();

	    switch ( level_direction) {
	    case Glow.eDirection_Right:
		if ( level_color_tone != Glow.eDrawTone_No) {
		    old_color_tone = color_tone;
		    color_tone = level_color_tone;
		}
		else if ( level_fill_drawtype != Glow.eDrawType_No) {
		    old_fill_drawtype = fill_drawtype;
		    fill_drawtype = level_fill_drawtype;
		}
		clip_sts = cmn.gdraw.set_clip_rectangle( x1 + x_level, y1 - 1, x2 + 1, y2 + 1);
		break;
	    case Glow.eDirection_Left:
		if ( level_color_tone != Glow.eDrawTone_No)
		    color_tone = old_color_tone;
		else if ( level_fill_drawtype != Glow.eDrawType_No)
		    fill_drawtype = old_fill_drawtype;
		clip_sts = cmn.gdraw.set_clip_rectangle( x1 + x_level, y1 - 1, x2 + 1, y2 + 1);
		break;
	    case Glow.eDirection_Up:
		if ( level_color_tone != Glow.eDrawTone_No) {
		    old_color_tone = color_tone;
		    color_tone = level_color_tone;
		}
		else if ( level_fill_drawtype != Glow.eDrawType_No) {
		    old_fill_drawtype = fill_drawtype;
		    fill_drawtype = level_fill_drawtype;
		}
		clip_sts = cmn.gdraw.set_clip_rectangle( x1 - 1, y1 + y_level, x2 + 1, y2 + 1);
		break;
	    case Glow.eDirection_Down:
		if ( level_color_tone != Glow.eDrawTone_No)
		    color_tone = old_color_tone;
		else if ( level_fill_drawtype != Glow.eDrawType_No)
		    fill_drawtype = old_fill_drawtype;
		clip_sts = cmn.gdraw.set_clip_rectangle( x1 - 1, y1 + y_level, x2 + 1, y2 + 1);
		break;
	    default: ;
	    }

	    if ( t != null) {
		GlowTransform trf_tot = t.multiply( trf);

		// If this node has a trace pointer, use colors for this node
		nc.draw( trf_tot, highlight, hot, this, this);
	    }
	    else
		nc.draw( trf, highlight, hot, node, node);
	    if ( (clip_sts & 1) != 0)
		cmn.gdraw.reset_clip_rectangle();

	    switch ( level_direction) {
	    case Glow.eDirection_Right:
		if ( level_color_tone != Glow.eDrawTone_No)
		    color_tone = old_color_tone;
		else if ( level_fill_drawtype != Glow.eDrawType_No)
		    fill_drawtype = old_fill_drawtype;
		break;
	    case Glow.eDirection_Left:
		break;
	    case Glow.eDirection_Up:
		if ( level_color_tone != Glow.eDrawTone_No)
		    color_tone = old_color_tone;
		else if ( level_fill_drawtype != Glow.eDrawType_No)
		    fill_drawtype = old_fill_drawtype;
		break;
	    case Glow.eDirection_Down:
		break;
	    default: ;
	    }
	}

	if ( annot_scrollingtext != -1)
	    cmn.gdraw.reset_clip_rectangle();
    }

    public int getClassTraceColor1() {
	return nc.dyn_color[0];
    }
    public int getClassTraceColor2() {
	return nc.dyn_color[1];
    }
    public int getClassDynType1() {
	return nc.dyn_type1;
    }
    public int getClassDynType2() {
	return nc.dyn_type2;
    }
    public int getClassActionType1() {
	return nc.action_type1;
    }
    public int getClassActionType2() {
	return nc.action_type2;
    }
    public int getClassCycle() {
	return nc.cycle;
    }
    public Object getClassUserData() {
	return nc.userdata;
    }
    public Object getUserData() {
	return userdata;
    }
    public void setUserData( Object userdata) {
	this.userdata = userdata;
    }
    public void setColorTone(int color_tone) {
	this.color_tone = color_tone;
    }
    public void resetColorTone() {
	color_tone = original_color_tone;
    }
    public void setFillColor(int fill_drawtype) {

	this.fill_drawtype = fill_drawtype;
	color_tone = Glow.eDrawTone_No;
	color_shift = 0;
	color_lightness = 0;
	color_intensity = 0;
    }
    public void resetFillColor() {
	fill_drawtype = original_fill_drawtype;
	color_tone = original_color_tone;
	color_shift = original_color_shift;
	color_lightness = original_color_lightness;
	color_intensity = original_color_intensity;
    }
    public void setBorderColor(int draw_type) {
	this.draw_type = draw_type;
	color_tone = Glow.eDrawTone_No;
	color_shift = 0;
	color_lightness = 0;
	color_intensity = 0;
    }
    public void resetBorderColor() {
	draw_type = original_border_drawtype;
    }
    public void setTextColor(int draw_type) {
	text_drawtype = draw_type;
	color_tone = Glow.eDrawTone_No;
	color_shift = 0;
	color_lightness = 0;
	color_intensity = 0;
    }
    public void resetTextColor() {
	text_drawtype = original_text_drawtype;
    }
    public void setBackgroundColor(int draw_type) {
	background_drawtype = draw_type;
    }
    public void resetBackgroundColor() {
	background_drawtype = original_background_drawtype;
    }
    public void setColorInverse(int color_inverse) {
	this.color_inverse = color_inverse;
    }
    public void setLevelFillColor(int color) {
	level_fill_drawtype = color;
    }
    public void setLevelColorTone(int tone) {
	level_color_tone = tone;
    }
    public void setLevelDirection( int level_direction) {
	this.level_direction = level_direction;
    }
    public void setFillLevel(double fill_level) {
	this.fill_level = fill_level;
    }
    public String getAnnotation(int number) {
	return annotv[number];
    }
    public void setAnnotation(int number, String annot) {
	annotv[number] = annot;
    }
    public void setAnnotationTextOffset( int num, double x, double y) {
	if ( annot_scrollingtext == -1)
	    annot_scrollingtext = num;
	if ( num == annot_scrollingtext) {
	    annot_offset_x = x;
	    annot_offset_y = y;
	}
    }

    public GlowDimensionD getAnnotationTextExtent( int num) {
	return nc.getAnnotationTextExtent( trf, this, num);
    }
    public void setVisibility( int visibility) {
	switch ( visibility) {
	case Glow.eVis_Visible:
	    visible = 1;
	    dimmed = 0;
	    break;
	case Glow.eVis_Invisible:
	    visible = 0;
	    dimmed = 0;
	    draw();
	    break;
	case Glow.eVis_Dimmed:
	    visible = 1;
	    dimmed = 1;
	    draw();
	    break;
	}
    }

    void setRotation( double angel, double x0, double y0, int type) {
	double old_x_left, old_x_right, old_y_low, old_y_high;
	GlowTransform t = new GlowTransform();

	if ( Math.abs( angel - trf.rotation + trf.s_rotation) < Float.MIN_VALUE)
	    return;

	switch( type) {
	case Glow.eRotationPoint_LowerLeft:
	    x0 = x_left;
	    y0 = y_low;
	    break;
	case Glow.eRotationPoint_LowerRight:
	    x0 = x_right;
	    y0 = y_low;
	    break;
	case Glow.eRotationPoint_UpperRight:
	    x0 = x_right;
	    y0 = y_high;
	    break;
	case Glow.eRotationPoint_UpperLeft:
	    x0 = x_left;
	    y0 = y_high;
	    break;
	case Glow.eRotationPoint_Center:
	    x0 = (x_left + x_right) / 2;
	    y0 = (y_high + y_low) / 2;
	    break;
	case Glow.eRotationPoint_Zero:
	    x0 = trf.s_a13;
	    y0 = trf.s_a23;
	    break;
	default:
	    ;
	}

	old_x_left = x_left;
	old_x_right = x_right;
	old_y_low = y_low;
	old_y_high = y_high;

	System.out.println("Trf rotate " + angel + " x0 " + x0 + " y0 " + y0);
	t.rotate( angel, x0, y0);
	trf.set_from_stored( t);
	get_node_borders();
    }
    
    public void storeTransform() {
	trf.store();
    }
    public boolean transformIsStored() {
	return trf.is_stored();
    }
    void get_node_borders() {
	GlowGeometry g = new GlowGeometry();

	g.ur_x = 10e-37;
	g.ll_x = 10e37;
	g.ur_y = 10e-37;
	g.ll_y = 10e37;

	nc.get_borders( trf, g);
	x_left = g.ll_x;
	x_right = g.ur_x;
	y_low = g.ll_y;
	y_high = g.ur_y;
    }

    public void get_borders( GlowTransform t, GlowGeometry g) {
	if ( t != null) {
	    GlowTransform t2 = t.multiply(trf);
	    nc.get_borders(t2, g);
	}
	else
	    nc.get_borders(trf, g);
    }

    int set_next_nodeclass() {
	if ( nc.next_nc != null) {
	    set_nodeclass( (GlowNodeClass)nc.next_nc);
	    return 1;    
	}
	return 0;
    }

    void set_first_nodeclass() {
	set_root_nodeclass();
    }

    void set_last_nodeclass() {
	GlowArrayElem next;
	for ( next = nc_root; 
	      ((GlowNodeClass)next).next_nc != null; 
	      next = ((GlowNodeClass)next).next_nc)
	    ;
	if ( next != nc)
	    set_nodeclass( (GlowNodeClass)next);
    }

    int set_nodeclass_by_index( int idx) {
	GlowArrayElem next;
	int i;

	next = nc_root;
	for ( i = 0; i < idx; i++) {
	    if ( ((GlowNodeClass)next).next_nc == null)
		return 0;
	    next = ((GlowNodeClass)next).next_nc;
	}
	if ( next != nc)
	    set_nodeclass( (GlowNodeClass)next);
	return 1;
    }

    int set_previous_nodeclass() {
	if ( nc.prev_nc != null) {
	    set_nodeclass( (GlowNodeClass)nc.prev_nc);
	    return 1;    
	}
	return 0;
    }

    void set_root_nodeclass() {
	if ( nc_root != nc)
	    set_nodeclass( nc_root);
    }

    int get_animation_count() {
	return nc.animation_count;
    }

    int get_nodeclass_dyn_attr1() {
	return nc.dyn_attr[0];
    }

    void set_nodeclass( GlowNodeClass new_nc) {
	double old_x_left, old_x_right, old_y_low, old_y_high;

	old_x_left = x_left;
	old_x_right = x_right;
	old_y_low = y_low;
	old_y_high = y_high;

	nc = new_nc;

	get_node_borders();
	old_x_left = Math.min( old_x_left, x_left);
	old_x_right = Math.max( old_x_right, x_right);
	old_y_low = Math.min( old_y_low, y_low);
	old_y_high = Math.max( old_y_high, y_high);	
	cmn.ctx.draw( old_x_left * cmn.mw.zoom_factor_x - cmn.mw.offset_x - Glow.DRAW_MP,
		      old_y_low * cmn.mw.zoom_factor_y - cmn.mw.offset_y - Glow.DRAW_MP,
		      old_x_right * cmn.mw.zoom_factor_x - cmn.mw.offset_x + Glow.DRAW_MP,
		      old_y_high * cmn.mw.zoom_factor_y - cmn.mw.offset_y + Glow.DRAW_MP);
    }

    public GlowFillLevelLimits getLimits()
    {
	GlowFillLevelLimits limits = new GlowFillLevelLimits();

	if ( nc.y0 == 0 && nc.y1 == 0) {
	    limits.status = 0;
	    return limits;
	}
	if ( !(nc.x0 == 0 && nc.x1 == 0)) {
	    limits.status = 0;
	    return limits;
	}

	double x1, x2, y1, y2;
	double rotation;

	// Calculate max and min coordinates

	x1 = trf.x( 0, nc.y0);
	y1 = trf.y( 0, nc.y0);
	x2 = trf.x( 0, nc.y1);
	y2 = trf.y( 0, nc.y1);

	rotation = (trf.rot() / 360 - Math.floor( trf.rot() / 360)) * 360;

	if ( 45 >= rotation || rotation > 315) {
	    limits.direction = Glow.eDirection_Down;
	    limits.min = y1;
	    limits.max = y2;
	}
	else if ( 45 < rotation && rotation <= 135) {
	    limits.direction = Glow.eDirection_Right;
	    limits.min = x2;
	    limits.max = x1;
	}
	else if ( 135 < rotation && rotation <= 225) {
	    limits.direction = Glow.eDirection_Up;
	    limits.min = y2;
	    limits.max = y1;
	}
	else if ( 225 < rotation && rotation <= 315) {
	    limits.direction = Glow.eDirection_Left;
	    limits.min = x1;
	    limits.max = x2;
	}
	limits.status = 1;
	return limits;
    }

    public GlowGeometry measure() {
	GlowGeometry geom = new GlowGeometry();
	geom.ll_x = x_left;
	geom.ll_y = y_low;
	geom.ur_x = x_right;
	geom.ur_y = y_high;

	return geom;
    }

    public void move_to( double x, double y) {
	double old_x_left = x_left;
	double old_x_right = x_right;
	double old_y_low = y_low;
	double old_y_high = y_high;

	trf.move( x - x_left, y - y_low);
	get_node_borders();

	//draw();
	cmn.ctx.draw( old_x_left * cmn.mw.zoom_factor_x - cmn.mw.offset_x - Glow.DRAW_MP,
		      old_y_low * cmn.mw.zoom_factor_y - cmn.mw.offset_y - Glow.DRAW_MP,
		      old_x_right * cmn.mw.zoom_factor_x - cmn.mw.offset_x + Glow.DRAW_MP,
		      old_y_high * cmn.mw.zoom_factor_y - cmn.mw.offset_y + Glow.DRAW_MP);
	cmn.ctx.draw( x_left * cmn.mw.zoom_factor_x - cmn.mw.offset_x - Glow.DRAW_MP,
		      y_low * cmn.mw.zoom_factor_y - cmn.mw.offset_y - Glow.DRAW_MP,
		      x_right * cmn.mw.zoom_factor_x - cmn.mw.offset_x + Glow.DRAW_MP,
		      y_high * cmn.mw.zoom_factor_y - cmn.mw.offset_y + Glow.DRAW_MP);
    }

    public void move( double x, double y) {
	double old_x_left = x_left;
	double old_x_right = x_right;
	double old_y_low = y_low;
	double old_y_high = y_high;

	trf.move( x, y);
	get_node_borders();

	//draw();
	cmn.ctx.draw( old_x_left * cmn.mw.zoom_factor_x - cmn.mw.offset_x - Glow.DRAW_MP,
		      old_y_low * cmn.mw.zoom_factor_y - cmn.mw.offset_y - Glow.DRAW_MP,
		      old_x_right * cmn.mw.zoom_factor_x - cmn.mw.offset_x + Glow.DRAW_MP,
		      old_y_high * cmn.mw.zoom_factor_y - cmn.mw.offset_y + Glow.DRAW_MP);
	cmn.ctx.draw( x_left * cmn.mw.zoom_factor_x - cmn.mw.offset_x - Glow.DRAW_MP,
		      y_low * cmn.mw.zoom_factor_y - cmn.mw.offset_y - Glow.DRAW_MP,
		      x_right * cmn.mw.zoom_factor_x - cmn.mw.offset_x + Glow.DRAW_MP,
		      y_high * cmn.mw.zoom_factor_y - cmn.mw.offset_y + Glow.DRAW_MP);
    }

    public void set_position( double x, double y) {
	double old_x_left, old_x_right, old_y_low, old_y_high;

	if ( trf.a13 == trf.s_a13 + x && trf.a23 == trf.s_a23 + y)
	    return;
	old_x_left = x_left;
	old_x_right = x_right;
	old_y_low = y_low;
	old_y_high = y_high;
	trf.move_from_stored( x, y);
	get_node_borders();
	cmn.ctx.draw( old_x_left * cmn.mw.zoom_factor_x - cmn.mw.offset_x - Glow.DRAW_MP,
		      old_y_low * cmn.mw.zoom_factor_y - cmn.mw.offset_y - Glow.DRAW_MP,
		      old_x_right * cmn.mw.zoom_factor_x - cmn.mw.offset_x + Glow.DRAW_MP,
		      old_y_high * cmn.mw.zoom_factor_y - cmn.mw.offset_y + Glow.DRAW_MP);
	cmn.ctx.draw( x_left * cmn.mw.zoom_factor_x - cmn.mw.offset_x - Glow.DRAW_MP,
		      y_low * cmn.mw.zoom_factor_y - cmn.mw.offset_y - Glow.DRAW_MP,
		      x_right * cmn.mw.zoom_factor_x - cmn.mw.offset_x + Glow.DRAW_MP,
		      y_high * cmn.mw.zoom_factor_y - cmn.mw.offset_y + Glow.DRAW_MP);
    }

    public void set_scale_pos( double x, double y, 
			       double scale_x, double scale_y, 
			       double x0, double y0, int type) {
	double old_x_left, old_x_right, old_y_low, old_y_high;

	old_x_left = x_left;
	old_x_right = x_right;
	old_y_low = y_low;
	old_y_high = y_high;

	cmn.setNodraw();
	set_scale( scale_x, scale_y, x0, y0, type);
	cmn.resetNodraw();
	trf.move( x - x_left, y - y_low);
	get_node_borders();

	/*
	ctx->set_defered_redraw();
	ctx->draw( &ctx->mw, old_x_left * ctx->mw.zoom_factor_x - ctx->mw.offset_x - DRAW_MP,
		   old_y_low * ctx->mw.zoom_factor_y - ctx->mw.offset_y - DRAW_MP,
		   old_x_right * ctx->mw.zoom_factor_x - ctx->mw.offset_x + DRAW_MP,
		   old_y_high * ctx->mw.zoom_factor_y - ctx->mw.offset_y + DRAW_MP);
	ctx->draw( &ctx->mw, x_left * ctx->mw.zoom_factor_x - ctx->mw.offset_x - DRAW_MP,
		   y_low * ctx->mw.zoom_factor_y - ctx->mw.offset_y - DRAW_MP,
		   x_right * ctx->mw.zoom_factor_x - ctx->mw.offset_x + DRAW_MP,
		   y_high * ctx->mw.zoom_factor_y - ctx->mw.offset_y + DRAW_MP);
	ctx->draw( &ctx->navw,  old_x_left * ctx->navw.zoom_factor_x - ctx->navw.offset_x - 1,
		   old_y_low * ctx->navw.zoom_factor_y - ctx->navw.offset_y - 1,
		   old_x_right * ctx->navw.zoom_factor_x - ctx->navw.offset_x + 1,
		   old_y_high * ctx->navw.zoom_factor_y - ctx->navw.offset_y + 1);
	ctx->draw( &ctx->navw,  x_left * ctx->navw.zoom_factor_x - ctx->navw.offset_x - 1,
		   y_low * ctx->navw.zoom_factor_y - ctx->navw.offset_y - 1,
		   x_right * ctx->navw.zoom_factor_x - ctx->navw.offset_x + 1,
		   y_high * ctx->navw.zoom_factor_y - ctx->navw.offset_y + 1);
	ctx->redraw_defered();
	*/
    }

    public void set_scale( double scale_x, double scale_y, 
			   double x0, double y0, int type) {
	double old_x_left, old_x_right, old_y_low, old_y_high;

	if ( !((scale_x == -1 && scale_y == 1) || (scale_x == 1 && scale_y == -1))) {
	    if ( scale_x < 0)
		scale_x = 0;
	    if ( scale_y < 0)
		scale_y = 0;
	}

	if ( trf.s_a11 != 0 && trf.s_a22 != 0 &&
	     Math.abs( scale_x - trf.a11 / trf.s_a11) < Float.MIN_VALUE &&
	     Math.abs( scale_y - trf.a22 / trf.s_a22) < Float.MIN_VALUE)
	    return;

	switch( type) {
	case Glow.eScaleType_LowerLeft:
	    x0 = x_left;
	    y0 = y_low;
	    break;
	case Glow.eScaleType_LowerRight:
	    x0 = x_right;
	    y0 = y_low;
	    break;
	case Glow.eScaleType_UpperRight:
	    x0 = x_right;
	    y0 = y_high;
	    break;
	case Glow.eScaleType_UpperLeft:
	    x0 = x_left;
	    y0 = y_high;
	    break;
	case Glow.eScaleType_FixPoint:
	    break;
	case Glow.eScaleType_Center:
	    x0 = (x_left + x_right) / 2;
	    y0 = (y_low + y_high) /2;
	    break;
	default:
	    ;
	}

	old_x_left = x_left;
	old_x_right = x_right;
	old_y_low = y_low;
	old_y_high = y_high;
	trf.scale_from_stored( scale_x, scale_y, x0, y0);
	get_node_borders();

	/*
	ctx->draw( &ctx->mw, old_x_left * ctx->mw.zoom_factor_x - ctx->mw.offset_x - DRAW_MP,
		   old_y_low * ctx->mw.zoom_factor_y - ctx->mw.offset_y - DRAW_MP,
		   old_x_right * ctx->mw.zoom_factor_x - ctx->mw.offset_x + DRAW_MP,
		   old_y_high * ctx->mw.zoom_factor_y - ctx->mw.offset_y + DRAW_MP);
	ctx->draw( &ctx->mw, x_left * ctx->mw.zoom_factor_x - ctx->mw.offset_x - DRAW_MP,
		   y_low * ctx->mw.zoom_factor_y - ctx->mw.offset_y - DRAW_MP,
		   x_right * ctx->mw.zoom_factor_x - ctx->mw.offset_x + DRAW_MP,
		   y_high * ctx->mw.zoom_factor_y - ctx->mw.offset_y + DRAW_MP);
	ctx->draw( &ctx->navw,  x_left * ctx->navw.zoom_factor_x - ctx->navw.offset_x - 1,
		   y_low * ctx->navw.zoom_factor_y - ctx->navw.offset_y - 1,
		   x_right * ctx->navw.zoom_factor_x - ctx->navw.offset_x + 1,
		   y_high * ctx->navw.zoom_factor_y - ctx->navw.offset_y + 1);
	*/
    }

    public int get_background_object_limits(GlowTransform t, int type, double x, double y, Object bo) {
	int dyn_type;
	GlowBackgroundObject b = (GlowBackgroundObject)bo;
	GlowNodeClass base_nc = nc.get_base_nc();
	dyn_type = base_nc.dyn_type1;

	if ( (type & dyn_type) == 0)
	    return 0;
	if ( nc.y0 == 0 && nc.y1 == 0)
	    return 0;

	double x1, x2, y1, y2;
	double rotation;
	GlowGeometry g = new GlowGeometry();

	g.ur_x = 10e-37;
	g.ll_x = 10e37;
	g.ur_y = 10e-37;
	g.ll_y = 10e37;

	get_borders( t, g);
	double x1_right = g.ur_x;
	double x1_left = g.ll_x;
	double y1_high = g.ur_y;
	double y1_low = g.ll_y;

	System.out.println("Slider background: ("+x+","+y+")  ("+x1_left+","+y1_low+") ("+x1_right+","+y1_high+")");
	if ( x <= x1_right && x >= x1_left && y <= y1_high && y >= y1_low) {
	    // Hit, calculate max and min koordinates

	    if (t == null) {
		x1 = trf.x( 0, nc.y0);
		y1 = trf.y( 0, nc.y0);
		x2 = trf.x( 0, nc.y1);
		y2 = trf.y( 0, nc.y1);
	    }
	    else {
		x1 = trf.x( t, 0, nc.y0);
		y1 = trf.y( t, 0, nc.y0);
		x2 = trf.x( t, 0, nc.y1);
		y2 = trf.y( t, 0, nc.y1);
	    }
	    
	    if ( t != null)
		rotation = (trf.rot( t) / 360 - Math.floor( trf.rot( t) / 360)) * 360;
	    else {
		rotation = (trf.rot() / 360 - Math.floor( trf.rot() / 360)) * 360;
		System.out.println("trf.rotation" + trf.rotation + "   floor: " + Math.floor( trf.rot() / 360)); 
	    }
	    if ( 45 >= rotation || rotation > 315) {
		b.direction = Glow.eDirection_Down;
		b.min = y1;
		b.max = y2;
	    }
	    else if ( 45 < rotation && rotation <= 135) {
		b.direction = Glow.eDirection_Left;
		b.min = x2;
		b.max = x1;
	    }
	    else if ( 135 < rotation && rotation <= 225) {
		b.direction = Glow.eDirection_Up;
		b.min = y2;
		b.max = y1;
	    }
	    else if ( 225 < rotation && rotation <= 315) {
		b.direction = Glow.eDirection_Right;
		b.min = x1;
		b.max = x2;
	    }
	    b.background = this;
	    System.out.println("Background limits (" + g.ll_x + "," + g.ll_y + ") (" + g.ur_x + "," + g.ur_y + ") rot " + rotation);
	    return 1;
	}
	return 0;
    }

    public int getColorInverse() {
	return color_inverse;
    }
    public int getColorLightness(){
	return color_lightness;
    }
    public int getColorIntensity(){
	return color_intensity;
    }
    public int getColorShift(){
	return color_shift;
    }
    public int getColorTone(){
	return color_tone;
    }
    public int getFillDrawtype(){
	return fill_drawtype;
    }
    public int getTextDrawtype(){
	return text_drawtype;
    }
    public int getBackgroundDrawtype(){
	return background_drawtype;
    }
    public int getDrawtype(){
	return draw_type;
    }
    public int getDimmed(){
	return dimmed;
    }

    public void setColorThemeLightness() {
	if ( cmn.customcolors == null)
	    return;

	if ( cmn.customcolors.colortheme_lightness != color_lightness)
	    color_lightness = cmn.customcolors.colortheme_lightness;
    }

    public String getName() {
	return n_name;
    }
    public void store_transform() { 
	trf.store(); 
    }
    public boolean transform_is_stored() { 
	return trf.is_stored(); 
    }
}
