/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2014 SSAB AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */


package jpwr.jopg;
import java.io.*;
import java.util.*;
import jpwr.rt.*;


public class GrowCtx implements GrowCtxIfc {
    public GrowCmn cmn;
    String name;
    boolean sliderActive;
    GrowSlider sliderObject;
    double node_move_last_x;
    double node_move_last_y;
    double slider_cursor_offset;
    boolean trace_started = false;
    boolean drawing = false;

    public GrowCtx(GrowApplIfc appl) {
	cmn = new GrowCmn( this, appl);
    }
    public GrowCmn getCmn() {
	return cmn;
    }
    public void open( BufferedReader reader) {
	String line;
	StringTokenizer token;
	boolean end_found = false;
	boolean zoom_y_found = false;
	boolean grow_loaded = false;

	try {
	    while( (line = reader.readLine()) != null) {
		if ( line.length() > 2 && line.substring(0,2).equals("0!"))
		     continue;
		if ( line.length() > 1 && line.substring(0,1).equals("!"))
		     continue;

		token = new StringTokenizer(line);
		int key = Integer.valueOf(token.nextToken());
		if ( cmn.debug) System.out.println( "GlowCtx : " + line);

		System.out.println("GrowCtx key: " + key);
		switch ( key) {
		case Glow.eSave_Ctx: 
		    break;
		case Glow.eSave_Ctx_zoom_factor_x: 
		    cmn.mw.zoom_factor_x = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_Ctx_zoom_factor_y: 
		    cmn.mw.zoom_factor_y = new Double(token.nextToken()).doubleValue();
		    zoom_y_found = true; 
		    break;
		case Glow.eSave_Ctx_base_zoom_factor: 
		    cmn.mw.base_zoom_factor = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_Ctx_offset_x: 
		    cmn.mw.offset_x = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_Ctx_offset_y: 
		    cmn.mw.offset_y = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_Ctx_nav_zoom_factor_x: 
		case Glow.eSave_Ctx_nav_zoom_factor_y: 
		case Glow.eSave_Ctx_print_zoom_factor: 
		case Glow.eSave_Ctx_nav_offset_x: 
		case Glow.eSave_Ctx_nav_offset_y: 
		    break;
		case Glow.eSave_Ctx_x_right: 
		    cmn.x_right = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_Ctx_x_left: 
		    cmn.x_left = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_Ctx_y_high: 
		    cmn.y_high = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_Ctx_y_low: 
		    cmn.y_low = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_Ctx_nav_rect_ll_x: 
		case Glow.eSave_Ctx_nav_rect_ll_y:
		case Glow.eSave_Ctx_nav_rect_ur_x: 
		case Glow.eSave_Ctx_nav_rect_ur_y: 
		case Glow.eSave_Ctx_nav_rect_hot: 
		    break;
		case Glow.eSave_Ctx_name: 
		    cmn.name = token.nextToken();
		    break;
		case Glow.eSave_Ctx_user_highlight: 
		case Glow.eSave_Ctx_grid_size_x: 
		case Glow.eSave_Ctx_grid_size_y: 
		case Glow.eSave_Ctx_grid_on:
		case Glow.eSave_Ctx_draw_delta: 
		case Glow.eSave_Ctx_refcon_width: 
		case Glow.eSave_Ctx_refcon_height: 
		case Glow.eSave_Ctx_refcon_textsize: 
		case Glow.eSave_Ctx_refcon_linewidth: 
		    break;
		case Glow.eSave_Ctx_version: 
		    cmn.version = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_Ctx_hot_indication: 
		    cmn.hot_indication = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_Ctx_tiptext_size: 
		    break;
		case Glow.eSave_Ctx_app_motion: 
		    cmn.app_motion = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_Ctx_grow:
		    open_grow( reader);
		    grow_loaded = true;
		    break;
		case Glow.eSave_Ctx_a_nc: 
		    GlowVector.open( reader, cmn, cmn.a_nc); 
		    break;
		case Glow.eSave_Ctx_a_cc: 
		    GlowVector.open( reader, cmn, cmn.a_cc); 
		    break;
		case Glow.eSave_Ctx_a: 
		    GlowVector.open( reader, cmn, cmn.a); 
		    break;
		case Glow.eSave_Ctx_comment: 
		    open_comment( reader);
		    break;
		case Glow.eSave_End: 
		    end_found = true; 
		    break;
		case Glow.eSave_Comment:
		    break;
		default:
		    System.out.println( "Syntax error in GlowCtx");
		    break;
		}
		if ( end_found)
		    break;
	    }
	    if ( !zoom_y_found)
		cmn.mw.zoom_factor_y = cmn.mw.zoom_factor_x;
	} catch ( Exception e) {
	    System.out.println( "IOException GlowCtx");
	}
    }

    public void open_comment( BufferedReader reader) {
	String line;
	try {
	    while( (line = reader.readLine()) != null) {
		if ( !line.startsWith("!"))
		     break;
		if ( line.startsWith("!*/"))
		     break;
	    }
	} catch ( Exception e) {
	    System.out.println( "IOException GlowCtx comment");
	}

    }

    public void open_grow( BufferedReader reader) {
	String line;
	StringTokenizer token;
	boolean end_found = false;

	try {
	    while( (line = reader.readLine()) != null) {
		token = new StringTokenizer(line);
		int key = Integer.valueOf(token.nextToken());
		if ( cmn.debug) System.out.println( "GrowCtx : " + line);

		switch ( key) {
		case Glow.eSave_GrowCtx: 
		    break;
		case Glow.eSave_GrowCtx_conpoint_num_cnt:
		case Glow.eSave_GrowCtx_objectname_cnt: 
		case Glow.eSave_GrowCtx_name:
		    cmn.name = token.nextToken();
		    break;
		case Glow.eSave_GrowCtx_background_color: 
		    cmn.background_color = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowCtx_dynamicsize: 
		    cmn.dynamicsize = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowCtx_dynamic:
		    if ( cmn.dynamicsize > 0) {
			for ( int j = 0; j < cmn.dynamicsize; j++) 
			    line = reader.readLine();
		    }
		    break;
		case Glow.eSave_GrowCtx_arg_cnt: 
		    cmn.arg_cnt = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowCtx_argname:
		    for ( int i = 0; i < cmn.arg_cnt; i++)
			cmn.argname[i] = reader.readLine();
		    break;
		case Glow.eSave_GrowCtx_argtype:
		    for ( int i = 0; i < cmn.arg_cnt; i++)
			cmn.argtype[i] = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowCtx_x0: 
		    cmn.x0 = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_GrowCtx_y0: 
		    cmn.y0 = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_GrowCtx_x1: 
		    cmn.x1 = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_GrowCtx_y1: 
		    cmn.y1 = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_End: 
		    end_found = true; 
		    break;
		case Glow.eSave_GrowCtx_path_cnt: 
		    cmn.path_cnt = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowCtx_path:
		    for ( int i = 0; i < cmn.path_cnt; i++)
			cmn.path[i] = reader.readLine();
		    break;
		case Glow.eSave_GrowCtx_dyn_type1: 
		    cmn.dyn_type1 = Integer.valueOf(token.nextToken());
		    break; 
		case Glow.eSave_GrowCtx_dyn_type2: 
		    cmn.dyn_type2 = Integer.valueOf(token.nextToken());
		    break; 
		case Glow.eSave_GrowCtx_dyn_action_type1: 
		    cmn.dyn_action_type1 = Integer.valueOf(token.nextToken());
		    break; 
		case Glow.eSave_GrowCtx_dyn_action_type2: 
		    cmn.dyn_action_type2 = Integer.valueOf(token.nextToken());
		    break; 
		case Glow.eSave_GrowCtx_dyn_color1:
		    cmn.dyn_color[0] = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowCtx_dyn_color2:
		    cmn.dyn_color[1] = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowCtx_dyn_color3:
		    cmn.dyn_color[2] = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowCtx_dyn_color4:
		    cmn.dyn_color[3] = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowCtx_dyn_attr1: 
		    cmn.dyn_attr[0] = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowCtx_dyn_attr2: 
		    cmn.dyn_attr[1] = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowCtx_dyn_attr3: 
		    cmn.dyn_attr[2] = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowCtx_dyn_attr4: 
		    cmn.dyn_attr[3] = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowCtx_no_con_obstacle: 
		    break;
		case Glow.eSave_GrowCtx_slider: 
		    cmn.slider = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowCtx_subgraph: 
		    cmn.subgraph = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowCtx_java_name:
		case Glow.eSave_GrowCtx_is_javaapplet: 
		case Glow.eSave_GrowCtx_is_javaapplication: 
		case Glow.eSave_GrowCtx_next_subgraph:
		case Glow.eSave_GrowCtx_animation_count: 
		    break;
		case Glow.eSave_GrowCtx_scantime: 
		    cmn.scantime = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_GrowCtx_fast_scantime: 
		    cmn.fast_scantime = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_GrowCtx_animation_scantime: 
		    cmn.animation_scantime = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_GrowCtx_java_width: 
		    cmn.java_width = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowCtx_background_image:
		    if ( token.hasMoreTokens())
			cmn.background_image = token.nextToken();
		    break;
		case Glow.eSave_GrowCtx_background_tiled: 
		    cmn.background_tiled = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowCtx_double_buffered: 
		    cmn.double_buffered = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowCtx_cycle:
		    cmn.cycle = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowCtx_mb3_action: 
		    cmn.mb3_action = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowCtx_translate_on: 
		    cmn.translate_on = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowCtx_input_focus_mark: 
		    cmn.input_focus_mark = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowCtx_recursive_trace:
		    cmn.recursive_trace = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowCtx_userdata_cb:
		    if ( cmn.appl != null)
			cmn.userdata = cmn.appl.growUserdataOpen(reader, cmn, Glow.eUserdataCbType_Ctx);
		    break;
		case Glow.eSave_GrowCtx_bitmap_fonts:
		    break;
		default:
		    System.out.println( "Syntax error in GrowCtx");
		    break;
		}
		if ( end_found)
		    break;
	    }
	    cmn.mw.offset_x = (int)(cmn.x0 * cmn.mw.zoom_factor_x);
	    cmn.mw.offset_y = (int)(cmn.y0 * cmn.mw.zoom_factor_y);

	} catch ( Exception e) {
	    System.out.println( "IOException GrowCtx");
	}
    }

    public void draw() {
	drawing = true;
	// Draw background color
	// draw.fillRect(0, 0, cmn.mw.window_width, cmn.mw.window_height, background_color);
	// Draw connections
	for ( int i = 0; i < cmn.a.size(); i++) {
	    if ( ((GlowArrayElem)cmn.a.get(i)).type() == Glow.eObjectType_Con)
		((GlowArrayElem)cmn.a.get(i)).draw();
	}
	// Draw nodes
	for ( int i = 0; i < cmn.a.size(); i++) {
	    if ( ((GlowArrayElem)cmn.a.get(i)).type() != Glow.eObjectType_Con)
		((GlowArrayElem)cmn.a.get(i)).draw();
	}
	drawing = false;
    }

    public void draw( double ll_x, double ll_y, double ur_x, double ur_y) {
	// TODO
	if ( drawing)
	    return;

	for ( int i = 0; i < cmn.a.size(); i++) {
	    if ( ((GlowArrayElem)cmn.a.get(i)).type() == Glow.eObjectType_Con)
		((GlowArrayElem)cmn.a.get(i)).draw();
	}
	for ( int i = 0; i < cmn.a.size(); i++) {
	    if ( ((GlowArrayElem)cmn.a.get(i)).type() != Glow.eObjectType_Con)
		((GlowArrayElem)cmn.a.get(i)).draw();
	}
    }

    public void register_callback_object(int type, GlowArrayElem o) {
	cmn.callback_object = o;
	cmn.callback_object_type = type;
    }
    public int send_menu_callback( GlowArrayElem object, int item, int event,
				   double x, double y) {
	/* Send a host request callback */
	GlowEventMenu e = new GlowEventMenu();

	e.event = event;
	e.type = Glow.eEventType_Menu;
	// e.any.x_pixel = int( x * mw.zoom_factor_x) - mw.offset_x;
	// e.any.y_pixel = int( y * mw.zoom_factor_y) - mw.offset_y;
	e.x = x;
	e.y = y;
	e.object_type = object.type();
	e.object = object;
	e.item = item;
	cmn.appl.eventHandler(e);
 
	return 1;
    }

    public int eventHandler(GlowEvent e, double fx, double fy) {
	return eventHandler( e);
    }

    public int eventHandler(GlowEvent e) {
	int sts = 0;
	double x = e.x * cmn.mw.zoom_factor_x - cmn.mw.offset_x;
	double y = e.y * cmn.mw.zoom_factor_y - cmn.mw.offset_y;

	cmn.callback_object = null;
	cmn.callback_object_type = Glow.eObjectType_NoObject;
	for ( int i = cmn.a.size() - 1; i >= 0; i--) {
	    sts = ((GlowArrayElem)cmn.a.get(i)).eventHandler(e, e.x, e.y);
	    if ( sts == 1) {
		break;
	    }
	}	

	switch ( e.event) {
	case Glow.eEvent_MB1Down:
	    if ( sts == 1 && cmn.callback_object != null && cmn.callback_object.type() == Glow.eObjectType_GrowSlider) {
		System.out.println("Slider start");
		sliderActive = true;
		sliderObject = (GrowSlider)cmn.callback_object;

		GlowEvent se = new GlowEvent();
		se.event = Glow.eEvent_SliderMoveStart;
		se.type = Glow.eEventType_Object;
		se.x = e.x;
		se.y = e.y;
		se.object = cmn.callback_object;
		se.object_type = cmn.callback_object.type();
		cmn.appl.eventHandler(se);

		if ( cmn.restriction_object != null) {
		    GlowGeometry g = ((GrowSlider)cmn.restriction_object).measure();
		    if (cmn.move_restriction == Glow.eMoveRestriction_VerticalSlider)
			slider_cursor_offset = g.ll_y - e.y;
		    else
			slider_cursor_offset = g.ll_x - e.x;
		}
		node_move_last_x = e.x;
		node_move_last_y = e.y;
	    }
	    break;
	case Glow.eEvent_MB1Up:
	    if ( sliderActive) {
		if ( cmn.restriction_object != null) {
		    System.out.println("Slider end");

		    GlowEvent se = new GlowEvent();
		    se.event = Glow.eEvent_SliderMoveEnd;
		    se.type = Glow.eEventType_Object;
		    se.x = e.x;
		    se.y = e.y;
		    se.object = cmn.restriction_object;
		    se.object_type = cmn.restriction_object.type();
		    cmn.appl.eventHandler(se);

		    cmn.restriction_object = null;
		}
		sliderObject = null;
		sliderActive = false;
	    }
	    break;
	case Glow.eEvent_ButtonMotion:
	    if ( sliderActive && cmn.restriction_object != null) {

		double move_x, move_y;
		double cursor_y, cursor_x;

		switch( cmn.move_restriction) {
		case Glow.eMoveRestriction_VerticalSlider: {
		    cursor_y = e.y;
		    if ( cursor_y + slider_cursor_offset > cmn.restriction_max_limit) {
			if ( node_move_last_y + slider_cursor_offset > cmn.restriction_max_limit)
			    break;
			else {
			    move_y = cmn.restriction_max_limit - node_move_last_y -
				slider_cursor_offset;
			    System.out.println("Slider max limit: " + move_y + " limit " + cmn.restriction_max_limit);
			}
		    }
		    else if ( cursor_y + slider_cursor_offset < cmn.restriction_min_limit) {
			if ( node_move_last_y + slider_cursor_offset < cmn.restriction_min_limit)
			    break;
			else
			    move_y = cmn.restriction_min_limit - node_move_last_y -
				slider_cursor_offset;
		    }
		    else {
			if ( node_move_last_y + slider_cursor_offset > cmn.restriction_max_limit)
			    move_y = cursor_y + slider_cursor_offset - 
				cmn.restriction_max_limit;
			else if ( node_move_last_y + slider_cursor_offset < cmn.restriction_min_limit)
			    move_y = cursor_y + slider_cursor_offset - 
				cmn.restriction_min_limit;
			else
			    move_y = e.y - node_move_last_y;
		    }
		    if ( move_y == 0)
			break;
		    // set_defered_redraw();
		    ((GrowSlider)cmn.restriction_object).move( 0, move_y);
		    // redraw_defered();
		    
		    GlowEvent se = new GlowEvent();
		    se.event = Glow.eEvent_SliderMoved;
		    se.type = Glow.eEventType_Object;
		    se.x = e.x;
		    se.y = node_move_last_y + move_y;
		    se.object = cmn.restriction_object;
		    se.object_type = cmn.restriction_object.type();
		    cmn.appl.eventHandler(se);
		    
		    node_move_last_x = e.x;
		    node_move_last_y = e.y;
		    break;
		}
		case Glow.eMoveRestriction_HorizontalSlider: {
		    cursor_x = e.x;
		    if ( cursor_x + slider_cursor_offset > cmn.restriction_max_limit) {
			if ( node_move_last_x +
			     slider_cursor_offset > cmn.restriction_max_limit)
			    break;
			else
			    move_x = cmn.restriction_max_limit - 
				node_move_last_x - slider_cursor_offset;
		    }
		    else if ( cursor_x + slider_cursor_offset < cmn.restriction_min_limit) {
			if ( node_move_last_x +
			     slider_cursor_offset < cmn.restriction_min_limit)
			    break;
			else
			    move_x = cmn.restriction_min_limit - 
				node_move_last_x - slider_cursor_offset;
		    }
		    else {
			if ( node_move_last_x + slider_cursor_offset > cmn.restriction_max_limit)
			    move_x = cursor_x + slider_cursor_offset - 
				cmn.restriction_max_limit;
			else if ( node_move_last_x + slider_cursor_offset < cmn.restriction_min_limit)
			    move_x = cursor_x + slider_cursor_offset - 
				cmn.restriction_min_limit;
		    else
			move_x = e.x - node_move_last_x;
		    }
		    if ( move_x == 0)
			break;
		    // set_defered_redraw();
		    ((GrowSlider)cmn.restriction_object).move( move_x, 0);
		    GlowGeometry g = ((GrowSlider)cmn.restriction_object).measure();
		    // redraw_defered();
		    
		    GlowEvent se = new GlowEvent();
		    se.event = Glow.eEvent_SliderMoved;
		    se.type = Glow.eEventType_Object;
		    se.x = node_move_last_x + move_x;
		    se.y = e.y;
		    se.object = cmn.restriction_object;
		    se.object_type = cmn.restriction_object.type();
		    cmn.appl.eventHandler(se);
		    
		    node_move_last_x = e.x;
		    node_move_last_y = e.y;
		}		    
		break;
	    }
	    }
	}

	if ( sts == 1 && cmn.appl != null) {
	    e.object = cmn.callback_object;
	    e.object_type = cmn.callback_object_type;
	    cmn.appl.eventHandler(e);
	}
	return sts;
    }

    public void traceConnect() {
	int sts;
	cmn.nodraw++;
	for ( int i = 0; i < cmn.a.size(); i++) {
	    if ( cmn.a.get(i).type() == Glow.eObjectType_GrowNode ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowGroup ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowBar ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowTrend ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowTable ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowSlider ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowWindow ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowFolder) {
		System.out.println("GrowCtx connect " + i + " (" + cmn.a.size() + ") " + cmn.a.get(i));
		cmn.appl.traceConnect(cmn.a.get(i));
		if ( cmn.a.get(i).type() == Glow.eObjectType_GrowGroup) {
		    for ( int j = 0; j < ((GrowNode)cmn.a.get(i)).nc.a.size(); j++) {
			if ( ((GrowNode)cmn.a.get(i)).nc.a.get(j).type() == Glow.eObjectType_GrowNode ||
			     ((GrowNode)cmn.a.get(i)).nc.a.get(j).type() == Glow.eObjectType_GrowGroup) {
			    cmn.appl.traceConnect((GrowNode)((GrowNode)cmn.a.get(i)).nc.a.get(j));
			}
		    }		
		    
		}
		else if ( cmn.a.get(i).type() == Glow.eObjectType_GrowWindow ||
			  cmn.a.get(i).type() == Glow.eObjectType_GrowFolder) {
		    ((GrowWindow)cmn.a.get(i)).traceConnect();
		}
	    }
	}		
	cmn.nodraw--;
	trace_started = true;
    }

    public void traceDisconnect() {
	int sts;
	trace_started = false;
	for ( int i = 0; i < cmn.a.size(); i++) {
	    if ( cmn.a.get(i).type() == Glow.eObjectType_GrowNode ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowGroup ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowBar ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowTrend ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowTable ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowSlider ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowWindow ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowFolder) {
		cmn.appl.traceDisconnect(cmn.a.get(i));
		if ( cmn.a.get(i).type() == Glow.eObjectType_GrowGroup) {
		    for ( int j = 0; j < ((GrowNode)cmn.a.get(i)).nc.a.size(); j++) {
			if ( ((GrowNode)cmn.a.get(i)).nc.a.get(j).type() == Glow.eObjectType_GrowNode ||
			     ((GrowNode)cmn.a.get(i)).nc.a.get(j).type() == Glow.eObjectType_GrowGroup) {
			    cmn.appl.traceDisconnect((GrowNode)((GrowNode)cmn.a.get(i)).nc.a.get(j));
			}
		    }		
		    
		}
		else if ( cmn.a.get(i).type() == Glow.eObjectType_GrowWindow ||
			  cmn.a.get(i).type() == Glow.eObjectType_GrowFolder) {
		    ((GrowWindow)cmn.a.get(i)).traceDisconnect();
		}
	    }
	}		
    }
    public void traceScan() {
	int sts;
	for ( int i = 0; i < cmn.a.size(); i++) {
	    if ( cmn.a.get(i).type() == Glow.eObjectType_GrowNode ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowGroup ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowBar ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowTrend ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowTable ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowSlider ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowWindow ||
		 cmn.a.get(i).type() == Glow.eObjectType_GrowFolder) {
	    	cmn.appl.traceScan(cmn.a.get(i));
		if ( cmn.a.get(i).type() == Glow.eObjectType_GrowGroup) {
		    for ( int j = 0; j < ((GrowNode)cmn.a.get(i)).nc.a.size(); j++) {
			if ( ((GrowNode)cmn.a.get(i)).nc.a.get(j).type() == Glow.eObjectType_GrowNode ||
			     ((GrowNode)cmn.a.get(i)).nc.a.get(j).type() == Glow.eObjectType_GrowGroup) {
			    cmn.appl.traceScan((GrowNode)((GrowNode)cmn.a.get(i)).nc.a.get(j));
			}
		    }		
		    
		}
		else if ( cmn.a.get(i).type() == Glow.eObjectType_GrowWindow ||
			  cmn.a.get(i).type() == Glow.eObjectType_GrowFolder) {
		    ((GrowWindow)cmn.a.get(i)).traceScan();
		}
	    }
	}		
    }

    public boolean traceStarted() {
	return trace_started;
    }

    public GlowArrayElem get_nodeclass_from_name(String name) {
	for ( int i = 0; i < cmn.a_nc.size(); i++) {
	    if ( name.equals(((GlowNodeClass)cmn.a_nc.get(i)).nc_name))
		return (GlowNodeClass)cmn.a_nc.get(i);
	}   
	return null;
    }

    public GlowArrayElem get_conclass_from_name(String name) {
	for ( int i = 0; i < cmn.a_cc.size(); i++) {
	    if ( name.equals(((GlowConClass)cmn.a_cc.get(i)).cc_name))
		return (GlowConClass)cmn.a_cc.get(i);
	}   
	return null;
    }

    public GlowArrayElem get_node_from_name(String name) {
	for ( int i = 0; i < cmn.a.size(); i++) {
	    if ( cmn.a.get(i).type() == Glow.eObjectType_GrowNode) {
		if ( name.equals(((GrowNode)cmn.a.get(i)).n_name))
		    return (GrowNode)cmn.a.get(i);
	    }
	}   
	return null;
    }

    public GlowArrayElem get_object_group( GlowArrayElem object) {
	int sts;
	GlowArrayElem group;

	for ( int i = 0; i < cmn.a.size(); i++) {
	    if ( cmn.a.get(i).type() == Glow.eObjectType_GrowGroup) {
		group = ((GrowGroup)cmn.a.get(i)).get_object_group( object);
		if (group != null)
		    return group;
	    }
	}
	return null;
    }

    public void insert(GlowArrayElem e) {
	cmn.a.add(e);
    }
    public void remove(GlowArrayElem e) {
	cmn.a.remove(e);
    }
    public void pop(GlowArrayElem e) {
	// TODO
    }
    public Vector<GlowArrayElem> get_object_list() {
	return cmn.a;
    }

    public GlowBackgroundObject getBackgroundObjectLimits(int type, double x, double y) {
	int sts = 0;
	GlowBackgroundObject b = new GlowBackgroundObject();

	for ( int i = 0; i < cmn.a.size(); i++) {
	    sts = cmn.a.get(i).get_background_object_limits(null, type, x, y, b);
	    if ( (sts & 1) != 0)
		break;
	}
	b.sts = sts;
	return b;
    }

    public void setMoveRestrictions( int restriction, double max_limit, double min_limit, GlowArrayElem object) {
	cmn.move_restriction = restriction;
	cmn.restriction_max_limit = max_limit;
	cmn.restriction_min_limit = min_limit;
	cmn.restriction_object = object;
    }
    
    public void zoom( double factor) { 
      if ( Math.abs(factor) < Double.MIN_VALUE)
        return;

      cmn.mw.zoom_factor_x *= factor;
      cmn.mw.zoom_factor_y *= factor;
      // cmn.mw.offset_x = (int)( (cmn.mw.offset_x - cmn.mw.window_width / 2.0 * ( 1.0/factor - 1)) * factor);
      // cmn.mw.offset_y = (int)( (cmn.mw.offset_y  - cmn.mw.window_height / 2.0 * ( 1.0/factor - 1)) * factor);
      draw();
    }

    public void zoom( double factor, double x, double y) { 
	if ( Math.abs(factor) < Double.MIN_VALUE)
	    return;


	double scrollX = (x + cmn.mw.offset_x) * factor - (x + cmn.mw.offset_x);
	double scrollY = (y + cmn.mw.offset_y) * factor - (y + cmn.mw.offset_y);
      
	cmn.mw.zoom_factor_x *= factor;
	cmn.mw.zoom_factor_y *= factor;
	scroll( (int)scrollX, (int)scrollY);

	draw();
    }

    public void zoomAbsolute( double factor) { 
      cmn.mw.zoom_factor_x = factor;
      cmn.mw.zoom_factor_y = factor;
      draw();
    }

    public void scroll( int delta_x, int delta_y) {
	cmn.mw.offset_x += delta_x;
	cmn.mw.offset_y += delta_y;

	if ( !((cmn.x0 == 0 && cmn.x1 == 0) || (cmn.y0 == 0 && cmn.y1 == 0) 
	       || cmn.mw.window_width == 0 || cmn.mw.window_height == 0)) {
	    if ( cmn.mw.offset_x + cmn.mw.window_width > cmn.x1 * cmn.mw.zoom_factor_x)
		cmn.mw.offset_x = (int)(cmn.x1 * cmn.mw.zoom_factor_x - cmn.mw.window_width);
	    if ( cmn.mw.offset_x < cmn.x0 * cmn.mw.zoom_factor_x)
		cmn.mw.offset_x = (int)(cmn.x0 * cmn.mw.zoom_factor_x);
	    if ( cmn.mw.offset_y + cmn.mw.window_height > cmn.y1 * cmn.mw.zoom_factor_y)
		cmn.mw.offset_y = (int)(cmn.y1 * cmn.mw.zoom_factor_y - cmn.mw.window_height);
	    if ( cmn.mw.offset_y < cmn.y0 * cmn.mw.zoom_factor_y)
		cmn.mw.offset_y = (int)(cmn.y0 * cmn.mw.zoom_factor_y);
	}
	System.out.println("Scroll: offset (" + cmn.mw.offset_x + "," + cmn.mw.offset_y + ") window (" + cmn.mw.window_width + "," + cmn.mw.window_height);
	draw();
    }

    public void openVector( BufferedReader reader, Object cmn, Vector a) {
	GlowVector.open(reader, (GrowCmn)cmn, a);
    }

    public GlowArrayElem findByName( String name) {
	for ( int i = 0; i < cmn.a.size(); i++) {
	    System.out.println("findByName: " + ((GlowArrayElem)cmn.a.get(i)).getName());
	    if ( ((GlowArrayElem)cmn.a.get(i)).getName().equalsIgnoreCase(name))
		return (GlowArrayElem)cmn.a.get(i);
	}
	return null;
    }

    public void setSubwindowSource( String name, String source, String owner) {
	GrowWindow e = (GrowWindow)findByName( name);
	if ( e == null || e.type() != Glow.eObjectType_GrowWindow) {
	    System.out.println("Window " + name + " not found " + e);
	    return;
	}

	e.setSource( source, owner);
    }

    public boolean getSliderActive() {
	return sliderActive;
    }

    public void setSliderActive( boolean active) {
	sliderActive = active;
    }

    public void setDefaultLayout( int width, int height) {
	if ( cmn.x0 >= cmn.x1 || cmn.y0 >= cmn.y1)
	    return;

	cmn.mw.zoom_factor_x = Math.min( width/(cmn.x1 - cmn.x0), 
					 height/(cmn.y1 - cmn.y0));
	cmn.mw.zoom_factor_y = cmn.mw.zoom_factor_x;
	cmn.mw.offset_x = (int)(cmn.x0 * cmn.mw.zoom_factor_x);
	cmn.mw.offset_y = (int)(cmn.y0 * cmn.mw.zoom_factor_y);

	draw();
    }
}







