/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jopg;
import java.util.Vector;
import java.util.Scanner;
import java.util.Calendar;
import java.text.SimpleDateFormat;
import java.io.*;
import java.net.*;

public class Ccm {
    static final boolean ccm_testmode = false;

    public static final int ROOT_APPLET 	= 1;
    public static final int ROOT_FRAME 		= 2;
    public static final int ROOT_AAPP 		= 3;

    public static final int CCM__SUCCESS 	= 1;
    public static final int CCM__EXITFUNC 	= 3;
    public static final int CCM__EXPRESSION 	= 2;
    public static final int CCM__VARTYPE 	= 4;
    public static final int CCM__VARALREXIST 	= 8;
    public static final int CCM__VARNOTFOUND 	= 10;
    public static final int CCM__OPENFILE 	= 12;
    public static final int CCM__SYNTAX 	= 14;
    public static final int CCM__FUNCNOTFOUND 	= 16;
    public static final int CCM__UNKNVARTYPE 	= 18;
    public static final int CCM__FUNCMISM 	= 20;
    public static final int CCM__MAINMISM 	= 22;
    public static final int CCM__IFMISM 	= 24;
    public static final int CCM__WHILEMISM 	= 26;
    public static final int CCM__FORMISM 	= 28;
    public static final int CCM__ARGMISM 	= 30;
    public static final int CCM__CONTMISM 	= 32;
    public static final int CCM__BREAKMISM 	= 34;
    public static final int CCM__NOEXTVAR 	= 36;
    public static final int CCM__GOTOMISM 	= 38;
    public static final int CCM__SYSFUNCEXCEED 	= 40;
    public static final int CCM__EXTERNFUNC 	= 5;
    public static final int CCM__LONGLINE 	= 42;
    public static final int CCM__STRINGEXCEED 	= 44;
    public static final int CCM__ARRAYBOUNDS 	= 46;
    public static final int CCM__ALREADYREG 	= 7;
    public static final int CCM__NOACCESS 	= 48;
    public static final int CCM__ARGEXCEED 	= 50;

    public static final int K_STRING_SIZE 	= 400;
    public static final int K_LINE_SIZE 	= 400;

    public static final int K_ACTION_NO		= 0;
    public static final int K_ACTION_DOWN	= 1;
    public static final int K_ACTION_UP		= 2;
    public static final int K_ACTION_MUL	= 3;
    public static final int K_ACTION_DIV	= 4;
    public static final int K_ACTION_ADD	= 5;
    public static final int K_ACTION_SUB	= 6;
    public static final int K_ACTION_EQL	= 7;
    public static final int K_ACTION_LT		= 8;
    public static final int K_ACTION_GT		= 9;
    public static final int K_ACTION_GE		= 10;
    public static final int K_ACTION_LE		= 11;
    public static final int K_ACTION_EQ		= 12;
    public static final int K_ACTION_NE		= 13;
    public static final int K_ACTION_INV	= 14;
    public static final int K_ACTION_INCR	= 15;
    public static final int K_ACTION_DECR	= 16;
    public static final int K_ACTION_AND	= 17;
    public static final int K_ACTION_OR		= 18;
    public static final int K_ACTION_BITAND	= 19;
    public static final int K_ACTION_BITOR	= 20;
    public static final int K_ACTION_VAR	= 21;
    public static final int K_ACTION_NUM	= 22;
    public static final int K_ACTION_FLOAT	= 23;
    public static final int K_ACTION_END	= 24;
    public static final int K_ACTION_EQLADD	= 25;
    public static final int K_ACTION_EQLSUB 	= 26;
    public static final int K_ACTION_DELIM	= 27;
    public static final int K_ACTION_EQLMUL	= 28;
    public static final int K_ACTION_EQLDIV	= 29;
    public static final int K_ACTION_CREALOCINT = 30;
    public static final int K_ACTION_CREALOCFLOAT = 31;
    public static final int K_ACTION_CREALOCSTRING = 32;
    public static final int K_ACTION_CREAGBLINT = 33;
    public static final int K_ACTION_CREAGBLFLOAT = 34;
    public static final int K_ACTION_CREAGBLSTRING = 35;
    public static final int K_ACTION_CREAEXTINT = 36;
    public static final int K_ACTION_CREAEXTFLOAT = 37;
    public static final int K_ACTION_CREAEXTSTRING = 38;
    public static final int K_ACTION_STRING	= 39;
    public static final int K_ACTION_LSHIFT	= 40;
    public static final int K_ACTION_RSHIFT	= 41;
    public static final int K_ACTION_LIST	= 42;
    public static final int K_ACTION_FUNCTION 	= 43;
    public static final int K_ACTION_RETURN 	= 44;
    public static final int K_ACTION_BACKSLASH 	= 45;
    public static final int K_ACTION_DELETE 	= 46;

    public static final int K_OPERAND_NO	= 0;
    public static final int K_OPERAND_NAME	= 1;
    public static final int K_OPERAND_VALUE	= 2;
    public static final int K_OPERAND_DECL	= 3;
    public static final int K_OPERAND_GLOBAL 	= 4;
    public static final int K_OPERAND_EXTERN 	= 5;
    public static final int K_OPERAND_FUNCTION 	= 6;
    public static final int K_OPERAND_RETURN 	= 7;
    public static final int K_OPERAND_DELETE 	= 8;

    public static final int K_LOCTYPE_NO	= 0;
    public static final int K_LOCTYPE_BEFORE 	= 1;
    public static final int K_LOCTYPE_AFTER	= 2;

    public static final int K_TYPE_OPERATOR	= 0;
    public static final int K_TYPE_OPERAND	= 1;

    public static final int K_DECL_STRING	= 1;
    public static final int K_DECL_INT	= 2;
    public static final int K_DECL_FLOAT	= 3;
    public static final int K_DECL_UNKNOWN	= 4;

    public static final int K_STATE_VAR		= 1;
    public static final int K_STATE_NUM		= 2;
    public static final int K_STATE_STRING     	= 3;
    public static final int K_STATE_OPERATOR	= 4;
    public static final int K_STATE_DELIM      	= 5;
    public static final int K_STATE_PAR		= 6;
    public static final int K_STATE_END		= 7;
    public static final int K_STATE_ERROR      	= 8;
    public static final int K_STATE_LIST       	= 9;
    public static final int K_STATE_NUM_NEG    	= 10;

    public static final int K_LINE_STATMENT    	= 0;
    public static final int K_LINE_FUNCTION    	= 1;
    public static final int K_LINE_ENDFUNCTION	= 2;
    public static final int K_LINE_MAIN		= 3;
    public static final int K_LINE_ENDMAIN     	= 4;
    public static final int K_LINE_IF		= 5;
    public static final int K_LINE_ELSE		= 6;
    public static final int K_LINE_ENDIF       	= 7;
    public static final int K_LINE_FOR		= 8;
    public static final int K_LINE_ENDFOR      	= 9;
    public static final int K_LINE_WHILE       	= 10;
    public static final int K_LINE_ENDWHILE    	= 11;
    public static final int K_LINE_BREAK       	= 12;
    public static final int K_LINE_CONTINUE    	= 13;
    public static final int K_LINE_LABEL       	= 14;
    public static final int K_LINE_GOTO		= 15;

    public Vector<CcmIntvar> extint_list = new Vector<CcmIntvar>();
    public Vector<CcmFloatvar> extfloat_list = new Vector<CcmFloatvar>();
    public Vector<CcmStringvar> extstring_list = new Vector<CcmStringvar>();

    public Vector<CcmSysFunc> sysfunc_list = new Vector<CcmSysFunc>();

    static int[] ctable = new int[256];
    static int[] ptable = new int[256];


    public Ccm() {
	registerFunction( new CcmFuncPrintf("printf"));
	registerFunction( new CcmFuncSprintf("sprintf"));
	registerFunction( new CcmFuncSay("say"));
	registerFunction( new CcmFuncScanf("scanf"));
	registerFunction( new CcmFuncAsk("ask"));
	registerFunction( new CcmFuncElement("element"));
	registerFunction( new CcmFuncExtract("extract"));
	registerFunction( new CcmFuncEdit("edit"));
	registerFunction( new CcmFuncStrlen("strlen"));
	registerFunction( new CcmFuncStrchr("strchr"));
	registerFunction( new CcmFuncStrrchr("strrchr"));
	registerFunction( new CcmFuncStrstr("strstr"));
	registerFunction( new CcmFuncExit("exit"));
	registerFunction( new CcmFuncVerify("verify"));
	registerFunction( new CcmFuncTime("time"));
	registerFunction( new CcmFuncSystem("system"));
	registerFunction( new CcmFuncToUpper("toupper"));
	registerFunction( new CcmFuncToLower("tolower"));
    }

    static boolean EVEN(int sts) {
	return ((sts & 1) == 0);
    }
    static boolean ODD(int sts) {
	return ((sts & 1) != 0);
    }

    void init_ctable() {
	ptable[ K_ACTION_DOWN] = 	1;
	ptable[ K_ACTION_UP] = 		1;
	ptable[ K_ACTION_MUL] = 	8;
	ptable[ K_ACTION_DIV] = 	8;
	ptable[ K_ACTION_ADD] = 	10;
	ptable[ K_ACTION_SUB] = 	10;
	ptable[ K_ACTION_EQL] = 	20;
	ptable[ K_ACTION_LT] = 		13;
	ptable[ K_ACTION_GT] = 		13;
	ptable[ K_ACTION_GE] = 		13;
	ptable[ K_ACTION_LE] = 		13;
	ptable[ K_ACTION_EQ] = 		14;
	ptable[ K_ACTION_NE] = 		14;
	ptable[ K_ACTION_INV] = 	6;
	ptable[ K_ACTION_INCR] = 	2;
	ptable[ K_ACTION_DECR] = 	2;
	ptable[ K_ACTION_AND] = 	17;
	ptable[ K_ACTION_OR] = 		18;
	ptable[ K_ACTION_BITAND] = 	16;
	ptable[ K_ACTION_BITOR] = 	15;
	ptable[ K_ACTION_EQLADD] = 	19;
	ptable[ K_ACTION_EQLSUB] = 	19;
	ptable[ K_ACTION_EQLMUL] = 	19;
	ptable[ K_ACTION_EQLDIV] = 	19;
	ptable[ K_ACTION_CREALOCINT] = 	19;
	ptable[ K_ACTION_CREALOCFLOAT] = 19;
	ptable[ K_ACTION_CREALOCSTRING] = 19;
	ptable[ K_ACTION_CREAGBLINT] = 	19;
	ptable[ K_ACTION_CREAGBLFLOAT] = 19;
	ptable[ K_ACTION_CREAGBLSTRING] = 19;
	ptable[ K_ACTION_CREAEXTINT] = 	19;
	ptable[ K_ACTION_CREAEXTFLOAT] = 19;
	ptable[ K_ACTION_CREAEXTSTRING] = 19;
	ptable[ K_ACTION_LSHIFT] = 	12;
	ptable[ K_ACTION_RSHIFT] = 	12;
	ptable[ K_ACTION_FUNCTION] = 	2;

	ctable[0] = K_ACTION_END;
	ctable[';'] = K_ACTION_END;
	ctable['	'] = K_ACTION_DELIM;
	ctable[' '] = K_ACTION_DELIM;
	ctable[10]  = K_ACTION_DELIM;
	ctable['!'] = K_ACTION_INV;
	ctable['='] = K_ACTION_EQL;
	ctable['>'] = K_ACTION_GT;
	ctable['<'] = K_ACTION_LT;
	ctable[')'] = K_ACTION_DOWN;
	ctable['('] = K_ACTION_UP;
	ctable['*'] = K_ACTION_MUL;
	ctable['/'] = K_ACTION_DIV;
	ctable['+'] = K_ACTION_ADD;
	ctable['-'] = K_ACTION_SUB;
	ctable['|'] = K_ACTION_OR;
	ctable['&'] = K_ACTION_AND;
	ctable['_'] = K_ACTION_VAR;
	ctable['A'] = K_ACTION_VAR;
	ctable['B'] = K_ACTION_VAR;
	ctable['C'] = K_ACTION_VAR;
	ctable['D'] = K_ACTION_VAR;
	ctable['E'] = K_ACTION_VAR;
	ctable['F'] = K_ACTION_VAR;
	ctable['G'] = K_ACTION_VAR;
	ctable['H'] = K_ACTION_VAR;
	ctable['I'] = K_ACTION_VAR;
	ctable['J'] = K_ACTION_VAR;
	ctable['K'] = K_ACTION_VAR;
	ctable['L'] = K_ACTION_VAR;
	ctable['M'] = K_ACTION_VAR;
	ctable['N'] = K_ACTION_VAR;
	ctable['O'] = K_ACTION_VAR;
	ctable['P'] = K_ACTION_VAR;
	ctable['Q'] = K_ACTION_VAR;
	ctable['R'] = K_ACTION_VAR;
	ctable['S'] = K_ACTION_VAR;
	ctable['T'] = K_ACTION_VAR;
	ctable['U'] = K_ACTION_VAR;
	ctable['V'] = K_ACTION_VAR;
	ctable['W'] = K_ACTION_VAR;
	ctable['X'] = K_ACTION_VAR;
	ctable['Y'] = K_ACTION_VAR;
	ctable['Z'] = K_ACTION_VAR;
	ctable[143] = K_ACTION_VAR;
	ctable[142] = K_ACTION_VAR;
	ctable[153] = K_ACTION_VAR;
	ctable['a'] = K_ACTION_VAR;
	ctable['b'] = K_ACTION_VAR;
	ctable['c'] = K_ACTION_VAR;
	ctable['d'] = K_ACTION_VAR;
	ctable['e'] = K_ACTION_VAR;
	ctable['f'] = K_ACTION_VAR;
	ctable['g'] = K_ACTION_VAR;
	ctable['h'] = K_ACTION_VAR;
	ctable['i'] = K_ACTION_VAR;
	ctable['j'] = K_ACTION_VAR;
	ctable['k'] = K_ACTION_VAR;
	ctable['l'] = K_ACTION_VAR;
	ctable['m'] = K_ACTION_VAR;
	ctable['n'] = K_ACTION_VAR;
	ctable['o'] = K_ACTION_VAR;
	ctable['p'] = K_ACTION_VAR;
	ctable['q'] = K_ACTION_VAR;
	ctable['r'] = K_ACTION_VAR;
	ctable['s'] = K_ACTION_VAR;
	ctable['t'] = K_ACTION_VAR;
	ctable['u'] = K_ACTION_VAR;
	ctable['v'] = K_ACTION_VAR;
	ctable['w'] = K_ACTION_VAR;
	ctable['x'] = K_ACTION_VAR;
	ctable['y'] = K_ACTION_VAR;
	ctable['z'] = K_ACTION_VAR;
	ctable[134] = K_ACTION_VAR;
	ctable[132] = K_ACTION_VAR;
	ctable[148] = K_ACTION_VAR;
	ctable['['] = K_ACTION_VAR;
	ctable[']'] = K_ACTION_VAR;
	ctable['0'] = K_ACTION_NUM;
	ctable['1'] = K_ACTION_NUM;
	ctable['2'] = K_ACTION_NUM;
	ctable['3'] = K_ACTION_NUM;
	ctable['4'] = K_ACTION_NUM;
	ctable['5'] = K_ACTION_NUM;
	ctable['6'] = K_ACTION_NUM;
	ctable['7'] = K_ACTION_NUM;
	ctable['8'] = K_ACTION_NUM;
	ctable['9'] = K_ACTION_NUM;
	ctable['.'] = K_ACTION_FLOAT;
	ctable['"'] = K_ACTION_STRING;
	ctable[','] = K_ACTION_LIST;
	ctable['\\'] = K_ACTION_BACKSLASH;
    }

    public class CcmFuncToUpper extends CcmSysFunc {
	public CcmFuncToUpper( String name) {
	    super(name);
	}
	public CcmReturn func( CcmFileCtx filectx, CcmArg[] args) {
	    CcmReturn ret = new CcmReturn();

	    if ( args.length != 1) {
		ret.sts = CCM__ARGMISM;
		return ret;
	    }
	    if ( args[0].value_decl != K_DECL_STRING) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }
	    ret.rstring = args[0].value_string.toUpperCase();
	    ret.decl = K_DECL_STRING;	    
	    return ret;
	}
    }

    public class CcmFuncToLower extends CcmSysFunc {
	public CcmFuncToLower( String name) {
	    super(name);
	}
	public CcmReturn func( CcmFileCtx filectx, CcmArg[] args) {
	    CcmReturn ret = new CcmReturn();

	    if ( args.length != 1) {
		ret.sts = CCM__ARGMISM;
		return ret;
	    }
	    if ( args[0].value_decl != K_DECL_STRING) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }
	    ret.rstring = args[0].value_string.toLowerCase();
	    ret.decl = K_DECL_STRING;	    
	    return ret;
	}
    }

    public class CcmFuncTime extends CcmSysFunc {
	public CcmFuncTime( String name) {
	    super(name);
	}
	public CcmReturn func( CcmFileCtx filectx, CcmArg[] args) {
	    CcmReturn ret = new CcmReturn();

	    if ( args.length != 0) {
		ret.sts = CCM__ARGMISM;
		return ret;
	    }
	    Calendar cal = Calendar.getInstance();
		
	    SimpleDateFormat format = new SimpleDateFormat("dd-MMM-yyyy HH:mm:ss");
	    ret.rstring = format.format(cal.getTime()).toUpperCase();

	    ret.decl = K_DECL_STRING;	    
	    return ret;
	}
    }

    public class CcmFuncSystem extends CcmSysFunc {
	public CcmFuncSystem( String name) {
	    super(name);
	}
	public CcmReturn func( CcmFileCtx filectx, CcmArg[] args) {
	    CcmReturn ret = new CcmReturn();

	    if ( args.length != 1) {
		ret.sts = CCM__ARGMISM;
		return ret;
	    }
	    if ( args[0].value_decl != K_DECL_STRING) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }

	    try {
		Runtime.getRuntime().exec( args[0].value_string);
	    }
	    catch ( IOException e) {
		System.out.println( "IOException");
	    }
	    ret.decl = K_DECL_INT;
	    ret.rint = 1;
	    return ret;
	}
    }

    public class CcmFuncPrintf extends CcmSysFunc {
	public CcmFuncPrintf( String name) {
	    super(name);
	}
	public CcmReturn func( CcmFileCtx filectx, CcmArg[] args) {
	    CcmReturn ret = new CcmReturn();

	    String	format;
	    String	frm;
	    int	sts = 0;

	    if ( args.length == 0) {
		ret.sts = CCM__ARGMISM;
		return ret;
	    }

	    if ( args[0].value_decl != K_DECL_STRING) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }

	    // Replace any '\x' characters
	    format = new String(args[0].value_string);
	    for ( int i = 0; i < format.length() - 1; i++) {
		if ( format.charAt(i) == '\\') {
		    switch ( format.charAt(i+1)) {
		    case 'n':
			format = new StringBuffer(format).delete(i,i+2).insert(i,'\n').toString();
			break;
		    case '"':
			format = new StringBuffer(format).delete(i,i+2).insert(i,'\"').toString();
			break;
		    case '\\':
			format = new StringBuffer(format).delete(i,i+2).insert(i,'\\').toString();
			break;
		    default: ;
		    }
		}
	    }

	    if ( args.length == 1) {
		System.out.printf( "%s", format);
	    }
	    else {

		int pos = 0;
		int last_pos = 0;
		int aix = 1;
		for ( int i = 0; i < args.length; i++) {

		    pos = format.indexOf( '%', pos);
		    if ( pos != -1) {
			while ( pos != -1 && format.charAt(pos+1) == '%') {
			    pos += 2;
			    pos = format.indexOf( '%', pos);
			}
		    }
		    if ( pos == -1 && i != args.length - 1) {
			ret.sts = CCM__ARGMISM;
			return ret;
		    }
		    if ( pos != - 1 && i == args.length - 1) {
			ret.sts = CCM__ARGMISM;
			return ret;
		    }

		    if ( pos == - 1)
			pos = format.length();
			
		    if ( i == 0) {
			pos++;
			continue;
		    }

		    frm = format.substring( last_pos, pos);
		    switch ( args[aix].value_decl) {
		    case K_DECL_FLOAT: 
			System.out.printf( frm, args[aix].value_float);
			break;
		    case K_DECL_INT: 
			System.out.printf( frm, args[aix].value_int);
			break;
		    case K_DECL_STRING: 
			System.out.printf( frm, args[aix].value_string);
			break;
		    }
		    last_pos = pos;
		    pos++;
		    aix++;
		}

	    }
	    sts = format.length(); // TODO
	    ret.decl = K_DECL_INT;
	    ret.rint = sts;
	    return ret;

	}
    }

    public class CcmFuncSprintf extends CcmSysFunc {
	public CcmFuncSprintf( String name) {
	    super(name);
	}
	public CcmReturn func( CcmFileCtx filectx, CcmArg[] args) {
	    CcmReturn ret = new CcmReturn();

	    String	format;
	    String	frm;
	    int	sts = 0;

	    if ( args.length <= 1) {
		ret.sts = CCM__ARGMISM;
		return ret;
	    }

	    if ( args[0].value_decl != K_DECL_STRING) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }

	    if ( args[1].value_decl != K_DECL_STRING) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }

	    // Replace any '\x' characters
	    format = new String(args[1].value_string);
	    for ( int i = 0; i < format.length() - 1; i++) {
		if ( format.charAt(i) == '\\') {
		    switch ( format.charAt(i+1)) {
		    case 'n':
			format = new StringBuffer(format).delete(i,i+2).insert(i,'\n').toString();
			break;
		    case '"':
			format = new StringBuffer(format).delete(i,i+2).insert(i,'\"').toString();
			break;
		    case '\\':
			format = new StringBuffer(format).delete(i,i+2).insert(i,'\\').toString();
			break;
		    default: ;
		    }
		}
	    }

	    if ( args.length == 1) {
 		args[0].value_string = format;
 		args[0].value_returned = true;
	    }
	    else {

		int pos = 0;
		int last_pos = 0;
		int aix = 2;
		String str = "";
		for ( int i = 0; i < args.length - 1; i++) {

		    pos = format.indexOf( '%', pos);
		    if ( pos != -1) {
			while ( pos != -1 && format.charAt(pos+1) == '%') {
			    pos += 2;
			    pos = format.indexOf( '%', pos);
			}
		    }
		    if ( pos == -1 && i != args.length - 2) {
			ret.sts = CCM__ARGMISM;
			return ret;
		    }
		    if ( pos != - 1 && i == args.length - 2) {
			ret.sts = CCM__ARGMISM;
			return ret;
		    }

		    if ( pos == - 1)
			pos = format.length();
			
		    if ( i == 0) {
			pos++;
			continue;
		    }

		    frm = format.substring( last_pos, pos);
		    switch ( args[aix].value_decl) {
		    case K_DECL_FLOAT: 
			str += String.format(frm, args[aix].value_float);
			break;
		    case K_DECL_INT: 
			str += String.format( frm, args[aix].value_int);
			break;
		    case K_DECL_STRING: 
			str += String.format( frm, args[aix].value_string);
			break;
		    }
		    last_pos = pos;
		    pos++;
		    aix++;
		}
 		args[0].value_string = str;
 		args[0].value_returned = true;
	    }
	    sts = format.length(); // TODO
	    ret.decl = K_DECL_INT;
	    ret.rint = sts;
	    return ret;

	}
    }

    public class CcmFuncSay extends CcmSysFunc {
	public CcmFuncSay( String name) {
	    super(name);
	}
	public CcmReturn func( CcmFileCtx filectx, CcmArg[] args) {
	    CcmReturn ret = new CcmReturn();

	    if ( args.length != 1) {
		ret.sts = CCM__ARGMISM;
		return ret;
	    }
	    if ( args[0].value_decl != K_DECL_STRING) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }
	    System.out.println( args[0].value_string);
	    ret.rint = args[0].value_string.length();
	    ret.decl = K_DECL_INT;	    
	    return ret;
	}
    }

    public class CcmFuncScanf extends CcmSysFunc {
	public CcmFuncScanf( String name) {
	    super(name);
	}
	public CcmReturn func( CcmFileCtx filectx, CcmArg[] args) {
	    CcmReturn ret = new CcmReturn();

	    if ( args.length != 2) {
		ret.sts = CCM__ARGMISM;
		return ret;
	    }
	    if ( args[0].value_decl != K_DECL_STRING) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }

	    Scanner in = new Scanner( System.in);

	    if ( args[1].value_decl == K_DECL_FLOAT)
		args[1].value_float = in.nextFloat();
	    else if ( args[1].value_decl == K_DECL_INT)
		args[1].value_int = in.nextInt();
	    else if ( args[1].value_decl == K_DECL_STRING) {
		args[1].value_string = in.nextLine();
	    }
	    in.close();

	    args[1].value_returned = true;
	    ret.rint = args[0].value_string.length(); // TODO
	    ret.decl = K_DECL_INT;	    
	    return ret;
	}
    }

    public class CcmFuncAsk extends CcmSysFunc {
	public CcmFuncAsk( String name) {
	    super(name);
	}
	public CcmReturn func( CcmFileCtx filectx, CcmArg[] args) {
	    CcmReturn ret = new CcmReturn();

	    if ( args.length != 2) {
		ret.sts = CCM__ARGMISM;
		return ret;
	    }
	    if ( args[0].value_decl != K_DECL_STRING) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }

	    System.out.print( args[0].value_string);

	    Scanner in = new Scanner( System.in);

	    if ( args[1].value_decl == K_DECL_FLOAT)
		args[1].value_float = in.nextFloat();
	    else if ( args[1].value_decl == K_DECL_INT)
		args[1].value_int = in.nextInt();
	    else if ( args[1].value_decl == K_DECL_STRING) {
		args[1].value_string = in.nextLine();
	    }
	    in.close();

	    args[1].value_returned = true;
	    ret.rint = args[0].value_string.length(); // TODO
	    ret.decl = K_DECL_INT;	    
	    return ret;
	}
    }

    public class CcmFuncVerify extends CcmSysFunc {
	public CcmFuncVerify( String name) {
	    super(name);
	}
	public CcmReturn func( CcmFileCtx filectx, CcmArg[] args) {
	    CcmReturn ret = new CcmReturn();

	    if ( args.length == 0) {
		ret.rint = filectx.verify ? 1 : 0;
		ret.decl = K_DECL_INT;
		return ret;
	    }
	    if ( args[0].value_decl == K_DECL_INT) {
		if ( args[0].value_int == 1)
		    filectx.verify = true;
		else if ( args[0].value_int == 0)
		    filectx.verify = false;
		ret.rint = filectx.verify ? 1 : 0;
		ret.decl = K_DECL_INT;
		return ret;
	    }
	    else {
		ret.sts = CCM__ARGMISM;
		return ret;
	    }
	}
    }

    public class CcmFuncElement extends CcmSysFunc {
	public CcmFuncElement( String name) {
	    super(name);
	}
	public CcmReturn func( CcmFileCtx filectx, CcmArg[] args) {
	    CcmReturn ret = new CcmReturn();

	    if ( args.length != 3) {
		ret.sts = CCM__ARGMISM;
		return ret;
	    }
	    if ( args[0].value_decl != K_DECL_INT) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }
	    if ( args[1].value_decl != K_DECL_STRING) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }
	    if ( args[2].value_decl != K_DECL_STRING) {
 		ret.sts = CCM__VARTYPE;
		return ret;
	    }
 
	    String[] elem = args[2].value_string.split(args[1].value_string);
	    if ( args[0].value_int > elem.length || args[0].value_int <= 0) {
 		ret.sts = CCM__ARRAYBOUNDS;
		return ret;
	    }
	    ret.rstring = elem[args[0].value_int -1];
	    ret.decl = K_DECL_STRING;
	    return ret;
	}
    }

    public class CcmFuncExtract extends CcmSysFunc {
	public CcmFuncExtract( String name) {
	    super(name);
	}
	public CcmReturn func( CcmFileCtx filectx, CcmArg[] args) {
	    CcmReturn ret = new CcmReturn();

	    if ( args.length != 3) {
		ret.sts = CCM__ARGMISM;
		return ret;
	    }
	    if ( args[0].value_decl != K_DECL_INT) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }
	    if ( args[1].value_decl != K_DECL_INT) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }
	    if ( args[2].value_decl != K_DECL_STRING) {
 		ret.sts = CCM__VARTYPE;
		return ret;
	    }
	    
	    if ( args[0].value_int > args[2].value_string.length() ||
		 args[0].value_int < 1 || args[1].value_int < 1)
		ret.rstring = "";
	    else {
		int endpos = args[0].value_int - 1 + args[1].value_int;
		if ( endpos > args[2].value_string.length())
		    endpos = args[2].value_string.length();
		ret.rstring = args[2].value_string.substring(args[0].value_int - 1, endpos);
	    }
	    ret.decl = K_DECL_STRING;
	    return ret;
	}
    }

    public class CcmFuncEdit extends CcmSysFunc {
	public CcmFuncEdit( String name) {
	    super(name);
	}
	public CcmReturn func( CcmFileCtx filectx, CcmArg[] args) {
	    CcmReturn ret = new CcmReturn();

	    if ( args.length != 1) {
		ret.sts = CCM__ARGMISM;
		return ret;
	    }
	    if ( args[0].value_decl != K_DECL_STRING) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }
	    
	    String str = args[0].value_string.trim();
	    for ( int i = 0; i < str.length() - 1; i++) {		
		if ( str.charAt(i) == '\t' || str.charAt(i) == ' ') {
		    if ( str.charAt(i) == '\t')
			str = new StringBuffer(str).delete(i,i+1).insert(i,' ').toString();
		    while ( str.charAt(i+1) == '\t' || str.charAt(i+1) == ' ')
			str = new StringBuffer(str).delete(i+1,i+2).toString();
		}
	    }
	    
	    ret.rstring = str;
	    ret.decl = K_DECL_STRING;
	    return ret;
	}
    }

    public class CcmFuncStrlen extends CcmSysFunc {
	public CcmFuncStrlen( String name) {
	    super(name);
	}
	public CcmReturn func( CcmFileCtx filectx, CcmArg[] args) {
	    CcmReturn ret = new CcmReturn();

	    if ( args.length != 1) {
		ret.sts = CCM__ARGMISM;
		return ret;
	    }
	    if ( args[0].value_decl != K_DECL_STRING) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }
	    
	    ret.rint = args[0].value_string.length();
	    ret.decl = K_DECL_INT;
	    return ret;
	}
    }

    public class CcmFuncStrchr extends CcmSysFunc {
	public CcmFuncStrchr( String name) {
	    super(name);
	}
	public CcmReturn func( CcmFileCtx filectx, CcmArg[] args) {
	    CcmReturn ret = new CcmReturn();

	    if ( args.length != 2) {
		ret.sts = CCM__ARGMISM;
		return ret;
	    }
	    if ( args[0].value_decl != K_DECL_STRING) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }
	    if ( args[1].value_decl != K_DECL_STRING) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }
	    
	    ret.rint = args[0].value_string.indexOf(args[1].value_string.charAt(0)) + 1;
	    ret.decl = K_DECL_INT;
	    return ret;
	}
    }

    public class CcmFuncStrrchr extends CcmSysFunc {
	public CcmFuncStrrchr( String name) {
	    super(name);
	}
	public CcmReturn func( CcmFileCtx filectx, CcmArg[] args) {
	    CcmReturn ret = new CcmReturn();

	    if ( args.length != 2) {
		ret.sts = CCM__ARGMISM;
		return ret;
	    }
	    if ( args[0].value_decl != K_DECL_STRING) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }
	    if ( args[1].value_decl != K_DECL_STRING) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }
	    
	    ret.rint = args[0].value_string.lastIndexOf(args[1].value_string.charAt(0)) + 1;
	    ret.decl = K_DECL_INT;
	    return ret;
	}
    }

    public class CcmFuncStrstr extends CcmSysFunc {
	public CcmFuncStrstr( String name) {
	    super(name);
	}
	public CcmReturn func( CcmFileCtx filectx, CcmArg[] args) {
	    CcmReturn ret = new CcmReturn();

	    if ( args.length != 2) {
		ret.sts = CCM__ARGMISM;
		return ret;
	    }
	    if ( args[0].value_decl != K_DECL_STRING) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }
	    if ( args[1].value_decl != K_DECL_STRING) {
		ret.sts = CCM__VARTYPE;
		return ret;
	    }
	    
	    ret.rint = args[0].value_string.indexOf(args[1].value_string) + 1;
	    ret.decl = K_DECL_INT;
	    return ret;
	}
    }


    public class CcmFuncExit extends CcmSysFunc {
	public CcmFuncExit( String name) {
	    super(name);
	}
	public CcmReturn func( CcmFileCtx filectx, CcmArg[] args) {
	    CcmReturn ret = new CcmReturn();

	    if ( args.length != 0 && args[0].value_decl == K_DECL_INT)
		ret.rint = args[0].value_int;
	    else
		ret.rint = 1;
	    ret.decl = K_DECL_INT;

	    ret.sts = CCM__EXITFUNC;
	    return ret;
	}
    }

    public int readFile( CcmFileCtx filectx, String filename, Vector<CcmLine> line_list) {
	String line;
	int row = 0;

	try {
	    BufferedReader reader;

	    if ( filectx.appl != null && 
		 (filectx.appl.getRootType() == ROOT_APPLET || filectx.appl.getRootType() == ROOT_AAPP)) {
		URL fileURL = new URL( filename);
		InputStream in = fileURL.openStream();
		InputStreamReader r2 = new InputStreamReader(in, "ISO-8859-1");
		reader = new BufferedReader( r2);
	    }
	    else
		reader = new BufferedReader( new InputStreamReader( new FileInputStream( filename), "ISO-8859-1"));

	    while ( (line = reader.readLine()) != null) {
		row++;
		line = line.trim();

		if ( line.isEmpty())
		    continue;
		     
		if ( line.startsWith( "#include")) {
		    /* TODO */
		    // Read the include file
		    int s = line.indexOf( '<');
		    if ( s == -1) {
			filectx.error_row = row;
			filectx.error_line = line;
			return CCM__SYNTAX;
		    }
		    int se = line.lastIndexOf( '>');
		    if ( se == -1) {
			filectx.error_row = row;
			filectx.error_line = line;
			return CCM__SYNTAX;
		    }
		    String fname = line.substring( s+1, se);
		    if ( filectx.appl != null)
			fname = filectx.appl.defFilename(fname);
		    		    
		    int sts = readFile( filectx, fname, filectx.line_list);
		    if ( EVEN(sts)) return sts;
		    continue;
		}
		if ( line.charAt(0) == '#')
		    continue;

		// If last char is backslash, concatenate next line
		if ( line.charAt(line.length()-1) == '\\') {
		    String line2 = reader.readLine();		    
		    if ( line2 == null) {
			filectx.error_row = row;
			filectx.error_line = new String("EOF");
			return CCM__SYNTAX;
		    }
		    row++;

		    line2 = line2.trim();
		    line = line.substring( 0, line.length()-1) + line2;
		}

		CcmLine l = new CcmLine( line, row);
		l.idx = line_list.size();
		line_list.add( l);
	    }
	    reader.close();

	}
	catch ( IOException e) {
	    System.err.format( "IOException %s%n", e);
	    return CCM__OPENFILE;
	}

	return 1;
    }

    public int readBuffer( CcmFileCtx filectx, String buffer, Vector<CcmLine> line_list) {
	String line;
	int row = 0;
	int last_line = -1;
	int s;

	
	while ( (s = buffer.indexOf( '\n', last_line + 1)) != -1) {
	    row++;
	    line = buffer.substring( last_line + 1, s);
	    line = line.trim();
	    last_line = s;

	    if ( line.isEmpty())
		continue;
		     
	    if ( line.startsWith( "#include"))
		continue;

	    if ( line.charAt(0) == '#')
		continue;

	    // If last char is backslash, concatenate next line
	    if ( line.charAt(line.length()-1) == '\\') {
		s = buffer.indexOf( '\n', last_line + 1);
		if ( s == -1) {
		    filectx.error_row = row;
		    filectx.error_line = new String("EOF");
		    return CCM__SYNTAX;
		}
		row++;

		String line2 = buffer.substring( last_line + 1, s);
		line2 = line2.trim();
		line = line.substring( 0, line.length()-1) + line2;
	    }	    

	    CcmLine l = new CcmLine( line, row);
	    l.idx = line_list.size();
	    line_list.add( l);
	}

	line = buffer.substring( last_line + 1);
	line = line.trim();
	if ( !line.isEmpty() && !(line.charAt(0) != '#')) {
	    CcmLine l = new CcmLine( line, row);
	    l.idx = line_list.size();
	    line_list.add( l);
	}
	

	return 1;
    }

    CcmFileReturn fileExec( String cmd, boolean verify, boolean break_before, int extfunc_return_mode,
			    boolean resume, CcmFileCtx ctx, CcmLine extfunc_line, Object client_data,
			    CcmApplIfc appl) {
	int		i;
	CcmFileCtx 	filectx;
	String[]       	elm_str = null;
	int		nr;
        CcmArg[]	arg_list = new CcmArg[10];
	CcmArg		arg_p;
	int		arg_count = 0;
	CcmFileReturn   fret = new CcmFileReturn();

	if ( resume) {
	    filectx = ctx;
	}
	else {
	    // Parse the commandline
	    elm_str = cmd.split("[ 	]+");
	    if ( elm_str.length < 1) {
		fret.sts = CCM__SYNTAX;
		return fret;
	    }

	    // Create an argumentlist
	    arg_count = 0;
	    arg_list = new CcmArg[elm_str.length - 1];
	    for ( i = 1; i < elm_str.length; i++) {
		arg_p = new CcmArg();
		arg_p.value_string = elm_str[i];
		arg_p.value_decl = K_DECL_STRING;
		arg_list[i-1] = arg_p;
		arg_count++;
	    }
	}

	if ( ctx != null)
	    filectx = ctx;
	else
	    filectx = new CcmFileCtx();
	filectx.appl = appl;
	filectx.verify = verify;
	filectx.break_before = break_before;
	filectx.extfunc_return_mode = extfunc_return_mode;
	filectx.main_arg_list = arg_list;
	filectx.main_arg_count = arg_count;
	filectx.client_data = client_data;

	String filename = appl.defFilename(elm_str[0]);

	fret.sts = readFile( filectx, filename, filectx.line_list);
	if ( ODD(fret.sts)) {
	    fret.sts = initFilectx( filectx);	    
	}

	if ( ODD(fret.sts)) {
	    CcmReturn ret = functionExec( filectx, "main", null, arg_list, arg_count, resume);
	    fret.sts = ret.sts;
	    if ( ret.sts == CCM__EXTERNFUNC) {
		fret.extfunc_line = filectx.extfunc_line;
		return fret;
	    }
	    if ( ret.sts == CCM__EXITFUNC)
		fret.appl_sts = ret.rint;
	    else
		fret.appl_sts = 1;
	}
	if ( EVEN(fret.sts))
	    printError( filectx, fret.sts);
    
	return fret;
    }

    CcmFileReturn bufferExec( String buffer, boolean verify, boolean break_before, int extfunc_return_mode,
			      CcmFileCtx ctx, CcmLine extfunc_line, Object client_data,
			      CcmApplIfc appl) {
	int		i;
	CcmFileCtx 	filectx;
	CcmFileReturn   fret = new CcmFileReturn();

	if ( ctx != null)
	    filectx = ctx;
	else
	    filectx = new CcmFileCtx();

	filectx.appl = appl;
	filectx.verify = verify;
	filectx.break_before = break_before;
	filectx.extfunc_return_mode = extfunc_return_mode;
	filectx.main_arg_list = null;
	filectx.main_arg_count = 0;
	filectx.client_data = client_data;

	fret.sts = readBuffer( filectx, buffer, filectx.line_list);
	if ( ODD(fret.sts)) {
	    fret.sts = initFilectx( filectx);	    
	}

	if ( ODD(fret.sts)) {
	    CcmReturn ret = functionExec( filectx, "main", null, null, 0, false);
	    fret.sts = ret.sts;
	    if ( ret.sts == CCM__EXTERNFUNC) {
		fret.extfunc_line = filectx.extfunc_line;
		return fret;
	    }
	    if ( ret.sts == CCM__EXITFUNC)
		fret.appl_sts = ret.rint;
	    else
		fret.appl_sts = 1;
	}
	if ( EVEN(fret.sts))
	    printError( filectx, fret.sts);
    
	return fret;
    }

    int initFilectx( CcmFileCtx filectx) {
	boolean in_function = false;
	boolean func_found = false;
	boolean main_start_found = false;
	boolean main_end_found = false;

	for ( int i = 0; i < filectx.line_list.size(); i++) {
	    CcmLine line_p = filectx.line_list.get(i);

	    if ( line_p.line.startsWith("function") && line_p.line.length() > 8 &&
		 (line_p.line.charAt(8) == ' ' || line_p.line.charAt(8) == '	')) {
		if ( in_function) {
		    filectx.error_row = line_p.row;
		    filectx.error_line = line_p.line;
		    return CCM__FUNCNOTFOUND;
		}
		func_found = true;

		// Parse the command string
		String[] out_str = line_p.line.split("[ 	\\(]+");		
		if ( out_str.length < 4) {
		    filectx.error_row = line_p.row;
		    filectx.error_line = line_p.line;
		    return CCM__SYNTAX;
		}
		CcmFunc func_p = new CcmFunc();
		func_p.name = out_str[2];
		func_p.start_line = line_p;
		if ( out_str[1].equals("int"))
		    func_p.decl = K_DECL_INT;
		else if ( out_str[1].equals("float"))
		    func_p.decl = K_DECL_FLOAT;
		else if ( out_str[1].equals("string"))
		    func_p.decl = K_DECL_STRING;
		else {
		    filectx.error_row = line_p.row;
		    filectx.error_line = line_p.line;
		    return CCM__UNKNVARTYPE;
		}
		filectx.func_list.add( func_p);
		in_function = true;
	    }
	    else if ( line_p.line.startsWith( "endfunction")) {
		if ( !in_function) {
		    filectx.error_row = line_p.row;
		    filectx.error_line = line_p.line;
		    return CCM__FUNCMISM;
		}

		CcmFunc func_p = filectx.func_list.get(filectx.func_list.size()-1);
		func_p.end_line = line_p;
		in_function = false;
		line_p.type = K_LINE_ENDFUNCTION;
	    }
	    else if ( line_p.line.startsWith( "main")) {

		// Parse the command string
		String[] out_str = line_p.line.split("[ 	\\(]+");		
		if ( out_str.length < 1) {
		    filectx.error_row = line_p.row;
		    filectx.error_line = line_p.line;
		    return CCM__SYNTAX;
		}

		if ( out_str[0].startsWith( "main")) {
		    if ( main_start_found) {
			filectx.error_row = line_p.row;
			filectx.error_line = line_p.line;
			return CCM__MAINMISM;
		    }


		    filectx.main_start_line = line_p;
		    main_start_found = true;
		    line_p.type = K_LINE_MAIN;
		}
	    }
	    else if ( line_p.line.startsWith( "endmain")) {
		if ( !main_start_found) {
		    filectx.error_row = line_p.row;
		    filectx.error_line = line_p.line;
		    return CCM__MAINMISM;
		}
		
		filectx.main_end_line = line_p;
		main_end_found = true;
		line_p.type = K_LINE_ENDMAIN;
	    }
	    else if ( line_p.line.startsWith( "if") && line_p.line.length() > 2 &&
		      (line_p.line.charAt(2) == ' ' || line_p.line.charAt(2) == '	' ||
		       line_p.line.charAt(2) == '(')) {
		line_p.type = K_LINE_IF;
	    }
	    else if ( line_p.line.startsWith( "else") && 
		      (line_p.line.length() == 4 ||
		       line_p.line.charAt(4) == ' ' || line_p.line.charAt(4) == '	' ||
		       line_p.line.charAt(4) == 10  || line_p.line.charAt(4) == 0)) {
		line_p.type = K_LINE_ELSE;
	    }
	    else if ( line_p.line.startsWith( "endif") && 
		      (line_p.line.length() == 5 ||
		       line_p.line.charAt(5) == ' ' || line_p.line.charAt(5) == '	' ||
		       line_p.line.charAt(5) == 10  || line_p.line.charAt(5) == 0 ||
		       line_p.line.charAt(5) == ';')) {
		line_p.type = K_LINE_ENDIF;
	    }
	    else if ( line_p.line.startsWith( "while") && line_p.line.length() >= 5 &&
		      (line_p.line.charAt(5) == ' ' || line_p.line.charAt(5) == '	' ||
		       line_p.line.charAt(5) == '(')) {
		line_p.type = K_LINE_WHILE;
	    }
	    else if ( line_p.line.startsWith( "endwhile") && 
		      (line_p.line.length() == 8 ||
		       line_p.line.charAt(8) == ' ' || line_p.line.charAt(8) == '	' ||
		       line_p.line.charAt(8) == 10  || line_p.line.charAt(8) == 0 ||
		       line_p.line.charAt(8) == ';')) {
		line_p.type = K_LINE_ENDWHILE;
	    }
	    else if ( line_p.line.startsWith( "for") && line_p.line.length() > 3 &&
		      (line_p.line.charAt(3) == ' ' || line_p.line.charAt(3) == '	' ||
		       line_p.line.charAt(3) == '(')) {
		line_p.type = K_LINE_FOR;
	    }
	    else if ( line_p.line.startsWith( "endfor") && 
		      (line_p.line.length() == 6 ||
		       line_p.line.charAt(6) == ' ' || line_p.line.charAt(6) == '	' ||
		       line_p.line.charAt(6) == 10  || line_p.line.charAt(6) == 0 ||
		       line_p.line.charAt(6) == ';')) {
		line_p.type = K_LINE_ENDFOR;
	    }
	    else if ( line_p.line.startsWith( "break") && line_p.line.length() > 5 &&
		      (line_p.line.charAt(5) == ' ' || line_p.line.charAt(5) == '	' ||
		       line_p.line.charAt(5) == 10  || line_p.line.charAt(5) == 0 ||
		       line_p.line.charAt(5) == ';')) {
		line_p.type = K_LINE_BREAK;
	    }
	    else if ( line_p.line.startsWith( "continue") && line_p.line.length() > 8 &&
		      (line_p.line.charAt(8) == ' ' || line_p.line.charAt(8) == '	' ||
		       line_p.line.charAt(8) == 10  || line_p.line.charAt(8) == 0 ||
		       line_p.line.charAt(8) == ';')) {
		line_p.type = K_LINE_CONTINUE;
	    }
	    else if ( line_p.line.startsWith( "goto") && line_p.line.length() > 4 &&
		      (line_p.line.charAt(4) == ' ' || line_p.line.charAt(4) == '	' )) {
		line_p.type = K_LINE_GOTO;
	    }
	    else if ( line_p.line.length() != 0 &&
		      line_p.line.charAt(line_p.line.length()-1) == ':') {
		// Check label name
		boolean ok = true;
		for ( int j = 0; j < line_p.line.length(); j++) {
		    char c = line_p.line.charAt(j);
		    if ( ! (Character.isLetter(c) || c == '_')) {
			if ( j != line_p.line.length() - 1) {
			    ok = false;
			    break;
			}
		    }
		}
		if ( ok)
		    line_p.type = K_LINE_LABEL;
	    }
	}
	    
	if ( filectx.line_list.size() != 0 && 
	     !main_start_found && !main_end_found && !func_found) {
	    // No main and no function found, insert mainstart first and main end last
	    // in list

	    CcmLine l_p = new CcmLine( "endmain", 0);
	    filectx.main_end_line = l_p;
	    l_p.type = K_LINE_ENDMAIN;
	    filectx.line_list.add( l_p);
	    main_end_found = true;
	    
	    l_p = new CcmLine( "main()", 0);
	    filectx.main_start_line = l_p;
	    l_p.type = K_LINE_MAIN;
	    filectx.line_list.add( 0, l_p);
	    main_start_found = true;
	    filectx.updateLines();
	}

	if ( !main_start_found)
	    return CCM__MAINMISM;
	if ( !main_end_found)
	    return CCM__MAINMISM;
	if ( in_function)
	    return CCM__FUNCMISM;
	
	return 1;
    }
    
    CcmReturn functionExec( CcmFileCtx filectx, String name, CcmFunc func, CcmArg[] arg_list, int arg_count,
			    boolean resume) {
	boolean		return_found;
	int		i;
	CcmLine 	line_p;
	CcmLine 	l_p = null;
	int		sts = 1;
	CcmLine		start_line = null;
	CcmLine		end_line = null;
	boolean		main_found;
	boolean		found;
	CcmFunc		func_p = null;
	String[]       	arg_str = new String[20];
	String[]       	elm_str;
	CcmArg     	arg_p;
	int		nr;
	String		expr;
	CcmFuncCtx	funcctx;
	int		if_level;
	int		while_level;
	int		for_level;
	String		arg_name;
	CcmSysFunc     	sysfunc_p;
	String		label;
	String		goto_label;
	CcmReturn	return_val = null;
	int		decl;
	float		float_val;
	int		int_val;
	String		string_val;
	CcmReturn	retur = new CcmReturn();

	if ( resume) {
	    funcctx = filectx.main_funcctx;
	    start_line = filectx.lineNext(funcctx.current_line);
	    end_line = filectx.main_end_line;
	}
	else {
	    main_found = false;

	    if ( func != null) {
		/*
		sts = (*func)( (void *)filectx, arg_list, arg_count, 
			       return_decl, return_float, return_int, return_string);
		return sts;
		*/
	    }
	    else if ( name.equals( "main")) {
		start_line = filectx.lineNext(filectx.main_start_line);
		end_line = filectx.main_end_line;
		main_found = true;
	    }
	    else {
		// Search i system function list
		for ( i = 0; i < sysfunc_list.size(); i++) {
		    sysfunc_p = sysfunc_list.get(i);
		    if ( sysfunc_p.name.equals(name)) {
			CcmReturn ret = sysfunc_p.func( filectx, arg_list);
			return ret;
		    }
		}

		// Search for an application function
		found = false;
		for ( i = 0; i < filectx.func_list.size(); i++) {
		    func_p = filectx.func_list.get(i);
		    if ( func_p.name.equals( name)) {
			start_line = filectx.line_list.get(func_p.start_line.idx+1);
			end_line = func_p.end_line;
			found = true;
			break;
		    }
		}
		if ( !found)
		    return new CcmReturn(CCM__FUNCNOTFOUND);
	    }
	    
	    
	    funcctx = new CcmFuncCtx();
	    funcctx.filectx = filectx;
	    funcctx.arg_list = arg_list;
	    funcctx.arg_count = arg_count;

	    if ( main_found) {
		funcctx.is_main = true;
		filectx.main_funcctx = funcctx;
	    }
	    // Match the argument list and insert arguments as local variables
	    if ( !funcctx.is_main) {
		expr = extractParenthesExpr( func_p.start_line.line);
		arg_str = expr.split(",");
		    if ( arg_str.length != arg_count)
			return new CcmReturn(CCM__ARGMISM);
		for ( i = 0; i < arg_count; i++) {
		    arg_p = arg_list[i];
		    arg_str[i] = arg_str[i].trim();
		    elm_str = arg_str[i].split("[ 	]+");
		    if ( elm_str.length != 2)
			return new CcmReturn(CCM__SYNTAX);
		    if ( elm_str[0].equals( "float")) {
			     
			sts = createVar( elm_str[1], K_DECL_FLOAT, 0, 0, null,
					 funcctx.locint_list, funcctx.locfloat_list, funcctx.locstring_list);
			if ( EVEN(sts)) return new CcmReturn(sts);
			sts = setVar( funcctx, elm_str[1], arg_p.value_decl, arg_p.value_float,
				      arg_p.value_int, arg_p.value_string);
			if ( EVEN(sts)) return new CcmReturn(sts);
			arg_p.var_name = elm_str[1];
			arg_p.var_decl = K_DECL_FLOAT;
		    }
		    else if ( elm_str[0].equals( "int")) {
			sts = createVar( elm_str[1], K_DECL_INT, 0, 0, null,
					 funcctx.locint_list, funcctx.locfloat_list, funcctx.locstring_list);
			if ( EVEN(sts)) return new CcmReturn(sts);
			sts = setVar( funcctx, elm_str[1], arg_p.value_decl, arg_p.value_float,
				      arg_p.value_int, arg_p.value_string);
			if ( EVEN(sts)) return new CcmReturn(sts);
			arg_p.var_name = elm_str[1];
			arg_p.var_decl = K_DECL_INT;
		    }
		    else if ( elm_str[0].equals( "string")) {
			sts = createVar( elm_str[1], K_DECL_STRING, 0, 0, null,
					 funcctx.locint_list, funcctx.locfloat_list, funcctx.locstring_list);
			if ( EVEN(sts)) return new CcmReturn(sts);
			sts = setVar( funcctx, elm_str[1], arg_p.value_decl, arg_p.value_float,
				      arg_p.value_int, arg_p.value_string);
			if ( EVEN(sts)) return new CcmReturn(sts);
			arg_p.var_name = elm_str[1];
			arg_p.var_decl = K_DECL_STRING;
		    }
		    else
			return new CcmReturn(CCM__UNKNVARTYPE);
		}
	    }
	    else  if ( arg_list != null) {
		// Save the arguments as p1 - p9
		for ( i = 1; i <= 9; i++) {
		    arg_name = "p" + i;
		    if ( i - 1 < arg_list.length) {
			arg_p = arg_list[i-1];
			sts = createVar( arg_name, K_DECL_STRING, 0, 0, 
					 arg_p.value_string, funcctx.locint_list, 
					 funcctx.locfloat_list, funcctx.locstring_list);
			if ( EVEN(sts)) return new CcmReturn(sts);
		    }
		    else {
			sts = createVar( arg_name, K_DECL_STRING, 0, 0, 
					 "", funcctx.locint_list, 
					 funcctx.locfloat_list, funcctx.locstring_list);
			if ( EVEN(sts)) return new CcmReturn(sts);
		    }
		}
	    }

	    funcctx.for_init = true;
	}
	return_found = false;
	for ( line_p = start_line; line_p != end_line && line_p != null; line_p = filectx.lineNext(line_p)) {
	    if ( filectx.verify && line_p.type != K_LINE_STATMENT) {
		if ( filectx.break_before)
		    System.out.println( "");
		System.out.println( "CCM-I-VERIFY, \"" + line_p.line + "\"");
	    }

	    filectx.current_row = line_p.row;

	    if ( ccm_testmode)
		System.out.println( line_p.line);

	    switch ( line_p.type) {
	    case K_LINE_MAIN:
	    case K_LINE_FUNCTION:
		break;
	    case K_LINE_IF:
		expr = extractParenthesExpr( line_p.line);
		if ( expr == null)
		    return new CcmReturn( CCM__SYNTAX);
		    
		CcmReturn ret = lineExec( funcctx, expr);
		if ( ret.evenSts()) {
		    if ( filectx.error_row == 0) {
			filectx.error_row = line_p.row;
			filectx.error_line = line_p.line;
		    }
		    return ret;
		}
		decl = ret.decl;
		float_val = ret.rfloat;
		int_val = ret.rint;
		string_val = ret.rstring;
		if ( ret.sts == CCM__EXITFUNC) return ret;
		if ( (decl == K_DECL_INT && int_val == 0) ||
		     (decl == K_DECL_FLOAT && Math.abs(float_val) < Float.MIN_VALUE)) {
		    // Find next matching endif
		    if_level = 0;
		    found = false;
		    for ( i = line_p.idx + 1; i < filectx.line_list.size(); i++) {
			l_p = filectx.line_list.get(i);
			if ( l_p.type == K_LINE_IF)
			    if_level++;
			else if ( l_p.type == K_LINE_ENDIF) {
			    if ( if_level == 0) {
				found = true;
				break;
			    }
			    else
				if_level--;
			}
			else if ( l_p.type == K_LINE_ELSE) {
			    if ( if_level == 0) {
				found = true;
				break;
			    }
			}
		    }
		    if ( !found) 
			return new CcmReturn(CCM__IFMISM);
		    line_p = l_p;
		}
		break;
	    case K_LINE_ELSE:
		// Find next matching endif
		if_level = 0;
		found = false;
		for ( i = line_p.idx + 1; i < filectx.line_list.size(); i++) {
		    l_p = filectx.line_list.get(i);
		    if ( l_p.type == K_LINE_IF)
			if_level++;
		    else if ( l_p.type == K_LINE_ENDIF) {
			if ( if_level == 0) {
			    found = true;
			    break;
			}
			else
			    if_level--;
		    }
		}
		if ( !found)
		    return new CcmReturn(CCM__IFMISM);
		line_p = l_p;
		break;
	    case K_LINE_ENDIF:
		break;
	    case K_LINE_WHILE:
		expr = extractParenthesExpr( line_p.line);
		if ( expr == null)
		    return new CcmReturn( CCM__SYNTAX);
		ret = lineExec( funcctx, expr);		
		if ( ret.evenSts()) {
		    if ( filectx.error_row == 0) {
			filectx.error_row = line_p.row;
			filectx.error_line = line_p.line;
		    }
		    return ret;
		}
		if (sts == CCM__EXITFUNC)
		    return new CcmReturn(sts);
		decl = ret.decl;
		float_val = ret.rfloat;
		int_val = ret.rint;
		string_val = ret.rstring;
		if ( (decl == K_DECL_INT && int_val == 0) ||
		     (decl == K_DECL_FLOAT && Math.abs(float_val) < Float.MIN_VALUE)) {
		    // Find next matching endwhile
		    while_level = 0;
		    found = false;
		    for ( i = line_p.idx + 1; i < filectx.line_list.size(); i++) {
			l_p = filectx.line_list.get(i);
			if ( l_p.type == K_LINE_WHILE)
			    while_level++;
			else if ( l_p.type == K_LINE_ENDWHILE) {
			    if ( while_level == 0) {
				found = true;
				break;
			    }
			    else
				while_level--;
			}
		    }
		    if ( !found)
			return new CcmReturn(CCM__WHILEMISM);
		    line_p = l_p;
		}
		break;
	    case K_LINE_ENDWHILE:
		// Find previous matching while
		while_level = 0;
		found = false;
		for ( i = line_p.idx - 1; i >= 0; i--) {
		    l_p = filectx.line_list.get(i);
		    if ( l_p.type == K_LINE_ENDWHILE)
			while_level++;
		    else if ( l_p.type == K_LINE_WHILE) {
			if ( while_level == 0) {
			    found = true;
			    break;
			}
			else
			    while_level--;
		    }
		}
		if ( !found) {
		    return new CcmReturn(CCM__WHILEMISM);
		}
		line_p = filectx.line_list.get(l_p.idx-1);
		break;
	    case K_LINE_FOR:
		expr = extractParenthesExpr( line_p.line);
		if ( expr == null) return new CcmReturn(CCM__SYNTAX);
		elm_str = expr.split(";");		
		if ( elm_str.length != 3)
		    return new CcmReturn(CCM__SYNTAX);
		
		if ( funcctx.for_init)
		    ret = lineExec( funcctx, elm_str[0]);
		else
		    ret = lineExec( funcctx, elm_str[2]);
		if ( ret.evenSts()) {
		    if ( filectx.error_row == 0) {
			filectx.error_row = line_p.row;
			filectx.error_line = line_p.line;
		    }
		    return ret;
		}
		if (ret.sts == CCM__EXITFUNC) return ret;
		decl = ret.decl;
		float_val = ret.rfloat;
		int_val = ret.rint;
		string_val = ret.rstring;
		funcctx.for_init = true;
		elm_str[1] = elm_str[1].trim();
		if ( elm_str[1].isEmpty()) {
		    // Null-string is always true
		    decl = K_DECL_INT;
		    int_val = 1;
		}
		else {
		    ret = lineExec( funcctx, elm_str[1]);
		    if ( ret.evenSts()) {
			if ( filectx.error_row == 0) {
			    filectx.error_row = line_p.row;
			    filectx.error_line = line_p.line;
			}
			return ret;
		    }
		    if (ret.sts == CCM__EXITFUNC) return ret;
		}
		decl = ret.decl;
		float_val = ret.rfloat;
		int_val = ret.rint;
		string_val = ret.rstring;
		
		if ( (decl == K_DECL_INT && int_val == 0) ||
		     (decl == K_DECL_FLOAT && Math.abs(float_val) < Float.MIN_VALUE)) {
		    // Find next matching endfor
		    for_level = 0;
		    found = false;
		    for ( i = line_p.idx + 1; i < filectx.line_list.size(); i++) {
			l_p = filectx.line_list.get(i);
			if ( l_p.type == K_LINE_FOR)
			    for_level++;
			else if ( l_p.type == K_LINE_ENDFOR) {
			    if ( for_level == 0) {
				found = true;
				break;
			    }
			    else
				for_level--;
			}
		    }
		    if ( !found)
			return new CcmReturn(CCM__FORMISM);
		    line_p = l_p;
		}
		break;
	    case K_LINE_ENDFOR:
		// Find previous matching for
		for_level = 0;
		found = false;
		for ( i = line_p.idx - 1; i >= 0; i--) {
		    l_p = filectx.line_list.get(i);
		    if ( l_p.type == K_LINE_ENDFOR)
			for_level++;
		    else if ( l_p.type == K_LINE_FOR) {
			if ( for_level == 0) {
			    found = true;
			    break;
			}
			else
			    for_level--;
		    }
		}
		if ( !found)
		    return new CcmReturn(CCM__FORMISM);
		funcctx.for_init = false;
		line_p = filectx.line_list.get(l_p.idx - 1);
		break;
	    case K_LINE_CONTINUE:
		// Find previous matching for or while statement
		found = false;
		for_level = 0;
		while_level = 0;
		for ( i = line_p.idx - 1; i >= 0; i--) {
		    l_p = filectx.line_list.get(i);
		    if ( l_p.type == K_LINE_ENDFOR)
			for_level++;
		    else if ( l_p.type == K_LINE_FOR) {
			if ( for_level == 0) {
			    found = true;
			    funcctx.for_init = false;
			    break;
			}
			else
			    for_level--;
		    }
		    if ( l_p.type == K_LINE_ENDWHILE)
			while_level++;
		    else if ( l_p.type == K_LINE_WHILE) {
			if ( while_level == 0) {
			    found = true;
			    break;
			}
			else
			    while_level--;
		    }
		}
		if ( !found)
		    return new CcmReturn(CCM__CONTMISM);
		line_p = filectx.line_list.get(l_p.idx - 1);
		break;
	    case K_LINE_BREAK:
		// Find next matching endfor or endwhile statement
		found = false;
		for_level = 0;
		while_level = 0;
		for ( i = line_p.idx + 1; i < filectx.line_list.size(); i++) {
		    l_p = filectx.line_list.get(i);
		    if ( l_p.type == K_LINE_FOR)
			for_level++;
		    else if ( l_p.type == K_LINE_ENDFOR) {
			if ( for_level == 0) {
			    found = true;
			    break;
			}
			else
			    for_level--;
		    }
		    else if ( l_p.type == K_LINE_WHILE)
			while_level++;
		    else if ( l_p.type == K_LINE_ENDWHILE) {
			if ( while_level == 0) {
			    found = true;
			    break;
			}
			else
			    while_level--;
		    }
		}
		if ( !found)
		    return new CcmReturn(CCM__BREAKMISM);
		line_p = l_p;
		break;
	    case K_LINE_LABEL:
		break;
	    case K_LINE_GOTO:
		// Find matching label inside this function
		goto_label = line_p.line.substring(5, line_p.line.length()-1).trim();
		
		found = false;
		for ( i = start_line.idx; i != end_line.idx && i < filectx.line_list.size(); i++) {
		    l_p = filectx.line_list.get(i);
		    if ( l_p.type == K_LINE_LABEL) {
			label = l_p.line.substring(0, l_p.line.length()-1).trim();
			if ( label.equals( goto_label)) {
			    found = true;
			    break;
			}
		    }
		}
		if ( !found)
		    return new CcmReturn(CCM__GOTOMISM);
		line_p = l_p;
		break;
	    default:
		
		line_p.line = line_p.line.trim();
		if ( line_p.line.isEmpty())
		    break;
		else if ( line_p.line.charAt(line_p.line.length() - 1) != ';') {
		    // This is an external command
		    expr = replaceSymbol( funcctx, line_p.line);
		    
		    if ( filectx.verify) { 
			if ( filectx.break_before)
			    System.out.printf( "\nCCM-I-VERIFY, \"%s\"", expr);
			else
			    System.out.printf( "CCM-I-VERIFY, \"%s\"\n", expr);
		    }
		    
		    if ( funcctx.is_main && filectx.extfunc_return_mode != 0) {
			funcctx.current_line = line_p;
			filectx.extfunc_line = line_p;
			return new CcmReturn(CCM__EXTERNFUNC);
		    }
		    if ( filectx.appl != null)
			sts = filectx.appl.externCmd( expr);
		}
		else {
		    if ( filectx.verify) {
			if ( filectx.break_before)
			    System.out.println("");
			System.out.println( "CCM-I-VERIFY, \"" + line_p.line + "\"");
		    }
		    ret = lineExec( funcctx, line_p.line);
		    if ( ret.evenSts()) {
			if ( filectx.error_row == 0) {
			    filectx.error_row = line_p.row;
			    filectx.error_line = line_p.line;
			}
			return ret;
		    }
		    if ( ccm_testmode)
			System.out.println( line_p.line + "\n decl: " + ret.decl + " " + ret.rfloat + " " + ret.rint + " " + ret.rstring);
		    
		    if ( ret.getSts() == CCM__EXITFUNC) {
			return_val = new CcmReturn();
			return_val.rint = ret.rint;
			return_val.decl = ret.decl;
			return_found = true;
		    }
		    else if ( line_p.line.startsWith( "return") && line_p.line.length() > 6 &&
			      (line_p.line.charAt(6) == ' ' || line_p.line.charAt(6) == '	')) {
			// Return statement, set return value and exit function
			return_val = new CcmReturn();
			if ( func_p.decl == K_DECL_INT &&  ret.decl == K_DECL_INT)
			    return_val.rint = ret.rint;
			else if ( func_p.decl == K_DECL_INT &&  ret.decl == K_DECL_FLOAT)
			    return_val.rint = (int)ret.rfloat;
			else if ( func_p.decl == K_DECL_FLOAT &&  ret.decl == K_DECL_INT)
			    return_val.rfloat = ret.rint;
			else if ( func_p.decl == K_DECL_FLOAT &&  ret.decl == K_DECL_FLOAT)
			    return_val.rfloat = ret.rfloat;
			else if ( func_p.decl == K_DECL_STRING &&  ret.decl == K_DECL_STRING)
			    return_val.rstring  = ret.rstring;
			else if ( func_p.decl == K_DECL_STRING)
			    return_val.rstring = new String("");
			return_val.decl = func_p.decl;
			return_found = true;
		    }
		}
	    }
	    if ( return_found)
		break;
	}
	
	// Modify values in argument list
	if ( !funcctx.is_main) {
	    for ( i = 0; i < funcctx.arg_list.length; i++) {
		arg_p = funcctx.arg_list[i];
		if ( arg_p.value_type == K_OPERAND_NAME) {
		    CcmReturn ret = getVar( funcctx, arg_p.var_name);
		    if ( ret.evenSts()) return ret;

		    if ( arg_p.var_decl == arg_p.value_decl) {
			if ( ret.decl == K_DECL_FLOAT)
			    arg_p.value_float = ret.rfloat;
			else if ( ret.decl == K_DECL_INT)
			    arg_p.value_int = ret.rint;
			else if ( ret.decl == K_DECL_STRING)
			    arg_p.value_string = ret.rstring;
			arg_p.value_returned = true;
		    }
		}
	    }
	}
	
	if ( return_found)
	    return return_val;

	CcmReturn ret = new CcmReturn();
	if ( sts == CCM__EXITFUNC)
	    ret.sts = sts;
	else
	    ret.sts = 1;
	ret.decl = 0;
	return ret;
    }



    public static void main(String[] args) {
	String cmd = "/home/claes/jtest/test.rtt_com argh1 arghh2 arghhh3";

	Ccm ccm = new Ccm();

	CcmFileReturn fret = ccm.fileExec( cmd, false, false, 0,
					   false, null, null, null, null);
	/*

	CcmFileCtx filectx = new CcmFileCtx();
	filectx.verify = false;

	ccm.readFile( filectx, "/home/claes/jtest/test.rtt_com", filectx.line_list);
        ccm.initFilectx( filectx);

	CcmArg[] arg_list = new CcmArg[3];
	arg_list[0] = new CcmArg();
	arg_list[1] = new CcmArg();
	arg_list[2] = new CcmArg();
	arg_list[0].value_string = "arg1";
	arg_list[0].value_decl = K_DECL_STRING;
	arg_list[1].value_string = "arg2";
	arg_list[1].value_decl = K_DECL_STRING;
	arg_list[2].value_string = "arg3";
	arg_list[2].value_decl = K_DECL_STRING;
	int arg_count = arg_list.length;
	
	CcmReturn retur = ccm.functionExec( filectx, "main", null, arg_list, arg_count, false);
	if ( retur.evenSts())
	    ccm.printError( filectx, retur.sts);
	*/
    }

    public CcmReturn lineExec( CcmFuncCtx funcctx, String line) {
	int		sts;
	Vector<CcmOperand> list = new Vector<CcmOperand>();
        CcmOperand	op;
	CcmReturn	result = new CcmReturn();;

	sts = createList( (CcmFileCtx)funcctx.filectx, line, list);
	if ( EVEN(sts)) {
	    result = new CcmReturn();
	    result.sts = sts;
	    return result;
	}

	funcctx.list = list;

	for ( int i = 0; i < list.size(); i++) {
	    op = list.get(i);

	    if ( ccm_testmode)
		 System.out.println( "operator " + op.o_operator + " prio " + op.prio + " parlevel " + op.parlevel
			+ " Name " + op.name); 
	}

	result = executeList( funcctx, list);
	return result;
    }
    
    int createList( CcmFileCtx filectx, String line,  Vector<CcmOperand> list) {
	CcmRowCtx rowctx;
	String	msg;
	int     sts;
	int     c;

	rowctx = new CcmRowCtx();
	rowctx.list = list;
	rowctx.line = line;
	rowctx.filectx = filectx;

	init_ctable();

	for (;;) {

	    if ( rowctx.pos > K_LINE_SIZE -1) {
		rowctx.state = K_STATE_ERROR;
		rowctx.msg = "Expression to large";
		break;
	    }
	    if ( rowctx.state == K_STATE_STRING && rowctx.pos < rowctx.line.length()) {
		if ( ctable[ rowctx.line.charAt(rowctx.pos)] != K_ACTION_STRING ||
		     (ctable[ rowctx.line.charAt(rowctx.pos)] == K_ACTION_STRING &&
		      ctable[ rowctx.line.charAt(rowctx.pos-1)] == K_ACTION_BACKSLASH)) {
		    rowctx.pos++;
		    continue;
		}
	    }
	    if ( rowctx.pos >= rowctx.line.length())
		c = ctable[ 0];
	    else
		c = ctable[ rowctx.line.charAt(rowctx.pos)];
	    switch( c) {
	    case K_ACTION_VAR:
		if ( rowctx.state == K_STATE_NUM) {
		    rowctx.state = K_STATE_ERROR;
		    rowctx.msg = "Syntax error";
		}
		else if ( rowctx.state == K_STATE_NUM_NEG) {
		    rowctx.state = K_STATE_VAR;
		    rowctx.delim_pos = rowctx.pos;

		    // Create an -1 operand with multiplication operator
		    rowctx.last_type = K_TYPE_OPERATOR;
		    rowctx.delim_pos = rowctx.pos;
		    create_no_operand( rowctx);
		    rowctx.curr_operand.o_operator = K_ACTION_MUL;
		    rowctx.curr_operand.type = K_OPERAND_VALUE;
		    rowctx.curr_operand.name = "-1";
		    rowctx.curr_operand.value.rint = -1;
		    rowctx.curr_operand.value.decl = K_DECL_INT;
		    rowctx.curr_operand.prio = ptable[rowctx.curr_operand.o_operator];
		    set_operand_parlevel( rowctx);
		}
		else if ( !(rowctx.state == K_STATE_VAR || rowctx.state == K_STATE_STRING)) {
		    rowctx.state = K_STATE_VAR;
		    rowctx.delim_pos = rowctx.pos;
		}
		rowctx.pos++;
		break;

	    case K_ACTION_NUM:
		if ( rowctx.state == K_STATE_NUM_NEG) {
		    rowctx.state = K_STATE_NUM;
		    rowctx.delim_pos = rowctx.pos;
		    rowctx.num_neg = true;
		}
		else if ( !(rowctx.state == K_STATE_VAR || rowctx.state == K_STATE_NUM)) {
		    rowctx.state = K_STATE_NUM;
		    rowctx.delim_pos = rowctx.pos;
		}
		rowctx.pos++;
		break;

	    case K_ACTION_FLOAT:
		if ( rowctx.state == K_STATE_NUM)
		    rowctx.num_decl = K_DECL_FLOAT;
		else if ( rowctx.state == K_STATE_VAR)
		    ;
		else {
		    rowctx.state = K_STATE_ERROR;
		    rowctx.msg = "Syntax error";
		}
		rowctx.pos++;
		break;

	    case K_ACTION_STRING:
		if ( rowctx.state == K_STATE_NUM) {
		    rowctx.state = K_STATE_ERROR;
		    rowctx.msg = "Syntax error";
		}
		else if ( rowctx.state != K_STATE_STRING) {
		    rowctx.state = K_STATE_STRING;
		    rowctx.delim_pos = rowctx.pos + 1;
		}
		else {
		    sts = operand_found( rowctx);
		    if ( EVEN(sts)) break;
		    rowctx.state = K_STATE_DELIM;
		}
		rowctx.pos++;
		break;

	    case K_ACTION_LIST:
		if ( rowctx.state == K_STATE_NUM ||
		     rowctx.state == K_STATE_VAR) {
		    sts = operand_found( rowctx);
		    if ( EVEN(sts)) break;
		    rowctx.last_type = K_TYPE_OPERATOR;
		}
		else if ( !(rowctx.state == K_STATE_DELIM &&
			    rowctx.last_type == K_TYPE_OPERAND)) {
		    rowctx.state = K_STATE_ERROR;
		    rowctx.msg = "Syntax error";
		}

		rowctx.curr_operand.o_operator = K_ACTION_LIST;
		rowctx.state = K_STATE_LIST;
		rowctx.last_type = K_TYPE_OPERATOR;
		set_operand_parlevel( rowctx);
		rowctx.pos++;
		break;

	    case K_ACTION_DOWN:
		if ( rowctx.state == K_STATE_NUM ||
		     rowctx.state == K_STATE_VAR) {
		    sts = operand_found( rowctx);
		    if ( EVEN(sts)) break;
		}
		else if ( rowctx.state == K_STATE_PAR) {
		    create_no_operand( rowctx);
		    rowctx.last_type = K_TYPE_OPERAND;
		}
		else if ( rowctx.last_type != K_TYPE_OPERAND) {
		    create_no_operand( rowctx);
		    rowctx.last_type = K_TYPE_OPERAND;
		}
		rowctx.pos++;
		set_operand_parlevel_down( rowctx);
		rowctx.state = K_STATE_PAR;
		break;

	    case K_ACTION_UP:
		if ( rowctx.state == K_STATE_VAR &&
		     rowctx.last_type == K_TYPE_OPERATOR)
		    function_found( rowctx);
		else if ( rowctx.state == K_STATE_NUM_NEG) {
		    // Create an -1 operand with multiplication operator
		    rowctx.last_type = K_TYPE_OPERATOR;
		    rowctx.delim_pos = rowctx.pos;
		    create_no_operand( rowctx);
		    rowctx.curr_operand.o_operator = K_ACTION_MUL;
		    rowctx.curr_operand.type = K_OPERAND_VALUE;
		    rowctx.curr_operand.name = "-1";
		    rowctx.curr_operand.value.rint = -1;
		    rowctx.curr_operand.value.decl = K_DECL_INT;
		    rowctx.curr_operand.prio = ptable[rowctx.curr_operand.o_operator];
		    set_operand_parlevel( rowctx);

		    create_no_operand( rowctx);
		}
		else if ( rowctx.state == K_STATE_NUM ||
			  rowctx.state == K_STATE_VAR) {
		    sts = operand_found( rowctx);
		    if ( EVEN(sts)) break;
		}
		else if ( rowctx.last_type != K_TYPE_OPERAND) {
		    create_no_operand( rowctx);
		    rowctx.last_type = K_TYPE_OPERATOR;
		}
		rowctx.pos++;
		set_operand_parlevel_up( rowctx);
		rowctx.state = K_STATE_PAR;
		break;

	    case K_ACTION_INV:
		if ( rowctx.line.charAt(rowctx.pos+1) == '=') {
		    if ( rowctx.state == K_STATE_NUM ||
			 rowctx.state == K_STATE_VAR) {
			sts = operand_found( rowctx);
			if ( EVEN(sts)) break;
		    }
	
		    if ( rowctx.last_type != K_TYPE_OPERAND) {
			rowctx.state = K_STATE_ERROR;
			rowctx.msg = "Syntax error";
			break;
		    }

		    rowctx.curr_operand.o_operator = K_ACTION_NE;
		    rowctx.pos++;
		    rowctx.pos++;
		    rowctx.last_type = K_TYPE_OPERATOR;
		    rowctx.state = K_STATE_OPERATOR;
		    rowctx.curr_operand.prio = ptable[rowctx.curr_operand.o_operator];
		    set_operand_parlevel( rowctx);
		}
		else {
		    if ( rowctx.state == K_STATE_NUM ||
			 rowctx.state == K_STATE_VAR) {
			rowctx.state = K_STATE_ERROR;
			rowctx.msg = "Syntax error";
		    }
		    else {
			create_no_operand( rowctx);
			rowctx.last_type = K_TYPE_OPERATOR;
			rowctx.curr_operand.o_operator = K_ACTION_INV;
			rowctx.pos++;
			set_operand_parlevel( rowctx);
		    }
		}
		break;

	    case K_ACTION_ADD:
		if ( rowctx.state == K_STATE_NUM ||
		     rowctx.state == K_STATE_VAR) {
		    sts = operand_found( rowctx);
		    if ( EVEN(sts)) break;
		}
	
		if ( rowctx.line.charAt(rowctx.pos+1) == '+') {
		    if ( rowctx.last_type != K_TYPE_OPERAND) {
			rowctx.state = K_STATE_ERROR;
			rowctx.msg = "Syntax error";
			break;
		    }
		    rowctx.curr_operand.local_operator = K_ACTION_INCR;
		    rowctx.curr_operand.local_type = K_LOCTYPE_AFTER;
		    rowctx.pos++;
		    rowctx.pos++;
		    rowctx.state = K_STATE_DELIM;
		}
		else if ( rowctx.line.charAt(rowctx.pos+1) == '=') {
		    if ( rowctx.last_type != K_TYPE_OPERAND) {
			rowctx.state = K_STATE_ERROR;
			rowctx.msg = "Syntax error";
			break;
		    }
		    rowctx.curr_operand.o_operator = K_ACTION_EQLADD;
		    rowctx.pos++;
		    rowctx.pos++;
		    rowctx.last_type = K_TYPE_OPERATOR;
		    rowctx.state = K_STATE_OPERATOR;
		}
		else {
		    if ( rowctx.last_type != K_TYPE_OPERAND) {
			rowctx.state = K_STATE_ERROR;
			rowctx.msg = "Syntax error";
			break;
		    }
		    rowctx.curr_operand.o_operator = K_ACTION_ADD;
		    rowctx.pos++;
		    rowctx.last_type = K_TYPE_OPERATOR;
		    rowctx.state = K_STATE_OPERATOR;
		}
		rowctx.curr_operand.prio = ptable[rowctx.curr_operand.o_operator];
		set_operand_parlevel( rowctx);
		break;

	    case K_ACTION_SUB:
		if ( rowctx.state == K_STATE_NUM ||
		     rowctx.state == K_STATE_VAR) {
		    sts = operand_found( rowctx);
		    if ( EVEN(sts)) break;
		}

		if ( rowctx.line.charAt(rowctx.pos+1) == '-') {
		    if ( rowctx.last_type != K_TYPE_OPERAND) {
			rowctx.state = K_STATE_ERROR;
			rowctx.msg = "Syntax error";
			break;
		    }
		    rowctx.curr_operand.local_operator = K_ACTION_DECR;
		    rowctx.curr_operand.local_type = K_LOCTYPE_AFTER;
		    rowctx.state = K_STATE_DELIM;
		    rowctx.pos++;
		    rowctx.pos++;
		}
		else if ( rowctx.line.charAt(rowctx.pos+1) == '=') {
		    if ( rowctx.last_type != K_TYPE_OPERAND) {
			rowctx.state = K_STATE_ERROR;
			rowctx.msg = "Syntax error";
			break;
		    }
		    rowctx.curr_operand.o_operator = K_ACTION_EQLSUB;
		    rowctx.pos++;
		    rowctx.pos++;
		    rowctx.last_type = K_TYPE_OPERATOR;
		    rowctx.state = K_STATE_OPERATOR;
		}
		else if ( rowctx.last_type != K_TYPE_OPERAND) {
		    rowctx.state = K_STATE_NUM_NEG;
		    rowctx.pos++;
		}
		else {
		    rowctx.curr_operand.o_operator = K_ACTION_SUB;
		    rowctx.pos++;
		    rowctx.last_type = K_TYPE_OPERATOR;
		    rowctx.state = K_STATE_OPERATOR;
		}
		rowctx.curr_operand.prio = ptable[rowctx.curr_operand.o_operator];
		set_operand_parlevel( rowctx);
		break;

	    case K_ACTION_MUL:
		if ( rowctx.state == K_STATE_NUM ||
		     rowctx.state == K_STATE_VAR) {
		    sts = operand_found( rowctx);
		    if ( EVEN(sts)) break;
		}
	
		if ( rowctx.last_type != K_TYPE_OPERAND) {
		    rowctx.state = K_STATE_ERROR;
		    rowctx.msg = "Syntax error";
		    break;
		}

		else if ( rowctx.line.charAt(rowctx.pos+1) == '=') {
		    rowctx.curr_operand.o_operator = K_ACTION_EQLMUL;
		    rowctx.pos++;
		    rowctx.pos++;
		}
		else {
		    rowctx.curr_operand.o_operator = K_ACTION_MUL;
		    rowctx.pos++;
		}
		rowctx.last_type = K_TYPE_OPERATOR;
		rowctx.state = K_STATE_OPERATOR;
		rowctx.curr_operand.prio = ptable[rowctx.curr_operand.o_operator];
		set_operand_parlevel( rowctx);
		break;

	    case K_ACTION_DIV:
		if ( rowctx.state == K_STATE_NUM ||
		     rowctx.state == K_STATE_VAR) {
		    sts = operand_found( rowctx);
		    if ( EVEN(sts)) break;
		}
	
		if ( rowctx.last_type != K_TYPE_OPERAND) {
		    rowctx.state = K_STATE_ERROR;
		    rowctx.msg = "Syntax error";
		    break;
		}

		else if ( rowctx.line.charAt(rowctx.pos+1) == '=') {
		    rowctx.curr_operand.o_operator = K_ACTION_EQLDIV;
		    rowctx.pos++;
		    rowctx.pos++;
		}
		else {
		    rowctx.curr_operand.o_operator = K_ACTION_DIV;
		    rowctx.pos++;
		}
		rowctx.last_type = K_TYPE_OPERATOR;
		rowctx.state = K_STATE_OPERATOR;
		rowctx.curr_operand.prio = ptable[rowctx.curr_operand.o_operator];
		set_operand_parlevel( rowctx);
		break;

	    case K_ACTION_EQL:
		if ( rowctx.state == K_STATE_NUM ||
		     rowctx.state == K_STATE_VAR) {
		    sts = operand_found( rowctx);
		    if ( EVEN(sts)) break;
		}

		if ( rowctx.last_type != K_TYPE_OPERAND) {
		    rowctx.state = K_STATE_ERROR;
		    rowctx.msg = "Syntax error";
		    break;
		}

		else if ( rowctx.line.charAt(rowctx.pos+1) == '=') {
		    rowctx.curr_operand.o_operator = K_ACTION_EQ;
		    rowctx.pos++;
		    rowctx.pos++;
		}
		else {
		    rowctx.curr_operand.o_operator = K_ACTION_EQL;
		    rowctx.pos++;
		}
		rowctx.last_type = K_TYPE_OPERATOR;
		rowctx.state = K_STATE_OPERATOR;
		rowctx.curr_operand.prio = ptable[rowctx.curr_operand.o_operator];
		set_operand_parlevel( rowctx);
		break;

	    case K_ACTION_LT:
		if ( rowctx.state == K_STATE_NUM ||
		     rowctx.state == K_STATE_VAR) {
		    sts = operand_found( rowctx);
		    if ( EVEN(sts)) break;
		}
	
		if ( rowctx.last_type != K_TYPE_OPERAND) {
		    rowctx.state = K_STATE_ERROR;
		    rowctx.msg = "Syntax error";
		    break;
		}

		else if ( rowctx.line.charAt(rowctx.pos+1) == '=') {
		    rowctx.curr_operand.o_operator = K_ACTION_LE;
		    rowctx.pos++;
		    rowctx.pos++;
		}
		else if ( rowctx.line.charAt(rowctx.pos+1) == '<') {
		    rowctx.curr_operand.o_operator = K_ACTION_LSHIFT;
		    rowctx.pos++;
		    rowctx.pos++;
		}
		else {
		    rowctx.curr_operand.o_operator = K_ACTION_LT;
		    rowctx.pos++;
		}
		rowctx.last_type = K_TYPE_OPERATOR;
		rowctx.state = K_STATE_OPERATOR;
		rowctx.curr_operand.prio = ptable[rowctx.curr_operand.o_operator];
		set_operand_parlevel( rowctx);
		break;

	    case K_ACTION_GT:
		if ( rowctx.state == K_STATE_NUM ||
		     rowctx.state == K_STATE_VAR) {
		    sts = operand_found( rowctx);
		    if ( EVEN(sts)) break;
		}
	
		if ( rowctx.last_type != K_TYPE_OPERAND) {
		    rowctx.state = K_STATE_ERROR;
		    rowctx.msg = "Syntax error";
		    break;
		}

		else if ( rowctx.line.charAt(rowctx.pos+1) == '=') {
		    rowctx.curr_operand.o_operator = K_ACTION_GE;
		    rowctx.pos++;
		    rowctx.pos++;
		}
		else if ( rowctx.line.charAt(rowctx.pos+1) == '>') {
		    rowctx.curr_operand.o_operator = K_ACTION_RSHIFT;
		    rowctx.pos++;
		    rowctx.pos++;
		}
		else {
		    rowctx.curr_operand.o_operator = K_ACTION_GT;
		    rowctx.pos++;
		}
		rowctx.last_type = K_TYPE_OPERATOR;
		rowctx.state = K_STATE_OPERATOR;
		rowctx.curr_operand.prio = ptable[rowctx.curr_operand.o_operator];
		set_operand_parlevel( rowctx);
		break;

	    case K_ACTION_AND:
		if ( rowctx.state == K_STATE_NUM ||
		     rowctx.state == K_STATE_VAR) {
		    sts = operand_found( rowctx);
		    if ( EVEN(sts)) break;
		}	

		if ( rowctx.last_type != K_TYPE_OPERAND) {
		    rowctx.state = K_STATE_ERROR;
		    rowctx.msg = "Syntax error";
		    break;
		}

		else if ( rowctx.line.charAt(rowctx.pos+1) == '&') {
		    rowctx.curr_operand.o_operator = K_ACTION_AND;
		    rowctx.pos++;
		    rowctx.pos++;
		}
		else {
		    rowctx.curr_operand.o_operator = K_ACTION_BITAND;
		    rowctx.pos++;
		}
		rowctx.last_type = K_TYPE_OPERATOR;
		rowctx.state = K_STATE_OPERATOR;
		rowctx.curr_operand.prio = ptable[rowctx.curr_operand.o_operator];
		set_operand_parlevel( rowctx);
		break;

	    case K_ACTION_OR:
		if ( rowctx.state == K_STATE_NUM ||
		     rowctx.state == K_STATE_VAR) {
		    sts = operand_found( rowctx);
		    if ( EVEN(sts)) break;
		}
	
		if ( rowctx.last_type != K_TYPE_OPERAND) {
		    rowctx.state = K_STATE_ERROR;
		    rowctx.msg = "Syntax error";
		    break;
		}

		else if ( rowctx.line.charAt(rowctx.pos+1) == '|') {
		    rowctx.curr_operand.o_operator = K_ACTION_OR;
		    rowctx.pos++;
		    rowctx.pos++;
		}
		else {
		    rowctx.curr_operand.o_operator = K_ACTION_BITOR;
		    rowctx.pos++;
		}
		rowctx.last_type = K_TYPE_OPERATOR;
		rowctx.state = K_STATE_OPERATOR;
		rowctx.curr_operand.prio = ptable[rowctx.curr_operand.o_operator];
		set_operand_parlevel( rowctx);
		break;

	    case K_ACTION_END:
		if ( rowctx.state == K_STATE_VAR ||
		     rowctx.state == K_STATE_NUM) {
		    // Operand found
		    sts = operand_found( rowctx);
		    if ( EVEN(sts)) break;
		}
	
		set_operand_parlevel( rowctx);
		rowctx.state = K_STATE_END;
		break;

	    case K_ACTION_DELIM:
		if ( rowctx.state == K_STATE_VAR ||
		     rowctx.state == K_STATE_NUM) {
		    // Operand found
		    sts = operand_found( rowctx);
		    if ( EVEN(sts)) break;
		}
	
		if ( rowctx.state != K_STATE_NUM_NEG)
		    rowctx.state = K_STATE_DELIM;
		rowctx.pos++;
		break;

	    default:
		rowctx.pos++;
	    }
	    if ( rowctx.state == K_STATE_ERROR ||
		 rowctx.state == K_STATE_END)
		break;
	}
	if ( rowctx.state == K_STATE_ERROR) {
	    msg = rowctx.msg + " line " +  
		filectx.current_row + " pos " + (rowctx.pos - 1) + " \"" + rowctx.line + "\""; 
	    System.out.println( msg);
	    return CCM__EXPRESSION;
	}
	return 1;
    }

    void set_operand_parlevel( CcmRowCtx rowctx) {
        CcmOperand 	curr_operand;
	CcmOperand 	operand;
  
	if ( rowctx.curr_operand == null)
	    return;
	curr_operand = rowctx.curr_operand;
	int idx = rowctx.list.indexOf(curr_operand);
	if ( idx == 0)
	    curr_operand.parlevel = 1;
	else if ( curr_operand.parlevel == 0 ) {
	    operand = rowctx.list.get(idx-1);
	    curr_operand.parlevel = operand.parlevel;
	}
    }
    
    void set_operand_parlevel_down( CcmRowCtx rowctx) {
	CcmOperand 	curr_operand;
	CcmOperand 	operand;
  
	curr_operand = rowctx.curr_operand;

	int idx = rowctx.list.indexOf(curr_operand);
	if ( idx == 0) {
	    curr_operand.parlevel = 1;
	    return;
	}

	operand = rowctx.list.get(idx-1);
	if ( operand.parlevel == 1) {
	    rowctx.state = K_STATE_ERROR;
	    rowctx.msg = "Parenthesis mismatch";
	}
	else {
	    curr_operand.parlevel = operand.parlevel - 1;
	}
    }

    static void set_operand_parlevel_up( CcmRowCtx rowctx) {
	CcmOperand 	curr_operand;
	CcmOperand 	operand;
  
	curr_operand = rowctx.curr_operand;
	int idx = rowctx.list.indexOf(curr_operand);
	if ( idx == 0) {
	    curr_operand.parlevel = 2;
	    return;
	}
	operand = rowctx.list.get(idx-1);
	curr_operand.parlevel = operand.parlevel + 1;
    }

    void create_no_operand( CcmRowCtx rowctx) {
	CcmOperand 	operand_p;
	CcmOperand 	prev_operand;
 	
	operand_p = new CcmOperand();
	operand_p.type = K_OPERAND_NO;
	rowctx.curr_operand = operand_p;

	// Insert in list
	rowctx.list.add( operand_p);
    }

    int operand_found( CcmRowCtx rowctx) {
	CcmOperand 	operand_p;
	CcmOperand 	prev_operand;
	int		nr;
	String		upname;
 
	if ( rowctx.last_type != K_TYPE_OPERATOR) {
	    rowctx.state = K_STATE_ERROR;
	    return CCM__SYNTAX;
	}

	operand_p = new CcmOperand();

	if ( rowctx.state == K_STATE_VAR) {
	    // Variable found
	    operand_p.type = K_OPERAND_NAME;
	    operand_p.name = rowctx.line.substring( rowctx.delim_pos, rowctx.pos);

	    rowctx.last_type = K_TYPE_OPERAND;

	    // Check if reserved word 
	    upname = operand_p.name.toUpperCase();
	    if ( upname.equals( "INT")) {
		if ( rowctx.curr_operand != null && 
		     rowctx.curr_operand.type == K_OPERAND_GLOBAL)
		    operand_p.o_operator = K_ACTION_CREAGBLINT;
		else if ( rowctx.curr_operand != null && 
			  rowctx.curr_operand.type == K_OPERAND_EXTERN)
		    operand_p.o_operator = K_ACTION_CREAEXTINT;
		else
		    operand_p.o_operator = K_ACTION_CREALOCINT;
		operand_p.type = K_OPERAND_DECL;
		rowctx.last_type = K_TYPE_OPERATOR;
	    }
	    else if ( upname.equals( "FLOAT")) {
		if ( rowctx.curr_operand != null && 
		     rowctx.curr_operand.type == K_OPERAND_GLOBAL)
		    operand_p.o_operator = K_ACTION_CREAGBLFLOAT;
		else if ( rowctx.curr_operand != null && 
			  rowctx.curr_operand.type == K_OPERAND_EXTERN)
		    operand_p.o_operator = K_ACTION_CREAEXTFLOAT;
		else
		    operand_p.o_operator = K_ACTION_CREALOCFLOAT;
		operand_p.type = K_OPERAND_DECL;
		rowctx.last_type = K_TYPE_OPERATOR;
	    }
	    else if ( upname.equals( "STRING")) {
		if ( rowctx.curr_operand != null && 
		     rowctx.curr_operand.type == K_OPERAND_GLOBAL)
		    operand_p.o_operator = K_ACTION_CREAGBLSTRING;
		else if ( rowctx.curr_operand != null && 
			  rowctx.curr_operand.type == K_OPERAND_EXTERN)
		    operand_p.o_operator = K_ACTION_CREAEXTSTRING;
		else
		    operand_p.o_operator = K_ACTION_CREALOCSTRING;
		operand_p.type = K_OPERAND_DECL;
		rowctx.last_type = K_TYPE_OPERATOR;
	    }
	    else if ( upname.equals( "GLOBAL")) {
		operand_p.type = K_OPERAND_GLOBAL;
		operand_p.o_operator = K_ACTION_NO;
		rowctx.last_type = K_TYPE_OPERATOR;
	    }
	    else if ( upname.equals( "EXTERN")) {
		operand_p.type = K_OPERAND_EXTERN;
		operand_p.o_operator = K_ACTION_NO;
		rowctx.last_type = K_TYPE_OPERATOR;
	    }
	    else if ( upname.equals( "DELETE")) {
		operand_p.type = K_OPERAND_DELETE;
		operand_p.o_operator = K_ACTION_DELETE;
		rowctx.last_type = K_TYPE_OPERATOR;
	    }
	    else if ( upname.equals( "RETURN")) {
		operand_p.type = K_OPERAND_RETURN;
		operand_p.o_operator = K_ACTION_RETURN;
		rowctx.last_type = K_TYPE_OPERATOR;
	    }
	    
	}
	else if ( rowctx.state == K_STATE_NUM) {
	    // Numeric found
	    operand_p.type = K_OPERAND_VALUE;
	    operand_p.name =  rowctx.line.substring( rowctx.delim_pos, rowctx.pos);
	    if ( rowctx.num_decl == K_DECL_FLOAT) {
		operand_p.value.rfloat = Float.parseFloat(operand_p.name);
		operand_p.value.decl = K_DECL_FLOAT;
		if ( rowctx.num_neg)
		    operand_p.value.rfloat = -operand_p.value.rfloat;
	    }
	    else {
		operand_p.value.rint = Integer.parseInt(operand_p.name);
		operand_p.value.decl = K_DECL_INT;
		if ( rowctx.num_neg)
		    operand_p.value.rint = -operand_p.value.rint;
	    }
	    rowctx.num_decl = 0;
	    rowctx.last_type = K_TYPE_OPERAND;
	}
	else if ( rowctx.state == K_STATE_STRING) {
	    // String found
	    operand_p.type = K_OPERAND_VALUE;
	    if ( rowctx.pos - rowctx.delim_pos > K_STRING_SIZE - 1) {
		rowctx.state = K_STATE_ERROR;
		rowctx.msg = "String too long";
		return CCM__SYNTAX;
	    }
	    operand_p.name = rowctx.line.substring( rowctx.delim_pos, rowctx.pos);
	    operand_p.value.rstring = rowctx.line.substring( rowctx.delim_pos, rowctx.pos);
	    operand_p.value.decl = K_DECL_STRING;
	    rowctx.last_type = K_TYPE_OPERAND;
	}

	// Insert in list
	if ( rowctx.curr_operand == null) {
	    rowctx.list.add( operand_p);
	    rowctx.curr_operand = operand_p;
	}
	else {
	    int idx = rowctx.list.indexOf( rowctx.curr_operand);
	    rowctx.list.insertElementAt( operand_p, idx + 1);
	    rowctx.curr_operand = operand_p;
	}
	rowctx.num_neg = false;

	return CCM__SUCCESS;
    }

    void function_found( CcmRowCtx rowctx) {
	CcmOperand 	operand_p;
	CcmOperand 	prev_operand;
 
	operand_p = new CcmOperand();

	operand_p.type = K_OPERAND_FUNCTION;
	operand_p.name = rowctx.line.substring( rowctx.delim_pos, rowctx.pos);
	operand_p.o_operator = K_ACTION_FUNCTION;
	rowctx.last_type = K_TYPE_OPERATOR;

	// Insert in list
	if ( rowctx.curr_operand == null) {
	    rowctx.list.add( operand_p);
	    rowctx.curr_operand = operand_p;
	}
	else {
	    int idx = rowctx.list.indexOf( rowctx.curr_operand);
	    rowctx.list.insertElementAt( operand_p, idx + 1);
	    rowctx.curr_operand = operand_p;
	}
    }

    CcmReturn executeList( CcmFuncCtx funcctx, Vector<CcmOperand> list) {
	int		sts = 1;
	CcmOperand	op;
	CcmOperand	bp;
	boolean		exit_func_found;
	CcmReturn	result = new CcmReturn();

	// Store type
	for ( int i = 0; i < funcctx.list.size(); i++) {
	    op = funcctx.list.get(i);
	    op.orig_type = op.type;
	}

	exit_func_found = false;
	for ( int i = 0; i < funcctx.list.size(); i++) {
	    op = funcctx.list.get(i);

	    if ( i == 0) {
		// First in list
		if ( op.type == K_OPERAND_NAME) {
		    op.value = getVar( funcctx, op.name);
		    if ( op.value.evenSts()) return op.value;
		}
		switch ( op.value.decl) {
		case K_DECL_FLOAT:
		    op.result.rfloat = op.value.rfloat;
		    break;
		case K_DECL_INT:
		    op.result.rint = op.value.rint;
		    break;
		default:
		    op.result.rstring = op.value.rstring;
		}
		op.result.decl = op.value.decl;
		op.result_done = true;

		if ( i == funcctx.list.size() - 1) {
		    sts = operateExec( funcctx, op, null);
		    if ( EVEN(sts)) {
			result.sts = sts;
			return result;
		    }
		    if ( sts == CCM__EXITFUNC) exit_func_found = true;
		}
	    }
	    if ( i == funcctx.list.size() - 1) {
		// Last in list
		for ( int j = i - 1; j >= 0; j--) {
		    bp = funcctx.list.get(j);
		    if ( !bp.done) {
			sts = operateExec( funcctx, bp, op);
			if ( EVEN(sts)) {
			    result.sts = sts;
			    return result;
			}
			if ( sts == CCM__EXITFUNC) exit_func_found = true;
		    }
		}
		result.decl = op.result.decl;
		switch ( op.result.decl) {
		case K_DECL_FLOAT:
		    result.rfloat = op.result.rfloat;
		    break;
		case K_DECL_INT:
		    result.rint = op.result.rint;
		    break;
		case K_DECL_STRING:
		    result.rstring = op.result.rstring;
		    break;
		default: ;
		}
	    }
	    else {
		CcmOperand next = funcctx.list.get(i+1);
		CcmOperand prev = null;
		if ( i != 0)
		    prev = funcctx.list.get(i-1);
		if ( next.parlevel > op.parlevel) {

		    // Left parenthesis
		    if ( next.prio < op.prio) {

			for ( int j = i - 1; j >= 0; j--) {
			    bp = funcctx.list.get(j);

			    if ( bp.parlevel < op.parlevel)
				break;
			    if ( bp.parlevel > op.parlevel)
				continue;

			    if ( bp.prio <= op.prio && !bp.done) {
				sts = operateExec( funcctx, bp, op);
				if ( EVEN(sts)) {
				    result.sts = sts;
				    return result;
				}
				if ( sts == CCM__EXITFUNC) exit_func_found = true;
			    }
			}
		    }
		    continue;
		}
		else if ( next.parlevel < op.parlevel) {

		    // Right parentheseis, sum sinc last right parenthes
		    for ( int j = i; j >= 0; j--) {
			bp = funcctx.list.get(j);
			if ( bp.parlevel < op.parlevel)
			    break;
			if ( bp.parlevel > op.parlevel)
			    continue;

			if ( !bp.done) {
			    sts = operateExec( funcctx, bp, next);
			    if ( EVEN(sts)) {
				result.sts = sts;
				return result;
			    }
			    if ( sts == CCM__EXITFUNC) exit_func_found = true;
			}
		    }
		    
		}
		else {

		    if ( next.prio < op.prio) {
			for ( int j = i - 1; j >= 0; j--) {
			    bp = funcctx.list.get(j);
			    if ( bp.parlevel < op.parlevel)
				break;
			    if ( bp.parlevel > op.parlevel)
				continue;
			    if ( bp.prio <= op.prio && !bp.done) {
				sts = operateExec( funcctx, bp, op);
				if ( EVEN(sts)) {
				    result.sts = sts;
				    return result;
				}
				if ( sts == CCM__EXITFUNC) exit_func_found = true;
			    }
			}
			if ( next.type == K_OPERAND_NAME) {

			    next.value = getVar( funcctx, next.name);
			    if ( EVEN(sts)) {
				result.sts = sts;
				return result;
			    }
			}
			switch ( next.value.decl) {
			case K_DECL_FLOAT:
			    next.result.rfloat = next.value.rfloat;
			    break;
			case K_DECL_INT:
			    next.result.rint = next.value.rint;
			    break;
			case K_DECL_STRING:
			    next.result.rstring = next.value.rstring;
			    break;
			default: ;
			}
			next.result.decl = next.value.decl;
			next.result_done = true;
			continue;
		    }
		    else {
			sts = operateExec( funcctx, op, next);
			if ( EVEN(sts)) {
			    result.sts = sts;
			    return result;
			}
			if ( sts == CCM__EXITFUNC) exit_func_found = true;
		    }
		}
	    }
	    
	}

	// Reset and restore type for next evaluation
	for ( int i = 0; i < funcctx.list.size(); i++) {
	    op = funcctx.list.get(i);
	    op.type = op.orig_type;
	    op.done = false;
	    op.result_done = false;
	}

	if ( exit_func_found)
	    result.sts = CCM__EXITFUNC;
	else
	    result.sts = 1;
	return result;
    }

    CcmVariable varnameParse( CcmFuncCtx funcctx, String name) {
	CcmVariable result = new CcmVariable();

	// Check index in parameter
	int idx1 = name.indexOf('[');
	if ( idx1 == -1) {
	    result.array = false;
	    result.element = 0;
	    result.varname = name;
	}
	else {
	    int idx2 = name.indexOf(']');
	    if ( idx2 == -1 || idx2 <= idx1+1) {
		result.sts = 0;
		return result;
	    }	    
	    String elementstr = name.substring(idx1+1, idx2).trim();
	    try {
		result.element = new Integer(elementstr).intValue();
	    }
	    catch( NumberFormatException e) {
		// Try varible
		CcmReturn ret = getVar( funcctx, elementstr);
		if ( ret.evenSts()) {		
		    result.sts = ret.sts;
		    return result;
		}
		if ( ret.decl != K_DECL_INT) {
		    result.sts = 0;
		    return result;
		}
		result.element = ret.rint;
	    }
	    if ( result.element < 0 || result.element > 1000) {
		result.sts = 0;
		return result;
	    }	    
	    result.array = true;
	    result.varname = name.substring(0, idx1-1);
	}
	result.sts = 1;
	return result;
    }

    int createVar( String name, int decl, float value_float, int value_int, String value_string,
		   Vector<CcmIntvar> int_list, Vector<CcmFloatvar> float_list,
		   Vector<CcmStringvar> string_list) {
	CcmIntvar		int_p;
	CcmFloatvar		float_p;
	CcmStringvar		string_p;
	boolean			array;
	int			elements;
	String			varname;
	int			sts = 1;

	CcmVariable var = varnameParse( null, name);
	if ( EVEN(var.sts)) return var.sts;
	varname = var.varname;
	elements = var.element + 1;
	array = var.array;

	if ( decl == K_DECL_INT) {
	    for ( int i = 0; i < int_list.size(); i++) {
		if ( int_list.get(i).name.equals(varname))
		    return CCM__VARALREXIST;
	    }

	    int_p = new CcmIntvar();
	    int_p.name = varname;
	    if ( array) {
		int_p.avalue = new int[elements];
	    }
	    else
		int_p.value = value_int;
	    int_p.elements = elements;
	    int_p.array = array;
	    int_list.add(int_p);
	}
	else if ( decl == K_DECL_FLOAT) {
	    for ( int i = 0; i < float_list.size(); i++) {
		if ( float_list.get(i).name.equals(varname))
		    return CCM__VARALREXIST;
	    }

	    float_p = new CcmFloatvar();
	    float_p.name = varname;
	    if ( array) {
		float_p.avalue = new float[elements];
	    }
	    else
		float_p.value = value_float;
	    float_p.elements = elements;
	    float_p.array = array;
	    float_list.add(float_p);
	}
	else if ( decl == K_DECL_STRING) {
	    for ( int i = 0; i < string_list.size(); i++) {
		if ( string_list.get(i).name.equals(varname))
		    return CCM__VARALREXIST;
	    }

	    string_p = new CcmStringvar();
	    string_p.name = varname;
	    if ( array) {
		string_p.avalue = new String[elements];
	    }
	    else
		string_p.value = value_string;
	    string_p.elements = elements;
	    string_p.array = array;
	    string_list.add(string_p);
	}
	return 1;
    }

    int deleteVar( String name, Vector<CcmIntvar> int_list, Vector<CcmFloatvar> float_list,
		   Vector<CcmStringvar> string_list) {
	String varname;
	int sts;
	boolean found;

	CcmVariable var = varnameParse( null, name);
	if ( EVEN(var.sts)) return var.sts;
	varname = var.varname;

	found = false;

	for ( int i = 0; i < int_list.size(); i++) {
	    if ( int_list.get(i).name.equals(varname)) {
		int_list.remove(i);
		found = true;
		break;
	    }
	}

	if ( found)
	    return 1;

	for ( int i = 0; i < float_list.size(); i++) {
	    if ( float_list.get(i).name.equals(varname)) {
		float_list.remove(i);
		found = true;
		break;
	    }
	}

	if ( found)
	    return 1;

	for ( int i = 0; i < string_list.size(); i++) {
	    if ( string_list.get(i).name.equals(varname)) {
		string_list.remove(i);
		found = true;
		break;
	    }
	}

	if ( !found)
	    return CCM__VARNOTFOUND;
	return 1;
    }

    int createExternalVar( String name, int decl, float value_float, int value_int, String value_string) {
	int	sts;

	sts = createVar( name, decl, value_float, value_int, value_string,
			 extint_list, extfloat_list, extstring_list);
	if ( sts == CCM__VARALREXIST)
	    return CCM__SUCCESS;
	return sts;
    }

    int deleteExternalVar( String name, float value_float, int value_int, String value_string) {
	return deleteVar( name, extint_list, extfloat_list, extstring_list);
    }

    CcmReturn getVar( CcmFuncCtx funcctx, String name) {
	CcmIntvar      	int_p = null;
	CcmFloatvar	float_p = null;
	CcmStringvar	string_p = null;
	boolean	       	found;
	int	       	sts;
	boolean	       	array;
	int	       	element;
	String	       	varname;
	Vector<CcmIntvar> int_list;
	Vector<CcmFloatvar> float_list;
	Vector<CcmStringvar> string_list;
	CcmReturn	result = new CcmReturn();
	CcmFileCtx	filectx = (CcmFileCtx)funcctx.filectx;

	CcmVariable var = varnameParse( funcctx, name);
	if ( EVEN(var.sts)) {
	    result.sts = var.sts;
	    return result;
	}
	varname = var.varname;
	element = var.element;
	array = var.array;

	found = false;
	for ( int i = 0; i < 3; i++) {
	    if ( i == 0) {
		int_list = funcctx.locint_list;
		float_list = funcctx.locfloat_list;
		string_list = funcctx.locstring_list;
	    }
	    else if ( i == 1) {
		int_list = filectx.gblint_list;
		float_list = filectx.gblfloat_list;
		string_list = filectx.gblstring_list;
	    }
	    else {
		int_list = extint_list;
		float_list = extfloat_list;
		string_list = extstring_list;
	    }

	    for ( int j = 0; j < int_list.size(); j++) {
		if ( int_list.get(j).name.equals( varname)) {
		    found = true;
		    int_p = int_list.get(j);
		    break;
		}
	    }
	    if ( found) {
		if ( int_p.array != array) {
		    result.sts = CCM__VARNOTFOUND;
		    return result;
		}
		if ( int_p.array && ( element < 0 || element >= int_p.elements)) {
		    result.sts = CCM__ARRAYBOUNDS;
		    return result;
		}
		if ( int_p.array)
		    result.rint = int_p.avalue[element];
		else
		    result.rint = int_p.value;
		result.decl = K_DECL_INT;
	    }
	    else {
		// Search float
		for ( int j = 0; j < float_list.size(); j++) {
		    if ( float_list.get(j).name.equals( varname)) {
			found = true;
			float_p = float_list.get(j);
			break;
		    }
		}
		if ( found) {
		    if ( float_p.array != array) {
			result.sts = CCM__VARNOTFOUND;
			return result;
		    }
		    if ( float_p.array && ( element < 0 || element >= float_p.elements)) {
			result.sts = CCM__ARRAYBOUNDS;
			return result;
		    }
		    if ( float_p.array)
			result.rfloat = float_p.avalue[element];
		    else
			result.rfloat = float_p.value;
		    result.decl = K_DECL_FLOAT;
		}
		else {
		    // Search string
		    for ( int j = 0; j < string_list.size(); j++) {
			if ( string_list.get(j).name.equals( varname)) {
			    string_p = string_list.get(j);
			    found = true;
			    break;
			}
		    }
		    if ( found) {
			if ( string_p.array != array) {
			    result.sts = CCM__VARNOTFOUND;
			    return result;
			}
			if ( string_p.array && ( element < 0 || element >= string_p.elements)) {
			    result.sts = CCM__ARRAYBOUNDS;
			    return result;
			}
			if ( string_p.array)
			    result.rstring = string_p.avalue[element];
			else
			    result.rstring = string_p.value;
			result.decl = K_DECL_STRING;
		    }
		}
	    }
	    if ( found)
		break;
	}
	if ( !found) {
	    result.sts = CCM__VARNOTFOUND;
	    return result;
	}
	result.sts = 1;
	return result;
    }

    int setVar( CcmFuncCtx funcctx, String name, int decl, float value_float,
		    int value_int, String value_string) {
	CcmIntvar		int_p = null;
	CcmFloatvar		float_p = null;
	CcmStringvar		string_p = null;
	String			varname;
	boolean			found;
	int			element;
	boolean			array;
	Vector<CcmIntvar> int_list;
	Vector<CcmFloatvar> float_list;
	Vector<CcmStringvar> string_list;
	CcmFileCtx	filectx = (CcmFileCtx)funcctx.filectx;

	CcmVariable var = varnameParse( funcctx, name);
	if ( EVEN(var.sts)) return var.sts;
	varname = var.varname;
	element = var.element;
	array = var.array;

	found = false;
	for ( int i = 0; i < 3; i++) {
	    if ( i == 0) {
		int_list = funcctx.locint_list;
		float_list = funcctx.locfloat_list;
		string_list = funcctx.locstring_list;
	    }
	    else if ( i == 1) {
		int_list = filectx.gblint_list;
		float_list = filectx.gblfloat_list;
		string_list = filectx.gblstring_list;
	    }
	    else {
		int_list = extint_list;
		float_list = extfloat_list;
		string_list = extstring_list;
	    }

	    for ( int j = 0; j < int_list.size(); j++) {
		if ( int_list.get(j).name.equals(varname)) {
		    found = true;
		    int_p = int_list.get(j);
		    break;
		}
	    }
	    if ( found) {
		if ( int_p.array != array)
		    return CCM__VARNOTFOUND;
		if ( int_p.array && ( element < 0 || element >= int_p.elements))
		    return CCM__ARRAYBOUNDS;

		if ( decl == K_DECL_INT) {
		    if ( int_p.array)
			int_p.avalue[element] = value_int;
		    else
			int_p.value = value_int;
		}
		else if ( decl == K_DECL_FLOAT) {
		    if ( int_p.array)
			int_p.avalue[element] = (int)value_float;
		    else
			int_p.value = (int)value_float;
		}
		else {
		    try {
			if ( value_string.indexOf('.') != -1) {
			    if ( int_p.array)
				int_p.avalue[element] = (int)Float.parseFloat( value_string);
			    else
				int_p.value = (int)Float.parseFloat( value_string);
			}
			else {
			    if ( int_p.array)
				int_p.avalue[element] = Integer.parseInt( value_string);
			    else
				int_p.value = Integer.parseInt( value_string);
			}
		    }
		    catch( NumberFormatException e) {
			return CCM__VARTYPE;
		    }
		}
	    }
	    else {
		// Search float
		for ( int j = 0; j < float_list.size(); j++) {
		    if ( float_list.get(j).name.equals(varname)) {
			found = true;
			float_p = float_list.get(j);
			break;
		    }
		}
		if ( found) {
		    if ( float_p.array != array)
			return CCM__VARNOTFOUND;
		    if ( float_p.array && ( element < 0 || element >= float_p.elements))
			return CCM__ARRAYBOUNDS;

		    if ( decl == K_DECL_INT) {
			if ( float_p.array)
			    float_p.avalue[element] = (float)value_int;
			else
			    float_p.value = (float)value_int;
		    }
		    else if ( decl == K_DECL_FLOAT) {
			if ( float_p.array)
			    float_p.avalue[element] = value_float;
			else
			    float_p.value = value_float;
		    }
		    else {
			try {
			    if ( float_p.array)
				float_p.avalue[element] = (int)Float.parseFloat( value_string);
			    else
				float_p.value = (int)Float.parseFloat( value_string);
			}
			catch( NumberFormatException e) {
			    return CCM__VARTYPE;
			}
		    }
		}
		else {
		    // Search string
		    for ( int j = 0; j < string_list.size(); j++) {
			if ( string_list.get(j).name.equals(varname)) {
			    found = true;
			    string_p = string_list.get(j);
			    break;
			}
		    }
		    if ( found) {
			if ( string_p.array != array)
			    return CCM__VARNOTFOUND;
			if ( string_p.array && ( element < 0 || element >= string_p.elements))
			    return CCM__ARRAYBOUNDS;

			if ( decl == K_DECL_INT) {
			    if ( string_p.array)
				string_p.avalue[element] = Integer.toString(value_int);
			    else
				string_p.value = Integer.toString(value_int);
			}
			else if ( decl == K_DECL_FLOAT) {
			    if ( string_p.array)
				string_p.avalue[element] = Float.toString(value_float);
			    else
				string_p.value = Float.toString(value_float);
			}
			else {
			    if ( string_p.array)
				string_p.avalue[element] = value_string;
			    else
				string_p.value = value_string;
			}
		    }
		}
	    }
	    if ( found)
		break;
	}
	if ( !found)
	    return CCM__VARNOTFOUND;
	return 1;
    }
    
    int operateExec( CcmFuncCtx funcctx, CcmOperand op, CcmOperand next) {
	int		next_decl;
	int	next_int;
	float	next_float;
	String	next_string;
	String	tmp_str;
	int		sts = 1;
	CcmOperand 	op_arg = null;
	CcmArg[]	arg_list;
	CcmArg	arg_p, a_p, next_arg;
	int		arg_count;
	boolean		exit_function_found;
	int		op_idx;
	CcmFileCtx	filectx = (CcmFileCtx)funcctx.filectx;

	op_idx = funcctx.list.indexOf(op);

	exit_function_found = false;
	if ( next == null) {

	    if ( !op.result_done) {
		switch ( op.value.decl) {
		case K_DECL_FLOAT:
		    op.result.rfloat = op.value.rfloat;
		    break;
		case K_DECL_INT:
		    op.result.rint = op.value.rint;
		    break;
		default:
		    op.result.rstring = op.value.rstring;
		}
		op.result.decl = op.value.decl;
	    }
	}
	else {

	    if ( op.type == K_OPERAND_NO) {

		if ( !next.result_done) {

		    if ( next.type == K_OPERAND_NAME ) {
			CcmReturn ret = getVar( funcctx, next.name);
			if ( ret.evenSts()) return ret.sts;
			next.value.decl = ret.decl; 
			next.value.rfloat = ret.rfloat;
			next.value.rint = ret.rint;			
			next.value.rstring = ret.rstring;
		    }
		    switch ( next.value.decl) {
		    case K_DECL_FLOAT:
			next.result.rfloat = next.value.rfloat;
			break;
		    case K_DECL_INT:
			next.result.rint = next.value.rint;
			break;
		    default:
			next.result.rstring = next.value.rstring;
		    }
		    next.result.decl = next.value.decl;
		}
	    }
	    else if ( op.type == K_OPERAND_NAME && !op.result_done) {
		
		CcmReturn ret = getVar( funcctx, op.name);
		if ( ret.evenSts()) return ret.sts;
		op.value.decl = ret.decl;
		op.value.rfloat = ret.rfloat; 
		op.value.rint = ret.rint;
		op.value.rstring = ret.rstring;
	    }
	    else if ( op.type == K_OPERAND_FUNCTION) {
		// Create an argument list
		arg_list = null;
		arg_count = 0;

		for ( int i = op_idx + 1; i < funcctx.list.size(); i++) {
		    op_arg = funcctx.list.get(i);
		    if ( op_arg.type == K_OPERAND_NO &&
			 op_arg.parlevel == op.parlevel - 1)
			break;
		    arg_count++;
		}
		arg_list = new CcmArg[arg_count];
		arg_count = 0;
		for ( int i = op_idx + 1; i < funcctx.list.size(); i++) {
		    op_arg = funcctx.list.get(i);

		    if ( op_arg.type == K_OPERAND_NO &&
			 op_arg.parlevel == op.parlevel - 1)
			break;

		    if ( op_arg.type == K_OPERAND_NAME) {
			CcmReturn ret = getVar( funcctx, op_arg.name);
			if ( ret.evenSts()) return ret.sts;
			op_arg.value.decl = ret.decl; 
			op_arg.value.rfloat = ret.rfloat;
			op_arg.value.rint = ret.rint;
			op_arg.value.rstring = ret.rstring;
		    }
		    arg_p = new CcmArg();
		    switch ( op_arg.value.decl) {
		    case K_DECL_INT:
			arg_p.value_int = op_arg.value.rint;
			break;
		    case K_DECL_FLOAT:
			arg_p.value_float = op_arg.value.rfloat;
			break;
		    case K_DECL_STRING:
			arg_p.value_string = op_arg.value.rstring;
			break;
		    default: ;
		    }
		    arg_p.value_decl = op_arg.value.decl;
		    arg_p.value_type = op_arg.type;
		    arg_p.value_name = op_arg.name;
		    arg_list[arg_count] = arg_p;
		    arg_count++;
		    op_arg.type = K_OPERAND_NO;
		    if ( op_arg.parlevel == op.parlevel - 1)
			break;
		}

		CcmReturn ret = functionExec( filectx, op.name, null, arg_list, arg_count, false);
		// Set returned argument values and free argumentlist
		for ( int i = 0; i < arg_list.length; i++) {
		    arg_p = arg_list[i];
		    if ( arg_p.value_type == K_OPERAND_NAME &&
			 arg_p.value_returned) {
			sts = setVar( funcctx, arg_p.value_name, arg_p.value_decl, 
				      arg_p.value_float, arg_p.value_int, arg_p.value_string);
			if ( EVEN(sts)) return sts;
		    }
		}

		if ( EVEN(ret.sts)) return ret.sts;
		if ( ret.sts == CCM__EXITFUNC) exit_function_found = true;
		op.result = ret;
	    }

	    if ( next.type == K_OPERAND_NAME && !next.result_done &&
		 op.type != K_OPERAND_DECL) {

		CcmReturn ret = getVar( funcctx, next.name);
		if ( ret.evenSts()) return ret.sts;
		next.value.decl = ret.decl;
		next.value.rfloat = ret.rfloat; 
		next.value.rint = ret.rint;
		next.value.rstring = ret.rstring;
	    }
	    if ( next.result_done) {

		// Use result, not value for next-operand
		next_decl = next.result.decl;
		next_int = next.result.rint;
		next_float = next.result.rfloat;
		next_string = next.result.rstring;
	    }
	    else {

		// Use value for next-operand
		next_decl = next.value.decl;
		next_int = next.value.rint;
		next_float = next.value.rfloat;
		next_string = next.value.rstring;
	    }

	    if ( next.type == K_OPERAND_NO && !next.result_done) {
		next.result.rfloat = op.result.rfloat;
		next.result.rint = op.result.rint;
		next.result.rstring = op.result.rstring;
		next.result.decl = op.result.decl;
	    }
	    else if ( next_decl == K_DECL_UNKNOWN) {
		next_decl = op.value.decl;
	    }

	    switch ( op.o_operator) {
	    case K_ACTION_EQL:
		sts = setVar( funcctx, op.name, next_decl, next_float, next_int, 
			      next_string);
		if ( EVEN(sts)) return sts;
		break;
	    case K_ACTION_RETURN:
		if ( !next.result_done) {

		    next.result.decl = next_decl;
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = next_int;
			break;	  
		    case K_DECL_FLOAT:
			next.result.rfloat = next_float;
			break;	  
		    case K_DECL_STRING:
			next.result.rstring = next_string;
			break;
		    }
		}
		break;
	    case K_ACTION_MUL:
		switch ( op.result.decl) {
		case K_DECL_INT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = op.result.rint * next_int;
			next.result.decl = K_DECL_INT;
			break;
		    case K_DECL_FLOAT:
			next.result.rfloat = op.result.rint * next_float;
			next.result.decl = K_DECL_FLOAT;
			break;
		    }
		    break;
		case K_DECL_FLOAT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rfloat = op.result.rfloat * next_int;
			next.result.decl = K_DECL_FLOAT;
			break;
		    case K_DECL_FLOAT:
			next.result.rfloat = op.result.rfloat * next_float;
			next.result.decl = K_DECL_FLOAT;
			break;
		    }
		    break;
		}
		break;
	    case K_ACTION_DIV:
		switch ( op.result.decl) {
		case K_DECL_INT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = op.result.rint / next_int;
			next.result.decl = K_DECL_INT;
			break;
		    case K_DECL_FLOAT:
			next.result.rfloat = op.result.rint / next_float;
			next.result.decl = K_DECL_FLOAT;
			break;
		    }
		    break;
		case K_DECL_FLOAT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rfloat = op.result.rfloat / next_int;
			next.result.decl = K_DECL_FLOAT;
			break;
		    case K_DECL_FLOAT:
			next.result.rfloat = op.result.rfloat / next_float;
			next.result.decl = K_DECL_FLOAT;
			break;
		    }
		    break;
		}
		break;
	    case K_ACTION_ADD:
		switch ( op.result.decl) {
		case K_DECL_INT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = op.result.rint + next_int;
			next.result.decl = K_DECL_INT;
			break;
		    case K_DECL_FLOAT:
			next.result.rfloat = op.result.rint + next_float;
			next.result.decl = K_DECL_FLOAT;
			break;
		    case K_DECL_STRING:
			if ( next.result.rstring == null)
			    next.result.rstring = Integer.toString(op.result.rint);
			else
			    next.result.rstring += Integer.toString(op.result.rint);
			next.result.rstring += next_string;
			next.result.decl = K_DECL_STRING;
			break;
		    }
		    break;
		case K_DECL_FLOAT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rfloat = op.result.rfloat + next_int;
			next.result.decl = K_DECL_FLOAT;
			break;
		    case K_DECL_FLOAT:
			next.result.rfloat = op.result.rfloat + next_float;
			next.result.decl = K_DECL_FLOAT;
			break;
		    case K_DECL_STRING:
			next.result.rstring = Float.toString(op.result.rfloat);
			next.result.rstring += next_string;
			next.result.decl = K_DECL_STRING;
			break;
		    }
		    break;
		case K_DECL_STRING:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rstring = op.result.rstring;
			next.result.rstring += Integer.toString( next_int);
			next.result.decl = K_DECL_STRING;
			break;
		    case K_DECL_FLOAT:
			next.result.rstring = op.result.rstring;
			next.result.rstring += Float.toString(next_float);
			next.result.decl = K_DECL_STRING;
			break;
		    case K_DECL_STRING:
			next.result.rstring = op.result.rstring;
			next.result.rstring += next_string;
			next.result.decl = K_DECL_STRING;
			break;
		    }
		    break;
		}
		break;
	    case K_ACTION_EQLADD:
		switch ( op.result.decl) {
		case K_DECL_INT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = op.result.rint + next_int;
			next.result.decl = K_DECL_INT;
			break;
		    case K_DECL_FLOAT:
			next.result.rfloat = op.result.rint + next_float;
			next.result.decl = K_DECL_FLOAT;
			break;
		    case K_DECL_STRING:
			if ( next.result.rstring == null)
			    next.result.rstring = Integer.toString( op.result.rint);
			else
			    next.result.rstring += Integer.toString( op.result.rint);
			next.result.rstring += next_string;
			next.result.decl = K_DECL_STRING;
			break;
		    }
		    break;
		case K_DECL_FLOAT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rfloat = op.result.rfloat + next_int;
			next.result.decl = K_DECL_FLOAT;
			break;
		    case K_DECL_FLOAT:
			next.result.rfloat = op.result.rfloat + next_float;
			next.result.decl = K_DECL_FLOAT;
			break;
		    case K_DECL_STRING:
			if ( next.result.rstring == null)
			    next.result.rstring = Float.toString( op.result.rfloat);
			else
			    next.result.rstring += Float.toString( op.result.rfloat);			
			next.result.rstring += next_string;
			next.result.decl = K_DECL_STRING;
			break;
		    }
		    break;
		case K_DECL_STRING:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rstring = op.result.rstring;
			next.result.rstring += Integer.toString( next_int);
			next.result.decl = K_DECL_STRING;
			break;
		    case K_DECL_FLOAT:
			next.result.rstring = op.result.rstring;
			next.result.rstring += Float.toString(next_float);
			next.result.decl = K_DECL_STRING;
			break;
		    case K_DECL_STRING:
			next.result.rstring = op.result.rstring;
			next.result.rstring += next_string;
			next.result.decl = K_DECL_STRING;
			break;
		    }
		    break;
		}

		sts = setVar( funcctx, op.name, next.result.decl, 
			      next.result.rfloat, next.result.rint, next.result.rstring);
		if ( EVEN(sts)) return sts;
		break;
	    case K_ACTION_EQLSUB:
		switch ( op.result.decl) {
		case K_DECL_INT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = op.result.rint - next_int;
			next.result.decl = K_DECL_INT;
			break;
		    case K_DECL_FLOAT:
			next.result.rfloat = op.result.rint - next_float;
			next.result.decl = K_DECL_FLOAT;
			break;
		    }
		    break;
		case K_DECL_FLOAT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rfloat = op.result.rfloat - next_int;
			next.result.decl = K_DECL_FLOAT;
			break;
		    case K_DECL_FLOAT:
			next.result.rfloat = op.result.rfloat - next_float;
			next.result.decl = K_DECL_FLOAT;
			break;
		    }
		    break;
		}

		sts = setVar( funcctx, op.name, next.result.decl,
			      next.result.rfloat, next.result.rint, next.result.rstring);
		if ( EVEN(sts)) return sts;
		break;
	    case K_ACTION_SUB:
		switch ( op.result.decl) {
		case K_DECL_INT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = op.result.rint - next_int;
			next.result.decl = K_DECL_INT;
			break;
		    case K_DECL_FLOAT:
			next.result.rfloat = op.result.rint - next_float;
			next.result.decl = K_DECL_FLOAT;
			break;
		    }
		    break;
		case K_DECL_FLOAT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rfloat = op.result.rfloat - next_int;
			next.result.decl = K_DECL_FLOAT;
			break;
		    case K_DECL_FLOAT:
			next.result.rfloat = op.result.rfloat - next_float;
			next.result.decl = K_DECL_FLOAT;
			break;
		    }
		    break;
		}
		break;
	    case K_ACTION_AND:
		switch ( op.result.decl) {
		case K_DECL_INT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = (op.result.rint != 0 && next_int != 0) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    case K_DECL_FLOAT:
			next.result.rfloat = (op.result.rint != 9 && Math.abs(next_float) > Float.MIN_VALUE) ? 1 : 0;
			next.result.decl = K_DECL_FLOAT;
			break;
		    }
		    break;
		case K_DECL_FLOAT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rfloat = (Math.abs(op.result.rfloat) > Float.MIN_VALUE && next_int != 0) ? 1 : 0;
			next.result.decl = K_DECL_FLOAT;
			break;
		    case K_DECL_FLOAT:
			next.result.rfloat = (Math.abs(op.result.rfloat) > Float.MIN_VALUE && Math.abs(next_float) < Float.MIN_VALUE) ? 1 : 0;
			next.result.decl = K_DECL_FLOAT;
			break;
		    }
		    break;
		}
		break;
	    case K_ACTION_OR:
		switch ( op.result.decl) {
		case K_DECL_INT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = (op.result.rint != 0 || next_int != 0) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    case K_DECL_FLOAT:
			next.result.rfloat = (op.result.rint != 0 || Math.abs(next_float) > Float.MIN_VALUE) ? 1 : 0;
			next.result.decl = K_DECL_FLOAT;
			break;
		    }
		    break;
		case K_DECL_FLOAT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rfloat = (Math.abs(op.result.rfloat) > Float.MIN_VALUE || next_int != 0) ? 1 : 0;
			next.result.decl = K_DECL_FLOAT;
			break;
		    case K_DECL_FLOAT:
			next.result.rfloat = (Math.abs(op.result.rfloat) > Float.MIN_VALUE || 
					      Math.abs(next_float) > Float.MIN_VALUE) ? 1 : 0;
			next.result.decl = K_DECL_FLOAT;
			break;
		    }
		    break;
		}
		break;
	    case K_ACTION_EQ:
		switch ( op.result.decl) {
		case K_DECL_INT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = ( op.result.rint == next_int) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    case K_DECL_FLOAT:
			next.result.rint = ( Math.abs( op.result.rint - next_float) < Float.MIN_VALUE) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    default:
			next.result.rint = 0;
			next.result.decl = K_DECL_INT;
		    }
		    break;
		case K_DECL_FLOAT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = ( Math.abs( op.result.rfloat - next_int) < Float.MIN_VALUE) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    case K_DECL_FLOAT:
			next.result.rint = ( Math.abs( op.result.rfloat - next_float) < Float.MIN_VALUE) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    default:
			next.result.rint = 0;
			next.result.decl = K_DECL_INT;
		    }
		    break;
		case K_DECL_STRING:
		    switch ( next_decl) {
		    case K_DECL_STRING:
			next.result.rint = ( op.result.rstring.equals( next_string)) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    default:
			next.result.rint = 0;
			next.result.decl = K_DECL_INT;
		    }
		    break;
		}
		break;
	    case K_ACTION_NE:
		switch ( op.result.decl) {
		case K_DECL_INT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = ( op.result.rint != next_int) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    case K_DECL_FLOAT:
			next.result.rint = !( Math.abs( op.result.rint - next_float) < Float.MIN_VALUE) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    default:
			next.result.rint = 1;
			next.result.decl = K_DECL_INT;
		    }
		    break;
		case K_DECL_FLOAT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = !( Math.abs( op.result.rfloat - next_int) < Float.MIN_VALUE) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    case K_DECL_FLOAT:
			next.result.rint = !( Math.abs( op.result.rfloat - next_float) < Float.MIN_VALUE) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    default:
			next.result.rint = 1;
			next.result.decl = K_DECL_INT;
		    }
		    break;
		case K_DECL_STRING:
		    switch ( next_decl) {
		    case K_DECL_STRING:
			next.result.rint = !( op.result.rstring.equals( next_string)) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    default:
			next.result.rint = 1;
			next.result.decl = K_DECL_INT;
		    }
		    break;
		}
		break;
	    case K_ACTION_LT:
		switch ( op.result.decl) {
		case K_DECL_INT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = ( op.result.rint < next_int) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    case K_DECL_FLOAT:
			next.result.rint = ( op.result.rint < next_float) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    }
		    break;
		case K_DECL_FLOAT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = ( op.result.rfloat < next_int) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    case K_DECL_FLOAT:
			next.result.rint = ( op.result.rfloat < next_float) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    }
		    break;
		}
		break;
	    case K_ACTION_GT:
		switch ( op.result.decl) {
		case K_DECL_INT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = ( op.result.rint > next_int) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    case K_DECL_FLOAT:
			next.result.rint = ( op.result.rint > next_float) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    }
		    break;
		case K_DECL_FLOAT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = ( op.result.rfloat > next_int) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    case K_DECL_FLOAT:
			next.result.rint = ( op.result.rfloat > next_float) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    }
		    break;
		}
		break;
	    case K_ACTION_LE:
		switch ( op.result.decl) {
		case K_DECL_INT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = ( op.result.rint <= next_int) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    case K_DECL_FLOAT:
			next.result.rint = ( op.result.rint <= next_float) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    }
		    break;
		case K_DECL_FLOAT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = ( op.result.rfloat <= next_int) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    case K_DECL_FLOAT:
			next.result.rint = ( op.result.rfloat <= next_float) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    }
		    break;
		}
		break;
	    case K_ACTION_GE:
		switch ( op.result.decl) {
		case K_DECL_INT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = ( op.result.rint >= next_int) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    case K_DECL_FLOAT:
			next.result.rint = ( op.result.rint >= next_float) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    }
		    break;
		case K_DECL_FLOAT:
		    switch ( next_decl) {
		    case K_DECL_INT:
			next.result.rint = ( op.result.rfloat >= next_int) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    case K_DECL_FLOAT:
			next.result.rint = ( op.result.rfloat >= next_float) ? 1 : 0;
			next.result.decl = K_DECL_INT;
			break;
		    }
		    break;
		}
		break;
	    case K_ACTION_INV:
		switch ( next_decl) {
		case K_DECL_INT:
		    next.result.rint = (next_int == 0) ? 1 : 0;
		    next.result.decl = K_DECL_INT;
		    break;
		default:
		    next.result.rfloat = next_float;
		    next.result.decl = K_DECL_FLOAT;
		    break;
		}
		break;
	    case K_ACTION_BITAND:
		if ( op.result.decl == K_DECL_INT && next_decl == K_DECL_INT) {
		    next.result.rint = op.result.rint & next_int;
		    next.result.decl = K_DECL_INT;
		}
		break;
	    case K_ACTION_BITOR:
		if ( op.result.decl == K_DECL_INT && next_decl == K_DECL_INT) {
		    next.result.rint = op.result.rint | next_int;
		    next.result.decl = K_DECL_INT;
		}
		break;
	    case K_ACTION_LSHIFT:
		if ( op.result.decl == K_DECL_INT && next_decl == K_DECL_INT) {
		    next.result.rint = op.result.rint << next_int;
		    next.result.decl = K_DECL_INT;
		}
		break;
	    case K_ACTION_RSHIFT:
		if ( op.result.decl == K_DECL_INT && next_decl == K_DECL_INT) {
		    next.result.rint = op.result.rint >> next_int;
		    next.result.decl = K_DECL_INT;
		}
		break;
	    case K_ACTION_CREALOCINT:
		sts = createVar( next.name, K_DECL_INT, 0, 0, null,
		funcctx.locint_list, funcctx.locfloat_list, funcctx.locstring_list);
		if ( EVEN(sts)) return sts;
		break;
	    case K_ACTION_CREALOCFLOAT:
		sts = createVar( next.name, K_DECL_FLOAT, 0, 0, null,
		funcctx.locint_list, funcctx.locfloat_list, funcctx.locstring_list);
		if ( EVEN(sts)) return sts;
		break;
	    case K_ACTION_CREALOCSTRING:
		sts = createVar( next.name, K_DECL_STRING, 0, 0, "",
				     funcctx.locint_list, funcctx.locfloat_list, funcctx.locstring_list);
		if ( EVEN(sts)) return sts;
		break;
	    case K_ACTION_CREAGBLINT:
		sts = createVar( next.name, K_DECL_INT, 0, 0, null,
				 filectx.gblint_list, filectx.gblfloat_list, filectx.gblstring_list);
		if ( EVEN(sts)) return sts;
		break;
	    case K_ACTION_CREAGBLFLOAT:
		sts = createVar( next.name, K_DECL_FLOAT, 0, 0, null,
		filectx.gblint_list, filectx.gblfloat_list, filectx.gblstring_list);
		if ( EVEN(sts)) return sts;
		break;
	    case K_ACTION_CREAGBLSTRING:
		sts = createVar( next.name, K_DECL_STRING, 0, 0, "",
				 filectx.gblint_list, filectx.gblfloat_list, filectx.gblstring_list);
		if ( EVEN(sts)) return sts;
		break;
	    case K_ACTION_CREAEXTINT:
		sts = createVar( next.name, K_DECL_INT, 0, 0, null,
				 extint_list, extfloat_list, extstring_list);
		if ( sts == CCM__VARALREXIST)
		    sts = CCM__SUCCESS;
		if ( EVEN(sts)) return sts;
		break;
	    case K_ACTION_CREAEXTFLOAT:
		sts = createVar( next.name, K_DECL_FLOAT, 0, 0, null,
				 extint_list, extfloat_list, extstring_list);
		if ( sts == CCM__VARALREXIST)
		    sts = CCM__SUCCESS;
		if ( EVEN(sts)) return sts;
		break;
	    case K_ACTION_CREAEXTSTRING:
		sts = createVar( next.name, K_DECL_STRING, 0, 0, "",
				 extint_list, extfloat_list, extstring_list);
		if ( sts == CCM__VARALREXIST)
		    sts = CCM__SUCCESS;
		if ( EVEN(sts)) return sts;
		break;
	    case K_ACTION_DELETE:
		sts = deleteVar( next.name,
				 extint_list, extfloat_list, extstring_list);
		if ( EVEN(sts)) return sts;
		break;
	    }
	    next.result_done = true;
	    if ( ccm_testmode)
		System.out.println(
"     Processing \"" + op.name + "\"	\"" + next.name + "\"	decl: " + next.result.decl + ", float: " + next.result.rfloat + ", int: " + next.result.rint + " str: \"" + next.result.rstring + "\"");

	}
	op.done = true;

	if ( op.local_type == K_LOCTYPE_AFTER) {

	    switch ( op.local_operator) {
	    case K_ACTION_INCR:
		if ( op.value.decl == K_DECL_INT || op.value.decl == K_DECL_FLOAT) {
		    op.value.rint++;
		    op.value.rfloat++;
		    sts = setVar( funcctx, op.name, op.value.decl, op.value.rfloat, 
				  op.value.rint, "");
		    if ( EVEN(sts)) return sts;
		}
		break;
	    case K_ACTION_DECR:
		if ( op.value.decl == K_DECL_INT || op.value.decl == K_DECL_FLOAT) {
		    op.value.rint--;
		    op.value.rfloat--;
		    sts = setVar( funcctx, op.name, op.value.decl, op.value.rfloat, 
				  op.value.rint, "");
		    if ( EVEN(sts)) return sts;
		}
		break;
	    }
	}
	if ( exit_function_found)
	    return CCM__EXITFUNC;
	return 1;
    }

    String extractParenthesExpr( String line) {
	int idx1 = line.indexOf('(');
	if ( idx1 == -1)
	    return null;

	int idx2 = line.lastIndexOf(')');
	if ( idx2 == -1)
	    return null;

	return line.substring( idx1+1, idx2).trim();
    }

    int registerFunction( CcmSysFunc sysfunc) {
	for ( int i = 0; i < sysfunc_list.size(); i++) {
	    if ( sysfunc_list.get(i).name.equals( sysfunc.name))
		return CCM__ALREADYREG;
	}
	sysfunc_list.add(sysfunc);
	return 1;
    }

    void printError( CcmFileCtx filectx, int sts) {
	String	text;

	switch ( sts) {
	case CCM__EXPRESSION : 	text = "Syntax error in expression"; return;
	case CCM__VARTYPE :    	text = "Variable type mismatch"; break;
	case CCM__VARALREXIST :	text = "Variable already declared"; break;
	case CCM__VARNOTFOUND :	text = "Variable not found"; break;
	case CCM__OPENFILE :	text = "Unable to open file"; break;
	case CCM__SYNTAX :     	text = "Syntax error"; break;
	case CCM__FUNCNOTFOUND : text = "Function not declared"; break;
	case CCM__UNKNVARTYPE :	text = "Unknown varable type"; break;
	case CCM__FUNCMISM :	text = "Function-endfunction mismatch"; break;
	case CCM__MAINMISM :	text = "Main-endmain mismatch"; break;
	case CCM__IFMISM :	text = "If-else-endif mismatch"; break;
	case CCM__WHILEMISM :	text = "While-endwhile mismatch"; break;
	case CCM__FORMISM :    	text = "For-endfor mismatch"; break;
	case CCM__ARGMISM :    	text = "Argument mismatch"; break;
	case CCM__CONTMISM :	text = "Continue-for/while mismatch"; break;
	case CCM__BREAKMISM :	text = "Break-if/for/while mismatch"; break;
	case CCM__NOEXTVAR :	text = "No external variables defined"; break;
	case CCM__GOTOMISM :	text = "Label in goto-expression not found"; break;
	case CCM__SYSFUNCEXCEED : text = "Max number of functions exceeded"; break;
	case CCM__LONGLINE :	text = "Maximum line size exceeded"; break;
	case CCM__STRINGEXCEED : text = "Maximum string size exceeded"; break;
	case CCM__ARGEXCEED :	text = "Maximum number of arguments exceeded"; break;
	case CCM__ARRAYBOUNDS :	text = "Array index out of bounds"; break;
	case CCM__NOACCESS :	text = "No access for operation"; break;
	default :		text = "Unknown error code";
	}
	if ( filectx.error_row != 0)
	    text += ", at line " + filectx.error_row + " \"" + filectx.error_line + "\"";
	System.out.println( text);

	if ( filectx.appl != null)
	  filectx.appl.errorMessage( text, 0);
    }

    String replaceSymbol( CcmFuncCtx funcctx, String command) {
	boolean	symbolmode;
	String	value;
	String	symbol;
	int	sts;
	boolean	ignore_symbolmode;
	symbolmode = false;
	ignore_symbolmode = false;
	
	String t = "";
	int u = 0;
	char s;
	char s1 = 0;
	for ( int i = 0; i < command.length(); i++) {
	    s = command.charAt(i);
	    if ( i != command.length() - 1)
		s1 = command.charAt(i+1);

	    if ( s == '\\' &&
		 s1 == '\'') {	
		if ( ignore_symbolmode)
		    ignore_symbolmode = false;
		else
		    ignore_symbolmode = true;
		t += "'";
	    }
	    else if (s == '\'') {
		if ( symbolmode) {
		    // End of potential symbol
		    symbol =  command.substring( u, i);
		    CcmReturn ret = getVar( funcctx, symbol);
		    if ( ret.evenSts()) {
			// It was no symbol
			t += "'" + symbol + "'";
		    }
		    else {
			if ( ret.decl == K_DECL_FLOAT)
			    value = Float.toString( ret.rfloat);
			else if ( ret.decl == K_DECL_INT)
			    value = Integer.toString( ret.rint);
			else
			    value = ret.rstring;
			// Symbol found
			t += value;
		    }
		    symbolmode = false;
		}
		else {
		    if ( ignore_symbolmode) {
			t += "'";
		    }
		    else {
			symbolmode = true;
			u = i + 1; 
		    }
		}
		ignore_symbolmode = false;
	    }
	    else {
		if ( !symbolmode) {
		    t += s;
		}
		ignore_symbolmode = false;
	    }
	}
	if ( symbolmode) {
	    t += command.substring( u, command.length());
	}
	
	return t;
    }


}

