/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */


package jpwr.jopg;
import java.awt.*;
import java.awt.geom.*;
import java.awt.image.*;
import java.awt.font.*;
import javax.swing.*;
import javax.swing.border.*;
import java.awt.event.*;

public class GlowDraw implements GlowDrawIfc {
    public static final int DRAW_FONT_SIZE = 9;
    public static final int CUSTOMCOLORS_STACK_SIZE = 10;
    Graphics2D g2;
    boolean nodraw = true;
    Font fonts[] = new Font[DRAW_FONT_SIZE * 2];
    int clip_x1[] = new int[10];
    int clip_y1[] = new int[10];
    int clip_x2[] = new int[10];
    int clip_y2[] = new int[10];
    int clipCount = 0;
    GlowCustomColors[] customcolors = new GlowCustomColors[CUSTOMCOLORS_STACK_SIZE];
    int customcolors_cnt = 0;

        
    public void setNodraw(boolean nodraw) {
	this.nodraw = nodraw;
    }

    public void setGraphics( Graphics2D g2) {
	this.g2 = g2;
	nodraw = false;
    }

    public void rect(int border, int fill, double x, double y, double width, double height) {
	if ( nodraw)
	    return;

	Rectangle2D r = new Rectangle2D.Double(x, y, width, height);
	g2.setPaint(Color.black);
	g2.setStroke(new BasicStroke(1));
	g2.draw(r);
    }

    public void rect(int x, int y, int width, int height, int gc_type, int idx, int highlight) {
	if ( nodraw)
	    return;

	if ( gc_type == Glow.eDrawType_LineGray && highlight != 0)
	    gc_type = Glow.eDrawType_Line;

	Color color = getColor(gc_type);

	Rectangle2D r = new Rectangle2D.Float((float)x, (float)y, (float)width, (float)height);
	g2.setPaint(color);
	g2.setStroke(new BasicStroke(1));
	g2.draw(r);
    }

    public void fill_rect(int x, int y, int width, int height, int gc_type) {
	if ( nodraw)
	    return;

	Color color = getColor(gc_type);

	Rectangle2D r = new Rectangle2D.Float((float)x, (float)y, (float)width, (float)height);
	g2.setPaint(color);
	g2.fill(r);
    }
    public void gradient_fill_rect(int x, int y, int width, int height, int gc_type, int f1, int f2, int gradient) {
	if ( nodraw)
	    return;

	Rectangle2D r = new Rectangle2D.Float((float)x, (float)y, (float)width, (float)height);
	setGradient( gradient, f1, f2, (float)x, (float)y, (float)width, (float)height);
	g2.fill(r);
    }

    public void gradient_fill_rectrounded(int x, int y, int width, int height, int amount, int gc_type, int f1, int f2, int gradient) {
	if ( nodraw)
	    return;

	RoundRectangle2D r = new RoundRectangle2D.Float((float)x, (float)y, (float)width, (float)height,
						   (float)amount, (float)amount);
	setGradient( gradient, f1, f2, (float)x, (float)y, (float)width, (float)height);
	g2.fill(r);
    }

    public void arc(int x, int y, int width, int height, int angle1, int angle2, int gc_type, int idx, int highlight) {
	if ( nodraw)
	    return;

	if ( gc_type == Glow.eDrawType_LineGray && highlight != 0)
	    gc_type = Glow.eDrawType_Line;

	Color color = getColor(gc_type);

	Arc2D a = new Arc2D.Float((float)x, (float)y, (float)width, (float)height, angle1, angle2, Arc2D.OPEN);
	g2.setPaint(color);
	g2.setStroke(new BasicStroke(idx+1));
	g2.draw(a);
    }

    public void fill_arc(int x, int y, int width, int height, int angle1, int angle2, int gc_type) {
	if ( nodraw)
	    return;

	Color color = getColor(gc_type);

	Arc2D a = new Arc2D.Float((float)x, (float)y, (float)width, (float)height, angle1, angle2, Arc2D.PIE);
	g2.setPaint(color);
	g2.fill(a);
    }
    public void gradient_fill_arc(int x, int y, int width, int height, int angle1, int angle2, int gc_type, int f1, int f2, int gradient) {
	if ( nodraw)
	    return;

	Arc2D a = new Arc2D.Float((float)x, (float)y, (float)width, (float)height, angle1, angle2, Arc2D.PIE);
	setGradient( gradient, f1, f2, (float)x, (float)y, (float)width, (float)height);
	g2.fill(a);
    }

    public void line(int x1, int y1, int x2, int y2, int gc_type, int idx, int highlight) {
	if ( nodraw)
	    return;

	Color color = getColor(gc_type);

	Line2D l = new Line2D.Float((float)x1, (float)y1, (float)x2, (float)y2);
	g2.setPaint(color);
	g2.setStroke(new BasicStroke(idx+1));
	g2.draw(l);
    }

    public void line_dashed(int x1, int y1, int x2, int y2, int gc_type, int idx, int highlight, int line_type) {
	if ( nodraw)
	    return;

	Color color = getColor(gc_type);

	Line2D l = new Line2D.Float((float)x1, (float)y1, (float)x2, (float)y2);

	float[] dash = null;
	switch ( line_type) {
	case Glow.eLineType_Solid: 
	    break;
	case Glow.eLineType_Dashed1: 
	    dash = new float[] {(float)idx, (float)idx};
	    break;
	case Glow.eLineType_Dashed2: 
	    dash = new float[] {(float)idx  * 2, (float)idx * 2};
	    break;
	case Glow.eLineType_Dashed3: 
	    dash = new float[] {(float)idx  * 4, (float)idx * 4};
	    break;
	case Glow.eLineType_Dotted: 
	    dash = new float[] {(float)idx, (float)idx * 6};
	    break;
	case Glow.eLineType_DotDashed1: 
	    dash = new float[] {(float)idx * 1, (float)idx * 2, (float)idx  * 4, (float)idx * 2};
	    break;
	case Glow.eLineType_DotDashed2: 
	    dash = new float[] {(float)idx, (float)idx * 4, (float)idx * 8, (float)idx * 4};
	    break;
	}
	if ( dash == null || idx == 0)
	    g2.setStroke(new BasicStroke(idx+1));
	else
	    g2.setStroke( new BasicStroke((float)idx, BasicStroke.CAP_BUTT,
					 BasicStroke.JOIN_BEVEL, 0, dash, 0));
	g2.setPaint(color);
	g2.draw(l);
    }

    public void polyline(GlowPointX[] points, int point_cnt, int gc_type, int idx, int highlight) {
	if ( nodraw)
	    return;

	Color color = getColor(gc_type);

	GeneralPath path = new GeneralPath();
	path.moveTo((float)points[0].x, (float)points[0].y);
	for ( int i = 1; i < point_cnt; i++) 
	    path.lineTo((float)points[i].x, (float)points[i].y);
	
	g2.setStroke(new BasicStroke(idx+1));
	g2.setPaint(color);
	g2.draw(path);
    }

    public void fill_polyline(GlowPointX[] points, int point_cnt, int gc_type, int highlight) {
	if ( nodraw)
	    return;

	Color color = getColor(gc_type);

	GeneralPath path = new GeneralPath();
	path.moveTo((float)points[0].x, (float)points[0].y);
	for ( int i = 1; i < point_cnt; i++) 
	    path.lineTo((float)points[i].x, (float)points[i].y);
	
	g2.setPaint(color);
	g2.fill(path);
    }

    public void gradient_fill_polyline(GlowPointX[] points, int point_cnt, int gc_type, int f1, int f2, int gradient) {
	if ( nodraw)
	    return;

	int x_low = Integer.MAX_VALUE;
	int x_high = -Integer.MAX_VALUE;
	int y_low = Integer.MAX_VALUE;
	int y_high = -Integer.MAX_VALUE;
	GeneralPath path = new GeneralPath();
	path.moveTo((float)points[0].x, (float)points[0].y);
	for ( int i = 1; i < point_cnt; i++) {
	    path.lineTo((float)points[i].x, (float)points[i].y);
	    if ( points[i].x > x_high)
		x_high = points[i].x;
	    if ( points[i].x < x_low)
		x_low = points[i].x;
	    if ( points[i].y > y_high)
		y_high = points[i].y;
	    if ( points[i].y < y_low)
		y_low = points[i].y;
	}
	
	setGradient( gradient, f1, f2, (float)x_low, (float)y_low, (float)(x_high - x_low), (float)(y_high - y_low));
	g2.fill(path);
    }

    public void text( int x, int y, String text, int gc_type, int color, int idx, int highlight, int line, 
		      int font_idx, double size, int rot) {
	if ( nodraw)
	    return;

	Color c = getColor(color);

	g2.setFont(getFont(font_idx, idx, gc_type));
	g2.setPaint(c);
	g2.drawString(text, x, y);
    }

    public Color getColor(int gc_type) {
	GlowColorRgb rgb = GlowColor.rgb_color(gc_type, get_customcolors());
	return new Color((float)rgb.r, (float)rgb.g, (float)rgb.b);
    }
    public  int gradient_rotate(double rotate, int gradient) {
	return gradient;
    }

    public void setGradient( int gradient, int f1, int f2,
			     float x, float y, float w, float h) {
	float gx0 = 0;
	float gy0 = 0;
	float gx1 = 0; 
	float gy1 = 0;
	float gr = 0;
	
	switch ( gradient) {
	case Glow.eGradient_HorizontalUp:
	    gx0 = x;
	    gy0 = y;
	    gx1 = x;
	    gy1 = y + h;
	    break;
	case Glow.eGradient_HorizontalDown:
	    gx0 = x;
	    gy0 = y + h;
	    gx1 = x;
	    gy1 = y;
	    break;
	case Glow.eGradient_HorizontalTube1:
	    gx0 = x;
	    gy0 = y + 0.5F * h;
	    gx1 = x;
	    gy1 = y;
	    break;
	case Glow.eGradient_HorizontalTube2:
	    gx0 = x;
	    gy0 = y + 0.3F * h;
	    gx1 = x;
	    gy1 = y + h;
	    break;
	case Glow.eGradient_VerticalLeft:
	    gx0 = x;
	    gy0 = y;
	    gx1 = x + w;
	    gy1 = y;
	    break;
	case Glow.eGradient_VerticalRight:
	    gx0 = x + w;
	    gy0 = y;
	    gx1 = x;
	    gy1 = y;
	    break;
	case Glow.eGradient_VerticalTube1:
	    gx0 = x + 0.5F * w;
	    gy0 = y;
	    gx1 = x;
	    gy1 = y;
	    break;
	case Glow.eGradient_VerticalTube2:
	    gx0 = x + 0.3F * w;
	    gy0 = y;
	    gx1 = x + w;
	    gy1 = y;
	    break;
	case Glow.eGradient_DiagonalUpperLeft:
	    gx0 = x;
	    gy0 = y;
	    gx1 = x + w;
	    gy1 = y + h;
	    break;
	case Glow.eGradient_DiagonalLowerLeft:
	    gx0 = x;
	    gy0 = y + h;
	    gx1 = x + w;
	    gy1 = y;
	    break;
	case Glow.eGradient_DiagonalUpperRight:
	    gx0 = x + w;
	    gy0 = y;
	    gx1 = x;
	    gy1 = y + h;
	    break;
	case Glow.eGradient_DiagonalLowerRight:
	    gx0 = x + w;
	    gy0 = y + h;
	    gx1 = x;
	    gy1 = y;
	    break;
	case Glow.eGradient_DiagonalUpTube:
	    gx0 = x + 0.5F * w;
	    gy0 = y + 0.5F * h;
	    gx1 = x + w;
	    gy1 = y + h;
	    break;
	case Glow.eGradient_DiagonalDownTube:
	    gx0 = x + 0.5F * w;
	    gy0 = y + 0.5F * h;
	    gx1 = x;
	    gy1 = y + h;
	    break;
	case Glow.eGradient_Globe:
	    gx0 = x + 0.3F * w;
	    gy0 = y + 0.3F * h;
	    gx1 = x + w;
	    gy1 = y + h;
	    gr = (float) Math.sqrt( w*w/4+h*h/4);
	    break;
	case Glow.eGradient_RadialCenter:
	    gx0 = x + 0.5F * w;
	    gy0 = y + 0.5F * h;
	    gx1 = x + w;
	    gy1 = y + h;
	    gr = (float) Math.sqrt( w*w/4F+h*h/4F);
	    break;
	case Glow.eGradient_RadialUpperLeft:
	    gx0 = x;
	    gy0 = y;
	    gx1 = x + w;
	    gy1 = y + h;
	    gr = (float) Math.sqrt( w*w+h*h);
	    break;
	case Glow.eGradient_RadialLowerLeft:
	    gx0 = x;
	    gy0 = y + h;
	    gx1 = x + w;
	    gy1 = y;
	    gr = (float) Math.sqrt( w*w+h*h);
	    break;
	case Glow.eGradient_RadialUpperRight: 
	    gx0 = x + w;
	    gy0 = y;
	    gx1 = x;
	    gy1 = y + h;
	    gr = (float) Math.sqrt( w*w+h*h);
	    break;
	case Glow.eGradient_RadialLowerRight:
	    gx0 = x + w;
	    gy0 = y + h;
	    gx1 = x;
	    gy1 = y;
	    gr = (float) Math.sqrt( w*w+h*h);
	    break;
	default: ;
	}

	switch ( gradient) {
	case Glow.eGradient_HorizontalUp:
	case Glow.eGradient_HorizontalDown:
	case Glow.eGradient_HorizontalTube1:
	case Glow.eGradient_HorizontalTube2:
	case Glow.eGradient_VerticalLeft:
	case Glow.eGradient_VerticalRight:
	case Glow.eGradient_VerticalTube1:
	case Glow.eGradient_VerticalTube2:
	case Glow.eGradient_DiagonalUpperLeft:
	case Glow.eGradient_DiagonalLowerLeft:
	case Glow.eGradient_DiagonalUpperRight:
	case Glow.eGradient_DiagonalLowerRight:
	case Glow.eGradient_DiagonalUpTube:
	case Glow.eGradient_DiagonalDownTube: {
		GradientPaint gp = new GradientPaint( gx0, gy0,
						      getColor(f2),
						      gx1, gy1,
						      getColor(f1),true);
		g2.setPaint(gp);
	    break;
	}
	case Glow.eGradient_Globe:
	case Glow.eGradient_RadialCenter:
	case Glow.eGradient_RadialUpperLeft:
	case Glow.eGradient_RadialLowerLeft:
	case Glow.eGradient_RadialUpperRight: 
	case Glow.eGradient_RadialLowerRight:{
	    RadialGradientPaint gp = new RadialGradientPaint( new Point2D.Float(gx0,gy0), gr, new float[] {0F,1F}, new Color[] { getColor(f2), getColor(f1)});
	    g2.setPaint(gp);
	    break;
	}
	default: ;
	}
    }	    

    public GlowDimension getTextExtent( String text, int idx, int type, int gc_type) {
	FontMetrics metrics = g2.getFontMetrics( getFont( type, idx, gc_type));
	GlowDimension dim = new GlowDimension();
	dim.height = metrics.getHeight();
	dim.width = metrics.stringWidth(text);
	return dim;
    }

    public Font getFont( int type, int idx, int gc_type) {
	int fidx;

	fidx = idx;
	if ( gc_type == Glow.eDrawType_TextHelveticaBold)
	    fidx += DRAW_FONT_SIZE;
	if ( fonts[fidx] == null) {
	    int text_size;
	    switch ( idx) {
	    case 0: text_size = 8; break;
	    case 1: text_size = 10; break;
	    case 2: text_size = 12; break;
	    case 3: text_size = 14; break;
	    case 4: text_size = 16; break;
	    case 5: text_size = 18; break;
	    case 6: text_size = 20; break;
	    case 7: text_size = 22; break;
	    default: text_size = 24;
	    }
	    text_size *= 0.8;
	    if ( fidx < DRAW_FONT_SIZE)
		fonts[fidx] = new Font("Helvetica", Font.PLAIN, text_size);
	    else
		fonts[fidx] = new Font("Helvetica", Font.BOLD, text_size);
	}
	return fonts[fidx];
    }

    public int set_clip_rectangle( int x1, int y1, int x2, int y2) {
	if ( clipCount > 0) {
	    if ( clipCount >= 10)
		return 0;
	    if ( x1 < clip_x1[clipCount-1])
		x1 = clip_x1[clipCount-1];
	    if ( y1 < clip_y1[clipCount-1])
		y1 = clip_y1[clipCount-1];
	    if ( x2 > clip_x2[clipCount-1])
		x2 = clip_x2[clipCount-1];
	    if ( y2 > clip_y2[clipCount-1])
		y2 = clip_y2[clipCount-1];
	}
	clip_x1[clipCount] = x1;
	clip_y1[clipCount] = y1;
	clip_x2[clipCount] = x2;
	clip_y2[clipCount] = y2;
	clipCount++;

	g2.setClip(new Rectangle2D.Float((float)x1, (float)y1, (float)(x2-x1+1), (float)(y2-y1+1)));
	return 1;
    }

    public void reset_clip_rectangle() {
	if ( clipCount == 0) {
	    System.out.println("Clip mismatch");
	    return;
	}
	clipCount--;
	if ( clipCount > 0) {
	    g2.setClip(new Rectangle2D.Float((float)clip_x1[clipCount-1], (float)clip_y1[clipCount-1], 
					     (float)(clip_x2[clipCount-1]-clip_x1[clipCount-1]), 
					     (float)(clip_y2[clipCount-1]-clip_y1[clipCount-1])));	    
	}	    
	else
	    g2.setClip(null);
    }

    public void push_customcolors( GlowCustomColors cc) {
	if ( customcolors_cnt > CUSTOMCOLORS_STACK_SIZE) {
	    System.out.println( "** Max number custom colors exceede\n");
	    return;
	}

	for ( int i = customcolors_cnt; i > 0; i--)
	    customcolors[i] = customcolors[i-1];
	customcolors[0] = cc;
	customcolors_cnt++;
    }

    public void pop_customcolors() {
	if ( customcolors_cnt <= 0) {
	    System.out.println( "** Customcolor stack disorder\n");
	}
	for ( int i = 0; i < customcolors_cnt - 1; i++)
	    customcolors[i] = customcolors[i+1];
	customcolors_cnt--;
    }

    public GlowCustomColors get_customcolors() {
	if ( customcolors_cnt == 0)
	    return null;
	return customcolors[0];
    }
}
