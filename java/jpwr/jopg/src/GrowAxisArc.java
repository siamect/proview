/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jopg;
import jpwr.rt.*;
import java.io.*;
import java.util.*;

public class GrowAxisArc extends GrowArc {

    int text_size;
    int text_drawtype;
    int text_color_drawtype;
    double max_value;
    double min_value;
    int lines;
    double linelength;
    int longquotient;
    int valuequotient;
    double increment;
    String format;    
    Object userdata;
    GlowCFormat	cFormat;
    StringBuffer sb = new StringBuffer();

    public GrowAxisArc(GrowCmn cmn) {
	super(cmn);
	configure();
    }

    public int type() {
	return Glow.eObjectType_GrowAxisArc;
    }

    void configure() {
	if ( lines <= 1)
	    lines = 2;
	if ( longquotient <= 0)
	    longquotient = 1;
	if ( valuequotient <= 0)
	    valuequotient = 1;
	increment = (max_value - min_value) / (lines - 1);
    }

    public void open(BufferedReader reader) {
	String line;
	StringTokenizer token;
	boolean end_found = false;

	try {
	    while( (line = reader.readLine()) != null) {
		token = new StringTokenizer(line);
		int key = Integer.valueOf(token.nextToken());
		if ( cmn.debug) System.out.println( "GrowAxisArc : " + line);

		switch ( key) {

		case Glow.eSave_GrowAxisArc: 
		    break;
		case Glow.eSave_GrowAxisArc_text_size: 
		    text_size = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowAxisArc_text_drawtype: 
		    text_drawtype = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowAxisArc_text_color_drawtype: 
		    text_color_drawtype = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowAxisArc_max_value: 
		    max_value = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_GrowAxisArc_min_value: 
		    min_value = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_GrowAxisArc_lines: 
		    lines = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowAxisArc_linelength: 
		    linelength = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_GrowAxisArc_longquotient: 
		    longquotient = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowAxisArc_valuequotient: 
		    valuequotient = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowAxisArc_format:
		    if ( token.hasMoreTokens())
			format = token.nextToken();			 
		    break;
		case Glow.eSave_GrowAxisArc_arc_part: 
		    super.open( reader);
		    break;
		case Glow.eSave_GrowAxisArc_userdata_cb:
		    if ( cmn.appl != null)
			userdata = cmn.appl.growUserdataOpen( reader, this, Glow.eUserdataCbType_Node);
		    break;
		case Glow.eSave_End:
		    end_found = true;
		    break;
		default:
		    System.out.println( "Syntax error in GrowAxisArc");
		    break;
		}
		if ( end_found)
		    break;
	    }

	    configure();
	    if ( format != null)
		cFormat = new GlowCFormat(format);


	} catch ( Exception e) {
	    System.out.println( "IOException GrowAxisArc");
	}
    }    

    public void draw(GlowTransform t, int highlight, int hot, Object node, Object colornode) {
	if ( cmn.nodraw != 0)
	    return;
	int i;
	boolean draw_text = (Math.abs(increment) > Double.MIN_VALUE);
	int idx;
	int x, y;
	String text;
	int line_length;
	int x_text, y_text;
	int z_height = 0, z_width, z_descent = 0;
	int max_z_width = 0;
	double rotation;
	int drawtype;
	int text_idx = (int)( cmn.mw.zoom_factor_y / cmn.mw.base_zoom_factor * (text_size +4) - 4);
	double tsize = cmn.mw.zoom_factor_y / cmn.mw.base_zoom_factor * (8+2*text_size);
	text_idx = Math.min( text_idx, Glow.DRAW_TYPE_SIZE-1);

	if ( node != null && ((GrowNode)node).line_width != 0)
	    idx = (int)( cmn.mw.zoom_factor_y / cmn.mw.base_zoom_factor * 
			 ((GrowNode)node).line_width - 1);
	else
	    idx = (int)( cmn.mw.zoom_factor_y / cmn.mw.base_zoom_factor * line_width - 1);
	idx += hot;
	
	idx = Math.max( 0, idx);
	idx = Math.min( idx, Glow.DRAW_TYPE_SIZE-1);
	int x1, y1, x2, y2, ll_x, ll_y, ur_x, ur_y, xt, yt;

	if (t == null) {
	    x1 = (int)( trf.x( ll.x, ll.y) * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	    y1 = (int)( trf.y( ll.x, ll.y) * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	    x2 = (int)( trf.x( ur.x, ur.y) * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	    y2 = (int)( trf.y( ur.x, ur.y) * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	    rotation = (trf.rot() / 360 - Math.floor( trf.rot() / 360)) * 360;
	}
	else {
	    x1 = (int)( trf.x( t, ll.x, ll.y) * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	    y1 = (int)( trf.y( t, ll.x, ll.y) * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	    x2 = (int)( trf.x( t, ur.x, ur.y) * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	    y2 = (int)( trf.y( t, ur.x, ur.y) * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	    rotation = (trf.rot( t) / 360 - Math.floor( trf.rot( t) / 360)) * 360;
	}

	ll_x = Math.min( x1, x2);
	ur_x = Math.max( x1, x2);
	ll_y = Math.min( y1, y2);
	ur_y = Math.max( y1, y2);
	drawtype = GlowColor.get_drawtype( draw_type, Glow.eDrawType_LineHighlight,
					   highlight, (GrowNode)colornode, 0, 0);

	if ( true) {
	    // Lines inwards
	    cmn.gdraw.arc( ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, 
			   angle1 - (int)rotation, angle2, drawtype, idx, 0);

	    if ( lines == 1)
		return;

	    if ( increment > 0)
		text = format_text( format, min_value + (lines - 2) * increment);
	    else 
		text = format_text( format, min_value + increment);
	    GlowDimension d = cmn.gdraw.getTextExtent( text,
						       Math.max( 0, text_idx), Glow.eFont_Helvetica, 
						       text_drawtype);
	    z_width = d.width;
	    z_height = d.height;
	    z_descent = z_height/4;
	    if ( max_z_width < z_width)
		max_z_width = z_width;

	    double line_angle = (double)angle2 / (lines - 1);
	    for ( i = 0; i < lines; i++) {
		double sin1 = Math.sin( ((double)angle1 + i * line_angle) / 180 * Math.PI);
		double cos1 = Math.cos( ((double)angle1 + i * line_angle) / 180 * Math.PI);
		y1 = (int)( ((double)ur_y - ll_y) / 2 * ( -sin1 + 1) + ll_y);
		x1 = (int)( ((double)ur_x - ll_x) / 2 * ( cos1 + 1) + ll_x);
		if ( i % longquotient == 0) {
		    y2 = (int)( ((double)ur_y - ll_y) / 2 * ( -sin1 * (1.0 - linelength) + 1) + ll_y);
		    x2 = (int)( ((double)ur_x - ll_x) / 2 * ( cos1 * (1.0 - linelength) + 1) + ll_x);
		}
		else {
		    y2 = (int)( ((double)ur_y - ll_y) / 2 * ( -sin1 * (1.0 - linelength/2) + 1) + ll_y);
		    x2 = (int)( ((double)ur_x - ll_x) / 2 * ( cos1 * (1.0 - linelength/2) + 1) + ll_x);
		}
		yt = (int)( ((double)ur_y - ll_y) / 2 * ( -sin1 * (1.0 - linelength) + 1) + ll_y +
			  sin1 * (z_height - z_descent)/2);
		xt = (int)( ((double)ur_x - ll_x) / 2 * ( cos1 * (1.0 - linelength) + 1) + ll_x -
			  cos1 * z_width/2);

		cmn.gdraw.line( x1, y1, 
				x2, y2, drawtype, idx, 0);
		if ( draw_text) {
		    if ( text_idx >= 0 && i % valuequotient == 0 &&
			 !(angle2 == 360 && 
			   ((increment > 0 && i == lines - 1) || (increment < 0 && i == 0)))) {
			text = format_text( format, min_value + i * increment);
		        d = cmn.gdraw.getTextExtent( text,
						     Math.max( 0, text_idx), Glow.eFont_Helvetica, 
						     text_drawtype);
			z_width = d.width;
			z_height = d.height;
			z_descent = z_height/4;
			if ( max_z_width < z_width)
			    max_z_width = z_width;
	  
			if ( i == lines - 1 && angle1 == 0 && angle2 == 180) {
			    xt = xt - z_width/2;
			}
			else if ( i == 0 && angle1 == 0 && angle2 != 360) {
			    xt = xt - z_width/2;
			}
			else {
			    yt = yt + (z_height-z_descent)/2;
			    xt = xt - z_width/2;
			}
			cmn.gdraw.text( xt, yt,
					text, text_drawtype, text_color_drawtype, 
					text_idx, highlight, 0, Glow.eFont_Helvetica, tsize, 0);
		    }
		}
	    }
	}

    }

    String format_text( String fmt, double value) {
	/*
	if ( fmt.equals( "%1t")) {
	    // Hours, minutes and seconds, value in seconds
	    int val = (int) Math.nearbyint(value);
	    int hours = val / 3600;
	    int minutes = (val - hours * 3600) / 60; 
	    int seconds = (val - hours * 3600 - minutes * 60); 
	    sprintf( text, "%d:%02d:%02d", hours, minutes, seconds);
	}
	else if ( fmt.equals( "%2t")) {
	    // Hours and minutes, value in seconds
	    int val = (int) nearbyint(value);
	    int hours = val / 3600;
	    int minutes = (val - hours * 3600) / 60; 
	    sprintf( text, "%d:%02d", hours, minutes);
	}
	else if ( fmt.equals( "%3t")) {
	    // Days, hours and minues, value in seconds
	    int val = (int) nearbyint(value);
	    int days = val / (24 * 3600);
	    int hours = (val - days * 24 * 3600) / 3600; 
	    int minutes = (val - days * 24 * 3600 - hours * 3600) / 60; 
	    sprintf( text, "%d %02d:%02d", days, hours, minutes);
	}
	else if ( fmt.equals( "%10t")) {
	    // Date
	    char timstr[40];
	    pwr_tTime t;
	    t.tv_sec = (int) nearbyint(value);
	    t.tv_nsec = 0;
    
	    time_AtoAscii( &t, time_eFormat_NumDateAndTime, timstr, sizeof(timstr));
	    timstr[19] = 0;
	    strcpy( text, timstr);
	}
	else if ( fmt.equals( "%11t")) {
	    // Date, no seconds
	    char timstr[40];
	    pwr_tTime t;
	    t.tv_sec = (int) nearbyint(value);
	    t.tv_nsec = 0;
    
	    time_AtoAscii( &t, time_eFormat_NumDateAndTime, timstr, sizeof(timstr));
	    timstr[16] = 0;
	    strcpy( text, timstr);
	}
	else {
	*/
	    if ( Math.abs(value) < Double.MIN_VALUE)
		value = 0;
	    sb = cFormat.format( (float)value, sb);
	    return new String(sb);
	/*	    
	}
	*/
	    
    }

    public Object getUserData() {
	return userdata;
    }

    public class Range {
	public Range(int lines, int longq, int vvalq, int hvalq, String format) {
	    this.lines = lines;
	    this.longq = longq;
	    this.vvalq = vvalq;
	    this.hvalq = hvalq;
	    this.format = format;
	}
	int lines;
	int longq;
	int vvalq;
	int hvalq;
	String format;
    }

    public void set_range( double minval, double maxval, int keep_settings) {
	Range[][] rdata = new Range[][] {
	    new Range[] {
		new Range(  26,  5,  5, 10, "%3.1f"), // 1
		new Range(  21,  5,  5, 10, "%3.1f"), // 2
		new Range(  31,  5, 10, 10, "%3.1f"), // 3
		new Range(  41,  5, 10, 20, "%3.1f"), // 4
		new Range(  26,  5,  5, 10, "%1.0f"), // 5
		new Range(  31,  5, 10, 10, "%1.0f"), // 6
		new Range(  36,  5, 10, 10, "%1.0f"), // 7
		new Range(  17,  2,  4,  4, "%1.0f"), // 8
		new Range(  19,  2,  4,  4, "%1.0f"), // 9
		new Range(  21,  2,  4,  8, "%2.0f"), // 10
		new Range(  23,  2,  4,  8, "%2.0f"), // 11
		new Range(  13,  4,  4,  4, "%2.0f"), // 12
		new Range(  14,  4,  4,  4, "%2.0f"), // 13
		new Range(  15,  4,  4,  4, "%2.0f"), // 14
		new Range(  16,  5,  5,  5, "%2.0f"), // 15
		new Range(  17,  5,  5,  5, "%2.0f"), // 16
		new Range(  18,  5,  5,  5, "%2.0f"), // 17
		new Range(  19,  5,  5,  5, "%2.0f"), // 18
		new Range(  20,  5,  5,  5, "%2.0f"), // 19
		new Range(  21,  5,  5,  5, "%2.0f"), // 20
		new Range(  22,  5,  5,  5, "%2.0f"), // 21
		new Range(  23,  5,  5,  5, "%2.0f"), // 22
		new Range(  24,  5,  5,  5, "%2.0f"), // 23
		new Range(  25,  5,  5,  5, "%2.0f"), // 24
		new Range(  26,  5,  5, 10, "%2.0f")},// 25
	    new Range[] {
		new Range( 101,  5, 10, 20, "%3.1f"), // 1
		new Range( 101,  5, 10, 20, "%3.1f"), // 2
		new Range(  61, 10, 10, 20, "%3.1f"), // 3
		new Range(  81, 10, 10, 20, "%3.1f"), // 4
		new Range( 101, 10, 20, 20, "%1.0f"), // 5
		new Range(  61,  5, 10, 20, "%1.0f"), // 6
		new Range(  71,  5, 10, 20, "%1.0f"), // 7
		new Range(  81,  5, 10, 20, "%1.0f"), // 8
		new Range(  91,  5, 10, 20, "%1.0f"), // 9
		new Range( 101,  5, 10, 20, "%2.0f"), // 10
		new Range(  56,  5,  5,  5, "%2.0f"), // 11
		new Range(  61,  5, 10, 10, "%2.0f"), // 12
		new Range(  66,  5, 10, 20, "%2.0f"), // 13
		new Range(  71,  5, 10, 20, "%2.0f"), // 14
		new Range(  76,  5, 10, 20, "%2.0f"), // 15
		new Range(  81,  5, 10, 20, "%2.0f"), // 16
		new Range(  86,  5, 10, 20, "%2.0f"), // 17
		new Range(  91,  5, 10, 20, "%2.0f"), // 18
		new Range(  96,  5, 10, 20, "%2.0f"), // 19
		new Range( 101,  5, 10, 25, "%2.0f"), // 20
		new Range(  43,  2,  6,  6, "%2.0f"), // 21
		new Range(  45,  2,  4,  8, "%2.0f"), // 22
		new Range(  47,  2,  4,  8, "%2.0f"), // 23
		new Range(  49,  2,  4,  8, "%2.0f"), // 24
		new Range(  26,  5,  5,  5, "%2.0f")}}; // 25
	
	max_value = maxval;
	min_value = minval;

	int x1 = (int)( trf.x( ll.x, ll.y) * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	int y1 = (int)( trf.y( ll.x, ll.y) * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	int x2 = (int)( trf.x( ur.x, ur.y) * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	int y2 = (int)( trf.y( ur.x, ur.y) * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	double rotation = (trf.rot() / 360 - Math.floor( trf.rot() / 360)) * 360;

	if ( keep_settings == 0) {
	    int len;
	    int lix;
	    int di;
	    int horizontal = ( rotation < 45 || (rotation > 135 && rotation < 225) || rotation > 315) ? 0 : 1;
	    if ( horizontal != 0)
		len = Math.abs( x2 - x1);
	    else
		len = Math.abs( y2 - y1);
	    
	    if ( len < 150)
		lix = 0;
	    else 
		lix = 1;

	    double d = Math.abs( maxval - minval);
	    if ( d < 5)
		d = 1000 * d;
	    
	    di = (int) (d + 0.5);
	    while ( di >= 25)
		di /= 10;

	    if ( di > 0 && di <= 25) {
		lines = rdata[lix][di-1].lines;
		longquotient = rdata[lix][di-1].longq;
		if ( horizontal != 0)
		    valuequotient = rdata[lix][di-1].hvalq;
		else
		    valuequotient = rdata[lix][di-1].vvalq;
	    }

	    double m = Math.max(Math.abs(maxval),Math.abs(minval)); 
	    switch ( lix) {
	    case 0: {
		if ( m < 0.01)
		    format = "%g";
		else if ( m < 0.1)
		    format = "%5.3f";
		else if ( m < 1)
		    format = "%4.2f";
		else if ( m < 3)
		    format = "%3.1f";
		else if ( m <= 20)
		    format = "%2.0f";
		else if ( m <= 200)
		    format = "%3.0f";
		else if ( m < 2000)
		    format = "%4.0f";
		else if ( m < 20000)
		    format = "%5.0f";
		else
		    format = "%g";
		break;
	    }
	    case 1: {
		if ( m < 0.01)
		    format = "%g";
		else if ( m < 0.1)
		    format = "%5.3f";
		else if ( m < 1)
		    format = "%4.2f";
		else if ( m <= 4)
		    format = "%3.1f";
		else if ( m <= 20)
		    format = "%2.0f";
		else if ( m <= 200)
		    format = "%3.0f";
		else if ( m < 2000)
		    format = "%4.0f";
		else if ( m < 20000)
		    format = "%5.0f";
		else
		    format = "%g";
		break;
	    }
	    default: ;
	    }
	}
	configure();
	draw();
    }
}
