/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jopg;
import jpwr.rt.*;
import java.io.*;
import java.util.*;

public class GrowTrend extends GrowRect {

    class TraceData{
	String[] data = new String[10];
	int color;
	int attr_type;
	int access;
	int cycle;
	String ref_object;
    }

    double[] y_max_value = new double[Glow.TREND_MAX_CURVES];
    double[] y_min_value = new double[Glow.TREND_MAX_CURVES];
    double[] x_max_value = new double[Glow.TREND_MAX_CURVES];
    double[] x_min_value = new double[Glow.TREND_MAX_CURVES];
    int vertical_lines;
    int horizontal_lines;
    int fill_curve;
    int no_of_points;
    int curve_width;
    int[] curve_drawtype = new int[Glow.TREND_MAX_CURVES];
    int[] curve_fill_drawtype = new int[Glow.TREND_MAX_CURVES];
    double scan_time;
    GrowPolyline[] curve = new GrowPolyline[Glow.TREND_MAX_CURVES];
    int curve_cnt = 1;
    TraceData trace = new TraceData();
    Object userdata;
    int display_x_mark1 = 0;
    int display_x_mark2 = 0;
    int display_y_mark1 = 0;
    int display_y_mark2 = 0;
    double x_mark1;
    double x_mark2;
    double y_mark1;
    double y_mark2;
    int mark1_color;
    int mark2_color;

    public GrowTrend(GrowCmn cmn) {
	super(cmn);
    }

    public GrowTrend( GrowCmn cmn, String n_name, double x, double y, 
		    double w, double h, int draw_type, int line_width, 
		    int fill, int border, int shadow,
		    int fill_drawtype) {
	super(cmn, n_name, x, y, w, h, draw_type, line_width, fill, border, shadow, fill_drawtype);
    }

    public int type() {
	return Glow.eObjectType_GrowTrend;
    }

    public void open(BufferedReader reader) {
	String line;
	StringTokenizer token;
	boolean end_found = false;

	try {
	    while( (line = reader.readLine()) != null) {
		token = new StringTokenizer(line);
		int key = Integer.valueOf(token.nextToken());
		if ( cmn.debug) System.out.println( "GrowTrend : " + line);

		switch ( key) {

		case Glow.eSave_GrowTrend: 
		    break;

		case Glow.eSave_GrowTrend_y_max_value_0: 
		    y_max_value[0] = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_GrowTrend_y_max_value_1: 
		    y_max_value[1] = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_GrowTrend_y_min_value_0: 
		    y_min_value[0] = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_GrowTrend_y_min_value_1: 
		    y_min_value[1] = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_GrowTrend_x_max_value_0: 
		    x_max_value[0] = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_GrowTrend_x_max_value_1: 
		    x_max_value[1] = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_GrowTrend_x_min_value_0: 
		    x_min_value[0] = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_GrowTrend_x_min_value_1: 
		    x_min_value[1] = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_GrowTrend_horizontal_lines: 
		    horizontal_lines = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTrend_vertical_lines: 
		    vertical_lines = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTrend_fill_curve: 
		    fill_curve = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTrend_curve_drawtype_0: 		    
			curve_drawtype[0] = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTrend_curve_drawtype_1: 
		    curve_drawtype[1] = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTrend_curve_fill_drawtype_0: 
		    curve_fill_drawtype[0] = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTrend_curve_fill_drawtype_1: 
		    curve_fill_drawtype[1] = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTrend_no_of_points: 
		    no_of_points = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTrend_curve_width: 
		    curve_width = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTrend_scan_time: 
		    scan_time = new Double(token.nextToken()).doubleValue(); 
		    break;
		case Glow.eSave_GrowTrend_rect_part: 
		    super.open( reader);
		    break;
		case Glow.eSave_GrowTrend_trace_data1:
		    if ( token.hasMoreTokens())
			trace.data[0] = token.nextToken();			 
		    break;
		case Glow.eSave_GrowTrend_trace_data2:
		    if ( token.hasMoreTokens())
			trace.data[1] = token.nextToken();			 
		    break;
		case Glow.eSave_GrowTrend_trace_data3:
		    if ( token.hasMoreTokens())
			trace.data[2] = token.nextToken();			 
		    break;
		case Glow.eSave_GrowTrend_trace_data4:
		    if ( token.hasMoreTokens())
			trace.data[3] = token.nextToken();			 
		    break;
		case Glow.eSave_GrowTrend_trace_data5:
		    if ( token.hasMoreTokens())
			trace.data[4] = token.nextToken();			 
		    break;
		case Glow.eSave_GrowTrend_trace_data6:
		    if ( token.hasMoreTokens())
			trace.data[5] = token.nextToken();			 
		    break;
		case Glow.eSave_GrowTrend_trace_data7:
		    if ( token.hasMoreTokens())
			trace.data[6] = token.nextToken();			 
		    break;
		case Glow.eSave_GrowTrend_trace_data8:
		    if ( token.hasMoreTokens())
			trace.data[7] = token.nextToken();			 
		    break;
		case Glow.eSave_GrowTrend_trace_data9:
		    if ( token.hasMoreTokens())
			trace.data[8] = token.nextToken();			 
		    break;
		case Glow.eSave_GrowTrend_trace_data10:
		    if ( token.hasMoreTokens())
			trace.data[9] = token.nextToken();			 
		    break;
		case Glow.eSave_GrowTrend_trace_attr_type: 
		    trace.attr_type = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTrend_trace_color: 
		    trace.color = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTrend_access:
		    trace.access = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTrend_cycle:
		    trace.cycle = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTrend_ref_object:
		    if ( token.hasMoreTokens())
			trace.ref_object = token.nextToken();			 
		    break;
		case Glow.eSave_GrowTrend_userdata_cb:
		    if ( cmn.appl != null)
			userdata = cmn.appl.growUserdataOpen( reader, this, Glow.eUserdataCbType_Node);
		    break;

		case Glow.eSave_End:
		    end_found = true;
		    break;
		default:
		    System.out.println( "Syntax error in GrowTrend");
		    break;
		}
		if ( end_found)
		    break;
	    }
		
	    configure_curves();

	} catch ( Exception e) {
	    System.out.println( "IOException GrowTrend");
	}
    }    

    public void draw(GlowTransform t, int highlight, int hot, Object node, Object colornode) {
	if ( cmn.nodraw != 0)
	    return;
	int i;
	int idx;
	int drawtype;

	if ( node != null && ((GrowNode)node).line_width != 0)
	    idx = (int)( cmn.mw.zoom_factor_y / cmn.mw.base_zoom_factor * 
		       ((GrowNode)node).line_width - 1);
	else
	    idx = (int)( cmn.mw.zoom_factor_y / cmn.mw.base_zoom_factor * line_width - 1);
	idx += hot;
	
	idx = Math.max( 0, idx);
	idx = Math.min( idx, Glow.DRAW_TYPE_SIZE-1);
	int x1, y1, x2, y2, ll_x, ll_y, ur_x, ur_y;

	if (t == null) {
	    x1 = (int)( trf.x( ll.x, ll.y) * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	    y1 = (int)( trf.y( ll.x, ll.y) * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	    x2 = (int)( trf.x( ur.x, ur.y) * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	    y2 = (int)( trf.y( ur.x, ur.y) * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	}
	else {
	    x1 = (int)( trf.x( t, ll.x, ll.y) * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	    y1 = (int)( trf.y( t, ll.x, ll.y) * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	    x2 = (int)( trf.x( t, ur.x, ur.y) * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	    y2 = (int)( trf.y( t, ur.x, ur.y) * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	}

	ll_x = Math.min( x1, x2);
	ur_x = Math.max( x1, x2);
	ll_y = Math.min( y1, y2);
	ur_y = Math.max( y1, y2);
	if ( fill != 0) {
	    int grad = gradient;
	    if ( gradient == Glow.eGradient_No && 
		     (node != null && ((GrowNode)node).gradient != Glow.eGradient_No) && disable_gradient == 0)
		grad = ((GrowNode)node).gradient;

	    drawtype = GlowColor.get_drawtype( fill_drawtype, Glow.eDrawType_FillHighlight,
					       highlight, colornode, 1, 0);
	    if ( grad == Glow.eGradient_No)
		cmn.gdraw.fill_rect( ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, drawtype);
	    else {
		int f1, f2;
		double rotation;
		
		if ( t != null)
		    rotation = trf.rot( t);
		else
		    rotation = trf.rot();
		if ( gradient_contrast >= 0) {
		    f2 = GlowColor.shift_drawtype( drawtype, -gradient_contrast/2, null);
		    f1 = GlowColor.shift_drawtype( drawtype, (int)((float)(gradient_contrast)/2+0.6), null);
		}
		else {
		    f2 = GlowColor.shift_drawtype( drawtype, -(int)((float)(gradient_contrast)/2-0.6), null);
		    f1 = GlowColor.shift_drawtype( drawtype, gradient_contrast/2, null);
		}
		cmn.gdraw.gradient_fill_rect( ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, drawtype, f1, f2, cmn.gdraw.gradient_rotate( rotation, grad));
	    }
	}
	drawtype = GlowColor.get_drawtype( draw_type, Glow.eDrawType_LineHighlight,
					   highlight, colornode, 0, 0);

	if ( fill_curve != 0) {
	    for ( i = 0; i < curve_cnt; i++) {
		if ( curve[i] != null)
		    curve[i].border = 0;
	    }
	    if ( t != null) {
		GlowTransform tmp = t.multiply(trf);
		for ( i = 0; i < curve_cnt; i++) {
		    if ( curve[i] != null)
			curve[i].draw( tmp, highlight, hot, node, colornode);
		}
	    }
	    else {
		for ( i = 0; i < curve_cnt; i++) {
		    if ( curve[i] != null)
			curve[i].draw( trf, highlight, hot, node, colornode);
		}
	    }
	    for ( i = 0; i < curve_cnt; i++) {
		if ( curve[i] != null)
		    curve[i].border = 1;
	    }
	}

	for ( i = 0; i < vertical_lines; i++) {
	    int x = (int)( ll_x + (double)(ur_x - ll_x) / (vertical_lines + 1) * (i + 1)); 
	    cmn.gdraw.line( x, ll_y, x, ur_y, drawtype, 0, 0);
	}

	for ( i = 0; i < horizontal_lines; i++) {
	    int y = (int)( ll_y + (double)(ur_y - ll_y) / (horizontal_lines + 1) * (i + 1)); 
	    cmn.gdraw.line( ll_x, y, ur_x, y, drawtype, 0, 0);
	}

	if ( fill_curve != 0) {
	    for ( i = 0; i < curve_cnt; i++) {
		if ( curve[i] != null)
		    curve[i].fill = 0;
	    }
	}
	if ( t != null) {
	    GlowTransform tmp = t.multiply(trf);
	    for ( i = 0; i < curve_cnt; i++) {
		if ( curve[i] != null)
		    curve[i].draw( tmp, highlight, hot, node, colornode);
	    }
	}
	else {
	    for ( i = 0; i < curve_cnt; i++) {
		if ( curve[i] != null)
		    curve[i].draw( trf, highlight, hot, node, colornode);
	    }
	}

	if ( fill_curve != 0) {
	    for ( i = 0; i < curve_cnt; i++) {
		if ( curve[i] != null)
		    curve[i].fill = 1;
	    }
	}

	if ( display_x_mark1 != 0) {
	    int xm;
	    if (t == null)
		xm = (int)(trf.x( x_mark1, ll.y) * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	    else
		xm = (int)(trf.x( t, x_mark1, ll.y) * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	    if ( xm >= ll_x && xm <= ur_x) {
		drawtype = mark1_color;
		if ( drawtype == Glow.eDrawType_Inherit)
		    drawtype = Glow.eDrawType_ColorYellow;
		cmn.gdraw.line( xm, ll_y, xm, ur_y, drawtype, idx, 0);
	    }
	}
	if ( display_x_mark2 != 0) {
	    int xm;
	    if (t == null)
		xm = (int)(trf.x( x_mark2, ll.y) * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	    else
		xm = (int)(trf.x( t, x_mark2, ll.y) * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	    if ( xm >= ll_x && xm <= ur_x) {
		drawtype = mark2_color;
		if ( drawtype == Glow.eDrawType_Inherit)
		    drawtype = Glow.eDrawType_ColorYellow;
		cmn.gdraw.line( xm, ll_y, xm, ur_y, drawtype, idx, 0);
	    }
	}
	if ( display_y_mark1 != 0) {
	    int ym;
	    if (t == null)
		ym = (int)( trf.y( ll.x, y_mark1) * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	    else
		ym = (int)( trf.y( t, ll.x, y_mark1) * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	    if ( ym >= ll_y && ym <= ur_y) {
		drawtype = mark1_color;
		if ( drawtype == Glow.eDrawType_Inherit)
		    drawtype = Glow.eDrawType_ColorYellow;
		cmn.gdraw.line( ll_x, ym, ur_x, ym, drawtype, idx, 0);
	    }
	}
	if ( display_y_mark2 != 0) {
	    int ym;
	    if (t == null)
		ym = (int)( trf.y( ll.x, y_mark2) * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	    else
		ym = (int)( trf.y( t, ll.x, y_mark2) * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	    if ( ym >= ll_y && ym <= ur_y) {
		drawtype = mark2_color;
		if ( drawtype == Glow.eDrawType_Inherit)
		    drawtype = Glow.eDrawType_ColorYellow;
		cmn.gdraw.line( ll_x, ym, ur_x, ym, drawtype, idx, 0);
	    }
	}

	if ( border != 0) {
	    cmn.gdraw.rect( ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, drawtype, idx, 0);
	}
    }

    public void set_range( int curve, double min, double max) { 
	if ( !( curve == 0 || curve == 1))
	    return;
	y_max_value[curve] = max;
	y_min_value[curve] = min;
	configure_curves();
    }

    public Object getUserData() {
	return userdata;
    }

    void configure_curves() {
	int dt, dt_fill;
	int points;
	GlowPoint[] pointarray;
	GlowPoint point_p;
	int	i;


	if ( false /* strcmp( trace.data[1], "") == 0 */ )
	    curve_cnt = 1;
	else
	    curve_cnt = 2;

	no_of_points = Math.max( 2, no_of_points);
	points = no_of_points;
	if ( fill_curve != 0)
	    points += 2;
	curve_width = Math.min( Glow.DRAW_TYPE_SIZE, Math.max( 1, curve_width));

	pointarray = new GlowPoint[points];
	for ( i = 0; i < points; i++) {
	    pointarray[i] = new GlowPoint();
	    point_p = pointarray[i];
	    if ( fill_curve == 0) {
		point_p.y = ur.y;
		point_p.x = ur.x - i * (ur.x - ll.x) / (points - 1);
	    }
	    else {
		point_p.y = ur.y;
		if ( i == 0)
		    point_p.x = ur.x;
		else if ( i == points - 1)
		    point_p.x = ll.x;
		else
		    point_p.x = ur.x - (i - 1) * (ur.x - ll.x) / (points - 3);
	    }
	}

	for ( i = 0; i < curve_cnt; i++) {
	    if ( curve[i] != null)
		curve[i] = null;

	    if ( curve_drawtype[i] != Glow.eDrawType_Inherit)
		dt = curve_drawtype[i];
	    else
		dt = draw_type;

	    if ( curve_fill_drawtype[i] != Glow.eDrawType_Inherit)
		dt_fill = curve_fill_drawtype[i];
	    else
		dt_fill = draw_type;

	    cmn.nodraw++;
	    curve[i] = new GrowPolyline( cmn, "", pointarray, points, dt, 
					 curve_width,
					 0, fill_curve, 1, 0, dt_fill);
	    cmn.nodraw--;
	}
    }

    public void set_range_y( int curve, double min, double max) {
	if ( !( curve == 0 || curve == 1))
	    return;

	if ( curve == 0) {
	    if ( display_y_mark1 != 0) {
		double mark = y_min_value[0] - (y_mark1 - ur.y) *(y_max_value[0] - y_min_value[0]) / (ur.y - ll.y);
		y_mark1 = ur.y - (mark - min) / (max - min) * (ur.y - ll.y);
	    }
	    if ( display_y_mark2 != 0) {
		double mark = y_min_value[0] - (y_mark2 - ur.y) *(y_max_value[0] - y_min_value[0]) / (ur.y - ll.y);
		y_mark2 = ur.y - (mark - min) / (max - min) * (ur.y - ll.y);
	    }
	}

	y_max_value[curve] = max;
	y_min_value[curve] = min;
	configure_curves();
    }


    public void add_value( double value, int idx) { 
	double curve_value = 0;
	if ( idx >= curve_cnt)
	    return;
	if ( y_max_value[idx] != y_min_value[idx])
	    curve_value = ur.y - (value - y_min_value[idx]) / 
		(y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);

	curve_value = Math.max( ll.y, Math.min( curve_value, ur.y));
	if ( fill_curve == 0)
	    curve[idx].add_and_shift_y_value( curve_value);
	else
	    curve[idx].add_and_shift_y_value_filled( curve_value);
	draw();
    }

    public void set_scan_time( double time) {
	scan_time = time;
	configure_curves();
    }

    public double get_scan_time() {
	return scan_time;
    }
    public int get_no_of_points() {
	return no_of_points;
    }
    public void set_x_mark1( double mark) {
	display_x_mark1 = 1;
	x_mark1 = ll.x + (mark - x_min_value[0]) / 
	    (x_max_value[0] - x_min_value[0]) * (ur.x - ll.x);
	draw();
    }
    public void set_x_mark2( double mark) {
	display_x_mark2 = 1;
	x_mark2 = ll.x + (mark - x_min_value[0]) / 
	    (x_max_value[0] - x_min_value[0]) * (ur.x - ll.x);
	draw();
    }
    public void set_y_mark1( double mark) {
	display_y_mark1 = 1;
	y_mark1 = ur.y - (mark - y_min_value[0]) / 
	    (y_max_value[0] - y_min_value[0]) * (ur.y - ll.y);
	draw();
    }
    public void set_y_mark2( double mark) {
	display_y_mark2 = 1;
	y_mark2 = ur.y - (mark - y_min_value[0]) / 
	    (y_max_value[0] - y_min_value[0]) * (ur.y - ll.y);
	draw();
    }

    public void set_mark_color( int m1color, int m2color){
	mark1_color = m1color;
	mark2_color = m2color;
    }
}
