/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jopg;
import jpwr.rt.*;
import java.io.*;
import java.util.*;

public class GlowTransform {
    double a11;
    double a12;
    double a13;
    double a21;
    double a22;
    double a23;
    double rotation;
    double s_a11;
    double s_a12;
    double s_a13;
    double s_a21;
    double s_a22;
    double s_a23;
    double s_rotation;
    boolean stored;

    public GlowTransform() {
	a11 = 1;
	a22 = 1;
	s_a11 = 1;
	s_a22 = 1;
    }

    public void store() { 
	s_a11=a11;
	s_a12=a12;
	s_a13=a13;
	s_a21=a21;
	s_a22=a22;
	s_a23=a23;
	s_rotation=rotation; 
	stored=true;
    }

    public void open(BufferedReader reader) {
	String line;
	StringTokenizer token;
	boolean end_found = false;
	boolean debug = false;

	try {
	    while( (line = reader.readLine()) != null) {
		token = new StringTokenizer(line);
		int key = Integer.valueOf(token.nextToken());
		if ( debug) System.out.println( "GlowTransform : " + line);

		switch ( key) {
		case Glow.eSave_Transform: break;
		case Glow.eSave_Transform_a11:
		    a11 = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_Transform_a12:
		    a12 = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_Transform_a13:
		    a13 = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_Transform_a21:
		    a21 = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_Transform_a22:
		    a22 = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_Transform_a23:
		    a23 = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_Transform_rotation:
		    rotation = new Double(token.nextToken()).doubleValue();
		    break;
		case Glow.eSave_End:
		    end_found = true;
		    break;
		default:
		    System.out.println( "Syntax error in GlowTransform");
		    break;
		}
		if ( end_found)
		    break;

	    }
	} catch ( Exception e) {
	    System.out.println( "IOException GlowTransform");
	}
    }

    public double rot( GlowTransform t) { 
	return t.rotation + rotation;
    }

    public double rot() { 
	return rotation;
    }

    public double x( double x1, double y1) {
	return x1 * a11 + y1 * a12 + a13;
    }

    public double y( double x1, double y1) {
	return x1 * a21 + y1 * a22 + a23;
    }


    public GlowTransform multiply(GlowTransform p) {
	GlowTransform tmp = new GlowTransform();
	tmp.a11 = a11 * p.a11 + a12 * p.a21;
	tmp.a12 = a11 * p.a12 + a12 * p.a22;
	tmp.a13 = a11 * p.a13 + a12 * p.a23 + a13;
	tmp.a21 = a21 * p.a11 + a22 * p.a21;
	tmp.a22 = a21 * p.a12 + a22 * p.a22;
	tmp.a23 = a21 * p.a13 + a22 * p.a23 + a23;
	tmp.rotation = rotation + p.rotation;
	return tmp;
    }

    public void set_from_stored( GlowTransform t) {
	a11 = t.a11 * s_a11 + t.a12 * s_a21;
	a12 = t.a11 * s_a12 + t.a12 * s_a22;
	a13 = t.a11 * s_a13 + t.a12 * s_a23 + t.a13;
	a21 = t.a21 * s_a11 + t.a22 * s_a21;
	a22 = t.a21 * s_a12 + t.a22 * s_a22;
	a23 = t.a21 * s_a13 + t.a22 * s_a23 + t.a23;
	rotation = s_rotation + t.rotation;
    }

    public void scale( double sx, double sy, double x0, double y0) {
	a13 = a13 * sx + x0 * ( 1 - sx);
	a23 = a23 * sy + y0 * ( 1 - sy);
	a11 *= sx;
	a12 *= sx;
	a21 *= sy;
	a22 *= sy;
    }

    public void scale_from_stored( double sx, double sy, double x0, double y0) {
	a13 = s_a13 * sx + x0 * ( 1 - sx);
	a23 = s_a23 * sy + y0 * ( 1 - sy);
	a11 = s_a11 * sx;
	a12 = s_a12 * sx;
	a21 = s_a21 * sy;
	a22 = s_a22 * sy;
    }

    public void rotate( double angle, double x0, double y0) {
	double sin_a;
	double cos_a;
	GlowTransform tmp = new GlowTransform();
	tmp.a11 = a11;
	tmp.a12 = a12;
	tmp.a13 = a13;
	tmp.a21 = a21;
	tmp.a22 = a22;
	tmp.a23 = a23;
	tmp.rotation = rotation;

	if ( -90.01 < angle && angle < -89.99) {
	    sin_a = -1.0;
	    cos_a = 0.0;
	}
	else {
	    sin_a = Math.sin( angle/180*3.14159);
	    cos_a = Math.cos( angle/180*3.14159);
	}

	a11 = tmp.a11 * cos_a - tmp.a21 * sin_a;
	a12 = tmp.a12 * cos_a - tmp.a22 * sin_a;
	a13 = tmp.a13 * cos_a - tmp.a23 * sin_a + x0 * ( 1 - cos_a) + y0 * sin_a;
	a21 = tmp.a11 * sin_a + tmp.a21 * cos_a;
	a22 = tmp.a21 * sin_a + tmp.a22 * cos_a;
	a23 = tmp.a13 * sin_a + tmp.a23 * cos_a + y0 * ( 1 - cos_a) - x0 * sin_a;
	rotation += angle;
    }

    public void rotate_from_stored( double angle, double x0, double y0) {

	double sin_a;
	double cos_a;
	if ( -90.01 < s_rotation + angle  && s_rotation + angle < -89.99) {
	    sin_a = -1.0;
	    cos_a = 0.0;
	}
	else {
	    sin_a = Math.sin( (s_rotation + angle)/180*3.14159);
	    cos_a = Math.cos( (s_rotation + angle)/180*3.14159);
	}

	a11 = s_a11 * cos_a - s_a21 * sin_a;
	a12 = s_a12 * cos_a - s_a22 * sin_a;
	a13 = s_a13 * cos_a - s_a23 * sin_a + x0 * ( 1 - cos_a) + y0 * sin_a;
	a21 = s_a11 * sin_a + s_a21 * cos_a;
	a22 = s_a21 * sin_a + s_a22 * cos_a;
	a23 = s_a13 * sin_a + s_a23 * cos_a + y0 * ( 1 - cos_a) - x0 * sin_a;
	rotation = s_rotation + angle;
    }

    public void move( double x0, double y0) {
	a13 += x0;
	a23 += y0;
    }

    public void move_from_stored( double x0, double y0) {
	a13 = s_a13 + x0;
	a23 = s_a23 + y0;
    }

    public void posit( double x0, double y0) {
	a13 = x0;
	a23 = y0;
    }

    public double x( GlowTransform t, double x1, double y1) { 
	GlowTransform tmp = t.multiply(this);

	return tmp.x( x1, y1);
    }

    public double y( GlowTransform t, double x1, double y1) { 
	GlowTransform tmp = t.multiply(this);

	return tmp.y( x1, y1);
    }

    public GlowPointDX reverse( double x, double y) {
	GlowPointDX p = new GlowPointDX();
	if ( a11 == 0 || ( a12 * a21 - a11 * a22) == 0) {
	    if ( a11 == 0 && a22 == 0 && a12 != 0 && a21 != 0) {
		p.y = (x - a13) / a12;
		p.x = (y - a23) / a21;
		return p;
	    }
	    else {
		p.y = p.x = 0;
		return p;
	    }
	}
	p.y = ( a11 * ( a23 - y) - a21 * ( a13 - x)) / ( a12 * a21 - a11 * a22);
	p.x = ( x - a12 * p.y - a13) / a11;
	return p;
    }

    public double vertical_scale( GlowTransform t) {
	if ( t == null)
	    return Math.sqrt( a12*a12 + a22*a22);

	GlowTransform tmp = t.multiply(this);

	return Math.sqrt( tmp.a12*tmp.a12 + tmp.a22*tmp.a22);
    }

    public boolean is_stored() { 
	return stored;
    }

}
