/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jopg;
import jpwr.rt.*;
import java.io.*;
import java.util.*;

public class GrowTable extends GrowRect implements GrowScrollBarIfc {

    public static final int mTableOptions_No 		= 0;
    public static final int mTableOptions_ZeroIfHeader 	= 1 << 0;
    public static final int mTableOptions_ZeroIfHeaderIs0 = 1 << 1;

    String	       	file_name;
    Object 	        userdata;
    int			vertical_scrollbar;
    int			horizontal_scrollbar;
    double		scrollbar_width;
    GrowScrollBar	v_scrollbar;
    GrowScrollBar      	h_scrollbar;
    double		v_value;
    double		h_value;
    double		table_x0;
    double		table_x1;
    double		table_y0;
    double		table_y1;
    int			scrollbar_color;
    int			scrollbar_bg_color;
    double		window_scale  = 1;
    double		y_low_offs;
    double	        x_left_offs;
    int			rows;
    int			columns;
    int			header_row;
    int			header_column;
    int			text_size;
    int			text_drawtype;
    int 	      	text_color_drawtype;
    int			header_text_size;
    int			header_text_drawtype;
    int		       	header_text_color;
    double		header_row_height;
    double		row_height;
    double[]		column_width = new double[Glow.TABLE_MAX_COL];
    String[]	       	header_text = new String[Glow.TABLE_MAX_COL];
    int[]	       	column_size = new int[Glow.TABLE_MAX_COL];
    int[]	       	column_adjustment = new int[Glow.TABLE_MAX_COL];
    int			value_size;
    String[]  	       	cell_value;
    int			selected_cell_row = -1;
    int			selected_cell_column = -1;
    int			select_drawtype;
    int			input_focus;
    int 	       	header_text_bold;
    int			options;
    int			font;

    public GrowTable(GrowCmn cmn) {
	super(cmn);
    }

    public GrowTable( GrowCmn cmn, String n_name, double x, double y, 
		    double w, double h, int draw_type, int line_width, 
		    int fill, int border, int shadow,
		    int fill_drawtype) {
	super(cmn, n_name, x, y, w, h, draw_type, line_width, fill, border, shadow, fill_drawtype);
    }

    public int type() {
	return Glow.eObjectType_GrowTable;
    }

    public void open(BufferedReader reader) {
	String line;
	StringTokenizer token;
	boolean end_found = false;

	try {
	    while( (line = reader.readLine()) != null) {
		token = new StringTokenizer(line);
		int key = Integer.valueOf(token.nextToken());
		if ( cmn.debug) System.out.println( "GrowTable : " + line);

		switch ( key) {
		case Glow.eSave_GrowTable: 
		    break;
		case Glow.eSave_GrowTable_scrollbar_width: 
		    scrollbar_width = Double.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_scrollbar_color: 
		    scrollbar_color = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_scrollbar_bg_color: 
		    scrollbar_bg_color = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_vertical_scrollbar: 
		    vertical_scrollbar = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_horizontal_scrollbar: 
		    horizontal_scrollbar = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_window_scale: 
		    window_scale = Double.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_rows: 
		    rows = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_columns: 
		    columns = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_header_row: 
		    header_row = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_header_column: 
		    header_column = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_text_size: 
		    text_size = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_text_drawtype: 
		    text_drawtype = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_text_color_drawtype: 
		    text_color_drawtype = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_header_text_size: 
		    header_text_size = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_header_text_drawtype: 
		    header_text_drawtype = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_header_text_color: 
		    header_text_color = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_header_text_bold: 
		    header_text_bold = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_header_row_height: 
		    header_row_height = Double.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_row_height: 
		    row_height = Double.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_options: 
		    options = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_select_drawtype: 
		    select_drawtype = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_font: 
		    font = Integer.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_column_width1: 
		    column_width[0] = Double.valueOf(token.nextToken());
		    break;
		case Glow.eSave_GrowTable_header_text1: 
		    if ( token.hasMoreTokens())
			header_text[0] = token.nextToken();
		    break;
		case Glow.eSave_GrowTable_column_width2: 
		    column_width[1] = Double.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_header_text2: 
		    if ( token.hasMoreTokens())
			header_text[1] = token.nextToken();
		    break;
		case Glow.eSave_GrowTable_column_width3: 
		    column_width[2] = Double.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_header_text3: 
		    if ( token.hasMoreTokens())
			header_text[2] = token.nextToken();
		    break;
		case Glow.eSave_GrowTable_column_width4: 
		    column_width[3] = Double.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_header_text4: 
		    if ( token.hasMoreTokens())
			header_text[3] = token.nextToken();
		    break;
		case Glow.eSave_GrowTable_column_width5: 
		    column_width[4] = Double.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_header_text5: 
		    if ( token.hasMoreTokens())
			header_text[4] = token.nextToken();
		    break;
		case Glow.eSave_GrowTable_column_width6: 
		    column_width[5] = Double.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_header_text6: 
		    if ( token.hasMoreTokens())
			header_text[5] = token.nextToken();
		    break;
		case Glow.eSave_GrowTable_column_width7: 
		    column_width[6] = Double.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_header_text7: 
		    if ( token.hasMoreTokens())
			header_text[6] = token.nextToken();
		    break;
		case Glow.eSave_GrowTable_column_width8: 
		    column_width[7] = Double.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_header_text8: 
		    if ( token.hasMoreTokens())
			header_text[7] = token.nextToken();
		    break;
		case Glow.eSave_GrowTable_column_width9: 
		    column_width[8] = Double.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_header_text9: 
		    if ( token.hasMoreTokens())
			header_text[8] = token.nextToken();
		    break;
		case Glow.eSave_GrowTable_column_width10: 
		    column_width[9] = Double.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_header_text10: 
		    if ( token.hasMoreTokens())
			header_text[9] = token.nextToken();
		    break;
		case Glow.eSave_GrowTable_column_width11: 
		    column_width[10] = Double.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_header_text11: 
		    if ( token.hasMoreTokens())
			header_text[10] = token.nextToken();
		    break;
		case Glow.eSave_GrowTable_column_width12: 
		    column_width[11] = Double.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_header_text12: 
		    if ( token.hasMoreTokens())
			header_text[11] = token.nextToken();
		    break;
		case Glow.eSave_GrowTable_column_adjustment1: 
		    column_adjustment[0] = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_column_adjustment2: 
		    column_adjustment[1] = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_column_adjustment3: 
		    column_adjustment[2] = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_column_adjustment4: 
		    column_adjustment[3] = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_column_adjustment5: 
		    column_adjustment[4] = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_column_adjustment6: 
		    column_adjustment[5] = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_column_adjustment7: 
		    column_adjustment[6] = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_column_adjustment8: 
		    column_adjustment[7] = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_column_adjustment9: 
		    column_adjustment[8] = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_column_adjustment10: 
		    column_adjustment[9] = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_column_adjustment11: 
		    column_adjustment[10] = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_column_adjustment12: 
		    column_adjustment[11] = Integer.valueOf(token.nextToken()); 
		    break;
		case Glow.eSave_GrowTable_rect_part: 
		    super.open( reader);
		    break;
		case Glow.eSave_GrowTable_userdata_cb:
		    if ( cmn.appl != null)
			userdata = cmn.appl.growUserdataOpen( reader, this, Glow.eUserdataCbType_Node);
		    break;
		case Glow.eSave_End:
		    end_found = true;
		    break;
		default:
		    System.out.println( "Syntax error in GrowTable");
		    break;
		}
		if ( end_found)
		    break;
	    }

	} catch ( Exception e) {
	    System.out.println( "IOException GrowTable");
	}
	if ( cmn.debug)
	    System.out.println("GeTable: call_value size: " + columns * rows);

	configure();
	configure_scrollbars();
    }    

    public void configure() {
	table_x0 = table_y0 = 0;
	table_x1 = 0;
	for ( int i = 0; i < columns; i++) {
	    if ( header_column != 0 && i == 0)
		continue;
	    table_x1 += column_width[i];
	}
	table_y1 = row_height * rows;

	if ( header_row != 0)
	    y_low_offs = header_row_height;
	else
	    y_low_offs = 0;

	if ( header_column != 0)
	    x_left_offs = column_width[0];
	else
	    x_left_offs = 0;

	cell_value = new String[columns * rows];
    }

    void configure_scrollbars() {
	double x0, y0, width, height;

	if ( vertical_scrollbar != 0 && v_scrollbar == null) {
	    x0 = x_right - scrollbar_width;
	    y0 = y_low + y_low_offs;
	    width = scrollbar_width;
	    if ( horizontal_scrollbar != 0)
		height = y_high - (y_low + y_low_offs) - scrollbar_width;
	    else
		height = y_high - (y_low + y_low_offs);

	    v_scrollbar = new GrowScrollBar( cmn, "vScrollbar", x0, y0, width, height,
					     Glow.eDir_Vertical, Glow.eDrawType_Line, 1, display_level, 
					     scrollbar_bg_color, scrollbar_color, 1, this);
	    // v_scrollbar->register_value_changed_cb( (void *)this, &v_value_changed_cb);
	    v_scrollbar.set_range( table_y0 * window_scale, table_y1 * window_scale);
	    v_scrollbar.set_value( table_y0 * window_scale, y_high - (y_low + y_low_offs) - scrollbar_width * horizontal_scrollbar);
	    v_scrollbar.set_shadow( shadow);
	    v_value = table_y0 * window_scale;
	}
	else if ( vertical_scrollbar == 0 && v_scrollbar != null) {
	    v_scrollbar = null;
	    v_value = table_y0 * window_scale;
	}
	else if ( v_scrollbar != null) {
	    // Reconfigure range and length
	    v_scrollbar.set_range( table_y0 * window_scale, table_y1 * window_scale);
	    v_scrollbar.set_value( table_y0 * window_scale, y_high - (y_low + y_low_offs) - scrollbar_width * horizontal_scrollbar);
	    v_value = table_y0 * window_scale;
	    v_scrollbar.set_shadow( shadow);
	}
	else
	    v_value = table_y0 * window_scale;

	if ( horizontal_scrollbar != 0 && h_scrollbar == null) {
	    x0 = x_left + x_left_offs;
	    y0 = y_high - scrollbar_width;
	    height = scrollbar_width;
	    if ( vertical_scrollbar != 0)
		width = x_right - (x_left + x_left_offs) - scrollbar_width;
	    else
		width = x_right - (x_left + x_left_offs);

	    h_scrollbar = new GrowScrollBar( cmn, "hScrollbar", x0, y0, width, height,
					     Glow.eDir_Horizontal, Glow.eDrawType_Line, 1, display_level, 
					     scrollbar_bg_color, scrollbar_color, 1, this);
	    // h_scrollbar.register_value_changed_cb( (void *)this, &h_value_changed_cb);
	    h_scrollbar.set_range( table_x0 * window_scale, table_x1 * window_scale);
	    h_scrollbar.set_value( table_x0 * window_scale, x_right - (x_left + x_left_offs) - 
				   scrollbar_width * vertical_scrollbar);
	    h_scrollbar.set_shadow( shadow);
	    h_value = table_x0 * window_scale;
	}
	else if ( horizontal_scrollbar == 0 && h_scrollbar != null) {
	    h_scrollbar = null;
	    h_value = table_x0 * window_scale;    
	}
	else if ( h_scrollbar != null) {
	    // Reconfigure lenght and range
	    h_scrollbar.set_value( table_x0 * window_scale, x_right - (x_left + x_left_offs) - 
				   scrollbar_width * vertical_scrollbar);
	    h_value = table_x0 * window_scale;
	    h_scrollbar.set_range( table_x0 * window_scale, table_x1 * window_scale);
	    h_scrollbar.set_shadow( shadow);
	}
	else
	    h_value = table_x0 * window_scale;    
    }

    public void draw(GlowTransform t, int highlight, int hot, Object node, Object colornode) {
	if ( cmn.nodraw != 0)
	    return;

	int idx;
	int drawtype;

	idx = (int)( cmn.mw.zoom_factor_y / cmn.mw.base_zoom_factor * line_width - 1);
	idx += hot;
	idx = Math.max( 0, idx);
	idx = Math.min( idx, Glow.DRAW_TYPE_SIZE-1);

	int text_idx = (int)( cmn.mw.zoom_factor_y / cmn.mw.base_zoom_factor * (text_size +4) - 4);
	double tsize = cmn.mw.zoom_factor_y / cmn.mw.base_zoom_factor * (8+2*text_size);
	text_idx = Math.min( text_idx, Glow.DRAW_TYPE_SIZE-1);
	int header_text_idx = (int)( cmn.mw.zoom_factor_y / cmn.mw.base_zoom_factor * (header_text_size +4) - 4);
	header_text_idx = Math.min( header_text_idx, Glow.DRAW_TYPE_SIZE-1);
	double header_tsize = cmn.mw.zoom_factor_y / cmn.mw.base_zoom_factor * (8+2*header_text_size);

	int ll_x, ll_y, ur_x, ur_y;
	double dx1, dy1, dx2, dy2;

	if (t == null) {
	    dx1 = trf.x( ll.x, ll.y);
	    dy1 = trf.y( ll.x, ll.y);
	    dx2 = trf.x( ur.x, ur.y);
	    dy2 = trf.y( ur.x, ur.y);
	}
	else {
	    dx1 = trf.x( t, ll.x, ll.y);
	    dy1 = trf.y( t, ll.x, ll.y);
	    dx2 = trf.x( t, ur.x, ur.y);
	    dy2 = trf.y( t, ur.x, ur.y);
	}
	dx1 = Math.min( dx1, dx2);
	dx2 = Math.max( dx1, dx2);
	dy1 = Math.min( dy1, dy2);
	dy2 = Math.max( dy1, dy2);

	if ( v_scrollbar != null) {
	    if ( h_scrollbar == null)
		v_scrollbar.set_position( dx2 - scrollbar_width, dy1 + y_low_offs, scrollbar_width, 
					  dy2 - (dy1 + y_low_offs));
	    else
		v_scrollbar.set_position( dx2 - scrollbar_width, dy1 + y_low_offs, scrollbar_width, 
					  dy2 - (dy1 + y_low_offs) - scrollbar_width);
	    v_scrollbar.draw( null, 0, 0, null, null);

	}
	if ( h_scrollbar != null) {
	    if ( v_scrollbar == null)
		h_scrollbar.set_position( dx1 + x_left_offs, dy2 - scrollbar_width, dx2 - (dx1 + x_left_offs),
					  scrollbar_width);
	    else
		h_scrollbar.set_position( dx1 + x_left_offs, dy2 - scrollbar_width, 
					  dx2 - (dx1 + x_left_offs) - scrollbar_width, scrollbar_width);
	    h_scrollbar.draw( null, 0, 0, null, null);
	}

	drawtype = GlowColor.get_drawtype( draw_type, Glow.eDrawType_LineHighlight,
					   highlight, colornode, 0, 0);

	int light_drawtype;
	int dark_drawtype;
	int sel_drawtype;

	dark_drawtype = GlowColor.shift_drawtype( fill_drawtype, 2, null);
	light_drawtype = GlowColor.shift_drawtype( fill_drawtype, -2, null);
	if ( select_drawtype == Glow.eDrawType_Inherit)
	    sel_drawtype = dark_drawtype;
	else
	    sel_drawtype = select_drawtype;

	ll_x = (int)( dx1 * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	ll_y = (int)( dy1 * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	ur_x = (int)( dx2 * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	ur_y = (int)( dy2 * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;

	int o_ll_x = (int)( (dx1 + x_left_offs) * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	int o_ll_y = (int)( (dy1 + y_low_offs) * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	int o_ur_x = (int)( (dx2 - vertical_scrollbar * scrollbar_width) * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	int o_ur_y = (int)( (dy2 - horizontal_scrollbar * scrollbar_width) * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;

	int t_ll_x = o_ll_x - (int)( h_value * cmn.mw.zoom_factor_x);
	int t_ll_y = o_ll_y - (int)( v_value * cmn.mw.zoom_factor_y);;
	int t_ur_x = t_ll_x + (int)( table_x1 * cmn.mw.zoom_factor_x);
	int t_ur_y = t_ll_y + (int)( table_y1 * cmn.mw.zoom_factor_y);

	double x;
	double y;
	int offs;
	int header_h = 0;
	int header_w = 0;
	int text_offs = 10;

	if ( header_row != 0)
	    header_h = (int)(header_row_height * cmn.mw.zoom_factor_y);
	if ( header_column != 0)
	    header_w = (int)(column_width[0] * cmn.mw.zoom_factor_x);

	if ( header_row != 0) {

	    if ( fill != 0)
		cmn.gdraw.fill_rect( ll_x, ll_y, ur_x - ll_x, header_h, fill_drawtype);

	    cmn.gdraw.set_clip_rectangle( ll_x + header_w, ll_y, ur_x, ll_y + header_h);

	    if ( shadow != 0) {
		x = t_ll_x;
		y = ll_y;
		for ( int i = header_column; i < columns + 1; i++) {
		    if ( x > ur_x)
			break;
		    if ( i != header_column)
			cmn.gdraw.line( (int)(x)-1, ll_y, (int)(x)-1, ll_y + header_h, dark_drawtype, 0, 0);
		    if ( i != columns)
			cmn.gdraw.line( (int)(x)+1, ll_y, (int)(x)+1, ll_y + header_h, light_drawtype, 0, 0);
		    x += column_width[i] * cmn.mw.zoom_factor_x;
		}
		cmn.gdraw.line( ll_x, ll_y+1, t_ur_x, ll_y+1, light_drawtype, 0, 0);
		cmn.gdraw.line( ll_x, ll_y+header_h-1, t_ur_x, ll_y+header_h-1, dark_drawtype, 1, 0);
	    }
	    x = t_ll_x;
	    y = ll_y;

	    for ( int i = header_column; i < columns + 1; i++) {
		if ( x > ur_x)
		    break;
		cmn.gdraw.line( (int)(x), ll_y, (int)(x), ll_y + header_h, drawtype, idx, 0);
		x += column_width[i] * cmn.mw.zoom_factor_x;
	    }

	    x = t_ll_x;
	    y = ll_y;

	    for ( int i = header_column; i < columns; i++) {
		if ( header_text_idx >= 0 && !header_text[i].equals("")) {
		    cmn.gdraw.text( (int)(x + text_offs), (int)(y + header_h - 4),
				      header_text[i], header_text_drawtype, header_text_color,
				      header_text_idx, highlight, 0, font, header_tsize, 0);
		}
		x += column_width[i] * cmn.mw.zoom_factor_x;
		if ( x > ur_x)
		    break;
	    }
	    cmn.gdraw.reset_clip_rectangle( );

	    if ( header_w != 0) {
		if ( shadow != 0) {
		    cmn.gdraw.line( ll_x+header_w-1, ll_y, ll_x+header_w-1, ll_y+header_h, dark_drawtype, 1, 0);
		    cmn.gdraw.line( ll_x-1, ll_y+header_h-1, ll_x+header_w, ll_y+header_h-1, dark_drawtype, 1, 0);
		    cmn.gdraw.line( ll_x, ll_y+1, ll_x + header_w, ll_y+1, light_drawtype, 0, 0);
		    cmn.gdraw.line( ll_x+1, ll_y, ll_x+1, ll_y+header_h, light_drawtype, 0, 0);
		}
		cmn.gdraw.line( ll_x+header_w, ll_y, ll_x+header_w, ll_y+header_h, drawtype, idx, 0);
	    }
	    cmn.gdraw.rect( ll_x, ll_y, ur_x - ll_x, header_h, drawtype, idx, 0);

	    if ( header_column != 0) {
		// Draw header of header column header
		x = ll_x;
		y = ll_y;
		if ( header_text_idx >= 0 && !header_text[0].equals(""))
		    cmn.gdraw.text( (int)(x + text_offs), (int)(y + header_h - 4),
				      header_text[0], header_text_drawtype, header_text_color,
				      header_text_idx, highlight, 0, font, tsize, 0);
	    }
	}

	if ( header_column != 0) {

	    if ( fill != 0)
		cmn.gdraw.fill_rect( ll_x, ll_y + header_h, header_w, ur_y - ll_y - header_h, fill_drawtype);

	    cmn.gdraw.set_clip_rectangle( ll_x, ll_y + header_h, ll_x + header_w, ur_y);

	    // Draw selected cell, if cell in header column
	    if ( selected_cell_row >= 0 && selected_cell_column == 0) {
		x = ll_x;
		y = t_ll_y + row_height * cmn.mw.zoom_factor_y * selected_cell_row;
		cmn.gdraw.fill_rect( (int)(x), (int)(y), header_w, (int)(row_height * cmn.mw.zoom_factor_y), sel_drawtype);
	    }

	    if ( shadow != 0) {
		x = ll_x;
		y = t_ll_y;
		for ( int i = 0; i < rows + 1; i++) {
		    if ( y > ur_y)
			break;
		    if ( y > ll_y) {
			if ( i != 0)
			    cmn.gdraw.line( ll_x, (int)(y)-1, ll_x + header_w, (int)(y)-1, dark_drawtype, 0, 0);
			if ( i != rows)
			    cmn.gdraw.line( ll_x, (int)(y)+1, ll_x + header_w, (int)(y)+1, light_drawtype, 0, 0);
		    }
		    y += row_height * cmn.mw.zoom_factor_y;
		}
		cmn.gdraw.line( ll_x+1, ll_y+header_h, ll_x+1, ur_y, light_drawtype, 0, 0);
		cmn.gdraw.line( ll_x+header_w-1, ll_y+header_h, ll_x+header_w-1, ur_y, dark_drawtype, 1, 0);
	    }
	    x = ll_x;
	    y = t_ll_y;

	    for ( int i = 0; i < rows; i++) {
		y += row_height * cmn.mw.zoom_factor_y;
		if ( y - row_height * cmn.mw.zoom_factor_y > ur_y)
		    break;
		if ( y > ll_y) {
		    cmn.gdraw.line( ll_x, (int)(y), ll_x + header_w, (int)(y), drawtype, idx, 0);

		    offs = i;
		    if ( text_idx >= 0 && cell_value[offs] != null && !cell_value[offs].equals("")) {
			int text_x = (int)(x) + text_offs;

			if ( column_adjustment[0] == Glow.eAdjustment_Right ||
			     column_adjustment[0] == Glow.eAdjustment_Center) {
			    int width, height, descent;
			    GlowDimension dim = cmn.gdraw.getTextExtent( cell_value[offs], 
									 text_idx, font, text_drawtype);
			    width = dim.width;
			    height = dim.height;
			    descent = height/4;

			    switch ( column_adjustment[0]) {
			    case Glow.eAdjustment_Left:
				break;
			    case Glow.eAdjustment_Right:
				text_x = (int)(x) + header_w - text_offs - width;
				break;
			    case Glow.eAdjustment_Center:
				text_x = (int)(x + (header_w - width)/2);
				break;
			    }
			}
			cmn.gdraw.text( text_x, (int)(y - 5),
					  cell_value[offs], text_drawtype, text_color_drawtype,
					  text_idx, highlight, 0, font, tsize, 0);
		    }
		}
	    }
	    cmn.gdraw.reset_clip_rectangle();
	    cmn.gdraw.rect( ll_x, ll_y + header_h-1, header_w, ur_y - ll_y - header_h+1, drawtype, idx, 0);
	}

	// Draw table
	if ( fill != 0)
	    cmn.gdraw.fill_rect( o_ll_x, o_ll_y, o_ur_x - o_ll_x, o_ur_y - o_ll_y, fill_drawtype);

	cmn.gdraw.set_clip_rectangle( o_ll_x, o_ll_y, o_ur_x, o_ur_y);

	if ( selected_cell_row >= 0 && !(header_column != 0 && selected_cell_column == 0)) {
	    // Draw selected cell, if cell not in header column
	    x = t_ll_x;
	    for ( int i = header_column; i < selected_cell_column; i++)
		x += column_width[i] * cmn.mw.zoom_factor_x;
	    y = t_ll_y + row_height * cmn.mw.zoom_factor_y * selected_cell_row;
	    cmn.gdraw.fill_rect( (int)(x), (int)(y), (int)(column_width[selected_cell_column] * cmn.mw.zoom_factor_x), 
				   (int)(row_height * cmn.mw.zoom_factor_y), sel_drawtype);
	}

	if ( shadow != 0) {
	    x = t_ll_x;
	    y = t_ll_y;

	    for ( int i = header_column; i < columns + 1; i++) {
		if ( x > ur_x)
		    break;
		if ( x > ll_x) {
		    if ( i != header_column)
			cmn.gdraw.line( (int)(x)-1, t_ll_y, (int)(x)-1, t_ur_y, dark_drawtype, 0, 0);
		    if ( i != columns)
			cmn.gdraw.line( (int)(x)+1, t_ll_y, (int)(x)+1, t_ur_y, light_drawtype, 0, 0);
		}
		x += column_width[i] * cmn.mw.zoom_factor_x;
	    }

	    for ( int i = 0; i < rows + 1; i++) {
		if ( y > ur_y)
		    break;
		if ( y > ll_y) {
		    if ( i != 0)
			cmn.gdraw.line( t_ll_x, (int)(y-1), t_ur_x, (int)(y)-1, dark_drawtype, 0, 0);
		    if ( i != rows)
			cmn.gdraw.line( t_ll_x, (int)(y)+1, t_ur_x, (int)(y)+1, light_drawtype, 0, 0);
		}
		y += row_height * cmn.mw.zoom_factor_y;
	    }
	}

	x = t_ll_x;
	y = t_ll_y;

	for ( int i = header_column; i < columns + 1; i++) {
	    if ( x > ur_x)
		break;
	    if ( x > ll_x)
		cmn.gdraw.line( (int)(x), t_ll_y, (int)(x), t_ur_y, drawtype, idx, 0);
	    x += column_width[i] * cmn.mw.zoom_factor_x;
	}

	for ( int i = 0; i < rows + 1; i++) {
	    if ( y > ur_y) 
		break;
	    if ( y > ll_y)
		cmn.gdraw.line( t_ll_x, (int)(y), t_ur_x, (int)(y), drawtype, idx, 0);
	    y += row_height * cmn.mw.zoom_factor_y;
	}

	// Draw text values
	int column_offs = header_column * rows;
	x = t_ll_x;
	int x_border = ll_x - (int)(column_width[0] * cmn.mw.zoom_factor_x);
	for ( int i = header_column; i < columns; i++) {
	    if ( x > ur_x)
		break;

	    if ( x > x_border) {
		// Draw column i
		y = t_ll_y;
		for ( int j = 0; j < rows; j++) {
		    y += row_height * cmn.mw.zoom_factor_y;
		    if ( y - row_height * cmn.mw.zoom_factor_y > ur_y)
			break;

		    if ( (options & mTableOptions_ZeroIfHeader) != 0) {
			// Don't draw the row if the value in the first column is zero
			if ( cell_value[j] == null || cell_value[j].equals(""))
			    continue;
		    }
		    if ( (options & mTableOptions_ZeroIfHeaderIs0) != 0) {
			// Don't draw the row if the value in the first column is zero
			if ( cell_value[j] == null || cell_value[j].equals("0"))
			    continue;
		    }

		    if ( y > ll_y) {
			offs = column_offs + j;
			if ( text_idx >= 0 && cell_value[offs] != null && !cell_value[offs].equals("")) {
			    int text_x = (int)(x) + text_offs;

			    if ( column_adjustment[i] == Glow.eAdjustment_Right ||
				 column_adjustment[i] == Glow.eAdjustment_Center) {
				int width, height, descent;
				GlowDimension dim = cmn.gdraw.getTextExtent( cell_value[offs], 
									     text_idx, font, text_drawtype);
				width = dim.width;
				height = dim.height;
				descent = height/4;

				switch ( column_adjustment[i]) {
				case Glow.eAdjustment_Left:
				    break;
				case Glow.eAdjustment_Right:
				    text_x = (int)(x + column_width[i] * cmn.mw.zoom_factor_x) - text_offs - width;
				    break;
				case Glow.eAdjustment_Center:
				    text_x = (int)(x + (column_width[i] * cmn.mw.zoom_factor_x - width)/2);
				    break;
				}
			    }

			    cmn.gdraw.text( text_x, (int)(y - 5),
					    cell_value[offs], text_drawtype, text_color_drawtype,
					    text_idx, highlight, 0, font, tsize, 0);
			}
		    }
		}
	    }
	    x += column_width[i] * cmn.mw.zoom_factor_x;
	    column_offs += rows;
	}

	cmn.gdraw.reset_clip_rectangle();


	// Draw frame
	cmn.gdraw.rect( o_ll_x, o_ll_y, ur_x - o_ll_x, ur_y - o_ll_y, drawtype, idx, 0);
	if ( input_focus != 0) {
	    cmn.gdraw.line( ll_x - 2, ll_y - 2, ll_x - 2, ur_y + 2, Glow.eDrawType_DarkGray, 0, 0);
	    cmn.gdraw.line( ll_x - 2, ll_y - 2, ur_x + 2, ll_y - 2, Glow.eDrawType_DarkGray, 0, 0);
	    cmn.gdraw.line( ll_x - 2, ur_y + 2, ur_x + 2, ur_y + 2, Glow.eDrawType_LightGray, 0, 0);
	    cmn.gdraw.line( ur_x + 2, ll_y - 2, ur_x + 2, ur_y + 2, Glow.eDrawType_LightGray, 0, 0);
	}
    }

    public Object getUserData() {
	return userdata;
    }

    public void verticalScrollValueChanged(double value) {
	if ( v_value != value) {
	    v_value = value;
	    draw();
	}
    }

    public void horizontalScrollValueChanged(double value) {
	if ( h_value != value) {
	    h_value = value;
	    draw();
	}
    }

    public int eventHandler( GlowEvent event, double fx, double fy) {
	int sts, v_sts, h_sts;

	v_sts = h_sts = 0;
	if ( v_scrollbar != null)
	    v_sts = v_scrollbar.eventHandler( event, fx, fy);
	if (h_scrollbar != null)
	    h_sts = h_scrollbar.eventHandler( event, fx, fy);
	if ( v_sts != 0 || h_sts != 0) {
	    return 1;
	}

	sts = super.eventHandler( event, fx, fy);
	if ( event.event == Glow.eEvent_ButtonMotion)
	    return 0;

	switch ( event.event) {
	case Glow.eEvent_MB1Click: {
	    int column = -1;
	    int row = -1;

	    // Find out which cell
	    double o_ll_x = x_left + x_left_offs;
	    double o_ll_y = y_low + y_low_offs;
	    double o_ur_x = x_right - vertical_scrollbar * scrollbar_width;
	    double o_ur_y = y_high - horizontal_scrollbar * scrollbar_width;

	    double t_ll_x = o_ll_x - h_value;
	    double t_ll_y = o_ll_y - v_value;

	    if ( o_ll_y <= fy && fy <= o_ur_y) {
		if ( header_column != 0 &&
		     x_left <= fx && fx <= x_left + x_left_offs)
		    column = 0;
		else if ( o_ll_x <= fx && fx <= o_ur_x) {
		    double column_x_right = t_ll_x;
		    for ( int i = header_column; i < columns; i++) {
			column_x_right += column_width[i];
			if ( fx <= column_x_right) {
			    column = i;
			    break;
			}
		    }
		}
		double row_y_high = t_ll_y;
		for ( int i = 0; i < rows; i++) {
		    row_y_high += row_height;
		    if ( fy <= row_y_high) {
			row = i;
			break;
		    }
		}
	    }

	    if ( row != -1 && column != -1)
		cmn.ctx.send_table_callback( this, event.event, fx, fy, column, row);
	    break;
	}
	default: ;
	}

	return sts;
    }

    public GlowTableInfo getTableInfo() {
	GlowTableInfo info = new GlowTableInfo();

	info.columns = columns;
	info.rows = rows;
	for ( int i = 0; i < Glow.TABLE_MAX_COL; i++)
	    info.column_size[i] = column_size[i];
	return info;
    }

    public void setTableInfo(GlowTableInfo info) {
	columns = info.columns;
	rows = info.rows;
	for ( int i = 0; i < Glow.TABLE_MAX_COL; i++)
	    column_size[i] = info.column_size[i];	
    }

    public void setValue(String value, int col, int row) {
	cell_value[col * rows + row] = value;
    }

    public void setSelectedCell( int column, int row) {
	if ( selected_cell_column == column &&
	     selected_cell_row == row)
	    return;

	if ( column >= columns || row >= rows)
	    return;

	selected_cell_column = column;
	selected_cell_row = row;
	draw();
    }

    public int getSelectedCellRow() {
	return selected_cell_row;
    }
    public int getSelectedCellColumn() {
	if ( selected_cell_row == -1)
	    return -1;
	return selected_cell_column;
    }
}
