/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */


package jpwr.jopg;
import jpwr.rt.*;
import java.io.*;
import java.util.*;

public class Graph implements GraphIfc, GrowApplIfc {

    public GrowCmn cmn;
    public GrowCtx ctx;
    public GlowDraw gdraw;
    public GraphApplIfc appl;
    public Gdh gdh;
    public GraphLocalDb ldb;
    public GrowSlider currentSlider;
    public double scan_time = 1;
    public double fast_scan_time = 1;
    public double animation_scan_time = 1;
    int slow_scan_cnt = 0;
    int fast_scan_cnt = 0;
    GrowCmn[] cmnStack = new GrowCmn[10];
    int cmnStackCnt = 0;
    int clickActive = 0;

    public Graph(GraphApplIfc appl, Gdh gdh) {
	this.appl = appl;
	this.gdh = gdh;

	ldb = new GraphLocalDb();
	ctx = new GrowCtx(this);
	gdraw = new GlowDraw();
	cmn = ctx.getCmn();
	cmn.setGdraw(gdraw);
    }

    public int getWidth() {
	return appl.getWidth();
    }
    public int getHeight() {
	return appl.getHeight();
    }
    public Gdh getGdh() {
	return gdh;
    }
    public GraphLocalDb getLdb() {
	return ldb;
    }
    public GrowCtx getCtx() {
	return ctx;
    }
    public GrowCmn getCmn() {
	return cmn;
    }

    public void open(BufferedReader reader) {
	ctx.open( reader);
	animation_scan_time = ctx.cmn.animation_scantime;
	ctx.traceConnect();
    }

    public void traceConnect(GlowArrayElem object) {
	boolean cmn_popped = false;

	// Check if new ctx
	GrowCmn ocmn = (GrowCmn)object.getCmn();

	if ( cmn != ocmn) {
	    cmnPop( ocmn);
	    cmn_popped = true;
	}  

	Dyn dyn = (Dyn)object.getUserData();
	if ( dyn == null) {
	    if ( cmn_popped)
		cmnPush();
	    return;
	}

	if ( object.type() == Glow.eObjectType_GrowNode && dyn != null) {
	    int dyn_type1 = ((GrowNode)object).getClassDynType1();

	    if ( (((dyn_type1 & Dyn.mDynType1_HostObject) != 0 && 
		   (dyn.dyn_type1 & Dyn.mDynType1_Inherit) != 0)) || 
		 (dyn.dyn_type1 & Dyn.mDynType1_HostObject) != 0) {
		Dyn nodeclass_dyn = (Dyn)((GrowNode)object).getClassUserData();
		dyn.setTotal(null);
		if ( nodeclass_dyn != null) {
		    Dyn old_dyn = dyn;
		    dyn = new Dyn( nodeclass_dyn);
		    dyn.merge( old_dyn);
		    if ( old_dyn.cycle != Glow.eCycle_Inherit)
			dyn.cycle = old_dyn.cycle;
		    if ( !(old_dyn.action_type1 == Dyn.mActionType1_Inherit && old_dyn.action_type2 == 0))
			dyn.access = old_dyn.access;
		    object.setUserData( dyn);
		    dyn.setTotal(object);
		}
	    }
	}

	dyn.connect(object);

	if ( cmn_popped)
	    cmnPush();
    }

    public void traceDisconnect(GlowArrayElem object) {
	Dyn dyn = (Dyn)object.getUserData();
	if ( dyn != null)
	    dyn.disconnect();
    }

    public void traceScan(GlowArrayElem object) {
	Dyn dyn = (Dyn)object.getUserData();
	if ( dyn == null)
	    return;
	if ( dyn.cycle == Glow.eCycle_Slow && slow_scan_cnt != 0 &&
	     !((dyn.total_dyn_type1 & Dyn.mDynType1_Animation) != 0 || (dyn.total_dyn_type2 & Dyn.mDynType2_ScrollingText) != 0))
	    return;
	if ( dyn.cycle == Glow.eCycle_Fast && fast_scan_cnt != 0 &&
	     !((dyn.total_dyn_type1 & Dyn.mDynType1_Animation) != 0 || (dyn.total_dyn_type2 & Dyn.mDynType2_ScrollingText) != 0))
	    return;

	dyn.scan(object);
    }

    public void traceScan() {
	
	ctx.traceScan();

	fast_scan_cnt++;
	if ( fast_scan_cnt >= 
	     (int)(fast_scan_time / animation_scan_time + 0.5))
	    fast_scan_cnt = 0;

	slow_scan_cnt++;
	if ( slow_scan_cnt >= 
	     (int)(scan_time / animation_scan_time + 0.5))
	    slow_scan_cnt = 0;
    }

    int stringToType( String str) {
	int idx;
	if ( (idx = str.indexOf('#')) != -1)
	    str = str.substring(0, idx);
	if ( str.equalsIgnoreCase("boolean"))
	    return Pwr.eType_Boolean;
	if ( str.equalsIgnoreCase("float32"))
	    return Pwr.eType_Float32;
	if ( str.equalsIgnoreCase("float64"))
	    return Pwr.eType_Float64;
	if ( str.equalsIgnoreCase("char"))
	    return Pwr.eType_Char;
	if ( str.equalsIgnoreCase("int8"))
	    return Pwr.eType_Int8;
	if ( str.equalsIgnoreCase("int16"))
	    return Pwr.eType_Int16;
	if ( str.equalsIgnoreCase("int32"))
	    return Pwr.eType_Int32;
	if ( str.equalsIgnoreCase("int64"))
	    return Pwr.eType_Int64;
	if ( str.equalsIgnoreCase("uint8"))
	    return Pwr.eType_UInt8;
	if ( str.equalsIgnoreCase("uint16"))
	    return Pwr.eType_UInt16;
	if ( str.equalsIgnoreCase("uint32"))
	    return Pwr.eType_UInt32;
	if ( str.equalsIgnoreCase("uint64"))
	    return Pwr.eType_UInt64;
	if ( str.equalsIgnoreCase("objid"))
	    return Pwr.eType_Objid;
	if ( str.equalsIgnoreCase("time"))
	    return Pwr.eType_Time;
	if ( str.equalsIgnoreCase("deltatime"))
	    return Pwr.eType_DeltaTime;
	if ( str.equalsIgnoreCase("attrref"))
	    return Pwr.eType_AttrRef;
	if ( str.equalsIgnoreCase("status"))
	    return Pwr.eType_Status;
	if ( str.equalsIgnoreCase("netstatus"))
	    return Pwr.eType_NetStatus;
	if ( str.equalsIgnoreCase("enum"))
	    return Pwr.eType_Enum;
	if ( str.equalsIgnoreCase("mask"))
	    return Pwr.eType_Mask;
	if ( str.equalsIgnoreCase("bit"))
	    return GraphIfc.eType_Bit;
	if ( str.length() >= 6 && str.substring(0,6).equalsIgnoreCase("string"))
	     return Pwr.eType_String;
	return 0;
    }

    int stringToIndex( String str) {
	int idx1, idx2;
	int index;

	if ( (idx1 = str.indexOf('[')) != -1 &&
	     (idx2 = str.indexOf(']')) != -1 &&
	     idx2 > idx1) {
	    try {
		index = new Integer(str.substring(idx1+1, idx2)).intValue();
	    }
	    catch( NumberFormatException e) {
		System.out.println("stringToIndex: Element syntax error, " + str);
		return 1;
	    }
	    return index;
	}
	return 1;
    }

    public DynParsedAttrName parseAttrName( String name) {
	return parseAttrName( name, 0);
    }

    public DynParsedAttrName parseAttrName( String name, int options) {
	if ( name == null)
	    return null;

	int idx, tidx, eidx;
	DynParsedAttrName pname = new DynParsedAttrName();

	String str = name.trim();
  	
	if ( (idx = str.indexOf("$local.")) != -1) {
	    if ( (tidx = str.indexOf('#')) == -1)
		pname.name = str.substring(idx+1);
	    else {
		pname.name = str.substring(idx+7, tidx);
		String type = str.substring(tidx);
		if ( type.equals("##Float32"))
		    pname.type = Pwr.eType_Float32;
		else if ( type.equals("##Float64"))
		    pname.type = Pwr.eType_Float64;
		else if ( type.equals("##Int32"))
		    pname.type = Pwr.eType_Int32;
		else if ( type.equals("##Boolean"))
		    pname.type = Pwr.eType_Boolean;
		else
		    pname.type = Pwr.eType_String;
	    }
	    if ( str.startsWith("!")) {
		str = str.substring(1);
		str = str.trim();
		pname.inverted = true;
	    }
	    else
		pname.inverted = false;

	    pname.database = GraphIfc.eDatabase_Local;
	    pname.tname = new String(name);
	    return pname;
	}

	if ( (idx = str.indexOf("$ccm.")) != -1) {
	    if ( (tidx = str.indexOf('#')) == -1)
		pname.name = str.substring(idx+1);
	    else {
		pname.name = str.substring(idx+5, tidx);
		String type = str.substring(tidx);
		if ( type.equals("##Float32"))
		    pname.type = Pwr.eType_Float32;
		else if ( type.equals("##Int32"))
		    pname.type = Pwr.eType_Int32;
		else if ( type.equals("##Boolean"))
		    pname.type = Pwr.eType_Boolean;
		else
		    pname.type = Pwr.eType_String;
	    }
	    if ( str.startsWith("!")) {
		str = str.substring(1);
		str = str.trim();
		pname.inverted = true;
	    }
	    else
		pname.inverted = false;

	    pname.database = GraphIfc.eDatabase_Ccm;
	    pname.tname = new String(pname.name);
	    return pname;
	}


	for ( int i = 0; i < 4; i++) {
	    if ( (idx = str.indexOf("$object")) != -1) {
		if ( appl != null) {
		    String oname = cmn.getOwner();
		    str = str.substring(0, idx) + oname + str.substring(idx+7);
		}
	    }
	    else
		break;
	}

	if ( (options & GraphIfc.mParseOpt_KeepIndex) == 0) {
	    // Translate index variable
	    for ( int i = 0; i < 4; i++) {
		if ( (idx = str.indexOf("[&(")) != -1) {
		    String iname = str.substring(idx+3);
		    int idx2 = iname.indexOf(')');
		    if ( idx2 != -1) {
			String rest = iname.substring( idx2 + 1);
			iname = iname.substring( 0, idx2);
			
			CdhrInt ret = getGdh().getObjectInfoInt( iname);
			if ( ret.evenSts()) break;
			
			str = str.substring( 0, idx + 1) + ret.value + rest;
		    }
		    else
			break;
		}
		else
		    break;
	    }
	}

	for ( int i = 0; i < 4; i++) {
	    // Remove attribute before
	    if ( (idx = str.indexOf(".<")) != -1) {
		String rest = str.substring( idx + 2);
		int idx2 = str.lastIndexOf( '.', idx - 2);
		if ( idx2 != -1)
		    str = str.substring( 0, idx2) + rest;
		else
		    break;
	    }
	    else
		break;
	}

	for ( int i = 0; i < 4; i++) {
	    // Remove segment name before
	    if ( (idx = str.indexOf("-<")) != -1) {
		String rest = str.substring( idx + 2);
		int idx2 = str.lastIndexOf( '-', idx - 2);
		if ( idx2 != -1)
		    str = str.substring( 0, idx2) + rest;
		else
		    break;
	    }
	    else
		break;
	}
	

	pname.tname = new String(str);
	
	if ( (idx = str.indexOf('[')) == -1) {
	    if ((eidx = str.lastIndexOf('#')) != -1 &&
		str.charAt(eidx-1) != '#') {
		try {
		    pname.elements = new Integer(str.substring(eidx+1)).intValue();
		}
		catch( NumberFormatException e) {
		    System.out.println("parseAttrName: Element syntax error, " + str);
		    pname.elements = 1;
		}
		str = str.substring(0, eidx);
	    }
	    else
		pname.elements = 1;
	}	    
	else {
	    if ( (options & GraphIfc.mParseOpt_KeepIndex) == 0 || str.indexOf("[&(") == -1)
		pname.index = stringToIndex(str);
	    pname.elements = 1;
	    // if ((eidx = str.lastIndexOf('#')) != -1 &&
	    //	str.charAt(eidx-1) != '#')
	    //	str = str.substring( 0, eid);
	    // else
	    //	str = str.substring(0, idx-1);
	}

	if ( (tidx = str.indexOf("##")) != -1) {
	    if ( str.toLowerCase().startsWith("bit", tidx+2)) {
		String typestr = str.substring(tidx+2);
		int bit = stringToIndex(str);
		pname.bitmask = 1 << bit;
		str = str.substring(0, tidx+5);
	    }

	    pname.type = stringToType( str.substring(tidx+2));
	    str = str.substring(0, tidx);
	}
	else
	    pname.type = 0;

	if ( str.startsWith("!")) {
	    str = str.substring(1);
	    str = str.trim();
	    pname.inverted = true;
	    pname.tname = pname.tname.substring(1);
	    pname.tname = pname.tname.trim();
	}
	else
	    pname.inverted = false;

	pname.database = Graph.eDatabase_Gdh;
	pname.name = str;

	if ( Dyn.debug)
	    System.out.println( "ParsedName: " + name + "    " + pname.name + " type: " + pname.type + " elements: " + pname.elements + " bitm: " + pname.bitmask);

	return pname;
    }

    public String getCommand(String cmd) {

	String str = new String(cmd);
	int idx;

	while ( (idx = str.indexOf("$object")) != -1) {
	    if ( appl != null) {
		// String oname = appl.getObject();
		String oname = cmn.getOwner();
		str = str.substring(0, idx) + oname + str.substring(idx+7);
	    }
	}
	return str;
    }

    public GdhrRefObjectInfo refObjectInfo( String attributeName) {
	String str = new String(attributeName);
	int idx;

	// Replace references
	if ( (idx = str.indexOf("&(")) != -1) {	
	    String ref_name;
	    String end;
	    CdhrString ret;
	    int idx2;

	    if ( str.substring(idx+2).startsWith("&(")) {
		idx2 = str.indexOf(")");
		if ( idx2 == -1)
		    return null;
		ref_name = str.substring( idx + 4, idx2);
		
		end = str.substring( idx2 + 1);
		ret = getGdh().getObjectInfoString( ref_name);
		if ( ret.evenSts()) return null;

		str = str.substring(0, idx+2) + ret.str + end;
	    }	    
	    
	    idx2 = str.lastIndexOf(")");
	    if ( idx2 == -1)
		return null;
    
	    ref_name = str.substring( idx + 2, idx2);

	    end = str.substring( idx2 + 1);
	    ret = getGdh().getObjectInfoString( ref_name);	    
	    if ( ret.evenSts()) return null;
	    
	    str = str.substring(0, idx) + ret.str + end;

	}
	return getGdh().refObjectInfo(str);
    }

    public int getRefUpdate( String in, String ref_name[], int ref_tid[], int ref_size[],
			     String idx_ref_name[], int idx_ref_tid[], int idx_ref_size[],
			     int ref_cnt[], Object dyn) {
	int idx, lidx;
	ref_cnt[0] = 0;
	ref_cnt[1] = 0;
	
	String str = new String( in);

	// Get index variable and replace 
	for ( int i = 0; i < 2; i++) {
	    if ( (idx = str.indexOf("[&(")) != -1) {
		String iname = str.substring(idx+3);
		int idx2 = iname.indexOf(')');
		if ( idx2 != -1) {
		    String rest = iname.substring( idx2 + 1);
		    iname = iname.substring( 0, idx2);
		    idx_ref_name[ref_cnt[1]] = iname;
		    ref_cnt[1]++;
		    
		    CdhrInt ret = getGdh().getObjectInfoInt( iname);
		    if ( ret.evenSts()) return 0;
		    
		    str = str.substring( 0, idx + 1) + ret.value + rest;
		}
		else
		    break;
	    }
	    else
		break;
	}
	
	// Get reference
	if ( (idx = str.indexOf("&(")) != -1) {	
	    if ( str.substring(idx+2).startsWith("&(")) {
		int idx2 = str.indexOf(")");
		if ( idx2 == -1)
		    return 0;
		ref_name[ref_cnt[0]] = str.substring( idx + 4, idx2);

		CdhrAttrRef attrRef = getGdh().nameToAttrRef(ref_name[ref_cnt[0]]);
		if ( attrRef.oddSts()) {
		    CdhrTypeId cdhrTypeId = getGdh().getAttrRefTid( attrRef.aref );
		    ref_tid[ref_cnt[0]] = cdhrTypeId.getTypeId();
		}
		ref_cnt[0]++;
		
		String end = str.substring( idx2 + 1);
		CdhrString ret = getGdh().getObjectInfoString( ref_name[ref_cnt[0]-1]);
		if ( ret.evenSts()) return 0;

		str = str.substring(0, idx+2) + ret.str + end;
	    }	    
	    
	    int idx2 = str.lastIndexOf(")");
	    if ( idx2 == -1)
		return 0;
    
	    ref_name[ref_cnt[0]] = str.substring( idx + 2, idx2);

	    CdhrAttrRef attrRef = getGdh().nameToAttrRef(ref_name[ref_cnt[0]]);
	    if ( attrRef.oddSts()) {
		CdhrTypeId cdhrTypeId = getGdh().getAttrRefTid( attrRef.aref );
		ref_tid[ref_cnt[0]] = cdhrTypeId.getTypeId();
	    }
	    ref_cnt[0]++;
	}

	for ( int i = 0; i < 4; i++) {
	    // Remove attribute before
	    if ( (idx = str.indexOf(".<")) != -1) {
		String rest = str.substring( idx + 2);
		int idx2 = str.lastIndexOf( '.', idx - 2);
		if ( idx2 != -1)
		    str = str.substring( 0, idx2) + rest;
		else
		    break;
	    }
	    else
		break;
	}
    
	for ( int i = 0; i < 4; i++) {
	    // Remove segment name before
	    if ( (idx = str.indexOf("-<")) != -1) {
		String rest = str.substring( idx + 2);
		int idx2 = str.lastIndexOf( '-', idx - 2);
		if ( idx2 != -1)
		    str = str.substring( 0, idx2) + rest;
		else
		    break;
	    }
	    else
		break;
	}
	
	return 1;
    }


    public Object growUserdataOpen( BufferedReader reader, Object object, int type) {
	switch ( type) {
	case Glow.eUserdataCbType_Ctx:
	    break;
	case Glow.eUserdataCbType_Node: {
	    Dyn dyn = new Dyn(this);
	    dyn.open(reader);
	    return dyn;
	}
	case Glow.eUserdataCbType_NodeClass: {
	    Dyn dyn = new Dyn(this);
	    dyn.open(reader);
	    return dyn;
	}	    
	}
	return null;
    }

    @SuppressWarnings("fallthrough")
    public void eventHandler(GlowEvent e) {
	boolean cmn_popped = false;

	if (e.object_type != Glow.eObjectType_NoObject &&
	    e.object != null) {
	    GrowCmn ocmn = (GrowCmn)((GlowArrayElem)e.object).getCmn();

	    if ( ocmn != null && cmn != ocmn) {
		cmnPop( ocmn);
		cmn_popped = true;
	    }  
	}

	switch ( e.event) {
	case Glow.eEvent_MB1Click:
	    if ( e.object_type == Glow.eObjectType_NoObject ||
		 ((GlowArrayElem)e.object).type() != Glow.eObjectType_GrowMenu) {
		// Close any open menu, if not click in menu
		GlowEventMenu event = new GlowEventMenu();
		event.event = Glow.eEvent_MenuDelete;
		event.type = Glow.eEventType_Menu;
		event.object = null;

		Vector<GlowArrayElem> list = ctx.get_object_list();
		for ( int i = 0; i < list.size(); i++) {
		    GlowArrayElem o = list.get(i);
		    if ( (o.type() == Glow.eObjectType_GrowNode ||
			  o.type() == Glow.eObjectType_GrowGroup) &&
			 (e.object_type == Glow.eObjectType_NoObject ||
			  o != e.object)) {
			Dyn dyn = (Dyn)o.getUserData();
			if ( dyn != null)
			    dyn.action( (GrowNode)o, (GlowEvent)event);
			int old_size = list.size(); 
			list = ctx.get_object_list();
			if ( old_size != list.size())
			    // Something is deleted
			    break;
		    }
		}
	    }
	    // Note! no break
	case Glow.eEvent_MB1Up:
	case Glow.eEvent_MB1Down:
	case Glow.eEvent_MB3Press:
	case Glow.eEvent_ValueChanged:
	case Glow.eEvent_SliderMoveStart:
	case Glow.eEvent_SliderMoveEnd:
	case Glow.eEvent_SliderMoved:
	case Glow.eEvent_Signal:
	    if ( e.object != null) {
		int sts;
		Dyn dyn = (Dyn)((GlowArrayElem)e.object).getUserData();
		if ( dyn != null)
		    sts = dyn.action((GlowArrayElem)e.object, e);	    	    
	    }
	    break;
	case Glow.eEvent_MenuActivated:
	case Glow.eEvent_MenuCreate:
	case Glow.eEvent_MenuDelete: {
	    int		old_size;
	    int		sts;

	    Vector<GlowArrayElem> list = ctx.get_object_list();

	    for ( int i = 0; i < list.size(); i++) {
		GlowArrayElem o = list.get(i);
		if ( o.type() == Glow.eObjectType_GrowNode ||
		     o.type() == Glow.eObjectType_GrowGroup) {
		    		    
		    Dyn dyn = (Dyn)o.getUserData();
		    if ( dyn != null) {
			sts = dyn.action((GrowNode)o, e);
			if ( sts == Glow.GLOW__TERMINATED)
			    return;
		    
			// Check if anything is deleted
			old_size = list.size();
			list = ctx.get_object_list();
			if ( old_size != list.size())
			    break;
		    }
		}
	    }
	    break;
	}
	}
	if ( cmn_popped)
	    cmnPush();
    }

    public Object loadCtx( String file, String owner) {
	return appl.loadGrowCtx( file, owner);
    }

    public Object loadGrowCtx( BufferedReader reader, String owner) {
	GrowCtx ctx = new GrowCtx(this);
	GrowCmn cmn = ctx.getCmn();
	cmn.setOwner(owner);
	cmn.setGdraw(gdraw);
	ctx.open( reader);
	ctx.traceConnect();

	return ctx;
    }

    public int loadSubgraph( BufferedReader reader) {
	return ctx.loadSubgraph( reader);
    }

    public int loadSubgraph( String file) {
	return appl.loadSubgraph( file);
    }

    public int command(String cmd) {
	if ( appl != null)
	    return appl.command(cmd);
	return 0;
    }

    public int script(String script) {
	if ( appl != null)
	    return appl.script(script);
	return 0;
    }

    public void closeGraph() {
	if ( appl != null)
	    appl.closeGraph();
    }

    public void openConfirmDialog(Object dyn, String text, Object object) {
	if ( appl != null)
	    appl.openConfirmDialog(dyn, text, object);
    }

    public void openValueInputDialog(Object dyn, String text, Object object) {
	if ( appl != null)
	    appl.openValueInputDialog(dyn, text, object);
    }

    public void openPopupMenu(String object, double x, double y) {
	if ( appl != null)
	    appl.openPopupMenu(object, x, y);
    }

    public String get_reference_name(String name) {
	// TODO
	return null;
    }

    public GrowSlider getCurrentSlider() {
	return currentSlider;
    }
    public void setCurrentSlider(GrowSlider currentSlider) {
	this.currentSlider = currentSlider;
    }

    public boolean isAuthorized(int access) {
	return appl.isAuthorized(access);
    }

    public void setScanTime( double scan_time) {
	this.scan_time = scan_time;
    }

    public void setFastScanTime( double fast_scan_time) {
	this.fast_scan_time = fast_scan_time;
    }

    public void setAnimationScanTime( double animation_scan_time) {
	this.animation_scan_time = animation_scan_time;
    }

    public double getScanTime() {
	return scan_time;
    }

    public double getFastScanTime() {
	return fast_scan_time;
    }

    public double getAnimationScanTime() {
	if ( scan_time < animation_scan_time)
	    return scan_time;
	return animation_scan_time;
    }

    public void setOwner( String owner) {
	cmn.setOwner( owner);
    }

    public void setSubwindowSource( String name, String source, String owner) {
	GrowCtxIfc ctx = cmn.ctx;
	if ( cmnStackCnt > 0)
	    ctx = cmnStack[cmnStackCnt-1].ctx;
	ctx.setSubwindowSource( name, source, owner);
    }

    public void cmnPop( GrowCmn ncmn) {
	if ( cmnStackCnt >= 10) {
	    System.out.println("** Graph cmn stack overflow");
	    return;
	}
	cmnStack[cmnStackCnt++] = cmn;
	cmn = ncmn;
	ctx = (GrowCtx)cmn.ctx;
    }

    public void cmnPush() {
	if ( cmnStackCnt > 0) {
	    cmn = cmnStack[--cmnStackCnt];
	    ctx = (GrowCtx)cmn.ctx;
	}
    }

    public void setClickActive(int active) {
	clickActive = active;
    }

    public int getClickActive() {
	return clickActive;
    }

    public void signalSend( String signalName) {
	ctx.signalSend( signalName);
    }
}
