/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2014 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */


package jpwr.jopg;
import jpwr.rt.*;
import java.io.*;
import java.util.*;

public class Graph implements GraphIfc, GrowApplIfc {


    public GrowCmn cmn;
    public GrowCtx ctx;
    public GlowDraw gdraw;
    public GraphApplIfc appl;
    public Gdh gdh;
    public GraphLocalDb ldb;
    public GrowSlider currentSlider;
    public double scan_time = 1;
    GrowCmn[] cmnStack = new GrowCmn[10];
    int cmnStackCnt = 0;
    int clickActive = 0;

    public Graph(GraphApplIfc appl, Gdh gdh) {
	this.appl = appl;
	this.gdh = gdh;

	ldb = new GraphLocalDb();
	ctx = new GrowCtx(this);
	gdraw = new GlowDraw();
	cmn = ctx.getCmn();
	cmn.setGdraw(gdraw);
    }

    public int getWidth() {
	return appl.getWidth();
    }
    public int getHeight() {
	return appl.getHeight();
    }
    public Gdh getGdh() {
	return gdh;
    }
    public GraphLocalDb getLdb() {
	return ldb;
    }
    public GrowCtx getCtx() {
	return ctx;
    }
    public GrowCmn getCmn() {
	return cmn;
    }

    public void open(BufferedReader reader) {
	ctx.open( reader);
	ctx.traceConnect();
    }

    public void traceConnect(GlowArrayElem object) {
	boolean cmn_popped = false;

	// Check if new ctx
	GrowCmn ocmn = (GrowCmn)object.getCmn();

	if ( cmn != ocmn) {
	    cmnPop( ocmn);
	    cmn_popped = true;
	}  

	Dyn dyn = (Dyn)object.getUserData();
	if ( dyn == null) {
	    if ( cmn_popped)
		cmnPush();
	    return;
	}

	if ( object.type() == Glow.eObjectType_GrowNode && dyn != null) {
	    int dyn_type1 = ((GrowNode)object).getClassDynType1();

	    if ( (((dyn_type1 & Dyn.mDynType1_HostObject) != 0 && 
		   (dyn.dyn_type1 & Dyn.mDynType1_Inherit) != 0)) || 
		 (dyn.dyn_type1 & Dyn.mDynType1_HostObject) != 0) {
		Dyn nodeclass_dyn = (Dyn)((GrowNode)object).getClassUserData();
		dyn.setTotal(null);
		if ( nodeclass_dyn != null) {
		    Dyn old_dyn = dyn;
		    dyn = new Dyn( nodeclass_dyn);
		    dyn.merge( old_dyn);
		    object.setUserData( dyn);
		    dyn.setTotal(object);
		}
	    }
	}
	System.out.println("before connect total_dyn_type1 : " + dyn.total_dyn_type1);

	dyn.connect(object);

	if ( cmn_popped)
	    cmnPush();
    }

    public void traceDisconnect(GlowArrayElem object) {
	Dyn dyn = (Dyn)object.getUserData();
	if ( dyn != null)
	    dyn.disconnect();
    }

    public void traceScan(GlowArrayElem object) {
	Dyn dyn = (Dyn)object.getUserData();
	if ( dyn != null)
	    dyn.scan(object);
    }

    int stringToType( String str) {
	int idx;
	if ( (idx = str.indexOf('#')) != -1)
	    str = str.substring(0, idx);
	System.out.println("type: " + str);
	if ( str.equalsIgnoreCase("boolean"))
	    return Pwr.eType_Boolean;
	if ( str.equalsIgnoreCase("float32"))
	    return Pwr.eType_Float32;
	if ( str.equalsIgnoreCase("float64"))
	    return Pwr.eType_Float64;
	if ( str.equalsIgnoreCase("char"))
	    return Pwr.eType_Char;
	if ( str.equalsIgnoreCase("int8"))
	    return Pwr.eType_Int8;
	if ( str.equalsIgnoreCase("int16"))
	    return Pwr.eType_Int16;
	if ( str.equalsIgnoreCase("int32"))
	    return Pwr.eType_Int32;
	if ( str.equalsIgnoreCase("int64"))
	    return Pwr.eType_Int64;
	if ( str.equalsIgnoreCase("uint8"))
	    return Pwr.eType_UInt8;
	if ( str.equalsIgnoreCase("uint16"))
	    return Pwr.eType_UInt16;
	if ( str.equalsIgnoreCase("uint32"))
	    return Pwr.eType_UInt32;
	if ( str.equalsIgnoreCase("uint64"))
	    return Pwr.eType_UInt64;
	if ( str.equalsIgnoreCase("objid"))
	    return Pwr.eType_Objid;
	if ( str.equalsIgnoreCase("time"))
	    return Pwr.eType_Time;
	if ( str.equalsIgnoreCase("deltatime"))
	    return Pwr.eType_DeltaTime;
	if ( str.equalsIgnoreCase("attrref"))
	    return Pwr.eType_AttrRef;
	if ( str.equalsIgnoreCase("status"))
	    return Pwr.eType_Status;
	if ( str.equalsIgnoreCase("netstatus"))
	    return Pwr.eType_NetStatus;
	if ( str.equalsIgnoreCase("enum"))
	    return Pwr.eType_Enum;
	if ( str.equalsIgnoreCase("mask"))
	    return Pwr.eType_Mask;
	if ( str.equalsIgnoreCase("bit"))
	    return GraphIfc.eType_Bit;
	if ( str.substring(0,6).equalsIgnoreCase("string"))
	     return Pwr.eType_String;
	return 0;
    }

    int stringToElements( String str) {
	int idx1, idx2;
	int elements;

	if ( (idx1 = str.indexOf('[')) != -1 &&
	     (idx2 = str.indexOf(']')) != -1 &&
	     idx2 > idx1) {
	    try {
		System.out.println("Elements: " + str.substring(idx1+1, idx2));
		elements = new Integer(str.substring(idx1+1, idx2)).intValue();
	    }
	    catch( NumberFormatException e) {
		System.out.println("Element syntax error, " + str);
		return 1;
	    }
	    return elements;
	}
	return 1;
    }

    public DynParsedAttrName parseAttrName( String name) {
	if ( name == null)
	    return null;

	int idx, tidx, eidx;
	DynParsedAttrName pname = new DynParsedAttrName();

	String str = name.trim();
  	
	if ( (idx = str.indexOf("$local.")) != -1) {
	    if ( (tidx = str.indexOf('#')) == -1)
		pname.name = str.substring(idx+1);
	    else {
		pname.name = str.substring(idx+7, tidx);
		String type = str.substring(tidx);
		if ( type.equals("##Float32"))
		    pname.type = Pwr.eType_Float32;
		else if ( type.equals("##Float64"))
		    pname.type = Pwr.eType_Float64;
		else if ( type.equals("##Int32"))
		    pname.type = Pwr.eType_Int32;
		else if ( type.equals("##Boolean"))
		    pname.type = Pwr.eType_Boolean;
		else
		    pname.type = Pwr.eType_String;
	    }
	    if ( str.startsWith("!")) {
		str = str.substring(1);
		str = str.trim();
		pname.inverted = true;
	    }
	    else
		pname.inverted = false;

	    pname.database = GraphIfc.eDatabase_Local;
	    pname.tname = new String(name);
	    return pname;
	}

	if ( (idx = str.indexOf("$ccm.")) != -1) {
	    if ( (tidx = str.indexOf('#')) == -1)
		pname.name = str.substring(idx+1);
	    else {
		pname.name = str.substring(idx+5, tidx);
		String type = str.substring(tidx);
		if ( type.equals("##Float32"))
		    pname.type = Pwr.eType_Float32;
		else if ( type.equals("##Int32"))
		    pname.type = Pwr.eType_Int32;
		else if ( type.equals("##Boolean"))
		    pname.type = Pwr.eType_Boolean;
		else
		    pname.type = Pwr.eType_String;
	    }
	    if ( str.startsWith("!")) {
		str = str.substring(1);
		str = str.trim();
		pname.inverted = true;
	    }
	    else
		pname.inverted = false;

	    pname.database = GraphIfc.eDatabase_Ccm;
	    pname.tname = new String(pname.name);
	    return pname;
	}


	if ( (idx = str.indexOf("$object")) != -1) {
	    if ( appl != null) {
		String oname = cmn.getOwner();
		str = str.substring(0, idx) + oname + str.substring(idx+7);
		System.out.println("Parse name $object " + oname + " str " + str);
	    }
	}

	pname.tname = new String(str);
	
	if ( (idx = str.indexOf('[')) != -1 &&
	     (eidx = str.lastIndexOf('#')) != -1 &&
	     str.charAt(eidx-1) != '#') {
	    pname.elements = stringToElements(str);
	    str = str.substring(0, idx-1);
	}
	else
	    pname.elements = 1;

	if ( (tidx = str.indexOf("##")) != -1) {
	    if ( str.toLowerCase().startsWith("bit", tidx+2)) {
		String typestr = str.substring(tidx+2);
		int bit = stringToElements(str);
		pname.bitmask = 1 << bit;
		str =  str.substring(0, tidx+5);
	    }

	    pname.type = stringToType( str.substring(tidx+2));
	    str = str.substring(0, tidx);
	}
	else
	    pname.type = 0;

	if ( str.startsWith("!")) {
	    str = str.substring(1);
	    str = str.trim();
	    pname.inverted = true;
	    pname.tname = pname.tname.substring(1);
	    pname.tname = pname.tname.trim();
	}
	else
	    pname.inverted = false;

	pname.database = Graph.eDatabase_Gdh;
	pname.name = str;

	System.out.println( "ParsedName: " + name + "    " + pname.name + " type: " + pname.type + " elements: " + pname.elements + " bitm: " + pname.bitmask);

	return pname;
    }

    public String getCommand(String cmd) {

	String str = new String(cmd);
	int idx;

	while ( (idx = str.indexOf("$object")) != -1) {
	    if ( appl != null) {
		// String oname = appl.getObject();
		String oname = cmn.getOwner();
		str = str.substring(0, idx) + oname + str.substring(idx+7);
	    }
	}
	return str;
    }

    public Object growUserdataOpen( BufferedReader reader, Object object, int type) {
	switch ( type) {
	case Glow.eUserdataCbType_Ctx:
	    break;
	case Glow.eUserdataCbType_Node: {
	    Dyn dyn = new Dyn(this);
	    dyn.open(reader);
	    return dyn;
	}
	case Glow.eUserdataCbType_NodeClass: {
	    Dyn dyn = new Dyn(this);
	    dyn.open(reader);
	    return dyn;
	}	    
	}
	return null;
    }

    public void eventHandler(GlowEvent e) {
	boolean cmn_popped = false;

	if (e.object_type != Glow.eObjectType_NoObject &&
	    e.object != null) {
	    GrowCmn ocmn = (GrowCmn)((GlowArrayElem)e.object).getCmn();

	    if ( ocmn != null && cmn != ocmn) {
		cmnPop( ocmn);
		cmn_popped = true;
	    }  
	}

	switch ( e.event) {
	case Glow.eEvent_MB1Click:
	    if ( e.object_type == Glow.eObjectType_NoObject ||
		 ((GlowArrayElem)e.object).type() != Glow.eObjectType_GrowMenu) {
		// Close any open menu, if not click in menu
		GlowEventMenu event = new GlowEventMenu();
		event.event = Glow.eEvent_MenuDelete;
		event.type = Glow.eEventType_Menu;
		event.object = null;

		Vector<GlowArrayElem> list = ctx.get_object_list();
		for ( int i = 0; i < list.size(); i++) {
		    GlowArrayElem o = list.get(i);
		    if ( (o.type() == Glow.eObjectType_GrowNode ||
			  o.type() == Glow.eObjectType_GrowGroup) &&
			 (e.object_type == Glow.eObjectType_NoObject ||
			  o != e.object)) {
			Dyn dyn = (Dyn)o.getUserData();
			if ( dyn != null)
			    dyn.action( (GrowNode)o, (GlowEvent)event);
			int old_size = list.size(); 
			list = ctx.get_object_list();
			if ( old_size != list.size())
			    // Something is deleted
			    break;
		    }
		}
	    }
	    // Note! no break
	case Glow.eEvent_MB1Up:
	case Glow.eEvent_MB1Down:
	case Glow.eEvent_MB3Press:
	case Glow.eEvent_ValueChanged:
	case Glow.eEvent_SliderMoveStart:
	case Glow.eEvent_SliderMoveEnd:
	case Glow.eEvent_SliderMoved:
	    if ( e.object != null) {
		int sts;
		Dyn dyn = (Dyn)((GlowArrayElem)e.object).getUserData();
		if ( dyn != null)
		    sts = dyn.action((GrowNode)e.object, e);	    	    
	    }
	    break;
	case Glow.eEvent_MenuActivated:
	case Glow.eEvent_MenuCreate:
	case Glow.eEvent_MenuDelete: {
	    int		old_size;
	    int		sts;

	    Vector<GlowArrayElem> list = ctx.get_object_list();

	    for ( int i = 0; i < list.size(); i++) {
		GlowArrayElem o = list.get(i);
		if ( o.type() == Glow.eObjectType_GrowNode ||
		     o.type() == Glow.eObjectType_GrowGroup) {
		    		    
		    Dyn dyn = (Dyn)o.getUserData();
		    if ( dyn != null) {
			sts = dyn.action((GrowNode)o, e);
			if ( sts == Glow.GLOW__TERMINATED)
			    return;
		    
			// Check if anything is deleted
			old_size = list.size();
			list = ctx.get_object_list();
			if ( old_size != list.size())
			    break;
		    }
		}
	    }
	    break;
	}
	}
	if ( cmn_popped)
	    cmnPush();
    }

    public Object loadCtx( String file) {
	return appl.loadGrowCtx( file);
    }

    public Object loadGrowCtx( BufferedReader reader) {
	GrowCtx ctx = new GrowCtx(this);
	GrowCmn cmn = ctx.getCmn();
	cmn.setGdraw(gdraw);
	ctx.open( reader);
	ctx.traceConnect();

	return ctx;
    }

    public int command(String cmd) {
	if ( appl != null)
	    return appl.command(cmd);
	return 0;
    }

    public void closeGraph() {
	if ( appl != null)
	    appl.closeGraph();
    }

    public void openConfirmDialog(Object dyn, String text, Object object) {
	if ( appl != null)
	    appl.openConfirmDialog(dyn, text, object);
    }

    public void openValueInputDialog(Object dyn, String text, Object object) {
	if ( appl != null)
	    appl.openValueInputDialog(dyn, text, object);
    }

    public void openPopupMenu(String object, double x, double y) {
	if ( appl != null)
	    appl.openPopupMenu(object, x, y);
    }

    public String get_reference_name(String name) {
	// TODO
	return null;
    }

    public GrowSlider getCurrentSlider() {
	return currentSlider;
    }
    public void setCurrentSlider(GrowSlider currentSlider) {
	this.currentSlider = currentSlider;
    }

    public boolean isAuthorized(int access) {
	return appl.isAuthorized(access);
    }

    public double getScanTime() {
	return scan_time;
    }

    public void setOwner( String owner) {
	cmn.setOwner( owner);
    }

    public void setSubwindowSource( String name, String source, String owner) {
	GrowCtxIfc ctx = cmn.ctx;
	if ( cmnStackCnt > 0)
	    ctx = cmnStack[cmnStackCnt-1].ctx;
	ctx.setSubwindowSource( name, source, owner);
    }

    public void cmnPop( GrowCmn ncmn) {
	if ( cmnStackCnt >= 10) {
	    System.out.println("** Graph cmn stack overflow");
	    return;
	}
	cmnStack[cmnStackCnt++] = cmn;
	cmn = ncmn;
	ctx = (GrowCtx)cmn.ctx;
    }

    public void cmnPush() {
	if ( cmnStackCnt > 0) {
	    cmn = cmnStack[--cmnStackCnt];
	    ctx = (GrowCtx)cmn.ctx;
	}
    }

    public void setClickActive(int active) {
	clickActive = active;
    }

    public int getClickActive() {
	return clickActive;
    }
}
