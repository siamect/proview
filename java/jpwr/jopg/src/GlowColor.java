/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jopg;
import jpwr.rt.*;
import java.io.*;
import java.util.*;

public class GlowColor {
    static final double gray_i0 = 0.32;		// Gray min
    static final double gray_i1 = 0.95;		// Gray max

    static class Sat {
	public double s;
	public double i_min;
	public double i_max;
	public double a;
	public Sat() {}
	public Sat(double s, double i_min, double i_max, double a) {
	    this.s = s;
	    this.i_min = i_min;
	    this.i_max = i_max;
	    this.a = a;
	}
    }

    static class Hue {
	public Hue(double h, double hk, Sat[] s) {
	    this.h = h;
	    this.hk = hk;
	    this.s = s;
	}
	public double h;
	public double hk;
	public Sat[]  s;
    }

    static final Hue ctab[] = new Hue[]{
	

	new Hue( 18, -20.0, new Sat[]{new Sat( 0.2, -1.4, 2.8, .9), new Sat( 0.5, -1.4, 3, .9), new Sat(1.5, -3.5, 5.0, 1.0)}),
	new Hue( 28,  10.0, new Sat[]{new Sat( 0.2, -1.4, 2.8, .9), new Sat( 0.5, -1.4, 3, .9), new Sat(1.5, -3.5, 5.0, 1.0)}),  // Yellow
	new Hue( 45,  20.0, new Sat[]{new Sat( 0.2, -1.3, 2.8, .9), new Sat( 0.5, -1.3, 3, .9), new Sat(1.5, -3.5, 4.5, 1.0)}), // Orange
        new Hue( 90,   0.0, new Sat[]{new Sat( 0.2, -1.1, 2.8, .9), new Sat( 0.5, -1.1, 3, .9), new Sat(1.5, -4.5, 4.5, 0.8)}), // Red
        new Hue( 150,  0.0, new Sat[]{new Sat( 0.2, -1.,  2.8, .9), new Sat( 0.5,  -1., 3, .9), new Sat(1.5, -3.5, 5.9, 1.0)}), // Violet
        new Hue( 240,  0.0, new Sat[]{new Sat( 0.2, -1.,  2.8, .9), new Sat( 0.4,  -1., 3, .9), new Sat(1.5, -3.5, 5.5, 0.8)}), // Blue
        new Hue( 280,  0.0, new Sat[]{new Sat( 0.2, -1.,  2.8, .9), new Sat( 0.4,  -1., 3, .9), new Sat(1.5, -3.5, 5.5, 1.2)}), // Seablue
        new Hue( 355,-20.0, new Sat[]{new Sat( 0.2, -1.,  2.8, .9), new Sat( 0.4,  -1., 3, .9), new Sat(1.5, -4.5, 3.5, 1.0)})  // Green
    };

    static class Rgb {
	public double r;
	public double g;
	public double b;
	public Rgb(double r, double g, double b) {
	    this.r = r;
	    this.g = g;
	    this.b = b;
	}
    }

    static Rgb[] rgbtab = new Rgb[] {
	new Rgb( 0.254, 0.329, 0),  // YellowGreen
	new Rgb( 0.357, 0.459, 0),
	new Rgb( 0.498, 0.639, 0),
	new Rgb( 0.624, 0.800, 0),
	new Rgb( 0.764, 0.976, 0),
	new Rgb( 0.808, 1.000, 0.129),
	new Rgb( 0.847, 1.000, 0.310),
	new Rgb( 0.898, 1.000, 0.537),
	new Rgb( 0.933, 1.000, 0.710),
	new Rgb( 0.949, 1.000, 0.776),
	new Rgb( 0., 0., 0),		// Yellow
	new Rgb( 0., 0., 0),
	new Rgb( 0., 0., 0),
	new Rgb( 0., 0., 0),
	new Rgb( 0., 0., 0),
	new Rgb( 0., 0., 0),
	new Rgb( 0., 0., 0),
	new Rgb( 0., 0., 0),
	new Rgb( 0., 0., 0),
	new Rgb( 0., 0., 0),
	new Rgb( 0., 0., 0),		// Orange
	new Rgb( 0., 0., 0),
	new Rgb( 0., 0., 0),
	new Rgb( 0., 0., 0),
	new Rgb( 0., 0., 0),
	new Rgb( 0., 0., 0),
	new Rgb( 1.000, 0.725, 0.420),
	new Rgb( 1.000, 0.796, 0.569),
	new Rgb( 1.000, 0.886, 0.667),
	new Rgb( 1.000, 0.937, 0.820)
	};


    static boolean is_shiftable( int dt) {
      return (dt >= 20 && dt <= Glow.eDrawType_Color300);
    }

    static boolean is_custom( int dt) {
      return (dt >= Glow.eDrawType_CustomColor1 && dt <= Glow.eDrawType_CustomColor__);
    }

    public static int shift_drawtype( int dt, int shift, Object node) {
	int incr;
	int base_drawtype;
	int drawtype;

	if ( node != null && ((GlowColorNode)node).getColorInverse() != 0)
	    shift = - shift;

	if ( is_shiftable(dt)) {
	    base_drawtype = (dt / 10 * 10);
	    incr = shift + dt - base_drawtype;
	    if ( incr < 0)
		drawtype = Glow.eDrawType_Color4; // White
	    else if ( incr >= 10)
		drawtype = Glow.eDrawType_Color30; // DarkGrey
	    else
		drawtype = (base_drawtype + incr);
	}
	else if ( is_custom(dt)) {
	    if ( shift == -1)
		drawtype = (dt + 3);
	    else if ( shift < 0)
		drawtype = (dt + 2);
	    else if ( shift > 0)
		drawtype = (dt + 1);
	    else
		drawtype = dt;
	}
	else
	    drawtype = dt;
	
	return drawtype;
    }

    public static int get_drawtype( int local_drawtype,
			     int highlight_drawtype, int highlight, Object node, 
			     int fill, int highlight_disabled) {
	int drawtype;
	int	base_drawtype;
	int	incr;
	int	lightness = 0;
	int	intensity = 0;

	if ( node != null) {
	    lightness = ((GlowColorNode)node).getColorLightness();
	    intensity = ((GlowColorNode)node).getColorIntensity();
	}

	if ( highlight != 0 && highlight_disabled == 0) {
	    drawtype = highlight_drawtype;
	}
	else if ( highlight != 0 && highlight_disabled != 0 && fill== 0 && local_drawtype == 
		  Glow.eDrawType_Line) {
	    drawtype = highlight_drawtype;
	}
	else {
	    if ( node != null && ((GlowColorNode)node).getColorTone() != Glow.eDrawTone_No) {
		int tone = ((GlowColorNode)node).getColorTone();

		if ( local_drawtype > 30 && local_drawtype < 300) {
		    if ( tone == Glow.eDrawTone_LightGrayHighSaturation)
			drawtype = Glow.eDrawType_Color31; // GrayLow1
		    else if ( tone == Glow.eDrawTone_DarkGrayHighSaturation)
			drawtype = Glow.eDrawType_Color30; // DarkGrey
		    else {
			if ( tone >= Glow.eDrawTone_GrayHighSaturation &&
			     tone < Glow.eDrawTone_GrayLowSaturation) {
			    tone = tone - 27;
			    intensity += 2;
			}
			else if ( tone >= Glow.eDrawTone_GrayLowSaturation) {
			    tone =  tone - 2 * 27;
			    intensity -= 1;
			}
			if ( tone >= Glow.eDrawTone_DarkGray &&
			     tone < Glow.eDrawTone_LightGray) {
			    tone = ( tone - 9);
			    lightness -= 2;
			}
			else if ( tone >= Glow.eDrawTone_LightGray) {
			    tone = tone - 18;
			    lightness += 2;
			}
	  
			drawtype = local_drawtype - local_drawtype / 30 * 30 + 
			    30 * tone;
		    }
		}
		else
		    drawtype = local_drawtype;
	    }
	    else if ( node != null && fill == 1 && ((GlowColorNode)node).getFillDrawtype() != Glow.eDrawType_No) {
		drawtype = ((GlowColorNode)node).getFillDrawtype();
	    }
	    else if ( node != null && fill == 2 && ((GlowColorNode)node).getTextDrawtype() != Glow.eDrawType_No) {
		drawtype = ((GlowColorNode)node).getTextDrawtype();
	    }
	    else if ( node != null && fill == 3 && ((GlowColorNode)node).getBackgroundDrawtype() != Glow.eDrawType_No) {
		drawtype = ((GlowColorNode)node).getBackgroundDrawtype();
	    }
	    else if ( node != null && fill == 0 && ((GlowColorNode)node).getDrawtype() != Glow.eDrawType_No) {
		drawtype = ((GlowColorNode)node).getDrawtype();
	    }
	    else
		drawtype = local_drawtype;

	    if ( node != null && lightness != 0) {
		if ( local_drawtype >= 30 && drawtype < 300) {
		    base_drawtype = drawtype / 10 * 10;
		    incr = -lightness + drawtype - base_drawtype;
		    if ( incr < 0)
			drawtype = Glow.eDrawType_Color4; // White
		    else if ( incr >= 10)
			drawtype = Glow.eDrawType_Color30; // DarkGrey
		    else
			drawtype = base_drawtype + incr;
		}
	    }
	    if ( node != null && intensity != 0) {
		if ( drawtype >= 60) {
		    base_drawtype = drawtype / 30 * 30;
		    incr = drawtype - base_drawtype;
		    drawtype = ( drawtype + Math.min( 2 - incr / 10, intensity) * 10);
		    if ( drawtype < base_drawtype)
			drawtype = ( Glow.eDrawType_Color41 + incr);
		}
	    }
	    if ( node != null && ((GlowColorNode)node).getColorShift() != 0) {
		if ( drawtype >= 60 && drawtype < 300) {
		    incr = ((GlowColorNode)node).getColorShift() - 
			((GlowColorNode)node).getColorShift() / 8 * 8;
		    if ( incr < 0)
			incr += 8;

		    incr = drawtype + incr * 30;
		    if ( incr >= 300)
			incr -= 240;
		    drawtype = incr;
		}
	    }
	    if ( node != null && ((GlowColorNode)node).getColorInverse() != 0) {
		if ( drawtype >= 30 && drawtype < 300)
		    drawtype = drawtype + 10 - 2 * (drawtype % 10) - 1;      
		else if ( is_custom(drawtype)) {
		    if ( (drawtype - Glow.eDrawType_CustomColor1) % 4 == 1)
			drawtype = drawtype + 1;
		    else if ( (drawtype - Glow.eDrawType_CustomColor1) % 4 == 2)
			drawtype = drawtype - 1;
		    else if ( (drawtype - Glow.eDrawType_CustomColor1) % 4 == 3)
			drawtype = drawtype - 2;
		}
	    }
	    if ( node != null && ((GlowColorNode)node).getDimmed() != 0) {
		if ( drawtype == 0)
		    drawtype = 25;
		else if ( 26 <= drawtype && drawtype <= 29)
		    drawtype = ( drawtype - 4);
		else if ( 36 <= drawtype && drawtype <= 39)
		    drawtype = ( drawtype - 4);
		else if ( 46 <= drawtype && drawtype <= 49)
		    drawtype = ( drawtype - 4);
		else if ( 56 <= drawtype && drawtype <= 59)
		    drawtype = ( drawtype - 4);
		else if ( is_custom(drawtype)) {
		    if ( drawtype == Glow.eDrawType_CustomColor37) 
			// Button border color
			drawtype = Glow.eDrawType_CustomColor40;	  
		    if ( drawtype == Glow.eDrawType_CustomColor38)
			// Button text color
			drawtype = Glow.eDrawType_CustomColor39;	  
		}
	    }
	}
	if ( !((drawtype >= 0 && drawtype <= Glow.eDrawType_Color__) || 
	       (drawtype >= Glow.eDrawType_CustomColor1 && drawtype < Glow.eDrawType_CustomColor__))) {
	    System.out.println("** Invalid drawtype : " + drawtype);    
	    drawtype = Glow.eDrawType_Line;
	}
	return drawtype;
    }

    public static GlowColorRgb rgb_color( int idx, GlowCustomColors customcolors) {
	double h1, i1, s1;
	int i, j, k;
	double r = 0;
	double g = 0;
	double b = 0;

  
	if ( idx == 300)
	    idx = 31;

	if ( idx == 3) // White
	    r = g = b = 1.0;
	else if ( idx == 2) // Gray
	    r = g = b = 0.75;
	else if ( idx == 1) { // Red
	    r = 1.0;
	    g = b = 0;
	}
	else if ( idx == 0) // Black
	    r = g = b = 0;
	else if ( idx < 20) {
	    // Sixteen colors of different hue
	    h1 = 360. * (idx - 4) / 16;
	    s1 = 1.5;
	    i1 = 1;
	    return his_to_rgb( h1, i1, s1);
	}
	else if ( idx < 60) {
	    // Four sets of gray
	    double i0 = gray_i0;

	    if ( idx < 30 || (50 <= idx && idx < 60))
		i0 = 0.25;
    
	    r = g = b = i0 + (gray_i1 - i0) * Math.pow( (double)(9 - idx % 10) / 9, 0.9);
	}
	else if ( idx < 300) {
	    i = (idx - 60) / 30;
	    j = (idx - 60 - i * 30) / 10;
	    k = 9 - (idx - 60 - i * 30 - j * 10);
    
	    if ( (i == 0 && j == 2) ||
		 (i == 2 && j == 2 && k > 5)) {
		// Formula doesn't work for yellow...
		r = rgbtab[ i * 10 + k].r;
		g = rgbtab[ i * 10 + k].g;
		b = rgbtab[ i * 10 + k].b;
	    }
	    else {
		s1 = ctab[i].s[j].s;
		i1 = ctab[i].s[j].i_min + (ctab[i].s[j].i_max - ctab[i].s[j].i_min) * 
		    Math.pow((double)(k)/9, ctab[i].s[j].a);
		h1 = ctab[i].h + ctab[i].hk * k / 9;
	
		return his_to_rgb( h1, i1, s1);
	    }
	}
	else if ( idx >= Glow.eDrawType_CustomColor1 && idx < Glow.eDrawType_CustomColor__) {
	    if ( customcolors == null)
		return new GlowColorRgb(1,1,1);
	    else
		return customcolors.get_color(idx);
	}
	return new GlowColorRgb(r, g, b);
    }


    public static GlowColorRgb his_to_rgb( double h, double i, double s) {
	double m1, m2, i1;
	double r, g, b;

	m1 = s * Math.sin( h * Math.PI/180);
	m2 = s * Math.cos( h * Math.PI/180);
	i1 = i / Math.sqrt(3);
	
	r = m1 * 2 / Math.sqrt(6) + i1 / Math.sqrt(3);
	g = - m1 / Math.sqrt(6)  + m2 / Math.sqrt(2) + i1 / Math.sqrt(3);
	b = - m1 / Math.sqrt(6) - m2 / Math.sqrt(2) + i1 / Math.sqrt(3);
	
	r = r / 2 + 0.5;
	g = g / 2 + 0.5;
	b = b / 2 + 0.5;
	if ( r > 1) r = 1;
	if ( r < 0) r = 0;
	if ( g > 1) g = 1;
	if ( g < 0) g = 0;
	if ( b > 1) b = 1;
	if ( b < 0) b = 0;

	return new GlowColorRgb(r, g, b);
    }
}
