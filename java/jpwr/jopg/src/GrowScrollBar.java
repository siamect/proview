/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jopg;
import jpwr.rt.*;
import java.io.*;
import java.util.*;

public class GrowScrollBar extends GrowRect {
    double		max_value;
    double		min_value;
    double		bar_value;
    double		bar_length;
    Object		user_data;
    int			direction;
    int			movement_active;
    double		start_pos;
    double		start_value;
    GrowScrollBarIfc	parent;
    //    void			(*value_changed_cb)( void *, double); //!< Callback when value is changed
    int			bar_color;
    int hot;
    int highlight;

    public GrowScrollBar( GrowCmn cmn, String name, double x, double y, 
			  double w, double h, int dir, int border_d_type, int line_w, 
			  int display_lev,
			  int fill_d_type, int bar_d_type, int nodraw, GrowScrollBarIfc parent) {
	super(cmn, name, x, y, w, h, border_d_type, line_w, 1, 1, 0, fill_d_type);
	this.bar_color = bar_d_type;
	this.direction = dir;
	this.parent = parent;
	if ( nodraw != 0)
	    draw( null, highlight, hot, null, null);
    }


    public void draw( GlowTransform t, int highlight, int hot, Object node, Object colornode) {
	if ( cmn.nodraw != 0)
	    return;

	int idx;

	idx = (int)( cmn.mw.zoom_factor_y / cmn.mw.base_zoom_factor * line_width - 1);
	idx += hot;

	idx = Math.max( 0, idx);
	idx = Math.min( idx, Glow.DRAW_TYPE_SIZE-1);
	int x1, y1, x2, y2, ll_x, ll_y, ur_x, ur_y;
	int x0 = 0, y0 = 0, width = 0, height = 0;

	if (t == null) {
	    x1 = (int)( trf.x( ll.x, ll.y) * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	    y1 = (int)( trf.y( ll.x, ll.y) * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	    x2 = (int)( trf.x( ur.x, ur.y) * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	    y2 = (int)( trf.y( ur.x, ur.y) * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	}
	else {
	    x1 = (int)( trf.x( t, ll.x, ll.y) * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	    y1 = (int)( trf.y( t, ll.x, ll.y) * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	    x2 = (int)( trf.x( t, ur.x, ur.y) * cmn.mw.zoom_factor_x) - cmn.mw.offset_x;
	    y2 = (int)( trf.y( t, ur.x, ur.y) * cmn.mw.zoom_factor_y) - cmn.mw.offset_y;
	}

	ll_x = Math.min( x1, x2);
	ur_x = Math.max( x1, x2);
	ll_y = Math.min( y1, y2);
	ur_y = Math.max( y1, y2);

	int fdrawtype = GlowColor.get_drawtype( fill_drawtype, Glow.eDrawType_FillHighlight,
						highlight, colornode, 1, 0);
	int bdrawtype = GlowColor.get_drawtype( draw_type, Glow.eDrawType_LineHighlight,
						highlight, colornode, 0, 0);
	int shift_drawtype;

	//	System.out.println("ScrollBar bdraw: (" + ll_x + "," + ll_y + ") w: " + (ur_x-ll_x) + " h: " + (ur_y-ll_y) + " color: " + fdrawtype);
	cmn.gdraw.fill_rect( ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, fdrawtype);
	if ( shadow != 0) {
	    shift_drawtype = GlowColor.shift_drawtype( fill_drawtype, 2, null); // Dark
	    cmn.gdraw.line( ll_x+1, ll_y+1, ll_x+1, ur_y-1, shift_drawtype, 0, 0);
	    cmn.gdraw.line( ll_x+1, ll_y+1, ur_x-1, ll_y+1, shift_drawtype, 0, 0);
	    shift_drawtype = GlowColor.shift_drawtype( fill_drawtype, -2, null); // Light
	    cmn.gdraw.line( ll_x+1, ur_y-1, ur_x-1, ur_y-1, shift_drawtype, 0, 0);
	    cmn.gdraw.line( ur_x-1, ll_y+1, ur_x-1, ur_y-1, shift_drawtype, 0, 0);
	}
 
	if ( max_value != min_value) {

	    switch ( direction) {
	    case Glow.eDir_Vertical:
		height = (int)( bar_length / (max_value - min_value) 
			      * (ur_y - ll_y));
		height = Math.max( 0, Math.min( height, ur_y - ll_y));
		width = ur_x - ll_x;
		x0 = ll_x;
		y0 = ll_y + (int)( (bar_value - min_value) / (max_value - min_value) * (ur_y - ll_y));
		break;
	    case Glow.eDir_Horizontal:
		width = (int)( bar_length / (max_value - min_value) * 
			     (ur_x - ll_x));
		//		System.out.println("ScrollBar hdraw: bar_len: " + bar_length + " len: " + (max_value - min_value));
		width = Math.max( 0, Math.min( width, ur_x - ll_x));
		height = ur_y - ll_y;
		x0 = ll_x + (int)( (bar_value - min_value) / (max_value - min_value) * (ur_x - ll_x));
		y0 = ll_y;
		break;
	    }
	    //	    System.out.println("ScrollBar fdraw: (" + x0 + "," + y0 + ") w: " + width + " h: " + height + " color: " + bar_color);
	    cmn.gdraw.fill_rect( x0, y0, width, height, bar_color);
	    if ( shadow != 0) {
		shift_drawtype = GlowColor.shift_drawtype( bar_color, -2, null); // Light
		cmn.gdraw.line( x0+1, y0+1, x0+1, y0+height-1, shift_drawtype, 0, 0);
		cmn.gdraw.line( x0+1, y0+1, x0+width-1, y0+1, shift_drawtype, 0, 0);
		shift_drawtype = GlowColor.shift_drawtype( bar_color, 2, null); // Dark
		cmn.gdraw.line( x0+1, y0+height-1, x0+width-1, y0+height-1, shift_drawtype, 0, 0);
		cmn.gdraw.line( x0+width-1, y0+1, x0+width-1, y0+height-1, shift_drawtype, 0, 0);
	    }
	    cmn.gdraw.rect( x0, y0, width, height, bdrawtype, idx, 0);
	}

	cmn.gdraw.rect( ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, bdrawtype, idx, 0);
    }

    public double set_value( double value, double length) {
	bar_value = value; 
	if ( length != 0)
	    bar_length = length;

	if ( bar_value < min_value)
	    bar_value = min_value;
	if ( bar_value > max_value - bar_length)
	    bar_value = max_value - bar_length;
	System.out.println("ScrollBar: set_range " + value + " " + length + "min/max " + min_value + " " + max_value);

	draw();
	return bar_value;
    }

    public int eventHandler( GlowEvent event, double fx, double fy) {
	double ll_x, ur_x, ll_y, ur_y;

	ll_x = Math.min( ll.x, ur.x);
	ur_x = Math.max( ll.x, ur.x);
	ll_y = Math.min( ll.y, ur.y);
	ur_y = Math.max( ll.y, ur.y);

	if ( movement_active == 0 &&
	     !( ll_x <= fx && fx <= ur_x &&
		ll_y <= fy && fy <= ur_y))
	    return 0;

	if ( event.event == Glow.eEvent_ButtonMotion &&
	     movement_active == 0)
	    return 0;

	if ( min_value == max_value)
	    return 1;

	switch ( event.event){
	case Glow.eEvent_MB1Down:
	    switch ( direction) {
	    case Glow.eDir_Vertical:
		if ( ll_y + (bar_value - min_value) / (max_value - min_value) * (ur_y - ll_y) <= fy &&
		     fy <= ll_y + (bar_value - min_value + bar_length) / (max_value - min_value) * (ur_y - ll_y)) {
		    start_pos = fy;
		    start_value = bar_value;
		    movement_active = 1;
		    cmn.ctx.setSliderActive(true);
		}
		break;
	    case Glow.eDir_Horizontal:
		if ( ll_x + (bar_value - min_value) / (max_value - min_value) * (ur_x - ll_x) <= fx &&
		     fx <= ll_x + (bar_value - min_value + bar_length) / (max_value - min_value) * (ur_x - ll_x)) {
		    start_pos = fx;
		    start_value = bar_value;
		    movement_active = 1;
		    cmn.ctx.setSliderActive(true);
		}
		break;
	    }
	    break;
	case Glow.eEvent_MB1Up:
	    movement_active = 0;
	    cmn.ctx.setSliderActive(false);
	    break;
	case Glow.eEvent_ButtonMotion:
	    if ( movement_active != 0) {
		if ( bar_length >= max_value - min_value)
		    break;
		switch ( direction) {
		case Glow.eDir_Vertical:
		    bar_value = start_value + (fy - start_pos) / (ur_y - ll_y) * (max_value - min_value);
		    if ( bar_value < min_value) 
			bar_value = min_value;
		    if ( bar_value > max_value - bar_length)
			bar_value = max_value - bar_length;
		    parent.verticalScrollValueChanged( bar_value);
		    break;
		case Glow.eDir_Horizontal:
		    bar_value = start_value + (fx - start_pos) / (ur_x - ll_x) * (max_value - min_value);
		    if ( bar_value < min_value) 
			bar_value = min_value;
		    if ( bar_value > max_value - bar_length)
			bar_value = max_value - bar_length;
		    parent.horizontalScrollValueChanged( bar_value);
		    break;
		}
	    }
	    break;
	default: ;
	}
	return 1;
    }

    public void set_range( double min, double max) { 
	max_value = max;
	min_value = min;
	draw();
    }

    public void set_shadow(int shadow) {
	this.shadow = shadow;
    }

    public void set_position( double x, double y, double width, double height) { 
	ll.posit(x,y); 
	ur.posit(x+width,y+height);
    }
}
