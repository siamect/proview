/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

package jpwr.jopg;
import jpwr.rt.*;
import java.io.*;
import java.util.*;

public class GrowXYCurve extends GrowTrend {

    public GrowXYCurve(GrowCmn cmn) {
	super(cmn);
    }

    public GrowXYCurve( GrowCmn cmn, String n_name, double x, double y, 
		    double w, double h, int draw_type, int line_width, 
		    int fill, int border, int shadow,
		    int fill_drawtype) {
	super(cmn, n_name, x, y, w, h, draw_type, line_width, fill, border, shadow, fill_drawtype);
    }

    public int type() {
	return Glow.eObjectType_GrowXYCurve;
    }

    public void open(BufferedReader reader) {
	String line;
	StringTokenizer token;
	boolean end_found = false;

	try {
	    while( (line = reader.readLine()) != null) {
		token = new StringTokenizer(line);
		int key = Integer.valueOf(token.nextToken());
		if ( cmn.debug) System.out.println( "GrowXYCurve : " + line);

		switch ( key) {

		case Glow.eSave_GrowXYCurve: 
		    break;

		case Glow.eSave_GrowXYCurve_trend_part: 
		    super.open( reader);
		    break;

		case Glow.eSave_End:
		    end_found = true;
		    break;
		default:
		    System.out.println( "Syntax error in GrowXYCurve");
		    break;
		}
		if ( end_found)
		    break;
	    }
		
	} catch ( Exception e) {
	    System.out.println( "IOException GrowXYCurve");
	}
    }    



    public void set_xy_range_x( int curve, double min, double max) {
	if ( curve > Glow.TREND_MAX_CURVES || curve < 0)
	    return;
	if ( curve == 0) {
	    if ( display_x_mark1 != 0) {
		double mark = (x_mark1 - ll.x) * (x_max_value[0] - x_min_value[0]) / (ur.x - ll.x) +  x_min_value[0];
		x_mark1 = ll.x + (mark - min) / (max - min) * (ur.x - ll.x);
	    }
	    if ( display_x_mark2 != 0) {
		double mark = (x_mark2 - ll.x) * (x_max_value[0] - x_min_value[0]) / (ur.x - ll.x) +  x_min_value[0];
		x_mark2 = ll.x + (mark - min) / (max - min) * (ur.x - ll.x);
	    }
	}
	x_max_value[curve] = max;
	x_min_value[curve] = min;
    }

    public void set_xy_range_y( int curve, double min, double max) {
	if ( curve > Glow.TREND_MAX_CURVES || curve < 0)
	    return;

	if ( curve == 0) {
	    if ( display_y_mark1 != 0) {
		double mark = y_min_value[0] - (y_mark1 - ur.y) *(y_max_value[0] - y_min_value[0]) / (ur.y - ll.y);
		y_mark1 = ur.y - (mark - min) / (max - min) * (ur.y - ll.y);
	    }
	    if ( display_y_mark2 != 0) {
		double mark = y_min_value[0] - (y_mark2 - ur.y) *(y_max_value[0] - y_min_value[0]) / (ur.y - ll.y);
		y_mark2 = ur.y - (mark - min) / (max - min) * (ur.y - ll.y);
	    }
	}

	y_max_value[curve] = max;
	y_min_value[curve] = min;
    }

    public void set_xy_noofcurves( int noofcurves) {
	curve_cnt = noofcurves;
    }

    public void set_xy_curve_color( int curve, int curve_color,
				    int fill_color) {
	if ( curve > Glow.TREND_MAX_CURVES || curve < 0)
	    return;
	curve_drawtype[curve] = curve_color;
	curve_fill_drawtype[curve] = fill_color;
    }

    public void set_xy_data( double[] y_data, double[] x_data, int curve_idx, int data_points) {
	int dt, dt_fill;
	int points;
	int cpoints;
	GlowPoint[] pointarray;
	GlowPoint point_p;
	int	i, j, idx;

	if ( curve_idx > Glow.TREND_MAX_CURVES || curve_idx < 0)
	    return;

	no_of_points = Math.max( 2, no_of_points);
	points = cpoints = Math.min( no_of_points, data_points);
	if ( fill_curve != 0)
	    cpoints += 2;
	
	curve_width = Math.min( Glow.DRAW_TYPE_SIZE, Math.max( 1, curve_width));
	
	pointarray = new GlowPoint[cpoints];
	j = curve_idx;
	for ( i = 0, idx = 0; i < cpoints; i++, idx++) {
	    point_p = pointarray[i] = new GlowPoint();
	    if ( fill_curve == 0) {
		idx = i;
		if ( y_max_value[j] != y_min_value[j])
		    point_p.y = ur.y - (y_data[idx] - y_min_value[j]) / 
			(y_max_value[j] - y_min_value[j]) * (ur.y - ll.y);
				
		point_p.y = Math.max( ll.y, Math.min( point_p.y, ur.y));	
		
		if ( x_max_value[j] != x_min_value[j])
		    point_p.x = ll.x + (x_data[idx] - x_min_value[j]) / 
			(x_max_value[j] - x_min_value[j]) * (ur.x - ll.x);
		
		point_p.x = Math.max( ll.x, Math.min( point_p.x, ur.x));	

	    }
	    else {
		
		if ( i == 0) {
		    if ( x_max_value[j] != x_min_value[j])
			point_p.x = ll.x + (x_data[idx] - x_min_value[j]) / 
			    (x_max_value[j] - x_min_value[j]) * (ur.x - ll.x);
		    
		    point_p.x = Math.max( ll.x, Math.min( point_p.x, ur.x));	
		    point_p.y = ur.y;
		    idx--;
		}
		else if ( i == cpoints - 1) {
		    if ( x_max_value[j] != x_min_value[j])
			point_p.x = ll.x + (x_data[idx-1] - x_min_value[j]) / 
			    (x_max_value[j] - x_min_value[j]) * (ur.x - ll.x);
		    
		    point_p.x = Math.max( ll.x, Math.min( point_p.x, ur.x));	
		    point_p.y = ur.y;
		}
		else {
		    if ( y_max_value[j] != y_min_value[j])
			point_p.y = ur.y - (y_data[idx] - y_min_value[j]) / 
			    (y_max_value[j] - y_min_value[j]) * (ur.y - ll.y);
		    
		    point_p.y = Math.max( ll.y, Math.min( point_p.y, ur.y));	
	
		    if ( x_max_value[j] != x_min_value[j])
			point_p.x = ll.x + (x_data[idx] - x_min_value[j]) / 
			    (x_max_value[j] - x_min_value[j]) * (ur.x - ll.x);
		    
		    point_p.x = Math.max( ll.x, Math.min( point_p.x, ur.x));	
		}
	    }
	}
	
	if ( curve_drawtype[j] != Glow.eDrawType_Inherit)
	    dt = curve_drawtype[j];
	else
	    dt = draw_type;
	
	if ( curve_fill_drawtype[j] != Glow.eDrawType_Inherit)
	    dt_fill = curve_fill_drawtype[j];
	else
	    dt_fill = draw_type;
	
	cmn.nodraw++;
	curve[j] = new GrowPolyline( cmn, "", pointarray, cpoints, dt, 
				     curve_width,
				     0, fill_curve, 1, 0, dt_fill);
	cmn.nodraw--;
	draw();
    }

}
