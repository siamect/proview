/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

#include <stdio.h>
#include <math.h>

#include "pwr.h"
#include "pwr_baseclasses.h"
#include "pwr_basecomponentclasses.h"
#include "rt_plc.h"
#include "rt_gdh.h"
#include "co_math.h"
#include "co_time.h"
#include "rt_plc_bcomp.h"

/*_*
  RunTimeCounterFo

  @aref runtimecounter
  @aref runtimecounterfo RunTimeCounterFo
*/
void RunTimeCounterFo_init( pwr_sClass_RunTimeCounterFo  *o)
{
  pwr_tDlid dlid;
  pwr_tStatus sts;

  sts = gdh_DLRefObjectInfoAttrref( &o->PlcConnect, (void **)&o->PlcConnectP, &dlid);
  if ( EVEN(sts)) 
    o->PlcConnectP = 0;
  if ( o->PlcConnectP && o->ResetP == &o->Reset)
    ((pwr_sClass_RunTimeCounter *)o->PlcConnectP)->AccTripReset = 1;
}

void RunTimeCounterFo_exec( plc_sThread		*tp,
			    pwr_sClass_RunTimeCounterFo  *o)
{
  pwr_tDeltaTime	TimeSince;
  pwr_sClass_RunTimeCounter *co = (pwr_sClass_RunTimeCounter *) o->PlcConnectP;

  if ( !co)
    return;

  if ( *o->ResetP && !o->OldReset)
    co->TripReset = 1;

  time_FloatToD( &TimeSince, *o->ScanTime);

  /* Test if New Trip */
  if (co->TripReset) {
    co->OldTripNOfStarts = co->TripNOfStarts;
    co->OldTripUsage = co->TripUsage;
    co->OldTripTime = co->TripTime;
    co->OldTripRunTime = co->TripRunTime;

    co->TripNOfStarts = 0;
    co->TripRunTime.tv_sec = co->TripRunTime.tv_nsec = 0;
    co->TripTime.tv_sec = co->TripTime.tv_nsec = 0;

    time_GetTime( &co->ResetTime);
    co->TripReset = 0;
  }
  /* Update Calendar time */
  time_Dadd_NE( &co->TotalTime, &co->TotalTime, &TimeSince);
  time_Dadd_NE( &co->TripTime, &co->TripTime, &TimeSince);

  /* Test if running */
  o->Start = 0;
  if (*o->RunningP) {
    /* New start ? */
    if ( !o->Running) {
      o->Start = 1;
      co->TotalNOfStarts++;
      co->TripNOfStarts++;
      time_GetTime( &co->StartTime);
    } /* End if new start */
    /* Update Running Time */
    time_Dadd_NE( &co->TripRunTime, &co->TripRunTime, &TimeSince);
    time_Dadd_NE( &co->TotalRunTime, &co->TotalRunTime, &TimeSince);
  } /* End if Running */

  o->Running = co->Running = *o->RunningP;

  /* Calculate usage % */
  if ( co->TotalRunTime.tv_sec)
    co->TotalUsage = ((float)co->TotalRunTime.tv_sec) / co->TotalTime.tv_sec * 100;
  if ( co->TripTime.tv_sec)
    co->TripUsage = ((float)co->TripRunTime.tv_sec) / co->TripTime.tv_sec * 100;

  o->OldReset = *o->ResetP;
}


/*_*
  CompModePID_Fo

  @aref compmodepid
  @aref compmodepid_fo CompModePID_Fo
*/
void CompModePID_Fo_init( pwr_sClass_CompModePID_Fo  *o)
{
  pwr_tDlid dlid;
  pwr_tStatus sts;

  sts = gdh_DLRefObjectInfoAttrref( &o->PlcConnect, (void **)&o->PlcConnectP, &dlid);
  if ( EVEN(sts)) 
    o->PlcConnectP = 0;
}

void CompModePID_Fo_exec( plc_sThread *tp,
			  pwr_sClass_CompModePID_Fo *o)
{
  pwr_sClass_CompModePID *co = (pwr_sClass_CompModePID *) o->PlcConnectP;

  if ( !co)
    return;

  /* Get indata */
  co->ProcVal = *o->ProcValP;
  co->XSetVal = *o->XSetValP;
  if ( o->XForcValP != &o->XForcVal)
    co->XForcVal = *o->XForcValP;
  co->Forc1 = *o->Forc1P;
  co->Forc2 = *o->Forc2P;
  co->OutVal = *o->OutValP;

  /* Make appropriate actions, depending on actual mode */

  /* Manual */
  if (co->OpMod <= 1) {
    co->Force = TRUE;
    co->ManMode = TRUE;
    co->AutMode = FALSE;
    co->CascMod = FALSE;
    /* External setpoint ? */
    if ((co->AccMod & 2) == 0)
      co->SetVal = co->XSetVal;
    /* Test if Force in manual mode */
    if (co->Forc1 )
      co->ForcVal = co->XForcVal;
  }
  else {
    /* Not Manual Mode */
    if (co->OpMod == 2) {
      /* Auto */
      co->ManMode = FALSE;
      co->AutMode = TRUE;
      co->CascMod = FALSE;
    }
    else {
      /* Cascade mode */
      co->ManMode = FALSE;
      co->AutMode = FALSE;
      co->CascMod = TRUE;
      co->SetVal = o->SetVal = co->XSetVal;
    }
    /* Test if force in Auto or Cascade */
    if ( co->Forc1 || co->Forc2 ) {
      co->Force = TRUE;
      co->ForcVal = co->XForcVal;
    }
    else {
      co->Force = FALSE;
      co->ForcVal = co->OutVal;
    }
  }

  if ( co->SetVal < co->MinSet)
    co->SetVal = co->MinSet;
  else if ( co->SetVal > co->MaxSet)
    co->SetVal = co->MaxSet;

  co->Error = co->ProcVal - co->SetVal;

  /* Transfer to outputs */
  o->SetVal = co->SetVal;
  o->ForcVal = co->ForcVal;
  o->Force = co->Force;
  o->AutMode = co->AutMode;
  o->CascMod = co->CascMod;
}

/*_*
  CompPID_Fo

  Revision:	2011-01-18 / Werner
		Error in filtered derivate part corrected.

  @aref comppid
  @aref comppid_fo CompPID_Fo
*/
void CompPID_Fo_init( pwr_sClass_CompPID_Fo  *o)
{
  pwr_tDlid dlid;
  pwr_tStatus sts;

  sts = gdh_DLRefObjectInfoAttrref( &o->PlcConnect, (void **)&o->PlcConnectP, &dlid);
  if ( EVEN(sts)) 
    o->PlcConnectP = 0;
}

/* Define Algoritm bitmask */
#define IALG 1		/* Integral part -> Incremental algorithm */
#define PALG 2		/* Proportional part exists */
#define PAVV 4		/* Proportional part working on control difference */
#define DALG 8		/* Derivative part exists */
#define DAVV 16		/* Derivative part working on control difference */

#define IWUP 1		/* Windup limitation on I part */
#define BIWUP 2		/* Windup limitation on Bias and I part */
#define BPIWUP 4	/* Windup limitation on Bias PI part */
#define BPIDWUP 8	/* Windup limitation on Bias and PID part (Default, old funcionality */

void CompPID_Fo_exec( plc_sThread *tp,
		      pwr_sClass_CompPID_Fo *o)
{

  float	xold;	/* Local variables */
  float	eold;
  float	bfold;
  float	ddiff;
  float	derold;
  double ut;
  double dut;
  float kd;
  double absut;
  float	gain;

  pwr_sClass_CompPID *co = (pwr_sClass_CompPID *) o->PlcConnectP;

  if ( !co)
    return;

  /* Save old values */
  xold=co->ProcVal;
  eold=co->ControlDiff;
  bfold=co->Bias;
  derold=co->FiltDer;

  /* Get Input */
  co->ProcVal = *o->ProcValP;
  if ( o->SetValP != &o->SetVal)
    co->SetVal = *o->SetValP;
  if ( o->ForcValP != &o->ForcVal)
    co->ForcVal = *o->ForcValP;
  if ( o->BiasP != &o->Bias)
    co->Bias = *o->BiasP;
  if ( o->ForceP != &o->Force)
    co->Force = *o->ForceP;
  if ( o->IntOffP != &o->IntOff)
    co->IntOff = *o->IntOffP;
  else
    o->IntOff = co->IntOff;

  /* Calculate Controller Error and Filtered derivate */

  co->ControlDiff = co->ProcVal - co->SetVal;
  ddiff = ((co->PidAlg & DAVV) != 0) ?
    (co->ControlDiff - eold) / *o->ScanTime:
    (co->ProcVal - xold) / *o->ScanTime;
  if (((co->DerGain * *o->ScanTime) >= co->DerTime) || (co->DerTime <= 0))
    co->FiltDer = ddiff;		/* No Filter */
  else {
    kd = 1.0 / (1.0 + co->DerGain * *o->ScanTime / co->DerTime);
    co->FiltDer += (ddiff - derold) * (1.0 - kd);
  }

  if (co->Inverse == 0) gain = co->Gain;
  else gain = -co->Gain;
  
  if ( co->Force ) {
    /* Force */
    co->OutChange = co->ForcVal - co->OutVal;
    co->OutVal = co->OutWindup = co->ForcVal;
    co->EndMin = FALSE;
    co->EndMax = FALSE;

    /* Adjust for bumpless transfer to auto */
    co->PDManOffset = co->OutVal - 
    gain * co->ControlDiff - co->BiasGain * co->Bias;  

    if ((co->PidAlg & IALG) != 0) co->AbsOut = 0.0;
    else co->AbsOut = co->OutVal;

    if (co->WindupMask < BIWUP)
      co->OutWindup -= co->BiasGain * co->Bias;
    if (co->WindupMask < BPIWUP)
      co->OutWindup -= gain * co->ControlDiff;
    
    co->AbsOut = co->OutVal - co->OutWindup;
  }

  else {
    /* Auto mode */
    
    dut = absut = 0.0;
    
    if ((co->PidAlg & IALG) != 0)
    /* Incremental algorithm */
    {
      /* Integral-part */
      if ((*o->IntOffP == FALSE) && (co->IntTime > 0))
	dut = co->ControlDiff * *o->ScanTime / co->IntTime;

      if ((co->PidAlg & PALG) != 0) dut *= gain;
      else gain = 0.0; /* Pure I-controller */

      /* Bias */
      if (co->WindupMask >= BIWUP) /* Windup on Bias */
        dut += co->BiasGain * (co->Bias - bfold);
      else absut = co->BiasGain * co->Bias;

      /* P-part */
      if (co->WindupMask >= BPIWUP) /* Windup on P */
        dut += ((co->PidAlg & PAVV) != 0) ?
            gain * (co->ControlDiff - eold) :
            gain * (co->ProcVal - xold) ;
      else
        absut += gain * co->ControlDiff;

      /* Derivative-part */
      if ((co->PidAlg & DALG) != 0) {
        if (co->WindupMask >= BPIDWUP) /* Windup on D */
          dut += gain * (co->FiltDer - derold) * co->DerTime;
        else
          absut += gain * co->FiltDer * co->DerTime;
      }

      /* Limit output */
      co->OutWindup += dut;

      if (co->OutWindup > co->MaxWindup) {
        co->OutWindup = co->MaxWindup;
        co->EndMax = TRUE;
      } else if (co->OutWindup < co->MinWindup) {
        co->OutWindup = co->MinWindup;
        co->EndMin = TRUE;
      }

      ut = co->OutWindup + absut;
      if (ut > co->MaxOut) ut = co->MaxOut;
      else if (ut < co->MinOut) ut = co->MinOut;
      dut += absut - co->AbsOut;
    }

    else
      /* Nonincremental algorithm */
    {
      /* P-part */
      ut = co->ControlDiff;
      /* Derivative-part */
      if ((co->PidAlg & DALG) != 0)
	ut += co->FiltDer * co->DerTime;
      /* Gain */
      ut *= gain;

      /* Bias and Man offset*/
      if (co->PDAbsFlag) co->PDManOffset = 0;
      ut += co->BiasGain * co->Bias + co->PDManOffset;
      
      /* Limit output */
      if (co->MaxOut > co->MinOut)
      {
        if (ut > co->MaxOut) ut = co->MaxOut;
        else if (ut < co->MinOut) ut = co->MinOut;
      }
      dut = ut - co->OutVal;
      absut = ut;
    }
    
    /* Output Auto */
    co->OutChange = dut;
    co->OutVal = ut;
    co->AbsOut = absut;
  }

  /* Transfer outputs */
  o->OutVal = co->OutVal;
  o->OutChange = co->OutChange;
  o->ControlDiff = co->ControlDiff;
  o->EndMax = co->EndMax;
  o->EndMin = co->EndMin;
}

/*_*
  OnOffBurnerFo

  @aref componoffburner
  @aref componoffburnerfo CompOnOffBurnerFo
*/
void CompOnOffBurnerFo_init( pwr_sClass_CompOnOffBurnerFo  *o)
{
  pwr_tDlid dlid;
  pwr_tStatus sts;

  sts = gdh_DLRefObjectInfoAttrref( &o->PlcConnect, (void **)&o->PlcConnectP, &dlid);
  if ( EVEN(sts)) 
    o->PlcConnectP = 0;
}

void CompOnOffBurnerFo_exec( plc_sThread		*tp,
			     pwr_sClass_CompOnOffBurnerFo *o)
{
  pwr_sClass_CompOnOffBurner *co = (pwr_sClass_CompOnOffBurner *) o->PlcConnectP;
  pwr_sClass_CompOnOffZoneFo	*zono;
  pwr_sClass_CompOnOffZone	*zonco;
  pwr_tFloat32 Cnt;

  zono = (pwr_sClass_CompOnOffZoneFo *)
    ((char *)o->InP - (sizeof(pwr_sClass_CompOnOffZoneFo) - pwr_AlignLW(sizeof(pwr_tFloat32))));
  zonco = (pwr_sClass_CompOnOffZone *)zono->PlcConnectP;

  if ( !co || !zonco)
    return;

  co->Executing = zonco->Executing;
  if ( !co->Executing) {
    o->Status = co->Status = 0;
    co->BrTime = 0;
    co->TrendStatus = (pwr_tFloat32) co->Number;
    return;
  }
     
  if ( zonco->CycleCount < 0.5)
    co->OnDetected = 0;

  if ( (co->PulseOn && co->BrTime < zonco->BurnerTimeMinOn) ||
       (!co->PulseOn && co->BrTime < zonco->BurnerTimeMinOff)) {
    co->BrTime += *o->ScanTime;
    return;
  }

  if ( co->ManMode && co->OpMan) {
    if ( (o->Status && !co->ManStatus) || (!o->Status && co->ManStatus))
      co->BrTime = 0;
    o->Status = co->Status = co->ManStatus;
    co->TrendStatus = (pwr_tFloat32) co->Number + 0.8 * (co->Status ? 1 : 0);
    co->BrTime += *o->ScanTime;
    return;
  }
  else
    co->ManStatus = 0;

  if ( zonco->PauseMode)
    co->PulseTime = zonco->BurnerTimeMinOff;
  else
    co->PulseTime = zonco->BurnerTimeMinOn;

  Cnt = zonco->CycleCount - 100.0 * co->Number / zonco->NumberOfBurners;
  if ( Cnt < 0)
    Cnt += 100;
  if ( zonco->PauseMode)
    co->OffCnt = co->PulseTime / zonco->CycleTime * 100;
  else
    co->OffCnt = (zonco->CycleTime - co->PulseTime) / zonco->CycleTime * 100;

  if ( Cnt >= 0 && Cnt < co->OffCnt &&
       !co->Status) {
    // Turn on
    co->OnDetected = 1;
    co->Status = 1;
    co->BrTime = 0;
  }
  else if ( Cnt >= co->OffCnt &&
            co->Status) {
    // Turn off
    co->Status = 0;
    co->BrTime = 0;
  }
  co->BrTime += *o->ScanTime;
  co->TrendStatus = (pwr_tFloat32) co->Number + 0.8 * (co->Status ? 1 : 0);
  o->Status = co->Status;
}


/*_*
  CompOnOffZoneFo

  @aref componoffzone
  @aref componoffzonefo CompOnOffZoneFo
*/
void CompOnOffZoneFo_init( pwr_sClass_CompOnOffZoneFo  *o)
{
  pwr_tDlid dlid;
  pwr_tStatus sts;

  sts = gdh_DLRefObjectInfoAttrref( &o->PlcConnect, (void **)&o->PlcConnectP, &dlid);
  if ( EVEN(sts)) 
    o->PlcConnectP = 0;
}

void CompOnOffZoneFo_exec( plc_sThread	    *tp,
		           pwr_sClass_CompOnOffZoneFo *o)
{
  pwr_sClass_CompOnOffZone *co = (pwr_sClass_CompOnOffZone *) o->PlcConnectP;

  if ( !co)
    return;

  co->Power = o->Power = *o->PowerP;
  co->Executing = o->Execute = *o->ExecuteP;
  if ( co->Power < co->PowerMin)
    co->Power = co->PowerMin;
  if ( co->Power > co->PowerMax)
    co->Power = co->PowerMax;

  if ( !co->Executing) {
    co->CycleCount = 0;
    return;
  }

  co->PauseMode = ( co->Power / 100 > (co->BurnerTimeMinOff / (co->BurnerTimeMinOn + co->BurnerTimeMinOn))) ? 0 : 1;

  if ( co->PauseMode) {
    if ( co->Power != 100.0)
      co->CycleTime = co->BurnerTimeMinOff * 100.0 / co->Power;
  }
  else {
    if ( co->Power != 0)
      co->CycleTime = co->BurnerTimeMinOn * 100.0 / (100.0 - co->Power);
  }
  co->CycleCount += *o->ScanTime / co->CycleTime * 100;
  if ( co->CycleCount > 100)
    co->CycleCount = 0;
}

//---- modified v0.3-----------------------------------------------START--------

/*_*
  PLC interface & calculus to discrete time Internal Model Controler component

  @aref compimc
  @aref compimc_fo CompImc_Fo

  2015 - 12 - 19	Bruno: initial object. v0.1
  2016 - 04 - 11	Bruno: cleaning. v0.2
  2017 - 04 - 14    Bruno: remove "division by zero" potential bugs v0.3
*/

#define Te tp->ActualScanTime
#define MAXCELLS 100
#define Clamp(x, min, max) x = ((x)<(min)) ? (min) : (((x)>(max)) ? (max) : (x))   
//#define Normalize(x, y, xmin, xmax, ymin, ymax) y = (((((ymax)-(ymin))/((xmax)-(xmin)))*((x)-(xmin)))+(ymin)) // replaced by a function in v0.3



void CompIMC_Fo_init( pwr_sClass_CompIMC_Fo *plc_obj) 
{
	pwr_tDlid dlid;
	pwr_tStatus sts;
	sts = gdh_DLRefObjectInfoAttrref( &plc_obj->PlcConnect, (void **)&plc_obj->PlcConnectP, &dlid);
	if ( EVEN(sts))
	plc_obj->PlcConnectP = 0;
}
 

void CompIMC_Fo_exec( plc_sThread *tp, 
                         pwr_sClass_CompIMC_Fo *plc_obj) 
{ 
	pwr_sClass_CompIMC *plant_obj = (pwr_sClass_CompIMC *) plc_obj->PlcConnectP;
	if ( !plant_obj) return;
	pwr_tFloat32 man_OP, sig,  yr, LSP, PV, nLSP, nPV, Tl1, Tl2;
	
	void Normalize (pwr_tFloat32 x, pwr_tFloat32 *y, pwr_tFloat32 xmin, pwr_tFloat32 xmax, pwr_tFloat32 ymin, pwr_tFloat32 ymax) // v0.3
	{
		if((xmax-xmin)!=0.0) *y =(ymax-ymin)/(xmax-xmin)*(x-xmin)+ymin; else return;
	}

	void LagFilter(pwr_tInt16 n, pwr_tFloat32 Tlag)
	{
		if (Tlag < Te) { plant_obj->S[n+1] = plant_obj->S[n]; return; }	
		pwr_tFloat32 kf= 1.0/(1.0+Tlag/Te);
		Clamp (plant_obj->S[n+1], 0.0, 100.0);
		plant_obj->S[n+1]  = (1.0-kf)* plant_obj->S[n+1] + kf * plant_obj->S[n];
	}

	void LeadLagFilter(pwr_tInt16 n, pwr_tFloat32 T1, pwr_tFloat32 T2)
	{
		if (T2 < Te)  { plant_obj->S[n+1] = plant_obj->S[n]; plant_obj->M[n]=plant_obj->S[n];return; }	
		pwr_tFloat32 kc = -T1/Te;
		pwr_tFloat32 kd = T2/Te;
		pwr_tFloat32 ka = 1.0+kd;
		pwr_tFloat32 kb = 1.0-kc;	
		
		if (ka<=0) return; // v0.3
		Clamp (plant_obj->S[n+1], 0.0, 100.0);
		plant_obj->S[n+1] = 
			  kd/ka* plant_obj->S[n+1] 
			+ kb/ka*plant_obj->S[n] 
			+ kc/ka* plant_obj->M[n];
		plant_obj->M[n]=plant_obj->S[n];
	}

	void SouFilter(pwr_tInt16 n, pwr_tFloat32 w0P, pwr_tFloat32 ksi)
	{
		if (w0P<=0.0) {plant_obj->S[n+1] = plant_obj->S[n];return;}
		pwr_tFloat32 a0 = Te*Te*w0P*w0P+2.0*ksi*Te*w0P+1.0;
		pwr_tFloat32 a1 = 2.0*(ksi*Te*w0P+1.0);
		pwr_tFloat32 a2 = -1.0;
		pwr_tFloat32 b0 = Te*Te*w0P*w0P;
		
		if (a0<=0) return; // v0.3
		Clamp (plant_obj->S[n+1], 0.0, 100.0);
		plant_obj->uOutm2 = plant_obj->uOutm1;
		plant_obj->uOutm1 = plant_obj->S[n+1];
		plant_obj->S[n+1]= 
 			  a1/a0 * plant_obj->uOutm1 
			+ a2/a0 * plant_obj->uOutm2 
			+ b0/a0 * plant_obj->S[n];
	}


	void SouTOoFilter(pwr_tInt16 n, pwr_tFloat32 w0, pwr_tFloat32 ksi, pwr_tFloat32 Tl1, pwr_tFloat32 Tl2)
	{
		if (w0<=0.0) {plant_obj->S[n+1] = plant_obj->S[n];return;}
		pwr_tFloat32 b0 = Te*Te*w0*w0+2.0*ksi*Te*w0+1.0;
		pwr_tFloat32 b1 = -2.0*(ksi*Te*w0+1.0);
		pwr_tFloat32 b2 = 1.0;
		pwr_tFloat32 a0 = w0*w0*(Tl1+Te)*(Tl2+Te);
		pwr_tFloat32 a1 = w0*w0*(2.0*Tl1*Tl2+Te*(Tl1+Tl2));
		pwr_tFloat32 a2 = -w0*w0*Tl1*Tl2;
		
		if (a0<=0) return; // v0.3
		Clamp (plant_obj->S[n+1], 0.0, 100.0);
		plant_obj->Outm2 = plant_obj->Outm1;
		plant_obj->Outm1 = plant_obj->S[n+1];
		plant_obj->S[n+1] = 
			  a1/a0 * plant_obj->Outm1 
			+ a2/a0 *plant_obj->Outm2 
			+ b0/a0 * plant_obj->S[n]
			+ b1/a0 * plant_obj->Inm1
			+ b2/a0 * plant_obj->Inm2;
		plant_obj->Inm2 = plant_obj->Inm1;
		plant_obj->Inm1 = plant_obj->S[n];
	}

	void Delay(pwr_tInt16 n, pwr_tFloat32 Delay) // Only one delay per IMC object available
	{
		pwr_tFloat32 OP=0.0;
		int i, Ntime, Nscan;	

	
		if ((int) Delay < Te) { plant_obj->S[n+1]=plant_obj->S[n]; return; } // return if nothing can be done	
		if (plant_obj->PrevDelay != Delay) for(i=MAXCELLS-1; i>=0; i--) plant_obj->D[i]=plant_obj->S[n]; // reset if delay param as changed
		plant_obj->PrevDelay = Delay; // Apply new delay
		Nscan = (int) (0.5+Delay/Te); // Calculate number of cells needed
		if (Nscan > MAXCELLS) // Things to do if delay time is more than 100 times scan time
		{
			Ntime = (int) (0.5+Delay/(Te * (pwr_tFloat32) MAXCELLS)); // calculate number of time lags to count
			if (plant_obj->DtCtr==0) for(i=0; i<=MAXCELLS; i++) plant_obj->D[i]=plant_obj->S[n]; // reset all the array
			OP=plant_obj->D[MAXCELLS-1]; // copy last array item to output
			if (plant_obj->DtCtr >= Ntime) // if time elapsed -> shift array
			{
				plant_obj->DtCtr=0; // Reset time lag counter
				for(i=MAXCELLS-1; i>0; i--) plant_obj->D[i]=plant_obj->D[i-1]; // shift all the array
				plant_obj->D[0]=plant_obj->S[n]; // copy input to first array item 
			}
			plant_obj->DtCtr++; // decrement time lag counter
		}
		else // things to do if delay time is less than (or equal to) 100 times scan time
		{
			OP = plant_obj->D[Nscan-1]; // copy last active array item to output
			for(i=Nscan; i>0; i--) plant_obj->D[i]=plant_obj->D[i-1]; // shift a sufficient part of the array
			plant_obj->D[0]=plant_obj->S[n]; // copy input to first array item 
		}	
		plant_obj->S[n+1]=OP; // copy to function output
	}

	pwr_tInt16 i;
	pwr_tFloat32 OP;
	

	plant_obj->PV  = *plc_obj->PVP; // Process value: copy IMC_Fo to IMC
	plant_obj->SP  = *plc_obj->SPP; // Setpoint value: copy IMC_Fo to IMC
	plant_obj->aut = *plc_obj->autP; // Auto input: copy IMC_Fo to IMC	

	LSP=plant_obj->SP+plant_obj->Trim_SP; // Calculate working setpoint
	Clamp (LSP, plant_obj->LL_SP, plant_obj->HL_SP); // Apply limits
	Normalize(LSP,&nLSP, plant_obj->LR_PV, plant_obj->HR_PV,0.0,100.0); // Normalize setpoint value // v0.3
	
	PV = plant_obj->PV; // Copy from GUI 
	Normalize(PV,&nPV, plant_obj->LR_PV, plant_obj->HR_PV,0.0,100.0);  // Normalize process value // v0.3
	sig = (plant_obj->Inverse) ? nLSP - nPV : nPV - nLSP; 	// Error signal after direct/inverse Comparator
	plant_obj->EP=-sig; // Calculate error value to display

	if(!plant_obj->aut){	// Manage manual mode & reset all buffers
		sig=0; 
		Normalize(*plc_obj->Man_OPP, &man_OP, plant_obj->LR_OP, plant_obj->HR_OP, 0.0, 100.0); // v0.3

		for (i=0; i<12; i++) plant_obj->S[i]=man_OP;
		for (i=0; i<100; i++) plant_obj->D[i]=man_OP;
		for (i=0; i<10; i++) plant_obj->M[i]=man_OP;
		plant_obj->Inm1=plant_obj->Inm2=plant_obj->Outm1=plant_obj->Outm2=man_OP;
		plant_obj->uOutm1=plant_obj->uOutm2=man_OP; 

		yr = *plc_obj->Man_OPP;
		Clamp (yr, plant_obj->LL_OP, plant_obj->HL_OP); // Apply limits on control signal
		plc_obj->OP=plant_obj->OP = yr;
	} 
	else{ // Calculate IMC controller
		
		if (Te<=0) return; // v0.3
		if (plant_obj->Accel<1.0) return; // v0.3
		if (plant_obj->Gain>0.0) sig /= plant_obj->Gain; else return;	// Apply static gain // v0.3
		
		plant_obj->S[0] = sig+plant_obj->S[11];	// Add previous model's feedback 	

		LagFilter(0,plant_obj->RobTau); // Increasing robustness by low pass filtering
		
		if(plant_obj->ProcModel & 8) 
		{
			LagFilter(1, plant_obj->LeadT);	
			LeadLagFilter(2, plant_obj->LagT3, plant_obj->LagT3/plant_obj->Accel);	
		}
			else plant_obj->S[3]=plant_obj->S[2]=plant_obj->S[1];

		if(plant_obj->ProcModel & 1) LeadLagFilter(3, plant_obj->LagT1, plant_obj->LagT1/plant_obj->Accel); 
			else plant_obj->S[4]=plant_obj->S[3];

		if(plant_obj->ProcModel & 2) LeadLagFilter(4, plant_obj->LagT2, plant_obj->LagT2/plant_obj->Accel); 
			else plant_obj->S[5]=plant_obj->S[4];

		if(plant_obj->ProcModel & 4) 
			{
				Tl1 = Tl2 = plant_obj->ksi*M_PI/(2.0*plant_obj->Accel*plant_obj->w0);
				SouTOoFilter(5, plant_obj->w0, plant_obj->ksi, Tl1, Tl2);
			}
			else plant_obj->S[6]=plant_obj->S[5];
		
		OP=plant_obj->S[6];
		Clamp (OP, 0.0, 100.0); // Apply limits on model output		
		Normalize(OP,&yr,0.0,100.0,plant_obj->LR_OP, plant_obj->HR_OP);	// Denormalize output // v0.3
		yr+=plant_obj->FF; // Add feedforward input value
		Clamp (yr, plant_obj->LL_OP, plant_obj->HL_OP); // Apply limits to control signal
		plc_obj->OP=plant_obj->OP = yr; // copy to GUI objects
	
		// Model's feedback

		if(plant_obj->ProcModel & 1) LagFilter(6,plant_obj->LagT1);
			else plant_obj->S[7]=plant_obj->S[6];

		if(plant_obj->ProcModel & 2) LagFilter(7,plant_obj->LagT2);
			else plant_obj->S[8]=plant_obj->S[7];

		if(plant_obj->ProcModel & 8) LeadLagFilter(8,plant_obj->LeadT, plant_obj->LagT3);
			else plant_obj->S[9]=plant_obj->S[8];

		if(plant_obj->ProcModel & 4) SouFilter(9, plant_obj->w0, plant_obj->ksi);
			else plant_obj->S[10]=plant_obj->S[9];

		Delay(10, plant_obj->DelayT);
		
	}
} 



//---- modified v0.3-----------------------------------------------END----

/*_*
  PLC Mode interface to a discrete time Internal Model Controler component

  @aref compmodeimc
  @aref compmodeimc_fo CompImc_Fo

  2015 - 12 - 19	Bruno: initial object.
  2016 - 04 - 11	Bruno: cleaning.
*/


void CompModeIMC_Fo_init( pwr_sClass_CompModeIMC_Fo *plc_obj) 
{
	pwr_tDlid dlid;
	pwr_tStatus sts;
	sts = gdh_DLRefObjectInfoAttrref( &plc_obj->PlcConnect, (void **)&plc_obj->PlcConnectP, &dlid);
	if ( EVEN(sts))
	plc_obj->PlcConnectP = 0;
}


void CompModeIMC_Fo_exec( plc_sThread *tp, 
                         pwr_sClass_CompModeIMC_Fo *plc_obj) 
{ 
	pwr_sClass_CompModeIMC *plant_obj = (pwr_sClass_CompModeIMC *) plc_obj->PlcConnectP;
	if ( !plc_obj)
	return;

	plant_obj->PV=*plc_obj->PVP; // Copy from GUI
	plant_obj->OP=*plc_obj->OPP; // Copy from GUI

	if((plant_obj->Mode==pwr_eImcModeEnum_Manual) // Manage manual mode
		&&(plant_obj->PrevMode!=pwr_eImcModeEnum_Manual)) 
			plant_obj->Loc_OP=plant_obj->OP;

	if (plant_obj->Mode!=pwr_eImcModeEnum_Manual) // Manage auto mode
			plant_obj->Loc_OP=*plc_obj->OPP; 
		else 
			plc_obj->Man_OP = plant_obj->Loc_OP;

	if((plant_obj->Mode!=pwr_eImcModeEnum_Manual)
		&&(plant_obj->PrevMode==pwr_eImcModeEnum_Manual)
		&&(plant_obj->BumpLess)) // copy PV to SP when bumpless is set & aut to man transition
			plant_obj->Loc_SP=plant_obj->PV;

	if((plant_obj->Mode==pwr_eImcModeEnum_Auto)
		&&(plant_obj->PrevMode==pwr_eImcModeEnum_Remote)
		&&(plant_obj->BumpLess)) // copy PV to SP when bumpless is set & rem to man transition
			plant_obj->Loc_SP=plant_obj->PV;  

	if(plant_obj->Loc_SP != plant_obj->SP) plant_obj->SP = plant_obj->Loc_SP; // set SP to manual GUI SP setting
	if(plant_obj->Mode == pwr_eImcModeEnum_Remote) plant_obj->SP = *plc_obj->Rem_SPP;// set SP to external SP when remote mode is selected
	plc_obj->SP=plant_obj->SP; // copy plant SP to plc SP
	plc_obj->aut=(plant_obj->Mode!=pwr_eImcModeEnum_Manual); // set aut output on plc object
	plant_obj->EP= (plant_obj->PV-plant_obj->SP); // calculate EP
	plant_obj->PrevMode=plant_obj->Mode; // memorize last mode
}

/*_*
  CompCurveTabValueFo

  @aref compcurvetabvaluefo CompCurveTabValueFo
*/
void CompCurveTabValueFo_init( pwr_sClass_CompCurveTabValueFo *o)
{
  pwr_tDlid dlid;
  pwr_tStatus sts;

  sts = gdh_DLRefObjectInfoAttrref( &o->PlcConnect, (void **)&o->PlcConnectP, &dlid);
  if ( EVEN(sts)) 
    o->PlcConnectP = 0;

  if ( ODD(sts))
    sts = gdh_DLRefObjectInfoAttrref( &((pwr_sClass_CompCurveTabValue *)o->PlcConnectP)->CurveTabObject, 
				      (void **)&o->CurveTabObjectP, &dlid);
  if ( EVEN(sts)) 
    o->CurveTabObjectP = 0;
}

void CompCurveTabValueFo_exec( plc_sThread		*tp,
			       pwr_sClass_CompCurveTabValueFo *o)
{
  pwr_sClass_CompCurveTabValue *co = (pwr_sClass_CompCurveTabValue *) o->PlcConnectP;
  pwr_sClass_CompCurveTab *to = (pwr_sClass_CompCurveTab *) o->CurveTabObjectP;
  int ii;
  float x0, x1, y0, y1;
  pwr_tInt32 confError = 0;

  if ( !co || !to)
    return;


  o->ActVal = *o->InP;

  if ( to->NoOfPoints <= 0 )
    confError = 1;
  else if ( to->NoOfPoints > 50 )
    confError = 2;
  else {
    for(ii = 1; ii < to->NoOfPoints && !confError; ii++) {
      if(to->X[ii] < to->X[ii-1])
	confError = 3;
    }
  }
  to->ConfigurationError = confError;

  if(!confError) {
    x1 = x0 = to->X[0];
    y1 = y0 = to->Y[0];
    for(ii = 1; ii < to->NoOfPoints && *o->InP > x1; ii++) {
      x0 = x1;
      x1 = to->X[ii];
      y0 = y1;
      y1 = to->Y[ii];
    }
    if ( *o->InP <= x0) 
      o->ActVal = y0; /* End of table */
    else if ( *o->InP >= x1) 
      o->ActVal = y1; /* End of table */
    else  
      o->ActVal = y0 + (y1 - y0) * (*o->InP - x0) / (x1 - x0); /* Interpolation */
  }
  co->ActVal = o->ActVal;
  co->In = *o->InP;
}

/*_*
  CompCurvePolValueFo

  @aref compcurvetabvaluefo CompCurvePolValueFo
*/
#define CURVEPOL_POINTS 50

static void CompCurvePolValueFo_draw( pwr_sClass_CompCurvePol *o)
{
  int i, j;
  pwr_tFloat32 x, y;
  pwr_tFloat32 dx = (o->MaxShowX - o->MinShowX) / CURVEPOL_POINTS;
  
  if ( o->Power == 1) {
    o->DisplayNoOfPoints = 2;
    o->DisplayX[0] = o->MinShowX;
    o->DisplayX[1] = o->MaxShowX;
    o->DisplayY[0] = o->PolyCoeff[0] + o->MinShowX * o->PolyCoeff[1];
    o->DisplayY[1] = o->PolyCoeff[0] + o->MaxShowX * o->PolyCoeff[1];
  }
  else {
    x = o->MinShowX;
    for ( i = 0; i <= CURVEPOL_POINTS; i++) {
      y = 0;
      for ( j = o->Power; j > 0; j--)
	y = x * (o->PolyCoeff[j] + y);
      y += o->PolyCoeff[0];
      o->DisplayX[i] = x;
      o->DisplayY[i] = y;
      x += dx;
    }
    o->DisplayNoOfPoints = CURVEPOL_POINTS + 1;
  }
  o->UpdateDisplay = 0;
}

void CompCurvePolValueFo_init( pwr_sClass_CompCurvePolValueFo *o)
{
  pwr_tDlid dlid;
  pwr_tStatus sts;

  sts = gdh_DLRefObjectInfoAttrref( &o->PlcConnect, (void **)&o->PlcConnectP, &dlid);
  if ( EVEN(sts)) 
    o->PlcConnectP = 0;

  if ( ODD(sts))
    sts = gdh_DLRefObjectInfoAttrref( &((pwr_sClass_CompCurvePolValue *)o->PlcConnectP)->CurvePolObject, 
				      (void **)&o->CurvePolObjectP, &dlid);
  if ( EVEN(sts)) 
    o->CurvePolObjectP = 0;

  if ( o->CurvePolObjectP && ((pwr_sClass_CompCurvePol *)o->CurvePolObjectP)->UpdateDisplay)
    CompCurvePolValueFo_draw(o->CurvePolObjectP);
}

void CompCurvePolValueFo_exec( plc_sThread		*tp,
			       pwr_sClass_CompCurvePolValueFo *o)
{
  pwr_sClass_CompCurvePolValue *co = (pwr_sClass_CompCurvePolValue *) o->PlcConnectP;
  pwr_sClass_CompCurvePol *to = (pwr_sClass_CompCurvePol *) o->CurvePolObjectP;
  int i;
  float x, y;

  if ( !co || !to)
    return;

  o->ActVal = *o->InP;

  if ( to->Power > 5) {
    to->ConfigurationError = 1;
    return;
  }
  else
    to->ConfigurationError = 0;

  if ( !to->ConfigurationError) {
    x = *o->InP;
    y = 0;
    for ( i = to->Power; i > 0; i--)
      y = x * (to->PolyCoeff[i] + y);
    y += to->PolyCoeff[0];
    o->ActVal = y;
    
    if ( to->UpdateDisplay)
      CompCurvePolValueFo_draw(to);
  }
  co->ActVal = o->ActVal;
  co->In = *o->InP;
}









