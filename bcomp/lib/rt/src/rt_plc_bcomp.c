/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2018 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <stdio.h>
#include <math.h>

#include "co_math.h"
#include "co_time.h"
#include "rt_plc_bcomp.h"

/*_*
  RunTimeCounterFo

  @aref runtimecounter
  @aref runtimecounterfo RunTimeCounterFo
*/
void RunTimeCounterFo_init(pwr_sClass_RunTimeCounterFo* o)
{
  pwr_tDlid dlid;
  pwr_tStatus sts;

  sts = gdh_DLRefObjectInfoAttrref(
      &o->PlcConnect, (void**)&o->PlcConnectP, &dlid);
  if (EVEN(sts))
    o->PlcConnectP = 0;
  if (o->PlcConnectP && o->ResetP == &o->Reset)
    ((pwr_sClass_RunTimeCounter*)o->PlcConnectP)->AccTripReset = 1;
}

void RunTimeCounterFo_exec(plc_sThread* tp, pwr_sClass_RunTimeCounterFo* o)
{
  pwr_tDeltaTime TimeSince;
  pwr_sClass_RunTimeCounter* co = (pwr_sClass_RunTimeCounter*)o->PlcConnectP;

  if (!co)
    return;

  if (*o->ResetP && !o->OldReset)
    co->TripReset = 1;

  time_FloatToD(&TimeSince, *o->ScanTime);

  /* Test if New Trip */
  if (co->TripReset) {
    co->OldTripNOfStarts = co->TripNOfStarts;
    co->OldTripUsage = co->TripUsage;
    co->OldTripTime = co->TripTime;
    co->OldTripRunTime = co->TripRunTime;

    co->TripNOfStarts = 0;
    co->TripRunTime.tv_sec = co->TripRunTime.tv_nsec = 0;
    co->TripTime.tv_sec = co->TripTime.tv_nsec = 0;

    time_GetTime(&co->ResetTime);
    co->TripReset = 0;
  }
  /* Update Calendar time */
  time_Dadd_NE(&co->TotalTime, &co->TotalTime, &TimeSince);
  time_Dadd_NE(&co->TripTime, &co->TripTime, &TimeSince);

  /* Test if running */
  o->Start = 0;
  if (*o->RunningP) {
    /* New start ? */
    if (!o->Running) {
      o->Start = 1;
      co->TotalNOfStarts++;
      co->TripNOfStarts++;
      time_GetTime(&co->StartTime);
    } /* End if new start */
    /* Update Running Time */
    time_Dadd_NE(&co->TripRunTime, &co->TripRunTime, &TimeSince);
    time_Dadd_NE(&co->TotalRunTime, &co->TotalRunTime, &TimeSince);
  } /* End if Running */

  o->Running = co->Running = *o->RunningP;

  /* Calculate usage % */
  if (co->TotalRunTime.tv_sec)
    co->TotalUsage
        = ((float)co->TotalRunTime.tv_sec) / co->TotalTime.tv_sec * 100;
  if (co->TripTime.tv_sec)
    co->TripUsage = ((float)co->TripRunTime.tv_sec) / co->TripTime.tv_sec * 100;

  o->OldReset = *o->ResetP;
}

/*_*
  CompModePID_Fo

  @aref compmodepid
  @aref compmodepid_fo CompModePID_Fo
*/
void CompModePID_Fo_init(pwr_sClass_CompModePID_Fo* o)
{
  pwr_tDlid dlid;
  pwr_tStatus sts;

  sts = gdh_DLRefObjectInfoAttrref(
      &o->PlcConnect, (void**)&o->PlcConnectP, &dlid);
  if (EVEN(sts))
    o->PlcConnectP = 0;
}

void CompModePID_Fo_exec(plc_sThread* tp, pwr_sClass_CompModePID_Fo* o)
{
  pwr_sClass_CompModePID* co = (pwr_sClass_CompModePID*)o->PlcConnectP;

  if (!co)
    return;

  /* Get indata */
  co->ProcVal = *o->ProcValP;
  co->XSetVal = *o->XSetValP;
  if (o->XForcValP != &o->XForcVal)
    co->XForcVal = *o->XForcValP;
  co->Forc1 = *o->Forc1P;
  co->Forc2 = *o->Forc2P;
  co->OutVal = *o->OutValP;

  /* Make appropriate actions, depending on actual mode */

  /* Manual */
  if (co->OpMod <= 1) {
    co->Force = TRUE;
    co->ManMode = TRUE;
    co->AutMode = FALSE;
    co->CascMod = FALSE;
    /* External setpoint ? */
    if ((co->AccMod & 2) == 0)
      co->SetVal = co->XSetVal;
    /* Test if Force in manual mode */
    if (co->Forc1)
      co->ForcVal = co->XForcVal;
  } else {
    /* Not Manual Mode */
    if (co->OpMod == 2) {
      /* Auto */
      co->ManMode = FALSE;
      co->AutMode = TRUE;
      co->CascMod = FALSE;
    } else {
      /* Cascade mode */
      co->ManMode = FALSE;
      co->AutMode = FALSE;
      co->CascMod = TRUE;
      co->SetVal = o->SetVal = co->XSetVal;
    }
    /* Test if force in Auto or Cascade */
    if (co->Forc1 || co->Forc2) {
      co->Force = TRUE;
      co->ForcVal = co->XForcVal;
    } else {
      co->Force = FALSE;
      co->ForcVal = co->OutVal;
    }
  }

  if (co->SetVal < co->MinSet)
    co->SetVal = co->MinSet;
  else if (co->SetVal > co->MaxSet)
    co->SetVal = co->MaxSet;

  co->Error = co->ProcVal - co->SetVal;

  /* Transfer to outputs */
  o->SetVal = co->SetVal;
  o->ForcVal = co->ForcVal;
  o->Force = co->Force;
  o->AutMode = co->AutMode;
  o->CascMod = co->CascMod;
}

/*_*
  CompPID_Fo

  Revision:	2011-01-18 / Werner
                Error in filtered derivate part corrected.

  @aref comppid
  @aref comppid_fo CompPID_Fo
*/
void CompPID_Fo_init(pwr_sClass_CompPID_Fo* o)
{
  pwr_tDlid dlid;
  pwr_tStatus sts;

  sts = gdh_DLRefObjectInfoAttrref(
      &o->PlcConnect, (void**)&o->PlcConnectP, &dlid);
  if (EVEN(sts))
    o->PlcConnectP = 0;
}

/* Define Algoritm bitmask */
#define IALG 1 /* Integral part -> Incremental algorithm */
#define PALG 2 /* Proportional part exists */
#define PAVV 4 /* Proportional part working on control difference */
#define DALG 8 /* Derivative part exists */
#define DAVV 16 /* Derivative part working on control difference */

//#define IWUP 1 /* Windup limitation on I part */
#define BIWUP 2 /* Windup limitation on Bias and I part */
#define BPIWUP 4 /* Windup limitation on Bias PI part */
#define BPIDWUP                                                                \
  8 /* Windup limitation on Bias and PID part (Default, old funcionality */

void CompPID_Fo_exec(plc_sThread* tp, pwr_sClass_CompPID_Fo* o)
{
  float xold; /* Local variables */
  float eold;
  float bfold;
  float ddiff;
  float derold;
  double ut;
  double dut;
  float kd;
  double absut;
  float gain;

  pwr_sClass_CompPID* co = (pwr_sClass_CompPID*)o->PlcConnectP;

  if (!co)
    return;

  /* Save old values */
  xold = co->ProcVal;
  eold = co->ControlDiff;
  bfold = co->Bias;
  derold = co->FiltDer;

  /* Get Input */
  co->ProcVal = *o->ProcValP;
  if (o->SetValP != &o->SetVal)
    co->SetVal = *o->SetValP;
  if (o->ForcValP != &o->ForcVal)
    co->ForcVal = *o->ForcValP;
  if (o->BiasP != &o->Bias)
    co->Bias = *o->BiasP;
  if (o->ForceP != &o->Force)
    co->Force = *o->ForceP;
  if (o->IntOffP != &o->IntOff)
    co->IntOff = *o->IntOffP;
  else
    o->IntOff = co->IntOff;

  /* Calculate Controller Error and Filtered derivate */

  co->ControlDiff = co->ProcVal - co->SetVal;
  ddiff = ((co->PidAlg & DAVV) != 0) ? (co->ControlDiff - eold) / *o->ScanTime
                                     : (co->ProcVal - xold) / *o->ScanTime;
  if (((co->DerGain * *o->ScanTime) >= co->DerTime) || (co->DerTime <= 0))
    co->FiltDer = ddiff; /* No Filter */
  else {
    kd = 1.0 / (1.0 + co->DerGain * *o->ScanTime / co->DerTime);
    co->FiltDer += (ddiff - derold) * (1.0 - kd);
  }

  if (co->Inverse == 0)
    gain = co->Gain;
  else
    gain = -co->Gain;

  if (co->Force) {
    /* Force */
    co->OutChange = co->ForcVal - co->OutVal;
    co->OutVal = co->OutWindup = co->ForcVal;
    co->EndMin = FALSE;
    co->EndMax = FALSE;

    /* Adjust for bumpless transfer to auto */
    co->PDManOffset
        = co->OutVal - gain * co->ControlDiff - co->BiasGain * co->Bias;

    if ((co->PidAlg & IALG) != 0)
      co->AbsOut = 0.0;
    else
      co->AbsOut = co->OutVal;

    if (co->WindupMask < BIWUP)
      co->OutWindup -= co->BiasGain * co->Bias;
    if (co->WindupMask < BPIWUP)
      co->OutWindup -= gain * co->ControlDiff;

    co->AbsOut = co->OutVal - co->OutWindup;
  }

  else {
    /* Auto mode */

    dut = absut = 0.0;

    if ((co->PidAlg & IALG) != 0)
    /* Incremental algorithm */
    {
      /* Integral-part */
      if ((*o->IntOffP == FALSE) && (co->IntTime > 0))
        dut = co->ControlDiff * *o->ScanTime / co->IntTime;

      if ((co->PidAlg & PALG) != 0)
        dut *= gain;
      else
        gain = 0.0; /* Pure I-controller */

      /* Bias */
      if (co->WindupMask >= BIWUP) /* Windup on Bias */
        dut += co->BiasGain * (co->Bias - bfold);
      else
        absut = co->BiasGain * co->Bias;

      /* P-part */
      if (co->WindupMask >= BPIWUP) /* Windup on P */
        dut += ((co->PidAlg & PAVV) != 0) ? gain * (co->ControlDiff - eold)
                                          : gain * (co->ProcVal - xold);
      else
        absut += gain * co->ControlDiff;

      /* Derivative-part */
      if ((co->PidAlg & DALG) != 0) {
        if (co->WindupMask >= BPIDWUP) /* Windup on D */
          dut += gain * (co->FiltDer - derold) * co->DerTime;
        else
          absut += gain * co->FiltDer * co->DerTime;
      }

      /* Limit output */
      co->OutWindup += dut;

      if (co->OutWindup > co->MaxWindup) {
        co->OutWindup = co->MaxWindup;
        co->EndMax = TRUE;
      } else if (co->OutWindup < co->MinWindup) {
        co->OutWindup = co->MinWindup;
        co->EndMin = TRUE;
      }

      ut = co->OutWindup + absut;
      if (ut > co->MaxOut)
        ut = co->MaxOut;
      else if (ut < co->MinOut)
        ut = co->MinOut;
      dut += absut - co->AbsOut;
    }

    else
    /* Nonincremental algorithm */
    {
      /* P-part */
      ut = co->ControlDiff;
      /* Derivative-part */
      if ((co->PidAlg & DALG) != 0)
        ut += co->FiltDer * co->DerTime;
      /* Gain */
      ut *= gain;

      /* Bias and Man offset*/
      if (co->PDAbsFlag)
        co->PDManOffset = 0;
      ut += co->BiasGain * co->Bias + co->PDManOffset;

      /* Limit output */
      if (co->MaxOut > co->MinOut) {
        if (ut > co->MaxOut)
          ut = co->MaxOut;
        else if (ut < co->MinOut)
          ut = co->MinOut;
      }
      dut = ut - co->OutVal;
      absut = ut;
    }

    /* Output Auto */
    co->OutChange = dut;
    co->OutVal = ut;
    co->AbsOut = absut;
  }

  /* Transfer outputs */
  o->OutVal = co->OutVal;
  o->OutChange = co->OutChange;
  o->ControlDiff = co->ControlDiff;
  o->EndMax = co->EndMax;
  o->EndMin = co->EndMin;
}

/*_*
  OnOffBurnerFo

  @aref componoffburner
  @aref componoffburnerfo CompOnOffBurnerFo
*/
void CompOnOffBurnerFo_init(pwr_sClass_CompOnOffBurnerFo* o)
{
  pwr_tDlid dlid;
  pwr_tStatus sts;

  sts = gdh_DLRefObjectInfoAttrref(
      &o->PlcConnect, (void**)&o->PlcConnectP, &dlid);
  if (EVEN(sts))
    o->PlcConnectP = 0;
}

void CompOnOffBurnerFo_exec(plc_sThread* tp, pwr_sClass_CompOnOffBurnerFo* o)
{
  pwr_sClass_CompOnOffBurner* co = (pwr_sClass_CompOnOffBurner*)o->PlcConnectP;
  pwr_sClass_CompOnOffZoneFo* zono;
  pwr_sClass_CompOnOffZone* zonco;
  pwr_tFloat32 Cnt;

  zono = (pwr_sClass_CompOnOffZoneFo*)((char*)o->InP
      - (sizeof(pwr_sClass_CompOnOffZoneFo)
            - pwr_AlignLW(sizeof(pwr_tFloat32))));
  zonco = (pwr_sClass_CompOnOffZone*)zono->PlcConnectP;

  if (!co || !zonco)
    return;

  co->Executing = zonco->Executing;
  if (!co->Executing) {
    o->Status = co->Status = 0;
    co->BrTime = 0;
    co->TrendStatus = (pwr_tFloat32)co->Number;
    return;
  }

  if (zonco->CycleCount < 0.5)
    co->OnDetected = 0;

  if ((co->PulseOn && co->BrTime < zonco->BurnerTimeMinOn)
      || (!co->PulseOn && co->BrTime < zonco->BurnerTimeMinOff)) {
    co->BrTime += *o->ScanTime;
    return;
  }

  if (co->ManMode && co->OpMan) {
    if ((o->Status && !co->ManStatus) || (!o->Status && co->ManStatus))
      co->BrTime = 0;
    o->Status = co->Status = co->ManStatus;
    co->TrendStatus = (pwr_tFloat32)co->Number + 0.8 * (co->Status ? 1 : 0);
    co->BrTime += *o->ScanTime;
    return;
  } else
    co->ManStatus = 0;

  if (zonco->PauseMode)
    co->PulseTime = zonco->BurnerTimeMinOff;
  else
    co->PulseTime = zonco->BurnerTimeMinOn;

  Cnt = zonco->CycleCount - 100.0 * co->Number / zonco->NumberOfBurners;
  if (Cnt < 0)
    Cnt += 100;
  if (zonco->PauseMode)
    co->OffCnt = co->PulseTime / zonco->CycleTime * 100;
  else
    co->OffCnt = (zonco->CycleTime - co->PulseTime) / zonco->CycleTime * 100;

  if (Cnt >= 0 && Cnt < co->OffCnt && !co->Status) {
    // Turn on
    co->OnDetected = 1;
    co->Status = 1;
    co->BrTime = 0;
  } else if (Cnt >= co->OffCnt && co->Status) {
    // Turn off
    co->Status = 0;
    co->BrTime = 0;
  }
  co->BrTime += *o->ScanTime;
  co->TrendStatus = (pwr_tFloat32)co->Number + 0.8 * (co->Status ? 1 : 0);
  o->Status = co->Status;
}

/*_*
  CompOnOffZoneFo

  @aref componoffzone
  @aref componoffzonefo CompOnOffZoneFo
*/
void CompOnOffZoneFo_init(pwr_sClass_CompOnOffZoneFo* o)
{
  pwr_tDlid dlid;
  pwr_tStatus sts;

  sts = gdh_DLRefObjectInfoAttrref(
      &o->PlcConnect, (void**)&o->PlcConnectP, &dlid);
  if (EVEN(sts))
    o->PlcConnectP = 0;
}

void CompOnOffZoneFo_exec(plc_sThread* tp, pwr_sClass_CompOnOffZoneFo* o)
{
  pwr_sClass_CompOnOffZone* co = (pwr_sClass_CompOnOffZone*)o->PlcConnectP;

  if (!co)
    return;

  co->Power = o->Power = *o->PowerP;
  co->Executing = o->Execute = *o->ExecuteP;
  if (co->Power < co->PowerMin)
    co->Power = co->PowerMin;
  if (co->Power > co->PowerMax)
    co->Power = co->PowerMax;

  if (!co->Executing) {
    co->CycleCount = 0;
    return;
  }

  co->PauseMode
      = (co->Power / 100 > (co->BurnerTimeMinOff
                               / (co->BurnerTimeMinOn + co->BurnerTimeMinOn)))
      ? 0
      : 1;

  if (co->PauseMode) {
    if (co->Power != 100.0)
      co->CycleTime = co->BurnerTimeMinOff * 100.0 / co->Power;
  } else {
    if (!feqf(co->Power, 0.0f))
      co->CycleTime = co->BurnerTimeMinOn * 100.0 / (100.0 - co->Power);
  }
  co->CycleCount += *o->ScanTime / co->CycleTime * 100;
  if (co->CycleCount > 100)
    co->CycleCount = 0;
}

//---- modified v0.3-----------------------------------------------START--------

/*_*
  PLC interface & calculus to discrete time Internal Model Controler component

  @aref compimc
  @aref compimc_fo CompImc_Fo

  2015 - 12 - 19	Bruno: initial object. v0.1
  2016 - 04 - 11	Bruno: cleaning. v0.2
  2017 - 04 - 14  Bruno: remove "division by zero" potential bugs v0.3
  2019 - 08 - 31  Bruno: add missing links for Trim_SP and FF inputs: copy IMC_Fo to IMC	
*/

#define MAXCELLS 100
//#define Normalize(x, y, xmin, xmax, ymin, ymax) y =
//(((((ymax)-(ymin))/((xmax)-(xmin)))*((x)-(xmin)))+(ymin)) // replaced by a
// function in v0.3

void CompIMC_Fo_init(pwr_sClass_CompIMC_Fo* plc_obj)
{
  pwr_tDlid dlid;
  pwr_tStatus sts;
  sts = gdh_DLRefObjectInfoAttrref(
      &plc_obj->PlcConnect, (void**)&plc_obj->PlcConnectP, &dlid);
  if (EVEN(sts))
    plc_obj->PlcConnectP = 0;
}

void Normalize(pwr_tFloat32 x, pwr_tFloat32* y, pwr_tFloat32 xmin,
    pwr_tFloat32 xmax, pwr_tFloat32 ymin, pwr_tFloat32 ymax) // v0.3
{
  if ((xmax - xmin) != 0.0)
    *y = (ymax - ymin) / (xmax - xmin) * (x - xmin) + ymin;
  else
    return;
}

void LagFilter(plc_sThread* tp, pwr_sClass_CompIMC* plant_obj, pwr_tInt16 n,
    pwr_tFloat32 Tlag)
{
  if (Tlag < tp->ActualScanTime) {
    plant_obj->S[n + 1] = plant_obj->S[n];
    return;
  }
  pwr_tFloat32 kf = 1.0 / (1.0 + Tlag / tp->ActualScanTime);
  plant_obj->S[n + 1] = CLAMP(plant_obj->S[n + 1], 0.0, 100.0);
  plant_obj->S[n + 1] = (1.0 - kf) * plant_obj->S[n + 1] + kf * plant_obj->S[n];
}

void LeadLagFilter(plc_sThread* tp, pwr_sClass_CompIMC* plant_obj, pwr_tInt16 n,
    pwr_tFloat32 T1, pwr_tFloat32 T2)
{
  if (T2 < tp->ActualScanTime) {
    plant_obj->S[n + 1] = plant_obj->S[n];
    plant_obj->M[n] = plant_obj->S[n];
    return;
  }
  pwr_tFloat32 kc = -T1 / tp->ActualScanTime;
  pwr_tFloat32 kd = T2 / tp->ActualScanTime;
  pwr_tFloat32 ka = 1.0 + kd;
  pwr_tFloat32 kb = 1.0 - kc;
  if (ka <= 0)
    return; // v0.3
  plant_obj->S[n + 1] = CLAMP(plant_obj->S[n + 1], 0.0, 100.0);
  plant_obj->S[n + 1] = kd / ka * plant_obj->S[n + 1]
      + kb / ka * plant_obj->S[n] + kc / ka * plant_obj->M[n];
  plant_obj->M[n] = plant_obj->S[n];
}

void SouFilter(plc_sThread* tp, pwr_sClass_CompIMC* plant_obj, pwr_tInt16 n,
    pwr_tFloat32 w0P, pwr_tFloat32 ksi)
{
  if (w0P <= 0.0) {
    plant_obj->S[n + 1] = plant_obj->S[n];
    return;
  }
  pwr_tFloat32 a0 = tp->ActualScanTime * tp->ActualScanTime * w0P * w0P + 2.0 * ksi * tp->ActualScanTime * w0P + 1.0;
  pwr_tFloat32 a1 = 2.0 * (ksi * tp->ActualScanTime * w0P + 1.0);
  pwr_tFloat32 a2 = -1.0;
  pwr_tFloat32 b0 = tp->ActualScanTime * tp->ActualScanTime * w0P * w0P;
  if (a0 <= 0)
    return; // v0.3
  plant_obj->S[n + 1] = CLAMP(plant_obj->S[n + 1], 0.0, 100.0);
  plant_obj->uOutm2 = plant_obj->uOutm1;
  plant_obj->uOutm1 = plant_obj->S[n + 1];
  plant_obj->S[n + 1] = a1 / a0 * plant_obj->uOutm1
      + a2 / a0 * plant_obj->uOutm2 + b0 / a0 * plant_obj->S[n];
}

void SouTOoFilter(plc_sThread* tp, pwr_sClass_CompIMC* plant_obj, pwr_tInt16 n,
    pwr_tFloat32 w0, pwr_tFloat32 ksi, pwr_tFloat32 Tl1, pwr_tFloat32 Tl2)
{
  if (w0 <= 0.0) {
    plant_obj->S[n + 1] = plant_obj->S[n];
    return;
  }
  pwr_tFloat32 b0 = tp->ActualScanTime * tp->ActualScanTime * w0 * w0 + 2.0 * ksi * tp->ActualScanTime * w0 + 1.0;
  pwr_tFloat32 b1 = -2.0 * (ksi * tp->ActualScanTime * w0 + 1.0);
  pwr_tFloat32 b2 = 1.0;
  pwr_tFloat32 a0 = w0 * w0 * (Tl1 + tp->ActualScanTime) * (Tl2 + tp->ActualScanTime);
  pwr_tFloat32 a1 = w0 * w0 * (2.0 * Tl1 * Tl2 + tp->ActualScanTime * (Tl1 + Tl2));
  pwr_tFloat32 a2 = -w0 * w0 * Tl1 * Tl2;
  if (a0 <= 0)
    return; // v0.3
  plant_obj->S[n + 1] = CLAMP(plant_obj->S[n + 1], 0.0, 100.0);
  plant_obj->Outm2 = plant_obj->Outm1;
  plant_obj->Outm1 = plant_obj->S[n + 1];
  plant_obj->S[n + 1] = a1 / a0 * plant_obj->Outm1 + a2 / a0 * plant_obj->Outm2
      + b0 / a0 * plant_obj->S[n] + b1 / a0 * plant_obj->Inm1
      + b2 / a0 * plant_obj->Inm2;
  plant_obj->Inm2 = plant_obj->Inm1;
  plant_obj->Inm1 = plant_obj->S[n];
}

void Delay(plc_sThread* tp, pwr_sClass_CompIMC* plant_obj, pwr_tInt16 n,
    pwr_tFloat32 Delay) // Only one delay per IMC objectavailable
{
  pwr_tFloat32 OP = 0.0;
  int i, Ntime, Nscan;
  if ((int)Delay < tp->ActualScanTime) {
    plant_obj->S[n + 1] = plant_obj->S[n];
    return;
  } // return if nothing can be done
  if (!feqf(plant_obj->PrevDelay, Delay))
    for (i = MAXCELLS - 1; i >= 0; i--)
      plant_obj->D[i] = plant_obj->S[n]; // reset if delay param as changed
  plant_obj->PrevDelay = Delay; // Apply new delay
  Nscan = (int)(0.5 + Delay / tp->ActualScanTime); // Calculate number of cells needed
  if (Nscan > MAXCELLS) // Things to do if delay time is more than 100 times
  // scan time
  {
    Ntime = (int)(0.5
        + Delay
            / (tp->ActualScanTime * (pwr_tFloat32)
                        MAXCELLS)); // calculate number of time lags to count
    if (plant_obj->DtCtr == 0)
      for (i = 0; i <= MAXCELLS; i++)
        plant_obj->D[i] = plant_obj->S[n]; // reset all the array
    OP = plant_obj->D[MAXCELLS - 1]; // copy last array item to output
    if (plant_obj->DtCtr >= Ntime) // if time elapsed -> shift array
    {
      plant_obj->DtCtr = 0; // Reset time lag counter
      for (i = MAXCELLS - 1; i > 0; i--)
        plant_obj->D[i] = plant_obj->D[i - 1]; // shift all the array
      plant_obj->D[0] = plant_obj->S[n]; // copy input to first array item
    }
    plant_obj->DtCtr++; // decrement time lag counter
  } else // things to do if delay time is less than (or equal to) 100 times
  // scan time
  {
    OP = plant_obj->D[Nscan - 1]; // copy last active array item to output
    for (i = Nscan; i > 0; i--)
      plant_obj->D[i]
          = plant_obj->D[i - 1]; // shift a sufficient part of the array
    plant_obj->D[0] = plant_obj->S[n]; // copy input to first array item
  }
  plant_obj->S[n + 1] = OP; // copy to function output
}

void CompIMC_Fo_exec(plc_sThread* tp, pwr_sClass_CompIMC_Fo* plc_obj)
{
  pwr_sClass_CompIMC* plant_obj = (pwr_sClass_CompIMC*)plc_obj->PlcConnectP;
  if (!plant_obj)
    return;
  pwr_tFloat32 man_OP, sig, yr, LSP, PV, nLSP, nPV, Tl1, Tl2;

  pwr_tInt16 i;
  pwr_tFloat32 OP;

  plant_obj->PV = *plc_obj->PVP; // Process value: copy IMC_Fo to IMC
  plant_obj->SP = *plc_obj->SPP; // Setpoint value: copy IMC_Fo to IMC
  plant_obj->aut = *plc_obj->autP; // Auto input: copy IMC_Fo to IMC
  plant_obj->FF = *plc_obj->FF; // FF input: copy IMC_Fo to IMC	
  plant_obj->Trim_SP = *plc_obj->Trim_SP; // Trim_SP input: copy IMC_Fo to IMC	

  LSP = plant_obj->SP + plant_obj->Trim_SP; // Calculate working setpoint
  LSP = CLAMP(LSP, plant_obj->LL_SP, plant_obj->HL_SP); // Apply limits
  Normalize(LSP, &nLSP, plant_obj->LR_PV, plant_obj->HR_PV, 0.0,
      100.0); // Normalize setpoint value // v0.3

  PV = plant_obj->PV; // Copy from GUI
  Normalize(PV, &nPV, plant_obj->LR_PV, plant_obj->HR_PV, 0.0,
      100.0); // Normalize process value // v0.3
  sig = (plant_obj->Inverse)
      ? nLSP - nPV
      : nPV - nLSP; // Error signal after direct/inverse Comparator
  plant_obj->EP = -sig; // Calculate error value to display

  if (!plant_obj->aut) { // Manage manual mode & reset all buffers
    sig = 0;
    Normalize(*plc_obj->Man_OPP, &man_OP, plant_obj->LR_OP, plant_obj->HR_OP,
        0.0, 100.0); // v0.3

    for (i = 0; i < 12; i++)
      plant_obj->S[i] = man_OP;
    for (i = 0; i < 100; i++)
      plant_obj->D[i] = man_OP;
    for (i = 0; i < 10; i++)
      plant_obj->M[i] = man_OP;
    plant_obj->Inm1 = plant_obj->Inm2 = plant_obj->Outm1 = plant_obj->Outm2
        = man_OP;
    plant_obj->uOutm1 = plant_obj->uOutm2 = man_OP;

    yr = *plc_obj->Man_OPP;
    yr = CLAMP(yr, plant_obj->LL_OP,
        plant_obj->HL_OP); // Apply limits on control signal
    plc_obj->OP = plant_obj->OP = yr;
  } else { // Calculate IMC controller

    if (tp->ActualScanTime <= 0)
      return; // v0.3
    if (plant_obj->Accel < 1.0)
      return; // v0.3
    if (plant_obj->Gain > 0.0)
      sig /= plant_obj->Gain;
    else
      return; // Apply static gain // v0.3

    plant_obj->S[0] = sig + plant_obj->S[11]; // Add previous model's feedback

    LagFilter(tp, plant_obj, 0,
        plant_obj->RobTau); // Increasing robustness by low pass filtering

    if (plant_obj->ProcModel & 8) {
      LagFilter(tp, plant_obj, 1, plant_obj->LeadT);
      LeadLagFilter(tp, plant_obj, 2, plant_obj->LagT3,
          plant_obj->LagT3 / plant_obj->Accel);
    } else
      plant_obj->S[3] = plant_obj->S[2] = plant_obj->S[1];

    if (plant_obj->ProcModel & 1)
      LeadLagFilter(tp, plant_obj, 3, plant_obj->LagT1,
          plant_obj->LagT1 / plant_obj->Accel);
    else
      plant_obj->S[4] = plant_obj->S[3];

    if (plant_obj->ProcModel & 2)
      LeadLagFilter(tp, plant_obj, 4, plant_obj->LagT2,
          plant_obj->LagT2 / plant_obj->Accel);
    else
      plant_obj->S[5] = plant_obj->S[4];

    if (plant_obj->ProcModel & 4) {
      Tl1 = Tl2
          = plant_obj->ksi * M_PI / (2.0 * plant_obj->Accel * plant_obj->w0);
      SouTOoFilter(tp, plant_obj, 5, plant_obj->w0, plant_obj->ksi, Tl1, Tl2);
    } else
      plant_obj->S[6] = plant_obj->S[5];

    OP = plant_obj->S[6];
    OP = CLAMP(OP, 0.0, 100.0); // Apply limits on model output
    Normalize(OP, &yr, 0.0, 100.0, plant_obj->LR_OP,
        plant_obj->HR_OP); // Denormalize output // v0.3
    yr += plant_obj->FF; // Add feedforward input value
    yr = CLAMP(yr, plant_obj->LL_OP,
        plant_obj->HL_OP); // Apply limits to control signal
    plc_obj->OP = plant_obj->OP = yr; // copy to GUI objects

    // Model's feedback

    if (plant_obj->ProcModel & 1)
      LagFilter(tp, plant_obj, 6, plant_obj->LagT1);
    else
      plant_obj->S[7] = plant_obj->S[6];

    if (plant_obj->ProcModel & 2)
      LagFilter(tp, plant_obj, 7, plant_obj->LagT2);
    else
      plant_obj->S[8] = plant_obj->S[7];

    if (plant_obj->ProcModel & 8)
      LeadLagFilter(tp, plant_obj, 8, plant_obj->LeadT, plant_obj->LagT3);
    else
      plant_obj->S[9] = plant_obj->S[8];

    if (plant_obj->ProcModel & 4)
      SouFilter(tp, plant_obj, 9, plant_obj->w0, plant_obj->ksi);
    else
      plant_obj->S[10] = plant_obj->S[9];

    Delay(tp, plant_obj, 10, plant_obj->DelayT);
  }
}

//---- modified v0.3-----------------------------------------------END----

/*_*
  PLC Mode interface to a discrete time Internal Model Controler component

  @aref compmodeimc
  @aref compmodeimc_fo CompImc_Fo

  2015 - 12 - 19	Bruno: initial object.
  2016 - 04 - 11	Bruno: cleaning.
*/

void CompModeIMC_Fo_init(pwr_sClass_CompModeIMC_Fo* plc_obj)
{
  pwr_tDlid dlid;
  pwr_tStatus sts;
  sts = gdh_DLRefObjectInfoAttrref(
      &plc_obj->PlcConnect, (void**)&plc_obj->PlcConnectP, &dlid);
  if (EVEN(sts))
    plc_obj->PlcConnectP = 0;
}

void CompModeIMC_Fo_exec(plc_sThread* tp, pwr_sClass_CompModeIMC_Fo* plc_obj)
{
  pwr_sClass_CompModeIMC* plant_obj
      = (pwr_sClass_CompModeIMC*)plc_obj->PlcConnectP;
  if (!plc_obj)
    return;

  plant_obj->PV = *plc_obj->PVP; // Copy from GUI
  plant_obj->OP = *plc_obj->OPP; // Copy from GUI

  if ((plant_obj->Mode == pwr_eImcModeEnum_Manual) // Manage manual mode
      && (plant_obj->PrevMode != pwr_eImcModeEnum_Manual))
    plant_obj->Loc_OP = plant_obj->OP;

  if (plant_obj->Mode != pwr_eImcModeEnum_Manual) // Manage auto mode
    plant_obj->Loc_OP = *plc_obj->OPP;
  else
    plc_obj->Man_OP = plant_obj->Loc_OP;

  if ((plant_obj->Mode != pwr_eImcModeEnum_Manual)
      && (plant_obj->PrevMode == pwr_eImcModeEnum_Manual)
      && (plant_obj->BumpLess)) // copy PV to SP when bumpless is set & aut to
    // man transition
    plant_obj->Loc_SP = plant_obj->PV;

  if ((plant_obj->Mode == pwr_eImcModeEnum_Auto)
      && (plant_obj->PrevMode == pwr_eImcModeEnum_Remote)
      && (plant_obj->BumpLess)) // copy PV to SP when bumpless is set & rem to
    // man transition
    plant_obj->Loc_SP = plant_obj->PV;

  if (!feqf(plant_obj->Loc_SP, plant_obj->SP))
    plant_obj->SP = plant_obj->Loc_SP; // set SP to manual GUI SP setting
  if (plant_obj->Mode == pwr_eImcModeEnum_Remote)
    plant_obj->SP
        = *plc_obj
               ->Rem_SPP; // set SP to external SP when remote mode is selected
  plc_obj->SP = plant_obj->SP; // copy plant SP to plc SP
  plc_obj->aut = (plant_obj->Mode
      != pwr_eImcModeEnum_Manual); // set aut output on plc object
  plant_obj->EP = (plant_obj->PV - plant_obj->SP); // calculate EP
  plant_obj->PrevMode = plant_obj->Mode; // memorize last mode
}

/*_*
  CompCurveTabValueFo

  @aref compcurvetabvaluefo CompCurveTabValueFo
*/
void CompCurveTabValueFo_init(pwr_sClass_CompCurveTabValueFo* o)
{
  pwr_tDlid dlid;
  pwr_tStatus sts;

  sts = gdh_DLRefObjectInfoAttrref(
      &o->PlcConnect, (void**)&o->PlcConnectP, &dlid);
  if (EVEN(sts))
    o->PlcConnectP = 0;

  if (ODD(sts))
    sts = gdh_DLRefObjectInfoAttrref(
        &((pwr_sClass_CompCurveTabValue*)o->PlcConnectP)->CurveTabObject,
        (void**)&o->CurveTabObjectP, &dlid);
  if (EVEN(sts))
    o->CurveTabObjectP = 0;
}

void CompCurveTabValueFo_exec(
    plc_sThread* tp, pwr_sClass_CompCurveTabValueFo* o)
{
  pwr_sClass_CompCurveTabValue* co
      = (pwr_sClass_CompCurveTabValue*)o->PlcConnectP;
  pwr_sClass_CompCurveTab* to = (pwr_sClass_CompCurveTab*)o->CurveTabObjectP;
  int ii;
  float x0, x1, y0, y1;
  pwr_tInt32 confError = 0;

  if (!co || !to)
    return;

  o->ActVal = *o->InP;

  if (to->NoOfPoints <= 0)
    confError = 1;
  else if (to->NoOfPoints > 50)
    confError = 2;
  else {
    for (ii = 1; ii < to->NoOfPoints && !confError; ii++) {
      if (to->X[ii] < to->X[ii - 1])
        confError = 3;
    }
  }
  to->ConfigurationError = confError;

  if (!confError) {
    x1 = x0 = to->X[0];
    y1 = y0 = to->Y[0];
    for (ii = 1; ii<to->NoOfPoints&& * o->InP> x1; ii++) {
      x0 = x1;
      x1 = to->X[ii];
      y0 = y1;
      y1 = to->Y[ii];
    }
    if (*o->InP <= x0)
      o->ActVal = y0; /* End of table */
    else if (*o->InP >= x1)
      o->ActVal = y1; /* End of table */
    else
      o->ActVal
          = y0 + (y1 - y0) * (*o->InP - x0) / (x1 - x0); /* Interpolation */
  }
  co->ActVal = o->ActVal;
  co->In = *o->InP;
}

/*_*
  CompCurvePolValueFo

  @aref compcurvetabvaluefo CompCurvePolValueFo
*/
#define CURVEPOL_POINTS 50

static void CompCurvePolValueFo_draw(pwr_sClass_CompCurvePol* o)
{
  int i, j;
  pwr_tFloat32 x, y;
  pwr_tFloat32 dx = (o->MaxShowX - o->MinShowX) / CURVEPOL_POINTS;

  if (o->Power == 1) {
    o->DisplayNoOfPoints = 2;
    o->DisplayX[0] = o->MinShowX;
    o->DisplayX[1] = o->MaxShowX;
    o->DisplayY[0] = o->PolyCoeff[0] + o->MinShowX * o->PolyCoeff[1];
    o->DisplayY[1] = o->PolyCoeff[0] + o->MaxShowX * o->PolyCoeff[1];
  } else {
    x = o->MinShowX;
    for (i = 0; i <= CURVEPOL_POINTS; i++) {
      y = 0;
      for (j = o->Power; j > 0; j--)
        y = x * (o->PolyCoeff[j] + y);
      y += o->PolyCoeff[0];
      o->DisplayX[i] = x;
      o->DisplayY[i] = y;
      x += dx;
    }
    o->DisplayNoOfPoints = CURVEPOL_POINTS + 1;
  }
  o->UpdateDisplay = 0;
}

void CompCurvePolValueFo_init(pwr_sClass_CompCurvePolValueFo* o)
{
  pwr_tDlid dlid;
  pwr_tStatus sts;

  sts = gdh_DLRefObjectInfoAttrref(
      &o->PlcConnect, (void**)&o->PlcConnectP, &dlid);
  if (EVEN(sts))
    o->PlcConnectP = 0;

  if (ODD(sts))
    sts = gdh_DLRefObjectInfoAttrref(
        &((pwr_sClass_CompCurvePolValue*)o->PlcConnectP)->CurvePolObject,
        (void**)&o->CurvePolObjectP, &dlid);
  if (EVEN(sts))
    o->CurvePolObjectP = 0;

  if (o->CurvePolObjectP
      && ((pwr_sClass_CompCurvePol*)o->CurvePolObjectP)->UpdateDisplay)
    CompCurvePolValueFo_draw(o->CurvePolObjectP);
}

void CompCurvePolValueFo_exec(
    plc_sThread* tp, pwr_sClass_CompCurvePolValueFo* o)
{
  pwr_sClass_CompCurvePolValue* co
      = (pwr_sClass_CompCurvePolValue*)o->PlcConnectP;
  pwr_sClass_CompCurvePol* to = (pwr_sClass_CompCurvePol*)o->CurvePolObjectP;
  int i;
  float x, y;

  if (!co || !to)
    return;

  o->ActVal = *o->InP;

  if (to->Power > 5) {
    to->ConfigurationError = 1;
    return;
  } else
    to->ConfigurationError = 0;

  if (!to->ConfigurationError) {
    x = *o->InP;
    y = 0;
    for (i = to->Power; i > 0; i--)
      y = x * (to->PolyCoeff[i] + y);
    y += to->PolyCoeff[0];
    o->ActVal = y;

    if (to->UpdateDisplay)
      CompCurvePolValueFo_draw(to);
  }
  co->ActVal = o->ActVal;
  co->In = *o->InP;
}
