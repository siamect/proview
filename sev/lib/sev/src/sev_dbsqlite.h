/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#ifndef sev_dbsqlite_h
#define sev_dbsqlite_h
#if defined PWRE_CONF_SQLITE3

#include "sev_db.h"
#include <sqlite3.h>

class sev_dbsqlite_env;

class sev_dbsqlite : public sev_db {
public:
  static const unsigned int constMaxColNameLength = 64;

  sqlite3* m_con;
  char m_systemName[80];

  sev_dbsqlite()
  {
    strcpy(m_systemName, "");
  }
  ~sev_dbsqlite();

  int checkAndUpdateVersion(unsigned int version);
  int updateDBToSevVersion2(void);
  int createSevVersion2Tables(void);
  int createSevVersion3Tables(void);
  int get_systemname();

  int open_db();
  int check_item(pwr_tStatus* sts, pwr_tOid oid, char* oname, char* aname,
      pwr_tDeltaTime storagetime, pwr_eType type, unsigned int size,
      char* description, char* unit, pwr_tFloat32 scantime,
      pwr_tFloat32 deadband, pwr_tMask options, unsigned int* idx);
  int add_item(pwr_tStatus* sts, pwr_tOid oid, char* oname, char* aname,
      pwr_tDeltaTime storagetime, pwr_eType type, unsigned int size,
      char* description, char* unit, pwr_tFloat32 scantime,
      pwr_tFloat32 deadband, pwr_tMask options, unsigned int* idx);
  int store_value(pwr_tStatus* sts, void* thread, int item_idx, int attr_idx,
      pwr_tTime time, void* buf, unsigned int size);
  int get_values(pwr_tStatus* sts, void* thread, pwr_tOid oid,
      pwr_tMask options, float deadband, char* aname, pwr_eType type,
      unsigned int size, pwr_tFloat32 scantime, pwr_tTime* creatime,
      pwr_tTime* starttime, pwr_tTime* endtime, int maxsize, pwr_tTime** tbuf,
      void** vbuf, unsigned int* bsize);
  int delete_old_data(pwr_tStatus* sts, void* thread, char* tablename,
      pwr_tMask options, pwr_tTime limit, pwr_tFloat32 scantime,
      pwr_tFloat32 garbagecycle);
  int delete_item(pwr_tStatus* sts, pwr_tOid oid, char* aname);

  int get_items(pwr_tStatus* sts);
  int create_table(pwr_tStatus* sts, char* tablename, pwr_eType type,
      unsigned int size, pwr_tMask options, float deadband);
  int delete_table(pwr_tStatus* sts, char* tablename);
  int store_item(pwr_tStatus* sts, char* tabelname, pwr_tOid oid, char* oname,
      char* aname, pwr_tDeltaTime storagetime, pwr_eType vtype,
      unsigned int vsize, char* description, char* unit, pwr_tFloat32 scantime,
      pwr_tFloat32 deadband, pwr_tMask options);
  int remove_item(pwr_tStatus* sts, pwr_tOid oid, char* aname);
  static sev_db* open_database();
  static char* oid_to_table(pwr_tOid oid, char* aname);
  char* dbName();
  char* pwrtype_to_type(pwr_eType type, unsigned int size);
  static int timestr_to_time(char* tstr, pwr_tTime* ts);
  int check_objectitem(pwr_tStatus* sts, char* tablename, pwr_tOid oid,
      char* oname, char* aname, pwr_tDeltaTime storagetime, char* description,
      pwr_tFloat32 scantime, pwr_tFloat32 deadband, pwr_tMask options,
      unsigned int attrnum, sev_sHistAttr* attr, unsigned int* idx);
  int add_objectitem(pwr_tStatus* sts, char* tablename, pwr_tOid oid,
      char* oname, char* aname, pwr_tDeltaTime storagetime, char* description,
      pwr_tFloat32 scantime, pwr_tFloat32 deadband, pwr_tMask options,
      unsigned int attrnum, sev_sHistAttr* attr, unsigned int* idx);
  int store_objectitem(pwr_tStatus* sts, char* tablename, pwr_tOid oid,
      char* oname, char* aname, pwr_tDeltaTime storagetime, char* description,
      pwr_tFloat32 scantime, pwr_tFloat32 deadband, pwr_tMask options);
  int create_objecttable(
      pwr_tStatus* sts, char* tablename, pwr_tMask options, float deadband);
  int store_objectvalue(pwr_tStatus* sts, int item_idx, int attr_idx,
      pwr_tTime time, void* buf, void* oldbuf, unsigned int size);
  int get_item(pwr_tStatus* sts, void* thread, sev_item* item, pwr_tOid oid,
      char* attributename);
  int get_objectitem(pwr_tStatus* sts, void* thread, sev_item* item,
      pwr_tOid oid, char* attributename);
  int get_objectitems(pwr_tStatus* sts);
  int get_objectitemattributes(
      pwr_tStatus* sts, sev_item* item, char* tablename);
  int check_objectitemattr(pwr_tStatus* sts, char* tablename, pwr_tOid oid,
      char* aname, char* oname, pwr_eType type, unsigned int size,
      unsigned int* idx);
  int delete_old_objectdata(pwr_tStatus* sts, void* thread, char* tablename,
      pwr_tMask options, pwr_tTime limit, pwr_tFloat32 scantime,
      pwr_tFloat32 garbagecycle);
  int check_deadband(pwr_eType type, unsigned int size, pwr_tFloat32 deadband,
      void* value, void* oldvalue);
  int get_objectvalues(pwr_tStatus* sts, void* thread, sev_item* item,
      unsigned int size, pwr_tTime* starttime, pwr_tTime* endtime, int maxsize,
      pwr_tTime** tbuf, void** vbuf, unsigned int* bsize);
  int delete_event_table(pwr_tStatus* sts, char* tablename);
  int create_event_table(pwr_tStatus* sts, char* tablename, pwr_tMask options);
  int store_event(pwr_tStatus* sts, void* thread, int item_idx, sev_event* ep);
  pwr_tUInt64 get_minFromIntegerColumn(char* tablename, char* colname);
  pwr_tUInt64 get_maxFromIntegerColumn(char* tablename, char* colname);
  pwr_tUInt64 get_nextAutoIncrement(char* tablename);
  int handle_itemchange(
      pwr_tStatus* sts, char* tablename, unsigned int item_idx);
  int handle_objectchange(
      pwr_tStatus* sts, char* tablename, unsigned int item_idx, bool newObject);
  int repair_table(pwr_tStatus* sts, char* tablename);
  int alter_engine(pwr_tStatus* sts, char* tablename);
  int store_stat(sev_sStat* stat);
  int begin_transaction(void* thread);
  int commit_transaction(void* thread);
  inline char* create_colName(unsigned int index, char* attributename)
  {
    static char colName[constMaxColNameLength];
    strncpy(colName, attributename, constMaxColNameLength);
    if (strlen(attributename) > constMaxColNameLength) {
      colName[constMaxColNameLength - 5] = 0;
      snprintf(&colName[strlen(colName)], 5, "_%d", index);
    }
    return colName;
  }
};
#endif
#endif
