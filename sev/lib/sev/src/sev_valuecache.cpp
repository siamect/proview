/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <math.h>

#include "pwr_baseclasses.h"
#include "co_math.h"
#include "rt_gdh.h"

#include "sev_valuecache.h"

sev_valuecache::sev_valuecache(sev_eCvType type)
    : m_type(type), m_userdata(0), m_useridx(0), m_write_cb(0)
{
}

sev_valuecache::sev_valuecache(const sev_valuecache& x)
    : m_type(x.m_type), m_userdata(x.m_userdata), m_useridx(x.m_useridx),
      m_write_cb(x.m_write_cb)
{
}

sev_valuecache::~sev_valuecache()
{
}

void sev_valuecache::add(void* value, pwr_tTime* time, void* thread)
{
}

int sev_valuecache::evaluate(double maxtime, void* thread)
{
  return SEV__NOWRITE;
}

void sev_valuecache::write(int index, void* thread)
{
}

void sev_valuecache::set_write_cb(
    void (*write_cb)(void*, int, void*, pwr_tTime*, void*), void* userdata,
    int idx)
{
  m_write_cb = write_cb;
  m_userdata = userdata;
  m_useridx = idx;
}

const int sev_valuecache_double::m_size = VALUECACHE_SIZE;

sev_valuecache_double::sev_valuecache_double(
    sev_eCvType type, double deadband_value, double deadband_time)
    : sev_valuecache(type), m_length(0), m_first(0), m_last(0), m_inited(false),
      m_deadband_value(deadband_value), m_deadband_time(deadband_time)
{
  memset(&m_wval, 0, sizeof(m_wval));
  time_GetTime(&m_start_time);
}

sev_valuecache_double::sev_valuecache_double(const sev_valuecache_double& x)
    : sev_valuecache(x), m_length(x.m_length), m_first(x.m_first),
      m_last(x.m_last), m_inited(x.m_inited), m_k(x.m_k),
      m_deadband(x.m_deadband), m_deadband_value(x.m_deadband_value),
      m_deadband_time(x.m_deadband_time), m_last_opt_write(x.m_last_opt_write),
      m_start_time(x.m_start_time), m_last_k(x.m_last_k)
{
  memcpy(m_val, x.m_val, sizeof(m_val));
  memcpy(&m_wval, &x.m_wval, sizeof(m_wval));
}

sev_valuecache_double::~sev_valuecache_double()
{
}

int sev_valuecache_double::length()
{
  return m_length;
}

int sev_valuecache_double::idx(int index)
{
  if (!m_length)
    return 0;
  if (index >= m_length)
    return 0;
  int i = m_last - index;
  if (i < 0)
    i += m_size;
  return i;
}

sev_sCacheValueDouble& sev_valuecache_double::operator[](const int index)
{
  return m_val[idx(index)];
}

sev_sCacheValueDouble& sev_valuecache_double::wval()
{
  return m_wval;
}

void sev_valuecache_double::add(void* value, pwr_tTime* t, void* thread)
{
  double val = *(double*)value;
  double time;
  pwr_tDeltaTime dt;

  time_Adiff_NE(&dt, t, &m_start_time);
  time_DToFloat64(&time, &dt);

  // Store optimized write index before adding
  m_last_opt_write = get_optimal_write();

  bool update_k = m_length < m_size;
  if (!m_length) {
    m_val[0].val = val;
    m_val[0].time = time;
    m_length++;
  } else {
    if (++m_last >= m_size)
      m_last -= m_size;
    m_val[m_last].val = val;
    m_val[m_last].time = time;
    m_length++;
    if (m_last == m_first) {
      m_first++;
      if (m_first >= m_size)
        m_first -= m_size;
      m_length--;
    }
  }
  if (!m_inited) {
    write(0, thread);
    m_inited = true;
    return;
  }

  if (update_k) {
    calculate_k();
    // Update epsilon for all data
    calculate_epsilon();
  } else
    calculate_epsilon(0);
}

int sev_valuecache_double::evaluate(double maxtime, void* thread)
{
  int value_added = 1;
  int sts = SEV__NOWRITE;

  while (1) {
    if ((!feq(maxtime, 0.0) && (m_val[m_last].time - m_wval.time) > maxtime)
        || !check_deadband()) {
      // Store optimal value
      write(m_last_opt_write + value_added, thread);
      sts = SEV__SUCCESS;
    } else
      break;

    calculate_k();
    calculate_epsilon();
    m_last_opt_write = get_optimal_write();
    value_added = 0;
  }
  return sts;
}

void sev_valuecache_double::calculate_k()
{
  double xysum = 0;
  double x2sum = 0;

  for (int i = 0; i < length(); i++) {
    int ii = idx(i);
    xysum += (m_val[ii].val - m_wval.val) * (m_val[ii].time - m_wval.time);
    x2sum += (m_val[ii].val - m_wval.val) * (m_val[ii].val - m_wval.val);
  }
  if (x2sum < DBL_EPSILON) {
    m_k = 0;
    m_m = m_wval.val;
    m_deadband = m_deadband_value;
  } else if (ABS(xysum) < DBL_EPSILON) {
    m_k = 1E32;
    m_m = m_wval.time;
    m_deadband = m_deadband_time;
  } else {
    m_k = x2sum / xysum;
    m_m = m_wval.val - m_wval.time * m_k;
    m_deadband = m_deadband_value
        + ABS(atan(m_k)) / (M_PI / 2) * (m_deadband_time - m_deadband_value);
  }
}

void sev_valuecache_double::write(int index, void* thread)
{
  int ii = idx(index);
  double wval, wtime;

  if (m_type == sev_eCvType_Mean) {
    if (ABS(m_last_k) < 1) {
      m_wval.val = m_wval.val + m_last_k * (m_val[ii].time - m_wval.time);
      m_wval.time = m_val[ii].time;
    } else {
      m_wval.time = m_wval.time + (m_val[ii].val - m_wval.val) / m_last_k;
      m_wval.val = m_val[ii].val;
    }
    wval = m_wval.val;
    wtime = m_wval.time;
  } else {
    wval = m_val[ii].val;
    wtime = m_val[ii].time;
    m_wval = m_val[ii];
  }

  if (index == 0) {
    m_last = m_first = 0;
    m_length = 0;
  } else {
    m_first = ii + 1;
    if (m_first >= m_size)
      m_first -= m_size;
    m_length = m_last - m_first + 1;
    if (m_length < 0)
      m_length += m_size;
  }
  if (m_write_cb) {
    pwr_tTime time;
    pwr_tDeltaTime dt;
    time_Float64ToD(&dt, wtime);
    time_Aadd(&time, &m_start_time, &dt);
    (m_write_cb)(m_userdata, m_useridx, &wval, &time, thread);
  }
}

// Calculate epsilon for all
void sev_valuecache_double::calculate_epsilon()
{
  if (m_length == 1) {
    m_val[m_first].epsilon = 0;
    return;
  }

  for (int i = 0; i < m_length; i++)
    calculate_epsilon(i);
}

// Calculate epsilon for one index
void sev_valuecache_double::calculate_epsilon(int index)
{
  int ii = idx(index);
  if (m_k >= 1E32) {
    m_val[ii].epsilon = ABS(m_val[ii].time - m_wval.time);
  } else {
    m_val[ii].epsilon
        = ABS(m_val[ii].val - m_k * m_val[ii].time - m_m) / sqrt(1 + m_k * m_k);
  }
}

// Check deadband for one index
// Returns true if all values inside deadband.
bool sev_valuecache_double::check_deadband(int index)
{
  if (m_val[idx(index)].epsilon > m_deadband)
    return false;
  return true;
}

// Check deadband for all values
// Returns true if all values inside deadband.
bool sev_valuecache_double::check_deadband()
{
  for (int i = 0; i < m_length; i++) {
    int ii = idx(i);
    if (m_val[ii].epsilon > m_deadband)
      return false;
  }
  return true;
}

int sev_valuecache_double::get_optimal_write()
{
  if (m_type == sev_eCvType_Mean) {
    m_last_k = m_k;
    return 0;
  }

  double min_weight = 10E32;
  int ii;
  double dist;
  double weight;
  int min_idx = 0;

  for (int i = 0; i < m_length; i++) {
    if (m_length == m_size && i == m_length - 1)
      continue;

    ii = idx(i);
    dist = sqrt((m_val[ii].val - m_wval.val) * (m_val[ii].val - m_wval.val)
        + (m_val[ii].time - m_wval.time) * (m_val[ii].time - m_wval.time));
    weight = m_val[ii].epsilon / dist;
    if (weight < min_weight) {
      min_weight = weight;
      min_idx = i;
    }
  }
  return min_idx;
}

double sev_valuecache_double::epsilon(int index)
{
  return m_val[idx(index)].epsilon;
}

double sev_valuecache_double::get_k()
{
  return m_k;
}

sev_valuecache_bool::sev_valuecache_bool(sev_eCvType type)
    : sev_valuecache(type), m_inited(false)
{
  memset(&m_wval, 0, sizeof(m_wval));
}

sev_valuecache_bool::sev_valuecache_bool(const sev_valuecache_bool& x)
    : sev_valuecache(x), m_inited(x.m_inited)
{
  memcpy(&m_wval, &x.m_wval, sizeof(m_wval));
}

sev_valuecache_bool::~sev_valuecache_bool()
{
}

sev_sCacheValueBool& sev_valuecache_bool::wval()
{
  return m_wval;
}

void sev_valuecache_bool::add(void* value, pwr_tTime* t, void* thread)
{
  m_val.val = *(pwr_tBoolean*)value;
  m_val.time = *t;

  if (!m_inited) {
    // Store value
    write(0, thread);
    m_inited = true;
  }
}

int sev_valuecache_bool::evaluate(double maxtime, void* thread)
{
  if (m_val.val != m_wval.val) {
    write(0, thread);
    return SEV__SUCCESS;
  }
  return SEV__NOWRITE;
}

void sev_valuecache_bool::write(int index, void* thread)
{
  m_wval.val = m_val.val;
  m_wval.time = m_val.time;
  if (m_write_cb)
    (m_write_cb)(m_userdata, m_useridx, &m_wval.val, &m_wval.time, thread);
}
