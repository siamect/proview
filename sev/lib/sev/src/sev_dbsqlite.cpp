/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#if defined PWRE_CONF_SQLITE3

#include <sstream>
#include <string>

#include "pwr_names.h"

#include "co_cdh.h"
#include "co_cnf.h"
#include "co_dcli.h"
#include "co_string.h"
#include "co_syi.h"
#include "co_time.h"

#include "rt_errh.h"
#include "rt_load.h"

#include "sev_dbsqlite.h"

int sev_dbsqlite::get_systemname()
{
  FILE* file;
  pwr_tFileName fname;
  char nodename[40];
  char* bus_str;
  int bus;
  char line[200];
  pwr_tStatus sts;

  if (!streq(m_systemName, ""))
    return 1;

  syi_NodeName(&sts, nodename, sizeof(nodename));
  if (EVEN(sts))
    return 0;

  bus_str = getenv("PWR_BUS_ID");
  if (!bus_str)
    return 0;
  if (sscanf(bus_str, "%d", &bus) != 1)
    return 0;

  sprintf(fname, pwr_cNameBoot, load_cDirectory, cdh_Low(nodename), bus);
  dcli_translate_filename(fname, fname);
  file = fopen(fname, "r");
  if (file == 0) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("** Warning, systemname not found\n");
    return 0;
  }

  if (!dcli_read_line(line, sizeof(line), file))
    return 0;
  if (!dcli_read_line(line, sizeof(line), file))
    return 0;

  strcpy(m_systemName, line);
  return 1;
}

char* sev_dbsqlite::dbName(void)
{
  static char dbname[80];

  get_systemname();
  strcpy(dbname, "pwrp__");
  strcat(dbname, m_systemName);
  str_ToLower(dbname, dbname);

  return dbname;
}

sev_db* sev_dbsqlite::open_database()
{
  sev_dbsqlite* db;

  db = new sev_dbsqlite();

  db->open_db();

  errh_Info("Database opened '%s'", db->dbName());

  return db;
}

int sev_dbsqlite::open_db()
{
  pwr_tFileName dbname;
  char query[400];
  char* errmsg;
  int rc;

  sprintf(dbname, "$pwrp_db/%s.dbsqlite", dbName());
  dcli_translate_filename(dbname, dbname);

  rc = sqlite3_open_v2(dbname, &m_con, SQLITE_OPEN_READWRITE, 0);
  if (rc != SQLITE_OK) {
    // Not yet created
    rc = sqlite3_open_v2(
        dbname, &m_con, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, 0);
    if (rc != SQLITE_OK) {
      printf("Open database error\n");
      exit(0);
    }

    sprintf(query, "create table items ("
                   "id integer not null primary key autoincrement,"
                   "tablename varchar(255),"
                   "vid int unsigned,"
                   "oix int unsigned,"
                   "oname varchar(255),"
                   "aname varchar(255),"
                   "uptime datetime,"
                   "cretime datetime,"
                   "storagetime int unsigned,"
                   "deadband float,"
                   "options int unsigned,"
                   "scantime float,"
                   "description varchar(80),"
                   "vtype int unsigned,"
                   "vsize int unsigned,"
                   "unit varchar(16));");

    rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
    if (rc != SQLITE_OK) {
      printf("Create items table, %s\n", errmsg);
      sqlite3_free(errmsg);
    }
    createSevVersion2Tables();
    createSevVersion3Tables();
  }

  errh_Info("Database opened '%s'", dbName());

  return 1;
}

int sev_dbsqlite::checkAndUpdateVersion(unsigned int version)
{
  return 1;
}

int sev_dbsqlite::createSevVersion2Tables(void)
{
  char query[400];
  char* errmsg;

  sprintf(query, "create table sev_version ("
                 "version int unsigned not null primary key);");
  int rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Create sev_version table: %s\n", errmsg);
    sqlite3_free(errmsg);
  }

  sprintf(query, "insert into sev_version (version) values(%d)", sev_cVersion);
  rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Insert into table sev_version: %s\n", errmsg);
    sqlite3_free(errmsg);
  }

  sprintf(query, "create table objectitems ("
                 "id integer not null primary key autoincrement,"
                 "tablename varchar(255),"
                 "vid int unsigned,"
                 "oix int unsigned,"
                 "oname varchar(255),"
                 "aname varchar(255),"
                 "uptime datetime,"
                 "cretime datetime,"
                 "storagetime int unsigned,"
                 "deadband float,"
                 "options int unsigned,"
                 "scantime float,"
                 "description varchar(80));");

  rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Create objectitems table: %s\n", errmsg);
    sqlite3_free(errmsg);
  }

  sprintf(query, "create table objectitemattributes ("
                 "tablename varchar(255) not null,"
                 "attributename varchar(255) not null,"
                 "attributeidx int unsigned not null,"
                 "attributetype int unsigned not null,"
                 "attributesize int unsigned not null,"
                 "PRIMARY KEY(tablename, attributename));");

  rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Create objectitemattributes table: %s\n", errmsg);
    sqlite3_free(errmsg);
  }

  return 1;
}

int sev_dbsqlite::createSevVersion3Tables(void)
{
  char query[400];
  char* errmsg;

  sprintf(query,
      "create table sev_stat (current_load float,medium_load float,"
      "storage_rate float,medium_storage_rate float,"
      "datastore_msg_cnt int unsigned,dataget_msg_cnt int unsigned,"
      "items_msg_cnt int unsigned,eventstore_msg_cnt int unsigned);");
  int rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Create sev_stat table: %s\n", errmsg);
    sqlite3_free(errmsg);
  }
  sprintf(
      query, "insert into sev_stat (current_load, medium_load) values(0,0)");
  rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Insert into table sev_stat: %s\n", errmsg);
    sqlite3_free(errmsg);
  }
  return 1;
}

int sev_dbsqlite::create_table(pwr_tStatus* sts, char* tablename,
    pwr_eType type, unsigned int size, pwr_tMask options, float deadband)
{
  char query[400];
  char* errmsg;
  char timeformatstr[80];
  char jumpstr[80];
  char idtypestr[20];
  char readoptstr[80];
  char enginestr[100] = "";

  if (options & pwr_mSevOptionsMask_PosixTime) {
    if (options & pwr_mSevOptionsMask_HighTimeResolution) {
      // Posix time, high resolution
      strcpy(timeformatstr, "time int unsigned, ntime int unsigned");
      strcpy(idtypestr, "integer");
    } else {
      // Posix time, low resolution
      strcpy(timeformatstr, "time int unsigned");
      strcpy(idtypestr, "integer");
    }
  } else {
    if (options & pwr_mSevOptionsMask_HighTimeResolution) {
      // Sql time, high resolution
      strcpy(timeformatstr, "time datetime not null, ntime int unsigned");
      strcpy(idtypestr, "integer");
    } else {
      // Sql time, low resolution
      strcpy(timeformatstr, "time datetime not null");
      strcpy(idtypestr, "integer");
    }
  }

  if (options & pwr_mSevOptionsMask_ReadOptimized)
    sprintf(readoptstr, "id %s not null primary key autoincrement,", idtypestr);
  else
    strcpy(readoptstr, "");

  if (options & pwr_mSevOptionsMask_UseDeadBand)
    strcpy(jumpstr, ",jump tinyint unsigned");
  else
    strcpy(jumpstr, "");

  sprintf(query, "create table %s ( %s"
                 "%s, value %s %s)%s;",
      tablename, readoptstr, timeformatstr, pwrtype_to_type(type, size),
      jumpstr, enginestr);

  int rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Create table: %s\n", errmsg);
    sqlite3_free(errmsg);
    *sts = SEV__DBERROR;
    return 0;
  }

  sprintf(query, "create index %s_time_idx on %s (time)", tablename, tablename);

  rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Create table: %s\n", errmsg);
    sqlite3_free(errmsg);
    *sts = SEV__DBERROR;
    return 0;
  }

  return 1;
}

int sev_dbsqlite::delete_table(pwr_tStatus* sts, char* tablename)
{
  char query[200];
  char* errmsg;

  sprintf(query, "drop table %s;", tablename);

  int rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Delete table: %s\n", errmsg);
    sqlite3_free(errmsg);
    *sts = SEV__DBERROR;
    return 0;
  }
  return 1;
}

int sev_dbsqlite::create_event_table(
    pwr_tStatus* sts, char* tablename, pwr_tMask options)
{
  char query[530];
  char* errmsg;
  char timeformatstr[80];
  char jumpstr[80];
  char idtypestr[20];
  char readoptstr[80];
  char enginestr[100] = "";

  if (options & pwr_mSevOptionsMask_PosixTime) {
    if (options & pwr_mSevOptionsMask_HighTimeResolution) {
      // Posix time, high resolution
      strcpy(timeformatstr, "time int unsigned, ntime int unsigned");
      strcpy(idtypestr, "bigint");
    } else {
      // Posix time, low resolution
      strcpy(timeformatstr, "time int unsigned");
      strcpy(idtypestr, "int");
    }
  } else {
    if (options & pwr_mSevOptionsMask_HighTimeResolution) {
      // Sql time, high resolution
      strcpy(timeformatstr, "time datetime not null, ntime int unsigned");
      strcpy(idtypestr, "bigint");
    } else {
      // Sql time, low resolution
      strcpy(timeformatstr, "time datetime not null");
      strcpy(idtypestr, "int");
    }
  }

  if (options & pwr_mSevOptionsMask_ReadOptimized)
    sprintf(readoptstr, "id %s unsigned not null primary key auto_increment,",
        idtypestr);
  else
    strcpy(readoptstr, "");

  strcpy(jumpstr, "");

  sprintf(query, "create table %s ( %s"
                 "%s, eventtype int, eventprio int, eventid_nix int, "
                 "eventid_birthtime int, eventid_idx int,"
                 "supobject_vid int unsigned, supobject_oix int unsigned, "
                 "supobject_offset int unsigned,"
                 "supobject_size int unsigned,"
                 "eventtext varchar(80), eventname varchar(80))%s;",
      tablename, readoptstr, timeformatstr, enginestr);

  int rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Create table: %s\n", errmsg);
    sqlite3_free(errmsg);
    *sts = SEV__DBERROR;
    return 0;
  }

  sprintf(query, "create index %s_time_idx on %s (time)", tablename, tablename);
  rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Create table: %s\n", errmsg);
    sqlite3_free(errmsg);
    *sts = SEV__DBERROR;
    return 0;
  }

  return 1;
}

int sev_dbsqlite::delete_event_table(pwr_tStatus* sts, char* tablename)
{
  char query[200];
  char* errmsg;

  sprintf(query, "drop table %s;", tablename);

  int rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Delete table: %s\n", errmsg);
    sqlite3_free(errmsg);
    *sts = SEV__DBERROR;
    return 0;
  }
  return 1;
}

int sev_dbsqlite::store_item(pwr_tStatus* sts, char* tablename, pwr_tOid oid,
    char* oname, char* aname, pwr_tDeltaTime storagetime, pwr_eType vtype,
    unsigned int vsize, char* description, char* unit, pwr_tFloat32 scantime,
    pwr_tFloat32 deadband, pwr_tMask options)
{
  char query[800];
  char* errmsg;
  char timestr[40];
  pwr_tTime creatime;

  time_GetTime(&creatime);
  time_AtoAscii(
      &creatime, time_eFormat_NumDateAndTime, timestr, sizeof(timestr));
  timestr[19] = 0;

  unsigned int next_id = get_nextAutoIncrement((char*)"items");
  /*
    char volName[32];
    strncpy(volName, oname, sizeof(volName));
    for ( char *s = volName; *s; s++) {
      if ( *s == ':') {
        *s = 0;
        break;
      }
    }
    sprintf(tablename, "%s_%d", volName, next_id);
  */

  sprintf(tablename, "%s_%d", oid_to_table(oid, (char*)""), next_id);

  sprintf(query,
      "insert into items "
      "(tablename,vid,oix,oname,aname,uptime,cretime,storagetime,vtype,vsize,"
      "description,unit,scantime,deadband,options) "
      "values ('%s',%d,%d,'%s','%s','%s','%s',%ld,%d,%d,'%s','%s',%f,%f,%d);",
      tablename, oid.vid, oid.oix, oname, aname, timestr, timestr,
      (long int)storagetime.tv_sec, vtype, vsize, description, unit, scantime,
      deadband, options);
  int rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Store item: %s\n", errmsg);
    sqlite3_free(errmsg);
    *sts = SEV__DBERROR;
    return 0;
  }

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbsqlite::remove_item(pwr_tStatus* sts, pwr_tOid oid, char* aname)
{
  char query[800];
  char* errmsg;

  sprintf(query,
      "delete from items where vid = %u and oix = %u and aname = '%s';",
      oid.vid, oid.oix, aname);
  int rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Remove item: %s\n", errmsg);
    sqlite3_free(errmsg);
    *sts = SEV__DBERROR;
    return 0;
  }

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbsqlite::get_items(pwr_tStatus* sts)
{
  m_items.clear();
  char query[300];
  sqlite3_stmt* stmt;

  sprintf(query, "select "
                 "id,tablename,vid,oix,oname,aname,uptime,cretime,storagetime,"
                 "vtype,vsize,description,unit,scantime,deadband,options "
                 "from items");

  int rc = sqlite3_prepare_v2(m_con, query, -1, &stmt, 0);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s\n", __FUNCTION__);
    return 0;
  }

  for (int i = 0;; i++) {
    int col = 0;
    char* text;

    rc = sqlite3_step(stmt);
    if (rc != SQLITE_ROW)
      break;

    sev_item item;
    sev_attr attr;
    item.attr.push_back(attr);

    // printf( "%d %s %s\n", i, row[0], row[1]);

    item.id = sqlite3_column_int(stmt, col++);
    text = (char*)sqlite3_column_text(stmt, col++);
    if (text)
      strncpy(item.tablename, text, sizeof(item.tablename));
    item.oid.vid = sqlite3_column_int(stmt, col++);
    item.oid.oix = sqlite3_column_int(stmt, col++);
    text = (char*)sqlite3_column_text(stmt, col++);
    if (text)
      strncpy(item.oname, text, sizeof(item.oname));
    text = (char*)sqlite3_column_text(stmt, col++);
    if (text)
      strncpy(item.attr[0].aname, text, sizeof(item.attr[0].aname));
    text = (char*)sqlite3_column_text(stmt, col++);
    if (text)
      timestr_to_time(text, &item.modtime);
    text = (char*)sqlite3_column_text(stmt, col++);
    if (text)
      timestr_to_time(text, &item.creatime);
    item.storagetime.tv_sec = sqlite3_column_int(stmt, col++);
    item.storagetime.tv_nsec = 0;
    item.attr[0].type = (pwr_eType)sqlite3_column_int(stmt, col++);
    item.attr[0].size = sqlite3_column_int(stmt, col++);
    text = (char*)sqlite3_column_text(stmt, col++);
    if (text)
      strncpy(item.description, text, sizeof(item.description));
    text = (char*)sqlite3_column_text(stmt, col++);
    if (text)
      strncpy(item.attr[0].unit, text, sizeof(item.attr[0].unit));
    item.scantime = sqlite3_column_double(stmt, col++);
    item.deadband = sqlite3_column_double(stmt, col++);
    item.options = sqlite3_column_int(stmt, col++);

    item.attrnum = 1;

    m_items.push_back(item);
  }
  sqlite3_finalize(stmt);

  // for ( int i = 0; i < (int)m_items.size(); i++)
  //  printf( "Item: %d %s\n", m_items[i].id, m_items[i].tablename);

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbsqlite::store_value(pwr_tStatus* sts, void* thread, int item_idx,
    int attr_idx, pwr_tTime time, void* buf, unsigned int size)
{
  if (size != m_items[item_idx].value_size) {
    // Something is seriously wrong
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s expected size:%d recevied size:%d ERROR!!\n", __FUNCTION__,
        m_items[item_idx].value_size, size);
    *sts = SEV__DBERROR;
    return 0;
  }
  if (m_items[item_idx].attrnum > 1) {
    return store_objectvalue(
        sts, item_idx, attr_idx, time, buf, m_items[item_idx].old_value, size);
  }
  char query[1150];
  char* errmsg;
  char bufstr[512];
  char timstr[40];
  int update_time_only = 0;
  int set_jump = 0;

  if (!m_items[item_idx].first_storage) {
    if (m_items[item_idx].options & pwr_mSevOptionsMask_UseDeadBand) {
      if (m_items[item_idx].deadband_active) {
        // Compare current value to old value
        switch (m_items[item_idx].attr[attr_idx].type) {
        case pwr_eType_Float32:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(buf, m_items[item_idx].old_value,
                         sizeof(pwr_tFloat32)))
              || (ABS(*(pwr_tFloat32*)buf
                      - *(pwr_tFloat32*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tFloat32*)m_items[item_idx].old_value = *(pwr_tFloat32*)buf;
          }
          break;
        case pwr_eType_Float64:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(buf, m_items[item_idx].old_value,
                         sizeof(pwr_tFloat64)))
              || (ABS(*(pwr_tFloat64*)buf
                      - *(pwr_tFloat64*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tFloat64*)m_items[item_idx].old_value = *(pwr_tFloat64*)buf;
          }
          break;
        case pwr_eType_Int64:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tInt64)))
              || (ABS(*(pwr_tInt64*)buf
                      - *(pwr_tInt64*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tInt64*)m_items[item_idx].old_value = *(pwr_tInt64*)buf;
          }
          break;
        case pwr_eType_Int32:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tInt32)))
              || (ABS(*(pwr_tInt32*)buf
                      - *(pwr_tInt32*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tInt32*)m_items[item_idx].old_value = *(pwr_tInt32*)buf;
          }
          break;
        case pwr_eType_Int16:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tInt16)))
              || (ABS(*(pwr_tInt16*)buf
                      - *(pwr_tInt16*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tInt16*)m_items[item_idx].old_value = *(pwr_tInt16*)buf;
          }
          break;
        case pwr_eType_Int8:
        case pwr_eType_Char:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tInt8)))
              || (ABS(*(pwr_tInt8*)buf
                      - *(pwr_tInt8*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tInt8*)m_items[item_idx].old_value = *(pwr_tInt8*)buf;
          }
          break;
        case pwr_eType_UInt64:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tUInt64)))
              || (ABS(((pwr_tInt64)(*(pwr_tUInt64*)buf
                      - *(pwr_tUInt64*)m_items[item_idx].old_value)))
                     < m_items[item_idx].deadband)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tUInt64*)m_items[item_idx].old_value = *(pwr_tUInt64*)buf;
          }
          break;
        case pwr_eType_UInt32:
        case pwr_eType_Boolean:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tUInt32)))
              || (ABS(((pwr_tInt32)(*(pwr_tUInt32*)buf
                      - *(pwr_tUInt32*)m_items[item_idx].old_value)))
                     < m_items[item_idx].deadband)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tUInt32*)m_items[item_idx].old_value = *(pwr_tUInt32*)buf;
          }
          break;
        case pwr_eType_UInt16:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tUInt16)))
              || (ABS(((pwr_tInt16)(*(pwr_tUInt16*)buf
                      - *(pwr_tUInt16*)m_items[item_idx].old_value)))
                     < m_items[item_idx].deadband)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tUInt16*)m_items[item_idx].old_value = *(pwr_tUInt16*)buf;
          }
          break;
        case pwr_eType_UInt8:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tUInt8)))
              || (ABS(((pwr_tInt8)(*(pwr_tUInt8*)buf
                      - *(pwr_tUInt8*)m_items[item_idx].old_value)))
                     < m_items[item_idx].deadband)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tUInt8*)m_items[item_idx].old_value = *(pwr_tUInt8*)buf;
          }
          break;
        case pwr_eType_String:
          if (!strncmp((char*)buf, (char*)m_items[item_idx].old_value,
                  m_items[item_idx].value_size)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            strncpy((char*)m_items[item_idx].old_value, (char*)buf,
                m_items[item_idx].value_size);
          }
          break;
        default:;
        }
      } else {
        // Compare current value to old value
        switch (m_items[item_idx].attr[attr_idx].type) {
        case pwr_eType_Float32:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(buf, m_items[item_idx].old_value,
                         sizeof(pwr_tFloat32)))
              || (ABS(*(pwr_tFloat32*)buf
                      - *(pwr_tFloat32*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          *(pwr_tFloat32*)m_items[item_idx].old_value = *(pwr_tFloat32*)buf;
          break;
        case pwr_eType_Float64:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(buf, m_items[item_idx].old_value,
                         sizeof(pwr_tFloat64)))
              || (ABS(*(pwr_tFloat64*)buf
                      - *(pwr_tFloat64*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          *(pwr_tFloat64*)m_items[item_idx].old_value = *(pwr_tFloat64*)buf;
          break;
        case pwr_eType_Int64:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tInt64)))
              || (ABS(*(pwr_tInt64*)buf
                      - *(pwr_tInt64*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          *(pwr_tInt64*)m_items[item_idx].old_value = *(pwr_tInt64*)buf;
          break;
        case pwr_eType_Int32:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tInt32)))
              || (ABS(*(pwr_tInt32*)buf
                      - *(pwr_tInt32*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          *(pwr_tInt32*)m_items[item_idx].old_value = *(pwr_tInt32*)buf;
          break;
        case pwr_eType_Int16:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tInt16)))
              || (ABS(*(pwr_tInt16*)buf
                      - *(pwr_tInt16*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          *(pwr_tInt16*)m_items[item_idx].old_value = *(pwr_tInt16*)buf;
          break;
        case pwr_eType_Int8:
        case pwr_eType_Char:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tInt8)))
              || (ABS(*(pwr_tInt8*)buf
                      - *(pwr_tInt8*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          *(pwr_tInt8*)m_items[item_idx].old_value = *(pwr_tInt8*)buf;
          break;
        case pwr_eType_UInt64:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tUInt64)))
              || (ABS(((pwr_tInt64)(*(pwr_tUInt64*)buf
                      - *(pwr_tUInt64*)m_items[item_idx].old_value)))
                     < m_items[item_idx].deadband)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          *(pwr_tUInt64*)m_items[item_idx].old_value = *(pwr_tUInt64*)buf;
          break;
        case pwr_eType_UInt32:
        case pwr_eType_Boolean:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tUInt32)))
              || (ABS(((pwr_tInt32)(*(pwr_tUInt32*)buf
                      - *(pwr_tUInt32*)m_items[item_idx].old_value)))
                     < m_items[item_idx].deadband)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          *(pwr_tUInt32*)m_items[item_idx].old_value = *(pwr_tUInt32*)buf;
          break;
        case pwr_eType_UInt16:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tUInt16)))
              || (ABS(((pwr_tInt16)(*(pwr_tUInt16*)buf
                      - *(pwr_tUInt16*)m_items[item_idx].old_value)))
                     < m_items[item_idx].deadband)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          *(pwr_tUInt16*)m_items[item_idx].old_value = *(pwr_tUInt16*)buf;
          break;
        case pwr_eType_UInt8:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tUInt8)))
              || (ABS(((pwr_tInt8)(*(pwr_tUInt8*)buf
                      - *(pwr_tUInt8*)m_items[item_idx].old_value)))
                     < m_items[item_idx].deadband)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          *(pwr_tUInt8*)m_items[item_idx].old_value = *(pwr_tUInt8*)buf;
          break;
        case pwr_eType_String:
          if (!strncmp((char*)buf, (char*)m_items[item_idx].old_value,
                  m_items[item_idx].value_size)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          strncpy((char*)m_items[item_idx].old_value, (char*)buf,
              m_items[item_idx].value_size);
          break;
        default:;
        }
      }
    }
    if (set_jump
        && (m_items[item_idx].options & pwr_mSevOptionsMask_UseDeadBand)) {
      sprintf(query, "update %s set jump = 1 where id = %d",
          m_items[item_idx].tablename, m_items[item_idx].last_id);
      int rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
      if (rc != SQLITE_OK) {
        printf("In %s row %d:\n", __FILE__, __LINE__);
        printf("Update jump: %s\n", errmsg);
        sqlite3_free(errmsg);
      }
    }
  } else {
    m_items[item_idx].first_storage = 0;
    memcpy(m_items[item_idx].old_value, buf, size);
  }

  *sts = time_AtoAscii(
      &time, time_eFormat_NumDateAndTime, timstr, sizeof(timstr));
  if (EVEN(*sts))
    return 0;
  timstr[19] = 0;

  switch (m_items[item_idx].attr[attr_idx].type) {
  case pwr_eType_Time:
    *sts = time_AtoAscii(
        (pwr_tTime*)buf, time_eFormat_NumDateAndTime, bufstr, sizeof(bufstr));
    if (EVEN(*sts))
      return 0;
    break;
  default:
    *sts = cdh_AttrValueToString(
        m_items[item_idx].attr[attr_idx].type, buf, bufstr, sizeof(bufstr));
    if (EVEN(*sts))
      return 0;
  }

  char colname[255];
  strcpy(colname, "value");
  if (!update_time_only) {
    if (m_items[item_idx].options & pwr_mSevOptionsMask_PosixTime) {
      if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
        // Posix time, high resolution
        switch (m_items[item_idx].attr[attr_idx].type) {
        case pwr_eType_String:
        case pwr_eType_Time:
          sprintf(query,
              "insert into %s (time, ntime, %s) values (%ld,%ld,'%s')",
              m_items[item_idx].tablename, colname, (long int)time.tv_sec,
              (long int)time.tv_nsec, bufstr);
          break;
        default:
          if (m_items[item_idx].options & pwr_mSevOptionsMask_UseDeadBand)
            sprintf(query,
                "insert into %s (time, ntime, %s, jump) values (%ld,%ld,%s,%d)",
                m_items[item_idx].tablename, colname, (long int)time.tv_sec,
                (long int)time.tv_nsec, bufstr, set_jump);
          else
            sprintf(query,
                "insert into %s (time, ntime, %s) values (%ld,%ld,%s)",
                m_items[item_idx].tablename, colname, (long int)time.tv_sec,
                (long int)time.tv_nsec, bufstr);
        }
      } else {
        // Posix time, low resolution
        switch (m_items[item_idx].attr[attr_idx].type) {
        case pwr_eType_String:
        case pwr_eType_Time:
          sprintf(query, "insert into %s (time, %s) values (%ld,'%s')",
              m_items[item_idx].tablename, colname, (long int)time.tv_sec,
              bufstr);
          break;
        default:
          if (m_items[item_idx].options & pwr_mSevOptionsMask_UseDeadBand)
            sprintf(query, "insert into %s (time, %s, jump) values (%ld,%s,%d)",
                m_items[item_idx].tablename, colname, (long int)time.tv_sec,
                bufstr, set_jump);
          else
            sprintf(query, "insert into %s (time, %s) values (%ld,%s)",
                m_items[item_idx].tablename, colname, (long int)time.tv_sec,
                bufstr);
        }
      }
    } else {
      if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
        // Sql time, high resolution
        switch (m_items[item_idx].attr[attr_idx].type) {
        case pwr_eType_String:
        case pwr_eType_Time:
          sprintf(query,
              "insert into %s (time, ntime, %s) values ('%s',%ld,'%s')",
              m_items[item_idx].tablename, colname, timstr,
              (long int)time.tv_nsec, bufstr);
          break;
        default:
          if (m_items[item_idx].options & pwr_mSevOptionsMask_UseDeadBand)
            sprintf(query, "insert into %s (time, ntime, %s, jump) values "
                           "('%s',%ld,%s,%d)",
                m_items[item_idx].tablename, colname, timstr,
                (long int)time.tv_nsec, bufstr, set_jump);
          else
            sprintf(query,
                "insert into %s (time, ntime, %s) values ('%s',%ld,%s)",
                m_items[item_idx].tablename, colname, timstr,
                (long int)time.tv_nsec, bufstr);
        }
      } else {
        // Sql time, low resolution
        switch (m_items[item_idx].attr[attr_idx].type) {
        case pwr_eType_String:
        case pwr_eType_Time:
          sprintf(query, "insert into %s (time, %s) values ('%s','%s')",
              m_items[item_idx].tablename, colname, timstr, bufstr);
          break;
        default:
          if (m_items[item_idx].options & pwr_mSevOptionsMask_UseDeadBand)
            sprintf(query,
                "insert into %s (time, %s, jump) values ('%s',%s,%d)",
                m_items[item_idx].tablename, colname, timstr, bufstr, set_jump);
          else
            sprintf(query, "insert into %s (time, %s) values ('%s',%s)",
                m_items[item_idx].tablename, colname, timstr, bufstr);
        }
      }
    }
    int rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
    if (rc != SQLITE_OK) {
      // printf( "Store value: %s \"%s\"\n", errmsg, query);
      *sts = SEV__DBERROR;
      m_items[item_idx].status = *sts;
      if (m_items[item_idx].status != m_items[item_idx].logged_status) {
        m_items[item_idx].logged_status = m_items[item_idx].status;
        errh_Error("Database store error: %s, table: %s object: %s", errmsg,
            m_items[item_idx].tablename, m_items[item_idx].oname);
      }
      sqlite3_free(errmsg);
      return 0;
    }
  } else {
    if (m_items[item_idx].options & pwr_mSevOptionsMask_PosixTime) {
      if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
        // Posix time, high resolution
        sprintf(query, "update %s set time = %ld, ntime = %ld where id = %d",
            m_items[item_idx].tablename, (long int)time.tv_sec,
            (long int)time.tv_nsec, m_items[item_idx].last_id);
      } else {
        // Posix time, low resolution
        sprintf(query, "update %s set time = %ld where id = %d",
            m_items[item_idx].tablename, (long int)time.tv_sec,
            m_items[item_idx].last_id);
      }
    } else {
      if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
        // Sql time, high resolution
        sprintf(query, "update %s set time = '%s', ntime = %ld where id = %d",
            m_items[item_idx].tablename, timstr, (long int)time.tv_nsec,
            m_items[item_idx].last_id);
      } else {
        // Sql time, low resolution
        sprintf(query, "update %s set time = '%s' where id = %d",
            m_items[item_idx].tablename, timstr, m_items[item_idx].last_id);
      }
    }

    int rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
    if (rc != SQLITE_OK) {
      // printf( "Update value: %s\n", errmsg);
      *sts = SEV__DBERROR;
      m_items[item_idx].status = *sts;
      if (m_items[item_idx].status != m_items[item_idx].logged_status) {
        m_items[item_idx].logged_status = m_items[item_idx].status;
        errh_Error("Database update error: %s, table: %s object: %s", errmsg,
            m_items[item_idx].tablename, m_items[item_idx].oname);
      }
      sqlite3_free(errmsg);
      return 0;
    }
  }

  *sts = SEV__SUCCESS;
  m_items[item_idx].status = *sts;
  m_items[item_idx].logged_status = 1;
  return 1;
}

int sev_dbsqlite::get_values(pwr_tStatus* sts, void* thread, pwr_tOid oid,
    pwr_tMask options, float deadband, char* aname, pwr_eType type,
    unsigned int size, pwr_tFloat32 scantime, pwr_tTime* creatime,
    pwr_tTime* starttime, pwr_tTime* endtime, int maxsize, pwr_tTime** tbuf,
    void** vbuf, unsigned int* bsize)
{
  sev_item item;
  get_item(sts, thread, &item, oid, aname);
  if (EVEN(*sts)) {
    return 0;
  }

  char query[6400];
  char starttimstr[40];
  char endtimstr[40];
  int total_rows;
  int max_id;
  int div;
  pwr_tDeltaTime dt;
  pwr_tTime stime, etime;
  char column_part[80];
  char orderby_part[80];
  char jumpstr[40];
  char where_part[200];
  char last_update[20] = "";
  char create_time_str[20] = "2012-01-01 01:00:00";
  const char* text;
  sqlite3_stmt* stmt;

  if (starttime && starttime->tv_sec == 0 && starttime->tv_nsec == 0)
    starttime = 0;
  else
    stime = *starttime;

  if (endtime && endtime->tv_sec == 0 && endtime->tv_nsec == 0)
    endtime = 0;
  else
    etime = *endtime;

  // Get number of rows
  if (item.options & pwr_mSevOptionsMask_ReadOptimized) {
    sprintf(query, "select coalesce(max(id)+1,0) from %s", item.tablename);
    int rc = sqlite3_prepare_v2(m_con, query, -1, &stmt, 0);
    if (rc != SQLITE_OK) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("GetValues Query Error\n");
      *sts = SEV__DBERROR;
      return 0;
    }

    rc = sqlite3_step(stmt);
    if (rc != SQLITE_ROW) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      *sts = SEV__DBERROR;
      return 0;
    }

    max_id = sqlite3_column_int(stmt, 0);
    sqlite3_finalize(stmt);
  } else {
    // TODO
    *sts = SEV__NYI;
    return 0;
  }

  if (starttime && endtime) {
    pwr_tTime update_time;
    if (strcpy(last_update, "") != 0)
      timestr_to_time(last_update, &update_time);

    if (time_Acomp(creatime, &stime) == 1)
      stime = *creatime;

    if (!streq(last_update, "") && time_Acomp(&etime, &update_time) == 1)
      etime = update_time;

    time_Adiff(&dt, &etime, &stime);
    total_rows = int(time_DToFloat(0, &dt) / scantime);
    if (max_id < total_rows)
      total_rows = max_id;

    div = total_rows / maxsize + 1;
  } else if (starttime) {
    pwr_tTime update_time;
    if (!streq(last_update, ""))
      timestr_to_time(last_update, &update_time);
    else
      time_GetTime(&update_time);

    if (time_Acomp(&update_time, starttime) != 1) {
      *sts = SEV__NODATATIME;
      return 0;
    }
    time_Adiff(&dt, &update_time, starttime);
    total_rows = int(time_DToFloat(0, &dt) / scantime);
    if (max_id < total_rows)
      total_rows = max_id;
  } else if (endtime) {
    pwr_tTime create_time;
    timestr_to_time(create_time_str, &create_time);

    if (time_Acomp(endtime, &create_time) != 1) {
      *sts = SEV__NODATATIME;
      return 0;
    }
    time_Adiff(&dt, endtime, &create_time);
    total_rows = int(time_DToFloat(0, &dt) / scantime);
    if (max_id < total_rows)
      total_rows = max_id;
  } else {
    total_rows = max_id;
  }

  div = total_rows / maxsize + 1;

  if (starttime) {
    *sts = time_AtoAscii(
        &stime, time_eFormat_NumDateAndTime, starttimstr, sizeof(starttimstr));
    if (EVEN(*sts))
      return 0;
    starttimstr[19] = 0;
  }
  if (endtime) {
    *sts = time_AtoAscii(
        &etime, time_eFormat_NumDateAndTime, endtimstr, sizeof(endtimstr));
    if (EVEN(*sts))
      return 0;
    endtimstr[19] = 0;
  }

  // Column part
  if (options & pwr_mSevOptionsMask_HighTimeResolution)
    strcpy(column_part, "time,ntime,value");
  else
    strcpy(column_part, "time,value");

  if (options & pwr_mSevOptionsMask_UseDeadBand)
    strcpy(jumpstr, "or jump = 1");
  else
    strcpy(jumpstr, "");

  // 'order by' part
  if (options & pwr_mSevOptionsMask_ReadOptimized)
    strcpy(orderby_part, "id");
  else {
    if (options & pwr_mSevOptionsMask_HighTimeResolution)
      strcpy(orderby_part, "time,ntime");
    else
      strcpy(orderby_part, "time");
  }

  // 'where' part
  if (options & pwr_mSevOptionsMask_ReadOptimized) {
    if (starttime && endtime) {
      if (div == 1) {
        if (options & pwr_mSevOptionsMask_PosixTime)
          sprintf(where_part, "where time >= %ld and time <= %ld",
              (long int)starttime->tv_sec, (long int)endtime->tv_sec);
        else
          sprintf(where_part, "where time >= '%s' and time <= '%s'",
              starttimstr, endtimstr);
      } else {
        if (options & pwr_mSevOptionsMask_PosixTime)
          sprintf(where_part,
              "where (id %% %d = 0 %s) and time >= %ld and time <= %ld", div,
              jumpstr, (long int)starttime->tv_sec, (long int)endtime->tv_sec);
        else
          sprintf(where_part,
              "where (id %% %d = 0 %s) and time >= '%s' and time <= '%s'", div,
              jumpstr, starttimstr, endtimstr);
      }
    } else if (starttime) {
      if (div == 1) {
        if (options & pwr_mSevOptionsMask_PosixTime)
          sprintf(where_part, "where time >= %ld", (long int)starttime->tv_sec);
        else
          sprintf(where_part, "where time >= '%s'", starttimstr);
      } else {
        if (options & pwr_mSevOptionsMask_PosixTime)
          sprintf(where_part, "where (id %% %d = 0 %s) and time >= %ld", div,
              jumpstr, (long int)starttime->tv_sec);
        else
          sprintf(where_part, "where (id %% %d = 0 %s) and time >= '%s'", div,
              jumpstr, starttimstr);
      }
    } else if (endtime) {
      if (div == 1) {
        if (options & pwr_mSevOptionsMask_PosixTime)
          sprintf(where_part, "where time <= %ld", (long int)endtime->tv_sec);
        else
          sprintf(where_part, "where time <= '%s'", endtimstr);
      } else {
        if (options & pwr_mSevOptionsMask_PosixTime)
          sprintf(where_part, "where (id %% %d = 0 %s) and time <= %ld", div,
              jumpstr, (long int)endtime->tv_sec);
        else
          sprintf(where_part, "where (id %% %d = 0 %s) and time <= '%s'", div,
              jumpstr, endtimstr);
      }
    } else {
      if (div == 1)
        strcpy(where_part, "");
      else
        sprintf(where_part, "where id %% %d = 0 %s", div, jumpstr);
    }
  } else {
    // Not read optimized
    if (starttime && endtime) {
      if (options & pwr_mSevOptionsMask_PosixTime)
        sprintf(where_part, "where time >= %ld and time <= %ld",
            (long int)starttime->tv_sec, (long int)endtime->tv_sec);
      else
        sprintf(where_part, "where time >= '%s' and time <= '%s'", starttimstr,
            endtimstr);
    } else if (starttime) {
      if (options & pwr_mSevOptionsMask_PosixTime)
        sprintf(where_part, "where time >= %ld", (long int)starttime->tv_sec);
      else
        sprintf(where_part, "where time >= '%s'", starttimstr);
    } else if (endtime) {
      if (options & pwr_mSevOptionsMask_PosixTime)
        sprintf(where_part, "where time <= %ld", (long int)endtime->tv_sec);
      else
        sprintf(where_part, "where time <= '%s'", endtimstr);
    } else
      strcpy(where_part, "");
  }

  sprintf(query, "select %s from %s %s order by %s", column_part,
      item.tablename, where_part, orderby_part);

  int rc = sqlite3_prepare_v2(m_con, query, -1, &stmt, 0);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s\n", __FUNCTION__);
    *sts = SEV__DBERROR;
    return 0;
  }

  int bufrows = total_rows / div;
  int row_cnt = 0;

  if (options & pwr_mSevOptionsMask_ReadOptimized) {
    *tbuf = (pwr_tTime*)calloc(bufrows, sizeof(pwr_tTime));
    *vbuf = calloc(bufrows, size);

    int bcnt = 0;
    for (int i = 0;; i++) {
      rc = sqlite3_step(stmt);
      if (rc != SQLITE_ROW)
        break;

      row_cnt++;
      if (row_cnt > bufrows)
        break;

      int j = 0;

      if (options & pwr_mSevOptionsMask_PosixTime) {
        if (options & pwr_mSevOptionsMask_HighTimeResolution) {
          // Posix time, high resolution
          text = (const char*)sqlite3_column_text(stmt, j++);
          if (text)
            timestr_to_time((char*)text, (pwr_tTime*)&(*tbuf)[bcnt].tv_sec);
          (*tbuf)[bcnt].tv_nsec = sqlite3_column_int(stmt, j++);
        } else {
          // Posix time, low resolution
          text = (const char*)sqlite3_column_text(stmt, j++);
          if (text)
            timestr_to_time((char*)text, (pwr_tTime*)&(*tbuf)[bcnt].tv_sec);
        }
      } else {
        if (options & pwr_mSevOptionsMask_HighTimeResolution) {
          // Sql time, high resolution
          text = (const char*)sqlite3_column_text(stmt, j++);
          if (text)
            timestr_to_time((char*)text, (pwr_tTime*)&(*tbuf)[bcnt].tv_sec);
          (*tbuf)[bcnt].tv_nsec = sqlite3_column_int(stmt, j++);
        } else {
          // Sql time, low resolution
          text = (const char*)sqlite3_column_text(stmt, j++);
          if (text)
            timestr_to_time((char*)text, (pwr_tTime*)&(*tbuf)[bcnt].tv_sec);
        }
      }

      const char* value_str = (const char*)sqlite3_column_text(stmt, j++);
      if (!value_str || streq(value_str, "")) {
        // Null value
        switch (type) {
        case pwr_eType_Float32:
        case pwr_eType_Float64:
        case pwr_eType_Int8:
        case pwr_eType_Int16:
        case pwr_eType_Int32:
        case pwr_eType_Int64:
        case pwr_eType_UInt8:
        case pwr_eType_UInt16:
        case pwr_eType_UInt32:
        case pwr_eType_UInt64:
        case pwr_eType_Mask:
        case pwr_eType_Enum:
          cdh_StringToAttrValue(type, "0", ((char*)*vbuf) + bcnt * size);
          break;
        case pwr_eType_Time:
        case pwr_eType_DeltaTime:
          // TODO deltatime??
          cdh_StringToAttrValue(
              type, "1970-01-01 00:00:00", ((char*)*vbuf) + bcnt * size);
          break;
        default:
          cdh_StringToAttrValue(type, " ", ((char*)*vbuf) + bcnt * size);
          break;
        }
        j++;
      } else
        cdh_StringToAttrValue(type, value_str, ((char*)*vbuf) + bcnt * size);

      bcnt++;
      // if ( options & pwr_mSevOptionsMask_HighTimeResolution)
      //  printf( "%5d %5d %s.%9s %s\n", i, bcnt, row[0], row[1], row[2]);
      // else
      //  printf( "%5d %5d %s %s\n", i, bcnt, row[0], row[1]);
    }
    printf("bcnt %d bufrows %d\n", bcnt, row_cnt);
    *bsize = bcnt;
    sqlite3_finalize(stmt);
  } else {
    *tbuf = (pwr_tTime*)calloc(bufrows, sizeof(pwr_tTime));
    *vbuf = calloc(bufrows, size);

    int bcnt = 0;
    for (int i = 0;; i++) {
      if (i == 0) {
        rc = sqlite3_step(stmt);
        if (rc != SQLITE_ROW)
          break;
      } else {
        for (int k = 0; k < div; k++) {
          rc = sqlite3_step(stmt);
          if (rc != SQLITE_ROW)
            break;
        }
        if (rc != SQLITE_ROW)
          break;
      }

      bufrows++;
      int j = 0;

      if (options & pwr_mSevOptionsMask_PosixTime) {
        if (options & pwr_mSevOptionsMask_HighTimeResolution) {
          // Posix time, high resolution
          text = (const char*)sqlite3_column_text(stmt, j++);
          if (text)
            timestr_to_time((char*)text, (pwr_tTime*)&(*tbuf)[bcnt].tv_sec);
          (*tbuf)[bcnt].tv_nsec = sqlite3_column_int(stmt, j++);
        } else {
          // Posix time, low resolution
          text = (const char*)sqlite3_column_text(stmt, j++);
          if (text)
            timestr_to_time((char*)text, (pwr_tTime*)&(*tbuf)[bcnt].tv_sec);
        }
      } else {
        if (options & pwr_mSevOptionsMask_HighTimeResolution) {
          // Sql time, high resolution
          text = (const char*)sqlite3_column_text(stmt, j++);
          if (text)
            timestr_to_time((char*)text, (pwr_tTime*)&(*tbuf)[bcnt].tv_sec);
          (*tbuf)[bcnt].tv_nsec = sqlite3_column_int(stmt, j++);
        } else {
          // Sql time, low resolution
          text = (const char*)sqlite3_column_text(stmt, j++);
          if (text)
            timestr_to_time((char*)text, (pwr_tTime*)&(*tbuf)[bcnt].tv_sec);
        }
      }

      const char* value_str = (const char*)sqlite3_column_text(stmt, j++);
      if (streq(value_str, "")) {
        // Null value
        switch (type) {
        case pwr_eType_Float32:
        case pwr_eType_Float64:
        case pwr_eType_Int8:
        case pwr_eType_Int16:
        case pwr_eType_Int32:
        case pwr_eType_Int64:
        case pwr_eType_UInt8:
        case pwr_eType_UInt16:
        case pwr_eType_UInt32:
        case pwr_eType_UInt64:
        case pwr_eType_Mask:
        case pwr_eType_Enum:
          cdh_StringToAttrValue(type, "0", ((char*)*vbuf) + bcnt * size);
          break;
        case pwr_eType_Time:
        case pwr_eType_DeltaTime:
          // TODO deltatime??
          cdh_StringToAttrValue(
              type, "1970-01-01 00:00:00", ((char*)*vbuf) + bcnt * size);
          break;
        default:
          cdh_StringToAttrValue(type, " ", ((char*)*vbuf) + bcnt * size);
          break;
        }
        j++;
      } else
        cdh_StringToAttrValue(type, value_str, ((char*)*vbuf) + bcnt * size);

      bcnt++;
      // if ( options & pwr_mSevOptionsMask_HighTimeResolution)
      //  printf( "%5d %5d %s.%9s %s\n", i, bcnt, row[0], row[1], row[2]);
      // else
      //  printf( "%5d %5d %s %s\n", i, bcnt, row[0], row[1]);
    }
    printf("bcnt %d bufrows %d\n", bcnt, bufrows);
    *bsize = bcnt;
    sqlite3_finalize(stmt);
  }
  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbsqlite::store_event(
    pwr_tStatus* sts, void* thread, int item_idx, sev_event* ep)
{
  char query[800];
  char* errmsg;
  char timstr[40];

  *sts = time_AtoAscii(
      &ep->time, time_eFormat_NumDateAndTime, timstr, sizeof(timstr));
  if (EVEN(*sts))
    return 0;
  timstr[19] = 0;

  if (m_items[item_idx].options & pwr_mSevOptionsMask_PosixTime) {
    if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
      // Posix time, high resolution
      sprintf(query, "insert into %s (time, ntime, eventtype, eventprio, "
                     "eventid_nix, eventid_birthtime,"
                     "eventid_idx, supobject_vid, supobject_oix, "
                     "supobject_offset, supobject_size,"
                     "eventtext, eventname) values "
                     "(%ld,%ld,%d,%d,%d,%d,%d,%u,%u,%u,%u,'%s','%s')",
          m_items[item_idx].tablename, (long int)ep->time.tv_sec,
          (long int)ep->time.tv_nsec, ep->type, ep->eventprio, ep->eventid.Nix,
          ep->eventid.BirthTime.tv_sec, ep->eventid.Idx,
          ep->supobject.Objid.vid, ep->supobject.Objid.oix,
          ep->supobject.Offset, ep->supobject.Size, ep->eventtext,
          ep->eventname);
    } else {
      // Posix time, low resolution
      sprintf(query, "insert into %s (time, eventtype, eventprio, eventid_nix, "
                     "eventid_birthtime,"
                     "eventid_idx, supobject_vid, supobject_oix, "
                     "supobject_offset, supobject_size,"
                     "eventtext, eventname) values "
                     "(%ld,%d,%d,%d,%d,%d,%u,%u,%u,%u,'%s','%s')",
          m_items[item_idx].tablename, (long int)ep->time.tv_sec, ep->type,
          ep->eventprio, ep->eventid.Nix, ep->eventid.BirthTime.tv_sec,
          ep->eventid.Idx, ep->supobject.Objid.vid, ep->supobject.Objid.oix,
          ep->supobject.Offset, ep->supobject.Size, ep->eventtext,
          ep->eventname);
    }
  } else {
    if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
      // Sql time, high resolution
      sprintf(query, "insert into %s (time, ntime, eventtype, eventprio, "
                     "eventid_nix, eventid_birthtime,"
                     "eventid_idx, supobject_vid, supobject_oix, "
                     "supobject_offset, supobject_size,"
                     "eventtext, eventname) values "
                     "('%s',%ld,%d,%d,%d,%d,%d,%u,%u,%u,%u,'%s','%s')",
          m_items[item_idx].tablename, timstr, (long int)ep->time.tv_sec,
          ep->type, ep->eventprio, ep->eventid.Nix,
          ep->eventid.BirthTime.tv_sec, ep->eventid.Idx,
          ep->supobject.Objid.vid, ep->supobject.Objid.oix,
          ep->supobject.Offset, ep->supobject.Size, ep->eventtext,
          ep->eventname);
    } else {
      // Sql time, low resolution
      sprintf(query, "insert into %s (time, eventtype, eventprio, eventid_nix, "
                     "eventid_birthtime,"
                     "eventid_idx, supobject_vid, supobject_oix, "
                     "supobject_offset, supobject_size,"
                     "eventtext, eventname) values "
                     "('%s',%d,%d,%d,%d,%d,%u,%u,%u,%u,'%s','%s')",
          m_items[item_idx].tablename, timstr, ep->type, ep->eventprio,
          ep->eventid.Nix, ep->eventid.BirthTime.tv_sec, ep->eventid.Idx,
          ep->supobject.Objid.vid, ep->supobject.Objid.oix,
          ep->supobject.Offset, ep->supobject.Size, ep->eventtext,
          ep->eventname);
    }
  }
  int rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    // printf( "Store value: %s \"%s\"\n", errmsg, query);
    *sts = SEV__DBERROR;
    m_items[item_idx].status = *sts;
    if (m_items[item_idx].status != m_items[item_idx].logged_status) {
      m_items[item_idx].logged_status = m_items[item_idx].status;
      errh_Error("Database store error: %s, table: %s object: %s", errmsg,
          m_items[item_idx].tablename, m_items[item_idx].oname);
    }
    sqlite3_free(errmsg);
    return 0;
  }

  *sts = SEV__SUCCESS;
  m_items[item_idx].status = *sts;
  m_items[item_idx].logged_status = 1;
  return 1;
}

int sev_dbsqlite::check_item(pwr_tStatus* sts, pwr_tOid oid, char* oname,
    char* aname, pwr_tDeltaTime storagetime, pwr_eType type, unsigned int size,
    char* description, char* unit, pwr_tFloat32 scantime, pwr_tFloat32 deadband,
    pwr_tMask options, unsigned int* idx)
{
  char timestr[40];
  pwr_tTime uptime;

  time_GetTime(&uptime);
  time_AtoAscii(&uptime, time_eFormat_NumDateAndTime, timestr, sizeof(timestr));
  timestr[19] = 0;

  for (unsigned int i = 0; i < m_items.size(); i++) {
    if (m_items[i].deleted)
      continue;

    if (cdh_ObjidIsEqual(oid, m_items[i].oid)
        && str_NoCaseStrcmp(aname, m_items[i].attr[0].aname) == 0) {
      char query[600];
      char* errmsg;

      bool itemdefchange = false;
      if (type != m_items[i].attr[0].type || size != m_items[i].attr[0].size) {
        itemdefchange = true;
      }

      sprintf(query, "update items set ");
      if (storagetime.tv_sec != m_items[i].storagetime.tv_sec) {
        sprintf(&query[strlen(query)], "storagetime=%ld,",
            (long int)storagetime.tv_sec);
        m_items[i].storagetime = storagetime;
      }
      if (!streq(oname, m_items[i].oname)) {
        sprintf(&query[strlen(query)], "oname=\'%s\',", oname);
        strncpy(m_items[i].oname, oname, sizeof(m_items[i].oname));
      }
      if (type != m_items[i].attr[0].type) {
        sprintf(&query[strlen(query)], "vtype=%d,", type);
        m_items[i].attr[i].type = type;
      }
      if (size != m_items[i].attr[0].size) {
        sprintf(&query[strlen(query)], "vsize=%d,", size);
        m_items[i].attr[i].size = size;
      }
      if (!feqf(scantime, m_items[i].scantime)) {
        sprintf(&query[strlen(query)], "scantime=%.1f,", scantime);
        m_items[i].scantime = scantime;
      }
      if (!feqf(deadband, m_items[i].deadband)) {
        sprintf(&query[strlen(query)], "deadband=%.4f,", deadband);
        m_items[i].deadband = deadband;
      }
      if (!streq(description, m_items[i].description)) {
        sprintf(&query[strlen(query)], "description=\'%s\',", description);
        strncpy(m_items[i].description, description,
            sizeof(m_items[i].description));
      }
      if (!streq(unit, m_items[i].attr[0].unit)) {
        sprintf(&query[strlen(query)], "unit=\'%s\',", unit);
        strncpy(m_items[i].attr[0].unit, unit, sizeof(m_items[i].attr[0].unit));
      }

      sprintf(&query[strlen(query)], "uptime=\'%s\' ", timestr);
      sprintf(&query[strlen(query)], "where id=%d;", m_items[i].id);

      // This won't work!! We have to alter the table to be able to change this
      // m_items[i].options = options;

      int rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
      if (rc != SQLITE_OK) {
        printf("In %s row %d:\n", __FILE__, __LINE__);
        printf("Store item: %s\n", errmsg);
        sqlite3_free(errmsg);
        *sts = SEV__DBERROR;
        return 0;
      }

      if (itemdefchange) {
        if (!handle_itemchange(sts, m_items[i].tablename, i)) {
          return 1;
        }
      }
      *idx = i;
      *sts = SEV__SUCCESS;
      return 1;
    }
  }
  *sts = SEV__NOSUCHITEM;
  return 0;
}

int sev_dbsqlite::add_item(pwr_tStatus* sts, pwr_tOid oid, char* oname,
    char* aname, pwr_tDeltaTime storagetime, pwr_eType type, unsigned int size,
    char* description, char* unit, pwr_tFloat32 scantime, pwr_tFloat32 deadband,
    pwr_tMask options, unsigned int* idx)
{
  char tablename[256];

  store_item(sts, tablename, oid, oname, aname, storagetime, type, size,
      description, unit, scantime, deadband, options);
  if (EVEN(*sts))
    return 0;

  if (streq(aname, "Events"))
    create_event_table(sts, tablename, options);
  else
    create_table(sts, tablename, type, size, options, deadband);
  if (EVEN(*sts))
    return 0;

  sev_item item;
  sev_attr attr;
  item.attr.push_back(attr);
  item.id = 0;
  strncpy(item.tablename, tablename, sizeof(item.tablename));
  item.oid = oid;
  strncpy(item.oname, oname, sizeof(item.oname));
  strncpy(item.attr[0].aname, aname, sizeof(item.attr[0].aname));
  time_GetTime(&item.creatime);
  item.modtime = item.creatime;
  item.storagetime = storagetime;
  item.attr[0].type = type;
  item.attr[0].size = size;
  strncpy(item.description, description, sizeof(item.description));
  strncpy(item.attr[0].unit, unit, sizeof(item.attr[0].unit));
  item.scantime = scantime;
  item.deadband = deadband;
  item.options = options;
  item.attrnum = 1;

  // Only tables with id are implemented
  item.options |= pwr_mSevOptionsMask_ReadOptimized;

  m_items.push_back(item);
  *idx = m_items.size() - 1;

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbsqlite::delete_item(pwr_tStatus* sts, pwr_tOid oid, char* aname)
{
  sev_item item;
  get_item(sts, 0, &item, oid, aname);
  if (EVEN(*sts)) {
    return 0;
  }

  remove_item(sts, oid, aname);

  if (ODD(*sts))
    delete_table(sts, item.tablename);

  if (ODD(*sts)) {
    for (int i = 0; i < (int)m_items.size(); i++) {
      if (m_items[i].deleted)
        continue;
      if (cdh_ObjidIsEqual(m_items[i].oid, oid)
          && str_NoCaseStrcmp(m_items[i].attr[0].aname, aname) == 0) {
        m_items[i].deleted = 1;
        break;
      }
    }
  }
  return 1;
}

int sev_dbsqlite::delete_old_data(pwr_tStatus* sts, void* thread,
    char* tablename, pwr_tMask options, pwr_tTime limit, pwr_tFloat32 scantime,
    pwr_tFloat32 garbagecycle)
{
  char query[300];
  char* errmsg;
  char timstr[40];

  *sts = time_AtoAscii(
      &limit, time_eFormat_NumDateAndTime, timstr, sizeof(timstr));
  if (EVEN(*sts))
    return 0;
  timstr[19] = 0;

  if (options & pwr_mSevOptionsMask_ReadOptimized) {
    // TODO Change 86400 to sev_cGarbageCycle
    // We scan trough as many rows that we write between two garbage cycles plus
    // some extra rows
    // to be sure that the table not grows to much.
    pwr_tUInt64 nbRowsToClean = 86400 * 2; // default value
    if (scantime > 0.0)
      nbRowsToClean = (pwr_tUInt64)((garbagecycle / scantime) + 10000.0);

    nbRowsToClean += get_minFromIntegerColumn(tablename, (char*)"id");
    if (options & pwr_mSevOptionsMask_PosixTime)
      sprintf(query,
          "delete from %s where id < " pwr_dFormatUInt64 " and time < %ld;",
          tablename, nbRowsToClean, (long int)limit.tv_sec);
    else
      sprintf(query,
          "delete from %s where id < " pwr_dFormatUInt64 " and time < '%s';",
          tablename, nbRowsToClean, timstr);
  } else {
    if (options & pwr_mSevOptionsMask_PosixTime)
      sprintf(query, "delete from %s where time < %ld;", tablename,
          (long int)limit.tv_sec);
    else
      sprintf(query, "delete from %s where time < '%s';", tablename, timstr);
  }
  int rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Delete old data: %s\n", errmsg);
    sqlite3_free(errmsg);
    *sts = SEV__DBERROR;
    return 0;
  }

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbsqlite::timestr_to_time(char* tstr, pwr_tTime* ts)
{
  struct tm tt;

  int nr = sscanf(tstr, "%4d-%02d-%20d %02d:%02d:%02d", &tt.tm_year, &tt.tm_mon,
      &tt.tm_mday, &tt.tm_hour, &tt.tm_min, &tt.tm_sec);
  if (nr != 6)
    return 0;

  tt.tm_year -= 1900;
  tt.tm_mon--;

  tt.tm_wday = -1;
  tt.tm_yday = -1;
  tt.tm_isdst = -1;

  ts->tv_sec = mktime(&tt);
  ts->tv_nsec = 0;

  return 1;
}

char* sev_dbsqlite::oid_to_table(pwr_tOid oid, char* aname)
{
  static char tbl[40];
  unsigned char vid[4];

  memcpy(&vid, &oid.vid, sizeof(vid));
  sprintf(tbl, "O%3.3u_%3.3u_%3.3u_%3.3u_%8.8x_%s", vid[3], vid[2], vid[1],
      vid[0], oid.oix, cdh_Low(aname));

  // Replace '.' in attribute with '_'
  for (char* s = tbl; *s; s++) {
    if (*s == '.')
      *s = '_';
    if (*s == '[')
      *s = '$';
    if (*s == ']')
      *s = '$';
  }
  return tbl;
}

char* sev_dbsqlite::pwrtype_to_type(pwr_eType type, unsigned int size)
{
  static char stype[40];

  switch (type) {
  case pwr_eType_Boolean:
    strcpy(stype, "int unsigned");
    break;
  case pwr_eType_Int64:
    strcpy(stype, "bigint");
    break;
  case pwr_eType_UInt64:
    strcpy(stype, "bigint unsigned");
    break;
  case pwr_eType_Int32:
    strcpy(stype, "int");
    break;
  case pwr_eType_UInt32:
    strcpy(stype, "int unsigned");
    break;
  case pwr_eType_Int16:
    strcpy(stype, "smallint");
    break;
  case pwr_eType_UInt16:
    strcpy(stype, "smallint unsigned");
    break;
  case pwr_eType_Int8:
    strcpy(stype, "tinyint");
    break;
  case pwr_eType_UInt8:
    strcpy(stype, "tinyint unsigned");
    break;
  case pwr_eType_Float64:
    strcpy(stype, "double");
    break;
  case pwr_eType_Float32:
    strcpy(stype, "float");
    break;
  case pwr_eType_Char:
    strcpy(stype, "char(1)");
    break;
  case pwr_eType_String:
    sprintf(stype, "varchar(%d)", size);
    break;
  case pwr_eType_Time:
    strcpy(stype, "datetime");
    break;
  default:
    strcpy(stype, "");
  }
  return stype;
}

int sev_dbsqlite::check_objectitem(pwr_tStatus* sts, char* tablename,
    pwr_tOid oid, char* oname, char* aname, pwr_tDeltaTime storagetime,
    char* description, pwr_tFloat32 scantime, pwr_tFloat32 deadband,
    pwr_tMask options, unsigned int attrnum, sev_sHistAttr* attr,
    unsigned int* idx)
{
  char timestr[40];
  pwr_tTime uptime;

  time_GetTime(&uptime);
  time_AtoAscii(&uptime, time_eFormat_NumDateAndTime, timestr, sizeof(timestr));
  timestr[19] = 0;

  for (unsigned int i = 0; i < m_items.size(); i++) {
    if (m_items[i].deleted)
      continue;

    if (cdh_ObjidIsEqual(oid, m_items[i].oid)
        && str_NoCaseStrcmp(oname, m_items[i].oname) == 0) {
      char query[400];
      char* errmsg;
      sprintf(query, "update objectitems set ");
      sprintf(&query[strlen(query)], "storagetime=%ld,",
          (long int)storagetime.tv_sec);
      sprintf(&query[strlen(query)], "description=\'%s\',", description);
      sprintf(&query[strlen(query)], "scantime=%.3f,", scantime);
      sprintf(&query[strlen(query)], "deadband=%.3f,", deadband);
      // For now we can't change options. sprintf( &query[strlen(query)],
      // "options=%d,", options);
      sprintf(&query[strlen(query)], "uptime=\'%s\' ", timestr);
      sprintf(&query[strlen(query)],
          "where vid=%d and oix=%d and tablename='%s';", oid.vid, oid.oix,
          tablename);

      // printf("%s query:%s\n", __FUNCTION__, query);

      int rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
      if (rc != SQLITE_OK) {
        printf("In %s row %d:\n", __FILE__, __LINE__);
        printf("%s : %s\n", __FUNCTION__, errmsg);
        sqlite3_free(errmsg);
        *sts = SEV__DBERROR;
        return 0;
      }
      m_items[i].storagetime = storagetime;
      strncpy(
          m_items[i].description, description, sizeof(m_items[i].description));
      m_items[i].scantime = scantime;
      m_items[i].deadband = deadband;
      // This won't work!! We have to alter the table to be able to change this
      // m_items[i].options = options;

      strcpy(tablename, m_items[i].tablename);

      *idx = i;
      *sts = SEV__SUCCESS;
      return 1;
    }
  }
  *sts = SEV__NOSUCHITEM;
  return 0;
}

int sev_dbsqlite::add_objectitem(pwr_tStatus* sts, char* tablename,
    pwr_tOid oid, char* oname, char* aname, pwr_tDeltaTime storagetime,
    char* description, pwr_tFloat32 scantime, pwr_tFloat32 deadband,
    pwr_tMask options, unsigned int attrnum, sev_sHistAttr* attr,
    unsigned int* idx)
{
  store_objectitem(sts, tablename, oid, oname, aname, storagetime, description,
      scantime, deadband, options);
  if (EVEN(*sts))
    return 0;

  create_objecttable(sts, tablename, options, deadband);
  if (EVEN(*sts))
    return 0;

  *sts = SEV__SUCCESS;
  sev_item item;
  item.id = 0;
  strncpy(item.tablename, tablename, sizeof(item.tablename));
  item.oid = oid;
  strncpy(item.oname, oname, sizeof(item.oname));
  time_GetTime(&item.creatime);
  item.modtime = item.creatime;
  item.storagetime = storagetime;
  strncpy(item.description, description, sizeof(item.description));
  item.scantime = scantime;
  item.deadband = deadband;
  item.options = options;
  item.attrnum = 0;

  // Only tables with id are implemented
  item.options |= pwr_mSevOptionsMask_ReadOptimized;

  m_items.push_back(item);
  *idx = m_items.size() - 1;

  return 1;
}
int sev_dbsqlite::store_objectitem(pwr_tStatus* sts, char* tablename,
    pwr_tOid oid, char* oname, char* aname, pwr_tDeltaTime storagetime,
    char* description, pwr_tFloat32 scantime, pwr_tFloat32 deadband,
    pwr_tMask options)
{
  char query[800];
  char* errmsg;
  char timestr[40];
  pwr_tTime creatime;

  time_GetTime(&creatime);
  time_AtoAscii(
      &creatime, time_eFormat_NumDateAndTime, timestr, sizeof(timestr));
  timestr[19] = 0;

  unsigned int next_id = get_nextAutoIncrement((char*)"objectitems");
  /*
    char volName[32];
    strncpy(volName, oname, sizeof(volName));
    for ( char *s = volName; *s; s++) {
      if ( *s == ':') {
        *s = 0;
        break;
      }
    }

    sprintf(tablename, "obj_%s_%d", volName, next_id);
  */
  sprintf(tablename, "obj_%s_%d", oid_to_table(oid, (char*)""), next_id);

  sprintf(query, "insert into objectitems "
                 "(tablename,vid,oix,oname,aname,uptime,cretime,storagetime,"
                 "description,scantime,deadband,options) "
                 "values ('%s',%d,%d,'%s','%s','%s','%s',%ld,'%s',%f,%f,%d);",
      tablename, oid.vid, oid.oix, oname, aname, timestr, timestr,
      (long int)storagetime.tv_sec, description, scantime, deadband, options);
  int rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, errmsg);
    sqlite3_free(errmsg);
    *sts = SEV__DBERROR;
    return 0;
  }

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbsqlite::create_objecttable(
    pwr_tStatus* sts, char* tablename, pwr_tMask options, float deadband)
{
  char query[2000];
  char* errmsg;
  char timeformatstr[80];
  char jumpstr[80];
  char idtypestr[20];
  char readoptstr[80];
  char enginestr[100] = "";

  if (options & pwr_mSevOptionsMask_PosixTime) {
    if (options & pwr_mSevOptionsMask_HighTimeResolution) {
      // Posix time, high resolution
      strcpy(timeformatstr, "sev__time int unsigned, sev__ntime int unsigned");
      strcpy(idtypestr, "integer");
    } else {
      // Posix time, low resolution
      strcpy(timeformatstr, "sev__time int unsigned");
      strcpy(idtypestr, "integer");
    }
  } else {
    if (options & pwr_mSevOptionsMask_HighTimeResolution) {
      // Sql time, high resolution
      strcpy(timeformatstr,
          "sev__time datetime not null, sev__ntime int unsigned");
      strcpy(idtypestr, "integer");
    } else {
      // Sql time, low resolution
      strcpy(timeformatstr, "sev__time datetime not null");
      strcpy(idtypestr, "integer");
    }
  }

  if (options & pwr_mSevOptionsMask_ReadOptimized)
    sprintf(readoptstr, "sev__id %s not null primary key autoincrement,",
        idtypestr);
  else
    strcpy(readoptstr, "");

  if (options & pwr_mSevOptionsMask_UseDeadBand)
    strcpy(jumpstr, ",sev__jump tinyint unsigned");
  else
    strcpy(jumpstr, "");

  sprintf(query, "create table %s ( %s"
                 "%s %s)%s;",
      tablename, readoptstr, timeformatstr, jumpstr, enginestr);

  int rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, errmsg);
    sqlite3_free(errmsg);
    *sts = SEV__DBERROR;
    return 0;
  }

  sprintf(query, "create index %s_sev__time_idx on %s (sev__time)", tablename,
      tablename);

  rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, errmsg);
    sqlite3_free(errmsg);
    *sts = SEV__DBERROR;
    return 0;
  }

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbsqlite::check_objectitemattr(pwr_tStatus* sts, char* tablename,
    pwr_tOid oid, char* aname, char* oname, pwr_eType type, unsigned int size,
    unsigned int* idx)
{
  sev_item* item = &m_items[*idx];
  for (size_t j = 0; j < item->attr.size(); j++) {
    if (str_NoCaseStrcmp(aname, item->attr[j].aname) == 0) {
      if (type != item->attr[j].type || size != item->attr[j].size) {
        *sts = SEV__NOSUCHITEM;
        return 0;
        /*
        if( !handle_attrchange(sts, tablename, oid, aname,oname,type,size, *idx,
        j) ) {
          return 1;
        }
        item->attr[j].type = type;
        item->attr[j].size = size;
        update_objectitemattr(sts, tablename, aname, type, size);
        */
      }
      *sts = SEV__SUCCESS;
      return 1;
    }
  }
  *sts = SEV__NOSUCHITEM;
  return 0;
}

pwr_tUInt64 sev_dbsqlite::get_minFromIntegerColumn(
    char* tablename, char* colname)
{
  char query[2000];
  pwr_tUInt64 retVal = 0;
  sqlite3_stmt* stmt;
  sprintf(query, "select min(`%s`) from %s", colname, tablename);

  // printf( "%s: %s\n", __FUNCTION__ ,query);
  int rc = sqlite3_prepare_v2(m_con, query, -1, &stmt, 0);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s\n", __FUNCTION__);
    return 0;
  }

  rc = sqlite3_step(stmt);
  if (rc != SQLITE_ROW) {
    sqlite3_finalize(stmt);
    return 0;
  }

  const char* text = (const char*)sqlite3_column_text(stmt, 0);
  if (!text) {
    sqlite3_finalize(stmt);
    return 0;
  }
  retVal = strtoull(text, 0, 10);
  sqlite3_finalize(stmt);
  return retVal;
}

pwr_tUInt64 sev_dbsqlite::get_maxFromIntegerColumn(
    char* tablename, char* colname)
{
  char query[2000];
  pwr_tUInt64 retVal = 0;
  sqlite3_stmt* stmt;
  sprintf(query, "select max(`%s`) from %s", colname, tablename);

  int rc = sqlite3_prepare_v2(m_con, query, -1, &stmt, 0);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s\n", __FUNCTION__);
    return 0;
  }

  rc = sqlite3_step(stmt);
  if (rc != SQLITE_ROW) {
    sqlite3_finalize(stmt);
    return retVal;
  }

  const char* text = (const char*)sqlite3_column_text(stmt, 0);
  retVal = strtoull(text, 0, 10);
  sqlite3_finalize(stmt);
  return retVal;
}

pwr_tUInt64 sev_dbsqlite::get_nextAutoIncrement(char* tablename)
{
  char query[200];
  pwr_tUInt64 retVal = 0;
  sqlite3_stmt* stmt;
  sprintf(query, "SELECT seq FROM SQLITE_SEQUENCE WHERE name='%s'", tablename);
  // printf( "%s: %s\n", __FUNCTION__ ,query);

  int rc = sqlite3_prepare_v2(m_con, query, -1, &stmt, 0);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s\n", __FUNCTION__);
    return 0;
  }

  rc = sqlite3_step(stmt);
  if (rc != SQLITE_ROW) {
    sqlite3_finalize(stmt);
    return retVal;
  }

  const char* text = (const char*)sqlite3_column_text(stmt, 0);
  retVal = strtoull(text, 0, 10);
  sqlite3_finalize(stmt);
  return ++retVal;
}

int sev_dbsqlite::store_objectvalue(pwr_tStatus* sts, int item_idx,
    int attr_idx, pwr_tTime time, void* buf, void* oldbuf, unsigned int size)
{
  void* data = buf;
  void* olddata = oldbuf;

  static const int constQueryLength = 3000;
  std::string valuesStr;
  std::string colsStr;
  std::ostringstream queryOStr;

  char query[constQueryLength];
  char* errmsg;
  char bufstr[512];
  char timstr[40];

  *sts = time_AtoAscii(
      &time, time_eFormat_NumDateAndTime, timstr, sizeof(timstr));
  if (EVEN(*sts))
    return 0;
  timstr[19] = 0;

  bool updateOnlyTime = false;
  bool setJump = false;
  if (!m_items[item_idx].first_storage
      && (m_items[item_idx].options & pwr_mSevOptionsMask_UseDeadBand)) {
    if (m_items[item_idx].deadband_active) {
      updateOnlyTime = true;
      for (size_t i = 0; i < m_items[item_idx].attr.size(); i++) {
        pwr_tFloat32 deadband
            = m_items[item_idx].deadband; // TODO should be on attribute
        m_items[item_idx].deadband_active
            = check_deadband(m_items[item_idx].attr[i].type,
                m_items[item_idx].attr[i].size, deadband, buf, oldbuf);
        if (!m_items[item_idx].deadband_active) {
          updateOnlyTime = false;
          break;
        }
        buf = (char*)buf + m_items[item_idx].attr[i].size;
        oldbuf = (char*)oldbuf + m_items[item_idx].attr[i].size;
      }
    } else {
      setJump = true;
      for (size_t i = 0; i < m_items[item_idx].attr.size(); i++) {
        pwr_tFloat32 deadband
            = m_items[item_idx].deadband; // TODO should be on attribute
        m_items[item_idx].deadband_active
            = check_deadband(m_items[item_idx].attr[i].type,
                m_items[item_idx].attr[i].size, deadband, buf, oldbuf);
        if (!m_items[item_idx].deadband_active) {
          setJump = false;
          break;
        }
        buf = (char*)buf + m_items[item_idx].attr[i].size;
        oldbuf = (char*)oldbuf + m_items[item_idx].attr[i].size;
      }
    }
  }
  buf = data;
  oldbuf = olddata;

  if (!updateOnlyTime) {
    memcpy(oldbuf, buf, size);

    for (size_t i = 0; i < m_items[item_idx].attr.size(); i++) {
      if (m_items[item_idx].attr[i].type == pwr_eType_Time)
        *sts = time_AtoAscii((pwr_tTime*)buf, time_eFormat_NumDateAndTime,
            bufstr, sizeof(bufstr));
      else
        *sts = cdh_AttrValueToString(
            m_items[item_idx].attr[i].type, buf, bufstr, sizeof(bufstr));
      if (EVEN(*sts))
        return 0;
      if (m_items[item_idx].attr[i].type == pwr_eType_String
          || m_items[item_idx].attr[i].type == pwr_eType_Text) {
        valuesStr.append("'");
        valuesStr.append(bufstr);
        valuesStr.append("',");
      } else {
        valuesStr.append("'");
        valuesStr.append(bufstr);
        valuesStr.append("',");
      }
      char colNameStr[80];
      sprintf(colNameStr, "`%s`,",
          create_colName(i, m_items[item_idx].attr[i].aname));
      colsStr.append(colNameStr);

      //      colsStr.append("`");
      //      colsStr.append(m_items[item_idx].attr[i].aname);
      //      colsStr.append("`,");

      buf = (char*)buf + m_items[item_idx].attr[i].size;
    }
    // remove last ,
    valuesStr.resize(valuesStr.length() - 1);
    colsStr.resize(colsStr.length() - 1);

    if (m_items[item_idx].options & pwr_mSevOptionsMask_PosixTime) {
      if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
        // Posix time, high resolution
        queryOStr << "insert into " << m_items[item_idx].tablename
                  << " (sev__time, sev__ntime, " << colsStr << ") values ("
                  << time.tv_sec << "," << time.tv_nsec << "," << valuesStr
                  << ")";

        snprintf(query, constQueryLength,
            "insert into %s (sev__time, sev__ntime, %s) values (%ld,%ld,%s)",
            m_items[item_idx].tablename, colsStr.c_str(), (long int)time.tv_sec,
            (long int)time.tv_nsec, valuesStr.c_str());
      } else {
        // Posix time, low resolution
        queryOStr << "insert into " << m_items[item_idx].tablename
                  << " (sev__time, " << colsStr << ") values (" << time.tv_sec
                  << "," << valuesStr << ")";

        snprintf(query, constQueryLength,
            "insert into %s (sev__time, %s) values (%ld,%s)",
            m_items[item_idx].tablename, colsStr.c_str(), (long int)time.tv_sec,
            valuesStr.c_str());
      }
    } else {
      if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
        // Sql time, high resolution
        queryOStr << "insert into " << m_items[item_idx].tablename
                  << " (sev__time, sev__ntime, " << colsStr << ") values ("
                  << "'" << timstr << "'"
                  << "," << time.tv_nsec << "," << valuesStr << ")";

        snprintf(query, constQueryLength,
            "insert into %s (sev__time, sev__ntime, %s) values ('%s',%ld,%s)",
            m_items[item_idx].tablename, colsStr.c_str(), timstr,
            (long int)time.tv_nsec, valuesStr.c_str());

      } else {
        // Sql time, low resolution
        queryOStr << "insert into " << m_items[item_idx].tablename
                  << " (sev__time, " << colsStr << ") values ("
                  << "'" << timstr << "'"
                  << "," << valuesStr << ")";

        snprintf(query, constQueryLength,
            "insert into %s (sev__time, %s) values ('%s',%s)",
            m_items[item_idx].tablename, colsStr.c_str(), timstr,
            valuesStr.c_str());
      }
    }
  } // end insert new values
  else {
    if (m_items[item_idx].options & pwr_mSevOptionsMask_PosixTime) {
      if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
        // Posix time, high resolution
        queryOStr << "update " << m_items[item_idx].tablename
                  << " set sev__time = " << time.tv_sec
                  << ", sev__ntime = " << time.tv_nsec
                  << " where sev__id = " << m_items[item_idx].last_id;
      } else {
        // Posix time, low resolution
        queryOStr << "update " << m_items[item_idx].tablename
                  << " set sev__time = " << time.tv_sec
                  << " where sev__id = " << m_items[item_idx].last_id;
      }
    } else {
      if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
        // Sql time, high resolution
        queryOStr << "update " << m_items[item_idx].tablename
                  << " set sev__time = '" << timstr
                  << "', sev__ntime = " << time.tv_nsec
                  << " where sev__id = " << m_items[item_idx].last_id;
      } else {
        // Sql time, low resolution
        queryOStr << "update " << m_items[item_idx].tablename
                  << " set sev__time = '" << timstr
                  << "' where sev__id = " << m_items[item_idx].last_id;
      }
    }
  }

  if (setJump || updateOnlyTime) {
    sprintf(query, "update %s set sev__jump = 1 where sev__id = %d",
        m_items[item_idx].tablename, m_items[item_idx].last_id);
    int rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
    if (rc != SQLITE_OK) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("Update jump: %s\n", errmsg);
      sqlite3_free(errmsg);
    }
  }

  // printf( "Store_objectvalue: %s\n", queryOStr.str().c_str());

  int rc = sqlite3_exec(m_con, queryOStr.str().c_str(), 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, errmsg);
    printf("Error in: %s\n", queryOStr.str().c_str());

    *sts = SEV__DBERROR;
    m_items[item_idx].status = *sts;
    if (m_items[item_idx].status != m_items[item_idx].logged_status) {
      m_items[item_idx].logged_status = m_items[item_idx].status;
      errh_Error("Database update error: %s, table: %s object: %s", errmsg,
          m_items[item_idx].tablename, m_items[item_idx].oname);
    }
    sqlite3_free(errmsg);
    return 0;
  }

  m_items[item_idx].first_storage = 0;

  *sts = SEV__SUCCESS;
  m_items[item_idx].status = *sts;
  m_items[item_idx].logged_status = 1;

  return 1;
}

int sev_dbsqlite::get_item(pwr_tStatus* sts, void* thread, sev_item* item,
    pwr_tOid oid, char* attributename)
{
  char query[300];
  sqlite3_stmt* stmt;

  sprintf(query, "select "
                 "id,tablename,vid,oix,oname,aname,uptime,cretime,storagetime,"
                 "vtype,vsize,description,unit,scantime,deadband,options "
                 "from items where vid=%d and oix=%d and aname='%s'",
      oid.vid, oid.oix, attributename);

  int rc = sqlite3_prepare_v2(m_con, query, -1, &stmt, 0);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s\n", __FUNCTION__);
    return 0;
  }

  rc = sqlite3_step(stmt);
  if (rc != SQLITE_ROW) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s Result Error\n", __FUNCTION__);
    sqlite3_finalize(stmt);
    *sts = SEV__DBERROR;
    return 0;
  }

  int col = 0;
  const char* text;

  sev_attr attr;
  item->attr.push_back(attr);

  item->id = sqlite3_column_int(stmt, col++);
  text = (char*)sqlite3_column_text(stmt, col++);
  if (text)
    strncpy(item->tablename, text, sizeof(item->tablename));
  item->oid.vid = sqlite3_column_int(stmt, col++);
  item->oid.oix = sqlite3_column_int(stmt, col++);
  text = (char*)sqlite3_column_text(stmt, col++);
  if (text)
    strncpy(item->oname, text, sizeof(item->oname));
  text = (char*)sqlite3_column_text(stmt, col++);
  if (text)
    strncpy(item->attr[0].aname, text, sizeof(item->attr[0].aname));
  text = (char*)sqlite3_column_text(stmt, col++);
  if (text)
    timestr_to_time((char*)text, &item->modtime);
  text = (char*)sqlite3_column_text(stmt, col++);
  if (text)
    timestr_to_time((char*)text, &item->creatime);
  item->storagetime.tv_sec = sqlite3_column_int(stmt, col++);
  item->storagetime.tv_nsec = 0;
  item->attr[0].type = (pwr_eType)sqlite3_column_int(stmt, col++);
  item->attr[0].size = sqlite3_column_int(stmt, col++);
  text = (char*)sqlite3_column_text(stmt, col++);
  if (text)
    strncpy(item->description, text, sizeof(item->description));
  text = (char*)sqlite3_column_text(stmt, col++);
  if (text)
    strncpy(item->attr[0].unit, text, sizeof(item->attr[0].unit));
  item->scantime = sqlite3_column_double(stmt, col++);
  item->deadband = sqlite3_column_double(stmt, col++);
  item->options = sqlite3_column_int(stmt, col++);

  item->attrnum = 1;

  sqlite3_finalize(stmt);

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbsqlite::get_objectitem(pwr_tStatus* sts, void* thread, sev_item* item,
    pwr_tOid oid, char* attributename)
{
  char query[300];
  sqlite3_stmt* stmt;

  sprintf(query, "select "
                 "id,tablename,vid,oix,oname,aname,uptime,cretime,storagetime,"
                 "description,scantime,deadband,options "
                 "from objectitems where vid=%d and oix=%d and aname='%s'",
      oid.vid, oid.oix, attributename);

  int rc = sqlite3_prepare_v2(m_con, query, -1, &stmt, 0);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s\n", __FUNCTION__);
    return 0;
  }

  rc = sqlite3_step(stmt);
  if (rc != SQLITE_ROW) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s Result Error\n", __FUNCTION__);
    sqlite3_finalize(stmt);
    *sts = SEV__DBERROR;
    return 0;
  }

  int col = 0;
  const char* text;

  item->id = sqlite3_column_int(stmt, col++);
  text = (char*)sqlite3_column_text(stmt, col++);
  if (text)
    strncpy(item->tablename, text, sizeof(item->tablename));
  item->oid.vid = sqlite3_column_int(stmt, col++);
  item->oid.oix = sqlite3_column_int(stmt, col++);
  text = (char*)sqlite3_column_text(stmt, col++);
  if (text)
    strncpy(item->oname, text, sizeof(item->oname));
  col++; // No aname in sev_item TODO add aname to sev_item??
  text = (char*)sqlite3_column_text(stmt, col++);
  if (text)
    timestr_to_time((char*)text, &item->modtime);
  text = (char*)sqlite3_column_text(stmt, col++);
  if (text)
    timestr_to_time((char*)text, &item->creatime);
  item->storagetime.tv_sec = sqlite3_column_int(stmt, col++);
  item->storagetime.tv_nsec = 0;
  text = (char*)sqlite3_column_text(stmt, col++);
  if (text)
    strncpy(item->description, text, sizeof(item->description));
  item->scantime = sqlite3_column_double(stmt, col++);
  item->deadband = sqlite3_column_double(stmt, col++);
  item->options = sqlite3_column_int(stmt, col++);
  // Time to fetch all attributes for this item
  get_objectitemattributes(sts, item, item->tablename);

  item->attrnum = item->attr.size();

  sqlite3_finalize(stmt);

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbsqlite::get_objectitems(pwr_tStatus* sts)
{
  char query[300];
  sqlite3_stmt* stmt;

  sprintf(query, "select "
                 "id,tablename,vid,oix,oname,aname,uptime,cretime,storagetime,"
                 "description,scantime,deadband,options "
                 "from objectitems");

  int rc = sqlite3_prepare_v2(m_con, query, -1, &stmt, 0);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s\n", __FUNCTION__);
    return 0;
  }

  int col;
  for (int i = 0;; i++) {
    char* text;

    rc = sqlite3_step(stmt);
    if (rc != SQLITE_ROW)
      break;

    sev_item item;

    // printf( "%d %s %s\n", i, row[0], row[1]);
    col = 0;
    item.id = sqlite3_column_int(stmt, col++);
    text = (char*)sqlite3_column_text(stmt, col++);
    if (text)
      strncpy(item.tablename, text, sizeof(item.tablename));
    item.oid.vid = sqlite3_column_int(stmt, col++);
    item.oid.oix = sqlite3_column_int(stmt, col++);
    text = (char*)sqlite3_column_text(stmt, col++);
    if (text)
      strncpy(item.oname, text, sizeof(item.oname));
    col++; // No aname in sev_item TODO add aname to sev_item??
    text = (char*)sqlite3_column_text(stmt, col++);
    if (text)
      timestr_to_time(text, &item.modtime);
    text = (char*)sqlite3_column_text(stmt, col++);
    if (text)
      timestr_to_time(text, &item.creatime);
    item.storagetime.tv_sec = sqlite3_column_int(stmt, col++);
    item.storagetime.tv_nsec = 0;
    text = (char*)sqlite3_column_text(stmt, col++);
    if (text)
      strncpy(item.description, text, sizeof(item.description));
    text = (char*)sqlite3_column_text(stmt, col++);
    item.scantime = sqlite3_column_double(stmt, col++);
    item.deadband = sqlite3_column_double(stmt, col++);
    item.options = sqlite3_column_int(stmt, col++);
    // Time to fetch all attributes for this item
    get_objectitemattributes(sts, &item, item.tablename);

    item.attrnum = item.attr.size();

    m_items.push_back(item);
  }
  sqlite3_finalize(stmt);

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbsqlite::get_objectitemattributes(
    pwr_tStatus* sts, sev_item* item, char* tablename)
{
  char query[300];
  sqlite3_stmt* stmt;

  sprintf(query, "select attributename, attributetype, attributesize from "
                 "objectitemattributes where tablename='%s'order by "
                 "attributeidx asc",
      tablename);

  int rc = sqlite3_prepare_v2(m_con, query, -1, &stmt, 0);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s\n", __FUNCTION__);
    return 0;
  }

  int col;
  for (int i = 0;; i++) {
    char* text;

    rc = sqlite3_step(stmt);
    if (rc != SQLITE_ROW)
      break;

    sev_attr attr;
    col = 0;
    text = (char*)sqlite3_column_text(stmt, col++);
    if (text)
      strncpy(attr.aname, text, sizeof(attr.aname));
    attr.type = (pwr_eType)sqlite3_column_int(stmt, col++);
    attr.size = sqlite3_column_int(stmt, col++);
    attr.unit[0] = '\0'; // No unit present TODO add??
    item->value_size += attr.size;
    item->attr.push_back(attr);
  }
  sqlite3_finalize(stmt);

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbsqlite::delete_old_objectdata(pwr_tStatus* sts, void* thread,
    char* tablename, pwr_tMask options, pwr_tTime limit, pwr_tFloat32 scantime,
    pwr_tFloat32 garbagecycle)
{
  char query[300];
  char* errmsg;
  char timstr[40];

  *sts = time_AtoAscii(
      &limit, time_eFormat_NumDateAndTime, timstr, sizeof(timstr));
  if (EVEN(*sts))
    return 0;
  timstr[19] = 0;

  if (options & pwr_mSevOptionsMask_ReadOptimized) {
    // We scan trough as many rows that we write between two garbage cycles plus
    // some extra rows
    // to be sure that the table not grows to much.
    pwr_tUInt64 nbRowsToClean = 86400 * 2; // default value
    if (scantime > 0.0)
      nbRowsToClean = (pwr_tUInt64)((garbagecycle / scantime) + 10000.0);

    nbRowsToClean += get_minFromIntegerColumn(tablename, (char*)"sev__id");
    if (options & pwr_mSevOptionsMask_PosixTime)
      sprintf(query, "delete from %s where sev__id < " pwr_dFormatUInt64
                     " and sev__time < %ld;",
          tablename, nbRowsToClean, (long int)limit.tv_sec);
    else
      sprintf(query, "delete from %s where sev__id < " pwr_dFormatUInt64
                     " and sev__time < '%s';",
          tablename, nbRowsToClean, timstr);
  } else {
    if (options & pwr_mSevOptionsMask_PosixTime)
      sprintf(query, "delete from %s where sev__time < %ld;", tablename,
          (long int)limit.tv_sec);
    else
      sprintf(
          query, "delete from %s where sev__time < '%s';", tablename, timstr);
  }

  int rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, errmsg);
    sqlite3_free(errmsg);
    *sts = SEV__DBERROR;
    return 0;
  }

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbsqlite::check_deadband(pwr_eType type, unsigned int size,
    pwr_tFloat32 deadband, void* value, void* oldvalue)
{
  int deadband_active = 0;
  switch (type) {
  case pwr_eType_Float32:
    if (ABS(*(pwr_tFloat32*)value - *(pwr_tFloat32*)oldvalue) < deadband) {
      deadband_active = 1;
    }
    break;
  case pwr_eType_Float64:
    if (ABS(*(pwr_tFloat64*)value - *(pwr_tFloat64*)oldvalue) < deadband) {
      deadband_active = 1;
    }
    break;
  case pwr_eType_Int64:
    if (ABS(*(pwr_tInt64*)value - *(pwr_tInt64*)oldvalue) < deadband) {
      deadband_active = 1;
    }
    break;
  case pwr_eType_Int32:
    if (ABS(*(pwr_tInt32*)value - *(pwr_tInt32*)oldvalue) < deadband) {
      deadband_active = 1;
    }
    break;
  case pwr_eType_Int16:
    if (ABS(*(pwr_tInt16*)value - *(pwr_tInt16*)oldvalue) < deadband) {
      deadband_active = 1;
    }
    break;
  case pwr_eType_Int8:
  case pwr_eType_Char:
    if (ABS(*(pwr_tInt8*)value - *(pwr_tInt8*)oldvalue) < deadband) {
      deadband_active = 1;
    }
    break;
  case pwr_eType_UInt64:
    if (ABS(((pwr_tInt64)(*(pwr_tUInt64*)value - *(pwr_tUInt64*)oldvalue)))
        < deadband) {
      deadband_active = 1;
    }
    break;
  case pwr_eType_UInt32:
  case pwr_eType_Boolean:
    if (ABS(((pwr_tInt32)(*(pwr_tUInt32*)value - *(pwr_tUInt32*)oldvalue)))
        < deadband) {
      deadband_active = 1;
    }
    break;
  case pwr_eType_UInt16:
    if (ABS(((pwr_tInt16)(*(pwr_tUInt16*)value - *(pwr_tUInt16*)oldvalue)))
        < deadband) {
      deadband_active = 1;
    }
    break;
  case pwr_eType_UInt8:
    if (ABS(((pwr_tInt8)(*(pwr_tUInt8*)value - *(pwr_tUInt8*)oldvalue)))
        < deadband) {
      deadband_active = 1;
    }
    break;
  case pwr_eType_String:
  case pwr_eType_Text:
    if (!memcmp(value, oldvalue, size)) {
      deadband_active = 1;
    }
    break;
  default:;
  }
  return deadband_active;
}

int sev_dbsqlite::get_objectvalues(pwr_tStatus* sts, void* thread,
    sev_item* item, unsigned int size, pwr_tTime* starttime, pwr_tTime* endtime,
    int maxsize, pwr_tTime** tbuf, void** vbuf, unsigned int* bsize)
{
  char query[300];
  std::string queryStr;
  char starttimstr[40];
  char endtimstr[40];
  int total_rows;
  int max_id;
  int div;
  pwr_tDeltaTime dt;
  pwr_tTime stime, etime;
  std::string colsStr;
  char orderby_part[80];
  char jumpstr[40];
  char where_part[200];
  char last_update[20] = "";
  char create_time_str[20] = "2012-01-01 01:00:00";
  const char* text;
  sqlite3_stmt* stmt;

  if (starttime && starttime->tv_sec == 0 && starttime->tv_nsec == 0)
    starttime = 0;
  else
    stime = *starttime;

  if (endtime && endtime->tv_sec == 0 && endtime->tv_nsec == 0)
    endtime = 0;
  else
    etime = *endtime;

  // Get number of rows
  if (item->options & pwr_mSevOptionsMask_ReadOptimized) {
    sprintf(
        query, "select coalesce(max(sev__id)+1,0) from %s", item->tablename);
    int rc = sqlite3_prepare_v2(m_con, query, -1, &stmt, 0);
    if (rc != SQLITE_OK) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("GetValues Query Error\n");
      *sts = SEV__DBERROR;
      return 0;
    }

    rc = sqlite3_step(stmt);
    if (rc != SQLITE_ROW) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      *sts = SEV__DBERROR;
      return 0;
    }

    max_id = sqlite3_column_int(stmt, 0);
    sqlite3_finalize(stmt);
  } else {
    // TODO
    *sts = SEV__NYI;
    return 1;
  }

  if (starttime && endtime) {
    pwr_tTime update_time;
    if (!streq(last_update, ""))
      timestr_to_time(last_update, &update_time);

    if (time_Acomp(&item->creatime, &stime) == 1)
      stime = item->creatime;

    if (!streq(last_update, "") && time_Acomp(&etime, &update_time) == 1)
      etime = update_time;

    time_Adiff(&dt, &etime, &stime);
    total_rows = int(time_DToFloat(0, &dt) / item->scantime);
    if (max_id < total_rows)
      total_rows = max_id;

    div = total_rows / maxsize + 1;
  } else if (starttime) {
    pwr_tTime update_time;
    if (!streq(last_update, ""))
      timestr_to_time(last_update, &update_time);
    else
      time_GetTime(&update_time);

    if (time_Acomp(&update_time, starttime) != 1) {
      *sts = SEV__NODATATIME;
      return 0;
    }
    time_Adiff(&dt, &update_time, starttime);
    total_rows = int(time_DToFloat(0, &dt) / item->scantime);
  } else if (endtime) {
    pwr_tTime create_time;
    timestr_to_time(create_time_str, &create_time);

    if (time_Acomp(endtime, &create_time) != 1) {
      sqlite3_finalize(stmt);
      *sts = SEV__NODATATIME;
      return 0;
    }
    time_Adiff(&dt, endtime, &create_time);
    total_rows = int(time_DToFloat(0, &dt) / item->scantime);
    if (max_id < total_rows)
      total_rows = max_id;
  } else {
    total_rows = max_id;
  }

  div = total_rows / maxsize + 1;

  if (starttime) {
    *sts = time_AtoAscii(
        &stime, time_eFormat_NumDateAndTime, starttimstr, sizeof(starttimstr));
    if (EVEN(*sts))
      return 0;
    starttimstr[19] = 0;
  }
  if (endtime) {
    *sts = time_AtoAscii(
        &etime, time_eFormat_NumDateAndTime, endtimstr, sizeof(endtimstr));
    if (EVEN(*sts))
      return 0;
    endtimstr[19] = 0;
  }

  // Column part
  if (item->options & pwr_mSevOptionsMask_HighTimeResolution) {
    colsStr.append("sev__time, sev__ntime, ");
  } else {
    colsStr.append("sev__time, ");
  }
  char colNameStr[80];
  for (size_t i = 0; i < item->attr.size(); i++) {
    sprintf(colNameStr, "`%s`,", create_colName(i, item->attr[i].aname));
    colsStr.append(colNameStr);
  }
  // remove last ,
  colsStr.resize(colsStr.length() - 1);

  if (item->options & pwr_mSevOptionsMask_UseDeadBand)
    strcpy(jumpstr, "or sev__jump = 1");
  else
    strcpy(jumpstr, "");

  // 'order by' part
  if (item->options & pwr_mSevOptionsMask_ReadOptimized)
    strcpy(orderby_part, "sev__id");
  else {
    if (item->options & pwr_mSevOptionsMask_HighTimeResolution)
      strcpy(orderby_part, "sev__time,sev__ntime");
    else
      strcpy(orderby_part, "sev__time");
  }

  // 'where' part
  if (item->options & pwr_mSevOptionsMask_ReadOptimized) {
    if (starttime && endtime) {
      if (div == 1) {
        if (item->options & pwr_mSevOptionsMask_PosixTime)
          sprintf(where_part, "where sev__time >= %ld and sev__time <= %ld",
              (long int)starttime->tv_sec, (long int)endtime->tv_sec);
        else
          sprintf(where_part, "where sev__time >= '%s' and sev__time <= '%s'",
              starttimstr, endtimstr);
      } else {
        if (item->options & pwr_mSevOptionsMask_PosixTime)
          sprintf(where_part, "where (sev__id %% %d = 0 %s) and sev__time >= "
                              "%ld and sev__time <= %ld",
              div, jumpstr, (long int)starttime->tv_sec,
              (long int)endtime->tv_sec);
        else
          sprintf(where_part, "where (sev__id %% %d = 0 %s) and sev__time >= "
                              "'%s' and sev__time <= '%s'",
              div, jumpstr, starttimstr, endtimstr);
      }
    } else if (starttime) {
      if (div == 1) {
        if (item->options & pwr_mSevOptionsMask_PosixTime)
          sprintf(where_part, "where sev__time >= %ld",
              (long int)starttime->tv_sec);
        else
          sprintf(where_part, "where sev__time >= '%s'", starttimstr);
      } else {
        if (item->options & pwr_mSevOptionsMask_PosixTime)
          sprintf(where_part,
              "where (sev__id %% %d = 0 %s) and sev__time >= %ld", div, jumpstr,
              (long int)starttime->tv_sec);
        else
          sprintf(where_part,
              "where (sev__id %% %d = 0 %s) and sev__time >= '%s'", div,
              jumpstr, starttimstr);
      }
    } else if (endtime) {
      if (div == 1) {
        if (item->options & pwr_mSevOptionsMask_PosixTime)
          sprintf(
              where_part, "where sev__time <= %ld", (long int)endtime->tv_sec);
        else
          sprintf(where_part, "where sev__time <= '%s'", endtimstr);
      } else {
        if (item->options & pwr_mSevOptionsMask_PosixTime)
          sprintf(where_part,
              "where (sev__id %% %d = 0 %s) and sev__time <= %ld", div, jumpstr,
              (long int)endtime->tv_sec);
        else
          sprintf(where_part,
              "where (sev__id %% %d = 0 %s) and sev__time <= '%s'", div,
              jumpstr, endtimstr);
      }
    } else {
      if (div == 1)
        strcpy(where_part, "");
      else
        sprintf(where_part, "where sev__id %% %d = 0 %s", div, jumpstr);
    }
  } else {
    // Not read optimized
    if (starttime && endtime) {
      if (item->options & pwr_mSevOptionsMask_PosixTime)
        sprintf(where_part, "where sev__time >= %ld and sev__time <= %ld",
            (long int)starttime->tv_sec, (long int)endtime->tv_sec);
      else
        sprintf(where_part, "where sev__time >= '%s' and sev__time <= '%s'",
            starttimstr, endtimstr);
    } else if (starttime) {
      if (item->options & pwr_mSevOptionsMask_PosixTime)
        sprintf(
            where_part, "where sev__time >= %ld", (long int)starttime->tv_sec);
      else
        sprintf(where_part, "where sev__time >= '%s'", starttimstr);
    } else if (endtime) {
      if (item->options & pwr_mSevOptionsMask_PosixTime)
        sprintf(
            where_part, "where sev__time <= %ld", (long int)endtime->tv_sec);
      else
        sprintf(where_part, "where sev__time <= '%s'", endtimstr);
    } else
      strcpy(where_part, "");
  }

  queryStr.append("select ");
  queryStr.append(colsStr);
  queryStr.append(" from ");
  queryStr.append(item->tablename);
  queryStr.append(" ");
  queryStr.append(where_part);
  queryStr.append(" order by ");
  queryStr.append(orderby_part);

  errh_Info("Before query in get_objectvalues");
  printf("%s: %s\n", __FUNCTION__, queryStr.c_str());

  int rc = sqlite3_prepare_v2(m_con, queryStr.c_str(), -1, &stmt, 0);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s\n", __FUNCTION__);
    *sts = SEV__DBERROR;
    return 0;
  }
  errh_Info("After query in get_objectvalues");

  int bufrows = total_rows / div;
  int row_cnt = 0;

  if (item->options & pwr_mSevOptionsMask_ReadOptimized) {
    *tbuf = (pwr_tTime*)calloc(bufrows, sizeof(pwr_tTime));
    *vbuf = calloc(bufrows, item->value_size);

    int bcnt = 0;
    for (int i = 0;; i++) {
      rc = sqlite3_step(stmt);
      if (rc != SQLITE_ROW)
        break;

      row_cnt++;
      if (row_cnt > bufrows)
        break;

      int j = 0;

      if (item->options & pwr_mSevOptionsMask_PosixTime) {
        if (item->options & pwr_mSevOptionsMask_HighTimeResolution) {
          // Posix time, high resolution
          text = (const char*)sqlite3_column_text(stmt, j++);
          if (text)
            timestr_to_time((char*)text, (pwr_tTime*)&(*tbuf)[bcnt].tv_sec);
          (*tbuf)[bcnt].tv_nsec = sqlite3_column_int(stmt, j++);
        } else {
          // Posix time, low resolution
          text = (const char*)sqlite3_column_text(stmt, j++);
          if (text)
            timestr_to_time((char*)text, (pwr_tTime*)&(*tbuf)[bcnt].tv_sec);
        }
      } else {
        if (item->options & pwr_mSevOptionsMask_HighTimeResolution) {
          // Sql time, high resolution
          text = (const char*)sqlite3_column_text(stmt, j++);
          if (text)
            timestr_to_time((char*)text, (pwr_tTime*)&(*tbuf)[bcnt].tv_sec);
          (*tbuf)[bcnt].tv_nsec = sqlite3_column_int(stmt, j++);
        } else {
          // Sql time, low resolution
          text = (const char*)sqlite3_column_text(stmt, j++);
          if (text)
            timestr_to_time((char*)text, (pwr_tTime*)&(*tbuf)[bcnt].tv_sec);
        }
      }
      int read_size = 0;
      for (size_t k = 0; k < item->attr.size(); k++) {
        const char* value_str = (const char*)sqlite3_column_text(stmt, j++);
        if (!value_str || streq(value_str, "")) {
          // Null value
          switch (item->attr[k].type) {
          case pwr_eType_Float32:
          case pwr_eType_Float64:
          case pwr_eType_Int8:
          case pwr_eType_Int16:
          case pwr_eType_Int32:
          case pwr_eType_Int64:
          case pwr_eType_UInt8:
          case pwr_eType_UInt16:
          case pwr_eType_UInt32:
          case pwr_eType_UInt64:
          case pwr_eType_Mask:
          case pwr_eType_Enum:
            cdh_StringToAttrValue(item->attr[k].type, "0",
                ((char*)*vbuf) + bcnt * item->value_size + read_size);
            break;
          case pwr_eType_Time:
          case pwr_eType_DeltaTime:
            // TODO deltatime??
            cdh_StringToAttrValue(item->attr[k].type, "1970-01-01 00:00:00",
                ((char*)*vbuf) + bcnt * item->value_size + read_size);
            break;
          default:
            cdh_StringToAttrValue(item->attr[k].type, " ",
                ((char*)*vbuf) + bcnt * item->value_size + read_size);
            break;
          }
          j++;
        } else {
          cdh_StringToAttrValue(item->attr[k].type, value_str,
              ((char*)*vbuf) + bcnt * item->value_size + read_size);
        }
        read_size += item->attr[k].size;
      }
      bcnt++;
      // if ( item->options & pwr_mSevOptionsMask_HighTimeResolution)
      //  printf( "%5d %5d %s.%9s %s\n", i, bcnt, row[0], row[1], row[2]);
      // else
      //  printf( "%5d %5d %s %s\n", i, bcnt, row[0], row[1]);
    }
    printf("bcnt %d bufrows %d\n", bcnt, bufrows);
    *bsize = bcnt;
    sqlite3_finalize(stmt);
  } else {
    *tbuf = (pwr_tTime*)calloc(bufrows, sizeof(pwr_tTime));
    *vbuf = calloc(bufrows, size);

    int bcnt = 0;
    for (int i = 0;; i++) {
      if (i == 0) {
        rc = sqlite3_step(stmt);
        if (rc != SQLITE_ROW)
          break;
      } else {
        for (int k = 0; k < div; k++) {
          rc = sqlite3_step(stmt);
          if (rc != SQLITE_ROW)
            break;
        }
        if (rc != SQLITE_ROW)
          break;
      }

      bufrows++;
      int j = 0;

      if (item->options & pwr_mSevOptionsMask_PosixTime) {
        if (item->options & pwr_mSevOptionsMask_HighTimeResolution) {
          // Posix time, high resolution
          text = (const char*)sqlite3_column_text(stmt, j++);
          if (text)
            timestr_to_time((char*)text, (pwr_tTime*)&(*tbuf)[bcnt].tv_sec);
          (*tbuf)[bcnt].tv_nsec = sqlite3_column_int(stmt, j++);
        } else {
          // Posix time, low resolution
          text = (const char*)sqlite3_column_text(stmt, j++);
          if (text)
            timestr_to_time((char*)text, (pwr_tTime*)&(*tbuf)[bcnt].tv_sec);
        }
      } else {
        if (item->options & pwr_mSevOptionsMask_HighTimeResolution) {
          // Sql time, high resolution
          text = (const char*)sqlite3_column_text(stmt, j++);
          if (text)
            timestr_to_time((char*)text, (pwr_tTime*)&(*tbuf)[bcnt].tv_sec);
          (*tbuf)[bcnt].tv_nsec = sqlite3_column_int(stmt, j++);
        } else {
          // Sql time, low resolution
          text = (const char*)sqlite3_column_text(stmt, j++);
          if (text)
            timestr_to_time((char*)text, (pwr_tTime*)&(*tbuf)[bcnt].tv_sec);
        }
      }

      int read_size = 0;
      for (size_t k = 0; k < item->attr.size(); k++) {
        const char* value_str = (const char*)sqlite3_column_text(stmt, j++);
        if (streq(value_str, "")) {
          // Null value
          switch (item->attr[k].type) {
          case pwr_eType_Float32:
          case pwr_eType_Float64:
          case pwr_eType_Int8:
          case pwr_eType_Int16:
          case pwr_eType_Int32:
          case pwr_eType_Int64:
          case pwr_eType_UInt8:
          case pwr_eType_UInt16:
          case pwr_eType_UInt32:
          case pwr_eType_UInt64:
          case pwr_eType_Mask:
          case pwr_eType_Enum:
            cdh_StringToAttrValue(item->attr[k].type, "0",
                ((char*)*vbuf) + bcnt * item->value_size + read_size);
            break;
          case pwr_eType_Time:
          case pwr_eType_DeltaTime:
            // TODO deltatime??
            cdh_StringToAttrValue(item->attr[k].type, "1970-01-01 00:00:00",
                ((char*)*vbuf) + bcnt * item->value_size + read_size);
            break;
          default:
            cdh_StringToAttrValue(item->attr[k].type, " ",
                ((char*)*vbuf) + bcnt * item->value_size + read_size);
            break;
          }
          j++;
        } else {
          cdh_StringToAttrValue(item->attr[k].type, value_str,
              ((char*)*vbuf) + bcnt * item->value_size + read_size);
        }
        read_size += item->attr[k].size;
      }
      bcnt++;
      // if ( item->options & pwr_mSevOptionsMask_HighTimeResolution)
      //  printf( "%5d %5d %s.%9s %s\n", i, bcnt, row[0], row[1], row[2]);
      // else
      //  printf( "%5d %5d %s %s\n", i, bcnt, row[0], row[1]);
    }
    printf("bcnt %d bufrows %d\n", bcnt, bufrows);
    *bsize = bcnt;
    sqlite3_finalize(stmt);
  }
  errh_Info("After copying values in get_objectvalues");

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbsqlite::handle_itemchange(
    pwr_tStatus* sts, char* tablename, unsigned int item_idx)
{
  char timestr[40];
  pwr_tTime uptime;

  time_GetTime(&uptime);
  time_AtoAscii(&uptime, time_eFormat_NumDateAndTime, timestr, sizeof(timestr));
  timestr[19] = 0;

  // Replace ':' '-' and ' ' in timestr with '_'
  for (char* s = timestr; *s; s++) {
    if (*s == ':')
      *s = '_';
    if (*s == ' ')
      *s = '_';
    if (*s == '-')
      *s = '_';
  }

  char newTableName[64];
  snprintf(newTableName, sizeof(newTableName), "%s_%s", tablename, timestr);

  printf("Recreating table %s due to attribute definition changes, old table "
         "saved to %s \n",
      tablename, newTableName);
  errh_Warning("Recreating table %s due to attribute definition changes, old "
               "table saved to %s",
      tablename, newTableName);

  char query[600];
  char* errmsg;
  sprintf(query, "RENAME TABLE %s to %s", tablename, newTableName);
  int rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, errmsg);
    sqlite3_free(errmsg);
    *sts = SEV__DBERROR;
    return 0;
  }

  sev_item* item = &m_items[item_idx];

  create_table(sts, item->tablename, item->attr[0].type, item->attr[0].size,
      item->options, item->deadband);
  if (EVEN(*sts))
    return 0;

  if (item->options & pwr_mSevOptionsMask_ReadOptimized) {
    // If we set increment to same value as in the old table we can easily move
    // the data from the old table to the new one
    pwr_tUInt64 autoIncrValue
        = get_maxFromIntegerColumn(newTableName, (char*)"id");
    if (autoIncrValue)
      autoIncrValue++;
    sprintf(query, "ALTER TABLE %s AUTO_INCREMENT = " pwr_dFormatUInt64,
        tablename, autoIncrValue);
    rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
    if (rc != SQLITE_OK) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("%s: %s\n", __FUNCTION__, errmsg);
      sqlite3_free(errmsg);
      *sts = SEV__DBERROR;
      return 0;
    }
  }

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbsqlite::handle_objectchange(
    pwr_tStatus* sts, char* tablename, unsigned int item_idx, bool newObject)
{
  char newTableName[64];
  char query[600];
  char* errmsg;
  int rc;

  sev_item* item = &m_items[item_idx];

  if (!newObject) {
    char timestr[40];
    pwr_tTime uptime;

    time_GetTime(&uptime);
    time_AtoAscii(
        &uptime, time_eFormat_NumDateAndTime, timestr, sizeof(timestr));
    timestr[19] = 0;

    // Replace ':' '-' and ' ' in timestr with '_'
    for (char* s = timestr; *s; s++) {
      if (*s == ':')
        *s = '_';
      if (*s == ' ')
        *s = '_';
      if (*s == '-')
        *s = '_';
    }

    snprintf(newTableName, sizeof(newTableName), "%s_%s", tablename, timestr);

    printf("Recreating table %s due to attribute definition changes, old table "
           "saved to %s \n",
        tablename, newTableName);
    errh_Warning("Recreating table %s due to attribute definition changes, old "
                 "table saved to %s",
        tablename, newTableName);

    sprintf(query, "RENAME TABLE %s to %s", tablename, newTableName);
    rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
    if (rc != SQLITE_OK) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("%s: %s\n", __FUNCTION__, errmsg);
      sqlite3_free(errmsg);
      *sts = SEV__DBERROR;
      return 0;
    }

    create_objecttable(sts, tablename, item->options, item->deadband);
    if (EVEN(*sts))
      return 0;

    if (item->options & pwr_mSevOptionsMask_ReadOptimized) {
      // If we set increment to same value as in the old table we can easily
      // move the data from the old table to the new one
      pwr_tUInt64 autoIncrValue
          = get_maxFromIntegerColumn(newTableName, (char*)"sev__id");
      if (autoIncrValue)
        autoIncrValue++;
      sprintf(query, "ALTER TABLE %s AUTO_INCREMENT = " pwr_dFormatUInt64,
          tablename, autoIncrValue);
      rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
      if (rc != SQLITE_OK) {
        printf("In %s row %d:\n", __FILE__, __LINE__);
        printf("%s: %s\n", __FUNCTION__, errmsg);
        sqlite3_free(errmsg);
        *sts = SEV__DBERROR;
        return 0;
      }
    }

    sprintf(query, "delete from objectitemattributes where tablename = '%s'",
        tablename);
    rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
    if (rc != SQLITE_OK) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("%s: %s\n", __FUNCTION__, errmsg);
      sqlite3_free(errmsg);
      *sts = SEV__DBERROR;
      return 0;
    }
  }

  for (size_t i = 0; i < item->attr.size(); i++) {
    char colName[64];
    strncpy(colName, create_colName(i, item->attr[i].aname), sizeof(colName));
    // sprintf(colName, "col_%d", i);
    sprintf(query, "alter table %s add `%s` %s;", tablename, colName,
        pwrtype_to_type(item->attr[i].type, item->attr[i].size));
    rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
    if (rc != SQLITE_OK) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("%s: %s\n", __FUNCTION__, errmsg);
      sqlite3_free(errmsg);
      *sts = SEV__DBERROR;
      return 0;
    }
    int aidx = i;
    sprintf(query, "insert into objectitemattributes (tablename, "
                   "attributename, attributeidx, attributetype, attributesize) "
                   "values('%s', '%s', %d, %d, %d)",
        tablename, item->attr[i].aname, aidx, item->attr[i].type,
        item->attr[i].size);
    rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
    if (rc != SQLITE_OK) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("%s: %s\n", __FUNCTION__, errmsg);
      sqlite3_free(errmsg);
      *sts = SEV__DBERROR;
      return 0;
    }
  }
  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbsqlite::repair_table(pwr_tStatus* sts, char* tablename)
{
  *sts = SEV__SUCCESS;

  return ODD(*sts);
}

int sev_dbsqlite::alter_engine(pwr_tStatus* sts, char* tablename)
{
  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbsqlite::store_stat(sev_sStat* stat)
{
  char query[250];
  char* errmsg;
  int rc;

  sprintf(query, "update sev_stat set current_load = %f,medium_load = %f,"
                 "storage_rate=%f,medium_storage_rate=%f,datastore_msg_cnt=%d,"
                 "dataget_msg_cnt=%d,items_msg_cnt=%d,eventstore_msg_cnt=%d",
      stat->current_load, stat->medium_load, stat->storage_rate,
      stat->medium_storage_rate, stat->datastore_msg_cnt, stat->dataget_msg_cnt,
      stat->items_msg_cnt, stat->eventstore_msg_cnt);
  rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Update sev_stat: %s\n", errmsg);
    sqlite3_free(errmsg);
    return 0;
  }
  return 1;
}

int sev_dbsqlite::begin_transaction(void* thread)
{
  char query[20];
  char* errmsg;
  int rc;

  strcpy(query, "begin transaction");
  rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Begin transaction: %s\n", errmsg);
    sqlite3_free(errmsg);
    return 0;
  }
  return 1;
}

int sev_dbsqlite::commit_transaction(void* thread)
{
  char query[20];
  char* errmsg;
  int rc;

  strcpy(query, "commit transaction");
  rc = sqlite3_exec(m_con, query, 0, 0, &errmsg);
  if (rc != SQLITE_OK) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Begin transaction: %s\n", errmsg);
    sqlite3_free(errmsg);
    return 0;
  }
  return 1;
}

sev_dbsqlite::~sev_dbsqlite()
{
  printf("Freeing memory\n");
  for (size_t idx = 0; idx < m_items.size(); idx++) {
    if (m_items[idx].old_value != 0) {
      free(m_items[idx].old_value);
      m_items[idx].old_value = 0;
    }
  }
}

#else
extern int no_sev_dbsqlite;
int no_sev_dbsqlite = 0;
#endif
