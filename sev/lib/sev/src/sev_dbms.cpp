/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#if defined PWRE_CONF_MYSQL

#include <errno.h>

#include <sstream>
#include <string>
#include <sys/stat.h>

#include <mysqld_error.h>
#include <errmsg.h>

#include "pwr_names.h"

#include "co_cdh.h"
#include "co_cnf.h"
#include "co_dcli.h"
#include "co_string.h"
#include "co_syi.h"
#include "co_time.h"

#include "rt_errh.h"
#include "rt_load.h"

#include "sev_dbms.h"

static unsigned int mysql_timeout = 315360000;
static bool mysql_enable_reconnect = true;

char sev_dbms_env::m_systemName[40];

sev_dbms_env::sev_dbms_env(const char* v_fileName)
    : m_con(0), m_fileName(0), m_host(0), m_user(0), m_passwd(0), m_dbName(0),
      m_port(0), m_socket(0), m_exists(false)
{
  fileName(v_fileName);
  strcpy(m_systemName, "");

  get_systemname();
}

sev_dbms_env::sev_dbms_env(const char* v_host, const char* v_user,
    const char* v_passwd, const char* v_dbName, unsigned int v_port,
    const char* v_socket)
    : m_con(0), m_fileName(0), m_host(0), m_user(0), m_passwd(0), m_dbName(0),
      m_port(0), m_socket(0), m_exists(false)
{
  strcpy(m_systemName, "");
  host(v_host);
  user(v_user);
  passwd(v_passwd);
  dbName(v_dbName);
  port(v_port);
  socket(v_socket);
  get_systemname();
}

sev_dbms_env::~sev_dbms_env()
{
  close();
}

void sev_dbms_env::host(const char* host)
{
  if (!host)
    return;

  m_host = (char*)realloc(m_host, strlen(host) + 1);
  strcpy(m_host, host);
}

char* sev_dbms_env::user(void)
{
  return m_user;
}

void sev_dbms_env::user(const char* user)
{
  if (!user)
    return;

  m_user = (char*)realloc(m_user, strlen(user) + 1);
  strcpy(m_user, user);
}

char* sev_dbms_env::passwd(void)
{
  return m_passwd;
}

void sev_dbms_env::passwd(const char* passwd)
{
  if (!passwd)
    return;

  m_passwd = (char*)realloc(m_passwd, strlen(passwd) + 1);
  strcpy(m_passwd, passwd);
}

void sev_dbms_env::dbName(const char* dbName)
{
  if (!dbName)
    return;

  m_dbName = (char*)realloc(m_dbName, strlen(dbName) + 1);
  strcpy(m_dbName, dbName);
}

char* sev_dbms_env::fileName(void)
{
  return m_fileName;
}

void sev_dbms_env::fileName(const char* fileName)
{
  if (!fileName)
    return;

  m_fileName = (char*)realloc(m_fileName, strlen(fileName) + 1);
  strcpy(m_fileName, fileName);
}

char* sev_dbms_env::dbName(void)
{
  static char dbname[80];

  get_systemname();
  strcpy(dbname, "pwrp__");
  strcat(dbname, m_systemName);
  str_ToLower(dbname, dbname);

  return dbname;
}

char* sev_dbms_env::host(void)
{
  char nodename[80];
  pwr_tStatus sts;
  static char host[80];

  syi_NodeName(&sts, nodename, sizeof(nodename));
  if (ODD(sts) && str_NoCaseStrcmp(nodename, m_host) == 0)
    strcpy(host, "localhost");
  else
    strcpy(host, m_host);

  return host;
}

unsigned int sev_dbms_env::port(void)
{
  return m_port;
}

void sev_dbms_env::port(const unsigned int port)
{
  m_port = port;
}

char* sev_dbms_env::socket(void)
{
  return m_socket;
}

void sev_dbms_env::socket(const char* socket)
{
  if (!socket)
    return;

  m_socket = (char*)realloc(m_socket, strlen(socket) + 1);
  strcpy(m_socket, socket);
}

MYSQL* sev_dbms_env::con(void)
{
  return m_con;
}

sev_dbms_env::sev_dbms_env()
    : m_con(0), m_fileName(0), m_host(0), m_user(0), m_passwd(0), m_dbName(0),
      m_port(0), m_socket(0), m_exists(false){

      };

int sev_dbms_env::close()
{
  return 0;
}

#if 0
int sev_dbms_env::open(const char *v_host, const char *v_user, const char *v_passwd,
                        const char *v_dbName, unsigned int v_port, const char *v_socket)
{

  host(v_host);
  user(v_user);
  passwd(v_passwd);
  dbName(v_dbName);
  port(v_port);
  socket(v_socket);

  m_con = mysql_init(NULL);

  MYSQL *con = mysql_real_connect(m_con, host(), user(), passwd(), dbName(), port(), socket(), 0);
  if (con == 0) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Failed to connect to database: Error: %s\n", mysql_error(m_con));
    return 1;
  }

  char sql[255];

  sprintf(sql, "use %s", dbName());
  int rc = mysql_query(m_con, sql);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s\n", mysql_error(m_con));
    printf("%s\n", sql);
    return rc;
  } else {
    printf("database open %s\n", sql);
  }

  return 0;
}
#endif

int sev_dbms_env::create(const char* v_fileName, const char* v_host,
    const char* v_user, const char* v_passwd, const char* v_dbName,
    unsigned int v_port, const char* v_socket)
{
  fileName(v_fileName);
  host(v_host);
  user(v_user);
  passwd(v_passwd);
  dbName(v_dbName);
  port(v_port);
  socket(v_socket);

  create();

  return 0;
}

MYSQL* sev_dbms_env::createDb(void)
{

  if (mysql_library_init(0, NULL, NULL)) {
    printf("** Cannot init mysql client library\n");
    return 0;
  }

  m_con = mysql_init(NULL);

  mysql_options(m_con, MYSQL_OPT_CONNECT_TIMEOUT, &mysql_timeout);
  mysql_options(m_con, MYSQL_OPT_RECONNECT, &mysql_enable_reconnect);

  MYSQL* con = mysql_real_connect(
      m_con, host(), user(), passwd(), 0, port(), socket(), 0);
  // printf("Tried to connect to database, con %x: Status: %s\n", (int)con,
  // mysql_error(m_con));
  if (con == 0) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Failed to connect to database: Error: %s\n", mysql_error(m_con));
    return 0;
  }

  char query[400];
  int rc;

  // Update auto_increment in stats immediately
  sprintf(query, "set persist information_schema_stats_expiry = 0");
  rc = mysql_query(m_con, query);
  sprintf(query, "set session information_schema_stats_expiry = 0");
  rc = mysql_query(m_con, query);

  sprintf(query, "create database %s", dbName());
  rc = mysql_query(m_con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s\n", mysql_error(m_con));
    printf("%s\n", query);
    return 0;
  }

  sprintf(query, "use %s", dbName());
  rc = mysql_query(m_con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s\n", mysql_error(m_con));
    printf("%s\n", query);
    return 0;
  }

  sprintf(query, "create table items ("
                 "id int unsigned not null primary key auto_increment,"
                 "tablename varchar(255),"
                 "vid int unsigned,"
                 "oix int unsigned,"
                 "oname varchar(255),"
                 "aname varchar(255),"
                 "uptime datetime,"
                 "cretime datetime,"
                 "storagetime int unsigned,"
                 "deadband float,"
                 "options int unsigned,"
                 "scantime float,"
                 "description varchar(80),"
                 "vtype int unsigned,"
                 "vsize int unsigned,"
                 "unit varchar(16));");

  rc = mysql_query(m_con, query);
  if (rc)
    printf("Create items table: %s\n", mysql_error(m_con));

  createSevVersion2Tables();
  createSevVersion3Tables();

  return con;
}

int sev_dbms_env::checkAndUpdateVersion(unsigned int version)
{
  unsigned int old_version = 1; // Proview 4.6.0.0 was first release with sev
  int rc = mysql_query(m_con, "select * from sev_version");
  if (rc) {
    printf("table sev_version do no exist\n");
  } else {
    MYSQL_ROW row;
    MYSQL_RES* result = mysql_store_result(m_con);

    if (!result) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("selecting sev_version Error\n");
      return 0;
    }

    row = mysql_fetch_row(result);
    if (!row) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("selecting sev_version Error\n");
      return 0;
    }

    old_version = strtoul(row[0], 0, 10);
    mysql_free_result(result);
  }

  printf("old sev_version: %d, new sev_version: %d\n", old_version, version);

  // add code for new versions here
  if (old_version < 2) {
    printf("Updating database tables to sev version 2\n");
    updateDBToSevVersion2();
  }
  if (old_version < 3) {
    printf("Updating database tables to sev version 3\n");
    createSevVersion3Tables();
  }
  if (old_version < 4) {
    printf("Updating database tables to sev version 4\n");
    updateDBToSevVersion4();
  }

  if (old_version < 5) {
    printf("Updating database tables to sev version 5\n");
    updateDBToSevVersion5();
  }

  if (old_version != version) {
    char query[100];
    sprintf(query, "update sev_version set version = %d", version);
    rc = mysql_query(m_con, query);
    if (rc) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("Update sev_version: %s\n", mysql_error(m_con));
    }
  }
  return 1;
}

int sev_dbms_env::updateDBToSevVersion2(void)
{
  createSevVersion2Tables();

  int rc;
  char query[530];

  sprintf(query, "select id,tablename,vid,oix from items order by id");

  rc = mysql_query(con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(con()));
    return 0;
  }

  MYSQL_ROW row;
  MYSQL_RES* result = mysql_store_result(con());
  if (!result) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("GetValues Result Error\n");
    return 0;
  }
  int rows = mysql_num_rows(result);

  std::vector<sev_item> itemsVec;
  for (int i = 0; i < rows; i++) {
    sev_item item;
    row = mysql_fetch_row(result);
    if (!row)
      break;
    item.id = atoi(row[0]);
    strncpy(item.tablename, row[1], sizeof(item.tablename));
    item.oid.vid = strtoul(row[2], 0, 10);
    item.oid.oix = strtoul(row[3], 0, 10);
    itemsVec.push_back(item);
  }
  mysql_free_result(result);

  char newTableName[256];
  for (size_t i = 0; i < itemsVec.size(); i++) {
    sprintf(newTableName, "%s_%d",
        sev_dbms::oid_to_table(itemsVec[i].oid, (char*)""), itemsVec[i].id);

    printf("UPDATE TO SEV_VERSION 2: Renaming table %s to %s \n",
        itemsVec[i].tablename, newTableName);
    errh_Info("UPDATE TO SEV_VERSION 2: Renaming table %s to %s",
        itemsVec[i].tablename, newTableName);

    sprintf(
        query, "RENAME TABLE %s to %s", itemsVec[i].tablename, newTableName);
    rc = mysql_query(con(), query);
    if (rc) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("%s: %s\n", __FUNCTION__, mysql_error(con()));
      return 0;
    }

    sprintf(query, "update items set tablename='%s' where id=%d", newTableName,
        itemsVec[i].id);
    rc = mysql_query(con(), query);
    if (rc) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("%s: %s\n", __FUNCTION__, mysql_error(con()));
      return 0;
    }
  }
  return 1;
}

int sev_dbms_env::createSevVersion2Tables(void)
{
  char query[400];

  sprintf(query, "create table sev_version ("
                 "version int unsigned not null primary key);");
  int rc = mysql_query(m_con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Create sev_version table: %s\n", mysql_error(m_con));
  }

  sprintf(query, "insert into sev_version (version) values(%d)", sev_cVersion);
  rc = mysql_query(m_con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Insert into table sev_version: %s\n", mysql_error(m_con));
  }

  sprintf(query, "create table objectitems ("
                 "id int unsigned not null primary key auto_increment,"
                 "tablename varchar(255),"
                 "vid int unsigned,"
                 "oix int unsigned,"
                 "oname varchar(255),"
                 "aname varchar(255),"
                 "uptime datetime,"
                 "cretime datetime,"
                 "storagetime int unsigned,"
                 "deadband float,"
                 "options int unsigned,"
                 "scantime float,"
                 "description varchar(80));");

  rc = mysql_query(m_con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Create objectitems table: %s\n", mysql_error(m_con));
  }

  sprintf(query, "create table objectitemattributes ("
                 "tablename varchar(255) not null,"
                 "attributename varchar(255) not null,"
                 "attributeidx int unsigned not null,"
                 "attributetype int unsigned not null,"
                 "attributesize int unsigned not null,"
                 "PRIMARY KEY(tablename, attributename)) default charset=utf8;");

  rc = mysql_query(m_con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Create objectitemattributes table: %s\n", mysql_error(m_con));
  }

  return 1;
}

int sev_dbms_env::createSevVersion3Tables(void)
{
  char query[400];

  sprintf(query,
      "create table sev_stat (current_load float,medium_load float,"
      "storage_rate float,medium_storage_rate float,"
      "datastore_msg_cnt int unsigned,dataget_msg_cnt int unsigned,"
      "items_msg_cnt int unsigned,eventstore_msg_cnt int unsigned);");
  int rc = mysql_query(m_con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Create sev_stat table: %s\n", mysql_error(m_con));
  }
  sprintf(
      query, "insert into sev_stat (current_load, medium_load) values(0,0)");
  rc = mysql_query(m_con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Insert into table sev_stat: %s\n", mysql_error(m_con));
  }
  return 1;
}

int sev_dbms_env::updateDBToSevVersion4(void)
{
  int rc;
  char query[300];

  sprintf(query,
      "select id,tablename from items where aname = 'Events' order by id");

  rc = mysql_query(con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(con()));
    return 0;
  }

  MYSQL_ROW row;
  MYSQL_RES* result = mysql_store_result(con());
  if (!result) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("GetValues Result Error\n");
    return 0;
  }
  int rows = mysql_num_rows(result);

  std::vector<sev_item> itemsVec;
  for (int i = 0; i < rows; i++) {
    char tablename[80];
    int id;

    row = mysql_fetch_row(result);
    if (!row)
      break;
    id = atoi(row[0]);
    strncpy(tablename, row[1], sizeof(tablename));

    sprintf(query,
        "alter table %s add supobject_size int unsigned after eventid_idx,"
        "add supobject_offset int unsigned after eventid_idx, add "
        "supobject_oix int unsigned after eventid_idx,"
        "add supobject_vid int unsigned after eventid_idx",
        tablename);

    rc = mysql_query(con(), query);
    if (rc) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("%s: %s\n", __FUNCTION__, mysql_error(con()));
      return 0;
    }
  }
  mysql_free_result(result);

  return 1;
}

int sev_dbms_env::updateDBToSevVersion5(void)
{
  int rc;
  char query[300];

  sprintf(query,
      "select id,tablename from items where aname = 'Events' order by id");

  rc = mysql_query(con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(con()));
    return 0;
  }

  MYSQL_ROW row;
  MYSQL_RES* result = mysql_store_result(con());
  if (!result) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("GetValues Result Error\n");
    return 0;
  }
  int rows = mysql_num_rows(result);

  std::vector<sev_item> itemsVec;
  for (int i = 0; i < rows; i++) {
    char tablename[80];
    int id;

    row = mysql_fetch_row(result);
    if (!row)
      break;
    id = atoi(row[0]);
    strncpy(tablename, row[1], sizeof(tablename));

    sprintf(query,
        "alter table %s add eventstatus int unsigned after eventname",
        tablename);

    rc = mysql_query(con(), query);
    if (rc) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("%s: %s\n", __FUNCTION__, mysql_error(con()));
      return 0;
    }

    sprintf(query,
        "update %s set eventstatus=0",
        tablename);

    rc = mysql_query(con(), query);
    if (rc) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("%s: %s\n", __FUNCTION__, mysql_error(con()));
      return 0;
    }
  }
  mysql_free_result(result);

  return 1;
}

MYSQL* sev_dbms_env::openDb(unsigned int* sts)
{
  *sts = 0;

  if (mysql_library_init(0, NULL, NULL)) {
    printf("** Cannot init mysql client library\n");
    return 0;
  }

  m_con = mysql_init(NULL);

  mysql_options(m_con, MYSQL_OPT_CONNECT_TIMEOUT, &mysql_timeout);
  mysql_options(m_con, MYSQL_OPT_RECONNECT, &mysql_enable_reconnect);

  MYSQL* con = mysql_real_connect(
      m_con, host(), user(), passwd(), dbName(), port(), socket(), 0);
  if (con == 0) {
    *sts = mysql_errno(m_con);
    return 0;
  }

  return con;
}

MYSQL* sev_dbms_env::open_thread(unsigned int* sts)
{
  MYSQL* con = mysql_init(NULL);

  mysql_options(con, MYSQL_OPT_CONNECT_TIMEOUT, &mysql_timeout);
  mysql_options(con, MYSQL_OPT_RECONNECT, &mysql_enable_reconnect);

  con = mysql_real_connect(
      con, host(), user(), passwd(), dbName(), port(), socket(), 0);
  if (con == 0) {
    *sts = mysql_errno(m_con);
    return 0;
  }

  return con;
}

void sev_dbms_env::close_thread(MYSQL* con)
{
  mysql_close(con);
  mysql_thread_end();
}

bool sev_dbms_env::exists()
{
  return m_exists;
}

int sev_dbms_env::create()
{
  struct stat sb;
  char name[512];

  str_ToLower(m_fileName, m_fileName);

  printf("sev_dbms_env::create: %s\n", m_fileName);
  /* Create the directory, read/write/access owner and group. */
  if (stat(m_fileName, &sb) != 0) {
    if (mkdir(m_fileName, S_IRWXU | S_IRWXG) != 0) {
      fprintf(stderr, "sev_dbms_env::create: mkdir: %s, %s\n", m_fileName,
          strerror(errno));
      return errno;
    }
  }

  sprintf(name, "%s/%s", m_fileName, "connection.dmsql");

  if (stat(name, &sb) != 0) {
    FILE* fp;

    fp = fopen(name, "w+b");
    if (fp == NULL) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("** Cannot open file: %s, %s\n", name, strerror(errno));
      return errno;
    }

    fprintf(fp, "HOST...: %s\n", m_host);
    fprintf(fp, "USER...: %s\n", user());
    if (!passwd() || streq(passwd(), ""))
      fprintf(fp, "PASSWD.: (null)\n");
    else
      fprintf(fp, "PASSWD.: %s\n", passwd());
    fprintf(fp, "DB_NAME: %s\n", m_dbName);
    fprintf(fp, "PORT...: %d\n", port());
    fprintf(fp, "SOCKET.: %s\n", socket());

    fclose(fp);
  }

  return 0;
}

int sev_dbms_env::open(const char* v_fileName)
{
  fileName(v_fileName);

  return open();
}

int sev_dbms_env::open(void)
{
  char var[32];
  char value[32];
  char buf[512];
  char* s;
  char* valp;
  int rc;

  str_ToLower(m_fileName, m_fileName);

  sprintf(buf, "%s/%s", m_fileName, "connection.dmsql");

  FILE* fp = fopen(buf, "r");
  if (fp == NULL) {
    // printf("In %s row %d:\n", __FILE__, __LINE__);
    // printf("** Cannot open file: %s, %s\n", buf, strerror(errno));
    return errno;
  }

  while ((s = fgets(buf, sizeof(buf) - 1, fp))) {
    if (*s == '#')
      continue;

    rc = sscanf(s, " %[A-Z_] %*[^ ] %s", var, value);
    if (rc < 1)
      continue;
    if (rc == 1)
      valp = 0;
    else
      valp = value;

    if (streq(valp, "(null)"))
      valp = 0;

    if (streq(var, "HOST")) {
      host(valp);
    } else if (streq(var, "USER")) {
      user(valp);
    } else if (streq(var, "PASSWD")) {
      passwd(valp);
    } else if (streq(var, "DB_NAME")) {
      dbName(valp);
    } else if (streq(var, "PORT")) {
      if (valp == 0)
        port(0);
      else
        port(atoi(valp));
    } else if (streq(var, "SOCKET")) {
      socket(valp);
    } else {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("Unknown connection parameter! : %s\n", var);
    }
  }

  fclose(fp);

  m_exists = true;

  return 0;
}

int sev_dbms_env::get_systemname()
{
  FILE* file;
  pwr_tFileName fname;
  char nodename[80];
  char* bus_str;
  int bus;
  char line[200];
  pwr_tStatus sts;

  if (!streq(m_systemName, ""))
    return 1;

  sev_db::get_orignode(nodename);
  if (streq(nodename, "")) {
    syi_NodeName(&sts, nodename, sizeof(nodename));
    if (EVEN(sts))
      return 0;
  }
  bus_str = getenv("PWR_BUS_ID");
  if (!bus_str)
    return 0;
  if (sscanf(bus_str, "%d", &bus) != 1)
    return 0;

  sprintf(fname, pwr_cNameBoot, load_cDirectory, cdh_Low(nodename), bus);
  dcli_translate_filename(fname, fname);
  file = fopen(fname, "r");
  if (file == 0) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("** Warning, systemname not found\n");
    return 0;
  }

  if (!dcli_read_line(line, sizeof(line), file))
    return 0;
  if (!dcli_read_line(line, sizeof(line), file))
    return 0;

  strcpy(m_systemName, line);
  return 1;
}

sev_dbms::sev_dbms(sev_dbms_env* env) : m_env(env)
{
}

sev_db* sev_dbms::open_database()
{
  pwr_tFileName envname;
  char socket[200];
  sev_dbms_env* env;
  sev_dbms* db;
  unsigned int rc;

  sprintf(envname, "$pwrp_db/%s.db", sev_dbms_env::dbName());
  dcli_translate_filename(envname, envname);

  env = new sev_dbms_env(envname);
  env->open(envname);
  if (!env->exists()) {
    cnf_get_value("mysqlSocket", socket, sizeof(socket));
    env->create(
        envname, "localhost", "pwrp", "", sev_dbms_env::dbName(), 50, socket);

    env->open(envname);

    if (!env->createDb()) {
      errh_Fatal("Failed to create to database '%s'", sev_dbms_env::dbName());
      exit(0);
    }
  } else {
    if (!env->openDb(&rc)) {
      if (rc == ER_BAD_DB_ERROR || rc == ER_NO_DB_ERROR) {
        // Database not created
        if (!env->createDb()) {
          errh_Fatal(
              "Failed to create to database '%s'", sev_dbms_env::dbName());
          exit(0);
        }
      } else {
        printf("No such database\n");
        errh_Fatal(
            "Failed to connect to database '%s'", sev_dbms_env::dbName());
        exit(0);
      }
    }
  }

  if (!env->checkAndUpdateVersion(sev_cVersion)) {
    errh_Fatal("Failed to upgrade tables to sev version %d db:'%s'",
        sev_cVersion, sev_dbms_env::dbName());
    exit(0);
  }

  db = new sev_dbms(env);

  errh_Info("Database opened '%s'", db->dbName());

  return db;
}

int sev_dbms::create_table(pwr_tStatus* sts, char* tablename, pwr_eType type,
    unsigned int size, pwr_tMask options, float deadband)
{
  char query[400];
  char timeformatstr[80];
  char jumpstr[80];
  char idtypestr[20];
  char readoptstr[80];
  char enginestr[100] = "";

  if (!streq(m_cnf.Engine, ""))
    snprintf(enginestr, sizeof(enginestr), " engine=%s", m_cnf.Engine);
  if (str_NoCaseStrcmp(m_cnf.Engine, "innodb") == 0)
    strcat(enginestr, " row_format=compressed");

  if (options & pwr_mSevOptionsMask_PosixTime) {
    if (options & pwr_mSevOptionsMask_HighTimeResolution) {
      // Posix time, high resolution
      strcpy(timeformatstr, "time int unsigned, ntime int unsigned");
      strcpy(idtypestr, "bigint");
    } else {
      // Posix time, low resolution
      strcpy(timeformatstr, "time int unsigned");
      strcpy(idtypestr, "int");
    }
  } else {
    if (options & pwr_mSevOptionsMask_HighTimeResolution) {
      // Sql time, high resolution
      strcpy(timeformatstr, "time datetime not null, ntime int unsigned");
      strcpy(idtypestr, "bigint");
    } else {
      // Sql time, low resolution
      strcpy(timeformatstr, "time datetime not null");
      strcpy(idtypestr, "int");
    }
  }

  if (options & pwr_mSevOptionsMask_ReadOptimized)
    sprintf(readoptstr, "id %s unsigned not null primary key auto_increment,",
        idtypestr);
  else
    strcpy(readoptstr, "");

  if (options & pwr_mSevOptionsMask_UseDeadBand)
    strcpy(jumpstr, ",jump tinyint unsigned");
  else
    strcpy(jumpstr, "");

  sprintf(query, "create table %s ( %s"
                 "%s, value %s %s, index (time))%s;",
      tablename, readoptstr, timeformatstr, pwrtype_to_type(type, size),
      jumpstr, enginestr);

  int rc = mysql_query(m_env->con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Create table: %s\n", mysql_error(m_env->con()));
    *sts = SEV__DBERROR;
    return 0;
  }
  return 1;
}

int sev_dbms::delete_table(pwr_tStatus* sts, char* tablename)
{
  char query[200];

  sprintf(query, "drop table %s;", tablename);

  int rc = mysql_query(m_env->con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Delete table: %s\n", mysql_error(m_env->con()));
    *sts = SEV__DBERROR;
    return 0;
  }
  return 1;
}

int sev_dbms::create_event_table(
    pwr_tStatus* sts, char* tablename, pwr_tMask options)
{
  char query[580];
  char timeformatstr[80];
  char jumpstr[80];
  char idtypestr[20];
  char readoptstr[80];
  char enginestr[100] = "";

  if (!streq(m_cnf.Engine, ""))
    snprintf(enginestr, sizeof(enginestr), " engine=%s", m_cnf.Engine);

  if (options & pwr_mSevOptionsMask_PosixTime) {
    if (options & pwr_mSevOptionsMask_HighTimeResolution) {
      // Posix time, high resolution
      strcpy(timeformatstr, "time int unsigned, ntime int unsigned");
      strcpy(idtypestr, "bigint");
    } else {
      // Posix time, low resolution
      strcpy(timeformatstr, "time int unsigned");
      strcpy(idtypestr, "int");
    }
  } else {
    if (options & pwr_mSevOptionsMask_HighTimeResolution) {
      // Sql time, high resolution
      strcpy(timeformatstr, "time datetime not null, ntime int unsigned");
      strcpy(idtypestr, "bigint");
    } else {
      // Sql time, low resolution
      strcpy(timeformatstr, "time datetime not null");
      strcpy(idtypestr, "int");
    }
  }

  if (options & pwr_mSevOptionsMask_ReadOptimized)
    sprintf(readoptstr, "id %s unsigned not null primary key auto_increment,",
        idtypestr);
  else
    strcpy(readoptstr, "");

  strcpy(jumpstr, "");

  sprintf(query,
      "create table %s ( %s"
      "%s, eventtype int, eventprio int, eventid_nix int, eventid_birthtime "
      "int, eventid_idx int,"
      "supobject_vid int unsigned, supobject_oix int unsigned, "
      "supobject_offset int unsigned,"
      "supobject_size int unsigned,"
      "eventtext varchar(80), eventname varchar(80), eventstatus int unsigned, index (time))%s;",
      tablename, readoptstr, timeformatstr, enginestr);

  int rc = mysql_query(m_env->con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Create table: %s\n", mysql_error(m_env->con()));
    *sts = SEV__DBERROR;
    return 0;
  }
  return 1;
}

int sev_dbms::delete_event_table(pwr_tStatus* sts, char* tablename)
{
  char query[200];

  sprintf(query, "drop table %s;", tablename);

  int rc = mysql_query(m_env->con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Delete table: %s\n", mysql_error(m_env->con()));
    *sts = SEV__DBERROR;
    return 0;
  }
  return 1;
}

int sev_dbms::store_item(pwr_tStatus* sts, char* tablename, pwr_tOid oid,
    char* oname, char* aname, pwr_tDeltaTime storagetime, pwr_eType vtype,
    unsigned int vsize, char* description, char* unit, pwr_tFloat32 scantime,
    pwr_tFloat32 deadband, pwr_tMask options)
{
  char query[800];
  char timestr[40];
  pwr_tTime creatime;

  time_GetTime(&creatime);
  time_AtoAscii(
      &creatime, time_eFormat_NumDateAndTime, timestr, sizeof(timestr));
  timestr[19] = 0;

  unsigned int next_id = get_nextAutoIncrement((char*)"items");
  /*
    char volName[32];
    strncpy(volName, oname, sizeof(volName));
    for ( char *s = volName; *s; s++) {
      if ( *s == ':') {
        *s = 0;
        break;
      }
    }
    sprintf(tablename, "%s_%d", volName, next_id);
  */

  sprintf(tablename, "%s_%d", oid_to_table(oid, (char*)""), next_id);

  sprintf(query,
      "insert into items "
      "(id,tablename,vid,oix,oname,aname,uptime,cretime,storagetime,vtype,"
      "vsize,description,unit,scantime,deadband,options) "
      "values (0,'%s',%d,%d,'%s','%s','%s','%s',%ld,%d,%d,'%s','%s',%f,%f,%d);",
      tablename, oid.vid, oid.oix, oname, aname, timestr, timestr,
      (long int)storagetime.tv_sec, vtype, vsize, description, unit, scantime,
      deadband, options);
  int rc = mysql_query(m_env->con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Store item: %s\n", mysql_error(m_env->con()));
    *sts = SEV__DBERROR;
    return 0;
  }

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbms::remove_item(pwr_tStatus* sts, pwr_tOid oid, char* aname)
{
  char query[800];

  sprintf(query,
      "delete from items where vid = %u and oix = %u and aname = '%s';",
      oid.vid, oid.oix, aname);
  int rc = mysql_query(m_env->con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Remove item: %s\n", mysql_error(m_env->con()));
    *sts = SEV__DBERROR;
    return 0;
  }

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbms::get_items(pwr_tStatus* sts)
{
  m_items.clear();
  char query[300];

  sprintf(query, "select "
                 "id,tablename,vid,oix,oname,aname,uptime,cretime,storagetime,"
                 "vtype,vsize,description,unit,scantime,deadband,options "
                 "from items");

  int rc = mysql_query(m_env->con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Get Items: %s\n", mysql_error(m_env->con()));
    *sts = SEV__DBERROR;
    return 0;
  }

  MYSQL_ROW row;
  MYSQL_RES* result = mysql_store_result(m_env->con());
  if (!result) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("GetValues Result Error\n");
    *sts = SEV__DBERROR;
    return 0;
  }
  int rows = mysql_num_rows(result);

  for (int i = 0; i < rows; i++) {
    sev_item item;
    sev_attr attr;
    item.attr.push_back(attr);
    row = mysql_fetch_row(result);
    if (!row)
      break;

    // printf( "%d %s %s\n", i, row[0], row[1]);

    item.id = atoi(row[0]);
    strncpy(item.tablename, row[1], sizeof(item.tablename));
    item.oid.vid = strtoul(row[2], 0, 10);
    item.oid.oix = strtoul(row[3], 0, 10);
    strncpy(item.oname, row[4], sizeof(item.oname));
    strncpy(item.attr[0].aname, row[5], sizeof(item.attr[0].aname));
    timestr_to_time(row[6], &item.modtime);
    timestr_to_time(row[7], &item.creatime);
    item.storagetime.tv_sec = strtoul(row[8], 0, 10);
    item.storagetime.tv_nsec = 0;
    item.attr[0].type = (pwr_eType)strtoul(row[9], 0, 10);
    item.attr[0].size = strtoul(row[10], 0, 10);
    strncpy(item.description, row[11], sizeof(item.description));
    strncpy(item.attr[0].unit, row[12], sizeof(item.attr[0].unit));
    item.scantime = atof(row[13]);
    item.deadband = atof(row[14]);
    item.options = strtoul(row[15], 0, 10);
    item.attrnum = 1;

    if (m_cnf.LinearRegrAll && item.options & pwr_mSevOptionsMask_UseDeadBand)
      item.options |= pwr_mSevOptionsMask_DeadBandLinearRegr;
    if (m_cnf.MeanValueAll)
      item.options |= pwr_mSevOptionsMask_MeanValue1;

    m_items.push_back(item);

    if (item.options & pwr_mSevOptionsMask_DeadBandLinearRegr)
      add_cache(m_items.size() - 1);
  }
  mysql_free_result(result);

  // for ( int i = 0; i < (int)m_items.size(); i++)
  //  printf( "Item: %d %s\n", m_items[i].id, m_items[i].tablename);

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbms::store_value(pwr_tStatus* sts, void* thread, int item_idx,
    int attr_idx, pwr_tTime time, void* buf, unsigned int size)
{
  MYSQL* con;

  if (thread)
    con = (MYSQL*)thread;
  else
    con = m_env->con();

  tree_update_value(item_idx, attr_idx, time, buf);

  if (m_items[item_idx].options & pwr_mSevOptionsMask_DeadBandLinearRegr) {
    void* value;
    double dval;
    pwr_tBoolean bval;
    switch (m_items[item_idx].attr[0].type) {
    case pwr_eType_Float32:
      dval = *(pwr_tFloat32*)buf;
      value = &dval;
      break;
    case pwr_eType_Float64:
      dval = *(pwr_tFloat64*)buf;
      value = &dval;
      break;
    case pwr_eType_Int32:
      dval = *(pwr_tInt32*)buf;
      value = &dval;
      break;
    case pwr_eType_Boolean:
      bval = *(pwr_tBoolean*)buf;
      value = &bval;
      break;
    default:
      return 0;
    }
    if (m_items[item_idx].cache) {
      m_items[item_idx].cache->add(value, &time, thread);
      *sts = m_items[item_idx].cache->evaluate(m_cnf.LinearRegrMaxTime, thread);
    }
    return 1;
  } else
    return write_value(sts, item_idx, attr_idx, time, buf, size, thread);
}

int sev_dbms::write_value(pwr_tStatus* sts, int item_idx, int attr_idx,
    pwr_tTime time, void* buf, unsigned int size, void* thread)
{
  if (size != m_items[item_idx].value_size) {
    // Something is seriously wrong
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s expected size:%d recevied size:%d ERROR!!\n", __FUNCTION__,
        m_items[item_idx].value_size, size);
    *sts = SEV__DBERROR;
    return 0;
  }

  if (m_items[item_idx].attrnum > 1) {
    return store_objectvalue(sts, thread, item_idx, attr_idx, time, buf,
        m_items[item_idx].old_value, size);
  }
  char query[1150];
  char bufstr[512];
  char timstr[40];
  int update_time_only = 0;
  int set_jump = 0;
  MYSQL* con;

  if (thread)
    con = (MYSQL*)thread;
  else
    con = m_env->con();

  if (!m_items[item_idx].first_storage) {
    if (m_items[item_idx].options & pwr_mSevOptionsMask_UseDeadBand
        && !(m_items[item_idx].options
               & pwr_mSevOptionsMask_DeadBandLinearRegr)) {
      if (m_items[item_idx].deadband_active) {
        // Compare current value to old value
        switch (m_items[item_idx].attr[attr_idx].type) {
        case pwr_eType_Float32:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(buf, m_items[item_idx].old_value,
                         sizeof(pwr_tFloat32)))
              || (ABS(*(pwr_tFloat32*)buf
                      - *(pwr_tFloat32*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tFloat32*)m_items[item_idx].old_value = *(pwr_tFloat32*)buf;
          }
          break;
        case pwr_eType_Float64:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(buf, m_items[item_idx].old_value,
                         sizeof(pwr_tFloat64)))
              || (ABS(*(pwr_tFloat64*)buf
                      - *(pwr_tFloat64*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tFloat64*)m_items[item_idx].old_value = *(pwr_tFloat64*)buf;
          }
          break;
        case pwr_eType_Int64:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tInt64)))
              || (ABS(*(pwr_tInt64*)buf
                      - *(pwr_tInt64*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tInt64*)m_items[item_idx].old_value = *(pwr_tInt64*)buf;
          }
          break;
        case pwr_eType_Int32:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tInt32)))
              || (ABS(*(pwr_tInt32*)buf
                      - *(pwr_tInt32*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tInt32*)m_items[item_idx].old_value = *(pwr_tInt32*)buf;
          }
          break;
        case pwr_eType_Int16:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tInt16)))
              || (ABS(*(pwr_tInt16*)buf
                      - *(pwr_tInt16*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tInt16*)m_items[item_idx].old_value = *(pwr_tInt16*)buf;
          }
          break;
        case pwr_eType_Int8:
        case pwr_eType_Char:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tInt8)))
              || (ABS(*(pwr_tInt8*)buf
                      - *(pwr_tInt8*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tInt8*)m_items[item_idx].old_value = *(pwr_tInt8*)buf;
          }
          break;
        case pwr_eType_UInt64:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tUInt64)))
              || (ABS(((pwr_tInt64)(*(pwr_tUInt64*)buf
                      - *(pwr_tUInt64*)m_items[item_idx].old_value)))
                     < m_items[item_idx].deadband)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tUInt64*)m_items[item_idx].old_value = *(pwr_tUInt64*)buf;
          }
          break;
        case pwr_eType_UInt32:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tUInt32)))
              || (ABS(((pwr_tInt32)(*(pwr_tUInt32*)buf
                      - *(pwr_tUInt32*)m_items[item_idx].old_value)))
                     < m_items[item_idx].deadband)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tUInt32*)m_items[item_idx].old_value = *(pwr_tUInt32*)buf;
          }
          break;
        case pwr_eType_Boolean:
	  if (*(pwr_tBoolean*)buf == *(pwr_tBoolean*)m_items[item_idx].old_value) {
            return 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tBoolean*)m_items[item_idx].old_value = *(pwr_tBoolean*)buf;
          }
          break;
        case pwr_eType_UInt16:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tUInt16)))
              || (ABS(((pwr_tInt16)(*(pwr_tUInt16*)buf
                      - *(pwr_tUInt16*)m_items[item_idx].old_value)))
                     < m_items[item_idx].deadband)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tUInt16*)m_items[item_idx].old_value = *(pwr_tUInt16*)buf;
          }
          break;
        case pwr_eType_UInt8:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tUInt8)))
              || (ABS(((pwr_tInt8)(*(pwr_tUInt8*)buf
                      - *(pwr_tUInt8*)m_items[item_idx].old_value)))
                     < m_items[item_idx].deadband)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            *(pwr_tUInt8*)m_items[item_idx].old_value = *(pwr_tUInt8*)buf;
          }
          break;
        case pwr_eType_String:
          if (!strncmp((char*)buf, (char*)m_items[item_idx].old_value,
                  m_items[item_idx].value_size)) {
            update_time_only = 1;
          } else {
            m_items[item_idx].deadband_active = 0;
            strncpy((char*)m_items[item_idx].old_value, (char*)buf,
                m_items[item_idx].value_size);
          }
          break;
        default:;
        }
      } else {
        // Compare current value to old value
        switch (m_items[item_idx].attr[attr_idx].type) {
        case pwr_eType_Float32:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(buf, m_items[item_idx].old_value,
                         sizeof(pwr_tFloat32)))
              || (ABS(*(pwr_tFloat32*)buf
                      - *(pwr_tFloat32*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          *(pwr_tFloat32*)m_items[item_idx].old_value = *(pwr_tFloat32*)buf;
          break;
        case pwr_eType_Float64:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(buf, m_items[item_idx].old_value,
                         sizeof(pwr_tFloat64)))
              || (ABS(*(pwr_tFloat64*)buf
                      - *(pwr_tFloat64*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          *(pwr_tFloat64*)m_items[item_idx].old_value = *(pwr_tFloat64*)buf;
          break;
        case pwr_eType_Int64:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tInt64)))
              || (ABS(*(pwr_tInt64*)buf
                      - *(pwr_tInt64*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          *(pwr_tInt64*)m_items[item_idx].old_value = *(pwr_tInt64*)buf;
          break;
        case pwr_eType_Int32:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tInt32)))
              || (ABS(*(pwr_tInt32*)buf
                      - *(pwr_tInt32*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          *(pwr_tInt32*)m_items[item_idx].old_value = *(pwr_tInt32*)buf;
          break;
        case pwr_eType_Int16:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tInt16)))
              || (ABS(*(pwr_tInt16*)buf
                      - *(pwr_tInt16*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          *(pwr_tInt16*)m_items[item_idx].old_value = *(pwr_tInt16*)buf;
          break;
        case pwr_eType_Int8:
        case pwr_eType_Char:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tInt8)))
              || (ABS(*(pwr_tInt8*)buf
                      - *(pwr_tInt8*)m_items[item_idx].old_value)
                     < m_items[item_idx].deadband)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          *(pwr_tInt8*)m_items[item_idx].old_value = *(pwr_tInt8*)buf;
          break;
        case pwr_eType_UInt64:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tUInt64)))
              || (ABS(((pwr_tInt64)(*(pwr_tUInt64*)buf
                      - *(pwr_tUInt64*)m_items[item_idx].old_value)))
                     < m_items[item_idx].deadband)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          *(pwr_tUInt64*)m_items[item_idx].old_value = *(pwr_tUInt64*)buf;
          break;
        case pwr_eType_Boolean:
          if (*(pwr_tBoolean*)buf != *(pwr_tBoolean*)m_items[item_idx].old_value) {
            m_items[item_idx].deadband_active = 1;
	    *(pwr_tBoolean*)m_items[item_idx].old_value = *(pwr_tBoolean*)buf;
            set_jump = 1;
          }
	  else {
	    return 1;
	  }
          break;
        case pwr_eType_UInt32:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tUInt32)))
              || (ABS(((pwr_tInt32)(*(pwr_tUInt32*)buf
                      - *(pwr_tUInt32*)m_items[item_idx].old_value)))
                     < m_items[item_idx].deadband)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          *(pwr_tUInt32*)m_items[item_idx].old_value = *(pwr_tUInt32*)buf;
          break;
        case pwr_eType_UInt16:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tUInt16)))
              || (ABS(((pwr_tInt16)(*(pwr_tUInt16*)buf
                      - *(pwr_tUInt16*)m_items[item_idx].old_value)))
                     < m_items[item_idx].deadband)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          *(pwr_tUInt16*)m_items[item_idx].old_value = *(pwr_tUInt16*)buf;
          break;
        case pwr_eType_UInt8:
          if ((feqf(m_items[item_idx].deadband, 0.0f)
                  && !memcmp(
                         buf, m_items[item_idx].old_value, sizeof(pwr_tUInt8)))
              || (ABS(((pwr_tInt8)(*(pwr_tUInt8*)buf
                      - *(pwr_tUInt8*)m_items[item_idx].old_value)))
                     < m_items[item_idx].deadband)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          *(pwr_tUInt8*)m_items[item_idx].old_value = *(pwr_tUInt8*)buf;
          break;
        case pwr_eType_String:
          if (!strncmp((char*)buf, (char*)m_items[item_idx].old_value,
                  m_items[item_idx].value_size)) {
            m_items[item_idx].deadband_active = 1;
            set_jump = 1;
          }
          strncpy((char*)m_items[item_idx].old_value, (char*)buf,
              m_items[item_idx].value_size);
          break;
        default:;
        }
      }
    }
    if (set_jump
        && (m_items[item_idx].options & pwr_mSevOptionsMask_UseDeadBand)) {
      sprintf(query, "update %s set jump = 1 where id = %d",
          m_items[item_idx].tablename, m_items[item_idx].last_id);
      int rc = mysql_query(con, query);
      if (rc) {
        printf("In %s row %d:\n", __FILE__, __LINE__);
        printf("Update jump: %s\n", mysql_error(m_env->con()));
      }
    }
  } else {
    m_items[item_idx].first_storage = 0;
    memcpy(m_items[item_idx].old_value, buf, size);
  }

  *sts = time_AtoAscii(
      &time, time_eFormat_NumDateAndTime, timstr, sizeof(timstr));
  if (EVEN(*sts))
    return 0;
  timstr[19] = 0;

  switch (m_items[item_idx].attr[attr_idx].type) {
  case pwr_eType_Time:
    *sts = time_AtoAscii(
        (pwr_tTime*)buf, time_eFormat_NumDateAndTime, bufstr, sizeof(bufstr));
    if (EVEN(*sts))
      return 0;
    break;
  default:
    *sts = cdh_AttrValueToString(
        m_items[item_idx].attr[attr_idx].type, buf, bufstr, sizeof(bufstr));
    if (EVEN(*sts))
      return 0;
  }

  char colname[255];
  strcpy(colname, "value");
  if (!update_time_only) {
    if (m_items[item_idx].options & pwr_mSevOptionsMask_PosixTime) {
      if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
        // Posix time, high resolution
        switch (m_items[item_idx].attr[attr_idx].type) {
        case pwr_eType_String:
        case pwr_eType_Time:
          sprintf(query,
              "insert into %s (time, ntime, %s) values (%ld,%ld,'%s')",
              m_items[item_idx].tablename, colname, (long int)time.tv_sec,
              (long int)time.tv_nsec, bufstr);
          break;
        default:
          if (m_items[item_idx].options & pwr_mSevOptionsMask_UseDeadBand)
            sprintf(query,
                "insert into %s (time, ntime, %s, jump) values (%ld,%ld,%s,%d)",
                m_items[item_idx].tablename, colname, (long int)time.tv_sec,
                (long int)time.tv_nsec, bufstr, set_jump);
          else
            sprintf(query,
                "insert into %s (time, ntime, %s) values (%ld,%ld,%s)",
                m_items[item_idx].tablename, colname, (long int)time.tv_sec,
                (long int)time.tv_nsec, bufstr);
        }
      } else {
        // Posix time, low resolution
        switch (m_items[item_idx].attr[attr_idx].type) {
        case pwr_eType_String:
        case pwr_eType_Time:
          sprintf(query, "insert into %s (time, %s) values (%ld,'%s')",
              m_items[item_idx].tablename, colname, (long int)time.tv_sec,
              bufstr);
          break;
        default:
          if (m_items[item_idx].options & pwr_mSevOptionsMask_UseDeadBand)
            sprintf(query, "insert into %s (time, %s, jump) values (%ld,%s,%d)",
                m_items[item_idx].tablename, colname, (long int)time.tv_sec,
                bufstr, set_jump);
          else
            sprintf(query, "insert into %s (time, %s) values (%ld,%s)",
                m_items[item_idx].tablename, colname, (long int)time.tv_sec,
                bufstr);
        }
      }
    } else {
      if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
        // Sql time, high resolution
        switch (m_items[item_idx].attr[attr_idx].type) {
        case pwr_eType_String:
        case pwr_eType_Time:
          sprintf(query,
              "insert into %s (time, ntime, %s) values ('%s',%ld,'%s')",
              m_items[item_idx].tablename, colname, timstr,
              (long int)time.tv_nsec, bufstr);
          break;
        default:
          if (m_items[item_idx].options & pwr_mSevOptionsMask_UseDeadBand)
            sprintf(query, "insert into %s (time, ntime, %s, jump) values "
                           "('%s',%ld,%s,%d)",
                m_items[item_idx].tablename, colname, timstr,
                (long int)time.tv_nsec, bufstr, set_jump);
          else
            sprintf(query,
                "insert into %s (time, ntime, %s) values ('%s',%ld,%s)",
                m_items[item_idx].tablename, colname, timstr,
                (long int)time.tv_nsec, bufstr);
        }
      } else {
        // Sql time, low resolution
        switch (m_items[item_idx].attr[attr_idx].type) {
        case pwr_eType_String:
        case pwr_eType_Time:
          sprintf(query, "insert into %s (time, %s) values ('%s','%s')",
              m_items[item_idx].tablename, colname, timstr, bufstr);
          break;
        default:
          if (m_items[item_idx].options & pwr_mSevOptionsMask_UseDeadBand)
            sprintf(query,
                "insert into %s (time, %s, jump) values ('%s',%s,%d)",
                m_items[item_idx].tablename, colname, timstr, bufstr, set_jump);
          else
            sprintf(query, "insert into %s (time, %s) values ('%s',%s)",
                m_items[item_idx].tablename, colname, timstr, bufstr);
        }
      }
    }
    int rc = mysql_query(con, query);
    if (rc) {
      // printf( "Store value: %s \"%s\"\n", mysql_error(m_env->con()), query);
      *sts = SEV__DBERROR;
      m_items[item_idx].status = *sts;
      if (m_items[item_idx].status != m_items[item_idx].logged_status) {
        m_items[item_idx].logged_status = m_items[item_idx].status;
        errh_Error("Database store error: %s, table: %s object: %s",
            mysql_error(m_env->con()), m_items[item_idx].tablename,
            m_items[item_idx].oname);
      }
      return 0;
    }
    if (m_items[item_idx].options & pwr_mSevOptionsMask_ReadOptimized)
      m_items[item_idx].last_id = mysql_insert_id(m_env->con());
  } else {
    if (m_items[item_idx].options & pwr_mSevOptionsMask_PosixTime) {
      if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
        // Posix time, high resolution
        sprintf(query, "update %s set time = %ld, ntime = %ld where id = %d",
            m_items[item_idx].tablename, (long int)time.tv_sec,
            (long int)time.tv_nsec, m_items[item_idx].last_id);
      } else {
        // Posix time, low resolution
        sprintf(query, "update %s set time = %ld where id = %d",
            m_items[item_idx].tablename, (long int)time.tv_sec,
            m_items[item_idx].last_id);
      }
    } else {
      if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
        // Sql time, high resolution
        sprintf(query, "update %s set time = '%s', ntime = %ld where id = %d",
            m_items[item_idx].tablename, timstr, (long int)time.tv_nsec,
            m_items[item_idx].last_id);
      } else {
        // Sql time, low resolution
        sprintf(query, "update %s set time = '%s' where id = %d",
            m_items[item_idx].tablename, timstr, m_items[item_idx].last_id);
      }
    }

    int rc = mysql_query(con, query);
    if (rc) {
      // printf( "Update value: %s\n", mysql_error(m_env->con()));
      *sts = SEV__DBERROR;
      m_items[item_idx].status = *sts;
      if (m_items[item_idx].status != m_items[item_idx].logged_status) {
        m_items[item_idx].logged_status = m_items[item_idx].status;
        errh_Error("Database update error: %s, table: %s object: %s",
            mysql_error(m_env->con()), m_items[item_idx].tablename,
            m_items[item_idx].oname);
      }
      return 0;
    }
  }

  *sts = SEV__SUCCESS;

  if (m_items[item_idx].attr[0].ip)
    m_items[item_idx].attr[0].ip->WriteCount++;
  m_items[item_idx].status = *sts;
  m_items[item_idx].logged_status = 1;
  return 1;
}

int sev_dbms::get_id_range(pwr_tStatus* sts, void* thread, sev_item* item,
    pwr_tMask options, unsigned int* first, unsigned int* last)
{
  int rows;
  char query[300];
  MYSQL* con;

  if (thread)
    con = (MYSQL*)thread;
  else
    con = m_env->con();

  if (first) {
    if (options & pwr_mSevOptionsMask_HighTimeResolution)
      // sprintf( query, "select id from %s order by time,ntime asc limit 1;",
      // item->tablename);
      sprintf(query, "select id from %s order by time asc limit 1;",
          item->tablename);
    else
      sprintf(query, "select id from %s order by time asc limit 1;",
          item->tablename);

    int rc = mysql_query(con, query);
    if (rc) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("Get time range query error\n");
      *sts = SEV__DBERROR;
      return 0;
    }

    MYSQL_ROW row;
    MYSQL_RES* result = mysql_store_result(con);

    row = mysql_fetch_row(result);
    if (!row) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("GetValues Status Result Error\n");
      *sts = SEV__DBERROR;
      return 0;
    }

    rows = mysql_num_rows(result);
    if (rows != 1) {
      *sts = SEV__DBERROR;
      *first = 0;
      return 0;
    }

    *first = strtoul(row[0], 0, 10);
    mysql_free_result(result);
  }
  if (last) {
    if (options & pwr_mSevOptionsMask_HighTimeResolution)
      // sprintf( query, "select id from %s order by time,ntime desc limit 1;",
      // item->tablename);
      sprintf(query, "select id from %s order by time desc limit 1;",
          item->tablename);
    else
      sprintf(query, "select id from %s order by time desc limit 1;",
          item->tablename);

    int rc = mysql_query(con, query);
    if (rc) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("Get time range query error\n");
      *sts = SEV__DBERROR;
      return 0;
    }

    MYSQL_ROW row;
    MYSQL_RES* result = mysql_store_result(con);

    row = mysql_fetch_row(result);
    if (!row) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("GetValues Status Result Error\n");
      *sts = SEV__DBERROR;
      return 0;
    }

    rows = mysql_num_rows(result);
    if (rows != 1) {
      *sts = SEV__DBERROR;
      *last = 0;
      return 0;
    }

    *last = strtoul(row[0], 0, 10);
    mysql_free_result(result);
  }
  return 1;
}

int sev_dbms::get_time_range(pwr_tStatus* sts, sev_item* item,
    pwr_tMask options, pwr_tTime* first, pwr_tTime* last)
{
  int rows = 0;
  char query[320];

  if (first) {
    if (options & pwr_mSevOptionsMask_HighTimeResolution)
      sprintf(query,
          "select time,ntime from %s order by time,ntime asc limit 1;",
          item->tablename);
    else
      sprintf(query, "select time from %s order by time asc limit 1;",
          item->tablename);

    int rc = mysql_query(m_env->con(), query);
    if (rc) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("Get time range query error\n");
      *sts = SEV__DBERROR;
      return 0;
    }

    MYSQL_ROW row;
    MYSQL_RES* result = mysql_store_result(m_env->con());

    row = mysql_fetch_row(result);
    if (!row) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("GetValues Status Result Error\n");
      *sts = SEV__DBERROR;
      return 0;
    }

    rows = mysql_num_rows(result);

    if (options & pwr_mSevOptionsMask_HighTimeResolution) {
      if (rows != 2) {
        *sts = SEV__DBERROR;
        return 0;
      }
    } else {
      if (rows != 1) {
        *sts = SEV__DBERROR;
        return 0;
      }
    }
    if (options & pwr_mSevOptionsMask_PosixTime) {
      if (options & pwr_mSevOptionsMask_HighTimeResolution) {
        // Posix time, high resolution
        first->tv_sec = strtoul(row[0], 0, 10);
        first->tv_nsec = strtoul(row[1], 0, 10);
      } else
        // Posix time, low resolution
        first->tv_sec = strtoul(row[0], 0, 10);
    } else {
      if (options & pwr_mSevOptionsMask_HighTimeResolution) {
        // Sql time, high resolution
        timestr_to_time(row[0], first);
        first->tv_nsec = strtoul(row[1], 0, 10);
      } else
        // Sql time, low resolution
        timestr_to_time(row[0], first);
    }
    mysql_free_result(result);
  }

  if (last) {
    if (options & pwr_mSevOptionsMask_HighTimeResolution)
      sprintf(query,
          "select time,ntime from %s order by time,ntime desc limit 1;",
          item->tablename);
    else
      sprintf(query, "select time from %s order by time desc limit 1;",
          item->tablename);

    int rc = mysql_query(m_env->con(), query);
    if (rc) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("Get time range query error\n");
      *sts = SEV__DBERROR;
      return 0;
    }

    MYSQL_ROW row;
    MYSQL_RES* result = mysql_store_result(m_env->con());

    row = mysql_fetch_row(result);
    if (!row) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("GetValues Status Result Error\n");
      *sts = SEV__DBERROR;
      return 0;
    }

    if (options & pwr_mSevOptionsMask_HighTimeResolution) {
      if (rows != 2) {
        *sts = SEV__DBERROR;
        return 0;
      }
    } else {
      if (rows != 1) {
        *sts = SEV__DBERROR;
        return 0;
      }
    }
    if (options & pwr_mSevOptionsMask_PosixTime) {
      if (options & pwr_mSevOptionsMask_HighTimeResolution) {
        // Posix time, high resolution
        last->tv_sec = strtoul(row[0], 0, 10);
        last->tv_nsec = strtoul(row[1], 0, 10);
      } else
        // Posix time, low resolution
        last->tv_sec = strtoul(row[0], 0, 10);
    } else {
      if (options & pwr_mSevOptionsMask_HighTimeResolution) {
        // Sql time, high resolution
        timestr_to_time(row[0], last);
        last->tv_nsec = strtoul(row[1], 0, 10);
      } else
        // Sql time, low resolution
        timestr_to_time(row[0], last);
    }
    mysql_free_result(result);
  }
  return 1;
}

int sev_dbms::get_values(pwr_tStatus* sts, void* thread, pwr_tOid oid,
    pwr_tMask options, float deadband, char* aname, pwr_eType type,
    unsigned int size, pwr_tFloat32 scantime, pwr_tTime* creatime,
    pwr_tTime* starttime, pwr_tTime* endtime, int maxsize, pwr_tTime** tbuf,
    void** vbuf, unsigned int* bsize)
{
  sev_item item;
  get_item(sts, thread, &item, oid, aname);
  if (EVEN(*sts)) {
    return 0;
  }

  char query[700];
  char starttimstr[40];
  char endtimstr[40];
  int total_rows;
  int div;
  pwr_tTime stime, etime;
  char column_part[80];
  char orderby_part[80];
  char jumpstr[40];
  char where_part[200];
  int rows = 0;
  MYSQL* con;
  char startval[8];
  char endval[8];
  char *startvalue = 0;
  char *endvalue = 0;

  if (thread)
    con = (MYSQL*)thread;
  else
    con = m_env->con();

  if (starttime && starttime->tv_sec == 0 && starttime->tv_nsec == 0)
    starttime = 0;
  else
    stime = *starttime;

  if (endtime && endtime->tv_sec == 0 && endtime->tv_nsec == 0)
    endtime = 0;
  else
    etime = *endtime;

  // Get number of rows
  sprintf(query, "show table status where name = '%s';", item.tablename);

  int rc = mysql_query(con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("GetValues Query Error\n");
    *sts = SEV__DBERROR;
    return 0;
  }

  MYSQL_ROW row;
  MYSQL_RES* result = mysql_store_result(con);

  if (!result) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("GetValues Status Result Error\n");
    *sts = SEV__DBERROR;
    return 0;
  }

  row = mysql_fetch_row(result);
  if (!row) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("GetValues Status Result Error\n");
    *sts = SEV__DBERROR;
    return 0;
  }
  if (item.options & pwr_mSevOptionsMask_Event) {
    total_rows = atoi(row[4]);
    div = total_rows / maxsize + 1;
  } else if (item.options & pwr_mSevOptionsMask_UseDeadBand
      && item.options & pwr_mSevOptionsMask_DeadBandLinearRegr) {
    unsigned int startid;
    unsigned int endid;

    if (starttime) {
      if (type == pwr_eType_Boolean) {
	// Get id for starttime
	*sts = get_closest_time(
            thread, item.tablename, item.options, starttime, 1, &startid);
	if (*sts == SEV__NOROWS)
	  get_id_range(sts, thread, &item, item.options, &startid, 0);
	get_id_value(thread, item.tablename, startid, type, size,
		     startval);
	startvalue = startval;

      } else {
	// Get id for starttime
	*sts = get_closest_time(
            thread, item.tablename, item.options, starttime, 1, &startid);
	if (*sts == SEV__NOROWS)
	  get_id_range(sts, thread, &item, item.options, &startid, 0);
      }
    } else {
      get_id_range(sts, thread, &item, item.options, &startid, 0);
      // startid = 0;
    }
    if (endtime) {
      if (type == pwr_eType_Boolean) {
	// Get id for starttime
	*sts = get_closest_time(
            thread, item.tablename, item.options, endtime, 1, &endid);
	if (*sts == SEV__NOROWS)
	  get_id_range(sts, thread, &item, item.options, 0, &endid);
	if (endid == 0)
	  endid = strtoul(row[4], 0, 10);
	get_id_value(thread, item.tablename, endid, type, size, endval);
	endvalue = endval;
      } else {
	// Get id for starttime
	*sts = get_closest_time(
            thread, item.tablename, item.options, endtime, 0, &endid);
	if (*sts == SEV__NOROWS)
	  get_id_range(sts, thread, &item, item.options, 0, &endid);
	if (endid == 0)
	  endid = strtoul(row[4], 0, 10);
      }
    } else
      endid = strtoul(row[4], 0, 10);

    printf("startid %d, endid %d\n", startid, endid);
    div = (endid - startid + 1) / maxsize + 1;
  } else {
    if (starttime && endtime) {
      if (options & pwr_mSevOptionsMask_ReadOptimized) {
        unsigned int startid, endid;

        *sts = get_closest_time(
            thread, item.tablename, item.options, endtime, 1, &endid);
        if (*sts == SEV__NOROWS)
          get_id_range(sts, thread, &item, item.options, 0, &endid);

        *sts = get_closest_time(
            thread, item.tablename, item.options, starttime, 0, &startid);
        if (*sts == SEV__NOROWS)
          get_id_range(sts, thread, &item, item.options, &startid, 0);

        total_rows = endid - startid;
      } else {
        pwr_tDeltaTime dt;

        get_time_range(sts, &item, item.options, &stime, &etime);
        if (ODD(*sts)) {
          if (time_Acomp(starttime, &stime) == 1)
            stime = *starttime;
          else
            *starttime = stime;
          if (time_Acomp(endtime, &etime) == -1)
            etime = *endtime;
          else
            *endtime = etime;
        } else {
          pwr_tTime update_time;

          if (row[12])
            timestr_to_time(row[12], &update_time);

          if (time_Acomp(creatime, &stime) == 1)
            stime = *creatime;

          if (row[12] && time_Acomp(&etime, &update_time) == 1)
            etime = update_time;
        }
        time_Adiff(&dt, &etime, &stime);
        total_rows = int(time_DToFloat(0, &dt) / scantime);
      }

      div = total_rows / maxsize + 1;
    } else if (starttime) {
      if (options & pwr_mSevOptionsMask_ReadOptimized) {
        unsigned int startid, endid;

        *sts = get_closest_time(
            thread, item.tablename, item.options, starttime, 0, &startid);
        if (*sts == SEV__NOROWS)
          get_id_range(sts, thread, &item, item.options, &startid, 0);

        get_id_range(sts, thread, &item, item.options, 0, &endid);
        total_rows = endid - startid;
      } else {
        pwr_tTime update_time;
        pwr_tDeltaTime dt;

        get_time_range(sts, &item, item.options, &stime, &etime);
        if (ODD(*sts)) {
          if (time_Acomp(starttime, &stime) == 1)
            stime = *starttime;
          else
            *starttime = stime;
          time_Adiff(&dt, &etime, &stime);
        } else {
          if (row[12])
            timestr_to_time(row[12], &update_time);
          else
            time_GetTime(&update_time);

          if (time_Acomp(&update_time, starttime) != 1) {
            mysql_free_result(result);
            *sts = SEV__NODATATIME;
            return 0;
          }
          time_Adiff(&dt, &update_time, starttime);
        }
        total_rows = int(time_DToFloat(0, &dt) / scantime);
      }
    } else if (endtime) {
      if (options & pwr_mSevOptionsMask_ReadOptimized) {
        unsigned int startid, endid;

        *sts = get_closest_time(
            thread, item.tablename, item.options, endtime, 1, &endid);
        if (*sts == SEV__NOROWS)
          get_id_range(sts, thread, &item, item.options, 0, &endid);

        get_id_range(sts, thread, &item, item.options, &startid, 0);

        total_rows = endid - startid;
      } else {
        pwr_tTime create_time;
        pwr_tDeltaTime dt;

        get_time_range(sts, &item, item.options, &stime, &etime);
        if (ODD(*sts)) {
          if (time_Acomp(endtime, &etime) == -1)
            etime = *endtime;
          else
            *endtime = etime;

          time_Adiff(&dt, &etime, &stime);
        } else {
          timestr_to_time(row[11], &create_time);

          if (time_Acomp(endtime, &create_time) != 1) {
            mysql_free_result(result);
            *sts = SEV__NODATATIME;
            return 0;
          }
          time_Adiff(&dt, endtime, &create_time);
        }
        total_rows = int(time_DToFloat(0, &dt) / scantime);
      }
    } else {
      total_rows = atoi(row[4]);
    }
    div = total_rows / maxsize + 1;
  }
  mysql_free_result(result);

  if (starttime) {
    *sts = time_AtoAscii(
        &stime, time_eFormat_NumDateAndTime, starttimstr, sizeof(starttimstr));
    if (EVEN(*sts))
      return 0;
    starttimstr[19] = 0;
  }
  if (endtime) {
    *sts = time_AtoAscii(
        &etime, time_eFormat_NumDateAndTime, endtimstr, sizeof(endtimstr));
    if (EVEN(*sts))
      return 0;
    endtimstr[19] = 0;
  }

  // Column part
  if (options & pwr_mSevOptionsMask_HighTimeResolution)
    strcpy(column_part, "time,ntime,value");
  else
    strcpy(column_part, "time,value");

  if (options & pwr_mSevOptionsMask_UseDeadBand)
    strcpy(jumpstr, ""); // "or jump = 1" removed
  else
    strcpy(jumpstr, "");

  // 'order by' part
  if (options & pwr_mSevOptionsMask_ReadOptimized)
    strcpy(orderby_part, "id");
  else {
    if (options & pwr_mSevOptionsMask_HighTimeResolution)
      strcpy(orderby_part, "time,ntime");
    else
      strcpy(orderby_part, "time");
  }

  for (int k = 0; k < 2; k++) {
    // 'where' part
    if (options & pwr_mSevOptionsMask_ReadOptimized) {
      if (starttime && endtime) {
        if (div == 1) {
          if (options & pwr_mSevOptionsMask_PosixTime)
            sprintf(where_part, "where time >= %ld and time <= %ld",
                (long int)starttime->tv_sec, (long int)endtime->tv_sec);
          else
            sprintf(where_part, "where time >= '%s' and time <= '%s'",
                starttimstr, endtimstr);
        } else {
          if (options & pwr_mSevOptionsMask_PosixTime)
            sprintf(where_part,
                "where (id %% %d = 0 %s) and time >= %ld and time <= %ld", div,
                jumpstr, (long int)starttime->tv_sec,
                (long int)endtime->tv_sec);
          else
            sprintf(where_part,
                "where (id %% %d = 0 %s) and time >= '%s' and time <= '%s'",
                div, jumpstr, starttimstr, endtimstr);
        }
      } else if (starttime) {
        if (div == 1) {
          if (options & pwr_mSevOptionsMask_PosixTime)
            sprintf(
                where_part, "where time >= %ld", (long int)starttime->tv_sec);
          else
            sprintf(where_part, "where time >= '%s'", starttimstr);
        } else {
          if (options & pwr_mSevOptionsMask_PosixTime)
            sprintf(where_part, "where (id %% %d = 0 %s) and time >= %ld", div,
                jumpstr, (long int)starttime->tv_sec);
          else
            sprintf(where_part, "where (id %% %d = 0 %s) and time >= '%s'", div,
                jumpstr, starttimstr);
        }
      } else if (endtime) {
        if (div == 1) {
          if (options & pwr_mSevOptionsMask_PosixTime)
            sprintf(where_part, "where time <= %ld", (long int)endtime->tv_sec);
          else
            sprintf(where_part, "where time <= '%s'", endtimstr);
        } else {
          if (options & pwr_mSevOptionsMask_PosixTime)
            sprintf(where_part, "where (id %% %d = 0 %s) and time <= %ld", div,
                jumpstr, (long int)endtime->tv_sec);
          else
            sprintf(where_part, "where (id %% %d = 0 %s) and time <= '%s'", div,
                jumpstr, endtimstr);
        }
      } else {
        if (div == 1)
          strcpy(where_part, "");
        else
          sprintf(where_part, "where id %% %d = 0 %s", div, jumpstr);
      }
    } else {
      // Not read optimized
      if (starttime && endtime) {
        if (options & pwr_mSevOptionsMask_PosixTime)
          sprintf(where_part, "where time >= %ld and time <= %ld",
              (long int)starttime->tv_sec, (long int)endtime->tv_sec);
        else
          sprintf(where_part, "where time >= '%s' and time <= '%s'",
              starttimstr, endtimstr);
      } else if (starttime) {
        if (options & pwr_mSevOptionsMask_PosixTime)
          sprintf(where_part, "where time >= %ld", (long int)starttime->tv_sec);
        else
          sprintf(where_part, "where time >= '%s'", starttimstr);
      } else if (endtime) {
        if (options & pwr_mSevOptionsMask_PosixTime)
          sprintf(where_part, "where time <= %ld", (long int)endtime->tv_sec);
        else
          sprintf(where_part, "where time <= '%s'", endtimstr);
      } else
        strcpy(where_part, "");
    }

    if (options & pwr_mSevOptionsMask_ReadOptimized)
      sprintf(query, "select %s from %s %s order by %s limit %d", column_part,
          item.tablename, where_part, orderby_part, maxsize * 2);
    else {
      rc = mysql_query(con, "set @x:=0;");
      sprintf(query, "select * from (select (@x:=@x+1) as x,%s from %s %s "
                     "order by %s) t where x%%%d=0;",
          column_part, item.tablename, where_part, orderby_part, div);
    }

    rc = mysql_query(con, query);
    if (rc) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("Get Values: %s\n", mysql_error(con));
      *sts = SEV__DBERROR;
      return 0;
    }

    result = mysql_store_result(con);
    if (!result) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("GetValues Result Error\n");
      *sts = SEV__DBERROR;
      return 0;
    }
    rows = mysql_num_rows(result);

    if (k == 0 && options & pwr_mSevOptionsMask_UseDeadBand
        && rows < maxsize / 3 && rows != 0 && div != 1) {
      // Try another read with smaller div
      printf("Retry: %d old dev: %d, new div %d\n", rows, div,
          div * rows / maxsize + 1);
      if (div == div * rows / maxsize + 1)
        break;
      div = div * rows / maxsize + 1;
      mysql_free_result(result);
    } else
      break;
  }
  int bufrows = rows + (startvalue != 0) + (endvalue != 0);

  if (options & pwr_mSevOptionsMask_ReadOptimized) {
    *tbuf = (pwr_tTime*)calloc(bufrows, sizeof(pwr_tTime));
    *vbuf = calloc(bufrows, size);

    int bcnt = 0;

    if (startvalue) {
      (*tbuf)[bcnt] = *starttime;
      memcpy((*vbuf), startvalue, size);
      bcnt++;
    }

    for (int i = 0; i < rows; i++) {
      int j = 0;

      // if ( div > 1)
      //   mysql_data_seek( result, i);

      row = mysql_fetch_row(result);
      if (!row)
        break;

      if (options & pwr_mSevOptionsMask_PosixTime) {
        if (options & pwr_mSevOptionsMask_HighTimeResolution) {
          // Posix time, high resolution
          (*tbuf)[bcnt].tv_sec = strtoul(row[j++], 0, 10);
          (*tbuf)[bcnt].tv_nsec = strtoul(row[j++], 0, 10);
        } else
          // Posix time, low resolution
          (*tbuf)[bcnt].tv_sec = strtoul(row[j++], 0, 10);
      } else {
        if (options & pwr_mSevOptionsMask_HighTimeResolution) {
          // Sql time, high resolution
          timestr_to_time(row[j++], &(*tbuf)[bcnt]);
          (*tbuf)[bcnt].tv_nsec = strtoul(row[j++], 0, 10);
        } else
          // Sql time, low resolution
          timestr_to_time(row[j++], &(*tbuf)[bcnt]);
      }

      if (row[j] == 0) {
        // Null value
        switch (type) {
        case pwr_eType_Float32:
        case pwr_eType_Float64:
        case pwr_eType_Int8:
        case pwr_eType_Int16:
        case pwr_eType_Int32:
        case pwr_eType_Int64:
        case pwr_eType_UInt8:
        case pwr_eType_UInt16:
        case pwr_eType_UInt32:
        case pwr_eType_UInt64:
        case pwr_eType_Mask:
        case pwr_eType_Enum:
          cdh_StringToAttrValue(type, "0", ((char*)*vbuf) + bcnt * size);
          break;
        case pwr_eType_Time:
        case pwr_eType_DeltaTime:
          // TODO deltatime??
          cdh_StringToAttrValue(
              type, "1970-01-01 00:00:00", ((char*)*vbuf) + bcnt * size);
          break;
        default:
          cdh_StringToAttrValue(type, " ", ((char*)*vbuf) + bcnt * size);
          break;
        }
        j++;
      } else
        cdh_StringToAttrValue(type, row[j++], ((char*)*vbuf) + bcnt * size);

      bcnt++;
      // if ( options & pwr_mSevOptionsMask_HighTimeResolution)
      //  printf( "%5d %5d %s.%9s %s\n", i, bcnt, row[0], row[1], row[2]);
      // else
      //  printf( "%5d %5d %s %s\n", i, bcnt, row[0], row[1]);
    }

    if (endvalue) {
      (*tbuf)[bcnt] = *endtime;
      memcpy(((char*)*vbuf) + bcnt * size, endvalue, size);
      bcnt++;
    }

    printf("bcnt %d bufrows %d\n", bcnt, bufrows);
    *bsize = bcnt;
    mysql_free_result(result);
  } else {
    *tbuf = (pwr_tTime*)calloc(bufrows, sizeof(pwr_tTime));
    *vbuf = calloc(bufrows, size);

    div = 1;
    int bcnt = 0;
    for (int i = 0; i < rows; i += div) {
      int j = 1;

      if (div > 1)
        mysql_data_seek(result, i);

      row = mysql_fetch_row(result);
      if (!row)
        break;

      if (options & pwr_mSevOptionsMask_PosixTime) {
        if (options & pwr_mSevOptionsMask_HighTimeResolution) {
          // Posix time, high resolution
          (*tbuf)[bcnt].tv_sec = strtoul(row[j++], 0, 10);
          (*tbuf)[bcnt].tv_nsec = strtoul(row[j++], 0, 10);
        } else
          // Posix time, low resolution
          (*tbuf)[bcnt].tv_sec = strtoul(row[j++], 0, 10);
      } else {
        if (options & pwr_mSevOptionsMask_HighTimeResolution) {
          // Sql time, high resolution
          timestr_to_time(row[j++], &(*tbuf)[bcnt]);
          (*tbuf)[bcnt].tv_nsec = strtoul(row[j++], 0, 10);
        } else
          // Sql time, low resolution
          timestr_to_time(row[j++], &(*tbuf)[bcnt]);
      }

      if (row[j] == 0) {
        // Null value
        switch (type) {
        case pwr_eType_Float32:
        case pwr_eType_Float64:
        case pwr_eType_Int8:
        case pwr_eType_Int16:
        case pwr_eType_Int32:
        case pwr_eType_Int64:
        case pwr_eType_UInt8:
        case pwr_eType_UInt16:
        case pwr_eType_UInt32:
        case pwr_eType_UInt64:
        case pwr_eType_Mask:
        case pwr_eType_Enum:
          cdh_StringToAttrValue(type, "0", ((char*)*vbuf) + bcnt * size);
          break;
        case pwr_eType_Time:
        case pwr_eType_DeltaTime:
          // TODO deltatime??
          cdh_StringToAttrValue(
              type, "1970-01-01 00:00:00", ((char*)*vbuf) + bcnt * size);
          break;
        default:
          cdh_StringToAttrValue(type, " ", ((char*)*vbuf) + bcnt * size);
          break;
        }
        j++;
      } else
        cdh_StringToAttrValue(type, row[j++], ((char*)*vbuf) + bcnt * size);

      bcnt++;
      // if ( options & pwr_mSevOptionsMask_HighTimeResolution)
      //  printf( "%5d %5d %s.%9s %s\n", i, bcnt, row[0], row[1], row[2]);
      // else
      //  printf( "%5d %5d %s %s\n", i, bcnt, row[0], row[1]);
    }
    printf("bcnt %d bufrows %d\n", bcnt, bufrows);
    *bsize = bcnt;
    mysql_free_result(result);
  }
  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbms::store_event(
    pwr_tStatus* sts, void* thread, int item_idx, sev_event* ep)
{
  char query[800];
  char timstr[40];
  char eventtext[100];
  int rc;
  MYSQL* con;

  if (thread)
    con = (MYSQL*)thread;
  else
    con = m_env->con();

  *sts = time_AtoAscii(
      &ep->time, time_eFormat_NumDateAndTime, timstr, sizeof(timstr));
  if (EVEN(*sts))
    return 0;
  timstr[19] = 0;

  // Check if event already exist
  if (m_items[item_idx].options & pwr_mSevOptionsMask_PosixTime) {
    if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution)
      // Posix time, high resolution
      sprintf(query,
          "select eventid_nix,eventid_idx,ntime from %s where time = %ld",
          m_items[item_idx].tablename, (long int)ep->time.tv_sec);
    else
      // Posix time, low resolution
      sprintf(query, "select eventid_nix,eventid_idx from %s where time = %ld",
          m_items[item_idx].tablename, (long int)ep->time.tv_sec);
  } else {
    if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution)
      // Sql time, high resolution
      sprintf(query,
          "select eventid_nix,eventid_idx,ntime from %s where time = '%s'",
          m_items[item_idx].tablename, timstr);
    else
      // Sql time, low resolution
      sprintf(query, "select eventid_nix,eventid_idx from %s where time = '%s'",
          m_items[item_idx].tablename, timstr);
  }
  rc = mysql_query(con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(con));
  }
  MYSQL_RES* result = mysql_store_result(con);
  if (!result) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s Result Error\n", __FUNCTION__);
    *sts = SEV__DBERROR;
    return 0;
  }

  int rows = mysql_num_rows(result);
  int found = 0;
  unsigned int idx = 0, nix = 0, ntime;
  for (int i = 0; i < rows; i++) {
    MYSQL_ROW row;
    ntime = 0;
    row = mysql_fetch_row(result);
    if (row[0] != NULL) {
      nix = strtoul(row[0], 0, 10);
      idx = strtoul(row[1], 0, 10);
      if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution)
        ntime = strtoul(row[2], 0, 10);
    }
    if (ep->eventid.Nix == nix && ep->eventid.Idx == idx) {
      if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
        if (ntime == ep->time.tv_nsec)
          found = 1;
      } else
        found = 1;
      break;
    }
  }
  mysql_free_result(result);

  if (found)
    return 1;

  // Replace " to \" in event text
  string_to_mysqlstring(ep->eventtext, eventtext, sizeof(eventtext));

  if (m_items[item_idx].options & pwr_mSevOptionsMask_PosixTime) {
    if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
      // Posix time, high resolution
      sprintf(query, "insert into %s (time, ntime, eventtype, eventprio, "
                     "eventid_nix, eventid_birthtime,"
                     "eventid_idx, supobject_vid, supobject_oix, "
                     "supobject_offset, supobject_size,"
                     "eventtext, eventname, eventstatus) values "
                     "(%ld,%ld,%d,%d,%d,%d,%d,%u,%u,%u,%u,'%s','%s',%u)",
          m_items[item_idx].tablename, (long int)ep->time.tv_sec,
          (long int)ep->time.tv_nsec, ep->type, ep->eventprio, ep->eventid.Nix,
          ep->eventid.BirthTime.tv_sec, ep->eventid.Idx,
          ep->supobject.Objid.vid, ep->supobject.Objid.oix,
	      ep->supobject.Offset, ep->supobject.Size, eventtext, ep->eventname,
	      ep->eventstatus);
    } else {
      // Posix time, low resolution
      sprintf(query, "insert into %s (time, eventtype, eventprio, eventid_nix, "
                     "eventid_birthtime,"
                     "eventid_idx, supobject_vid, supobject_oix, "
                     "supobject_offset, supobject_size, "
                     "eventtext, eventname, eventstatus) values "
                     "(%ld,%d,%d,%d,%d,%d,%u,%u,%u,%u,'%s','%s',%u)",
	  m_items[item_idx].tablename, (long int)ep->time.tv_sec, ep->type,
	  ep->eventprio, ep->eventid.Nix, ep->eventid.BirthTime.tv_sec,
	  ep->eventid.Idx, ep->supobject.Objid.vid, ep->supobject.Objid.oix,
	  ep->supobject.Offset, ep->supobject.Size, eventtext, ep->eventname,
	  ep->eventstatus);
    }
  } else {
    if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
      // Sql time, high resolution
      sprintf(query, "insert into %s (time, ntime, eventtype, eventprio, "
                     "eventid_nix, eventid_birthtime,"
                     "eventid_idx, supobject_vid, supobject_oix, "
                     "supobject_offset, supobject_size,"
                     "eventtext, eventname, eventstatus) values "
                     "('%s',%ld,%d,%d,%d,%d,%d,%u,%u,%u,%u,'%s','%s',%u)",
          m_items[item_idx].tablename, timstr, (long int)ep->time.tv_nsec,
          ep->type, ep->eventprio, ep->eventid.Nix,
          ep->eventid.BirthTime.tv_sec, ep->eventid.Idx,
          ep->supobject.Objid.vid, ep->supobject.Objid.oix,
	  ep->supobject.Offset, ep->supobject.Size, eventtext, ep->eventname,
	  ep->eventstatus);
    } else {
      // Sql time, low resolution
      sprintf(query, "insert into %s (time, eventtype, eventprio, eventid_nix, "
                     "eventid_birthtime,"
                     "eventid_idx, supobject_vid, supobject_oix, "
                     "supobject_offset, supobject_size,"
                     "eventtext, eventname, eventstatus) values "
                     "('%s',%d,%d,%d,%d,%d,%u,%u,%u,%u,'%s','%s',%u)",
          m_items[item_idx].tablename, timstr, ep->type, ep->eventprio,
          ep->eventid.Nix, ep->eventid.BirthTime.tv_sec, ep->eventid.Idx,
          ep->supobject.Objid.vid, ep->supobject.Objid.oix,
	  ep->supobject.Offset, ep->supobject.Size, eventtext, ep->eventname,
	  ep->eventstatus);
    }
  }
  rc = mysql_query(con, query);
  if (rc) {
    // printf( "Store value: %s \"%s\"\n", mysql_error(con), query);
    *sts = SEV__DBERROR;
    m_items[item_idx].status = *sts;
    if (m_items[item_idx].status != m_items[item_idx].logged_status) {
      m_items[item_idx].logged_status = m_items[item_idx].status;
      errh_Error("Database store error: %s, table: %s object: %s",
          mysql_error(con), m_items[item_idx].tablename,
          m_items[item_idx].oname);
    }
    return 0;
  }

  *sts = SEV__SUCCESS;
  m_items[item_idx].status = *sts;
  m_items[item_idx].logged_status = 1;
  return 1;
}

int sev_dbms::check_item(pwr_tStatus* sts, pwr_tOid oid, char* oname,
    char* aname, pwr_tDeltaTime storagetime, pwr_eType type, unsigned int size,
    char* description, char* unit, pwr_tFloat32 scantime, pwr_tFloat32 deadband,
    pwr_tMask options, unsigned int* idx)
{
  char timestr[40];
  pwr_tTime uptime;

  time_GetTime(&uptime);
  time_AtoAscii(&uptime, time_eFormat_NumDateAndTime, timestr, sizeof(timestr));
  timestr[19] = 0;

  for (unsigned int i = 0; i < m_items.size(); i++) {
    if (m_items[i].deleted)
      continue;

    if (cdh_ObjidIsEqual(oid, m_items[i].oid)
        && str_NoCaseStrcmp(aname, m_items[i].attr[0].aname) == 0) {
      char query[600];

      bool itemdefchange = false;
      if (type != m_items[i].attr[0].type || size != m_items[i].attr[0].size) {
        itemdefchange = true;
      }

      sprintf(query, "update items set ");
      if (storagetime.tv_sec != m_items[i].storagetime.tv_sec) {
        sprintf(&query[strlen(query)], "storagetime=%ld,",
            (long int)storagetime.tv_sec);
        m_items[i].storagetime = storagetime;
      }
      if (!streq(oname, m_items[i].oname)) {
        sprintf(&query[strlen(query)], "oname=\'%s\',", oname);
        strncpy(m_items[i].oname, oname, sizeof(m_items[i].oname));
      }
      if (type != m_items[i].attr[0].type) {
        sprintf(&query[strlen(query)], "vtype=%d,", type);
        m_items[i].attr[i].type = type;
      }
      if (size != m_items[i].attr[0].size) {
        sprintf(&query[strlen(query)], "vsize=%d,", size);
        m_items[i].attr[i].size = size;
      }
      if (!feqf(scantime, m_items[i].scantime)) {
        sprintf(&query[strlen(query)], "scantime=%.1f,", scantime);
        m_items[i].scantime = scantime;
      }
      if (!feqf(deadband, m_items[i].deadband)) {
        sprintf(&query[strlen(query)], "deadband=%.4f,", deadband);
        m_items[i].deadband = deadband;
      }
      if (!streq(description, m_items[i].description)) {
        sprintf(&query[strlen(query)], "description=\'%s\',", description);
        strncpy(m_items[i].description, description,
            sizeof(m_items[i].description));
      }
      if (!streq(unit, m_items[i].attr[0].unit)) {
        sprintf(&query[strlen(query)], "unit=\'%s\',", unit);
        strncpy(m_items[i].attr[0].unit, unit, sizeof(m_items[i].attr[0].unit));
      }

      sprintf(&query[strlen(query)], "uptime=\'%s\' ", timestr);
      sprintf(&query[strlen(query)], "where id=%d;", m_items[i].id);

      // This won't work!! We have to alter the table to be able to change this
      // m_items[i].options = options;

      int rc = mysql_query(m_env->con(), query);
      if (rc) {
        printf("In %s row %d:\n", __FILE__, __LINE__);
        printf("Store item: %s\n", mysql_error(m_env->con()));
        *sts = SEV__DBERROR;
        return 0;
      }

      if (itemdefchange) {
        if (!handle_itemchange(sts, m_items[i].tablename, i)) {
          return 1;
        }
      }
      *idx = i;
      *sts = SEV__SUCCESS;
      return 1;
    }
  }
  *sts = SEV__NOSUCHITEM;
  return 0;
}

int sev_dbms::add_item(pwr_tStatus* sts, pwr_tOid oid, char* oname, char* aname,
    pwr_tDeltaTime storagetime, pwr_eType type, unsigned int size,
    char* description, char* unit, pwr_tFloat32 scantime, pwr_tFloat32 deadband,
    pwr_tMask options, unsigned int* idx)
{
  char tablename[256];

  store_item(sts, tablename, oid, oname, aname, storagetime, type, size,
      description, unit, scantime, deadband, options);
  if (EVEN(*sts))
    return 0;

  if (streq(aname, "Events"))
    create_event_table(sts, tablename, options);
  else
    create_table(sts, tablename, type, size, options, deadband);
  if (EVEN(*sts))
    return 0;

  sev_item item;
  sev_attr attr;
  item.attr.push_back(attr);
  item.id = 0;
  strncpy(item.tablename, tablename, sizeof(item.tablename));
  item.oid = oid;
  strncpy(item.oname, oname, sizeof(item.oname));
  strncpy(item.attr[0].aname, aname, sizeof(item.attr[0].aname));
  time_GetTime(&item.creatime);
  item.modtime = item.creatime;
  item.storagetime = storagetime;
  item.attr[0].type = type;
  item.attr[0].size = size;
  strncpy(item.description, description, sizeof(item.description));
  strncpy(item.attr[0].unit, unit, sizeof(item.attr[0].unit));
  item.scantime = scantime;
  item.deadband = deadband;
  item.options = options;
  item.attrnum = 1;

  m_items.push_back(item);
  *idx = m_items.size() - 1;

  if (item.options & pwr_mSevOptionsMask_UseDeadBand && m_cnf.LinearRegrAll)
    item.options |= pwr_mSevOptionsMask_DeadBandLinearRegr;

  if (item.options & pwr_mSevOptionsMask_DeadBandLinearRegr)
    add_cache(*idx);

  if (m_cnf.MeanValueAll)
    item.options |= pwr_mSevOptionsMask_MeanValue1;

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbms::delete_item(pwr_tStatus* sts, pwr_tOid oid, char* aname)
{
  sev_item item;
  get_item(sts, 0, &item, oid, aname);
  if (EVEN(*sts)) {
    return 0;
  }

  remove_item(sts, oid, aname);

  if (ODD(*sts))
    delete_table(sts, item.tablename);

  if (ODD(*sts)) {
    for (int i = 0; i < (int)m_items.size(); i++) {
      if (m_items[i].deleted)
        continue;
      if (cdh_ObjidIsEqual(m_items[i].oid, oid)
          && str_NoCaseStrcmp(m_items[i].attr[0].aname, aname) == 0) {
        m_items[i].deleted = 1;
        break;
      }
    }
  }
  return 1;
}

int sev_dbms::delete_old_data(pwr_tStatus* sts, void* thread, char* tablename,
    pwr_tMask options, pwr_tTime limit, pwr_tFloat32 scantime,
    pwr_tFloat32 garbagecycle)
{
  char query[300];
  char timstr[40];
  MYSQL* con;

  if (thread)
    con = (MYSQL*)thread;
  else
    con = m_env->con();

  *sts = time_AtoAscii(
      &limit, time_eFormat_NumDateAndTime, timstr, sizeof(timstr));
  if (EVEN(*sts))
    return 0;
  timstr[19] = 0;

  if (options & pwr_mSevOptionsMask_ReadOptimized) {
    // TODO Change 86400 to sev_cGarbageCycle
    // We scan trough as many rows that we write between two garbage cycles plus
    // some extra rows
    // to be sure that the table not grows to much.
    pwr_tUInt64 nbRowsToClean = 86400 * 2; // default value
    if (scantime > 0.0)
      nbRowsToClean = (pwr_tUInt64)((garbagecycle / scantime) + 10000.0);

    nbRowsToClean += get_minFromIntegerColumn(thread, tablename, (char*)"id");
    if (options & pwr_mSevOptionsMask_PosixTime)
      sprintf(query,
          "delete from %s where id < " pwr_dFormatUInt64 " and time < %ld;",
          tablename, nbRowsToClean, (long int)limit.tv_sec);
    else
      sprintf(query,
          "delete from %s where id < " pwr_dFormatUInt64 " and time < '%s';",
          tablename, nbRowsToClean, timstr);
  } else {
    if (options & pwr_mSevOptionsMask_PosixTime)
      sprintf(query, "delete from %s where time < %ld;", tablename,
          (long int)limit.tv_sec);
    else
      sprintf(query, "delete from %s where time < '%s';", tablename, timstr);
  }
  int rc = mysql_query(con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Delete old data: %s\n", mysql_error(con));
    if ( con->net.last_errno == CR_SERVER_GONE_ERROR)
      *sts = SEV__NOCONNECTION;
    else
      *sts = SEV__DBERROR;
    return 0;
  }

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbms::timestr_to_time(char* tstr, pwr_tTime* ts)
{
  struct tm tt;

  int nr = sscanf(tstr, "%4d-%02d-%20d %02d:%02d:%02d", &tt.tm_year, &tt.tm_mon,
      &tt.tm_mday, &tt.tm_hour, &tt.tm_min, &tt.tm_sec);
  if (nr != 6)
    return 0;

  tt.tm_year -= 1900;
  tt.tm_mon--;

  tt.tm_wday = -1;
  tt.tm_yday = -1;
  tt.tm_isdst = -1;

  ts->tv_sec = mktime(&tt);
  ts->tv_nsec = 0;

  return 1;
}

char* sev_dbms::oid_to_table(pwr_tOid oid, char* aname)
{
  static char tbl[40];
  unsigned char vid[4];

  memcpy(&vid, &oid.vid, sizeof(vid));
  sprintf(tbl, "O%3.3u_%3.3u_%3.3u_%3.3u_%8.8x_%s", vid[3], vid[2], vid[1],
      vid[0], oid.oix, cdh_Low(aname));

  // Replace '.' in attribute with '_'
  for (char* s = tbl; *s; s++) {
    if (*s == '.')
      *s = '_';
    if (*s == '[')
      *s = '$';
    if (*s == ']')
      *s = '$';
  }
  return tbl;
}

char* sev_dbms::dbName()
{
  return sev_dbms_env::dbName();
}

char* sev_dbms::pwrtype_to_type(pwr_eType type, unsigned int size)
{
  static char stype[40];

  switch (type) {
  case pwr_eType_Boolean:
    strcpy(stype, "int unsigned");
    break;
  case pwr_eType_Int64:
    strcpy(stype, "bigint");
    break;
  case pwr_eType_UInt64:
    strcpy(stype, "bigint unsigned");
    break;
  case pwr_eType_Int32:
    strcpy(stype, "int");
    break;
  case pwr_eType_UInt32:
    strcpy(stype, "int unsigned");
    break;
  case pwr_eType_Int16:
    strcpy(stype, "smallint");
    break;
  case pwr_eType_UInt16:
    strcpy(stype, "smallint unsigned");
    break;
  case pwr_eType_Int8:
    strcpy(stype, "tinyint");
    break;
  case pwr_eType_UInt8:
    strcpy(stype, "tinyint unsigned");
    break;
  case pwr_eType_Float64:
    strcpy(stype, "double");
    break;
  case pwr_eType_Float32:
    strcpy(stype, "float");
    break;
  case pwr_eType_Char:
    strcpy(stype, "char(1)");
    break;
  case pwr_eType_String:
    sprintf(stype, "varchar(%d)", size);
    break;
  case pwr_eType_Time:
    strcpy(stype, "datetime");
    break;
  default:
    strcpy(stype, "");
  }
  return stype;
}

int sev_dbms::check_objectitem(pwr_tStatus* sts, char* tablename, pwr_tOid oid,
    char* oname, char* aname, pwr_tDeltaTime storagetime, char* description,
    pwr_tFloat32 scantime, pwr_tFloat32 deadband, pwr_tMask options,
    unsigned int attrnum, sev_sHistAttr* attr, unsigned int* idx)
{
  char timestr[40];
  pwr_tTime uptime;

  time_GetTime(&uptime);
  time_AtoAscii(&uptime, time_eFormat_NumDateAndTime, timestr, sizeof(timestr));
  timestr[19] = 0;

  for (unsigned int i = 0; i < m_items.size(); i++) {
    if (m_items[i].deleted)
      continue;

    if (cdh_ObjidIsEqual(oid, m_items[i].oid)
        && str_NoCaseStrcmp(oname, m_items[i].oname) == 0) {
      char query[400];
      sprintf(query, "update objectitems set ");
      sprintf(&query[strlen(query)], "storagetime=%ld,",
          (long int)storagetime.tv_sec);
      sprintf(&query[strlen(query)], "description=\'%s\',", description);
      sprintf(&query[strlen(query)], "scantime=%.3f,", scantime);
      sprintf(&query[strlen(query)], "deadband=%.3f,", deadband);
      // For now we can't change options. sprintf( &query[strlen(query)],
      // "options=%d,", options);
      sprintf(&query[strlen(query)], "uptime=\'%s\' ", timestr);
      sprintf(&query[strlen(query)],
          "where vid=%d and oix=%d and tablename='%s';", oid.vid, oid.oix,
          tablename);

      // printf("%s query:%s\n", __FUNCTION__, query);

      int rc = mysql_query(m_env->con(), query);
      if (rc) {
        printf("In %s row %d:\n", __FILE__, __LINE__);
        printf("%s : %s\n", __FUNCTION__, mysql_error(m_env->con()));
        *sts = SEV__DBERROR;
        return 0;
      }
      m_items[i].storagetime = storagetime;
      strncpy(
          m_items[i].description, description, sizeof(m_items[i].description));
      m_items[i].scantime = scantime;
      m_items[i].deadband = deadband;
      // This won't work!! We have to alter the table to be able to change this
      // m_items[i].options = options;

      strcpy(tablename, m_items[i].tablename);

      *idx = i;
      *sts = SEV__SUCCESS;
      return 1;
    }
  }
  *sts = SEV__NOSUCHITEM;
  return 0;
}

int sev_dbms::add_objectitem(pwr_tStatus* sts, char* tablename, pwr_tOid oid,
    char* oname, char* aname, pwr_tDeltaTime storagetime, char* description,
    pwr_tFloat32 scantime, pwr_tFloat32 deadband, pwr_tMask options,
    unsigned int attrnum, sev_sHistAttr* attr, unsigned int* idx)
{
  store_objectitem(sts, tablename, oid, oname, aname, storagetime, description,
      scantime, deadband, options);
  if (EVEN(*sts))
    return 0;

  create_objecttable(sts, tablename, options, deadband);
  if (EVEN(*sts))
    return 0;

  *sts = SEV__SUCCESS;
  sev_item item;
  item.id = 0;
  strncpy(item.tablename, tablename, sizeof(item.tablename));
  item.oid = oid;
  strncpy(item.oname, oname, sizeof(item.oname));
  time_GetTime(&item.creatime);
  item.modtime = item.creatime;
  item.storagetime = storagetime;
  strncpy(item.description, description, sizeof(item.description));
  item.scantime = scantime;
  item.deadband = deadband;
  item.options = options;
  item.attrnum = 0;

  m_items.push_back(item);
  *idx = m_items.size() - 1;

  return 1;
}
int sev_dbms::store_objectitem(pwr_tStatus* sts, char* tablename, pwr_tOid oid,
    char* oname, char* aname, pwr_tDeltaTime storagetime, char* description,
    pwr_tFloat32 scantime, pwr_tFloat32 deadband, pwr_tMask options)
{
  char query[800];
  char timestr[40];
  pwr_tTime creatime;

  time_GetTime(&creatime);
  time_AtoAscii(
      &creatime, time_eFormat_NumDateAndTime, timestr, sizeof(timestr));
  timestr[19] = 0;

  unsigned int next_id = get_nextAutoIncrement((char*)"objectitems");
  /*
    char volName[32];
    strncpy(volName, oname, sizeof(volName));
    for ( char *s = volName; *s; s++) {
      if ( *s == ':') {
        *s = 0;
        break;
      }
    }

    sprintf(tablename, "obj_%s_%d", volName, next_id);
  */
  sprintf(tablename, "obj_%s_%d", oid_to_table(oid, (char*)""), next_id);

  sprintf(query, "insert into objectitems "
                 "(id,tablename,vid,oix,oname,aname,uptime,cretime,storagetime,"
                 "description,scantime,deadband,options) "
                 "values (0,'%s',%d,%d,'%s','%s','%s','%s',%ld,'%s',%f,%f,%d);",
      tablename, oid.vid, oid.oix, oname, aname, timestr, timestr,
      (long int)storagetime.tv_sec, description, scantime, deadband, options);
  int rc = mysql_query(m_env->con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(m_env->con()));
    *sts = SEV__DBERROR;
    return 0;
  }

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbms::create_objecttable(
    pwr_tStatus* sts, char* tablename, pwr_tMask options, float deadband)
{
  char query[2000];
  char timeformatstr[80];
  char jumpstr[80];
  char idtypestr[20];
  char readoptstr[80];
  char enginestr[100] = "";

  if (!streq(m_cnf.Engine, ""))
    snprintf(enginestr, sizeof(enginestr), " engine=%s", m_cnf.Engine);

  if (options & pwr_mSevOptionsMask_PosixTime) {
    if (options & pwr_mSevOptionsMask_HighTimeResolution) {
      // Posix time, high resolution
      strcpy(timeformatstr, "sev__time int unsigned, sev__ntime int unsigned");
      strcpy(idtypestr, "bigint");
    } else {
      // Posix time, low resolution
      strcpy(timeformatstr, "sev__time int unsigned");
      strcpy(idtypestr, "int");
    }
  } else {
    if (options & pwr_mSevOptionsMask_HighTimeResolution) {
      // Sql time, high resolution
      strcpy(timeformatstr,
          "sev__time datetime not null, sev__ntime int unsigned");
      strcpy(idtypestr, "bigint");
    } else {
      // Sql time, low resolution
      strcpy(timeformatstr, "sev__time datetime not null");
      strcpy(idtypestr, "int");
    }
  }

  if (options & pwr_mSevOptionsMask_ReadOptimized)
    sprintf(readoptstr,
        "sev__id %s unsigned not null primary key auto_increment,", idtypestr);
  else
    strcpy(readoptstr, "");

  if (options & pwr_mSevOptionsMask_UseDeadBand)
    strcpy(jumpstr, ",sev__jump tinyint unsigned");
  else
    strcpy(jumpstr, "");

  sprintf(query, "create table %s ( %s"
                 "%s %s, index (sev__time) )%s;",
      tablename, readoptstr, timeformatstr, jumpstr, enginestr);

  int rc = mysql_query(m_env->con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(m_env->con()));
    *sts = SEV__DBERROR;
    return 0;
  }
  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbms::check_objectitemattr(pwr_tStatus* sts, char* tablename,
    pwr_tOid oid, char* aname, char* oname, pwr_eType type, unsigned int size,
    unsigned int* idx)
{
  sev_item* item = &m_items[*idx];
  for (size_t j = 0; j < item->attr.size(); j++) {
    if (str_NoCaseStrcmp(aname, item->attr[j].aname) == 0) {
      if (type != item->attr[j].type || size != item->attr[j].size) {
        *sts = SEV__NOSUCHITEM;
        return 0;
        /*
        if( !handle_attrchange(sts, tablename, oid, aname,oname,type,size, *idx,
        j) ) {
          return 1;
        }
        item->attr[j].type = type;
        item->attr[j].size = size;
        update_objectitemattr(sts, tablename, aname, type, size);
        */
      }
      *sts = SEV__SUCCESS;
      return 1;
    }
  }
  *sts = SEV__NOSUCHITEM;
  return 0;
}

pwr_tUInt64 sev_dbms::get_minFromIntegerColumn(
    void* thread, char* tablename, char* colname)
{
  char query[2000];
  pwr_tUInt64 retVal = 0;
  MYSQL* con;

  if (thread)
    con = (MYSQL*)thread;
  else
    con = m_env->con();

  sprintf(query, "select min(`%s`) from %s", colname, tablename);

  // printf( "%s: %s\n", __FUNCTION__ ,query);
  int rc = mysql_query(con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(m_env->con()));
    return 0;
  }
  MYSQL_RES* result = mysql_store_result(con);
  if (!result) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s Result Error\n", __FUNCTION__);
    return retVal;
  }

  int rows = mysql_num_rows(result);
  if (rows <= 0) {
    mysql_free_result(result);
    return retVal;
  }
  MYSQL_ROW row;
  row = mysql_fetch_row(result);
  if (row[0] != NULL) {
    retVal = strtoull(row[0], 0, 10);
  }
  mysql_free_result(result);
  return retVal;
}

pwr_tUInt64 sev_dbms::get_maxFromIntegerColumn(
    void* thread, char* tablename, char* colname)
{
  char query[2000];
  pwr_tUInt64 retVal = 0;
  MYSQL* con;

  if (thread)
    con = (MYSQL*)thread;
  else
    con = m_env->con();

  sprintf(query, "select max(`%s`) from %s", colname, tablename);

  // printf( "%s: %s\n", __FUNCTION__ ,query);
  int rc = mysql_query(con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(m_env->con()));
    return 0;
  }
  MYSQL_RES* result = mysql_store_result(con);
  if (!result) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s Result Error\n", __FUNCTION__);
    return retVal;
  }

  int rows = mysql_num_rows(result);
  if (rows <= 0) {
    mysql_free_result(result);
    return retVal;
  }
  MYSQL_ROW row;
  row = mysql_fetch_row(result);
  if (row[0] != NULL) {
    retVal = strtoull(row[0], 0, 10);
  }
  mysql_free_result(result);
  return retVal;
}

pwr_tUInt64 sev_dbms::get_nextAutoIncrement(char* tablename)
{
  char query[200];
  pwr_tUInt64 retVal = 0;
  sprintf(query, "SELECT Auto_increment FROM information_schema.tables WHERE "
                 "table_name='%s' && table_schema='%s'",
      tablename, m_env->dbName());
  // printf( "%s: %s\n", __FUNCTION__ ,query);
  int rc = mysql_query(m_env->con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(m_env->con()));
    return 0;
  }
  MYSQL_RES* result = mysql_store_result(m_env->con());
  if (!result) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s Result Error\n", __FUNCTION__);
    return retVal;
  }

  int rows = mysql_num_rows(result);
  if (rows <= 0) {
    mysql_free_result(result);
    return retVal;
  }
  MYSQL_ROW row;
  row = mysql_fetch_row(result);
  if (row[0] != NULL) {
    retVal = strtoull(row[0], 0, 10);
  }
  mysql_free_result(result);
  return retVal;
}

int sev_dbms::store_objectvalue(pwr_tStatus* sts, void* thread, int item_idx,
    int attr_idx, pwr_tTime time, void* buf, void* oldbuf, unsigned int size)
{
  void* data = buf;
  void* olddata = oldbuf;

  static const int constQueryLength = 3000;
  std::string valuesStr;
  std::string colsStr;
  std::ostringstream queryOStr;

  char query[constQueryLength];
  char bufstr[512];
  char bufInclEscCharstr[1025];
  char timstr[40];
  MYSQL* con;

  if (thread)
    con = (MYSQL*)thread;
  else
    con = m_env->con();

  *sts = time_AtoAscii(
      &time, time_eFormat_NumDateAndTime, timstr, sizeof(timstr));
  if (EVEN(*sts))
    return 0;
  timstr[19] = 0;

  bool updateOnlyTime = false;
  bool setJump = false;
  if (!m_items[item_idx].first_storage
      && (m_items[item_idx].options & pwr_mSevOptionsMask_UseDeadBand)) {
    if (m_items[item_idx].deadband_active) {
      updateOnlyTime = true;
      for (size_t i = 0; i < m_items[item_idx].attr.size(); i++) {
        pwr_tFloat32 deadband
            = m_items[item_idx].deadband; // TODO should be on attribute
        m_items[item_idx].deadband_active
            = check_deadband(m_items[item_idx].attr[i].type,
                m_items[item_idx].attr[i].size, deadband, buf, oldbuf);
        if (!m_items[item_idx].deadband_active) {
          updateOnlyTime = false;
          break;
        }
        buf = (char*)buf + m_items[item_idx].attr[i].size;
        oldbuf = (char*)oldbuf + m_items[item_idx].attr[i].size;
      }
    } else {
      setJump = true;
      for (size_t i = 0; i < m_items[item_idx].attr.size(); i++) {
        pwr_tFloat32 deadband
            = m_items[item_idx].deadband; // TODO should be on attribute
        m_items[item_idx].deadband_active
            = check_deadband(m_items[item_idx].attr[i].type,
                m_items[item_idx].attr[i].size, deadband, buf, oldbuf);
        if (!m_items[item_idx].deadband_active) {
          setJump = false;
          break;
        }
        buf = (char*)buf + m_items[item_idx].attr[i].size;
        oldbuf = (char*)oldbuf + m_items[item_idx].attr[i].size;
      }
    }
  }
  buf = data;
  oldbuf = olddata;

  if (!updateOnlyTime) {
    memcpy(oldbuf, buf, size);

    for (size_t i = 0; i < m_items[item_idx].attr.size(); i++) {
      tree_update_value(item_idx, i, time, buf);

      if (m_items[item_idx].attr[i].type == pwr_eType_Time)
        *sts = time_AtoAscii((pwr_tTime*)buf, time_eFormat_NumDateAndTime,
            bufstr, sizeof(bufstr));
      else
        *sts = cdh_AttrValueToString(
            m_items[item_idx].attr[i].type, buf, bufstr, sizeof(bufstr));
      if (EVEN(*sts))
        return 0;
      if (m_items[item_idx].attr[i].type == pwr_eType_String
          || m_items[item_idx].attr[i].type == pwr_eType_Text) {
        mysql_real_escape_string(
            con, bufInclEscCharstr, bufstr, strlen(bufstr));
        valuesStr.append("'");
        valuesStr.append(bufInclEscCharstr);
        valuesStr.append("',");
      } else {
        valuesStr.append("'");
        valuesStr.append(bufstr);
        valuesStr.append("',");
      }
      char colNameStr[80];
      sprintf(colNameStr, "`%s`,",
          create_colName(i, m_items[item_idx].attr[i].aname));
      colsStr.append(colNameStr);

      //      colsStr.append("`");
      //      colsStr.append(m_items[item_idx].attr[i].aname);
      //      colsStr.append("`,");

      buf = (char*)buf + m_items[item_idx].attr[i].size;
    }
    // remove last ,
    valuesStr.resize(valuesStr.length() - 1);
    colsStr.resize(colsStr.length() - 1);

    if (m_items[item_idx].options & pwr_mSevOptionsMask_PosixTime) {
      if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
        // Posix time, high resolution
        queryOStr << "insert into " << m_items[item_idx].tablename
                  << " (sev__time, sev__ntime, " << colsStr << ") values ("
                  << time.tv_sec << "," << time.tv_nsec << "," << valuesStr
                  << ")";

        snprintf(query, constQueryLength,
            "insert into %s (sev__time, sev__ntime, %s) values (%ld,%ld,%s)",
            m_items[item_idx].tablename, colsStr.c_str(), (long int)time.tv_sec,
            (long int)time.tv_nsec, valuesStr.c_str());
      } else {
        // Posix time, low resolution
        queryOStr << "insert into " << m_items[item_idx].tablename
                  << " (sev__time, " << colsStr << ") values (" << time.tv_sec
                  << "," << valuesStr << ")";

        snprintf(query, constQueryLength,
            "insert into %s (sev__time, %s) values (%ld,%s)",
            m_items[item_idx].tablename, colsStr.c_str(), (long int)time.tv_sec,
            valuesStr.c_str());
      }
    } else {
      if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
        // Sql time, high resolution
        queryOStr << "insert into " << m_items[item_idx].tablename
                  << " (sev__time, sev__ntime, " << colsStr << ") values ("
                  << "'" << timstr << "'"
                  << "," << time.tv_nsec << "," << valuesStr << ")";

        snprintf(query, constQueryLength,
            "insert into %s (sev__time, sev__ntime, %s) values ('%s',%ld,%s)",
            m_items[item_idx].tablename, colsStr.c_str(), timstr,
            (long int)time.tv_nsec, valuesStr.c_str());

      } else {
        // Sql time, low resolution
        queryOStr << "insert into " << m_items[item_idx].tablename
                  << " (sev__time, " << colsStr << ") values ("
                  << "'" << timstr << "'"
                  << "," << valuesStr << ")";

        snprintf(query, constQueryLength,
            "insert into %s (sev__time, %s) values ('%s',%s)",
            m_items[item_idx].tablename, colsStr.c_str(), timstr,
            valuesStr.c_str());
      }
    }
  } // end insert new values
  else {
    if (m_items[item_idx].options & pwr_mSevOptionsMask_PosixTime) {
      if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
        // Posix time, high resolution
        queryOStr << "update " << m_items[item_idx].tablename
                  << " set sev__time = " << time.tv_sec
                  << ", sev__ntime = " << time.tv_nsec
                  << " where sev__id = " << m_items[item_idx].last_id;
      } else {
        // Posix time, low resolution
        queryOStr << "update " << m_items[item_idx].tablename
                  << " set sev__time = " << time.tv_sec
                  << " where sev__id = " << m_items[item_idx].last_id;
      }
    } else {
      if (m_items[item_idx].options & pwr_mSevOptionsMask_HighTimeResolution) {
        // Sql time, high resolution
        queryOStr << "update " << m_items[item_idx].tablename
                  << " set sev__time = '" << timstr
                  << "', sev__ntime = " << time.tv_nsec
                  << " where sev__id = " << m_items[item_idx].last_id;
      } else {
        // Sql time, low resolution
        queryOStr << "update " << m_items[item_idx].tablename
                  << " set sev__time = '" << timstr
                  << "' where sev__id = " << m_items[item_idx].last_id;
      }
    }
  }

  if (setJump || updateOnlyTime) {
    sprintf(query, "update %s set sev__jump = 1 where sev__id = %d",
        m_items[item_idx].tablename, m_items[item_idx].last_id);
    int rc = mysql_query(con, query);
    if (rc) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("Update jump: %s\n", mysql_error(con));
    }
  }

  // printf( "Store_objectvalue: %s\n", queryOStr.str().c_str());

  int rc = mysql_query(con, queryOStr.str().c_str());
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(con));
    printf("Error in: %s\n", queryOStr.str().c_str());

    *sts = SEV__DBERROR;
    m_items[item_idx].status = *sts;
    if (m_items[item_idx].status != m_items[item_idx].logged_status) {
      m_items[item_idx].logged_status = m_items[item_idx].status;
      errh_Error("Database update error: %s, table: %s object: %s",
          mysql_error(con), m_items[item_idx].tablename,
          m_items[item_idx].oname);
    }
    return 0;
  }

  if ((m_items[item_idx].options & pwr_mSevOptionsMask_ReadOptimized)
      && !updateOnlyTime)
    m_items[item_idx].last_id = mysql_insert_id(con);

  m_items[item_idx].first_storage = 0;

  *sts = SEV__SUCCESS;
  m_items[item_idx].status = *sts;
  m_items[item_idx].logged_status = 1;
  return 1;
}

int sev_dbms::get_item(pwr_tStatus* sts, void* thread, sev_item* item,
    pwr_tOid oid, char* attributename)
{
  char query[300];
  MYSQL* con;

  if (thread)
    con = (MYSQL*)thread;
  else
    con = m_env->con();

  sprintf(query, "select "
                 "id,tablename,vid,oix,oname,aname,uptime,cretime,storagetime,"
                 "vtype,vsize,description,unit,scantime,deadband,options "
                 "from items where vid=%d and oix=%d and aname='%s'",
      oid.vid, oid.oix, attributename);

  int rc = mysql_query(con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(con));
    *sts = SEV__DBERROR;
    return 0;
  }

  MYSQL_ROW row;
  MYSQL_RES* result = mysql_store_result(con);
  if (!result) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s Result Error\n", __FUNCTION__);
    *sts = SEV__DBERROR;
    return 0;
  }
  int rows = mysql_num_rows(result);

  if (rows > 1) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s Duplicate items Error\n", __FUNCTION__);
    *sts = SEV__DBERROR;
    mysql_free_result(result);
    return 0;
  }
  if (rows == 0) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s No item Error\n", __FUNCTION__);
    *sts = SEV__DBERROR;
    mysql_free_result(result);
    return 0;
  }

  int col;
  for (int i = 0; i < rows; i++) {
    row = mysql_fetch_row(result);
    if (!row)
      break;
    col = 0;
    sev_attr attr;
    item->attr.push_back(attr);

    item->id = atoi(row[col++]);
    strncpy(item->tablename, row[col++], sizeof(item->tablename));
    item->oid.vid = strtoul(row[col++], 0, 10);
    item->oid.oix = strtoul(row[col++], 0, 10);
    strncpy(item->oname, row[col++], sizeof(item->oname));
    strncpy(item->attr[0].aname, row[col++], sizeof(item->attr[0].aname));
    timestr_to_time(row[col++], &item->modtime);
    timestr_to_time(row[col++], &item->creatime);
    item->storagetime.tv_sec = strtoul(row[col++], 0, 10);
    item->storagetime.tv_nsec = 0;
    item->attr[0].type = (pwr_eType)strtoul(row[col++], 0, 10);
    item->attr[0].size = strtoul(row[col++], 0, 10);
    strncpy(item->description, row[col++], sizeof(item->description));
    strncpy(item->attr[0].unit, row[col++], sizeof(item->attr[0].unit));
    item->scantime = atof(row[col++]);
    item->deadband = atof(row[col++]);
    item->options = strtoul(row[col++], 0, 10);

    item->attrnum = 1;
  }
  mysql_free_result(result);

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbms::get_objectitem(pwr_tStatus* sts, void* thread, sev_item* item,
    pwr_tOid oid, char* attributename)
{
  char query[300];
  MYSQL* con;

  if (thread)
    con = (MYSQL*)thread;
  else
    con = m_env->con();

  sprintf(query, "select "
                 "id,tablename,vid,oix,oname,aname,uptime,cretime,storagetime,"
                 "description,scantime,deadband,options "
                 "from objectitems where vid=%d and oix=%d and aname='%s'",
      oid.vid, oid.oix, attributename);

  int rc = mysql_query(con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(con));
    *sts = SEV__DBERROR;
    return 0;
  }

  MYSQL_ROW row;
  MYSQL_RES* result = mysql_store_result(con);
  if (!result) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s Result Error\n", __FUNCTION__);
    *sts = SEV__DBERROR;
    return 0;
  }
  int rows = mysql_num_rows(result);
  if (!rows) {
    mysql_free_result(result);
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s Row Error\n", __FUNCTION__);
    printf("%s: %s\n", __FUNCTION__, query);
    *sts = SEV__DBERROR;
    return 0;
  }
  row = mysql_fetch_row(result);
  if (!row) {
    mysql_free_result(result);
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s Row Error\n", __FUNCTION__);
    *sts = SEV__DBERROR;
    return 0;
  }

  int col = 0;
  item->id = atoi(row[col++]);
  strncpy(item->tablename, row[col++], sizeof(item->tablename));
  item->oid.vid = strtoul(row[col++], 0, 10);
  item->oid.oix = strtoul(row[col++], 0, 10);
  strncpy(item->oname, row[col++], sizeof(item->oname));
  col++; // No aname in sev_item TODO add aname to sev_item??
  timestr_to_time(row[col++], &item->modtime);
  timestr_to_time(row[col++], &item->creatime);
  item->storagetime.tv_sec = strtoul(row[col++], 0, 10);
  item->storagetime.tv_nsec = 0;
  strncpy(item->description, row[col++], sizeof(item->description));
  item->scantime = atof(row[col++]);
  item->deadband = atof(row[col++]);
  item->options = strtoul(row[col++], 0, 10);
  // Time to fetch all attributes for this item
  get_objectitemattributes(sts, item, item->tablename);

  item->attrnum = item->attr.size();

  mysql_free_result(result);

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbms::get_objectitems(pwr_tStatus* sts)
{
  char query[300];

  sprintf(query, "select "
                 "id,tablename,vid,oix,oname,aname,uptime,cretime,storagetime,"
                 "description,scantime,deadband,options "
                 "from objectitems");

  int rc = mysql_query(m_env->con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(m_env->con()));
    *sts = SEV__DBERROR;
    return 0;
  }

  MYSQL_ROW row;
  MYSQL_RES* result = mysql_store_result(m_env->con());
  if (!result) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s Result Error\n", __FUNCTION__);
    *sts = SEV__DBERROR;
    return 0;
  }
  int rows = mysql_num_rows(result);
  int col;
  for (int i = 0; i < rows; i++) {
    sev_item item;
    row = mysql_fetch_row(result);
    if (!row)
      break;

    // printf( "%d %s %s\n", i, row[0], row[1]);
    col = 0;
    item.id = atoi(row[col++]);
    strncpy(item.tablename, row[col++], sizeof(item.tablename));
    item.oid.vid = strtoul(row[col++], 0, 10);
    item.oid.oix = strtoul(row[col++], 0, 10);
    strncpy(item.oname, row[col++], sizeof(item.oname));
    col++; // No aname in sev_item TODO add aname to sev_item??
    timestr_to_time(row[col++], &item.modtime);
    timestr_to_time(row[col++], &item.creatime);
    item.storagetime.tv_sec = strtoul(row[col++], 0, 10);
    item.storagetime.tv_nsec = 0;
    strncpy(item.description, row[col++], sizeof(item.description));
    item.scantime = atof(row[col++]);
    item.deadband = atof(row[col++]);
    item.options = strtoul(row[col++], 0, 10);
    // Time to fetch all attributes for this item
    get_objectitemattributes(sts, &item, item.tablename);

    item.attrnum = item.attr.size();

    m_items.push_back(item);
  }
  mysql_free_result(result);

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbms::get_objectitemattributes(
    pwr_tStatus* sts, sev_item* item, char* tablename)
{
  char query[300];

  sprintf(query, "select attributename, attributetype, attributesize from "
                 "objectitemattributes where tablename='%s'order by "
                 "attributeidx asc",
      tablename);

  int rc = mysql_query(m_env->con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(m_env->con()));
    *sts = SEV__DBERROR;
    return 0;
  }

  MYSQL_ROW row;
  MYSQL_RES* result = mysql_store_result(m_env->con());
  if (!result) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: Result Error\n", __FUNCTION__);
    *sts = SEV__DBERROR;
    return 0;
  }
  int rows = mysql_num_rows(result);
  int col;
  for (int i = 0; i < rows; i++) {
    sev_attr attr;
    row = mysql_fetch_row(result);
    if (!row)
      break;
    col = 0;
    strncpy(attr.aname, row[col++], sizeof(attr.aname));
    attr.type = (pwr_eType)strtoul(row[col++], 0, 10);
    attr.size = strtoul(row[col++], 0, 10);
    attr.unit[0] = '\0'; // No unit present TODO add??
    item->value_size += attr.size;
    item->attr.push_back(attr);
  }
  mysql_free_result(result);

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbms::delete_old_objectdata(pwr_tStatus* sts, void* thread,
    char* tablename, pwr_tMask options, pwr_tTime limit, pwr_tFloat32 scantime,
    pwr_tFloat32 garbagecycle)
{
  char query[300];
  char timstr[40];
  MYSQL* con;

  if (thread)
    con = (MYSQL*)thread;
  else
    con = m_env->con();

  *sts = time_AtoAscii(
      &limit, time_eFormat_NumDateAndTime, timstr, sizeof(timstr));
  if (EVEN(*sts))
    return 0;
  timstr[19] = 0;

  if (options & pwr_mSevOptionsMask_ReadOptimized) {
    // We scan trough as many rows that we write between two garbage cycles plus
    // some extra rows
    // to be sure that the table not grows to much.
    pwr_tUInt64 nbRowsToClean = 86400 * 2; // default value
    if (scantime > 0.0)
      nbRowsToClean = (pwr_tUInt64)((garbagecycle / scantime) + 10000.0);

    nbRowsToClean
        += get_minFromIntegerColumn(thread, tablename, (char*)"sev__id");
    if (options & pwr_mSevOptionsMask_PosixTime)
      sprintf(query, "delete from %s where sev__id < " pwr_dFormatUInt64
                     " and sev__time < %ld;",
          tablename, nbRowsToClean, (long int)limit.tv_sec);
    else
      sprintf(query, "delete from %s where sev__id < " pwr_dFormatUInt64
                     " and sev__time < '%s';",
          tablename, nbRowsToClean, timstr);
  } else {
    if (options & pwr_mSevOptionsMask_PosixTime)
      sprintf(query, "delete from %s where sev__time < %ld;", tablename,
          (long int)limit.tv_sec);
    else
      sprintf(
          query, "delete from %s where sev__time < '%s';", tablename, timstr);
  }

  int rc = mysql_query(con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(con));
    *sts = SEV__DBERROR;
    return 0;
  }

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbms::check_deadband(pwr_eType type, unsigned int size,
    pwr_tFloat32 deadband, void* value, void* oldvalue)
{
  int deadband_active = 0;
  switch (type) {
  case pwr_eType_Float32:
    if (ABS(*(pwr_tFloat32*)value - *(pwr_tFloat32*)oldvalue) < deadband) {
      deadband_active = 1;
    }
    break;
  case pwr_eType_Float64:
    if (ABS(*(pwr_tFloat64*)value - *(pwr_tFloat64*)oldvalue) < deadband) {
      deadband_active = 1;
    }
    break;
  case pwr_eType_Int64:
    if (ABS(*(pwr_tInt64*)value - *(pwr_tInt64*)oldvalue) < deadband) {
      deadband_active = 1;
    }
    break;
  case pwr_eType_Int32:
    if (ABS(*(pwr_tInt32*)value - *(pwr_tInt32*)oldvalue) < deadband) {
      deadband_active = 1;
    }
    break;
  case pwr_eType_Int16:
    if (ABS(*(pwr_tInt16*)value - *(pwr_tInt16*)oldvalue) < deadband) {
      deadband_active = 1;
    }
    break;
  case pwr_eType_Int8:
  case pwr_eType_Char:
    if (ABS(*(pwr_tInt8*)value - *(pwr_tInt8*)oldvalue) < deadband) {
      deadband_active = 1;
    }
    break;
  case pwr_eType_UInt64:
    if (ABS(((pwr_tInt64)(*(pwr_tUInt64*)value - *(pwr_tUInt64*)oldvalue)))
        < deadband) {
      deadband_active = 1;
    }
    break;
  case pwr_eType_UInt32:
  case pwr_eType_Boolean:
    if (ABS(((pwr_tInt32)(*(pwr_tUInt32*)value - *(pwr_tUInt32*)oldvalue)))
        < deadband) {
      deadband_active = 1;
    }
    break;
  case pwr_eType_UInt16:
    if (ABS(((pwr_tInt16)(*(pwr_tUInt16*)value - *(pwr_tUInt16*)oldvalue)))
        < deadband) {
      deadband_active = 1;
    }
    break;
  case pwr_eType_UInt8:
    if (ABS(((pwr_tInt8)(*(pwr_tUInt8*)value - *(pwr_tUInt8*)oldvalue)))
        < deadband) {
      deadband_active = 1;
    }
    break;
  case pwr_eType_String:
  case pwr_eType_Text:
    if (!memcmp(value, oldvalue, size)) {
      deadband_active = 1;
    }
    break;
  default:;
  }
  return deadband_active;
}

int sev_dbms::get_closest_time(void* thread, char* tablename,
    unsigned int options, pwr_tTime* time, int before, unsigned int* id)
{
  char query[200];
  pwr_tStatus sts;
  char timstr[20];
  MYSQL* con;

  if (thread)
    con = (MYSQL*)thread;
  else
    con = m_env->con();

  sts = time_AtoAscii(
      time, time_eFormat_NumDateAndTime, timstr, sizeof(timstr));
  if (EVEN(sts))
    return sts;
  timstr[19] = 0;

  if (options & pwr_mSevOptionsMask_PosixTime) {
    if (before)
      sprintf(query,
          "select id from %s where time <= %ld order by time desc limit 1",
          tablename, (long int)time->tv_sec);
    else
      sprintf(query,
          "select id from %s where time >= %ld order by time asc limit 1",
          tablename, (long int)time->tv_sec);
  } else {
    if (before)
      sprintf(query,
          "select id from %s where time <= '%s' order by time desc limit 1",
          tablename, timstr);
    else
      sprintf(query,
          "select id from %s where time >= '%s' order by time asc limit 1",
          tablename, timstr);
  }

  int rc = mysql_query(con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s Query Error\n", __FUNCTION__);
    return SEV__DBERROR;
  }

  MYSQL_ROW row;
  MYSQL_RES* result = mysql_store_result(con);

  if (!result) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s Status Result Error\n", __FUNCTION__);
    return SEV__DBERROR;
  }

  row = mysql_fetch_row(result);
  if (!row) {
    mysql_free_result(result);
    *id = 0;
    return SEV__NOROWS;
  } else
    *id = strtoul(row[0], 0, 10);

  mysql_free_result(result);

  return 1;
}

int sev_dbms::get_id_value(void* thread, char* tablename,
			   unsigned int id, pwr_eType type, int size,
			   void *value)
{
  char query[200];
  MYSQL* con;

  if (thread)
    con = (MYSQL*)thread;
  else
    con = m_env->con();

  sprintf(query, "select value from %s where id = %d",
          tablename, id);
  int rc = mysql_query(con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s Query Error\n", __FUNCTION__);
    return SEV__DBERROR;
  }

  MYSQL_ROW row;
  MYSQL_RES* result = mysql_store_result(con);

  if (!result) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s Status Result Error\n", __FUNCTION__);
    return SEV__DBERROR;
  }

  row = mysql_fetch_row(result);
  if (!row) {
    mysql_free_result(result);
    return SEV__NOROWS;
  } else
    cdh_StringToAttrValue(type, row[0], value);

  mysql_free_result(result);

  return 1;
}

int sev_dbms::get_objectvalues(pwr_tStatus* sts, void* thread, sev_item* item,
    unsigned int size, pwr_tTime* starttime, pwr_tTime* endtime, int maxsize,
    pwr_tTime** tbuf, void** vbuf, unsigned int* bsize)
{
  char query[300];
  std::string queryStr;
  char starttimstr[40];
  char endtimstr[40];
  int total_rows = 0;
  int div;
  pwr_tDeltaTime dt;
  pwr_tTime stime, etime;
  std::string colsStr;
  char orderby_part[80];
  char jumpstr[40];
  char where_part[200];
  MYSQL* con;

  if (thread)
    con = (MYSQL*)thread;
  else
    con = m_env->con();

  if (starttime && starttime->tv_sec == 0 && starttime->tv_nsec == 0)
    starttime = 0;
  else
    stime = *starttime;

  if (endtime && endtime->tv_sec == 0 && endtime->tv_nsec == 0)
    endtime = 0;
  else
    etime = *endtime;

  // Get number of rows
  sprintf(query, "show table status where name = '%s';", item->tablename);

  int rc = mysql_query(con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s Query Error\n", __FUNCTION__);
    *sts = SEV__DBERROR;
    return 0;
  }

  MYSQL_ROW row;
  MYSQL_RES* result = mysql_store_result(con);

  if (!result) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s Status Result Error\n", __FUNCTION__);
    *sts = SEV__DBERROR;
    return 0;
  }

  row = mysql_fetch_row(result);
  if (!row) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s Status Result Error\n", __FUNCTION__);
    *sts = SEV__DBERROR;
    return 0;
  }
  if (item->options & pwr_mSevOptionsMask_Event) {
    total_rows = atoi(row[4]);
  } else if (item->options & pwr_mSevOptionsMask_UseDeadBand
      && item->options & pwr_mSevOptionsMask_DeadBandLinearRegr) {
    unsigned int startid;
    unsigned int endid;

    if (starttime) {
      // Get id for starttime
      *sts = get_closest_time(
          thread, item->tablename, item->options, starttime, 1, &startid);
    } else
      startid = 0;
    if (endtime) {
      // Get id for starttime
      *sts = get_closest_time(
          thread, item->tablename, item->options, endtime, 0, &endid);
    } else
      endid = strtoul(row[4], 0, 10);

    printf("startid %d, endid %d\n", startid, endid);
    div = (endid - startid + 1) / maxsize + 1;
  } else if (starttime && endtime) {
    pwr_tTime update_time;
    if (row[12])
      timestr_to_time(row[12], &update_time);

    if (time_Acomp(&item->creatime, &stime) == 1)
      stime = item->creatime;

    if (row[12] && time_Acomp(&etime, &update_time) == 1)
      etime = update_time;

    time_Adiff(&dt, &etime, &stime);
    total_rows = int(time_DToFloat(0, &dt) / item->scantime);

    div = total_rows / maxsize + 1;
  } else if (starttime) {
    pwr_tTime update_time;
    if (row[12])
      timestr_to_time(row[12], &update_time);
    else
      time_GetTime(&update_time);

    if (time_Acomp(&update_time, starttime) != 1) {
      mysql_free_result(result);
      *sts = SEV__NODATATIME;
      return 0;
    }
    time_Adiff(&dt, &update_time, starttime);
    total_rows = int(time_DToFloat(0, &dt) / item->scantime);
  } else if (endtime) {
    pwr_tTime create_time;
    timestr_to_time(row[11], &create_time);

    if (time_Acomp(endtime, &create_time) != 1) {
      mysql_free_result(result);
      *sts = SEV__NODATATIME;
      return 0;
    }
    time_Adiff(&dt, endtime, &create_time);
    total_rows = int(time_DToFloat(0, &dt) / item->scantime);
  } else {
    total_rows = atoi(row[4]);
  }
  mysql_free_result(result);

  div = total_rows / maxsize + 1;

  if (starttime) {
    *sts = time_AtoAscii(
        &stime, time_eFormat_NumDateAndTime, starttimstr, sizeof(starttimstr));
    if (EVEN(*sts))
      return 0;
    starttimstr[19] = 0;
  }
  if (endtime) {
    *sts = time_AtoAscii(
        &etime, time_eFormat_NumDateAndTime, endtimstr, sizeof(endtimstr));
    if (EVEN(*sts))
      return 0;
    endtimstr[19] = 0;
  }

  // Column part
  if (item->options & pwr_mSevOptionsMask_HighTimeResolution) {
    colsStr.append("sev__time, sev__ntime, ");
  } else {
    colsStr.append("sev__time, ");
  }
  char colNameStr[80];
  for (size_t i = 0; i < item->attr.size(); i++) {
    sprintf(colNameStr, "`%s`,", create_colName(i, item->attr[i].aname));
    colsStr.append(colNameStr);
  }
  // remove last ,
  colsStr.resize(colsStr.length() - 1);

  if (item->options & pwr_mSevOptionsMask_UseDeadBand)
    strcpy(jumpstr, "or sev__jump = 1");
  else
    strcpy(jumpstr, "");

  // 'order by' part
  if (item->options & pwr_mSevOptionsMask_ReadOptimized)
    strcpy(orderby_part, "sev__id");
  else {
    if (item->options & pwr_mSevOptionsMask_HighTimeResolution)
      strcpy(orderby_part, "sev__time,sev__ntime");
    else
      strcpy(orderby_part, "sev__time");
  }

  // 'where' part
  if (item->options & pwr_mSevOptionsMask_ReadOptimized) {
    if (starttime && endtime) {
      if (div == 1) {
        if (item->options & pwr_mSevOptionsMask_PosixTime)
          sprintf(where_part, "where sev__time >= %ld and sev__time <= %ld",
              (long int)starttime->tv_sec, (long int)endtime->tv_sec);
        else
          sprintf(where_part, "where sev__time >= '%s' and sev__time <= '%s'",
              starttimstr, endtimstr);
      } else {
        if (item->options & pwr_mSevOptionsMask_PosixTime)
          sprintf(where_part, "where (sev__id %% %d = 0 %s) and sev__time >= "
                              "%ld and sev__time <= %ld",
              div, jumpstr, (long int)starttime->tv_sec,
              (long int)endtime->tv_sec);
        else
          sprintf(where_part, "where (sev__id %% %d = 0 %s) and sev__time >= "
                              "'%s' and sev__time <= '%s'",
              div, jumpstr, starttimstr, endtimstr);
      }
    } else if (starttime) {
      if (div == 1) {
        if (item->options & pwr_mSevOptionsMask_PosixTime)
          sprintf(where_part, "where sev__time >= %ld",
              (long int)starttime->tv_sec);
        else
          sprintf(where_part, "where sev__time >= '%s'", starttimstr);
      } else {
        if (item->options & pwr_mSevOptionsMask_PosixTime)
          sprintf(where_part,
              "where (sev__id %% %d = 0 %s) and sev__time >= %ld", div, jumpstr,
              (long int)starttime->tv_sec);
        else
          sprintf(where_part,
              "where (sev__id %% %d = 0 %s) and sev__time >= '%s'", div,
              jumpstr, starttimstr);
      }
    } else if (endtime) {
      if (div == 1) {
        if (item->options & pwr_mSevOptionsMask_PosixTime)
          sprintf(
              where_part, "where sev__time <= %ld", (long int)endtime->tv_sec);
        else
          sprintf(where_part, "where sev__time <= '%s'", endtimstr);
      } else {
        if (item->options & pwr_mSevOptionsMask_PosixTime)
          sprintf(where_part,
              "where (sev__id %% %d = 0 %s) and sev__time <= %ld", div, jumpstr,
              (long int)endtime->tv_sec);
        else
          sprintf(where_part,
              "where (sev__id %% %d = 0 %s) and sev__time <= '%s'", div,
              jumpstr, endtimstr);
      }
    } else {
      if (div == 1)
        strcpy(where_part, "");
      else
        sprintf(where_part, "where sev__id %% %d = 0 %s", div, jumpstr);
    }
  } else {
    // Not read optimized
    if (starttime && endtime) {
      if (item->options & pwr_mSevOptionsMask_PosixTime)
        sprintf(where_part, "where sev__time >= %ld and sev__time <= %ld",
            (long int)starttime->tv_sec, (long int)endtime->tv_sec);
      else
        sprintf(where_part, "where sev__time >= '%s' and sev__time <= '%s'",
            starttimstr, endtimstr);
    } else if (starttime) {
      if (item->options & pwr_mSevOptionsMask_PosixTime)
        sprintf(
            where_part, "where sev__time >= %ld", (long int)starttime->tv_sec);
      else
        sprintf(where_part, "where sev__time >= '%s'", starttimstr);
    } else if (endtime) {
      if (item->options & pwr_mSevOptionsMask_PosixTime)
        sprintf(
            where_part, "where sev__time <= %ld", (long int)endtime->tv_sec);
      else
        sprintf(where_part, "where sev__time <= '%s'", endtimstr);
    } else
      strcpy(where_part, "");
  }

  queryStr.append("select ");
  queryStr.append(colsStr);
  queryStr.append(" from ");
  queryStr.append(item->tablename);
  queryStr.append(" ");
  queryStr.append(where_part);
  queryStr.append(" order by ");
  queryStr.append(orderby_part);

  rc = mysql_query(con, queryStr.c_str());
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(con));
    *sts = SEV__DBERROR;
    return 0;
  }

  result = mysql_store_result(con);
  if (!result) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s Result Error\n", __FUNCTION__);
    *sts = SEV__DBERROR;
    return 0;
  }

  int rows = mysql_num_rows(result);
  int bufrows = rows;

  if (item->options & pwr_mSevOptionsMask_ReadOptimized) {
    *tbuf = (pwr_tTime*)calloc(bufrows, sizeof(pwr_tTime));
    *vbuf = calloc(bufrows, item->value_size);

    int bcnt = 0;
    for (int i = 0; i < rows; i++) {
      int j = 0;

      // if ( div > 1)
      //   mysql_data_seek( result, i);

      row = mysql_fetch_row(result);
      if (!row)
        break;

      if (item->options & pwr_mSevOptionsMask_PosixTime) {
        if (item->options & pwr_mSevOptionsMask_HighTimeResolution) {
          // Posix time, high resolution
          (*tbuf)[bcnt].tv_sec = strtoul(row[j++], 0, 10);
          (*tbuf)[bcnt].tv_nsec = strtoul(row[j++], 0, 10);
        } else
          // Posix time, low resolution
          (*tbuf)[bcnt].tv_sec = strtoul(row[j++], 0, 10);
      } else {
        if (item->options & pwr_mSevOptionsMask_HighTimeResolution) {
          // Sql time, high resolution
          timestr_to_time(row[j++], &(*tbuf)[bcnt]);
          (*tbuf)[bcnt].tv_nsec = strtoul(row[j++], 0, 10);
        } else
          // Sql time, low resolution
          timestr_to_time(row[j++], &(*tbuf)[bcnt]);
      }
      int read_size = 0;
      for (size_t k = 0; k < item->attr.size(); k++) {
        if (row[j] == 0) {
          // Null value
          switch (item->attr[k].type) {
          case pwr_eType_Float32:
          case pwr_eType_Float64:
          case pwr_eType_Int8:
          case pwr_eType_Int16:
          case pwr_eType_Int32:
          case pwr_eType_Int64:
          case pwr_eType_UInt8:
          case pwr_eType_UInt16:
          case pwr_eType_UInt32:
          case pwr_eType_UInt64:
          case pwr_eType_Mask:
          case pwr_eType_Enum:
            cdh_StringToAttrValue(item->attr[k].type, "0",
                ((char*)*vbuf) + bcnt * item->value_size + read_size);
            break;
          case pwr_eType_Time:
          case pwr_eType_DeltaTime:
            // TODO deltatime??
            cdh_StringToAttrValue(item->attr[k].type, "1970-01-01 00:00:00",
                ((char*)*vbuf) + bcnt * item->value_size + read_size);
            break;
          default:
            cdh_StringToAttrValue(item->attr[k].type, " ",
                ((char*)*vbuf) + bcnt * item->value_size + read_size);
            break;
          }
          j++;
        } else {
          cdh_StringToAttrValue(item->attr[k].type, row[j++],
              ((char*)*vbuf) + bcnt * item->value_size + read_size);
        }
        read_size += item->attr[k].size;
      }
      bcnt++;
      // if ( item->options & pwr_mSevOptionsMask_HighTimeResolution)
      //  printf( "%5d %5d %s.%9s %s\n", i, bcnt, row[0], row[1], row[2]);
      // else
      //  printf( "%5d %5d %s %s\n", i, bcnt, row[0], row[1]);
    }
    printf("bcnt %d bufrows %d\n", bcnt, bufrows);
    *bsize = bcnt;
    mysql_free_result(result);
  } else {
    *tbuf = (pwr_tTime*)calloc(bufrows, sizeof(pwr_tTime));
    *vbuf = calloc(bufrows, size);

    int bcnt = 0;
    for (int i = 0; i < rows; i += div) {
      int j = 0;

      if (div > 1)
        mysql_data_seek(result, i);

      row = mysql_fetch_row(result);
      if (!row)
        break;

      if (item->options & pwr_mSevOptionsMask_PosixTime) {
        if (item->options & pwr_mSevOptionsMask_HighTimeResolution) {
          // Posix time, high resolution
          (*tbuf)[bcnt].tv_sec = strtoul(row[j++], 0, 10);
          (*tbuf)[bcnt].tv_nsec = strtoul(row[j++], 0, 10);
        } else
          // Posix time, low resolution
          (*tbuf)[bcnt].tv_sec = strtoul(row[j++], 0, 10);
      } else {
        if (item->options & pwr_mSevOptionsMask_HighTimeResolution) {
          // Sql time, high resolution
          timestr_to_time(row[j++], &(*tbuf)[bcnt]);
          (*tbuf)[bcnt].tv_nsec = strtoul(row[j++], 0, 10);
        } else
          // Sql time, low resolution
          timestr_to_time(row[j++], &(*tbuf)[bcnt]);
      }

      int read_size = 0;
      for (size_t k = 0; k < item->attr.size(); k++) {
        if (row[j] == 0) {
          // Null value
          switch (item->attr[k].type) {
          case pwr_eType_Float32:
          case pwr_eType_Float64:
          case pwr_eType_Int8:
          case pwr_eType_Int16:
          case pwr_eType_Int32:
          case pwr_eType_Int64:
          case pwr_eType_UInt8:
          case pwr_eType_UInt16:
          case pwr_eType_UInt32:
          case pwr_eType_UInt64:
          case pwr_eType_Mask:
          case pwr_eType_Enum:
            cdh_StringToAttrValue(item->attr[k].type, "0",
                ((char*)*vbuf) + bcnt * item->value_size + read_size);
            break;
          case pwr_eType_Time:
          case pwr_eType_DeltaTime:
            // TODO deltatime??
            cdh_StringToAttrValue(item->attr[k].type, "1970-01-01 00:00:00",
                ((char*)*vbuf) + bcnt * item->value_size + read_size);
            break;
          default:
            cdh_StringToAttrValue(item->attr[k].type, " ",
                ((char*)*vbuf) + bcnt * item->value_size + read_size);
            break;
          }
          j++;
        } else {
          cdh_StringToAttrValue(item->attr[k].type, row[j++],
              ((char*)*vbuf) + bcnt * item->value_size + read_size);
        }
        read_size += item->attr[k].size;
      }
      bcnt++;
      // if ( item->options & pwr_mSevOptionsMask_HighTimeResolution)
      //  printf( "%5d %5d %s.%9s %s\n", i, bcnt, row[0], row[1], row[2]);
      // else
      //  printf( "%5d %5d %s %s\n", i, bcnt, row[0], row[1]);
    }
    printf("bcnt %d bufrows %d\n", bcnt, bufrows);
    *bsize = bcnt;
    mysql_free_result(result);
  }

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbms::handle_itemchange(
    pwr_tStatus* sts, char* tablename, unsigned int item_idx)
{
  char timestr[40];
  pwr_tTime uptime;

  time_GetTime(&uptime);
  time_AtoAscii(&uptime, time_eFormat_NumDateAndTime, timestr, sizeof(timestr));
  timestr[19] = 0;

  // Replace ':' '-' and ' ' in timestr with '_'
  for (char* s = timestr; *s; s++) {
    if (*s == ':')
      *s = '_';
    if (*s == ' ')
      *s = '_';
    if (*s == '-')
      *s = '_';
  }

  char newTableName[64];
  snprintf(newTableName, sizeof(newTableName), "%s_%s", tablename, timestr);

  printf("Recreating table %s due to attribute definition changes, old table "
         "saved to %s \n",
      tablename, newTableName);
  errh_Warning("Recreating table %s due to attribute definition changes, old "
               "table saved to %s",
      tablename, newTableName);

  char query[600];
  sprintf(query, "RENAME TABLE %s to %s", tablename, newTableName);
  int rc = mysql_query(m_env->con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(m_env->con()));
    *sts = SEV__DBERROR;
    return 0;
  }

  sev_item* item = &m_items[item_idx];

  create_table(sts, item->tablename, item->attr[0].type, item->attr[0].size,
      item->options, item->deadband);
  if (EVEN(*sts))
    return 0;

  if (item->options & pwr_mSevOptionsMask_ReadOptimized) {
    // If we set increment to same value as in the old table we can easily move
    // the data from the old table to the new one
    pwr_tUInt64 autoIncrValue
        = get_maxFromIntegerColumn(0, newTableName, (char*)"id");
    if (autoIncrValue)
      autoIncrValue++;
    sprintf(query, "ALTER TABLE %s AUTO_INCREMENT = " pwr_dFormatUInt64,
        tablename, autoIncrValue);
    rc = mysql_query(m_env->con(), query);
    if (rc) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("%s: %s\n", __FUNCTION__, mysql_error(m_env->con()));
      *sts = SEV__DBERROR;
      return 0;
    }
  }

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbms::handle_objectchange(
    pwr_tStatus* sts, char* tablename, unsigned int item_idx, bool newObject)
{
  char newTableName[64];
  char query[600];
  int rc;

  sev_item* item = &m_items[item_idx];

  if (!newObject) {
    char timestr[40];
    pwr_tTime uptime;

    time_GetTime(&uptime);
    time_AtoAscii(
        &uptime, time_eFormat_NumDateAndTime, timestr, sizeof(timestr));
    timestr[19] = 0;

    // Replace ':' '-' and ' ' in timestr with '_'
    for (char* s = timestr; *s; s++) {
      if (*s == ':')
        *s = '_';
      if (*s == ' ')
        *s = '_';
      if (*s == '-')
        *s = '_';
    }

    snprintf(newTableName, sizeof(newTableName), "%s_%s", tablename, timestr);

    printf("Recreating table %s due to attribute definition changes, old table "
           "saved to %s \n",
        tablename, newTableName);
    errh_Warning("Recreating table %s due to attribute definition changes, old "
                 "table saved to %s",
        tablename, newTableName);

    sprintf(query, "RENAME TABLE %s to %s", tablename, newTableName);
    rc = mysql_query(m_env->con(), query);
    if (rc) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("%s: %s\n", __FUNCTION__, mysql_error(m_env->con()));
      *sts = SEV__DBERROR;
      return 0;
    }

    create_objecttable(sts, tablename, item->options, item->deadband);
    if (EVEN(*sts))
      return 0;

    if (item->options & pwr_mSevOptionsMask_ReadOptimized) {
      // If we set increment to same value as in the old table we can easily
      // move the data from the old table to the new one
      pwr_tUInt64 autoIncrValue
          = get_maxFromIntegerColumn(0, newTableName, (char*)"sev__id");
      if (autoIncrValue)
        autoIncrValue++;
      sprintf(query, "ALTER TABLE %s AUTO_INCREMENT = " pwr_dFormatUInt64,
          tablename, autoIncrValue);
      rc = mysql_query(m_env->con(), query);
      if (rc) {
        printf("In %s row %d:\n", __FILE__, __LINE__);
        printf("%s: %s\n", __FUNCTION__, mysql_error(m_env->con()));
        *sts = SEV__DBERROR;
        return 0;
      }
    }

    sprintf(query, "delete from objectitemattributes where tablename = '%s'",
        tablename);
    rc = mysql_query(m_env->con(), query);
    if (rc) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("%s: %s\n", __FUNCTION__, mysql_error(m_env->con()));
      *sts = SEV__DBERROR;
      return 0;
    }
  }

  for (size_t i = 0; i < item->attr.size(); i++) {
    char colName[64];
    strncpy(colName, create_colName(i, item->attr[i].aname), sizeof(colName));
    // sprintf(colName, "col_%d", i);
    sprintf(query, "alter table %s add `%s` %s;", tablename, colName,
        pwrtype_to_type(item->attr[i].type, item->attr[i].size));
    rc = mysql_query(m_env->con(), query);
    if (rc) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("%s: %s\n", __FUNCTION__, mysql_error(m_env->con()));
      *sts = SEV__DBERROR;
      return 0;
    }
    int aidx = i;
    sprintf(query, "insert into objectitemattributes (tablename, "
                   "attributename, attributeidx, attributetype, attributesize) "
                   "values('%s', '%s', %d, %d, %d)",
        tablename, item->attr[i].aname, aidx, item->attr[i].type,
        item->attr[i].size);
    rc = mysql_query(m_env->con(), query);
    if (rc) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("%s: %s\n", __FUNCTION__, mysql_error(m_env->con()));
      *sts = SEV__DBERROR;
      return 0;
    }
  }
  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbms::get_events(pwr_tStatus *sts, void *thread, pwr_tOid oid,
			 pwr_tMask options, pwr_tMask eventtypemask,
			 pwr_tMask eventpriomask, char *eventtext, char *eventname,
			 pwr_tTime *starttime, pwr_tTime *endtime, unsigned int numevents,
			 std::vector<sev_event> &list)
{
  sev_item item;
  get_item(sts, thread, &item, oid, (char *)"Events");
  if (EVEN(*sts)) {
    return 0;
  }

  char query[1300];
  char starttimstr[40];
  char endtimstr[40];
  pwr_tTime stime, etime;
  char column_part[200];
  char orderby_part[80];
  char limit_part[80];
  char where_part[600];
  int rows = 0;
  MYSQL* con;

  if (thread)
    con = (MYSQL*)thread;
  else
    con = m_env->con();

  if (starttime && starttime->tv_sec == 0 && starttime->tv_nsec == 0)
    starttime = 0;
  else
    stime = *starttime;

  if (endtime && endtime->tv_sec == 0 && endtime->tv_nsec == 0)
    endtime = 0;
  else
    etime = *endtime;

  // Get number of rows
  sprintf(query, "show table status where name = '%s';", item.tablename);

  int rc = mysql_query(con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("GetEvents Query Error\n");
    *sts = SEV__DBERROR;
    return 0;
  }

  MYSQL_ROW row;
  MYSQL_RES* result = mysql_store_result(con);

  if (!result) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("GetValues Status Result Error\n");
    *sts = SEV__DBERROR;
    return 0;
  }

  row = mysql_fetch_row(result);
  if (!row) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("GetValues Status Result Error\n");
    *sts = SEV__DBERROR;
    return 0;
  }
  mysql_free_result(result);

  if (starttime) {
    *sts = time_AtoAscii(
        &stime, time_eFormat_NumDateAndTime, starttimstr, sizeof(starttimstr));
    if (EVEN(*sts))
      return 0;
    starttimstr[19] = 0;
  }
  if (endtime) {
    *sts = time_AtoAscii(
        &etime, time_eFormat_NumDateAndTime, endtimstr, sizeof(endtimstr));
    if (EVEN(*sts))
      return 0;
    endtimstr[19] = 0;
  }

  // Column part
  if (options & pwr_mSevOptionsMask_HighTimeResolution)
    strcpy(column_part, "time,ntime,eventtype,eventprio,eventid_nix,eventid_birthtime,"
	   "eventid_idx,supobject_vid,supobject_oix,supobject_offset,supobject_size,eventtext,"
	   "eventname,eventstatus");
  else
    strcpy(column_part, "time,eventtype,eventprio,eventid_nix,eventid_birthtime,"
	   "eventid_idx,supobject_vid,supobject_oix,supobject_offset,supobject_size,eventtext,"
	   "eventname,eventstatus");

  // 'order by' part
  if (options & pwr_mSevOptionsMask_HighTimeResolution)
    strcpy(orderby_part, "time,ntime");
  else
    strcpy(orderby_part, "time");

  // 'where' part
  // Not read optimized
  if (starttime && endtime) {
    if (options & pwr_mSevOptionsMask_PosixTime)
      sprintf(where_part, "where time >= %ld and time <= %ld",
              (long int)starttime->tv_sec, (long int)endtime->tv_sec);
    else
      sprintf(where_part, "where time >= '%s' and time <= '%s'",
              starttimstr, endtimstr);
  } else if (starttime) {
    if (options & pwr_mSevOptionsMask_PosixTime)
      sprintf(where_part, "where time >= %ld", (long int)starttime->tv_sec);
    else
      sprintf(where_part, "where time >= '%s'", starttimstr);
  } else if (endtime) {
    if (options & pwr_mSevOptionsMask_PosixTime)
      sprintf(where_part, "where time <= %ld", (long int)endtime->tv_sec);
    else
      sprintf(where_part, "where time <= '%s'", endtimstr);
  } else
    strcpy(where_part, "");

  if (eventtypemask) {
    bool first = true;
    sprintf(&where_part[strlen(where_part)], " and (");
    if (eventtypemask & sev_mEventType_Ack) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventtype = %d", mh_eEvent_Ack);
      first = false;
    }
    if (eventtypemask & sev_mEventType_Block) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventtype = %d", mh_eEvent_Block);
      first = false;
    }
    if (eventtypemask & sev_mEventType_Cancel) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventtype = %d", mh_eEvent_Cancel);
      first = false;
    }
    if (eventtypemask & sev_mEventType_CancelBlock) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventtype = %d", mh_eEvent_CancelBlock);
      first = false;
    }
    if (eventtypemask & sev_mEventType_Missing) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventtype = %d", mh_eEvent_Missing);
      first = false;
    }
    if (eventtypemask & sev_mEventType_Reblock) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventtype = %d", mh_eEvent_Reblock);
      first = false;
    }
    if (eventtypemask & sev_mEventType_Return) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventtype = %d", mh_eEvent_Return);
      first = false;
    }
    if (eventtypemask & sev_mEventType_Unblock) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventtype = %d", mh_eEvent_Unblock);
      first = false;
    }
    if (eventtypemask & sev_mEventType_InfoSuccess) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventtype = %d", mh_eEvent_InfoSuccess);
      first = false;
    }
    if (eventtypemask & sev_mEventType_Alarm) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventtype = %d", mh_eEvent_Alarm);
      first = false;
    }
    if (eventtypemask & sev_mEventType_MaintenanceAlarm) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventtype = %d", mh_eEvent_MaintenanceAlarm);
      first = false;
    }
    if (eventtypemask & sev_mEventType_SystemAlarm) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventtype = %d", mh_eEvent_SystemAlarm);
      first = false;
    }
    if (eventtypemask & sev_mEventType_UserAlarm1) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventtype = %d", mh_eEvent_UserAlarm1);
      first = false;
    }
    if (eventtypemask & sev_mEventType_UserAlarm2) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventtype = %d", mh_eEvent_UserAlarm2);
      first = false;
    }
    if (eventtypemask & sev_mEventType_UserAlarm3) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventtype = %d", mh_eEvent_UserAlarm3);
      first = false;
    }
    if (eventtypemask & sev_mEventType_UserAlarm4) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventtype = %d", mh_eEvent_UserAlarm4);
      first = false;
    }
    if (eventtypemask & sev_mEventType_Info) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventtype = %d", mh_eEvent_Info);
      first = false;
    }
    sprintf(&where_part[strlen(where_part)], ")");
  }

  if (eventpriomask) {
    bool first = true;
    sprintf(&where_part[strlen(where_part)], " and (");
    if (eventpriomask & sev_mEventPrio_A) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventprio = %d", mh_eEventPrio_A);
      first = false;
    }
    if (eventpriomask & sev_mEventPrio_B) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventprio = %d", mh_eEventPrio_B);
      first = false;
    }
    if (eventpriomask & sev_mEventPrio_C) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventprio = %d", mh_eEventPrio_C);
      first = false;
    }
    if (eventpriomask & sev_mEventPrio_D) {
      if (!first)
	sprintf(&where_part[strlen(where_part)], " or ");
      sprintf(&where_part[strlen(where_part)], "eventprio = %d", mh_eEventPrio_C);
      first = false;
    }
    sprintf(&where_part[strlen(where_part)], ")");
  }

  if (!streq(eventtext, ""))
    sprintf(&where_part[strlen(where_part)], " and eventtext regexp '%s'", eventtext);
  if (!streq(eventname, ""))
    sprintf(&where_part[strlen(where_part)], " and eventname regexp '%s'", eventname);

  if (numevents)
    sprintf(limit_part, "limit %d", numevents);
  else
    strcpy(limit_part, "");

  sprintf(query, "select %s from %s %s order by %s %s", column_part,
          item.tablename, where_part, orderby_part, limit_part);

  rc = mysql_query(con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Get Events: %s\n", mysql_error(con));
    *sts = SEV__DBERROR;
    return 0;
  }

  result = mysql_store_result(con);
  if (!result) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("GetEvents Result Error\n");
    *sts = SEV__DBERROR;
    return 0;
  }
  rows = mysql_num_rows(result);


  for (int i = 0; i < rows; i++) {
    sev_event e;
    int j = 0;

    row = mysql_fetch_row(result);
    if (!row)
      break;

    if (options & pwr_mSevOptionsMask_PosixTime) {
      if (options & pwr_mSevOptionsMask_HighTimeResolution) {
	// Posix time, high resolution
	e.time.tv_sec = strtoul(row[j++], 0, 10);
	e.time.tv_nsec = strtoul(row[j++], 0, 10);
      } else
	// Posix time, low resolution
        e.time.tv_sec = strtoul(row[j++], 0, 10);
    } else {
      if (options & pwr_mSevOptionsMask_HighTimeResolution) {
	// Sql time, high resolution
	timestr_to_time(row[j++], &e.time);
	e.time.tv_nsec = strtoul(row[j++], 0, 10);
      } else
	// Sql time, low resolution
	timestr_to_time(row[j++], &e.time);
    }
    e.type = strtoul(row[j++], 0, 10);
    e.eventprio = strtoul(row[j++], 0, 10);
    e.eventid.Nix = strtoul(row[j++], 0, 10);
    e.eventid.BirthTime.tv_sec = strtoul(row[j++], 0, 10);
    e.eventid.Idx = strtoul(row[j++], 0, 10);
    e.supobject.Objid.vid = strtoul(row[j++], 0, 10);
    e.supobject.Objid.oix = strtoul(row[j++], 0, 10);
    e.supobject.Offset = strtoul(row[j++], 0, 10);
    e.supobject.Size = strtoul(row[j++], 0, 10);
    strncpy(e.eventtext, row[j++], sizeof(e.eventtext));
    strncpy(e.eventname, row[j++], sizeof(e.eventname));
    e.eventstatus = strtoul(row[j++], 0, 10);
    list.push_back(e);
  }

  mysql_free_result(result);
  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbms::repair_table(pwr_tStatus* sts, char* tablename)
{
  char query[200];
  int rc;
  int repair_table;
  int repair_failed;

  // Check table
  printf("-- Checking table %s...\n", tablename);

  sprintf(query, "check table %s", tablename);
  rc = mysql_query(m_env->con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(m_env->con()));
    *sts = SEV__DBERROR;
    return 0;
  } else {
    MYSQL_ROW row = NULL;
    MYSQL_RES* result = mysql_store_result(m_env->con());

    if (!result) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("%s Status Result Error\n", __FUNCTION__);
      *sts = SEV__DBERROR;
      return 0;
    }

    int rows = mysql_num_rows(result);

    for (int i = 0; i < rows; i++) {
      row = mysql_fetch_row(result);
      if (!row)
        break;

      printf("-- Check result '%s %s %s %s'\n", row[0], row[1], row[2], row[3]);
    }
    if (str_NoCaseStrcmp(row[3], "ok") == 0)
      repair_table = 0;
    else
      repair_table = 1;

    mysql_free_result(result);
  }

  if (!repair_table) {
    *sts = SEV__SUCCESS;
    return *sts;
  }

  // Repair table
  printf("-- Repairing %s...\n", tablename);

  sprintf(query, "repair table %s", tablename);
  rc = mysql_query(m_env->con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(m_env->con()));
    *sts = SEV__DBERROR;
    return 0;
  } else {
    MYSQL_ROW row = NULL;
    MYSQL_RES* result = mysql_store_result(m_env->con());

    if (!result) {
      printf("In %s row %d:\n", __FILE__, __LINE__);
      printf("%s Status Result Error\n", __FUNCTION__);
      *sts = SEV__DBERROR;
      return 0;
    }

    int rows = mysql_num_rows(result);

    for (int i = 0; i < rows; i++) {
      row = mysql_fetch_row(result);
      if (!row)
        break;

      printf(
          "-- Repair result '%s %s %s %s'\n", row[0], row[1], row[2], row[3]);
    }
    if (str_NoCaseStrcmp(row[3], "ok") != 0) {
      printf("** Error, repair failure %s\n", row[0]);
      repair_failed = 1;
    } else
      repair_failed = 0;

    mysql_free_result(result);
  }

  if (repair_failed)
    *sts = SEV__REPAIR_FAILED;
  else
    *sts = SEV__SUCCESS;

  return ODD(*sts);
}

int sev_dbms::alter_engine(pwr_tStatus* sts, char* tablename)
{
  char query[200];
  int rc;

  if (streq(m_cnf.Engine, "")) {
    printf("** No engine specified in /etc/proview.cnf\n");
    return 0;
  }

  // Check table
  printf("-- Altering engine to %s table %s...\n", m_cnf.Engine, tablename);

  sprintf(query, "alter table %s engine=%s", tablename, m_cnf.Engine);
  rc = mysql_query(m_env->con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(m_env->con()));
    *sts = SEV__DBERROR;
    return 0;
  }

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbms::optimize(pwr_tStatus* sts, char* tablename)
{
  char query[200];
  int rc;

  sprintf(query, "optimize table %s", tablename);
  rc = mysql_query(m_env->con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("%s: %s\n", __FUNCTION__, mysql_error(m_env->con()));
    *sts = SEV__DBERROR;
    return 0;
  }
  MYSQL_RES* result = mysql_store_result(m_env->con());
  mysql_free_result(result);

  *sts = SEV__SUCCESS;
  return 1;
}

int sev_dbms::store_stat(sev_sStat* stat)
{
  char query[250];
  int rc;

  sprintf(query, "update sev_stat set current_load = %f,medium_load = %f,"
                 "storage_rate=%f,medium_storage_rate=%f,datastore_msg_cnt=%d,"
                 "dataget_msg_cnt=%d,items_msg_cnt=%d,eventstore_msg_cnt=%d",
      stat->current_load, stat->medium_load, stat->storage_rate,
      stat->medium_storage_rate, stat->datastore_msg_cnt, stat->dataget_msg_cnt,
      stat->items_msg_cnt, stat->eventstore_msg_cnt);
  rc = mysql_query(m_env->con(), query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Update sev_stat: %s\n", mysql_error(m_env->con()));
    return 0;
  }
  return 1;
}

void sev_dbms::write_db_cb(
    void* data, int idx, void* value, pwr_tTime* time, void* thread)
{
  pwr_tStatus sts;
  sev_dbms* dbms = (sev_dbms*)data;

  switch (dbms->m_items[idx].attr[0].type) {
  case pwr_eType_Float32: {
    pwr_tFloat32 v = *(double*)value;
    dbms->write_value(&sts, idx, 0, *time, &v, sizeof(v), thread);
    break;
  }
  case pwr_eType_Float64: {
    pwr_tFloat64 v = *(double*)value;
    dbms->write_value(&sts, idx, 0, *time, &v, sizeof(v), thread);
    break;
  }
  case pwr_eType_Int32: {
    pwr_tInt32 v = *(double*)value;
    dbms->write_value(&sts, idx, 0, *time, &v, sizeof(v), thread);
    break;
  }
  case pwr_eType_Boolean: {
    pwr_tBoolean v = *(pwr_tBoolean*)value;
    dbms->write_value(&sts, idx, 0, *time, &v, sizeof(v), thread);
    break;
  }
  default:;
  }
}

void sev_dbms::add_cache(int item_idx)
{
  switch (m_items[item_idx].attr[0].type) {
  case pwr_eType_Float32:
  case pwr_eType_Float64:
  case pwr_eType_Int32:
    if (m_items[item_idx].options & pwr_mSevOptionsMask_DeadBandMeanValue)
      m_items[item_idx].cache = new sev_valuecache_double(sev_eCvType_Mean,
          m_items[item_idx].deadband, m_items[item_idx].scantime / 2);
    else
      m_items[item_idx].cache = new sev_valuecache_double(sev_eCvType_Point,
          m_items[item_idx].deadband, m_items[item_idx].scantime / 2);
    m_items[item_idx].cache->set_write_cb(write_db_cb, this, item_idx);
    break;
  case pwr_eType_Boolean:
    m_items[item_idx].cache = new sev_valuecache_bool(sev_eCvType_Point);
    m_items[item_idx].cache->set_write_cb(write_db_cb, this, item_idx);
    break;
  default:;
  }
}

int sev_dbms::begin_transaction(void* thread)
{
  char query[20];
  int rc;
  MYSQL* con;

  if (thread)
    con = (MYSQL*)thread;
  else
    con = m_env->con();

  strcpy(query, "start transaction");
  rc = mysql_query(con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Begin transaction: %s\n", mysql_error(con));
    if ( con->net.last_errno == CR_SERVER_GONE_ERROR)
      return SEV__NOCONNECTION;
    return SEV__DBERROR;
  }
  return 1;
}

int sev_dbms::commit_transaction(void* thread)
{
  char query[20];
  int rc;
  MYSQL* con;

  if (thread)
    con = (MYSQL*)thread;
  else
    con = m_env->con();

  strcpy(query, "commit");
  rc = mysql_query(con, query);
  if (rc) {
    printf("In %s row %d:\n", __FILE__, __LINE__);
    printf("Commit transaction: %s\n", mysql_error(con));
    if ( con->net.last_errno == CR_SERVER_GONE_ERROR)
      return SEV__NOCONNECTION;
    return SEV__DBERROR;
  }
  return 1;
}

void sev_dbms::string_to_mysqlstring(char* in, char* out, int size)
{
  char *s, *t;

  for (s = in, t = out; *s; s++, t++) {
    if (*s == '\"' || *s == '\'') {
      *t = '\\';
      t++;
    }
    *t = *s;
    if (t - out >= size - 1)
      break;
  }
  *t = 0;
}

void sev_dbms::mysqlstring_to_string(char* in, char* out, int size)
{
  char *s, *t;

  for (s = in, t = out; *s; s++, t++) {
    if (*s == '\\' && (*(s + 1) == '\"' || *(s + 1) == '\''))
      s++;
    *t = *s;
    if (t - out >= size - 1)
      break;
  }
  *t = 0;
}

void* sev_dbms::new_thread()
{
  unsigned int sts;
  return m_env->open_thread(&sts);
}

void sev_dbms::delete_thread(void* thread)
{
  m_env->close_thread((MYSQL*)thread);
}

sev_dbms::~sev_dbms()
{
  printf("Freeing memory\n");
  for (size_t idx = 0; idx < m_items.size(); idx++) {
    if (m_items[idx].cache)
      // Write last value
      m_items[idx].cache->write(0, 0);
    if (m_items[idx].old_value != 0) {
      free(m_items[idx].old_value);
      m_items[idx].old_value = 0;
    }
  }
}

char* sev_dbms::create_colName(unsigned int index, char* attributename)
{
  static char colName[constMaxColNameLength];
  strncpy(colName, attributename, constMaxColNameLength);
  if (strlen(attributename) > constMaxColNameLength) {
    colName[constMaxColNameLength - 5] = 0;
    snprintf(&colName[strlen(colName)], 5, "_%d", index);
  }
  return colName;
}

#else
extern int no_sev_dbms;
int no_sev_dbms = 0;
#endif
