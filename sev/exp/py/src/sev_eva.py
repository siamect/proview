#!/usr/bin/python3
#
# ProviewR   Open Source Process Control.
# Copyright (C) 2005-2019 SSAB EMEA AB.
#
# This file is part of ProviewR.
#
# This program is free software; you can redistribute it and/or 
# modify it under the terms of the GNU General Public License as 
# published by the Free Software Foundation, either version 2 of 
# the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful 
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License 
# along with ProviewR. If not, see <http://www.gnu.org/licenses/>
#
# Linking ProviewR statically or dynamically with other modules is
# making a combined work based on ProviewR. Thus, the terms and
# conditions of the GNU General Public License cover the whole 
# combination.
#
# In addition, as a special exception, the copyright holders of
# ProviewR give you permission to, from the build function in the
# ProviewR Configurator, combine ProviewR with modules generated by the
# ProviewR PLC Editor to a PLC program, regardless of the license
# terms of these modules. You may copy and distribute the resulting
# combined work under the terms of your choice, provided that every 
# copy of the combined work is accompanied by a complete copy of 
# the source code of ProviewR (the version used to produce the
# combined work), being distributed under the terms of the GNU 
# General Public License plus this exception.
#

# Sev data analysis application


from tkinter import *
import tkinter.filedialog
import tkinter.messagebox
import tkinter.ttk
import sys
import math
import time
import getopt
import os
import re
import pwrrt
from datetime import datetime
from datetime import timedelta
import statsmodels.api as am
from statsmodels.sandbox.regression.predstd import wls_prediction_std
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.linear_model import Ridge
from sklearn.linear_model import Lasso
from sklearn.neural_network import MLPRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import r2_score
from scipy.interpolate import interp1d
import matplotlib
matplotlib.use('TkAgg')
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.widgets
import pickle
import co
import wow
from rt_mva import *
from rt_mva_msg import *


class Sev:
  mEventType_Ack = 1
  mEventType_Block = 2
  mEventType_Cancel = 4
  mEventType_CancelBlock = 8
  mEventType_Missing = 16
  mEventType_Reblock = 32
  mEventType_Return = 64
  mEventType_Unblock = 128
  mEventType_InfoSuccess = 256
  mEventType_Alarm = 512
  mEventType_MaintenanceAlarm = 1024
  mEventType_SystemAlarm = 2048
  mEventType_UserAlarm1 = 4098
  mEventType_UserAlarm2 = 8192
  mEventType_UserAlarm3 = 16384
  mEventType_UserAlarm4 = 32768
  mEventType_Info = 65536

  mEventPrio_A = 1
  mEventPrio_B = 2
  mEventPrio_C = 4
  mEventPrio_D = 8
  
class Ev:
  eEvent_Ack = 1
  eEvent_Block = 2
  eEvent_Cancel = 3
  eEvent_CancelBlock = 4
  eEvent_Missing = 5
  eEvent_Reblock = 6
  eEvent_Return = 7
  eEvent_Unblock = 8
  eEvent_InfoSuccess = 32
  eEvent_Alarm = 64
  eEvent_MaintenanceAlarm = 128
  eEvent_SystemAlarm = 256
  eEvent_UserAlarm1 = 512
  eEvent_UserAlarm2 = 1024
  eEvent_UserAlarm3 = 2048
  eEvent_UserAlarm4 = 4096
  eEvent_Info = 8192
  eEvent_ClearAlarmList = 2147483647

  eEventPrio_A = 67
  eEventPrio_B = 66
  eEventPrio_C = 65
  eEventPrio_D = 64

  mEventStatus_NotRet = 1
  mEventStatus_NotAck = 2
  mEventStatus_Block = 4
  
  @staticmethod
  def eventtype_to_str(type):
    if type == Ev.eEvent_Ack:
        return 'Ack'
    if type == Ev.eEvent_Block:
        return 'Block'
    if type == Ev.eEvent_Cancel:
        return 'Cancel'
    if type == Ev.eEvent_CancelBlock:
        return 'CancelBlock'
    if type == Ev.eEvent_Missing:
        return 'Missing'
    if type == Ev.eEvent_Reblock:
        return 'Reblock'
    if type == Ev.eEvent_Return:
        return 'Return'
    if type == Ev.eEvent_Unblock:
        return 'Unblock'
    if type == Ev.eEvent_InfoSuccess:
        return 'InfoSuccess'
    if type == Ev.eEvent_Alarm:
        return 'Alarm'
    if type == Ev.eEvent_MaintenanceAlarm:
        return 'MaintAlarm'
    if type == Ev.eEvent_SystemAlarm:
        return 'SystemAlarm'
    if type == Ev.eEvent_UserAlarm1:
        return 'UserAlarm1'
    if type == Ev.eEvent_UserAlarm2:
        return 'UserAlarm2'
    if type == Ev.eEvent_UserAlarm3:
        return 'UserAlarm3'
    if type == Ev.eEvent_UserAlarm4:
        return 'UserAlarm4'
    if type == Ev.eEvent_Info:
        return 'Info'
    if type == Ev.eEvent_ClearAlarmList:
        return 'ClearAlarmList'
    return ''

  @staticmethod
  def eventprio_to_str(prio):
    if prio == Ev.eEventPrio_A:
        return 'A'
    if prio == Ev.eEventPrio_B:
        return 'B'
    if prio == Ev.eEventPrio_C:
        return 'C'
    if prio == Ev.eEventPrio_D:
        return 'D'
    return ''

  @staticmethod
  def eventsts_to_str(sts, type):
    str = ''      
    first = True
    if type == Ev.eEvent_Alarm or type == Ev.eEvent_MaintenanceAlarm or \
       type == Ev.eEvent_SystemAlarm or \
       type == Ev.eEvent_UserAlarm1 or type == Ev.eEvent_UserAlarm2 or \
       type == Ev.eEvent_UserAlarm3 or type == Ev.eEvent_UserAlarm4:
        if sts & Ev.mEventStatus_NotRet == 0:
            if first:
                first = False
            else:
                str += '|'
            str += 'R'
        if sts & Ev.mEventStatus_NotAck == 0:
            if first:
                first = False
            else:
                str += '|'
            str += 'A'
        if sts & Ev.mEventStatus_Block:
            if first:
                first = False
            else:
                str += '|'
            str += 'B'
    else:
        if sts & Ev.mEventStatus_NotRet:
            if first:
                first = False
            else:
                str += '|'
            str += 'NR'
        if sts & Ev.mEventStatus_NotAck:
            if first:
                first = False
            else:
                str += '|'
            str += 'NA'
        if sts & Ev.mEventStatus_Block:
            if first:
                first = False
            else:
                str += '|'
            str += 'B'
    return str

class EventClip:
    def __init__(self, mintime, maxtime):
        self.mintime = mintime
        self.maxtime = maxtime

class EventClipSelected:
    def __init__(self, idxlist):
        self.idxlist = idxlist

class EventSplit:
    def __init__(self, time):
        self.time = time
    
class EventFilter:
    def __init__(self, typemask, priomask, eventtext, eventname, supobject):
        self.eventtypemask = typemask
        self.eventpriomask = priomask
        self.eventtext = eventtext
        self.eventname = eventname
        self.supobject = supobject

class FilterDialog:
    def __init__(self, parent, filter_cb):

        top = self.top = Toplevel(parent, bg=bgcolor)
        main.set_icon(top)

        self.top.title('Filter events')
        self.filter_cb = filter_cb

        row = 0
        
        # EventType entry
        eventtypelabel = Label(top, text='EventType')
        eventtypelabel.grid(column=0, row=row, padx=0, pady=5, sticky=W)
        eventtypelabel.config(bg=bgcolor)

        typeframe = Frame(top, bg=bgcolor)
        typeframe.grid(column=1, row=row, padx=20, pady=5, sticky=W)
        i = 0
        self.typesel = [None] * 17
        while i < 17:
            self.typesel[i] = IntVar()
            i += 1
        # Ack
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_Ack),
                               variable=self.typesel[0], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=0, row=0, padx=20, pady=5, sticky=W)
        # Block
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_Block),
                               variable=self.typesel[1], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=1, row=0, padx=20, pady=5, sticky=W)
        # Cancel
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_Cancel),
                               variable=self.typesel[2], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=2, row=0, padx=20, pady=5, sticky=W)
        # CancelBlock
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_CancelBlock),
                               variable=self.typesel[3], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=3, row=0, padx=20, pady=5, sticky=W)
        # Missing
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_Missing),
                               variable=self.typesel[4], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=4, row=0, padx=20, pady=5, sticky=W)
        # Reblock
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_Reblock),
                               variable=self.typesel[5], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=0, row=1, padx=20, pady=5, sticky=W)
        # Return
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_Return),
                               variable=self.typesel[6], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=1, row=1, padx=20, pady=5, sticky=W)
        # Unblock
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_Unblock),
                               variable=self.typesel[7], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=2, row=1, padx=20, pady=5, sticky=W)
        # Info
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_Info),
                               variable=self.typesel[16], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=3, row=1, padx=20, pady=5, sticky=W)
        # InfoSuccess
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_InfoSuccess),
                               variable=self.typesel[8], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=4, row=1, padx=20, pady=5, sticky=W)
        # Alarm
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_Alarm),
                               variable=self.typesel[9], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=0, row=2, padx=20, pady=5, sticky=W)
        # MantenanceAlarm
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_MaintenanceAlarm),
                               variable=self.typesel[10], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=1, row=2, padx=20, pady=5, sticky=W)
        # SystemAlarm
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_SystemAlarm),
                               variable=self.typesel[11], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=2, row=2, padx=20, pady=5, sticky=W)
        # UserAlarm1
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_UserAlarm1),
                               variable=self.typesel[12], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=3, row=2, padx=20, pady=5, sticky=W)
        # UserAlarm2
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_UserAlarm2),
                               variable=self.typesel[13], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=4, row=2, padx=20, pady=5, sticky=W)
        # UserAlarm3
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_UserAlarm3),
                               variable=self.typesel[14], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=0, row=3, padx=20, pady=5, sticky=W)
        # UserAlarm4
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_UserAlarm4),
                               variable=self.typesel[15], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=1, row=3, padx=20, pady=5, sticky=W)
        row += 4

        
        # EventPrio entry
        eventpriolabel = Label(top, text='EventPrio')
        eventpriolabel.grid(column=0, row=row, padx=0, pady=5, sticky=W)
        eventpriolabel.config(bg=bgcolor)

        prioframe = Frame(top, bg=bgcolor)
        prioframe.grid(column=1, row=row, padx=20, pady=5, sticky=W)
        row += 1
        i = 0
        self.priosel = [None] * 4
        self.priosel[i] = IntVar()
        checkbox = Checkbutton(prioframe, text=Ev.eventprio_to_str(Ev.eEventPrio_A),
                               variable=self.priosel[0], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=0, row=0, padx=20, pady=5, sticky=W)
        i += 1
        self.priosel[i] = IntVar()
        checkbox = Checkbutton(prioframe, text=Ev.eventprio_to_str(Ev.eEventPrio_B),
                               variable=self.priosel[1], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=1, row=0, padx=20, pady=5, sticky=W)
        i += 1
        self.priosel[i] = IntVar()
        checkbox = Checkbutton(prioframe, text=Ev.eventprio_to_str(Ev.eEventPrio_C),
                               variable=self.priosel[2], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=2, row=0, padx=20, pady=5, sticky=W)
        i += 1
        self.priosel[i] = IntVar()
        checkbox = Checkbutton(prioframe, text=Ev.eventprio_to_str(Ev.eEventPrio_D),
                               variable=self.priosel[3], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=3, row=0, padx=20, pady=5, sticky=W)
        i += 1

        # EventText
        defaulteventtext = StringVar()
        eventtextlabel = Label(top, text='EventText')
        eventtextlabel.grid(column=0, row=row, padx=0, pady=5, sticky=W)
        eventtextlabel.config(bg=bgcolor)
        self.eventtextentry = Entry(top, textvariable=defaulteventtext)
        self.eventtextentry.grid(column=1, row=row, padx=20, pady=5, sticky=W)
        self.eventtextentry.config(bg=bgcolor)
        row += 1

        # EventName
        defaulteventname = StringVar()
        eventnamelabel = Label(top, text='EventName')
        eventnamelabel.grid(column=0, row=row, padx=0, pady=5, sticky=W)
        eventnamelabel.config(bg=bgcolor)
        self.eventnameentry = Entry(top, textvariable=defaulteventname)
        self.eventnameentry.grid(column=1, row=row, padx=20, pady=5, sticky=W)
        self.eventnameentry.config(bg=bgcolor)
        row += 1

        button = Button(top, text="Ok", command=self.ok_cb, width=10)
        button.grid(column=0, row=row, padx=10, pady=5, sticky=W)
    
        button = Button(top, text="Cancel", command=self.cancel_cb, width=10)
        button.grid(column=1, row=row, padx=10, pady=5, sticky=W)
    

    def cancel_cb(self):
        self.top.destroy()

    def ok_cb(self):

        eventtypevalue = 0
        m = 1
        for sel in self.typesel:
            if sel.get() == 1:
                eventtypevalue += m
            m = m << 1

        eventpriovalue = 0
        m = 1
        for sel in self.priosel:
            if sel.get() == 1:
                eventpriovalue += m
            m = m << 1
        filter = EventFilter(eventtypevalue, eventpriovalue, self.eventtextentry.get(),
                             self.eventnameentry.get(), '')
        self.filter_cb(filter)
        self.top.destroy()

class ValueDialog:
    def __init__(self, parent, title, text, defaultstr, value_cb):

        top = self.top = Toplevel(parent)
        main.set_icon(top)

        self.top.title(title)

        label = Label(top, text=text)
        label.grid(column=0, row=0, padx=10, pady=5, sticky=W)

        defaultvalue = StringVar()
        self.entry = Entry(top, width=25, textvariable=defaultvalue)
        self.entry.grid(column=1, row=0, padx=10, pady=5, sticky=W)
        defaultvalue.set(defaultstr)
        self.entry.focus()
        self.value_cb = value_cb

        button = Button(top, text="Ok", command=self.ok_cb, width=10)
        button.grid(column=0, row=1, padx=10, pady=5, sticky=W)
    
        button = Button(top, text="Cancel", command=self.cancel_cb, width=10)
        button.grid(column=1, row=1, padx=10, pady=5, sticky=W)

        self.top.bind('<Return>', self.ok_cb)

    def cancel_cb(self):
        self.top.destroy()

    def ok_cb(self, arg=0):
        value = self.entry.get()
        self.value_cb(value)
        self.top.destroy()

class SelectDialog:

    def __init__(self, parent, itemlist, cb_func):
        self.window = Toplevel(parent, bg=bgcolor)
        main.set_icon(self.window)
        self.window.title("Select data")
        self.itemlist = itemlist
        self.cb_func = cb_func
        #self.window.minsize(600, 200)
        
        self.listbox = Listbox(self.window)
        self.listbox.grid(row=0, column=0)
        
        for item in itemlist:
            self.listbox.insert(END, item)
            
        button = Button(self.window, text='Ok', command=self.ok_cb, bg=buttoncolor).grid(row=1, column=0)

    def ok_cb(self): 
        idx = self.listbox.curselection()
        self.cb_func(self.itemlist[idx[0]])
        self.window.destroy()

class EWData:
    """EWData class, container for events.

    wd 	 Frame with events
    """
    def __init__(self):
        self.set = False
        self.name = ''
        self.wd = None
        self.origdata = None
        self.origcol = ['Time', 'Type', 'Prio', 'Text', 'Name', 'SupObject', 'Id', 'Status']
    
    def empty(self):
        """Returns true is no data is set yet."""
        return not self.set

    def rows(self):
        """Number of rows in wd."""
        if self.empty():
            return 0
        return self.wd.shape[0]

    def set_name(self, name):
        self.name = name
    
    def set_data(self, data):
        """Insert new data."""
        self.origdata = data
        self.origdata.columns = self.origcol
        
        self.wd = self.origdata.loc[:,:]
        self.wd.columns = self.origdata.columns
        self.set = True

    def save_orig(self, file):
        self.origdata.to_csv(file, index=False)

    def save_wd(self, file):
        self.wb.to_csv(file, index=False)
                
    def set_name(self, name):
        self.name = name

    def read_file(self, file):
    
        self.origdata = pd.read_csv(file, parse_dates=[0])
        self.origdata.columns = self.origcol
        self.wd = self.origdata.loc[:,:]
        self.wd.columns = self.origcol
        self.wd['Text'].fillna('',inplace=True)
        self.set = True

    def save_orig(self, file):
        self.origdata.to_csv(file, index=False)

    def save_wd(self, file):
        self.wd.to_csv(file, index=False)
                
    def set_name(self, name):
        self.name = name

    def revert(self):
        if self.empty():
            return
    
        self.wd = self.origdata.loc[:,:]

    def clip(self, c):
        self.wd = self.wd[(self.wd['Time'] >= c.mintime) & (self.wd['Time'] <= c.maxtime)]
        self.wd = self.wd.reset_index(drop=True)

    def clip_selected(self, c):
        self.wd = self.wd.loc[self.wd.index.isin(c.idxlist)]
        self.wd = self.wd.reset_index(drop=True)

    def split(self, s):
        wdata = EWData()
        wdata.origdata = self.origdata
        wdata.origcol = self.origcol
        wdata.wd = self.wd[self.wd['Time'] < s.time]
        wdata.wd = wdata.wd.reset_index(drop=True)
        wdata.set = True

        self.wd = self.wd[self.wd['Time'] >= s.time]
        self.wd = self.wd.reset_index(drop=True)
        return wdata

    def split_redo(self, s):
        self.wd = self.wd[self.wd['Time'] >= s.time]
        self.wd = self.wd.reset_index(drop=True)

    def filter(self, eventfilter):
        mod = False
        if eventfilter.eventtypemask != 0:
            typelist = []
            if eventfilter.eventtypemask & Sev.mEventType_Ack:
                typelist.append(Ev.eEvent_Ack)
            if eventfilter.eventtypemask & Sev.mEventType_Block:
                typelist.append(Ev.eEvent_Block)
            if eventfilter.eventtypemask & Sev.mEventType_Cancel:
                typelist.append(Ev.eEvent_Cancel)
            if eventfilter.eventtypemask & Sev.mEventType_CancelBlock:
                typelist.append(Ev.eEvent_CancelBlock)
            if eventfilter.eventtypemask & Sev.mEventType_Missing:
                typelist.append(Ev.eEvent_Missing)
            if eventfilter.eventtypemask & Sev.mEventType_Reblock:
                typelist.append(Ev.eEvent_Reblock)
            if eventfilter.eventtypemask & Sev.mEventType_Return:
                typelist.append(Ev.eEvent_Return)
            if eventfilter.eventtypemask & Sev.mEventType_Unblock:
                typelist.append(Ev.eEvent_Unblock)
            if eventfilter.eventtypemask & Sev.mEventType_InfoSuccess:
                typelist.append(Ev.eEvent_InfoSuccess)
            if eventfilter.eventtypemask & Sev.mEventType_Alarm:
                typelist.append(Ev.eEvent_Alarm)
            if eventfilter.eventtypemask & Sev.mEventType_MaintenanceAlarm:
                typelist.append(Ev.eEvent_MaintenanceAlarm)
            if eventfilter.eventtypemask & Sev.mEventType_SystemAlarm:
                typelist.append(Ev.eEvent_SystemAlarm)
            if eventfilter.eventtypemask & Sev.mEventType_UserAlarm1:
                typelist.append(Ev.eEvent_UserAlarm1)
            if eventfilter.eventtypemask & Sev.mEventType_UserAlarm2:
                typelist.append(Ev.eEvent_UserAlarm2)
            if eventfilter.eventtypemask & Sev.mEventType_UserAlarm3:
                typelist.append(Ev.eEvent_UserAlarm3)
            if eventfilter.eventtypemask & Sev.mEventType_UserAlarm4:
                typelist.append(Ev.eEvent_UserAlarm4)
            if eventfilter.eventtypemask & Sev.mEventType_Info:
                typelist.append(Ev.eEvent_Info)
        
            self.wd = self.wd[self.wd.Type.isin(typelist)]
            mod = True

        if eventfilter.eventpriomask != 0:
            priolist = []
            if eventfilter.eventpriomask & Sev.mEventPrio_A:
                priolist.append(Ev.eEventPrio_A)
            if eventfilter.eventpriomask & Sev.mEventPrio_B:
                priolist.append(Ev.eEventPrio_B)
            if eventfilter.eventpriomask & Sev.mEventPrio_C:
                priolist.append(Ev.eEventPrio_C)
            if eventfilter.eventpriomask & Sev.mEventPrio_D:
                priolist.append(Ev.eEventPrio_D)

            self.wd = self.wd[self.wd.Prio.isin(priolist)]
            mod = True

        if eventfilter.eventtext != '':
            mask = self.wd['Text'].str.match(eventfilter.eventtext)
            i = 0
            while i < len(mask):
                if mask[i] != True:
                    mask[i] = False
                i += 1
            self.wd = self.wd[mask]
            mod = True

        if eventfilter.eventname != '':
            mask = self.wd['Name'].str.match(eventfilter.eventname)
            i = 0
            while i < len(mask):
                if mask[i] != True:
                    mask[i] = False
                i += 1
            self.wd = self.wd[mask]
            mod = True

        if eventfilter.supobject != '':
            mask = self.wd['SupObject'].str.match(eventfilter.supobject)
            for b in mask:
                if b != True:
                    b = False
            self.wd = self.wd[mask]
            mod = True

        if mod:
            self.wd = self.wd.reset_index(drop=True)

class TrendHistogram:
    def __init__(self, wdata):
        self.wdata = wdata
        self.trenddia = Toplevel(window, bg=bgcolor)
        self.trenddia.geometry("450x170")
        self.trenddia.title('TrendHistogram')
        main.set_icon(self.trenddia)

        defaultmin = StringVar()
        minlabel = Label(self.trenddia, text='From', bg=bgcolor)
        minlabel.grid(column=0, row=0, padx=20, pady=5, sticky=W)
        self.minentry = Entry(self.trenddia, textvariable=defaultmin, width=25, bg=bgcolor)
        defaultmin.set(str(self.wdata.wd['Time'][0]))
        self.minentry.grid(column=1, row=0, padx=20, pady=5, sticky=W)

        # Max entry
        defaultmax = StringVar()
        maxlabel = Label(self.trenddia, text='To', bg=bgcolor)
        maxlabel.grid(column=0, row=1, padx=20, pady=5, sticky=W)
        self.maxentry = Entry(self.trenddia, textvariable=defaultmax, width=25, bg=bgcolor)
        defaultmax.set(str(self.wdata.wd['Time'][len(self.wdata.wd)-1]))
        self.maxentry.grid(column=1, row=1, padx=20, pady=5, sticky=W)

        # Bins
        defaultbins = StringVar()
        binslabel = Label(self.trenddia, text='Number of bins', bg=bgcolor)
        binslabel.grid(column=0, row=2, padx=20, pady=5, sticky=W)
        self.binsentry = Entry(self.trenddia, textvariable=defaultbins, width=25, bg=bgcolor)
        defaultbins.set(str(100))
        self.binsentry.grid(column=1, row=2, padx=20, pady=5, sticky=W)

        # All events
        self.all_events = IntVar()
        checkbox = Checkbutton(self.trenddia, text='All events',
                               variable=self.all_events, highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=0, row=3, padx=20, pady=5, sticky=W)

        readdatabutton = Button(self.trenddia, text="Apply", command=self.trend_action_ok_cb, bg=buttoncolor);
        readdatabutton.grid(column=0, row=4, padx=60, pady=20, sticky=W)

        readdatabutton = Button(self.trenddia, text="Cancel", command=self.trend_action_cancel_cb, bg=buttoncolor);
        readdatabutton.grid(column=1, row=4, padx=60, pady=20, sticky=W)

    def trend_action_cancel_cb(self):
        self.trenddia.destroy()

    def trend_action_ok_cb(self):
        try:
            mintime = datetime.strptime(self.minentry.get(), '%Y-%m-%d %H:%M:%S.%f')
        except ValueError:
            try:
                mintime = datetime.strptime(self.minentry.get(), '%Y-%m-%d %H:%M:%S')
            except ValueError:
                tkinter.messagebox.showerror("Error", "Time syntax error")
                return
        try:
            maxtime = datetime.strptime(self.maxentry.get(), '%Y-%m-%d %H:%M:%S.%f')
        except ValueError:
            try:
                maxtime = datetime.strptime(self.maxentry.get(), '%Y-%m-%d %H:%M:%S')
            except ValueError:
                tkinter.messagebox.showerror("Error", "Time syntax error")
                return
        try:
            bins = int(self.binsentry.get())
        except ValueError:
            tkinter.messagebox.showerror("Error", "Integer syntax error")
            return
        all_events = self.all_events.get()

        self.trenddia.destroy()

        if all_events == 1:
            wd = self.wdata.wd
        else:
            types = [Ev.eEvent_Alarm, Ev.eEvent_MaintenanceAlarm, Ev.eEvent_SystemAlarm,
                     Ev.eEvent_Info, Ev.eEvent_InfoSuccess,
                     Ev.eEvent_UserAlarm1, Ev.eEvent_UserAlarm2, Ev.eEvent_UserAlarm3,
                     Ev.eEvent_UserAlarm4]
            wd = self.wdata.wd.loc[self.wdata.wd['Type'].isin(types)]

        wdtime = wd[(wd['Time'] >= mintime) & (wd['Time'] <= maxtime)]['Time']
#        wdtime = self.wdata.wd[(self.wdata.wd['Time'] >= mintime) & (self.wdata.wd['Time'] <= maxtime)]['Time']
        fig = plt.figure(figsize=(12,5))
        ax = fig.add_subplot(1,1,1)
        timelist = []
        for t in wdtime:
            timelist.append(t)
        ax.hist(timelist, bins=bins)
        plt.show()

class FrequencyHistogram:
    def __init__(self, wdata):
        self.wdata = wdata
        self.counts = self.wdata.wd['SupObject'].value_counts()
        types = [Ev.eEvent_Alarm, Ev.eEvent_MaintenanceAlarm, Ev.eEvent_SystemAlarm,
                 Ev.eEvent_Info, Ev.eEvent_InfoSuccess,
                 Ev.eEvent_UserAlarm1, Ev.eEvent_UserAlarm2, Ev.eEvent_UserAlarm3,
                 Ev.eEvent_UserAlarm4]

        i = 0
        self.names = []
        self.texts = []
        while i < len(self.counts):
            res = self.wdata.wd.loc[ (self.wdata.wd['SupObject'] == self.counts.index[i]) & self.wdata.wd['Type'].isin(types)]
            if len(res) > 0:
                res = res.iloc[0]
                self.names.append(res['Name'])
                self.texts.append(res['Text'])                   
            else:
                self.names.append('')
                self.texts.append('')
            i += 1

        self.xlim = None
        self.ax = None
        self.page = 0 
        self.rows = 30
        self.display_names = 0
        fig = plt.figure(num="Event Frequency Histogram")
        fig.subplots_adjust(left=0.4)
        axprev = plt.axes([0.01, 0.01, 0.1, 0.05])
        axnext = plt.axes([0.125, 0.01, 0.1, 0.05])
        axdisplay = plt.axes([0.580, 0.01, 0.1, 0.05])
        axname = plt.axes([0.700, 0.01, 0.1, 0.05])
        axtext = plt.axes([0.825, 0.01, 0.1, 0.05])
        bprev = matplotlib.widgets.Button(axprev, 'Previous')
        bprev.on_clicked(self.bprev_cb)
        bnext = matplotlib.widgets.Button(axnext, 'Next')
        bnext.on_clicked(self.bnext_cb)
        bdisplay = matplotlib.widgets.Button(axdisplay, 'Display', color=bgcolor, hovercolor=bgcolor)
        bname = matplotlib.widgets.Button(axname, 'Name')
        bname.on_clicked(self.bname_cb)
        btext = matplotlib.widgets.Button(axtext, 'Text')
        btext.on_clicked(self.btext_cb)
        axrows = plt.axes([0.25, 0.01, 0.1, 0.05])
        self.brows = matplotlib.widgets.Button(axrows, '', color=bgcolor, hovercolor=bgcolor)
        self.draw()
        plt.show()

    def draw(self):

        idx1 = self.page * self.rows
        idx2 = (self.page + 1) * self.rows
        if idx2 > len(self.counts)-1:
            idx2 = len(self.counts)
        size = idx2 - idx1
        text = str(idx1+1) + "-" + str(idx2) + " (" + str(len(self.counts)) + ")"        
        self.brows.label.set_text(text)
        if self.ax == None:
            self.ax = plt.subplot()
        if self.xlim != None:
            self.ax.set_xlim(self.xlim)
            self.ax.invert_yaxis()
        else:
            self.ax.invert_yaxis()
        plt.title('Event frequency')
        values = self.counts[idx1:idx2]
        self.y_pos = np.arange(size)
        self.ax.barh(self.y_pos, values, align='center', alpha=0.5)
        if self.display_names:
            plt.yticks(self.y_pos, self.names[idx1:idx2])
        else:
            plt.yticks(self.y_pos, self.texts[idx1:idx2])
        if self.xlim == None:
            self.xlim = self.ax.get_xlim()

        texts = self.names[idx1:idx2]
        names = self.texts[idx1:idx2]

    def bnext_cb(self, event):
        if self.page >= math.floor((len(self.counts)-1)/self.rows):
          tkinter.messagebox.showerror("Next", "No next page")
          return
        self.page += 1
        if self.page > len(self.counts)/self.rows:
            self.page = len(self.counts)/self.rows
        self.ax.clear()
        self.draw()
        plt.draw()

    def bprev_cb(self, event):
        if self.page == 0:
          tkinter.messagebox.showerror("Previous", "No previous page")
          return          
        self.page -= 1
        if self.page < 0:
            self.page = 0
        self.ax.clear()
        self.draw()
        plt.draw()

    def bname_cb(self, event):
        self.display_names = 1
        self.ax.clear()
        self.draw()
        plt.draw()

    def btext_cb(self, event):
        self.display_names = 0
        self.ax.clear()
        self.draw()
        plt.draw()

class WdWindow:
    # Constructor, create empty window
    def __init__(self):
        global window

        main.add_appl(self)
        
        self.name = ''
        self.wdata = EWData()
        self.dataframe = None
        self.add_dia = None
        self.clipdia = None
        self.fcurve = None
        self.fcurvefile = None
        self.constantentry = None
        self.shiftentry = None
        self.curveentry = None
        self.datasel = None
        self.stack = []
        self.searchstr = ''
        self.searchnext = 0

        self.window = Toplevel(window, bg=bgcolor)
        self.window.title(self.name)
        self.window.geometry("1240x700")
        #self.window.minsize(600, 200)
        self.window.protocol("WM_DELETE_WINDOW", self.close_action_cb)
        main.set_icon(self.window)
        self.create_toolbar()
        self.create_dataframe()
        self.create_datamenu()


    def empty(self):
        return self.wdata.empty()
    
    # Rename callback
    def rename_action_cb(self): 
        ValueDialog(self.window, "Rename", "Name", "", self.rename_ok_cb)
                    
    def rename_ok_cb(self, name):
        self.name = name
        self.wdata.set_name(name)
        self.window.title(self.name)

    def get_select(self):
        if self.empty():
            return None
        mask = [None] * len(self.datasel)
        i = 0
        for sel in self.datasel:
            mask[i] = (sel.get() == 1)
            i += 1
        return mask

    # Number of unacknowleged alarms plot callback
    def alarmplot_notret_action_cb(self):
        self.no_of_alarms_plot(1)

    # Number of not returned alarms plot callback
    def alarmplot_ack_action_cb(self):
        self.no_of_alarms_plot(0)

    # Number of alarms plot
    def no_of_alarms_plot(self, plottype):
        if self.empty():
            return

        if plottype == 0:
            down_event = Ev.eEvent_Ack
        elif plottype == 1:
            down_event = Ev.eEvent_Return
            
        # The SupObject for all alarms are added to lists and removed when
        # acked or returned, dependent on type.
        # The size of the lists are stored in the dataframe ser and plotted.
        ser = pd.DataFrame(columns=['Time','A','B','C','D','Info','InfoSucc'])
        j = 0
        k = 0
        a_alarms = []
        b_alarms = []
        c_alarms = []
        d_alarms = []
        info_msgs = []
        infosucc_msgs = []
        old_a_alarms = 0
        old_b_alarms = 0
        old_c_alarms = 0
        old_d_alarms = 0
        old_info_msgs = 0
        old_infosucc_msgs = 0
        while j < len(self.wdata.wd):
            type = self.wdata.wd['Type'][j]
            if type == Ev.eEvent_Alarm or type == Ev.eEvent_MaintenanceAlarm or \
               type == Ev.eEvent_SystemAlarm or \
               type == Ev.eEvent_UserAlarm1 or type == Ev.eEvent_UserAlarm2 or \
               type == Ev.eEvent_UserAlarm3 or type == Ev.eEvent_UserAlarm4:
                if plottype == 1 and \
                   (self.wdata.wd['Status'][j] & Ev.mEventStatus_NotRet == 0):
                    j += 1
                    continue
                
                prio = self.wdata.wd['Prio'][j]
                if prio == Ev.eEventPrio_A:
                    a_alarms.append(self.wdata.wd['SupObject'][j])
                elif prio == Ev.eEventPrio_B:
                    b_alarms.append(self.wdata.wd['SupObject'][j])
                elif prio == Ev.eEventPrio_C:
                    c_alarms.append(self.wdata.wd['SupObject'][j])
                elif prio == Ev.eEventPrio_D:
                    d_alarms.append(self.wdata.wd['SupObject'][j])
            elif type == Ev.eEvent_Info:
                info_msgs.append(self.wdata.wd['SupObject'][j])
            elif type == Ev.eEvent_InfoSuccess:
                infosucc_msgs.append(self.wdata.wd['SupObject'][j])
            elif type == Ev.eEvent_ClearAlarmList:
                # TODO remove any alarms from a subvolume
                vid = self.wdata.wd['SupObject'][j][:-1]
                a_alarms = [i for i in a_alarms if not i.startswith(vid)]
                b_alarms = [i for i in b_alarms if not i.startswith(vid)]
                c_alarms = [i for i in c_alarms if not i.startswith(vid)]
                d_alarms = [i for i in d_alarms if not i.startswith(vid)]
                info_msgs = [i for i in info_msgs if not i.startswith(vid)]
                infosucc_msgs = [i for i in infosucc_msgs if not i.startswith(vid)]
            elif type == down_event:

                # Find the last corresponding alarm or info event
                # For application info it's not certain the correct info will be found...
                types = [Ev.eEvent_Alarm, Ev.eEvent_MaintenanceAlarm, Ev.eEvent_SystemAlarm,
                         Ev.eEvent_Info, Ev.eEvent_InfoSuccess,
                         Ev.eEvent_UserAlarm1, Ev.eEvent_UserAlarm2, Ev.eEvent_UserAlarm3,
                         Ev.eEvent_UserAlarm4]

                res = self.wdata.wd.loc[ (self.wdata.wd['SupObject'] == self.wdata.wd['SupObject'][j]) & self.wdata.wd['Type'].isin(types) & (self.wdata.wd['Time'] < self.wdata.wd['Time'][j])]
                if len(res) > 0:
                    res = res.iloc[-1]
                    atype = res['Type']
                    if atype == Ev.eEvent_Alarm or type == Ev.eEvent_MaintenanceAlarm or \
                           atype == Ev.eEvent_SystemAlarm or \
                           atype == Ev.eEvent_UserAlarm1 or type == Ev.eEvent_UserAlarm2 or \
                           atype == Ev.eEvent_UserAlarm3 or type == Ev.eEvent_UserAlarm4:
                        aprio = self.wdata.wd['Prio'][j]
                        if aprio == Ev.eEventPrio_A:
                            try:
                                a_alarms.remove(self.wdata.wd['SupObject'][j])
                            except ValueError:
                                pass
                        elif aprio == Ev.eEventPrio_B:
                            try:
                                b_alarms.remove(self.wdata.wd['SupObject'][j])
                            except ValueError:
                                pass
                        elif aprio == Ev.eEventPrio_C:
                            try:
                                c_alarms.remove(self.wdata.wd['SupObject'][j])
                            except ValueError:
                                pass
                        elif aprio == Ev.eEventPrio_D:
                            try:
                                d_alarms.remove(self.wdata.wd['SupObject'][j])
                            except ValueError:
                                pass
                    elif atype == Ev.eEvent_Info:
                        try:
                            info_msgs.remove(self.wdata.wd['SupObject'][j])
                        except ValueError:
                            pass
                    elif atype == Ev.eEvent_InfoSuccess:
                        try:
                            infosucc_msgs.remove(self.wdata.wd['SupObject'][j])
                        except ValueError:
                            pass

            if j < len(self.wdata.wd)-1 and \
                   self.wdata.wd['Time'][j] == self.wdata.wd['Time'][j+1]:
                j += 1
                continue
            
            if len(a_alarms) != old_a_alarms or len(b_alarms) != old_b_alarms or \
               len(c_alarms) != old_c_alarms or len(d_alarms) != old_d_alarms or \
               len(info_msgs) != old_info_msgs or len(infosucc_msgs) != old_infosucc_msgs:
                ser.loc[k] = [self.wdata.wd['Time'][j] - timedelta(0, 0, 1000), old_a_alarms, old_b_alarms,
                              old_c_alarms, old_d_alarms, old_info_msgs, old_infosucc_msgs]
                k += 1
                ser.loc[k] = [self.wdata.wd['Time'][j], len(a_alarms), len(b_alarms),
                              len(c_alarms), len(d_alarms), len(info_msgs), len(infosucc_msgs)]
                k += 1
                old_a_alarms = len(a_alarms)
                old_b_alarms = len(b_alarms)
                old_c_alarms = len(c_alarms)
                old_d_alarms = len(d_alarms)
                old_info_msgs = len(info_msgs)
                old_infosucc_msgs = len(infosucc_msgs)
            j += 1

        fig = plt.figure(figsize=(12,5))
        if plottype == 0:
            fig.canvas.set_window_title('Number of not acknowledged alarms ' + self.name)
            plt.title('Not acknowledged alarms')
        else:
            fig.canvas.set_window_title('Number of not returned alarms ' + self.name)
            plt.title('Not returned alarms')

        plt.plot(ser['Time'], ser['A'] + ser['B'] + ser['C'] + ser['D'] +
                 ser['InfoSucc'] + ser['Info'], 'k', label='Info')
        plt.plot(ser['Time'], ser['A'] + ser['B'] + ser['C'] + ser['D'] +
                 ser['InfoSucc'], 'g', label='InfoS')
        plt.plot(ser['Time'], ser['A'] + ser['B'] + ser['C'] + ser['D'] ,'r', label='A')
        plt.plot(ser['Time'], ser['B'] + ser['C'] + ser['D'] ,'y', label='B')
        plt.plot(ser['Time'], ser['C'] + ser['D'] ,'b', label='C')
        plt.plot(ser['Time'], ser['D'] ,'m', label='D')
        plt.legend(loc='center left', bbox_to_anchor=(1, 0.5));
        plt.show()
        
    # Event frequency table callback
    def frequency_table_action_cb(self): 
        if self.empty():
            return

        counts = self.wdata.wd['SupObject'].value_counts()
        types = [Ev.eEvent_Alarm, Ev.eEvent_MaintenanceAlarm, Ev.eEvent_SystemAlarm,
                 Ev.eEvent_Info, Ev.eEvent_InfoSuccess,
                 Ev.eEvent_UserAlarm1, Ev.eEvent_UserAlarm2, Ev.eEvent_UserAlarm3,
                 Ev.eEvent_UserAlarm4]

        dia = Toplevel(self.window, bg=bgcolor)
        dia.title('Event Frequency Table')
        dia.geometry("1145x700")
        main.set_icon(dia)

        tree = tkinter.ttk.Treeview(dia)
        tree.pack(expand=1, anchor=W, side=LEFT, fill=BOTH)

        tree["columns"] = ("Frequency", "Type", "Prio", "Text", "Name", "SupObject")

        tree.column("#0", width=100, minwidth=20, stretch=NO)
        tree.column("#1", width=100, minwidth=20, stretch=NO)
        tree.column("#2", width=30, minwidth=20, stretch=NO)
        tree.column("#3", width=350, minwidth=20)
        tree.column("#4", width=350, minwidth=20)
        tree.column("#5", width=200, minwidth=20)
        tree.column("#6", width=0, minwidth=0) # Hide empty column???

        tree.heading("#0", text="Frequency", anchor=W)
        tree.heading("#1", text="Type", anchor=W)
        tree.heading("#2", text="Prio", anchor=W)
        tree.heading("#3", text="Text", anchor=W)
        tree.heading("#4", text="Name", anchor=W)
        tree.heading("#5", text="SupObject", anchor=W)

        scroll = tkinter.ttk.Scrollbar(dia, orient="vertical", command=tree.yview)
        scroll.pack(anchor=E, expand=1, side=RIGHT, fill=Y)

        i = 0
        while i < len(counts):
            res = self.wdata.wd.loc[ (self.wdata.wd['SupObject'] == counts.index[i]) & self.wdata.wd['Type'].isin(types)]
            if len(res) > 0:
                res = res.iloc[0]
                tree.insert('', 'end', text=str(counts[i]),
                            values=(Ev.eventtype_to_str(res['Type']),
                                    Ev.eventprio_to_str(res['Prio']),
                                    res['Text'],
                                    res['Name'],
                                    res['SupObject']))
            i += 1

        tree.configure(yscrollcommand=scroll.set)


    # Event frequency histogram callback
    def frequency_histogram_action_cb(self): 
        if self.empty():
            return
        fh = FrequencyHistogram(self.wdata)        

    # Event trend histogram callback
    def trend_histogram_action_cb(self): 
        if self.empty():
            return

        th = TrendHistogram(self.wdata)
#        fig = plt.figure(figsize=(12,5))
#        ax = fig.add_subplot(1,1,1)
#        timelist = []
#        for t in self.wdata.wd['Time']:
#            timelist.append(t)
#        print timelist
#        ax.hist(timelist, bins=100)
#        plt.show()

    # Revert callback
    def revert_action_cb(self):
        self.wdata.revert()
        self.redraw()

    # Search callback
    def search_action_cb(self, arg=0):
        ValueDialog(self.window, "Search", "String", "", self.search_ok_cb)

    def search_ok_cb(self, searchstr):
        selected = self.tree.focus()
        if selected == None:
            next = 0
        else:
            next = self.tree.index(selected) + 1
        if self.search(next, 0, searchstr.lower()) == -1:
            tkinter.messagebox.showerror("Search", "String not found")
        
        
    # Search Previous callback
    def searchprev_action_cb(self, arg=0):
        selected = self.tree.focus()
        if selected == None:
            next = self.search_next - 1
        else:
            next = self.tree.index(selected) - 1
        if self.search(next, 1, self.searchstr) == -1:
            tkinter.messagebox.showerror("Search", "No previous found")

    # Search Next callback
    def searchnext_action_cb(self, arg=0):
        selected = self.tree.focus()
        if selected == None:
            next = self.search_next + 1
        else:
            next = self.tree.index(selected) + 1
        if self.search(next, 0, self.searchstr) == -1:
            tkinter.messagebox.showerror("Search", "No next found")

    def search(self, fromidx, direction, searchstr):
        self.searchstr = searchstr
        found = -1
        i = fromidx
        if direction == 0:
            
            while i < len(self.wdata.wd):
                if self.wdata.wd['Text'][i].lower().find(searchstr) >= 0 or \
                   self.wdata.wd['Name'][i].lower().find(searchstr) >= 0:
                    id = self.tree.get_children()[i]
                    self.tree.focus(id)
                    self.tree.yview_moveto(float((0 if i < 5 else i - 5))/len(self.wdata.wd))
                    self.tree.selection_set(id)
                    self.search_next = i
                    found = 1
                    break
                i += 1
        else:
            while i >= 0:
                if self.wdata.wd['Text'][i].lower().find(searchstr) >= 0 or \
                   self.wdata.wd['Name'][i].lower().find(searchstr) >= 0:
                    id = self.tree.get_children()[i]
                    self.tree.focus(id)
                    self.tree.yview_moveto(float((0 if i < 5 else i - 5))/len(self.wdata.wd))
                    self.tree.selection_set(id)
                    self.search_next = i
                    found = 1
                    break
                i -= 1
        return found

    # Clip callback
    def clip_action_cb(self):
        if self.empty():
            return
    
        self.clipdia = Toplevel(self.window, bg=bgcolor)
        self.clipdia.geometry("450x130")
        self.clipdia.title('Clip')
        main.set_icon(self.clipdia)

        defaultmin = StringVar()
        minlabel = Label(self.clipdia, text='From', bg=bgcolor)
        minlabel.grid(column=0, row=0, padx=20, pady=5, sticky=W)
        self.minentry = Entry(self.clipdia, textvariable=defaultmin, width=25, bg=bgcolor)
        defaultmin.set(str(self.wdata.wd['Time'][len(self.wdata.wd)-1]))
        self.minentry.grid(column=1, row=0, padx=20, pady=5, sticky=W)

        # Max entry
        defaultmax = StringVar()
        maxlabel = Label(self.clipdia, text='To', bg=bgcolor)
        maxlabel.grid(column=0, row=1, padx=20, pady=5, sticky=W)
        self.maxentry = Entry(self.clipdia, textvariable=defaultmax, width=25, bg=bgcolor)
        defaultmax.set(str(self.wdata.wd['Time'][0]))
        self.maxentry.grid(column=1, row=1, padx=20, pady=5, sticky=W)

        readdatabutton = Button(self.clipdia, text="Apply", command=self.clip_action_ok_cb, bg=buttoncolor);
        readdatabutton.grid(column=0, row=2, padx=60, pady=20, sticky=W)

        readdatabutton = Button(self.clipdia, text="Cancel", command=self.clip_action_cancel_cb, bg=buttoncolor);
        readdatabutton.grid(column=1, row=2, padx=60, pady=20, sticky=W)

    def clip_action_cancel_cb(self):
        self.clipdia.destroy()

    def clip_action_ok_cb(self):
        try:
            mintime = datetime.strptime(self.minentry.get(), '%Y-%m-%d %H:%M:%S.%f')
        except ValueError:
            try:
                mintime = datetime.strptime(self.minentry.get(), '%Y-%m-%d %H:%M:%S')
            except ValueError:
                tkinter.messagebox.showerror("Error", "Time syntax error")
                return
        try:
            maxtime = datetime.strptime(self.maxentry.get(), '%Y-%m-%d %H:%M:%S.%f')
        except ValueError:
            try:
                maxtime = datetime.strptime(self.maxentry.get(), '%Y-%m-%d %H:%M:%S')
            except ValueError:
                tkinter.messagebox.showerror("Error", "Time syntax error")
                return
        self.clipdia.destroy()
        clip = EventClip(mintime, maxtime)
        self.stack.append(clip)
        self.wdata.clip(clip)
        self.redraw()
    
    # Clip Selected callback
    def clip_select_action_cb(self):
        if self.empty():
            return

        selected = self.tree.focus()
        if len(self.tree.selection()) == 0:
            tkinter.messagebox.showerror("Error", "Selection empty")
            return

        rows = []
        for item in self.tree.selection():
            rows.append(int(item))
            
        clip = EventClipSelected(rows)
        self.stack.append(clip)
        self.wdata.clip_selected(clip)
        self.redraw()

    # Split callback
    def split_action_cb(self):
        if self.empty():
            return

        selected = self.tree.focus()
        if selected == None:
            defaultvalue = str(self.wdata.wd['Time'][0])
        else:
            defaultvalue = str(self.tree.item(selected)['text'])
        ValueDialog(self.window, "Split Time", "Time", defaultvalue, self.split_ok_cb)
                    
    def split_ok_cb(self, valuestr):
        try:
            value = datetime.strptime(valuestr, '%Y-%m-%d %H:%M:%S.%f')
        except ValueError:
            try:
                value = datetime.strptime(valuestr, '%Y-%m-%d %H:%M:%S')
            except ValueError:
                tkinter.messagebox.showerror("Error", "Time syntax error")
                return

        wdwindow = WdWindow()
        idx = self.name.find('.')
        if idx == -1:            
            wdwindow.name = self.name + '_2'
        else:
            wdwindow.name = self.name[:idx] + '_2' + self.name[idx:]
        wdwindow.window.title(wdwindow.name)
        wdwindow.wdata.set_name(wdwindow.name)
        split = EventSplit(value)
        wdwindow.wdata = self.wdata.split(split)
        self.stack.append(split)
        if wdwindow.dataframe != None:
            wdwindow.dataframe.pack_forget()
            wdwindow.dataframe.destroy()
        wdwindow.create_dataframe()

        self.dataframe.pack_forget()
        self.dataframe.destroy()
        self.create_dataframe()

    
    # Filter callback
    def filter_action_cb(self):
        if self.empty():
            return

        FilterDialog(self.window, self.filter_ok_cb)
                    
    def filter_ok_cb(self, filter):
        self.wdata.filter(filter)
        self.stack.append(filter)
        
        self.dataframe.pack_forget()
        self.dataframe.destroy()
        self.create_dataframe()

    # Filter callback
    def filteronsupobject_action_cb(self):
        if self.empty():
            return

        selected = self.tree.focus()
        print("Selected", selected)
        if selected == None or selected == "":
            tkinter.messagebox.showerror("Error", "Select an event")
            return
        
        filter = EventFilter(0,0,'','', self.tree.item(selected)['values'][4])
        self.wdata.filter(filter)

        self.stack.append(filter)
        self.dataframe.pack_forget()
        self.dataframe.destroy()
        self.create_dataframe()

    # Filter alarms callback
    def filteralarms_action_cb(self):
        if self.empty():
            return
        typemask = Sev.mEventType_Alarm | Sev.mEventType_MaintenanceAlarm | \
                   Sev.mEventType_SystemAlarm | \
                   Sev.mEventType_UserAlarm1 | Sev.mEventType_UserAlarm2 | \
                   Sev.mEventType_UserAlarm3 | Sev.mEventType_UserAlarm4 | \
                   Sev.mEventType_Info | Sev.mEventType_InfoSuccess
        filter = EventFilter(typemask,0,'','','')
        self.wdata.filter(filter)

        self.stack.append(filter)
        self.dataframe.pack_forget()
        self.dataframe.destroy()
        self.create_dataframe()
                    
    # Previous
    def previous_action_cb(self):
        self.wdata.revert()
        if len(self.stack) == 0:
            return
        
        self.stack.pop()
        i = 0
        while i < len(self.stack):
            if isinstance(self.stack[i], EventFilter):
                self.wdata.filter(self.stack[i])
            elif isinstance(self.stack[i], EventClip):
                self.wdata.clip(self.stack[i])
            elif isinstance(self.stack[i], EventClipSelected):
                self.wdata.clip_selected(self.stack[i])
            elif isinstance(self.stack[i], EventSplit):
                self.wdata.split_redo(self.stack[i])
            i += 1

        self.dataframe.pack_forget()
        self.dataframe.destroy()
        self.create_dataframe()

    # Delete column callback
    def deletecolumn_action_cb(self):
        if self.empty():
            return

        answer = tkinter.messagebox.askquestion('Delete columns', 'Do you want to delete the selected columns')
        if answer == 'yes':
            mask = [None] * len(self.datasel)
            i = 0
            for sel in self.datasel:
                mask[i] = (sel.get() == 1)
                i += 1

            try:
                self.wdata.delete_columns(mask)
            except co.Error as e:
                tkinter.messagebox.showerror("Error", e.str)
                
            self.redraw()
            
    def close_action_cb(self, arg=0):
        self.window.destroy()
        main.remove_appl(self)

    # Save original dataframe
    def saveorig_action_cb(self): 
        if self.empty():
            return

        file = tkinter.filedialog.asksaveasfilename(initialdir='./', title='Select file',
                                              filetypes=[('dat files','*.dat'),('all files','*.*')],
                                              initialfile=self.name)
        if len(file) != 0:
            self.wdata.save_orig(file)


    # Save work dataframe
    def savewd_action_cb(self): 
        if self.empty():
            return

        file = tkinter.filedialog.asksaveasfilename(initialdir='./', title='Select file',
                                              filetypes=[('dat files','*.dat'),('all files','*.*')],
                                              initialfile=self.name)
        if len(file) != 0:
            self.wdata.save_wd(file)

    def fetch_sev_cb(self):
        fetch = FetchSev(self)

    # New window
    def new_action_cb(self, arg=0): 
        WdWindow()

    # Open from file
    def open_action_cb(self, arg=0): 
        file = tkinter.filedialog.askopenfilename(initialdir='./', title='Open file',
                                          filetypes=[('dat files','*.dat'),('all files','*.*')])
        if len(file) != 0:
            self.read_file(file)

    # Help callback
    def help_action_cb(self):
        os.system('co_help -s ' + pwr_exe + '/en_us/man_eva.dat &')

    def new_data(self, data):
        self.wdata.set_data(data)

        if self.dataframe != None:
            self.dataframe.pack_forget()
            self.dataframe.destroy()
        self.create_dataframe()

    def read_file(self, file):
        self.wdata.read_file(file)
            
        if self.toolbar != None:
            self.toolbar.pack_forget()
            self.toolbar.destroy()
        if self.dataframe != None:
            self.dataframe.pack_forget()
            self.dataframe.destroy()

        self.create_toolbar()
        self.create_dataframe()
        self.create_datamenu()
        idx = file.rfind('/')
        if idx == -1:
            self.name = file
        else:
            self.name = file[idx+1:]
        self.window.title(self.name)


    # Create frame with action buttons
    def create_datamenu(self):

        # Create menu
        menubar = Menu(self.window, bg=buttoncolor)
        filemenu = Menu(menubar, bg=buttoncolor)
        filemenu.add_command(label='New', command=self.new_action_cb, accelerator='Ctrl+N')
        filemenu.add_command(label='Open', command=self.open_action_cb, accelerator='Ctrl+O')
        filemenu.add_command(label='Import from server', command=self.fetch_sev_cb)
        filemenu.add_command(label='Save', command=self.savewd_action_cb)
        filemenu.add_command(label='Save Original Data', command=self.saveorig_action_cb)
        filemenu.add_command(label='Revert', command=self.revert_action_cb)
        filemenu.add_command(label='Rename', command=self.rename_action_cb)
        filemenu.add_command(label='Close', command=self.close_action_cb, accelerator='Ctrl+W')
        menubar.add_cascade(label='File', menu=filemenu)

        editmenu = Menu(menubar, bg=buttoncolor)
        editmenu.add_command(label='Search', command=self.search_action_cb, accelerator='Ctrl+F')
        editmenu.add_command(label='Search Next', command=self.searchnext_action_cb, accelerator='Ctrl+G')
        editmenu.add_command(label='Search Previous', command=self.searchprev_action_cb, accelerator='Shift+Ctrl+G')
        editmenu.add_command(label='Clip', command=self.clip_action_cb)
        editmenu.add_command(label='Crop not selected', command=self.clip_select_action_cb)
        editmenu.add_command(label='Split', command=self.split_action_cb)
        editmenu.add_command(label='Filter', command=self.filter_action_cb)
        editmenu.add_command(label='Filter on SupObject', command=self.filteronsupobject_action_cb)
        editmenu.add_command(label='Previous', command=self.previous_action_cb)
        menubar.add_cascade(label='Edit', menu=editmenu)
        
        viewmenu = Menu(menubar, bg=buttoncolor)
        viewmenu.add_command(label='Event frequency table', command=self.frequency_table_action_cb)
        viewmenu.add_command(label='Event frequency histogram', command=self.frequency_histogram_action_cb)
        viewmenu.add_command(label='Trend histogram', command=self.trend_histogram_action_cb)
        viewmenu.add_command(label='Number of not acked alarms plot', command=self.alarmplot_ack_action_cb)
        viewmenu.add_command(label='Number of not returned alarms plot', command=self.alarmplot_notret_action_cb)
        menubar.add_cascade(label='View', menu=viewmenu)

        helpmenu = Menu(menubar, bg=buttoncolor)
        helpmenu.add_command(label='Help', command=self.help_action_cb)
        menubar.add_cascade(label='Help', menu=helpmenu)
        self.window.config(menu=menubar)
        self.window.bind("<Control-w>", self.close_action_cb)
        self.window.bind("<Control-o>", self.open_action_cb)
        self.window.bind("<Control-n>", self.new_action_cb)
        self.window.bind("<Control-f>", self.search_action_cb)
        self.window.bind("<Control-g>", self.searchnext_action_cb)
        self.window.bind("<Control-Shift-Control-G>", self.searchprev_action_cb)
    
    def create_toolbar(self):
    
        self.toolbar = Frame(self.window, bg=bgcolor, bd=1, relief=RAISED)

        self.toolbar_revert_img = PhotoImage(file=pwr_exe+"/evatoolbar_revert.png")
        button = Button(self.toolbar, image=self.toolbar_revert_img, command=self.revert_action_cb, bg=buttoncolor)
        wow.Tooltip(button, text='Revert')
        button.pack(side=LEFT, padx=2, pady=2)

        self.toolbar_prev_img = PhotoImage(file=pwr_exe+"/evatoolbar_prev.png")
        button = Button(self.toolbar, image=self.toolbar_prev_img, command=self.previous_action_cb, bg=buttoncolor)
        wow.Tooltip(button, text='Back')
        button.pack(side=LEFT, padx=2, pady=2)

        self.toolbar_crop_img = PhotoImage(file=pwr_exe+"/evatoolbar_crop.png")
        button = Button(self.toolbar, image=self.toolbar_crop_img, command=self.clip_select_action_cb, bg=buttoncolor)
        wow.Tooltip(button, text='Crop not selected')
        button.pack(side=LEFT, padx=2, pady=2)

        self.toolbar_filter_img = PhotoImage(file=pwr_exe+"/evatoolbar_filter.png")
        button = Button(self.toolbar, image=self.toolbar_filter_img, command=self.filter_action_cb, bg=buttoncolor)
        wow.Tooltip(button, text='Filter')
        button.pack(side=LEFT, padx=2, pady=2)

        self.toolbar_filteralarms_img = PhotoImage(file=pwr_exe+"/evatoolbar_filteralarms.png")
        button = Button(self.toolbar, image=self.toolbar_filteralarms_img, command=self.filteralarms_action_cb, bg=buttoncolor)
        wow.Tooltip(button, text='Alarm and info message filter')
        button.pack(side=LEFT, padx=2, pady=2)

        self.toolbar_filtersup_img = PhotoImage(file=pwr_exe+"/evatoolbar_filtersup.png")
        button = Button(self.toolbar, image=self.toolbar_filtersup_img, command=self.filteronsupobject_action_cb, bg=buttoncolor)
        wow.Tooltip(button, text='SupObject filter')
        button.pack(side=LEFT, padx=2, pady=2)

        self.toolbar_plot_img = PhotoImage(file=pwr_exe+"/evatoolbar_plot.png")
        button = Button(self.toolbar, image=self.toolbar_plot_img, command=self.alarmplot_notret_action_cb, bg=buttoncolor)
        wow.Tooltip(button, text='Number of not returned alarms plot')
        button.pack(side=LEFT, padx=2, pady=2)

        self.toolbar_frequencyplot_img = PhotoImage(file=pwr_exe+"/evatoolbar_frequencyplot.png")
        button = Button(self.toolbar, image=self.toolbar_frequencyplot_img, command=self.frequency_histogram_action_cb, bg=buttoncolor)
        wow.Tooltip(button, text='Event frequency histogram')
        button.pack(side=LEFT, padx=2, pady=2)

        self.toolbar.pack(side=TOP, fill=X)

    def create_dataframe(self):
        global startframe

        if self.wdata.empty():
            return
        
        if 'startframe' in globals():    
            startframe.pack_forget()
            startframe.destroy()
        self.dataframe = Frame(self.window, bg=bgcolor)

        rowslabel = Label(self.dataframe, text='Dataset ' + str(len(self.wdata.wd)) + ' rows',
                          bg=bgcolor)
        rowslabel.pack()

        self.img_evred = PhotoImage(file=pwr_exe+"/eva_evred.png")
        self.img_evyellow = PhotoImage(file=pwr_exe+"/eva_evyellow.png")
        self.img_evblue = PhotoImage(file=pwr_exe+"/eva_evblue.png")
        self.img_evviolet = PhotoImage(file=pwr_exe+"/eva_evviolet.png")
        self.img_evsystemred = PhotoImage(file=pwr_exe+"/eva_evsystemred.png")
        self.img_evsystemyellow = PhotoImage(file=pwr_exe+"/eva_evsystemyellow.png")
        self.img_evsystemblue = PhotoImage(file=pwr_exe+"/eva_evsystemblue.png")
        self.img_evsystemviolet = PhotoImage(file=pwr_exe+"/eva_evsystemviolet.png")
        self.img_evmaintred = PhotoImage(file=pwr_exe+"/eva_evmaintred.png")
        self.img_evmaintyellow = PhotoImage(file=pwr_exe+"/eva_evmaintyellow.png")
        self.img_evmaintblue = PhotoImage(file=pwr_exe+"/eva_evmaintblue.png")
        self.img_evmaintviolet = PhotoImage(file=pwr_exe+"/eva_evmaintviolet.png")
        self.img_evgreen = PhotoImage(file=pwr_exe+"/eva_evgreen.png")
        self.img_evwhite = PhotoImage(file=pwr_exe+"/eva_evwhite.png")
        self.img_evack = PhotoImage(file=pwr_exe+"/eva_evack.png")
        self.img_evreturn = PhotoImage(file=pwr_exe+"/eva_evreturn.png")
        self.img_evblock = PhotoImage(file=pwr_exe+"/eva_evblock.png")
        self.img_evunblock = PhotoImage(file=pwr_exe+"/eva_evunblock.png")
        self.img_evnone = PhotoImage(file=pwr_exe+"/eva_evnone.png")

        self.tree = tkinter.ttk.Treeview(self.dataframe)
        self.tree.pack(expand=1, anchor=W, side=LEFT, fill=BOTH)

        self.tree["columns"] = ("Type", "Prio", "Text", "Name", "SupObject", "Id", "Status")

        self.tree.column("#0", width=200, minwidth=150, stretch=NO)
        self.tree.column("#1", width=100, minwidth=20, stretch=NO)
        self.tree.column("#2", width=20, minwidth=20, stretch=NO)
        self.tree.column("#3", width=300, minwidth=20)
        self.tree.column("#4", width=300, minwidth=20)
        self.tree.column("#5", width=200, minwidth=20)
        self.tree.column("#6", width=80, minwidth=20)
        self.tree.column("#7", width=20, minwidth=20)

        self.tree.heading("#0", text="Time", anchor=CENTER)
        self.tree.heading("#1", text="Type", anchor=W)
        self.tree.heading("#2", text="Prio", anchor=W)
        self.tree.heading("#3", text="Text", anchor=W)
        self.tree.heading("#4", text="Name", anchor=W)
        self.tree.heading("#5", text="SupObject", anchor=W)
        self.tree.heading("#6", text="Id", anchor=W)
        self.tree.heading("#7", text="Status", anchor=W)

        scroll = tkinter.ttk.Scrollbar(self.dataframe, orient="vertical", command=self.tree.yview)
        scroll.pack(anchor=E, expand=1, side=RIGHT, fill=Y)

        j = 0
        while j < len(self.wdata.wd):
            type = self.wdata.wd.iat[j,1]
            prio = self.wdata.wd.iat[j,2]
            img = None
            if type == Ev.eEvent_Alarm or \
               type == Ev.eEvent_UserAlarm1 or type == Ev.eEvent_UserAlarm2 or \
               type == Ev.eEvent_UserAlarm3 or type == Ev.eEvent_UserAlarm4:
                if prio == Ev.eEventPrio_A:
                    img = self.img_evred
                elif prio == Ev.eEventPrio_B:
                    img = self.img_evyellow
                elif prio == Ev.eEventPrio_C:
                    img = self.img_evblue
                elif prio == Ev.eEventPrio_D:
                    img = self.img_evviolet
            elif type == Ev.eEvent_SystemAlarm:
                if prio == Ev.eEventPrio_A:
                    img = self.img_evsystemred
                elif prio == Ev.eEventPrio_B:
                    img = self.img_evsystemyellow
                elif prio == Ev.eEventPrio_C:
                    img = self.img_evsystemblue
                elif prio == Ev.eEventPrio_D:
                    img = self.img_evsystemviolet
            elif type == Ev.eEvent_MaintenanceAlarm:
                if prio == Ev.eEventPrio_A:
                    img = self.img_evmaintred
                elif prio == Ev.eEventPrio_B:
                    img = self.img_evmaintyellow
                elif prio == Ev.eEventPrio_C:
                    img = self.img_evmaintblue
                elif prio == Ev.eEventPrio_D:
                    img = self.img_evmaintviolet
            elif type == Ev.eEvent_InfoSuccess:
                img = self.img_evgreen
            elif type == Ev.eEvent_Info:
                img = self.img_evwhite
            elif type == Ev.eEvent_Ack:
                img = self.img_evack
            elif type == Ev.eEvent_Return:
                img = self.img_evreturn
            elif type == Ev.eEvent_Block:
                img = self.img_evblock
            elif type == Ev.eEvent_Unblock:
                img = self.img_evunblock
            else:
                img = self.img_evnone
            
        
            self.tree.insert('', 'end', iid=str(j), text=str(self.wdata.wd.iat[j,0]),
                             image=img,
                             values=(Ev.eventtype_to_str(self.wdata.wd.iat[j,1]),
                                     Ev.eventprio_to_str(self.wdata.wd.iat[j,2]),
                                     '' if not isinstance(self.wdata.wd.iat[j,3],str) else self.wdata.wd.iat[j,3],
                                     self.wdata.wd.iat[j,4],
                                     self.wdata.wd.iat[j,5],str(self.wdata.wd.iat[j,6]),
                                     Ev.eventsts_to_str(self.wdata.wd.iat[j,7],self.wdata.wd.iat[j,1])))
            j += 1

        self.tree.configure(yscrollcommand=scroll.set)
        self.dataframe.pack(side=LEFT, fill=BOTH)

    def redraw(self):
        self.toolbar.pack_forget()
        self.toolbar.destroy()
        self.dataframe.pack_forget()
        self.dataframe.destroy()
        self.create_toolbar()
        self.create_dataframe()
        self.create_datamenu()    

#
# End of WdWindow class
#

#
# Fetch sev items class
#
class FetchSev:

    def on_configure(self, event):
        size = self.iteminnerframe.winfo_reqwidth(), self.iteminnerframe.winfo_reqheight()
        self.canvas.config(scrollregion="0 0 %s %s" % size)

    # Constructor, create empty window
    def __init__(self, wdata):
        self.itemframe = None
        self.wdata = wdata

        self.fswindow = Toplevel(window, bg=bgcolor)
        self.fswindow.title('Import from Sev Server')
        self.fswindow.geometry("350x200")
        main.set_icon(self.fswindow)
        self.create_filterframe()

    # Create filter frame
    def create_filterframe(self):

        if self.itemframe != None:
            self.itemframe.pack_forget()
            self.itemframe.destroy()

        self.filterframe = Frame(self.fswindow, bg=bgcolor)
        defaultserver = StringVar()

        # Server entry
        # Read last server from file
        try:
            fp = open(home + "/sevserver.dat", "r")
            srv = fp.read()
            fp.close()
        except IOError:
            srv = ''

        serverlabel = Label(self.filterframe, text='Sev server')
        serverlabel.grid(column=0, row=0, padx=20, pady=5, sticky=W)
        serverlabel.config(bg=bgcolor)
        self.serverentry = Entry(self.filterframe, textvariable=defaultserver)
        defaultserver.set(srv)
        self.serverentry.grid(column=1, row=0, padx=20, pady=5, sticky=W)
        self.serverentry.config(bg=bgcolor)

        # Filter entry
        filterlabel = Label(self.filterframe, text='Item Filter')
        filterlabel.grid(column=0, row=1, padx=20, pady=5, sticky=W)
        filterlabel.config(bg=bgcolor)
        self.filterentry = Entry(self.filterframe)
        self.filterentry.grid(column=1, row=1, padx=20, pady=5, sticky=W)
        self.filterentry.config(bg=bgcolor)

        # Fetch items button
        filterbutton = Button(self.filterframe, text='Fetch Items', command=self.fetchitems_cb, bg=buttoncolor)
        filterbutton.grid(column=1, row=2, padx=20, pady=5, sticky=W)
        self.filterframe.pack(side=LEFT, fill=X)

    # Create frame to show and select sev items

    def fetchitems_cb(self):

        self.fswindow.geometry("850x500")
        filtervalue = self.filterentry.get()
        self.server = self.serverentry.get()

        # Store server to file
        try:
            fp = open(home + "/sevserver.dat", "w")
            fp.write(self.server)
            fp.close()
        except IOError:
            pass

        try:
            pwrrt.init('sev_eva')
        except RuntimeError as e:
            tkinter.messagebox.showerror("Error", str(e))
            return

        try:
            self.items = pwrrt.getSevEventsItemList(self.server, filtervalue)
        except RuntimeError as e:
            tkinter.messagebox.showerror("Error", str(e))
            return

        self.itemframe = Frame(self.fswindow, bg=bgcolor)

        # Scrollbars
        scrollbar = Scrollbar(self.itemframe, orient=VERTICAL)
        self.canvas = Canvas(self.itemframe, bd= 0, bg=bgcolor, yscrollcommand=scrollbar.set)
        scrollbar.config(command=self.canvas.yview)
        scrollbar.pack(side=RIGHT, fill=Y)
        self.canvas.pack(expand=1, side=LEFT, fill=BOTH)
        self.canvas.xview("moveto", 0)
        self.canvas.yview("moveto", 0)
        self.iteminnerframe = Frame(self.canvas, bg=bgcolor)
        self.iteminnerframe.bind('<Configure>', self.on_configure)
        self.canvas.create_window(0, 0, window=self.iteminnerframe, anchor=NW)

        row = 0

        valframe = Frame(self.iteminnerframe, bg=bgcolor)

        # From entry
        defaultfrom = StringVar()
        fromlabel = Label(valframe, text='From')
        fromlabel.grid(column=0, row=row, padx=0, pady=5, sticky=W)
        fromlabel.config(bg=bgcolor)
        self.fromentry = Entry(valframe, textvariable=defaultfrom)
        defaultfrom.set('00:05:00')
        self.fromentry.grid(column=1, row=row, padx=20, pady=5, sticky=W)
        self.fromentry.config(bg=bgcolor)
        row += 1

        # To entry
        defaultto = StringVar()
        tolabel = Label(valframe, text='To')
        tolabel.grid(column=0, row=row, padx=0, pady=5, sticky=W)
        tolabel.config(bg=bgcolor)
        self.toentry = Entry(valframe, textvariable=defaultto)
        defaultto.set('now')
        self.toentry.grid(column=1, row=row, padx=20, pady=5, sticky=W)
        self.toentry.config(bg=bgcolor)
        row += 1

        # EventType entry
        eventtypelabel = Label(valframe, text='EventType')
        eventtypelabel.grid(column=0, row=row, padx=0, pady=5, sticky=W)
        eventtypelabel.config(bg=bgcolor)

        typeframe = Frame(valframe, bg=bgcolor)
        typeframe.grid(column=1, row=row, padx=20, pady=5, sticky=W)
        i = 0
        self.typesel = [None] * 17
        while i < 17:
            self.typesel[i] = IntVar()
            i += 1
        # Ack
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_Ack),
                               variable=self.typesel[0], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=0, row=0, padx=20, pady=5, sticky=W)
        # Block
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_Block),
                               variable=self.typesel[1], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=1, row=0, padx=20, pady=5, sticky=W)
        # Cancel
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_Cancel),
                               variable=self.typesel[2], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=2, row=0, padx=20, pady=5, sticky=W)
        # CancelBlock
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_CancelBlock),
                               variable=self.typesel[3], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=3, row=0, padx=20, pady=5, sticky=W)
        # Missing
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_Missing),
                               variable=self.typesel[4], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=4, row=0, padx=20, pady=5, sticky=W)
        # Reblock
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_Reblock),
                               variable=self.typesel[5], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=0, row=1, padx=20, pady=5, sticky=W)
        # Return
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_Return),
                               variable=self.typesel[6], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=1, row=1, padx=20, pady=5, sticky=W)
        # Unblock
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_Unblock),
                               variable=self.typesel[7], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=2, row=1, padx=20, pady=5, sticky=W)
        # Info
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_Info),
                               variable=self.typesel[16], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=3, row=1, padx=20, pady=5, sticky=W)
        # InfoSuccess
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_InfoSuccess),
                               variable=self.typesel[8], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=4, row=1, padx=20, pady=5, sticky=W)
        # Alarm
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_Alarm),
                               variable=self.typesel[9], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=0, row=2, padx=20, pady=5, sticky=W)
        # MantenanceAlarm
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_MaintenanceAlarm),
                               variable=self.typesel[10], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=1, row=2, padx=20, pady=5, sticky=W)
        # SystemAlarm
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_SystemAlarm),
                               variable=self.typesel[11], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=2, row=2, padx=20, pady=5, sticky=W)
        # UserAlarm1
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_UserAlarm1),
                               variable=self.typesel[12], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=3, row=2, padx=20, pady=5, sticky=W)
        # UserAlarm2
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_UserAlarm2),
                               variable=self.typesel[13], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=4, row=2, padx=20, pady=5, sticky=W)
        # UserAlarm3
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_UserAlarm3),
                               variable=self.typesel[14], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=0, row=3, padx=20, pady=5, sticky=W)
        # UserAlarm4
        checkbox = Checkbutton(typeframe, text=Ev.eventtype_to_str(Ev.eEvent_UserAlarm4),
                               variable=self.typesel[15], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=1, row=3, padx=20, pady=5, sticky=W)
        row += 4

        
        # EventPrio entry
        eventpriolabel = Label(valframe, text='EventPrio')
        eventpriolabel.grid(column=0, row=row, padx=0, pady=5, sticky=W)
        eventpriolabel.config(bg=bgcolor)

        prioframe = Frame(valframe, bg=bgcolor)
        prioframe.grid(column=1, row=row, padx=20, pady=5, sticky=W)
        row += 1
        i = 0
        self.priosel = [None] * 4
        self.priosel[i] = IntVar()
        checkbox = Checkbutton(prioframe, text=Ev.eventprio_to_str(Ev.eEventPrio_A),
                               variable=self.priosel[0], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=0, row=0, padx=20, pady=5, sticky=W)
        i += 1
        self.priosel[i] = IntVar()
        checkbox = Checkbutton(prioframe, text=Ev.eventprio_to_str(Ev.eEventPrio_B),
                               variable=self.priosel[1], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=1, row=0, padx=20, pady=5, sticky=W)
        i += 1
        self.priosel[i] = IntVar()
        checkbox = Checkbutton(prioframe, text=Ev.eventprio_to_str(Ev.eEventPrio_C),
                               variable=self.priosel[2], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=2, row=0, padx=20, pady=5, sticky=W)
        i += 1
        self.priosel[i] = IntVar()
        checkbox = Checkbutton(prioframe, text=Ev.eventprio_to_str(Ev.eEventPrio_D),
                               variable=self.priosel[3], highlightthickness=0,
                               bg=bgcolor)
        checkbox.grid(column=3, row=0, padx=20, pady=5, sticky=W)
        i += 1

        # Max rows
        defaultmax = StringVar()
        maxlabel = Label(valframe, text='Max')
        maxlabel.grid(column=0, row=row, padx=0, pady=5, sticky=W)
        maxlabel.config(bg=bgcolor)
        self.maxentry = Entry(valframe, textvariable=defaultmax)
        defaultmax.set('500')
        self.maxentry.grid(column=1, row=row, padx=20, pady=5, sticky=W)
        self.maxentry.config(bg=bgcolor)
        row += 1


        readdatabutton = Button(valframe, text="Read DataSet", command=self.readdata_cb, bg=buttoncolor);
        readdatabutton.grid(column=0, row=row, padx=0, pady=20, sticky=W)
        row += 1

        valframe.grid(column=0, row=0, padx=20, pady=5, sticky=W)

        i = 0
        row = 1
        self.sel = [None] * len(self.items)
        for item in self.items:
            self.sel[i] = IntVar()
            text = item[0]
            item_checkbox = Checkbutton(self.iteminnerframe, text=text, variable=self.sel[i], highlightthickness=0,
                                        bg=bgcolor)
            item_checkbox.grid(column=0, row=i+row, padx=20, pady=5, sticky=W)
            i = i + 1

        self.filterframe.pack_forget()
        self.filterframe.destroy()
        self.itemframe.pack(expand=1, fill=BOTH)



    # Read dataframe from sev database
    def readdata_cb(self):
        # Get selected items

        wdname = []
        dataattr = []
        dataoid = []
        isobject = []
        wdcol = []

        i = 0
        j = 0
        for selected in self.sel:
            if selected.get():
                oid = self.items[i][1]
                j += 1
            i += 1
        
        if j != 1:
            tkinter.messagebox.showerror("Error", "Select one item")
            return

        fromvalue = self.fromentry.get()
        tovalue = self.toentry.get()

        eventtypevalue = 0
        m = 1
        for sel in self.typesel:
            if sel.get() == 1:
                eventtypevalue += m
            m = m << 1

        eventpriovalue = 0
        m = 1
        for sel in self.priosel:
            if sel.get() == 1:
                eventpriovalue += m
            m = m << 1
        maxvalue = int(self.maxentry.get())
        print(fromvalue, tovalue)

        try:
            pwrrt.init('sev_eva')
        except RuntimeError as e:
            tkinter.messagebox.showerror("Error", str(e))
            return

        try:
            result = pwrrt.getSevEventsDataFrame( self.server, oid,
                                                  fromvalue, tovalue, eventtypevalue,
                                                  eventpriovalue, '', '', maxvalue)
        except RuntimeError as e:
            tkinter.messagebox.showerror("Error", str(e))
            return
            
        
        if result == None or len(result) == 0:
            tkinter.messagebox.showerror("Error", "No events found")
            return
            
        origdata = pd.DataFrame(data=result)
        self.wdata.new_data(origdata) 

        self.fswindow.destroy()


#
# End FetchSev class
#

    
file = ''
try:
    opts, args = getopt.getopt(sys.argv[1:], "f:r:", ["--file"])
except getopt.GetoptError:
    print('sev_eva.py [-f <file>]')
    sys.exit(2)

for opt, arg in opts:
    if opt == "-h":
        print('sev_eva.py [-f <file>]')
    if opt in ("-f", "--file"):
        file = arg
        
pwr_exe = os.environ.get('pwr_exe')
home = os.environ.get('HOME')
bgcolor = 'white'
buttoncolor = '#F0F0F0'

class MvMain:

    def __init__(self):
        global window
        global main

        self.applist = []
        
        # Create window
        main = self
        window = Tk()
        window.withdraw()
        wdwindow = WdWindow()
        if file != '':
            wdwindow.read_file(file)

    def add_appl(self, a):
        self.applist.append(a)

    def remove_appl(self, a):
        self.applist.remove(a)
        if len(self.applist) == 0:
            sys.exit()

    def set_icon(self, w):
        icon = PhotoImage(file=pwr_exe + '/pwr_icon16.png')
        window.tk.call('wm', 'iconphoto', w._w, icon)

            
MvMain()
window.mainloop()

