#!/usr/bin/python3
#
# ProviewR   Open Source Process Control.
# Copyright (C) 2005-2019 SSAB EMEA AB.
#
# This file is part of ProviewR.
#
# This program is free software; you can redistribute it and/or 
# modify it under the terms of the GNU General Public License as 
# published by the Free Software Foundation, either version 2 of 
# the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful 
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License 
# along with ProviewR. If not, see <http://www.gnu.org/licenses/>
#
# Linking ProviewR statically or dynamically with other modules is
# making a combined work based on ProviewR. Thus, the terms and
# conditions of the GNU General Public License cover the whole 
# combination.
#
# In addition, as a special exception, the copyright holders of
# ProviewR give you permission to, from the build function in the
# ProviewR Configurator, combine ProviewR with modules generated by the
# ProviewR PLC Editor to a PLC program, regardless of the license
# terms of these modules. You may copy and distribute the resulting
# combined work under the terms of your choice, provided that every 
# copy of the combined work is accompanied by a complete copy of 
# the source code of ProviewR (the version used to produce the
# combined work), being distributed under the terms of the GNU 
# General Public License plus this exception.
#

# Sev data analysis application


from tkinter import *
import tkinter.filedialog
import tkinter.messagebox
import sys
import math
import time
import getopt
import os
import pwrrt
from datetime import datetime
import statsmodels.api as am
from statsmodels.sandbox.regression.predstd import wls_prediction_std
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.linear_model import Ridge
from sklearn.linear_model import Lasso
from sklearn.neural_network import MLPRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import r2_score
from scipy.interpolate import interp1d
import matplotlib
matplotlib.use('TkAgg')
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import pickle
import co
import wow
from rt_mva import *
from rt_mva_msg import *

class ValueDialog:
    def __init__(self, parent, title, text, rename_ok_cb):

        top = self.top = Toplevel(parent)
        main.set_icon(top)

        self.top.title(title)

        label = Label(top, text=text)
        label.grid(column=0, row=0, padx=10, pady=5, sticky=W)

        self.entry = Entry(top, width=15)
        self.entry.grid(column=1, row=0, padx=10, pady=5, sticky=W)
        self.entry.focus()
        self.rename_ok_cb = rename_ok_cb

        button = Button(top, text="Ok", command=self.ok_cb, width=10)
        button.grid(column=0, row=1, padx=10, pady=5, sticky=W)
    
        button = Button(top, text="Cancel", command=self.cancel_cb, width=10)
        button.grid(column=1, row=1, padx=10, pady=5, sticky=W)
    
        self.top.bind('<Return>', self.ok_cb)


    def cancel_cb(self):
        self.top.destroy()

    def ok_cb(self, arg=0):
        value = self.entry.get()
        self.rename_ok_cb(value)
        self.top.destroy()

class SelectDialog:

    def __init__(self, parent, itemlist, cb_func):
        self.window = Toplevel(parent, bg=bgcolor)
        main.set_icon(self.window)
        self.window.title("Select data")
        self.itemlist = itemlist
        self.cb_func = cb_func
        #self.window.minsize(600, 200)
        
        self.listbox = Listbox(self.window)
        self.listbox.grid(row=0, column=0)
        
        for item in itemlist:
            self.listbox.insert(END, item)
            
        button = Button(self.window, text='Ok', command=self.ok_cb, bg=buttoncolor).grid(row=1, column=0)

    def ok_cb(self): 
        idx = self.listbox.curselection()
        self.cb_func(self.itemlist[idx[0]])
        self.window.destroy()

#
# Linear regression model class
#
class LinRegModel:
    TYPE_LINEAR_REGRESSION = 1
    TYPE_RIDGE_REGRESSION = 2
    TYPE_LASSO_REGRESSION = 3

    # Constructor, create empty window
    def __init__(self, wdwindow, type):
        self.lr_wframe = None
        self.lr_pframe = None
        self.wdwindow = wdwindow
        self.wdata = wdwindow.wdata
        self.type = type
        self.fignum = 0

        self.lrwindow = Toplevel(wdwindow.window, bg=bgcolor)
        self.lrwindow.title('Linear Regression ' + wdwindow.name)
        self.lrwindow.minsize(600, 300)
        main.set_icon(self.lrwindow)

        # Create menu
        menubar = Menu(self.lrwindow, bg=buttoncolor)
        filemenu = Menu(menubar, bg=buttoncolor)
        filemenu.add_command(label='Create Model', command=self.create_action_cb)
        filemenu.add_command(label='Apply Model', command=self.open_action_cb)
        filemenu.add_command(label='Save Model', command=self.save_action_cb)
        menubar.add_cascade(label='File', menu=filemenu)
        helpmenu = Menu(menubar, bg=buttoncolor)
        helpmenu.add_command(label='Help', command=self.help_action_cb)
        menubar.add_cascade(label='Help', menu=helpmenu)

        self.lrwindow.config(menu=menubar)

        self.lr_argframe = Frame(self.lrwindow, bg=bgcolor)
        if self.type == self.TYPE_RIDGE_REGRESSION:
            # Solver options list
            list = ['auto', 'svd', 'cholesky', 'lsqr', 'sparse_cg', 'sag', 'saga']
            self.solver = StringVar()
            self.solver.set('auto')
            label = Label(self.lr_argframe, text='Solver')
            label.grid(column=0, row=0, padx=0, pady=5, sticky=W)
            label.config(bg=bgcolor)
            optmenu = OptionMenu(self.lr_argframe, self.solver, *list)
            optmenu.grid(column=1, row=0, padx=20, pady=5, sticky=W)
            optmenu.config(bg=bgcolor)

            # Max iter entry
            self.maxiter = IntVar()
            label = Label(self.lr_argframe, text='Max Iterations')
            label.grid(column=0, row=1, padx=0, pady=5, sticky=W)
            label.config(bg=bgcolor)
            entry = Entry(self.lr_argframe, textvariable=self.maxiter, width=8)
            self.maxiter.set(1000)
            entry.grid(column=1, row=1, padx=20, pady=5, sticky=W)
            entry.config(bg=bgcolor)

            # alpha entry
            label = Label(self.lr_argframe, text='Alpha')
            label.grid(column=0, row=2, padx=0, pady=5, sticky=W)
            label.config(bg=bgcolor)
            self.alpha = DoubleVar()
            entry = Entry(self.lr_argframe, textvariable=self.alpha, width=8)
            self.alpha.set(1.0)
            entry.grid(column=1, row=2, padx=20, pady=5, sticky=W)
            entry.config(bg=bgcolor)

            self.lr_argframe.pack(side=TOP, fill=X)

        elif self.type == self.TYPE_LASSO_REGRESSION:
            # Max iter entry
            self.maxiter = IntVar()
            label = Label(self.lr_argframe, text='Max Iterations')
            label.grid(column=0, row=1, padx=0, pady=5, sticky=W)
            label.config(bg=bgcolor)
            entry = Entry(self.lr_argframe, textvariable=self.maxiter, width=8)
            self.maxiter.set(20000)
            entry.grid(column=1, row=1, padx=20, pady=5, sticky=W)
            entry.config(bg=bgcolor)

            # alpha entry
            label = Label(self.lr_argframe, text='Alpha')
            label.grid(column=0, row=2, padx=0, pady=5, sticky=W)
            label.config(bg=bgcolor)
            self.alpha = DoubleVar()
            entry = Entry(self.lr_argframe, textvariable=self.alpha, width=8)
            self.alpha.set(1.0)
            entry.grid(column=1, row=2, padx=20, pady=5, sticky=W)
            entry.config(bg=bgcolor)

            self.lr_argframe.pack(side=TOP, fill=X)



    # Save menu callback
    def save_action_cb(self):

        file = tkinter.filedialog.asksaveasfilename(initialdir='./', title='Select file',
                                          filetypes=[('lrm files','*.lrm'),('all files','*.*')])
        if file != '':
            fp = open(file, 'w')
            fp.write('Intercept ' + str(self.slr.intercept_[0]) + '\n')
            i = 0
            for name in self.wdata.wdname:
                if i != 0:
                    if self.type == self.TYPE_LASSO_REGRESSION:
                        fp.write( name + ' ' + str(self.slr.coef_[i-1]) + '\n')
                    else:
                        fp.write( name + ' ' + str(self.slr.coef_[0][i-1]) + '\n')
                i += 1
            fp.close()

    # Open menu callback
    def open_action_cb(self):
        file = tkinter.filedialog.askopenfilename(initialdir='./', title='Open Coefficients',
                                            filetypes=[('lrm files','*.lrm'),('all files','*.*')])
        if file != '':
            lrname = []
            lrcoeff = []
            fp = open(file, 'r')
            for line in fp:
                token = line.rstrip().split(" ")
                lrname.append(token[0])
                lrcoeff.append(float(token[1]))
            fp.close()

            if len(lrname) != len(self.wdata.wdname):
                tkinter.messagebox.showerror("Error", "Not matching number of attributes")
                return
        
            coeff = [None]*len(self.wdata.wdname)
            i = 0
            coeff[0] = lrcoeff[0]
            for name in lrname:
                if i > 0:
                    j = 0
                    found = False
                    for wname in self.wdata.wdname:
                        if j > 0:
                            if name == wname:
                                found = True
                                coeff[j] = lrcoeff[i]
                                break
                        j += 1
                    if not found:
                        tkinter.messagebox.showerror("Error", "Can't find " + name)
                        return
                i += 1

            for c in coeff:
                if c == None:
                    tkinter.messagebox.showerror("Error", "Not matching index")
                    return

            i = 0
            for n in self.wdata.wdname:
                if i == 0:
                    print(coeff[0], 'Intercept')
                else:
                    print(coeff[i], n)
                    i += 1

            self.regrcoef_draw(coeff)
        
    # Create menu callback
    def create_action_cb(self):

        if self.type == self.TYPE_LINEAR_REGRESSION:
            self.slr = LinearRegression()

        elif self.type == self.TYPE_RIDGE_REGRESSION:
            solver = self.solver.get()
            maxiter = self.maxiter.get()
            alpha = self.alpha.get()

            self.slr = Ridge(alpha=alpha, max_iter=maxiter, solver=solver)

        elif self.type == self.TYPE_LASSO_REGRESSION:
            maxiter = self.maxiter.get()
            alpha = self.alpha.get()

            self.slr = Lasso(alpha=alpha, max_iter=maxiter)
    
        reg = self.slr.fit(self.wdata.wd.iloc[:,1:], self.wdata.wd.iloc[:,0:1])
        #print "params", self.slr.get_params()
        #print "coef ", self.slr.coef_
        #print "intercept ", self.slr.intercept_
        coeff = [None]*len(self.wdata.wdname)
        coeff[0] = self.slr.intercept_[0]
        if self.type == self.TYPE_LASSO_REGRESSION:
            for i in range(1,len(self.wdata.wdname)):
                #print i, self.slr.coef_[i-1]
                coeff[i] = self.slr.coef_[i-1]
        else:
            for i in range(1,len(self.wdata.wdname)):
                #print i, self.slr.coef_[0][i-1]
                coeff[i] = self.slr.coef_[0][i-1]
        self.regrcoef_draw(coeff)

    # Draw coefficients and curves
    def regrcoef_draw(self, coeff):

        textheigt = len(self.wdata.wdname) + 2
        maxlen = 0
        for name in self.wdata.wdname:
            if len(name) > maxlen:
                maxlen = len(name)
                              
        textlen = 0.01 * maxlen
        textpages = 1 + math.floor(textheigt/9)


        layo = (2 + textpages) * 100 + 10

        j = textpages
        fig = plt.figure(self.fignum, figsize=(8,2*(2 + textpages)))
        self.fignum += 1
        fig.canvas.set_window_title('Linear Regression ' + self.wdwindow.name)
        # Calculate model values
        res = pd.Series([coeff[0]]*len(self.wdata.wd))
        i = 0
        for name in self.wdata.wdname:
            if i != 0:
                res += coeff[i] * self.wdata.wd[self.wdata.wdcol[i]]
            i += 1

        # Get difference between actual value and model
        diff = self.wdata.wd[self.wdata.wdcol[0]] - res

        # Draw score
        offs = 0.95
        score = r2_score(res, self.wdata.wd[self.wdata.wdcol[0]])
        plt.gcf().text(0.1, offs, 'Score', fontsize=10)
        plt.gcf().text(0.1 + textlen, offs, "%.4f" % score, fontsize=10)

        #Draw intercept
        offs -= 0.035
        plt.gcf().text(0.1, offs, 'Intercept', fontsize=10)
        plt.gcf().text(0.1 + textlen, offs, "%f" % coeff[0], fontsize=10)

        # Draw coefficients
        i = 0
        for name in self.wdata.wdname:
            if i != 0:
                offs -= 0.035
                plt.gcf().text(0.1, offs, name, fontsize=10)
                plt.gcf().text(0.1 + textlen, offs, "%f" % coeff[i], fontsize=10)
            i += 1

        ax = plt.subplot(layo+j+1)
        plt.subplot(layo+j+1)
        plt.plot(self.wdata.wdtime, self.wdata.wd[self.wdata.wdcol[0]])
        plt.plot(self.wdata.wdtime, res, label='Model')
        plt.legend(loc='center left', bbox_to_anchor=(1, 0.5));

        j = j + 1

        # Plot difference
        plt.subplot(layo+j+1)
        plt.plot(self.wdata.wdtime, diff, label='Diff')
        plt.legend(loc='center left', bbox_to_anchor=(1, 0.5));

        plt.show()
        return


        plotwind = Toplevel(self.lrwindow, bg=bgcolor)
        plotwind.title('Linear Regression ' + self.wdwindow.name)
        plotwind.minsize(600, 300)
        main.set_icon(plotwind)

        # Calculate model values
        res = pd.Series([coeff[0]]*len(self.wdata.wd))
        i = 0
        for name in self.wdata.wdname:
            if i != 0:
                res += coeff[i] * self.wdata.wd[self.wdata.wdcol[i]]
            i += 1

        # Get difference between actual value and model
        diff = self.wdata.wd[self.wdata.wdcol[0]] - res

        self.lr_wframe = Frame(plotwind, bg=bgcolor)

        score = r2_score(res, self.wdata.wd[self.wdata.wdcol[0]])
        label = Label(self.lr_wframe, text='Score', bg=bgcolor)
        label.grid(column=0, row=0, padx=20, pady=5, sticky=W)
        label = Label(self.lr_wframe, text=str(score), bg=bgcolor)
        label.grid(column=1, row=0, padx=20, pady=5, sticky=W)

        # Draw linreg coefficients
        msg = 'Intercept'
        label = Label(self.lr_wframe, text=msg, bg=bgcolor)
        label.grid(column=0, row=1, padx=20, pady=5, sticky=W)
        msg = str(coeff[0])
        label = Label(self.lr_wframe, text=msg, bg=bgcolor)
        label.grid(column=1, row=1, padx=20, pady=5, sticky=W)

        i = 0
        for name in self.wdata.wdname:
            if i != 0:
                label = Label(self.lr_wframe, text=name, bg=bgcolor)
                label.grid(column=0, row=i+1, padx=20, pady=5, sticky=W)
                msg = str(coeff[i])
                label = Label(self.lr_wframe, text=msg, bg=bgcolor)
                label.grid(column=1, row=i+1, padx=20, pady=5, sticky=W)
            i += 1

        self.lr_wframe.pack(side=TOP, fill=X)

        layo = 2 * 100 + 10

        j = 0
        fig = plt.figure()

        # Plot actual value and model value
        plt.subplot(layo+j+1)
        plt.plot(self.wdata.wdtime, self.wdata.wd[self.wdata.wdcol[0]])
        plt.plot(self.wdata.wdtime, res, label='Model')
        plt.legend(loc='center left', bbox_to_anchor=(1, 0.5));
        j = j + 1

        # Plot difference
        plt.subplot(layo+j+1)
        plt.plot(self.wdata.wdtime, diff, label='Diff')
        plt.legend(loc='center left', bbox_to_anchor=(1, 0.5));

        self.lr_pframe = Frame(plotwind, bg=bgcolor)
        canvas = FigureCanvasTkAgg(fig, master=self.lr_pframe)
        plot_widget = canvas.get_tk_widget()
        plot_widget.grid(column=0, row=0)
        self.lr_pframe.pack(side=BOTTOM, fill=X)

    # Help callback
    def help_action_cb(self):
        os.system('co_help -s ' + pwr_exe + '/en_us/man_mva.dat -t mva_linreg_model &')
        pass

#
# End Linear regression class
#

#
# MLP regressor model class
#
class MLPModel:
    # Constructor, create empty window
    def __init__(self, wdwindow):
        self.lr_wframe = None
        self.lr_pframe = None
        self.wdwindow = wdwindow
        self.wdata = wdwindow.wdata
        self.fignum = 1
        self.scaler = 'No'

        self.lrwindow = Toplevel(wdwindow.window, bg=bgcolor)
        self.lrwindow.title('MLP Regressor ' + wdwindow.name)
        self.lrwindow.minsize(600, 300)
        main.set_icon(self.lrwindow)

        # Create menu
        menubar = Menu(self.lrwindow, bg=buttoncolor)
        filemenu = Menu(menubar, bg=buttoncolor)
        filemenu.add_command(label='Create Model', command=self.create_action_cb)
        filemenu.add_command(label='Apply Model', command=self.open_action_cb)
        filemenu.add_command(label='Save Model', command=self.save_action_cb)
        filemenu.add_command(label='Export Model', command=self.export_action_cb)
        menubar.add_cascade(label='File', menu=filemenu)
        helpmenu = Menu(menubar, bg=buttoncolor)
        helpmenu.add_command(label='Help', command=self.help_action_cb)
        menubar.add_cascade(label='Help', menu=helpmenu)

        self.lrwindow.config(menu=menubar)

        # Scaler options list
        list = ['No', 'MinMax', 'Standard']
        self.scaleropt = StringVar()
        self.scaleropt.set('No')
        label = Label(self.lrwindow, text='Scaler')
        label.grid(column=0, row=0, padx=0, pady=5, sticky=W)
        label.config(bg=bgcolor)
        optmenu = OptionMenu(self.lrwindow, self.scaleropt, *list)
        optmenu.grid(column=1, row=0, padx=20, pady=5, sticky=W)
        optmenu.config(bg=bgcolor)

        # Solver options list
        list = ['adam', 'lbfgs', 'sgd']
        self.solver = StringVar()
        self.solver.set('adam')
        label = Label(self.lrwindow, text='Solver')
        label.grid(column=0, row=1, padx=0, pady=5, sticky=W)
        label.config(bg=bgcolor)
        optmenu = OptionMenu(self.lrwindow, self.solver, *list)
        optmenu.grid(column=1, row=1, padx=20, pady=5, sticky=W)
        optmenu.config(bg=bgcolor)

        # Activation options list
        list = ['identity', 'logistic', 'tanh', 'relu']
        self.activation = StringVar()
        self.activation.set('tanh')
        label = Label(self.lrwindow, text='Activation')
        label.grid(column=0, row=2, padx=0, pady=5, sticky=W)
        label.config(bg=bgcolor)
        optmenu = OptionMenu(self.lrwindow, self.activation, *list)
        optmenu.grid(column=1, row=2, padx=20, pady=5, sticky=W)
        optmenu.config(bg=bgcolor)

        # Max iter entry
        self.maxiter = IntVar()
        label = Label(self.lrwindow, text='Max Iterations')
        label.grid(column=0, row=3, padx=0, pady=5, sticky=W)
        label.config(bg=bgcolor)
        entry = Entry(self.lrwindow, textvariable=self.maxiter, width=8)
        self.maxiter.set(20000)
        entry.grid(column=1, row=3, padx=20, pady=5, sticky=W)
        entry.config(bg=bgcolor)

        # Hidden layer sizes entry
        label = Label(self.lrwindow, text='Hidden Layer Sizes')
        label.grid(column=0, row=4, padx=0, pady=5, sticky=W)
        label.config(bg=bgcolor)

        self.layersize1 = IntVar()
        entry = Entry(self.lrwindow, textvariable=self.layersize1, width=4)
        self.layersize1.set(20)
        entry.grid(column=1, row=4, padx=20, pady=5, sticky=W)
        entry.config(bg=bgcolor)

        self.layersize2 = IntVar()
        entry = Entry(self.lrwindow, textvariable=self.layersize2, width=4)
        self.layersize2.set(20)
        entry.grid(column=2, row=4, padx=20, pady=5, sticky=W)
        entry.config(bg=bgcolor)

        self.layersize3 = IntVar()
        entry = Entry(self.lrwindow, textvariable=self.layersize3, width=4)
        self.layersize3.set(20)
        entry.grid(column=3, row=4, padx=20, pady=5, sticky=W)
        entry.config(bg=bgcolor)

        self.layersize4 = IntVar()
        entry = Entry(self.lrwindow, textvariable=self.layersize4, width=4)
        self.layersize4.set(0)
        entry.grid(column=4, row=4, padx=20, pady=5, sticky=W)
        entry.config(bg=bgcolor)

        self.layersize5 = IntVar()
        entry = Entry(self.lrwindow, textvariable=self.layersize5, width=4)
        self.layersize5.set(0)
        entry.grid(column=5, row=4, padx=20, pady=5, sticky=W)
        entry.config(bg=bgcolor)

        # alpha entry
        label = Label(self.lrwindow, text='Alpha')
        label.grid(column=0, row=5, padx=0, pady=5, sticky=W)
        label.config(bg=bgcolor)
        self.alpha = DoubleVar()
        entry = Entry(self.lrwindow, textvariable=self.alpha, width=8)
        self.alpha.set(0.0001)
        entry.grid(column=1, row=5, padx=20, pady=5, sticky=W)
        entry.config(bg=bgcolor)

        # beta_1 entry
        label = Label(self.lrwindow, text='Beta1')
        label.grid(column=0, row=6, padx=0, pady=5, sticky=W)
        label.config(bg=bgcolor)
        self.beta1 = DoubleVar()
        entry = Entry(self.lrwindow, textvariable=self.beta1, width=8)
        self.beta1.set(0.9)
        entry.grid(column=1, row=6, padx=20, pady=5, sticky=W)
        entry.config(bg=bgcolor)

        # beta_2 entry
        label = Label(self.lrwindow, text='Beta2')
        label.grid(column=0, row=7, padx=0, pady=5, sticky=W)
        label.config(bg=bgcolor)
        self.beta2 = DoubleVar()
        entry = Entry(self.lrwindow, textvariable=self.beta2, width=8)
        self.beta2.set(0.999)
        entry.grid(column=1, row=7, padx=20, pady=5, sticky=W)
        entry.config(bg=bgcolor)

        # Learning rate options list
        list = ['constant', 'invscaling', 'adaptive']
        self.learningrate = StringVar()
        self.learningrate.set('constant')
        label = Label(self.lrwindow, text='Learning rate')
        label.grid(column=0, row=8, padx=0, pady=5, sticky=W)
        label.config(bg=bgcolor)
        optmenu = OptionMenu(self.lrwindow, self.learningrate, *list)
        optmenu.grid(column=1, row=8, padx=20, pady=5, sticky=W)
        optmenu.config(bg=bgcolor)

        # learning rate init entry
        label = Label(self.lrwindow, text='Initial learning rate')
        label.grid(column=0, row=9, padx=0, pady=5, sticky=W)
        label.config(bg=bgcolor)
        self.learningrateinit = DoubleVar()
        entry = Entry(self.lrwindow, textvariable=self.learningrateinit, width=8)
        self.learningrateinit.set(0.001)
        entry.grid(column=1, row=9, padx=20, pady=5, sticky=W)
        entry.config(bg=bgcolor)

        # tolerance entry
        label = Label(self.lrwindow, text='Tolerance')
        label.grid(column=0, row=10, padx=0, pady=5, sticky=W)
        label.config(bg=bgcolor)
        self.tol = DoubleVar()
        entry = Entry(self.lrwindow, textvariable=self.tol, width=8)
        self.tol.set(0.0001)
        entry.grid(column=1, row=10, padx=20, pady=5, sticky=W)
        entry.config(bg=bgcolor)

        # Verbose options list
        list = ['True', 'False']
        self.verbose = StringVar()
        self.verbose.set('True')
        label = Label(self.lrwindow, text='Verbose')
        label.grid(column=0, row=11, padx=0, pady=5, sticky=W)
        label.config(bg=bgcolor)
        optmenu = OptionMenu(self.lrwindow, self.verbose, *list)
        optmenu.grid(column=1, row=11, padx=20, pady=5, sticky=W)
        optmenu.config(bg=bgcolor)


    # Save menu callback
    def save_action_cb(self):

        file = tkinter.filedialog.asksaveasfilename(initialdir='./', title='Select file',
                                          filetypes=[('mlpm files','*.mlpm'),('all files','*.*')])
        if file != '':
            params = self.mlp.get_params()

            all = [[self.mlp.n_layers_, self.mlp.n_outputs_, self.mlp.out_activation_], params,
                   self.mlp.intercepts_, self.mlp.coefs_, self.scaler, self.scaler_c0, self.scaler_c1]
            pickle.dump(all, open(file, 'wb'))

    # Open menu callback
    def open_action_cb(self):
        file = tkinter.filedialog.askopenfilename(initialdir='./', title='Open Coefficients',
                                            filetypes=[('mlpm files','*.mlpm'),('all files','*.*')])
        if file != '':
            all = pickle.load(open(file, 'rb'))

            self.mlp = MLPRegressor()

            params = all[1]
            for par in params:
                if par == 'beta_1':
                    self.mlp.set_params(beta_1=params[par])
                elif par == 'warm_start':
                    self.mlp.set_params(warm_start=params[par])
                elif par == 'beta_2':
                    self.mlp.set_params(beta_2=params[par])
                elif par == 'shuffle':
                    self.mlp.set_params(shuffle=params[par])
                elif par == 'verbose':
                    self.mlp.set_params(verbose=params[par])
                elif par == 'nesterovs_momentum':
                    self.mlp.set_params(nesterovs_momentum=params[par])
                elif par == 'activation':
                    self.mlp.set_params(activation=params[par])
                elif par == 'max_iter':
                    self.mlp.set_params(max_iter=params[par])
                elif par == 'batch_size':
                    self.mlp.set_params(batch_size=params[par])
                elif par == 'power_t':
                    self.mlp.set_params(power_t=params[par])
                elif par == 'random_state':
                    self.mlp.set_params(random_state=params[par])
                elif par == 'momentum':
                    self.mlp.set_params(momentum=params[par])
                elif par == 'tol':
                    self.mlp.set_params(tol=params[par])
                elif par == 'validation_fraction':
                    self.mlp.set_params(validation_fraction=params[par])
                elif par == 'alpha':
                    self.mlp.set_params(alpha=params[par])
                elif par == 'solver':
                    self.mlp.set_params(solver=params[par])
                elif par == 'early_stopping':
                    self.mlp.set_params(early_stopping=params[par])
                elif par == 'learning_rate':
                    self.mlp.set_params(learning_rate=params[par])
                elif par == 'learning_rate_init':
                    self.mlp.set_params(learning_rate_init=params[par])
                elif par == 'hidden_layer_sizes':
                    self.mlp.set_params(hidden_layer_sizes=params[par])

            self.mlp.intercepts_ = all[2]
            self.mlp.coefs_ = all[3]
            self.mlp.n_layers_ = all[0][0]
            self.mlp.n_outputs_ = all[0][1]
            self.mlp.out_activation_ = all[0][2]
            self.scaler = all[4]
            self.scaler_c0 = all[5]
            self.scaler_c1 = all[6]

            self.scaleropt.set(self.scaler)
            self.solver.set(params['solver'])
            self.activation.set(params['activation'])
            self.maxiter.set(params['max_iter'])
            layer_sizes = list(params['hidden_layer_sizes'])
            self.layersize1.set(0)
            self.layersize2.set(0)
            self.layersize3.set(0)
            self.layersize4.set(0)
            self.layersize5.set(0)
            if self.mlp.n_layers_ > 2:
                   self.layersize1.set(layer_sizes[0])
            if self.mlp.n_layers_ > 3:
                   self.layersize2.set(layer_sizes[1])
            if self.mlp.n_layers_ > 4:
                   self.layersize3.set(layer_sizes[2])
            if self.mlp.n_layers_ > 5:
                   self.layersize4.set(layer_sizes[3])
            if self.mlp.n_layers_ > 6:
                   self.layersize5.set(layer_sizes[4])
            self.alpha.set(params['alpha'])
            self.beta1.set(params['beta_1'])
            self.beta2.set(params['beta_2'])
            self.learningrate.set(params['learning_rate'])
            self.tol.set(params['tol'])
            
            Z = self.wdata.wd.iloc[:,1:].copy()
            y = self.wdata.wd.iloc[:,0:1].values.ravel()
            y = y * self.scaler_c1[0] + self.scaler_c0[0]
            i = 0
            while i < Z.shape[1]:
                Z.iloc[:,i] = Z.iloc[:,i] * self.scaler_c1[i+1] + self.scaler_c0[i+1]
                i += 1
            
            self.mlp_draw(Z, y)
        
    # Export menu callback
    def export_action_cb(self):

        file = tkinter.filedialog.asksaveasfilename(initialdir='./', title='Select file',
                                          filetypes=[('txt files','*.txt'),('all files','*.*')])
        if file != '':
            params = self.mlp.get_params()

            fp = open(file, 'w')
            if self.scaler != 'No':
                fp.write('Scaler ' + str(len(self.scaler_c0)) + '\n')
                i = 0
                while i < len(self.scaler_c0):
                    fp.write(str(self.scaler_c0[i]))
                    if i != len(self.scaler_c0) - 1:
                        fp.write(' ')
                    i += 1
                fp.write('\n')
                i = 0
                while i < len(self.scaler_c1):
                    fp.write(str(self.scaler_c1[i]))
                    if i != len(self.scaler_c0) - 1:
                        fp.write(' ')
                    i += 1
                fp.write('\n')            

            fp.write('Layers ' + str(self.mlp.n_layers_) + '\n')
            fp.write('LayerSizes')
            inputs = len(self.mlp.coefs_[0])
            layer_sizes = list(params['hidden_layer_sizes'])
            layer_sizes.append(1)
            fp.write(' ' + str(inputs))
            for size in layer_sizes:
                fp.write(' ' + str(size))
            fp.write(' ' + str(self.mlp.n_outputs_) + '\n')
            fp.write('Activation ' + params['activation'] +  '\n')
            fp.write('Intercepts\n')
            i = 0
            while i < self.mlp.n_layers_ - 1:
                j = 0
                while j < layer_sizes[i]:
                    fp.write(str(self.mlp.intercepts_[i][j]) + ' ')
                    j += 1
                fp.write('\n')
                i += 1
            fp.write('Coefs\n')
            i = 0
            while i < self.mlp.n_layers_ - 1:
                j = 0
                while j < layer_sizes[i]:
                    if i == 0:
                        k = 0
                        while k < inputs:
                            fp.write(str(i) + ' ' + str(j) + ' ' + str(k) + ' ' + str(self.mlp.coefs_[i][k][j]) + '\n')
                            k += 1
                    else:
                        k = 0
                        while k < layer_sizes[i-1]:
                            fp.write(str(i) + ' ' + str(j) + ' ' + str(k) + ' ' + str(self.mlp.coefs_[i][k][j]) + '\n')
                            k += 1
                    j += 1
                    #fp.write('\n')
                i += 1
            fp.close()

    # Create menu callback
    def create_action_cb(self):

        scaler = self.scaleropt.get()
        solver = self.solver.get()
        activation = self.activation.get()
        maxiter = self.maxiter.get()
        verbose = self.verbose.get() == 'True'
        layersizes = []
        if self.layersize1.get() > 0:
            layersizes.append(self.layersize1.get())
        if self.layersize2.get() > 0:
            layersizes.append(self.layersize2.get())
        if self.layersize3.get() > 0:
            layersizes.append(self.layersize3.get())
        if self.layersize4.get() > 0:
            layersizes.append(self.layersize4.get())
        if self.layersize5.get() > 0:
            layersizes.append(self.layersize5.get())
        beta1 = self.beta1.get()
        beta2 = self.beta2.get()
        alpha = self.alpha.get()
        learningrate = self.learningrate.get()
        learningrateinit = self.learningrateinit.get()
        tol = self.tol.get()

        self.mlp = MLPRegressor(solver=solver, random_state=0, activation=activation,
                                hidden_layer_sizes=layersizes, verbose=verbose, max_iter=maxiter,
                                early_stopping=False, learning_rate=learningrate,learning_rate_init=learningrateinit,
                                beta_1=beta1, beta_2=beta2, alpha=alpha, tol=tol)
    
        X = self.wdata.wd.iloc[:,1:]
        y = self.wdata.wd.iloc[:,0:1].values.ravel()
        self.scaler_c0 = []
        self.scaler_c1 = []
        self.scaler = scaler
        if scaler == 'No':
            Z = X
            self.scaler_c0.append(0)
            self.scaler_c1.append(1)
            i = 0
            while i < X.shape[1]:
                self.scaler_c0.append(0)
                self.scaler_c1.append(1)
                i += 1
        else:
            Z = X.copy()
            if scaler == 'MinMax':
                y, c0, c1 = minmax_scale(y)
            elif scaler == 'Standard':
                y, c0, c1 = standard_scale(y)
            self.scaler_c0.append(c0)
            self.scaler_c1.append(c1)
            i = 0
            while i < Z.shape[1]:
                if scaler == 'MinMax':
                    Z.iloc[:,i], c0, c1 = minmax_scale(Z.iloc[:,i])
                elif scaler == 'Standard':
                    Z.iloc[:,i], c0, c1 = standard_scale(Z.iloc[:,i])
                self.scaler_c0.append(c0)
                self.scaler_c1.append(c1)
                i += 1
                
        reg = self.mlp.fit(Z, y)
        coeff = 0
        params = self.mlp.get_params()
        self.mlp_draw(Z, y)

    def mlp_predict(self, X):
        inputs = len(self.mlp.coefs_[0])
        params = self.mlp.get_params()
        layer_sizes = list(params['hidden_layer_sizes'])
        layer_sizes.append(1)
        h = [None] * (self.mlp.n_layers_ - 1)
        i = 0
        while i < self.mlp.n_layers_ - 1:
            if i < self.mlp.n_layers_ - 2:
                h[i] = [None] * len(self.mlp.coefs_[i+1])
            else:
                h[i] = [None] * 1
            i += 1

        n = 0
        activation = params['activation']
        res2 = pd.Series([None]*len(X))
        while n < 500:
            i = 0
            while i < self.mlp.n_layers_ - 1:
                j = 0
                while j < layer_sizes[i]:
                    h[i][j] = self.mlp.intercepts_[i][j]
                    k = 0
                    if i == 0:
                        while k < inputs:
                            x = X[self.wdata.wdcol[k+1]][n]
                            h[i][j] += self.mlp.coefs_[i][k][j] * x
                            k += 1
                    else:
                        while k < layer_sizes[i-1]:
                            h[i][j] += self.mlp.coefs_[i][k][j] * h[i-1][k]
                            k += 1
                    if i != self.mlp.n_layers_ - 2:
                        if  activation == 'tanh':
                            h[i][j] = math.tanh(h[i][j])
                        elif activation == 'identity':
                            pass
                        elif activation == 'relu':
                            if h[i][j] < 0:
                                h[i][j] = 0
                        elif activation == 'logistic':
                            h[i][j] = 1/(1+math.exp(-h[i][j]))
                    j += 1

                i += 1
            res2[n] = h[i-1][0]
            n += 1
        return res2
    
    # Draw coefficients and curves
    def mlp_draw(self, X, y):

        res = self.mlp.predict(X)

        score = r2_score(res, y)

        layo = 1 * 100 + 10

        j = 0
        fig = plt.figure(self.fignum)
        self.fignum += 1
        fig.canvas.set_window_title('MLP Regressor ' + self.wdwindow.name)

        #mgr = plt.get_current_fig_manager()
        #main.set_icon(mgr.window)
        ax = plt.subplot(layo+j+1)
        plt.plot(self.wdata.wdtime, y)
        plt.plot(self.wdata.wdtime, res, label='Model')
        plt.legend(loc='center left', bbox_to_anchor=(1, 0.5));
        plt.gcf().text(0.1, 0.95, 'Score  ' + "%.4f" % score, fontsize=10)
        plt.show()
        fig = plt.figure()

    # Help callback
    def help_action_cb(self):
        os.system('co_help -s ' + pwr_exe + '/en_us/man_mva.dat -t mva_linreg_model &')
        pass

#
# End MLP regressor class
#


class WdWindow:
    # Constructor, create empty window
    def __init__(self):
        global window

        main.add_appl(self)
        
        self.name = ''
        self.wdata = WData()
        self.dataframe = None
        self.add_dia = None
        self.clipdia = None
        self.fcurve = None
        self.fcurvefile = None
        self.constantentry = None
        self.shiftentry = None
        self.mshiftentry = None
        self.mshiftnumentry = None
        self.curveentry = None
        self.datasel = None

        self.window = Toplevel(window, bg=bgcolor)
        self.window.title(self.name)
        self.window.minsize(600, 200)
        self.window.protocol("WM_DELETE_WINDOW", self.close_action_cb)
        main.set_icon(self.window)
        self.create_toolbar()
        self.create_dataframe()
        self.create_datamenu()

    def empty(self):
        return self.wdata.empty()
    
    # Rename callback
    def rename_action_cb(self): 
        ValueDialog(self.window, "Rename", "Name", self.rename_ok_cb)
                    
    def rename_ok_cb(self, name):
        self.name = name
        self.wdata.setName(name)
        self.window.title(self.name)

    def get_select(self):
        if self.empty():
            return None
        mask = [None] * len(self.datasel)
        i = 0
        for sel in self.datasel:
            mask[i] = (sel.get() == 1)
            i += 1
        return mask

    # Plot callback
    def plot_action_cb(self): 
        if self.empty():
            return        
        self.wdata.plot(self.get_select())

    # Individual plot callback
    def indplot_action_cb(self): 
        if self.empty():
            return
        self.wdata.indplot(self.get_select())

    # Scatterplot callback
    def scatter_action_cb(self): 
        if self.empty():
            return
        self.wdata.scatterplot(self.get_select())

    # Correlationplot callback
    def corr_action_cb(self): 
        if self.empty():
            return
        self.wdata.correlation_plot(self.get_select())

    def corr2_action_cb(self): 
        if self.empty():
            return
        self.wdata.correlation2_plot(self.get_select())

    # Regressionplot callback
    def regr_action_cb(self): 
        if self.empty():
            return
        try:
            self.wdata.regression_plot(self.get_select())
        except co.Error as e:
            tkinter.messagebox.showerror("Error", e.str)

    # Histogram callback
    def histogram_action_cb(self): 
        if self.empty():
            return

        fig = plt.figure()
        ax = fig.add_subplot(1,1,1)
        self.wdata.wd.hist(bins=50, ax=ax)
        fig.show()

    # Statistics callback
    def stat_action_cb(self): 
        if self.empty():
            return

        mean = self.wdata.wd.mean()
        std = self.wdata.wd.std()

        dia = Toplevel(self.window, bg=bgcolor)
        dia.title('Statistics')
        main.set_icon(dia)

        l = Label(dia, text='Column', bg=bgcolor)
        l.grid(column=0, row=0, padx=20, pady=5, sticky=W)
        l = Label(dia, text='Mean', bg=bgcolor)
        l.grid(column=1, row=0, padx=20, pady=5, sticky=W)
        l = Label(dia, text='Std', bg=bgcolor)
        l.grid(column=2, row=0, padx=20, pady=5, sticky=W)

        i = 0
        for col in self.wdata.wdcol:
            l = Label(dia, text=col, bg=bgcolor)
            l.grid(column=0, row=i+1, padx=20, pady=5, sticky=W)
            l = Label(dia, text=str(mean[i]), bg=bgcolor)
            l.grid(column=1, row=i+1, padx=20, pady=5, sticky=W)
            l = Label(dia, text=str(std[i]), bg=bgcolor)
            l.grid(column=2, row=i+1, padx=20, pady=5, sticky=W)
            i += 1


    def regrcoef_action_cb(self): 
        if self.empty():
            return
        wdwindow = self
        LinRegModel(wdwindow, LinRegModel.TYPE_LINEAR_REGRESSION)
    
    def ridgeregr_action_cb(self): 
        if self.empty():
            return
        wdwindow = self
        LinRegModel(wdwindow, LinRegModel.TYPE_RIDGE_REGRESSION)
    
    def lassoregr_action_cb(self): 
        if self.empty():
            return
        wdwindow = self
        LinRegModel(wdwindow, LinRegModel.TYPE_LASSO_REGRESSION)
    
    def mlp_action_cb(self): 
        if self.empty():
            return
        wdwindow = self
        MLPModel(wdwindow)
    
    # Move up callback
    def moveup_action_cb(self): 
        if self.empty():
            return

        idx = 0
        for sel in self.datasel:
            if sel.get() == 1:
                break
            idx += 1
        try:
            self.wdata.moveup(self.get_select())
        except co.Error as e:
            tkinter.messagebox.showerror("Error", e.str)
            return

        self.redraw()
        self.datasel[idx-1].set(True)
    
    # Move down callback
    def movedown_action_cb(self): 
        if self.empty():
            return

        idx = 0
        for sel in self.datasel:
            if sel.get() == 1:
                break
            idx += 1
        try:
            self.wdata.movedown(self.get_select())
        except co.Error as e:
            tkinter.messagebox.showerror("Error", e.str)
            return

        self.redraw()
        self.datasel[idx+1].set(True)

    # Revert callback
    def revert_action_cb(self):
        self.wdata.revert()
        self.redraw()

    # Clip callback
    def clip_action_cb(self):
        if self.empty():
            return
    
        self.clipdia = Toplevel(self.window, bg=bgcolor)
        self.clipdia.title('Clip')
        main.set_icon(self.clipdia)

        defaultmin = StringVar()
        minlabel = Label(self.clipdia, text='Min', bg=bgcolor)
        minlabel.grid(column=0, row=0, padx=20, pady=5, sticky=W)
        self.minentry = Entry(self.clipdia, textvariable=defaultmin, bg=bgcolor)
        defaultmin.set(str(0))
        self.minentry.grid(column=1, row=0, padx=20, pady=5, sticky=W)

        # Max entry
        defaultmax = StringVar()
        maxlabel = Label(self.clipdia, text='Max', bg=bgcolor)
        maxlabel.grid(column=0, row=1, padx=20, pady=5, sticky=W)
        self.maxentry = Entry(self.clipdia, textvariable=defaultmax, bg=bgcolor)
        defaultmax.set(str(self.wdata.rows()))
        self.maxentry.grid(column=1, row=1, padx=20, pady=5, sticky=W)

        readdatabutton = Button(self.clipdia, text="Apply", command=self.clip_action_ok_cb, bg=buttoncolor);
        readdatabutton.grid(column=0, row=2, padx=60, pady=20, sticky=W)

        readdatabutton = Button(self.clipdia, text="Cancel", command=self.clip_action_cancel_cb, bg=buttoncolor);
        readdatabutton.grid(column=1, row=2, padx=60, pady=20, sticky=W)

    def clip_action_cancel_cb(self):
        self.clipdia.destroy()

    def clip_action_ok_cb(self):

        minvalue = int(self.minentry.get())
        maxvalue = int(self.maxentry.get())
        self.clipdia.destroy()
            
        self.wdata.clip(minvalue, maxvalue)
        self.redraw()
    
    # Split callback
    def split_action_cb(self):
        if self.empty():
            return

        ValueDialog(self.window, "Split entry", "Row", self.split_ok_cb)
                    
    def split_ok_cb(self, valuestr):
        value = int(valuestr)

        wdwindow = WdWindow()
        idx = self.name.find('.')
        if idx == -1:            
            wdwindow.name = self.name + '_2'
        else:
            wdwindow.name = self.name[:idx] + '_2' + self.name[idx:]
        wdwindow.window.title(wdwindow.name)
        wdwindow.wdata.set_name(wdwindow.name)
        wdwindow.wdata = self.wdata.split(value)
        wdwindow.dataframe.pack_forget()
        wdwindow.dataframe.destroy()
        wdwindow.create_dataframe()

        self.dataframe.pack_forget()
        self.dataframe.destroy()
        self.create_dataframe()

    
    # Multiply callback
    def multiply_action_cb(self):
        if self.empty():
            return

        ValueDialog(self.window, "Multiply", "Times", self.multiply_ok_cb)
                    
    def multiply_ok_cb(self, valuestr):
        value = int(valuestr)
        try:
            self.wdata.multiply(value)
        except co.Error as e:
            tkinter.messagebox.showerror("Error", e.str)
            return

        self.dataframe.pack_forget()
        self.dataframe.destroy()
        self.create_dataframe()

    # Delete column callback
    def deletecolumn_action_cb(self):
        if self.empty():
            return

        answer = tkinter.messagebox.askquestion('Delete columns', 'Do you want to delete the selected columns')
        if answer == 'yes':
            mask = [None] * len(self.datasel)
            i = 0
            for sel in self.datasel:
                mask[i] = (sel.get() == 1)
                i += 1

            try:
                self.wdata.delete_columns(mask)
            except co.Error as e:
                tkinter.messagebox.showerror("Error", e.str)
                
            self.redraw()
        
    # Convert column callback
    def convcolumn_action_cb(self):
        if self.empty():
            return

        cix = []
        i = 0;
        for name in self.wdata.wdname:
            if self.datasel[i].get():
                cix.append(i)
            i += 1
                     
        if len(cix) != 1:
            tkinter.messagebox.showerror("Error", "Select one attribute")
            return

        self.wdata.set_add_replace(1)
        self.add_dia = Toplevel(self.window, bg=bgcolor)
        self.add_dia.title('Convert Column')
        main.set_icon(self.add_dia)

        self.fcurve = None
        self.sel_copy = IntVar()
        self.sel_norm = IntVar()
        self.sel_square = IntVar()
        self.sel_sqrt = IntVar()
        self.sel_exp = IntVar()
        self.sel_log = IntVar()
        self.sel_integral = IntVar()
        self.sel_derivate = IntVar()
        self.sel_add = IntVar()
        self.sel_sub = IntVar()
        self.sel_mul = IntVar()
        self.sel_div = IntVar()
        self.sel_curve = IntVar()
        self.sel_constant = IntVar()
        self.sel_shift = IntVar()
        self.sel_mshift = IntVar()
        self.sel_scale = IntVar()

        checkbox = Checkbutton(self.add_dia, text='Norm', variable=self.sel_norm,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=0, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Scale', variable=self.sel_scale,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=1, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Square', variable=self.sel_square,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=2, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Squareroot', variable=self.sel_sqrt,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=3, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Exp', variable=self.sel_exp,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=4, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Log', variable=self.sel_log,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=5, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Integral', variable=self.sel_integral,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=6, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Derivate', variable=self.sel_derivate,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=7, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Curve', variable=self.sel_curve,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=8, padx=20, pady=5, sticky=W)
        self.curveentry = Entry(self.add_dia, bg=bgcolor)
        self.curveentry.grid(column=1, row=8, padx=20, pady=5, sticky=W)
        button = Button(self.add_dia, text="Browse", command=self.addcol_action_curve_cb, bg=buttoncolor) 
        button.grid(column=2, row=8, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Shift', variable=self.sel_shift,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=9, padx=20, pady=5, sticky=W)
        self.shiftentry = Entry(self.add_dia, bg=bgcolor)
        self.shiftentry.grid(column=1, row=9, padx=20, pady=5, sticky=W)

        button = Button(self.add_dia, text="Apply", command=self.addcol_action_ok_cb, bg=buttoncolor);
        button.grid(column=0, row=10, padx=60, pady=20, sticky=W)

        button = Button(self.add_dia, text="Cancel", command=self.addcol_action_cancel_cb, bg=buttoncolor);
        button.grid(column=1, row=10, padx=60, pady=20, sticky=W)

    # Add column callback
    def addcolumn_action_cb(self):
        if self.empty():
            return

        self.wdata.set_add_replace(0)
    
        self.add_dia = Toplevel(self.window, bg=bgcolor)
        self.add_dia.title('Add Column')
        main.set_icon(self.add_dia)

        self.fcurve = None
        self.sel_copy = IntVar()
        self.sel_norm = IntVar()
        self.sel_square = IntVar()
        self.sel_sqrt = IntVar()
        self.sel_exp = IntVar()
        self.sel_log = IntVar()
        self.sel_integral = IntVar()
        self.sel_derivate = IntVar()
        self.sel_add = IntVar()
        self.sel_sub = IntVar()
        self.sel_mul = IntVar()
        self.sel_div = IntVar()
        self.sel_curve = IntVar()
        self.sel_constant = IntVar()
        self.sel_shift = IntVar()
        self.sel_mshift = IntVar()
        self.sel_scale = IntVar()
        checkbox = Checkbutton(self.add_dia, text='Copy', variable=self.sel_copy,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=0, padx=20, pady=5, sticky=W)
        
        checkbox = Checkbutton(self.add_dia, text='Norm', variable=self.sel_norm,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=1, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Scale', variable=self.sel_scale,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=2, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Square', variable=self.sel_square,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=3, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Squareroot', variable=self.sel_sqrt,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=4, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Exp', variable=self.sel_exp,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=5, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Log', variable=self.sel_log,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=6, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Integral', variable=self.sel_integral,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=7, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Derivate', variable=self.sel_derivate,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=8, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Add', variable=self.sel_add,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=9, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Sub', variable=self.sel_sub,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=10, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Multiply', variable=self.sel_mul,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=11, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Divide', variable=self.sel_div,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=12, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Curve', variable=self.sel_curve,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=13, padx=20, pady=5, sticky=W)
        self.curveentry = Entry(self.add_dia, bg=bgcolor)
        self.curveentry.grid(column=1, row=13, padx=20, pady=5, sticky=W)
        button = Button(self.add_dia, text="Browse", command=self.addcol_action_curve_cb, bg=buttoncolor) 
        button.grid(column=2, row=13, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Constant', variable=self.sel_constant,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=14, padx=20, pady=5, sticky=W)
        self.constantentry = Entry(self.add_dia, bg=bgcolor)
        self.constantentry.grid(column=1, row=14, padx=20, pady=5, sticky=W)

        checkbox = Checkbutton(self.add_dia, text='Shift', variable=self.sel_shift,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=15, padx=20, pady=5, sticky=W)
        self.shiftentry = Entry(self.add_dia, bg=bgcolor)
        self.shiftentry.grid(column=1, row=15, padx=20, pady=5, sticky=W)
        
        checkbox = Checkbutton(self.add_dia, text='MShift', variable=self.sel_mshift,
                               highlightthickness=0, bg=bgcolor)
        checkbox.grid(column=0, row=16, padx=20, pady=5, sticky=W)
        self.mshiftentry = Entry(self.add_dia, bg=bgcolor)
        self.mshiftentry.grid(column=1, row=16, padx=20, pady=5, sticky=W)
        self.mshiftnumentry = Entry(self.add_dia, bg=bgcolor)
        self.mshiftnumentry.grid(column=2, row=16, padx=20, pady=5, sticky=W)
        
        button = Button(self.add_dia, text="Apply", command=self.addcol_action_ok_cb, bg=buttoncolor);
        button.grid(column=0, row=17, padx=60, pady=20, sticky=W)

        button = Button(self.add_dia, text="Cancel", command=self.addcol_action_cancel_cb, bg=buttoncolor);
        button.grid(column=1, row=17, padx=60, pady=20, sticky=W)

    def addcol_action_curve_cb(self):
        self.fcurvefile = tkinter.filedialog.askopenfilename(
            initialdir='./', title='Open curve file',
            filetypes=[('dat files','*.dat'),('all files','*.*')])
        self.fcurve = None
        if self.fcurvefile != '':
            fname = co.reTranslateFilename(self.fcurvefile)
            self.curveentry.delete(0,END)
            self.curveentry.insert(0,fname)

    def addcol_action_cancel_cb(self):
        self.add_dia.destroy()

    def addcol_action_ok_cb(self):
        cix = []
        i = 0;
        for name in self.wdata.wdname:
            if self.datasel[i].get():
                cix.append(i)
            i += 1
                         
        if self.sel_constant.get():
            pass
        elif self.sel_add.get() or self.sel_sub.get() or self.sel_mul.get() or self.sel_div.get():   
            if len(cix) != 2:
                tkinter.messagebox.showerror("Error", "Select two attributes")
                return
            ser = pd.Series(self.wdata.wd[self.wdata.wdcol[cix[0]]])
        else:
            if len(cix) != 1:
                tkinter.messagebox.showerror("Error", "Select one attributes")
                return

        cix1 = -1
        cix2 = -1
        arg1 = None
        arg2 = None
        if len(cix) > 0:
            cix1 = cix[0]
        if len(cix) > 1:
            cix2 = cix[1]

        if self.sel_copy.get():
            op = self.wdata.OP_COPY
        elif self.sel_norm.get():
            op = self.wdata.OP_NORM
        elif self.sel_square.get():
            op = self.wdata.OP_SQUARE
        elif self.sel_sqrt.get():
            op = self.wdata.OP_SQUAREROOT
        elif self.sel_exp.get():
            op = self.wdata.OP_EXP
        elif self.sel_log.get():
            op = self.wdata.OP_LOG
        elif self.sel_integral.get():
            op = self.wdata.OP_INTEGRAL
        elif self.sel_derivate.get():
            op = self.wdata.OP_DERIVATE
        elif self.sel_add.get():
            op = self.wdata.OP_ADD
        elif self.sel_sub.get():
            op = self.wdata.OP_SUB
        elif self.sel_mul.get():
            op = self.wdata.OP_MULTIPLY
        elif self.sel_div.get():
            op = self.wdata.OP_DIVIDE
        elif self.sel_curve.get():
            op = self.wdata.OP_CURVE
            arg1 = self.curveentry.get()
        elif self.sel_constant.get():
            op = self.wdata.OP_CONSTANT
            arg1 = self.constantentry.get()
        elif self.sel_shift.get():
            op = self.wdata.OP_SHIFT
            arg1 = self.shiftentry.get()
        elif self.sel_mshift.get():
            op = self.wdata.OP_MSHIFT
            arg1 = self.mshiftentry.get()
            arg2 = self.mshiftnumentry.get()
        elif self.sel_scale.get():
            op = self.wdata.OP_SCALE
        else:
            tkinter.messagebox.showerror("Error", "No action is selected")
            return

        keep = 0
        try:
            self.wdata.op_exec(op, cix1, cix2, arg1, arg2)
        except co.SyntaxError as e:
            tkinter.messagebox.showerror("Error", str(e))
            return
        except co.Error as e:
            tkinter.messagebox.showerror("Error", e.str)

        self.redraw()
        if not self.add_dia is None:
            self.add_dia.destroy()

    def close_action_cb(self, arg=0):
        self.window.destroy()
        main.remove_appl(self)
    
    # Save original dataframe
    def saveorig_action_cb(self): 
        if self.empty():
            return

        file = tkinter.filedialog.asksaveasfilename(initialdir='./', title='Select file',
                                              filetypes=[('dat files','*.dat'),('all files','*.*')],
                                              initialfile=self.name)
        if len(file) != 0:
            self.wdata.save_orig(file)


    # Save work dataframe
    def savewd_action_cb(self): 
        if self.empty():
            return

        file = tkinter.filedialog.asksaveasfilename(initialdir='./', title='Select file',
                                              filetypes=[('dat files','*.dat'),('all files','*.*')],
                                              initialfile=self.name)
        if len(file) != 0:
            self.wdata.save_wd(file)

    # Save formula
    def saveformula_action_cb(self):
        if self.empty():
            return

        file = tkinter.filedialog.asksaveasfilename(initialdir='./', title='Select file',
                                          filetypes=[('frm files','*.frm'),('all files','*.*')])
        if file != '':
            self.wdata.save_formula(file)

    # Apply formula
    def applyformula_action_cb(self):
        if self.empty():
            return

        self.add_dia = None
        self.wdata.set_add_replace(0)

        file = tkinter.filedialog.askopenfilename(initialdir='./', title='Open file',
                                          filetypes=[('frm files','*.frm'),('all files','*.*')])
        if file != '':
            try:
                self.wdata.apply_formula(file)
            except co.Error as e:
                tkinter.messagebox.showerror("Error", e.str)
                return

            self.redraw()
            
    def fetch_sev_cb(self):
        fetch = FetchSev(self)

    # New window
    def new_action_cb(self, arg=0): 
        WdWindow()

    # Open from file
    def open_action_cb(self, arg=0): 
        file = tkinter.filedialog.askopenfilename(initialdir='./', title='Open file',
                                          filetypes=[('dat files','*.dat'),('all files','*.*')])
        if len(file) != 0:
            self.read_file(file)

    # Concatenate file other WdWindow
    def concatwd_action_cb(self, arg=0): 
        if self.empty():
            return

        apps = []
        appnames = []
        for appl in main.applist:
            if appl == self:
                continue
            apps.append(appl)
            appnames.append(appl.name)

        if len(apps) == 0:
            tkinter.messagebox.showerror("Error", "No other window")                
            return

        if len(apps) == 1:
            ccwd = apps[0].wdata.wd
            ccname = apps[0].wdata.wdname
            ccwdtime = apps[0].wdata.wdtime
            try:
                self.wdata.concat(ccwd, ccname, ccwdtime)
            except co.Error as e:
                tkinter.messagebox.showerror("Error", e.str)
                return
                
            self.dataframe.pack_forget()
            self.dataframe.destroy()
            self.create_dataframe()
        else:
            dia = SelectDialog(self.window, appnames, self.dataselect_ok_cb)

    def dataselect_ok_cb(self, item):
        for appl in main.applist:
            if appl.name == item:
                ccwd = appl.wdata.wd
                ccname = appl.wdata.wdname
                ccwdtime = appl.wdata.wdtime
                try:
                    self.wdata.concat(ccwd, ccname, ccwdtime)
                except co.Error as e:
                    tkinter.messagebox.showerror("Error", e.str)
                    return

                self.dataframe.pack_forget()
                self.dataframe.destroy()
                self.create_dataframe()
                break
        
    # Concatenate file
    def concat_action_cb(self, arg=0): 
        if self.empty():
            return

        file = tkinter.filedialog.askopenfilename(initialdir='./', title='Open file',
                                            filetypes=[('dat files','*.dat'),('all files','*.*')])
        if file != '':

            try:
                self.wdata.concat_file(file)
            except co.Error as e:
                tkinter.messagebox.showerror("Error", e.str)                
                return                

            self.dataframe.pack_forget()
            self.dataframe.destroy()
            self.create_dataframe()

    # Help callback
    def help_action_cb(self):
        os.system('co_help -s ' + pwr_exe + '/en_us/man_mva.dat &')

    def new_data(self, data, col, name):
        self.wdata.set_data(data, col, name)

        self.dataframe.pack_forget()
        self.dataframe.destroy()
        self.create_dataframe()

    def read_file(self, file):
        self.wdata.read_file(file)
            
        if self.dataframe != None:
            self.toolbar.pack_forget()
            self.toolbar.destroy()
            self.dataframe.pack_forget()
            self.dataframe.destroy()

        self.create_toolbar()
        self.create_dataframe()
        self.create_datamenu()
        idx = file.rfind('/')
        if idx == -1:
            self.name = file
        else:
            self.name = file[idx+1:]
        self.window.title(self.name)


    # Create frame with action buttons
    def create_datamenu(self):

        # Create menu
        menubar = Menu(self.window, bg=buttoncolor)
        filemenu = Menu(menubar, bg=buttoncolor)
        filemenu.add_command(label='New', command=self.new_action_cb, accelerator='Ctrl+N')
        filemenu.add_command(label='Open', command=self.open_action_cb, accelerator='Ctrl+O')
        filemenu.add_command(label='Import from server', command=self.fetch_sev_cb)
        filemenu.add_command(label='Concatenate file', command=self.concat_action_cb)
        filemenu.add_command(label='Join', command=self.concatwd_action_cb)
        filemenu.add_command(label='Save', command=self.savewd_action_cb)
        filemenu.add_command(label='Save Original Data', command=self.saveorig_action_cb)
        filemenu.add_command(label='Save Formula', command=self.saveformula_action_cb)
        filemenu.add_command(label='Apply Formula', command=self.applyformula_action_cb)
        filemenu.add_command(label='Revert', command=self.revert_action_cb)
        filemenu.add_command(label='Rename', command=self.rename_action_cb)
        filemenu.add_command(label='Close', command=self.close_action_cb, accelerator='Ctrl+W')
        menubar.add_cascade(label='File', menu=filemenu)

        editmenu = Menu(menubar, bg=buttoncolor)
        editmenu.add_command(label='Move up', command=self.moveup_action_cb)
        editmenu.add_command(label='Move down', command=self.movedown_action_cb)
        editmenu.add_command(label='Convert column', command=self.convcolumn_action_cb)
        editmenu.add_command(label='Add column', command=self.addcolumn_action_cb)
        editmenu.add_command(label='Delete column', command=self.deletecolumn_action_cb)
        editmenu.add_command(label='Clip', command=self.clip_action_cb)
        editmenu.add_command(label='Split', command=self.split_action_cb)
        editmenu.add_command(label='Multiply', command=self.multiply_action_cb)
        menubar.add_cascade(label='Edit', menu=editmenu)
        
        viewmenu = Menu(menubar, bg=buttoncolor)
        viewmenu.add_command(label='Plot common', command=self.plot_action_cb)
        viewmenu.add_command(label='Plot separate', command=self.indplot_action_cb)
        viewmenu.add_command(label='Scatterplot', command=self.scatter_action_cb)
        viewmenu.add_command(label='Plot correlation', command=self.corr2_action_cb)
        viewmenu.add_command(label='Plot correlation hinton', command=self.corr_action_cb)
        viewmenu.add_command(label='Plot linear regression', command=self.regr_action_cb)
        viewmenu.add_command(label='Plot histogram', command=self.histogram_action_cb)
        viewmenu.add_command(label='Statistics', command=self.stat_action_cb)
        menubar.add_cascade(label='View', menu=viewmenu)

        functionmenu = Menu(menubar, bg=buttoncolor)
        functionmenu.add_command(label='Linear regression', command=self.regrcoef_action_cb)
        functionmenu.add_command(label='Ridge regression', command=self.ridgeregr_action_cb)
        functionmenu.add_command(label='Lasso regression', command=self.lassoregr_action_cb)
        functionmenu.add_command(label='MLP regressor', command=self.mlp_action_cb)
        menubar.add_cascade(label='Functions', menu=functionmenu)
        
        helpmenu = Menu(menubar, bg=buttoncolor)
        helpmenu.add_command(label='Help', command=self.help_action_cb)
        menubar.add_cascade(label='Help', menu=helpmenu)
        self.window.config(menu=menubar)
        self.window.bind("<Control-w>", self.close_action_cb)
        self.window.bind("<Control-o>", self.open_action_cb)
        self.window.bind("<Control-n>", self.new_action_cb)
    
    def create_toolbar(self):
    
        self.toolbar = Frame(self.window, bg=bgcolor, bd=1, relief=RAISED)

        self.toolbar_plot_img = PhotoImage(file=pwr_exe+"/mvtoolbar_plot.png")
        button = Button(self.toolbar, image=self.toolbar_plot_img, command=self.plot_action_cb, bg=buttoncolor)
        wow.Tooltip(button, text='Plot common')
        button.pack(side=LEFT, padx=2, pady=2)

        self.toolbar_indplot_img = PhotoImage(file=pwr_exe+"/mvtoolbar_indplot.png")
        button = Button(self.toolbar, image=self.toolbar_indplot_img, command=self.indplot_action_cb, bg=buttoncolor)
        wow.Tooltip(button, text='Plot separate')
        button.pack(side=LEFT, padx=2, pady=2)

        self.toolbar_scatterplot_img = PhotoImage(file=pwr_exe+"/mvtoolbar_scatterplot.png")
        button = Button(self.toolbar, image=self.toolbar_scatterplot_img, command=self.scatter_action_cb, bg=buttoncolor)
        wow.Tooltip(button, text='Scatterplot')
        button.pack(side=LEFT, padx=2, pady=2)

        self.toolbar_lrplot_img = PhotoImage(file=pwr_exe+"/mvtoolbar_lrplot.png")
        button = Button(self.toolbar, image=self.toolbar_lrplot_img, command=self.regr_action_cb, bg=buttoncolor)
        wow.Tooltip(button, text='Linear regression plot')
        button.pack(side=LEFT, padx=2, pady=2)

        self.toolbar_corr2plot_img = PhotoImage(file=pwr_exe+"/mvtoolbar_corr2plot.png")
        button = Button(self.toolbar, image=self.toolbar_corr2plot_img, command=self.corr2_action_cb, bg=buttoncolor)
        wow.Tooltip(button, text='Correlation plot')
        button.pack(side=LEFT, padx=2, pady=2)

        self.toolbar_up_img = PhotoImage(file=pwr_exe+"/mvtoolbar_up.png")
        button = Button(self.toolbar, image=self.toolbar_up_img, command=self.moveup_action_cb, bg=buttoncolor)
        wow.Tooltip(button, text='Move item up')
        button.pack(side=LEFT, padx=2, pady=2)

        self.toolbar_down_img = PhotoImage(file=pwr_exe+"/mvtoolbar_down.png")
        button = Button(self.toolbar, image=self.toolbar_down_img, command=self.movedown_action_cb, bg=buttoncolor)
        wow.Tooltip(button, text='Move item down')
        button.pack(side=LEFT, padx=2, pady=2)

        self.toolbar_conv_img = PhotoImage(file=pwr_exe+"/mvtoolbar_conv.png")
        button = Button(self.toolbar, image=self.toolbar_conv_img, command=self.convcolumn_action_cb, bg=buttoncolor)
        wow.Tooltip(button, text='Convert item')
        button.pack(side=LEFT, padx=2, pady=2)

        self.toolbar_add_img = PhotoImage(file=pwr_exe+"/mvtoolbar_add.png")
        button = Button(self.toolbar, image=self.toolbar_add_img, command=self.addcolumn_action_cb, bg=buttoncolor)
        wow.Tooltip(button, text='Add item')
        button.pack(side=LEFT, padx=2, pady=2)

        self.toolbar_delete_img = PhotoImage(file=pwr_exe+"/mvtoolbar_delete.png")
        button = Button(self.toolbar, image=self.toolbar_delete_img, command=self.deletecolumn_action_cb, bg=buttoncolor)
        wow.Tooltip(button, text='Delete item')
        button.pack(side=LEFT, padx=2, pady=2)

        self.toolbar.pack(side=TOP, fill=X)

    def create_dataframe(self):
        global startframe

        if 'startframe' in globals():    
            startframe.pack_forget()
            startframe.destroy()
        self.dataframe = Frame(self.window, bg=bgcolor)

        # Create dataset label
        if self.wdata.wdcol != None:
            dataset_text = "Dataset " + str(self.wdata.columns()) + " X " + str(self.wdata.rows())
        else:
            dataset_text = ""
        dataset_label = Label(self.dataframe, text=dataset_text, anchor=NW);
        dataset_label.grid(column=0, row=0, padx=40, pady=10, sticky='ew') 
        dataset_label.config(bg=bgcolor)

        if self.wdata.wdcol != None:
            i = 0
            self.datasel = [None] * len(self.wdata.wdcol)
            for name in self.wdata.wdcol:
                self.datasel[i] = IntVar()
                text = self.wdata.wdcol[i] + ' ' + self.wdata.wdname[i]
                item_checkbox = Checkbutton(self.dataframe, text=text, variable=self.datasel[i], highlightthickness=0,
                                            bg=bgcolor)
                item_checkbox.grid(column=0, row=i+1, padx=20, pady=5, sticky=W)
                i = i + 1

        self.dataframe.pack(side=LEFT, fill=X)

    def redraw(self):
        self.toolbar.pack_forget()
        self.toolbar.destroy()
        self.dataframe.pack_forget()
        self.dataframe.destroy()
        self.create_toolbar()
        self.create_dataframe()
        self.create_datamenu()    

#
# End of WdWindow class
#

#
# Fetch sev items class
#
class FetchSev:

    def on_configure(self, event):
        size = self.iteminnerframe.winfo_reqwidth(), self.iteminnerframe.winfo_reqheight()
        self.canvas.config(scrollregion="0 0 %s %s" % size)

    # Constructor, create empty window
    def __init__(self, wdata):
        self.itemframe = None
        self.wdata = wdata

        self.fswindow = Toplevel(window, bg=bgcolor)
        self.fswindow.title('Import from Sev Server')
        self.fswindow.geometry("350x200")
        main.set_icon(self.fswindow)
        self.create_filterframe()

    # Create filter frame
    def create_filterframe(self):

        if self.itemframe != None:
            self.itemframe.pack_forget()
            self.itemframe.destroy()

        self.filterframe = Frame(self.fswindow, bg=bgcolor)
        defaultserver = StringVar()

        # Server entry
        # Read last server from file
        try:
            fp = open(home + "/sevserver.dat", "r")
            srv = fp.read()
            fp.close()
        except IOError:
            srv = ''

        serverlabel = Label(self.filterframe, text='Sev server')
        serverlabel.grid(column=0, row=0, padx=20, pady=5, sticky=W)
        serverlabel.config(bg=bgcolor)
        self.serverentry = Entry(self.filterframe, textvariable=defaultserver)
        defaultserver.set(srv)
        self.serverentry.grid(column=1, row=0, padx=20, pady=5, sticky=W)
        self.serverentry.config(bg=bgcolor)

        # Filter entry
        filterlabel = Label(self.filterframe, text='Item Filter')
        filterlabel.grid(column=0, row=1, padx=20, pady=5, sticky=W)
        filterlabel.config(bg=bgcolor)
        self.filterentry = Entry(self.filterframe)
        self.filterentry.grid(column=1, row=1, padx=20, pady=5, sticky=W)
        self.filterentry.config(bg=bgcolor)

        # Fetch items button
        filterbutton = Button(self.filterframe, text='Fetch Items', command=self.fetchitems_cb, bg=buttoncolor)
        filterbutton.grid(column=1, row=2, padx=20, pady=5, sticky=W)
        self.filterframe.pack(side=LEFT, fill=X)

    # Create frame to show and select sev items

    def fetchitems_cb(self):

        self.fswindow.geometry("650x700")
        filtervalue = self.filterentry.get()
        self.server = self.serverentry.get()

        try:
            pwrrt.init('sev_analyse')
        except RuntimeError as e:
            tkinter.messagebox.showerror("Error", str(e))
            return

        # Store server to file
        try:
            fp = open(home + "/sevserver.dat", "w")
            fp.write(self.server)
            fp.close()
        except IOError:
            pass

        try:
            self.items = pwrrt.getSevItemList(self.server, filtervalue)
        except RuntimeError as e:
            tkinter.messagebox.showerror("Error", str(e))
            return

        self.itemframe = Frame(self.fswindow, bg=bgcolor)

        # Scrollbars
        scrollbar = Scrollbar(self.itemframe, orient=VERTICAL)
        self.canvas = Canvas(self.itemframe, bd= 0, bg=bgcolor, yscrollcommand=scrollbar.set)
        scrollbar.config(command=self.canvas.yview)
        scrollbar.pack(side=RIGHT, fill=Y)
        self.canvas.pack(expand=1, side=LEFT, fill=BOTH)
        self.canvas.xview("moveto", 0)
        self.canvas.yview("moveto", 0)
        self.iteminnerframe = Frame(self.canvas, bg=bgcolor)
        self.iteminnerframe.bind('<Configure>', self.on_configure)
        self.canvas.create_window(0, 0, window=self.iteminnerframe, anchor=NW)

        row = 0

        valframe = Frame(self.iteminnerframe, bg=bgcolor)

        # From entry
        defaultfrom = StringVar()
        fromlabel = Label(valframe, text='From')
        fromlabel.grid(column=0, row=row, padx=0, pady=5, sticky=W)
        fromlabel.config(bg=bgcolor)
        self.fromentry = Entry(valframe, textvariable=defaultfrom)
        defaultfrom.set('00:05:00')
        self.fromentry.grid(column=1, row=row, padx=20, pady=5, sticky=W)
        self.fromentry.config(bg=bgcolor)
        row += 1

        # To entry
        defaultto = StringVar()
        tolabel = Label(valframe, text='To')
        tolabel.grid(column=0, row=row, padx=0, pady=5, sticky=W)
        tolabel.config(bg=bgcolor)
        self.toentry = Entry(valframe, textvariable=defaultto)
        defaultto.set('now')
        self.toentry.grid(column=1, row=row, padx=20, pady=5, sticky=W)
        self.toentry.config(bg=bgcolor)
        row += 1

        # Interval entry
        defaultinterval = StringVar()
        intervallabel = Label(valframe, text='Interval')
        intervallabel.grid(column=0, row=row, padx=0, pady=5, sticky=W)
        intervallabel.config(bg=bgcolor)
        self.intervalentry = Entry(valframe, textvariable=defaultinterval)
        defaultinterval.set('1.0')
        self.intervalentry.grid(column=1, row=row, padx=20, pady=5, sticky=W)
        self.intervalentry.config(bg=bgcolor)
        row += 1

        # Max rows
        defaultmax = StringVar()
        maxlabel = Label(valframe, text='Max')
        maxlabel.grid(column=0, row=row, padx=0, pady=5, sticky=W)
        maxlabel.config(bg=bgcolor)
        self.maxentry = Entry(valframe, textvariable=defaultmax)
        defaultmax.set('500')
        self.maxentry.grid(column=1, row=row, padx=20, pady=5, sticky=W)
        self.maxentry.config(bg=bgcolor)
        row += 1


        readdatabutton = Button(valframe, text="Read DataSet", command=self.readdata_cb, bg=buttoncolor);
        readdatabutton.grid(column=0, row=row, padx=0, pady=20, sticky=W)
        row += 1

        valframe.grid(column=0, row=0, padx=20, pady=5, sticky=W)

        i = 0
        row = 1
        self.sel = [None] * len(self.items)
        for item in self.items:
            attrnum = len(item) - 6;
            self.sel[i] = IntVar()
            if attrnum == 1:
                text = item[0] + "." + item[6]
            else:
                text = item[0]
            item_checkbox = Checkbutton(self.iteminnerframe, text=text, variable=self.sel[i], highlightthickness=0,
                                        bg=bgcolor)
            item_checkbox.grid(column=0, row=i+row, padx=20, pady=5, sticky=W)
            i = i + 1

        self.filterframe.pack_forget()
        self.filterframe.destroy()
        self.itemframe.pack(expand=1, fill=BOTH)



    # Read dataframe from sev database
    def readdata_cb(self):
        # Get selected items

        wdname = []
        dataattr = []
        dataoid = []
        isobject = []
        origcol = ['Time']
        wdcol = []

        i = 0
        j = 0
        for selected in self.sel:
            if selected.get():
                colname = self.items[i][0] + '.' + self.items[i][6]
                wdname.append(colname)
                dataattr.append(self.items[i][6])
                dataoid.append(self.items[i][1])
                if len(self.items[i]) - 6 > 1:
                    isobject.append(1)
                else:
                    isobject.append(0)
                print((colname, isobject[j]))
                origcol.append(colname)
                colname = "A" + str(j+1)
                wdcol.append(colname)
                j += 1
            i += 1
        
        if j == 0:
            tkinter.messagebox.showerror("Error", "No item is selected")
            return

        fromvalue = self.fromentry.get()
        tovalue = self.toentry.get()
        intervalvalue = float(self.intervalentry.get())
        maxvalue = int(self.maxentry.get())

        try:
            pwrrt.init('sev_analyse')
        except RuntimeError as e:
            tkinter.messagebox.showerror("Error", str(e))
            return

        try:
            result = pwrrt.getSevItemsDataFrame( self.server, dataoid, dataattr, isobject,
                                                 fromvalue, tovalue, intervalvalue, maxvalue)
        except RuntimeError as e:
            tkinter.messagebox.showerror("Error", str(e))
            return

        if result == None:
            tkinter.messagebox.showerror("Error", "None return")
            return
            
        origdata = pd.DataFrame(data=result)
        origdata.columns = origcol

        self.wdata.new_data(origdata, wdcol, wdname)

        self.fswindow.destroy()


#
# End FetchSev class
#

    
file = ''
formula = ''
try:
    opts, args = getopt.getopt(sys.argv[1:], "f:r:", ["--file","--formula"])
except getopt.GetoptError:
    print('sev_analyse.py [-f <file> -r <formula>]')
    sys.exit(2)

for opt, arg in opts:
    if opt == "-h":
        print('sev_analyse.py [-f <file> [-f <formula>]]')
    if opt in ("-f", "--file"):
        file = arg
    if opt in ("-r", "--formula"):
        formula = arg
        
pwr_exe = os.environ.get('pwr_exe')
home = os.environ.get('HOME')
bgcolor = 'white'
buttoncolor = '#F0F0F0'

class MvMain:

    def __init__(self):
        global window
        global main

        self.applist = []
        
        # Create window
        main = self
        window = Tk()
        window.withdraw()
        wdwindow = WdWindow()
        if file != '':
            wdwindow.read_file(file)
            if formula != '':
                try:
                    wdwindow.wdata.apply_formula(formula)
                except co.Error as e:
                    tkinter.messagebox.showerror("Error", e.str)                    
                    return
                wdwindow.redraw()

    def add_appl(self, a):
        self.applist.append(a)

    def remove_appl(self, a):
        self.applist.remove(a)
        if len(self.applist) == 0:
            sys.exit()

    def set_icon(self, w):
        icon = PhotoImage(file=pwr_exe + '/pwr_icon16.png')
        window.tk.call('wm', 'iconphoto', w._w, icon)

            
MvMain()
window.mainloop()

