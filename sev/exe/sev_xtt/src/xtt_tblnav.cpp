/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* ge_attrnav.cpp -- Display object info */

#include <stdlib.h>

#include "pwr_baseclasses.h"
#include "co_cdh.h"
#include "co_dcli.h"
#include "co_string.h"
#include "co_time.h"

#include "flow_msg.h"

#include "xtt_tblnav.h"

/*
#define TBLNAV__INPUT_SYNTAX 2
#define TBLNAV__OBJNOTFOUND 4
#define TBLNAV__STRINGTOLONG 6
#define TBLNAV__ITEM_NOCREA 8
*/
#define TBLNAV__SUCCESS 1

void TblNav::message(char sev, const char* text)
{
  (message_cb)(parent_ctx, sev, text);
}

void TblNav::print(char* filename)
{
  brow_Print(brow->ctx, filename);
}

//
//  Free pixmaps
//
void TblNavBrow::free_pixmaps()
{
  brow_FreeAnnotPixmap(ctx, pixmap_leaf);
  brow_FreeAnnotPixmap(ctx, pixmap_map);
  brow_FreeAnnotPixmap(ctx, pixmap_openmap);
  brow_FreeAnnotPixmap(ctx, pixmap_attr);
}

//
//  Create pixmaps for leaf, closed map and open map
//
void TblNavBrow::allocate_pixmaps()
{
  brow_LoadPBM(ctx, "xnav_bitmap_leaf", &pixmap_leaf);
  brow_LoadPBM(ctx, "xnav_bitmap_map", &pixmap_map);
  brow_LoadPBM(ctx, "xnav_bitmap_openmap", &pixmap_openmap);
  brow_LoadPBM(ctx, "xnav_bitmap_attr", &pixmap_attr);
  brow_LoadPBM(ctx, "xnav_bitmap_attrarra", &pixmap_attrarray);
}

//
// Create the navigator widget
//
TblNav::TblNav(void* xn_parent_ctx, sevcli_sHistItem* xn_itemlist,
    int xn_item_cnt, pwr_tStatus* status)
    : parent_ctx(xn_parent_ctx), itemlist(xn_itemlist), item_cnt(xn_item_cnt),
      message_cb(NULL), list_layout(0)
{
  create_objectlist(xn_itemlist, xn_item_cnt, status);
  *status = 1;
}

//
//  Delete a nav context
//
TblNav::~TblNav()
{
}

TblNavBrow::~TblNavBrow()
{
  free_pixmaps();
}

int TblNav::is_authorized(unsigned int access, int msg)
{
  return (is_authorized_cb)(parent_ctx, access, msg);
}

//
// Callbacks from brow
//
static int tblnav_brow_cb(FlowCtx* ctx, flow_tEvent event)
{
  TblNav* tblnav;
  ItemBase* item;

  if (event->event == flow_eEvent_ObjectDeleted) {
    brow_GetUserData(event->object.object, (void**)&item);
    delete item;
    return 1;
  }

  brow_GetCtxUserData((BrowCtx*)ctx, (void**)&tblnav);

  if (!tblnav->is_authorized())
    return 1;

  tblnav->message(' ', "");
  switch (event->event) {
  case flow_eEvent_Key_PageDown: {
    brow_Page(tblnav->brow->ctx, 0.8);
    break;
  }
  case flow_eEvent_Key_PageUp: {
    brow_Page(tblnav->brow->ctx, -0.8);
    break;
  }
  case flow_eEvent_ScrollDown: {
    brow_Page(tblnav->brow->ctx, 0.1);
    break;
  }
  case flow_eEvent_ScrollUp: {
    brow_Page(tblnav->brow->ctx, -0.1);
    break;
  }
  case flow_eEvent_Key_Up: {
    brow_tNode* node_list;
    int node_count;
    brow_tObject object;
    int sts;

    brow_GetSelectedNodes(tblnav->brow->ctx, &node_list, &node_count);
    if (!node_count) {
      sts = brow_GetLastVisible(tblnav->brow->ctx, &object);
      if (EVEN(sts))
        return 1;
    } else {
      if (!brow_IsVisible(
              tblnav->brow->ctx, node_list[0], flow_eVisible_Partial)) {
        sts = brow_GetLastVisible(tblnav->brow->ctx, &object);
        if (EVEN(sts))
          return 1;
      } else {
        sts = brow_GetPrevious(tblnav->brow->ctx, node_list[0], &object);
        if (EVEN(sts)) {
          if (node_count)
            free(node_list);
          return 1;
        }
      }
    }
    brow_SelectClear(tblnav->brow->ctx);
    brow_SetInverse(object, 1);
    brow_SelectInsert(tblnav->brow->ctx, object);
    if (!brow_IsVisible(tblnav->brow->ctx, object, flow_eVisible_Full))
      brow_CenterObject(tblnav->brow->ctx, object, 0.25);
    if (node_count)
      free(node_list);
    break;
  }
  case flow_eEvent_Key_Down: {
    brow_tNode* node_list;
    int node_count;
    brow_tObject object;
    int sts;

    brow_GetSelectedNodes(tblnav->brow->ctx, &node_list, &node_count);
    if (!node_count) {
      sts = brow_GetFirstVisible(tblnav->brow->ctx, &object);
      if (EVEN(sts))
        return 1;
    } else {
      if (!brow_IsVisible(
              tblnav->brow->ctx, node_list[0], flow_eVisible_Partial)) {
        sts = brow_GetFirstVisible(tblnav->brow->ctx, &object);
        if (EVEN(sts))
          return 1;
      } else {
        sts = brow_GetNext(tblnav->brow->ctx, node_list[0], &object);
        if (EVEN(sts)) {
          if (node_count)
            free(node_list);
          return 1;
        }
      }
    }
    brow_SelectClear(tblnav->brow->ctx);
    brow_SetInverse(object, 1);
    brow_SelectInsert(tblnav->brow->ctx, object);
    if (!brow_IsVisible(tblnav->brow->ctx, object, flow_eVisible_Full))
      brow_CenterObject(tblnav->brow->ctx, object, 0.75);
    if (node_count)
      free(node_list);
    break;
  }
  case flow_eEvent_SelectClear:
    brow_ResetSelectInverse(tblnav->brow->ctx);
    break;
  case flow_eEvent_MB1Click: {
    // Select
    double ll_x, ll_y, ur_x, ur_y;
    int sts;

    switch (event->object.object_type) {
    case flow_eObjectType_Node:
      brow_MeasureNode(event->object.object, &ll_x, &ll_y, &ur_x, &ur_y);
      if (event->object.x < ll_x + 1.0) {
        // Simulate doubleclick
        flow_tEvent doubleclick_event;

        doubleclick_event = (flow_tEvent)calloc(1, sizeof(*doubleclick_event));
        memcpy(doubleclick_event, event, sizeof(*doubleclick_event));
        doubleclick_event->event = flow_eEvent_MB1DoubleClick;
        sts = tblnav_brow_cb(ctx, doubleclick_event);
        free((char*)doubleclick_event);
        return sts;
      }

      if (brow_FindSelectedObject(tblnav->brow->ctx, event->object.object)) {
        brow_SelectClear(tblnav->brow->ctx);
      } else {
        brow_SelectClear(tblnav->brow->ctx);
        brow_SetInverse(event->object.object, 1);
        brow_SelectInsert(tblnav->brow->ctx, event->object.object);
      }
      break;
    default:
      brow_SelectClear(tblnav->brow->ctx);
    }
    break;
  }
  case flow_eEvent_Key_Left: {
    brow_tNode* node_list;
    int node_count;
    brow_tObject object;
    int sts;

    brow_GetSelectedNodes(tblnav->brow->ctx, &node_list, &node_count);
    if (!node_count)
      return 1;

    if (brow_IsOpen(node_list[0]))
      // Close this node
      object = node_list[0];
    else {
      // Close parent
      sts = brow_GetParent(tblnav->brow->ctx, node_list[0], &object);
      if (EVEN(sts)) {
        free(node_list);
        return 1;
      }
    }
    brow_GetUserData(object, (void**)&item);
    item->close(tblnav, 0, 0);

    brow_SelectClear(tblnav->brow->ctx);
    brow_SetInverse(object, 1);
    brow_SelectInsert(tblnav->brow->ctx, object);
    if (!brow_IsVisible(tblnav->brow->ctx, object, flow_eVisible_Full))
      brow_CenterObject(tblnav->brow->ctx, object, 0.25);
    free(node_list);
    break;
  }
  case flow_eEvent_Key_Right: {
    brow_tNode* node_list;
    int node_count;

    brow_GetSelectedNodes(tblnav->brow->ctx, &node_list, &node_count);
    if (!node_count)
      return 1;

    brow_GetUserData(node_list[0], (void**)&item);
    switch (item->type) {
    case tblnav_eItemType_Local:
    case tblnav_eItemType_TreeLocal:
      ((ItemLocal*)item)->open_attributes(tblnav, 0, 0);
      break;
    case tblnav_eItemType_TreeNode:
      ((ItemTreeNode*)item)->open_children(tblnav, 0, 0);
      break;
    default:;
    }
  }
  case flow_eEvent_MB1DoubleClick:
    switch (event->object.object_type) {
    case flow_eObjectType_Node:
      brow_GetUserData(event->object.object, (void**)&item);
      switch (item->type) {
      case tblnav_eItemType_Local:
      case tblnav_eItemType_TreeLocal:
        ((ItemLocal*)item)
            ->open_attributes(tblnav, event->object.x, event->object.y);
        break;
      case tblnav_eItemType_TreeNode:
        ((ItemTreeNode*)item)
            ->open_children(tblnav, event->object.x, event->object.y);
        break;
      default:;
      }
      break;
    default:;
    }
    break;
  default:;
  }
  return 1;
}

//
// Create nodeclasses
//
void TblNavBrow::create_nodeclasses()
{
  allocate_pixmaps();

  // Create common-class

  brow_CreateNodeClass(
      ctx, "NavigatorDefault", flow_eNodeGroup_Common, &nc_object);
  brow_AddAnnotPixmap(nc_object, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap(nc_object, 1, 1.1, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot(nc_object, 2, 0.6, 0, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_object, 12, 0.6, 1, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 1);
  brow_AddAnnot(nc_object, 15, 0.6, 2, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 1);
  brow_AddFrame(nc_object, 0, 0, 20, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Create attribute nodeclass

  brow_CreateNodeClass(ctx, "NavigatorAttr", flow_eNodeGroup_Common, &nc_attr);
  brow_AddAnnotPixmap(nc_attr, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot(nc_attr, 2, 0.6, 0, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_attr, 8, 0.6, 1, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 1);
  brow_AddFrame(nc_attr, 0, 0, 20, 0.83, flow_eDrawType_LineGray, -1, 1);
}

void TblNav::show_list()
{
  list_layout = 1;
  brow_DeleteAll(brow->ctx);
  create_items();
}

void TblNav::show_tree()
{
  list_layout = 0;
  brow_DeleteAll(brow->ctx);
  create_items();
}

int TblNav::create_items()
{
  int i;

  brow_SetNodraw(brow->ctx);

  if (list_layout) {
    for (i = 0; i < (int)sevhistobjectlist.size(); i++) {
      new ItemLocal(this, &sevhistobjectlist[i], NULL, flow_eDest_IntoLast);
    }
  } else {
    for (int idx = 1; idx; idx = tree[idx].fws) {
      if (tree[idx].type == tblnav_eTreeItemType_SevHist)
        new ItemTreeLocal(this, &sevhistobjectlist[tree[idx].idx], idx, NULL,
            flow_eDest_IntoLast);
      if (tree[idx].type == tblnav_eTreeItemType_Command)
        new ItemTreeCommand(
            this, &commandlist[tree[idx].idx], idx, NULL, flow_eDest_IntoLast);
      else
        new ItemTreeNode(this, tree[idx].sname, idx, NULL, flow_eDest_IntoLast);
    }
  }
  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
  return TBLNAV__SUCCESS;
}

void TblNavBrow::brow_setup()
{
  brow_sAttributes brow_attr;
  unsigned long mask;

  mask = 0;
  mask |= brow_eAttr_indentation;
  brow_attr.indentation = 0.5;
  mask |= brow_eAttr_annotation_space;
  brow_attr.annotation_space = 0.5;
  brow_SetAttributes(ctx, &brow_attr, mask);
  brow_SetCtxUserData(ctx, tblnav);

  brow_EnableEvent(
      ctx, flow_eEvent_MB1Click, flow_eEventType_CallBack, tblnav_brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_MB1DoubleClick, flow_eEventType_CallBack,
      tblnav_brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_SelectClear, flow_eEventType_CallBack, tblnav_brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_ObjectDeleted, flow_eEventType_CallBack, tblnav_brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_Key_Up, flow_eEventType_CallBack, tblnav_brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_Key_Down, flow_eEventType_CallBack, tblnav_brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_Key_Right, flow_eEventType_CallBack, tblnav_brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_Key_Left, flow_eEventType_CallBack, tblnav_brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_Key_PF3, flow_eEventType_CallBack, tblnav_brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_Radiobutton, flow_eEventType_CallBack, tblnav_brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_Key_PageUp, flow_eEventType_CallBack, tblnav_brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_Key_PageDown, flow_eEventType_CallBack, tblnav_brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_ScrollUp, flow_eEventType_CallBack, tblnav_brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_ScrollDown, flow_eEventType_CallBack, tblnav_brow_cb);
}

//
// Backcall routine called at creation of the brow widget
// Enable event, create nodeclasses and insert the root objects.
//
int TblNav::init_brow_cb(FlowCtx* fctx, void* client_data)
{
  TblNav* tblnav = (TblNav*)client_data;
  BrowCtx* ctx = (BrowCtx*)fctx;

  tblnav->brow = new TblNavBrow(ctx, (void*)tblnav);

  tblnav->brow->brow_setup();
  tblnav->brow->create_nodeclasses();

  tblnav->build_tree();

  // Create the root items
  tblnav->create_items();

  if (tblnav->command_cb) {
    pwr_tCmd cmd = "@$HOME/sev_xtt_setup";
    tblnav->command_cb(tblnav->parent_ctx, cmd);
  }

  // sts = brow_TraceInit( ctx, tblnav_trace_connect_bc,
  //		tblnav_trace_disconnect_bc, tblnav_trace_scan_bc);
  // tblnav->trace_started = 1;

  // tblnav->trace_start();

  return 1;
}

int TblNav::get_select(ItemBase** item)
{
  brow_tNode* node_list;
  int node_count;

  brow_GetSelectedNodes(brow->ctx, &node_list, &node_count);

  if (!node_count)
    return 0;

  brow_GetUserData(node_list[0], (void**)item);
  return 1;
}

int TblNav::get_item(char* oname, TblNav_sevhistobject** hi)
{
  for (int i = 0; i < (int)sevhistobjectlist.size(); i++) {
    if (str_NoCaseStrcmp(sevhistobjectlist[i].oname, oname) == 0) {
      *hi = &sevhistobjectlist[i];
      return 1;
    }
  }
  return 0;
}

//
//  Get zoom
//
void TblNav::get_zoom(double* zoom_factor)
{
  brow_GetZoom(brow->ctx, zoom_factor);
}

//
//  Zoom
//
void TblNav::zoom(double zoom_factor)
{
  brow_Zoom(brow->ctx, zoom_factor);
}

//
//  Return to base zoom factor
//
void TblNav::unzoom()
{
  brow_UnZoom(brow->ctx);
}

void TblNav::delete_item(TblNav_sevhistobject* hi)
{
  brow_tNode* node_list;
  int node_count;
  ItemBase* baseitem;

  brow_GetObjectList(brow->ctx, &node_list, &node_count);
  // Delete in tree
  for (int i = 1; i < (int)tree.size(); i++) {
    if (tree[i].deleted)
      continue;
    if (tree[i].type == tblnav_eTreeItemType_SevHist
        && cdh_ObjidIsEqual(sevhistobjectlist[tree[i].idx].oid, hi->oid)
        && strcmp(sevhistobjectlist[tree[i].idx].objectattrlist[0].aname,
               hi->objectattrlist[0].aname)
            == 0) {
      tree[i].deleted = 1;
    }
  }

  // Delete node if visible
  brow_GetObjectList(brow->ctx, &node_list, &node_count);

  int found = 0;
  for (int i = 0; i < node_count; i++) {
    brow_GetUserData(node_list[i], (void**)&baseitem);
    switch (baseitem->type) {
    case tblnav_eItemType_Local:
    case tblnav_eItemType_TreeLocal: {
      ItemLocal* item = (ItemLocal*)baseitem;
      if (cdh_ObjidIsEqual(hi->oid, item->item.oid)
          && strcmp(hi->objectattrlist[0].aname,
                 item->item.objectattrlist[0].aname)
              == 0) {
        brow_DeleteNode(brow->ctx, item->node);
        found = 1;
      }
      break;
    }
    default:;
    }
    if (found)
      break;
  }
}

void TblNav::add_item_command(char* name, char* command)
{
  TblNav_command item;

  strncpy(item.oname, name, sizeof(item.oname));
  strncpy(item.command, command, sizeof(item.command));

  commandlist.push_back(item);
  tree_add(name, commandlist.size() - 1, tblnav_eTreeItemType_Command);
}

ItemBase::ItemBase(tblnav_eItemType t) : type(t)
{
}

ItemBase::~ItemBase()
{
}

int ItemBase::close(TblNav* tblnav, double x, double y)
{
  return 1;
}

ItemLocal::ItemLocal(TblNav* tblnav, TblNav_sevhistobject* xitem,
    brow_tNode dest, flow_eDest dest_code)
    : ItemBase(tblnav_eItemType_Local), item(*xitem)
{
  type = tblnav_eItemType_Local;
  pwr_tAName aname;

  brow_CreateNode(tblnav->brow->ctx, "LocalItem", tblnav->brow->nc_object, dest,
      dest_code, (void*)this, 1, &node);

  brow_SetAnnotPixmap(node, 0, tblnav->brow->pixmap_leaf);

  strcpy(aname, item.oname);
  if (item.attrnum == 1) {
    strcat(aname, ".");
    strcat(aname, item.objectattrlist[0].aname);
  }
  brow_SetAnnotation(node, 0, aname, strlen(aname));
  brow_SetAnnotation(node, 1, item.description, strlen(item.description));
}

int ItemLocal::open_attributes(TblNav* tblnav, double x, double y)
{
  double node_x, node_y;

  brow_GetNodePosition(node, &node_x, &node_y);

  if (brow_IsOpen(node)) {
    // Close
    brow_SetNodraw(tblnav->brow->ctx);
    brow_CloseNode(tblnav->brow->ctx, node);
    brow_SetAnnotPixmap(node, 0, tblnav->brow->pixmap_leaf);
    brow_ResetOpen(node, tblnav_mOpen_All);
    brow_ResetNodraw(tblnav->brow->ctx);
    brow_Redraw(tblnav->brow->ctx, node_y);
  } else {
    char value[256];
    char txt[80];

    brow_SetNodraw(tblnav->brow->ctx);

    new ItemLocalAttr(
        tblnav, "Description", item.description, node, flow_eDest_IntoLast);

    strcpy(value, "");
    cdh_OidToString(value, sizeof(value), item.oid, 1);
    new ItemLocalAttr(tblnav, "Oid", value, node, flow_eDest_IntoLast);

    new ItemLocalAttr(tblnav, "Object", item.oname, node, flow_eDest_IntoLast);

    time_DtoAscii(&item.storagetime, 0, value, sizeof(value));
    new ItemLocalAttr(tblnav, "StorageTime", value, node, flow_eDest_IntoLast);

    time_AtoAscii(
        &item.creatime, time_eFormat_DateAndTime, value, sizeof(value));
    new ItemLocalAttr(tblnav, "CreationTime", value, node, flow_eDest_IntoLast);

    time_AtoAscii(
        &item.modtime, time_eFormat_DateAndTime, value, sizeof(value));
    new ItemLocalAttr(
        tblnav, "ModificationTime", value, node, flow_eDest_IntoLast);

    sprintf(value, "%f", item.scantime);
    new ItemLocalAttr(tblnav, "ScanTime", value, node, flow_eDest_IntoLast);

    strcpy(value, "");
    if (item.options & pwr_mSevOptionsMask_PosixTime)
      strcat(value, " PosixTime");
    if (item.options & pwr_mSevOptionsMask_HighTimeResolution)
      strcat(value, " HighTimeResolution");
    if (item.options & pwr_mSevOptionsMask_ReadOptimized)
      strcat(value, " ReadOptimized");
    if (item.options & pwr_mSevOptionsMask_UseDeadBand)
      strcat(value, " UseDeadBand");
    new ItemLocalAttr(tblnav, "Options", value, node, flow_eDest_IntoLast);

    sprintf(value, "%f", item.deadband);
    new ItemLocalAttr(tblnav, "Deadband", value, node, flow_eDest_IntoLast);

    for (int i = 0; i < (int)item.objectattrlist.size(); i++) {
      sprintf(txt, "Attr[%d].Name", i);
      new ItemLocalAttr(
          tblnav, txt, item.objectattrlist[i].aname, node, flow_eDest_IntoLast);

      switch (item.objectattrlist[i].type) {
      case pwr_eType_Int64:
        strcpy(value, "Int64");
        break;
      case pwr_eType_Int32:
        strcpy(value, "Int32");
        break;
      case pwr_eType_Int16:
        strcpy(value, "Int16");
        break;
      case pwr_eType_Int8:
        strcpy(value, "Int8");
        break;
      case pwr_eType_UInt64:
        strcpy(value, "UInt64");
        break;
      case pwr_eType_UInt32:
        strcpy(value, "UInt32");
        break;
      case pwr_eType_UInt16:
        strcpy(value, "UInt16");
        break;
      case pwr_eType_UInt8:
        strcpy(value, "UInt8");
        break;
      case pwr_eType_Boolean:
        strcpy(value, "Boolean");
        break;
      case pwr_eType_Char:
        strcpy(value, "Char");
        break;
      case pwr_eType_Float32:
        strcpy(value, "Float32");
        break;
      case pwr_eType_Float64:
        strcpy(value, "Float64");
        break;
      case pwr_eType_String:
        strcpy(value, "String");
        break;
      case pwr_eType_Time:
        strcpy(value, "Time");
        break;
      case pwr_eType_DeltaTime:
        strcpy(value, "DeltaTime");
        break;
      default:
        strcpy(value, "Unknown");
      }
      sprintf(txt, "Attr[%d].DataType", i);
      new ItemLocalAttr(tblnav, txt, value, node, flow_eDest_IntoLast);

      sprintf(txt, "Attr[%d].DataSize", i);
      sprintf(value, "%d", item.objectattrlist[i].size);
      new ItemLocalAttr(tblnav, txt, value, node, flow_eDest_IntoLast);

      sprintf(txt, "Attr[%d].Unit", i);
      new ItemLocalAttr(
          tblnav, txt, item.objectattrlist[i].unit, node, flow_eDest_IntoLast);
    }
    brow_SetOpen(node, tblnav_mOpen_Attributes);
    brow_ResetNodraw(tblnav->brow->ctx);
    brow_Redraw(tblnav->brow->ctx, node_y);
  }
  return 1;
}

int ItemLocal::close(TblNav* tblnav, double x, double y)
{
  double node_x, node_y;

  brow_GetNodePosition(node, &node_x, &node_y);

  if (brow_IsOpen(node)) {
    // Close
    brow_SetNodraw(tblnav->brow->ctx);
    brow_CloseNode(tblnav->brow->ctx, node);
    brow_SetAnnotPixmap(node, 0, tblnav->brow->pixmap_leaf);
    brow_ResetOpen(node, tblnav_mOpen_All);
    brow_ResetNodraw(tblnav->brow->ctx);
    brow_Redraw(tblnav->brow->ctx, node_y);
  }
  return 1;
}

ItemLocalAttr::ItemLocalAttr(TblNav* tblnav, const char* name, char* value,
    brow_tNode dest, flow_eDest dest_code)
    : ItemBase(tblnav_eItemType_LocalAttr)
{
  brow_CreateNode(tblnav->brow->ctx, "LocalItemAttr", tblnav->brow->nc_attr,
      dest, dest_code, (void*)this, 1, &node);

  brow_SetAnnotPixmap(node, 0, tblnav->brow->pixmap_attr);

  brow_SetAnnotation(node, 0, name, strlen(name));
  brow_SetAnnotation(node, 1, value, strlen(value));
}

ItemLocalAttr::~ItemLocalAttr()
{
}

ItemTreeLocal::ItemTreeLocal(TblNav* tblnav, TblNav_sevhistobject* xitem,
    int index, brow_tNode dest, flow_eDest dest_code)
    : ItemLocal(tblnav, xitem, dest, dest_code), idx(index)
{
  pwr_tAName aname;
  char* s;

  type = tblnav_eItemType_TreeLocal;

  if ((s = strrchr(item.oname, '-')))
    strcpy(aname, s + 1);
  else
    strcpy(aname, item.oname);
  if (item.attrnum == 1) {
    strcat(aname, ".");
    strcat(aname, item.objectattrlist[0].aname);
  }
  brow_SetAnnotation(node, 0, aname, strlen(aname));
}

ItemTreeLocal::~ItemTreeLocal()
{
}

ItemTreeNode::ItemTreeNode(TblNav* tblnav, char* name, int index,
    brow_tNode dest, flow_eDest dest_code)
    : ItemBase(tblnav_eItemType_TreeNode), idx(index)
{
  brow_CreateNode(tblnav->brow->ctx, "TreeNode", tblnav->brow->nc_attr, dest,
      dest_code, (void*)this, 1, &node);

  if (tblnav->tree[idx].fch)
    brow_SetAnnotPixmap(node, 0, tblnav->brow->pixmap_map);
  else
    brow_SetAnnotPixmap(node, 0, tblnav->brow->pixmap_leaf);

  brow_SetAnnotation(node, 0, name, strlen(name));
}

ItemTreeNode::~ItemTreeNode()
{
}

int ItemTreeNode::open_children(TblNav* tblnav, double x, double y)
{
  double node_x, node_y;

  brow_GetNodePosition(node, &node_x, &node_y);

  if (brow_IsOpen(node) & tblnav_mOpen_Children) {
    // Attributes is open, close
    brow_SetNodraw(tblnav->brow->ctx);
    brow_CloseNode(tblnav->brow->ctx, node);
    brow_ResetOpen(node, tblnav_mOpen_Children);
    brow_RemoveAnnotPixmap(node, 1);
    brow_ResetNodraw(tblnav->brow->ctx);
    brow_Redraw(tblnav->brow->ctx, node_y);
  } else {
    brow_SetNodraw(tblnav->brow->ctx);
    for (int i = tblnav->tree[idx].fch; i; i = tblnav->tree[i].fws) {
      if (tblnav->tree[i].deleted)
        continue;

      if (tblnav->tree[i].type == tblnav_eTreeItemType_SevHist)
        new ItemTreeLocal(tblnav,
            &tblnav->sevhistobjectlist[tblnav->tree[i].idx], i, node,
            flow_eDest_IntoLast);
      else if (tblnav->tree[i].type == tblnav_eTreeItemType_Command)
        new ItemTreeCommand(tblnav, &tblnav->commandlist[tblnav->tree[i].idx],
            i, node, flow_eDest_IntoLast);
      else
        new ItemTreeNode(
            tblnav, tblnav->tree[i].sname, i, node, flow_eDest_IntoLast);
    }
    brow_SetOpen(node, tblnav_mOpen_Children);
    brow_SetAnnotPixmap(node, 1, tblnav->brow->pixmap_openmap);
    brow_ResetNodraw(tblnav->brow->ctx);
    brow_Redraw(tblnav->brow->ctx, node_y);
  }
  return 1;
}

int ItemTreeNode::close(TblNav* tblnav, double x, double y)
{
  double node_x, node_y;

  if (brow_IsOpen(node) & tblnav_mOpen_Children) {
    // Children is open, close
    brow_GetNodePosition(node, &node_x, &node_y);
    brow_SetNodraw(tblnav->brow->ctx);
    brow_CloseNode(tblnav->brow->ctx, node);
    brow_ResetOpen(node, tblnav_mOpen_All);
    brow_ResetNodraw(tblnav->brow->ctx);
    brow_Redraw(tblnav->brow->ctx, node_y);
  }
  return 1;
}

ItemTreeCommand::ItemTreeCommand(TblNav* tblnav, TblNav_command* xitem,
    int index, brow_tNode dest, flow_eDest dest_code)
    : ItemBase(tblnav_eItemType_TreeCommand), item(*xitem), idx(index)
{
  pwr_tAName aname;
  char* s;

  type = tblnav_eItemType_TreeCommand;
  if ((s = strrchr(item.oname, '-')))
    strcpy(aname, s + 1);
  else
    strcpy(aname, item.oname);

  brow_CreateNode(tblnav->brow->ctx, "TreeNodeCommand", tblnav->brow->nc_attr,
      dest, dest_code, (void*)this, 1, &node);

  if (tblnav->tree[idx].fch)
    brow_SetAnnotPixmap(node, 0, tblnav->brow->pixmap_map);
  else
    brow_SetAnnotPixmap(node, 0, tblnav->brow->pixmap_leaf);

  brow_SetAnnotation(node, 0, aname, strlen(aname));
}

ItemTreeCommand::~ItemTreeCommand()
{
}

void TblNav::build_tree()
{
  pwr_tAName aname;

  for (int i = 0; i < (int)sevhistobjectlist.size(); i++) {
    TblTreeNode n;

    if (sevhistobjectlist[i].objectattrlist.size() == 0)
      continue;

    strcpy(aname, sevhistobjectlist[i].oname);
    strcat(aname, ".");
    strcat(aname, sevhistobjectlist[i].objectattrlist[0].aname);

    tree_add(aname, i, tblnav_eTreeItemType_SevHist);
  }
}

void TblNav::tree_add(char* name, int list_index, tblnav_eTreeItemType type)
{
  pwr_tObjName name_array[24];
  int seg;

  seg = dcli_parse(name, "-", "", (char*)name_array,
      sizeof(name_array) / sizeof(name_array[0]), sizeof(name_array[0]), 0);

  if (tree.size() == 0) {
    // First item
    TblTreeNode n0;
    strcpy(n0.sname, "nonode");
    tree.push_back(n0);

    for (int j = 0; j < seg; j++) {
      TblTreeNode n;

      n.fth = j;
      tree[j].fch = j + 1;
      strcpy(n.sname, name_array[j]);
      if (j == seg - 1) {
        n.idx = list_index;
        n.type = type;
      }
      tree.push_back(n);
    }
  } else {
    int idx = 1;
    int last = idx;
    for (int j = 0; j < seg; j++) {
      int found = 0;
      while (idx) {
        last = idx;
        if (streq(tree[idx].sname, name_array[j])) {
          found = 1;
          break;
        }
        idx = tree[idx].fws;
      }
      if (!found) {
        TblTreeNode n;
        strcpy(n.sname, name_array[j]);
        n.fth = tree[last].fth;
        n.bws = last;
        tree[last].fws = tree.size();
        if (j == seg - 1) {
          n.idx = list_index;
          n.type = type;
        }
        tree.push_back(n);

        for (int k = j + 1; k < seg; k++) {
          TblTreeNode n;

          n.fth = tree.size() - 1;
          if (tree[n.fth].fch == 0)
            tree[n.fth].fch = tree.size();
          strcpy(n.sname, name_array[k]);
          if (k == seg - 1) {
            n.idx = list_index;
            n.type = type;
          }
          tree.push_back(n);
        }
        break;
      }
      if (tree[idx].fch == 0) {
        TblTreeNode n;
        strcpy(n.sname, name_array[j]);
        n.fth = tree[last].fth;
        n.bws = last;
        tree[last].fws = tree.size();
        if (j == seg - 1) {
          n.idx = list_index;
          n.type = type;
        }
        tree.push_back(n);
        for (int k = j + 1; k < seg; k++) {
          TblTreeNode n;

          n.fth = tree.size() - 1;
          if (tree[n.fth].fch == 0)
            tree[n.fth].fch = tree.size();
          strcpy(n.sname, name_array[k]);
          if (k == seg - 1) {
            n.idx = list_index;
            n.type = type;
          }
          tree.push_back(n);
        }
        break;
      }
      idx = tree[idx].fch;
      last = idx;
    }
  }
}

void TblNav::create_objectlist(
    sevcli_sHistItem* xn_itemlist, int xn_item_cnt, pwr_tStatus* status)
{
  sevcli_sHistItem* histItemPtr = xn_itemlist;
  while ((int)sevhistobjectlist.size() < xn_item_cnt) {
    // Item with multiple attributes
    TblNav_sevhistobject object;
    object.attrnum = histItemPtr->attrnum;
    object.creatime = histItemPtr->creatime;
    object.deadband = histItemPtr->deadband;
    strncpy(object.description, histItemPtr->description,
        sizeof(object.description));
    object.modtime = histItemPtr->modtime;
    object.oid = histItemPtr->oid;
    strncpy(object.oname, histItemPtr->oname, sizeof(object.oname));
    object.options = histItemPtr->options;
    object.scantime = histItemPtr->scantime;
    object.storagetime = histItemPtr->storagetime;
    size_t j = 0;
    for (j = 0; j < object.attrnum; j++) {
      TblNav_sevhistobjectattr oattr;
      strncpy(oattr.aname, histItemPtr->attr[j].aname, sizeof(oattr.aname));
      oattr.elem = histItemPtr->attr[j].elem;
      oattr.size = histItemPtr->attr[j].size;
      oattr.type = histItemPtr->attr[j].type;
      strncpy(oattr.unit, histItemPtr->attr[j].unit, sizeof(oattr.unit));
      object.objectattrlist.push_back(oattr);
    }
    sevhistobjectlist.push_back(object);
    histItemPtr = (sevcli_sHistItem*)&histItemPtr->attr[j];
  }
}
