/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* xtt_tbl.cpp -- Display object attributes */

#include <stdlib.h>

#include "co_cnf.h"
#include "co_dcli.h"
#include "co_string.h"
#include "co_time.h"

#include "cow_wow.h"
#include "cow_xhelp.h"

#include "flow_msg.h"

#include "glow_curvectx.h"

#include "xtt_sevhist.h"
#include "xtt_tbl.h"
#include "xtt_tblnav.h"

XttTbl::~XttTbl()
{
}

XttTbl::XttTbl(void* xn_parent_ctx, sevcli_tCtx xn_sevcli)
    : parent_ctx(xn_parent_ctx), sevcli(xn_sevcli), cologin(0), command_open(0),
      close_cb(0), base_priv(pwr_mPrv_System), priv(pwr_mPrv_System), verify(0),
      ccm_func_registred(0), wow(0), quiet(0)
{
  char default_priv[80];

  strcpy(base_user, "");
  strcpy(user, "");

  // Get default privilete from proview.cnf
  if (cnf_get_value("sevXttDefaultPriv", default_priv, sizeof(default_priv))) {
    if (str_NoCaseStrcmp(default_priv, "READ") == 0)
      priv = pwr_mPrv_SevRead;
    else if (str_NoCaseStrcmp(default_priv, "ADMIN") == 0)
      priv = pwr_mPrv_SevAdmin;
    else if (str_NoCaseStrcmp(default_priv, "NONE") == 0)
      priv = 0;
    else
      priv = 0;
  } else
    priv = 0;
}

void XttTbl::message(void* xtttbl, char severity, const char* message)
{
  ((XttTbl*)xtttbl)->message(severity, message);
}

int XttTbl::command_cb(void* ctx, char* cmd)
{
  return ((XttTbl*)ctx)->command(cmd);
}

int XttTbl::is_authorized(void* ctx, unsigned int access, int msg)
{
  return ((XttTbl*)ctx)->is_authorized(access, msg);
}

int XttTbl::is_authorized(unsigned int access, int msg)
{
  if (!(priv & access)) {
    if (msg)
      message('I', "Not authorized for this operation");
    return 0;
  }
  return 1;
}

void XttTbl::open_login()
{
  pwr_tCmd cmd;
  strcpy(cmd, "login");
  command(cmd);
}

void XttTbl::logout()
{
  pwr_tCmd cmd;
  strcpy(cmd, "logout");
  command(cmd);
}

void XttTbl::activate_print()
{
  pwr_tFileName filename;
  pwr_tCmd cmd;

  dcli_translate_filename(filename, "$pwrp_tmp/sevxtt.ps");
  tblnav->print(filename);

  sprintf(cmd, "$pwr_exe/rt_print.sh %s", filename);
  system(cmd);
}

void XttTbl::activate_opensevhist()
{
  ItemBase* item;
  XttSevHist* hist;
  pwr_tStatus sts;

  if (!tblnav->get_select(&item)) {
    message('E', "Select an storage item");
    return;
  }

  switch (item->type) {
  case tblnav_eItemType_Local:
  case tblnav_eItemType_TreeLocal: {
    TblNav_sevhistobject* hi = &((ItemLocal*)item)->item;
    pwr_tOid oidv[2] = { hi->oid, pwr_cNOid };
    pwr_tOName anamev[2];
    pwr_tOName onamev[2] = { "", "" };
    bool sevhistobjectv[2] = { hi->attrnum > 1, false };
    if (!sevhistobjectv[0]) {
      strcpy(anamev[0], hi->objectattrlist[0].aname);
      strcpy(onamev[0], hi->oname);
      hist = sevhist_new(oidv, anamev, onamev, sevhistobjectv, &sts);
      if (ODD(sts)) {
        hist->help_cb = sevhist_help_cb;
        hist->get_select_cb = sevhist_get_select_cb;
      }
    } else {
      char* s;
      pwr_tAName aname;
      s = strchr(hi->oname, '.');
      if (!s) {
        // It is a complete object
        aname[0] = '\0';
      } else {
        strcpy(aname, s + 1);
      }
      strcpy(anamev[0], aname);
      hist = sevhist_new(oidv, anamev, onamev, sevhistobjectv, &sts);
      if (ODD(sts)) {
        hist->help_cb = sevhist_help_cb;
        hist->get_select_cb = sevhist_get_select_cb;
      }
    }
    break;
  }
  case tblnav_eItemType_TreeCommand: {
    ItemTreeCommand* ci = (ItemTreeCommand*)item;

    command(ci->item.command);
    break;
  }
  default:;
  }
}

void XttTbl::delete_item_yes(void* ctx, void* data)
{
  XttTbl* tbl = (XttTbl*)ctx;
  //  sevcli_sHistItem *hi = (sevcli_sHistItem *)data;
  TblNav_sevhistobject* hi = (TblNav_sevhistobject*)data;
  pwr_tStatus sts;

  printf("Deleting %s\n", hi->oname);
  sevcli_delete_item(&sts, tbl->sevcli, hi->oid, hi->objectattrlist[0].aname);
  if (EVEN(sts)) {
    tbl->message('E', "Delete error");
    return;
  }
  tbl->tblnav->delete_item(hi);

  tbl->message('I', "Item deleted");
}

void XttTbl::activate_delete_item()
{
  // sevcli_sHistItem *hi;
  ItemBase* item;
  TblNav_sevhistobject* hi;
  char msg[860];

  if (!tblnav->get_select(&item)) {
    message('E', "Select an storage item");
    return;
  }
  if (!(item->type == tblnav_eItemType_Local
          || item->type == tblnav_eItemType_TreeLocal)) {
    message('E', "Select an storage item");
    return;
  }
  hi = &((ItemLocal*)item)->item;

  sprintf(msg,
      "Do you really wan't to delete all stored data for item\n\n%s.%s\n",
      hi->oname, hi->objectattrlist[0].aname);

  wow->DisplayQuestion(
      this, "Confirm Delete Item", msg, delete_item_yes, 0, hi);
}

void XttTbl::activate_zoom_in()
{
  double zoom_factor;

  tblnav->get_zoom(&zoom_factor);
  if (zoom_factor > 40)
    return;

  tblnav->zoom(1.18);
}

void XttTbl::activate_zoom_out()
{
  double zoom_factor;

  tblnav->get_zoom(&zoom_factor);
  if (zoom_factor < 15)
    return;

  tblnav->zoom(1.0 / 1.18);
}

void XttTbl::activate_zoom_reset()
{
  tblnav->unzoom();
}

void XttTbl::activate_help()
{
  CoXHelp::dhelp("overview", "", navh_eHelpFile_Base, NULL, 0);
}

void XttTbl::activate_help_project()
{
  CoXHelp::dhelp("index", "", navh_eHelpFile_Project, NULL, 0);
}

void XttTbl::activate_help_proview()
{
  char cmd[] = "help /version";

  command(cmd);
}

void XttTbl::sevhist_help_cb(void* ctx, const char* key)
{
  CoXHelp::dhelp(key, "", navh_eHelpFile_Base, NULL, 0);
}

int XttTbl::sevhist_get_select_cb(
    void* ctx, pwr_tOid* oid, char* aname, char* oname)
{
  XttTbl* xtttbl = (XttTbl*)ctx;
  ItemBase* item;

  if (!xtttbl->tblnav->get_select(&item)) {
    xtttbl->message('E', "Select an storage item");
    return 0;
  }

  switch (item->type) {
  case tblnav_eItemType_Local:
  case tblnav_eItemType_TreeLocal: {
    TblNav_sevhistobject* hi = &((ItemLocal*)item)->item;
    if (hi->attrnum > 1)
      return 0;

    *oid = hi->oid;
    strcpy(aname, hi->objectattrlist[0].aname);
    strcpy(oname, hi->oname);
    break;
  }
  default:
    return 0;
  }
  return 1;
}
