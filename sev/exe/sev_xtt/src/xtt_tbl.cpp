/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2012 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

/* xtt_tbl.cpp -- Display object attributes */

#include "glow_std.h"

#include <stdio.h>
#include <stdlib.h>
#include <vector>
#include "co_cdh.h"
#include "co_time.h"
#include "cow_xhelp.h"
#include "co_dcli.h"
#include "cow_wow.h"
#include "co_cnf.h"

#include "flow.h"
#include "flow_browctx.h"
#include "flow_browapi.h"

#include "glow.h"
#include "glow_growctx.h"
#include "glow_growapi.h"
#include "flow_msg.h"

#include "glow_curvectx.h"

#include "xtt_tbl.h"
#include "xtt_tblnav.h"
#include "xtt_sevhist.h"

XttTbl::~XttTbl()
{
}

XttTbl::XttTbl( void *xn_parent_ctx, sevcli_tCtx xn_sevcli) :
  parent_ctx(xn_parent_ctx), sevcli(xn_sevcli), cologin(0), command_open(0), close_cb(0),
  base_priv(pwr_mPrv_System), priv(pwr_mPrv_System), verify(0), ccm_func_registred(0),
  wow(0), quiet(0)
{
  char default_priv[80];

  strcpy( base_user, "");
  strcpy( user, "");

  // Get default privilete from proview.cnf
  if ( cnf_get_value( "sevXttDefaultPriv", default_priv, sizeof(default_priv))) {
    if ( cdh_NoCaseStrcmp( default_priv, "READ") == 0)
      priv = pwr_mPrv_SevRead;
    else if ( cdh_NoCaseStrcmp( default_priv, "ADMIN") == 0)
      priv = pwr_mPrv_SevAdmin;
    else if ( cdh_NoCaseStrcmp( default_priv, "NONE") == 0)
      priv = 0;
    else
      priv = 0;
  }
  else
    priv = 0;
}

void XttTbl::message( void *xtttbl, char severity, const char *message)
{
  ((XttTbl *)xtttbl)->message( severity, message);
}

int XttTbl::command_cb( void *ctx, char *cmd)
{
  return ((XttTbl *)ctx)->command( cmd);
}

int XttTbl::is_authorized( void *ctx, unsigned int access, int msg)
{
  return ((XttTbl *)ctx)->is_authorized( access, msg);
}

int XttTbl::is_authorized( unsigned int access, int msg)
{
  if (!(priv & access)) {
    if ( msg)
      message( 'I', "Not authorized for this operation");
    return 0;
  }
  return 1;
}

void XttTbl::open_login()
{
  pwr_tCmd cmd;
  strcpy( cmd, "login");
  command( cmd);
}

void XttTbl::logout()
{
  pwr_tCmd cmd;
  strcpy( cmd, "logout");
  command( cmd);
}

void XttTbl::activate_print()
{
  pwr_tFileName filename;
  pwr_tCmd cmd;

  dcli_translate_filename( filename, "$pwrp_tmp/sevxtt.ps");
  tblnav->print( filename);

  sprintf( cmd, "$pwr_exe/rt_print.sh %s", filename);
  system(cmd);
}

void XttTbl::activate_opensevhist()
{
  ItemBase *item;
  XttSevHist *hist;
  pwr_tStatus sts;

  if ( !tblnav->get_select( &item)) {
    message( 'E', "Select an storage item");
    return;
  }

  switch ( item->type) {
  case tblnav_eItemType_Local:
  case tblnav_eItemType_TreeLocal: {
    TblNav_sevhistobject *hi = &((ItemLocal *)item)->item;
    pwr_tOid oidv[2] = { hi->oid, pwr_cNOid};
    pwr_tOName anamev[2];
    pwr_tOName onamev[2] = {"", ""};
    bool sevhistobjectv[2] = {hi->attrnum > 1, false};
    if( !sevhistobjectv[0] ) {
      strcpy( anamev[0], hi->objectattrlist[0].aname);
      strcpy( onamev[0], hi->oname);
      hist = sevhist_new( oidv, anamev, onamev, sevhistobjectv, &sts);
      if ( ODD(sts)) {
        hist->help_cb = sevhist_help_cb;
	hist->get_select_cb = sevhist_get_select_cb;
      }
    }
    else {
      char *s;
      pwr_tAName aname;
      s = strchr( hi->oname, '.');
      if ( !s) {
	//It is a complete object
	aname[0] = '\0';
      }
      else {  
	strcpy( aname, s+1);
      }
      strcpy( anamev[0], aname);
      hist = sevhist_new( oidv, anamev, onamev, sevhistobjectv, &sts);
      if ( ODD(sts)) {
        hist->help_cb = sevhist_help_cb;
	hist->get_select_cb = sevhist_get_select_cb;
      }
    }
    break;
  }
  case tblnav_eItemType_TreeCommand: {
    ItemTreeCommand *ci = (ItemTreeCommand *)item;

    command( ci->item.command);
    break;
  }
  default: ;
  }
}

void XttTbl::delete_item_yes( void *ctx, void *data)
{
  XttTbl *tbl = (XttTbl *)ctx;
//  sevcli_sHistItem *hi = (sevcli_sHistItem *)data;
  TblNav_sevhistobject *hi = (TblNav_sevhistobject *)data;
  pwr_tStatus sts;

  printf("Deleting %s\n", hi->oname);
  sevcli_delete_item( &sts, tbl->sevcli, hi->oid, hi->objectattrlist[0].aname);
  if ( EVEN(sts)) {
    tbl->message( 'E', "Delete error");
    return;
  }
  tbl->tblnav->delete_item( hi);

  tbl->message( 'I', "Item deleted");
}

void XttTbl::activate_delete_item()
{
  //sevcli_sHistItem *hi;
  ItemBase *item;
  TblNav_sevhistobject *hi;
  char msg[300];

  if ( !tblnav->get_select( &item)) {
    message( 'E', "Select an storage item");
    return;
  }
  if ( !(item->type == tblnav_eItemType_Local || 
	 item->type == tblnav_eItemType_TreeLocal)) {
    message( 'E', "Select an storage item");
    return;
  }
  hi = &((ItemLocal *)item)->item;

  sprintf( msg, "Do you really wan't to delete all stored data for item\n\n%s.%s\n", hi->oname, hi->objectattrlist[0].aname);

  wow->DisplayQuestion( this, "Confirm Delete Item", msg, delete_item_yes, 0, hi);
}

void XttTbl::activate_zoom_in()
{
  double zoom_factor;

  tblnav->get_zoom( &zoom_factor);
  if ( zoom_factor > 40)
    return;

   tblnav->zoom( 1.18);
}

void XttTbl::activate_zoom_out()
{
  double zoom_factor;

  tblnav->get_zoom( &zoom_factor);
  if ( zoom_factor < 15)
    return;

  tblnav->zoom( 1.0 / 1.18);
}

void XttTbl::activate_zoom_reset()
{
  tblnav->unzoom();
}

void XttTbl::activate_help()
{
  CoXHelp::dhelp("overview", "", navh_eHelpFile_Base, NULL, 0);
}

void XttTbl::activate_help_project()
{
  CoXHelp::dhelp("index", "", navh_eHelpFile_Project, NULL, 0);
}

void XttTbl::activate_help_proview()
{
  CoXHelp::dhelp( "version", "", navh_eHelpFile_Other, "$pwr_exe/sev_xtt_version_help.dat", 0);
}

void XttTbl::sevhist_help_cb( void *ctx, const char *key)
{
  CoXHelp::dhelp( key, "", navh_eHelpFile_Base, NULL, 0);
}

int XttTbl::sevhist_get_select_cb( void *ctx, pwr_tOid *oid, char *aname, char *oname)
{
  XttTbl *xtttbl = (XttTbl *) ctx;
  ItemBase *item;

  if ( !xtttbl->tblnav->get_select( &item)) {
    xtttbl->message( 'E', "Select an storage item");
    return 0;
  }

  switch ( item->type) {
  case tblnav_eItemType_Local:
  case tblnav_eItemType_TreeLocal: {
    TblNav_sevhistobject *hi = &((ItemLocal *)item)->item;
    if ( hi->attrnum > 1)
      return 0;

    *oid = hi->oid;
    strcpy( aname, hi->objectattrlist[0].aname);
    strcpy( oname, hi->oname);
    break;
  }
  default:
    return 0;
  }
  return 1;
}
