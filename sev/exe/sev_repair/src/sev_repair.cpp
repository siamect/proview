/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#if defined PWRE_CONF_MYSQL

#include <iostream>

#include "co_cdh.h"
#include "co_dcli.h"
#include "co_string.h"

#include "sev_dbms.h"
#include "sev_repair.h"

static void usage()
{
  std::cout
      << "\n\n"
      << "sev_repair   Maintain sev database\n\n"
      << "> sev_repair [-e] [-r] [-c] [-o] [-l] [-t 'tablename'] [-h]\n\n"
      << "-r   Repair database\n"
      << "-e   Alter database engine to engine specified in /etc/proview.cnf,\n"
      << "     eg \"sevMysqlEngine innodb\"\n"
      << "-c   Clean tables\n"
      << "-o   Optimize tables\n"
      << "-l   List tables\n"
      << "-t   Table name when a single table is to be repaired, cleaned or "
         "optimized.\n"
      << "     Default is all tables.\n\n";
}

int sev_repair::init()
{
  sev_dbms_env* env;
  pwr_tFileName envname;
  unsigned int rc;

  sprintf(envname, "$pwrp_db/%s.db", sev_dbms_env::dbName());
  dcli_translate_filename(envname, envname);

  env = new sev_dbms_env(envname);
  env->open(envname);
  if (!env->exists()) {
    printf("** Error: Database environment doesn't exist\n");
    exit(0);
  }

  if (!env->openDb(&rc)) {
    printf("Failed to connect to database '%s'", sev_dbms_env::dbName());
    exit(0);
  }

  m_db = new sev_dbms(env);

  printf("-- Database opened '%s'\n", sev_dbms_env::dbName());

  m_db->get_items(&m_sts);
  m_db->get_objectitems(&m_sts);
  return 1;
}

int sev_repair::check()
{
  pwr_tStatus sts;
  int fail_cnt = 0;

  printf(
      "-- Number of tables to check: %u\n", (unsigned int)m_db->m_items.size());
  for (unsigned int i = 0; i < m_db->m_items.size(); i++) {
    printf("\n-- Processing %u (%u) %s\n", i,
        (unsigned int)m_db->m_items.size(), m_db->m_items[i].tablename);
    m_db->repair_table(&sts, m_db->m_items[i].tablename);
    if (EVEN(sts))
      fail_cnt++;
  }
  if (fail_cnt)
    printf("** Repair failed on %d tables\n", fail_cnt);
  else
    printf("-- Tables successfully repaired\n");
  return 1;
}

int sev_repair::check(char* table)
{
  pwr_tStatus sts;
  int fail_cnt = 0;
  int found = 0;

  for (unsigned int i = 0; i < m_db->m_items.size(); i++) {
    if (str_NoCaseStrcmp(table, m_db->m_items[i].tablename) == 0) {
      printf("\n-- Processing %s\n", m_db->m_items[i].tablename);
      m_db->repair_table(&sts, m_db->m_items[i].tablename);
      if (EVEN(sts))
        fail_cnt++;
      found = 1;
      break;
    }
  }
  if (!found)
    printf("** No such table\n");
  else if (fail_cnt)
    printf("** Repair failed on table\n");
  else
    printf("-- Table successfully repaired\n");
  return 1;
}

int sev_repair::alter_engine()
{
  pwr_tStatus sts;
  int fail_cnt = 0;

  printf(
      "-- Number of tables to alter: %u\n", (unsigned int)m_db->m_items.size());
  for (unsigned int i = 0; i < m_db->m_items.size(); i++) {
    printf("\n-- Processing %u (%u) %s\n", i,
        (unsigned int)m_db->m_items.size(), m_db->m_items[i].tablename);
    m_db->alter_engine(&sts, m_db->m_items[i].tablename);
    if (EVEN(sts))
      fail_cnt++;
  }
  if (fail_cnt)
    printf("** Alter failed on %d tables\n", fail_cnt);
  else
    printf("-- Tables successfully altered\n");
  return 1;
}

int sev_repair::optimize()
{
  pwr_tStatus sts;
  int fail_cnt = 0;

  printf("-- Number of tables to optimize: %u\n",
      (unsigned int)m_db->m_items.size());
  for (unsigned int i = 0; i < m_db->m_items.size(); i++) {
    printf("-- Processing %u (%u) %s\n", i, (unsigned int)m_db->m_items.size(),
        m_db->m_items[i].tablename);
    m_db->optimize(&sts, m_db->m_items[i].tablename);
    if (EVEN(sts))
      fail_cnt++;
  }
  if (fail_cnt)
    printf("** Optimize failed on %d tables\n", fail_cnt);
  else
    printf("-- Tables successfully optimized\n");
  return 1;
}

int sev_repair::optimize(char* table)
{
  pwr_tStatus sts;
  int fail_cnt = 0;
  int found = 0;

  for (unsigned int i = 0; i < m_db->m_items.size(); i++) {
    if (str_NoCaseStrcmp(table, m_db->m_items[i].tablename) == 0) {
      printf("-- Processing %s\n", m_db->m_items[i].tablename);
      m_db->optimize(&sts, m_db->m_items[i].tablename);
      if (EVEN(sts))
        fail_cnt++;
      found = 1;
      break;
    }
  }
  if (!found)
    printf("** No such table\n");
  else if (fail_cnt)
    printf("** Optimize on table\n");
  else
    printf("-- Table successfully optimized\n");
  return 1;
}

void sev_repair::clean()
{
  int i;

  printf(" \n-- Number of tables to clean: %u\n",
      (unsigned int)m_db->m_items.size());
  for (i = 0; i < (int)m_db->m_items.size(); i++) {
    clean_item(i, 1);
  }
}

void sev_repair::clean(char* table)
{
  int found = 0;

  for (unsigned int i = 0; i < m_db->m_items.size(); i++) {
    if (str_NoCaseStrcmp(table, m_db->m_items[i].tablename) == 0) {
      clean_item(i, 0);
      found = 1;
      break;
    }
  }
  if (!found)
    printf("** No such table\n");
  else
    printf("-- Table successfully cleaned\n");
}

void sev_repair::clean_item(int idx, int print_idx)
{
  pwr_tTime currenttime, limit;

  time_GetTime(&currenttime);

  if (m_db->m_items[idx].deleted)
    return;
  if (m_db->m_items[idx].storagetime.tv_sec == 0)
    return;

  time_Asub(&limit, &currenttime, &m_db->m_items[idx].storagetime);

  if (m_db->m_items[idx].attrnum > 1) {
    if (print_idx)
      printf("-- Processing %d (%u) %s\n", idx,
          (unsigned int)m_db->m_items.size(), m_db->m_items[idx].tablename);
    else
      printf("-- Processing %s\n", m_db->m_items[idx].tablename);
    m_db->delete_old_objectdata(&m_sts, 0, m_db->m_items[idx].tablename,
        m_db->m_items[idx].options, limit, m_db->m_items[idx].scantime,
        (float)0xEFFFFFFF);
  } else {
    if (print_idx)
      printf("-- Processing %d (%u) %s\n", idx,
          (unsigned int)m_db->m_items.size(), m_db->m_items[idx].tablename);
    else
      printf("-- Processing %s\n", m_db->m_items[idx].tablename);
    m_db->delete_old_data(&m_sts, 0, m_db->m_items[idx].tablename,
        m_db->m_items[idx].options, limit, m_db->m_items[idx].scantime,
        (float)0xEFFFFFFF);
  }
}

int sev_repair::list()
{
  for (unsigned int i = 0; i < m_db->m_items.size(); i++) {
    printf("-- %-4u %s", i, m_db->m_items[i].tablename);
    for (int j = 0; j < 40 - (int)strlen(m_db->m_items[i].tablename); j++)
      printf(" ");
    printf(" %s\n", m_db->m_items[i].oname);
  }
  printf("-- Number of tables: %u\n", (unsigned int)m_db->m_items.size());
  return 1;
}

int sev_repair::list(char* table)
{
  int found = 0;
  char timstr[40];

  for (unsigned int i = 0; i < m_db->m_items.size(); i++) {
    if (str_NoCaseStrcmp(table, m_db->m_items[i].tablename) == 0) {
      printf("-- %s\n", m_db->m_items[i].tablename);
      printf("    Object:            %s\n", m_db->m_items[i].oname);
      for (int j = 0; j < (int)m_db->m_items[i].attr.size(); j++) {
        printf("    Attribute:         %s ", m_db->m_items[i].attr[j].aname);
        for (int k = 0; k < 19 - (int)strlen(m_db->m_items[i].attr[j].aname);
             k++)
          printf(" ");
        switch (m_db->m_items[i].attr[j].type) {
        case pwr_eType_Boolean:
          printf("Boolean\n");
          break;
        case pwr_eType_Float32:
          printf("Float32\n");
          break;
        case pwr_eType_Float64:
          printf("Float64\n");
          break;
        case pwr_eType_Int64:
          printf("Int64\n");
          break;
        case pwr_eType_Int32:
          printf("Int32\n");
          break;
        case pwr_eType_Int16:
          printf("Int16\n");
          break;
        case pwr_eType_Int8:
          printf("Int8\n");
          break;
        case pwr_eType_UInt64:
          printf("UInt64\n");
          break;
        case pwr_eType_UInt32:
          printf("UInt32\n");
          break;
        case pwr_eType_UInt16:
          printf("UInt16\n");
          break;
        case pwr_eType_UInt8:
          printf("UInt8\n");
          break;
        case pwr_eType_String:
          printf("String\n");
          break;
        default:
          printf("Unknown\n");
        }
      }
      time_AtoAscii(&m_db->m_items[i].creatime, time_eFormat_DateAndTime,
          timstr, sizeof(timstr));
      printf("    Creation time:     %s\n", timstr);
      time_AtoAscii(&m_db->m_items[i].modtime, time_eFormat_DateAndTime, timstr,
          sizeof(timstr));
      printf("    Modification time: %s\n", timstr);
      time_DtoAscii(&m_db->m_items[i].storagetime, time_eFormat_DateAndTime,
          timstr, sizeof(timstr));
      printf("    Storage time:      %s\n", timstr);
      printf("    Scantime:          %f\n", m_db->m_items[i].scantime);
      printf("    Deadband:          %f\n", m_db->m_items[i].deadband);
      printf("    Options:           ");
      if (m_db->m_items[i].options & pwr_mSevOptionsMask_PosixTime)
        printf("PosixTime ");
      if (m_db->m_items[i].options & pwr_mSevOptionsMask_HighTimeResolution)
        printf("HighTimeResoltion ");
      if (m_db->m_items[i].options & pwr_mSevOptionsMask_ReadOptimized)
        printf("ReadOptimized ");
      if (m_db->m_items[i].options & pwr_mSevOptionsMask_UseDeadBand)
        printf("UseDeadBand ");
      if (m_db->m_items[i].options & pwr_mSevOptionsMask_Parameter)
        printf("Parameter ");
      if (m_db->m_items[i].options & pwr_mSevOptionsMask_Event)
        printf("Event ");
      printf("\n");
      found = 1;
      break;
    }
  }
  if (!found)
    printf("** No such table\n");
  return 1;
}

int main(int argc, char* argv[])
{
  sev_repair rep;

  if (argc > 1 && (streq(argv[1], "-e") || streq(argv[1], "--engine"))) {
    // Alter engine
    rep.init();
    rep.alter_engine();
  } else if (argc > 1 && (streq(argv[1], "-r") || streq(argv[1], "--repair"))) {
    // Repair
    if (argc == 2) {
      rep.init();
      rep.check();
    } else if (argc == 4 && streq(argv[2], "-t")) {
      rep.init();
      rep.check(argv[3]);
    } else
      usage();
  } else if (argc > 1 && (streq(argv[1], "-c") || streq(argv[1], "--clean"))) {
    // Clean
    if (argc == 2) {
      rep.init();
      rep.clean();
    } else if (argc == 4 && streq(argv[2], "-t")) {
      rep.init();
      rep.clean(argv[3]);
    } else
      usage();
  } else if (argc > 1
      && (streq(argv[1], "-o") || streq(argv[1], "--optimize"))) {
    // Optimize
    if (argc == 2) {
      rep.init();
      rep.optimize();
    } else if (argc == 4 && streq(argv[2], "-t")) {
      rep.init();
      rep.optimize(argv[3]);
    } else
      usage();
  } else if (argc > 1 && (streq(argv[1], "-l") || streq(argv[1], "--list"))) {
    if (argc == 2) {
      // List
      rep.init();
      rep.list();
    } else if (argc == 4 && streq(argv[2], "-t")) {
      rep.init();
      rep.list(argv[3]);
    } else
      usage();
  } else
    usage();
}
#else
int main()
{
}
#endif
