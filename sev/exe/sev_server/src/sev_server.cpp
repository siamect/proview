/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

#include <math.h>
#include <pthread.h>
#include <float.h>

#include "pwr.h"
#include "co_cdh.h"
#include "co_dcli.h"
#include "co_time.h"
#include "co_error.h"
#include "co_cnf.h"
#include "co_tree.h"
#include "rt_qcom.h"
#include "rt_qcom_msg.h"
#include "rt_ini_event.h"
#include "rt_gdh.h"
#include "sev_server.h"
#include "rt_sev_net.h"
#include "sev_dbms.h"
#include "rt_sev_msg.h"
#include "rt_pwr_msg.h"
#include "rt_errh.h"
#include "pwr_baseclasses.h"

#define sev_cStatInterval 10
#define sev_cGarbageInterval 120
#define sev_cGarbageCycle 86400

static int sev_comp_refid(tree_sTable *tp, tree_sNode *x, tree_sNode *y)
{
  sev_sRefid *xp = (sev_sRefid *) x; 
  sev_sRefid *yp = (sev_sRefid *) y;
  
  if (xp->id.nid > yp->id.nid)
    return 1;

  if (xp->id.nid < yp->id.nid)
    return -1;

  if (xp->id.rix > yp->id.rix)
    return 1;

  if (xp->id.rix < yp->id.rix)
    return -1;

  return 0;
}

int sev_server::init( int noneth)
{
  qcom_sNode		node;
  pwr_tNid		nid;
  pwr_tStatus		sts;
  qcom_sAid		aid;
  qcom_sQid 		qini;
  sev_sDbConfig		db_config;
  char 			str[80];

  m_server_status = PWR__SRVSTARTUP;

  qcom_Init( &m_sts, &aid, "sev_server");
  if ( EVEN(m_sts)) throw co_error(m_sts);

  errh_Init( "sev_server", (errh_eAnix)0);

  m_noneth = noneth;

  if (!m_noneth) {
    // Check server config object
    pwr_tOid conf_oid;

    sts = gdh_Init( "sev_server");
    if ( EVEN(m_sts)) throw co_error(m_sts);

    sts = gdh_GetClassList( pwr_cClass_SevServer, &conf_oid);
    if ( EVEN(sts)) {
      errh_CErrLog( PWR__SRVNOTCONF, 0);
      exit(0);
    }

    pwr_sAttrRef aref = cdh_ObjidToAref( conf_oid);
    sts = gdh_DLRefObjectInfoAttrref( &aref, (void **)&m_config, &m_config_dlid);
    if ( EVEN(sts)) {
      errh_CErrLog( PWR__SRVNOTCONF, 0);
      exit(0);
    }

    memset( m_config->ServerThreads, 0, sizeof(m_config->ServerThreads));
  }
  else {
    // Read config from proview.cnf
    static pwr_sClass_SevServer config;
    float fvalue;

    memset( &config, 0, sizeof(config));
    m_config = &config;
    m_config_dlid = pwr_cNDlid;

    if ( cnf_get_value( "sevDatabaseType", str, sizeof(str))) {
      if ( cdh_NoCaseStrcmp( str, "sqlite") == 0)
	m_config->Database = sev_eDbType_Sqlite;
      else if ( cdh_NoCaseStrcmp( str, "mysql") == 0)
	m_config->Database = sev_eDbType_Mysql;	
      else if ( cdh_NoCaseStrcmp( str, "hdf5") == 0)
	m_config->Database = sev_eDbType_HDF5;	
      else
	m_config->Database = sev_eDbType_Mysql;
    }
    else
      m_config->Database = sev_eDbType_Mysql;

    if ( cnf_get_value( "sevUseServerThreads", str, sizeof(str))) {
      if ( cdh_NoCaseStrcmp( str, "1") == 0)
	m_config->UseServerThreads = 1;
    }
    if ( cnf_get_value( "sevLinearRegrAll", str, sizeof(str))) {
      if ( cdh_NoCaseStrcmp( str, "1") == 0)
	m_config->LinearRegrAll = 1;
    }
    if ( cnf_get_value( "sevMeanValueAll", str, sizeof(str))) {
      if ( cdh_NoCaseStrcmp( str, "1") == 0)
	m_config->MeanValueAll = 1;
    }
    if ( cnf_get_value( "sevMeanValueInterval1", str, sizeof(str))) {
      if ( sscanf( str, "%f", &fvalue) == 1)
	m_config->MeanValueInterval1 = fvalue;
    }
    if ( cnf_get_value( "sevMeanValueInterval2", str, sizeof(str))) {
      if ( sscanf( str, "%f", &fvalue) == 1)
	m_config->MeanValueInterval2 = fvalue;
    }
    if ( cnf_get_value( "sevLinearRegrMaxTime", str, sizeof(str))) {
      if ( sscanf( str, "%f", &fvalue) == 1)
	m_config->LinearRegrMaxTime = fvalue;
    }
  }

  if ( cnf_get_value( "sevThreadKeyNode", str, sizeof(str))) {
    if ( cdh_NoCaseStrcmp( str, "1") == 0)
      m_thread_key_node = 1;
  }
  
  if ( m_config->UseServerThreads)
    m_read_threads = 1;

  switch ( m_config->Database) {
  case pwr_eSevDatabaseEnum_MySQL:
    set_dbtype( sev_eDbType_Mysql);
    break;
  case pwr_eSevDatabaseEnum_SQLite:
    m_config->UseServerThreads = 0;
    m_read_threads = 0;
    set_dbtype( sev_eDbType_Sqlite);
    break;
  case pwr_eSevDatabaseEnum_HDF5:
    m_config->UseServerThreads = 0;
    m_read_threads = 0;
    set_dbtype( sev_eDbType_HDF5);
    break;
  default:
    set_dbtype( sev_eDbType_Mysql);
  }

  memset( &db_config, 0, sizeof(db_config));
  db_config.LinearRegrMaxTime = m_config->LinearRegrMaxTime;
  db_config.LinearRegrAll = m_config->LinearRegrAll;
  db_config.MeanValueAll = m_config->MeanValueAll;
  db_config.MeanValueInterval1 = m_config->MeanValueInterval1;
  db_config.MeanValueInterval2 = m_config->MeanValueInterval2;
  cnf_get_value( "sevMysqlEngine", db_config.Engine, sizeof(db_config.Engine));
  cnf_get_value( "mysqlSocket", db_config.Socket, sizeof(db_config.Socket));
  
  m_db = sev_db::open_database( m_db_type, &db_config);
  if ( !m_db) {
    errh_Fatal( "Database open error");
    exit(0);
  }
  errh_Info("Database opened '%s'", m_db->dbName());

  m_db->get_items( &m_sts);
  m_db->get_objectitems(&m_sts);

  m_refid = tree_CreateTable(&sts, sizeof(pwr_tRefId), offsetof(sev_sRefid, id), sizeof(sev_sRefid), 100, sev_comp_refid);
  sts = thread_MutexInit(&m_refid_mutex);

  // Create a queue to server
  qcom_sQattr attr;
  qcom_sQid qid;

  qid.qix = sev_eProcSevServer;
  qid.nid = 0;
  attr.type = qcom_eQtype_private;
  attr.quota = 200;

  if (!qcom_CreateQ(&sts, &qid, &attr, "SevServer")) {
    if ( sts == QCOM__QALLREXIST) {
      if ( !qcom_AttachQ(&sts, &qid)) {
	if ( !qcom_DeleteQ(&sts, &qid))
	  throw co_error(sts);	     
	if ( !qcom_CreateQ(&sts, &qid, &attr, "SevServer"))
	  throw co_error(sts);
      }      
    }
    else
      throw co_error( sts);
  }

  qini = qcom_cQini;
  if (!qcom_Bind(&sts, &qid, &qini))
    throw co_error(sts);

  // Get all qcom nodes
  qcom_MyNode( &m_sts, &node);
  if ( EVEN(m_sts)) throw co_error(m_sts);

  sev_node myn;
  myn.nid = node.nid;
  strncpy( myn.name, node.name, sizeof(myn.name));
  m_nodes.push_back( myn);

  for (nid = qcom_cNNid; qcom_NextNode(&sts, &node, nid); nid = node.nid) {
    sev_node n;

    n.nid = node.nid;
    strncpy( n.name, node.name, sizeof(n.name));
    m_nodes.push_back( n);
  }

  if ( !m_noneth)
    m_sts = m_db->tree_update();

  if ( m_read_threads)
    create_garbage_collector_thread();

  return 1;
}

int sev_server::connect()
{
  sev_sMsgAny 	*msg;
  qcom_sQid   	tgt;
  qcom_sPut	put;
  pwr_tStatus	sts, lsts;

  // Wait for qmon to start
  sleep(5);

  for ( unsigned int i = 0; i < m_nodes.size(); i++) {
    tgt.nid = m_nodes[i].nid;
    tgt.qix = sev_eProcSevClient;
    

    put.reply.nid = m_nodes[0].nid;
    put.reply.qix = sev_eProcSevServer;
    put.type.b = (qcom_eBtype) sev_cMsgClass;
    put.type.s = (qcom_eStype) sev_eMsgType_NodeUp;
    put.msg_id = m_msg_id++;
    put.size = sizeof(sev_sMsgAny);
    msg  = (sev_sMsgAny *) qcom_Alloc(&lsts, put.size);

    msg->Type = sev_eMsgType_NodeUp;
    msg->Version = sev_cNetVersion;
    put.data = msg;
    put.allocate = 0;

    if ( !qcom_Put( &sts, &tgt, &put)) {
      qcom_Free( &sts, put.data);
      errh_Info( "No connection to %s (%s)", m_nodes[i].name, cdh_NodeIdToString( 0, m_nodes[i].nid, 0, 0));
    }    
    else
      errh_Info( "Connect sent to %s (%s)", m_nodes[i].name, cdh_NodeIdToString( 0, m_nodes[i].nid, 0, 0));
  }

  return 1;
}

int sev_server::request_items( pwr_tNid nid)
{
  sev_sMsgAny 	*msg;
  qcom_sQid   	tgt;
  qcom_sPut	put;
  pwr_tStatus	sts, lsts;
  

  tgt.nid = nid;
  tgt.qix = sev_eProcSevClient;
    
  
  put.reply.nid = m_nodes[0].nid;
  put.reply.qix = sev_eProcSevServer;
  put.type.b = (qcom_eBtype) sev_cMsgClass;
  put.type.s = (qcom_eStype) sev_eMsgType_HistItemsRequest;
  put.msg_id = m_msg_id++;
  put.size = sizeof(*msg);
  msg = (sev_sMsgAny *) qcom_Alloc(&lsts, put.size);

  msg->Type = sev_eMsgType_HistItemsRequest;
  msg->Version = sev_cNetVersion;
  put.data = msg;
  put.allocate = 0;
  
  if ( !qcom_Put( &sts, &tgt, &put)) {
    qcom_Free( &sts, put.data);
  }    

  return 1;
}

int sev_server::send_itemlist( qcom_sQid tgt)
{
  int item_cnt = 0;
  int itemattr_cnt = 0;

  qcom_sPut	put;
  pwr_tStatus	sts, lsts;
  int		size;

  for ( unsigned int i = 0; i < m_db->m_items.size(); i++) {
    if ( m_db->m_items[i].deleted)
      continue;
    item_cnt++;
    itemattr_cnt += m_db->m_items[i].attrnum;
  }

  if ( !item_cnt)
    return 1;

  size = sizeof(sev_sMsgHistItems) + (item_cnt - 1) * sizeof(sev_sHistItem);
  
  size += itemattr_cnt * sizeof(sev_sHistAttr) - item_cnt * sizeof(sev_sHistAttr);

  put.size = size;
  put.data = qcom_Alloc(&lsts, put.size);
  put.allocate = 0;

  ((sev_sMsgHistItems *)put.data)->Type = sev_eMsgType_HistItems;
  ((sev_sMsgHistItems *)put.data)->Version = sev_cNetVersion;

  ((sev_sMsgHistItems *)put.data)->NumItems = item_cnt;
  ((sev_sMsgHistItems *)put.data)->NumAttributes = itemattr_cnt;

  sev_sHistItem *itemPtr = ((sev_sMsgHistItems *)put.data)->Items;
  for ( unsigned int i = 0; i < m_db->m_items.size(); i++) {
    if ( m_db->m_items[i].deleted)
      continue;
    itemPtr->oid = m_db->m_items[i].oid;
    strcpy( itemPtr->oname, m_db->m_items[i].oname);
    itemPtr->storagetime = net_DeltaTimeToNetTime(&m_db->m_items[i].storagetime);
    itemPtr->creatime = net_TimeToNetTime( &m_db->m_items[i].creatime);
    itemPtr->modtime = net_TimeToNetTime( &m_db->m_items[i].modtime);
    strcpy( itemPtr->description, m_db->m_items[i].description);
    itemPtr->attrnum = m_db->m_items[i].attrnum;
    itemPtr->scantime = m_db->m_items[i].scantime;
    itemPtr->deadband = m_db->m_items[i].deadband;
    itemPtr->options = m_db->m_items[i].options;
    size_t j = 0;
    for( j = 0; j < m_db->m_items[i].attr.size(); j++ ) {
      strcpy( itemPtr->attr[j].aname, m_db->m_items[i].attr[j].aname);
      itemPtr->attr[j].type = m_db->m_items[i].attr[j].type;
      itemPtr->attr[j].size = m_db->m_items[i].attr[j].size;
      strcpy( itemPtr->attr[j].unit, m_db->m_items[i].attr[j].unit);
    }
    itemPtr = (sev_sHistItem *)&itemPtr->attr[j];   
  }

  if ( !item_cnt)
    ((sev_sMsgHistItems *)put.data)->Status = SEV__NOITEMS;
  else
    ((sev_sMsgHistItems *)put.data)->Status = SEV__SUCCESS;

  put.reply.nid = m_nodes[0].nid;
  put.reply.qix = sev_eProcSevServer;
  put.type.b = (qcom_eBtype) sev_cMsgClass;
  put.type.s = (qcom_eStype) sev_eMsgType_HistItems;
  put.msg_id = m_msg_id++;

  if ( !qcom_Put( &sts, &tgt, &put)) {
    qcom_Free( &sts, put.data);
    return 0;
  }    
  return 1;
}

int sev_server::send_server_status( qcom_sQid tgt)
{
  qcom_sPut	put;
  pwr_tStatus	sts, lsts;

  put.size = sizeof(sev_sMsgServerStatus);
  put.data = qcom_Alloc(&lsts, put.size);
  put.allocate = 0;

  ((sev_sMsgServerStatus *)put.data)->Type = sev_eMsgType_ServerStatus;
  ((sev_sMsgServerStatus *)put.data)->Version = sev_cNetVersion;


  sts = m_server_status;

  for ( unsigned int i = 0; i < m_db->m_items.size(); i++) {
    if ( m_db->m_items[i].deleted || m_db->m_items[i].status == 0)
      continue;
    if ( errh_Severity( m_db->m_items[i].status) > errh_Severity( sts))
      sts = m_db->m_items[i].status;
  }

  ((sev_sMsgServerStatus *)put.data)->Status = sts;

  put.reply.nid = m_nodes[0].nid;
  put.reply.qix = sev_eProcSevServer;
  put.type.b = (qcom_eBtype) sev_cMsgClass;
  put.type.s = (qcom_eStype) sev_eMsgType_ServerStatus;
  put.msg_id = m_msg_id++;

  if ( !qcom_Put( &sts, &tgt, &put)) {
    qcom_Free( &sts, put.data);
    return 0;
  }    
  return 1;
}

int sev_server::delete_item( qcom_sQid tgt, sev_sMsgHistItemDelete *rmsg)
{
  qcom_sPut	put;
  pwr_tStatus	sts, lsts;

  put.size = sizeof(sev_sMsgHistItemStatus);
  put.data = qcom_Alloc(&lsts, put.size);
  put.allocate = 0;

  m_db->delete_item( &sts, rmsg->Oid, rmsg->AName);

  ((sev_sMsgHistItemStatus *)put.data)->Type = sev_eMsgType_HistItemStatus;
  ((sev_sMsgHistItemStatus *)put.data)->Version = sev_cNetVersion;

  ((sev_sMsgHistItemStatus *)put.data)->Oid = rmsg->Oid;
  strcpy( ((sev_sMsgHistItemStatus *)put.data)->AName, rmsg->AName);
  ((sev_sMsgHistItemStatus *)put.data)->Status = sts;

  put.reply.nid = m_nodes[0].nid;
  put.reply.qix = sev_eProcSevServer;
  put.type.b = (qcom_eBtype) sev_cMsgClass;
  put.type.s = (qcom_eStype) sev_eMsgType_HistItemStatus;
  put.msg_id = m_msg_id++;

  if ( !qcom_Put( &sts, &tgt, &put)) {
    qcom_Free( &sts, put.data);
    return 0;
  }    
  return 1;
}

int sev_server::mainloop()
{
  qcom_sQid qid;
  int tmo = 200;
  qcom_sGet get;
  void *mp;
  pwr_tStatus sts;
  pwr_tTime next_garco, currenttime;
  pwr_tTime next_stat;
  pwr_tDeltaTime stat_interval;
  pwr_tDeltaTime garco_interval;
  pwr_tTime before_get;
  pwr_tDeltaTime busy = pwr_cNDeltaTime;
  pwr_tDeltaTime idle = pwr_cNDeltaTime;
  pwr_tDeltaTime dt;
  float a = exp(-((float)sev_cStatInterval)/300);

  qid.nid = 0;
  qid.qix = sev_eProcSevServer;

  time_FloatToD( &garco_interval, sev_cGarbageInterval);
  time_FloatToD( &stat_interval, sev_cStatInterval);
  time_GetTime( &currenttime);
  time_Aadd( &next_garco, &currenttime, &garco_interval);
  time_Aadd( &next_stat, &currenttime, &stat_interval);

  m_server_status = PWR__SRUN;

  for (;;) {
    memset( &get, 0, sizeof(get));
    time_GetTime( &before_get);
    time_Adiff( &dt, &before_get, &currenttime);
    time_Dadd( &busy, &busy, &dt);

    mp = qcom_Get(&sts, &qid, &get, tmo);

    time_GetTime( &currenttime);
    time_Adiff( &dt, &currenttime, &before_get);
    time_Dadd( &idle, &idle, &dt);

    if ( time_Acomp( &currenttime, &next_stat) == 1) {
      m_stat.current_load = 100.0 * time_DToFloat(0, &busy)/(time_DToFloat(0, &busy)+time_DToFloat(0, &idle));      
      if ( m_stat.medium_load == 0)
	m_stat.medium_load = m_stat.current_load;
      else
	m_stat.medium_load = a * m_stat.medium_load + (1.0-a) * m_stat.current_load;
      m_stat.storage_rate = (float)m_storage_cnt / (time_DToFloat(0, &busy)+time_DToFloat(0, &idle));
      m_stat.write_rate = (float)m_write_cnt / (time_DToFloat(0, &busy)+time_DToFloat(0, &idle));
      if ( m_stat.medium_storage_rate == 0)
	m_stat.medium_storage_rate = m_stat.storage_rate;
      else
	m_stat.medium_storage_rate = a * m_stat.medium_storage_rate + (1.0-a) * m_stat.storage_rate;
      if ( m_stat.medium_write_rate == 0)
	m_stat.medium_write_rate = m_stat.write_rate;
      else
	m_stat.medium_write_rate = a * m_stat.medium_write_rate + (1.0-a) * m_stat.write_rate;
      if ( m_stat.medium_storage_rate < FLT_EPSILON)
	m_stat.write_quota = 0;
      else
	m_stat.write_quota = m_stat.medium_write_rate / m_stat.medium_storage_rate * 100;
      m_storage_cnt = 0;
      m_write_cnt = 0;
      m_db->store_stat( &m_stat); 

      m_config->Stat.CurrentLoad = m_stat.current_load;
      m_config->Stat.MediumLoad = m_stat.medium_load;
      m_config->Stat.StorageRate = m_stat.storage_rate;
      m_config->Stat.MediumStorageRate = m_stat.medium_storage_rate;
      m_config->Stat.WriteRate = m_stat.write_rate;
      m_config->Stat.MediumWriteRate = m_stat.medium_write_rate;
      m_config->Stat.WriteQuota = m_stat.write_quota;

      time_Aadd( &next_stat, &next_stat, &stat_interval);
      busy = pwr_cNDeltaTime;
      idle = pwr_cNDeltaTime;
    }
    if ( m_read_threads && time_Acomp( &currenttime, &next_garco) == 1) {
      garbage_collector( 0);
      time_Aadd( &next_garco, &next_garco, &garco_interval);
    }
    if ( sts == QCOM__TMO || !mp)
      continue;

    switch ((int)get.type.b) {
      case sev_cMsgClass:
        switch ( (int)get.type.s) {
          case sev_eMsgType_NodeUp:
            errh_Info("Node up %s", cdh_NodeIdToString( 0, get.reply.nid, 0, 0));
            request_items( get.reply.nid);
            break;
          case sev_eMsgType_HistItems:
            errh_Info("Itemlist received %s", cdh_NodeIdToString( 0, get.reply.nid, 0, 0));
            check_histitems( (sev_sMsgHistItems *) mp, get.size);
	    m_stat.items_msg_cnt++;
            break;
          case sev_eMsgType_HistDataStore:
            receive_histdata( (sev_sMsgHistDataStore *) mp, get.size, get.sender.nid);
	    m_stat.datastore_msg_cnt++;
            break;
          case sev_eMsgType_HistDataGetRequest:
            send_histdata( get.reply, (sev_sMsgHistDataGetRequest *) mp, get.size);
	    m_stat.dataget_msg_cnt++;
	    // Don't free the message now
            continue;
          case sev_eMsgType_HistItemsRequest:
            send_itemlist( get.reply);
            break;
          case sev_eMsgType_HistItemDelete:
            delete_item( get.reply, (sev_sMsgHistItemDelete *) mp);
            break;
          case sev_eMsgType_ServerStatusRequest:
            send_server_status( get.reply);
            break;
          case sev_eMsgType_HistObjectDataGetRequest:
            send_objecthistdata( get.reply, (sev_sMsgHistDataGetRequest *) mp, get.size);
	    m_stat.dataget_msg_cnt++;
	    // Don't free the message now
            continue;
          case sev_eMsgType_EventsStore:
            receive_events( (sev_sMsgEventsStore *) mp, get.size, get.sender.nid);
	    m_stat.eventstore_msg_cnt++;
            break;
          default: ;
        }
        break;
      case qcom_eBtype_event: {
          ini_mEvent  new_event;
          qcom_sEvent *ep = (qcom_sEvent*) get.data;

          new_event.m  = ep->mask;
          if (new_event.b.terminate) {
	    delete m_db;
            exit(0);
	  }
          break;
        }
      default: ;
    }

    qcom_Free( &sts, mp);

    m_config->Stat.DataStoreMsgCnt = m_stat.datastore_msg_cnt;
    m_config->Stat.DataGetMsgCnt = m_stat.dataget_msg_cnt;
    m_config->Stat.ItemsMsgCnt = m_stat.items_msg_cnt;
    m_config->Stat.EventStoreMsgCnt = m_stat.eventstore_msg_cnt;	
  }
}

int sev_server::check_histitems( sev_sMsgHistItems *msg, unsigned int size)
{
  unsigned int idx;
  pwr_tDeltaTime storagetime;
  int item_cnt = (size - sizeof(sev_sMsgHistItems)) / sizeof(sev_sHistItem) + 1;

  if ( item_cnt <= 0)
    return 0;

  // Remove all refid's for this node
  pwr_tNid nid = msg->Items[0].sevid.nid;
  pwr_tStatus sts;
  sev_sRefid *succ_rp;
  thread_MutexLock(&m_refid_mutex);
  sev_sRefid *rp = (sev_sRefid *)tree_Minimum(&sts, m_refid);
  while ( rp) {
    succ_rp = (sev_sRefid *)tree_Successor(&sts, m_refid, rp);
    if ( rp->id.nid == nid) 
      tree_Remove( &sts, m_refid, &rp->id);
    rp = succ_rp;
  }
  thread_MutexUnlock(&m_refid_mutex);

  for ( int i = 0; i < item_cnt; i++) {
    if ( msg->Items[i].attrnum > 0) {

      // Deadband requires id variable
      if ( msg->Items[i].options & pwr_mSevOptionsMask_UseDeadBand)
	msg->Items[i].options |= pwr_mSevOptionsMask_ReadOptimized;

      // printf( "Received: %s.%s\n", msg->Items[i].oname, msg->Items[i].attr[0].aname);
      storagetime = net_NetTimeToDeltaTime( &msg->Items[i].storagetime);

      if(msg->Items[i].attrnum > 1) {
	//printf( "Received: %s.%s AttrNum:%d\n", msg->Items[i].oname, msg->Items[i].attr[0].aname, msg->Items[i].attrnum);
	sev_sHistItem *buffP = &msg->Items[i];
	while( (char *)buffP < (char *)msg + size) {
	  //for(size_t j = 0; j < buffP->attrnum; j++) {
	  //  printf( "Received: %s.%s\n", buffP->oname, buffP->attr[j].aname);
	  //}
	  char *s;
	  char tablename[400];
	  char tmpStr[400];
	  char attributeName[400];
	  strcpy( tmpStr, buffP->oname);
	  //Point out attribute name
	  s = strchr( tmpStr, '.');
	  if (s) {
	    *s = 0;
	    strcpy( attributeName, s+1);
	  }
	  else
	    attributeName[0] = '\0';

	  storagetime = net_NetTimeToDeltaTime( &buffP->storagetime );
	  sprintf( tablename, "HiaHia"); //Dummy-name, real name created in add_objectitem
	  bool newobject = false;
	  if ( !m_db->check_objectitem( &m_sts, 
					tablename, 
					buffP->oid, 
					buffP->oname, 
					attributeName,
					storagetime, 
					buffP->description, 
					buffP->scantime, 
					buffP->deadband, 
					buffP->options, 
					buffP->attrnum,
					buffP->attr,
					&idx)) {
	    m_db->add_objectitem( &m_sts, 
				  tablename, 
				  buffP->oid, 
				  buffP->oname, 
				  attributeName,
				  storagetime, 
				  buffP->description,
				  buffP->scantime, 
				  buffP->deadband, 
				  buffP->options, 
				  buffP->attrnum,
				  buffP->attr,
				  &idx);
	    if ( EVEN(m_sts)) return m_sts;
	    newobject = true;
	  }

	  vector<sev_attr> oldattrVec = m_db->m_items[idx].attr;
	  vector<sev_attr> newattrVec;
	  m_db->m_items[idx].value_size = 0;
	  //Check if any new attributes is found if so add column
	  bool tableChange = false;
	  for(size_t j = 0; j < buffP->attrnum; j++) {
	    //printf( "Received: %s.%s\n", buffP->oname, buffP->attr[j].aname);
	    sev_attr newattr;
	    strncpy( newattr.aname, buffP->attr[j].aname, sizeof(newattr.aname));
	    newattr.type = buffP->attr[j].type;
	    newattr.size = buffP->attr[j].size;
	    m_db->m_items[idx].value_size += newattr.size;
	    newattr.elem = 0;
	    newattrVec.push_back(newattr);

	    if ( !m_db->check_objectitemattr( &m_sts, 
					      tablename, 
					      buffP->oid, 
					      buffP->attr[j].aname, 
					      buffP->oname,
					      buffP->attr[j].type, 
					      buffP->attr[j].size, 
					      &idx) ) {
	      tableChange = true;
	    }
	  }


	  //Be sure that we have the correct attribute order. Use the list from the client
	  m_db->m_items[idx].attr.clear();
	  m_db->m_items[idx].attr = newattrVec;
	  m_db->m_items[idx].attrnum = newattrVec.size();

	  if(tableChange) {
	    //Either an attribute has changed type or size or we have a new attribute
	    //rename the table to something and create a new one.
	    //this is the only way to do this without hanging the server for several minutes
	    m_db->handle_objectchange(&m_sts, tablename, idx, newobject);
	  }

	  //If node is coming up again we do not want deadband to be active due to init of old_value
	  m_db->m_items[idx].deadband_active = 0;
	  m_db->m_items[idx].first_storage = 1;

	  //TODO Check if some items in oldAttrVec no longer exists if so mark this item
	  //so that databaseadministrator knows which columns he can delete

	  //If something was wrong during checking of attributes we ignore this object
	  if ( ODD(m_sts) ) {
	    //Create space for the old values used if we have deadband active
	    if( m_db->m_items[idx].old_value != 0 ) {
	      free(m_db->m_items[idx].old_value);
	      m_db->m_items[idx].old_value = 0;
	    }
	    m_db->m_items[idx].old_value = malloc(m_db->m_items[idx].value_size);
	    
	    m_db->m_items[idx].sevid = buffP->sevid;

	    pwr_tRefId rk;
	    sev_sRefid *rp;
                  
	    rk = buffP->sevid;
	    thread_MutexLock(&m_refid_mutex);
	    rp = (sev_sRefid *) tree_Insert(&sts, m_refid, &rk);
	    rp->idx = idx;
	    thread_MutexUnlock(&m_refid_mutex);
	  }

	  int numberOfAttributes = buffP->attrnum;
	  //buffP points after the last attribute written
	  if(numberOfAttributes == 0) {
	    printf("Something is very strange at line:%d in file:%s\n", __LINE__, __FUNCTION__);
	    break;
	  }
	  buffP = (sev_sHistItem *)&buffP->attr[numberOfAttributes];
	}
	break;
      }
      if ( !m_db->check_item( &m_sts, msg->Items[i].oid, msg->Items[i].oname, msg->Items[i].attr[0].aname,
			      storagetime, msg->Items[i].attr[0].type, msg->Items[i].attr[0].size, 
			      msg->Items[i].description, msg->Items[i].attr[0].unit, msg->Items[i].scantime, 
			      msg->Items[i].deadband, msg->Items[i].options, &idx)) {
	m_db->add_item( &m_sts, msg->Items[i].oid, msg->Items[i].oname, msg->Items[i].attr[0].aname,
			storagetime, msg->Items[i].attr[0].type, msg->Items[i].attr[0].size, 
			msg->Items[i].description, msg->Items[i].attr[0].unit, msg->Items[i].scantime, 
			msg->Items[i].deadband, msg->Items[i].options, &idx);
	if ( EVEN(m_sts)) return m_sts;
      }
      if ( ODD(m_sts) ) {
	//Create space for the old values used if we have deadband active
	if ( m_db->m_items[idx].old_value != 0 ) {
	  free(m_db->m_items[idx].old_value);
	  m_db->m_items[idx].old_value = 0;
	}
	m_db->m_items[idx].value_size = msg->Items[i].attr[0].size;
	m_db->m_items[idx].old_value = malloc(m_db->m_items[idx].value_size);
	
	//If node is coming up again we do not want deadband to be active due to init of old_value
	m_db->m_items[idx].deadband_active = 0;
	m_db->m_items[idx].first_storage = 1;
	
	m_db->m_items[idx].sevid = msg->Items[i].sevid;
  
	pwr_tRefId rk;
	sev_sRefid *rp;
                    
	rk = msg->Items[i].sevid;
	thread_MutexLock(&m_refid_mutex);
	rp = (sev_sRefid *) tree_Insert(&sts, m_refid, &rk);
	rp->idx = idx;
	thread_MutexUnlock(&m_refid_mutex);
      }
    }
    else {
      // SevHistEvents item

      if ( !m_db->check_item( &m_sts, msg->Items[i].oid, msg->Items[i].oname, (char *)"Events",
			      storagetime, (pwr_eType)0, 0, 
			      msg->Items[i].description, (char *)"", msg->Items[i].scantime, 
			      0, msg->Items[i].options, &idx)) {
	m_db->add_item( &m_sts, msg->Items[i].oid, msg->Items[i].oname, (char *)"Events",
			storagetime, (pwr_eType)0, 0,
			msg->Items[i].description, (char *)"", msg->Items[i].scantime, 
			0, msg->Items[i].options, &idx);
	if ( EVEN(m_sts)) return m_sts;
      }
    }
  }

  if ( !m_noneth) {
    m_sts = m_db->tree_update();
    if ( EVEN(m_sts)) 
      printf( "Tree error %d\n", m_sts);
  }

  return 1;
}

int sev_server::receive_histdata( sev_sMsgHistDataStore *msg, unsigned int size, pwr_tNid nid)
{
  pwr_tStatus sts;
  sev_sHistData *dp;
  pwr_tTime time;
  pwr_tUInt32 server_thread;

  if ( msg->Version == 0) { 
    // Server thread was added in version 1
    dp = (sev_sHistData *) &((sev_sMsgHistDataStoreV0 *)msg)->Data;
    server_thread = 0;
  }
  else {
    dp = (sev_sHistData *) &msg->Data;
    server_thread = msg->ServerThread;
  }

  if ( !m_config->UseServerThreads) {
    m_db->begin_transaction( 0);

    while ( (char *)dp - (char *)msg < (int)size) {
      sev_sRefid *rp;
      pwr_tRefId rk = dp->sevid;

      thread_MutexLock(&m_refid_mutex);
      rp = (sev_sRefid *) tree_Find(&sts, m_refid, &rk);
      thread_MutexUnlock(&m_refid_mutex);

      if ( !rp) {
	dp = (sev_sHistData *)((char *)dp + sizeof( *dp) - sizeof(dp->data) +  dp->size);
	continue;
      }
      unsigned int idx = rp->idx;
      
      time = net_NetTimeToTime( &msg->Time);
      m_db->store_value( &m_sts, 0, idx, 0, time, &dp->data, dp->size);
      m_storage_cnt++;
      m_write_cnt++;
      
      dp = (sev_sHistData *)((char *)dp + sizeof( *dp) - sizeof(dp->data) +  dp->size);
    }

    m_db->commit_transaction( 0);
  }
  else {
    sev_sThread *th;
    sev_sQMsgHistData *qmsg;
    pwr_tUInt32 key;

    if ( m_thread_key_node)
      key = nid;
    else
      key = server_thread;

    th = find_thread( key);
    if ( !th) {
      th = create_thread( key);
      printf( "sev_server, new thread %d\n", key);
    }
    
    // Create a queue message
    if ( (int)(th->alloc + sizeof(*qmsg) - sizeof(qmsg->data) + size) > (int)m_config->ThreadQueueLimit ||
	 (int)(m_total_queue_cnt + sizeof(*qmsg) - sizeof(qmsg->data) + size) > (int)m_config->TotalQueueLimit) {
      // Queue maxlimit exceeded, discard message
      m_config->ServerThreads[th->conf_idx].LostCnt++;
      return 1;
    }

    qmsg = (sev_sQMsgHistData *)malloc( sizeof(*qmsg) - sizeof(qmsg->data) + size);
    memcpy( &qmsg->data, dp, size);
    qmsg->h.type = sev_eQMsgType_HistData;
    qmsg->h.version = msg->Version;
    qmsg->h.size = size;
    qmsg->time = msg->Time;
    lst_Init( NULL, &qmsg->h.e, qmsg);

    th->alloc += qmsg->h.size;
    m_total_queue_cnt += qmsg->h.size;
    m_config->TotalQueueCnt = m_total_queue_cnt;
    if ( th->conf_idx >= 0) {
      m_config->ServerThreads[th->conf_idx].QueueAlloc = th->alloc;
      m_config->ServerThreads[th->conf_idx].DataStoreMsgCnt++;
    }
    que_Put( &sts, &th->queue, &qmsg->h.e, qmsg);
  }
  return 1;
}

int sev_server::send_histdata( qcom_sQid tgt, sev_sMsgHistDataGetRequest *rmsg, unsigned int size)
{
  pthread_t 	thread;
  int sts;

  sev_sHistDataThread *arg = (sev_sHistDataThread *) malloc( sizeof(*arg));
  arg->sev = this;
  arg->tgt = tgt;
  arg->rmsg = rmsg;
  arg->size = size;

  if ( m_read_threads) {
    printf( "New read thread\n");
    sts = pthread_create( &thread, NULL, send_histdata_thread, arg);
    if ( sts != 0)
      printf( "pthread_create error %d\n", sts);
  }
  else {
    send_histdata_thread( arg);
  }
  return 1;
}

void *sev_server::send_histdata_thread( void *arg)
{
  pwr_tTime *tbuf;
  void *vbuf;
  unsigned int rows = 0;
  sev_sMsgHistDataGet 	*msg;
  int msize;
  qcom_sPut	put;
  pwr_tStatus	sts, lsts;
  pwr_tTime	starttime, endtime;
  unsigned int	item_idx;
  void		*thread = 0;

  sev_server *sev = ((sev_sHistDataThread *)arg)->sev;
  qcom_sQid tgt = ((sev_sHistDataThread *)arg)->tgt;
  sev_sMsgHistDataGetRequest *rmsg = ((sev_sHistDataThread *)arg)->rmsg;

  free( arg);

  starttime = net_NetTimeToTime( &rmsg->StartTime);
  endtime = net_NetTimeToTime( &rmsg->EndTime);

  sev->m_db->get_item_idx(&sts, &item_idx, rmsg->Oid, rmsg->AName);
  if ( EVEN(sts)) {
    qcom_Free( &lsts, rmsg);
    return (void *) 1;
  }

  if ( sev->m_read_threads)
    thread = sev->m_db->new_thread();

  sev->m_db->get_values( &sts, thread, rmsg->Oid, sev->m_db->m_items[item_idx].options, 
			 sev->m_db->m_items[item_idx].deadband, 
			 rmsg->AName, sev->m_db->m_items[item_idx].attr[0].type, 
			 sev->m_db->m_items[item_idx].attr[0].size, 
			 sev->m_db->m_items[item_idx].scantime, &sev->m_db->m_items[item_idx].creatime,
			 &starttime, &endtime, rmsg->NumPoints, &tbuf,  &vbuf, &rows);
  if ( ODD(sts) && rows != 0)
    msize = rows * ( sizeof(pwr_tTime) + sev->m_db->m_items[item_idx].attr[0].size) + 
      sizeof(*msg) - sizeof(msg->Data);
  else
    msize = sizeof(*msg);

  put.reply.nid = sev->m_nodes[0].nid;
  put.reply.qix = sev_eProcSevServer;
  put.type.b = (qcom_eBtype) sev_cMsgClass;
  put.type.s = (qcom_eStype) sev_eMsgType_HistDataGet;
  put.msg_id = sev->m_msg_id++;
  put.size = msize;
  msg  = (sev_sMsgHistDataGet *) qcom_Alloc(&lsts, put.size);

  put.data = msg;
  put.allocate = 0;

  msg->Type = sev_eMsgType_HistDataGet;
  msg->Version = sev_cNetVersion;
  msg->Oid = rmsg->Oid;
  strncpy( msg->AName, rmsg->AName, sizeof(msg->AName));
  if ( ODD(sts)) {
    msg->NumPoints = rows;
    msg->VType = sev->m_db->m_items[item_idx].attr[0].type;
    msg->VSize = sev->m_db->m_items[item_idx].attr[0].size;
  }
  qcom_Free( &lsts, rmsg);

  msg->Status = sts;

  if ( ODD(sts) && rows) {
    memcpy( &msg->Data, tbuf, sizeof(pwr_tTime) * rows);
    memcpy( (char *)&msg->Data + sizeof(pwr_tTime) * rows, vbuf, sev->m_db->m_items[item_idx].attr[0].size * rows);
  }
  if ( !qcom_Put( &sts, &tgt, &put)) {
    qcom_Free( &sts, put.data);
  }    
  
  if ( sev->m_read_threads)
    sev->m_db->delete_thread( thread);

  // pthread_exit( (void *) 1);
  return (void *) 1;
}

int sev_server::send_objecthistdata( qcom_sQid tgt, sev_sMsgHistDataGetRequest *rmsg, unsigned int size)
{
  pthread_t 	thread;
  int sts;

  sev_sHistDataThread *arg = (sev_sHistDataThread *) malloc( sizeof(*arg));
  arg->sev = this;
  arg->tgt = tgt;
  arg->rmsg = rmsg;
  arg->size = size;

  if ( m_read_threads) {
    printf( "New read thread\n");
    sts = pthread_create( &thread, NULL, send_objecthistdata_thread, arg);
    if ( sts != 0)
      printf( "pthread_create error %d\n", sts);
  }
  else {
    send_objecthistdata_thread( arg);
  }
  return 1;
}

void *sev_server::send_objecthistdata_thread( void *arg)
{
  pwr_tTime *tbuf;
  void *vbuf;
  unsigned int rows = 0;
  sev_sMsgHistObjectDataGet *msg;
  int msize;
  qcom_sPut	put;
  pwr_tStatus	sts, lsts;
  pwr_tTime	starttime, endtime;
  void		*thread = 0;

  sev_server *sev = ((sev_sHistDataThread *)arg)->sev;
  qcom_sQid tgt = ((sev_sHistDataThread *)arg)->tgt;
  sev_sMsgHistDataGetRequest *rmsg = ((sev_sHistDataThread *)arg)->rmsg;

  free( arg);

  starttime = net_NetTimeToTime( &rmsg->StartTime);
  endtime = net_NetTimeToTime( &rmsg->EndTime);
  sev_item item;

  if ( sev->m_read_threads)
    thread = sev->m_db->new_thread();

  sev->m_db->get_objectitem(&sev->m_sts, thread, &item, rmsg->Oid, rmsg->AName);
  if(ODD(sev->m_sts)) {
    sev->m_db->get_objectvalues(&sev->m_sts, thread, &item, item.value_size, &starttime, &endtime, rmsg->NumPoints, &tbuf,  &vbuf, &rows);
  }
  if ( ODD(sev->m_sts) && rows != 0 ) {
    msize = rows * ( sizeof(pwr_tTime) + item.value_size);
    msize += item.attr.size() * sizeof(msg->Attr);
    msize += sizeof(*msg) - sizeof(msg->Data) - sizeof(msg->Attr);
  } 
  else
    msize = sizeof(*msg);


  put.reply.nid = sev->m_nodes[0].nid;
  put.reply.qix = sev_eProcSevServer;
  put.type.b = (qcom_eBtype) sev_cMsgClass;
  put.type.s = (qcom_eStype) sev_eMsgType_HistObjectDataGet;
  put.msg_id = sev->m_msg_id++;
  put.size = msize;
  msg  = (sev_sMsgHistObjectDataGet *) qcom_Alloc(&lsts, put.size);

  put.data = msg;
  put.allocate = 0;

  msg->Type = sev_eMsgType_HistObjectDataGet;
  msg->Version = sev_cNetVersion;
  msg->Oid = rmsg->Oid;
  strncpy( msg->AName, rmsg->AName, sizeof(msg->AName));
  msg->Status = sev->m_sts;
  msg->NumPoints = 0;
  msg->NumAttributes = 0;
  if ( ODD(sev->m_sts) && rows != 0 ) {
    msg->NumPoints = rows;
    msg->NumAttributes = item.attr.size();
    msg->TotalDataSize = rows * ( sizeof(pwr_tTime) + item.value_size);
    for( size_t i = 0; i < item.attr.size(); i++ ) {
      strncpy( msg->Attr[i].aname, item.attr[i].aname, sizeof(msg->Attr[0].aname));
      msg->Attr[i].elem = 1; //Not used
      msg->Attr[i].size = item.attr[i].size;
      msg->Attr[i].type = item.attr[i].type;
    }
    if( rows ) {
      void *ptr = &msg->Attr[item.attr.size()];
      memcpy( ptr, tbuf, sizeof(pwr_tTime) * rows);
      memcpy( (char *)ptr + sizeof(pwr_tTime) * rows, vbuf, item.value_size * rows);
    }
  }

  qcom_Free( &lsts, rmsg);

  if ( !qcom_Put( &sts, &tgt, &put)) {
    qcom_Free( &sts, put.data);
  }    

  if ( sev->m_read_threads)
    sev->m_db->delete_thread( thread);

  return (void *) 1;
}

int sev_server::receive_events( sev_sMsgEventsStore *msg, unsigned int size, pwr_tNodeId nid)
{
  sev_sEvent *ep;
  pwr_tUInt32 server_thread;

  if ( msg->Version == 0) { 
    // Server thread was added in version 1
    ep = (sev_sEvent *) &((sev_sMsgEventsStoreV0 *)msg)->Events;
    server_thread = 0;
  }
  else {
    ep = (sev_sEvent *)&msg->Events[0];
    server_thread = msg->ServerThread;
  }

  // Get index
  int idx;
  int found = 0;
  for ( unsigned int i = 0; i < m_db->m_items.size(); i++) {
    if ( m_db->m_items[i].deleted)
      continue;
    if ( cdh_ObjidIsEqual( m_db->m_items[i].oid, msg->Oid)) {
      idx = i;
      found = 1;
      break;
    }    
  }
  if ( !found) {
    errh_Error( "Unknown event table, objid (%d,%d)", msg->Oid.vid, msg->Oid.oix);
    return 1;
  }

  if ( !m_config->UseServerThreads) {
    for ( unsigned int i = 0; i < msg->NumEvents; i++) {
      sev_event ev;

      ev.type = ep->type;
      ev.eventprio = ep->eventprio;
      ev.eventid.Nix = ep->eventid_nix;
      ev.eventid.BirthTime.tv_sec = ep->eventid_birthtime;
      ev.eventid.BirthTime.tv_nsec = 0;
      ev.eventid.Idx = ep->eventid_idx;
      ev.time = net_NetTimeToTime( &ep->time);
      strcpy( ev.eventtext, ep->eventtext);
      strcpy( ev.eventname, ep->eventname);
      ev.supobject.Objid.vid = ep->sup_aref_vid;
      ev.supobject.Objid.oix = ep->sup_aref_oix;
      ev.supobject.Offset = ep->sup_aref_offset;
      ev.supobject.Size = ep->sup_aref_size;
      m_db->store_event( &m_sts, 0, idx, &ev);
      ep++;
    }
  }
  else {
    sev_sThread *th;
    sev_sQMsgEvent *qmsg;
    pwr_tUInt32 key;
    int sts;

    if ( m_thread_key_node)
      key = nid;
    else
      key = server_thread;

    th = find_thread( key);
    if ( !th) {
      th = create_thread( key);
      printf( "sev_server, new thread %d\n", key);
    }
    
    // Create a queue message
    if ( (int)(th->alloc + sizeof(*qmsg) - sizeof(qmsg->data) + size) > (int)m_config->ThreadQueueLimit ||
	 (int)(m_total_queue_cnt + sizeof(*qmsg) - sizeof(qmsg->data) + size) > (int)m_config->TotalQueueLimit) {
      // Queue maxlimit exceeded, discard message
      m_config->ServerThreads[th->conf_idx].LostCnt++;
      return 1;
    }

    qmsg = (sev_sQMsgEvent *)malloc( sizeof(*qmsg) - sizeof(qmsg->data) + size);
    memcpy( &qmsg->data, ep, size);
    qmsg->h.type = sev_eQMsgType_Event;
    qmsg->h.version = msg->Version;
    qmsg->h.size = size;
    lst_Init( NULL, &qmsg->h.e, qmsg);
    qmsg->num_events = msg->NumEvents;
    qmsg->item_idx = idx;

    th->alloc += qmsg->h.size;
    m_total_queue_cnt += qmsg->h.size;
    m_config->TotalQueueCnt = m_total_queue_cnt;
    if ( th->conf_idx >= 0) {
      m_config->ServerThreads[th->conf_idx].QueueAlloc = th->alloc;
      m_config->ServerThreads[th->conf_idx].EventStoreMsgCnt++;
    }
    que_Put( &sts, &th->queue, &qmsg->h.e, qmsg);
  }
  return 1;
}

void sev_server::create_garbage_collector_thread()
{
  pthread_t pthread;
  int sts;

  sts = pthread_create( &pthread, NULL, garbage_collector_thread, this);
  if ( sts != 0)
    printf( "sev_server: pthread_create error %d\n", sts);
}

void *sev_server::garbage_collector_thread( void *arg)
{
  void		*thread = 0;
  pwr_tTime next_garco, currenttime;
  pwr_tDeltaTime garco_interval;

  sev_server *sev = (sev_server *)arg;

  thread = sev->m_db->new_thread();

  time_FloatToD( &garco_interval, sev_cGarbageInterval);
  time_GetTime( &currenttime);
  time_Aadd( &next_garco, &currenttime, &garco_interval);

  while ( 1) {
    sleep(1);

    if ( time_Acomp( &currenttime, &next_garco) == 1) {
      sev->garbage_collector( thread);
      time_Aadd( &next_garco, &next_garco, &garco_interval);
    }
  }

  sev->m_db->delete_thread( thread);

  return (void *) 1;
}

void sev_server::garbage_collector( void *thread)
{
  int item_size = m_db->m_items.size();
  static int current = 0;
  float items_per_scan;
  int scan_per_items;
  static int scan_cnt = 0;
  int i;

  if ( item_size == 0)
    return;

  items_per_scan = ((float)sev_cGarbageInterval) * item_size / sev_cGarbageCycle;

  if ( items_per_scan >= 1) {
    for ( i = 0; i < (int)items_per_scan; i++) {
      garbage_item( thread, current);
      current++;
      if ( current >= item_size)
        current = 0;
    }    
  }
  else {
    scan_per_items = (int)( 1.0 / items_per_scan);
    scan_cnt++;
    if ( scan_cnt >= scan_per_items) {
      scan_cnt = 0;

      garbage_item( thread, current);

      current++;
      if ( current >= item_size)
        current = 0;
    }
  }
}

void sev_server::garbage_item( void *thread, int idx)
{
  pwr_tTime currenttime, limit;

  time_GetTime(&currenttime);

  if ( m_db->m_items[idx].deleted)
    return;
  if ( m_db->m_items[idx].storagetime.tv_sec == 0)
    return;

  time_Asub( &limit, &currenttime, &m_db->m_items[idx].storagetime);

  if( m_db->m_items[idx].attrnum > 1 ) {
    m_db->delete_old_objectdata( &m_sts, thread, m_db->m_items[idx].tablename, 
                                 m_db->m_items[idx].options, limit, m_db->m_items[idx].scantime, (float)sev_cGarbageCycle);
  }
  else {
    m_db->delete_old_data( &m_sts, thread, m_db->m_items[idx].tablename, 
         m_db->m_items[idx].options, limit, m_db->m_items[idx].scantime, (float)sev_cGarbageCycle);
  }
}


sev_sThread *sev_server::find_thread( int key)
{
  return m_thread_list[key];
}

void *sev_server::receive_histdata_thread( void *arg)
{
  sev_server *sev = (sev_server *)((sev_sReceiveHistDataThread *)arg)->ctx;
  int tmo_item;
  pwr_tDeltaTime tmo = {1, 0};
  sev_sThread *th = ((sev_sReceiveHistDataThread *)arg)->th;
  pwr_tStatus sts;
  pwr_tTime time;
  pwr_tTime currenttime;
  pwr_tTime next_stat;
  sev_sQMsgHeader *qmsg;
  pwr_tDeltaTime stat_interval = {0,500000000};
  pwr_tTime before_get;
  pwr_tDeltaTime busy = pwr_cNDeltaTime;
  pwr_tDeltaTime idle = pwr_cNDeltaTime;
  pwr_tDeltaTime dt;
  float a = exp(-((float)sev_cStatInterval)/300);
  pwr_sClass_SevServerThread *thread_conf = 0;
  float current_load;
  int storage_cnt = 0;
  int write_cnt = 0;

  if ( th->conf_idx >= 0)
    thread_conf = &sev->m_config->ServerThreads[th->conf_idx];

  free( arg);

  printf( "New thread %d\n", th->key);

  time_GetTime( &currenttime);
  time_Aadd( &next_stat, &currenttime, &stat_interval);

  while ( 1) {

    time_GetTime( &before_get);
    time_Adiff( &dt, &before_get, &currenttime);
    time_Dadd( &busy, &busy, &dt);

    qmsg = (sev_sQMsgHeader *)que_Get( NULL, &th->queue, &tmo, &tmo_item);

    if ( (int *)qmsg == &tmo_item) {
      // printf( "Tmo %d\n", th->key);
    }
    else {

      th->alloc -= qmsg->size;
      //if ( th->alloc < 0)
      //  th->alloc = 0;
      sev->m_total_queue_cnt -= qmsg->size;
      sev->m_config->TotalQueueCnt = sev->m_total_queue_cnt;

      time_GetTime( &currenttime);
      time_Adiff( &dt, &currenttime, &before_get);
      time_Dadd( &idle, &idle, &dt);

      if ( th->conf_idx >= 0 && time_Acomp( &currenttime, &next_stat) == 1) {

	thread_conf->QueueAlloc = th->alloc;
	current_load = 100.0 * time_DToFloat(0, &busy)/(time_DToFloat(0, &busy)+time_DToFloat(0, &idle));      
	if ( thread_conf->MediumLoad == 0)
	  thread_conf->MediumLoad = current_load;
	else
	  thread_conf->MediumLoad = a * thread_conf->MediumLoad + (1.0-a) * current_load;
	thread_conf->StorageRate = (float)storage_cnt / (time_DToFloat(0, &busy)+time_DToFloat(0, &idle));
	if ( thread_conf->MediumStorageRate == 0)
	  thread_conf->MediumStorageRate = thread_conf->StorageRate;
	else
	  thread_conf->MediumStorageRate = a * thread_conf->MediumStorageRate + (1.0-a) * thread_conf->StorageRate;
	thread_conf->WriteRate = (float)write_cnt / (time_DToFloat(0, &busy)+time_DToFloat(0, &idle));
	if ( thread_conf->MediumWriteRate == 0)
	  thread_conf->MediumWriteRate = thread_conf->WriteRate;
	else
	  thread_conf->MediumWriteRate = a * thread_conf->MediumWriteRate + (1.0-a) * thread_conf->WriteRate;
	if ( thread_conf->MediumStorageRate < FLT_EPSILON)
	  thread_conf->WriteQuota = 0;
	else
	  thread_conf->WriteQuota = thread_conf->MediumWriteRate / thread_conf->MediumStorageRate * 100;
	storage_cnt = 0;
	write_cnt = 0;
	
	time_Aadd( &next_stat, &next_stat, &stat_interval);
	busy = pwr_cNDeltaTime;
	idle = pwr_cNDeltaTime;
      }

      switch ( qmsg->type) {
      case sev_eQMsgType_HistData: {
	sev_sHistData *dp;
	sev_sQMsgHistData *msg = (sev_sQMsgHistData *)qmsg;
	
	dp = (sev_sHistData *) &msg->data;

	sev->m_db->begin_transaction( th->db_ctx);
    
	while ( (char *)dp - (char *)msg < (int)msg->h.size) {
	  sev_sRefid *rp;
	  pwr_tRefId rk = dp->sevid;
 
	  thread_MutexLock(&sev->m_refid_mutex);
	  rp = (sev_sRefid *) tree_Find(&sts, sev->m_refid, &rk);
	  thread_MutexUnlock(&sev->m_refid_mutex);
	  if ( !rp) {
	    dp = (sev_sHistData *)((char *)dp + sizeof( *dp) - sizeof(dp->data) +  dp->size);
	    continue;
	  }
	  unsigned int idx = rp->idx;
      
	  time = net_NetTimeToTime( &msg->time);
	  sev->m_db->store_value( &sev->m_sts, th->db_ctx, idx, 0, time, &dp->data, dp->size);
	  sev->m_storage_cnt++;
	  storage_cnt++;
	  if ( ODD(sev->m_sts) && sev->m_sts != SEV__NOWRITE) {
	    sev->m_write_cnt++;
	    write_cnt++;
	  }
      
	  dp = (sev_sHistData *)((char *)dp + sizeof( *dp) - sizeof(dp->data) +  dp->size);
	}
    
	sev->m_db->commit_transaction( th->db_ctx);
      
	break;
      }
      case sev_eQMsgType_Event: {
	sev_sEvent *ep;
	sev_sQMsgEvent *msg = (sev_sQMsgEvent *)qmsg;

	ep = (sev_sEvent *) &msg->data;

	if ( msg->h.version > 0) {
	  for ( int i = 0; i < msg->num_events; i++) {
	    sev_event ev;

	    ev.type = ep->type;
	    ev.eventprio = ep->eventprio;
	    ev.eventid.Nix = ep->eventid_nix;
	    ev.eventid.BirthTime.tv_sec = ep->eventid_birthtime;
	    ev.eventid.BirthTime.tv_nsec = 0;
	    ev.eventid.Idx = ep->eventid_idx;
	    ev.time = net_NetTimeToTime( &ep->time);
	    strcpy( ev.eventtext, ep->eventtext);
	    strcpy( ev.eventname, ep->eventname);
	    ev.supobject.Objid.vid = ep->sup_aref_vid;
	    ev.supobject.Objid.oix = ep->sup_aref_oix;
	    ev.supobject.Offset = ep->sup_aref_offset;
	    ev.supobject.Size = ep->sup_aref_size;
	    sev->m_db->store_event( &sev->m_sts, th->db_ctx, msg->item_idx, &ev);	  
	    ep++;
	  }
	}
	else {
	  // Supobject was added in version 1
	  sev_sEventV0 *epV0 = (sev_sEventV0 *)ep;
	  for ( int i = 0; i < msg->num_events; i++) {
	    sev_event ev;

	    ev.type = epV0->type;
	    ev.eventprio = epV0->eventprio;
	    ev.eventid.Nix = epV0->eventid_nix;
	    ev.eventid.BirthTime.tv_sec = epV0->eventid_birthtime;
	    ev.eventid.BirthTime.tv_nsec = 0;
	    ev.eventid.Idx = ep->eventid_idx;
	    ev.time = net_NetTimeToTime( &epV0->time);
	    strcpy( ev.eventtext, epV0->eventtext);
	    strcpy( ev.eventname, epV0->eventname);
	    ev.supobject.Objid.vid = 0;
	    ev.supobject.Objid.oix = 0;
	    ev.supobject.Offset = 0;
	    ev.supobject.Size = 0;
	    sev->m_db->store_event( &sev->m_sts, th->db_ctx, msg->item_idx, &ev);	  
	    epV0++;
	  }
	}
	break;
      }
      }    

      if ( th->conf_idx >= 0)
	thread_conf->QueueAlloc = th->alloc;

      free( qmsg);   
    }
  }
    
  return (void *)1;
}

sev_sThread *sev_server::create_thread( int key)
{
  int sts;

  sev_sThread *th = (sev_sThread *)calloc( 1, sizeof(sev_sThread));
  th->key = key;
  que_Create( NULL, &th->queue);
  th->db_ctx = m_db->new_thread();
  if ( m_thread_cnt < sizeof(m_config->ServerThreads)/sizeof(m_config->ServerThreads[0]))
    th->conf_idx = m_thread_cnt;
  else
    th->conf_idx = -1;
  m_thread_cnt++;

  m_thread_list[key] = th;

  sev_sReceiveHistDataThread *arg = (sev_sReceiveHistDataThread *)malloc( sizeof(*arg));
  arg->ctx = this;
  arg->th = th;  

  sts = pthread_create( &th->thread, NULL, receive_histdata_thread, arg);
  if ( sts != 0)
    printf( "sev_server: pthread_create error %d\n", sts);

  if ( th->conf_idx >= 0) {
    m_config->ServerThreads[th->conf_idx].Occupied = 1;
    m_config->ServerThreads[th->conf_idx].Key = key;
  }

  return th;
}

void sev_server::delete_thread( int key)
{
  sev_sThread *th;

  th = m_thread_list[key];
  if ( !th)
    return;

  free( th);
  m_thread_list.erase(key);
}


sev_server::~sev_server()
{
  for ( threadlist_iterator it = m_thread_list.begin(); it != m_thread_list.end();) {
    sev_sThread *th = it->second;
    m_thread_list.erase( it++);
    m_db->delete_thread( th->db_ctx);
    free( th);
  }
}

int main (int argc, char *argv[])
{
  sev_server srv;
  int noneth = 0;

  if ( argc > 1 && strcmp( argv[1], "-n") == 0)
    noneth = 1;

  srv.init( noneth);
  srv.connect();
  srv.mainloop();
}
