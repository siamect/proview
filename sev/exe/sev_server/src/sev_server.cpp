/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <math.h>
#include <pthread.h>
#include <unistd.h>

#include "co_cdh.h"
#include "co_cnf.h"
#include "co_dcli.h"
#include "co_error.h"
#include "co_string.h"
#include "co_tree.h"

#include "rt_gdh.h"
#include "rt_ini_event.h"
#include "rt_pwr_msg.h"
#include "rt_qcom_msg.h"

#include "sev_dbms.h"
#include "sev_server.h"

#define sev_cStatInterval 10
#define sev_cGarbageInterval 120
#define sev_cGarbageCycle 86400

static int sev_comp_refid(tree_sTable* tp, tree_sNode* x, tree_sNode* y)
{
  sev_sRefid* xp = (sev_sRefid*)x;
  sev_sRefid* yp = (sev_sRefid*)y;

  if (xp->id.nid > yp->id.nid)
    return 1;

  if (xp->id.nid < yp->id.nid)
    return -1;

  if (xp->id.rix > yp->id.rix)
    return 1;

  if (xp->id.rix < yp->id.rix)
    return -1;

  return 0;
}

int sev_server::init(int noneth)
{
  qcom_sNode node;
  pwr_tNid nid;
  pwr_tStatus sts;
  qcom_sAid aid;
  qcom_sQid qini;
  sev_sDbConfig db_config;
  char str[80];

  m_server_status = PWR__SRVSTARTUP;

  qcom_Init(&m_sts, &aid, "sev_server");
  if (EVEN(m_sts))
    throw co_error(m_sts);

  errh_Init("sev_server", (errh_eAnix)0);

  m_noneth = noneth;

  if (!m_noneth) {
    // Check server config object
    pwr_tOid conf_oid;
    pwr_sNode *np;
    pwr_tOid node_oid;

    m_sts = gdh_Init("sev_server");
    if (EVEN(m_sts))
      throw co_error(m_sts);

    sts = gdh_GetClassList(pwr_cClass_SevServer, &conf_oid);
    if (EVEN(sts)) {
      errh_CErrLog(PWR__SRVNOTCONF, 0);
      exit(0);
    }

    pwr_sAttrRef aref = cdh_ObjidToAref(conf_oid);
    sts = gdh_DLRefObjectInfoAttrref(&aref, (void**)&m_config, &m_config_dlid);
    if (EVEN(sts)) {
      errh_CErrLog(PWR__SRVNOTCONF, 0);
      exit(0);
    }

    memset(m_config->ServerThreads, 0, sizeof(m_config->ServerThreads));
    if (!m_config->GarbageInterval)
      m_config->GarbageInterval = sev_cGarbageInterval;

    sts = gdh_GetNodeObject(0, &node_oid);
    if (EVEN(sts)) {
      errh_CErrLog(PWR__SRVNOTCONF, 0);
      exit(0);
    }
    sts = gdh_ObjidToPointer(node_oid, (void **)&np);
    if (EVEN(sts)) {
      errh_CErrLog(PWR__SRVNOTCONF, 0);
      exit(0);
    }
    sev_db::set_orignode(np->OrigName);

  } else {
    // Read config from proview.cnf
    static pwr_sClass_SevServer config;
    float fvalue;

    memset(&config, 0, sizeof(config));
    m_config = &config;
    m_config_dlid = pwr_cNDlid;
    m_config->GarbageInterval = sev_cGarbageInterval;

    if (cnf_get_value("sevDatabaseType", str, sizeof(str))) {
      if (str_NoCaseStrcmp(str, "sqlite") == 0)
        m_config->Database = pwr_eSevDatabaseEnum_SQLite;
      else if (str_NoCaseStrcmp(str, "mysql") == 0)
        m_config->Database = pwr_eSevDatabaseEnum_MySQL;
      else if (str_NoCaseStrcmp(str, "hdf5") == 0)
        m_config->Database = pwr_eSevDatabaseEnum_HDF5;
      else
        m_config->Database = pwr_eSevDatabaseEnum_MySQL;
    } else
      m_config->Database = pwr_eSevDatabaseEnum_MySQL;

    if (cnf_get_value("sevUseServerThreads", str, sizeof(str))) {
      if (str_NoCaseStrcmp(str, "1") == 0)
        m_config->UseServerThreads = 1;
    }
    if (cnf_get_value("sevLinearRegrAll", str, sizeof(str))) {
      if (str_NoCaseStrcmp(str, "1") == 0)
        m_config->LinearRegrAll = 1;
    }
    if (cnf_get_value("sevMeanValueAll", str, sizeof(str))) {
      if (str_NoCaseStrcmp(str, "1") == 0)
        m_config->MeanValueAll = 1;
    }
    if (cnf_get_value("sevMeanValueInterval1", str, sizeof(str))) {
      if (sscanf(str, "%f", &fvalue) == 1)
        m_config->MeanValueInterval1 = fvalue;
    }
    if (cnf_get_value("sevMeanValueInterval2", str, sizeof(str))) {
      if (sscanf(str, "%f", &fvalue) == 1)
        m_config->MeanValueInterval2 = fvalue;
    }
    if (cnf_get_value("sevLinearRegrMaxTime", str, sizeof(str))) {
      if (sscanf(str, "%f", &fvalue) == 1)
        m_config->LinearRegrMaxTime = fvalue;
    }
  }

  if (cnf_get_value("sevThreadKeyNode", str, sizeof(str))) {
    if (str_NoCaseStrcmp(str, "1") == 0)
      m_thread_key_node = 1;
  }

  if (m_config->UseServerThreads)
    m_read_threads = 1;

  switch (m_config->Database) {
  case pwr_eSevDatabaseEnum_MySQL:
    set_dbtype(sev_eDbType_Mysql);
    break;
  case pwr_eSevDatabaseEnum_SQLite:
    m_config->UseServerThreads = 0;
    m_read_threads = 0;
    set_dbtype(sev_eDbType_Sqlite);
    break;
  case pwr_eSevDatabaseEnum_HDF5:
    m_config->UseServerThreads = 0;
    m_read_threads = 0;
    set_dbtype(sev_eDbType_HDF5);
    break;
  default:
    set_dbtype(sev_eDbType_Mysql);
  }

  memset(&db_config, 0, sizeof(db_config));
  db_config.LinearRegrMaxTime = m_config->LinearRegrMaxTime;
  db_config.LinearRegrAll = m_config->LinearRegrAll;
  db_config.MeanValueAll = m_config->MeanValueAll;
  db_config.MeanValueInterval1 = m_config->MeanValueInterval1;
  db_config.MeanValueInterval2 = m_config->MeanValueInterval2;
  cnf_get_value("sevMysqlEngine", db_config.Engine, sizeof(db_config.Engine));
  cnf_get_value("mysqlSocket", db_config.Socket, sizeof(db_config.Socket));

  m_db = sev_db::open_database(m_db_type, &db_config);
  if (!m_db) {
    errh_Fatal("Database open error");
    exit(0);
  }
  errh_Info("Database opened '%s'", m_db->dbName());

  m_db->get_items(&m_sts);
  m_db->get_objectitems(&m_sts);

  m_refid = tree_CreateTable(&sts, sizeof(pwr_tRefId), offsetof(sev_sRefid, id),
      sizeof(sev_sRefid), 100, sev_comp_refid);
  sts = thread_MutexInit(&m_refid_mutex);

  sts = thread_MutexInit(&m_alloc_mutex);

  // Create a queue to server
  qcom_sQattr attr;
  qcom_sQid qid;

  qid.qix = sev_eProcSevServer;
  qid.nid = 0;
  attr.type = qcom_eQtype_private;
  attr.quota = 200;

  if (!qcom_CreateQ(&sts, &qid, &attr, "SevServer")) {
    if (sts == QCOM__QALLREXIST) {
      if (!qcom_AttachQ(&sts, &qid)) {
        if (!qcom_DeleteQ(&sts, &qid))
          throw co_error(sts);
        if (!qcom_CreateQ(&sts, &qid, &attr, "SevServer"))
          throw co_error(sts);
      }
    } else
      throw co_error(sts);
  }

  qini = qcom_cQini;
  if (!qcom_Bind(&sts, &qid, &qini))
    throw co_error(sts);

  // Get all qcom nodes
  qcom_MyNode(&m_sts, &node);
  if (EVEN(m_sts))
    throw co_error(m_sts);

  sev_node myn;
  myn.nid = node.nid;
  strncpy(myn.name, node.name, sizeof(myn.name));
  m_nodes.push_back(myn);

  for (nid = qcom_cNNid; qcom_NextNode(&sts, &node, nid); nid = node.nid) {
    sev_node n;

    n.nid = node.nid;
    strncpy(n.name, node.name, sizeof(n.name));
    m_nodes.push_back(n);
  }

  if (!m_noneth) {
    m_sts = m_db->tree_update();
    m_sts = gdh_MountDynClients();
  }

  if (m_read_threads)
    create_garbage_collector_thread();

  return 1;
}

int sev_server::connect()
{
  sev_sMsgAny* msg;
  qcom_sQid tgt;
  qcom_sPut put;
  pwr_tStatus sts, lsts;

  // Wait for qmon to start
  sleep(5);

  for (unsigned int i = 0; i < m_nodes.size(); i++) {
    tgt.nid = m_nodes[i].nid;
    tgt.qix = sev_eProcSevClient;

    put.reply.nid = m_nodes[0].nid;
    put.reply.qix = sev_eProcSevServer;
    put.type.b = (qcom_eBtype)sev_cMsgClass;
    put.type.s = (qcom_eStype)sev_eMsgType_NodeUp;
    put.msg_id = m_msg_id++;
    put.size = sizeof(sev_sMsgAny);
    msg = (sev_sMsgAny*)qcom_Alloc(&lsts, put.size);

    msg->Type = sev_eMsgType_NodeUp;
    msg->Version = sev_cNetVersion;
    put.data = msg;
    put.allocate = 0;

    if (!qcom_Put(&sts, &tgt, &put)) {
      qcom_Free(&sts, put.data);
      errh_Info("No connection to %s (%s)", m_nodes[i].name,
          cdh_NodeIdToString(0, m_nodes[i].nid, 0, 0));
    } else
      errh_Info("Connect sent to %s (%s)", m_nodes[i].name,
          cdh_NodeIdToString(0, m_nodes[i].nid, 0, 0));
  }

  return 1;
}

int sev_server::request_items(pwr_tNid nid)
{
  sev_sMsgAny* msg;
  qcom_sQid tgt;
  qcom_sPut put;
  pwr_tStatus sts, lsts;

  tgt.nid = nid;
  tgt.qix = sev_eProcSevClient;

  put.reply.nid = m_nodes[0].nid;
  put.reply.qix = sev_eProcSevServer;
  put.type.b = (qcom_eBtype)sev_cMsgClass;
  put.type.s = (qcom_eStype)sev_eMsgType_HistItemsRequest;
  put.msg_id = m_msg_id++;
  put.size = sizeof(*msg);
  msg = (sev_sMsgAny*)qcom_Alloc(&lsts, put.size);

  msg->Type = sev_eMsgType_HistItemsRequest;
  msg->Version = sev_cNetVersion;
  put.data = msg;
  put.allocate = 0;

  if (!qcom_Put(&sts, &tgt, &put)) {
    qcom_Free(&sts, put.data);
  }

  return 1;
}

int sev_server::send_itemlist(qcom_sQid tgt)
{
  int item_cnt = 0;
  int itemattr_cnt = 0;

  qcom_sPut put;
  pwr_tStatus sts, lsts;
  int size;

  for (unsigned int i = 0; i < m_db->m_items.size(); i++) {
    if (m_db->m_items[i].deleted)
      continue;
    item_cnt++;
    itemattr_cnt += m_db->m_items[i].attrnum;
  }

  if (!item_cnt)
    return 1;

  size = sizeof(sev_sMsgHistItems) + (item_cnt - 1) * sizeof(sev_sHistItem);

  size += itemattr_cnt * sizeof(sev_sHistAttr)
      - item_cnt * sizeof(sev_sHistAttr);

  put.size = size;
  put.data = qcom_Alloc(&lsts, put.size);
  put.allocate = 0;

  ((sev_sMsgHistItems*)put.data)->Type = sev_eMsgType_HistItems;
  ((sev_sMsgHistItems*)put.data)->Version = sev_cNetVersion;

  ((sev_sMsgHistItems*)put.data)->NumItems = item_cnt;
  ((sev_sMsgHistItems*)put.data)->NumAttributes = itemattr_cnt;

  sev_sHistItem* itemPtr = ((sev_sMsgHistItems*)put.data)->Items;
  for (unsigned int i = 0; i < m_db->m_items.size(); i++) {
    if (m_db->m_items[i].deleted)
      continue;
    itemPtr->oid = m_db->m_items[i].oid;
    strcpy(itemPtr->oname, m_db->m_items[i].oname);
    itemPtr->storagetime
        = net_DeltaTimeToNetTime(&m_db->m_items[i].storagetime);
    itemPtr->creatime = net_TimeToNetTime(&m_db->m_items[i].creatime);
    itemPtr->modtime = net_TimeToNetTime(&m_db->m_items[i].modtime);
    strcpy(itemPtr->description, m_db->m_items[i].description);
    itemPtr->attrnum = m_db->m_items[i].attrnum;
    itemPtr->scantime = m_db->m_items[i].scantime;
    itemPtr->deadband = m_db->m_items[i].deadband;
    itemPtr->options = m_db->m_items[i].options;
    size_t j = 0;
    for (j = 0; j < m_db->m_items[i].attr.size(); j++) {
      strcpy(itemPtr->attr[j].aname, m_db->m_items[i].attr[j].aname);
      itemPtr->attr[j].type = m_db->m_items[i].attr[j].type;
      itemPtr->attr[j].size = m_db->m_items[i].attr[j].size;
      strcpy(itemPtr->attr[j].unit, m_db->m_items[i].attr[j].unit);
    }
    itemPtr = (sev_sHistItem*)&itemPtr->attr[j];
  }

  if (!item_cnt)
    ((sev_sMsgHistItems*)put.data)->Status = SEV__NOITEMS;
  else
    ((sev_sMsgHistItems*)put.data)->Status = SEV__SUCCESS;

  put.reply.nid = m_nodes[0].nid;
  put.reply.qix = sev_eProcSevServer;
  put.type.b = (qcom_eBtype)sev_cMsgClass;
  put.type.s = (qcom_eStype)sev_eMsgType_HistItems;
  put.msg_id = m_msg_id++;

  if (!qcom_Put(&sts, &tgt, &put)) {
    qcom_Free(&sts, put.data);
    return 0;
  }
  return 1;
}

int sev_server::send_eventsitemlist(qcom_sQid tgt)
{
  int item_cnt = 0;

  qcom_sPut put;
  pwr_tStatus sts, lsts;
  int size;

  for (unsigned int i = 0; i < m_db->m_items.size(); i++) {
    if (!m_db->m_items[i].deleted &&
	strcmp(m_db->m_items[i].attr[0].aname, "Events") == 0 && 
	m_db->m_items[i].attr[0].size == 0)
    item_cnt++;
  }

  if (!item_cnt)
    return 1;

  size = sizeof(sev_sMsgEventsItems) + (item_cnt - 1) * sizeof(sev_sEventsItem);

  put.size = size;
  put.data = qcom_Alloc(&lsts, put.size);
  put.allocate = 0;

  ((sev_sMsgEventsItems*)put.data)->Type = sev_eMsgType_EventsItems;
  ((sev_sMsgEventsItems*)put.data)->Version = sev_cNetVersion;

  ((sev_sMsgEventsItems*)put.data)->NumItems = item_cnt;

  sev_sEventsItem* itemPtr = ((sev_sMsgEventsItems*)put.data)->Items;
  for (unsigned int i = 0; i < m_db->m_items.size(); i++) {
    if (!(!m_db->m_items[i].deleted &&
	  strcmp(m_db->m_items[i].attr[0].aname, "Events") == 0 && 
	  m_db->m_items[i].attr[0].size == 0))
      continue;
    itemPtr->oid = m_db->m_items[i].oid;
    strcpy(itemPtr->oname, m_db->m_items[i].oname);
    itemPtr->storagetime
        = net_DeltaTimeToNetTime(&m_db->m_items[i].storagetime);
    itemPtr->creatime = net_TimeToNetTime(&m_db->m_items[i].creatime);
    strcpy(itemPtr->description, m_db->m_items[i].description);
    itemPtr->options = m_db->m_items[i].options;
    itemPtr++;
  }

  if (!item_cnt)
    ((sev_sMsgHistItems*)put.data)->Status = SEV__NOITEMS;
  else
    ((sev_sMsgHistItems*)put.data)->Status = SEV__SUCCESS;

  put.reply.nid = m_nodes[0].nid;
  put.reply.qix = sev_eProcSevServer;
  put.type.b = (qcom_eBtype)sev_cMsgClass;
  put.type.s = (qcom_eStype)sev_eMsgType_EventsItems;
  put.msg_id = m_msg_id++;

  if (!qcom_Put(&sts, &tgt, &put)) {
    qcom_Free(&sts, put.data);
    return 0;
  }
  return 1;
}

int sev_server::send_server_status(qcom_sQid tgt)
{
  qcom_sPut put;
  pwr_tStatus sts, lsts;

  put.size = sizeof(sev_sMsgServerStatus);
  put.data = qcom_Alloc(&lsts, put.size);
  put.allocate = 0;

  ((sev_sMsgServerStatus*)put.data)->Type = sev_eMsgType_ServerStatus;
  ((sev_sMsgServerStatus*)put.data)->Version = sev_cNetVersion;

  sts = m_server_status;

  for (unsigned int i = 0; i < m_db->m_items.size(); i++) {
    if (m_db->m_items[i].deleted || m_db->m_items[i].status == 0)
      continue;
    if (errh_Severity(m_db->m_items[i].status) > errh_Severity(sts))
      sts = m_db->m_items[i].status;
  }

  ((sev_sMsgServerStatus*)put.data)->Status = sts;

  put.reply.nid = m_nodes[0].nid;
  put.reply.qix = sev_eProcSevServer;
  put.type.b = (qcom_eBtype)sev_cMsgClass;
  put.type.s = (qcom_eStype)sev_eMsgType_ServerStatus;
  put.msg_id = m_msg_id++;

  if (!qcom_Put(&sts, &tgt, &put)) {
    qcom_Free(&sts, put.data);
    return 0;
  }
  return 1;
}

int sev_server::delete_item(qcom_sQid tgt, sev_sMsgHistItemDelete* rmsg)
{
  qcom_sPut put;
  pwr_tStatus sts, lsts;

  put.size = sizeof(sev_sMsgHistItemStatus);
  put.data = qcom_Alloc(&lsts, put.size);
  put.allocate = 0;

  m_db->delete_item(&sts, rmsg->Oid, rmsg->AName);

  ((sev_sMsgHistItemStatus*)put.data)->Type = sev_eMsgType_HistItemStatus;
  ((sev_sMsgHistItemStatus*)put.data)->Version = sev_cNetVersion;

  ((sev_sMsgHistItemStatus*)put.data)->Oid = rmsg->Oid;
  strcpy(((sev_sMsgHistItemStatus*)put.data)->AName, rmsg->AName);
  ((sev_sMsgHistItemStatus*)put.data)->Status = sts;

  put.reply.nid = m_nodes[0].nid;
  put.reply.qix = sev_eProcSevServer;
  put.type.b = (qcom_eBtype)sev_cMsgClass;
  put.type.s = (qcom_eStype)sev_eMsgType_HistItemStatus;
  put.msg_id = m_msg_id++;

  if (!qcom_Put(&sts, &tgt, &put)) {
    qcom_Free(&sts, put.data);
    return 0;
  }
  return 1;
}

int sev_server::mainloop()
{
  qcom_sQid qid;
  int tmo = 200;
  qcom_sGet get;
  void* mp;
  pwr_tStatus sts;
  pwr_tTime next_garco, currenttime;
  pwr_tTime next_stat;
  pwr_tDeltaTime stat_interval;
  pwr_tDeltaTime garco_interval;
  pwr_tTime before_get;
  pwr_tDeltaTime busy = pwr_cNDeltaTime;
  pwr_tDeltaTime idle = pwr_cNDeltaTime;
  pwr_tDeltaTime dt;
  float fbusy, fidle;
  float a = exp(-((float)sev_cStatInterval) / 300);

  qid.nid = 0;
  qid.qix = sev_eProcSevServer;

  time_FloatToD(&garco_interval, m_config->GarbageInterval);
  time_FloatToD(&stat_interval, sev_cStatInterval);
  time_GetTime(&currenttime);
  time_Aadd(&next_garco, &currenttime, &garco_interval);
  time_Aadd(&next_stat, &currenttime, &stat_interval);

  m_server_status = PWR__SRUN;

  for (;;) {
    memset(&get, 0, sizeof(get));
    time_GetTime(&before_get);
    time_Adiff(&dt, &before_get, &currenttime);
    time_Dadd(&busy, &busy, &dt);
    time_DToFloat(&fbusy, &busy);

    mp = qcom_Get(&sts, &qid, &get, tmo);

    time_GetTime(&currenttime);
    time_Adiff(&dt, &currenttime, &before_get);
    time_Dadd(&idle, &idle, &dt);
    time_DToFloat(&fidle, &idle);

    if (time_Acomp(&currenttime, &next_stat) == 1) {
      m_stat.current_load = 100.0 * fbusy / (fbusy + fidle);
      if (feqf(m_stat.medium_load, 0.0f))
        m_stat.medium_load = m_stat.current_load;
      else
        m_stat.medium_load
            = a * m_stat.medium_load + (1.0 - a) * m_stat.current_load;
      m_stat.storage_rate = (float)m_storage_cnt / (fbusy + fidle);
      m_stat.write_rate = (float)m_write_cnt / (fbusy + fidle);
      if (feqf(m_stat.medium_storage_rate, 0.0f))
        m_stat.medium_storage_rate = m_stat.storage_rate;
      else
        m_stat.medium_storage_rate
            = a * m_stat.medium_storage_rate + (1.0 - a) * m_stat.storage_rate;
      if (feqf(m_stat.medium_write_rate, 0.0f))
        m_stat.medium_write_rate = m_stat.write_rate;
      else
        m_stat.medium_write_rate
            = a * m_stat.medium_write_rate + (1.0 - a) * m_stat.write_rate;
      if (m_stat.medium_storage_rate < FLT_EPSILON)
        m_stat.write_quota = 0;
      else
        m_stat.write_quota
            = m_stat.medium_write_rate / m_stat.medium_storage_rate * 100;
      m_storage_cnt = 0;
      m_write_cnt = 0;
      m_db->store_stat(&m_stat);

      m_config->Stat.CurrentLoad = m_stat.current_load;
      m_config->Stat.MediumLoad = m_stat.medium_load;
      m_config->Stat.StorageRate = m_stat.storage_rate;
      m_config->Stat.MediumStorageRate = m_stat.medium_storage_rate;
      m_config->Stat.WriteRate = m_stat.write_rate;
      m_config->Stat.MediumWriteRate = m_stat.medium_write_rate;
      m_config->Stat.WriteQuota = m_stat.write_quota;

      time_Aadd(&next_stat, &next_stat, &stat_interval);
      busy = pwr_cNDeltaTime;
      idle = pwr_cNDeltaTime;
    }
    if (!m_read_threads && time_Acomp(&currenttime, &next_garco) == 1) {
      garbage_collector(0);
      time_Aadd(&next_garco, &next_garco, &garco_interval);
    }
    if (sts == QCOM__ALLOCQUOTA) {
      struct timespec r, t;
      t.tv_sec = 0;
      t.tv_nsec = tmo * 1000000;
      nanosleep(&t, &r);
      continue;
    }
    if (sts == QCOM__TMO || !mp)
      continue;

    switch ((int)get.type.b) {
    case sev_cMsgClass:
      switch ((int)get.type.s) {
      case sev_eMsgType_NodeUp:
        errh_Info("Node up %s", cdh_NodeIdToString(0, get.reply.nid, 0, 0));
        request_items(get.reply.nid);
        break;
      case sev_eMsgType_HistItems:
        errh_Info(
            "Itemlist received %s", cdh_NodeIdToString(0, get.reply.nid, 0, 0));
        check_histitems((sev_sMsgHistItems*)mp, get.size);
        m_stat.items_msg_cnt++;
        break;
      case sev_eMsgType_HistDataStore:
        receive_histdata((sev_sMsgHistDataStore*)mp, get.size, get.sender.nid);
        m_stat.datastore_msg_cnt++;
        break;
      case sev_eMsgType_HistDataGetRequest:
        send_histdata(get.reply, (sev_sMsgHistDataGetRequest*)mp, get.size);
        m_stat.dataget_msg_cnt++;
        // Don't free the message now
        continue;
      case sev_eMsgType_HistItemsRequest:
        send_itemlist(get.reply);
        break;
      case sev_eMsgType_HistItemDelete:
        delete_item(get.reply, (sev_sMsgHistItemDelete*)mp);
        break;
      case sev_eMsgType_ServerStatusRequest:
        send_server_status(get.reply);
        break;
      case sev_eMsgType_HistObjectDataGetRequest:
        send_objecthistdata(
            get.reply, (sev_sMsgHistDataGetRequest*)mp, get.size);
        m_stat.dataget_msg_cnt++;
        // Don't free the message now
        continue;
      case sev_eMsgType_EventsStore:
        receive_events((sev_sMsgEventsStore*)mp, get.size, get.sender.nid);
        m_stat.eventstore_msg_cnt++;
        break;
      case sev_eMsgType_EventsGetRequest:
        send_events(get.reply, (sev_sMsgEventsGetRequest*)mp, get.size);
        // m_stat.dataget_msg_cnt++;
        // Don't free the message now
        continue;
      case sev_eMsgType_EventsItemsRequest:
        send_eventsitemlist(get.reply);
        break;
      default:;
      }
      break;
    case qcom_eBtype_event: {
      ini_mEvent new_event;
      qcom_sEvent* ep = (qcom_sEvent*)get.data;

      new_event.m = ep->mask;
      if (new_event.b.terminate) {
        delete m_db;
        exit(0);
      }
      break;
    }
    default:;
    }

    qcom_Free(&sts, mp);

    m_config->Stat.DataStoreMsgCnt = m_stat.datastore_msg_cnt;
    m_config->Stat.DataGetMsgCnt = m_stat.dataget_msg_cnt;
    m_config->Stat.ItemsMsgCnt = m_stat.items_msg_cnt;
    m_config->Stat.EventStoreMsgCnt = m_stat.eventstore_msg_cnt;
  }
}

int sev_server::check_histitems(sev_sMsgHistItems* msg, unsigned int size)
{
  unsigned int idx;
  pwr_tDeltaTime storagetime;
  int item_cnt = (size - sizeof(sev_sMsgHistItems)) / sizeof(sev_sHistItem) + 1;

  if (item_cnt <= 0)
    return 0;

  // Remove all refid's for this node
  pwr_tNid nid = msg->Items[0].sevid.nid;
  pwr_tStatus sts;
  sev_sRefid* succ_rp;
  thread_MutexLock(&m_refid_mutex);
  sev_sRefid* rp = (sev_sRefid*)tree_Minimum(&sts, m_refid);
  while (rp) {
    succ_rp = (sev_sRefid*)tree_Successor(&sts, m_refid, rp);
    if (rp->id.nid == nid)
      tree_Remove(&sts, m_refid, &rp->id);
    rp = succ_rp;
  }
  thread_MutexUnlock(&m_refid_mutex);

  for (int i = 0; i < item_cnt; i++) {
    if (msg->Items[i].attrnum > 0) {
      // Deadband requires id variable
      if (msg->Items[i].options & pwr_mSevOptionsMask_UseDeadBand &&
	  !(msg->Items[i].options & pwr_mSevOptionsMask_DeadBandLinearRegr))
        msg->Items[i].options |= pwr_mSevOptionsMask_ReadOptimized;

      // printf( "Received: %s.%s\n", msg->Items[i].oname,
      // msg->Items[i].attr[0].aname);
      storagetime = net_NetTimeToDeltaTime(&msg->Items[i].storagetime);

      if (msg->Items[i].attrnum > 1) {
        // printf( "Received: %s.%s AttrNum:%d\n", msg->Items[i].oname,
        // msg->Items[i].attr[0].aname, msg->Items[i].attrnum);
        sev_sHistItem* buffP = &msg->Items[i];
        while ((char*)buffP < (char*)msg + size) {
          // for(size_t j = 0; j < buffP->attrnum; j++) {
          //  printf( "Received: %s.%s\n", buffP->oname, buffP->attr[j].aname);
          //}
          char* s;
          char tablename[400];
          char tmpStr[400];
          char attributeName[400];
          strcpy(tmpStr, buffP->oname);
          // Point out attribute name
          s = strchr(tmpStr, '.');
          if (s) {
            *s = 0;
            strcpy(attributeName, s + 1);
          } else
            attributeName[0] = '\0';

          storagetime = net_NetTimeToDeltaTime(&buffP->storagetime);
          sprintf(tablename,
              "HiaHia"); // Dummy-name, real name created in add_objectitem
          bool newobject = false;
          if (!m_db->check_objectitem(&m_sts, tablename, buffP->oid,
                  buffP->oname, attributeName, storagetime, buffP->description,
                  buffP->scantime, buffP->deadband, buffP->options,
                  buffP->attrnum, buffP->attr, &idx)) {
            m_db->add_objectitem(&m_sts, tablename, buffP->oid, buffP->oname,
                attributeName, storagetime, buffP->description, buffP->scantime,
                buffP->deadband, buffP->options, buffP->attrnum, buffP->attr,
                &idx);
            if (EVEN(m_sts))
              return m_sts;
            newobject = true;
          }

          std::vector<sev_attr> oldattrVec = m_db->m_items[idx].attr;
          std::vector<sev_attr> newattrVec;
          m_db->m_items[idx].value_size = 0;
          // Check if any new attributes is found if so add column
          bool tableChange = false;
          for (size_t j = 0; j < buffP->attrnum; j++) {
            // printf( "Received: %s.%s\n", buffP->oname, buffP->attr[j].aname);
            sev_attr newattr;
            strncpy(newattr.aname, buffP->attr[j].aname, sizeof(newattr.aname));
            newattr.type = buffP->attr[j].type;
            newattr.size = buffP->attr[j].size;
            m_db->m_items[idx].value_size += newattr.size;
            newattr.elem = 0;
            newattrVec.push_back(newattr);

            if (!m_db->check_objectitemattr(&m_sts, tablename, buffP->oid,
                    buffP->attr[j].aname, buffP->oname, buffP->attr[j].type,
                    buffP->attr[j].size, &idx)) {
              tableChange = true;
            }
          }

          // Be sure that we have the correct attribute order. Use the list from
          // the client
          m_db->m_items[idx].attr.clear();
          m_db->m_items[idx].attr = newattrVec;
          m_db->m_items[idx].attrnum = newattrVec.size();

          if (tableChange) {
            // Either an attribute has changed type or size or we have a new
            // attribute
            // rename the table to something and create a new one.
            // this is the only way to do this without hanging the server for
            // several minutes
            m_db->handle_objectchange(&m_sts, tablename, idx, newobject);
          }

          // If node is coming up again we do not want deadband to be active due
          // to init of old_value
          m_db->m_items[idx].deadband_active = 0;
          m_db->m_items[idx].first_storage = 1;

          // TODO Check if some items in oldAttrVec no longer exists if so mark
          // this item
          // so that databaseadministrator knows which columns he can delete

          // If something was wrong during checking of attributes we ignore this
          // object
          if (ODD(m_sts)) {
            // Create space for the old values used if we have deadband active
            if (m_db->m_items[idx].old_value != 0) {
              free(m_db->m_items[idx].old_value);
              m_db->m_items[idx].old_value = 0;
            }
            m_db->m_items[idx].old_value
                = malloc(m_db->m_items[idx].value_size);

            m_db->m_items[idx].sevid = buffP->sevid;

            pwr_tRefId rk;
            sev_sRefid* rp;

            rk = buffP->sevid;
            thread_MutexLock(&m_refid_mutex);
            rp = (sev_sRefid*)tree_Insert(&sts, m_refid, &rk);
            rp->idx = idx;
            thread_MutexUnlock(&m_refid_mutex);
          }

          int numberOfAttributes = buffP->attrnum;
          // buffP points after the last attribute written
          if (numberOfAttributes == 0) {
            printf("Something is very strange at line:%d in file:%s\n",
                __LINE__, __FUNCTION__);
            break;
          }
          buffP = (sev_sHistItem*)&buffP->attr[numberOfAttributes];
        }
        break;
      }
      if (!m_db->check_item(&m_sts, msg->Items[i].oid, msg->Items[i].oname,
              msg->Items[i].attr[0].aname, storagetime,
              msg->Items[i].attr[0].type, msg->Items[i].attr[0].size,
              msg->Items[i].description, msg->Items[i].attr[0].unit,
              msg->Items[i].scantime, msg->Items[i].deadband,
              msg->Items[i].options, &idx)) {
        m_db->add_item(&m_sts, msg->Items[i].oid, msg->Items[i].oname,
            msg->Items[i].attr[0].aname, storagetime,
            msg->Items[i].attr[0].type, msg->Items[i].attr[0].size,
            msg->Items[i].description, msg->Items[i].attr[0].unit,
            msg->Items[i].scantime, msg->Items[i].deadband,
            msg->Items[i].options, &idx);
        if (EVEN(m_sts))
          return m_sts;
      }
      if (ODD(m_sts)) {
        // Create space for the old values used if we have deadband active
        if (m_db->m_items[idx].old_value != 0) {
          free(m_db->m_items[idx].old_value);
          m_db->m_items[idx].old_value = 0;
        }
        m_db->m_items[idx].value_size = msg->Items[i].attr[0].size;
        m_db->m_items[idx].old_value = malloc(m_db->m_items[idx].value_size);

        // If node is coming up again we do not want deadband to be active due
        // to init of old_value
        m_db->m_items[idx].deadband_active = 0;
        m_db->m_items[idx].first_storage = 1;

        m_db->m_items[idx].sevid = msg->Items[i].sevid;

        pwr_tRefId rk;
        sev_sRefid* rp;

        rk = msg->Items[i].sevid;
        thread_MutexLock(&m_refid_mutex);
        rp = (sev_sRefid*)tree_Insert(&sts, m_refid, &rk);
        rp->idx = idx;
        thread_MutexUnlock(&m_refid_mutex);
      }
    } else {
      // SevHistEvents item

      storagetime = net_NetTimeToDeltaTime(&msg->Items[i].storagetime);

      if (!m_db->check_item(&m_sts, msg->Items[i].oid, msg->Items[i].oname,
              (char*)"Events", storagetime, (pwr_eType)0, 0,
              msg->Items[i].description, (char*)"", msg->Items[i].scantime, 0,
              msg->Items[i].options, &idx)) {
        m_db->add_item(&m_sts, msg->Items[i].oid, msg->Items[i].oname,
            (char*)"Events", storagetime, (pwr_eType)0, 0,
            msg->Items[i].description, (char*)"", msg->Items[i].scantime, 0,
            msg->Items[i].options, &idx);
        if (EVEN(m_sts))
          return m_sts;
      }
    }
  }

  if (!m_noneth) {
    m_sts = m_db->tree_update();
    if (EVEN(m_sts))
      printf("Tree error %d\n", m_sts);
    m_sts = gdh_MountDynClients();
  }

  return 1;
}

int sev_server::receive_histdata(
    sev_sMsgHistDataStore* msg, unsigned int size, pwr_tNid nid)
{
  pwr_tStatus sts;
  sev_sHistData* dp;
  pwr_tTime time;
  pwr_tUInt32 server_thread;
  int data_size;

  if (msg->Version == 0) {
    // Server thread was added in version 1
    dp = (sev_sHistData*)&((sev_sMsgHistDataStoreV0*)msg)->Data;
    data_size = size - (sizeof(sev_sMsgHistDataStoreV0) - sizeof(msg->Data));
    server_thread = 0;
  } else {
    dp = (sev_sHistData*)&msg->Data;
    data_size = size - (sizeof(*msg) - sizeof(msg->Data));
    server_thread = msg->ServerThread;
  }

  if (!m_config->UseServerThreads) {
    m_db->begin_transaction(0);

    while ((char*)dp - (char*)msg < (int)size) {
      sev_sRefid* rp;
      pwr_tRefId rk = dp->sevid;

      thread_MutexLock(&m_refid_mutex);
      rp = (sev_sRefid*)tree_Find(&sts, m_refid, &rk);
      thread_MutexUnlock(&m_refid_mutex);

      if (!rp) {
        dp = (sev_sHistData*)((char*)dp + sizeof(*dp) - sizeof(dp->data)
            + dp->size);
        continue;
      }
      unsigned int idx = rp->idx;

      time = net_NetTimeToTime(&msg->Time);
      m_db->store_value(&m_sts, 0, idx, 0, time, &dp->data, dp->size);
      m_storage_cnt++;
      m_write_cnt++;

      dp = (sev_sHistData*)((char*)dp + sizeof(*dp) - sizeof(dp->data)
          + dp->size);
    }

    m_db->commit_transaction(0);
  } else {
    sev_sThread* th;
    sev_sQMsgHistData* qmsg;
    int qmsg_size;
    pwr_tUInt32 key;

    if (m_thread_key_node)
      key = nid;
    else
      key = server_thread;

    th = find_thread(key);
    if (!th) {
      th = create_thread(key);
      printf("sev_server, new thread %d\n", key);
    }

    // Create a queue message
    qmsg_size = data_size + (sizeof(*qmsg) - sizeof(qmsg->data));

    if ((int)(th->alloc + qmsg_size) > (int)m_config->ThreadQueueLimit
        || (int)(m_total_queue_cnt + qmsg_size)
            > (int)m_config->TotalQueueLimit) {
      // Queue maxlimit exceeded, discard message
      m_config->ServerThreads[th->conf_idx].LostCnt++;
      return 1;
    }

    qmsg = (sev_sQMsgHistData*)malloc(qmsg_size);
    memcpy(&qmsg->data, dp, data_size);
    qmsg->h.type = sev_eQMsgType_HistData;
    qmsg->h.version = msg->Version;
    qmsg->h.size = qmsg_size;
    qmsg->time = msg->Time;
    lst_Init(NULL, &qmsg->h.e, qmsg);

    thread_MutexLock(&m_alloc_mutex);
    th->alloc += qmsg->h.size;
    m_total_queue_cnt += qmsg->h.size;
    thread_MutexUnlock(&m_alloc_mutex);

    m_config->TotalQueueCnt = m_total_queue_cnt;
    if (th->conf_idx >= 0) {
      m_config->ServerThreads[th->conf_idx].QueueAlloc = th->alloc;
      m_config->ServerThreads[th->conf_idx].DataStoreMsgCnt++;
    }
    que_Put(&sts, &th->queue, &qmsg->h.e, qmsg);
  }
  return 1;
}

int sev_server::send_histdata(
    qcom_sQid tgt, sev_sMsgHistDataGetRequest* rmsg, unsigned int size)
{
  pthread_t thread;
  pthread_attr_t attr;
  int sts;

  sev_sHistDataThread* arg = (sev_sHistDataThread*)malloc(sizeof(*arg));
  arg->sev = this;
  arg->tgt = tgt;
  arg->rmsg = rmsg;
  arg->size = size;

  if (m_read_threads) {
    static int pcnt = 0;
    printf("New read thread %d\n", pcnt++);
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    sts = pthread_create(&thread, &attr, send_histdata_thread, arg);
    if (sts != 0)
      printf("pthread_create error %d\n", sts);
  } else {
    send_histdata_thread(arg);
  }
  return 1;
}

void* sev_server::send_histdata_thread(void* arg)
{
  pwr_tTime* tbuf;
  void* vbuf;
  unsigned int rows = 0;
  sev_sMsgHistDataGet* msg;
  int msize;
  qcom_sPut put;
  pwr_tStatus sts, lsts;
  pwr_tTime starttime, endtime;
  unsigned int item_idx;
  void* thread = 0;

  sev_server* sev = ((sev_sHistDataThread*)arg)->sev;
  qcom_sQid tgt = ((sev_sHistDataThread*)arg)->tgt;
  sev_sMsgHistDataGetRequest* rmsg = ((sev_sHistDataThread*)arg)->rmsg;

  free(arg);

  starttime = net_NetTimeToTime(&rmsg->StartTime);
  endtime = net_NetTimeToTime(&rmsg->EndTime);

  if (cdh_ObjidIsNull(rmsg->Oid))
    sev->m_db->get_item_idx_by_name(&sts, &item_idx, rmsg->AName);
  else
    sev->m_db->get_item_idx(&sts, &item_idx, rmsg->Oid, rmsg->AName);

  if (ODD(sts)) {
    if (sev->m_read_threads)
      thread = sev->m_db->new_thread();

    sev->m_db->get_values(&sts, thread,
        sev->m_db->m_items[item_idx].oid,
        sev->m_db->m_items[item_idx].options,
        sev->m_db->m_items[item_idx].deadband,
        sev->m_db->m_items[item_idx].attr[0].aname,
        sev->m_db->m_items[item_idx].attr[0].type,
        sev->m_db->m_items[item_idx].attr[0].size,
        sev->m_db->m_items[item_idx].scantime,
        &sev->m_db->m_items[item_idx].creatime, &starttime, &endtime,
        rmsg->NumPoints, &tbuf, &vbuf, &rows);
    if (ODD(sts) && rows != 0)
      msize
          = rows * (sizeof(pwr_tTime) + sev->m_db->m_items[item_idx].attr[0].size)
          + sizeof(*msg) - sizeof(msg->Data);
    else
      msize = sizeof(*msg);
  }
  else 
    msize = sizeof(*msg);

  put.reply.nid = sev->m_nodes[0].nid;
  put.reply.qix = sev_eProcSevServer;
  put.type.b = (qcom_eBtype)sev_cMsgClass;
  put.type.s = (qcom_eStype)sev_eMsgType_HistDataGet;
  put.msg_id = sev->m_msg_id++;
  put.size = msize;
  msg = (sev_sMsgHistDataGet*)qcom_Alloc(&lsts, put.size);

  put.data = msg;
  put.allocate = 0;

  msg->Type = sev_eMsgType_HistDataGet;
  msg->Version = sev_cNetVersion;
  msg->Oid = rmsg->Oid;
  strncpy(msg->AName, rmsg->AName, sizeof(msg->AName));
  if (ODD(sts)) {
    msg->NumPoints = rows;
    msg->VType = sev->m_db->m_items[item_idx].attr[0].type;
    msg->VSize = sev->m_db->m_items[item_idx].attr[0].size;
  }
  qcom_Free(&lsts, rmsg);

  msg->Status = sts;

  if (ODD(sts) && rows) {
    memcpy(&msg->Data, tbuf, sizeof(pwr_tTime) * rows);
    memcpy((char*)&msg->Data + sizeof(pwr_tTime) * rows, vbuf,
        sev->m_db->m_items[item_idx].attr[0].size * rows);
  }
  if (!qcom_Put(&lsts, &tgt, &put)) {
    qcom_Free(&lsts, put.data);
  }
  if (ODD(sts)) {
    free(tbuf);
    free(vbuf);
  }

  if (sev->m_read_threads)
    sev->m_db->delete_thread(thread);

  pthread_exit( (void *) 1);
  return (void*)1;
}

int sev_server::send_objecthistdata(
    qcom_sQid tgt, sev_sMsgHistDataGetRequest* rmsg, unsigned int size)
{
  pthread_t thread;
  int sts;

  sev_sHistDataThread* arg = (sev_sHistDataThread*)malloc(sizeof(*arg));
  arg->sev = this;
  arg->tgt = tgt;
  arg->rmsg = rmsg;
  arg->size = size;

  if (m_read_threads) {
    printf("New read thread\n");
    sts = pthread_create(&thread, NULL, send_objecthistdata_thread, arg);
    if (sts != 0)
      printf("pthread_create error %d\n", sts);
  } else {
    send_objecthistdata_thread(arg);
  }
  return 1;
}

void* sev_server::send_objecthistdata_thread(void* arg)
{
  pwr_tTime* tbuf = NULL;
  void* vbuf = NULL;
  unsigned int rows = 0;
  sev_sMsgHistObjectDataGet* msg;
  int msize;
  qcom_sPut put;
  pwr_tStatus sts, lsts;
  pwr_tTime starttime, endtime;
  void* thread = 0;

  sev_server* sev = ((sev_sHistDataThread*)arg)->sev;
  qcom_sQid tgt = ((sev_sHistDataThread*)arg)->tgt;
  sev_sMsgHistDataGetRequest* rmsg = ((sev_sHistDataThread*)arg)->rmsg;

  free(arg);

  starttime = net_NetTimeToTime(&rmsg->StartTime);
  endtime = net_NetTimeToTime(&rmsg->EndTime);
  sev_item item;

  if (sev->m_read_threads)
    thread = sev->m_db->new_thread();

  sev->m_db->get_objectitem(&sev->m_sts, thread, &item, rmsg->Oid, rmsg->AName);
  if (ODD(sev->m_sts)) {
    sev->m_db->get_objectvalues(&sev->m_sts, thread, &item, item.value_size,
        &starttime, &endtime, rmsg->NumPoints, &tbuf, &vbuf, &rows);
  }
  if (ODD(sev->m_sts) && rows != 0) {
    msize = rows * (sizeof(pwr_tTime) + item.value_size);
    msize += item.attr.size() * sizeof(msg->Attr);
    msize += sizeof(*msg) - sizeof(msg->Data) - sizeof(msg->Attr);
  } else
    msize = sizeof(*msg);

  put.reply.nid = sev->m_nodes[0].nid;
  put.reply.qix = sev_eProcSevServer;
  put.type.b = (qcom_eBtype)sev_cMsgClass;
  put.type.s = (qcom_eStype)sev_eMsgType_HistObjectDataGet;
  put.msg_id = sev->m_msg_id++;
  put.size = msize;
  msg = (sev_sMsgHistObjectDataGet*)qcom_Alloc(&lsts, put.size);

  put.data = msg;
  put.allocate = 0;

  msg->Type = sev_eMsgType_HistObjectDataGet;
  msg->Version = sev_cNetVersion;
  msg->Oid = rmsg->Oid;
  strncpy(msg->AName, rmsg->AName, sizeof(msg->AName));
  msg->Status = sev->m_sts;
  msg->NumPoints = 0;
  msg->NumAttributes = 0;
  if (ODD(sev->m_sts) && rows != 0) {
    msg->NumPoints = rows;
    msg->NumAttributes = item.attr.size();
    msg->TotalDataSize = rows * (sizeof(pwr_tTime) + item.value_size);
    for (size_t i = 0; i < item.attr.size(); i++) {
      strncpy(
          msg->Attr[i].aname, item.attr[i].aname, sizeof(msg->Attr[0].aname));
      msg->Attr[i].elem = 1; // Not used
      msg->Attr[i].size = item.attr[i].size;
      msg->Attr[i].type = item.attr[i].type;
    }
    if (rows) {
      void* ptr = &msg->Attr[item.attr.size()];
      memcpy(ptr, tbuf, sizeof(pwr_tTime) * rows);
      memcpy(
          (char*)ptr + sizeof(pwr_tTime) * rows, vbuf, item.value_size * rows);
    }
  }

  qcom_Free(&lsts, rmsg);

  if (!qcom_Put(&sts, &tgt, &put)) {
    qcom_Free(&sts, put.data);
  }

  if (sev->m_read_threads)
    sev->m_db->delete_thread(thread);

  return (void*)1;
}

int sev_server::send_events(
    qcom_sQid tgt, sev_sMsgEventsGetRequest* rmsg, unsigned int size)
{
  pthread_t thread;
  pthread_attr_t attr;
  int sts;

  sev_sEventsThread* arg = (sev_sEventsThread*)malloc(sizeof(*arg));
  arg->sev = this;
  arg->tgt = tgt;
  arg->rmsg = rmsg;
  arg->size = size;

  if (m_read_threads) {
    static int pcnt = 0;
    printf("New read thread %d\n", pcnt++);
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    sts = pthread_create(&thread, &attr, send_events_thread, arg);
    if (sts != 0)
      printf("pthread_create error %d\n", sts);
  } else {
    send_events_thread(arg);
  }
  return 1;
}

void* sev_server::send_events_thread(void* arg)
{
  sev_sMsgEventsGet* msg;
  int msize;
  qcom_sPut put;
  pwr_tStatus sts, lsts;
  pwr_tTime starttime, endtime;
  unsigned int item_idx;
  void* thread = 0;
  std::vector<sev_event> list;

  sev_server* sev = ((sev_sEventsThread*)arg)->sev;
  qcom_sQid tgt = ((sev_sEventsThread*)arg)->tgt;
  sev_sMsgEventsGetRequest* rmsg = ((sev_sEventsThread*)arg)->rmsg;

  free(arg);

  starttime = net_NetTimeToTime(&rmsg->StartTime);
  endtime = net_NetTimeToTime(&rmsg->EndTime);

  sev->m_db->get_item_idx(&sts, &item_idx, rmsg->Oid, (char *)"Events");
  if (ODD(sts)) {
    if (sev->m_read_threads)
      thread = sev->m_db->new_thread();

    sev->m_db->get_events(&sts, thread, rmsg->Oid,
			  sev->m_db->m_items[item_idx].options, rmsg->EventTypeMask, 
			  rmsg->EventPrioMask, rmsg->EventText, rmsg->EventName,
			  &starttime, &endtime, rmsg->MaxEvents, list);
  }
  if (ODD(sts) && list.size() != 0)
    msize = sizeof(*msg) + (list.size() - 1) * sizeof(sev_sEvents);
  else
    msize = sizeof(*msg);

  put.reply.nid = sev->m_nodes[0].nid;
  put.reply.qix = sev_eProcSevServer;
  put.type.b = (qcom_eBtype)sev_cMsgClass;
  put.type.s = (qcom_eStype)sev_eMsgType_EventsGet;
  put.msg_id = sev->m_msg_id++;
  put.size = msize;
  msg = (sev_sMsgEventsGet*)qcom_Alloc(&lsts, put.size);

  put.data = msg;
  put.allocate = 0;

  msg->Type = sev_eMsgType_EventsGet;
  msg->Version = sev_cNetVersion;
  msg->Oid = rmsg->Oid;
  if (ODD(sts)) {
    msg->NumEvents = list.size();
  }
  qcom_Free(&lsts, rmsg);

  msg->Status = sts;

  if (ODD(sts) && list.size()) {
    sev_sEvents *mp = msg->Events;
    for (int i = 0; i < list.size(); i++) {
      mp->Time = net_TimeToNetTime(&list[i].time);
      mp->EventType = list[i].type;
      mp->EventPrio = list[i].eventprio;
      mp->SupObjectOid = list[i].supobject.Objid;
      mp->SupObjectOffset = list[i].supobject.Offset;
      mp->SupObjectSize = list[i].supobject.Size;
      strncpy(mp->EventText, list[i].eventtext, sizeof(mp->EventText));
      strncpy(mp->EventName, list[i].eventname, sizeof(mp->EventName));
      mp->EventId = list[i].eventid;
      mp->EventStatus = list[i].eventstatus;
      mp++;
    }
  }
  if (!qcom_Put(&sts, &tgt, &put)) {
    qcom_Free(&sts, put.data);
  }

  if (sev->m_read_threads)
    sev->m_db->delete_thread(thread);

  pthread_exit( (void *) 1);
  return (void*)1;
}

int sev_server::receive_events(
    sev_sMsgEventsStore* msg, unsigned int size, pwr_tNodeId nid)
{
  sev_sEvent* ep;
  pwr_tUInt32 server_thread;

  if (msg->Version == 0) {
    // Server thread was added in version 1
    ep = (sev_sEvent*)&((sev_sMsgEventsStoreV0*)msg)->Events;
    server_thread = 0;
  } else {
    ep = (sev_sEvent*)&msg->Events[0];
    server_thread = msg->ServerThread;
  }

  // Get index
  int idx = 0;
  int found = 0;
  for (unsigned int i = 0; i < m_db->m_items.size(); i++) {
    if (m_db->m_items[i].deleted)
      continue;
    if (cdh_ObjidIsEqual(m_db->m_items[i].oid, msg->Oid)) {
      idx = i;
      found = 1;
      break;
    }
  }
  if (!found) {
    errh_Error(
        "Unknown event table, objid (%d,%d)", msg->Oid.vid, msg->Oid.oix);
    return 1;
  }

  if (!m_config->UseServerThreads) {
    for (unsigned int i = 0; i < msg->NumEvents; i++) {
      sev_event ev;

      ev.type = ep->type;
      ev.eventprio = ep->eventprio;
      ev.eventid.Nix = ep->eventid_nix;
      ev.eventid.BirthTime.tv_sec = ep->eventid_birthtime;
      ev.eventid.BirthTime.tv_nsec = 0;
      ev.eventid.Idx = ep->eventid_idx;
      ev.time = net_NetTimeToTime(&ep->time);
      strcpy(ev.eventtext, ep->eventtext);
      strcpy(ev.eventname, ep->eventname);
      ev.supobject.Objid.vid = ep->sup_aref_vid;
      ev.supobject.Objid.oix = ep->sup_aref_oix;
      ev.supobject.Offset = ep->sup_aref_offset;
      ev.supobject.Size = ep->sup_aref_size;
      ev.eventstatus = ep->eventstatus;
      m_db->store_event(&m_sts, 0, idx, &ev);
      ep++;
    }
  } else {
    sev_sThread* th;
    sev_sQMsgEvent* qmsg;
    pwr_tUInt32 key;
    int sts;

    if (m_thread_key_node)
      key = nid;
    else
      key = server_thread;

    th = find_thread(key);
    if (!th) {
      th = create_thread(key);
      printf("sev_server, new thread %d\n", key);
    }

    // Create a queue message
    if ((int)(th->alloc + sizeof(*qmsg) - sizeof(qmsg->data) + size)
            > (int)m_config->ThreadQueueLimit
        || (int)(m_total_queue_cnt + sizeof(*qmsg) - sizeof(qmsg->data) + size)
            > (int)m_config->TotalQueueLimit) {
      // Queue maxlimit exceeded, discard message
      m_config->ServerThreads[th->conf_idx].LostCnt++;
      return 1;
    }

    qmsg = (sev_sQMsgEvent*)malloc(sizeof(*qmsg) - sizeof(qmsg->data) + size);
    memcpy(&qmsg->data, ep, size);
    qmsg->h.type = sev_eQMsgType_Event;
    qmsg->h.version = msg->Version;
    qmsg->h.size = size;
    lst_Init(NULL, &qmsg->h.e, qmsg);
    qmsg->num_events = msg->NumEvents;
    qmsg->item_idx = idx;

    thread_MutexLock(&m_alloc_mutex);
    th->alloc += qmsg->h.size;
    m_total_queue_cnt += qmsg->h.size;
    thread_MutexUnlock(&m_alloc_mutex);

    m_config->TotalQueueCnt = m_total_queue_cnt;
    if (th->conf_idx >= 0) {
      m_config->ServerThreads[th->conf_idx].QueueAlloc = th->alloc;
      m_config->ServerThreads[th->conf_idx].EventStoreMsgCnt++;
    }
    que_Put(&sts, &th->queue, &qmsg->h.e, qmsg);
  }
  return 1;
}

void sev_server::create_garbage_collector_thread()
{
  pthread_t pthread;
  int sts;

  sts = pthread_create(&pthread, NULL, garbage_collector_thread, this);
  if (sts != 0)
    printf("sev_server: pthread_create error %d\n", sts);
}

void* sev_server::garbage_collector_thread(void* arg)
{
  void* thread = 0;
  pwr_tTime next_garco, currenttime;
  pwr_tDeltaTime garco_interval;
  unsigned int reconnect_cnt = 0;

  sev_server* sev = (sev_server*)arg;

  thread = sev->m_db->new_thread();

  time_FloatToD(&garco_interval, sev->m_config->GarbageInterval);
  time_GetTime(&currenttime);
  time_Aadd(&next_garco, &currenttime, &garco_interval);

  while (1) {
    sleep(1);

    time_GetTime(&currenttime);
    if (time_Acomp(&currenttime, &next_garco) == 1) {
      sev->garbage_collector(thread);
      if (sev->m_sts == SEV__NOCONNECTION) {
	if ( reconnect_cnt < 50) {
	  errh_Error("Database connection lost, thread garbage collector, reconnecting");
	  thread = sev->m_db->new_thread();
	  reconnect_cnt++;
	}
      }
	

      time_FloatToD(&garco_interval, sev->m_config->GarbageInterval);
      time_Aadd(&next_garco, &next_garco, &garco_interval);
    }
  }
}

void sev_server::garbage_collector(void* thread)
{
  int item_size = m_db->m_items.size();
  static int current = 0;
  float items_per_scan;
  int scan_per_items;
  static int scan_cnt = 0;
  int i;

  if (item_size == 0)
    return;

  items_per_scan
      = ((float)m_config->GarbageInterval) * item_size / sev_cGarbageCycle;

  if (items_per_scan >= 1) {
    for (i = 0; i < (int)items_per_scan; i++) {
      garbage_item(thread, current);
      current++;
      if (current >= item_size)
        current = 0;
    }
  } else {
    scan_per_items = (int)(1.0 / items_per_scan);
    scan_cnt++;
    if (scan_cnt >= scan_per_items) {
      scan_cnt = 0;

      garbage_item(thread, current);
      if (m_sts == SEV__NOCONNECTION)
	return;

      current++;
      if (current >= item_size)
        current = 0;
    }
  }
}

void sev_server::garbage_item(void* thread, int idx)
{
  pwr_tTime currenttime, limit;

  time_GetTime(&currenttime);

  if (m_db->m_items[idx].deleted)
    return;
  if (m_db->m_items[idx].storagetime.tv_sec == 0)
    return;

  time_Asub(&limit, &currenttime, &m_db->m_items[idx].storagetime);

  if (m_db->m_items[idx].attrnum > 1) {
    m_db->delete_old_objectdata(&m_sts, thread, m_db->m_items[idx].tablename,
        m_db->m_items[idx].options, limit, m_db->m_items[idx].scantime,
        (float)sev_cGarbageCycle);
  } else {
    m_db->delete_old_data(&m_sts, thread, m_db->m_items[idx].tablename,
        m_db->m_items[idx].options, limit, m_db->m_items[idx].scantime,
        (float)sev_cGarbageCycle);
  }
}

sev_sThread* sev_server::find_thread(int key)
{
  return m_thread_list[key];
}

void* sev_server::receive_histdata_thread(void* arg)
{
  sev_server* sev = (sev_server*)((sev_sReceiveHistDataThread*)arg)->ctx;
  int tmo_item;
  pwr_tDeltaTime tmo = { 1, 0 };
  sev_sThread* th = ((sev_sReceiveHistDataThread*)arg)->th;
  pwr_tStatus sts;
  pwr_tTime time;
  pwr_tTime currenttime;
  pwr_tTime next_stat;
  sev_sQMsgHeader* qmsg;
  pwr_tDeltaTime stat_interval = { 0, 500000000 };
  pwr_tTime before_get;
  pwr_tDeltaTime busy = pwr_cNDeltaTime;
  pwr_tDeltaTime idle = pwr_cNDeltaTime;
  pwr_tDeltaTime dt;
  float fbusy, fidle;
  float a = exp(-((float)sev_cStatInterval) / 300);
  pwr_sClass_SevServerThread* thread_conf = 0;
  float current_load;
  int storage_cnt = 0;
  int write_cnt = 0;

  if (th->conf_idx >= 0)
    thread_conf = &sev->m_config->ServerThreads[th->conf_idx];

  free(arg);

  printf("New thread %d\n", th->key);

  time_GetTime(&currenttime);
  time_Aadd(&next_stat, &currenttime, &stat_interval);

  while (1) {
    time_GetTime(&before_get);
    time_Adiff(&dt, &before_get, &currenttime);
    time_Dadd(&busy, &busy, &dt);
    time_DToFloat(&fbusy, &busy);

    qmsg = (sev_sQMsgHeader*)que_Get(NULL, &th->queue, &tmo, &tmo_item);

    if ((int*)qmsg == &tmo_item) {
      // printf( "Tmo %d\n", th->key);
    } else {
      thread_MutexLock(&sev->m_alloc_mutex);
      th->alloc -= qmsg->size;
      // if ( th->alloc < 0)
      //  th->alloc = 0;
      sev->m_total_queue_cnt -= qmsg->size;
      thread_MutexUnlock(&sev->m_alloc_mutex);
      sev->m_config->TotalQueueCnt = sev->m_total_queue_cnt;

      time_GetTime(&currenttime);
      time_Adiff(&dt, &currenttime, &before_get);
      time_Dadd(&idle, &idle, &dt);
      time_DToFloat(&fidle, &idle);

      if (th->conf_idx >= 0 && time_Acomp(&currenttime, &next_stat) == 1) {
        thread_conf->QueueAlloc = th->alloc;
        current_load = 100.0 * fbusy / (fbusy + fidle);
        if (feqf(thread_conf->MediumLoad, 0.0f))
          thread_conf->MediumLoad = current_load;
        else
          thread_conf->MediumLoad
              = a * thread_conf->MediumLoad + (1.0 - a) * current_load;
        thread_conf->StorageRate = (float)storage_cnt / (fbusy + fidle);
        if (feqf(thread_conf->MediumStorageRate, 0.0f))
          thread_conf->MediumStorageRate = thread_conf->StorageRate;
        else
          thread_conf->MediumStorageRate = a * thread_conf->MediumStorageRate
              + (1.0 - a) * thread_conf->StorageRate;
        thread_conf->WriteRate = (float)write_cnt / (fbusy + fidle);
        if (feqf(thread_conf->MediumWriteRate, 0.0f))
          thread_conf->MediumWriteRate = thread_conf->WriteRate;
        else
          thread_conf->MediumWriteRate = a * thread_conf->MediumWriteRate
              + (1.0 - a) * thread_conf->WriteRate;
        if (thread_conf->MediumStorageRate < FLT_EPSILON)
          thread_conf->WriteQuota = 0;
        else
          thread_conf->WriteQuota = thread_conf->MediumWriteRate
              / thread_conf->MediumStorageRate * 100;
        storage_cnt = 0;
        write_cnt = 0;

        time_Aadd(&next_stat, &next_stat, &stat_interval);
        busy = pwr_cNDeltaTime;
        idle = pwr_cNDeltaTime;
      }

      switch (qmsg->type) {
      case sev_eQMsgType_HistData: {
        sev_sHistData* dp;
        sev_sQMsgHistData* msg = (sev_sQMsgHistData*)qmsg;
        int data_size = msg->h.size - (sizeof(*msg) - sizeof(msg->data));

        dp = (sev_sHistData*)&msg->data;

        sts = sev->m_db->begin_transaction(th->db_ctx);
	if (sts == SEV__NOCONNECTION) {
	  if ( th->reconnect_cnt < 50) {
	    errh_Error("Database connection lost, thread %d, reconnecting",th->key);
	    th->db_ctx = sev->m_db->new_thread();
	    th->reconnect_cnt++;
	    sts = sev->m_db->begin_transaction(th->db_ctx);
	  }
	  if (EVEN(sts))
	    break;
	}

        while ((char*)dp - (char*)msg->data < data_size) {
          sev_sRefid* rp;
          pwr_tRefId rk = dp->sevid;

          thread_MutexLock(&sev->m_refid_mutex);
          rp = (sev_sRefid*)tree_Find(&sts, sev->m_refid, &rk);
          thread_MutexUnlock(&sev->m_refid_mutex);
          if (!rp) {
            dp = (sev_sHistData*)((char*)dp + sizeof(*dp) - sizeof(dp->data)
                + dp->size);
            continue;
          }
          unsigned int idx = rp->idx;

          time = net_NetTimeToTime(&msg->time);
          sev->m_db->store_value(
              &sev->m_sts, th->db_ctx, idx, 0, time, &dp->data, dp->size);
          sev->m_storage_cnt++;
          storage_cnt++;
          if (ODD(sev->m_sts) && sev->m_sts != SEV__NOWRITE) {
            sev->m_write_cnt++;
            write_cnt++;
          }

          dp = (sev_sHistData*)((char*)dp + sizeof(*dp) - sizeof(dp->data)
              + dp->size);
        }

        sts = sev->m_db->commit_transaction(th->db_ctx);
	if (sts == SEV__NOCONNECTION) {
	  if ( th->reconnect_cnt < 50) {
	    errh_Error("Database connection lost, thread %d, reconnecting",th->key);
	    th->db_ctx = sev->m_db->new_thread();
	    th->reconnect_cnt++;
	  }
	}
        break;
      }
      case sev_eQMsgType_Event: {
        sev_sEvent* ep;
        sev_sQMsgEvent* msg = (sev_sQMsgEvent*)qmsg;

        ep = (sev_sEvent*)&msg->data;

        if (msg->h.version > 0) {
          for (int i = 0; i < msg->num_events; i++) {
            sev_event ev;

            ev.type = ep->type;
            ev.eventprio = ep->eventprio;
            ev.eventid.Nix = ep->eventid_nix;
            ev.eventid.BirthTime.tv_sec = ep->eventid_birthtime;
            ev.eventid.BirthTime.tv_nsec = 0;
            ev.eventid.Idx = ep->eventid_idx;
            ev.time = net_NetTimeToTime(&ep->time);
            strcpy(ev.eventtext, ep->eventtext);
            strcpy(ev.eventname, ep->eventname);
            ev.supobject.Objid.vid = ep->sup_aref_vid;
            ev.supobject.Objid.oix = ep->sup_aref_oix;
            ev.supobject.Offset = ep->sup_aref_offset;
            ev.supobject.Size = ep->sup_aref_size;
	    if (msg->h.version > 1)
	      // Eventstatus added in version 2
	      ev.eventstatus = ep->eventstatus;
	    else
	      ev.eventstatus = 0;
            sev->m_db->store_event(&sev->m_sts, th->db_ctx, msg->item_idx, &ev);
            ep++;
          }
        } else {
          // Supobject was added in version 1
          sev_sEventV0* epV0 = (sev_sEventV0*)ep;
          for (int i = 0; i < msg->num_events; i++) {
            sev_event ev;

            ev.type = epV0->type;
            ev.eventprio = epV0->eventprio;
            ev.eventid.Nix = epV0->eventid_nix;
            ev.eventid.BirthTime.tv_sec = epV0->eventid_birthtime;
            ev.eventid.BirthTime.tv_nsec = 0;
            ev.eventid.Idx = ep->eventid_idx;
            ev.time = net_NetTimeToTime(&epV0->time);
            strcpy(ev.eventtext, epV0->eventtext);
            strcpy(ev.eventname, epV0->eventname);
            ev.supobject.Objid.vid = 0;
            ev.supobject.Objid.oix = 0;
            ev.supobject.Offset = 0;
            ev.supobject.Size = 0;
	    ev.eventstatus = 0;
            sev->m_db->store_event(&sev->m_sts, th->db_ctx, msg->item_idx, &ev);
            epV0++;
          }
        }
        break;
      }
      }

      if (th->conf_idx >= 0)
        thread_conf->QueueAlloc = th->alloc;

      free(qmsg);
    }
  }
}

sev_sThread* sev_server::create_thread(int key)
{
  int sts;

  sev_sThread* th = (sev_sThread*)calloc(1, sizeof(sev_sThread));
  th->key = key;
  que_Create(NULL, &th->queue);
  th->db_ctx = m_db->new_thread();
  if (m_thread_cnt
      < sizeof(m_config->ServerThreads) / sizeof(m_config->ServerThreads[0]))
    th->conf_idx = m_thread_cnt;
  else
    th->conf_idx = -1;
  m_thread_cnt++;

  m_thread_list[key] = th;

  sev_sReceiveHistDataThread* arg
      = (sev_sReceiveHistDataThread*)malloc(sizeof(*arg));
  arg->ctx = this;
  arg->th = th;

  sts = pthread_create(&th->thread, NULL, receive_histdata_thread, arg);
  if (sts != 0)
    printf("sev_server: pthread_create error %d\n", sts);

  if (th->conf_idx >= 0) {
    m_config->ServerThreads[th->conf_idx].Occupied = 1;
    m_config->ServerThreads[th->conf_idx].Key = key;
  }

  return th;
}

void sev_server::delete_thread(int key)
{
  sev_sThread* th;

  th = m_thread_list[key];
  if (!th)
    return;

  free(th);
  m_thread_list.erase(key);
}

sev_server::~sev_server()
{
  for (threadlist_iterator it = m_thread_list.begin();
       it != m_thread_list.end();) {
    sev_sThread* th = it->second;
    m_thread_list.erase(it++);
    m_db->delete_thread(th->db_ctx);
    free(th);
  }
}

int main(int argc, char* argv[])
{
  sev_server srv;
  int noneth = 0;

  if (argc > 1 && streq(argv[1], "-n"))
    noneth = 1;

  srv.init(noneth);
  srv.connect();
  srv.mainloop();
}
