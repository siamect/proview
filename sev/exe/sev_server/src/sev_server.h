/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#ifndef sev_server_h
#define sev_server_h

#include <map>

#include "rt_que.h"

#include "sev_db.h"

class sev_server;

class sev_node {
public:
  pwr_tNodeId nid;
  char name[80];
};

typedef struct {
  tree_sNode node;
  pwr_tRefId id;
  int idx;
} sev_sRefid;

typedef struct {
  sev_server* sev;
  qcom_sQid tgt;
  sev_sMsgHistDataGetRequest* rmsg;
  unsigned int size;
  unsigned int item_idx;
} sev_sHistDataThread;

typedef struct {
  sev_server* sev;
  qcom_sQid tgt;
  sev_sMsgEventsGetRequest* rmsg;
  unsigned int size;
  unsigned int item_idx;
} sev_sEventsThread;

typedef struct {
  int key;
  pthread_t thread;
  que_sQue queue;
  int alloc;
  void* db_ctx;
  int conf_idx;
  unsigned int reconnect_cnt;
} sev_sThread;

typedef struct {
  void* ctx;
  sev_sThread* th;
} sev_sReceiveHistDataThread;

typedef enum { sev_eQMsgType_HistData, sev_eQMsgType_Event } sev_eQMsgType;

typedef struct {
  sev_eQMsgType type;
  unsigned int version;
  lst_sEntry e;
  int size;
} sev_sQMsgHeader;

typedef struct {
  sev_sQMsgHeader h;
  net_sTime time;
  char data[1];
} sev_sQMsgHistData;

typedef struct {
  sev_sQMsgHeader h;
  int num_events;
  int item_idx;
  char data[1];
} sev_sQMsgEvent;

typedef std::map<int, sev_sThread*>::iterator threadlist_iterator;

class sev_server {
public:
  sev_server()
      : m_server_status(0), m_refid(0), m_msg_id(0), m_storage_cnt(0),
        m_write_cnt(0), m_total_queue_cnt(0), m_db_type(sev_eDbType_Sqlite),
        m_config(0), m_thread_cnt(0), m_read_threads(0), m_thread_key_node(0)
  {
    memset(&m_stat, 0, sizeof(m_stat));
  }

  ~sev_server();
  pwr_tStatus m_sts;
  pwr_tStatus m_server_status;
  std::vector<sev_node> m_nodes;
  tree_sTable* m_refid;
  thread_sMutex m_refid_mutex;
  thread_sMutex m_alloc_mutex;
  unsigned int m_msg_id;
  sev_db* m_db;
  int m_noneth;
  unsigned int m_storage_cnt;
  unsigned int m_write_cnt;
  int m_total_queue_cnt;
  sev_sStat m_stat;
  sev_eDbType m_db_type;
  pwr_sClass_SevServer* m_config;
  unsigned int m_thread_cnt;
  pwr_tDlid m_config_dlid;
  int m_read_threads;
  int m_thread_key_node;
  std::map<int, sev_sThread*> m_thread_list;

  int init(int noneth);
  int connect();
  int request_items(pwr_tNid nid);
  int mainloop();
  int check_histitems(sev_sMsgHistItems* msg, unsigned int size);
  int receive_histdata(
      sev_sMsgHistDataStore* msg, unsigned int size, pwr_tNid nid);
  int send_histdata(
      qcom_sQid tgt, sev_sMsgHistDataGetRequest* msg, unsigned int size);
  int send_objecthistdata(
      qcom_sQid tgt, sev_sMsgHistDataGetRequest* rmsg, unsigned int size);
  static void* send_objecthistdata_thread(void* arg);
  int send_events(qcom_sQid tgt, sev_sMsgEventsGetRequest* rmsg, unsigned int size);
  static void* send_events_thread(void* arg);
  int send_itemlist(qcom_sQid tgt);
  int send_eventsitemlist(qcom_sQid tgt);
  int send_server_status(qcom_sQid tgt);
  int delete_item(qcom_sQid tgt, sev_sMsgHistItemDelete* rmsg);
  int receive_events(
      sev_sMsgEventsStore* msg, unsigned int size, pwr_tNodeId nid);
  void create_garbage_collector_thread();
  static void* garbage_collector_thread(void* arg);
  void garbage_collector(void* thread);
  void garbage_item(void* thread, int idx);
  void set_dbtype(sev_eDbType type)
  {
    m_db_type = type;
  }
  sev_sThread* find_thread(int key);
  static void* receive_histdata_thread(void* arg);
  sev_sThread* create_thread(int key);
  void delete_thread(int key);

  static void* send_histdata_thread(void* arg);
};
#endif
