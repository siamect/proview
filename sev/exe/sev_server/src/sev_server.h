/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2018 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

#ifndef sev_server_h
#define sev_server_h

#include <vector>
#include <map>

#include "pwr.h"
#include "pwr_class.h"
#include "pwr_baseclasses.h"
#include "rt_que.h"
#include "rt_sev_net.h"
#include "sev_db.h"

class sev_server;

class sev_node {
 public:
  pwr_tNodeId 	nid;
  char 		name[80];
};

typedef struct {
  tree_sNode  node;
  pwr_tRefId id;
  int idx;
} sev_sRefid;

typedef struct {
  sev_server *sev;
  qcom_sQid tgt;
  sev_sMsgHistDataGetRequest *rmsg;
  unsigned int size;
  unsigned int item_idx;
} sev_sHistDataThread;

typedef struct {
  int key;
  pthread_t thread;
  que_sQue queue;
  int alloc;
  void *db_ctx;
  int conf_idx;
} sev_sThread;

typedef struct {
  void *ctx;
  sev_sThread *th;
} sev_sReceiveHistDataThread;

typedef enum {
  sev_eQMsgType_HistData,
  sev_eQMsgType_Event
} sev_eQMsgType;

typedef struct {
  sev_eQMsgType type;
  unsigned int version;
  lst_sEntry e;
  int size;  
} sev_sQMsgHeader;

typedef struct {
  sev_sQMsgHeader h;
  net_sTime time;
  char data[1];
} sev_sQMsgHistData;

typedef struct {
  sev_sQMsgHeader h;
  int num_events;
  int item_idx;
  char data[1];
} sev_sQMsgEvent;

typedef map<int, sev_sThread *>::iterator threadlist_iterator;

class sev_server {
 public:

  sev_server() : m_server_status(0), m_refid(0), m_msg_id(0), m_storage_cnt(0), m_write_cnt(0),
    m_total_queue_cnt(0), m_db_type(sev_eDbType_Sqlite), m_config(0), m_thread_cnt(0),  
    m_read_threads(0), m_thread_key_node(0)
    { memset(&m_stat,0,sizeof(m_stat));}

  ~sev_server();
  pwr_tStatus m_sts;
  pwr_tStatus m_server_status;
  vector<sev_node> m_nodes;
  tree_sTable *m_refid;
  thread_sMutex	m_refid_mutex;
  thread_sMutex	m_alloc_mutex;
  unsigned int m_msg_id;
  sev_db *m_db;
  int m_noneth;
  unsigned int m_storage_cnt;
  unsigned int m_write_cnt;
  int m_total_queue_cnt;
  sev_sStat m_stat;
  sev_eDbType m_db_type;
  pwr_sClass_SevServer *m_config;
  unsigned int m_thread_cnt;
  pwr_tDlid m_config_dlid;
  int m_read_threads;
  int m_thread_key_node;
  map<int, sev_sThread *>m_thread_list;

  int init( int noneth);
  int connect();
  int request_items( pwr_tNid nid);
  int mainloop();
  int check_histitems( sev_sMsgHistItems *msg, unsigned int size);
  int receive_histdata( sev_sMsgHistDataStore *msg, unsigned int size, pwr_tNid nid);
  int send_histdata( qcom_sQid tgt, sev_sMsgHistDataGetRequest *msg, unsigned int size);
  int send_objecthistdata( qcom_sQid tgt, sev_sMsgHistDataGetRequest *rmsg, unsigned int size);
  static void *send_objecthistdata_thread( void *arg);
  int send_itemlist( qcom_sQid tgt);
  int send_server_status( qcom_sQid tgt);
  int delete_item( qcom_sQid tgt, sev_sMsgHistItemDelete *rmsg);
  int receive_events( sev_sMsgEventsStore *msg, unsigned int size, pwr_tNodeId nid);
  void create_garbage_collector_thread();
  static void *garbage_collector_thread( void *arg);
  void garbage_collector( void *thread);
  void garbage_item( void *thread, int idx);
  void set_dbtype( sev_eDbType type) { m_db_type = type;}
  sev_sThread *find_thread( int key);
  static void *receive_histdata_thread( void *arg);
  sev_sThread *create_thread( int key);
  void delete_thread( int key);

  static void *send_histdata_thread( void *arg);
};
#endif
