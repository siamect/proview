/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* wb.c -- work bench */

#include <stdlib.h>

#include <iostream>

#include "pwr.h"
#include "co_dcli.h"
#include "co_login_msg.h"
#include "co_msg.h"
#include "co_string.h"

#include "cow_login.h"
#include "cow_msgwindow.h"
#include "cow_xhelp.h"

#include "ge.h"

#include "wb_dblock.h"
#include "wb_dir.h"
#include "wb_env.h"
#include "wb_gre.h"
#include "wb_ldhld.h"
#include "wb_utl_api.h"
#include "wb_volume.h"
#include "wb_vrepdbs.h"
#include "wb_vrepext.h"
#include "wb_vrepmem.h"
#include "wb_vrepwbl.h"

#include "wb_main.h"

Wb* Wb::main_wb = 0;

void Wb::usage()
{
  printf("\n\
Usage: wb [-a][-q][-s][-c][-p] [-l language] [username] [password] [volume]\n\
\n\
  -a    Attach all databases.\n\
  -q    Quiet. Hide license information.\n\
  -s    Open dbs file for volume.\n\
  -c    Start class editor.\n\
  -p    Open project list.\n\
  -l    Language specification, sv_se or en_us.\n\
  -h    Display this help text.\n\
\n");
}

Wb::Wb() : announce(0), appl_count(0)
{
}

Wb::~Wb()
{
}

Wtt* Wb::wtt_new(const char* name, const char* iconname, ldh_tWBContext wbctx,
    pwr_tVolumeId volid, ldh_tVolume volctx, wnav_sStartMenu* root_menu,
    pwr_tStatus* status)
{
  return 0;
}

WVsel* Wb::vsel_new(pwr_tStatus* status, const char* name, ldh_tWBContext wbctx,
    char* volumename, int (*bc_success)(void*, pwr_tVolumeId*, int),
    void (*bc_cancel)(), int (*bc_time_to_exit)(void*), int show_volumes,
    wb_eType wb_type)
{
  return 0;
}

void Wb::wttlist_add(pwr_tStatus* sts, Wtt* wtt, pwr_tVid vid)
{
  wttlist_iterator it = wttlist.find(vid);
  if (it == wttlist.end()) {
    wttlist[vid] = wtt;
    *sts = LDH__SUCCESS;
  } else
    *sts = LDH__VOLIDALREXI;
}

void Wb::wttlist_remove(pwr_tStatus* sts, Wtt* wtt)
{
  for (wttlist_iterator it = wttlist.begin(); it != wttlist.end(); it++) {
    if (it->second == wtt) {
      wttlist.erase(it);
      *sts = LDH__SUCCESS;
      return;
    }
  }
  *sts = LDH__NOSUCHVOL;
}

void Wb::wttlist_find(pwr_tStatus* sts, pwr_tVid vid, Wtt** wtt)
{
  wttlist_iterator it = wttlist.find(vid);
  if (it == wttlist.end()) {
    *sts = LDH__NOSUCHVOL;
    return;
  }
  *sts = LDH__SUCCESS;
  *wtt = it->second;
}

int Wb::psts(unsigned long int sts, FILE* logfile)
{
  char msg[200];

  if (!(sts & 1)) {
    msg_GetMsg(sts, msg, sizeof(msg));

    if (logfile != NULL)
      fprintf(logfile, "%s\n", msg);
    else
      printf("%s\n", msg);
  }
  return sts & 1;
}

void Wb::find_wnav_cb(void* ctx, pwr_tOid oid)
{
  Wb* wb = main_wb;
  char title[80];
  char projectname[80];
  pwr_tStatus sts;
  Wtt* wtt;

  wb->wttlist_find(&sts, oid.vid, &wtt);
  if (ODD(sts)) {
    sts = wtt->find(oid);
    wtt->pop();
  } else {
    utl_get_projectname(projectname);
    strcpy(title, CoLogin::username());
    strcat(title, " on ");
    strcat(title, projectname);

    wtt = wb->wtt_new(title, "Navigator", wb->wbctx, oid.vid, 0, 0, &sts);
    if (ODD(sts)) {
      wb->appl_count++;
      wtt->close_cb = Wb::wtt_close;
      wtt->open_volume_cb = Wb::wtt_open_volume;
      wtt->time_to_exit_cb = Wb::time_to_exit;
      wb->wttlist_add(&sts, wtt, oid.vid);
      sts = wtt->find(oid);
    }
  }
}

void Wb::find_plc_cb(void* ctx, pwr_tOid oid)
{
  Wb* wb = main_wb;
  char title[80];
  char projectname[80];
  pwr_tStatus sts;
  Wtt* wtt;

  wb->wttlist_find(&sts, oid.vid, &wtt);
  if (ODD(sts)) {
    sts = wtt->find_plc(oid);
  } else {
    utl_get_projectname(projectname);
    strcpy(title, CoLogin::username());
    strcat(title, " on ");
    strcat(title, projectname);

    wtt = wb->wtt_new(title, "Navigator", wb->wbctx, oid.vid, 0, 0, &sts);
    if (ODD(sts)) {
      wb->appl_count++;
      wtt->close_cb = Wb::wtt_close;
      wtt->open_volume_cb = Wb::wtt_open_volume;
      wtt->time_to_exit_cb = Wb::time_to_exit;
      wb->wttlist_add(&sts, wtt, oid.vid);
      sts = wtt->find_plc(oid);
    }
  }
}

void Wb::find_ge_cb(void* ctx, char* object, void* utility)
{
  Wb* wb = main_wb;
  pwr_tStatus sts;
  Wtt* wtt;

  for (wttlist_iterator it = wb->wttlist.begin(); it != wb->wttlist.end();
       it++) {
    wtt = it->second;
    sts = wtt->appl.find(wb_eUtility_Ge, utility);
    if (ODD(sts)) {
      ((Ge*)utility)->select_object(object);
      ((Ge*)utility)->pop();
      break;
    }
  }
}

void Wb::login_success(void* ctx)
{
  Wb* wb = main_wb;
  char title[80];
  char systemname[80];
  char systemgroup[80];
  pwr_tStatus sts;
  char msg[80];

  printf("-- Successful login\n");
  sprintf(msg, "User %s logged in", CoLogin::username());
  MsgWindow::message('I', msg);

  /* Successful login, start the volume selection */

  if (CoLogin::privilege() & pwr_mPrv_DevRead) {
    utl_get_systemname(systemname, systemgroup);
    strcpy(title, "PwR Navigator: ");
    strcat(title, CoLogin::username());
    strcat(title, " on ");
    strcat(title, systemname);
    wb->appl_count++;
    wb->vsel_new(&sts, "PwR Volumes", wb->wbctx, NULL, &Wb::vsel_success,
        &Wb::vsel_cancel, &Wb::time_to_exit, 0, wb_eType_Volume);
  } else {
    printf("** Not authorized for development\n");
    exit(LOGIN__NOPRIV);
  }
}

void Wb::wtt_close(void* wttctx)
{
  Wb* wb = main_wb;
  pwr_tStatus sts;

  wb->wttlist_remove(&sts, (Wtt*)wttctx);
  wb->appl_count--;
  if (wb->appl_count == 0) {
    exit(0);
  }
}

int Wb::time_to_exit(void* wttctx)
{
  Wb* wb = main_wb;

  if (wb->appl_count == 1)
    return 1;
  return 0;
}

void Wb::wtt_open_volume(void* wttctx, wb_eType type, const char* filename,
    wow_eFileSelType file_type)
{
  Wb* wb = main_wb;
  char title[80];
  char systemname[80];
  char systemgroup[80];
  pwr_tStatus sts;

  if (CoLogin::privilege() & pwr_mPrv_DevRead
      || CoLogin::privilege() & pwr_mPrv_Administrator) {
    if (!filename) {
      utl_get_systemname(systemname, systemgroup);
      strcpy(title, "PwR Navigator: ");
      strcat(title, CoLogin::username());
      strcat(title, " on ");
      strcat(title, systemname);
      wb->appl_count++;
      wb->vsel_new(&sts, "PwR Volumes", wb->wbctx, NULL, &Wb::vsel_success,
          &Wb::vsel_cancel, &Wb::time_to_exit, 1, type);
    } else {
      // Open the file
      if (file_type == wow_eFileSelType_Wbl) {
        printf("Wb opening wb_load-file %s...\n", filename);

        // Load volume as extern
        wb_erep* erep = (wb_erep*)(*(wb_env*)wb->wbctx);
        wb_vrepwbl* vrep = new wb_vrepwbl(erep);
        sts = vrep->load(filename);
        if (vrep->vid() == 0) {
          delete vrep;
          return;
        }
        erep->addExtern(&sts, vrep);

        // Attach extern volume
        wb_volume* vol = new wb_volume(vrep);
        pwr_tVid volume = vrep->vid();

        Wtt* wtt = wb->wtt_new(
            filename, "Navigator", wb->wbctx, volume, vol, 0, &sts);
        if (ODD(sts)) {
          wb->appl_count++;
          wtt->close_cb = Wb::wtt_close;
          wtt->open_volume_cb = Wb::wtt_open_volume;
          wtt->time_to_exit_cb = Wb::time_to_exit;
        }
      } else if (file_type == wow_eFileSelType_Dbs) {
        printf("Wb opening loadfile %s...\n", filename);

        // Load volume as extern
        wb_erep* erep = (wb_erep*)(*(wb_env*)wb->wbctx);
        wb_vrepdbs* vrep = new wb_vrepdbs(erep, filename);
        try {
          vrep->load();
          erep->addExtern(&sts, vrep);
        } catch (wb_error& e) {
          std::cout << "** Error opening volume, " << e.what() << '\n';
          return;
        }

        // Attach extern volume
        wb_volume* vol = new wb_volume(vrep);
        pwr_tVid volume = vrep->vid();

        Wtt* wtt = wb->wtt_new(
            filename, "Navigator", wb->wbctx, volume, vol, 0, &sts);
        if (ODD(sts)) {
          wb->appl_count++;
          wtt->close_cb = Wb::wtt_close;
          wtt->open_volume_cb = Wb::wtt_open_volume;
          wtt->time_to_exit_cb = Wb::time_to_exit;
        }
      } else if (file_type == wow_eFileSelType_WblClass) {
        printf("Wb opening wb_load-file %s...\n", filename);

        char uname[80];
        if (wb_dblock::is_locked((char*)filename, uname)) {
          char msg[120];

          sprintf(msg, "Classvolume %s is locked by user %s", filename, uname);
          MsgWindow::message('E', msg, msgw_ePop_No);

          if (!MsgWindow::has_window())
            return;

          CoWow* wow = MsgWindow::get_wow();
          int res = wow->CreateModalDialog("Classvolume Locked", msg, "Cancel",
              "Remove lock", 0, "$pwr_exe/wtt_padlock.png");
          switch (res) {
          case wow_eModalDialogReturn_Button1:
          case wow_eModalDialogReturn_Deleted:
            return;
          case wow_eModalDialogReturn_Button2:
            // Remove lock
            wb_dblock::dbunlock((char*)filename);
            break;
          case wow_eModalDialogReturn_NYI:
          case wow_eModalDialogReturn_Button3:
            return;
          }
        }

        // Load volume and import to vrepmem
        wb_erep* erep = (wb_erep*)(*(wb_env*)wb->wbctx);
        wb_vrepmem* mem = new wb_vrepmem(erep, 0);
        mem->loadWbl(filename, &sts);
        if (EVEN(sts)) {
          delete mem;
          if (sts == LDH__OTHERSESS)
            MsgWindow::message(
                'E', "Other class volume is open", msgw_ePop_Yes);
          return;
        }
        erep->addExtern(&sts, mem);

        // Display buffer
        wb_volume* vol = new wb_volume(mem);

        // Display filename i title, without path
        const char* name_p;
        if ((name_p = strrchr(filename, '/')))
          name_p++;
        else
          name_p = (char*)filename;

        Wtt* wtt = wb->wtt_new(
            name_p, "Navigator", wb->wbctx, mem->vid(), vol, 0, &sts);
        if (ODD(sts)) {
          wb->appl_count++;
          wtt->close_cb = Wb::wtt_close;
          wtt->open_volume_cb = Wb::wtt_open_volume;
          wtt->time_to_exit_cb = Wb::time_to_exit;
        }
      } else {
        if (streq(filename, "ProjectList")) {
          // Load ProjectList

          wb_erep* erep = (wb_erep*)(*(wb_env*)wb->wbctx);
          wb_vrepext* ext = new wb_vrepext(
              erep, ldh_cProjectListVolume, filename, filename);
          erep->addExtern(&sts, ext);

          // Display buffer
          wb_volume* vol = new wb_volume(ext);

          Wtt* wtt = wb->wtt_new(
              filename, "Navigator", wb->wbctx, ext->vid(), vol, 0, &sts);
          if (ODD(sts)) {
            wb->appl_count++;
            wtt->close_cb = Wb::wtt_close;
            wtt->open_volume_cb = Wb::wtt_open_volume;
            wtt->time_to_exit_cb = Wb::time_to_exit;
          }
        } else if (streq(filename, "GlobalVolumeList")) {
          // Load GlobalVolumeList

          wb_erep* erep = (wb_erep*)(*(wb_env*)wb->wbctx);
          wb_vrepext* ext = new wb_vrepext(
              erep, ldh_cGlobalVolumeListVolume, filename, filename);
          erep->addExtern(&sts, ext);

          // Display buffer
          wb_volume* vol = new wb_volume(ext);

          Wtt* wtt = wb->wtt_new(
              filename, "Navigator", wb->wbctx, ext->vid(), vol, 0, &sts);
          if (ODD(sts)) {
            wb->appl_count++;
            wtt->close_cb = Wb::wtt_close;
            wtt->open_volume_cb = Wb::wtt_open_volume;
            wtt->time_to_exit_cb = Wb::time_to_exit;
          }
        } else if (streq(filename, "UserDatabase")) {
          // Load UserDatabase

          wb_erep* erep = (wb_erep*)(*(wb_env*)wb->wbctx);
          wb_vrepext* ext = new wb_vrepext(
              erep, ldh_cUserDatabaseVolume, filename, filename);
          erep->addExtern(&sts, ext);

          // Display buffer
          wb_volume* vol = new wb_volume(ext);

          Wtt* wtt = wb->wtt_new(
              filename, "Navigator", wb->wbctx, ext->vid(), vol, 0, &sts);
          if (ODD(sts)) {
            wb->appl_count++;
            wtt->close_cb = Wb::wtt_close;
            wtt->open_volume_cb = Wb::wtt_open_volume;
            wtt->time_to_exit_cb = Wb::time_to_exit;
          }
        } else
          printf("Unknown file\n");
      }
    }

  } else {
    printf("No privileges to enter development environment");
    if (wb->appl_count == 0)
      exit(LOGIN__NOPRIV);
  }
}

int Wb::vsel_success(void* vselctx, pwr_tVolumeId* volumelist, int volume_count)
{
  Wb* wb = main_wb;
  char projectname[80];
  char title[80];
  pwr_tVolumeId volume;
  int i;
  Wtt* wtt;
  int sts;
  pwr_tStatus status;

  sts = 1;
  if (CoLogin::privilege() & pwr_mPrv_DevRead) {
    for (i = 0; i < volume_count; i++) {
      volume = *volumelist++;
      utl_get_projectname(projectname);
      strcpy(title, CoLogin::username());
      strcat(title, " on ");
      strcat(title, projectname);
      wtt = wb->wtt_new(title, "Navigator", wb->wbctx, volume, 0, 0, &status);
      if (ODD(status)) {
        wb->appl_count++;
        wtt->close_cb = Wb::wtt_close;
        wtt->open_volume_cb = Wb::wtt_open_volume;
        wtt->time_to_exit_cb = Wb::time_to_exit;
        wb->wttlist_add(&sts, wtt, volume);
      } else
        sts = status;
    }
  } else {
    exit(LOGIN__NOPRIV);
  }
  if (ODD(sts) && wb->appl_count == 0)
    exit(0);

  return sts;
}

void Wb::vsel_cancel()
{
  Wb* wb = main_wb;

  wb->appl_count--;
  if (wb->appl_count == 0) {
    exit(0);
  }
}

void Wb::login_cancel(void* ctx)
{
  printf("-- Login canceled\n");
  /* Not successful login, exit */
  exit(LOGIN__AUTHFAIL);
}
