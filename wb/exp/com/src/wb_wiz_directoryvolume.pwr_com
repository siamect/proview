!** Description: Initial configuration of directory volume
# 
# ProviewR   Open Source Process Control.
# Copyright (C) 2005-2021 SSAB EMEA AB.
#
# This file is part of ProviewR.
#
#  This program is free software; you can redistribute it and/or 
#  modify it under the terms of the GNU General Public License as 
#  published by the Free Software Foundation, either version 2 of 
#  the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful 
#  but WITHOUT ANY WARRANTY; without even the implied warranty of 
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License 
# along with ProviewR. If not, see <http://www.gnu.org/licenses/>
#
# Linking ProviewR statically or dynamically with other modules is
# making a combined work based on ProviewR. Thus, the terms and
# conditions of the GNU General Public License cover the whole 
# combination.
#
# In addition, as a special exception, the copyright holders of
# ProviewR give you permission to, from the build function in the
# ProviewR Configurator, combine ProviewR with modules generated by the
# ProviewR PLC Editor to a PLC program, regardless of the license
# terms of these modules. You may copy and distribute the resulting
# combined work under the terms of your choice, provided that every 
# copy of the combined work is accompanied by a complete copy of 
# the source code of ProviewR (the version used to produce the
# combined work), being distributed under the terms of the GNU 
# General Public License plus this exception.
#

#
# Get volumes registred in pwr_volumelist.dat
#
function string getnextvol( string prev, string project)
  int vlist;
  string line;
  string proj;
  string vol;
  string vollow;
  int prev_found;
  int found;

  project = tolower( project);
  if ( prev == "")
    prev_found = 1;
  else
    prev = tolower(prev);
    prev_found = 0;
  endif

  vol = "";
  found = 0;
  vlist = fopen("$pwra_db/pwr_volumelist.dat", "r");
  while( fgets( line, vlist))
    line = edit( line);
    proj = element(3, " ", line);
    proj = tolower( proj);
    if ( proj == project)
      vol = element(1, " ", line);
      if ( !prev_found)
        vollow = tolower(vol);        
        if ( vollow == prev)
          prev_found = 1;
        endif
      else
        found = 1;
        break;
      endif
    endif
  endwhile

  fclose( vlist);
  if ( found )
    return vol;
  endif
  return "";
endfunction

#
# Main script
#
main()
  extern string pwr_wizard_title = "Configure Directory Volume";
  extern string dv_system_name;
  extern string dv_system_group;
  extern int dv_prd_qbus;
  extern int dv_sim_qbus;
  extern int dv_quit = 0;
  extern int dv_prev = 0;
  extern string dv_volumes[40];
  extern int dv_cvol_sel[40];
  extern int dv_vol_class[40];
  extern int dv_volume_found[40];
  extern int dv_node_busid;
  extern string dv_node_name;
  extern string dv_node_ip;
  extern string dv_node_description;
  extern string dv_node_rootvolume;
  extern string dv_addvol[40];
  extern int dv_addvol_sel[40];
  extern int dv_addvol_occ[40];
  extern int dv_node_skip;
  extern int dv_node_skip_inv;
  extern int dv_node_disdistr;
  extern int dv_node_distr[15];
  extern string dv_default_vname;
  extern string dv_default_vid;
  extern string dv_error_message;
  extern int dv_nomorereg;
  extern string dv_open_volume;

  string dv_vid[40];
  string project;
  string vol;
  int volcnt;
  string rootvolumes[40];
  int rvolcnt;
  int i;
  int j;
  int k;
  int ix;
  int addvolcnt;
  int addvol_class[40];
  string node_name[40];
  string node_ip[40];
  string node_description[40];
  string node_rootvolume[40];
  int node_busid[40];
  int node_disdistr[40];
  int node_distr[40];
  int node_addvol_sel[400];
  int nodecnt;
  string prd_bus_name;
  string sim_bus_name;
  string classname;
  string name;
  string attr;
  int sts;
  int fp;
  string dvname1;
  string dvname2;
  string cmd;
  int add_vid;
  string vid0;
  string vid1;
  string vid2;
  string vid3;
  int ivid0;
  int ivid1;
  int ivid2;
  int ivid3;
  int vid;
  int first_reg = 1;
  int first_sim = 1;
  string tmp_fname="$pwrp_tmp/wtmp.txt";
  int found;
  string oname;	
  string hw;
  string os;
  string localscript;

  verify(0);

  dv_system_group = get_pwr_config( "defaultSystemGroup");
  dv_prd_qbus = get_pwr_config( "defaultProductionQbus");
  dv_sim_qbus = get_pwr_config( "defaultSimulationQbus");

  hw = GetHardware();
  os = GetOpSys();

  if ( ! EditMode())
    MessageDialog("Error", "Enter edit mode before starting wizard");
    goto exit_now;
  endif

  project = GetProjectName();
  if ( project == "")
    MessageDialog("Error", "Can't get project name, wizard aborted");
    goto_exit_now;
  endif   

  dv_system_name = project;

  OpenGraph( "$pwr_exe/wb_wizard_frame", 0, pwr_wizard_title);

page_1:
  # System/Busid page
  SetSubwindow( "wb_wizard_frame", "wizwin", "$pwr_exe/wb_wiz_directoryvolume_1", 1);
  if ( dv_quit)
    goto exit_now;
  endif

  # Check that system group exists
  if ( ! CheckSystemGroup( dv_system_group))
    MessageDialog("Error", "System Group not found");
    goto page_1;
  endif
    
  # Get registred volumes for this system
  for ( i = 0; i < 40; i++)
    dv_volume_found[i] = 0;
  endfor
  volcnt = 0;
  vol = "";
  vol = getnextvol( "", dv_system_name);
  while( vol != "")
    dv_volumes[volcnt] = vol;
    dv_volume_found[volcnt] = 1;
    if ( extract(1, 4, vol) == "CVol")
      dv_vol_class[volcnt] = 4;
    endif
    volcnt++;
    vol = getnextvol( vol, dv_system_name);
  endwhile

  # If no volumes are registred, register a volume
page_2:
  if ( !volcnt)
page_2aa:
    if ( first_reg)
      dvname1 = extract( 1, 1, dv_system_name);
      dvname2 = extract( 2, 80, dv_system_name);
      dv_default_vname = "Vol" + toupper( dvname1) + dvname2; 
      dv_default_vid = GetNextFreeUserVid();
    else
      dv_default_vname = "";
      vid++;
      dv_default_vid = GetNextFreeUserVid( vid);
    endif

    if ( dv_default_vid == "")
      SetSubwindow( "wb_wizard_frame", "wizwin", "$pwr_exe/wb_wiz_directoryvolume_2", 1);
      goto exit_now;
    endif

page_2a:
    SetSubwindow( "wb_wizard_frame", "wizwin", "$pwr_exe/wb_wiz_directoryvolume_6", 1);
    if ( dv_quit)
      goto exit_now;
    endif
    if ( dv_prev)
      dv_prev = 0;
      volcnt = 0;
      first_reg = 1;
      for ( i = 0; i < volcnt; i++)
        dv_volume_found[i] = 0;
      endfor
      goto page_1;
    endif

    dv_default_vid = edit( dv_default_vid);
    dv_default_vname = edit( dv_default_vname);

    # Check values
    vid3 = element( 1, ".", dv_default_vid);
    vid2 = element( 2, ".", dv_default_vid);
    vid1 = element( 3, ".", dv_default_vid);
    vid0 = element( 4, ".", dv_default_vid);
    if ( vid0 == "" || vid1 == "" || vid2 == "" || vid3 == "")
      dv_error_message = dv_default_vid + " is not a valid volume identity";
      SetSubwindow( "wb_wizard_frame", "wizwin", "$pwr_exe/wb_wiz_directoryvolume_7", 1);
      if ( dv_prev)
        dv_prev = 0;
        goto page_2a;
      else
        goto exit_now;
      endif
    endif

    ivid0 = vid0;
    ivid1 = vid1;
    ivid2 = vid2;
    ivid3 = vid3;
    vid = ivid0 + ivid1 * 256 + ivid2 * 65536 + ivid3 * 16777216;

    if ( vid < 65793 || vid > 16711422 || ivid3 != 0 || ivid2 > 254 || ivid1 > 254 || ivid0 > 254)
      dv_error_message = dv_default_vid + " is not a valid volume identity";
      SetSubwindow( "wb_wizard_frame", "wizwin", "$pwr_exe/wb_wiz_directoryvolume_7", 1);
      if ( dv_prev)
        dv_prev = 0;
        goto page_2a;
      else
        goto exit_now;
      endif
    endif

    if ( dv_default_vname == "")
      dv_error_message = "Volume name is missing";
      SetSubwindow( "wb_wizard_frame", "wizwin", "$pwr_exe/wb_wiz_directoryvolume_7", 1);
      if ( dv_prev)
        dv_prev = 0;
        goto page_2a;
      else
        goto exit_now;
      endif
    endif

    sts = CheckNewVid( vid);
    if ( sts == 0)
      dv_error_message = "Volume identity already exist in Global Volume List";
      SetSubwindow( "wb_wizard_frame", "wizwin", "$pwr_exe/wb_wiz_directoryvolume_7", 1);
      if ( dv_prev)
        dv_prev = 0;
        goto page_2a;
      else
        goto exit_now;
      endif
    endif

    sts = CheckNewVolumeName( dv_default_vname);
    if ( sts == 0)
      dv_error_message = "Volume name already exist in Global Volume List";
      SetSubwindow( "wb_wizard_frame", "wizwin", "$pwr_exe/wb_wiz_directoryvolume_7", 1);
      if ( dv_prev)
        dv_prev = 0;
        goto page_2a;
      else
        goto exit_now;
      endif
    endif


    add_vid = 1;
    dv_volumes[volcnt] = dv_default_vname;
    dv_vid[volcnt] = dv_default_vid;
    dv_volume_found[volcnt] = 1;
    volcnt++;
    first_reg = 0;

    SetSubwindow( "wb_wizard_frame", "wizwin", "$pwr_exe/wb_wiz_directoryvolume_9", 1);
    if ( dv_nomorereg)
      dv_nomorereg = 0;
      goto page_3;
    endif	

    goto page_2aa;
  endif

page_3:
  # Volume page
  SetSubwindow( "wb_wizard_frame", "wizwin", "$pwr_exe/wb_wiz_directoryvolume_3", 1);
  if ( dv_quit)
    goto exit_now;
  endif
  if ( dv_prev)
    dv_prev = 0;
    volcnt = 0;
    first_reg = 1;
    for ( i = 0; i < volcnt; i++)
      dv_volume_found[i] = 0;
    endfor
    goto page_1;
  endif

  rvolcnt = 0;
  for ( i = 0; i < volcnt; i++)
    if ( dv_vol_class[i] == 0)
      rootvolumes[rvolcnt] = dv_volumes[i];
      rvolcnt++;
    endif
  endfor

  # Find additional volumes (class, sub or shared)
  addvolcnt = 0;
  for ( j = 0; j < 40; j++)
    dv_addvol_occ[j] = 0;
  endfor
  for ( j = 0; j < volcnt; j++)
    if ( dv_vol_class[j] == 1 || dv_vol_class[j] == 2 || dv_vol_class[j] == 4)
      dv_addvol[addvolcnt] = dv_volumes[j];
      addvol_class[addvolcnt] = dv_vol_class[j];
      dv_addvol_sel[addvolcnt] = 0;
      dv_addvol_occ[addvolcnt] = 1;
      addvolcnt++;
    endif
  endfor

  nodecnt = 0;
  for ( k = 0; k < 2; k++)
    if ( k == 0)
      dv_node_busid = dv_prd_qbus;
      dv_node_skip_inv = 1;
    else
      dv_node_busid = dv_sim_qbus;
      dv_node_skip_inv = 0;
    endif

    for ( i = 0; i < rvolcnt; i++)
      if ( first_sim && !dv_node_skip_inv)
        dv_node_name = get_node_name();
        first_sim = 0;
      else
        dv_node_name = tolower( rootvolumes[i]);
        if ( extract( 1, 3, dv_node_name) == "vol")
          dv_node_name = extract( 4, 100, dv_node_name);
        endif
      endif
      if ( !dv_node_skip_inv)
        dv_node_ip = "127.0.0.1";
      else
        dv_node_ip = "0.0.0.0";
      endif
      dv_node_description = "";
      dv_node_rootvolume = rootvolumes[i];
      for ( j = 0; j < addvolcnt; j++)
	if ( addvol_class[j] == 2)
          dv_addvol_sel[j] = 1;
        else
          dv_addvol_sel[j] = 0;
        endif
      endfor
      for ( j = 0; j < 12; j++)
        dv_node_distr[j] = 1;
      endfor
      dv_node_distr[12] = 0;
      dv_node_disdistr = 0;

page_4:
      # Node page
      SetSubwindow( "wb_wizard_frame", "wizwin", "$pwr_exe/wb_wiz_directoryvolume_4", 1);
      if ( dv_quit)
        goto exit_now;
      endif
      if ( dv_node_skip)
        dv_node_skip = 0;
        first_sim = 0;
        continue;
      endif
      if ( dv_prev)
        dv_prev = 0;
        if ( i == 0)
	  if ( k == 1)
            first_sim = 1;
          endif
          goto page_3;
        endif
        # Display data for previous node
        i -= 1;
	# k = node_busid[i];
        dv_node_name = node_name[i];
        dv_node_ip = node_ip[i];
	dv_node_description = node_description[i];
        dv_node_rootvolume = rootvolumes[i];
        addvolcnt = 0;
        for ( j = 0; j < 13; j++)
          if ( node_distr[i] & (1 << j))
            dv_node_distr[j] = 1;
          else
            dv_node_distr[j] = 0;
          endif
        endfor
        for ( j = 0; j < addvolcnt; j++)
          ix = i * 40 + j;
          dv_addvol_sel[j] = node_addvol_sel[ix];
        endfor
        dv_node_disdistr = node_disdistr[i];
	if ( k == 0)
          dv_node_busid = dv_prd_qbus;
        else
          dv_node_busid = dv_sim_qbus;
        endif
        goto page_4;
      endif
    
      # Store data for current node
      node_name[nodecnt] = dv_node_name;
      node_description[nodecnt] = dv_node_description;
      node_ip[nodecnt] = dv_node_ip;
      node_rootvolume[nodecnt] = dv_node_rootvolume;
      node_disdistr[nodecnt] = dv_node_disdistr;
      node_distr[nodecnt] = 0;
      node_busid[nodecnt] = k;
      for ( j = 0; j < 13; j++)
        if ( dv_node_distr[j])
          node_distr[nodecnt] = node_distr[nodecnt] | (1 << j);
        endif
      endfor
      for ( j = 0; j < addvolcnt; j++)
        ix = nodecnt * 40 + j;
        node_addvol_sel[ix] = dv_addvol_sel[j];
      endfor
      nodecnt++;
    endfor
  endfor

  SetSubwindow( "wb_wizard_frame", "wizwin", "$pwr_exe/wb_wiz_directoryvolume_5", 1);
  if ( dv_quit)
    goto exit_now;
  endif

  # Add volume to global volumelist
  if ( add_vid)
    fp = fopen( tmp_fname, "w");
    for ( i = 0; i < volcnt; i++)
      fprintf( fp, " %s     %s      %s\n", dv_volumes[i], dv_vid[i], dv_system_name);
    endfor
    fclose( fp);

    cmd = "cat " + tmp_fname + " >> $pwra_db/pwr_volumelist.dat";
    system( cmd);
    cmd = "rm " + tmp_fname;
    system( cmd);
  endif

  # Create system object
  create object /dest=""/class=$System /name="System" /last
  SetAttribute( "System.SystemName", dv_system_name);
  SetAttribute( "System.SystemGroup", dv_system_group);

  # Create volume config objects
  for ( i = 0; i < volcnt; i++)
    if ( dv_vol_class[i] == 0)
      classname = "RootVolumeConfig";
    endif
    if ( dv_vol_class[i] == 1)
      classname = "SubVolumeConfig";
    endif
    if ( dv_vol_class[i] == 2)
      classname = "SharedVolumeConfig";
    endif
    if ( dv_vol_class[i] == 3)
      # Dynamic volume is not configured
      continue;
    endif
    if ( dv_vol_class[i] == 4)
      classname = "ClassVolumeConfig";
    endif
    create object /dest=""/class='classname' /name="'dv_volumes[i]'" /last
  endfor

  # Create bus config objects
  prd_bus_name = "Prd" + dv_prd_qbus;
  create object /dest=""/class=BusConfig /name="'prd_bus_name'" /last
  attr = prd_bus_name + ".BusNumber";
  SetAttribute( attr, dv_prd_qbus);

  sim_bus_name = "Sim" + dv_sim_qbus;
  create object /dest=""/class=BusConfig /name="'sim_bus_name'" /last
  attr = sim_bus_name + ".BusNumber";
  SetAttribute( attr, dv_sim_qbus);

  # Create node config objects
  for ( i = 0; i < nodecnt; i++)
    if ( node_busid[i] == 0)
      oname = StringToObjectName( node_name[i]);
      create object /class=NodeConfig /dest='prd_bus_name' /name="'oname'" /last
      name = prd_bus_name + "-" + oname;
    else
      oname = StringToObjectName( node_name[i]);
      create object /class=NodeConfig /dest='sim_bus_name' /name="'oname'" /last
      name = sim_bus_name + "-" + oname;
    endif
    attr = name + ".Description";
    SetAttribute( attr, node_description[i]);
    attr = name + ".NodeName";
    SetAttribute( attr, node_name[i]);
    attr = name + ".OperatingSystem";

    if ( os == "Linux")
      if ( hw == "x86_64")
        SetAttribute( attr, 128);
      else
        if ( hw == "ARM")
          SetAttribute( attr, 512);
        else
          SetAttribute( attr, 64);
        endif
      endif
    endif
    if ( os == "MacOS")
      SetAttribute( attr, 256);
    endif
    if ( os == "ARM")
      SetAttribute( attr, 512);
    endif
    if ( os == "FreeBSD")
      SetAttribute( attr, 1024);
    endif
    if ( os == "OpenBSD")
      SetAttribute( attr, 2048);
    endif
    if ( os == "Cygwin")
      SetAttribute( attr, 4096);
    endif
  
    attr = name + ".Address";
    SetAttribute( attr, node_ip[i]);
    if ( !node_disdistr[i])
      attr = name + ".BootNode";
      SetAttribute( attr, node_name[i]);
    else	
      attr = name + ".DistributeDisable";
      SetAttribute( attr, 1);
    endif

    attr = name + "-Distribute.Components";
    SetAttribute( attr, node_distr[i]);

    attr = GetChild( name);
    move object/source='attr'/rename="'node_rootvolume[i]'"
    name = name + "-" + node_rootvolume[i];
    for ( j = 0; j < addvolcnt; j++)
      ix = i * 40 + j;
      if ( node_addvol_sel[ix])
        if ( addvol_class[j] == 1)
          classname = "SubVolumeLoad";
        endif
        if ( addvol_class[j] == 2)
          classname = "SharedVolumeLoad";
        endif
        if ( dv_vol_class[j] == 4)
          classname = "ClassVolumeLoad";
       endif
        create object /class='classname' /dest='name' /name="'dv_addvol[j]'"/after
      endif
    endfor
  endfor

  # Create BuildConfig objects
  create object /dest=""/class=BuildConfig /name="Build" /last

  create object /dest="Build"/class=BuildDirectory /name="pop" /first
  name = "Build-pop";
  attr = name + ".Directory";
  SetAttribute( attr, "$pwrp_pop");
  attr = name + ".Options";
  SetAttribute( attr, 1);

  create object /dest="Build-pop"/class=BuildCopy /name="pwg" /first
  name = "Build-pop-pwg";
  attr = name + ".Source";
  SetAttribute( attr, "*.pwg");
  attr = name + ".Target";
  SetAttribute( attr, "$pwrp_exe/,$pwrp_web/");

  save/quiet

  # Call local script
  localscript = translate_filename( "$pwr_directoryvolume_setup");
  if ( localscript != "")
    @'localscript'
  endif

  noedit

  found = 0;
  for ( i = 0; i < volcnt; i++)
    if ( dv_vol_class[i] == 0)
      dv_open_volume = dv_volumes[i];
      found = 1;
      break;
    endif
  endfor

  if ( !found)
    goto exit_now;
  endif
   
  SetSubwindow( "wb_wizard_frame", "wizwin", "$pwr_exe/wb_wiz_directoryvolume_8", 1);
  if ( dv_quit)
    goto exit_now;
  endif
  open database/volume='dv_open_volume'
  
exit_now:
  CloseGraph("wb_wizard_frame");
  delete dv_quit;
  delete dv_prev;
  delete dv_system_name;
  delete dv_system_group;
  delete dv_prd_qbus;
  delete dv_sim_qbus;
  delete pwr_wizard_title;
  delete dv_volumes[40];
  delete dv_cvol_sel[40];
  delete dv_vol_class[40];
  delete dv_volume_found[40];
  delete dv_node_busid;
  delete dv_node_name;
  delete dv_node_ip;
  delete dv_node_description;
  delete dv_node_rootvolume;
  delete dv_addvol[40];
  delete dv_addvol_sel[40];
  delete dv_addvol_occ[40];
  delete dv_node_skip;
  delete dv_node_skip_inv;
  delete dv_node_disdistr;
  delete dv_node_distr[15];
  delete dv_default_vname;
  delete dv_default_vid;
  delete dv_error_message;
  delete dv_nomorereg;

endmain




