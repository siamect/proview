/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* wb_lfu.cpp -- load file utitities
   Utitlites to handle loadfiles, bootfiles, volumelists etc */

#include <stdlib.h>

#include "pwr_names.h"

#include "co_cnf.h"
#include "co_dbs.h"
#include "co_dcli.h"
#include "co_string.h"
#include "co_time.h"

#include "rt_load.h"

#include "cow_msgwindow.h"

#include "wb_build.h"
#include "wb_dir.h"
#include "wb_env.h"
#include "wb_foe_msg.h"
#include "wb_gcg.h"
#include "wb_lfu.h"
#include "wb_lfu_msg.h"
#include "wb_revision.h"
#include "wb_trv.h"
#include "wb_utl_api.h"
#include "wb_vrepdb.h"

#define LFU_MAX_NODE_VOLUMES 100
#define LFU_MAX_VOLREF 40

lfu_volume_info::lfu_volume_info() : vid(0), cid(0), volrep(ldh_eVolRep_Db)
{
  strcpy(name, "");
  strcpy(server, "");
}

lfu_volume_info::lfu_volume_info(const lfu_volume_info& x)
    : vid(x.vid), cid(x.cid), volrep(x.volrep)
{
  strncpy(name, x.name, sizeof(name));
  strncpy(server, x.server, sizeof(server));
}

lfu_boot_info::lfu_boot_info() : vid(0), bus(0), opsys(0), number(0)
{
  strcpy(node_name, "");
  strcpy(node_text, "");
  strcpy(volume_name, "");
}

lfu_boot_info::lfu_boot_info(const lfu_boot_info& x)
    : vid(x.vid), bus(x.bus), opsys(x.opsys), number(x.number)
{
  strncpy(node_name, x.node_name, sizeof(node_name));
  strncpy(node_text, x.node_text, sizeof(node_text));
  strncpy(volume_name, x.volume_name, sizeof(volume_name));
}

class lfu_nodeconf {
public:
  lfu_nodeconf()
      : isfriend(0), port(0), vid(0), connection(0), qcom_min_resend_time(0),
        qcom_max_resend_time(0), has_secondary(0), redcom_port(0),
        redcom_min_resend_time(0), redcom_max_resend_time(0),
        redcom_export_buf_quota(0), redcom_ack_delay(0), redcom_segment_size(0)
  {
    strcpy(address, "");
    strcpy(nodename, "");
    strcpy(secondary_nodename, "");
    strcpy(secondary_address, "");
  }
  int isfriend;
  pwr_tOid oid;
  pwr_tEnum operatingsystem;
  pwr_tString80 nodename;
  pwr_tString80 address;
  pwr_tUInt32 port;
  pwr_tVid vid;
  pwr_tEnum connection;
  pwr_tFloat32 qcom_min_resend_time;
  pwr_tFloat32 qcom_max_resend_time;
  pwr_tUInt32 qcom_export_buf_quota;
  pwr_tFloat32 qcom_ack_delay;
  pwr_tUInt32 qcom_segment_size;
  int has_secondary;
  pwr_tString80 secondary_nodename;
  pwr_tString80 secondary_address;
  pwr_tUInt32 redcom_port;
  pwr_tFloat32 redcom_min_resend_time;
  pwr_tFloat32 redcom_max_resend_time;
  pwr_tUInt32 redcom_export_buf_quota;
  pwr_tFloat32 redcom_ack_delay;
  pwr_tUInt32 redcom_segment_size;
};

typedef struct {
  char name[32];
  pwr_tVid vid;
  pwr_tCid cid;
  ldh_eVolRep volrep;
  char server[80];
  ldh_tSesContext ldhses;
} lfu_sCreaDb;

static void lfu_creadb_qb_yes(void* ctx, void* data);

pwr_tStatus lfu_volumelist_load(
    const char* filename, lfu_t_volumelist** vollist, int* volcount)
{
  FILE* file;
  char line[200];
  char param[8][40];
  int nr;
  int line_count;
  int list_alloc;
  lfu_t_volumelist* list = NULL;
  lfu_t_volumelist* list_ptr;
  int sts;
  int count;
  int syntax_error;
  char fname[120];

  syntax_error = 0;
  dcli_translate_filename(fname, filename);
  file = fopen(fname, "r");
  if (!file) {
    printf("-- Error, unable to open file \"%s\"\n", fname);
    *volcount = 0;
    return LFU__NOFILE;
  }

  list_alloc = 0;
  line_count = 0;
  count = 0;
  while (ODD(sts = utl_read_line(line, sizeof(line), file, &line_count))) {
    nr = utl_parse(line, " 	", "", (char*)param,
        sizeof(param) / sizeof(param[0]), sizeof(param[0]));
    if (nr < 3) {
      printf("-- Syntax error in file '%s' line %d, \n", filename, line_count);
      printf("        \"%s\"\n", line);
      count++;
      syntax_error = 1;
      continue;
    }
    utl_realloc_s((char**)&list, count, sizeof(*list), &list_alloc);
    list_ptr = list + count;
    strcpy(list_ptr->volume_name, param[0]);
    if (nr > 2)
      strcpy(list_ptr->p1, param[2]);
    else
      strcpy(list_ptr->p1, "");
    if (nr > 3)
      strcpy(list_ptr->p2, param[3]);
    else
      strcpy(list_ptr->p2, "");
    if (nr > 4)
      strcpy(list_ptr->p3, param[4]);
    else
      strcpy(list_ptr->p3, "");
    if (nr > 5)
      strcpy(list_ptr->p4, param[5]);
    else
      strcpy(list_ptr->p4, "");
    if (nr > 6)
      strcpy(list_ptr->p5, param[6]);
    else
      strcpy(list_ptr->p5, "");
    if (nr > 7)
      strcpy(list_ptr->p6, param[7]);
    else
      strcpy(list_ptr->p6, "");
    sts = cdh_StringToVolumeId(param[1], &list_ptr->volume_id);
    if (EVEN(sts)) {
      printf("-- Syntax error in file '%s' line %d, \n", filename, line_count);
      printf("        \"%s\"\n", line);
      count++;
      syntax_error = 1;
      continue;
    }
    count++;
  }
  fclose(file);

  *vollist = list;
  *volcount = count;
  if (syntax_error)
    return LFU__VOLLIST;
  else
    return LFU__SUCCESS;
}

/************************************************************************
*
* Name: 	lfu_create_loadfile
*
* Type:	void
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Create loadfile for a volume.
*
*************************************************************************/
pwr_tStatus lfu_create_loadfile(ldh_tSesContext ldhses)
{
  pwr_tStatus sts;
  pwr_tClassId cid;
  ldh_sVolumeInfo volinfo;

  sts = ldh_GetVolumeInfo(ldh_SessionToVol(ldhses), &volinfo);
  if (EVEN(sts))
    return sts;

  sts = ldh_GetVolumeClass(ldh_SessionToWB(ldhses), volinfo.Volume, &cid);

  if (cid == pwr_eClass_RootVolume || cid == pwr_eClass_SubVolume) {
    sts = gcg_comp_volume(ldhses);
    if (EVEN(sts))
      return sts;
  }

  return LFU__SUCCESS;
}

/************************************************************************
*
* Name: 	lfu_create_bootfile
*
* Type:	void
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Create bootfile for one node.
*
*************************************************************************/
pwr_tStatus lfu_create_bootfile(char* nodeconfigname, int nodetype,
    lfu_t_volumelist* volumelist, int volumecount, int debug)
{
  int i, j;
  FILE* file;
  lfu_t_volumelist* volumelist_ptr;
  lfu_t_volumelist* first_volumelist_ptr;
  pwr_tString40 nodename;
  pwr_tStatus sts;
  char filename[120];
  pwr_tUInt32 bus;
  pwr_tVolumeId node_vollist[LFU_MAX_NODE_VOLUMES];
  int node_vollist_count;
  pwr_mOpSys os;
  unsigned long errorcount;
  unsigned long warningcount;
  pwr_tFloat32 single_scantime;
  char nodeconfigname_upper[80];
  char vollistname_upper[80];
  char systemname[80];
  char systemgroup[80];
  char timstr[32];
  gcg_t_plcproclist* plcproclist;
  unsigned long plcproc_count;
  int noplc;
  char plcname[80];

  volumelist_ptr = volumelist;
  utl_toupper(nodeconfigname_upper, nodeconfigname);
  for (j = 0; j < volumecount; j++) {
    utl_toupper(vollistname_upper, volumelist_ptr->p1);
    if (!strcmp(nodeconfigname_upper, vollistname_upper)) {
      strcpy(nodename, volumelist_ptr->p2);
      sscanf(volumelist_ptr->p3, "%d", &bus);
      sscanf(volumelist_ptr->p4, "%d", (int*)&os);
      sscanf(volumelist_ptr->p5, "%f", &single_scantime);

      node_vollist_count = 0;
      first_volumelist_ptr = volumelist_ptr;

      while (!strcmp(nodeconfigname_upper, vollistname_upper)) {
        if (node_vollist_count < LFU_MAX_NODE_VOLUMES) {
          node_vollist[node_vollist_count] = volumelist_ptr->volume_id;
          node_vollist_count++;
        } else {
          printf("** Error, max number of volumes exceeded\n");
          return LFU__NOFILE;
        }
        volumelist_ptr++;
        utl_toupper(vollistname_upper, volumelist_ptr->p1);
      }

      /* Get data for plc and print volumes on terminal */
      printf("-- Creating bootfile for node %s\n", nodename);

      sts = gcg_comp_rtnode(nodename, os, bus, 1, &errorcount, &warningcount,
          debug, node_vollist, node_vollist_count, 0, single_scantime);
      if (EVEN(sts))
        return sts;
      if (sts == GSX__NOPLC)
        noplc = 1;
      else
        noplc = 0;

      /* Open the file and print boot data */
      sprintf(filename, pwr_cNameBoot, load_cDirectory, cdh_Low(nodename), bus);
      dcli_translate_filename(filename, filename);
      file = fopen(filename, "w");
      if (!file) {
        printf("** Error, Unable to open bootfile, %s", filename);
        return LFU__NOFILE;
      }

      time_AtoAscii(NULL, time_eFormat_DateAndTime, timstr, sizeof(timstr));
      fprintf(file, "%s\n", timstr);

      sts = lfu_ReadSysObjectFile(systemname, systemgroup);
      if (EVEN(sts)) {
        fprintf(file, "\n");
        fprintf(file, "\n");
      } else {
        fprintf(file, "%s\n", systemname);
        fprintf(file, "%s\n", systemgroup);
      }

      plcproc_count = 0;
      gcg_read_volume_plclist(first_volumelist_ptr->volume_id, 0, 0, 0, 0,
          &plcproc_count, &plcproclist);

      if (noplc || plcproc_count == 0)
        fprintf(file, "-\n");
      else {
        for (i = 0; i < (int)plcproc_count; i++) {
          if (i != 0)
            fprintf(file, ",");
          strncpy(plcname, cdh_Low(plcproclist[i].name), sizeof(plcname));
          fprintf(file, pwr_cNamePlc, "", cdh_Low(nodename), bus, plcname);
        }
        fprintf(file, "\n");
      }
      node_vollist_count = 0;
      volumelist_ptr = first_volumelist_ptr;
      utl_toupper(vollistname_upper, volumelist_ptr->p1);
      while (!strcmp(nodeconfigname_upper, vollistname_upper)) {
        fprintf(file, "%s %s\n", volumelist_ptr->volume_name,
            cdh_VolumeIdToString(0, 0, volumelist_ptr->volume_id, 0, 0));
        volumelist_ptr++;
        utl_toupper(vollistname_upper, volumelist_ptr->p1);
      }

      if (nodetype == bld_eNodeType_Sev) {
        fprintf(file, "pwrs 0.0.0.1\n");
        fprintf(file, "pwrb 0.0.0.2\n");
      }

      fclose(file);

      break;
    }
    volumelist_ptr++;
  }
  return LFU__SUCCESS;
}

/*************************************************************************
*
* Name:		lfu_GetPlcFileVersion
*
* Type		pwr_tStatus
*
* Description:
*	Find the highest version of a plc-file.
*
* Parameters
*
**************************************************************************/
pwr_tStatus lfu_GetPlcFileVersion(
    pwr_tVolumeId volumeid, int* version, pwr_tTime* date)
{
  pwr_tStatus sts;
  char filename[80];
  unsigned char volid[4];

  memcpy(&volid, &volumeid, sizeof(volid));
  sprintf(filename, "pwrp_load:plc_%3.3u_%3.3u_%3.3u_%3.3u_*.exe", volid[3],
      volid[2], volid[1], volid[0]);
  sts = lfu_GetFileVersion(filename, 5, version, date);
  return sts;
}

/*************************************************************************
*
* Name:		lfu_GetFileVersion
*
* Type		pwr_tStatus
*
* Description:
*		Finds the highest version for a file, and returns
*		proview-version and date for this file.
*		Filename is given as a pattern, and the version
*		has to be in the filename befor the extention
*		with the number of digits given in num_of_digits.
*		ex "pwrp_load:ld_vol_000_000_001_001_%%%%%.dat.0"
*
* Parameters
*
**************************************************************************/

pwr_tStatus lfu_GetFileVersion(
    char* pattern, int number_of_digits, int* version, pwr_tTime* date)
{
  pwr_tStatus sts;
  char found_file[160];
  pwr_tTime found_date;
  int vms_vers;
  int size;
  char version_str[10];
  int highest_version = 0;
  char highest_filename[80] = "";
  pwr_tTime highest_date = { 0, 0 };
  int found;
  int nr;
  int found_version;
  char* s;
  unsigned long search_ctx;
  char trn_pattern[80];

  found = 0;
  search_ctx = 0;
  dcli_translate_filename(trn_pattern, pattern);
  sts = dcli_search_file(trn_pattern, found_file, DCLI_DIR_SEARCH_INIT);
  while (ODD(sts)) {
    found = 1;

    sts = dir_get_fileinfo(found_file, &found_date, &size, &vms_vers, NULL);
    if (EVEN(sts))
      return sts;

    /* Get the version from the file name */
    s = strrchr(found_file, '.');
    s -= number_of_digits;
    strncpy(version_str, s, number_of_digits);
    version_str[number_of_digits] = 0;
    nr = sscanf(version_str, "%d", &found_version);
    if (nr == 1) {
      if (found_version > highest_version) {
        highest_version = found_version;
        if (time_Acomp(&found_date, &highest_date) < 0) {
          printf("** Warning, %s has later creation time but lower version "
                 "than %s\n",
              highest_filename, found_file);
        }
        highest_date = found_date;
        strcpy(highest_filename, found_file);
      } else {
        if (time_Acomp(&found_date, &highest_date) > 0) {
          printf("** Warning, %s has later creation time but lower version "
                 "than %s\n",
              found_file, highest_filename);
        }
      }
    }
    sts = dcli_search_file(trn_pattern, found_file, DCLI_DIR_SEARCH_NEXT);
  }
  sts = dcli_search_file(trn_pattern, found_file, DCLI_DIR_SEARCH_END);
  *version = highest_version;
  *date = highest_date;
  if (!found)
    return sts;

  return 1;
}

pwr_tStatus lfu_IncrementAndGetVersion(
    char* filename, unsigned long* current_version)
{
  FILE* file;
  int nr;
  fpos_t pos;
  unsigned long version;
  char fname[120];

  dcli_translate_filename(fname, filename);
  file = fopen(fname, "r+");
  if (!file) {
    file = fopen(fname, "w");
    if (!file)
      return LFU__NOFILE;
    version = 1;
  } else {
    fgetpos(file, &pos);
    nr = fscanf(file, "%ld", &version);
    if (nr != 1) {
      fclose(file);
      return LFU__PLCVERSION;
    }

    version++;
    fsetpos(file, &pos);
  }
  fprintf(file, "%ld", version);
  fclose(file);
  *current_version = version;
  return 1;
}

/*************************************************************************
*
* Name:		lfu_ReadSysObjectFile
*
* Type		pwr_tStatus
*
* Description:
*		Read info of the systemobject in the directory db.
*
**************************************************************************/

pwr_tStatus lfu_ReadSysObjectFile(char* SystemName, char* SystemGroup)
{
  FILE* file;
  int nr;
  char fname[120];

  dcli_translate_filename(fname, pwr_cNameSysObject);
  file = fopen(fname, "r");
  if (file == 0) {
    strcpy(SystemName, "");
    strcpy(SystemGroup, "");
    return LFU__NOFILE;
  } else {
    nr = fscanf(file, "%s", SystemName);
    if (nr != 1) {
      fclose(file);
      return LFU__FILECRP;
    }

    nr = fscanf(file, "%s", SystemGroup);
    //	  if ( nr != 1) return LFU__FILECRP;
  }
  fclose(file);
  return LFU__SUCCESS;
}

pwr_tStatus lfu_WriteSysObjectFile(ldh_tSesContext ldhses)
{
  FILE* file;
  int sts;
  pwr_tObjid systemobjid;
  char systemname[80];
  char systemgroup[80];
  char fname[120];

  /* Get system object */
  sts = utl_get_systemobject(ldhses, &systemobjid, systemname, systemgroup);
  if (EVEN(sts))
    return sts;

  dcli_translate_filename(fname, pwr_cNameSysObject);
  file = fopen(fname, "w");
  if (!file) {
    printf("** Error, unable to open file \"%s\"\n", pwr_cNameSysObject);
    return LFU__NOFILE;
  }
  fprintf(file, "%s\n", systemname);
  fprintf(file, "%s", systemgroup);
  fclose(file);
  return LFU__SUCCESS;
}

/************************************************************************
*
* Name: lfu_save_directoryvolume
*
* Type: int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Syntax control and file generation when a directory volume is saved.
*
*************************************************************************/
pwr_tStatus lfu_SaveDirectoryVolume(
    ldh_tSesContext ldhses, CoWow* wow, int quiet)
{
  pwr_tStatus sts;
  lfu_t_volumelist* volumelist;
  lfu_t_volumelist* volumelist_ptr;
  int volumecount;
  int i;
  pwr_tString80 volname;
  pwr_tString80 volume_name;
  pwr_tString80 name;
  pwr_tString80 nodeconfig_name;
  pwr_tString80 bus_name;
  int syntax_error;
  int found;
  pwr_tObjid envobjid;
  pwr_tObjid dbobjid;
  pwr_tClassId cid, ccid, vcid;
  pwr_tObjid volobjid;
  int size;
  pwr_tString80* path_ptr;
  pwr_tString80 classname;
  FILE* file;
  FILE* fpath;
  pwr_tObjid nodeobjid;
  pwr_tObjid busobjid;
  char* nodename_ptr;
  char* secondary_nodename_ptr;
  char* bootnode_ptr;
  char* secondary_bootnode_ptr;
  char nodename[80];
  pwr_tUInt32* os_ptr;
  pwr_tUInt32 os;
  pwr_tEnum* remote_access_type_ptr;
  pwr_tUInt32* bus_number_ptr;
  pwr_tBoolean* single_scan_ptr;
  pwr_tFloat32* scantime_ptr;
  pwr_tFloat32 scantime;
  pwr_tBoolean* distr_disable_ptr;
  char null_nodename[4];
  char filename[200];
  char found_file[200];
  char text[200];
  pwr_tObjid systemobjid;
  char systemname[80];
  char systemgroup[80];
  char os_str[20];
  pwr_tObjid applobjid;
  char appl_name[80];
  char* source_ptr;
  char* target_ptr;
  char* targetnode_ptr;
  char* targetproject_ptr;
  pwr_tClassId class_vect[4];
  utl_t_objidlist* obj_ptr;
  utl_t_objidlist* objlist;
  int objcount;
  trv_tCtx trvctx;
  pwr_tObjid distrobjid;
  pwr_tVolumeId volume_id = 0;
  pwr_tMask distr_options = 0;
  int distr_disable;
  char fname[200];
  char path[80];
  int path_file_created = 0;
  pwr_tString80 custom_platform;
  pwr_mOpSys custom_os;
  pwr_tEnum qcom_auto_dis = 0;

  syntax_error = 0;
  strcpy(null_nodename, "-");

  /* Write system object */
  sts = lfu_WriteSysObjectFile(ldhses);
  if (sts == LFU__NOFILE)
    syntax_error = 1;

  /* Load the volume list */
  sts = lfu_volumelist_load(pwr_cNameGblVolumeList, &volumelist, &volumecount);
  if (EVEN(sts)) {
    syntax_error = 1;
    if (sts == LFU__NOFILE)
      return sts;
  }

  dcli_translate_filename(fname, pwr_cNameVolumeList);
  file = fopen(fname, "w");
  if (file == 0) {
    printf("** Error, Unable to open file \"%s\"\n", fname);
    return LFU__NOFILE;
  }

  /* Check that the configured volumes exist */
  for (int k = 0; k < 2; k++) {
    // Check class volumes in the first round, and other volumes after

    for (sts = ldh_GetRootList(ldhses, &envobjid); ODD(sts);
         sts = ldh_GetNextSibling(ldhses, envobjid, &envobjid)) {
      sts = ldh_GetObjectClass(ldhses, envobjid, &vcid);
      if (EVEN(sts))
        return sts;

      if (vcid == pwr_cClass_WbEnvironment) {
        if (k != 1)
          continue;

        /* Create directory list file */
        sts = ldh_ObjidToName(
            ldhses, envobjid, ldh_eName_Object, name, sizeof(name), &size);
        if (EVEN(sts))
          return sts;

        sts = ldh_GetObjectPar(
            ldhses, envobjid, "RtBody", "Path", (char**)&path_ptr, &size);
        if (EVEN(sts))
          return sts;

        dcli_translate_filename(filename, pwr_cNameFilePath);

        fpath = fopen(filename, "w");
        if (!fpath) {
          printf("** Unable to open path file %s\n", filename);
          syntax_error = 1;
          free((char*)path_ptr);
          return LFU__NOFILE;
        }

        path_file_created = 1;

        for (i = 0; i < 50; i++) {
          str_trim(path, path_ptr[i]);
          if (!streq(path, ""))
            fprintf(fpath, "%s\n", path);
        }
        fclose(fpath);
        free((char*)path_ptr);

        // Get xxxVolumeLoad objects
        sts = ldh_GetChild(ldhses, envobjid, &volobjid);
        while (ODD(sts)) {
          sts = ldh_GetObjectClass(ldhses, volobjid, &vcid);
          if (EVEN(sts))
            return sts;

          if (vcid == pwr_cClass_RootVolumeLoad
              || vcid == pwr_cClass_SubVolumeLoad
              || vcid == pwr_cClass_ClassVolumeLoad
              || vcid == pwr_cClass_DetachedClassVolumeLoad
              || vcid == pwr_cClass_SharedVolumeLoad) {
            sts = ldh_ObjidToName(ldhses, volobjid, ldh_eName_Object,
                volume_name, sizeof(volume_name), &size);
            if (EVEN(sts))
              return sts;
            utl_toupper(name, volume_name);

            /* Check that the name is in the global volume list */
            found = 0;
            volumelist_ptr = volumelist;
            for (i = 0; i < volumecount; i++) {
              utl_toupper(volname, volumelist_ptr->volume_name);
              if (!strcmp(name, volname)) {
                found = 1;

                switch (vcid) {
                case pwr_cClass_RootVolumeLoad:
                  strcpy(classname, "RootVolume");
                  break;
                case pwr_cClass_SubVolumeLoad:
                  strcpy(classname, "SubVolume");
                  break;
                case pwr_cClass_ClassVolumeLoad:
                  strcpy(classname, "ClassVolume");
                  break;
                case pwr_cClass_DetachedClassVolumeLoad:
                  strcpy(classname, "DetachedClassVolume");
                  break;
                case pwr_cClass_SharedVolumeLoad:
                  strcpy(classname, "SharedVolume");
                  break;
                }

                fprintf(file, "%s %s %s load\n", volume_name,
                    cdh_VolumeIdToString(0, 0, volumelist_ptr->volume_id, 0, 0),
                    classname);
                break;
              }
              volumelist_ptr++;
            }
            if (!found) {
              char msg[200];
              sprintf(msg,
                  "Error in VolumeConfig object,  '%s' is not configured in the global\
 volume list",
                  name);
              MsgWindow::message('E', msg, msgw_ePop_Default);
              syntax_error = 1;
            }
          }
          sts = ldh_GetNextSibling(ldhses, volobjid, &volobjid);
        }
      } else if (vcid == pwr_cClass_RootVolumeConfig
          || vcid == pwr_cClass_SubVolumeConfig
          || vcid == pwr_cClass_ClassVolumeConfig
          || vcid == pwr_cClass_DetachedClassVolumeConfig
          || vcid == pwr_cClass_SharedVolumeConfig
          || vcid == pwr_cClass_CloneVolumeConfig
          || vcid == pwr_cClass_ExternVolumeConfig) {
        if (!(vcid == pwr_cClass_ClassVolumeConfig
                || vcid == pwr_cClass_DetachedClassVolumeConfig)
            && k == 0)
          continue;
        if ((vcid == pwr_cClass_ClassVolumeConfig
                || vcid == pwr_cClass_DetachedClassVolumeConfig)
            && k == 1)
          continue;

        sts = ldh_ObjidToName(ldhses, envobjid, ldh_eName_Object, volume_name,
            sizeof(volume_name), &size);
        if (EVEN(sts))
          return sts;
        utl_toupper(name, volume_name);

        /* Check that the name is in the global volume list */
        found = 0;
        volumelist_ptr = volumelist;
        for (i = 0; i < volumecount; i++) {
          utl_toupper(volname, volumelist_ptr->volume_name);
          if (!strcmp(name, volname)) {
            found = 1;

            bool out_of_range = false;
            switch (vcid) {
            case pwr_cClass_RootVolumeConfig:
              strcpy(classname, "RootVolume");
              if (volumelist_ptr->volume_id < cdh_cUserVolMin
                  || volumelist_ptr->volume_id > cdh_cUserVolMax)
                out_of_range = true;
              break;
            case pwr_cClass_SubVolumeConfig:
              strcpy(classname, "SubVolume");
              if (volumelist_ptr->volume_id < cdh_cUserVolMin
                  || volumelist_ptr->volume_id > cdh_cUserVolMax)
                out_of_range = true;
              break;
            case pwr_cClass_ClassVolumeConfig:
              strcpy(classname, "ClassVolume");
              if (volumelist_ptr->volume_id < cdh_cUserClassVolMin
                  || volumelist_ptr->volume_id > cdh_cUserClassVolMax)
                out_of_range = true;
              break;
            case pwr_cClass_DetachedClassVolumeConfig:
              strcpy(classname, "DetachedClassVolume");
              if (volumelist_ptr->volume_id < cdh_cUserClassVolMin
                  || volumelist_ptr->volume_id > cdh_cUserClassVolMax)
                out_of_range = true;
              break;
            case pwr_cClass_SharedVolumeConfig:
              strcpy(classname, "SharedVolume");
              if (volumelist_ptr->volume_id < cdh_cUserVolMin
                  || volumelist_ptr->volume_id > cdh_cUserVolMax)
                out_of_range = true;
              break;
            case pwr_cClass_ExternVolumeConfig:
              strcpy(classname, "ExternVolume");
              if (volumelist_ptr->volume_id < cdh_cUserVolMin
                  || volumelist_ptr->volume_id > cdh_cUserVolMax)
                out_of_range = true;
              break;
            case pwr_cClass_CloneVolumeConfig:
              strcpy(classname, "RootVolume");
              if (volumelist_ptr->volume_id < cdh_cUserVolMin
                  || volumelist_ptr->volume_id > cdh_cUserVolMax)
                out_of_range = true;
              break;
            }

            if (out_of_range) {
              char msg[200];
              sprintf(msg, "Error in Volume identity for volume '%s', %s is "
                           "out of range",
                  name,
                  cdh_VolumeIdToString(0, 0, volumelist_ptr->volume_id, 1, 0));
              MsgWindow::message('E', msg, msgw_ePop_Default);
              syntax_error = 1;
            }

            switch (vcid) {
            case pwr_cClass_RootVolumeConfig:
            case pwr_cClass_SubVolumeConfig:
            case pwr_cClass_ClassVolumeConfig:
            case pwr_cClass_DetachedClassVolumeConfig:
            case pwr_cClass_SharedVolumeConfig: {
              int* dbenum = 0;
              char* server = 0;

              sts = ldh_GetObjectPar(ldhses, envobjid, "RtBody", "Database",
                  (char**)&dbenum, &size);
              if (EVEN(sts))
                return sts;

              if (((vcid == pwr_cClass_ClassVolumeConfig
                       || vcid == pwr_cClass_DetachedClassVolumeConfig)
                      && *dbenum == 2)
                  || (!(vcid == pwr_cClass_ClassVolumeConfig
                          || vcid == pwr_cClass_DetachedClassVolumeConfig)
                         && *dbenum == 1)) {
                sts = ldh_GetObjectPar(ldhses, envobjid, "RtBody", "Server",
                    (char**)&server, &size);
                if (EVEN(sts))
                  return sts;
              }

              fprintf(file, "%s %s %s cnf %d", volume_name,
                  cdh_VolumeIdToString(0, 0, volumelist_ptr->volume_id, 0, 0),
                  classname, *dbenum);
              if (server) {
                fprintf(file, " %s\n", server);
                free(server);
              } else
                fprintf(file, "\n");
              free(dbenum);
              break;
            }
            case pwr_cClass_ExternVolumeConfig: {
              char* devprovider;
              char* rtprovider;

              sts = ldh_GetObjectPar(ldhses, envobjid, "RtBody", "DevProvider",
                  (char**)&devprovider, &size);
              if (EVEN(sts))
                return sts;
              sts = ldh_GetObjectPar(ldhses, envobjid, "RtBody", "RtProvider",
                  (char**)&rtprovider, &size);
              if (EVEN(sts))
                return sts;

              fprintf(file, "%s %s %s cnf %s %s\n", volume_name,
                  cdh_VolumeIdToString(0, 0, volumelist_ptr->volume_id, 0, 0),
                  classname, devprovider, rtprovider);
              free(devprovider);
              free(rtprovider);
              break;
            }
            case pwr_cClass_CloneVolumeConfig: {
              char* parentvolume;

              sts = ldh_GetObjectPar(ldhses, envobjid, "RtBody", "ParentVolume",
                  (char**)&parentvolume, &size);
              if (EVEN(sts))
                return sts;

              // Check parent volume
              int parent_found = 0;
              for (int j = 0; j < volumecount; j++) {
                if (str_NoCaseStrcmp(parentvolume, volumelist[j].volume_name)
                    == 0) {
                  parent_found = 1;
                  break;
                }
              }
              if (!parent_found) {
                char msg[200];
                sprintf(msg,
                    "Error in VolumeConfig object '%s', parent volume is not configured in the global\
 volume list",
                    name);
                MsgWindow::message('E', msg, msgw_ePop_Default);
                syntax_error = 1;
              }

              fprintf(file, "%s %s %s clone %s\n", volume_name,
                  cdh_VolumeIdToString(0, 0, volumelist_ptr->volume_id, 0, 0),
                  classname, parentvolume);
              free(parentvolume);
              break;
            }
            }
            break;
          }
          volumelist_ptr++;
        }

        if (!found) {
          char msg[200];
          sprintf(msg,
              "Error in VolumeConfig object,  '%s' is not configured in the global\
 volume list",
              name);
          MsgWindow::message('E', msg, msgw_ePop_Default);
          syntax_error = 1;
        } else {
          switch (vcid) {
          case pwr_cClass_RootVolumeConfig:
          case pwr_cClass_SubVolumeConfig:
          case pwr_cClass_SharedVolumeConfig: {
            /* Check if the databas is created */
            int* dbenum_p = 0;
            char* server_p = 0;
            ldh_eVolRep volrep;
            pwr_tCid volcid = 0;
            pwr_tString40 server = "";

            switch (vcid) {
            case pwr_cClass_RootVolumeConfig:
              volcid = pwr_eClass_RootVolume;
              break;
            case pwr_cClass_SubVolumeConfig:
              volcid = pwr_eClass_SubVolume;
              break;
            case pwr_cClass_SharedVolumeConfig:
              volcid = pwr_eClass_SharedVolume;
              break;
            default:;
            }

            sts = ldh_GetObjectPar(ldhses, envobjid, "RtBody", "Database",
                (char**)&dbenum_p, &size);
            if (EVEN(sts))
              return sts;

            if (*dbenum_p == pwr_eVolumeDatabaseEnum_BerkeleyDb)
              volrep = ldh_eVolRep_Db;
            else if (*dbenum_p == pwr_eVolumeDatabaseEnum_MySql)
              volrep = ldh_eVolRep_Dbms;
            else {
              free(dbenum_p);
              break;
            }

            free(dbenum_p);

            if (volrep == ldh_eVolRep_Db) {
              sprintf(filename, "$pwrp_db/%s.db/info", volume_name);
              str_ToLower(filename, filename);
              dcli_translate_filename(filename, filename);
              sts = dcli_search_file(
                  filename, found_file, DCLI_DIR_SEARCH_INIT);
              dcli_search_file(filename, found_file, DCLI_DIR_SEARCH_END);
              if (EVEN(sts)) {
                if (wow) {
                  lfu_sCreaDb* data;
                  data = (lfu_sCreaDb*)calloc(1, sizeof(*data));
                  strcpy(data->name, volumelist_ptr->volume_name);
                  data->vid = volumelist_ptr->volume_id;
                  data->cid = volcid;
                  data->ldhses = ldhses;
                  data->volrep = volrep;
                  strcpy(data->server, "");

                  sprintf(text, "   Volume '%s' is not yet created.\n \n\
   Do you want to create this volume.\n",
                      volume_name);
                  if (quiet)
                    lfu_creadb_qb_yes(NULL, (void*)data);
                  else
                    wow->DisplayQuestion(NULL, "Create volume", text,
                        lfu_creadb_qb_yes, NULL, (void*)data);
                } else {
                  char msg[200];
                  sprintf(msg, "Error, Volume '%s' is not yet created.",
                      volume_name);
                  MsgWindow::message('E', msg, msgw_ePop_Default);
                }
              }
            }
            if (volrep == ldh_eVolRep_Dbms) {
              sts = ldh_GetObjectPar(ldhses, envobjid, "RtBody", "Server",
                  (char**)&server_p, &size);
              if (EVEN(sts))
                return sts;

              strcpy(server, server_p);
              free(server_p);

              sprintf(
                  filename, "$pwrp_db/%s.dbms/connection.dmsql", volume_name);
              str_ToLower(filename, filename);
              dcli_translate_filename(filename, filename);
              sts = dcli_search_file(
                  filename, found_file, DCLI_DIR_SEARCH_INIT);
              dcli_search_file(filename, found_file, DCLI_DIR_SEARCH_END);
              if (EVEN(sts)) {
                if (wow) {
                  lfu_sCreaDb* data;
                  data = (lfu_sCreaDb*)calloc(1, sizeof(*data));
                  strcpy(data->name, volumelist_ptr->volume_name);
                  data->vid = volumelist_ptr->volume_id;
                  data->cid = volcid;
                  data->ldhses = ldhses;
                  data->volrep = volrep;
                  strcpy(data->server, server);

                  sprintf(text, "   Volume '%s' is not yet created.\n \n\
   Do you want to create this volume.\n",
                      volume_name);
                  if (quiet)
                    lfu_creadb_qb_yes(NULL, (void*)data);
                  else
                    wow->DisplayQuestion(NULL, "Create volume", text,
                        lfu_creadb_qb_yes, NULL, (void*)data);
                } else {
                  char msg[200];
                  sprintf(msg, "Error, Volume '%s' is not yet created.",
                      volume_name);
                  MsgWindow::message('E', msg, msgw_ePop_Default);
                }
              }
            }
            break;
          }
          case pwr_cClass_DetachedClassVolumeConfig:
          case pwr_cClass_ClassVolumeConfig: {
            int* dbenum_p = 0;
            char* server_p = 0;
            ldh_eVolRep volrep;
            pwr_tString40 server = "";

            sts = ldh_GetObjectPar(ldhses, envobjid, "RtBody", "Database",
                (char**)&dbenum_p, &size);
            if (EVEN(sts))
              return sts;

            if (*dbenum_p == pwr_eClassVolumeDatabaseEnum_WbLoad)
              volrep = ldh_eVolRep_Wbl;
            else if (*dbenum_p == pwr_eClassVolumeDatabaseEnum_BerkeleyDb)
              volrep = ldh_eVolRep_Db;
            else if (*dbenum_p == pwr_eClassVolumeDatabaseEnum_MySql)
              volrep = ldh_eVolRep_Dbms;
            else {
              free(dbenum_p);
              break;
            }
            free(dbenum_p);

            if (volrep == ldh_eVolRep_Db) {
              /* Check if the databas is created */
              sprintf(filename, "$pwrp_db/%s.db/info", volume_name);
              str_ToLower(filename, filename);
              dcli_translate_filename(filename, filename);
              sts = dcli_search_file(
                  filename, found_file, DCLI_DIR_SEARCH_INIT);
              dcli_search_file(filename, found_file, DCLI_DIR_SEARCH_END);
              if (EVEN(sts)) {
                if (wow) {
                  lfu_sCreaDb* data;
                  data = (lfu_sCreaDb*)calloc(1, sizeof(*data));
                  strcpy(data->name, volumelist_ptr->volume_name);
                  data->vid = volumelist_ptr->volume_id;
                  if (vcid == pwr_cClass_DetachedClassVolumeConfig)
                    data->cid = pwr_eClass_DetachedClassVolume;
                  else
                    data->cid = pwr_eClass_ClassVolume;
                  data->ldhses = ldhses;
                  data->volrep = volrep;
                  strcpy(data->server, "");

                  sprintf(text, "   ClassVolume '%s' is not yet created.\n \n\
   Do you want to create this volume.\n",
                      volume_name);
                  if (quiet)
                    lfu_creadb_qb_yes(NULL, (void*)data);
                  else
                    wow->DisplayQuestion(NULL, "Create Classvolume", text,
                        lfu_creadb_qb_yes, NULL, (void*)data);
                }
              }
            } else if (volrep == ldh_eVolRep_Dbms) {
              // MySql...
              sts = ldh_GetObjectPar(ldhses, envobjid, "RtBody", "Server",
                  (char**)&server_p, &size);
              if (EVEN(sts))
                return sts;

              strcpy(server, server_p);
              free(server_p);

              sprintf(
                  filename, "$pwrp_db/%s.dbms/connection.dmsql", volume_name);
              str_ToLower(filename, filename);
              dcli_translate_filename(filename, filename);
              sts = dcli_search_file(
                  filename, found_file, DCLI_DIR_SEARCH_INIT);
              dcli_search_file(filename, found_file, DCLI_DIR_SEARCH_END);
              if (EVEN(sts)) {
                if (wow) {
                  lfu_sCreaDb* data;
                  data = (lfu_sCreaDb*)calloc(1, sizeof(*data));
                  strcpy(data->name, volumelist_ptr->volume_name);
                  data->vid = volumelist_ptr->volume_id;
                  if (vcid == pwr_cClass_DetachedClassVolumeConfig)
                    data->cid = pwr_eClass_DetachedClassVolume;
                  else
                    data->cid = pwr_eClass_ClassVolume;
                  data->ldhses = ldhses;
                  data->volrep = volrep;
                  strcpy(data->server, server);

                  sprintf(text, "   ClassVolume '%s' is not yet created.\n \n\
   Do you want to create this volume.\n",
                      volume_name);
                  if (quiet)
                    lfu_creadb_qb_yes(NULL, (void*)data);
                  else
                    wow->DisplayQuestion(NULL, "Create Classvolume", text,
                        lfu_creadb_qb_yes, NULL, (void*)data);
                }
              }
            } else if (volrep == ldh_eVolRep_Wbl) {
              // Check wbload-file...
              FILE* wblfile;

              sprintf(fname, "$pwrp_db/%s.wb_load", volume_name);
              str_ToLower(fname, fname);
              dcli_translate_filename(fname, fname);
              wblfile = fopen(fname, "r");
              if (wblfile == 0) {
                wblfile = fopen(fname, "w");
                if (wblfile == 0) {
                  char msg[240];
                  sprintf(msg, "Error, unable to create file %s, ", fname);
                  MsgWindow::message('E', msg, msgw_ePop_Default);
                  break;
                }

                if (vcid == pwr_cClass_DetachedClassVolumeConfig)
                  fprintf(wblfile, "Volume %s pwr_eClass_DetachedClassVolume "
                                   "%s\nEndVolume\n",
                      volume_name, cdh_VolumeIdToString(
                                       0, 0, volumelist_ptr->volume_id, 0, 0));
                else
                  fprintf(wblfile,
                      "Volume %s pwr_eClass_ClassVolume %s\nEndVolume\n",
                      volume_name, cdh_VolumeIdToString(
                                       0, 0, volumelist_ptr->volume_id, 0, 0));
                fclose(wblfile);
              }
            }
            break;
          }
          }
        }
      }
    }
  }
  fclose(file);

  if (!path_file_created) {
    // Create an empty path file
    dcli_translate_filename(filename, pwr_cNameFilePath);
    fpath = fopen(filename, "w");
    if (!fpath) {
      char msg[230];
      sprintf(msg, "Unable to open path file %s\n", filename);
      MsgWindow::message('E', msg, msgw_ePop_Default);
      syntax_error = 1;
    } else
      fclose(fpath);
  }

  /* Generate data for bootfiles */
  dcli_translate_filename(fname, pwr_cNameBootList);
  file = fopen(fname, "w");
  if (file == 0) {
    char tmp[240];
    sprintf(tmp, "** Error, Unable to open file \"%s\"", fname);
    MsgWindow::message('E', tmp, msgw_ePop_Default);
    return LFU__NOFILE;
  }

  /* Get the configured nodes */
  sts = ldh_GetRootList(ldhses, &busobjid);
  while (ODD(sts)) {
    sts = ldh_GetObjectClass(ldhses, busobjid, &cid);
    if (EVEN(sts)) {
      fclose(file);
      return sts;
    }

    if (cid == pwr_cClass_BusConfig) {
      /* Check Bus attribute */
      sts = ldh_GetObjectPar(ldhses, busobjid, "RtBody", "BusNumber",
          (char**)&bus_number_ptr, &size);
      if (EVEN(sts)) {
        fclose(file);
        return sts;
      }
      sts = ldh_GetObjectPar(ldhses, busobjid, "RtBody", "BusNumber",
          (char**)&bus_number_ptr, &size);
      if (EVEN(sts)) {
        fclose(file);
        return sts;
      }

      sts = ldh_ObjidToName(ldhses, busobjid, ldh_eName_Object, bus_name,
          sizeof(bus_name), &size);
      if (EVEN(sts)) {
        fclose(file);
        return sts;
      }

      if (*bus_number_ptr == 0) {
        char msg[200];
        sprintf(
            msg, "Error in Bus object '%s', BusNumber is missing", bus_name);
        MsgWindow::message('E', msg, msgw_ePop_Default);
        syntax_error = 1;
      }

      sts = ldh_GetChild(ldhses, busobjid, &nodeobjid);
      while (ODD(sts)) {
        sts = ldh_GetObjectClass(ldhses, nodeobjid, &cid);
        if (EVEN(sts)) {
          fclose(file);
          return sts;
        }

        if (cid == pwr_cClass_NodeConfig || cid == pwr_cClass_SevNodeConfig) {
          sts = ldh_ObjidToName(ldhses, nodeobjid, ldh_eName_Object,
              nodeconfig_name, sizeof(nodeconfig_name), &size);
          if (EVEN(sts)) {
            fclose(file);
            return sts;
          }

          /* Check NodeName attribute */
          sts = ldh_GetObjectPar(
              ldhses, nodeobjid, "RtBody", "NodeName", &nodename_ptr, &size);
          if (EVEN(sts)) {
            fclose(file);
            return sts;
          }

          if (!strcmp(nodename_ptr, "")) {
            char msg[200];
            sprintf(msg,
                "Error in NodeConfig object '%s', NodeName is not valid",
                nodeconfig_name);
            MsgWindow::message('E', msg, msgw_ePop_Default);
            syntax_error = 1;
            free(nodename_ptr);
            nodename_ptr = null_nodename;
          }

          /* Check SecondaryNode.NodeName attribute */
          if (cid == pwr_cClass_NodeConfig) {
            sts = ldh_GetObjectPar(ldhses, nodeobjid, "RtBody",
                "SecondaryNode.NodeName", &secondary_nodename_ptr, &size);
            if (EVEN(sts)) {
              fclose(file);
              return sts;
            }
          } else
            secondary_nodename_ptr = 0;

          /* Check OperatingSystem attribute */
          sts = ldh_GetObjectPar(ldhses, nodeobjid, "RtBody", "OperatingSystem",
              (char**)&os_ptr, &size);
          if (EVEN(sts)) {
            fclose(file);
            return sts;
          }

          os = *os_ptr;
          if (!(os == pwr_mOpSys_CustomBuild || os == pwr_mOpSys_PPC_LINUX
                  || os == pwr_mOpSys_X86_LINUX || os == pwr_mOpSys_X86_64_LINUX
                  || os == pwr_mOpSys_ARM_LINUX || os == pwr_mOpSys_X86_64_MACOS
                  || os == pwr_mOpSys_X86_64_FREEBSD
                  || os == pwr_mOpSys_X86_64_OPENBSD
                  || os == pwr_mOpSys_X86_CYGWIN)) {
            char msg[200];
            sprintf(msg,
                "Error in NodeConfig object '%s', OperatingSystem is not valid",
                nodeconfig_name);
            MsgWindow::message('E', msg, msgw_ePop_Default);
            syntax_error = 1;
            os = 0;
          }

          /* Check SimulateSingleProcess attribute */
          if (cid == pwr_cClass_NodeConfig) {
            sts = ldh_GetObjectPar(ldhses, nodeobjid, "RtBody",
                "SimulateSingleProcess", (char**)&single_scan_ptr, &size);
            if (EVEN(sts)) {
              fclose(file);
              return sts;
            }

            if (*single_scan_ptr != 0) {
              sts = ldh_GetObjectPar(ldhses, nodeobjid, "RtBody",
                  "SimulateSingleScanTime", (char**)&scantime_ptr, &size);
              if (EVEN(sts)) {
                fclose(file);
                return sts;
              }

              if (feqf(*scantime_ptr, 0.0f)) {
                char msg[200];
                sprintf(msg, "Error in NodeConfig object '%s', "
                             "SimulateSingleScanTime is missing",
                    nodeconfig_name);
                MsgWindow::message('E', msg, msgw_ePop_Default);
                syntax_error = 1;
              }
              scantime = *scantime_ptr;
              free((char*)scantime_ptr);
            } else
              scantime = 0;
            free((char*)single_scan_ptr);
          } else
            scantime = 0;

          lfu_check_appl_file(ldhses, nodename_ptr, *bus_number_ptr);
          // lfu_check_opt_file( ldhses, nodename_ptr, *bus_number_ptr,
          // (pwr_mOpSys) os);

          for (int j = 0; j < 2; j++) {
            // Loop over primary and secondary node

            /* Find the volumes in this node */
            sts = ldh_GetChild(ldhses, nodeobjid, &volobjid);
            while (ODD(sts)) {
              sts = ldh_GetObjectClass(ldhses, volobjid, &vcid);
              if (EVEN(sts)) {
                fclose(file);
                return sts;
              }

              if (vcid == pwr_cClass_RootVolumeLoad
                  || vcid == pwr_cClass_SubVolumeLoad
                  || vcid == pwr_cClass_ClassVolumeLoad
                  || vcid == pwr_cClass_DetachedClassVolumeLoad
                  || vcid == pwr_cClass_SharedVolumeLoad) {
                sts = ldh_ObjidToName(ldhses, volobjid, ldh_eName_Object,
                    volume_name, sizeof(volume_name), &size);
                if (EVEN(sts)) {
                  fclose(file);
                  return sts;
                }
                utl_toupper(name, volume_name);

                /* Check that the name is in the global volume list */
                found = 0;
                volumelist_ptr = volumelist;
                for (i = 0; i < volumecount; i++) {
                  utl_toupper(volname, volumelist_ptr->volume_name);
                  if (!strcmp(name, volname)) {
                    found = 1;

                    switch (cid) {
                    case pwr_cClass_RootVolumeLoad:
                      strcpy(classname, "RootVolume");
                      break;
                    case pwr_cClass_SubVolumeLoad:
                      strcpy(classname, "SubVolume");
                      break;
                    case pwr_cClass_ClassVolumeLoad:
                      strcpy(classname, "ClassVolume");
                      break;
                    case pwr_cClass_DetachedClassVolumeLoad:
                      strcpy(classname, "DetachedClassVolume");
                      break;
                    case pwr_cClass_SharedVolumeLoad:
                      strcpy(classname, "SharedVolume");
                      break;
                    }

                    if (j == 0)
                      fprintf(file, "%s %s %s %s %d %d %f %d\n", volume_name,
                          cdh_VolumeIdToString(
                              0, 0, volumelist_ptr->volume_id, 0, 0),
                          nodeconfig_name, nodename_ptr, *bus_number_ptr, os,
                          scantime,
                          cid == pwr_cClass_SevNodeConfig ? bld_eNodeType_Sev
                                                          : bld_eNodeType_Node);
                    else if (j == 1)
                      // Secondary node
                      fprintf(file, "%s %s %s(%s) %s %d %d %f %d\n",
                          volume_name, cdh_VolumeIdToString(0, 0,
                                           volumelist_ptr->volume_id, 0, 0),
                          secondary_nodename_ptr, nodeconfig_name,
                          secondary_nodename_ptr, *bus_number_ptr, os, scantime,
                          bld_eNodeType_Node);
                    break;
                  }
                  volumelist_ptr++;
                }
                if (!found) {
                  char msg[200];
                  sprintf(msg,
                      "Error in VolumeLoad object,  '%s' is not configured in the global\
 volume list",
                      name);
                  MsgWindow::message('E', msg, msgw_ePop_Default);
                  syntax_error = 1;
                }
              }
              sts = ldh_GetNextSibling(ldhses, volobjid, &volobjid);
            }
            if (secondary_nodename_ptr == 0
                || streq(secondary_nodename_ptr, ""))
              break;
          }
          if (nodename_ptr != null_nodename)
            free(nodename_ptr);
          if (secondary_nodename_ptr)
            free(secondary_nodename_ptr);
          free((char*)os_ptr);
        }
        sts = ldh_GetNextSibling(ldhses, nodeobjid, &nodeobjid);
      }
      free((char*)bus_number_ptr);
    }
    sts = ldh_GetNextSibling(ldhses, busobjid, &busobjid);
  }

  fclose(file);

  // Generate data for nodefiles */

  // Find all BusConfig objects */
  wb_session* sp = (wb_session*)ldhses;
  pwr_tUInt32 bus_number;

  for (wb_object buso = sp->object(); buso; buso = buso.after()) {
    if (buso.cid() != pwr_cClass_BusConfig)
      continue;

    wb_attribute a = sp->attribute(buso.oid(), "RtBody", "BusNumber");
    if (!a)
      return a.sts();

    a.value(&bus_number);
    if (!a)
      return a.sts();

    if (bus_number == 0)
      continue;

    a = sp->attribute(buso.oid(), "RtBody", "QComAutoConnectDisable");
    if (!a)
      return a.sts();

    a.value(&qcom_auto_dis);
    if (!a)
      return a.sts();

    // Get all nodeconfig and friendnodes for this bus
    std::vector<lfu_nodeconf> nodevect;
    int node_cnt = 0;
    for (wb_object nodeo = buso.first(); nodeo; nodeo = nodeo.after()) {
      switch (nodeo.cid()) {
      case pwr_cClass_NodeConfig: {
        pwr_tString80 volstr;
        lfu_nodeconf nc;

        nc.oid = nodeo.oid();

        // Get attribute NodeName
        a = sp->attribute(nodeo.oid(), "RtBody", "NodeName");
        if (!a)
          return a.sts();

        a.value(nc.nodename);
        if (!a)
          return sts;

        // Get attribute OperatingSystem
        a = sp->attribute(nodeo.oid(), "RtBody", "OperatingSystem");
        if (!a)
          return a.sts();

        a.value(&nc.operatingsystem);
        if (!a)
          return sts;

        // Get attribute Address
        a = sp->attribute(nodeo.oid(), "RtBody", "Address");
        if (!a)
          return a.sts();

        a.value(nc.address);
        if (!a)
          return sts;

        // Get attribute Port
        a = sp->attribute(nodeo.oid(), "RtBody", "Port");
        if (!a)
          return a.sts();

        a.value(&nc.port);
        if (!a)
          return sts;

        // Get attribute QComMinResendTime
        a = sp->attribute(nodeo.oid(), "RtBody", "QComMinResendTime");
        if (!a)
          return a.sts();

        a.value(&nc.qcom_min_resend_time);
        if (!a)
          return sts;

        // Get attribute QComMaxResendTime
        a = sp->attribute(nodeo.oid(), "RtBody", "QComMaxResendTime");
        if (!a)
          return a.sts();

        a.value(&nc.qcom_max_resend_time);
        if (!a)
          return sts;

        // Get attribute QComExportBufSize
        a = sp->attribute(nodeo.oid(), "RtBody", "QComExportBufQuota");
        if (!a)
          return a.sts();

        a.value(&nc.qcom_export_buf_quota);
        if (!a)
          return sts;

        // Get attribute QComAckDelay
        a = sp->attribute(nodeo.oid(), "RtBody", "QComAckDelay");
        if (!a)
          return a.sts();

        a.value(&nc.qcom_ack_delay);
        if (!a)
          return sts;

        // Get attribute QComSegmentSize
        a = sp->attribute(nodeo.oid(), "RtBody", "QComSegmentSize");
        if (!a)
          return a.sts();

        a.value(&nc.qcom_segment_size);
        if (!a)
          return sts;

        // Get attribute SecondaryNode.NodeName
        a = sp->attribute(nodeo.oid(), "RtBody", "SecondaryNode.NodeName");
        if (!a)
          return a.sts();

        a.value(&nc.secondary_nodename);
        if (!a)
          return sts;

        if (!streq(nc.secondary_nodename, ""))
          nc.has_secondary = 1;
        else {
          strcpy(nc.secondary_nodename, "-");
          strcpy(nc.secondary_address, "-");
        }

        if (nc.has_secondary) {
          // Get attribute SecondaryNode.Address
          a = sp->attribute(nodeo.oid(), "RtBody", "SecondaryNode.Address");
          if (!a)
            return a.sts();

          a.value(&nc.secondary_address);
          if (!a)
            return sts;

          // Get attribute SecondaryNode.RedcomPort
          a = sp->attribute(nodeo.oid(), "RtBody", "SecondaryNode.RedcomPort");
          if (!a)
            return a.sts();

          a.value(&nc.redcom_port);
          if (!a)
            return sts;

          // Get attribute SecondaryNode.RedcomMinResendTime
          a = sp->attribute(
              nodeo.oid(), "RtBody", "SecondaryNode.RedcomMinResendTime");
          if (!a)
            return a.sts();

          a.value(&nc.redcom_min_resend_time);
          if (!a)
            return sts;

          // Get attribute SecondaryNode.RedcomMaxResendTime
          a = sp->attribute(
              nodeo.oid(), "RtBody", "SecondaryNode.RedcomMaxResendTime");
          if (!a)
            return a.sts();

          a.value(&nc.redcom_max_resend_time);
          if (!a)
            return sts;

          // Get attribute SecondaryNode.RedcomExportBufSize
          a = sp->attribute(
              nodeo.oid(), "RtBody", "SecondaryNode.RedcomExportBufQuota");
          if (!a)
            return a.sts();

          a.value(&nc.redcom_export_buf_quota);
          if (!a)
            return sts;

          // Get attribute SecondaryNode.RedcomAckDelay
          a = sp->attribute(
              nodeo.oid(), "RtBody", "SecondaryNode.RedcomAckDelay");
          if (!a)
            return a.sts();

          a.value(&nc.redcom_ack_delay);
          if (!a)
            return sts;

          // Get attribute SecondaryNode.RedcomSegmentSize
          a = sp->attribute(
              nodeo.oid(), "RtBody", "SecondaryNode.RedcomSegmentSize");
          if (!a)
            return a.sts();

          a.value(&nc.redcom_segment_size);
          if (!a)
            return sts;
        }

        if (!strcmp(nc.nodename, "")) {
          char msg[200];
          sprintf(msg, "Error in NodeConfig object '%s', NodeName is missing\n",
              nodeo.longName().c_str());
          MsgWindow::message('E', msg, msgw_ePop_Default);
          syntax_error = 1;
        }

        // Get rootvolume
        found = 0;
        for (wb_object volo = nodeo.first(); volo; volo = volo.after()) {
          if (volo.cid() == pwr_cClass_RootVolumeLoad) {
            strcpy(volstr, volo.name());

            /* Check that the name is in the global volume list */
            found = 0;
            volumelist_ptr = volumelist;
            for (i = 0; i < volumecount; i++) {
              if (str_NoCaseStrcmp(volstr, volumelist_ptr->volume_name) == 0) {
                nc.vid = volumelist_ptr->volume_id;
                found = 1;
                break;
              }
              volumelist_ptr++;
            }
          }
        }
        if (!found) {
          char msg[200];
          sprintf(msg, "No valid RootVolume configured for object '%s'\n",
              nodeo.longName().c_str());
          MsgWindow::message('E', msg, msgw_ePop_Default);
          syntax_error = 1;
        }

        nodevect.push_back(nc);
        node_cnt++;

        break;
      }
      case pwr_cClass_SevNodeConfig:
      case pwr_cClass_FriendNodeConfig: {
        pwr_tString80 volstr;
        lfu_nodeconf nc;

        nc.oid = nodeo.oid();
        nc.isfriend = 1;

        // Get attribute NodeName
        a = sp->attribute(nodeo.oid(), "RtBody", "NodeName");
        if (!a)
          return a.sts();

        a.value(nc.nodename);
        if (!a)
          return sts;

        // Get attribute Address
        a = sp->attribute(nodeo.oid(), "RtBody", "Address");
        if (!a)
          return a.sts();

        a.value(nc.address);
        if (!a)
          return sts;

        // Get attribute Port
        a = sp->attribute(nodeo.oid(), "RtBody", "Port");
        if (!a)
          return a.sts();

        a.value(&nc.port);
        if (!a)
          return sts;

        if (nodeo.cid() == pwr_cClass_SevNodeConfig) {
          // Qcom only connection
          nc.connection = 1;

	  found = 0;
	  sts = ldh_GetChild(ldhses, nodeo.oid(), &volobjid);
	  while (ODD(sts)) {
	    sts = ldh_GetObjectClass(ldhses, volobjid, &vcid);
	    if (EVEN(sts))
	      return sts;

	    if (vcid == pwr_cClass_RootVolumeLoad) {
	      sts = ldh_ObjidToName(ldhses, volobjid, ldh_eName_Object,
				    volstr, sizeof(volstr), &size);
	      found = 1;
	      break;
	    }
            sts = ldh_GetNextSibling(ldhses, volobjid, &volobjid);
	  }
	  if (!found) {
	    char msg[200];
            sprintf(msg, "Error in SevNodeConfig object '%s', no RootVolumeLoad object found",
		    nodeo.longName().c_str());
	    MsgWindow::message('E', msg, msgw_ePop_Default);
	    syntax_error = 1;
	  }	    
        } else {
          // Get attribute Connection
          a = sp->attribute(nodeo.oid(), "RtBody", "Connection");
          if (!a)
            return a.sts();

          a.value(&nc.connection);
          if (!a)
            return sts;

	  // Get attribute Volume
	  a = sp->attribute(nodeo.oid(), "RtBody", "Volume");
	  if (!a)
	    return a.sts();

	  a.value(volstr);
	  if (!a)
	    return sts;
        }

        // Get attribute QComMinResendTime
        a = sp->attribute(nodeo.oid(), "RtBody", "QComMinResendTime");
        if (!a)
          return a.sts();

        a.value(&nc.qcom_min_resend_time);
        if (!a)
          return sts;

        // Get attribute QComMaxResendTime
        a = sp->attribute(nodeo.oid(), "RtBody", "QComMaxResendTime");
        if (!a)
          return a.sts();

        a.value(&nc.qcom_max_resend_time);
        if (!a)
          return sts;

        // Get attribute QComExportBufSize
        a = sp->attribute(nodeo.oid(), "RtBody", "QComExportBufQuota");
        if (!a)
          return a.sts();

        a.value(&nc.qcom_export_buf_quota);
        if (!a)
          return sts;

        // Get attribute QComAckDelay
        a = sp->attribute(nodeo.oid(), "RtBody", "QComAckDelay");
        if (!a)
          return a.sts();

        a.value(&nc.qcom_ack_delay);
        if (!a)
          return sts;

        if (nodeo.cid() == pwr_cClass_FriendNodeConfig) {
          // Get attribute SecondaryNode.NodeName
          a = sp->attribute(nodeo.oid(), "RtBody", "SecondaryNode.NodeName");
          if (!a)
            return a.sts();

          a.value(&nc.secondary_nodename);
          if (!a)
            return sts;

          if (!streq(nc.secondary_nodename, ""))
            nc.has_secondary = 1;
          else {
            strcpy(nc.secondary_nodename, "-");
            strcpy(nc.secondary_address, "-");
          }

          if (nc.has_secondary) {
            // Get attribute SecondaryNode.Address
            a = sp->attribute(nodeo.oid(), "RtBody", "SecondaryNode.Address");
            if (!a)
              return a.sts();

            a.value(&nc.secondary_address);
            if (!a)
              return sts;
          }
        }

        if (nodeo.cid() == pwr_cClass_SevNodeConfig) {
          strcpy(nc.secondary_nodename, "-");
          strcpy(nc.secondary_address, "-");

          // Get attribute QComSegmentSize
          a = sp->attribute(nodeo.oid(), "RtBody", "QComSegmentSize");
          if (!a)
            return a.sts();

          a.value(&nc.qcom_segment_size);
          if (!a)
            return sts;
        }

        /* Check that the name is in the global volume list */
        found = 0;
        volumelist_ptr = volumelist;
        for (i = 0; i < volumecount; i++) {
          if (str_NoCaseStrcmp(volstr, volumelist_ptr->volume_name) == 0) {
            nc.vid = volumelist_ptr->volume_id;
            found = 1;
            break;
          }
          volumelist_ptr++;
        }

        if (!found) {
          char msg[200];
          if (nodeo.cid() == pwr_cClass_FriendNodeConfig)
            sprintf(msg,
                "Error in FriendNodeConfig object '%s', Unknown volume",
                nodeo.longName().c_str());
          else
            sprintf(msg, "Error in SevNodeConfig object '%s', Unknown volume",
                nodeo.longName().c_str());
          MsgWindow::message('E', msg, msgw_ePop_Default);
          syntax_error = 1;
        }

        if (!strcmp(nc.nodename, "")) {
          char msg[200];
          if (nodeo.cid() == pwr_cClass_FriendNodeConfig)
            sprintf(msg,
                "Error in FriendNodeConfig object '%s', NodeName is missing\n",
                nodeo.longName().c_str());
          else
            sprintf(msg,
                "Error in SevNodeConfig object '%s', NodeName is missing\n",
                nodeo.longName().c_str());
          MsgWindow::message('E', msg, msgw_ePop_Default);
          syntax_error = 1;
        }
        nodevect.push_back(nc);
        node_cnt++;
        break;
      }
      default:;
      }
    }

    // Node config syntax check
    for (int i = 0; i < (int)nodevect.size(); i++) {
      for (int j = i + 1; j < (int)nodevect.size(); j++) {
        if (nodevect[i].vid == nodevect[j].vid) {
          char msg[450];
          pwr_tOName oname1, oname2;
          sts = ldh_ObjidToName(ldhses, nodevect[i].oid, ldh_eName_Hierarchy,
              oname1, sizeof(oname1), &size);
          if (EVEN(sts))
            return sts;
          sts = ldh_ObjidToName(ldhses, nodevect[j].oid, ldh_eName_Hierarchy,
              oname2, sizeof(oname2), &size);
          if (EVEN(sts))
            return sts;

          sprintf(msg, "Error in node '%s' and '%s', Volume is equal\n", oname1,
              oname2);
          MsgWindow::message('E', msg, msgw_ePop_Default);
          syntax_error = 1;
        }
        if (!streq(nodevect[i].address, "0.0.0.0")
            && !streq(nodevect[i].address, "127.0.0.1")
            && streq(nodevect[i].address, nodevect[j].address)) {
          char msg[450];
          pwr_tOName oname1, oname2;
          sts = ldh_ObjidToName(ldhses, nodevect[i].oid, ldh_eName_Hierarchy,
              oname1, sizeof(oname1), &size);
          if (EVEN(sts))
            return sts;
          sts = ldh_ObjidToName(ldhses, nodevect[j].oid, ldh_eName_Hierarchy,
              oname2, sizeof(oname2), &size);
          if (EVEN(sts))
            return sts;

          sprintf(msg, "Error in node '%s' and '%s', Address is equal\n",
              oname1, oname2);
          MsgWindow::message('E', msg, msgw_ePop_Default);
          syntax_error = 1;
        }
      }
    }

    // Print ld_node file
    for (wb_object nodeo = buso.first(); nodeo; nodeo = nodeo.after()) {
      switch (nodeo.cid()) {
      case pwr_cClass_NodeConfig:
      case pwr_cClass_SevNodeConfig: {
        FILE* fp;
        int idx;
        int found = 0;
        int is_secondary;

        for (idx = 0; idx < (int)nodevect.size(); idx++) {
          if (cdh_ObjidIsEqual(nodevect[idx].oid, nodeo.oid())) {
            found = 1;
            break;
          }
        }
        if (!found)
          return 0;

        for (int k = 0; k < 2; k++) {
          is_secondary = k;

          if (is_secondary && !nodevect[idx].has_secondary)
            break;

          if (!is_secondary)
            sprintf(filename, pwr_cNameNode, load_cDirectory,
                cdh_Low(nodevect[idx].nodename), bus_number);
          else
            sprintf(filename, pwr_cNameNode, load_cDirectory,
                cdh_Low(nodevect[idx].secondary_nodename), bus_number);

          dcli_translate_filename(fname, filename);
          fp = fopen(fname, "w");
          if (!fp) {
            char tmp[240];
            sprintf(tmp, "Error, Unable to open file \"%s\"\n", fname);
            MsgWindow::message('E', tmp, msgw_ePop_Default);
            return LFU__NOFILE;
          }

          for (int i = 0; i < (int)nodevect.size(); i++) {
            lfu_nodeconf nc = nodevect[i];

            if (qcom_auto_dis == pwr_eYesNoEnum_Yes && i != idx)
              continue;

            if (i == idx) {
              if (!is_secondary)
                fprintf(fp, "%s %s %s %d %d %d %d %d %f %d %d %s %s\n",
                    nc.nodename, cdh_VolumeIdToString(0, 0, nc.vid, 0, 0),
                    nc.address, nc.port, nc.connection,
                    int(nc.qcom_min_resend_time * 1000),
                    int(nc.qcom_max_resend_time * 1000),
                    nc.qcom_export_buf_quota, nc.qcom_ack_delay,
                    nc.qcom_segment_size, is_secondary, "-", "-");
              else
                fprintf(fp, "%s %s %s %d %d %d %d %d %f %d %d %s %s\n",
                    nc.secondary_nodename,
                    cdh_VolumeIdToString(0, 0, nc.vid, 0, 0),
                    nc.secondary_address, nc.port, nc.connection,
                    int(nc.qcom_min_resend_time * 1000),
                    int(nc.qcom_max_resend_time * 1000),
                    nc.qcom_export_buf_quota, nc.qcom_ack_delay,
                    nc.qcom_segment_size, is_secondary, "-", "-");
            } else
              fprintf(fp, "%s %s %s %d %d %d %d %d %f %d %d %s %s\n",
                  nc.nodename, cdh_VolumeIdToString(0, 0, nc.vid, 0, 0),
                  nc.address, nc.port, nc.connection,
                  int(nc.qcom_min_resend_time * 1000),
                  int(nc.qcom_max_resend_time * 1000), nc.qcom_export_buf_quota,
                  nc.qcom_ack_delay, nc.qcom_segment_size, 0,
                  nc.secondary_nodename, nc.secondary_address);
          }

          // Add specific FriendNodes for the node
          for (wb_object fnodeo = nodeo.first(); fnodeo;
               fnodeo = fnodeo.after()) {
            switch (fnodeo.cid()) {
            case pwr_cClass_FriendNodeConfig: {
              pwr_tString80 volstr;
              lfu_nodeconf nc;

              nc.isfriend = 1;

	      sts = ldh_ObjidToName(ldhses, fnodeo.oid(), ldh_eName_Object,
				    nodeconfig_name, sizeof(nodeconfig_name), &size);

              // Get attribute NodeName
              a = sp->attribute(fnodeo.oid(), "RtBody", "NodeName");
              if (!a) {
                fclose(fp);
                return a.sts();
              }

              a.value(nc.nodename);
              if (!a) {
                fclose(fp);
                return sts;
              }

              // Get attribute Address
              a = sp->attribute(fnodeo.oid(), "RtBody", "Address");
              if (!a) {
                fclose(fp);
                return a.sts();
              }

              a.value(nc.address);
              if (!a) {
                fclose(fp);
                return sts;
              }

              // Get attribute Port
              a = sp->attribute(fnodeo.oid(), "RtBody", "Port");
              if (!a) {
                fclose(fp);
                return a.sts();
              }

              a.value(&nc.port);
              if (!a) {
                fclose(fp);
                return sts;
              }

              // Get attribute Connection
              a = sp->attribute(fnodeo.oid(), "RtBody", "Connection");
              if (!a) {
                fclose(fp);
                return a.sts();
              }

              a.value(&nc.connection);
              if (!a) {
                fclose(fp);
                return sts;
              }

              // Get attribute Volume
              a = sp->attribute(fnodeo.oid(), "RtBody", "Volume");
              if (!a) {
                fclose(fp);
                return a.sts();
              }

              a.value(volstr);
              if (!a) {
                fclose(fp);
                return sts;
              }

              // Get attribute QComMaxResendTime
              a = sp->attribute(fnodeo.oid(), "RtBody", "QComMinResendTime");
              if (!a) {
                fclose(fp);
                return a.sts();
              }

              a.value(&nc.qcom_min_resend_time);
              if (!a) {
                fclose(fp);
                return sts;
              }

              // Get attribute QComMaxResendTime
              a = sp->attribute(fnodeo.oid(), "RtBody", "QComMaxResendTime");
              if (!a) {
                fclose(fp);
                return a.sts();
              }

              a.value(&nc.qcom_max_resend_time);
              if (!a) {
                fclose(fp);
                return sts;
              }

              // Get attribute QComExportBufSize
              a = sp->attribute(nodeo.oid(), "RtBody", "QComExportBufQuota");
              if (!a) {
                fclose(fp);
                return a.sts();
              }

              a.value(&nc.qcom_export_buf_quota);
              if (!a) {
                fclose(fp);
                return sts;
              }

              // Get attribute QComAckDelay
              a = sp->attribute(nodeo.oid(), "RtBody", "QComAckDelay");
              if (!a) {
                fclose(fp);
                return a.sts();
              }

              a.value(&nc.qcom_ack_delay);
              if (!a) {
                fclose(fp);
                return sts;
              }

              /* Check that the name is in the global volume list */
              found = 0;
              volumelist_ptr = volumelist;
              for (int j = 0; j < volumecount; j++) {
                if (str_NoCaseStrcmp(volstr, volumelist_ptr->volume_name)
                    == 0) {
                  nc.vid = volumelist_ptr->volume_id;
                  found = 1;
                  break;
                }
                volumelist_ptr++;
              }

              if (!found) {
                char msg[200];
                sprintf(msg,
                    "Error in FriendNodeConfig object '%s', Unknown volume",
                    nodeconfig_name);
                MsgWindow::message('E', msg, msgw_ePop_Default);
                syntax_error = 1;
              }

              fprintf(fp, "%s %s %s %d %d %d %d %d %f %d %d %s %s\n",
                  nc.nodename, cdh_VolumeIdToString(0, 0, nc.vid, 0, 0),
                  nc.address, nc.port, nc.connection,
                  (int)(nc.qcom_min_resend_time * 1000),
                  (int)(nc.qcom_max_resend_time * 1000),
                  nc.qcom_export_buf_quota, nc.qcom_ack_delay,
                  nc.qcom_segment_size, 0, nc.secondary_nodename,
                  nc.secondary_address);
              break;
            }
            default:;
            }
          }
          fclose(fp);
        }
        break;
      }
      default:;
      }
    }

    // Print ld_recom file
    for (unsigned int i = 0; i < nodevect.size(); i++) {
      lfu_nodeconf nc = nodevect[i];

      if (nc.has_secondary) {
        for (int j = 0; j < 2; j++) {
          FILE* fp;
          int is_secondary = j;

          if (!is_secondary)
            sprintf(filename, pwr_cNameRedcom, load_cDirectory,
                cdh_Low(nodevect[i].nodename), bus_number);
          else
            sprintf(filename, pwr_cNameRedcom, load_cDirectory,
                cdh_Low(nodevect[i].secondary_nodename), bus_number);

          dcli_translate_filename(fname, filename);
          fp = fopen(fname, "w");
          if (fp == 0) {
            char tmp[240];
            sprintf(tmp, "Error, Unable to open file \"%s\"\n", fname);
            MsgWindow::message('E', tmp, msgw_ePop_Default);
            return LFU__NOFILE;
          }

          fprintf(fp, "%s %s %s %d %d %d %d %d %f %d\n", nc.nodename,
              cdh_VolumeIdToString(0, 0, nc.vid, 0, 0), nc.address,
              nc.redcom_port, 2, int(nc.redcom_min_resend_time * 1000),
              int(nc.redcom_max_resend_time * 1000), nc.redcom_export_buf_quota,
              nc.redcom_ack_delay, nc.redcom_segment_size);
          fprintf(fp, "%s %s %s %d %d %d %d %d %f %d\n", nc.secondary_nodename,
              cdh_VolumeIdToString(0, 0, nc.vid, 0, 0), nc.secondary_address,
              nc.redcom_port, 1, int(nc.redcom_min_resend_time * 1000),
              int(nc.redcom_max_resend_time * 1000), nc.redcom_export_buf_quota,
              nc.redcom_ack_delay, nc.redcom_segment_size);
          fclose(fp);
        }
      }
    }
  }

  /* Generate data for distribution, custom build and build options */
  dcli_translate_filename(fname, pwr_cNameDistribute);
  file = fopen(fname, "w");
  if (file == 0) {
    char tmp[240];
    sprintf(tmp, "Error, Unable to open file \"%s\"\n", fname);
    MsgWindow::message('E', tmp, msgw_ePop_Default);
    return LFU__NOFILE;
  }

  /* Get the system name */
  sts = utl_get_systemobject(ldhses, &systemobjid, systemname, systemgroup);
  if (EVEN(sts)) {
    char msg[200];
    sprintf(msg, "Error in System object, object is missing");
    MsgWindow::message('E', msg, msgw_ePop_Default);
    syntax_error = 1;
  }
  if (!strcmp(systemname, "")) {
    char msg[200];
    sprintf(msg, "Error in System object, SystemName is missing");
    MsgWindow::message('E', msg, msgw_ePop_Default);
    syntax_error = 1;
  }

  fprintf(file, "project %s\n", systemname);

  /* Get the Distribute data of the node config objects */
  sts = ldh_GetRootList(ldhses, &busobjid);
  while (ODD(sts)) {
    sts = ldh_GetObjectClass(ldhses, busobjid, &cid);
    if (EVEN(sts))
      return sts;

    if (cid == pwr_cClass_BusConfig) {
      /* Check DmqBus attribute */
      sts = ldh_GetObjectPar(ldhses, busobjid, "RtBody", "BusNumber",
          (char**)&bus_number_ptr, &size);
      if (EVEN(sts))
        return sts;

      sts = ldh_GetChild(ldhses, busobjid, &nodeobjid);
      while (ODD(sts)) {
        distr_options = 0;
        distr_disable = 0;

        sts = ldh_GetObjectClass(ldhses, nodeobjid, &cid);
        if (EVEN(sts))
          return sts;

        if (cid == pwr_cClass_NodeConfig || cid == pwr_cClass_SevNodeConfig) {
          sts = ldh_ObjidToName(ldhses, nodeobjid, ldh_eName_Object,
              nodeconfig_name, sizeof(nodeconfig_name), &size);
          if (EVEN(sts))
            return sts;

          /* Check if Disabled attribute */
          sts = ldh_GetObjectPar(ldhses, nodeobjid, "RtBody",
              "DistributeDisable", (char**)&distr_disable_ptr, &size);
          if (ODD(sts)) {
            distr_disable = *distr_disable_ptr;
            free(distr_disable_ptr);
          }

          /* Check NodeName attribute */
          sts = ldh_GetObjectPar(
              ldhses, nodeobjid, "RtBody", "NodeName", &nodename_ptr, &size);
          if (EVEN(sts))
            return sts;

          if (!strcmp(nodename_ptr, "")) {
            free(nodename_ptr);
            nodename_ptr = null_nodename;
          }

          if (cid == pwr_cClass_NodeConfig) {
            /* Check SecondaryNode.NodeName attribute */
            sts = ldh_GetObjectPar(ldhses, nodeobjid, "RtBody",
                "SecondaryNode.NodeName", &secondary_nodename_ptr, &size);
            if (EVEN(sts))
              return sts;

            if (streq(secondary_nodename_ptr, "")) {
              free(secondary_nodename_ptr);
              secondary_nodename_ptr = null_nodename;
            }
          } else
            secondary_nodename_ptr = null_nodename;

          /* Check BootNode attribute */
          sts = ldh_GetObjectPar(
              ldhses, nodeobjid, "RtBody", "BootNode", &bootnode_ptr, &size);
          if (EVEN(sts))
            return sts;

          if (!strcmp(bootnode_ptr, "") || !strcmp(bootnode_ptr, "-")) {
            free(bootnode_ptr);
            bootnode_ptr = null_nodename;
          }

          if (cid == pwr_cClass_NodeConfig) {
            /* Check SecondaryNode.BootNode attribute */
            sts = ldh_GetObjectPar(ldhses, nodeobjid, "RtBody",
                "SecondaryNode.BootNode", &secondary_bootnode_ptr, &size);
            if (EVEN(sts))
              return sts;

            if (!strcmp(secondary_bootnode_ptr, "")
                || !strcmp(secondary_bootnode_ptr, "-")) {
              free(secondary_bootnode_ptr);
              secondary_bootnode_ptr = null_nodename;
            }
          } else
            secondary_bootnode_ptr = null_nodename;

          /* Check OperatingSystem attribute */
          sts = ldh_GetObjectPar(ldhses, nodeobjid, "RtBody", "OperatingSystem",
              (char**)&os_ptr, &size);
          if (EVEN(sts))
            return sts;

          os = *os_ptr;
          sprintf(os_str, "%d", os);

          /* Get RemoteAccessType attribute */
          sts = ldh_GetObjectPar(ldhses, nodeobjid, "RtBody",
              "RemoteAccessType", (char**)&remote_access_type_ptr, &size);
          if (EVEN(sts))
            return sts;

          if (*remote_access_type_ptr == pwr_eRemoteShellEnum_RSH)
            distr_options |= lfu_mDistrOpt_RSH;
          free(remote_access_type_ptr);

          /* Check that there is a rootvolume for this node */
          found = 0;
          sts = ldh_GetChild(ldhses, nodeobjid, &volobjid);
          while (ODD(sts)) {
            sts = ldh_GetObjectClass(ldhses, volobjid, &ccid);
            if (EVEN(sts))
              return sts;

            if (ccid == pwr_cClass_RootVolumeLoad) {
              found = 1;
              break;
            }
            sts = ldh_GetNextSibling(ldhses, volobjid, &volobjid);
          }
          if (!found)
            distr_options = (lfu_mDistrOpt)(
                (int)distr_options | lfu_mDistrOpt_NoRootVolume);

          strcpy(custom_platform, "-");
          custom_os = pwr_mOpSys__;

          /* Find any CustomBuild for this node */
          class_vect[0] = pwr_cClass_CustomBuild;
          class_vect[1] = 0;

          objcount = 0;
          objlist = 0;

          sts = trv_create_ctx(
              &trvctx, ldhses, nodeobjid, class_vect, NULL, NULL);
          if (EVEN(sts))
            return sts;

          sts = trv_object_search(
              trvctx, &utl_objidlist_insert, &objlist, &objcount, 0, 0, 0);
          if (EVEN(sts))
            return sts;

          sts = trv_delete_ctx(trvctx);

          for (obj_ptr = objlist; obj_ptr; obj_ptr = obj_ptr->next) {
            applobjid = obj_ptr->objid;
            sts = ldh_GetObjectClass(ldhses, applobjid, &ccid);
            if (EVEN(sts))
              return sts;

            switch (ccid) {
            case pwr_cClass_CustomBuild: {
              char* platform_p;
              pwr_tMask* os_p;

              sts = ldh_ObjidToName(ldhses, applobjid, ldh_eName_Object,
                  appl_name, sizeof(appl_name), &size);
              if (EVEN(sts))
                return sts;

              /* Get Platform attribute */
              sts = ldh_GetObjectPar(
                  ldhses, applobjid, "DevBody", "Platform", &platform_p, &size);
              if (EVEN(sts))
                return sts;

              if (!streq(platform_p, ""))
                strncpy(custom_platform, platform_p, sizeof(custom_platform));
              free(platform_p);

              /* Get OperatingSystem attribute */
              sts = ldh_GetObjectPar(ldhses, applobjid, "DevBody",
                  "OperatingSystem", (char**)&os_p, &size);
              if (EVEN(sts))
                return sts;

              custom_os = (pwr_mOpSys)*os_p;
              free(os_p);
              break;
            }
            default:;
            }
          }

          /* Find any BuildOptions for this node */
          class_vect[0] = pwr_cClass_BuildOptions;
          class_vect[1] = 0;

          objcount = 0;
          objlist = 0;

          sts = trv_create_ctx(
              &trvctx, ldhses, nodeobjid, class_vect, NULL, NULL);
          if (EVEN(sts))
            return sts;

          sts = trv_object_search(
              trvctx, &utl_objidlist_insert, &objlist, &objcount, 0, 0, 0);
          if (EVEN(sts))
            return sts;

          sts = trv_delete_ctx(trvctx);

          for (obj_ptr = objlist; obj_ptr; obj_ptr = obj_ptr->next) {
            applobjid = obj_ptr->objid;
            sts = ldh_GetObjectClass(ldhses, applobjid, &ccid);
            if (EVEN(sts))
              return sts;

            switch (ccid) {
            case pwr_cClass_BuildOptions: {
              pwr_sClass_BuildOptions* bop;
              int size;
              pwr_tString80 ar, opt;
              char str[2000] = "";
              FILE* optfile;
              char dir[80];
              pwr_tObjName plcproc;

              if (os == pwr_mOpSys_CustomBuild && custom_os == pwr_mOpSys__)
                break;

#if defined OS_LINUX
              strcpy(str, "`: Autogenerated options file, Do not edit !!` ");
#endif

              sts = ldh_ObjidToName(ldhses, applobjid, ldh_eName_Object,
                  appl_name, sizeof(appl_name), &size);
              if (EVEN(sts))
                return sts;

              sts = ldh_GetObjectBody(
                  ldhses, applobjid, "RtBody", (void**)&bop, &size);
              if (EVEN(sts))
                return sts;

              for (int i = 0; i < (int)(sizeof(bop->ArchivePath)
                                      / sizeof(bop->ArchivePath[0]));
                   i++) {
                str_trim(opt, bop->ArchivePath[i]);
                if (!streq(opt, ""))
                  sprintf(&str[strlen(str)], "-L%s ", opt);
              }

              for (int i = 0; i < (int)(sizeof(bop->ObjectModules)
                                      / sizeof(bop->ObjectModules[0]));
                   i++) {
                str_trim(opt, bop->ObjectModules[i]);
                if (!streq(opt, ""))
                  sprintf(&str[strlen(str)], "%s ", opt);
              }

              if (bop->SystemModules & pwr_mBuildOptionsMask_IoUser)
                sprintf(&str[strlen(str)], "$pwrp_obj/rt_io_user.o ");
              else {
                if (os == pwr_mOpSys_CustomBuild)
                  sprintf(&str[strlen(str)],
                      "$pwrb_root/%s/exp/obj/rt_io_user.o ",
                      cdh_OpSysToDirStr((pwr_mOpSys)custom_os));
                else
                  sprintf(&str[strlen(str)],
                      "$pwrb_root/%s/exp/obj/rt_io_user.o ",
                      cdh_OpSysToDirStr((pwr_mOpSys)os));
              }

              for (int i = 0;
                   i < (int)(sizeof(bop->Archives) / sizeof(bop->Archives[0]));
                   i++) {
                str_trim(opt, bop->Archives[i]);
                if (!streq(opt, "")) {
                  if (str_StartsWith(opt, "lib"))
                    strncpy(ar, &opt[3], sizeof(ar));
                  else
                    strncpy(ar, opt, sizeof(ar));
                  if (streq(&ar[strlen(ar) - 2], ".a"))
                    ar[strlen(ar) - 2] = 0;
                  else if (streq(&ar[strlen(ar) - 3], ".so"))
                    ar[strlen(ar) - 3] = 0;
                  sprintf(&str[strlen(str)], "-l%s ", ar);
                }
              }

              if (bop->SystemModules & pwr_mBuildOptionsMask_PwrpArchive)
                sprintf(&str[strlen(str)], "-lpwrp ");

              if (bop->SystemModules & pwr_mBuildOptionsMask_NMpsArchive)
                sprintf(&str[strlen(str)], "-lpwr_nmps ");

              if (bop->SystemModules & pwr_mBuildOptionsMask_MiscArchive)
                sprintf(&str[strlen(str)], "-lpwr_misc ");

              if (bop->SystemModules & pwr_mBuildOptionsMask_RemoteArchive)
                sprintf(&str[strlen(str)], "-lpwr_remote ");

              if (bop->SystemModules & pwr_mBuildOptionsMask_SsaboxArchive)
                sprintf(&str[strlen(str)], "-lpwr_ssabox ");

              if (bop->SystemModules & pwr_mBuildOptionsMask_SimulArchive)
                sprintf(&str[strlen(str)], "-lpwr_simul ");

              sprintf(&str[strlen(str)], "-lpwr_rt ");

              if (bop->SystemModules & pwr_mBuildOptionsMask_SoftingPNAK)
                sprintf(&str[strlen(str)], "-lprofinet ");
              else
                sprintf(&str[strlen(str)], "-lpwr_pnak_dummy ");

              if (bop->SystemModules & pwr_mBuildOptionsMask_HilscherCifX)
                sprintf(&str[strlen(str)], "-lcifx ");
              else
                sprintf(&str[strlen(str)], "-lpwr_cifx_dummy ");

              if (bop->SystemModules & pwr_mBuildOptionsMask_UsbLib)
                sprintf(&str[strlen(str)], "-lusblib-1.0 ");
              else
                sprintf(&str[strlen(str)], "-lpwr_usb_dummy ");

              if (bop->SystemModules & pwr_mBuildOptionsMask_MotionControlUSBIO)
                sprintf(&str[strlen(str)], "-lusbio ");
              else
                sprintf(&str[strlen(str)], "-lpwr_usbio_dummy ");

              if (bop->SystemModules & pwr_mBuildOptionsMask_Nodave)
                sprintf(&str[strlen(str)], "-lnodave ");
              else
                sprintf(&str[strlen(str)], "-lpwr_nodave_dummy ");

              // Powerlink can't be called from plc yet, always use the dummy
              sprintf(&str[strlen(str)], "-lpwr_epl_dummy ");

              if (streq(bop->PlcProcess, "")) {
                char msg[200];
                sprintf(msg, "Error in BuildOptions object '%s', PlcProcess is "
                             "missing\n",
                    appl_name);
                MsgWindow::message('E', msg, msgw_ePop_Default);
                syntax_error = 1;
                free((char*)bop);
              } else {
                strncpy(plcproc, bop->PlcProcess, sizeof(plcproc));
                free((char*)bop);

                if (os == pwr_mOpSys_CustomBuild)
                  sprintf(dir, "$pwrp_root/bld/%s/exe/",
                      cdh_OpSysToStr((pwr_mOpSys)custom_os));
                else
                  sprintf(dir, "$pwrp_root/bld/%s/exe/",
                      cdh_OpSysToStr((pwr_mOpSys)os));
                str_ToLower(nodename, nodename_ptr);
                sprintf(fname, pwr_cNameOpt, dir, nodename, *bus_number_ptr,
                    cdh_Low(plcproc));
                dcli_translate_filename(fname, fname);
                optfile = fopen(fname, "w");
                if (optfile == 0) {
                  char tmp[240];
                  sprintf(tmp, "Error, Unable to open file \"%s\"\n", fname);
                  MsgWindow::message('E', tmp, msgw_ePop_Default);
                  return LFU__NOFILE;
                }
                fprintf(optfile, "%s", str);
                fclose(optfile);

                if (secondary_nodename_ptr != null_nodename) {
                  if (os == pwr_mOpSys_CustomBuild)
                    sprintf(dir, "$pwrp_root/bld/%s/exe/",
                        cdh_OpSysToStr((pwr_mOpSys)custom_os));
                  else
                    sprintf(dir, "$pwrp_root/bld/%s/exe/",
                        cdh_OpSysToStr((pwr_mOpSys)os));
                  str_ToLower(nodename, secondary_nodename_ptr);
                  sprintf(fname, pwr_cNameOpt, dir, nodename, *bus_number_ptr,
                      cdh_Low(plcproc));
                  dcli_translate_filename(fname, fname);
                  optfile = fopen(fname, "w");
                  if (optfile == 0) {
                    char tmp[240];
                    sprintf(tmp, "Error, Unable to open file \"%s\"\n", fname);
                    MsgWindow::message('E', tmp, msgw_ePop_Default);
                    return LFU__NOFILE;
                  }
                  fprintf(optfile, "%s", str);
                  fclose(optfile);
                }
              }
              break;
            }
            default:;
            }
          }

          if (distr_disable) {
            /* Distribution is disabled, goto next node */
            sts = ldh_GetNextSibling(ldhses, nodeobjid, &nodeobjid);
            continue;
          }

          fprintf(file, "node %s %s %d %d %s %s\n", nodename_ptr, os_str,
              *bus_number_ptr, distr_options, bootnode_ptr, custom_platform);
          if (secondary_nodename_ptr != null_nodename)
            fprintf(file, "node %s %s %d %d %s %s\n", secondary_nodename_ptr,
                os_str, *bus_number_ptr, distr_options, secondary_bootnode_ptr,
                custom_platform);

          /* Find the applications for this node */
          class_vect[0] = pwr_cClass_Distribute;
          class_vect[1] = pwr_cClass_ApplDistribute;
          class_vect[2] = pwr_cClass_DistrDependNode;
          class_vect[3] = 0;

          objcount = 0;
          objlist = 0;

          sts = trv_create_ctx(
              &trvctx, ldhses, nodeobjid, class_vect, NULL, NULL);
          if (EVEN(sts))
            return sts;

          sts = trv_object_search(
              trvctx, &utl_objidlist_insert, &objlist, &objcount, 0, 0, 0);
          if (EVEN(sts))
            return sts;

          sts = trv_delete_ctx(trvctx);

          for (int k = 0; k < 2; k++) {
            char* stored_nodename_ptr = nodename_ptr;

            if (k == 1 && secondary_nodename_ptr == null_nodename)
              break;
            if (k == 1)
              nodename_ptr = secondary_nodename_ptr;

            for (obj_ptr = objlist; obj_ptr; obj_ptr = obj_ptr->next) {
              applobjid = obj_ptr->objid;
              sts = ldh_GetObjectClass(ldhses, applobjid, &ccid);
              if (EVEN(sts))
                return sts;

              switch (ccid) {
              case pwr_cClass_Distribute: {
                pwr_mDistrComponentMask* components_ptr;

                sts = ldh_ObjidToName(ldhses, applobjid, ldh_eName_Object,
                    appl_name, sizeof(appl_name), &size);
                if (EVEN(sts))
                  return sts;

                /* Check Components attribute */
                sts = ldh_GetObjectPar(ldhses, applobjid, "DevBody",
                    "Components", (char**)&components_ptr, &size);
                if (EVEN(sts))
                  return sts;

                if (*components_ptr & pwr_mDistrComponentMask_LoadFiles
                    && !(distr_options & lfu_mDistrOpt_NoRootVolume)) {
                  fprintf(file, "load %s\n", nodename_ptr);
                } else if (cid == pwr_cClass_SevNodeConfig)
                  fprintf(file, "boot %s\n", nodename_ptr);

                if (*components_ptr & pwr_mDistrComponentMask_UserDatabase)
                  fprintf(file, "appl %s W "
                                "$pwrp_cnf/%s/pwr_user2.dat:$pwra_db/"
                                "pwr_user2.dat $pwra_db/pwr_user2.dat\n",
                      nodename_ptr, nodename_ptr);
                if (*components_ptr & pwr_mDistrComponentMask_ApplFile)
                  fprintf(file, "appl %s W " pwr_cNameAppl " $pwrp_load/\n",
                      nodename_ptr, "$pwrp_load/", nodename_ptr,
                      *bus_number_ptr);
                if (*components_ptr & pwr_mDistrComponentMask_PwrpAliasFile)
                  fprintf(file, "appl %s W $pwrp_load/pwrp_alias.dat "
                                "$pwrp_load/pwrp_alias.dat\n",
                      nodename_ptr);
                if (*components_ptr & pwr_mDistrComponentMask_IncludeFiles)
                  fprintf(file, "appl %s W $pwrp_inc/*.h\n", nodename_ptr);
                if (*components_ptr & pwr_mDistrComponentMask_GraphFiles)
                  fprintf(file, "appl %s W $pwrp_exe/*.pwg\n", nodename_ptr);
                if (*components_ptr & pwr_mDistrComponentMask_XMLFiles)
                  fprintf(file, "appl %s W $pwrp_load/*.xml\n", nodename_ptr);
                if (*components_ptr & pwr_mDistrComponentMask_XttHelpFile) {
                  fprintf(file, "appl %s W "
                                "$pwrp_load/%s/xtt_help.dat:$pwrp_load/"
                                "xtt_help.dat $pwrp_load/xtt_help.dat\n",
                      nodename_ptr, nodename_ptr);
                }
                if (*components_ptr & pwr_mDistrComponentMask_XttResourceFile) {
                  fprintf(file, "appl %s W "
                                "$pwrp_load/%s/b55/Rt_xtt:$pwrp_load/%s/"
                                "Rt_xtt:$pwrp_load/Rt_xtt /home/b55/Rt_xtt\n",
                      nodename_ptr, nodename_ptr, nodename_ptr);
                  fprintf(file,
                      "appl %s S $pwrp_load/%s/pwrp/Rt_xtt /home/pwrp/Rt_xtt\n",
                      nodename_ptr, nodename_ptr);
                }
                if (*components_ptr & pwr_mDistrComponentMask_XttSetupFile) {
                  fprintf(file,
                      "appl %s W "
                      "$pwrp_load/%s/b55/xtt_setup.rtt_com:$pwrp_load/%s/"
                      "xtt_setup.rtt_com:$pwrp_load/xtt_setup.rtt_com "
                      "/home/b55/xtt_setup.rtt_com\n",
                      nodename_ptr, nodename_ptr, nodename_ptr);
                  fprintf(file, "appl %s S "
                                "$pwrp_load/%s/pwrp/xtt_setup.rtt_com "
                                "/home/pwrp/xtt_setup.rtt_com\n",
                      nodename_ptr, nodename_ptr);
                }
                if (*components_ptr & pwr_mDistrComponentMask_FlowFiles)
                  fprintf(file, "appl %s W $pwrp_load/*.flw\n", nodename_ptr);
                if (*components_ptr & pwr_mDistrComponentMask_RHostsFile)
                  fprintf(file, "appl %s W "
                                "$pwrp_cnf/%s/.rhosts:$pwra_db/.rhosts "
                                "/home/pwrp/.rhosts\n",
                      nodename_ptr, nodename_ptr);
                if (*components_ptr
                    & pwr_mDistrComponentMask_AuthorizedKeysFile)
                  fprintf(file, "appl %s W "
                                "$pwrp_cnf/%s/authorized_keys:$pwra_db/"
                                "authorized_keys "
                                "/home/pwrp/.ssh/authorized_keys\n",
                      nodename_ptr, nodename_ptr);
                if (*components_ptr & pwr_mDistrComponentMask_WebFiles) {
                  fprintf(file, "appl %s W $pwrp_web/*.html\n", nodename_ptr);
                  fprintf(file, "appl %s S $pwrp_web/*.jar\n", nodename_ptr);
                  fprintf(file, "appl %s S $pwrp_web/*.gif\n", nodename_ptr);
                  fprintf(file, "appl %s S $pwrp_web/*.png\n", nodename_ptr);
                  fprintf(file, "appl %s S $pwrp_web/*.jpg\n", nodename_ptr);
                  fprintf(file, "appl %s S $pwrp_web/*.pdf\n", nodename_ptr);
                  fprintf(file, "appl %s S $pwrp_web/*.pwg\n", nodename_ptr);
                }
                if (*components_ptr & pwr_mDistrComponentMask_PwrpStop)
                  fprintf(file, "appl %s W "
                                "$pwrp_load/%s/pwrp_stop.sh:$pwrp_load/"
                                "pwrp_stop.sh $pwrp_exe/pwrp_stop.sh\n",
                      nodename_ptr, nodename_ptr);

                free(components_ptr);

                break;
              }
              case pwr_cClass_ApplDistribute:
                sts = ldh_ObjidToName(ldhses, applobjid, ldh_eName_Object,
                    appl_name, sizeof(appl_name), &size);
                if (EVEN(sts))
                  return sts;

                /* Check Source attribute */
                sts = ldh_GetObjectPar(
                    ldhses, applobjid, "DevBody", "Source", &source_ptr, &size);
                if (EVEN(sts))
                  return sts;

                if (!strcmp(source_ptr, "")) {
                  char msg[200];
                  free(source_ptr);
                  source_ptr = null_nodename;
                  sprintf(msg,
                      "Error in ApplDistribute object '%s', Source is missing",
                      appl_name);
                  MsgWindow::message('E', msg, msgw_ePop_Default);
                  syntax_error = 1;
                }
                /* Check Target attribute */
                sts = ldh_GetObjectPar(
                    ldhses, applobjid, "DevBody", "Target", &target_ptr, &size);
                if (EVEN(sts))
                  return sts;

                if (!strcmp(target_ptr, ""))
                  fprintf(file, "appl %s E %s\n", nodename_ptr, source_ptr);
                else
                  fprintf(file, "appl %s E %s %s\n", nodename_ptr, source_ptr,
                      target_ptr);
                if (source_ptr != null_nodename)
                  free(source_ptr);
                free(target_ptr);
                break;
              case pwr_cClass_DistrDependNode: {
                char* depnodename_ptr;
                char* project_ptr;

                sts = ldh_ObjidToName(ldhses, applobjid, ldh_eName_Object,
                    appl_name, sizeof(appl_name), &size);
                if (EVEN(sts))
                  return sts;

                /* Check Node attribute */
                sts = ldh_GetObjectPar(ldhses, applobjid, "DevBody", "NodeName",
                    &depnodename_ptr, &size);
                if (EVEN(sts))
                  return sts;

                if (!strcmp(depnodename_ptr, "")) {
                  char msg[200];
                  free(depnodename_ptr);
                  depnodename_ptr = null_nodename;
                  sprintf(msg, "Error in DistrDependNode object '%s', NodeName "
                               "is missing",
                      appl_name);
                  MsgWindow::message('E', msg, msgw_ePop_Default);
                  syntax_error = 1;
                }
                /* Check Project attribute */
                sts = ldh_GetObjectPar(ldhses, applobjid, "DevBody", "Project",
                    &project_ptr, &size);
                if (EVEN(sts))
                  return sts;

                if (!strcmp(project_ptr, ""))
                  project_ptr = systemname;

                fprintf(file, "depnode %s %s %s\n", nodename_ptr,
                    depnodename_ptr, project_ptr);
                if (depnodename_ptr != null_nodename)
                  free(depnodename_ptr);
                if (project_ptr != systemname)
                  free(project_ptr);
                break;
              }
              default:;
              }
            }
            if (k == 1)
              nodename_ptr = stored_nodename_ptr;
          }
          if (nodename_ptr != null_nodename)
            free(nodename_ptr);
          if (secondary_nodename_ptr != null_nodename)
            free(secondary_nodename_ptr);
          if (bootnode_ptr != null_nodename)
            free(bootnode_ptr);
          free((char*)os_ptr);
          utl_objidlist_free(objlist);
        }
        sts = ldh_GetNextSibling(ldhses, nodeobjid, &nodeobjid);
      }
      free((char*)bus_number_ptr);
    }
    sts = ldh_GetNextSibling(ldhses, busobjid, &busobjid);
  }

  /* Get the DbDistribute objects */
  sts = ldh_GetRootList(ldhses, &dbobjid);
  while (ODD(sts)) {
    sts = ldh_GetObjectClass(ldhses, dbobjid, &cid);
    if (EVEN(sts))
      return sts;

    if (cid == pwr_cClass_RootVolumeConfig || cid == pwr_cClass_SubVolumeConfig
        || cid == pwr_cClass_ClassVolumeConfig
        || cid == pwr_cClass_DetachedClassVolumeConfig
        || cid == pwr_cClass_SharedVolumeConfig) {
      sts = ldh_ObjidToName(ldhses, volobjid, ldh_eName_Object, volume_name,
          sizeof(volume_name), &size);
      if (EVEN(sts))
        return sts;
      utl_toupper(name, volume_name);

      /* Check that the name is in the global volume list */
      found = 0;
      volumelist_ptr = volumelist;
      for (i = 0; i < volumecount; i++) {
        utl_toupper(volname, volumelist_ptr->volume_name);
        if (!strcmp(name, volname)) {
          volume_id = volumelist_ptr->volume_id;
          found = 1;
          break;
        }
        volumelist_ptr++;
      }
      /* Get any child of class VolumeDistribute */
      sts = ldh_GetChild(ldhses, volobjid, &distrobjid);
      while (ODD(sts)) {
        sts = ldh_GetObjectClass(ldhses, distrobjid, &cid);
        if (EVEN(sts))
          return sts;

        if (cid == pwr_cClass_VolumeDistribute) {
          sts = ldh_GetObjectPar(ldhses, distrobjid, "RtBody", "TargetNode",
              &targetnode_ptr, &size);
          if (EVEN(sts))
            return sts;

          sts = ldh_GetObjectPar(ldhses, distrobjid, "RtBody", "TargetProject",
              &targetproject_ptr, &size);
          if (EVEN(sts))
            return sts;

          sts = ldh_GetObjectPar(ldhses, distrobjid, "RtBody", "TargetOpSys",
              (char**)&os_ptr, &size);
          if (EVEN(sts))
            return sts;

          fprintf(file, "volumedistr %s %s %s %d\n",
              cdh_VolumeIdToString(0, 0, volume_id, 0, 0), targetnode_ptr,
              targetproject_ptr, *os_ptr);
          free(targetnode_ptr);
          free(targetproject_ptr);
        }
        sts = ldh_GetNextSibling(ldhses, distrobjid, &distrobjid);
      }
    }
    sts = ldh_GetNextSibling(ldhses, dbobjid, &dbobjid);
  }

  // Export files
  pwr_tOid exportoid;

  for (sts = ldh_GetClassList(ldhses, pwr_cClass_Export, &exportoid); ODD(sts);
       sts = ldh_GetNextObject(ldhses, exportoid, &exportoid)) {
    pwr_tFileName dir;
    char* dir_ptr;
    pwr_tMask* options_ptr;
    pwr_mExportImportMask* components_ptr;
    pwr_tOid appoid;
    pwr_tMask current_options = 0;

    sts = ldh_GetObjectPar(ldhses, exportoid, "DevBody", "TargetDirectory",
        (char**)&dir_ptr, &size);
    if (EVEN(sts))
      return sts;

    strncpy(dir, dir_ptr, sizeof(dir));
    free(dir_ptr);
    if (streq(dir, "")) {
      MsgWindow::message('E', "Export directory is missing", msgw_ePop_Default);
      continue;
    }

    if (dir[strlen(dir) - 1] != '/')
      strcat(dir, "/");

    sts = ldh_GetObjectPar(
        ldhses, exportoid, "DevBody", "Options", (char**)&options_ptr, &size);
    if (EVEN(sts))
      return sts;

    current_options = *options_ptr;
    free(options_ptr);

    sts = ldh_GetObjectPar(ldhses, exportoid, "DevBody", "Components",
        (char**)&components_ptr, &size);
    if (EVEN(sts))
      return sts;

    if (*components_ptr & pwr_mExportImportMask_IncludeFiles)
      fprintf(file, "export %d $pwrp_inc/*.h %s\n", current_options, dir);
    if (*components_ptr & pwr_mExportImportMask_GraphFiles)
      fprintf(file, "export %d $pwrp_exe/*.pwg %s\n", current_options, dir);
    if (*components_ptr & pwr_mExportImportMask_FlowFiles)
      fprintf(file, "export %d $pwrp_load/*.flw %s\n", current_options, dir);
    if (*components_ptr & pwr_mExportImportMask_LoadFiles) {
      fprintf(file, "export %d $pwrp_load/*.dbs %s\n", current_options, dir);
      fprintf(file, "export %d $pwrp_load/rtt_crr_*.dat %s\n", current_options,
          dir);
      fprintf(file, "export %d $pwrp_load/rtt_crro_*.dat %s\n", current_options,
          dir);
      fprintf(file, "export %d $pwrp_load/rtt_crrs_*.dat %s\n", current_options,
          dir);
      fprintf(file, "export %d $pwrp_load/rtt_crrc_*.dat %s\n", current_options,
          dir);
    }

    free(components_ptr);

    for (sts = ldh_GetChild(ldhses, exportoid, &appoid); ODD(sts);
         sts = ldh_GetNextSibling(ldhses, appoid, &appoid)) {
      sts = ldh_GetObjectClass(ldhses, appoid, &cid);
      if (EVEN(sts))
        return sts;

      switch (cid) {
      case pwr_cClass_ApplExport: {
        sts = ldh_GetObjectPar(
            ldhses, appoid, "DevBody", "Source", (char**)&source_ptr, &size);
        if (EVEN(sts))
          return sts;

        sts = ldh_GetObjectPar(
            ldhses, appoid, "DevBody", "Target", (char**)&target_ptr, &size);
        if (EVEN(sts))
          return sts;

        fprintf(file, "export %d %s %s%s\n", current_options, source_ptr, dir,
            target_ptr);

        free(source_ptr);
        free(target_ptr);
        break;
      }
      default:;
      }
    }
  }

  // Import files
  pwr_tOid importoid;

  for (sts = ldh_GetClassList(ldhses, pwr_cClass_Import, &importoid); ODD(sts);
       sts = ldh_GetNextObject(ldhses, importoid, &importoid)) {
    pwr_tFileName dir;
    char* dir_ptr;
    pwr_mExportImportMask* components_ptr;
    pwr_tOid appoid;
    pwr_tMask* options_ptr;
    pwr_tMask current_options = 0;

    sts = ldh_GetObjectPar(ldhses, importoid, "DevBody", "SourceDirectory",
        (char**)&dir_ptr, &size);
    if (EVEN(sts))
      return sts;

    strncpy(dir, dir_ptr, sizeof(dir));
    free(dir_ptr);
    if (streq(dir, "")) {
      MsgWindow::message('E', "Import directory is missing", msgw_ePop_Default);
      continue;
    }

    if (dir[strlen(dir) - 1] != '/')
      strcat(dir, "/");

    sts = ldh_GetObjectPar(
        ldhses, importoid, "DevBody", "Options", (char**)&options_ptr, &size);
    if (EVEN(sts))
      return sts;

    current_options = *options_ptr;
    free(options_ptr);

    sts = ldh_GetObjectPar(ldhses, importoid, "DevBody", "Components",
        (char**)&components_ptr, &size);
    if (EVEN(sts))
      return sts;

    if (*components_ptr & pwr_mExportImportMask_IncludeFiles)
      fprintf(file, "import %d %s*.h $pwrp_inc/\n", current_options, dir);
    if (*components_ptr & pwr_mExportImportMask_GraphFiles)
      fprintf(file, "import %d %s*.pwg $pwrp/exe/\n", current_options, dir);
    if (*components_ptr & pwr_mExportImportMask_FlowFiles)
      fprintf(file, "import %d %s*.flw $pwrp_load/\n", current_options, dir);
    if (*components_ptr & pwr_mExportImportMask_LoadFiles) {
      fprintf(file, "import %d %s*.dbs $pwrp_load/\n", current_options, dir);
      fprintf(file, "import %d %srtt_crr_*.dat $pwrp_load/\n", current_options,
          dir);
      fprintf(file, "import %d %srtt_crro_*.dat $pwrp_load/\n", current_options,
          dir);
      fprintf(file, "import %d %srtt_crrs_*.dat $pwrp_load/\n", current_options,
          dir);
      fprintf(file, "import %d %srtt_crrc_*.dat $pwrp_load/\n", current_options,
          dir);
    }

    free(components_ptr);

    for (sts = ldh_GetChild(ldhses, importoid, &appoid); ODD(sts);
         sts = ldh_GetNextSibling(ldhses, appoid, &appoid)) {
      sts = ldh_GetObjectClass(ldhses, appoid, &cid);
      if (EVEN(sts))
        return sts;

      switch (cid) {
      case pwr_cClass_ApplImport: {
        char target_array[10][80];
        int target_cnt;

        sts = ldh_GetObjectPar(
            ldhses, appoid, "DevBody", "Source", (char**)&source_ptr, &size);
        if (EVEN(sts))
          return sts;

        sts = ldh_GetObjectPar(
            ldhses, appoid, "DevBody", "Target", (char**)&target_ptr, &size);
        if (EVEN(sts))
          return sts;

        // Target can be a list
        target_cnt = dcli_parse(target_ptr, ",", "", (char*)target_array,
            sizeof(target_array) / sizeof(target_array[0]),
            sizeof(target_array[0]), 0);
        for (int i = 0; i < target_cnt; i++) {
          str_trim(target_array[i], target_array[i]);
          fprintf(file, "import %d %s%s %s\n", current_options, dir, source_ptr,
              target_array[i]);
        }
        free(source_ptr);
        free(target_ptr);
        break;
      }
      default:;
      }
    }
  }

  // Build files
  pwr_tOid builddir_oid;
  pwr_tOid coid;
  pwr_tObjName oname;
  pwr_tOName fullname;
  pwr_tOid poid;
  pwr_tOid buildconfig_oid;

  // Build config object, check version manager
  sts = ldh_GetClassList(ldhses, pwr_cClass_BuildConfig, &buildconfig_oid);
  if (ODD(sts)) {
    pwr_tEnum version_manager;

    wb_attribute a
        = sp->attribute(buildconfig_oid, "DevBody", "VersionManager");
    if (!a)
      return a.sts();

    a.value(&version_manager);
    if (!a)
      return sts;

    wb_revision rev(0, 0);
    if (rev.manager_enum() != version_manager) {
      rev.set_manager_enum((pwr_eVersionManagerEnum)version_manager);
      rev.write_file();
    }
  }

  for (sts = ldh_GetClassList(ldhses, pwr_cClass_BuildDirectory, &builddir_oid);
       ODD(sts); sts = ldh_GetNextObject(ldhses, builddir_oid, &builddir_oid)) {
    pwr_tFileName dir;
    char* dir_ptr;
    char* descr_ptr;
    pwr_tMask* options_ptr;

    sts = ldh_ObjidToName(
        ldhses, builddir_oid, ldh_eName_Object, oname, sizeof(oname), &size);

    strcpy(fullname, oname);
    for (sts = ldh_GetParent(ldhses, builddir_oid, &poid); ODD(sts);
         sts = ldh_GetParent(ldhses, poid, &poid)) {
      pwr_tOName tmp;
      pwr_tCid pcid;

      sts = ldh_GetObjectClass(ldhses, poid, &pcid);
      if (EVEN(sts))
        return sts;

      if (pcid != pwr_cClass_BuildDirectory)
        break;

      strcpy(tmp, fullname);
      sts = ldh_ObjidToName(
          ldhses, poid, ldh_eName_Object, oname, sizeof(oname), &size);
      if (EVEN(sts))
        return sts;

      strcpy(fullname, oname);
      strcat(fullname, "-");
      strcat(fullname, tmp);
    }

    sts = ldh_GetObjectPar(
        ldhses, builddir_oid, "DevBody", "Directory", (char**)&dir_ptr, &size);
    if (EVEN(sts))
      return sts;

    strncpy(dir, dir_ptr, sizeof(dir));
    free(dir_ptr);
    if (streq(dir, "")) {
      MsgWindow::message('E', "Build directory is missing", msgw_ePop_Default);
      continue;
    }

    if (dir[strlen(dir) - 1] != '/')
      strcat(dir, "/");

    sts = ldh_GetObjectPar(ldhses, builddir_oid, "DevBody", "Options",
        (char**)&options_ptr, &size);
    if (EVEN(sts))
      return sts;

    sts = ldh_GetObjectPar(ldhses, builddir_oid, "DevBody", "Description",
        (char**)&descr_ptr, &size);
    if (EVEN(sts))
      return sts;

    fprintf(file, "builddir %s %d \"%s\"\n", fullname, *options_ptr, descr_ptr);
    free(options_ptr);
    free(descr_ptr);

    for (sts = ldh_GetChild(ldhses, builddir_oid, &coid); ODD(sts);
         sts = ldh_GetNextSibling(ldhses, coid, &coid)) {
      sts = ldh_GetObjectClass(ldhses, coid, &cid);
      if (EVEN(sts))
        return sts;

      switch (cid) {
      case pwr_cClass_BuildCopy: {
        char target_array[10][80];
        int target_cnt;

        sts = ldh_GetObjectPar(
            ldhses, coid, "DevBody", "Source", (char**)&source_ptr, &size);
        if (EVEN(sts))
          return sts;

        sts = ldh_GetObjectPar(
            ldhses, coid, "DevBody", "Target", (char**)&target_ptr, &size);
        if (EVEN(sts))
          return sts;

        // Target can be a list
        target_cnt = dcli_parse(target_ptr, ",", "", (char*)target_array,
            sizeof(target_array) / sizeof(target_array[0]),
            sizeof(target_array[0]), 0);
        for (int i = 0; i < target_cnt; i++) {
          str_trim(target_array[i], target_array[i]);
          fprintf(file, "buildcopy %s %s%s %s\n", cdh_Low(fullname), dir,
              source_ptr, target_array[i]);
        }
        free(source_ptr);
        free(target_ptr);
        break;
      }
      case pwr_cClass_BuildConvert: {
        char target_array[10][80];
        int target_cnt;
	pwr_tEnum *conversion_ptr;

        sts = ldh_GetObjectPar(
            ldhses, coid, "DevBody", "Conversion", (char**)&conversion_ptr, &size);
        if (EVEN(sts))
          return sts;

        sts = ldh_GetObjectPar(
            ldhses, coid, "DevBody", "Source", (char**)&source_ptr, &size);
        if (EVEN(sts))
          return sts;

        sts = ldh_GetObjectPar(
            ldhses, coid, "DevBody", "Target", (char**)&target_ptr, &size);
        if (EVEN(sts))
          return sts;

        // Target can be a list
        target_cnt = dcli_parse(target_ptr, ",", "", (char*)target_array,
            sizeof(target_array) / sizeof(target_array[0]),
            sizeof(target_array[0]), 0);
        for (int i = 0; i < target_cnt; i++) {
          str_trim(target_array[i], target_array[i]);
          fprintf(file, "buildconvert %s %d %s%s %s\n", cdh_Low(fullname), *conversion_ptr, dir,
		  source_ptr, target_array[i]);
        }
	free(conversion_ptr);
        free(source_ptr);
        free(target_ptr);
        break;
      }
      case pwr_cClass_BuildExecute: {
        char* command_ptr;

        sts = ldh_GetObjectPar(
            ldhses, coid, "DevBody", "Command", (char**)&command_ptr, &size);
        if (EVEN(sts))
          return sts;

        fprintf(file, "buildexec %s %s \"%s\"\n", cdh_Low(fullname), dir,
            command_ptr);

        free(command_ptr);
        break;
      }
      case pwr_cClass_BuildMake: {
        char* makefile_ptr;

        sts = ldh_GetObjectPar(
            ldhses, coid, "DevBody", "Makefile", (char**)&makefile_ptr, &size);
        if (EVEN(sts))
          return sts;

        fprintf(file, "buildmake %s %s \"%s\"\n", cdh_Low(fullname), dir,
            makefile_ptr);

        free(makefile_ptr);
        break;
      }
      default:;
      }
    }
  }

  fclose(file);

  // Generate custom_build files
  for (wb_object buso = sp->object(); buso; buso = buso.after()) {
    if (buso.cid() != pwr_cClass_BusConfig)
      continue;

    // Get all nodeconfig and friendnodes for this bus
    for (wb_object nodeo = buso.first(); nodeo; nodeo = nodeo.after()) {
      if (nodeo.cid() != pwr_cClass_NodeConfig)
        continue;

      for (wb_object customo = nodeo.first(); customo;
           customo = customo.after()) {
        if (customo.cid() != pwr_cClass_CustomBuild)
          continue;

        pwr_tString80 nodename;
        pwr_tString256 cc;
        pwr_tString256 cxx;
        pwr_tString256 ar;
        pwr_tOpSysEnum opsys;
        pwr_tString40 platform;
        pwr_tString40 release;
        FILE* fp;
        char expdir[80];

        // Get NodeName
        wb_attribute a = sp->attribute(nodeo.oid(), "RtBody", "NodeName");
        if (!a)
          return a.sts();

        a.value(nodename);
        if (!a)
          return sts;

        // Get attribute cc
        a = sp->attribute(customo.oid(), "DevBody", "cc");
        if (!a)
          return a.sts();

        a.value(cc);
        if (!a)
          return sts;

        // Get attribute cxx
        a = sp->attribute(customo.oid(), "DevBody", "cxx");
        if (!a)
          return a.sts();

        a.value(cxx);
        if (!a)
          return sts;

        // Get attribute ar
        a = sp->attribute(customo.oid(), "DevBody", "ar");
        if (!a)
          return a.sts();

        a.value(ar);
        if (!a)
          return sts;

        // Get attribute OperatingSystem
        a = sp->attribute(customo.oid(), "DevBody", "OperatingSystem");
        if (!a)
          return a.sts();

        a.value((void*)&opsys);
        if (!a)
          return sts;

        // Get attribute Platform
        a = sp->attribute(customo.oid(), "DevBody", "Platform");
        if (!a)
          return a.sts();

        a.value(platform);
        if (!a)
          return sts;

        // Get attribute Release
        a = sp->attribute(customo.oid(), "DevBody", "Release");
        if (!a)
          return a.sts();

        a.value(release);
        if (!a)
          return sts;

        if (!strcmp(nodename, "")) {
          char msg[200];
          sprintf(msg, "Error in NodeConfig object '%s', NodeName is missing\n",
              nodeo.longName().c_str());
          MsgWindow::message('E', msg, msgw_ePop_Default);
          syntax_error = 1;
        }

        if (!((!streq(cc, "") && !streq(cxx, "")
                  && !streq(ar, ""))
                || (streq(cc, "") && streq(cxx, "")
                       && streq(ar, "")))) {
          char msg[200];
          sprintf(msg, "Error in CustomBuild object '%s', all or none of cc, "
                       "cxx and ar has to be supplied\n",
              customo.longName().c_str());
          MsgWindow::message('E', msg, msgw_ePop_Default);
          syntax_error = 1;
        }

        // Print custom build file
        if (!(opsys == pwr_mOpSys_PPC_LINUX || opsys == pwr_mOpSys_X86_LINUX
                || opsys == pwr_mOpSys_ARM_LINUX
                || opsys == pwr_mOpSys_ARM64_LINUX))
          continue;

        sprintf(fname, pwr_cNameCustomBuild);
        dcli_translate_filename(fname, fname);
        fp = fopen(fname, "w");
        if (!fp) {
          char tmp[240];
          sprintf(tmp, "Error, Unable to open file \"%s\"\n", fname);
          MsgWindow::message('E', tmp, msgw_ePop_Default);
          return LFU__NOFILE;
        }

        fprintf(fp, "#!/bin/bash\n\n");
        fprintf(fp, "let OpSys_PPC_LINUX=32\n");
        fprintf(fp, "let OpSys_X86_LINUX=64\n");
        fprintf(fp, "let OpSys_ARM_LINUX=512\n");
        fprintf(fp, "let OpSys_ARM64_LINUX=8192\n\n");

        switch (opsys) {
        case pwr_mOpSys_PPC_LINUX:
          strcpy(expdir, "os_linux/hw_ppc");
          break;
        case pwr_mOpSys_X86_LINUX:
          strcpy(expdir, "os_linux/hw_x86");
          break;
        case pwr_mOpSys_ARM_LINUX:
          strcpy(expdir, "os_linux/hw_arm");
          break;
        case pwr_mOpSys_ARM64_LINUX:
          strcpy(expdir, "os_linux/hw_arm64");
          break;
        default:;
          strcpy(expdir, "");
        }

        if (!streq(release, ""))
          fprintf(fp, "source $pwra_db/pwra_env.sh set base %s %s\n\n", release,
              expdir);

        if (!streq(cc, "")) {
          fprintf(fp, "export pwre_cc=%s\n", cc);
          fprintf(fp, "export pwre_cxx=%s\n", cxx);
          fprintf(fp, "export pwre_ar=%s\n\n", ar);
        }

        if (!streq(platform, "")) {
          fprintf(fp, "if [ ! -e $pwrp_root/bld/%s ]; then\n", platform);
          fprintf(fp, "  mkdir $pwrp_root/bld/%s\n", platform);
          fprintf(fp, "fi\n");
          fprintf(fp, "if [ ! -e $pwrp_root/bld/%s/obj ]; then\n", platform);
          fprintf(fp, "  mkdir $pwrp_root/bld/%s/obj\n", platform);
          fprintf(fp, "fi\n");
          fprintf(fp, "if [ ! -e $pwrp_root/bld/%s/lib ]; then\n", platform);
          fprintf(fp, "  mkdir $pwrp_root/bld/%s/lib\n", platform);
          fprintf(fp, "fi\n");
          fprintf(fp, "if [ ! -e $pwrp_root/bld/%s/lis ]; then\n", platform);
          fprintf(fp, "  mkdir $pwrp_root/bld/%s/lis\n", platform);
          fprintf(fp, "fi\n");
          fprintf(fp, "if [ ! -e $pwrp_root/bld/%s/exe ]; then\n", platform);
          fprintf(fp, "  mkdir $pwrp_root/bld/%s/exe\n", platform);
          fprintf(fp, "fi\n");
          fprintf(fp, "export pwrp_obj=$pwrp_root/bld/%s/obj\n", platform);
          fprintf(fp, "export pwrp_lib=$pwrp_root/bld/%s/lib\n", platform);
          fprintf(fp, "export pwrp_lis=$pwrp_root/bld/%s/lis\n", platform);
          fprintf(fp, "export pwrp_exe=$pwrp_root/bld/%s/exe\n\n", platform);
        }

        switch (opsys) {
        case pwr_mOpSys_PPC_LINUX:
          fprintf(fp, "$pwrb_root/os_linux/hw_ppc/exp/exe/wb_gcg.sh \"$1\" "
                      "\"$2\" \"$3\" \"$OpSys_PPC_LINUX\" \"$5\" \"$6\" \"$7\" "
                      "\"$8\"\n");
          break;
        case pwr_mOpSys_X86_LINUX:
          fprintf(fp, "$pwrb_root/os_linux/hw_x86/exp/exe/wb_gcg.sh \"$1\" "
                      "\"$2\" \"$3\" \"$OpSys_X86_LINUX\" \"$5\" \"$6\" \"$7\" "
                      "\"$8\"\n");
          break;
        case pwr_mOpSys_ARM_LINUX:
          fprintf(fp, "$pwrb_root/os_linux/hw_arm/exp/exe/wb_gcg.sh \"$1\" "
                      "\"$2\" \"$3\" \"$OpSys_ARM_LINUX\" \"$5\" \"$6\" \"$7\" "
                      "\"$8\"\n");
          break;
        case pwr_mOpSys_ARM64_LINUX:
          fprintf(fp, "$pwrb_root/os_linux/hw_arm64/exp/exe/wb_gcg.sh \"$1\" "
                      "\"$2\" \"$3\" \"$OpSys_ARM64_LINUX\" \"$5\" \"$6\" "
                      "\"$7\" \"$8\"\n");
          break;
        default:;
        }
        fclose(fp);

        pwr_tCmd cmd;
        sprintf(cmd, "chmod a+x %s\n", fname);
        system(cmd);
      }
    }
  }
  if (volumecount > 0)
    free((char*)volumelist);

  if (syntax_error)
    return LFU__SYNTAX;
  else
    return LFU__SUCCESS;
}

/************************************************************************
*
* Name: lfu_creatdb_qb_yes
*
* Type: int
*
* Type		Parameter	IOGF	Description
* hier_ctx	hier		I	Context variable
*
* Description:
*	Backcall when yes in the questionbox is activated on the question
*	"Should a new database be created".
*
*************************************************************************/
static void lfu_creadb_qb_yes(void* ctx, void* d)
{
  lfu_sCreaDb* data = (lfu_sCreaDb*)d;
  wb_session* sp = (wb_session*)data->ldhses;

  try {
    wb_env env = sp->env();
    wb_volume vdb = env.createVolume(
        data->vid, data->cid, data->name, data->volrep, data->server, false);
  } catch (wb_error&) {
    MsgWindow::message('E', "Unable to create volume", msgw_ePop_Default);
  }
  free((char*)data);
}

/*************************************************************************
*
* Name:		lfu_create_bootfiles()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description: 	Create bootfiles for a number of nodes.
*
**************************************************************************/

int lfu_create_bootfiles(char* nodestr, int debug, int allnodes)
{
  int sts;
  char node_array[30][80];
  int nodetype[30];
  int found;
  int nr, i, j;
  lfu_t_volumelist* volumelist;
  lfu_t_volumelist* volumelist_ptr;
  int volumecount;
  pwr_tString40 nodeconfigname;
  int nodeconfigtype;

  /* Load the bootlist */
  sts = lfu_volumelist_load(pwr_cNameBootList, &volumelist, &volumecount);
  if (sts == LFU__NOFILE) {
    MsgWindow::message('E', "Project is not configured", msgw_ePop_Default);
    return sts;
  } else if (EVEN(sts))
    return sts;

  /* Check if nodes */
  if (nodestr != NULL) {
    nr = utl_parse(nodestr, ", ", "", (char*)node_array,
        sizeof(node_array) / sizeof(node_array[0]), sizeof(node_array[0]));
    if ((nr == 0) || (nr > 30))
      return LFU__NODENAME;

    /* Check that the node's exist in the bootfile */
    for (i = 0; i < nr; i++) {
      found = 0;
      utl_toupper(node_array[i], node_array[i]);
      volumelist_ptr = volumelist;
      for (j = 0; j < volumecount; j++) {
        utl_toupper(nodeconfigname, volumelist_ptr->p1);
        if (!strcmp(nodeconfigname, node_array[i])) {
          nodetype[i] = atoi(volumelist_ptr->p6);
          found = 1;
          break;
        }
        volumelist_ptr++;
      }
      if (!found) {
        return LFU__NODENAME;
      }
    }
    /* Create the bootfiles */
    for (i = 0; i < nr; i++) {
      sts = lfu_create_bootfile(
          node_array[i], nodetype[i], volumelist, volumecount, debug);
      if (EVEN(sts))
        return sts;

      wb_log::log(wlog_eCategory_NodeBuild, node_array[i], 0);
    }
  } else if (allnodes) {
    strcpy(nodeconfigname, "");
    /* Create bootfiles for all created nodes */
    volumelist_ptr = volumelist;
    for (j = 0; j < volumecount; j++) {
      if (strcmp(nodeconfigname, volumelist_ptr->p1)) {
        strcpy(nodeconfigname, volumelist_ptr->p1);
        nodeconfigtype = atoi(volumelist_ptr->p6);
        sts = lfu_create_bootfile(
            nodeconfigname, nodeconfigtype, volumelist, volumecount, debug);
        if (EVEN(sts))
          return sts;
      }
      volumelist_ptr++;
    }
  }
  return LFU__SUCCESS;
}

/*************************************************************************
*
* Name:		lfu_ReadBootFile
*
* Type		pwr_tStatus
*
* Description:
*		Returns information in a bootfile.
*
**************************************************************************/

pwr_tStatus lfu_ReadBootFile(char* filename, pwr_tTime* date, char* systemname,
    char* systemgroup, pwr_tVolumeId** vollist, pwr_tString40** volnamelist,
    int* volcount, pwr_tString80** plclist, int* plccount)
{
  FILE* file;
  char timstr[40];
  char vol_name[40];
  char vol_str[20];
  pwr_tVolumeId volid;
  pwr_tStatus sts;
  char fname[120];
  char buff[1000];
  pwr_tString80 plcarray[50];

  dcli_translate_filename(fname, filename);
  file = fopen(fname, "r");
  if (file == 0)
    return LFU__NOFILE;

  if (fgets(timstr, sizeof(timstr), file) == NULL) {
    fclose(file);
    return LFU__FILECRP;
  }
  sts = time_AsciiToA(timstr, date);
  if (EVEN(sts)) {
    fclose(file);
    return sts;
  }

  if (utl_read_line(systemname, sizeof(pwr_tString80), file, NULL) == 0) {
    fclose(file);
    return LFU__FILECRP;
  }

  if (utl_read_line(systemgroup, sizeof(pwr_tString80), file, NULL) == 0) {
    fclose(file);
    return LFU__FILECRP;
  }

  if (utl_read_line(buff, sizeof(buff), file, NULL) == 0) {
    // Sev node bootfile
    fclose(file);
    *volcount = 0;
    *plccount = 0;
    if (plclist)
      *plclist = (pwr_tString80*)0;
    return LFU__SUCCESS;
  }

  if (plclist) {
    if (buff[0] == '-') {
      *plccount = 0;
      *plclist = (pwr_tString80*)0;
    } else {
      *plccount = dcli_parse(buff, ",", "", (char*)plcarray,
          sizeof(plcarray) / sizeof(plcarray[0]), sizeof(plcarray[0]), 0);

      *plclist = (pwr_tString80*)calloc(*plccount, sizeof(pwr_tString80));
      memcpy(*plclist, plcarray, *plccount * sizeof(pwr_tString80));
    }
  }

  if (vollist) {
    *volcount = 0;
    *vollist = (pwr_tVolumeId*)calloc(LFU_MAX_NODE_VOLUMES, sizeof(**vollist));
    *volnamelist
        = (pwr_tString40*)calloc(LFU_MAX_NODE_VOLUMES, sizeof(**volnamelist));
    while (fscanf(file, "%s %s", vol_name, vol_str) == 2) {
      sts = cdh_StringToVolumeId(vol_str, &volid);
      if (EVEN(sts)) {
        fclose(file);
        return sts;
      }
      *(*vollist + *volcount) = volid;
      strcpy(*(*volnamelist + *volcount), vol_name);
      (*volcount)++;
    }
  }
  fclose(file);

  return LFU__SUCCESS;
}

/****************************************************************************
* Name:		lfu_GetVolRef()
**************************************************************************/
pwr_tStatus lfu_GetVolRef(
    char* filename, lfu_t_volref** volref, int* volref_count)
{
  dbs_sEnv dbsenv;
  dbs_sVolRef vref;
  int idx;
  pwr_tStatus sts;
  char fname[200];
  lfu_t_volref* vr;

  dcli_translate_filename(fname, filename);
  dbs_Open(&sts, &dbsenv, fname);
  if (EVEN(sts))
    return sts;

  vr = (lfu_t_volref*)calloc(LFU_MAX_VOLREF, sizeof(lfu_t_volref));
  idx = 0;
  while (dbs_VolRef(&sts, idx, &vref, &dbsenv)) {
    if (idx >= LFU_MAX_VOLREF)
      break;
    if (EVEN(sts)) {
      free((char*)vr);
      return sts;
    }
    strcpy(vr[idx].name, vref.name);
    vr[idx].vid = vref.vid;
    vr[idx].version = vref.time;
    idx++;
  }
  dbs_Close(&sts, &dbsenv);

  *volref_count = idx;
  *volref = vr;
  return LFU__SUCCESS;
}

/****************************************************************************
* Name:		lfu_GetVolume()
**************************************************************************/
pwr_tStatus lfu_GetVolume(char* filename, char* name, pwr_tVid* vid,
    pwr_tCid* cid, pwr_tTime* time, pwr_tUInt32* dvversion)
{
  dbs_sEnv dbsenv;
  dbs_sVolume volume;
  pwr_tStatus sts;
  char fname[200];

  dcli_translate_filename(fname, filename);
  dbs_Open(&sts, &dbsenv, fname);
  if (EVEN(sts))
    return sts;

  dbs_Volume(&sts, &volume, &dbsenv);
  if (EVEN(sts))
    return sts;

  *vid = volume.vid;
  *cid = volume.cid;
  strcpy(name, volume.name);
  *time = volume.time;
  *dvversion = volume.dvVersion;
  dbs_Close(&sts, &dbsenv);

  return LFU__SUCCESS;
}

pwr_tStatus lfu_GetVolumeCnf(
    char* name, pwr_tVid* vid, pwr_tCid* cid, ldh_eVolRep* volrep, char* server)
{
  pwr_tStatus sts;
  pwr_tFileName fname;
  char line[200];
  char vol_array[7][80];
  int found = 0;

  strcpy(fname, pwr_cNameVolumeList);
  dcli_translate_filename(fname, fname);

  *volrep = ldh_eVolRep_Db;

  std::ifstream fpm(fname, std::ios::in);
  if (!fpm)
    return 0;

  while (fpm.getline(line, sizeof(line))) {
    int nr;

    if (line[0] == '#')
      continue;

    nr = dcli_parse(line, " ", "", (char*)vol_array,
        sizeof(vol_array) / sizeof(vol_array[0]), sizeof(vol_array[0]), 0);

    if (str_NoCaseStrcmp(vol_array[0], name) != 0)
      continue;

    found = 1;

    sts = cdh_StringToVolumeId(vol_array[1], vid);
    if (EVEN(sts))
      return sts;

    if (str_NoCaseStrcmp(vol_array[2], "RootVolume") == 0)
      *cid = pwr_eClass_RootVolume;
    else if (str_NoCaseStrcmp(vol_array[2], "SubVolume") == 0)
      *cid = pwr_eClass_SubVolume;
    else if (str_NoCaseStrcmp(vol_array[2], "SharedVolume") == 0)
      *cid = pwr_eClass_SharedVolume;
    else if (str_NoCaseStrcmp(vol_array[2], "ClassVolume") == 0)
      *cid = pwr_eClass_ClassVolume;
    else if (str_NoCaseStrcmp(vol_array[2], "DetachedClassVolume") == 0)
      *cid = pwr_eClass_DetachedClassVolume;

    switch (*cid) {
    case pwr_eClass_RootVolume:
    case pwr_eClass_SubVolume:
    case pwr_eClass_SharedVolume:
      *volrep = ldh_eVolRep_Db;
      if (str_NoCaseStrcmp(vol_array[0], name) == 0) {
        if (nr > 4 && streq(vol_array[4], "1")) {
          *volrep = ldh_eVolRep_Dbms;
          if (nr > 5)
            strcpy(server, vol_array[5]);
          else
            strcpy(server, "");
        }
      }
      break;
    case pwr_eClass_ClassVolume:
    case pwr_eClass_DetachedClassVolume:
      *volrep = ldh_eVolRep_Wbl;
      if (str_NoCaseStrcmp(vol_array[0], name) == 0) {
        if (nr > 4 && streq(vol_array[4], "1"))
          *volrep = ldh_eVolRep_Db;
        else if (nr > 4 && streq(vol_array[4], "2")) {
          *volrep = ldh_eVolRep_Dbms;
          if (nr > 5)
            strcpy(server, vol_array[5]);
          else
            strcpy(server, "");
        }
      }
      break;
    default:;
    }
    break;
  }
  fpm.close();

  if (found)
    return LFU__SUCCESS;
  return 0;
}

pwr_tStatus lfu_GetVolumeCnfAll(std::vector<lfu_volume_info>& vect)
{
  pwr_tStatus sts;
  pwr_tFileName fname;
  char line[200];
  char vol_array[7][80];
  int found = 0;

  strcpy(fname, pwr_cNameVolumeList);
  dcli_translate_filename(fname, fname);

  std::ifstream fpm(fname, std::ios::in);
  if (!fpm)
    return 0;

  while (fpm.getline(line, sizeof(line))) {
    int nr;
    lfu_volume_info vol;

    if (line[0] == '#')
      continue;

    nr = dcli_parse(line, " ", "", (char*)vol_array,
        sizeof(vol_array) / sizeof(vol_array[0]), sizeof(vol_array[0]), 0);

    strncpy(vol.name, vol_array[0], sizeof(vol.name));

    found = 1;

    sts = cdh_StringToVolumeId(vol_array[1], &vol.vid);
    if (EVEN(sts))
      return sts;

    if (str_NoCaseStrcmp(vol_array[2], "RootVolume") == 0)
      vol.cid = pwr_eClass_RootVolume;
    else if (str_NoCaseStrcmp(vol_array[2], "SubVolume") == 0)
      vol.cid = pwr_eClass_SubVolume;
    else if (str_NoCaseStrcmp(vol_array[2], "SharedVolume") == 0)
      vol.cid = pwr_eClass_SharedVolume;
    else if (str_NoCaseStrcmp(vol_array[2], "ClassVolume") == 0)
      vol.cid = pwr_eClass_ClassVolume;
    else if (str_NoCaseStrcmp(vol_array[2], "DetachedClassVolume") == 0)
      vol.cid = pwr_eClass_DetachedClassVolume;

    switch (vol.cid) {
    case pwr_eClass_RootVolume:
    case pwr_eClass_SubVolume:
    case pwr_eClass_SharedVolume:
      vol.volrep = ldh_eVolRep_Db;
      if (nr > 4 && streq(vol_array[4], "1")) {
        vol.volrep = ldh_eVolRep_Dbms;
        if (nr > 5)
          strncpy(vol.server, vol_array[5], sizeof(vol.server));
        else
          strcpy(vol.server, "");
      }
      break;
    case pwr_eClass_ClassVolume:
    case pwr_eClass_DetachedClassVolume:
      vol.volrep = ldh_eVolRep_Wbl;
      if (nr > 4 && streq(vol_array[4], "1"))
        vol.volrep = ldh_eVolRep_Db;
      else if (nr > 4 && streq(vol_array[4], "2")) {
        vol.volrep = ldh_eVolRep_Dbms;
        if (nr > 5)
          strncpy(vol.server, vol_array[5], sizeof(vol.server));
        else
          strcpy(vol.server, "");
      }
      break;
    default:;
    }
    vect.push_back(vol);
  }
  fpm.close();

  if (found)
    return LFU__SUCCESS;
  return 0;
}

pwr_tStatus lfu_GetBootList(std::vector<lfu_boot_info>& vect, int* nodes)
{
  pwr_tStatus sts;
  pwr_tFileName fname;
  char line[200];
  char boot_array[7][80];
  int found = 0;
  int cnt = 0;

  strcpy(fname, pwr_cNameBootList);
  dcli_translate_filename(fname, fname);

  std::ifstream fpm(fname, std::ios::in);
  if (!fpm)
    return 0;

  while (fpm.getline(line, sizeof(line))) {
    int nr;
    lfu_boot_info boot;

    if (line[0] == '#')
      continue;

    nr = dcli_parse(line, " ", "", (char*)boot_array,
        sizeof(boot_array) / sizeof(boot_array[0]), sizeof(boot_array[0]), 0);

    strncpy(boot.volume_name, boot_array[0], sizeof(boot.volume_name));
    strncpy(boot.node_name, boot_array[3], sizeof(boot.node_name));
    sts = sscanf(boot_array[4], "%d", &boot.bus);
    if (sts != 1)
      printf("File syntax error %s\n", fname);
    sts = sscanf(boot_array[5], "%d", &boot.opsys);
    if (sts != 1)
      printf("File syntax error %s\n", fname);

    found = 1;

    sts = cdh_StringToVolumeId(boot_array[1], &boot.vid);
    if (EVEN(sts))
      return sts;

    bool num_found = false;
    for (unsigned int j = 0; j < vect.size(); j++) {
      if (streq(vect[j].node_name, boot.node_name)) {
        boot.number = vect[j].number;
        num_found = true;
      }
    }
    if (!num_found)
      boot.number = cnt++;

    vect.push_back(boot);
  }
  fpm.close();

  *nodes = cnt;

  if (found)
    return LFU__SUCCESS;
  return 0;
}

pwr_tStatus lfu_ParseDbmsServer(
    char* server, char* user, char* password, unsigned int* port, char* host)
{
  char lserver[80];

  if (streq(server, "")) {
    if (!cnf_get_value("mysqlServer", lserver, sizeof(lserver))) {
      printf("** mysql Server not defined\n");
      return LDH__NOSERVER;
    }
  } else
    strcpy(lserver, server);

  // Parse server string: username:password@port:host
  char lhost[80];
  char luser[80] = "pwrp";
  char lpassword[80] = "";
  char str1[2][80];
  char str2[2][80];
  int nr;

  nr = dcli_parse(lserver, "@", "", (char*)str1, sizeof(str1) / sizeof(str1[0]),
      sizeof(str1[0]), 0);

  if (nr == 1)
    strncpy(lhost, lserver, sizeof(lhost));
  else if (nr >= 2) {
    strncpy(lhost, str1[1], sizeof(lhost));

    nr = dcli_parse(str1[0], ":", "", (char*)str2,
        sizeof(str2) / sizeof(str2[0]), sizeof(str2[0]), 0);

    if (nr == 1)
      strncpy(luser, str1[0], sizeof(luser));
    else if (nr >= 2) {
      strncpy(luser, str2[0], sizeof(luser));
      strncpy(lpassword, str2[1], sizeof(lpassword));
    }
  }
  nr = dcli_parse(host, ":", "", (char*)str1, sizeof(str1) / sizeof(str1[0]),
      sizeof(str1[0]), 0);
  if (nr >= 2) {
    nr = sscanf(str1[0], "%u", port);
    if (nr != 1) {
      printf("** Syntax error in mysql Server port\n");
      return LDH__NOSERVER;
    }
    strncpy(lhost, str1[1], sizeof(lhost));
  }

  if (streq(host, "localhost"))
    strcpy(lhost, "");

  strcpy(host, lhost);
  strcpy(user, luser);
  strcpy(password, lpassword);
  return LFU__SUCCESS;
}

pwr_tStatus lfu_check_appl_file(
    ldh_tSesContext ldhses, char* nodename, int bus_number)
{
  pwr_tFileName fname;
  pwr_tTime t;

  sprintf(fname, pwr_cNameAppl, "$pwrp_cnf/", cdh_Low(nodename), bus_number);
  dcli_translate_filename(fname, fname);

  if (ODD(dcli_file_time(fname, &t)))
    return LFU__SUCCESS;

  // strcat( fname, "_template");
  // if ( ODD(dcli_file_time( fname, &t)))
  //  return LFU__SUCCESS;

  // Create a template file
  std::ofstream fp(fname);
  if (!fp)
    return LFU__SUCCESS;

  fp << "#\n"
     << "# Startup processes for Proview.\n"
     << "#\n"
     << "#\n"
     << "# User applications\n"
     << "# id,   name,   load/noload run/norun,  file,   prio,   "
        "debug/nodebug,  \"arg\""
     << '\n'
     << "#myappl, myappl, noload, run, myappl, 12, nodebug, \"\"\n"
     << "#\n"
     << "# System processes\n"
     << "# System processes can be disabled by removing the #\n"
     << "#pwr_neth,       , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_plc_plc,        , noload, norun, ,  , debug, \"\"\n"
     << "#pwr_alim,       , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_emon,       , noload, norun, , 10, debug, \"\"\n"
     << "#pwr_tmon,       , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_qmon,       , noload, norun, , 19, debug, \"\"\n"
     << "#pwr_nacp,       , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_bck,        , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_io,         , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_linksup,    , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_trend,      , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_fast,       , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_remh,       , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_remlog,     , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_elog,       , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_sysmon,     , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_webmon,     , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_webmonmh,   , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_webmonelog, , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_opc_server, , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_statussrv,  , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_post,       , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_sevhistmon, , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_sev_server, , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_powerlink,  , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_videomgm,   , noload, norun, , 5, debug, \"\"\n"
     << "#pwr_redcom,     , noload, norun, , 5, debug, \"\"\n";

  fp.close();
  return LFU__SUCCESS;
}

pwr_tStatus lfu_check_opt_file(
    ldh_tSesContext ldhses, char* nodename, int bus_number, pwr_mOpSys opsys)
{
  char fname[280];
  pwr_tTime t;
  pwr_tFileName dir;
  pwr_tObjName name;
  int size;
  pwr_tStatus sts;
  pwr_tOid oid;

  sprintf(dir, "$pwrp_root/%s/exe/", cdh_OpSysToStr(opsys));

  for (sts = ldh_GetClassList(ldhses, pwr_cClass_PlcProcess, &oid); ODD(sts);
       sts = ldh_GetNextObject(ldhses, oid, &oid)) {
    sts = ldh_ObjidToName(
        ldhses, oid, ldh_eName_Object, name, sizeof(name), &size);
    if (EVEN(sts))
      return sts;

    sprintf(fname, pwr_cNameOpt, dir, nodename, bus_number, cdh_Low(name));
    dcli_translate_filename(fname, fname);

    if (ODD(dcli_file_time(fname, &t)))
      continue;

    strcat(fname, "_template");
    if (ODD(dcli_file_time(fname, &t)))
      continue;

    // Create a template file
    std::ofstream fp(fname);
    if (!fp)
      return LFU__SUCCESS;

    switch (opsys) {
    case pwr_mOpSys_PPC_LINUX:
    case pwr_mOpSys_X86_LINUX:
    case pwr_mOpSys_X86_64_LINUX:
    case pwr_mOpSys_ARM_LINUX:
    case pwr_mOpSys_ARM64_LINUX:
    case pwr_mOpSys_X86_64_MACOS:
    case pwr_mOpSys_CustomBuild:
      fp << "$pwr_obj/rt_io_user.o -lpwr_rt -lpwr_pnak_dummy -lpwr_cifx_dummy "
            "-lpwr_usb_dummy -lpwr_usbio_dummy -lpwr_nodave_dummy "
            "-lpwr_epl_dummy"
         << '\n';
      break;
    default:;
    }

    fp.close();
  }
  return LFU__SUCCESS;
}
