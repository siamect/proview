/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* wb_wccm.c -- Buildtin script functions for wb */

#include <stdlib.h>

#include "pwr_version.h"
#include "pwr_baseclasses.h"

#include "co_api_user.h"
#include "co_ccm.h"
#include "co_ccm_msg.h"
#include "co_string.h"
#include "co_time.h"

#include "wb_utl_api.h"
#include "wb_trv.h"
#include "wb_cmd_msg.h"
#include "wb_foe_msg.h"
#include "wb_wnav.h"
#include "wb_utl.h"
#include "wb_session.h"

class WFoe;

static int wccm_ccm_func_registred = 0;
static ldh_tSesContext stored_ldhses = 0;
static ldh_tWBContext stored_wbctx = 0;
static void* stored_client_data;
static WFoe* stored_foe = 0;
static pwr_tOName stored_foe_window;
int (*wccm_get_wbctx_cb)(void*, ldh_tWBContext*);
int (*wccm_get_ldhsession_cb)(void*, ldh_tSesContext*);
int (*wccm_get_wnav_cb)(void*, WNav**);

/*____Local function prototypes_______________________________________*/

static int wccm_attribute_func(char* name, int* return_decl,
    ccm_tFloat* return_float, ccm_tInt* return_int, char* return_string);
static int wccm_cut_segments(char* outname, char* name, int segments);

void wccm_store_client(void* client_data)
{
  stored_client_data = client_data;
}

void wccm_store_ldhses(void* client_data, ldh_tSesContext ldhsession)
{
  stored_ldhses = ldhsession;
  stored_client_data = client_data;
  if (!stored_wbctx)
    stored_wbctx = ldh_SessionToWB(ldhsession);
}

int wccm_get_ldhses(ldh_tSesContext* ldhses)
{
  int sts;

  if (!stored_ldhses) {
    sts = (wccm_get_ldhsession_cb)(stored_client_data, &stored_ldhses);
    if (EVEN(sts))
      return sts;
  }
  *ldhses = stored_ldhses;
  return 1;
}

int wccm_get_wbctx(ldh_tWBContext* wbctx)
{
  int sts;

  if (!stored_wbctx) {
    sts = (wccm_get_wbctx_cb)(stored_client_data, &stored_wbctx);
    if (EVEN(sts))
      return sts;
  }
  *wbctx = stored_wbctx;
  return 1;
}

int wccm_get_wnav(WNav** wnav)
{
  if (wccm_get_wnav_cb)
    return (wccm_get_wnav_cb)(stored_client_data, wnav);
  return 0;
}

static int wccm_getattribute_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  ccm_sArg* arg_p2;
  int sts;
  int value_decl;
  ccm_tInt value_int;
  ccm_tFloat value_float;
  ccm_tString value_string;

  if (!(arg_count == 2 || arg_count == 1))
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;
  if (arg_count == 2 && arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  sts = wccm_attribute_func(arg_list->value_string, &value_decl, &value_float,
      &value_int, value_string);
  if (EVEN(sts)) {
    if (arg_count == 2) {
      arg_p2->value_int = 0;
      arg_p2->value_returned = 1;
      arg_p2->var_decl = arg_p2->value_decl;
    }
    *return_decl = CCM_DECL_UNKNOWN;
  } else {
    if (value_decl == CCM_DECL_INT) {
      *return_int = value_int;
      *return_decl = CCM_DECL_INT;
    } else if (value_decl == CCM_DECL_FLOAT) {
      *return_float = value_float;
      *return_decl = CCM_DECL_FLOAT;
    } else if (value_decl == CCM_DECL_STRING) {
      strcpy(return_string, value_string);
      *return_decl = CCM_DECL_STRING;
    }
    if (arg_count == 2) {
      arg_p2->value_int = 1;
      arg_p2->value_returned = 1;
      arg_p2->var_decl = arg_p2->value_decl;
    }
  }

  return 1;
}

static int wccm_getchild_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  int sts;
  pwr_tOName name;
  pwr_tObjid parent_objid;
  pwr_tObjid child_objid;
  int size;
  ldh_tSesContext ldhses;

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = ldh_NameToObjid(ldhses, &parent_objid, arg_list->value_string);
  if (ODD(sts)) {
    sts = ldh_GetChild(ldhses, parent_objid, &child_objid);
    if (ODD(sts))
      sts = ldh_ObjidToName(
          ldhses, child_objid, ldh_eName_Hierarchy, name, sizeof(name), &size);
  }
  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_getparent_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  int sts;
  pwr_tOName name;
  pwr_tObjid parent_objid;
  pwr_tObjid child_objid;
  int size;
  ldh_tSesContext ldhses;

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = ldh_NameToObjid(ldhses, &child_objid, arg_list->value_string);
  if (ODD(sts)) {
    sts = ldh_GetParent(ldhses, child_objid, &parent_objid);
    if (ODD(sts))
      sts = ldh_ObjidToName(
          ldhses, parent_objid, ldh_eName_Hierarchy, name, sizeof(name), &size);
  }

  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_getnextsibling_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  pwr_tOName name;
  pwr_tObjid objid;
  pwr_tObjid next_objid;
  int size;
  ldh_tSesContext ldhses;

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = ldh_NameToObjid(ldhses, &objid, arg_list->value_string);
  if (ODD(sts)) {
    sts = ldh_GetNextSibling(ldhses, objid, &next_objid);
    if (ODD(sts))
      sts = ldh_ObjidToName(
          ldhses, next_objid, ldh_eName_Hierarchy, name, sizeof(name), &size);
  }

  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_getclasslist_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  pwr_tOName name;
  pwr_tCid cid;
  pwr_tObjid oid;
  int size;
  ldh_tSesContext ldhses;

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = ldh_ClassNameToId(ldhses, &cid, arg_list->value_string);
  if (ODD(sts)) {
    sts = ldh_GetClassList(ldhses, cid, &oid);
    if (ODD(sts))
      sts = ldh_ObjidToName(
          ldhses, oid, ldh_eName_Hierarchy, name, sizeof(name), &size);
  }

  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_gettemplateobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  pwr_tOName name;
  pwr_tCid cid;
  pwr_tObjid oid;
  int size;
  ldh_tSesContext ldhses;

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = ldh_ClassNameToId(ldhses, &cid, arg_list->value_string);
  if (ODD(sts)) {
    sts = ldh_GetTemplateObject(ldhses, cid, &oid);
    if (ODD(sts))
      sts = ldh_ObjidToName(
          ldhses, oid, cdh_mName_volumeStrict, name, sizeof(name), &size);
  }

  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_getnextobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  pwr_tOName name;
  pwr_tObjid objid;
  pwr_tObjid next_objid;
  int size;
  ldh_tSesContext ldhses;

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = ldh_NameToObjid(ldhses, &objid, arg_list->value_string);
  if (ODD(sts)) {
    sts = ldh_GetNextObject(ldhses, objid, &next_objid);
    if (ODD(sts))
      sts = ldh_ObjidToName(
          ldhses, next_objid, ldh_eName_Hierarchy, name, sizeof(name), &size);
  }

  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_getclasslistattrref_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  char* name = NULL;
  pwr_tCid cid;
  pwr_tAttrRef aref;
  int size;
  ldh_tSesContext ldhses;

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = ldh_ClassNameToId(ldhses, &cid, arg_list->value_string);
  if (ODD(sts)) {
    sts = ldh_GetClassListAttrRef(ldhses, cid, &aref);
    if (ODD(sts))
      sts = ldh_AttrRefToName(ldhses, &aref, ldh_eName_Hierarchy, &name, &size);
  }

  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_getnextattrref_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  char* name = NULL;
  pwr_tAttrRef aref;
  pwr_tAttrRef next_aref;
  int size;
  ldh_tSesContext ldhses;
  pwr_tCid cid;
  ccm_sArg* arg_p2;

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 2)
    return CCM__ARGMISM;
  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = ldh_ClassNameToId(ldhses, &cid, arg_list->value_string);
  if (ODD(sts)) {
    sts = ldh_NameToAttrRef(ldhses, arg_p2->value_string, &aref);
    if (ODD(sts)) {
      sts = ldh_GetNextAttrRef(ldhses, cid, &aref, &next_aref);
      if (ODD(sts))
        sts = ldh_AttrRefToName(
            ldhses, &next_aref, ldh_eName_Hierarchy, &name, &size);
    }
  }
  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_getnexttemplateattrref_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  char* name = NULL;
  pwr_tAttrRef aref;
  pwr_tAttrRef next_aref;
  int size;
  ldh_tSesContext ldhses;
  pwr_tCid cid;
  ccm_sArg* arg_p2;

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 2)
    return CCM__ARGMISM;
  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = ldh_ClassNameToId(ldhses, &cid, arg_list->value_string);
  if (ODD(sts)) {
    sts = ldh_NameToAttrRef(ldhses, arg_p2->value_string, &aref);
    if (ODD(sts)) {
      sts = ldh_GetNextTemplateAttrRef(ldhses, cid, &aref, &next_aref);
      if (ODD(sts))
        sts = ldh_AttrRefToName(
            ldhses, &next_aref, cdh_mName_volumeStrict, &name, &size);
    }
  }
  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_getrootlist_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  pwr_tOName name;
  pwr_tObjid objid;
  int size;
  ldh_tSesContext ldhses;

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 0)
    return CCM__ARGMISM;

  sts = ldh_GetRootList(ldhses, &objid);
  if (ODD(sts))
    sts = ldh_ObjidToName(
        ldhses, objid, ldh_eName_Hierarchy, name, sizeof(name), &size);

  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_getobjectclass_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  char name[80];
  pwr_tClassId cid;
  pwr_tObjid objid;
  int size;
  ldh_tSesContext ldhses;

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = ldh_NameToObjid(ldhses, &objid, arg_list->value_string);
  if (ODD(sts)) {
    sts = ldh_GetObjectClass(ldhses, objid, &cid);
    if (ODD(sts))
      sts = ldh_ObjidToName(ldhses, cdh_ClassIdToObjid(cid), ldh_eName_Object,
          name, sizeof(name), &size);
  }
  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_renameobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  pwr_tObjid objid;
  ldh_tSesContext ldhses;
  ccm_sArg* arg_p2;

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    *return_int = 0;
    *return_decl = CCM_DECL_INT;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = ldh_NameToObjid(ldhses, &objid, arg_list->value_string);
  if (ODD(sts))
    sts = ldh_SetObjectName(ldhses, objid, arg_p2->value_string);

  *return_int = sts;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int wccm_moveobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  pwr_tObjid objid;
  pwr_tObjid dest_objid;
  ldh_tSesContext ldhses;
  ccm_sArg* arg_p2;
  ccm_sArg* arg_p3;
  ldh_eDest dcode = ldh_eDest_Before;

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    *return_int = 0;
    *return_decl = CCM_DECL_INT;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 3)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;
  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  switch (arg_p3->value_int) {
  case 1:
    dcode = ldh_eDest_IntoFirst;
    break;
  case 2:
    dcode = ldh_eDest_IntoLast;
    break;
  case 3:
    dcode = ldh_eDest_After;
    break;
  case 4:
    dcode = ldh_eDest_Before;
    break;
  }

  sts = ldh_NameToObjid(ldhses, &objid, arg_list->value_string);
  if (ODD(sts)) {
    sts = ldh_NameToObjid(ldhses, &dest_objid, arg_p2->value_string);
    if (ODD(sts))
      sts = ldh_MoveObject(ldhses, objid, dest_objid, dcode);
  }
  *return_int = sts;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int wccm_objectexist_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  pwr_tObjid objid;
  ldh_tSesContext ldhses;

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    *return_int = 0;
    *return_decl = CCM_DECL_INT;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = ldh_NameToObjid(ldhses, &objid, arg_list->value_string);
  *return_int = ODD(sts);
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int wccm_getvolumelist_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  char name[80];
  pwr_tVolumeId volid;
  int size;
  ldh_tWBContext wbctx;

  sts = wccm_get_wbctx(&wbctx);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOWBATTACHED;
  }

  if (arg_count != 0)
    return CCM__ARGMISM;

  sts = ldh_GetVolumeList(wbctx, &volid);
  if (ODD(sts))
    sts = ldh_VolumeIdToName(wbctx, volid, name, sizeof(name), &size);

  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_getnextvolume_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  char name[80];
  pwr_tVolumeId volid;
  pwr_tVolumeId next_volid;
  int size;
  ldh_tWBContext wbctx;

  sts = wccm_get_wbctx(&wbctx);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOWBATTACHED;
  }

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = ldh_VolumeNameToId(wbctx, arg_list->value_string, &volid);
  if (ODD(sts)) {
    sts = ldh_GetNextVolume(wbctx, volid, &next_volid);
    if (ODD(sts))
      sts = ldh_VolumeIdToName(wbctx, next_volid, name, sizeof(name), &size);
  }

  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_getvolumeclass_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  char name[80];
  pwr_tClassId cid;
  pwr_tVolumeId volid;
  int size;
  ldh_tSesContext ldhses;

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = ldh_VolumeNameToId(
      ldh_SessionToWB(ldhses), arg_list->value_string, &volid);
  if (ODD(sts)) {
    sts = ldh_GetVolumeClass(ldh_SessionToWB(ldhses), volid, &cid);
    if (ODD(sts))
      sts = ldh_ObjidToName(ldhses, cdh_ClassIdToObjid(cid), ldh_eName_Object,
          name, sizeof(name), &size);
  }
  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_cutobjectname_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;
  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  wccm_cut_segments(return_string, arg_list->value_string, arg_p2->value_int);

  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_getnodeobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  pwr_tOName name;
  int size;
  unsigned long node_count;
  pwr_tObjid* nodelist;
  ldh_tSesContext ldhses;

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 0)
    return CCM__ARGMISM;

  sts = trv_get_rtnodes(ldhses, &node_count, &nodelist);
  if (ODD(sts)) {
    if (node_count > 0) {
      sts = ldh_ObjidToName(
          ldhses, *nodelist, ldh_eName_Hierarchy, name, sizeof(name), &size);
      free((char*)nodelist);
    } else
      sts = 0;
  }

  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_getprojectname_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  char projectname[80];

  if (arg_count != 0)
    return CCM__ARGMISM;

  sts = utl_get_projectname(projectname);
  if (ODD(sts))
    strcpy(return_string, projectname);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_setattribute_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  ccm_sArg* arg_p2;
  int sts;
  char buf[400];
  pwr_tAName name;
  pwr_tOName attr;
  char* s;
  ldh_tSesContext ldhses;

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__VARTYPE;
  switch (arg_p2->value_decl) {
  case CCM_DECL_STRING:
    strcpy(buf, arg_p2->value_string);
    break;
  case CCM_DECL_INT:
    sprintf(buf, "%ld", arg_p2->value_int);
    break;
  case CCM_DECL_FLOAT:
    sprintf(buf, "%f", arg_p2->value_float);
    break;
  }

  strcpy(name, arg_list->value_string);
  if ((s = strrchr(name, '.'))) {
    *s = 0;
    strcpy(attr, s + 1);
  } else
    return CMD__ATTRIBUTE;

  sts = utl_set_object_parameter(ldhses, 0, 0, name, attr, buf, 0, "", 0, 0);

  *return_int = sts;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int wccm_checksystemgroup_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__VARTYPE;

  sts = user_CheckSystemGroup(arg_list->value_string);

  *return_int = ODD(sts);
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int wccm_getnextfreeuservid_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  pwr_tVid next_vid;
  pwr_tVid start_vid = cdh_cUserVolMin;

  if (arg_count > 1)
    return CCM__ARGMISM;

  if (arg_count > 0) {
    if (arg_list->value_decl != CCM_DECL_INT)
      return CCM__VARTYPE;

    if ((pwr_tVid)arg_list->value_int > start_vid)
      start_vid = arg_list->value_int;
  }

  sts = WNav::get_next_free_vid(start_vid, cdh_cUserVolMax, &next_vid);
  if (EVEN(sts))
    strcpy(return_string, "");
  else
    strcpy(return_string, cdh_VolumeIdToString(0, 0, next_vid, 0, 0));

  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_checknewvid_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__VARTYPE;

  sts = WNav::check_new_vid(arg_list->value_int);
  if (EVEN(sts))
    *return_int = 0;
  else
    *return_int = 1;

  *return_decl = CCM_DECL_INT;

  return 1;
}

static int wccm_checknewvolumename_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__VARTYPE;

  sts = WNav::check_new_volumename(arg_list->value_string);
  if (EVEN(sts))
    *return_int = 0;
  else
    *return_int = 1;

  *return_decl = CCM_DECL_INT;

  return 1;
}

static int wccm_getcurrentvolume_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  char name[80];
  int size;
  ldh_tSesContext ldhses;
  ldh_sSessInfo info;
  ldh_tWBContext wbctx;

  sts = wccm_get_wbctx(&wbctx);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOWBATTACHED;
  }

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 0)
    return CCM__ARGMISM;

  sts = ldh_GetSessionInfo(ldhses, &info);
  if (ODD(sts))
    sts = ldh_VolumeIdToName(wbctx, info.Vid, name, sizeof(name), &size);

  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_stringtoobjectname_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  cdh_StringToObjectName(return_string, arg_list->value_string);

  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_getopsys_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  if (arg_count != 0)
    return CCM__ARGMISM;

  strcpy(return_string, syi_OpSys());
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_getversion_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  if (arg_count != 0)
    return CCM__ARGMISM;

  *return_int = 10000 * PWRV_VERSION_MAJOR + 100 * PWRV_VERSION_MINOR
      + PWRV_VERSION_RELEASE;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int wccm_gethardware_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  if (arg_count != 0)
    return CCM__ARGMISM;

  strcpy(return_string, syi_Hardware());
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int wccm_createobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  ccm_sArg *arg_p2, *arg_p3, *arg_p4;
  int sts;
  pwr_tAName dest;
  pwr_tOid dest_oid;
  int dest_code;
  pwr_tObjName classname, name;
  pwr_tCid cid;
  pwr_tOid oid;
  ldh_tSesContext ldhses;

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    *return_int = CMD__NOVOLATTACHED;
    *return_decl = CCM_DECL_INT;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 4)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;
  arg_p4 = arg_p3->next;
  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__VARTYPE;
  if (arg_p2->value_decl != CCM_DECL_STRING)
    return CCM__VARTYPE;
  if (arg_p3->value_decl != CCM_DECL_STRING)
    return CCM__VARTYPE;
  if (arg_p4->value_decl != CCM_DECL_INT)
    return CCM__VARTYPE;

  strncpy(name, arg_list->value_string, sizeof(name));
  strncpy(classname, arg_p2->value_string, sizeof(classname));
  strncpy(dest, arg_p3->value_string, sizeof(dest));
  dest_code = arg_p4->value_int;

  sts = ldh_NameToObjid(ldhses, &dest_oid, dest);
  if (EVEN(sts)) {
    *return_int = sts;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  sts = ldh_ClassNameToId(ldhses, &cid, classname);
  if (EVEN(sts)) {
    *return_int = sts;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  sts = ldh_CreateObject(
      ldhses, &oid, name, cid, dest_oid, (ldh_eDest)dest_code);
  *return_int = sts;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int wccm_openplcpgm_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  pwr_tOName name;
  pwr_tOid oid;
  pwr_tOid windoid, docoid;
  int size;
  ldh_tSesContext ldhses;
  ldh_tWBContext wbctx;
  ldh_sSessInfo info;
  int new_plc = 0;

  sts = wccm_get_wbctx(&wbctx);
  if (EVEN(sts)) {
    *return_int = CMD__NOWBATTACHED;
    *return_decl = CCM_DECL_INT;
    return CMD__NOWBATTACHED;
  }

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    *return_int = CMD__NOVOLATTACHED;
    *return_decl = CCM_DECL_INT;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__VARTYPE;
  /* Check that the session is saved */
  sts = ldh_GetSessionInfo(ldhses, &info);
  if (EVEN(sts))
    return sts;
  if (info.Access != ldh_eAccess_ReadWrite)
    return CCM__NOACCESS;
  if (!info.Empty) {
    return GSX__NOTSAVED;
  }

  /* To be able to redraw the windows, the session has to
     be set to ReadOnly */
  sts = ldh_SetSession(ldhses, ldh_eAccess_ReadOnly);
  if (EVEN(sts))
    return sts;

  strncpy(name, arg_list->value_string, sizeof(name));

  sts = ldh_NameToObjid(ldhses, &oid, name);
  if (EVEN(sts)) {
    *return_int = sts;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  // Check if this is a new PlcPgm
  sts = ldh_GetChild(ldhses, oid, &windoid);
  if (EVEN(sts))
    new_plc = 1;

  WNav* wnav;
  sts = wccm_get_wnav(&wnav);
  wb_utl* utl = wnav->utl_new();
  if (!wnav->has_window())
    utl->create_mainwindow(0, NULL);

  sts = utl->utl_foe_new("CmdEdit", oid, wbctx, ldhses, &stored_foe, 0,
      ldh_eAccess_SharedReadWrite);
  delete utl;

  if (ODD(sts)) {
    // Store the window object
    int lsts = ldh_GetChild(ldhses, oid, &windoid);
    if (EVEN(lsts))
      return sts;

    lsts = ldh_ObjidToName(ldhses, windoid, ldh_eName_Hierarchy,
        stored_foe_window, sizeof(stored_foe_window), &size);
    if (EVEN(lsts))
      return sts;

    if (new_plc) {
      // Delete the document object
      lsts = ldh_GetChild(ldhses, windoid, &docoid);
      if (EVEN(lsts))
        return sts;

      stored_foe->cmd_delete_node(docoid);
    } else {
      // Enter edit mode
      stored_foe->change_mode(EDIT);
    }
  }
  *return_int = sts;
  *return_decl = CCM_DECL_INT;

  return 1;
}

void wccm_foe_close(ldh_tSesContext ldhses)
{
  if (!stored_foe)
    return;

  stored_foe->quit();
  stored_foe = 0;

  /* Set session access to readwrite again */
  ldh_SetSession(ldhses, ldh_eAccess_ReadWrite);
}

static int wccm_closeplcpgm_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  ldh_tSesContext ldhses;
  int sts;

  if (arg_count != 0)
    return CCM__ARGMISM;

  if (!stored_foe) {
    *return_int = 0;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    *return_int = CMD__NOVOLATTACHED;
    *return_decl = CCM_DECL_INT;
    return CMD__NOVOLATTACHED;
  }

  WFoe::exit_save(stored_foe);
  stored_foe = 0;

  /* Set session access to readwrite again */
  sts = ldh_SetSession(ldhses, ldh_eAccess_ReadWrite);
  if (EVEN(sts))
    return sts;

  *return_int = 1;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int wccm_createplcobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  ccm_sArg *arg_p2, *arg_p3, *arg_p4, *arg_p5 = NULL, *arg_p6 = NULL,
                                      *arg_p7 = NULL, *arg_p8;
  int sts;
  pwr_tObjName dest;
  pwr_tObjName classname, name;
  float x;
  float y;
  unsigned int inputmask = 0, outputmask = 0, invertmask = 0;
  ldh_tSesContext ldhses;
  int use_default_masks = 1;
  pwr_tCid cid;
  pwr_tOid dest_oid;
  pwr_tOid* dest_oid_p = &dest_oid;
  int dest_found = 0;

  // Arguments name, class, document, x, y, document, inputmask, outputmask,
  // invertmask
  if (!stored_foe) {
    *return_int = 0;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    *return_int = CMD__NOVOLATTACHED;
    *return_decl = CCM_DECL_INT;
    return CMD__NOVOLATTACHED;
  }

  if (!(arg_count == 4 || arg_count == 5 || arg_count == 8)) {
    wccm_foe_close(ldhses);
    return CCM__ARGMISM;
  }

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;
  arg_p4 = arg_p3->next;
  if (arg_list->value_decl != CCM_DECL_STRING) {
    wccm_foe_close(ldhses);
    return CCM__VARTYPE;
  }
  if (arg_p2->value_decl != CCM_DECL_STRING) {
    wccm_foe_close(ldhses);
    return CCM__VARTYPE;
  }
  if (arg_p3->value_decl != CCM_DECL_FLOAT) {
    wccm_foe_close(ldhses);
    return CCM__VARTYPE;
  }
  if (arg_p4->value_decl != CCM_DECL_FLOAT) {
    wccm_foe_close(ldhses);
    return CCM__VARTYPE;
  }
  if (arg_count >= 5) {
    arg_p5 = arg_p4->next;
    if (arg_p5->value_decl != CCM_DECL_STRING) {
      wccm_foe_close(ldhses);
      return CCM__VARTYPE;
    }
    if (!streq(arg_p5->value_string, "")) {
      strncpy(dest, stored_foe_window, sizeof(dest));
      strncat(dest, "-", sizeof(dest) - strlen(dest) - 1);
      strncat(dest, arg_p5->value_string, sizeof(dest) - strlen(dest) - 1);
      dest_found = 1;
    }
  }
  if (arg_count >= 6) {
    arg_p6 = arg_p5->next;
    if (arg_p6->value_decl != CCM_DECL_INT) {
      wccm_foe_close(ldhses);
      return CCM__VARTYPE;
    }
    inputmask = arg_p6->value_int;
  }
  if (arg_count >= 7) {
    arg_p7 = arg_p6->next;
    if (arg_p7->value_decl != CCM_DECL_INT) {
      wccm_foe_close(ldhses);
      return CCM__VARTYPE;
    }
    outputmask = arg_p7->value_int;
  }
  if (arg_count >= 8) {
    arg_p8 = arg_p7->next;
    if (arg_p8->value_decl != CCM_DECL_INT) {
      wccm_foe_close(ldhses);
      return CCM__VARTYPE;
    }
    invertmask = arg_p8->value_int;
    use_default_masks = 0;
  }

  strncpy(name, arg_list->value_string, sizeof(name));
  strncpy(classname, arg_p2->value_string, sizeof(classname));
  x = arg_p3->value_float;
  y = arg_p4->value_float;

  sts = ldh_ClassNameToId(ldhses, &cid, classname);
  if (EVEN(sts)) {
    *return_int = sts;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  if (dest_found) {
    sts = ldh_NameToObjid(ldhses, &dest_oid, dest);
    if (EVEN(sts)) {
      *return_int = sts;
      *return_decl = CCM_DECL_INT;
      return 1;
    }
  } else
    dest_oid_p = 0;

  sts = stored_foe->cmd_create_node(name, cid, dest_oid_p, x, y,
      use_default_masks, inputmask, outputmask, invertmask);
  *return_int = sts;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int wccm_setplcobjectattr_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  ccm_sArg* arg_p2;
  int sts;
  char buf[400];
  pwr_tAName name;
  pwr_tOName attr;
  char* s;
  ldh_tSesContext ldhses;

  if (!stored_foe) {
    *return_int = 0;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 2) {
    wccm_foe_close(ldhses);
    return CCM__ARGMISM;
  }
  arg_p2 = arg_list->next;
  if (arg_list->value_decl != CCM_DECL_STRING) {
    wccm_foe_close(ldhses);
    return CCM__VARTYPE;
  }
  switch (arg_p2->value_decl) {
  case CCM_DECL_STRING:
    strcpy(buf, arg_p2->value_string);
    break;
  case CCM_DECL_INT:
    sprintf(buf, "%ld", arg_p2->value_int);
    break;
  case CCM_DECL_FLOAT:
    sprintf(buf, "%f", arg_p2->value_float);
    break;
  }

  strcpy(name, stored_foe_window);
  strcat(name, "-");
  strncat(name, arg_list->value_string, sizeof(name) - strlen(name) - 1);
  if ((s = strrchr(name, '.'))) {
    *s = 0;
    strcpy(attr, s + 1);
  } else {
    wccm_foe_close(ldhses);
    return CMD__ATTRIBUTE;
  }

  sts = stored_foe->cmd_get_ldhses(&ldhses);
  sts = utl_set_object_parameter(ldhses, 0, 0, name, attr, buf, 0, "", 0, 0);

  *return_int = sts;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int wccm_createplcconnection_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  ccm_sArg *arg_p2, *arg_p3, *arg_p4, *arg_p5;
  int sts;
  pwr_tObjName srcattr, destattr;
  pwr_tOName srcname, destname;
  pwr_tOid srcoid, destoid;
  ldh_tSesContext ldhses;
  int feedback = 0;

  // Arguments souce, source attribute, destination, destination attribute,
  // feedback
  if (!stored_foe) {
    *return_int = 0;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    *return_int = CMD__NOVOLATTACHED;
    *return_decl = CCM_DECL_INT;
    return CMD__NOVOLATTACHED;
  }

  if (!(arg_count == 4 || arg_count == 5)) {
    wccm_foe_close(ldhses);
    return CCM__ARGMISM;
  }

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;
  arg_p4 = arg_p3->next;
  if (arg_list->value_decl != CCM_DECL_STRING) {
    wccm_foe_close(ldhses);
    return CCM__VARTYPE;
  }
  if (arg_p2->value_decl != CCM_DECL_STRING) {
    wccm_foe_close(ldhses);
    return CCM__VARTYPE;
  }
  if (arg_p3->value_decl != CCM_DECL_STRING) {
    wccm_foe_close(ldhses);
    return CCM__VARTYPE;
  }
  if (arg_p4->value_decl != CCM_DECL_STRING) {
    wccm_foe_close(ldhses);
    return CCM__VARTYPE;
  }
  if (arg_count > 4) {
    arg_p5 = arg_p4->next;
    if (arg_p5->value_decl != CCM_DECL_INT) {
      wccm_foe_close(ldhses);
      return CCM__VARTYPE;
    }
    feedback = arg_p5->value_int;
  }

  strcpy(srcname, stored_foe_window);
  strcat(srcname, "-");
  strncat(
      srcname, arg_list->value_string, sizeof(srcname) - strlen(srcname) - 1);
  strncpy(srcattr, arg_p2->value_string, sizeof(srcattr));
  strcpy(destname, stored_foe_window);
  strcat(destname, "-");
  strncat(
      destname, arg_p3->value_string, sizeof(destname) - strlen(destname) - 1);
  strncpy(destattr, arg_p4->value_string, sizeof(destattr));

  sts = ldh_NameToObjid(ldhses, &srcoid, srcname);
  if (EVEN(sts)) {
    *return_int = sts;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  sts = ldh_NameToObjid(ldhses, &destoid, destname);
  if (EVEN(sts)) {
    *return_int = sts;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  sts = stored_foe->cmd_create_con(
      srcoid, srcattr, destoid, destattr, feedback);
  *return_int = sts;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int wccm_plcconnect_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  ccm_sArg* arg_p2;
  int sts;
  pwr_tOName nodename;
  pwr_tAName attrname;
  pwr_tAttrRef aref;
  pwr_tOid nodeoid;
  ldh_tSesContext ldhses;

  // Arguments plcnode, attribute
  if (!stored_foe) {
    *return_int = 0;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    *return_int = CMD__NOVOLATTACHED;
    *return_decl = CCM_DECL_INT;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 2) {
    wccm_foe_close(ldhses);
    return CCM__ARGMISM;
  }

  arg_p2 = arg_list->next;
  if (arg_list->value_decl != CCM_DECL_STRING) {
    wccm_foe_close(ldhses);
    return CCM__VARTYPE;
  }
  if (arg_p2->value_decl != CCM_DECL_STRING) {
    wccm_foe_close(ldhses);
    return CCM__VARTYPE;
  }

  strcpy(nodename, stored_foe_window);
  strcat(nodename, "-");
  strncat(nodename, arg_list->value_string,
      sizeof(nodename) - strlen(nodename) - 1);
  strncpy(attrname, arg_p2->value_string, sizeof(attrname));

  sts = ldh_NameToObjid(ldhses, &nodeoid, nodename);
  if (EVEN(sts)) {
    *return_int = sts;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  sts = ldh_NameToAttrRef(ldhses, attrname, &aref);
  if (EVEN(sts)) {
    *return_int = sts;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  sts = stored_foe->cmd_connect(&aref, nodeoid);
  *return_int = sts;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int wccm_inlib_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  int sts;
  pwr_tObjid oid;
  pwr_tCid cid;
  ldh_tSesContext ldhses;
  int in_lib;

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOVOLATTACHED;
  }

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  in_lib = 0;
  for (sts = ldh_NameToObjid(ldhses, &oid, arg_list->value_string); ODD(sts);
       sts = ldh_GetParent(ldhses, oid, &oid)) {
    sts = ldh_GetObjectClass(ldhses, oid, &cid);
    if (ODD(sts) && cid == pwr_eClass_LibHier) {
      in_lib = 1;
      break;
    }
  }
  *return_int = in_lib;
  *return_decl = CCM_DECL_INT;

  return 1;
}

/*************************************************************************
*
* Name:		wccm_register()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*
**************************************************************************/

int wccm_register(int (*get_wbctx_cb)(void*, ldh_tWBContext*),
    int (*get_ldhsession_cb)(void*, ldh_tSesContext*),
    int (*get_wnav_cb)(void*, WNav**))
{
  int sts;

  wccm_get_wbctx_cb = get_wbctx_cb;
  wccm_get_ldhsession_cb = get_ldhsession_cb;
  wccm_get_wnav_cb = get_wnav_cb;

  if (!wccm_ccm_func_registred) {
    sts = ccm_register_function("Wb", "GetAttribute", wccm_getattribute_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "GetChild", wccm_getchild_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "GetParent", wccm_getparent_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Wb", "GetNextSibling", wccm_getnextsibling_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "GetClassList", wccm_getclasslist_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "GetNextObject", wccm_getnextobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Wb", "GetClassListAttrRef", wccm_getclasslistattrref_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Wb", "GetNextAttrRef", wccm_getnextattrref_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "GetRootList", wccm_getrootlist_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Wb", "GetObjectClass", wccm_getobjectclass_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "RenameObject", wccm_renameobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "MoveObject", wccm_moveobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Wb", "GetTemplateObject", wccm_gettemplateobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Wb", "GetNextTemplateAttrRef", wccm_getnexttemplateattrref_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "GetVolumeList", wccm_getvolumelist_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "GetNextVolume", wccm_getnextvolume_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Wb", "GetVolumeClass", wccm_getvolumeclass_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "CutObjectName", wccm_cutobjectname_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "GetNodeObject", wccm_getnodeobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "ObjectExist", wccm_objectexist_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Wb", "GetProjectName", wccm_getprojectname_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "SetAttribute", wccm_setattribute_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Wb", "CheckSystemGroup", wccm_checksystemgroup_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Wb", "GetNextFreeUserVid", wccm_getnextfreeuservid_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "CheckNewVid", wccm_checknewvid_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Wb", "CheckNewVolumeName", wccm_checknewvolumename_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Wb", "GetCurrentVolume", wccm_getcurrentvolume_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Wb", "StringToObjectName", wccm_stringtoobjectname_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "GetHardware", wccm_gethardware_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "GetOpSys", wccm_getopsys_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "GetVersion", wccm_getversion_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "CreateObject", wccm_createobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "OpenPlcPgm", wccm_openplcpgm_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "ClosePlcPgm", wccm_closeplcpgm_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Wb", "CreatePlcObject", wccm_createplcobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Wb", "SetPlcObjectAttr", wccm_setplcobjectattr_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Wb", "CreatePlcConnection", wccm_createplcconnection_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "PlcConnect", wccm_plcconnect_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Wb", "InLib", wccm_inlib_func);
    if (EVEN(sts))
      return sts;

    sts = ccm_create_external_var("cmd_status", CCM_DECL_INT, 0, 1, NULL);

    wccm_ccm_func_registred = 1;
  }

  return CMD__SUCCESS;
}

/*************************************************************************
*
* Name:		wccm_set_status()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*
**************************************************************************/

void wccm_set_status(pwr_tStatus sts)
{
  int status;

  if (ODD(sts))
    status = 1;
  else
    status = sts;
  ccm_set_external_var("cmd_status", CCM_DECL_INT, 0, status, NULL);
}

/*************************************************************************
*
* Name:		wccm_attribute_func()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*
**************************************************************************/

static int wccm_attribute_func(char* name, int* return_decl,
    ccm_tFloat* return_float, ccm_tInt* return_int, char* return_string)
{
  int sts, size;
  pwr_tAName hier_name;
  char* hier_name_p;
  char* valuep;
  int decl = 0;
  int int_val = 0;
  float float_val = 0.0;
  char string_val[80];
  ldh_tSesContext ldhses;

  sts = wccm_get_ldhses(&ldhses);
  if (EVEN(sts)) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return CMD__NOVOLATTACHED;
  }

  wb_session* sp = (wb_session*)ldhses;

  wb_attribute a = sp->attribute(name);
  if (!a) {
    strcpy(return_string, "");
    *return_decl = CCM_DECL_STRING;
    return a.sts();
  }

  valuep = (char*)calloc(1, a.size());
  a.value(valuep);

  switch (a.type()) {
  case pwr_eType_Boolean: {
    int_val = *(pwr_tBoolean*)valuep;
    decl = CCM_DECL_INT;
    break;
  }
  case pwr_eType_Float32: {
    float_val = *(pwr_tFloat32*)valuep;
    decl = CCM_DECL_FLOAT;
    break;
  }
  case pwr_eType_Float64: {
    float_val = *(pwr_tFloat64*)valuep;
    decl = CCM_DECL_FLOAT;
    break;
  }
  case pwr_eType_Char: {
    int_val = *(pwr_tChar*)valuep;
    decl = CCM_DECL_INT;
    break;
  }
  case pwr_eType_Int8: {
    int_val = *(pwr_tInt8*)valuep;
    decl = CCM_DECL_INT;
    break;
  }
  case pwr_eType_Int16: {
    int_val = *(pwr_tInt16*)valuep;
    decl = CCM_DECL_INT;
    break;
  }
  case pwr_eType_Int32: {
    int_val = *(pwr_tInt32*)valuep;
    decl = CCM_DECL_INT;
    break;
  }
  case pwr_eType_Int64: {
    int_val = *(pwr_tInt64*)valuep;
    decl = CCM_DECL_INT;
    break;
  }
  case pwr_eType_UInt8: {
    int_val = *(pwr_tUInt8*)valuep;
    decl = CCM_DECL_INT;
    break;
  }
  case pwr_eType_UInt16: {
    int_val = *(pwr_tUInt16*)valuep;
    decl = CCM_DECL_INT;
    break;
  }
  case pwr_eType_UInt32:
  case pwr_eType_Enum:
  case pwr_eType_Mask:
  case pwr_eType_ClassId:
  case pwr_eType_TypeId:
  case pwr_eType_VolumeId:
  case pwr_eType_ObjectIx: {
    int_val = *(pwr_tUInt32*)valuep;
    decl = CCM_DECL_INT;
    break;
  }
  case pwr_eType_UInt64: {
    int_val = *(pwr_tUInt64*)valuep;
    decl = CCM_DECL_INT;
    break;
  }
  case pwr_eType_String: {
    strncpy(string_val, valuep, sizeof(string_val));
    string_val[sizeof(string_val) - 1] = 0;
    decl = CCM_DECL_STRING;
    break;
  }
  case pwr_eType_Text: {
    strncpy(string_val, valuep, sizeof(string_val));
    string_val[sizeof(string_val) - 1] = 0;
    decl = CCM_DECL_STRING;
    break;
  }
  case pwr_eType_ObjDId: {
    /* Get the object name from ldh */
    sts = ldh_ObjidToName(ldhses, *(pwr_tObjid*)valuep, ldh_eName_Hierarchy,
        hier_name, sizeof(hier_name), &size);
    if (EVEN(sts))
      strcpy(string_val, "Undefined Object");
    else
      strncpy(string_val, hier_name, sizeof(string_val));
    string_val[sizeof(string_val) - 1] = 0;
    decl = CCM_DECL_STRING;
    break;
  }
  case pwr_eType_AttrRef: {
    /* Get the object name from ldh */
    sts = ldh_AttrRefToName(
        ldhses, (pwr_sAttrRef*)valuep, ldh_eName_Aref, &hier_name_p, &size);
    if (EVEN(sts))
      strcpy(string_val, "Undefined attribute");
    else
      strncpy(string_val, hier_name_p, sizeof(string_val));
    string_val[sizeof(string_val) - 1] = 0;
    decl = CCM_DECL_STRING;
    break;
  }
  case pwr_eType_Time: {
    /* Convert time to ascii */
    sts = time_AtoAscii((pwr_tTime*)valuep, time_eFormat_DateAndTime,
        string_val, sizeof(string_val));
    string_val[20] = 0;
    decl = CCM_DECL_STRING;
    break;
  }
  case pwr_eType_DeltaTime: {
    /* Convert time to ascii */
    sts = time_DtoAscii(
        (pwr_tDeltaTime*)valuep, 1, string_val, sizeof(string_val));
    string_val[20] = 0;
    decl = CCM_DECL_STRING;
    break;
  }
  default:;
  }

  free(valuep);
  *return_decl = decl;
  if (decl == CCM_DECL_INT)
    *return_int = int_val;
  else if (decl == CCM_DECL_FLOAT)
    *return_float = float_val;
  else if (decl == CCM_DECL_STRING)
    strcpy(return_string, string_val);

  return FOE__SUCCESS;
}

/*************************************************************************
*
* Name:		wccm_cut_segments()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*
**************************************************************************/

static int wccm_cut_segments(char* outname, char* name, int segments)
{
  char* s[20];
  int i, j, last_i = 0;

  for (i = 0; i < segments; i++) {
    s[i] = strrchr(name, '-');
    if (s[i] == 0) {
      last_i = i;
      break;
    }
    *s[i] = '+';
    last_i = i;
  }
  for (j = 0; j <= last_i; j++) {
    if (s[j] != 0)
      *s[j] = '-';
  }
  if (s[last_i] == 0)
    strcpy(outname, name);
  else
    strcpy(outname, s[last_i] + 1);

  return FOE__SUCCESS;
}
