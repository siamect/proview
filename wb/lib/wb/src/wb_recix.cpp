/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* wb_recix.cpp    Recycle objid. Stores name and oix of deleted tree
                   to recycle the oix when a similar tree is copied.*/

#include <iostream>

#include "co_string.h"

#include "wb_name.h"
#include "wb_recix.h"

wb_recix::wb_recix() : m_destroot_len(0)
{
  strcpy(m_srcroot, "");
  strcpy(m_destroot, "");
}

bool wb_recix::add(const char* str, pwr_tOix ix)
{
  std::string key = std::string(str);
  m_ix[key] = ix;

  return true;
}

bool wb_recix::add_object_tree(wb_object& o)
{
  clear();

  wb_object p = o.parent();
  if (p)
    strcpy(m_srcroot, p.longName().c_str());

  add(o.longName().c_str(), o.oid().oix);
  for (wb_object ch = o.first(); ch; ch = ch.after())
    add_object_ctree(ch);

  // for (  ix_iterator it = m_ix.begin(); it != m_ix.end(); it++) {
  //   std::cout << " Object: " << it->second << "  " << it->first << '\n';
  // }

  return true;
}

bool wb_recix::add_object_ctree(wb_object& o)
{
  add(o.longName().c_str(), o.oid().oix);
  for (wb_object ch = o.first(); ch; ch = ch.after())
    add_object_tree(ch);
  return true;
}

void wb_recix::set_destination(const char* dest)
{
  strncpy(m_destroot, dest, sizeof(m_destroot));
  m_destroot_len = strlen(m_destroot);
}

bool wb_recix::get(char* str, pwr_tOix* ix)
{
  pwr_tOName keystr;

  if ((int)strlen(str) <= m_destroot_len)
    return false;

  if (!streq(m_srcroot, "")) {
    strcpy(keystr, m_srcroot);
    if (m_destroot_len)
      strcat(keystr, &str[m_destroot_len]);
    else {
      strcat(keystr, "-");
      strcat(keystr, str);
    }
  } else {
    if (m_destroot_len)
      strcat(keystr, &str[m_destroot_len + 1]);
    else {
      strcat(keystr, str);
    }
  }

  std::string key = std::string(keystr);

  ix_iterator it = m_ix.find(key);
  if (it == m_ix.end())
    return false;
  *ix = it->second;
  return true;
}

void wb_recix::clear()
{
  m_ix.clear();
}
