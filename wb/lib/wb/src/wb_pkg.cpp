/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2020 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <sys/stat.h>

#include "pwr_names.h"

#include "co_string.h"
#include "co_time.h"

#include "rt_load.h"

#include "cow_msgwindow.h"

#include "wb_erep.h"
#include "wb_error.h"
#include "wb_log.h"
#include "wb_pkg.h"

static unsigned int pkg_random()
{
  pwr_tTime t;

  time_GetTime(&t);
  int itime = t.tv_nsec + t.tv_sec % 10000;

  srand(itime);
  return (unsigned int)((double)rand() / ((double)RAND_MAX + 1) * 999999);
}

wb_pkg::wb_pkg(char* nodelist, bool distribute, bool config_only, bool check,
    int* new_files)
{
  if (nodelist) {
    char node_str[32][20];
    int num;

    str_ToLower(nodelist, nodelist);
    num = dcli_parse(nodelist, " 	,", "", (char*)node_str,
        sizeof(node_str) / sizeof(node_str[0]), sizeof(node_str[0]), 0);
    m_allnodes = false;

    for (int i = 0; i < num; i++) {
      pkg_node n(node_str[i]);
      m_nodelist.push_back(n);
    }
  } else
    m_allnodes = true;

  readConfig();
  if (config_only)
    return;

  for (unsigned int i = 0; i < m_nodelist.size(); i++)
    m_nodelist[i].checkNode();

  if (check && new_files) {
    *new_files = 0;
    for (unsigned int i = 0; i < m_nodelist.size(); i++)
      *new_files += m_nodelist[i].compareFiles();
    return;
  }

  fetchFiles(distribute);
}

void wb_pkg::readConfig()
{
  char fname[260];
  char line[200];
  char line_item[7][80];
  int num;
  int sts;

  dcli_translate_filename(fname, pwr_cNameDistribute);
  std::ifstream is(fname);

  while (is.getline(line, sizeof(line))) {
    str_trim(line, line);
    if (line[0] == '#' || line[0] == '!')
      continue;

    num = dcli_parse(line, " 	", "", (char*)line_item,
        sizeof(line_item) / sizeof(line_item[0]), sizeof(line_item[0]), 0);
    if (!num)
      continue;

    if (streq(cdh_Low(line_item[0]), "node")) {
      pwr_mOpSys opsys;
      int bus;
      pwr_tMask dstatus;
      char bootnode[80];
      pwr_tString80 custom_platform;

      if (num != 7)
        throw wb_error_str("File corrupt " pwr_cNameDistribute);

      sts = sscanf(line_item[2], "%d", (int*)&opsys);
      if (sts != 1)
        throw wb_error_str("File corrupt " pwr_cNameDistribute);

      sts = sscanf(line_item[3], "%d", &bus);
      if (sts != 1)
        throw wb_error_str("File corrupt " pwr_cNameDistribute);

      sts = sscanf(line_item[4], "%d", (int*)&dstatus);
      if (sts != 1)
        throw wb_error_str("File corrupt " pwr_cNameDistribute);

      strcpy(bootnode, line_item[5]);
      strcpy(custom_platform, line_item[6]);

      if (m_allnodes) {
        pkg_node node(
            line_item[1], opsys, bus, dstatus, bootnode, custom_platform);
        m_nodelist.push_back(node);
      } else {
        bool found = false;
        for (int i = 0; i < (int)m_nodelist.size(); i++) {
          if (streq(m_nodelist[i].name(), cdh_Low(line_item[1]))) {
            found = true;
            m_nodelist[i].setOpsys(opsys);
            m_nodelist[i].setBus(bus);
            m_nodelist[i].setDStatus(dstatus);
            m_nodelist[i].setBootnode(bootnode);
            m_nodelist[i].setCustomPlatform(custom_platform);
            m_nodelist[i].setValid();
            break;
          }
        }
      }
    } else if (streq(cdh_Low(line_item[0]), "appl")) {
      if (!(num == 4 || num == 5))
        throw wb_error_str("File corrupt " pwr_cNameDistribute);

      char severity = line_item[2][0];
      try {
        pkg_node& n = getNode(line_item[1]);
        if (num == 4) {
          pkg_pattern p(line_item[3], "", severity);
          n.push_back(p);
        } else {
          pkg_pattern p(line_item[3], line_item[4], severity);
          n.push_back(p);
        }
      } catch (wb_error&) {
        continue;
      }
    } else if (streq(cdh_Low(line_item[0]), "depnode")) {
      if (num != 4)
        throw wb_error_str("File corrupt " pwr_cNameDistribute);

      try {
        pkg_node& n = getNode(line_item[1]);
        pkg_depnode dn(line_item[2], line_item[3]);
        n.depnodeAdd(dn);
      } catch (wb_error&) {
        continue;
      }
    } else if (streq(cdh_Low(line_item[0]), "load")) {
      pwr_tVolumeId* vollist;
      pwr_tString40* volnamelist;
      int volcount;
      pwr_tString80* plclist;
      int plccount;
      char systemname[80];
      char systemgroup[80];
      pwr_tTime date;

      if (num != 2)
        throw wb_error_str("File corrupt " pwr_cNameDistribute);

      try {
        pkg_node& n = getNode(line_item[1]);

        // Add ld_node file
        sprintf(fname, pwr_cNameNode, load_cDirectory, n.name(), n.bus());
        pkg_pattern pnode(fname, "", 'E');
        n.push_back(pnode);

        // Add ld_redcom file
        sprintf(fname, pwr_cNameRedcom, load_cDirectory, n.name(), n.bus());
        pkg_pattern predcom(fname, "", 'S');
        n.push_back(predcom);

        // Add bootfile
        sprintf(fname, pwr_cNameBoot, load_cDirectory, n.name(), n.bus());
        pkg_pattern pboot(fname, "", 'E');
        n.push_back(pboot);

        // Read bootfile, get plc and volumes
	vollist = 0;
	volnamelist = 0;
        sts = lfu_ReadBootFile(fname, &date, systemname, systemgroup, &vollist,
            &volnamelist, &volcount, &plclist, &plccount);
        if (EVEN(sts))
          throw wb_error_str("Bootfile is corrupt");

        // Add plc
        for (int j = 0; j < plccount; j++) {
          pwr_tFileName dir;

          if (n.opsys() == pwr_mOpSys_CustomBuild
              && !streq(n.customPlatform(), "-"))
            sprintf(dir, "$pwrp_root/bld/%s/exe/", n.customPlatform());
          else
            sprintf(dir, "$pwrp_root/bld/%s/exe/", cdh_OpSysToStr(n.opsys()));
          sprintf(fname, "%s%s", dir, plclist[j]);
          sprintf(dir, "$pwrp_exe/");
          pkg_pattern pplc(fname, dir, 'W');
          n.push_back(pplc);
        }

        // Add volumes
        for (int j = 0; j < volcount; j++) {
          char dir[80];

          if ((vollist[j] >= cdh_cManufactClassVolMin
                  && vollist[j] <= cdh_cManufactClassVolMax)
              || (vollist[j] >= cdh_cSystemClassVolMin
                     && vollist[j] <= cdh_cSystemClassVolMax)) {
            // Base volume, skip
            continue;
          }

          strcpy(dir, "$pwrp_load/");
          sprintf(fname, "%s%s.dbs", dir, cdh_Low((char*)(volnamelist + j)));
          n.checkVolume(fname);

          // Check if there are any rtt-files for Root or Sub Volumes
          if (vollist[j] >= cdh_cUserVolMin && vollist[j] <= cdh_cUserVolMax) {
            cdh_uVolumeId vid;
            vid.pwr = vollist[j];

            // RttCrr-file
            strcpy(dir, "$pwrp_load/");
            sprintf(fname, "%s" pwr_cNameRttCrr, dir, vid.v.vid_3, vid.v.vid_2,
                vid.v.vid_1, vid.v.vid_0);
            pkg_pattern rttcrr(fname);
            n.push_back(rttcrr);

            // RttCrrObj-file
            strcpy(dir, "$pwrp_load/");
            sprintf(fname, "%s" pwr_cNameRttCrrObj, dir, vid.v.vid_3,
                vid.v.vid_2, vid.v.vid_1, vid.v.vid_0);
            pkg_pattern rttcrrobj(fname);
            n.push_back(rttcrrobj);

            // RttCrrCode-file
            strcpy(dir, "$pwrp_load/");
            sprintf(fname, "%s" pwr_cNameRttCrrCode, dir, vid.v.vid_3,
                vid.v.vid_2, vid.v.vid_1, vid.v.vid_0);
            pkg_pattern rttcrrcode(fname);
            n.push_back(rttcrrcode);

            // RttSignals

            strcpy(dir, "$pwrp_load/");
            sprintf(fname, "%s" pwr_cNameRttSignals, dir, vid.v.vid_3,
                vid.v.vid_2, vid.v.vid_1, vid.v.vid_0);
            pkg_pattern rttsignals(fname);
            n.push_back(rttsignals);
          }
        }

	if (volnamelist)
	  free(volnamelist);
	if (vollist)
	  free(vollist);

      } catch (wb_error& e) {
        if (e.what() == std::string("No such node"))
          continue;
        throw wb_error_str(e.what());
      }
    } else if (streq(cdh_Low(line_item[0]), "boot")) {
      // A Sev node, only node and bootfile
      try {
        if (num != 2)
          throw wb_error_str("File corrupt " pwr_cNameDistribute);

        pkg_node& n = getNode(line_item[1]);
        // Add ld_node file
        sprintf(fname, pwr_cNameNode, load_cDirectory, n.name(), n.bus());
        pkg_pattern pnode(fname, "", 'E');
        n.push_back(pnode);

        // Add bootfile
        sprintf(fname, pwr_cNameBoot, load_cDirectory, n.name(), n.bus());
        pkg_pattern pboot(fname, "", 'E');
        n.push_back(pboot);
      } catch (wb_error& e) {
        if (e.what() == std::string("No such node"))
          continue;
        throw wb_error_str(e.what());
      }
    }
  }

  is.close();

  // Check that all nodes are valid
  for (int i = 0; i < (int)m_nodelist.size(); i++) {
    if (!m_nodelist[i].valid())
      throw wb_error_str("Unknown node name");
  }
}

pkg_node& wb_pkg::getNode(char* name)
{
  for (int i = 0; i < (int)m_nodelist.size(); i++) {
    if (streq(m_nodelist[i].name(), cdh_Low(name)))
      return m_nodelist[i];
  }
  throw wb_error_str("No such node");
}

pkg_node::pkg_node(char* name)
    : m_opsys(pwr_mOpSys__), m_bus(0), m_dstatus(0), m_valid(false),
      m_errors(0), m_warnings(0)
{
  strncpy(m_name, name, sizeof(m_name));
  strcpy(m_user, "pwrp");
  strcpy(m_bootnode, "-");
  strcpy(m_custom_platform, "-");
}

pkg_node::pkg_node(char* name, pwr_mOpSys opsys, int bus, pwr_tMask dstatus,
    char* bootnode, char* custom_platform)
    : m_opsys(opsys), m_bus(bus), m_dstatus(dstatus), m_valid(true),
      m_errors(0), m_warnings(0)
{
  char* s;
  strncpy(m_user, bootnode, sizeof(m_user));
  if ((s = strchr(m_user, '@'))) {
    *s = 0;
    strncpy(m_bootnode, s + 1, sizeof(m_bootnode));
  } else {
    strcpy(m_user, "pwrp");
    strcpy(m_bootnode, bootnode);
  }
  strncpy(m_name, name, sizeof(m_name));
  strncpy(m_custom_platform, custom_platform, sizeof(m_custom_platform));
}

void pkg_node::setBootnode(char* bootnode)
{
  char* s;
  strncpy(m_user, bootnode, sizeof(m_user));
  if ((s = strchr(m_user, '@'))) {
    *s = 0;
    strncpy(m_bootnode, s + 1, sizeof(m_bootnode));
  } else {
    strcpy(m_user, "pwrp");
    strcpy(m_bootnode, bootnode);
  }
}

void pkg_node::setCustomPlatform(char* custom_platform)
{
  strncpy(m_custom_platform, custom_platform, sizeof(m_custom_platform));
}

void pkg_node::checkNode()
{
  pwr_tStatus sts;
  pwr_tVolumeId* vollist;
  pwr_tString40* volnamelist;
  int volcount;
  pwr_tString80* plclist;
  int plccount;
  char systemname[80];
  char systemgroup[80];
  pwr_tTime bootversion;
  pwr_tFileName fname;

  sprintf(fname, pwr_cNameBoot, load_cDirectory, name(), bus());
  sts = lfu_ReadBootFile(fname, &bootversion, systemname, systemgroup, &vollist,
      &volnamelist, &volcount, &plclist, &plccount);
  if (EVEN(sts))
    throw wb_error_str("Bootfile is corrupt");

  // Check that bootversion is later than volume versions
  for (int i = 0; i < volcount; i++) {
    pwr_tVid vol_vid;
    pwr_tCid vol_cid;
    pwr_tTime vol_time;
    char vol_name[80];
    pwr_tUInt32 vol_dvversion;
    char dir[20];
    pwr_tObjName vname;

    if (vollist[i] >= cdh_cUserClassVolMin)
      strcpy(dir, "$pwrp_load/");
    else
      strcpy(dir, "$pwr_load/");
    strcpy(vname, (char*)(volnamelist + i));
    sprintf(fname, "%s%s.dbs", dir, cdh_Low(vname));

    sts = lfu_GetVolume(
        fname, vol_name, &vol_vid, &vol_cid, &vol_time, &vol_dvversion);
    if (EVEN(sts)) {
      char msg[280];
      sprintf(msg, "Loadfile not found: %s", fname);
      MsgWindow::message('E', msg, msgw_ePop_No);
      m_errors++;
      continue;
    }

    if (time_Acomp(&bootversion, &vol_time) == -1) {
      char msg[200];
      sprintf(msg, "Volume %s is built after node %s", vname, name());
      MsgWindow::message('E', msg, msgw_ePop_No);
      m_errors++;
    }
  }
}

void pkg_node::checkVolume(char* filename)
{
  lfu_t_volref* volref = NULL;
  int volref_cnt;
  pwr_tVid vol_vid;
  pwr_tCid vol_cid;
  pwr_tTime vol_time;
  char vol_name[80];
  pwr_tUInt32 vol_dvversion;
  bool found;
  pwr_tStatus sts;
  char fname[200];

  sts = lfu_GetVolume(
      filename, vol_name, &vol_vid, &vol_cid, &vol_time, &vol_dvversion);
  if (EVEN(sts))
    throw wb_error(sts);

  found = false;
  for (int i = 0; i < (int)m_volumelist.size(); i++) {
    if (m_volumelist[i].m_vid == vol_vid) {
      found = true;
      if (m_volumelist[i].m_time.tv_sec != vol_time.tv_sec) {
        char msg[200];
        sprintf(msg, "Version mismatch volume %s in %s", (volref + i)->name,
            filename);
        MsgWindow::message('E', msg, msgw_ePop_No);
        m_errors++;
      }
      break;
    }
  }
  if (!found) {
    pkg_volume vol(vol_name, filename, vol_vid, vol_time);
    m_volumelist.push_back(vol);
  }

  if (vol_cid == pwr_eClass_DetachedClassVolume)
    // No check of referenced volumes
    return;

  sts = lfu_GetVolRef(filename, &volref, &volref_cnt);
  if (EVEN(sts))
    throw wb_error(sts);

  for (int i = 0; i < volref_cnt; i++) {
    wb_erep::volumeNameToFilename(&sts, (volref + i)->name, fname);
    if (EVEN(sts)) {
      char msg[200];
      sprintf(msg, "Loadfile not found: %s", (volref + i)->name);
      MsgWindow::message('E', msg, msgw_ePop_No);
      m_errors++;
      continue;
    }

    checkVolume(fname);

    for (int j = 0; j < (int)m_volumelist.size(); j++) {
      if (m_volumelist[j].m_vid == (volref + i)->vid) {
        if (m_volumelist[j].m_time.tv_sec != (volref + i)->version.tv_sec) {
          char msg[320];
          sprintf(msg, "Version mismatch volume %s in %s and %s",
              (volref + i)->name, filename, m_volumelist[j].m_filename);
          MsgWindow::message('E', msg, msgw_ePop_No);
          m_errors++;
        }
        break;
      }
    }
  }
  free((char*)volref);
}

int pkg_node::compareFiles()
{
  char dev[80];
  char dir[80];
  char file[80];
  char type[80];
  int version;
  char fname[200];
  bool artime_minute = true;
  int new_files = 0;

  // Read package version
  sprintf(fname, "$pwrp_load/pkg_v_%s.dat", m_name);
  dcli_translate_filename(fname, fname);
  std::ifstream ifv(fname);
  if (ifv) {
    ifv >> version;
    ifv.close();
  } else
    // No previous package
    return false;

  // List the package and retrive the file date
  pwr_tFileName pkg_name;
  sprintf(pkg_name, pwr_cNamePkg, m_name, version);

  pwr_tCmd cmd;
  if (artime_minute)
    sprintf(cmd, "tar -tvf $pwrp_load/%s > %s", pkg_name, "$pwrp_tmp/fl.tmp");
  else
    sprintf(cmd, "tar --full-time -tvf $pwrp_load/%s > %s", pkg_name,
        "$pwrp_tmp/fl.tmp");
  system(cmd);

  dcli_translate_filename(fname, "$pwrp_tmp/fl.tmp");
  std::ifstream is(fname);
  char line[400];
  char line_item[6][200];
  int num;
  char timstr[40];
  pwr_tTime time;
  pwr_tFileName source;
  std::map<std::string, pwr_tTime> tarlist;

  while (is.getline(line, sizeof(line))) {
    num = dcli_parse(line, " 	", "", (char*)line_item,
        sizeof(line_item) / sizeof(line_item[0]), sizeof(line_item[0]), 0);
    if (num != 6)
      continue;

    if (!str_StartsWith(line_item[5], "pkg_build/"))
      continue;

    // Add file to list
    strncpy(timstr, line_item[3], sizeof(timstr));
    strncat(timstr, " ", sizeof(timstr) - strlen(timstr) - 1);
    strncat(timstr, line_item[4], sizeof(timstr) - strlen(timstr) - 1);

    strncpy(source, &line_item[5][10], sizeof(source));

    if (artime_minute)
      time_FormAsciiToA(timstr, MINUTE, 0, &time);
    else
      time_FormAsciiToA(timstr, SECOND, 0, &time);

    std::string s(source);
    tarlist[s] = time;
  }

  // Add volumes to pattern
  for (int i = 0; i < (int)m_volumelist.size(); i++) {
    if (!m_volumelist[i].m_isSystem) {
      pkg_pattern vol(m_volumelist[i].m_filename, "$pwrp_load/", 'E');
      push_back(vol);
    }
  }

  for (int i = 0; i < (int)m_pattern.size(); i++)
    m_pattern[i].fetchFiles();

  // Put all files in a single list
  m_filelist.clear();
  for (int i = 0; i < (int)m_pattern.size(); i++) {
    for (int j = 0; j < (int)m_pattern[i].m_filelist.size(); j++) {
      try {
        pkg_file f = m_pattern[i].m_filelist[j];

        dcli_parse_filename(f.m_source, dev, dir, file, type, &version);
        strcpy(f.m_arname, file);
        strcat(f.m_arname, type);

        // Check that this name is unique
        for (;;) {
          bool new_name = false;
          for (int k = 0; k < (int)m_filelist.size(); k++) {
            if (streq(m_filelist[k].m_arname, f.m_arname)) {
              strcat(f.m_arname, "x");
              new_name = true;
              break;
            }
          }
          if (!new_name)
            break;
        }

        m_filelist.push_back(f);
      } catch (wb_error& e) {
        MsgWindow::message('W', e.what().c_str(), msgw_ePop_No);
        m_warnings++;
      }
    }
  }

  for (int k = 0; k < (int)m_filelist.size(); k++) {
    std::string s(m_filelist[k].m_arname);
    pwr_tTime tar_time, src_time;
    pwr_tStatus sts;

    tar_time = tarlist[s];
    if (tar_time.tv_sec == 0) {
      printf("No such file: %s\n", m_filelist[k].m_arname);
      new_files++;
      continue;
    }

    sts = dcli_file_time(m_filelist[k].m_source, &src_time);
    // printf( "tar: %lld  src: %lld %s\n", tar_time.tv_sec, src_time.tv_sec,
    // m_filelist[k].m_arname);

    int diff = 0;
    if (artime_minute)
      diff = 60;

    if (ABS(tar_time.tv_sec - src_time.tv_sec) > diff) {
      printf("New file: %s\n", m_filelist[k].m_arname);
      new_files++;
    }
  }

  if (m_errors) {
    char msg[200];
    sprintf(msg, "Distribute errors node %s: %d errors, %d warnings", m_name,
        m_errors, m_warnings);
    MsgWindow::message('E', msg, msgw_ePop_Yes);
    throw wb_error_str(msg);
  } else if (m_warnings) {
    char msg[200];
    sprintf(
        msg, "Distribute warnings node %s: %d warnings", m_name, m_warnings);
    MsgWindow::message('W', msg, msgw_ePop_Yes);
  }

  return new_files;
}

void pkg_node::fetchFiles(bool distribute)
{
  char dev[80];
  char dir[80];
  char file[80];
  char type[80];
  int version;
  char pack_fname[200];
  char fname[200];

  // Get temporary directory
  sprintf(m_tmpdir, "/tmp/pwrpkg%06u", pkg_random());
  sprintf(m_blddir, "%s/pkg_build", m_tmpdir);

  // Add volumes to pattern
  for (int i = 0; i < (int)m_volumelist.size(); i++) {
    if (!m_volumelist[i].m_isSystem) {
      pkg_pattern vol(m_volumelist[i].m_filename, "$pwrp_load/", 'E');
      push_back(vol);
    }
  }

  for (int i = 0; i < (int)m_pattern.size(); i++)
    m_pattern[i].fetchFiles();

  // Put all files in a single list
  m_filelist.clear();
  for (int i = 0; i < (int)m_pattern.size(); i++) {
    for (int j = 0; j < (int)m_pattern[i].m_filelist.size(); j++) {
      try {
        pkg_file f = m_pattern[i].m_filelist[j];

        dcli_parse_filename(f.m_source, dev, dir, file, type, &version);
        strcpy(f.m_arname, file);
        strcat(f.m_arname, type);

        // Check that this name is unique
        for (;;) {
          bool new_name = false;
          for (int k = 0; k < (int)m_filelist.size(); k++) {
            if (streq(m_filelist[k].m_arname, f.m_arname)) {
              strcat(f.m_arname, "x");
              new_name = true;
              break;
            }
          }
          if (!new_name)
            break;
        }

        m_filelist.push_back(f);
      } catch (wb_error& e) {
        MsgWindow::message('W', e.what().c_str(), msgw_ePop_No);
        m_warnings++;
      }
    }
  }

  if (m_errors) {
    char msg[200];
    sprintf(msg, "Distribute errors node %s: %d errors, %d warnings", m_name,
        m_errors, m_warnings);
    MsgWindow::message('E', msg, msgw_ePop_Yes);
    throw wb_error_str(msg);
  } else if (m_warnings) {
    char msg[200];
    sprintf(
        msg, "Distribute warnings node %s: %d warnings", m_name, m_warnings);
    MsgWindow::message('W', msg, msgw_ePop_Yes);
  }

  // Read and increment package version
  sprintf(fname, "$pwrp_load/pkg_v_%s.dat", m_name);
  dcli_translate_filename(fname, fname);
  std::ifstream ifv(fname);
  if (ifv) {
    ifv >> version;
    ifv.close();
    version++;
  } else
    version = 1;

  std::ofstream ofv(fname);
  ofv << version;
  ofv.close();

  // Create a script that copies files to build directory
  char pkg_name[110];
  sprintf(pkg_name, pwr_cNamePkg, m_name, version);

  sprintf(pack_fname, "$pwrp_tmp/pkg_pack_%s.sh", m_name);
  dcli_translate_filename(pack_fname, pack_fname);
  std::ofstream of(pack_fname);

  of << "if [ -e " << m_tmpdir << " ]; then\n"
     << "  rm -r " << m_tmpdir << '\n'
     << "fi\n"
     << "mkdir " << m_tmpdir << '\n'
     << "mkdir " << m_blddir << '\n';

  for (int i = 0; i < (int)m_filelist.size(); i++)
    of << "cp --preserve=timestamps " << m_filelist[i].m_source << " "
       << m_blddir << "/" << m_filelist[i].m_arname << '\n';

  of << "cp $pwrp_tmp/pkg_unpack_" << m_name << ".sh " << m_tmpdir
     << "/pkg_unpack.sh\n"
     << "cp $pwrp_tmp/pwr_pkg_" << m_name << ".dat " << m_tmpdir
     << "/pwr_pkg.dat\n"
     << "cd " << m_tmpdir << '\n'
     << "tar --atime-preserve -czf $pwrp_load/" << pkg_name
     << " pwr_pkg.dat pkg_unpack.sh pkg_build\n"
     << "rm -r " << m_tmpdir << '\n';

  of.close();

  // Create a script that unpackes the archive and moves files to the target
  // directories
  sprintf(fname, "$pwrp_tmp/pkg_unpack_%s.sh", m_name);
  dcli_translate_filename(fname, fname);
  std::ofstream ofu(fname);
  if (!ofu)
    throw wb_error_str(std::string("Unable to open file \"") + fname + "\"");

  ofu << "dir=$HOME\n"
      << "cd /tmp\n"
      << "if [ \"$1\" == \"\" ]; then\n"
      << "  pkg_name=\"$dir/" << pkg_name << "\"\n"
      << "else\n"
      << "  pkg_name=$1\n"
      << "fi\n"
      << "echo \"-- Unpack package " << pkg_name << "\"\n"
      << "tar -xzf $pkg_name\n"
      << "echo \"-- Move files to target directories\"\n"
      << "if [ ! -e $dir/.ssh ]; then\n"
      << "  mkdir $dir/.ssh\n"
      << "fi\n";

  for (int i = 0; i < (int)m_filelist.size(); i++)
    ofu << "mv /tmp/pkg_build/" << m_filelist[i].m_arname << " "
        << m_filelist[i].m_target << '\n';

  ofu << "mv pwr_pkg.dat $pwrp_load\n"
      << "rm -r /tmp/pkg_build\n";

  // Change owner to root of plc, to make modification of thread prio possible
  ofu << "nname=`eval uname -n`\n"
      << "if [ \"$USER\" == \"root\" ]; then\n"
      << "  chown root $pwrp_exe/plc_$nname_*\n"
      << "  chmod g+w $pwrp_exe/plc_$nname_*\n"
      << "  chmod u+s $pwrp_exe/plc_$nname_*\n"
      << "else\n"
      << "  tst=`eval sudo -l | grep \" ALL\"`\n"
      << "  if [ \"$tst\" != \"\" ]; then\n"
      << "    sudo chown root $pwrp_exe/plc_$nname_*\n"
      << "    sudo chmod g+w $pwrp_exe/plc_$nname_*\n"
      << "    sudo chmod u+s $pwrp_exe/plc_$nname_*\n"
      << "  fi\n"
      << "fi\n";

  // Group should not have write access to .rhosts file
  ofu << "if [ -e $dir/.rhosts ]; then\n"
      << "  if [ \"$USER\" == \"root\" ]; then\n"
      << "    chown " << m_user << " $dir/.rhosts\n"
      << "    chmod g-w $dir/.rhosts\n"
      << "  else\n"
      << "    if [ \"$tst\" != \"\" ]; then\n"
      << "      sudo chown " << m_user << " $dir/.rhosts\n"
      << "      sudo chmod g-w $dir/.rhosts\n"
      << "    fi\n"
      << "  fi\n"
      << "fi\n"
      << "if [ -e $dir/.ssh/authorized_keys ]; then\n"
      << "  if [ \"$USER\" == \"root\" ]; then\n"
      << "    chown " << m_user << " $dir/.ssh/authorized_keys\n"
      << "    chmod g-w $dir/.ssh/authorized_keys\n"
      << "  else\n"
      << "    if [ \"$tst\" != \"\" ]; then\n"
      << "      sudo chown " << m_user << " $dir/.ssh/authorized_keys\n"
      << "      sudo chmod g-w $dir/.ssh/authorized_keys\n"
      << "    fi\n"
      << "  fi\n"
      << "fi\n";

  ofu.close();

  // Create a data file with description and all installed files
  sprintf(fname, "$pwrp_tmp/pwr_pkg_%s.dat", m_name);
  dcli_translate_filename(fname, fname);
  std::ofstream ofd(fname);
  if (!ofd)
    throw wb_error_str(std::string("Unable to open file \"") + fname + "\"");

  pwr_tTime time;
  char time_str[32];
  time_GetTime(&time);
  time_AtoAscii(&time, time_eFormat_DateAndTime, time_str, sizeof(time_str));

  ofd << "%Package: \n"
      << pkg_name << '\n'
      << "%Brief:\n"
      << "ProviewR package " << m_name << " Version " << version << " "
      << time_str << '\n'
      << "%Description:\n"
      << "ProviewR package:	" << pkg_name << '\n'
      << "Node:		" << m_name << '\n'
      << "Version:		" << version << '\n'
      << "Created:		" << time_str << '\n'
      << "%Files:\n";

  for (int i = 0; i < (int)m_filelist.size(); i++) {
    char timestr[32];
    time_AtoAscii(&m_filelist[i].m_date, time_eFormat_DateAndTime, timestr,
        sizeof(timestr));

    ofd << m_filelist[i].m_target << " " << timestr << '\n';
  }
  ofd << "%End:\n";
  ofd.close();

  // Execute the pack file
  char cmd[2 + sizeof(pack_fname) + 1];
  sprintf(cmd, ". %s", pack_fname);
  system(cmd);

  wb_log::log(wlog_eCategory_CreatePackage, m_name, pkg_name);

  if (distribute) {
    // Copy the package
    copyPackage(pkg_name);
  }

  char msg[200];
  sprintf(msg, "Distribute package for node %s", m_name);
  MsgWindow::message('I', msg, msgw_ePop_No);
}

void pkg_node::copyPackage(char* pkg_name)
{
  char pack_fname[200];
  char bootnodes[10][80];
  int bootnode_cnt;

  if (!streq(m_bootnode, "-")) {
    bootnode_cnt = dcli_parse(m_bootnode, ",", "", (char*)bootnodes,
        sizeof(bootnodes) / sizeof(bootnodes[0]), sizeof(bootnodes[0]), 0);
  } else {
    // No bootnodes, copy to the node itself
    strcpy(bootnodes[0], m_name);
    bootnode_cnt = 1;
  }

  for (int i = 0; i < bootnode_cnt; i++) {
    sprintf(pack_fname, "$pwrp_tmp/pkg_pack_%s.sh", m_name);
    dcli_translate_filename(pack_fname, pack_fname);
    std::ofstream of(pack_fname);
    if (m_dstatus & lfu_mDistrOpt_RSH) {
      // Use ftp and rsh
      of << "cd $pwrp_load\n"
         << "ftp -vin " << bootnodes[i] << " << EOF &>$pwrp_tmp/ftp_"
         << bootnodes[i] << ".log\n"
         << "user " << m_user << " pwrp\n"
         << "binary\n"
         << "put " << pkg_name << '\n'
         << "quit\n"
         << "EOF\n"
         << "rsh -l " << m_user << " " << bootnodes[i]
         << " \\$pwr_exe/pwr_pkg.sh -i " << pkg_name << '\n';
    } else {
      // Use scp and SSH
      of << "cd $pwrp_load\n"
         << "scp " << pkg_name << " " << m_user << "@" << bootnodes[i] << ":"
         << '\n'
         << "ssh " << m_user << "@" << bootnodes[i]
         << " \\$pwr_exe/pwr_pkg.sh -i " << pkg_name << '\n';
    }
    of.close();

    // Execute the pack file
    char cmd[2 + sizeof(pack_fname) + 1];
    sprintf(cmd, ". %s", pack_fname);
    system(cmd);

    wb_log::log(wlog_eCategory_CopyPackage, m_name, pkg_name);
  }
}

void wb_pkg::copyPackage(char* pkg_name)
{
  char node_name[80];
  char* s;

  // Extract node name from package name
  strcpy(node_name, &pkg_name[9]);
  if ((s = strrchr(node_name, '_')))
    *s = 0;

  // Find the node and get the bootnode(s)
  wb_pkg pkg(node_name, false, true);
  pkg_node n = pkg.getNode(node_name);
  n.copyPackage(pkg_name);
}

pkg_pattern::pkg_pattern(const char* source, const char* target, char severity)
    : m_node(0), m_severity(severity)
{
  strcpy(m_source, source);
  strcpy(m_target, target);
}

pkg_pattern::pkg_pattern(const char* source) : m_node(0), m_severity('W')
{
  strcpy(m_source, source);
  strcpy(m_target, "");
}

pkg_pattern::pkg_pattern(const pkg_pattern& x)
    : m_filelist(x.m_filelist), m_node(x.m_node), m_severity(x.m_severity)
{
  strcpy(m_source, x.m_source);
  strcpy(m_target, x.m_target);
}

void pkg_pattern::fetchFiles()
{
  char found_file[200];
  int sts;
  char dev[80];
  char dir[80];
  char file[80];
  char type[80];
  int version;
  char file_target[80];

  if (strchr(m_source, ':')) {
    // Source is a search path separated by colon
    char source[10][120];
    int num;

    num = dcli_parse(m_source, ":", "", (char*)source,
        sizeof(source) / sizeof(source[0]), sizeof(source[0]), 0);

    for (int i = 0; i < num; i++) {
      sts = dcli_search_file(source[i], found_file, DCLI_DIR_SEARCH_INIT);
      dcli_search_file(source[i], found_file, DCLI_DIR_SEARCH_END);
      if (ODD(sts)) {
        if (hasTarget()) {
          dcli_parse_filename(m_target, dev, dir, file, type, &version);
          strcpy(file_target, dev);
          strcpy(file_target, dir);
          if (streq(file, "") && streq(type, ""))
            dcli_parse_filename(found_file, dev, dir, file, type, &version);
          strcat(file_target, file);
          strcat(file_target, type);
        } else {
          dcli_parse_filename(source[0], dev, dir, file, type, &version);
          strcpy(file_target, dev);
          strcat(file_target, dir);
          dcli_parse_filename(found_file, dev, dir, file, type, &version);
          strcat(file_target, file);
          strcat(file_target, type);
        }
        try {
          pkg_file file(found_file, file_target);
          m_filelist.push_back(file);
        } catch (wb_error& e) {
          MsgWindow::message('W', e.what().c_str(), msgw_ePop_Yes);
        }
        break;
      }
    }
  } else {
    sts = dcli_search_file(m_source, found_file, DCLI_DIR_SEARCH_INIT);
    while (ODD(sts)) {
      if (hasTarget()) {
        dcli_parse_filename(m_target, dev, dir, file, type, &version);
        strcpy(file_target, dev);
        strcpy(file_target, dir);
        if (streq(file, "") && streq(type, ""))
          dcli_parse_filename(found_file, dev, dir, file, type, &version);
        strcat(file_target, file);
        strcat(file_target, type);
      } else {
        dcli_parse_filename(m_source, dev, dir, file, type, &version);
        strcpy(file_target, dev);
        strcat(file_target, dir);
        dcli_parse_filename(found_file, dev, dir, file, type, &version);
        strcat(file_target, file);
        strcat(file_target, type);
      }
      try {
        pkg_file file(found_file, file_target);
        m_filelist.push_back(file);
      } catch (wb_error& e) {
        MsgWindow::message('W', e.what().c_str(), msgw_ePop_Yes);
      }

      sts = dcli_search_file(m_source, found_file, DCLI_DIR_SEARCH_NEXT);
    }
    dcli_search_file(m_source, found_file, DCLI_DIR_SEARCH_END);
  }
  if (m_filelist.size() == 0 && m_severity != 'S') {
    char msg[15 + sizeof(m_source) + 1];
    sprintf(msg, "No file found: %s", m_source);
    MsgWindow::message(m_severity, msg, msgw_ePop_No);

    if (m_node) {
      if (m_severity == 'E')
        m_node->incrErrors();
      else
        m_node->incrWarnings();
    }
  }
}

pkg_volume::pkg_volume(char* name, char* filename, pwr_tVid vid, pwr_tTime time)
    : m_vid(vid), m_time(time), m_isSystem(false)
{
  strcpy(m_name, name);
  strcpy(m_filename, filename);
  if (str_StartsWith(m_filename, "$pwr_load/"))
    m_isSystem = true;
}

pkg_depnode::pkg_depnode(char* nodename, char* project)
{
  strncpy(m_nodename, nodename, sizeof(m_nodename));
  strncpy(m_project, project, sizeof(m_project));
}

pkg_file::pkg_file(char* source, char* target)
{
  struct stat info;

  int sts = stat(source, &info);
  if (sts == -1) {
    char msg[256];
    sprintf(msg, "Source file doesn't exist: %s", source);
    throw wb_error_str(msg);
  }

  m_date.tv_sec = info.st_ctime;
  m_date.tv_nsec = 0;
  strcpy(m_source, source);
  strcpy(m_target, target);
}
