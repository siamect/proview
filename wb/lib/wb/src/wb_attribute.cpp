/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <string.h>

#include "wb_adrep.h"
#include "wb_attribute.h"
#include "wb_bdef.h"
#include "wb_bdrep.h"
#include "wb_cdrep.h"
#include "wb_merep.h"

wb_attribute::wb_attribute()
    : wb_status(LDH__NOSUCHATTR), m_orep(0), m_adrep(0), m_size(0), m_offset(0),
      m_idx(0), m_tid(0), m_elements(0), m_is_elem(0), m_type(pwr_eType_),
      m_flags(0), m_bix(pwr_eBix__), m_body(0), m_shadowed(false)
{
}

wb_attribute::wb_attribute(const wb_attribute& x)
    : wb_status(x.m_sts), m_orep(x.m_orep), m_adrep(x.m_adrep),
      m_size(x.m_size), m_offset(x.m_offset), m_idx(x.m_idx), m_tid(x.m_tid),
      m_original_tid(x.m_original_tid), m_elements(x.m_elements), m_is_elem(0),
      m_type(x.m_type), m_flags(x.m_flags), m_bix(x.m_bix), m_body(0),
      m_shadowed(x.m_shadowed)
{
  if (m_orep)
    m_orep->ref();
  if (m_adrep)
    m_adrep->ref();
}

wb_attribute::wb_attribute(pwr_tStatus sts, wb_orep* orep)
    : wb_status(sts), m_orep(orep), m_adrep(0), m_size(0), m_offset(0),
      m_idx(0), m_tid(0), m_elements(1), m_is_elem(0), m_type(pwr_eType_),
      m_flags(0), m_bix(pwr_eBix__), m_body(0), m_shadowed(false)
{
  if (orep == 0)
    m_sts = LDH__NOSUCHATTR;
  else {
    m_orep->ref();

    wb_cdef cdef(*orep);
    if (EVEN(cdef.sts())) {
      m_sts = cdef.sts();
      return;
    }
    wb_bdef bdef(((wb_cdrep*)cdef)->bdrep(&m_sts, pwr_eBix_rt));
    if (EVEN(bdef.sts())) {
      wb_bdef bdefdev(((wb_cdrep*)cdef)->bdrep(&m_sts, pwr_eBix_dev));
      if (EVEN(bdefdev.sts())) {
        m_sts = bdefdev.sts();
        return;
      }
      bdef = bdefdev;
    }

    m_size = bdef.size();
    m_bix = bdef.bix();
    m_tid = m_original_tid = orep->cid();
  }
}

wb_attribute::wb_attribute(
    pwr_tStatus sts, wb_orep* orep, wb_adrep* adrep, int idx)
    : wb_status(sts), m_orep(orep), m_adrep(adrep), m_size(0), m_offset(0),
      m_idx(0), m_tid(0), m_elements(1), m_is_elem(0), m_type(pwr_eType_),
      m_flags(0), m_bix(pwr_eBix__), m_body(0), m_shadowed(false)
{
  if (orep == 0)
    m_sts = LDH__NOSUCHATTR;
  else {
    m_orep->ref();

    if (m_adrep) {
      m_adrep->ref();
      m_size = m_adrep->size();
      m_offset = m_adrep->offset();
      m_tid = m_original_tid = m_adrep->tid();
      m_elements = m_adrep->nElement();
      m_type = m_adrep->type();
      m_flags = m_adrep->flags();
      m_bix = m_adrep->bix();

      if (m_flags & PWR_MASK_ARRAY) {
        if (idx >= m_elements)
          throw wb_error_str("wb_attribute() subscript out of range");
        m_idx = idx;
        if (idx != -1) { // element
          m_size = m_adrep->size() / m_adrep->nElement();
          if (m_flags & PWR_MASK_POINTER)
            m_offset = m_adrep->offset() + m_idx * sizeof(pwr_tUInt64);
          else
            m_offset = m_adrep->offset() + m_idx * m_size;
          m_elements = 1;
          m_is_elem = 1;
        }
      } else
        m_idx = 0;

      if (m_flags & PWR_MASK_CASTATTR) {
        pwr_tCastId castid;

        castId(&castid);
        if (castid != pwr_cNCastId)
          m_tid = castid;
      }
    } else {
      // m_size == get rtbody size... Fix
      wb_cdef cdef(*orep);
      if (EVEN(cdef.sts())) {
        char msg[256];
        m_sts = cdef.sts();
        sprintf(msg, "Can't get cdef for orep: %s", orep->name());
        throw wb_error_str(m_sts, msg);
      }
      wb_bdef bdef(((wb_cdrep*)cdef)->bdrep(&m_sts, pwr_eBix_rt));
      if (EVEN(bdef.sts())) {
        char msg[256];
        m_sts = bdef.sts();
        sprintf(msg, "Can't get bdef for orep: %s", orep->name());
        throw wb_error_str(m_sts, msg);
      }

      m_size = bdef.size();
      m_bix = bdef.bix();
    }
  }
}

wb_attribute::wb_attribute(pwr_tStatus sts, wb_orep* orep, const char* bname)
    : wb_status(sts), m_orep(orep), m_adrep(0), m_size(0), m_offset(0),
      m_idx(0), m_tid(0), m_elements(1), m_is_elem(0), m_type(pwr_eType_),
      m_flags(0), m_bix(pwr_eBix__), m_body(0), m_shadowed(false)
{
  if (orep == 0)
    m_sts = LDH__NOSUCHATTR;
  else {
    m_orep->ref();

    wb_cdrep* cd = m_orep->vrep()->merep()->cdrep(&m_sts, m_orep->cid());
    if (oddSts()) {
      wb_bdrep* bd = cd->bdrep(&m_sts, bname);
      if (oddSts()) {
        m_size = bd->size();
        m_bix = bd->bix();
        delete bd;
      }
      delete cd;
    }
  }
}

wb_attribute::wb_attribute(
    pwr_tStatus sts, wb_orep* orep, const char* bname, const char* aname)
    : wb_status(sts), m_orep(orep), m_adrep(0), m_size(0), m_offset(0),
      m_idx(0), m_tid(0), m_elements(1), m_is_elem(0), m_type(pwr_eType_),
      m_flags(0), m_bix(pwr_eBix__), m_body(0), m_shadowed(false)
{
  if (orep == 0)
    m_sts = LDH__NOSUCHATTR;
  else {
    m_orep->ref();

    wb_attrname n = wb_attrname(aname);
    wb_bdrep* bd = 0;
    wb_cdrep* cd = m_orep->vrep()->merep()->cdrep(&m_sts, m_orep->cid());
    if (oddSts()) {
      if (bname) {
        bd = cd->bdrep(&m_sts, bname);
        if (oddSts()) {
          m_adrep = bd->adrep(&m_sts, n.attributesAllTrue());
          m_bix = bd->bix();
        }
      } else {
        m_adrep = cd->adrep(&m_sts, n.attributesAllTrue());
        m_bix = pwr_eBix_rt;
      }
      if (oddSts()) {
        m_adrep->ref();

        m_size = m_adrep->size();
        m_offset = m_adrep->offset();
        m_tid = m_original_tid = m_adrep->tid();
        m_elements = m_adrep->nElement();
        m_flags = m_adrep->flags();
        m_type = m_adrep->type();

        if (m_flags & PWR_MASK_CASTATTR) {
          pwr_tCastId castid;

          castId(&castid);
          if (castid != pwr_cNCastId)
            m_tid = castid;
        }
      } else
        m_adrep = 0;

      delete cd;
      if (bd)
        delete bd;
    }
  }
}

wb_attribute::wb_attribute(
    const wb_attribute& pa, int pidx, const char* aname, int aidx)
    : wb_status(LDH__NOSUCHATTR), m_orep(0), m_adrep(0), m_size(0), m_offset(0),
      m_tid(0), m_elements(1), m_is_elem(0), m_type(pwr_eType_), m_flags(0),
      m_bix(pwr_eBix__), m_body(0), m_shadowed(false)
{
  pwr_tCid cid;
  wb_attrname n;
  pwr_tAName attrname;

  if (!cdh_tidIsCid(pa.tid()) || pa.m_orep == 0)
    return;

  if (pidx == -1)
    pidx = pa.m_idx;

  if (pa.m_flags & PWR_MASK_ARRAY && !pa.m_is_elem
      && (pidx < 0 || pidx >= pa.m_elements))
    throw wb_error_str("Invalid subscript");

  strcpy(attrname, pa.attrName());
  if (pa.m_flags & PWR_MASK_ARRAY) {
    if (attrname[strlen(attrname) - 1] == ']') {
      // Replace the index
      char* s = strrchr(attrname, '[');
      if (s)
        sprintf(s, "[%d]", pidx);
    } else
      // Add index
      sprintf(&attrname[strlen(attrname)], "[%d]", pidx);
  }
  strcat(attrname, ".");
  if (aname != 0)
    strcat(attrname, aname);
  else {
    // First attribute
    if (pa.isClass())
      cid = pa.subClass();
    else
      cid = pa.tid();
    wb_cdrep* cd = pa.m_orep->vrep()->merep()->cdrep(&m_sts, cid);
    if (evenSts())
      return;

    wb_bdrep* bd = cd->bdrep(&m_sts, pwr_eBix_sys);
    if (evenSts()) {
      delete cd;
      return;
    }

    wb_adrep* adrep = bd->adrep(&m_sts);
    if (evenSts()) {
      delete cd;
      delete bd;
      return;
    }

    strcat(attrname, adrep->name());
    delete adrep;
    delete bd;
    delete cd;
  }

  n = attrname;

  cid = pa.cid();

  wb_cdrep* cd = pa.m_orep->vrep()->merep()->cdrep(&m_sts, cid);
  if (evenSts())
    return;

  wb_bdrep* bd = cd->bdrep(&m_sts, pwr_eBix_sys);
  if (evenSts()) {
    // Try devbody
    bd = cd->bdrep(&m_sts, pwr_eBix_dev);
    if (evenSts()) {
      delete cd;
      return;
    }
  }

  m_adrep = bd->adrep(&m_sts, n.attributesAllTrue());
  if (evenSts()) {
    // Try devbody
    bd = cd->bdrep(&m_sts, pwr_eBix_dev);
    if (evenSts()) {
      delete cd;
      return;
    }

    m_adrep = bd->adrep(&m_sts, n.attributesAllTrue());
    if (evenSts()) {
      delete cd;
      delete bd;
      return;
    }
  }
  m_adrep->ref();
  m_size = m_adrep->size();
  m_offset = m_adrep->offset();
  m_tid = m_original_tid = m_adrep->tid();
  m_elements = m_adrep->nElement();
  m_flags = m_adrep->flags();
  m_type = m_adrep->type();
  m_idx = aidx;

  m_orep = pa.m_orep;
  m_orep->ref();
  m_bix = bd->bix();

  if (m_flags & PWR_MASK_CASTATTR) {
    pwr_tCastId castid;

    castId(&castid);
    if (castid != pwr_cNCastId)
      m_tid = castid;
  }

  delete bd;
  delete cd;
}

wb_attribute::~wb_attribute()
{
  if (m_orep) {
    m_orep->unref();
    m_orep = 0;
  }

  if (m_adrep) {
    m_adrep->unref();
    m_adrep = 0;
  }

  if (m_body) {
    // printf("a: %8.8x free\n", m_body);
    free(m_body);
  }
}

bool wb_attribute::operator==(const wb_attribute& x) const
{
  if (m_orep->oid().vid == x.m_orep->oid().vid
      && m_orep->oid().oix == x.m_orep->oid().oix && m_size == x.m_size
      && m_offset == x.m_offset)
    return true;
  return false;
}

wb_attribute& wb_attribute::operator=(const wb_attribute& x)
{
  if (x.m_orep)
    x.m_orep->ref();
  if (m_orep)
    m_orep->unref();
  if (x.m_adrep)
    x.m_adrep->ref();
  if (m_adrep)
    m_adrep->unref();
  m_orep = x.m_orep;
  m_adrep = x.m_adrep;
  m_sts = x.m_sts;
  m_size = x.m_size;
  m_offset = x.m_offset;
  m_idx = x.m_idx;
  m_tid = x.m_tid;
  m_original_tid = x.m_original_tid;
  m_elements = x.m_elements;
  m_is_elem = x.m_is_elem;
  m_type = x.m_type;
  m_flags = x.m_flags;
  m_bix = x.m_bix;
  if (m_body) {
    // printf("a: %8.8x free ==\n", m_body);
    free(m_body);
  }
  m_body = 0;

  return *this;
}

void wb_attribute::check() const
{
  if (evenSts())
    throw wb_error(m_sts);
}

//
// Return object identifier of attribute.
//
pwr_sAttrRef wb_attribute::aref() const
{
  check();

  pwr_sAttrRef ar;
  aref(&ar);

  return ar;
}

pwr_sAttrRef* wb_attribute::aref(pwr_sAttrRef* arp) const
{
  check();

  memset(arp, 0, sizeof(*arp));

  arp->Objid = m_orep->oid();
  arp->Offset = m_offset;
  arp->Size = m_size;
  arp->Body = m_orep->cid() | m_bix;

  if (m_flags & PWR_MASK_POINTER)
    arp->Flags.b.Indirect = 1;

  if (m_flags & PWR_MASK_ARRAY && m_idx == -1)
    arp->Flags.b.Array = 1;

  if (m_tid == m_orep->cid()) {
    arp->Flags.b.Object = 1;

    arp->Body = m_tid | m_bix;
  } else if (cdh_tidIsCid(m_tid))
    arp->Flags.b.ObjectAttr = 1;

  if (m_shadowed)
    arp->Flags.b.Shadowed = 1;

  if (m_flags & PWR_MASK_CASTATTR)
    arp->Flags.b.CastAttr = 1;
  if (m_flags & PWR_MASK_DISABLEATTR)
    arp->Flags.b.DisableAttr = 1;

  return arp;
}

pwr_tOid wb_attribute::aoid() const
{
  check();
  return m_orep->oid();
}

size_t wb_attribute::size() const
{
  check();
  return m_size;
}

size_t wb_attribute::offset() const
{
  check();
  return m_offset;
}

pwr_eType wb_attribute::type() const
{
  check();
  return m_type;
}

pwr_tTid wb_attribute::tid() const
{
  check();
  return m_tid;
}

pwr_tTid wb_attribute::originalTid() const
{
  check();
  return m_original_tid;
}

int wb_attribute::nElement() const
{
  check();
  return m_elements;
}

int wb_attribute::isElem() const
{
  check();
  return m_is_elem;
}

int wb_attribute::index() const
{
  if (m_adrep)
    return m_adrep->index();
  return 0;
}

int wb_attribute::flags() const
{
  check();
  return m_flags;
}

pwr_tAix wb_attribute::aix() const
{
  throw wb_error_str("wb_attribute::aix() NYI");
}

pwr_tCid wb_attribute::cid() const
{
  check();
  return m_orep->cid();
}

pwr_eBix wb_attribute::bix() const
{
  check();

  // if (!m_adrep || m_flags & PWR_MASK_SUBCLASS)
  return m_bix;

  // return m_adrep->bix();
}

pwr_tOid wb_attribute::boid() const
{
  throw wb_error_str("wb_attribute::boid() NYI");
}

pwr_tCid wb_attribute::subClass() const
{
  if (m_adrep)
    return m_adrep->subClass();
  return 0;
}

bool wb_attribute::checkXref() const
{
  throw wb_error_str("wb_attribute::checkXref() NYI");
}

pwr_sAttrXRef* wb_attribute::xref() const
{
  throw wb_error_str("wb_attribute::xref() NYI");
}

pwr_sObjXRef* wb_attribute::oxref() const
{
  throw wb_error_str("wb_attribute::oxref() NYI");
}

void* wb_attribute::value(void* p)
{
  pwr_eBix bix;
  pwr_tStatus sts;
  check();

  if (!p) {
    if (!m_body && (m_orep->vrep()->type() == ldh_eVolRep_Db
                       || m_orep->vrep()->type() == ldh_eVolRep_Dbms
                       || m_orep->vrep()->type() == ldh_eVolRep_Ced)) {
      m_body = (void*)calloc(1, m_size);
      // printf("a: %8.8x alloc %d\n", m_body, m_size);
    }
    p = m_body;
  }

  if (m_adrep == 0) {
    if (m_bix == pwr_eBix_dev)
      return m_orep->vrep()->readBody(&sts, m_orep, pwr_eBix_dev, p);
    else
      return m_orep->vrep()->readBody(&sts, m_orep, pwr_eBix_rt, p);
  }

  // if (m_flags & PWR_MASK_SUBCLASS)
  bix = m_bix;
  // else
  //  bix = m_adrep->bix();

  return m_orep->vrep()->readAttribute(&sts, m_orep, bix, m_offset, m_size, p);
}

void* wb_attribute::value(void* vp, size_t size, pwr_tStatus* sts)
{
  return 0;
}

void wb_attribute::castId(pwr_tCastId* castid)
{
  size_t offset;
  if (m_flags & PWR_MASK_DISABLEATTR)
    offset = m_offset - 2 * pwr_cAlignLW;
  else
    offset = m_offset - pwr_cAlignLW;
  m_orep->vrep()->readAttribute(
      &m_sts, m_orep, m_bix, offset, sizeof(pwr_tCastId), castid);
}

pwr_tDisableAttr wb_attribute::disabled()
{
  pwr_tDisableAttr disabled;

  if (m_flags & PWR_MASK_DISABLEATTR) {
    m_orep->vrep()->readAttribute(&m_sts, m_orep, m_bix,
        m_offset - pwr_cAlignLW, sizeof(pwr_tDisableAttr), &disabled);
  } else
    disabled = 0;

  return disabled;
}

std::string wb_attribute::toString() const
{
  throw wb_error_str("wb_attribute::toString() NYI");
}

pwr_tStatus wb_attribute::fromString(std::string) const
{
  throw wb_error_str("wb_attribute::fromString() NYI");
}

pwr_tStatus wb_attribute::fromString(char*) const
{
  throw wb_error_str("wb_attribute::fromString() NYI");
}

wb_attribute wb_attribute::after() const
{
  pwr_tStatus sts;

  check();
  if (m_adrep == 0)
    return wb_attribute();

  wb_adrep* adrep = m_adrep->next(&sts);
  if (EVEN(sts))
    return wb_attribute();

  wb_attribute a(LDH__SUCCESS, m_orep, adrep);
  a.m_bix = m_bix;

  return a;
}

wb_attribute wb_attribute::before() const
{
  pwr_tStatus sts;

  check();
  if (m_adrep == 0)
    return wb_attribute();

  wb_adrep* adrep = m_adrep->prev(&sts);
  if (EVEN(sts))
    return wb_attribute();

  wb_attribute a(LDH__SUCCESS, m_orep, adrep);
  a.m_bix = m_bix;

  return a;
}

wb_attribute wb_attribute::first(int idx) const
{
  if (!cdh_tidIsCid(m_tid))
    return wb_attribute();

  return wb_attribute(*this, idx, NULL);
}

wb_attribute wb_attribute::child(const char* name, int idx) const
{
  if (!cdh_tidIsCid(m_tid))
    return wb_attribute();

  return wb_attribute(*this, idx, name);
}

const char* wb_attribute::name() const
{
  check();

  return m_orep->name();
}

const char* wb_attribute::attrName() const
{
  check();

  static pwr_tAName str;

  if (m_adrep) {
    strcpy(str, m_adrep->subName());
    if (m_flags & PWR_MASK_ARRAY && m_idx != -1)
      sprintf(&str[strlen(str)], "[%d]", m_idx);
  } else
    strcpy(str, "");

  return str;
}

wb_name wb_attribute::longName() const
{
  check();

  if (!m_adrep)
    return m_orep->longName();

  char str[512];
  int len;

  len = sprintf(str, "%s.%s", m_orep->longName().c_str(), m_adrep->subName());
  if (m_flags & PWR_MASK_ARRAY && m_idx != -1)
    sprintf(&str[len], "[%d]", m_idx);

  wb_name n(str);
  if (m_shadowed)
    n.setShadowed(true);
  return n;
}

void wb_attribute::name(const char* name)
{
}

void wb_attribute::name(wb_name* name)
{
}

pwr_tCid wb_attribute::adefCid()
{
  if (m_adrep)
    return m_adrep->cid();
  else
    return 0;
}
