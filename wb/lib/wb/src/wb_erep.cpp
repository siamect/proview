/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <iostream>

#include "co_cnf.h"
#include "co_string.h"

#include "cow_msgwindow.h"

#include "wb_adrep.h"
#include "wb_cdrep.h"
#include "wb_dblock.h"
#include "wb_dbms.h"
#include "wb_lfu.h"
#include "wb_merep.h"
#include "wb_tdrep.h"
#include "wb_utl_api.h"
#include "wb_vrepwbl.h"
#include "wb_vrepdb.h"
#include "wb_vrepdbms.h"
#include "wb_vrepced.h"
#include "wb_vrepmem.h"
#include "wb_vrepref.h"
#include "wb_vrepext.h"

extern "C" {
#include "co_dcli.h"
#include "pwr_names.h"
}

pwr_dImport pwr_BindClasses(System);
pwr_dImport pwr_BindClasses(Base);

typedef enum { eDbType_db, eDbType_dbms, eDbType_wbl, eDbType_none } eDbType;

wb_volcheck::wb_volcheck(
    char* vname, char* filename, pwr_tVid vid, pwr_tTime time)
    : m_vid(vid), m_time(time)
{
  strncpy(m_vname, vname, sizeof(m_vname));
  strncpy(m_filename, filename, sizeof(m_filename));
}

wb_erep::wb_erep(unsigned int options)
    : m_nRef(0), m_dir_cnt(0), m_volatile_idx(0), m_buffer_max(10),
      m_ref_merep_occupied(false), m_options(options)
{
  m_merep = new wb_merep(0);

  atexit(at_exit);
}

wb_erep::~wb_erep()
{
  delete m_merep;
}

void wb_erep::at_exit()
{
  wb_dblock::dbunlock_all();
}

void wb_erep::unref()
{
  if (--m_nRef == 0)
    delete this;
}

wb_erep* wb_erep::ref()
{
  m_nRef++;
  return this;
}

// Get first volume
wb_vrep* wb_erep::volume(pwr_tStatus* sts)
{
  vrep_iterator it = m_vrepdb.begin();
  if (it == m_vrepdb.end()) {
    it = m_vrepdbs.begin();
    if (it == m_vrepdbs.end()) {
      *sts = LDH__NOSUCHVOL;
      return 0;
    }
  }
  *sts = LDH__SUCCESS;
  return it->second;
}

wb_vrep* wb_erep::volume(pwr_tStatus* sts, pwr_tVid vid)
{
  vrep_iterator it = m_vrepdb.find(vid);
  if (it != m_vrepdb.end()) {
    *sts = LDH__SUCCESS;
    return it->second;
  }

  it = m_vrepdbs.find(vid);
  if (it != m_vrepdbs.end()) {
    *sts = LDH__SUCCESS;
    return it->second;
  }

  it = m_vrepextern.find(vid);
  if (it != m_vrepextern.end()) {
    *sts = LDH__SUCCESS;
    return it->second;
  }

  for (buffer_iterator itb = m_vrepbuffer.begin(); itb != m_vrepbuffer.end();
       itb++) {
    if ((*itb)->vid() == vid) {
      *sts = LDH__SUCCESS;
      return *itb;
    }
  }

  *sts = LDH__NOSUCHVOL;
  return 0;
}

wb_vrep* wb_erep::volume(pwr_tStatus* sts, const char* name)
{
  vrep_iterator it;
  for (it = m_vrepdb.begin(); it != m_vrepdb.end(); it++) {
    if (str_NoCaseStrcmp(it->second->name(), name) == 0) {
      *sts = LDH__SUCCESS;
      return it->second;
    }
  }
  for (it = m_vrepdbs.begin(); it != m_vrepdbs.end(); it++) {
    if (str_NoCaseStrcmp(it->second->name(), name) == 0) {
      *sts = LDH__SUCCESS;
      return it->second;
    }
  }
  for (it = m_vrepextern.begin(); it != m_vrepextern.end(); it++) {
    if (str_NoCaseStrcmp(it->second->name(), name) == 0) {
      *sts = LDH__SUCCESS;
      return it->second;
    }
  }

  for (buffer_iterator itb = m_vrepbuffer.begin(); itb != m_vrepbuffer.end();
       itb++) {
    if (str_NoCaseStrcmp((*itb)->name(), name) == 0) {
      *sts = LDH__SUCCESS;
      return *itb;
    }
  }
  *sts = LDH__NOSUCHVOL;
  return 0;
}

wb_vrep* wb_erep::externVolume(pwr_tStatus* sts, pwr_tVid vid)
{
  vrep_iterator it = m_vrepextern.find(vid);
  if (it == m_vrepextern.end()) {
    *sts = LDH__NOSUCHVOL;
    return 0;
  }
  *sts = LDH__SUCCESS;
  return it->second;
}

wb_vrep* wb_erep::bufferVolume(pwr_tStatus* sts)
{
  buffer_iterator it = m_vrepbuffer.begin();
  if (it == m_vrepbuffer.end()) {
    *sts = LDH__NOSUCHVOL;
    return 0;
  }
  *sts = LDH__SUCCESS;
  return *it;
}

wb_vrep* wb_erep::bufferVolume(pwr_tStatus* sts, char* name)
{
  for (buffer_iterator it = m_vrepbuffer.begin(); it != m_vrepbuffer.end();
       it++) {
    if (str_NoCaseStrcmp(name, (*it)->name()) == 0) {
      *sts = LDH__SUCCESS;
      return *it;
    }
  }
  *sts = LDH__NOSUCHVOL;
  return 0;
}

wb_vrep* wb_erep::nextVolume(pwr_tStatus* sts, pwr_tVid vid)
{
  // Search in db
  vrep_iterator it = m_vrepdb.find(vid);
  if (it != m_vrepdb.end()) {
    it++;
    if (it != m_vrepdb.end()) {
      *sts = LDH__SUCCESS;
      return it->second;
    } else {
      // Next volume in dbs
      it = m_vrepdbs.begin();
      if (it != m_vrepdbs.end()) {
        *sts = LDH__SUCCESS;
        return it->second;
      } else {
        *sts = LDH__NOSUCHVOL;
        return 0;
      }
    }
  }

  // Search in dbs
  it = m_vrepdbs.find(vid);
  if (it != m_vrepdbs.end()) {
    it++;
    if (it != m_vrepdbs.end() && it->second->duplicateDb())
      it++;
    if (it != m_vrepdbs.end()) {
      *sts = LDH__SUCCESS;
      return it->second;
    } else {
      // Next volume in extern
      for (it = m_vrepextern.begin(); it != m_vrepextern.end(); it++) {
        if (it->second->cid() == pwr_eClass_ExternVolume) {
          *sts = LDH__SUCCESS;
          return it->second;
        }
      }
      *sts = LDH__NOSUCHVOL;
      return 0;
    }
  }

  // Search in buffer
  for (buffer_iterator itb = m_vrepbuffer.begin(); itb != m_vrepbuffer.end();
       itb++) {
    if ((*itb)->vid() == vid) {
      itb++;
      if (itb != m_vrepbuffer.end()) {
        *sts = LDH__SUCCESS;
        return *itb;
      } else {
        *sts = LDH__NOSUCHVOL;
        return 0;
      }
    }
  }

  *sts = LDH__NOSUCHVOL;
  return 0;
}

void wb_erep::addDb(pwr_tStatus* sts, wb_vrep* vrep)
{
  vrep_iterator it = m_vrepdb.find(vrep->vid());
  if (it == m_vrepdb.end()) {
    m_vrepdb[vrep->vid()] = vrep;
    vrep->ref();
    *sts = LDH__SUCCESS;
  } else
    *sts = LDH__VOLIDALREXI;
}

void wb_erep::addDbs(pwr_tStatus* sts, wb_vrep* vrep)
{
  vrep_iterator it = m_vrepdbs.find(vrep->vid());
  if (it == m_vrepdbs.end()) {
    m_vrepdbs[vrep->vid()] = vrep;
    vrep->ref();
    *sts = LDH__SUCCESS;
  } else {
    *sts = LDH__VOLIDALREXI;
    return;
  }

  if (cdh_isClassVolumeClass(vrep->cid())) {
    m_merep->addDbs(sts, (wb_mvrep*)vrep);
  }
}

void wb_erep::addExtern(pwr_tStatus* sts, wb_vrep* vrep)
{
  vrep_iterator it = m_vrepextern.find(vrep->vid());
  if (it == m_vrepextern.end()) {
    m_vrepextern[vrep->vid()] = vrep;
    vrep->ref();
    *sts = LDH__SUCCESS;
  } else {
    *sts = LDH__VOLIDALREXI;
    return;
  }
}

wb_vrep* wb_erep::findBuffer(pwr_tVid vid)
{
  for (buffer_iterator itb = m_vrepbuffer.begin(); itb != m_vrepbuffer.end();
       itb++) {
    if ((*itb)->vid() == vid)
      return *itb;
  }
  return 0;
}

void wb_erep::addBuffer(pwr_tStatus* sts, wb_vrep* vrep)
{
  wb_vrep* v = findBuffer(vrep->vid());
  if (!v) {
    // Remove oldest buffer
    if ((int)m_vrepbuffer.size() >= m_buffer_max) {
      m_vrepbuffer.erase(m_vrepbuffer.begin());
    }

    m_vrepbuffer.push_back(vrep);
    vrep->ref();
    *sts = LDH__SUCCESS;
  } else {
    *sts = LDH__VOLIDALREXI;
    return;
  }
}

void wb_erep::removeDb(pwr_tStatus* sts, wb_vrep* vrep)
{
  vrep_iterator it = m_vrepdb.find(vrep->vid());
  if (it == m_vrepdb.end()) {
    *sts = LDH__NOSUCHVOL;
    return;
  }
  it->second->unref();
  m_vrepdb.erase(it);
  *sts = LDH__SUCCESS;
}

void wb_erep::removeDbs(pwr_tStatus* sts, wb_vrep* vrep)
{
  vrep_iterator it = m_vrepdbs.find(vrep->vid());
  if (it == m_vrepdbs.end()) {
    *sts = LDH__NOSUCHVOL;
    return;
  }
  it->second->unref();
  m_vrepdbs.erase(it);
  *sts = LDH__SUCCESS;
}

void wb_erep::removeExtern(pwr_tStatus* sts, wb_vrep* vrep)
{
  vrep_iterator it = m_vrepextern.find(vrep->vid());
  if (it == m_vrepextern.end()) {
    *sts = LDH__NOSUCHVOL;
    return;
  }
  it->second->unref();
  m_vrepextern.erase(it);
  *sts = LDH__SUCCESS;
}

void wb_erep::removeBuffer(pwr_tStatus* sts, wb_vrep* vrep)
{
  for (buffer_iterator it = m_vrepbuffer.begin(); it != m_vrepbuffer.end();
       it++) {
    if (*it == vrep) {
      vrep->unref();
      m_vrepbuffer.erase(it);
      *sts = LDH__SUCCESS;
      return;
    }
  }
  *sts = LDH__NOSUCHVOL;
  return;
}

void wb_erep::load(pwr_tStatus* sts, char* db)
{
  loadDirList(sts);
  if (EVEN(*sts))
    return;
  else if (*sts == LDH__PROJCONFIG) {
    pwr_tStatus status;
    loadCommonMeta(&status);
    if (EVEN(status)) {
      *sts = status;
      return;
    }
    loadMeta(sts, db);
    bindMethods();
    loadLocalWb(sts);
    wb_vrepref* vrep = new wb_vrepref(this, ldh_cPlcMainVolume);
    addExtern(sts, vrep);
    vrep = new wb_vrepref(this, ldh_cPlcFoVolume);
    addExtern(sts, vrep);
    vrep = new wb_vrepref(this, ldh_cIoConnectVolume);
    addExtern(sts, vrep);
    return;
  }
  loadCommonMeta(sts);
  if (EVEN(*sts))
    return;

  loadMeta(sts, db);
  bindMethods();
  loadLocalWb(sts);

  wb_vrepref* vrep = new wb_vrepref(this, ldh_cPlcMainVolume);
  addExtern(sts, vrep);
  vrep = new wb_vrepref(this, ldh_cPlcFoVolume);
  addExtern(sts, vrep);
  vrep = new wb_vrepref(this, ldh_cIoConnectVolume);
  addExtern(sts, vrep);
}

void wb_erep::loadDirList(pwr_tStatus* status)
{
  // Read directory file
  char line[200];
  char fname[200];

  dcli_translate_filename(m_dir_list[0], "$pwr_load");
  strcat(m_dir_list[0], "/");
  m_dir_cnt = 1;

  dcli_translate_filename(fname, pwr_cNameFilePath);
  std::ifstream fp(fname, std::ios::in);
  if (!fp) {
    *status = LDH__PROJCONFIG;
    return;
  }

  while (fp.getline(line, sizeof(line))) {
    if (m_dir_cnt > (int)(sizeof(m_dir_list) / sizeof(m_dir_list[0]) - 1))
      break;
    dcli_translate_filename(m_dir_list[m_dir_cnt], line);
    if (m_dir_list[m_dir_cnt][strlen(m_dir_list[m_dir_cnt]) - 1] != '/')
      strcat(m_dir_list[m_dir_cnt], "/");
    m_dir_cnt++;
  }
  fp.close();
}

void wb_erep::loadCommonMeta(pwr_tStatus* status)
{
  char fname[200];
  char fdir[200];
  char vname[200];
  char line[200];
  int i;
  pwr_tVid vid;
  pwr_tStatus sts;

  for (i = 0; i < m_dir_cnt; i++) {
    // Load metavolumes
    strcpy(fdir, m_dir_list[i]);
    strcpy(fname, fdir);
    strcat(fname, pwr_cNameCmnVolumeList);

    std::ifstream fpm(fname, std::ios::in);
    if (!fpm) {
      if (i == 0) {
        *status = LDH__NOBASE;
        return;
      } else
        continue;
    }
    while (fpm.getline(line, sizeof(line))) {
      char vol_array[2][80];
      int nr;

      if (line[0] == '#')
        continue;

      nr = dcli_parse(line, " ", "", (char*)vol_array,
          sizeof(vol_array) / sizeof(vol_array[0]), sizeof(vol_array[0]), 0);
      if (nr != 2)
        MsgWindow::message('E', "Syntax error in file:", fname);

      // Load this volume
      str_ToLower(vol_array[0], vol_array[0]);
      strcpy(vname, fdir);
      strcat(vname, vol_array[0]);
      strcat(vname, ".dbs");
      cdh_StringToVolumeId(vol_array[1], &vid);

      wb_vrepdbs* vrep = new wb_vrepdbs(this, vname);
      try {
        vrep->load();
        addDbs(&sts, vrep);
        char buff[270];
        if (cdh_isClassVolumeClass(vrep->cid()))
          sprintf(buff, "Global class volume \"%s\" loaded from \"%s\"",
              vrep->dbsenv()->vp->name, vname);
        else
          sprintf(buff, "Volume \"%s\" loaded from \"%s\"",
              vrep->dbsenv()->vp->name, vname);
        MsgWindow::message('O', buff);
      } catch (wb_error& e) {
        if (m_options & ldh_mWbOption_IgnoreDLoadError)
          MsgWindow::message('I', "Unable to open class volume", vname);
        else
          MsgWindow::message(
              'E', "Unable to open class volume", vname, e.what().c_str());
      }
    }
    fpm.close();
  }
  *status = LDH__SUCCESS;
}

void wb_erep::loadMeta(pwr_tStatus* status, char* db)
{
  // Load local metavolumes
  char found_file[200];
  char fname[200];
  char vname[200];
  char line[200];
  int i, j;
  pwr_tVid vid;
  pwr_tStatus sts;
  wb_vrepdbs* vrep;
  int vol_cnt = 0;
  eDbType db_type;
  int is_classvolume = 0;
  int load_externvolume;
  int load_dbs;
  int load_db;

  strcpy(fname, pwr_cNameVolumeList);
  dcli_translate_filename(fname, fname);

  // Load classvolumes first (j == 0) and then other volumes (j == 1)
  for (j = 0; j < 2; j++) {
    std::ifstream fpm(fname, std::ios::in);
    if (!fpm) {
      *status = LDH__PROJCONFIG;

      // Load directory volume
      strcpy(vname, "$pwrp_db/directory.wb_load");
      dcli_translate_filename(vname, vname);

      sts = dcli_search_file(vname, found_file, DCLI_DIR_SEARCH_INIT);
      dcli_search_file(vname, found_file, DCLI_DIR_SEARCH_END);
      if (ODD(sts)) {
        wb_vrepmem* vrepmem = new wb_vrepmem(this);
        vrepmem->loadWbl(vname, &sts);
        vrepmem->name("directory");
        addDb(&sts, vrepmem);
        MsgWindow::message('I', "Directory database opened", vname);
      }

      return;
    }

    while (fpm.getline(line, sizeof(line))) {
      char vol_array[7][80];
      int nr;

      if (line[0] == '#')
        continue;

      nr = dcli_parse(line, " ", "", (char*)vol_array,
          sizeof(vol_array) / sizeof(vol_array[0]), sizeof(vol_array[0]), 0);
      if (nr > 6)
        std::cout << "Syntax error in file: " << fname << '\n';

      cdh_StringToVolumeId(vol_array[1], &vid);

      // Find out what to do with this volume
      load_externvolume = 0;
      load_dbs = 0;
      load_db = 0;
      if (str_NoCaseStrcmp(vol_array[2], "ExternVolume") == 0 && j == 1)
        load_externvolume = 1;
      else if (str_NoCaseStrcmp(vol_array[2], "ClassVolume") == 0
          || str_NoCaseStrcmp(vol_array[2], "DetachedClassVolume") == 0
          || streq(vol_array[3], "load")) {
        if (j == 0)
          load_dbs = 1;
        if (((str_NoCaseStrcmp(vol_array[2], "ClassVolume") == 0
                 || str_NoCaseStrcmp(vol_array[2], "DetachedClassVolume") == 0)
                && (streq(vol_array[3], "cnf") && db
                       && str_NoCaseStrcmp(db, vol_array[0]) == 0))) {
          if (j == 1)
            load_db = 1;
        }
      } else if (j == 1)
        load_db = 1;

      if (load_externvolume) {
        if (nr != 6)
          std::cout << "Syntax error in file: " << fname << '\n';

        // Load extern volume for this volume
        str_ToLower(vol_array[0], vol_array[0]);

        try {
          wb_vrepext* vrepext
              = new wb_vrepext(this, vid, vol_array[0], vol_array[4]);
          addExtern(&sts, vrepext);
          MsgWindow::message('O', "Volume loaded", vname);
          vol_cnt++;
        } catch (wb_error& e) {
          MsgWindow::message(
              'E', "Unable to open volume", vname, e.what().c_str());
        }
      }

      if (load_dbs) {
        if (nr < 4)
          std::cout << "Syntax error in file: " << fname << '\n';

        // Load dbs for this volume
        str_ToLower(vol_array[0], vol_array[0]);

        if (streq(vol_array[3], "cnf")) {
          // Configured in this project, load from pwrp_load
          strcpy(vname, "$pwrp_load/");
          strcat(vname, vol_array[0]);
          strcat(vname, ".dbs");
          dcli_translate_filename(vname, vname);

          // Load...
          try {
            vrep = new wb_vrepdbs(this, vname);
            vrep->load();
            addDbs(&sts, vrep);
            MsgWindow::message('O', "Volume loaded from snapshot file", vname);
            vol_cnt++;
          } catch (wb_error& e) {
            if (m_options & ldh_mWbOption_IgnoreDLoadError)
              MsgWindow::message(
                  'I', "Unable to open volume snapshot file", vname);
            else
              MsgWindow::message('E', "Unable to open volume snapshot file",
                  vname, e.what().c_str());
          }
        } else {
          // Imported loadfile
          bool found = false;
          for (i = 0; i < m_dir_cnt; i++) {
            strcpy(vname, m_dir_list[i]);
            strcat(vname, vol_array[0]);
            strcat(vname, ".dbs");
            sts = dcli_search_file(vname, found_file, DCLI_DIR_SEARCH_INIT);
            dcli_search_file(vname, found_file, DCLI_DIR_SEARCH_END);
            if (ODD(sts)) {
              // Load...
              found = true;
              try {
                vrep = new wb_vrepdbs(this, vname);
                vrep->load();
                // vrep->name( vol_array[0]);
                addDbs(&sts, vrep);
                MsgWindow::message(
                    'O', "Volume loaded from snapshot file", vname);
              } catch (wb_error& e) {
                if (m_options & ldh_mWbOption_IgnoreDLoadError)
                  MsgWindow::message(
                      'I', "Unable to open volume snapshot file", vname);
                else
                  MsgWindow::message('E', "Unable to open volume snapshot file",
                      vname, e.what().c_str());
              }
              break;
            }
          }
          if (!found)
            MsgWindow::message('E', "Volume snapshotfile not found", vname);
        }
      }
      if (load_db) {
        // Load db for this volume
        char uname[80];

        if (nr < 4)
          std::cout << "Syntax error in file: " << fname << '\n';

        if (db) {
          // If db is specified, load only specified db, load as dbs instead
          if (str_NoCaseStrcmp(vol_array[0], db) != 0) {
            str_ToLower(vol_array[0], vol_array[0]);
            strcpy(vname, "$pwrp_load/");
            strcat(vname, vol_array[0]);
            strcat(vname, ".dbs");
            sts = dcli_search_file(vname, found_file, DCLI_DIR_SEARCH_INIT);
            dcli_search_file(vname, found_file, DCLI_DIR_SEARCH_END);
            if (ODD(sts)) {
              // Load...
              try {
                vrep = new wb_vrepdbs(this, found_file);
                vrep->load();
                // vrep->name( vol_array[0]);
                addDbs(&sts, vrep);
                MsgWindow::message(
                    'O', "Volume loaded from snapshot file", vname);
              } catch (wb_error& e) {
                if (m_options & ldh_mWbOption_IgnoreDLoadError)
                  MsgWindow::message(
                      'I', "Unable to open volume snapshot file", vname);
                else
                  MsgWindow::message('E', "Unable to open volume snapshot file",
                      vname, e.what().c_str());
              }
            }
            continue;
          }
        }
        strcpy(vname, "$pwrp_db/");
        strcat(vname, vol_array[0]);
        str_ToLower(vname, vname);
        if (str_NoCaseStrcmp(vol_array[2], "ClassVolume") == 0
            || str_NoCaseStrcmp(vol_array[2], "DetchedClassVolume") == 0) {
          is_classvolume = 1;
          if (nr >= 5 && vol_array[4][0] == '2')
            db_type = eDbType_dbms;
          else if (nr >= 5 && vol_array[4][0] == '1')
            db_type = eDbType_db;
          else
            db_type = eDbType_wbl;
        } else if (streq(vol_array[3], "clone"))
          db_type = eDbType_none;
        else {
          if (nr >= 5 && vol_array[4][0] == '1')
            db_type = eDbType_dbms;
          else
            db_type = eDbType_db;
        }
        switch (db_type) {
        case eDbType_dbms:
          strcat(vname, ".dbms");
          break;
        case eDbType_db:
          strcat(vname, ".db");
          break;
        default:
          strcat(vname, ".dbxx");
        }
        dcli_translate_filename(vname, vname);

        if (db_type == eDbType_none) {
          m_options |= ldh_mWbOption_OpenDbs;
          sts = 1;
        } else {
          sts = dcli_search_file(vname, found_file, DCLI_DIR_SEARCH_INIT);
          dcli_search_file(vname, found_file, DCLI_DIR_SEARCH_END);
        }
        if (EVEN(sts)) {
          MsgWindow::message('E', "Database not found", vname);
        } else {
          int open_loadfile = m_options & ldh_mWbOption_OpenDbs ? 1 : 0;

          if (wb_dblock::is_locked(vname, uname) && !open_loadfile) {
            char msg[190];

            sprintf(
                msg, "Database %s is locked by user %s", vol_array[0], uname);
            MsgWindow::message('E', msg, msgw_ePop_No);

            if (!MsgWindow::has_window())
              exit(0);

            CoWow* wow = MsgWindow::get_wow();
            int res = wow->CreateModalDialog("Database Locked", msg, "Exit",
                "Enter loadfile", "Remove lock", "$pwr_exe/wtt_padlock.png");
            switch (res) {
            case wow_eModalDialogReturn_Button1:
            case wow_eModalDialogReturn_Deleted:
              exit(0);
            case wow_eModalDialogReturn_Button3:
              // Remove lock
              wb_dblock::dbunlock(vname);
              break;
            case wow_eModalDialogReturn_NYI:
            case wow_eModalDialogReturn_Button2:
              // Enter loadfile
              open_loadfile = 1;
              break;
            }
          }

          if (open_loadfile) {
            // Open dbs
            str_ToLower(vol_array[0], vol_array[0]);
            strcpy(vname, "$pwrp_load/");
            strcat(vname, vol_array[0]);
            strcat(vname, ".dbs");
            dcli_translate_filename(vname, vname);

            try {
              vrep = new wb_vrepdbs(this, vname);
              vrep->load();
              addDbs(&sts, vrep);
              MsgWindow::message(
                  'I', "Volume loaded from snapshot file", vname);
              vol_cnt++;
            } catch (wb_error& e) {
              if (m_options & ldh_mWbOption_IgnoreDLoadError)
                MsgWindow::message(
                    'I', "Unable to open volume snapshot file", vname);
              else
                MsgWindow::message('E', "Unable to open volume snapshot file",
                    vname, e.what().c_str());
            }
          } else {
            // Open db

            if (nr >= 5 && db_type == eDbType_dbms) {
#if defined PWRE_CONF_MYSQL
              if (is_classvolume) {
                wb_vrepdbms* vrepdbms = new wb_vrepdbms(this, vname);

                wb_vrepced* vrepced = new wb_vrepced(this, vrepdbms);
                vrepced->name(vol_array[0]);
                addDb(&sts, vrepced);
                MsgWindow::message('I', "Classvolume Database opened", vname);
                vol_cnt++;

              } else {
                wb_vrepdbms* vrepdbms = new wb_vrepdbms(this, vname);
                vrepdbms->name(vol_array[0]);
                addDb(&sts, vrepdbms);
                MsgWindow::message('I', "Database opened", vname);
                vol_cnt++;
              }
#endif
            } else {
              if (is_classvolume) {
                wb_vrepdb* vrepdb = new wb_vrepdb(this, vname);

                wb_vrepced* vrepced = new wb_vrepced(this, vrepdb);
                vrepced->name(vol_array[0]);
                addDb(&sts, vrepced);
                MsgWindow::message('I', "Classvolume Database opened", vname);
                vol_cnt++;
              } else {
                wb_vrepdb* vrepdb = new wb_vrepdb(this, vname);
                vrepdb->name(vol_array[0]);
                addDb(&sts, vrepdb);
                MsgWindow::message('I', "Database opened", vname);
                vol_cnt++;
              }
            }
          }
        }
      }
    }
    fpm.close();
  }

  // Identify dbs that also is loaded as db
  vrep_iterator itdbs, itdb;

  for (itdbs = m_vrepdbs.begin(); itdbs != m_vrepdbs.end(); itdbs++) {
    for (itdb = m_vrepdb.begin(); itdb != m_vrepdb.end(); itdb++) {
      if (itdbs->first == itdb->first)
        itdbs->second->setDuplicateDb(true);
    }
  }

  // Load directory volume

  if (!db || (db && str_NoCaseStrcmp("directory", db) == 0)) {
    char uname[80];

    strcpy(vname, "$pwrp_db/directory.wb_load");
    dcli_translate_filename(vname, vname);

    sts = dcli_search_file(vname, found_file, DCLI_DIR_SEARCH_INIT);
    dcli_search_file(vname, found_file, DCLI_DIR_SEARCH_END);
    if (EVEN(sts)) {
      *status = LDH__PROJCONFIG;
      return;
    }
    if (wb_dblock::is_locked(vname, uname)) {
      char msg[120];

      sprintf(msg, "Database directory is locked by user %s", uname);
      MsgWindow::message('E', msg, msgw_ePop_No);

      CoWow* wow = MsgWindow::get_wow();
      if (wow) {
        int res = wow->CreateModalDialog("Database Locked", msg, "Exit", 0,
            "Remove lock", "$pwr_exe/wtt_padlock.png");
        switch (res) {
        case wow_eModalDialogReturn_NYI:
        case wow_eModalDialogReturn_Button2:
        case wow_eModalDialogReturn_Button1:
        case wow_eModalDialogReturn_Deleted:
          exit(0);
        case wow_eModalDialogReturn_Button3:
          // Remove lock
          wb_dblock::dbunlock(vname);
          break;
        }
      } else
        exit(0);
    }

    wb_vrepmem* vrepmem = new wb_vrepmem(this);
    vrepmem->loadWbl(vname, &sts);
    vrepmem->name("directory");
    addDb(&sts, vrepmem);
    MsgWindow::message('I', "Database opened", vname);
  }

  if (!vol_cnt)
    *status = LDH__PROJCONFIG;
  else
    *status = LDH__SUCCESS;
}

void wb_erep::loadLocalWb(pwr_tStatus* rsts)
{
  pwr_tStatus sts;
  char found_file[200];

  sts = dcli_search_file(pwr_cNameLocalWb, found_file, DCLI_DIR_SEARCH_INIT);
  dcli_search_file(pwr_cNameLocalWb, found_file, DCLI_DIR_SEARCH_END);
  if (ODD(sts)) {
    try {
      wb_vrepwbl* vrep = new wb_vrepwbl(this);
      sts = vrep->load(found_file);
      if (ODD(sts))
        addExtern(&sts, vrep);
      else {
        *rsts = sts;
        MsgWindow::message('E', "Failiure loading local workbench volume");
        return;
      }
    } catch (wb_error& e) {
      *rsts = e.sts();
      MsgWindow::message('E', "Failiure loading local workbench volume");
      return;
    }
  }
  *rsts = LDH__SUCCESS;
}

wb_cdrep* wb_erep::cdrep(pwr_tStatus* sts, const wb_orep& o)
{
  wb_vrep* vrep = volume(sts, o.vid());
  if (EVEN(*sts))
    return 0;

  return vrep->merep()->cdrep(sts, o);
}

wb_tdrep* wb_erep::tdrep(pwr_tStatus* sts, const wb_adrep& a)
{
  pwr_tVid vid = cdh_TidToVid(a.type());
  wb_vrep* vrep = volume(sts, vid);
  if (EVEN(*sts))
    return 0;

  return vrep->merep()->tdrep(sts, a);
}

wb_orep* wb_erep::object(pwr_tStatus* sts, pwr_tOid oid)
{
  wb_vrep* vrep = volume(sts, oid.vid);
  if (EVEN(*sts))
    return 0;

  return vrep->object(sts, oid);
}

wb_orep* wb_erep::object(pwr_tStatus* sts, const char* name)
{
  wb_name n(name);

  if (n.evenSts()) {
    *sts = n.sts();
    return 0;
  }

  wb_vrep* vrep = volume(sts, n.volume());
  if (EVEN(*sts))
    return 0;

  return vrep->object(sts, n);
}

wb_orep* wb_erep::object(pwr_tStatus* sts, wb_name& name)
{
  if (name.evenSts()) {
    *sts = name.sts();
    return 0;
  }

  wb_vrep* vrep = volume(sts, name.volume());
  if (EVEN(*sts))
    return 0;

  return vrep->object(sts, name);
}

void wb_erep::method(pwr_tStatus* sts, char* methodName, wb_tMethod* method)
{
  std::string key = std::string(methodName);
  methods_iterator it = m_methods.find(key);
  if (it == m_methods.end()) {
    *sts = LDH__NOMETHOD;
    return;
  }
  *sts = LDH__SUCCESS;
  *method = it->second;
}

void wb_erep::bindMethods()
{
  int i, j;
  pwr_tStatus sts;
  char str[200];

  for (i = 0;; i++) {
    if (pwr_gSystem_ClassMethods[i].ClassName[0] == '\0')
      break;
    for (j = 0;; j++) {
      if ((*pwr_gSystem_ClassMethods[i].Methods)[j].MethodName[0] == '\0')
        break;
      strcpy(str, pwr_gSystem_ClassMethods[i].ClassName);
      strcat(str, "-");
      strcat(str, (*pwr_gSystem_ClassMethods[i].Methods)[j].MethodName);
      std::string key = std::string(str);
      m_methods[key] = (*pwr_gSystem_ClassMethods[i].Methods)[j].Method;
    }
  }

  for (i = 0;; i++) {
    if (pwr_gBase_ClassMethods[i].ClassName[0] == '\0')
      break;
    wb_name cname = wb_name(pwr_gBase_ClassMethods[i].ClassName);
    wb_cdrep* cdrep = m_merep->cdrep(&sts, cname);
    if (EVEN(sts))
      continue;

    for (j = 0;; j++) {
      if ((*pwr_gBase_ClassMethods[i].Methods)[j].MethodName[0] == '\0')
        break;
      strcpy(str, pwr_gBase_ClassMethods[i].ClassName);
      strcat(str, "-");
      strcat(str, (*pwr_gBase_ClassMethods[i].Methods)[j].MethodName);
      std::string key = std::string(str);
      m_methods[key] = (*pwr_gBase_ClassMethods[i].Methods)[j].Method;
    }
    delete cdrep;
  }
}

void wb_erep::printMethods()
{
  int i, j;

  printf("System Methods\n");
  for (i = 0;; i++) {
    if (pwr_gSystem_ClassMethods[i].ClassName[0] == '\0')
      break;
    printf("%3d %-20s\n", i, pwr_gSystem_ClassMethods[i].ClassName);
    for (j = 0;; j++) {
      if ((*pwr_gSystem_ClassMethods[i].Methods)[j].MethodName[0] == '\0')
        break;
      printf(
          "       %s\n", (*pwr_gSystem_ClassMethods[i].Methods)[j].MethodName);
    }
  }

  printf("Base Methods\n");
  for (i = 0;; i++) {
    if (pwr_gBase_ClassMethods[i].ClassName[0] == '\0')
      break;

    printf("%3d %-20s\n", i, pwr_gBase_ClassMethods[i].ClassName);
    for (j = 0;; j++) {
      if ((*pwr_gBase_ClassMethods[i].Methods)[j].MethodName[0] == '\0')
        break;
      printf("       %s\n", (*pwr_gBase_ClassMethods[i].Methods)[j].MethodName);
    }
  }
}

int wb_erep::nextVolatileVid(pwr_tStatus* sts, char* name)
{
  pwr_tVid vid = ldh_cVolatileVolMin + m_volatile_idx++;
  if (vid > ldh_cVolatileVolMax) {
    // Recycle identities, and hope that the old volumes are history
    m_volatile_idx = 0;
    vid = ldh_cVolatileVolMin + m_volatile_idx++;
  }
  if (name)
    // Suggest a name
    sprintf(name, "Buffer%03d", vid & 255);

  return vid;
}

wb_vrep* wb_erep::createVolume(pwr_tStatus* sts, pwr_tVid vid, pwr_tCid cid,
    const char* name, ldh_eVolRep type, char* server, bool add)
{
  pwr_tFileName vname;

  if (cid == pwr_eClass_DirectoryVolume) {
    vrep_iterator it = m_vrepdb.find(vid);
    if (it != m_vrepdb.end()) {
      *sts = LDH__VOLIDALREXI;
      return 0;
    }

    strcpy(vname, "$pwrp_db/directory.wb_load");
    dcli_translate_filename(vname, vname);

    std::ofstream ofd(vname);
    ofd << "Volume directory $DirectoryVolume 254.254.254.253\n"
        << "EndVolume\n";
    ofd.close();

    MsgWindow::message('I', "Database created", vname);

    wb_vrepmem* vrepmem = new wb_vrepmem(this);
    vrepmem->loadWbl(vname, sts);
    vrepmem->name("directory");
    if (add)
      addDb(sts, vrepmem);
    return vrepmem;
  } else if (type == ldh_eVolRep_Wbl) {
    char vidstr[40];
    pwr_tTime t;
    char classstr[40];

    cdh_VolumeIdToString(vidstr, sizeof(vidstr), vid, 0, 0);
    sprintf(vname, "$pwrp_db/%s.wb_load", cdh_Low(name));
    dcli_translate_filename(vname, vname);

    switch (cid) {
    case pwr_eClass_ClassVolume:
      strcpy(classstr, "$ClassVolume"); 
      break;
    case pwr_eClass_RootVolume:
      strcpy(classstr, "$RootVolume"); 
      break;
    default:
      *sts = LDH__NYI;
      return 0;
    }
    if (ODD(dcli_file_time(vname, &t))) {
      *sts = LDH__VOLIDALREXI;
      return 0;
    }
    
    std::ofstream ofd(vname);
    ofd << "Volume " << name << " " << classstr << " " << vidstr << "\n"
        << "EndVolume\n";
    ofd.close();

    MsgWindow::message('I', "Database created", vname);


  } else if (type == ldh_eVolRep_Db) {
    sprintf(vname, "$pwrp_db/%s.db", cdh_Low(name));
    dcli_translate_filename(vname, vname);

    vrep_iterator it = m_vrepdb.find(vid);
    if (it != m_vrepdb.end()) {
      *sts = LDH__VOLIDALREXI;
      return 0;
    }

    wb_vrepdb* vrepdb = new wb_vrepdb(this, vid, cid, name, vname);
    if (add)
      addDb(sts, vrepdb);
    MsgWindow::message('I', "Database created", vname);

    return vrepdb;
  } else if (type == ldh_eVolRep_Dbms) {
    char host[40] = "pwr42";
    char user[40] = "pwrp";
    char password[40] = "";
    unsigned int port = 0;
    char socket[80];

    cnf_get_value("mysqlSocket", socket, sizeof(socket));

    *sts = lfu_ParseDbmsServer(server, user, password, &port, host);
    if (EVEN(*sts))
      return 0;

    printf("Host: \"%s\"\nUser: \"%s\"\nPass: \"%s\"\nPort: %d\n", host, user,
        password, port);

    sprintf(vname, "$pwrp_db/%s.dbms", cdh_Low(name));
    dcli_translate_filename(vname, vname);

    vrep_iterator it = m_vrepdb.find(vid);
    if (it != m_vrepdb.end()) {
      *sts = LDH__VOLIDALREXI;
      return 0;
    }

#if defined PWRE_CONF_MYSQL
    wb_dbms_env* env = new wb_dbms_env();
    env->create(vname, host, user, password, cdh_Low(name), port, socket);

    // wb_dbms *dbms = new wb_dbms();
    // dbms->create( vid, cid, dbname, vname);

    wb_vrepdbms* vrepdbms = new wb_vrepdbms(this, vid, cid, name, vname);
    if (add)
      addDb(sts, vrepdbms);
    MsgWindow::message('I', "Database created", vname);

    return vrepdbms;
#endif
  }
  return 0;
}

void wb_erep::volumeNameToFilename(pwr_tStatus* sts, char* name, char* filename)
{
  char found_file[200];
  char vname[200];
  char line[200];
  char fname[200];
  char dir_list[11][200];
  int dir_cnt;
  int fsts;

  // Read directory file
  strcpy(dir_list[0], "$pwr_load/");
  strcpy(dir_list[1], "$pwrp_load/");
  dir_cnt = 2;

  dcli_translate_filename(fname, pwr_cNameFilePath);
  std::ifstream fp(fname, std::ios::in);
  if (!fp) {
    *sts = LDH__PROJCONFIG;
    return;
  }

  while (fp.getline(line, sizeof(line))) {
    if (dir_cnt > (int)(sizeof(dir_list) / sizeof(dir_list[0]) - 1))
      break;
    strcpy(dir_list[dir_cnt], line);
    if (dir_list[dir_cnt][strlen(dir_list[dir_cnt]) - 1] != '/')
      strcat(dir_list[dir_cnt], "/");
    dir_cnt++;
  }
  fp.close();

  for (int i = 0; i < dir_cnt; i++) {
    strcpy(vname, dir_list[i]);
    str_ToLower(&vname[strlen(vname)], name);
    strcat(vname, ".dbs");
    fsts = dcli_search_file(vname, found_file, DCLI_DIR_SEARCH_INIT);
    dcli_search_file(vname, found_file, DCLI_DIR_SEARCH_END);
    if (ODD(fsts)) {
      strcpy(filename, vname);
      *sts = LDH__SUCCESS;
      return;
    }
  }
  *sts = LDH__NOSUCHFILE;
}

void wb_erep::setRefMerep(wb_merep* merep)
{
  pwr_tStatus sts;
  m_ref_merep_occupied = true;

  wb_vrepref* vrepref = (wb_vrepref*)volume(&sts, ldh_cPlcMainVolume);
  if (ODD(sts))
    vrepref->setMerep(merep);
  vrepref = (wb_vrepref*)volume(&sts, ldh_cPlcFoVolume);
  if (ODD(sts))
    vrepref->setMerep(merep);
  vrepref = (wb_vrepref*)volume(&sts, ldh_cIoConnectVolume);
  if (ODD(sts))
    vrepref->setMerep(merep);
}

void wb_erep::resetRefMerep()
{
  pwr_tStatus sts;
  m_ref_merep_occupied = false;

  wb_vrepref* vrepref = (wb_vrepref*)volume(&sts, ldh_cPlcMainVolume);
  if (ODD(sts))
    vrepref->setMerep(m_merep);
  vrepref = (wb_vrepref*)volume(&sts, ldh_cPlcFoVolume);
  if (ODD(sts))
    vrepref->setMerep(m_merep);
  vrepref = (wb_vrepref*)volume(&sts, ldh_cIoConnectVolume);
  if (ODD(sts))
    vrepref->setMerep(m_merep);
}

bool wb_erep::check_lock(char* name, ldh_eVolDb type)
{
  char vname[200];

  sprintf(vname, "$pwrp_db/%s", cdh_Low(name));
  switch (type) {
  case ldh_eVolDb_Db:
    strcat(vname, ".db");
    break;
  case ldh_eVolDb_Dbms:
    strcat(vname, ".dbms");
    break;
  default:
    return true;
  }
  dcli_translate_filename(vname, vname);
  return wb_dblock::check(vname);
}

void wb_erep::checkVolume(pwr_tStatus* sts, pwr_tVid vid,
    std::vector<wb_volcheck>& carray, int* err_cnt)
{
  lfu_t_volref* volref;
  int volref_cnt;
  pwr_tFileName fname;

  wb_vrep* vol = volume(sts, vid);
  if (EVEN(*sts)) {
    MsgWindow::message(
        'E', "Volume not loaded: ", cdh_VolumeIdToString(0, 0, vid, 0, 0));
    (*err_cnt)++;
    return;
  }

  wb_volcheck vcheck;

  switch (vol->type()) {
  case ldh_eVolRep_Dbs: {
    vcheck.m_vid = vid;
    vcheck.m_time = ((wb_vrepdbs*)vol)->m_dbsvep->vp->time;
    strcpy(vcheck.m_vname, vol->name());
    strcpy(vcheck.m_filename, vol->fileName());
    break;
  }
  case ldh_eVolRep_Wbl:
  case ldh_eVolRep_Db:
  case ldh_eVolRep_Dbms: {
    // Find dbs-file on $pwrp_load
    pwr_tFileName filestr;
    pwr_tVid vol_vid;
    pwr_tCid vol_cid;
    pwr_tTime vol_time;
    pwr_tObjName vol_name;
    pwr_tUInt32 vol_dvversion;

    volumeNameToFilename(sts, (char*)vol->name(), filestr);

    *sts = lfu_GetVolume(
        filestr, vol_name, &vol_vid, &vol_cid, &vol_time, &vol_dvversion);
    if (EVEN(*sts)) {
      MsgWindow::message('E', "Dbs file not found for volume ",
          cdh_VolumeIdToString(0, 0, vid, 0, 0));
      (*err_cnt)++;
      return;
    }

    vcheck.m_vid = vid;
    vcheck.m_cid = vol_cid;
    vcheck.m_time = vol_time;
    vcheck.m_dvversion = vol_dvversion;
    strcpy(vcheck.m_vname, vol->name());
    strcpy(vcheck.m_filename, filestr);

    break;
  }
  default:
    MsgWindow::message(
        'E', "Strange volume type: ", cdh_VolumeIdToString(0, 0, vid, 0, 0));
    (*err_cnt)++;
  }

  // Check if volume is stored
  bool found = false;
  for (int i = 0; i < (int)carray.size(); i++) {
    if (carray[i].m_vid == vcheck.m_vid) {
      found = true;
      if (carray[i].m_time.tv_sec != vcheck.m_time.tv_sec) {
        char msg[280];
        sprintf(msg, "Version mismatch volume %s in %s and %s", vcheck.m_vname,
            vcheck.m_filename, carray[i].m_filename);
        MsgWindow::message('E', msg, msgw_ePop_No);
        (*err_cnt)++;
        *sts = LDH__VOLVERSION;
      }
    }
  }

  if (!found)
    carray.push_back(vcheck);

  if (vol->cid() == pwr_eClass_DetachedClassVolume)
    // No check of referenced volumes
    return;

  *sts = lfu_GetVolRef(vcheck.m_filename, &volref, &volref_cnt);
  if (EVEN(*sts))
    return;

  for (int i = 0; i < volref_cnt; i++) {
    volumeNameToFilename(sts, volref[i].name, fname);
    if (EVEN(*sts)) {
      char msg[200];
      sprintf(msg, "Loadfile not found: %s", volref[i].name);
      MsgWindow::message('E', msg, msgw_ePop_No);
      (*err_cnt)++;
      continue;
    }

    checkVolume(sts, volref[i].vid, carray, err_cnt);

    for (int j = 0; j < (int)carray.size(); j++) {
      if (carray[j].m_vid == volref[i].vid) {
        if (carray[j].m_time.tv_sec != volref[i].version.tv_sec) {
          char msg[280];
          sprintf(msg, "Version mismatch volume %s in %s and %s",
              volref[i].name, vcheck.m_filename, carray[j].m_filename);
          MsgWindow::message('E', msg, msgw_ePop_No);
          (*err_cnt)++;
          *sts = LDH__VOLVERSION;
        }
        break;
      }
    }
  }
  free((char*)volref);
}

void wb_erep::checkVolumes(pwr_tStatus* sts, char* nodeconfigname)
{
  lfu_t_volumelist* vollist;
  int volcnt;
  std::vector<wb_volcheck> carray;
  int err_cnt = 0;

  // Load the bootlist
  *sts = lfu_volumelist_load(pwr_cNameBootList, &vollist, &volcnt);
  if (EVEN(*sts))
    return;

  bool found = false;
  for (int i = 0; i < volcnt; i++) {
    if (str_NoCaseStrcmp(vollist[i].p1, nodeconfigname) == 0) {
      found = true;
      checkVolume(sts, vollist[i].volume_id, carray, &err_cnt);
    }
  }

  if (!found) {
    char msg[200];
    sprintf(msg, "No root volume found for node %s", nodeconfigname);
    MsgWindow::message('E', msg, msgw_ePop_Yes);
    *sts = LDH__NOSUCHVOL;
  }
  if (err_cnt) {
    MsgWindow::map_default();
    *sts = LDH__VOLERR;
  }
}
