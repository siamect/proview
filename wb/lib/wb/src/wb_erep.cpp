/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2014 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

#include <iostream>
#include <fstream>

#include "pwr.h"
#include "wb_erep.h"
#include "wb_merep.h"
#include "wb_vrepwbl.h"
#include "wb_vrepdbs.h"
#include "wb_vrepdb.h"
#include "wb_vrepdbms.h"
#include "wb_vrepced.h"
#include "wb_vrepmem.h"
#include "wb_vrepref.h"
#include "wb_vrepext.h"
#include "wb_cdrep.h"
#include "wb_orep.h"
#include "wb_tdrep.h"
#include "wb_adrep.h"
#include "wb_name.h"
#include "wb_dblock.h"
#include "wb_dbms.h"
#include "wb_utl_api.h"
#include "wb_lfu.h"
#include "wb_ldh_msg.h"
#include "cow_msgwindow.h"
#include "cow_wow.h"
#include "co_cnf.h"

extern "C" {
#include "co_dcli.h"
#include "co_cdh.h"
#include "rt_load.h"
#include "wb_pwrs.h"
}

pwr_dImport pwr_BindClasses(System);
pwr_dImport pwr_BindClasses(Base);

typedef enum {
  eDbType_db,
  eDbType_dbms,
  eDbType_wbl,
  eDbType_none
} eDbType;

wb_erep::wb_erep( unsigned int options) : m_nRef(0), m_dir_cnt(0), m_volatile_idx(0), m_buffer_max(10),
					  m_ref_merep_occupied(false), m_options( options)
{
  m_merep = new wb_merep(0);

  atexit( at_exit);
}

wb_erep::~wb_erep()
{
  delete m_merep;
}

void wb_erep::at_exit()
{
  wb_dblock::dbunlock_all();
}

void wb_erep::unref()
{
  if (--m_nRef == 0)
    delete this;
}

wb_erep *wb_erep::ref()
{
  m_nRef++;
  return this;
}


// Get first volume
wb_vrep *wb_erep::volume( pwr_tStatus *sts)
{
  vrep_iterator it = m_vrepdb.begin();
  if ( it == m_vrepdb.end()) {
    it = m_vrepdbs.begin();
    if ( it == m_vrepdbs.end()) {
      *sts = LDH__NOSUCHVOL;
      return 0;
    }
  }
  *sts = LDH__SUCCESS;
  return it->second;
}

wb_vrep *wb_erep::volume(pwr_tStatus *sts, pwr_tVid vid)
{
  vrep_iterator it = m_vrepdb.find( vid);
  if ( it != m_vrepdb.end()) {
    *sts = LDH__SUCCESS;
    return it->second;
  }

  it = m_vrepdbs.find(vid);
  if ( it != m_vrepdbs.end()) {
    *sts = LDH__SUCCESS;
    return it->second;
  }

  it = m_vrepextern.find(vid);
  if ( it != m_vrepextern.end()) {
    *sts = LDH__SUCCESS;
    return it->second;
  }

  for ( buffer_iterator itb = m_vrepbuffer.begin(); itb != m_vrepbuffer.end(); itb++) {
    if ( (*itb)->vid() == vid) {
      *sts = LDH__SUCCESS;
      return *itb;
    }
  }

  *sts = LDH__NOSUCHVOL;
  return 0;
}


wb_vrep *wb_erep::volume(pwr_tStatus *sts, const char *name)
{
  vrep_iterator it;
  for ( it = m_vrepdb.begin(); it != m_vrepdb.end(); it++) {
    if ( cdh_NoCaseStrcmp( it->second->name(), name) == 0) {
      *sts = LDH__SUCCESS;
      return it->second;
    }
  }
  for ( it = m_vrepdbs.begin(); it != m_vrepdbs.end(); it++) {
    if ( cdh_NoCaseStrcmp( it->second->name(), name) == 0) {
      *sts = LDH__SUCCESS;
      return it->second;
    }
  }
  for ( it = m_vrepextern.begin(); it != m_vrepextern.end(); it++) {
    if ( cdh_NoCaseStrcmp( it->second->name(), name) == 0) {
      *sts = LDH__SUCCESS;
      return it->second;
    }
  }

  for ( buffer_iterator itb = m_vrepbuffer.begin(); itb != m_vrepbuffer.end(); itb++) {
    if ( cdh_NoCaseStrcmp( (*itb)->name(), name) == 0) {
      *sts = LDH__SUCCESS;
      return *itb;
    }
  }
  *sts = LDH__NOSUCHVOL;
  return 0;
}

wb_vrep *wb_erep::externVolume(pwr_tStatus *sts, pwr_tVid vid)
{
  vrep_iterator it = m_vrepextern.find( vid);
  if ( it == m_vrepextern.end()) {
    *sts = LDH__NOSUCHVOL;
    return 0;
  }
  *sts = LDH__SUCCESS;
  return it->second;
}

wb_vrep *wb_erep::bufferVolume(pwr_tStatus *sts)
{
  buffer_iterator it = m_vrepbuffer.begin();
  if ( it == m_vrepbuffer.end()) {
    *sts = LDH__NOSUCHVOL;
    return 0;
  }
  *sts = LDH__SUCCESS;
  return *it;
}

wb_vrep *wb_erep::bufferVolume(pwr_tStatus *sts, char *name)
{
  for ( buffer_iterator it = m_vrepbuffer.begin(); it != m_vrepbuffer.end(); it++) {
    if ( cdh_NoCaseStrcmp( name, (*it)->name()) == 0) {
      *sts = LDH__SUCCESS;
      return *it;
    }
  }
  *sts = LDH__NOSUCHVOL;
  return 0;
}

wb_vrep *wb_erep::nextVolume(pwr_tStatus *sts, pwr_tVid vid)
{
  // Search in db
  vrep_iterator it = m_vrepdb.find( vid);
  if ( it != m_vrepdb.end()) {
    it++;
    if ( it != m_vrepdb.end()) {
      *sts = LDH__SUCCESS;
      return it->second;
    }
    else {
      // Next volume in dbs
      it = m_vrepdbs.begin();
      if ( it != m_vrepdbs.end()) {
        *sts = LDH__SUCCESS;
        return it->second;
      }
      else {
        *sts = LDH__NOSUCHVOL;
        return 0;
      }
    }
  }

  // Search in dbs
  it = m_vrepdbs.find(vid);
  if ( it != m_vrepdbs.end()) {
    it++;
    if ( it != m_vrepdbs.end() && it->second->duplicateDb())
      it++;
    if ( it != m_vrepdbs.end()) {
      *sts = LDH__SUCCESS;
      return it->second;
    }
    else {
      // Next volume in extern
      for ( it = m_vrepextern.begin();
	    it != m_vrepextern.end();
	    it++) {
	if ( it->second->cid() == pwr_eClass_ExternVolume) {
	  *sts = LDH__SUCCESS;
	  return it->second;
	}
      }
      *sts = LDH__NOSUCHVOL;
      return 0;
    }
  }

  // Search in buffer
  for ( buffer_iterator itb = m_vrepbuffer.begin(); itb != m_vrepbuffer.end(); itb++) {
    if ( (*itb)->vid() == vid) {
      itb++;
      if ( itb != m_vrepbuffer.end()) {
        *sts = LDH__SUCCESS;
        return *itb;
      }
      else {
        *sts = LDH__NOSUCHVOL;
        return 0;
      }
    }
  }

  *sts = LDH__NOSUCHVOL;
  return 0;
}

void wb_erep::addDb( pwr_tStatus *sts, wb_vrep *vrep)
{
  vrep_iterator it = m_vrepdb.find( vrep->vid());
  if ( it == m_vrepdb.end()) {
    m_vrepdb[vrep->vid()] = vrep;
    vrep->ref();
    *sts = LDH__SUCCESS;
  }
  else
    *sts = LDH__VOLIDALREXI;
}

void wb_erep::addDbs( pwr_tStatus *sts, wb_vrep *vrep)
{
  vrep_iterator it = m_vrepdbs.find( vrep->vid());
  if ( it == m_vrepdbs.end()) {
    m_vrepdbs[vrep->vid()] = vrep;
    vrep->ref();
    *sts = LDH__SUCCESS;
  }
  else {
    *sts = LDH__VOLIDALREXI;
    return;
  }

  if ( cdh_isClassVolumeClass( vrep->cid())) {
    m_merep->addDbs( sts, (wb_mvrep *)vrep);
  }
}

void wb_erep::addExtern( pwr_tStatus *sts, wb_vrep *vrep)
{
  vrep_iterator it = m_vrepextern.find( vrep->vid());
  if ( it == m_vrepextern.end()) {
    m_vrepextern[vrep->vid()] = vrep;
    vrep->ref();
    *sts = LDH__SUCCESS;
  }
  else {
    *sts = LDH__VOLIDALREXI;
    return;
  }
}

wb_vrep *wb_erep::findBuffer( pwr_tVid vid)
{
  for ( buffer_iterator itb = m_vrepbuffer.begin(); itb != m_vrepbuffer.end(); itb++) {
    if ( (*itb)->vid() == vid)
      return *itb;
  }
  return 0;
}

void wb_erep::addBuffer( pwr_tStatus *sts, wb_vrep *vrep)
{
  wb_vrep *v = findBuffer( vrep->vid());
  if ( !v) {
    // Remove oldest buffer
    if ( (int) m_vrepbuffer.size() >= m_buffer_max) {
      m_vrepbuffer.erase( m_vrepbuffer.begin());
    }

    m_vrepbuffer.push_back( vrep);
    vrep->ref();
    *sts = LDH__SUCCESS;
  }
  else {
    *sts = LDH__VOLIDALREXI;
    return;
  }
}

void wb_erep::removeDb(pwr_tStatus *sts, wb_vrep *vrep)
{
  vrep_iterator it = m_vrepdb.find( vrep->vid());
  if ( it == m_vrepdb.end()) {
    *sts = LDH__NOSUCHVOL;
    return;
  }
  it->second->unref();
  m_vrepdb.erase( it);
  *sts = LDH__SUCCESS;
}

void wb_erep::removeDbs(pwr_tStatus *sts, wb_vrep *vrep)
{
  vrep_iterator it = m_vrepdbs.find( vrep->vid());
  if ( it == m_vrepdbs.end()) {
    *sts = LDH__NOSUCHVOL;
    return;
  }
  it->second->unref();
  m_vrepdbs.erase( it);
  *sts = LDH__SUCCESS;
}

void wb_erep::removeExtern(pwr_tStatus *sts, wb_vrep *vrep)
{
  vrep_iterator it = m_vrepextern.find( vrep->vid());
  if ( it == m_vrepextern.end()) {
    *sts = LDH__NOSUCHVOL;
    return;
  }
  it->second->unref();
  m_vrepextern.erase( it);
  *sts = LDH__SUCCESS;
}

void wb_erep::removeBuffer(pwr_tStatus *sts, wb_vrep *vrep)
{
  for ( buffer_iterator it = m_vrepbuffer.begin(); it != m_vrepbuffer.end(); it++) {
    if ( *it == vrep) {
      vrep->unref();
      m_vrepbuffer.erase( it);
      *sts = LDH__SUCCESS;
      return;
    }
  }
  *sts = LDH__NOSUCHVOL;
  return;
}

void wb_erep::load( pwr_tStatus *sts, char *db)
{
  loadDirList( sts);
  if ( EVEN(*sts)) return;
  else if ( *sts == LDH__PROJCONFIG) {
    pwr_tStatus status;
    loadCommonMeta( &status);
    if ( EVEN(status)) {
      *sts = status;
      return;
    }
    loadMeta( sts, db);
    bindMethods();
    loadLocalWb( sts);
    wb_vrepref *vrep = new wb_vrepref( this, ldh_cPlcMainVolume);
    addExtern( sts, vrep);
    vrep = new wb_vrepref( this, ldh_cPlcFoVolume);
    addExtern( sts, vrep);
    vrep = new wb_vrepref( this, ldh_cIoConnectVolume);
    addExtern( sts, vrep);
    return;
  }
  loadCommonMeta( sts);
  if ( EVEN(*sts)) return;

  loadMeta( sts, db);
  bindMethods();
  loadLocalWb( sts);

  wb_vrepref *vrep = new wb_vrepref( this, ldh_cPlcMainVolume);
  addExtern( sts, vrep);
  vrep = new wb_vrepref( this, ldh_cPlcFoVolume);
  addExtern( sts, vrep);
  vrep = new wb_vrepref( this, ldh_cIoConnectVolume);
  addExtern( sts, vrep);
}

void wb_erep::loadDirList( pwr_tStatus *status)
{
  // Read directory file
  char line[200];
  char fname[200];

  dcli_translate_filename( m_dir_list[0], "$pwr_load");
  strcat( m_dir_list[0], "/");
  m_dir_cnt = 1;

  dcli_translate_filename( fname, load_cNameFilePath);
  ifstream fp( fname, ios::in);
  if ( !fp) {
    *status = LDH__PROJCONFIG;
    return;
  }

  while ( fp.getline( line, sizeof(line))) {
    if ( m_dir_cnt > (int) (sizeof(m_dir_list)/sizeof(m_dir_list[0]) - 1))
      break;
    dcli_translate_filename( m_dir_list[m_dir_cnt], line);
    if ( m_dir_list[m_dir_cnt][strlen(m_dir_list[m_dir_cnt])-1] != '/')
      strcat( m_dir_list[m_dir_cnt], "/");
    m_dir_cnt++;
  }
  fp.close();
}

void wb_erep::loadCommonMeta( pwr_tStatus *status)
{
  char fname[200];
  char fdir[200];
  char vname[200];
  char line[200];
  int i;
  pwr_tVid vid;
  pwr_tStatus sts;

  for ( i = 0; i < m_dir_cnt; i++) {

    // Load metavolumes
    strcpy( fdir, m_dir_list[i]);
    strcpy( fname, fdir);
    strcat( fname, load_cNameCmnVolumeList);

    ifstream fpm( fname, ios::in);
    if ( !fpm) {
      if ( i == 0) {
        *status = LDH__NOBASE;
        return;
      }
      else
        continue;
    }
    while ( fpm.getline( line, sizeof(line))) {
      char vol_array[2][80];
      int nr;

      if ( line[0] == '#')
        continue;

      nr = dcli_parse( line, " ", "", (char *)vol_array,
                       sizeof(vol_array)/sizeof(vol_array[0]),
                       sizeof(vol_array[0]), 0);
      if ( nr != 2)
        MsgWindow::message( 'E', "Syntax error in file:", fname);

      // Load this volume
      cdh_ToLower( vol_array[0], vol_array[0]);
      strcpy( vname, fdir);
      strcat( vname, vol_array[0]);
      strcat( vname, ".dbs");
      cdh_StringToVolumeId( vol_array[1], &vid);

      wb_vrepdbs *vrep = new wb_vrepdbs( this, vname);
      try {
        vrep->load();
        addDbs( &sts, vrep);
        char buff[256];
	if ( cdh_isClassVolumeClass( vrep->cid()))
	  sprintf(buff, "Global class volume \"%s\" loaded from \"%s\"", vrep->dbsenv()->vp->name, vname);
	else
	  sprintf(buff, "Volume \"%s\" loaded from \"%s\"", vrep->dbsenv()->vp->name, vname);
        MsgWindow::message( 'O', buff);
      }
      catch ( wb_error& e) {
	if ( m_options & ldh_mWbOption_IgnoreDLoadError)
	  MsgWindow::message( 'I', "Unable to open class volume", vname);
	else
        MsgWindow::message( 'E', "Unable to open class volume", vname, e.what().c_str());
      }
    }
    fpm.close();
  }
  *status = LDH__SUCCESS;
}

void wb_erep::loadMeta( pwr_tStatus *status, char *db)
{
  // Load local metavolumes
  char found_file[200];
  char fname[200];
  char vname[200];
  char line[200];
  int i, j;
  pwr_tVid vid;
  pwr_tStatus sts;
  wb_vrepdbs *vrep;
  int vol_cnt = 0;
  eDbType db_type;
  int is_classvolume = 0;
  int load_externvolume;
  int load_dbs;
  int load_db;

  strcpy( fname, load_cNameVolumeList);
  dcli_translate_filename( fname, fname);

  // Load classvolumes first (j == 0) and then other volumes (j == 1)
  for ( j = 0; j < 2; j++) {
    ifstream fpm( fname, ios::in);
    if ( !fpm) {
      *status = LDH__PROJCONFIG;

      // Load directory volume
      strcpy( vname, "$pwrp_db/directory.wb_load");
      dcli_translate_filename( vname, vname);

      sts = dcli_search_file( vname, found_file, DCLI_DIR_SEARCH_INIT);
      dcli_search_file( vname, found_file, DCLI_DIR_SEARCH_END);
      if ( ODD(sts)) {
	wb_vrepmem *vrepmem = new wb_vrepmem( this);
	vrepmem->loadWbl( vname, &sts);
	vrepmem->name("directory");
	addDb( &sts, vrepmem);
	MsgWindow::message( 'I', "Directory database opened", vname);
      }

      return;
    }

    while ( fpm.getline( line, sizeof(line))) {
      char vol_array[7][80];
      int nr;

      if ( line[0] == '#')
	continue;

      nr = dcli_parse( line, " ", "", (char *)vol_array,
		       sizeof(vol_array)/sizeof(vol_array[0]),
		       sizeof(vol_array[0]), 0);
      if ( nr > 6)
	cout << "Syntax error in file: " << fname << endl;

      cdh_StringToVolumeId( vol_array[1], &vid);

      // Find out what to do with this volume
      load_externvolume = 0;
      load_dbs = 0;
      load_db = 0;
      if ( cdh_NoCaseStrcmp( vol_array[2], "ExternVolume") == 0 && j == 1)
	load_externvolume = 1;
      else if ( cdh_NoCaseStrcmp( vol_array[2], "ClassVolume") == 0 ||
		cdh_NoCaseStrcmp( vol_array[2], "DetachedClassVolume") == 0 ||
		strcmp( vol_array[3], "load") == 0) {
	if ( j == 0)
	  load_dbs = 1;
	if ( ((cdh_NoCaseStrcmp( vol_array[2], "ClassVolume") == 0 ||
	       cdh_NoCaseStrcmp( vol_array[2], "DetachedClassVolume") == 0) &&
	      ( strcmp( vol_array[3], "cnf") == 0 && 
		db && cdh_NoCaseStrcmp( db, vol_array[0]) == 0 ))) {
	  if ( j == 1)
	    load_db = 1;
	}
      }
      else if ( j == 1)
	load_db = 1;


      if ( load_externvolume) {
	if ( nr != 6)
	  cout << "Syntax error in file: " << fname << endl;

	// Load extern volume for this volume
	cdh_ToLower( vol_array[0], vol_array[0]);
	  
	try {
	  wb_vrepext *vrepext = new wb_vrepext( this, vid, vol_array[0], vol_array[4]);
	  addExtern( &sts, vrepext);
	  MsgWindow::message( 'O', "Volume loaded", vname);
	  vol_cnt++;
	}
	catch ( wb_error& e) {
	  MsgWindow::message( 'E', "Unable to open volume", vname, e.what().c_str());
	}
      }

      if ( load_dbs) {
	if ( nr < 4)
	  cout << "Syntax error in file: " << fname << endl;
	  
	// Load dbs for this volume
	cdh_ToLower( vol_array[0], vol_array[0]);
	  
	if ( strcmp( vol_array[3], "cnf") == 0) {
	  // Configured in this project, load from pwrp_load
	  strcpy( vname, "$pwrp_load/");
	  strcat( vname, vol_array[0]);
	  strcat( vname, ".dbs");
	  dcli_translate_filename( vname, vname);
	  
	  // Load...
	  try {
	    vrep = new wb_vrepdbs( this, vname);
	    vrep->load();
	    addDbs( &sts, vrep);
	    MsgWindow::message( 'O', "Volume loaded from snapshot file", vname);
	    vol_cnt++;
	  }
	  catch ( wb_error& e) {
	    if ( m_options & ldh_mWbOption_IgnoreDLoadError)
	      MsgWindow::message( 'I', "Unable to open volume snapshot file", vname);
	    else
	      MsgWindow::message( 'E', "Unable to open volume snapshot file", vname, e.what().c_str());
	  }
	}
	else {
	  // Imported loadfile
	  bool found = false;
	  for ( i = 0; i < m_dir_cnt; i++) {
	    strcpy( vname, m_dir_list[i]);
	    strcat( vname, vol_array[0]);
	    strcat( vname, ".dbs");
	    sts = dcli_search_file( vname, found_file, DCLI_DIR_SEARCH_INIT);
	    dcli_search_file( vname, found_file, DCLI_DIR_SEARCH_END);
	    if ( ODD(sts)) {
	      // Load...
	      found = true;
	      try {
		vrep = new wb_vrepdbs( this, vname);
		vrep->load();
		// vrep->name( vol_array[0]);
		addDbs( &sts, vrep);
		MsgWindow::message( 'O', "Volume loaded from snapshot file", vname);
	      }
	      catch ( wb_error& e) {
		if ( m_options & ldh_mWbOption_IgnoreDLoadError)
		  MsgWindow::message( 'I', "Unable to open volume snapshot file", vname);
		else
		  MsgWindow::message( 'E', "Unable to open volume snapshot file", vname, e.what().c_str());
	      }
	      break;
	    }
	  }
	  if ( !found)
	    MsgWindow::message( 'E', "Volume snapshotfile not found", vname);
	}
      }
      if ( load_db) {

	// Load db for this volume
	char uname[80];

	if ( nr < 4)
	  cout << "Syntax error in file: " << fname << endl;

	if ( db) {
	  // If db is specified, load only specified db, load as dbs instead
	  if ( cdh_NoCaseStrcmp( vol_array[0], db) != 0) {
	    cdh_ToLower( vol_array[0], vol_array[0]);
	    strcpy( vname, "$pwrp_load/");
	    strcat( vname, vol_array[0]);
	    strcat( vname, ".dbs");
	    sts = dcli_search_file( vname, found_file, DCLI_DIR_SEARCH_INIT);
	    dcli_search_file( vname, found_file, DCLI_DIR_SEARCH_END);
	    if ( ODD(sts)) {
	      // Load...
	      try {
		vrep = new wb_vrepdbs( this, found_file);
		vrep->load();
		// vrep->name( vol_array[0]);
		addDbs( &sts, vrep);
		MsgWindow::message( 'O', "Volume loaded from snapshot file", vname);
	      }
	      catch ( wb_error& e) {
		if ( m_options & ldh_mWbOption_IgnoreDLoadError)
		  MsgWindow::message( 'I', "Unable to open volume snapshot file", vname);
		else
		  MsgWindow::message( 'E', "Unable to open volume snapshot file", vname, e.what().c_str());
	      }
	    }
	    continue;
	  }
	}
	strcpy( vname, "$pwrp_db/");
	strcat( vname, vol_array[0]);
	cdh_ToLower( vname, vname);
	if ( cdh_NoCaseStrcmp( vol_array[2], "ClassVolume") == 0 ||
	     cdh_NoCaseStrcmp( vol_array[2], "DetchedClassVolume") == 0) {
	  is_classvolume = 1;
	  if ( nr >= 5 && vol_array[4][0] == '2')
	    db_type = eDbType_dbms;
	  else if ( nr >= 5 && vol_array[4][0] == '1')
	    db_type = eDbType_db;
	  else
	    db_type = eDbType_wbl;
	}
	else if ( strcmp( vol_array[3], "clone") == 0)
	  db_type = eDbType_none;
	else {
	  if ( nr >= 5 && vol_array[4][0] == '1')
	    db_type = eDbType_dbms;
	  else
	    db_type = eDbType_db;
	}
	switch ( db_type) {
	case eDbType_dbms:
	  strcat( vname, ".dbms");
	  break;
	case eDbType_db:
	  strcat( vname, ".db");
	  break;
	default:
	  strcat( vname, ".dbxx");
	}
	dcli_translate_filename( vname, vname);

	if ( db_type == eDbType_none) {
	  m_options |= ldh_mWbOption_OpenDbs;
	  sts = 1;
	}
	else {
	  sts = dcli_search_file( vname, found_file, DCLI_DIR_SEARCH_INIT);
	  dcli_search_file( vname, found_file, DCLI_DIR_SEARCH_END);
	}
	if ( EVEN(sts)) {
	  MsgWindow::message( 'E', "Database not found", vname);
	}
	else {
	  int open_loadfile = m_options & ldh_mWbOption_OpenDbs ? 1 : 0;

	  if ( wb_dblock::is_locked(vname, uname) &&  !open_loadfile) {
	    char msg[120];

	    sprintf( msg, "Database %s is locked by user %s", vol_array[0], uname);
	    MsgWindow::message( 'E', msg, msgw_ePop_No);

	    if ( ! MsgWindow::has_window())
	      exit(0);

	    CoWow *wow = MsgWindow::get_wow();
	    int res = wow->CreateModalDialog( "Database Locked", msg, "Exit", "Enter loadfile", "Remove lock", 
					      "$pwr_exe/wtt_padlock.png");
	    switch( res) {
	    case wow_eModalDialogReturn_Button1:
	    case wow_eModalDialogReturn_Deleted:
	      exit(0);
	    case wow_eModalDialogReturn_Button3:
	      // Remove lock
	      wb_dblock::dbunlock(vname);
	      break;
	    case wow_eModalDialogReturn_NYI:
	    case wow_eModalDialogReturn_Button2:
	      // Enter loadfile
	      open_loadfile = 1;
	      break;
	    }
	    
	  }

	  if ( open_loadfile) {
	    // Open dbs
	    cdh_ToLower( vol_array[0], vol_array[0]);
	    strcpy( vname, "$pwrp_load/");
	    strcat( vname, vol_array[0]);
	    strcat( vname, ".dbs");
	    dcli_translate_filename( vname, vname);
	    
	    try {
	      vrep = new wb_vrepdbs( this, vname);
	      vrep->load();
	      addDbs( &sts, vrep);
	      MsgWindow::message( 'I', "Volume loaded from snapshot file", vname);
	      vol_cnt++;
	    }
	    catch ( wb_error& e) {
	      if ( m_options & ldh_mWbOption_IgnoreDLoadError)
		MsgWindow::message( 'I', "Unable to open volume snapshot file", vname);
	      else
		MsgWindow::message( 'E', "Unable to open volume snapshot file", vname, e.what().c_str());
	    }
	  }
	  else {
	    // Open db

	    if ( nr >= 5 && db_type == eDbType_dbms) {
#if defined PWRE_CONF_MYSQL
	      if ( is_classvolume) {
		wb_vrepdbms *vrepdbms = new wb_vrepdbms( this, vname);
	    
		wb_vrepced *vrepced = new wb_vrepced( this, vrepdbms);
		vrepced->name(vol_array[0]);
		addDb( &sts, vrepced);
		MsgWindow::message( 'I', "Classvolume Database opened", vname);
		vol_cnt++;
		
	      }
	      else {
		wb_vrepdbms *vrepdbms = new wb_vrepdbms( this, vname);
		vrepdbms->name(vol_array[0]);
		addDb( &sts, vrepdbms);
		MsgWindow::message( 'I', "Database opened", vname);
		vol_cnt++;
	      }
#endif
	    }
	    else {
	      if ( is_classvolume) {
		wb_vrepdb *vrepdb = new wb_vrepdb( this, vname);
	    
		wb_vrepced *vrepced = new wb_vrepced( this, vrepdb);
		vrepced->name(vol_array[0]);
		addDb( &sts, vrepced);
		MsgWindow::message( 'I', "Classvolume Database opened", vname);
		vol_cnt++;
	      }
	      else {
		wb_vrepdb *vrepdb = new wb_vrepdb( this, vname);
		vrepdb->name(vol_array[0]);
		addDb( &sts, vrepdb);
		MsgWindow::message( 'I', "Database opened", vname);
		vol_cnt++;
	      }
	    }
	  }
	}
      }
    }
    fpm.close();
  }

  // Identify dbs that also is loaded as db
  vrep_iterator itdbs, itdb;

  for ( itdbs = m_vrepdbs.begin(); itdbs != m_vrepdbs.end(); itdbs++) {
    for ( itdb = m_vrepdb.begin(); itdb != m_vrepdb.end(); itdb++) {
      if ( itdbs->first == itdb->first)
	itdbs->second->setDuplicateDb( true);
    }
  }

  // Load directory volume

  if ( !db || (db && cdh_NoCaseStrcmp( "directory", db) == 0)) {
    char uname[80];

    strcpy( vname, "$pwrp_db/directory.wb_load");
    dcli_translate_filename( vname, vname);

    sts = dcli_search_file( vname, found_file, DCLI_DIR_SEARCH_INIT);
    dcli_search_file( vname, found_file, DCLI_DIR_SEARCH_END);
    if ( EVEN(sts)) {
      *status = LDH__PROJCONFIG;
      return;
    }
    if ( wb_dblock::is_locked(vname, uname)) {
      char msg[120];

      sprintf( msg, "Database directory is locked by user %s", uname);
      MsgWindow::message( 'E', msg, msgw_ePop_No);

      CoWow *wow = MsgWindow::get_wow();
      if ( wow) {
	int res = wow->CreateModalDialog( "Database Locked", msg, "Exit", 0, "Remove lock", "$pwr_exe/wtt_padlock.png");
	switch( res) {
	case wow_eModalDialogReturn_NYI:
	case wow_eModalDialogReturn_Button2:
	case wow_eModalDialogReturn_Button1:
	case wow_eModalDialogReturn_Deleted:
	  exit(0);
	case wow_eModalDialogReturn_Button3:
	  // Remove lock
	  wb_dblock::dbunlock(vname);
	  break;
	}    
      }
      else
	exit(0);
    }
      

    wb_vrepmem *vrepmem = new wb_vrepmem( this);
    vrepmem->loadWbl( vname, &sts);
    vrepmem->name("directory");
    addDb( &sts, vrepmem);
    MsgWindow::message( 'I', "Database opened", vname);
  }

  if ( !vol_cnt)
    *status = LDH__PROJCONFIG;
  else
    *status = LDH__SUCCESS;

}

void wb_erep::loadLocalWb( pwr_tStatus *rsts)
{
  pwr_tStatus sts;
  char found_file[200];

  sts = dcli_search_file( load_cNameLocalWb, found_file, DCLI_DIR_SEARCH_INIT);
  dcli_search_file( load_cNameLocalWb, found_file, DCLI_DIR_SEARCH_END);
  if ( ODD(sts)) {
    try {
      wb_vrepwbl *vrep = new wb_vrepwbl( this);
      sts = vrep->load( found_file);
      if ( ODD(sts))
        addExtern( &sts, vrep);
      else {
        *rsts = sts;
        MsgWindow::message('E', "Failiure loading local workbench volume");
        return;
      }
    }
    catch ( wb_error& e) {
      *rsts = e.sts();
      MsgWindow::message('E', "Failiure loading local workbench volume");
      return;
    }
  }
  *rsts = LDH__SUCCESS;
}

wb_cdrep *wb_erep::cdrep( pwr_tStatus *sts, const wb_orep& o)
{
  wb_vrep *vrep = volume(sts, o.vid());
  if ( EVEN(*sts)) return 0;

  return vrep->merep()->cdrep( sts, o);
}

wb_tdrep *wb_erep::tdrep( pwr_tStatus *sts, const wb_adrep& a)
{
  pwr_tVid vid = cdh_TidToVid(a.type());
  wb_vrep *vrep = volume(sts, vid);
  if ( EVEN(*sts)) return 0;

  return vrep->merep()->tdrep( sts, a);
}

wb_orep *wb_erep::object(pwr_tStatus *sts, pwr_tOid oid)
{
  wb_vrep *vrep = volume( sts, oid.vid);
  if ( EVEN(*sts)) return 0;

  return vrep->object( sts, oid);
}

wb_orep *wb_erep::object( pwr_tStatus *sts, const char *name)
{
  wb_name n(name);

  if ( n.evenSts()) {
    *sts = n.sts();
    return 0;
  }

  wb_vrep *vrep = volume( sts, n.volume());
  if ( EVEN(*sts)) return 0;

  return vrep->object( sts, n);
}

wb_orep *wb_erep::object(pwr_tStatus *sts, wb_name &name)
{
  if ( name.evenSts()) {
    *sts = name.sts();
    return 0;
  }

  wb_vrep *vrep = volume( sts, name.volume());
  if ( EVEN(*sts)) return 0;

  return vrep->object( sts, name);
}


void wb_erep::method( pwr_tStatus *sts, char *methodName, wb_tMethod *method)
{
  string key = string( methodName);
  methods_iterator it = m_methods.find( key);
  if ( it == m_methods.end()) {
    *sts = LDH__NOMETHOD;
    return;
  }
  *sts = LDH__SUCCESS;
  *method = it->second;
}

void wb_erep::bindMethods()
{
  int i, j;
  pwr_tStatus sts;
  char str[200];

  for (i = 0;; i++) {
    if (pwr_gSystem_ClassMethods[i].ClassName[0] == '\0')
      break;
    for (j = 0;; j++) {
      if ((*pwr_gSystem_ClassMethods[i].Methods)[j].MethodName[0] == '\0')
        break;
      strcpy( str, pwr_gSystem_ClassMethods[i].ClassName);
      strcat( str, "-");
      strcat( str, (*pwr_gSystem_ClassMethods[i].Methods)[j].MethodName);
      string key = string( str);
      m_methods[ key] = (*pwr_gSystem_ClassMethods[i].Methods)[j].Method;
    }
  }

  for (i = 0;; i++) {
    if (pwr_gBase_ClassMethods[i].ClassName[0] == '\0') break;
    wb_name cname = wb_name( pwr_gBase_ClassMethods[i].ClassName);
    wb_cdrep *cdrep = m_merep->cdrep( &sts, cname);
    if ( EVEN(sts))
      continue;

    for (j = 0;; j++) {
      if ((*pwr_gBase_ClassMethods[i].Methods)[j].MethodName[0] == '\0')
        break;
      strcpy( str, pwr_gBase_ClassMethods[i].ClassName);
      strcat( str, "-");
      strcat( str, (*pwr_gBase_ClassMethods[i].Methods)[j].MethodName);
      string key = string( str);
      m_methods[ key] = (*pwr_gBase_ClassMethods[i].Methods)[j].Method;
    }
    delete cdrep;
  }

#if PWR_DEBUG
  for (  methods_iterator it = m_methods.begin(); it != m_methods.end(); it++) {
    cout << " Method: " << it->first << endl;
  }
#endif
}

void wb_erep::printMethods()
{
  int i, j;

  printf("System Methods\n");
  for (i = 0;; i++) {
    if (pwr_gSystem_ClassMethods[i].ClassName[0] == '\0')
      break;
    printf( "%3d %-20s\n", i, pwr_gSystem_ClassMethods[i].ClassName);
    for (j = 0;; j++) {
      if ((*pwr_gSystem_ClassMethods[i].Methods)[j].MethodName[0] == '\0')
	break;
      printf( "       %s\n", (*pwr_gSystem_ClassMethods[i].Methods)[j].MethodName);
    }
  }

  printf( "Base Methods\n");
  for (i = 0;; i++) {
    if (pwr_gBase_ClassMethods[i].ClassName[0] == '\0') break;

    printf( "%3d %-20s\n", i, pwr_gBase_ClassMethods[i].ClassName);
    for (j = 0;; j++) {
      if ((*pwr_gBase_ClassMethods[i].Methods)[j].MethodName[0] == '\0')
	break;
      printf( "       %s\n", (*pwr_gBase_ClassMethods[i].Methods)[j].MethodName);
    }
  }
}

int wb_erep::nextVolatileVid( pwr_tStatus *sts, char *name)
{
  pwr_tVid vid = ldh_cVolatileVolMin + m_volatile_idx++;
  if ( vid > ldh_cVolatileVolMax) {
    // Recycle identities, and hope that the old volumes are history
    m_volatile_idx = 0;
    vid = ldh_cVolatileVolMin + m_volatile_idx++;
  }
  if ( name)
    // Suggest a name
    sprintf( name, "Buffer%03d", vid & 255);

  return vid;
}

wb_vrep *wb_erep::createVolume(pwr_tStatus *sts, pwr_tVid vid, pwr_tCid cid,
			       const char *name, ldh_eVolRep type, 
			       char *server, bool add)
{
  pwr_tFileName vname;

  if ( cid == pwr_eClass_DirectoryVolume) {
    vrep_iterator it = m_vrepdb.find( vid);
    if ( it != m_vrepdb.end()) {
      *sts = LDH__VOLIDALREXI;
      return 0;
    }

    strcpy( vname, "$pwrp_db/directory.wb_load");
    dcli_translate_filename( vname, vname);

    ofstream ofd( vname);
    ofd << "Volume directory $DirectoryVolume 254.254.254.253" << endl <<
      "EndVolume" << endl;    
    ofd.close();

    MsgWindow::message( 'I', "Database created", vname);

    wb_vrepmem *vrepmem = new wb_vrepmem( this);
    vrepmem->loadWbl( vname, sts);
    vrepmem->name("directory");
    if ( add)
      addDb( sts, vrepmem);
    return vrepmem;
  }
  else if ( type == ldh_eVolRep_Db) {
    sprintf( vname, "$pwrp_db/%s.db", cdh_Low(name));
    dcli_translate_filename( vname, vname);
    
    vrep_iterator it = m_vrepdb.find( vid);
    if ( it != m_vrepdb.end()) {
      *sts = LDH__VOLIDALREXI;
      return 0;
    }

    wb_vrepdb *vrepdb = new wb_vrepdb( this, vid, cid, name, vname);
    if ( add)
      addDb( sts, vrepdb);
    MsgWindow::message( 'I', "Database created", vname);

    return vrepdb;
  }
  else if ( type == ldh_eVolRep_Dbms) {
    char host[40] = "pwr42";
    char user[40] = "pwrp";
    char password[40] = "";
    unsigned int port = 0;
    char socket[80];

    cnf_get_value( "mysqlSocket", socket, sizeof(socket));
      
    *sts = lfu_ParseDbmsServer( server, user, password, &port, host);
    if ( EVEN(*sts)) return 0;

    printf( "Host: \"%s\"\nUser: \"%s\"\nPass: \"%s\"\nPort: %d\n", host, user, password, port);

    sprintf( vname, "$pwrp_db/%s.dbms", cdh_Low(name));
    dcli_translate_filename( vname, vname);
    
    vrep_iterator it = m_vrepdb.find( vid);
    if ( it != m_vrepdb.end()) {
      *sts = LDH__VOLIDALREXI;
      return 0;
    }

#if defined PWRE_CONF_MYSQL
    wb_dbms_env *env = new wb_dbms_env();
    env->create( vname, host, user, password, cdh_Low(name), port, socket);

    // wb_dbms *dbms = new wb_dbms();
    // dbms->create( vid, cid, dbname, vname);

    wb_vrepdbms *vrepdbms = new wb_vrepdbms( this, vid, cid, name, vname);
    if ( add)
      addDb( sts, vrepdbms);
    MsgWindow::message( 'I', "Database created", vname);


    return vrepdbms;
#endif
  }
  return 0;
}


void wb_erep::volumeNameToFilename( pwr_tStatus *sts, char *name, char *filename)
{
  char found_file[200];
  char vname[200];
  char line[200];
  char fname[200];
  char dir_list[11][200];
  int dir_cnt;
  int fsts;

  // Read directory file
  strcpy( dir_list[0], "$pwr_load/");
  strcpy( dir_list[1], "$pwrp_load/");
  dir_cnt = 2;

  dcli_translate_filename( fname, load_cNameFilePath);
  ifstream fp( fname, ios::in);
  if ( !fp) {
    *sts = LDH__PROJCONFIG;
    return;
  }

  while ( fp.getline( line, sizeof(line))) {
    if ( dir_cnt > (int) (sizeof(dir_list)/sizeof(dir_list[0]) - 1))
      break;
    strcpy( dir_list[dir_cnt], line);
    if ( dir_list[dir_cnt][strlen(dir_list[dir_cnt])-1] != '/')
      strcat( dir_list[dir_cnt], "/");
    dir_cnt++;
  }
  fp.close();

  for ( int i = 0; i < dir_cnt; i++) {
    strcpy( vname, dir_list[i]);
    cdh_ToLower( &vname[strlen(vname)], name);
    strcat( vname, ".dbs");
    fsts = dcli_search_file( vname, found_file, DCLI_DIR_SEARCH_INIT);
    dcli_search_file( vname, found_file, DCLI_DIR_SEARCH_END);
    if ( ODD(fsts)) {
      strcpy( filename, vname);
      *sts = LDH__SUCCESS;
      return;
    }
  }
  *sts = LDH__NOSUCHFILE;
}


void wb_erep::setRefMerep( wb_merep *merep)
{
  pwr_tStatus sts;
  m_ref_merep_occupied = true;

  wb_vrepref *vrepref = (wb_vrepref *) volume( &sts, ldh_cPlcMainVolume);
  if ( ODD(sts))
    vrepref->setMerep( merep);
  vrepref = (wb_vrepref *) volume( &sts, ldh_cPlcFoVolume);
  if ( ODD(sts))
    vrepref->setMerep( merep);
  vrepref = (wb_vrepref *) volume( &sts, ldh_cIoConnectVolume);
  if ( ODD(sts))
    vrepref->setMerep( merep);
}

void wb_erep::resetRefMerep()
{
  pwr_tStatus sts;
  m_ref_merep_occupied = false;

  wb_vrepref *vrepref = (wb_vrepref *) volume( &sts, ldh_cPlcMainVolume);
  if ( ODD(sts))
    vrepref->setMerep( m_merep);
  vrepref = (wb_vrepref *) volume( &sts, ldh_cPlcFoVolume);
  if ( ODD(sts))
    vrepref->setMerep( m_merep);
  vrepref = (wb_vrepref *) volume( &sts, ldh_cIoConnectVolume);
  if ( ODD(sts))
    vrepref->setMerep( m_merep);
}

bool wb_erep::check_lock( char *name, ldh_eVolDb type)
{
  char vname[200];

  sprintf( vname, "$pwrp_db/%s", cdh_Low(name));
  switch ( type) {
  case ldh_eVolDb_Db:
    strcat( vname, ".db");
    break;
  case ldh_eVolDb_Dbms:
    strcat( vname, ".dbms");
    break;
  default:
    return true;
  }
  dcli_translate_filename( vname, vname);
  return wb_dblock::check(vname);
}


void wb_erep::checkVolume( pwr_tStatus *sts, pwr_tVid vid, vector<wb_volcheck> &carray, int *err_cnt)
{
  lfu_t_volref *volref;
  int volref_cnt;
  pwr_tFileName fname;
  
  wb_vrep *vol = volume( sts, vid);
  if ( EVEN(*sts)) {
    MsgWindow::message( 'E', "Volume not loaded: ", cdh_VolumeIdToString( 0, vid, 0, 0));
    (*err_cnt)++;
    return;
  }

  wb_volcheck vcheck;
  
  switch ( vol->type()) {
  case ldh_eVolRep_Dbs: {
    vcheck.m_vid = vid;
    vcheck.m_time = ((wb_vrepdbs *)vol)->m_dbsvep->vp->time;
    strcpy( vcheck.m_vname, vol->name());
    strcpy( vcheck.m_filename, vol->fileName());
    break;
  }
  case ldh_eVolRep_Wbl:
  case ldh_eVolRep_Db:
  case ldh_eVolRep_Dbms: {    
    // Find dbs-file on $pwrp_load
    pwr_tFileName filestr;
    pwr_tVid vol_vid;
    pwr_tCid vol_cid;
    pwr_tTime vol_time;
    pwr_tObjName vol_name;
    pwr_tUInt32 vol_dvversion;

    volumeNameToFilename( sts, (char *)vol->name(), filestr);
	   
    *sts = lfu_GetVolume( filestr, vol_name, &vol_vid, &vol_cid, &vol_time, &vol_dvversion);
    if ( EVEN(*sts)) {
      MsgWindow::message( 'E', "Dbs file not found for volume ", cdh_VolumeIdToString( 0, vid, 0, 0));
      (*err_cnt)++;
      return;
    }

    vcheck.m_vid = vid;
    vcheck.m_cid = vol_cid;
    vcheck.m_time = vol_time;
    vcheck.m_dvversion = vol_dvversion;
    strcpy( vcheck.m_vname, vol->name());
    strcpy( vcheck.m_filename, filestr);

    break;
  }
  default:
    MsgWindow::message( 'E', "Strange volume type: ", cdh_VolumeIdToString( 0, vid, 0, 0));
    (*err_cnt)++;
  }

  // Check if volume is stored
  bool found = false;
  for ( int i = 0; i < (int) carray.size(); i++) {
    if ( carray[i].m_vid == vcheck.m_vid) {
      found = true;
      if ( carray[i].m_time.tv_sec != vcheck.m_time.tv_sec) {
      	char msg[200];
	sprintf( msg, "Version mismatch volume %s in %s and %s", vcheck.m_vname, vcheck.m_filename, carray[i].m_filename);
	MsgWindow::message( 'E', msg, msgw_ePop_No);
	(*err_cnt)++;
	*sts = LDH__VOLVERSION;
      }
    }
  }

  if ( !found)
    carray.push_back( vcheck);
  
  if ( vol->cid() == pwr_eClass_DetachedClassVolume)
    // No check of referenced volumes
    return;

  *sts = lfu_GetVolRef( vcheck.m_filename, &volref, &volref_cnt);
  if ( EVEN(*sts)) return;

  for ( int i = 0; i < volref_cnt; i++) {
    volumeNameToFilename( sts, volref[i].name, fname);
    if ( EVEN(*sts)) {
      char msg[200];
      sprintf( msg, "Loadfile not found: %s", volref[i].name);
      MsgWindow::message( 'E', msg, msgw_ePop_No);
      (*err_cnt)++;
      continue;
    }

    checkVolume( sts, volref[i].vid, carray, err_cnt);

    for ( int j = 0; j < (int)carray.size(); j++) {
      if ( carray[j].m_vid == volref[i].vid) {
	if ( carray[j].m_time.tv_sec != volref[i].version.tv_sec) {
	  char msg[200];
	  sprintf( msg, "Version mismatch volume %s in %s and %s", volref[i].name, vcheck.m_filename, carray[j].m_filename);
	  MsgWindow::message( 'E', msg, msgw_ePop_No);
	  (*err_cnt)++;
	  *sts = LDH__VOLVERSION;
	}
	break;
      }
    }
  }
  free( (char *)volref);
  
}

void wb_erep::checkVolumes( pwr_tStatus *sts, char *nodeconfigname)
{
  lfu_t_volumelist	*vollist;
  int			volcnt;
  vector<wb_volcheck>   carray;
  int 			err_cnt = 0;

  // Load the bootlist
  *sts = lfu_volumelist_load( load_cNameBootList, &vollist, &volcnt);
  if ( EVEN(*sts)) return;
  
  bool found = false;
  for ( int i = 0; i < volcnt; i++) {
    if ( cdh_NoCaseStrcmp( vollist[i].p1, nodeconfigname) == 0) {
      found = true;
      checkVolume( sts, vollist[i].volume_id, carray, &err_cnt);      
    }
  }

  if ( !found) {
    char msg[200];
    sprintf( msg, "No root volume found for node %s", nodeconfigname);
    MsgWindow::message( 'E', msg, msgw_ePop_Yes);
    *sts = LDH__NOSUCHVOL;
  }
  if ( err_cnt) {
    MsgWindow::map_default();
    *sts = LDH__VOLERR;
  }
}
