/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include "co_string.h"
#include "co_time.h"

#include "wb_rev_msg.h"
#include "wb_wrevnav.h"

//
//  Free pixmaps
//
void WRevNavBrow::free_pixmaps()
{
  brow_FreeAnnotPixmap(ctx, pixmap_leaf);
  brow_FreeAnnotPixmap(ctx, pixmap_map);
  brow_FreeAnnotPixmap(ctx, pixmap_openmap);
  brow_FreeAnnotPixmap(ctx, pixmap_attr);
  brow_FreeAnnotPixmap(ctx, pixmap_current);
  brow_FreeAnnotPixmap(ctx, pixmap_warning);
  brow_FreeAnnotPixmap(ctx, pixmap_currentbranch);
}

//
//  Create pixmaps for leaf, closed map and open map
//
void WRevNavBrow::allocate_pixmaps()
{
  brow_LoadPBMs(ctx, "xnav_bitmap_leaf", &pixmap_leaf);
  brow_LoadPBMs(ctx, "xnav_bitmap_map", &pixmap_map);
  brow_LoadPBMs(ctx, "xnav_bitmap_openmap", &pixmap_openmap);
  brow_LoadPBMs(ctx, "xnav_bitmap_attr", &pixmap_attr);
  brow_LoadPBMs(ctx, "xnav_bitmap_current", &pixmap_current);
  brow_LoadPBMs(ctx, "xnav_bitmap_warning", &pixmap_warning);
  brow_LoadPBMs(ctx, "xnav_bitmap_morehelp", &pixmap_currentbranch);
}

void WRevNavBrow::brow_setup()
{
  brow_sAttributes brow_attr;
  unsigned long mask;

  mask = 0;
  mask |= brow_eAttr_indentation;
  brow_attr.indentation = 0.5;
  mask |= brow_eAttr_annotation_space;
  brow_attr.annotation_space = 0.5;
  brow_SetAttributes(ctx, &brow_attr, mask);
  brow_SetCtxUserData(ctx, wrevnav);
}

//
// Create nodeclasses
//
void WRevNavBrow::create_nodeclasses()
{
  allocate_pixmaps();

  // Create common-class

  brow_CreateNodeClass(
      ctx, "NavigatorDefault", flow_eNodeGroup_Common, &nc_object);
  brow_AddAnnotPixmap(nc_object, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap(nc_object, 1, 1.1, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot(nc_object, 2, 0.6, 0, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_object, 7, 0.6, 1, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 1);
  brow_AddAnnot(nc_object, 11, 0.6, 2, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 1);
  brow_AddFrame(nc_object, 0, 0, 20, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Create table nodeclass

  brow_CreateNodeClass(
      ctx, "NavigatorTable", flow_eNodeGroup_Common, &nc_table);
  brow_AddAnnotPixmap(nc_table, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap(nc_table, 1, 1.1, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot(nc_table, 2, 0.6, 0, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_table, 8, 0.6, 1, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 1);
  brow_AddAnnot(nc_table, 12, 0.6, 2, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 1);
  brow_AddAnnot(nc_table, 16, 0.6, 3, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 1);
  brow_AddAnnot(nc_table, 20, 0.6, 4, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 1);
  brow_AddAnnot(nc_table, 24, 0.6, 5, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 1);
  brow_AddAnnot(nc_table, 28, 0.6, 6, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 1);
  brow_AddAnnot(nc_table, 32, 0.6, 7, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 1);
  brow_AddAnnot(nc_table, 35, 0.6, 8, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 1);
  brow_AddAnnot(nc_table, 38, 0.6, 9, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 1);
  brow_AddFrame(nc_table, 0, 0, 20, 0.83, flow_eDrawType_LineGray, -1, 1);
}

void WRevNav::message(char sev, const char* text)
{
  (message_cb)(parent_ctx, sev, text);
}
//
//  Get current zoom factor
//
void WRevNav::get_zoom(double* zoom_factor)
{
  brow_GetZoom(brow->ctx, zoom_factor);
}

//
//  Zoom
//
void WRevNav::zoom(double zoom_factor)
{
  brow_Zoom(brow->ctx, zoom_factor);
}

//
//  Return to base zoom factor
//
void WRevNav::unzoom()
{
  brow_UnZoom(brow->ctx);
}

//
// Create the navigator widget
//
WRevNav::WRevNav(void* wa_parent_ctx, ldh_tSession wa_ldhses,
    const char* wa_name, wb_eUtility wa_utility, pwr_tStatus* status)
    : parent_ctx(wa_parent_ctx), ldhses(wa_ldhses), message_cb(0),
      set_clock_cursor_cb(0), reset_cursor_cb(0), utility(wa_utility),
      displayed(0), rev(0)
{
  strcpy(name, wa_name);
  *status = 1;
}

//
//  Delete a nav context
//
WRevNav::~WRevNav()
{
}

//
// Callbacks from brow
//
int WRevNav::brow_cb(FlowCtx* ctx, flow_tEvent event)
{
  WRevNav* wrevnav;
  WItemRev* item;

  if (event->event == flow_eEvent_ObjectDeleted) {
    brow_GetUserData(event->object.object, (void**)&item);
    delete item;
    return 1;
  }

  brow_GetCtxUserData((BrowCtx*)ctx, (void**)&wrevnav);
  wrevnav->message(' ', "");
  switch (event->event) {
  case flow_eEvent_Key_Up: {
    brow_tNode* node_list;
    int node_count;
    brow_tObject object;
    int sts;

    brow_GetSelectedNodes(wrevnav->brow->ctx, &node_list, &node_count);
    if (!node_count) {
      sts = brow_GetLast(wrevnav->brow->ctx, &object);
      if (EVEN(sts))
        return 1;
    } else {
      sts = brow_GetPrevious(wrevnav->brow->ctx, node_list[0], &object);
      if (EVEN(sts)) {
        if (node_count)
          free(node_list);
        return 1;
      }
    }
    brow_SelectClear(wrevnav->brow->ctx);
    brow_SetInverse(object, 1);
    brow_SelectInsert(wrevnav->brow->ctx, object);
    if (!brow_IsVisible(wrevnav->brow->ctx, object, flow_eVisible_Full))
      brow_CenterObject(wrevnav->brow->ctx, object, 0.25);
    if (node_count)
      free(node_list);
    break;
  }
  case flow_eEvent_Key_Down: {
    brow_tNode* node_list;
    int node_count;
    brow_tObject object;
    int sts;

    brow_GetSelectedNodes(wrevnav->brow->ctx, &node_list, &node_count);
    if (!node_count) {
      sts = brow_GetFirst(wrevnav->brow->ctx, &object);
      if (EVEN(sts))
        return 1;
    } else {
      sts = brow_GetNext(wrevnav->brow->ctx, node_list[0], &object);
      if (EVEN(sts)) {
        if (node_count)
          free(node_list);
        return 1;
      }
    }
    brow_SelectClear(wrevnav->brow->ctx);
    brow_SetInverse(object, 1);
    brow_SelectInsert(wrevnav->brow->ctx, object);
    if (!brow_IsVisible(wrevnav->brow->ctx, object, flow_eVisible_Full))
      brow_CenterObject(wrevnav->brow->ctx, object, 0.75);
    if (node_count)
      free(node_list);
    break;
  }
  case flow_eEvent_SelectClear:
    brow_ResetSelectInverse(wrevnav->brow->ctx);
    break;
  case flow_eEvent_MB1Click: {
    // Select
    double ll_x, ll_y, ur_x, ur_y;
    int sts;

    switch (event->object.object_type) {
    case flow_eObjectType_Node:
      brow_MeasureNode(event->object.object, &ll_x, &ll_y, &ur_x, &ur_y);
      if (event->object.x < ll_x + 1.0) {
        // Simulate doubleclick
        flow_tEvent doubleclick_event;

        doubleclick_event = (flow_tEvent)calloc(1, sizeof(*doubleclick_event));
        memcpy(doubleclick_event, event, sizeof(*doubleclick_event));
        doubleclick_event->event = flow_eEvent_MB1DoubleClick;
        sts = brow_cb(ctx, doubleclick_event);
        free((char*)doubleclick_event);
        return sts;
      }

      if (brow_FindSelectedObject(wrevnav->brow->ctx, event->object.object)) {
        brow_SelectClear(wrevnav->brow->ctx);
      } else {
        brow_SelectClear(wrevnav->brow->ctx);
        brow_SetInverse(event->object.object, 1);
        brow_SelectInsert(wrevnav->brow->ctx, event->object.object);
      }
      break;
    default:
      brow_SelectClear(wrevnav->brow->ctx);
    }
    break;
  }
  case flow_eEvent_Key_Left: {
    brow_tNode* node_list;
    int node_count;
    brow_tObject object;
    int sts;

    brow_GetSelectedNodes(wrevnav->brow->ctx, &node_list, &node_count);
    if (!node_count)
      return 1;

    if (brow_IsOpen(node_list[0]))
      // Close this node
      object = node_list[0];
    else {
      // Close parent
      sts = brow_GetParent(wrevnav->brow->ctx, node_list[0], &object);
      if (EVEN(sts)) {
        free(node_list);
        return 1;
      }
    }
    brow_GetUserData(object, (void**)&item);
    item->close(wrevnav->brow, 0, 0);
    brow_SelectClear(wrevnav->brow->ctx);
    brow_SetInverse(object, 1);
    brow_SelectInsert(wrevnav->brow->ctx, object);
    if (!brow_IsVisible(wrevnav->brow->ctx, object, flow_eVisible_Full))
      brow_CenterObject(wrevnav->brow->ctx, object, 0.25);
    free(node_list);
    break;
  }
  case flow_eEvent_Key_Right: {
    brow_tNode* node_list;
    int node_count;
    int sts;

    brow_GetSelectedNodes(wrevnav->brow->ctx, &node_list, &node_count);
    if (!node_count)
      return 1;

    brow_GetUserData(node_list[0], (void**)&item);
    (wrevnav->set_clock_cursor_cb)(wrevnav->parent_ctx);
    sts = item->open_children(wrevnav->brow, wrevnav->rev, 0, 0);
    (wrevnav->reset_cursor_cb)(wrevnav->parent_ctx);

    free(node_list);
    break;
  }
  case flow_eEvent_Key_ShiftRight: {
    brow_tNode* node_list;
    int node_count;
    int sts;

    brow_GetSelectedNodes(wrevnav->brow->ctx, &node_list, &node_count);
    if (!node_count)
      return 1;

    brow_GetUserData(node_list[0], (void**)&item);
    (wrevnav->set_clock_cursor_cb)(wrevnav->parent_ctx);
    sts = item->open_attributes(wrevnav->brow, 0, 0);
    (wrevnav->reset_cursor_cb)(wrevnav->parent_ctx);

    free(node_list);
    break;
  }
  case flow_eEvent_MB1DoubleClick:
    switch (event->object.object_type) {
    case flow_eObjectType_Node:
      brow_GetUserData(event->object.object, (void**)&item);
      (wrevnav->set_clock_cursor_cb)(wrevnav->parent_ctx);
      item->open_children(
          wrevnav->brow, wrevnav->rev, event->object.x, event->object.y);
      (wrevnav->reset_cursor_cb)(wrevnav->parent_ctx);
      break;
    default:;
    }
    break;
  case flow_eEvent_MB1ClickShift: {
    // Add elect
    switch (event->object.object_type) {
    case flow_eObjectType_Node:
      if (brow_FindSelectedObject(wrevnav->brow->ctx, event->object.object)) {
        brow_SetInverse(event->object.object, 0);
        brow_SelectRemove(wrevnav->brow->ctx, event->object.object);
      } else {
        brow_SetInverse(event->object.object, 1);
        brow_SelectInsert(wrevnav->brow->ctx, event->object.object);
      }
      break;
    default:;
    }
    break;
  }
  case flow_eEvent_MB1Press:
    // Select region
    brow_SetSelectInverse(wrevnav->brow->ctx);
    break;
  case flow_eEvent_MB1PressShift:
    // Add select region
    brow_SetSelectInverse(wrevnav->brow->ctx);
    break;
  case flow_eEvent_Key_PageDown: {
    brow_Page(wrevnav->brow->ctx, 0.8);
    break;
  }
  case flow_eEvent_Key_PageUp: {
    brow_Page(wrevnav->brow->ctx, -0.8);
    break;
  }
  case flow_eEvent_ScrollDown: {
    brow_Page(wrevnav->brow->ctx, 0.1);
    break;
  }
  case flow_eEvent_ScrollUp: {
    brow_Page(wrevnav->brow->ctx, -0.1);
    break;
  }
  case flow_eEvent_Map: {
    wrevnav->displayed = 1;
    break;
  }

  default:;
  }
  return 1;
}

int WRevNav::root_objects()
{
  brow_tObject* object_list;
  int object_cnt;

  brow_SetNodraw(brow->ctx);

  brow_DeleteAll(brow->ctx);
  if (rev)
    delete rev;

  rev = new wb_revision(this, (wb_session*)ldhses);
  rev->command_cb(rev_command_cb);

  for (int i = 0; i < rev->size(); i++) {
    wb_rev_item* rev_item = rev->vect(i);
    WItemRevision* item = new WItemRevision(brow, rev_item->name,
        rev_item->description, rev_item->date, rev_item->version,
        rev_item->current, rev_item->current_branch, rev_item->in_manager,
        rev_item->vect.size(), 0, flow_eDest_IntoLast);
    if (rev_item->current_branch)
      item->open_children(brow, rev, 0, 0);
  }

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);

  brow_GetObjectList(brow->ctx, &object_list, &object_cnt);
  for (int i = 0; i < object_cnt; i++) {
    WItemRevision* item;

    brow_GetUserData(object_list[i], (void**)&item);
    if (item->current) {
      brow_CenterObject(brow->ctx, object_list[i], 0.75);
      break;
    }
  }
  return REV__SUCCESS;
}

void WRevNav::enable_events()
{
  brow_EnableEvent(
      brow->ctx, flow_eEvent_MB1Click, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_MB1DoubleClick, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_MB1Press, flow_eEventType_RegionSelect, brow_cb);
  brow_EnableEvent(brow->ctx, flow_eEvent_MB1PressShift,
      flow_eEventType_RegionAddSelect, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_MB1ClickShift, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_SelectClear, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_ObjectDeleted, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_Key_Up, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_Key_Down, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_Key_Right, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_Key_ShiftRight, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_Key_Left, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_Key_PageUp, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_Key_PageDown, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_ScrollUp, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_ScrollDown, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_Map, flow_eEventType_CallBack, brow_cb);
}

//
// Backcall routine called at creation of the brow widget
// Enable event, create nodeclasses and insert the root objects.
//
int WRevNav::init_brow_cb(FlowCtx* fctx, void* client_data)
{
  WRevNav* wrevnav = (WRevNav*)client_data;
  BrowCtx* ctx = (BrowCtx*)fctx;

  wrevnav->brow = new WRevNavBrow(ctx, (void*)wrevnav);

  wrevnav->brow->brow_setup();
  wrevnav->brow->create_nodeclasses();
  wrevnav->enable_events();

  // Create the root item
  wrevnav->root_objects();

  return 1;
}

void WRevNav::redraw()
{
  brow_Redraw(brow->ctx, 0);
}

void WRevNav::refresh_node(WItemRev* item)
{
  if (brow_IsOpen(item->node)) {
    item->close(brow, 0, 0);
    item->open_children(brow, rev, 0, 0);
  }
}

WItemRev* WRevNav::get_parent(WItemRev* item)
{
  brow_tObject parent_node;
  WItemRev* parent;
  int sts;

  sts = brow_GetParent(brow->ctx, item->node, &parent_node);
  if (EVEN(sts))
    return 0;
  brow_GetUserData(parent_node, (void**)&parent);

  return parent;
}

int WRevNav::get_select(WItemRev*** items, int* item_cnt)
{
  brow_tNode* node_list;
  int node_count;
  WItemRev *item, **itemlist;

  brow_GetSelectedNodes(brow->ctx, &node_list, &node_count);
  if (node_count == 0) {
    *items = 0;
    return REV__NOSELECT;
  }
  itemlist = (WItemRev**)calloc(node_count, sizeof(WItemRev*));
  for (int i = 0; i < node_count; i++) {
    brow_GetUserData(node_list[i], (void**)&item);
    itemlist[i] = item;
  }
  *item_cnt = node_count;
  *items = itemlist;
  return REV__SUCCESS;
}

int WRevNav::rev_command_cb(void* ctx, char* cmd)
{
  WRevNav* revnav = (WRevNav*)((wb_revision*)ctx)->parent_ctx();

  if (revnav->command_cb)
    return (revnav->command_cb)(revnav, cmd);
  return 0;
}

WItemRev::WItemRev() : node(0), children(0)
{
}

int WItemRev::open_children(
    WRevNavBrow* brow, wb_revision* rev, double x, double y)
{
  return 1;
}

int WItemRev::open_attributes(WRevNavBrow* brow, double x, double y)
{
  return 1;
}

WItemRev::~WItemRev()
{
}

int WItemRev::close(WRevNavBrow* brow, double x, double y)
{
  double node_x, node_y;

  if (brow_IsOpen(node)) {
    // Close
    brow_GetNodePosition(node, &node_x, &node_y);
    brow_SetNodraw(brow->ctx);
    brow_CloseNode(brow->ctx, node);
    if (brow_IsOpen(node) & wnav_mOpen_Children) {
      if (children)
        brow_SetAnnotPixmap(node, 0, brow->pixmap_map);
      else
        brow_SetAnnotPixmap(node, 0, brow->pixmap_leaf);
    }
    brow_ResetOpen(node, wnav_mOpen_All);
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, node_y);
  }
  return 1;
}

WItemRevision::WItemRevision(WRevNavBrow* brow, char* item_name,
    char* item_description, pwr_tTime item_date, char* item_version,
    bool item_current, bool item_current_branch, bool item_in_manager,
    int item_children, brow_tNode dest, flow_eDest dest_code)
    : current(item_current), current_branch(item_current_branch),
      in_manager(item_in_manager)
{
  strcpy(name, item_name);
  strcpy(description, item_description);
  time_AtoAscii(&item_date, time_eFormat_DateAndTime, time, sizeof(time));
  time[20] = 0;
  strcpy(version, item_version);
  children = item_children;

  brow_CreateNode(
      brow->ctx, name, brow->nc_table, dest, dest_code, (void*)this, 1, &node);
  if (children)
    brow_SetAnnotPixmap(node, 0, brow->pixmap_map);
  else
    brow_SetAnnotPixmap(node, 0, brow->pixmap_leaf);
  brow_SetAnnotation(node, 0, name, strlen(name));
  brow_SetAnnotation(node, 1, time, strlen(time));
  brow_SetAnnotation(node, 3, description, strlen(description));
  if (current)
    brow_SetAnnotPixmap(node, 1, brow->pixmap_current);
  if (current_branch)
    brow_SetAnnotPixmap(node, 1, brow->pixmap_currentbranch);
  else if (!in_manager)
    brow_SetAnnotPixmap(node, 1, brow->pixmap_warning);
}

int WItemRevision::open_children(
    WRevNavBrow* brow, wb_revision* rev, double x, double y)
{
  WItemRevision* item;

  if (brow_IsOpen(node)) {
    close(brow, 0, 0);
    return 1;
  }

  if (!children)
    return 1;

  // Find in revision
  wb_rev_item* rev_item = NULL;
  bool found = false;
  for (int i = 0; i < rev->size(); i++) {
    rev_item = rev->vect(i);
    if (streq(rev_item->name, name)) {
      found = true;
      break;
    }
  }
  if (!found)
    return 1;

  brow_SetNodraw(brow->ctx);

  for (unsigned int i = 0; i < rev_item->vect.size(); i++) {
    item = new WItemRevision(brow, rev_item->vect[i].name,
        rev_item->vect[i].description, rev_item->vect[i].date,
        rev_item->vect[i].version, rev_item->vect[i].current,
        rev_item->vect[i].current_branch, rev_item->vect[i].in_manager,
        rev_item->vect[i].vect.size(), node, flow_eDest_IntoLast);
  }
  brow_SetOpen(node, wnav_mOpen_Children);
  brow_SetAnnotPixmap(node, 0, brow->pixmap_openmap);

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
  return 1;
}

int WItemRevision::open_attributes(WRevNavBrow* brow, double x, double y)
{
  WItemRevAttr* item;
  char status[80];

  if (brow_IsOpen(node)) {
    close(brow, 0, 0);
    return 1;
  }

  brow_SetNodraw(brow->ctx);

  item = new WItemRevAttr(
      brow, "Description", description, node, flow_eDest_IntoLast);
  item = new WItemRevAttr(brow, "Time", time, node, flow_eDest_IntoLast);
  if (current)
    strcpy(status, "Current");
  else if (!in_manager)
    strcpy(status, "Not found in repository");
  else
    strcpy(status, "");

  item = new WItemRevAttr(brow, "Status", status, node, flow_eDest_IntoLast);
  item = new WItemRevAttr(brow, "Version", version, node, flow_eDest_IntoLast);
  brow_SetOpen(node, wnav_mOpen_Attributes);

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
  return 1;
}

WItemRevAttr::WItemRevAttr(WRevNavBrow* brow, const char* item_name,
    char* item_value, brow_tNode dest, flow_eDest dest_code)
{
  strcpy(name, item_name);
  strcpy(value, item_value);

  brow_CreateNode(
      brow->ctx, name, brow->nc_object, dest, dest_code, (void*)this, 1, &node);
  brow_SetAnnotPixmap(node, 0, brow->pixmap_attr);
  brow_SetAnnotation(node, 0, name, strlen(name));
  brow_SetAnnotation(node, 1, value, strlen(value));
}

WItemRevAttr::~WItemRevAttr()
{
}
