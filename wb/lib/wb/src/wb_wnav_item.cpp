/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <stdlib.h>

#include "pwr_baseclasses.h"
#include "pwr_systemclasses.h"

#include "co_dcli.h"
#include "co_nav_msg.h"
#include "co_string.h"
#include "co_time.h"

#include "wb_wtt.h"
#include "wb_wnav_item.h"
#include "wb_wnav_msg.h"
#include "wb_session.h"
#include "wb_merep.h"
#include "wb_error.h"

// Definition of item classes
// The following classes are defined:
//    WItem		superclass.
//    WItemObject	Common object.

#define item_eType_ObjectName 1000000
#define item_eType_Other 1000001

static int item_get_reflist_object(
    wb_session* sp, pwr_tCid cid, char* attr, pwr_sClass_ReferenceList* op)
{
  pwr_tOName oname;
  bool found = false;
  wb_object listo;
  char* s;

  for (wb_cdef c = sp->cdef(cid); c; c = c.super()) {
    wb_object o = sp->object(cdh_ClassIdToObjid(cid));
    if (!o)
      return WNAV__NOCHILDREN;

    strcpy(oname, c.longName().name(cdh_mName_volumeStrict));
    strcat(oname, "-");
    if ((s = strrchr(attr, '.')))
      strcat(oname, s + 1);
    else
      strcat(oname, attr);

    listo = sp->object(oname);
    if (listo) {
      found = true;
      break;
    }
  }

  if (!found)
    return WNAV__NOCHILDREN;

  wb_attribute a = sp->attribute(listo.oid(), "SysBody");
  a.value(op);

  return WNAV__SUCCESS;
}

static bool item_check_configure_method(ldh_tSession ldhses, pwr_tOid oid)
{
  pwr_tOName name, method;
  pwr_tCid cid;
  pwr_tStatus sts;
  int size;

  ldh_GetObjectClass(ldhses, oid, &cid);

  for (sts = 1; ODD(sts); sts = ldh_GetSuperClass(ldhses, cid, &cid)) {
    sts = ldh_ObjidToName(ldhses, cdh_ClassIdToObjid(cid), ldh_eName_VolPath,
        name, sizeof(name), &size);
    if (EVEN(sts))
      return false;

    for (int i = 0; i < 3; i++) {
      strcpy(method, name);
      switch (i) {
      case 0:
        strcat(method, "-ConfiguratorPosos-Pointed-ConfigureComponent");
        break;
      case 1:
        strcat(method, "-ConfiguratorPosos-Pointed-ConfigureDevice");
        break;
      case 2:
        strcat(method, "-ConfiguratorPosos-Pointed-ConfigureSlave");
        break;
      }

      sts = ldh_NameToObjid(ldhses, &oid, method);
      if (ODD(sts))
        return true;
    }
  }
  return false;
}

//
// Member functions for WItem
//
WItem::WItem(pwr_tObjid item_objid, int item_is_root)
    : type(wnav_eItemType_Object), objid(item_objid), is_root(item_is_root),
      node(NULL)
{
}

WItem::~WItem()
{
}

int WItem::open_attributes(WNav* wnav, double x, double y)
{
  return 1;
}

int WItem::open_children(WNav* wnav, double x, double y)
{
  return 1;
}

int WItem::open_trace(WNav* wnav, double x, double y)
{
  return 1;
}

void WItem::close(WNav* wnav, double x, double y)
{
}

pwr_sAttrRef WItem::aref()
{
  pwr_sAttrRef a = pwr_cNAttrRef;
  a.Objid = objid;
  a.Flags.b.Object = 1;
  return a;
}

//
// Member functions for WItemObject
//
WItemObject::WItemObject(WNav* wnav, pwr_tObjid item_objid, brow_tNode dest,
    flow_eDest dest_code, int item_is_root)
    : WItemBaseObject(item_objid, item_is_root)
{
  int sts;
  char segname[120];
  pwr_tObjid child;
  pwr_tClassId classid;
  pwr_tEnum *config_status_p, *safety_level_p;
  pwr_tEnum config_status, safety_level;
  char* descr;
  char descr_str[200];
  int size;
  int next_annot, next_pixmap;
  ldh_sRefInfo ref_info;
  char buf[80];
  brow_tNodeClass nc = NULL;
  pwr_tObjName body;

  type = wnav_eItemType_Object;

  sts = ldh_ObjidToName(
      wnav->ldhses, objid, ldh_eName_Hierarchy, name, sizeof(name), &size);
  if (!is_root) {
    sts = ldh_GetObjectClass(wnav->ldhses, objid, &classid);
    sts = ldh_ObjidToName(
        wnav->ldhses, objid, ldh_eName_Object, segname, sizeof(segname), &size);

    // Get ConfigStatus
    config_status = 0;
    for (int i = 0; i < 3; i++) {
      switch (i) {
      case 0:
        strcpy(body, "DevBody");
        break;
      case 1:
        strcpy(body, "SysBody");
        break;
      case 2:
        strcpy(body, "RtBody");
        break;
      }
      sts = ldh_GetObjectPar(wnav->ldhses, objid, body, "ConfigurationStatus",
          (char**)&config_status_p, &size);
      if (ODD(sts)) {
        config_status = *config_status_p;
        free((char*)config_status_p);
        break;
      }
    }
    // Get SafetyLevel
    safety_level = 0;
    for (int i = 0; i < 3; i++) {
      switch (i) {
      case 0:
        strcpy(body, "DevBody");
        break;
      case 1:
        strcpy(body, "SysBody");
        break;
      case 2:
        strcpy(body, "RtBody");
        break;
      }
      sts = ldh_GetObjectPar(wnav->ldhses, objid, body, "SafetyLevel",
          (char**)&safety_level_p, &size);
      if (ODD(sts)) {
        safety_level = *safety_level_p;
        free((char*)safety_level_p);
        break;
      }
    }
    if (config_status == 0) {
      switch (safety_level) {
      case pwr_eSafetyLevel_None:
        nc = wnav->brow->nc_multiobject[wnav_eMultiobject_Normal];
        break;
      case pwr_eSafetyLevel_Low:
        nc = wnav->brow->nc_multiobject[wnav_eMultiobject_YellowTriangle];
        break;
      case pwr_eSafetyLevel_High:
        nc = wnav->brow->nc_multiobject[wnav_eMultiobject_RedTriangle];
        break;
      }
      strcpy(descr_str, "");
    } else {
      // Get enum text
      ldh_sParDef adef;
      ldh_sValueDef* vd;
      int rows;

      sts = ldh_GetAttrDef(
          wnav->ldhses, classid, body, "ConfigurationStatus", &adef);
      if (EVEN(sts))
        return;

      sts = ldh_GetEnumValueDef(
          wnav->ldhses, adef.Par->Param.TypeRef, &vd, &rows);
      if (EVEN(sts))
        return;

      bool found = false;
      int i;
      for (i = 0; i < rows; i++) {
        if (vd[i].Value.Value == config_status) {
          found = true;
          break;
        }
      }

      if (found) {
        if (config_status < 100) {
          switch (safety_level) {
          case pwr_eSafetyLevel_None:
            nc = wnav->brow->nc_multiobject[wnav_eMultiobject_RedSquare];
            break;
          case pwr_eSafetyLevel_Low:
            nc = wnav->brow->nc_multiobject
                     [wnav_eMultiobject_RedSquare_YellowTriangle];
            break;
          case pwr_eSafetyLevel_High:
            nc = wnav->brow
                     ->nc_multiobject[wnav_eMultiobject_RedSquare_RedTriangle];
            break;
          }
        } else if (config_status < 200) {
          switch (safety_level) {
          case pwr_eSafetyLevel_None:
            nc = wnav->brow->nc_multiobject[wnav_eMultiobject_YellowSquare];
            break;
          case pwr_eSafetyLevel_Low:
            nc = wnav->brow->nc_multiobject
                     [wnav_eMultiobject_YellowSquare_YellowTriangle];
            break;
          case pwr_eSafetyLevel_High:
            nc = wnav->brow->nc_multiobject
                     [wnav_eMultiobject_YellowSquare_RedTriangle];
            break;
          }
        } else {
          switch (safety_level) {
          case pwr_eSafetyLevel_None:
            nc = wnav->brow->nc_multiobject[wnav_eMultiobject_GreenSquare];
            break;
          case pwr_eSafetyLevel_Low:
            nc = wnav->brow->nc_multiobject
                     [wnav_eMultiobject_GreenSquare_YellowTriangle];
            break;
          case pwr_eSafetyLevel_High:
            nc = wnav->brow->nc_multiobject
                     [wnav_eMultiobject_GreenSquare_RedTriangle];
            break;
          }
        }
        sprintf(descr_str, "<%s> ", vd[i].Value.Text);
      } else {
        nc = wnav->brow->nc_multiobject_red;
        strcpy(descr_str, "<Unknown status>  ");
      }
      free((char*)vd);
    }

    brow_CreateNode(
        wnav->brow->ctx, segname, nc, dest, dest_code, (void*)this, 1, &node);

    // Set pixmap
    sts = ldh_GetChildMnt(wnav->ldhses, objid, &child);
    if (ODD(sts))
      brow_SetAnnotPixmap(node, 0, wnav->brow->pixmap_map);
    else
      brow_SetAnnotPixmap(node, 0, wnav->brow->pixmap_leaf);
    // Set object name annotation
    brow_SetAnnotation(node, 0, segname, strlen(segname));

    next_annot = 1;

    // Set class annotation
    if (wnav->gbl.show_class) {
      ldh_tSession ldhses;

      // Objects in mounted volumes has to use its own metavolumes.
      if (ldh_ExternObject(wnav->ldhses, objid))
        ldh_OpenMntSession(wnav->ldhses, objid, &ldhses);
      else
        ldhses = wnav->ldhses;

      sts = ldh_ObjidToName(ldhses, cdh_ClassIdToObjid(classid),
          ldh_eName_Object, segname, sizeof(segname), &size);
      brow_SetAnnotation(node, next_annot++, segname, strlen(segname));

      if (ldhses != wnav->ldhses)
        ldh_CloseSession(ldhses);
    }

    // Set description annotation
    if (wnav->gbl.show_descrip) {
      sts = ldh_GetObjectPar(
          wnav->ldhses, objid, "RtBody", "Description", &descr, &size);
      if (EVEN(sts))
        sts = ldh_GetObjectPar(
            wnav->ldhses, objid, "DevBody", "Description", &descr, &size);
      if (EVEN(sts))
        sts = ldh_GetObjectPar(
            wnav->ldhses, objid, "SysBody", "Description", &descr, &size);
      if (ODD(sts)) {
        strcat(descr_str, descr);
        free(descr);
      }
      if (!streq(descr_str, ""))
        brow_SetAnnotation(node, next_annot++, descr_str, strlen(descr_str));
    }
    if (wnav->gbl.show_alias && classid == pwr_eClass_Alias) {
      pwr_tOName alias_name;
      pwr_tObjid* ref_object;

      sts = ldh_GetObjectPar(
          wnav->ldhses, objid, "RtBody", "Object", (char**)&ref_object, &size);
      if (ODD(sts)) {
        sts = ldh_ObjidToName(wnav->ldhses, *ref_object, ldh_eName_Hierarchy,
            alias_name, sizeof(alias_name), &size);
        if (EVEN(sts))
          strcpy(alias_name, "-");
        free((char*)ref_object);
        brow_SetAnnotation(node, next_annot++, alias_name, strlen(alias_name));
      }
    }

    next_pixmap = 2;
    next_annot = next_pixmap + 2;

    if (wnav->gbl.show_objref || wnav->gbl.show_objxref
        || wnav->gbl.show_attrref || wnav->gbl.show_attrxref)
      sts = ldh_GetReferenceInfo(wnav->ldhses, objid, &ref_info);

    if (wnav->gbl.show_objref) {
      if (ref_info.ObjRef.Total) {
        if (ref_info.ObjRef.Errors)
          brow_SetAnnotPixmap(node, next_pixmap++, wnav->brow->pixmap_ref_err);
        else
          brow_SetAnnotPixmap(node, next_pixmap++, wnav->brow->pixmap_ref);
        sprintf(buf, "%d:%d", ref_info.ObjRef.Used, ref_info.ObjRef.Total);
        brow_SetAnnotation(node, next_annot++, buf, strlen(buf));
      } else {
        next_pixmap++;
        next_annot++;
      }
    }
    if (wnav->gbl.show_objxref) {
      if (ref_info.ObjXRef.Total) {
        if (ref_info.ObjXRef.Errors)
          brow_SetAnnotPixmap(
              node, next_pixmap++, wnav->brow->pixmap_crossref_err);
        else
          brow_SetAnnotPixmap(node, next_pixmap++, wnav->brow->pixmap_crossref);
        sprintf(buf, "%d:%d", ref_info.ObjXRef.Used, ref_info.ObjXRef.Total);
        brow_SetAnnotation(node, next_annot++, buf, strlen(buf));
      } else {
        next_pixmap++;
        next_annot++;
      }
    }
    if (wnav->gbl.show_attrref) {
      if (ref_info.AttrRef.Total) {
        if (ref_info.AttrRef.Errors)
          brow_SetAnnotPixmap(
              node, next_pixmap++, wnav->brow->pixmap_attrref_err);
        else
          brow_SetAnnotPixmap(node, next_pixmap++, wnav->brow->pixmap_attrref);
        sprintf(buf, "%d:%d", ref_info.AttrRef.Used, ref_info.AttrRef.Total);
        brow_SetAnnotation(node, next_annot++, buf, strlen(buf));
      } else {
        next_pixmap++;
        next_annot++;
      }
    }
    if (wnav->gbl.show_attrxref) {
      if (ref_info.AttrXRef.Total) {
        if (ref_info.AttrXRef.Errors)
          brow_SetAnnotPixmap(
              node, next_pixmap++, wnav->brow->pixmap_attrxref_err);
        else
          brow_SetAnnotPixmap(node, next_pixmap++, wnav->brow->pixmap_attrxref);
        sprintf(buf, "%d:%d", ref_info.AttrXRef.Used, ref_info.AttrXRef.Total);
        brow_SetAnnotation(node, next_annot++, buf, strlen(buf));
      } else {
        next_pixmap++;
        next_annot++;
      }
    }
  }
  if (wnav->editmode && item_check_configure_method(wnav->ldhses, objid))
    brow_SetAnnotPixmap(node, 1, wnav->brow->pixmap_confcomp);
}

WItemObject::~WItemObject()
{
}

WItemBaseObject::WItemBaseObject(pwr_tObjid item_objid, int item_is_root)
    : WItem(item_objid, item_is_root)
{
}

WItemBaseObject::~WItemBaseObject()
{
}

int WItemBaseObject::open_children(WNav* wnav, double x, double y)
{
  double node_x, node_y;
  pwr_tObjid child;
  int child_exist;
  int sts;

  if (cdh_ObjidIsNull(objid))
    return 1;

  if (!is_root)
    brow_GetNodePosition(node, &node_x, &node_y);
  else
    node_y = 0;

  if (!is_root && brow_IsOpen(node)) {
    // Close
    brow_SetNodraw(wnav->brow->ctx);
    brow_CloseNode(wnav->brow->ctx, node);
    if (brow_IsOpen(node) & wnav_mOpen_Attributes)
      brow_RemoveAnnotPixmap(node, 1);
    if (brow_IsOpen(node) & wnav_mOpen_Children)
      brow_SetAnnotPixmap(node, 0, wnav->brow->pixmap_map);
    if (wnav->editmode && item_check_configure_method(wnav->ldhses, objid))
      brow_SetAnnotPixmap(node, 1, wnav->brow->pixmap_confcomp);
    brow_ResetOpen(node, wnav_mOpen_All);
    brow_ResetNodraw(wnav->brow->ctx);
    brow_Redraw(wnav->brow->ctx, node_y);
  } else {
    // Create some children
    brow_SetNodraw(wnav->brow->ctx);

    child_exist = 0;
    sts = ldh_GetChildMnt(wnav->ldhses, objid, &child);
    while (ODD(sts)) {
      child_exist = 1;
      new WItemObject(wnav, child, node, flow_eDest_IntoLast, 0);
      sts = ldh_GetNextSibling(wnav->ldhses, child, &child);
    }

    if (child_exist && !is_root) {
      brow_SetOpen(node, wnav_mOpen_Children);
      brow_SetAnnotPixmap(node, 0, wnav->brow->pixmap_openmap);
    }
    brow_ResetNodraw(wnav->brow->ctx);
    if (child_exist)
      brow_Redraw(wnav->brow->ctx, node_y);
    else
      return WNAV__NOCHILD;
  }
  return 1;
}

int WItemBaseObject::open_attributes(WNav* wnav, double x, double y)
{
  double node_x, node_y;

  if (cdh_ObjidIsNull(objid))
    return 1;

  brow_GetNodePosition(node, &node_x, &node_y);

  if (brow_IsOpen(node) & wnav_mOpen_Attributes) {
    // Attributes is open, close
    brow_SetNodraw(wnav->brow->ctx);
    brow_CloseNode(wnav->brow->ctx, node);
    brow_ResetOpen(node, wnav_mOpen_Attributes);
    brow_RemoveAnnotPixmap(node, 1);
    if (wnav->editmode && item_check_configure_method(wnav->ldhses, objid))
      brow_SetAnnotPixmap(node, 1, wnav->brow->pixmap_confcomp);
    brow_ResetNodraw(wnav->brow->ctx);
    brow_Redraw(wnav->brow->ctx, node_y);
  } else {
    int sts;
    char parname[80];
    pwr_tClassId classid;
    unsigned long elements;
    ldh_sParDef* bodydef;
    int rows;
    WItem* item;
    int i, j;
    char body[20];
    int attr_exist = 0;
    int input_cnt = 0;
    int output_cnt = 0;
    char* block;
    int size;
    ldh_tSession ldhses;

    if (brow_IsOpen(node) & wnav_mOpen_Children
        || brow_IsOpen(node) & wnav_mOpen_Crossref) {
      // Close children first
      brow_SetNodraw(wnav->brow->ctx);
      brow_CloseNode(wnav->brow->ctx, node);
      brow_ResetOpen(node, wnav_mOpen_Children);
      brow_ResetOpen(node, wnav_mOpen_Crossref);
      brow_SetAnnotPixmap(node, 0, wnav->brow->pixmap_map);
      brow_ResetNodraw(wnav->brow->ctx);
      brow_Redraw(wnav->brow->ctx, node_y);
    }

    // Create some attributes
    brow_SetNodraw(wnav->brow->ctx);

    // Objects in mounted volumes has to use its own metavolumes.
    if (ldh_ExternObject(wnav->ldhses, objid))
      ldh_OpenMntSession(wnav->ldhses, objid, &ldhses);
    else
      ldhses = wnav->ldhses;

    // Display object name
    if (wnav->editmode) {
      item = (WItem*)new WItemObjectName(
          wnav->brow, ldhses, objid, node, flow_eDest_IntoLast);
      attr_exist = 1;
    }
    // Display modification time
    if (wnav->gbl.show_truedb) {
      item = (WItem*)new WItemObjectModTime(
          wnav->brow, ldhses, objid, node, flow_eDest_IntoLast);
      attr_exist = 1;
    }

    // Get bodydef for rtbody, devbody or sysbody

    sts = ldh_GetObjectClass(ldhses, objid, &classid);
    if (EVEN(sts))
      return sts;

    for (i = 0; i < 3; i++) {
      if (i == 0)
        strcpy(body, "RtBody");
      else if (i == 1)
        strcpy(body, "DevBody");
      else
        strcpy(body, "SysBody");

      if (wnav->gbl.show_truedb)
        sts = ldh_GetTrueObjectBodyDef(
            ldhses, classid, body, 1, &bodydef, &rows);
      else
        sts = ldh_GetObjectBodyDef(ldhses, classid, body, 1, &bodydef, &rows);
      if (EVEN(sts))
        continue;
      for (j = 0; j < rows; j++) {
        strcpy(parname, bodydef[j].ParName);
        //        sts = ldh_GetObjectPar( ldhses, objid, body, parname,
        //		(char **)&attr_p, &size);

        if (bodydef[j].Flags & ldh_mParDef_Shadowed)
          continue;
        if (bodydef[j].Par->Output.Info.Flags & PWR_MASK_POINTER)
          continue;
        if (bodydef[j].Par->Output.Info.Flags & PWR_MASK_INVISIBLE
            && !wnav->gbl.show_truedb)
          continue;
        if (bodydef[j].Par->Output.Info.Flags & PWR_MASK_DISABLEATTR
            && !wnav->gbl.show_truedb && j > 0) {
          pwr_tDisableAttr disabled;
          pwr_sAttrRef aar;
          pwr_sAttrRef ar = cdh_ObjidToAref(objid);

          sts = ldh_ArefANameToAref(ldhses, &ar, parname, &aar);
          if (EVEN(sts))
            return sts;

          sts = ldh_AttributeDisabled(ldhses, &aar, &disabled);
          if (EVEN(sts))
            return sts;

          if (disabled)
            continue;
        }

        if (bodydef[j].Par->Output.Info.Flags & PWR_MASK_ARRAY) {
          elements = bodydef[j].Par->Output.Info.Elements;

          if (bodydef[j].ParClass == pwr_eClass_Output) {
            new WItemAttrArrayOutput(wnav->brow, wnav->ldhses, objid, node,
                flow_eDest_IntoLast, parname,
                bodydef[j].Par->Output.Info.Elements,
                bodydef[j].Par->Output.Info.Type,
                bodydef[j].Par->Output.TypeRef,
                bodydef[j].Par->Output.Info.Size,
                bodydef[j].Par->Output.Info.Flags, body, output_cnt);
            output_cnt++;
          } else
            new WItemAttrArray(wnav->brow, wnav->ldhses, objid, node,
                flow_eDest_IntoLast, parname,
                bodydef[j].Par->Output.Info.Elements,
                bodydef[j].Par->Output.Info.Type,
                bodydef[j].Par->Output.TypeRef,
                bodydef[j].Par->Output.Info.Size,
                bodydef[j].Par->Output.Info.Flags, body, 0);
          attr_exist = 1;
        } else if (bodydef[j].ParClass == pwr_eClass_Input) {
          if (bodydef[j].Par->Input.Info.Type == pwr_eType_Boolean) {
            if (bodydef[j].Par->Input.Info.Flags & PWR_MASK_NOREMOVE
                && bodydef[j].Par->Input.Info.Flags & PWR_MASK_NOINVERT)
              new WItemAttr(wnav->brow, wnav->ldhses, objid, node,
                  flow_eDest_IntoLast, parname, bodydef[j].Par->Input.Info.Type,
                  bodydef[j].Par->Input.TypeRef,
                  bodydef[j].Par->Input.Info.Size,
                  bodydef[j].Par->Input.Info.Flags, body, 0);
            else if (bodydef[j].Par->Input.Info.Flags & PWR_MASK_NOREMOVE)
              new WItemAttrInputInv(wnav->brow, wnav->ldhses, objid, node,
                  flow_eDest_IntoLast, parname, bodydef[j].Par->Input.Info.Type,
                  bodydef[j].Par->Input.TypeRef,
                  bodydef[j].Par->Input.Info.Size,
                  bodydef[j].Par->Input.Info.Flags, body, input_cnt);
            else if (bodydef[j].Par->Input.Info.Flags & PWR_MASK_NOINVERT)
              new WItemAttrInputF(wnav->brow, wnav->ldhses, objid, node,
                  flow_eDest_IntoLast, parname, bodydef[j].Par->Input.Info.Type,
                  bodydef[j].Par->Input.TypeRef,
                  bodydef[j].Par->Input.Info.Size,
                  bodydef[j].Par->Input.Info.Flags, body, input_cnt);
            else
              new WItemAttrInput(wnav->brow, wnav->ldhses, objid, node,
                  flow_eDest_IntoLast, parname, bodydef[j].Par->Input.Info.Type,
                  bodydef[j].Par->Input.TypeRef,
                  bodydef[j].Par->Input.Info.Size,
                  bodydef[j].Par->Input.Info.Flags, body, input_cnt);
          } else {
            if (bodydef[j].Par->Input.Info.Flags & PWR_MASK_NOREMOVE)
              new WItemAttr(wnav->brow, wnav->ldhses, objid, node,
                  flow_eDest_IntoLast, parname, bodydef[j].Par->Input.Info.Type,
                  bodydef[j].Par->Input.TypeRef,
                  bodydef[j].Par->Input.Info.Size,
                  bodydef[j].Par->Input.Info.Flags, body, 0);
            else
              new WItemAttrInputF(wnav->brow, wnav->ldhses, objid, node,
                  flow_eDest_IntoLast, parname, bodydef[j].Par->Input.Info.Type,
                  bodydef[j].Par->Input.TypeRef,
                  bodydef[j].Par->Input.Info.Size,
                  bodydef[j].Par->Input.Info.Flags, body, input_cnt);
          }
          attr_exist = 1;
          input_cnt++;
        } else if (bodydef[j].ParClass == pwr_eClass_Output) {
          if (bodydef[j].Par->Output.Info.Flags & PWR_MASK_NOREMOVE)
            new WItemAttr(wnav->brow, wnav->ldhses, objid, node,
                flow_eDest_IntoLast, parname, bodydef[j].Par->Output.Info.Type,
                bodydef[j].Par->Output.TypeRef,
                bodydef[j].Par->Output.Info.Size,
                bodydef[j].Par->Output.Info.Flags, body, 0);
          else
            new WItemAttrOutput(wnav->brow, wnav->ldhses, objid, node,
                flow_eDest_IntoLast, parname, bodydef[j].Par->Output.Info.Type,
                bodydef[j].Par->Output.TypeRef,
                bodydef[j].Par->Output.Info.Size,
                bodydef[j].Par->Output.Info.Flags, body, output_cnt);
          attr_exist = 1;
          output_cnt++;
        } else {
          if (bodydef[j].Par->Output.Info.Flags & PWR_MASK_CLASS)
            new WItemAttrObject(wnav->brow, wnav->ldhses, objid, node,
                flow_eDest_IntoLast, parname, bodydef[j].Par->Output.Info.Type,
                bodydef[j].Par->Output.Info.Size, false, 0,
                bodydef[j].Par->Output.Info.Flags, body, 0);
          else
            new WItemAttr(wnav->brow, wnav->ldhses, objid, node,
                flow_eDest_IntoLast, parname, bodydef[j].Par->Output.Info.Type,
                bodydef[j].Par->Output.TypeRef,
                bodydef[j].Par->Output.Info.Size,
                bodydef[j].Par->Output.Info.Flags, body, 0);
          attr_exist = 1;
        }
      }
      free((char*)bodydef);

      sts = ldh_GetDocBlock(ldhses, objid, &block, &size);
      if (ODD(sts)) {
        new WItemDocBlock(wnav->brow, wnav->ldhses, objid, block, size, node,
            flow_eDest_IntoLast);
        attr_exist = 1;
      }
    }

    if (ldhses != wnav->ldhses)
      ldh_CloseSession(ldhses);

    if (attr_exist && !is_root) {
      brow_SetOpen(node, wnav_mOpen_Attributes);
      brow_SetAnnotPixmap(node, 1, wnav->brow->pixmap_openattr);
    }
    brow_ResetNodraw(wnav->brow->ctx);
    brow_Redraw(wnav->brow->ctx, node_y);
  }
  return 1;
}

int WItemBaseObject::open_crossref(WNav* wnav, double x, double y)
{
  double node_x, node_y;
  int crossref_exist;
  int sts;
  pwr_tClassId classid;

  if (cdh_ObjidIsNull(objid))
    return 1;

  if (!is_root)
    brow_GetNodePosition(node, &node_x, &node_y);
  else
    node_y = 0;

  if (!is_root && brow_IsOpen(node)) {
    // Close
    brow_SetNodraw(wnav->brow->ctx);
    brow_CloseNode(wnav->brow->ctx, node);
    if (brow_IsOpen(node) & wnav_mOpen_Attributes) {
      brow_RemoveAnnotPixmap(node, 1);
      if (wnav->editmode && item_check_configure_method(wnav->ldhses, objid))
        brow_SetAnnotPixmap(node, 1, wnav->brow->pixmap_confcomp);
    }
    if (brow_IsOpen(node) & wnav_mOpen_Children) {
      brow_SetAnnotPixmap(node, 0, wnav->brow->pixmap_map);
      if (wnav->editmode && item_check_configure_method(wnav->ldhses, objid))
        brow_SetAnnotPixmap(node, 1, wnav->brow->pixmap_confcomp);
    }
    brow_ResetOpen(node, wnav_mOpen_All);
    brow_ResetNodraw(wnav->brow->ctx);
    brow_Redraw(wnav->brow->ctx, node_y);
  } else {
    // Fetch the cross reference list
    crossref_exist = 0;
    brow_SetNodraw(wnav->brow->ctx);

    sts = ldh_GetObjectClass(wnav->ldhses, objid, &classid);
    if (EVEN(sts))
      return sts;

    switch (classid) {
    case pwr_cClass_Di:
    case pwr_cClass_Dv:
    case pwr_cClass_Do:
    case pwr_cClass_Po:
    case pwr_cClass_Av:
    case pwr_cClass_Ai:
    case pwr_cClass_Ao:
    case pwr_cClass_Co:
    case pwr_cClass_Iv:
    case pwr_cClass_Ii:
    case pwr_cClass_Io:
    case pwr_cClass_Sv:
    case pwr_cClass_ATv:
    case pwr_cClass_DTv:
      sts = wnav->crr_signal(wnav->brow, wnav->ldhses, NULL, name, node);
      break;
    default:
      sts = wnav->crr_object(wnav->brow, wnav->ldhses, NULL, name, node);
    }
    if (sts == NAV__OBJECTNOTFOUND)
      wnav->message('E', "Object not found in crossreferens file");
    else if (sts == NAV__NOCROSSREF)
      wnav->message('I', "There is no crossreferences for this object");
    else if (ODD(sts)) {
      brow_SetOpen(node, wnav_mOpen_Crossref);
      crossref_exist = 1;
    }
    brow_ResetNodraw(wnav->brow->ctx);
    if (crossref_exist)
      brow_Redraw(wnav->brow->ctx, node_y);
  }
  return 1;
}

int WItemBaseObject::close(WNav* wnav, double x, double y)
{
  double node_x, node_y;

  if (cdh_ObjidIsNull(objid))
    return 1;

  if (brow_IsOpen(node)) {
    // Close
    brow_GetNodePosition(node, &node_x, &node_y);
    brow_SetNodraw(wnav->brow->ctx);
    brow_CloseNode(wnav->brow->ctx, node);
    if (brow_IsOpen(node) & wnav_mOpen_Attributes)
      brow_RemoveAnnotPixmap(node, 1);
    if (brow_IsOpen(node) & wnav_mOpen_Children)
      brow_SetAnnotPixmap(node, 0, wnav->brow->pixmap_map);
    if (wnav->editmode && item_check_configure_method(wnav->ldhses, objid))
      brow_SetAnnotPixmap(node, 1, wnav->brow->pixmap_confcomp);
    brow_ResetOpen(node, wnav_mOpen_All);
    brow_ResetNodraw(wnav->brow->ctx);
    brow_Redraw(wnav->brow->ctx, node_y);
  }
  return 1;
}

int WItemBaseObject::open_attribute(
    WNav* wnav, double x, double y, char* attr_name, int element)
{
  return 1;
}

WItemMenu::WItemMenu(WNav* wnav, const char* item_name, brow_tNode dest,
    flow_eDest dest_code, wnav_sMenu** item_child_list, int item_is_root)
    : WItem(pwr_cNObjid, item_is_root), child_list(item_child_list)
{
  type = wnav_eItemType_Menu;
  strcpy(name, item_name);
  if (!is_root) {
    brow_CreateNode(wnav->brow->ctx, name, wnav->brow->nc_object, dest,
        dest_code, (void*)this, 1, &node);

    // Set pixmap
    if (*child_list)
      brow_SetAnnotPixmap(node, 0, wnav->brow->pixmap_map);
    else
      brow_SetAnnotPixmap(node, 0, wnav->brow->pixmap_leaf);
    // Set object name annotation
    brow_SetAnnotation(node, 0, name, strlen(name));
  }
}

WItemMenu::~WItemMenu()
{
}

int WItemMenu::open_children(WNav* wnav, double x, double y)
{
  int action_open = 0;

  if (!is_root) {
    if (!brow_IsOpen(node))
      action_open = 1;
    else
      action_open = 0;
  }
  if (action_open || is_root) {
    // Display childlist
    WItem* item;
    wnav_sMenu* menu;

    menu = *child_list;
    while (menu) {
      switch (menu->item_type) {
      case wnav_eItemType_Menu:
        item = (WItem*)new WItemMenu(
            wnav, menu->title, node, flow_eDest_IntoLast, &menu->child_list, 0);
        break;
      case wnav_eItemType_Command:
        item = (WItem*)new WItemCommand(wnav, menu->title, node,
            flow_eDest_IntoLast, menu->command, 0, wnav->brow->pixmap_graph);
        break;
      default:;
      }
      menu = menu->next;
      if (!is_root) {
        brow_SetOpen(node, wnav_mOpen_Children);
        brow_SetAnnotPixmap(node, 0, wnav->brow->pixmap_openmap);
      }
    }
  } else
    close(wnav, x, y);
  return 1;
}

int WItemMenu::close(WNav* wnav, double x, double y)
{
  double node_x, node_y;

  if (brow_IsOpen(node)) {
    // Close
    brow_GetNodePosition(node, &node_x, &node_y);
    brow_SetNodraw(wnav->brow->ctx);
    brow_CloseNode(wnav->brow->ctx, node);
    if (brow_IsOpen(node) & wnav_mOpen_Attributes)
      brow_RemoveAnnotPixmap(node, 1);
    if (brow_IsOpen(node) & wnav_mOpen_Children)
      brow_SetAnnotPixmap(node, 0, wnav->brow->pixmap_map);
    brow_ResetOpen(node, wnav_mOpen_All);
    brow_ResetNodraw(wnav->brow->ctx);
    brow_Redraw(wnav->brow->ctx, node_y);
  }
  return 1;
}

WItemCommand::WItemCommand(WNav* wnav, const char* item_name, brow_tNode dest,
    flow_eDest dest_code, char* item_command, int item_is_root,
    flow_sAnnotPixmap* pixmap)
    : WItem(pwr_cNObjid, item_is_root)
{
  type = wnav_eItemType_Command;

  strcpy(command, item_command);
  strcpy(name, item_name);
  if (!is_root) {
    brow_CreateNode(wnav->brow->ctx, "command_item", wnav->brow->nc_object,
        dest, dest_code, (void*)this, 1, &node);

    // Set pixmap
    brow_SetAnnotPixmap(node, 0, pixmap);
    // Set object name annotation
    brow_SetAnnotation(node, 0, name, strlen(name));
  }
}

WItemCommand::~WItemCommand()
{
}

int WItemCommand::open_children(WNav* wnav, double x, double y)
{
  wnav->command(command);
  return 1;
}

WItemLocal::WItemLocal(WNav* wnav, const char* item_name, const char* attr,
    int attr_type, int attr_size, double attr_min_limit, double attr_max_limit,
    void* attr_value_p, brow_tNode dest, flow_eDest dest_code)
    : WItem(pwr_cNObjid, 0), value_p(attr_value_p), first_scan(1),
      type_id(attr_type), size(attr_size), min_limit(attr_min_limit),
      max_limit(attr_max_limit)
{
  type = wnav_eItemType_Local;

  strcpy(name, item_name);
  memset(old_value, 0, sizeof(old_value));

  //  sts = wnav->ldb.add( attr, attr_type, value_p);
  //  if (EVEN(sts)) return;

  brow_CreateNode(wnav->brow->ctx, item_name, wnav->brow->nc_attr, dest,
      dest_code, (void*)this, 1, &node);

  brow_SetAnnotPixmap(node, 0, wnav->brow->pixmap_attr);

  brow_SetAnnotation(node, 0, item_name, strlen(item_name));
  brow_SetTraceAttr(node, attr, "", flow_eTraceType_User);
}

WItemLocal::~WItemLocal()
{
}

WItemText::WItemText(WNavBrow* brow, const char* item_name, char* text,
    brow_tNode dest, flow_eDest dest_code)
    : WItem(pwr_cNObjid, 0)
{
  type = wnav_eItemType_Text;
  strcpy(name, item_name);
  brow_CreateNode(brow->ctx, "text", brow->nc_object, dest, dest_code,
      (void*)this, 1, &node);
  brow_SetAnnotation(node, 0, text, strlen(text));
}

WItemText::~WItemText()
{
}

WItemHeader::WItemHeader(WNavBrow* brow, const char* item_name,
    const char* title, brow_tNode dest, flow_eDest dest_code)
    : WItem(pwr_cNObjid, 0)
{
  type = wnav_eItemType_Header;
  strcpy(name, item_name);
  brow_CreateNode(brow->ctx, "header", brow->nc_header, dest, dest_code,
      (void*)this, 1, &node);
  brow_SetAnnotation(node, 0, title, strlen(title));
}

WItemHeader::~WItemHeader()
{
}

WItemHeaderLarge::WItemHeaderLarge(WNavBrow* brow, const char* item_name,
    char* title, brow_tNode dest, flow_eDest dest_code)
    : WItem(pwr_cNObjid, 0)
{
  type = wnav_eItemType_HeaderLarge;
  strcpy(name, item_name);
  brow_CreateNode(brow->ctx, "header", brow->nc_headerlarge, dest, dest_code,
      (void*)this, 1, &node);
  brow_SetAnnotation(node, 0, title, strlen(title));
}

WItemHeaderLarge::~WItemHeaderLarge()
{
}

WItemVolume::WItemVolume(
    WNav* wnav, pwr_tVolumeId item_volid, brow_tNode dest, flow_eDest dest_code)
    : WItem(pwr_cNObjid, 0), volid(item_volid)
{
  int sts;
  char name[120];
  char classname[40];
  pwr_tClassId classid;
  int size;

  type = wnav_eItemType_Volume;

  sts = ldh_VolumeIdToName(wnav->wbctx, volid, name, sizeof(name), &size);

  brow_CreateNode(wnav->brow->ctx, name, wnav->brow->nc_object, dest, dest_code,
      (void*)this, 1, &node);

  // Set pixmap
  brow_SetAnnotPixmap(node, 0, wnav->brow->pixmap_map);

  // Set object name annotation
  brow_SetAnnotation(node, 0, name, strlen(name));

  // Set class annotation
  sts = ldh_GetVolumeClass(wnav->wbctx, volid, &classid);
  switch (classid) {
  case pwr_eClass_ClassVolume:
    strcpy(classname, "ClassVolume");
    break;
  case pwr_eClass_DetachedClassVolume:
    strcpy(classname, "DetachedClassVolume");
    break;
  case pwr_eClass_WorkBenchVolume:
    strcpy(classname, "WorkBenchVolume");
    break;
  case pwr_eClass_RootVolume:
    strcpy(classname, "RootVolume");
    break;
  case pwr_eClass_SubVolume:
    strcpy(classname, "SubVolume");
    break;
  case pwr_eClass_SharedVolume:
    strcpy(classname, "SharedVolume");
    break;
  case pwr_eClass_DynamicVolume:
    strcpy(classname, "DynamicVolume");
    break;
  case pwr_eClass_DirectoryVolume:
    strcpy(classname, "DirectoryVolume");
    break;
  }
  brow_SetAnnotation(node, 1, classname, strlen(classname));
}

WItemVolume::~WItemVolume()
{
}

int WItemVolume::close(WNav* wnav, double x, double y)
{
  return 1;
}

int WItemVolume::open_children(WNav* wnav, double x, double y)
{
  int sts;

  if (wnav->ldhses) {
    wnav->message('E', "Other volume is already open");
    return 0;
  }

  sts = (wnav->attach_volume_cb)(wnav->parent_ctx, volid, 1);
  if (EVEN(sts))
    return sts;

  return 1;
}

WItemObjectName::WItemObjectName(WNavBrow* item_brow,
    ldh_tSesContext item_ldhses, pwr_tObjid item_objid, brow_tNode dest,
    flow_eDest dest_code)
    : WItem(item_objid, 0), brow(item_brow), ldhses(item_ldhses)
{
  int sts;
  int size;
  char segname[120];
  ldh_sSessInfo info;

  type = wnav_eItemType_ObjectName;

  sts = ldh_ObjidToName(
      ldhses, objid, ldh_eName_Object, segname, sizeof(segname), &size);
  brow_CreateNode(brow->ctx, segname, brow->nc_attr, dest, dest_code,
      (void*)this, 1, &node);

  brow_SetAnnotPixmap(node, 0, brow->pixmap_objname);

  // Set name
  brow_SetAnnotation(node, 0, "ObjectName", strlen("ObjectName"));
  brow_SetAnnotation(node, 1, segname, strlen(segname));

  // Examine access
  ldh_GetSessionInfo(ldhses, &info);
  if (info.Access == ldh_eAccess_ReadWrite)
    brow_SetAnnotPixmap(node, 1, brow->pixmap_morehelp);
}

WItemObjectName::~WItemObjectName()
{
}

int WItemObjectName::open_children(double x, double y)
{
  double node_x, node_y;
  int sts;

  brow_GetNodePosition(node, &node_x, &node_y);

  if (brow_IsOpen(node)) {
    // Close
    brow_SetNodraw(brow->ctx);
    brow_CloseNode(brow->ctx, node);
    if (brow_IsOpen(node) & wnav_mOpen_Children)
      brow_SetAnnotPixmap(node, 0, brow->pixmap_objname);

    brow_ResetOpen(node, wnav_mOpen_All);
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, node_y);
  } else {
    pwr_sClass_ReferenceList listbody;
    pwr_tOName oname;
    int nametype;
    wb_session* sp = (wb_session*)ldhses;
    int idx = 0;
    pwr_tObjName attr = "ObjectName";

    try {
      wb_object o = sp->object(objid);

      sts = item_get_reflist_object(sp, o.cid(), attr, &listbody);
      if (EVEN(sts))
        return WNAV__NOCHILDREN;

      brow_SetNodraw(brow->ctx);

      if (listbody.Filter & pwr_mRefListFilterMask_Other)
        new WItemEnumObject(brow, ldhses, objid, (char*)"Other", attr,
            item_eType_Other, 0, 32, 0, (char*)"", oname, 0, 0, idx++, node,
            flow_eDest_IntoLast);

      for (wb_object co = sp->object(listbody.ObjectClass[0]); co;
           co = co.next()) {
        if (listbody.Filter & pwr_mRefListFilterMask_Siblings) {
          // Check if object are siblings
          wb_object p1 = o.parent();
          wb_object p2 = co.parent();
          if ((!p1 && !p2)
              || (p1 && p2 && cdh_ObjidIsNotEqual(p1.oid(), p2.oid())))
            continue;
        }

        if (listbody.Filter & pwr_mRefListFilterMask_AllVolumes)
          nametype = cdh_mName_volumeStrict;
        else
          nametype = cdh_mName_pathStrict;

        strcpy(oname, co.name());

        new WItemEnumObject(brow, ldhses, objid, oname, attr,
            item_eType_ObjectName, 0, 32, 0, (char*)"", oname, 0, 0, idx++,
            node, flow_eDest_IntoLast);
      }
    } catch (wb_error& e) {
      brow_ResetNodraw(brow->ctx);
      brow_Redraw(brow->ctx, node_y);
      return WNAV__NOCHILDREN;
    }

    brow_SetOpen(node, wnav_mOpen_Children);
    brow_SetAnnotPixmap(node, 0, brow->pixmap_openmap);
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, node_y);
  }
  return 1;
}

int WItemObjectName::close(double x, double y)
{
  double node_x, node_y;

  brow_GetNodePosition(node, &node_x, &node_y);

  if (brow_IsOpen(node)) {
    // Close
    brow_SetNodraw(brow->ctx);
    brow_CloseNode(brow->ctx, node);
    if (brow_IsOpen(node) & wnav_mOpen_Children)
      brow_SetAnnotPixmap(node, 0, brow->pixmap_objname);

    brow_ResetOpen(node, wnav_mOpen_All);
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, node_y);
  }
  return 1;
}

int WItemObjectName::update()
{
  char segname[120];
  int sts;
  int size;

  sts = ldh_ObjidToName(
      ldhses, objid, ldh_eName_Object, segname, sizeof(segname), &size);
  if (EVEN(sts))
    return sts;
  brow_SetAnnotation(node, 1, segname, strlen(segname));

  return WNAV__SUCCESS;
}

int WItemObjectName::get_value(char** value)
{
  char* segname;
  int size = 120;
  int sts;

  segname = (char*)malloc(size);
  sts = ldh_ObjidToName(ldhses, objid, ldh_eName_Object, segname, size, &size);
  if (EVEN(sts)) {
    free(segname);
    return sts;
  }
  *value = segname;
  return WNAV__SUCCESS;
}

WItemObjectModTime::WItemObjectModTime(WNavBrow* item_brow,
    ldh_tSesContext item_ldhses, pwr_tObjid item_objid, brow_tNode dest,
    flow_eDest dest_code)
    : WItem(item_objid, 0), brow(item_brow), ldhses(item_ldhses)
{
  int sts;
  char timestr[40];
  pwr_tTime time;

  type = wnav_eItemType_ObjectModTime;

  sts = ldh_GetModTime(ldhses, objid, &time);
  if (ODD(sts))
    sts = time_AtoAscii(
        &time, time_eFormat_DateAndTime, timestr, sizeof(timestr));
  if (EVEN(sts))
    strcpy(timestr, "Undefined");

  brow_CreateNode(brow->ctx, "ModTime", brow->nc_attr, dest, dest_code,
      (void*)this, 1, &node);

  brow_SetAnnotPixmap(node, 0, brow->pixmap_objname);

  // Set name
  brow_SetAnnotation(node, 0, "ModificationTime", strlen("ModificaionTime"));
  brow_SetAnnotation(node, 1, timestr, strlen(timestr));
}

WItemObjectModTime::~WItemObjectModTime()
{
}

int WItemObjectModTime::update()
{
  char timestr[40];
  pwr_tTime time;
  int sts;

  sts = ldh_GetModTime(ldhses, objid, &time);
  if (ODD(sts))
    sts = time_AtoAscii(
        &time, time_eFormat_DateAndTime, timestr, sizeof(timestr));
  if (EVEN(sts))
    strcpy(timestr, "Undefined");
  brow_SetAnnotation(node, 1, timestr, strlen(timestr));

  return WNAV__SUCCESS;
}

WItemFile::WItemFile(WNav* wnav, const char* item_name, char* text,
    char* item_file_name, item_eFileType item_filetype, brow_tNode dest,
    flow_eDest dest_code)
    : WItem(pwr_cNObjid, 0), file_type(item_filetype)
{
  FILE* file;
  char script_descr[200] = "";

  type = wnav_eItemType_File;
  strcpy(name, item_name);
  strcpy(file_name, item_file_name);

  if (file_type == item_eFileType_Script) {
    // Read first line to find a description
    file = fopen(file_name, "r");
    if (file) {
      char* s;
      char line[200];
      if (fgets(line, sizeof(line), file)) {
        if ((s = strstr(line, wnav_cScriptDescKey))) {
          strcpy(script_descr, s + strlen(wnav_cScriptDescKey) + 1);
          if (script_descr[strlen(script_descr) - 1] == '\n')
            script_descr[strlen(script_descr) - 1] = 0;
        } else if ((s = strstr(line, wnav_cScriptInvisKey))) {
          fclose(file);
          delete this;
          return;
        }
      }
      fclose(file);
    }
  }

  brow_CreateNode(wnav->brow->ctx, name, wnav->brow->nc_object, dest, dest_code,
      (void*)this, 1, &node);
  if (file_type == item_eFileType_Script) {
    brow_SetAnnotPixmap(node, 0, wnav->brow->pixmap_script);
    if (!streq(script_descr, ""))
      brow_SetAnnotation(node, 1, script_descr, strlen(script_descr));
  } else if (file_type == item_eFileType_Graph)
    brow_SetAnnotPixmap(node, 0, wnav->brow->pixmap_graph);
  else
    brow_SetAnnotPixmap(node, 0, wnav->brow->pixmap_file);
  brow_SetAnnotation(node, 0, text, strlen(text));
}

WItemFile::~WItemFile()
{
}

int WItemFile::open_children(WNav* wnav, double x, double y)
{
  int sts;

  switch (file_type) {
  case item_eFileType_Script: {
    char cmd[120];
    strcpy(cmd, "@");
    strcat(cmd, file_name);
    sts = wnav->command(cmd);
    break;
  }
  default:
    wnav->message('I', "Unknown filetype");
  }
  return 1;
}

// NEW !!

WItemBaseAttr::WItemBaseAttr(WNavBrow* item_brow, ldh_tSesContext item_ldhses,
    pwr_tObjid item_objid, char* attr_name, int attr_type_id, pwr_tTid attr_tid,
    int attr_size, int attr_flags, char* attr_body)
    : WItem(item_objid, 0), brow(item_brow), ldhses(item_ldhses),
      type_id(attr_type_id), tid(attr_tid), size(attr_size), flags(attr_flags)
{
  strcpy(attr, attr_name);
  strcpy(body, attr_body);

  ldh_GetObjectClass(ldhses, objid, &classid);
}

WItemBaseAttr::~WItemBaseAttr()
{
}

int WItemBaseAttr::get_value(char** value)
{
  int psize;

  return ldh_GetObjectPar(ldhses, objid, body, attr, (char**)value, &psize);
}

pwr_sAttrRef WItemBaseAttr::aref()
{
  pwr_tAName aname;
  pwr_sAttrRef a;
  pwr_tStatus sts;
  int asize;

  sts = ldh_ObjidToName(
      ldhses, objid, ldh_eName_VolPath, aname, sizeof(aname), &asize);
  if (EVEN(sts))
    return pwr_cNAttrRef;

  strcat(aname, ".");
  strcat(aname, name);

  sts = ldh_NameToAttrRef(ldhses, aname, &a);
  if (EVEN(sts))
    return pwr_cNAttrRef;

  return a;
}

WItemAttr::WItemAttr(WNavBrow* item_brow, ldh_tSesContext item_ldhses,
    pwr_tObjid item_objid, brow_tNode dest, flow_eDest dest_code,
    char* attr_name, int attr_type_id, pwr_tTid attr_tid, int attr_size,
    int attr_flags, char* attr_body, int fullname)
    : WItemBaseAttr(item_brow, item_ldhses, item_objid, attr_name, attr_type_id,
          attr_tid, attr_size, attr_flags, attr_body)
{
  pwr_tOName obj_name;
  pwr_tAName annot;
  int sts;
  int psize;
  ldh_sSessInfo info;
  brow_tNodeClass nc;

  type = wnav_eItemType_Attr;

  strcpy(name, attr_name);
  strcpy(body, attr_body);
  char* s = strrchr(attr_name, '.');
  if (s)
    strcpy(annot, s + 1);
  else
    strcpy(annot, attr_name);

  if (fullname)
    nc = brow->nc_attr_full;
  else
    nc = brow->nc_attr;

  switch (type_id) {
  case pwr_eType_Objid:
    brow_CreateNode(
        brow->ctx, attr_name, nc, dest, dest_code, (void*)this, 1, &node);
    brow_SetAnnotPixmap(node, 0, brow->pixmap_ref);
    break;
  case pwr_eType_AttrRef:
    brow_CreateNode(
        brow->ctx, attr_name, nc, dest, dest_code, (void*)this, 1, &node);
    brow_SetAnnotPixmap(node, 0, brow->pixmap_attrref);
    break;
  case pwr_eType_Enum:
    brow_CreateNode(
        brow->ctx, attr_name, nc, dest, dest_code, (void*)this, 1, &node);
    brow_SetAnnotPixmap(node, 0, brow->pixmap_attrenum);
    break;
  case pwr_eType_Mask:
    brow_CreateNode(
        brow->ctx, attr_name, nc, dest, dest_code, (void*)this, 1, &node);
    brow_SetAnnotPixmap(node, 0, brow->pixmap_attrmask);
    break;
  case pwr_eType_Text:
    if (fullname)
      nc = brow->nc_attr_multiline_full;
    else
      nc = brow->nc_attr_multiline;
    brow_CreateNode(
        brow->ctx, attr_name, nc, dest, dest_code, (void*)this, 1, &node);
    brow_SetAnnotPixmap(node, 0, brow->pixmap_attr);
    break;
  default:
    brow_CreateNode(
        brow->ctx, attr_name, nc, dest, dest_code, (void*)this, 1, &node);
    brow_SetAnnotPixmap(node, 0, brow->pixmap_attr);
  }
  sts = ldh_ObjidToName(
      ldhses, objid, ldh_eName_Hierarchy, obj_name, sizeof(obj_name), &psize);
  if (fullname)
    sprintf(annot, "%s.%s", obj_name, attr_name);

  brow_SetAnnotation(node, 0, annot, strlen(annot));

  //  brow_SetTraceAttr( node, obj_name, attr_name, flow_eTraceType_User);

  // Examine access
  ldh_GetSessionInfo(ldhses, &info);
  if (info.Access == ldh_eAccess_ReadWrite
      && !(flags & PWR_MASK_NOEDIT || flags & PWR_MASK_STATE))
    brow_SetAnnotPixmap(node, 1, brow->pixmap_morehelp);

  update();
}

WItemAttr::~WItemAttr()
{
}

int WItemAttr::open_children(double x, double y)
{
  double node_x, node_y;
  pwr_tStatus sts;

  switch (type_id) {
  case pwr_eType_Enum:
  case pwr_eType_Mask:
    break;
  case pwr_eType_Objid:
  case pwr_eType_AttrRef:
  case pwr_eType_TypeId:
    if (((wb_session*)ldhses)->access() == ldh_eAccess_ReadOnly)
      return WNAV__NOCHILDREN;
    break;
  default:
    return WNAV__NOCHILDREN;
  }

  brow_GetNodePosition(node, &node_x, &node_y);

  if (brow_IsOpen(node)) {
    // Close
    brow_SetNodraw(brow->ctx);
    brow_CloseNode(brow->ctx, node);
    if (brow_IsOpen(node) & wnav_mOpen_Attributes)
      brow_RemoveAnnotPixmap(node, 1);
    if (brow_IsOpen(node) & wnav_mOpen_Children) {
      switch (type_id) {
      case pwr_eType_Enum:
        brow_SetAnnotPixmap(node, 0, brow->pixmap_attrenum);
        break;
      case pwr_eType_Mask:
        brow_SetAnnotPixmap(node, 0, brow->pixmap_attrmask);
        break;
      default:
        brow_SetAnnotPixmap(node, 0, brow->pixmap_attr);
      }
    }
    brow_ResetOpen(node, wnav_mOpen_All);
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, node_y);
  } else {
    switch (type_id) {
    case pwr_eType_Enum: {
      ldh_sValueDef* vd;
      int rows;

      sts = ldh_GetEnumValueDef(ldhses, tid, &vd, &rows);
      if (EVEN(sts))
        return WNAV__NOCHILDREN;

      // Create some children
      brow_SetNodraw(brow->ctx);

      for (int i = 0; i < rows; i++) {
        new WItemEnum(brow, ldhses, objid, vd[i].Value.Text, attr, type_id, tid,
            size, flags, body, vd[i].Value.Value, 0, 0, node,
            flow_eDest_IntoLast);
      }
      free((char*)vd);
      break;
    }
    case pwr_eType_Mask: {
      ldh_sBitDef* bd;
      int rows;

      sts = ldh_GetMaskBitDef(ldhses, tid, &bd, &rows);
      if (EVEN(sts))
        return WNAV__NOCHILDREN;

      // Create some children
      brow_SetNodraw(brow->ctx);

      for (int i = 0; i < rows; i++) {
        new WItemMask(brow, ldhses, objid, bd[i].Bit->Text, attr, type_id, tid,
            size, flags, body, (unsigned int)bd[i].Bit->Value, 0, 0, node,
            flow_eDest_IntoLast);
      }
      free((char*)bd);
      break;
    }
    case pwr_eType_Objid:
    case pwr_eType_AttrRef:
    case pwr_eType_TypeId: {
      pwr_sClass_ReferenceList listbody;
      pwr_tOName oname;
      int nametype;
      wb_session* sp = (wb_session*)ldhses;
      int idx = 0;
      char* s;
      pwr_tCid cid_attrobj;
      pwr_tOName name_attrobj;
      pwr_tAName aname;

      try {
        // Get class for attribute object, lowest level
        wb_object o = sp->object(objid);

        strcpy(name_attrobj, name);
        if ((s = strrchr(name_attrobj, '.'))) {
          *s = 0;
          strcpy(aname, o.longName().name(cdh_mName_volumeStrict));
          strcat(aname, ".");
          strcat(aname, name_attrobj);

          wb_attribute a_attrobj = sp->attribute(aname);
          cid_attrobj = a_attrobj.tid();
        } else
          cid_attrobj = classid;

        sts = item_get_reflist_object(sp, cid_attrobj, attr, &listbody);
        if (EVEN(sts))
          return WNAV__NOCHILDREN;

        if (type_id == pwr_eType_Objid) {
          brow_SetNodraw(brow->ctx);

          if (listbody.Filter & pwr_mRefListFilterMask_Other)
            new WItemEnumObject(brow, ldhses, objid, (char*)"Other", attr,
                item_eType_Other, tid, size, flags, body, &objid, 0, 0, idx++,
                node, flow_eDest_IntoLast);

          for (unsigned int i = 0; i
               < sizeof(listbody.ObjectClass) / sizeof(listbody.ObjectClass[0]);
               i++) {
            if (listbody.ObjectClass[i] == 0)
              break;

            for (wb_object co = sp->object(listbody.ObjectClass[i]); co;
                 co = co.next()) {
              if (listbody.Filter & pwr_mRefListFilterMask_Siblings) {
                // Check if object are siblings
                wb_object p1 = o.parent();
                wb_object p2 = co.parent();
                if ((!p1 && !p2)
                    || (p1 && p2 && cdh_ObjidIsNotEqual(p1.oid(), p2.oid())))
                  continue;
              }

              if (listbody.Filter & pwr_mRefListFilterMask_AllVolumes)
                nametype = cdh_mName_volumeStrict;
              else
                nametype = cdh_mName_pathStrict;

              strcpy(oname, co.longName().name(nametype));

              pwr_tOid oid = co.oid();
              new WItemEnumObject(brow, ldhses, objid, oname, attr, type_id,
                  tid, size, flags, body, &oid, 0, 0, idx++, node,
                  flow_eDest_IntoLast);
            }
          }
        } else if (type_id == pwr_eType_TypeId) {
          wb_vrep* vrep;
          wb_mvrep* mvrep;
          wb_volume v;
          wb_object co;
          char* s;

          // Check Flags if class bit is set
          wb_attribute aflags = sp->attribute(objid, "SysBody", "Flags");
          if (aflags) {
            unsigned int flags;

            aflags.value(&flags);
            if (flags & PWR_MASK_CLASS)
              return WNAV__NOCHILDREN;
          }

          brow_SetNodraw(brow->ctx);

          if (listbody.Filter & pwr_mRefListFilterMask_Other)
            new WItemEnumObject(brow, ldhses, objid, (char*)"Other", attr,
                item_eType_Other, tid, size, flags, body, &objid, 0, 0, idx++,
                node, flow_eDest_IntoLast);

          for (int j = 0; j < 2; j++) {
            // Loop over current volume and pwrs volume
            if (j == 0
                && !(listbody.Filter & pwr_mRefListFilterMask_CurrentVolume))
              continue;
            if (j == 1
                && !(listbody.Filter & pwr_mRefListFilterMask_PwrsVolume))
              continue;

            if (j == 1) {
              vrep = *sp;
              mvrep = vrep->merep()->volume(&sts, 1);
              v = wb_volume(mvrep);
            }

            for (unsigned int i = 0; i < sizeof(listbody.ObjectClass)
                     / sizeof(listbody.ObjectClass[0]);
                 i++) {
              if (listbody.ObjectClass[i] == 0)
                break;

              if (j == 1)
                co = v.object(listbody.ObjectClass[i]);
              else
                co = sp->object(listbody.ObjectClass[i]);

              for (; co; co = co.next()) {
                strcpy(oname, co.longName().name(cdh_mName_volumeStrict));

                if ((s = strrchr(oname, '-')) && streq(s + 1, "Template"))
                  continue;

                pwr_tOid oid = co.oid();
                new WItemEnumObject(brow, ldhses, objid, oname, attr, type_id,
                    tid, size, flags, body, &oid, 0, 0, idx++, node,
                    flow_eDest_IntoLast);
              }
            }
          }
        } else {
          // type_id is AttrRef
          pwr_tAttrRef aref;

          brow_SetNodraw(brow->ctx);

          if (listbody.Filter & pwr_mRefListFilterMask_Other)
            new WItemEnumObject(brow, ldhses, objid, (char*)"Other", attr,
                item_eType_Other, tid, size, flags, body, &objid, 0, 0, idx++,
                node, flow_eDest_IntoLast);

          for (unsigned int i = 0; i
               < sizeof(listbody.ObjectClass) / sizeof(listbody.ObjectClass[0]);
               i++) {
            if (listbody.ObjectClass[i] == 0)
              break;

            if (listbody.Filter & pwr_mRefListFilterMask_AttrObjects) {
              for (sp->aref(listbody.ObjectClass[i], &aref); sp->oddSts();
                   sp->nextAref(listbody.ObjectClass[i], &aref, &aref)) {
                if (listbody.Filter & pwr_mRefListFilterMask_Siblings) {
                  // Check if object are siblings
                  wb_object co = sp->object(aref.Objid);
                  if (!co)
                    continue;

                  wb_object p1 = o.parent();
                  wb_object p2 = co.parent();
                  if ((!p1 && !p2)
                      || (p1 && p2 && cdh_ObjidIsNotEqual(p1.oid(), p2.oid())))
                    continue;
                }

                if (listbody.Filter & pwr_mRefListFilterMask_Children) {
                  // Check if object are children
                  wb_object co = sp->object(aref.Objid);
                  if (!co)
                    continue;

                  wb_object p1 = co.parent();
                  if (!p1)
                    continue;

                  if (cdh_ObjidIsNotEqual(p1.oid(), o.oid()))
                    continue;
                }

                wb_attribute ca = sp->attribute(&aref);
                if (listbody.Filter & pwr_mRefListFilterMask_AllVolumes)
                  nametype = cdh_mName_volumeStrict;
                else
                  nametype = cdh_mName_pathStrict;

                strcpy(oname, ca.longName().name(nametype));

                new WItemEnumObject(brow, ldhses, objid, oname, attr, type_id,
                    tid, size, flags, body, &aref, 0, 0, idx++, node,
                    flow_eDest_IntoLast);
              }
            } else {
              for (wb_object co = sp->object(listbody.ObjectClass[i]); co;
                   co = co.next()) {
                if (listbody.Filter & pwr_mRefListFilterMask_Siblings) {
                  // Check if object are siblings
                  wb_object p1 = o.parent();
                  wb_object p2 = co.parent();
                  if ((!p1 && !p2)
                      || (p1 && p2 && cdh_ObjidIsNotEqual(p1.oid(), p2.oid())))
                    continue;
                }

                if (listbody.Filter & pwr_mRefListFilterMask_Children) {
                  // Check if object are children
                  wb_object p1 = co.parent();
                  if (!p1)
                    continue;

                  if (cdh_ObjidIsNotEqual(p1.oid(), o.oid()))
                    continue;
                }

                if (listbody.Filter & pwr_mRefListFilterMask_AllVolumes)
                  nametype = cdh_mName_volumeStrict;
                else
                  nametype = cdh_mName_pathStrict;

                strcpy(oname, co.longName().name(nametype));

                pwr_tAttrRef aref = cdh_ObjidToAref(co.oid());
                new WItemEnumObject(brow, ldhses, objid, oname, attr, type_id,
                    tid, size, flags, body, &aref, 0, 0, idx++, node,
                    flow_eDest_IntoLast);
              }
            }
          }
        }
      } catch (wb_error& e) {
        brow_ResetNodraw(brow->ctx);
        brow_Redraw(brow->ctx, node_y);
        return WNAV__NOCHILDREN;
      }

      break;
    }
    default:
      return WNAV__NOCHILDREN;
    }

    brow_SetOpen(node, wnav_mOpen_Children);
    brow_SetAnnotPixmap(node, 0, brow->pixmap_openmap);
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, node_y);
  }
  return 1;
}

int WItemAttr::close(double x, double y)
{
  double node_x, node_y;

  brow_GetNodePosition(node, &node_x, &node_y);

  if (brow_IsOpen(node)) {
    // Close
    brow_SetNodraw(brow->ctx);
    brow_CloseNode(brow->ctx, node);
    if (brow_IsOpen(node) & wnav_mOpen_Attributes)
      brow_RemoveAnnotPixmap(node, 1);
    if (brow_IsOpen(node) & wnav_mOpen_Children) {
      switch (type_id) {
      case pwr_eType_Enum:
        brow_SetAnnotPixmap(node, 0, brow->pixmap_attrenum);
        break;
      case pwr_eType_Mask:
        brow_SetAnnotPixmap(node, 0, brow->pixmap_attrmask);
        break;
      default:
        brow_SetAnnotPixmap(node, 0, brow->pixmap_attr);
      }
    }
    brow_ResetOpen(node, wnav_mOpen_All);
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, node_y);
  }
  return 1;
}

int WItemAttr::update()
{
  int sts;
  int psize;
  void* value;
  char* buff = NULL;
  int len = 0;
  char buf[80];

  // Get the attribute value
  sts = ldh_GetObjectPar(ldhses, objid, body, attr, (char**)&value, &psize);
  if (EVEN(sts))
    return sts;

  switch (type_id) {
  case pwr_eType_Enum: {
    ldh_sValueDef* vd;
    int rows;
    bool found = false;

    sts = ldh_GetEnumValueDef(ldhses, tid, &vd, &rows);
    if (ODD(sts)) {
      for (int i = 0; i < rows; i++) {
        if (vd[i].Value.Value == *(pwr_tInt32*)value) {
          strcpy(buf, vd[i].Value.Text);
          buff = buf;
          len = strlen(buf);
          found = true;
          break;
        }
      }
      free((char*)vd);
    }
    if (EVEN(sts) || !found)
      wnav_attrvalue_to_string(ldhses, type_id, value, &buff, &len);
    break;
  }
  default:
    wnav_attrvalue_to_string(ldhses, type_id, value, &buff, &len);
  }

  if (flags & PWR_MASK_DEVHIDEVALUE)
    for (int i = 0; i < len; i++)
      buff[i] = '*';

  brow_SetAnnotation(node, 1, buff, len);
  free((char*)value);
  return WNAV__SUCCESS;
}

WItemAttrInput::WItemAttrInput(WNavBrow* item_brow, ldh_tSesContext item_ldhses,
    pwr_tObjid item_objid, brow_tNode dest, flow_eDest dest_code,
    char* attr_name, int attr_type_id, pwr_tTid attr_tid, int attr_size,
    int attr_flags, char* attr_body, int attr_input_num)
    : WItemBaseAttr(item_brow, item_ldhses, item_objid, attr_name, attr_type_id,
          attr_tid, attr_size, attr_flags, attr_body)
{
  pwr_tOName obj_name;
  char annot[120];
  int sts;
  int psize;
  ldh_sSessInfo info;

  type = wnav_eItemType_AttrInput;

  strcpy(name, attr_name);
  strcpy(body, attr_body);
  char* s = strrchr(attr_name, '.');
  if (s)
    strcpy(annot, s + 1);
  else
    strcpy(annot, attr_name);
  mask = 1 << attr_input_num;

  brow_CreateNode(brow->ctx, attr_name, brow->nc_attr_input, dest, dest_code,
      (void*)this, 1, &node);

  switch (type_id) {
  case pwr_eType_Objid:
    brow_SetAnnotPixmap(node, 0, brow->pixmap_ref);
    break;
  default:
    brow_SetAnnotPixmap(node, 0, brow->pixmap_attr);
  }
  brow_SetAnnotation(node, 0, annot, strlen(annot));
  sts = ldh_ObjidToName(
      ldhses, objid, ldh_eName_Hierarchy, obj_name, sizeof(obj_name), &psize);
  //  brow_SetTraceAttr( node, obj_name, attr_name, flow_eTraceType_User);

  // Examine access
  ldh_GetSessionInfo(ldhses, &info);
  if (info.Access == ldh_eAccess_ReadWrite
      && !(flags & PWR_MASK_NOEDIT || flags & PWR_MASK_STATE))
    brow_SetAnnotPixmap(node, 1, brow->pixmap_morehelp);

  update();
}

WItemAttrInput::~WItemAttrInput()
{
}

int WItemAttrInput::update()
{
  int sts;
  int psize;
  void* value;
  char* buff;
  int len;
  pwr_eClass eclass;
  pwr_sPlcNode* plcnode;

  // Get the attribute value
  sts = ldh_GetObjectPar(ldhses, objid, body, attr, (char**)&value, &psize);
  if (EVEN(sts))
    return sts;

  wnav_attrvalue_to_string(ldhses, type_id, value, &buff, &len);
  brow_SetAnnotation(node, 1, buff, len);
  free((char*)value);

  sts = ldh_GetObjectBuffer(
      ldhses, objid, "DevBody", "PlcNode", &eclass, (char**)&plcnode, &psize);
  if (EVEN(sts))
    return sts;

  // Used mask
  if (plcnode->mask[0] & mask)
    brow_SetRadiobutton(node, 0, 1);
  else
    brow_SetRadiobutton(node, 0, 0);

  // Invert mask
  if (plcnode->mask[2] & mask)
    brow_SetRadiobutton(node, 1, 1);
  else
    brow_SetRadiobutton(node, 1, 0);

  free((char*)plcnode);

  return WNAV__SUCCESS;
}

int WItemAttrInput::set_mask(int radio_button, int value)
{
  int sts;
  int psize;
  pwr_eClass eclass;
  pwr_sPlcNode* plcnode;
  int ldh_cb_used = brow->ldh_cb_used;

  sts = ldh_GetObjectBuffer(
      ldhses, objid, "DevBody", "PlcNode", &eclass, (char**)&plcnode, &psize);
  if (EVEN(sts))
    return sts;

  // Used mask
  if (radio_button == 0) {
    if (value == 1)
      plcnode->mask[0] |= mask;
    else
      plcnode->mask[0] &= ~mask;
  } else {
    if (value == 1)
      plcnode->mask[2] |= mask;
    else
      plcnode->mask[2] &= ~mask;
  }

  sts = ldh_SetObjectBuffer(
      ldhses, objid, "DevBody", "PlcNode", (char*)plcnode);
  if (EVEN(sts))
    return sts;

  if (!ldh_cb_used) {
    if (plcnode->mask[0] & mask)
      brow_SetRadiobutton(node, 0, 1);
    else
      brow_SetRadiobutton(node, 0, 0);

    // Invert mask
    if (plcnode->mask[2] & mask)
      brow_SetRadiobutton(node, 1, 1);
    else
      brow_SetRadiobutton(node, 1, 0);
  }

  free((char*)plcnode);
  return WNAV__SUCCESS;
}

WItemAttrInputF::WItemAttrInputF(WNavBrow* item_brow,
    ldh_tSesContext item_ldhses, pwr_tObjid item_objid, brow_tNode dest,
    flow_eDest dest_code, char* attr_name, int attr_type_id, pwr_tTid attr_tid,
    int attr_size, int attr_flags, char* attr_body, int attr_input_num)
    : WItemBaseAttr(item_brow, item_ldhses, item_objid, attr_name, attr_type_id,
          attr_tid, attr_size, attr_flags, attr_body)
{
  pwr_tOName obj_name;
  char annot[120];
  int sts;
  int psize;
  ldh_sSessInfo info;

  type = wnav_eItemType_AttrInputF;

  strcpy(name, attr_name);
  strcpy(body, attr_body);
  char* s = strrchr(attr_name, '.');
  if (s)
    strcpy(annot, s + 1);
  else
    strcpy(annot, attr_name);
  mask = 1 << attr_input_num;

  brow_CreateNode(brow->ctx, attr_name, brow->nc_attr_output, dest, dest_code,
      (void*)this, 1, &node);

  switch (type_id) {
  case pwr_eType_Objid:
    brow_SetAnnotPixmap(node, 0, brow->pixmap_ref);
    break;
  default:
    brow_SetAnnotPixmap(node, 0, brow->pixmap_attr);
  }
  brow_SetAnnotation(node, 0, annot, strlen(annot));
  sts = ldh_ObjidToName(
      ldhses, objid, ldh_eName_Hierarchy, obj_name, sizeof(obj_name), &psize);
  //  brow_SetTraceAttr( node, obj_name, attr_name, flow_eTraceType_User);

  // Examine access
  ldh_GetSessionInfo(ldhses, &info);
  if (info.Access == ldh_eAccess_ReadWrite
      && !(flags & PWR_MASK_NOEDIT || flags & PWR_MASK_STATE))
    brow_SetAnnotPixmap(node, 1, brow->pixmap_morehelp);

  update();
}

WItemAttrInputF::~WItemAttrInputF()
{
}

int WItemAttrInputF::update()
{
  int sts;
  int psize;
  void* value;
  char* buff;
  int len;
  pwr_eClass eclass;
  pwr_sPlcNode* plcnode;

  // Get the attribute value
  sts = ldh_GetObjectPar(ldhses, objid, body, attr, (char**)&value, &psize);
  if (EVEN(sts))
    return sts;

  wnav_attrvalue_to_string(ldhses, type_id, value, &buff, &len);
  brow_SetAnnotation(node, 1, buff, len);
  free((char*)value);

  sts = ldh_GetObjectBuffer(
      ldhses, objid, "DevBody", "PlcNode", &eclass, (char**)&plcnode, &psize);
  if (EVEN(sts))
    return sts;

  // Used mask
  if (plcnode->mask[0] & mask)
    brow_SetRadiobutton(node, 0, 1);
  else
    brow_SetRadiobutton(node, 0, 0);

  free((char*)plcnode);

  return WNAV__SUCCESS;
}

int WItemAttrInputF::set_mask(int radio_button, int value)
{
  int sts;
  int psize;
  pwr_eClass eclass;
  pwr_sPlcNode* plcnode;
  int ldh_cb_used = brow->ldh_cb_used;

  sts = ldh_GetObjectBuffer(
      ldhses, objid, "DevBody", "PlcNode", &eclass, (char**)&plcnode, &psize);
  if (EVEN(sts))
    return sts;

  // Used mask
  if (radio_button == 0) {
    if (value == 1)
      plcnode->mask[0] |= mask;
    else
      plcnode->mask[0] &= ~mask;
  }

  sts = ldh_SetObjectBuffer(
      ldhses, objid, "DevBody", "PlcNode", (char*)plcnode);
  if (EVEN(sts))
    return sts;

  if (!ldh_cb_used) {
    if (plcnode->mask[0] & mask)
      brow_SetRadiobutton(node, 0, 1);
    else
      brow_SetRadiobutton(node, 0, 0);
  }
  free((char*)plcnode);
  return WNAV__SUCCESS;
}

WItemAttrInputInv::WItemAttrInputInv(WNavBrow* item_brow,
    ldh_tSesContext item_ldhses, pwr_tObjid item_objid, brow_tNode dest,
    flow_eDest dest_code, char* attr_name, int attr_type_id, pwr_tTid attr_tid,
    int attr_size, int attr_flags, char* attr_body, int attr_input_num)
    : WItemBaseAttr(item_brow, item_ldhses, item_objid, attr_name, attr_type_id,
          attr_tid, attr_size, attr_flags, attr_body)
{
  pwr_tOName obj_name;
  char annot[120];
  int sts;
  int psize;
  ldh_sSessInfo info;

  type = wnav_eItemType_AttrInputInv;

  strcpy(name, attr_name);
  strcpy(body, attr_body);
  char* s = strrchr(attr_name, '.');
  if (s)
    strcpy(annot, s + 1);
  else
    strcpy(annot, attr_name);
  mask = 1 << attr_input_num;

  brow_CreateNode(brow->ctx, attr_name, brow->nc_attr_inputinv, dest, dest_code,
      (void*)this, 1, &node);

  switch (type_id) {
  case pwr_eType_Objid:
    brow_SetAnnotPixmap(node, 0, brow->pixmap_ref);
    break;
  default:
    brow_SetAnnotPixmap(node, 0, brow->pixmap_attr);
  }
  brow_SetAnnotation(node, 0, annot, strlen(annot));
  sts = ldh_ObjidToName(
      ldhses, objid, ldh_eName_Hierarchy, obj_name, sizeof(obj_name), &psize);
  //  brow_SetTraceAttr( node, obj_name, attr_name, flow_eTraceType_User);

  // Examine access
  ldh_GetSessionInfo(ldhses, &info);
  if (info.Access == ldh_eAccess_ReadWrite
      && !(flags & PWR_MASK_NOEDIT || flags & PWR_MASK_STATE))
    brow_SetAnnotPixmap(node, 1, brow->pixmap_morehelp);

  update();
}

WItemAttrInputInv::~WItemAttrInputInv()
{
}

int WItemAttrInputInv::update()
{
  int sts;
  int psize;
  void* value;
  char* buff;
  int len;
  pwr_eClass eclass;
  pwr_sPlcNode* plcnode;

  // Get the attribute value
  sts = ldh_GetObjectPar(ldhses, objid, body, attr, (char**)&value, &psize);
  if (EVEN(sts))
    return sts;

  wnav_attrvalue_to_string(ldhses, type_id, value, &buff, &len);
  brow_SetAnnotation(node, 1, buff, len);
  free((char*)value);

  sts = ldh_GetObjectBuffer(
      ldhses, objid, "DevBody", "PlcNode", &eclass, (char**)&plcnode, &psize);
  if (EVEN(sts))
    return sts;

  // Used mask
  if (plcnode->mask[2] & mask)
    brow_SetRadiobutton(node, 0, 1);
  else
    brow_SetRadiobutton(node, 0, 0);

  free((char*)plcnode);

  return WNAV__SUCCESS;
}

int WItemAttrInputInv::set_mask(int radio_button, int value)
{
  int sts;
  int psize;
  pwr_eClass eclass;
  pwr_sPlcNode* plcnode;
  int ldh_cb_used = brow->ldh_cb_used;

  sts = ldh_GetObjectBuffer(
      ldhses, objid, "DevBody", "PlcNode", &eclass, (char**)&plcnode, &psize);
  if (EVEN(sts))
    return sts;

  // Used mask
  if (radio_button == 0) {
    if (value == 1)
      plcnode->mask[2] |= mask;
    else
      plcnode->mask[2] &= ~mask;
  }

  sts = ldh_SetObjectBuffer(
      ldhses, objid, "DevBody", "PlcNode", (char*)plcnode);
  if (EVEN(sts))
    return sts;

  if (!ldh_cb_used) {
    if (plcnode->mask[2] & mask)
      brow_SetRadiobutton(node, 0, 1);
    else
      brow_SetRadiobutton(node, 0, 0);
  }
  free((char*)plcnode);
  return WNAV__SUCCESS;
}

WItemAttrOutput::WItemAttrOutput(WNavBrow* item_brow,
    ldh_tSesContext item_ldhses, pwr_tObjid item_objid, brow_tNode dest,
    flow_eDest dest_code, char* attr_name, int attr_type_id, pwr_tTid attr_tid,
    int attr_size, int attr_flags, char* attr_body, int attr_output_num)
    : WItemBaseAttr(item_brow, item_ldhses, item_objid, attr_name, attr_type_id,
          attr_tid, attr_size, attr_flags, attr_body)
{
  pwr_tOName obj_name;
  char annot[120];
  int sts;
  int psize;
  ldh_sSessInfo info;

  type = wnav_eItemType_AttrOutput;

  strcpy(name, attr_name);
  strcpy(body, attr_body);
  char* s = strrchr(attr_name, '.');
  if (s)
    strcpy(annot, s + 1);
  else
    strcpy(annot, attr_name);

  mask = 1 << attr_output_num;

  brow_CreateNode(brow->ctx, attr_name, brow->nc_attr_output, dest, dest_code,
      (void*)this, 1, &node);

  switch (type_id) {
  case pwr_eType_Objid:
    brow_SetAnnotPixmap(node, 0, brow->pixmap_ref);
    break;
  default:
    brow_SetAnnotPixmap(node, 0, brow->pixmap_attr);
  }
  brow_SetAnnotation(node, 0, annot, strlen(annot));
  sts = ldh_ObjidToName(
      ldhses, objid, ldh_eName_Hierarchy, obj_name, sizeof(obj_name), &psize);
  //  brow_SetTraceAttr( node, obj_name, attr_name, flow_eTraceType_User);

  // Examine access
  ldh_GetSessionInfo(ldhses, &info);
  if (info.Access == ldh_eAccess_ReadWrite
      && !(flags & PWR_MASK_NOEDIT || flags & PWR_MASK_STATE))
    brow_SetAnnotPixmap(node, 1, brow->pixmap_morehelp);

  update();
}

WItemAttrOutput::~WItemAttrOutput()
{
}

int WItemAttrOutput::update()
{
  int sts;
  int psize;
  void* value;
  char* buff;
  int len;
  pwr_eClass eclass;
  pwr_sPlcNode* plcnode;

  // Get the attribute value
  sts = ldh_GetObjectPar(ldhses, objid, body, attr, (char**)&value, &psize);
  if (EVEN(sts))
    return sts;

  wnav_attrvalue_to_string(ldhses, type_id, value, &buff, &len);
  brow_SetAnnotation(node, 1, buff, len);
  free((char*)value);

  sts = ldh_GetObjectBuffer(
      ldhses, objid, "DevBody", "PlcNode", &eclass, (char**)&plcnode, &psize);
  if (EVEN(sts))
    return sts;

  // Used mask
  if (plcnode->mask[1] & mask)
    brow_SetRadiobutton(node, 0, 1);
  else
    brow_SetRadiobutton(node, 0, 0);

  free((char*)plcnode);

  return WNAV__SUCCESS;
}

int WItemAttrOutput::set_mask(int radio_button, int value)
{
  int sts;
  int psize;
  pwr_eClass eclass;
  pwr_sPlcNode* plcnode;
  int ldh_cb_used = brow->ldh_cb_used;

  sts = ldh_GetObjectBuffer(
      ldhses, objid, "DevBody", "PlcNode", &eclass, (char**)&plcnode, &psize);
  if (EVEN(sts))
    return sts;

  // Used mask
  if (radio_button == 0) {
    if (value == 1)
      plcnode->mask[1] |= mask;
    else
      plcnode->mask[1] &= ~mask;
  }

  sts = ldh_SetObjectBuffer(
      ldhses, objid, "DevBody", "PlcNode", (char*)plcnode);
  if (EVEN(sts))
    return sts;

  if (!ldh_cb_used) {
    if (plcnode->mask[1] & mask)
      brow_SetRadiobutton(node, 0, 1);
    else
      brow_SetRadiobutton(node, 0, 0);

    free((char*)plcnode);
  }

  return WNAV__SUCCESS;
}

WItemAttrArray::WItemAttrArray(WNavBrow* item_brow, ldh_tSesContext item_ldhses,
    pwr_tObjid item_objid, brow_tNode dest, flow_eDest dest_code,
    char* attr_name, int attr_elements, int attr_type_id, pwr_tTid attr_tid,
    int attr_size, int attr_flags, char* attr_body, int fullname)
    : WItemBaseAttr(item_brow, item_ldhses, item_objid, attr_name, attr_type_id,
          attr_tid, attr_size, attr_flags, attr_body),
      elements(attr_elements)
{
  ldh_sSessInfo info;
  pwr_tOName annot;
  int psize;
  int sts;

  type = wnav_eItemType_AttrArray;

  strcpy(name, attr_name);
  strcpy(body, attr_body);
  brow_CreateNode(brow->ctx, attr_name, brow->nc_object, dest, dest_code,
      (void*)this, 1, &node);

  brow_SetAnnotPixmap(node, 0, brow->pixmap_attrarray);

  if (fullname) {
    sts = ldh_ObjidToName(
        ldhses, objid, ldh_eName_Hierarchy, annot, sizeof(annot), &psize);
    strcat(annot, ".");
    strcat(annot, attr_name);
  } else {
    char* s = strrchr(attr_name, '.');
    if (s)
      strcpy(annot, s + 1);
    else
      strcpy(annot, attr_name);
  }

  brow_SetAnnotation(node, 0, annot, strlen(annot));

  // Examine access
  ldh_GetSessionInfo(ldhses, &info);
  if (info.Access == ldh_eAccess_ReadWrite
      && !(flags & PWR_MASK_NOEDIT || flags & PWR_MASK_STATE))
    brow_SetAnnotPixmap(node, 1, brow->pixmap_morehelp);
}

WItemAttrArray::~WItemAttrArray()
{
}

int WItemAttrArray::open_attributes(double x, double y)
{
  double node_x, node_y;
  int i;

  brow_GetNodePosition(node, &node_x, &node_y);

  if (brow_IsOpen(node) & wnav_mOpen_Attributes) {
    // Attributes is open, close
    brow_SetNodraw(brow->ctx);
    brow_CloseNode(brow->ctx, node);
    brow_ResetOpen(node, wnav_mOpen_All);
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, node_y);
  } else {
    // Create some elements
    brow_SetNodraw(brow->ctx);

    for (i = 0; i < elements; i++) {
      if (flags & PWR_MASK_CLASS)
        new WItemAttrObject(brow, ldhses, objid, node, flow_eDest_IntoLast,
            name, type_id, size / elements, true, i, flags, body, 0);
      else
        new WItemAttrArrayElem(brow, ldhses, objid, node, flow_eDest_IntoLast,
            name, i, type_id, tid, size / elements, i * size / elements, flags,
            body);
    }

    brow_SetOpen(node, wnav_mOpen_Attributes);
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, node_y);
  }
  return 1;
}

int WItemAttrArray::close(double x, double y)
{
  double node_x, node_y;

  if (brow_IsOpen(node) & wnav_mOpen_Attributes) {
    // Attributes is open, close
    brow_GetNodePosition(node, &node_x, &node_y);
    brow_SetNodraw(brow->ctx);
    brow_CloseNode(brow->ctx, node);
    brow_ResetOpen(node, wnav_mOpen_All);
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, node_y);
  }
  return 1;
}

WItemAttrArrayOutput::WItemAttrArrayOutput(WNavBrow* item_brow,
    ldh_tSesContext item_ldhses, pwr_tObjid item_objid, brow_tNode dest,
    flow_eDest dest_code, char* attr_name, int attr_elements, int attr_type_id,
    pwr_tTid attr_tid, int attr_size, int attr_flags, char* attr_body,
    int attr_output_num)
    : WItemBaseAttr(item_brow, item_ldhses, item_objid, attr_name, attr_type_id,
          attr_tid, attr_size, attr_flags, attr_body),
      elements(attr_elements)
{
  ldh_sSessInfo info;
  char annot[32];

  type = wnav_eItemType_AttrArrayOutput;

  strcpy(name, attr_name);
  strcpy(body, attr_body);
  mask = 1 << attr_output_num;

  brow_CreateNode(brow->ctx, attr_name, brow->nc_attr_output, dest, dest_code,
      (void*)this, 1, &node);

  brow_SetAnnotPixmap(node, 0, brow->pixmap_attrarray);

  char* s = strrchr(attr_name, '.');
  if (s)
    strcpy(annot, s + 1);
  else
    strcpy(annot, attr_name);
  brow_SetAnnotation(node, 0, annot, strlen(annot));

  // Examine access
  ldh_GetSessionInfo(ldhses, &info);
  if (info.Access == ldh_eAccess_ReadWrite
      && !(flags & PWR_MASK_NOEDIT || flags & PWR_MASK_STATE))
    brow_SetAnnotPixmap(node, 1, brow->pixmap_morehelp);

  update();
}

WItemAttrArrayOutput::~WItemAttrArrayOutput()
{
}

int WItemAttrArrayOutput::update()
{
  int sts;
  int psize;
  pwr_eClass eclass;
  pwr_sPlcNode* plcnode;

  sts = ldh_GetObjectBuffer(
      ldhses, objid, "DevBody", "PlcNode", &eclass, (char**)&plcnode, &psize);
  if (EVEN(sts))
    return sts;

  // Used mask
  if (plcnode->mask[1] & mask)
    brow_SetRadiobutton(node, 0, 1);
  else
    brow_SetRadiobutton(node, 0, 0);

  free((char*)plcnode);

  return WNAV__SUCCESS;
}

int WItemAttrArrayOutput::set_mask(int radio_button, int value)
{
  int sts;
  int psize;
  pwr_eClass eclass;
  pwr_sPlcNode* plcnode;
  int ldh_cb_used = brow->ldh_cb_used;

  sts = ldh_GetObjectBuffer(
      ldhses, objid, "DevBody", "PlcNode", &eclass, (char**)&plcnode, &psize);
  if (EVEN(sts))
    return sts;

  // Used mask
  if (radio_button == 0) {
    if (value == 1)
      plcnode->mask[1] |= mask;
    else
      plcnode->mask[1] &= ~mask;
  }

  sts = ldh_SetObjectBuffer(
      ldhses, objid, "DevBody", "PlcNode", (char*)plcnode);
  if (EVEN(sts))
    return sts;

  if (!ldh_cb_used) {
    if (plcnode->mask[1] & mask)
      brow_SetRadiobutton(node, 0, 1);
    else
      brow_SetRadiobutton(node, 0, 0);

    free((char*)plcnode);
  }

  return WNAV__SUCCESS;
}

int WItemAttrArrayOutput::open_attributes(double x, double y)
{
  double node_x, node_y;
  int i;

  brow_GetNodePosition(node, &node_x, &node_y);

  if (brow_IsOpen(node) & wnav_mOpen_Attributes) {
    // Attributes is open, close
    brow_SetNodraw(brow->ctx);
    brow_CloseNode(brow->ctx, node);
    brow_ResetOpen(node, wnav_mOpen_All);
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, node_y);
  } else {
    // Create some elements
    brow_SetNodraw(brow->ctx);

    for (i = 0; i < elements; i++) {
      new WItemAttrArrayElem(brow, ldhses, objid, node, flow_eDest_IntoLast,
          name, i, type_id, tid, size / elements, i * size / elements, flags,
          body);
    }

    brow_SetOpen(node, wnav_mOpen_Attributes);
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, node_y);
  }
  return 1;
}

int WItemAttrArrayOutput::close(double x, double y)
{
  double node_x, node_y;

  if (brow_IsOpen(node) & wnav_mOpen_Attributes) {
    // Attributes is open, close
    brow_GetNodePosition(node, &node_x, &node_y);
    brow_SetNodraw(brow->ctx);
    brow_CloseNode(brow->ctx, node);
    brow_ResetOpen(node, wnav_mOpen_All);
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, node_y);
  }
  return 1;
}

WItemAttrObject::WItemAttrObject(WNavBrow* item_brow,
    ldh_tSesContext item_ldhses, pwr_tObjid item_objid, brow_tNode dest,
    flow_eDest dest_code, char* attr_name, int attr_type_id, int attr_size,
    bool attr_is_elem, int attr_idx, int attr_flags, char* attr_body,
    int fullname)
    : WItemBaseAttr(item_brow, item_ldhses, item_objid, attr_name, attr_type_id,
          0, attr_size, attr_flags, attr_body),
      is_elem(attr_is_elem), idx(attr_idx)
{
  ldh_sSessInfo info;
  pwr_tOName annot;
  int psize;
  int sts;
  char* s;
  int next_annot = 0;

  type = wnav_eItemType_AttrObject;

  if (!is_elem)
    strcpy(name, attr_name);
  else
    sprintf(name, "%s[%d]", attr_name, idx);
  strcpy(body, attr_body);
  brow_CreateNode(brow->ctx, attr_name, brow->nc_object, dest, dest_code,
      (void*)this, 1, &node);

  if (flags & PWR_MASK_CASTATTR) {
    // Replace tid from class definition to tid from actual attribute
    pwr_tTid tid;
    pwr_sAttrRef attrref = aref();
    sts = ldh_GetAttrRefTid(ldhses, &attrref, &tid);
    if ((int)tid == type_id)
      brow_SetAnnotPixmap(node, 0, brow->pixmap_uncastattr);
    else {
      type_id = tid;
      brow_SetAnnotPixmap(node, 0, brow->pixmap_castattr);
    }
  } else
    brow_SetAnnotPixmap(node, 0, brow->pixmap_object);

  if (flags & PWR_MASK_CASTATTR) {
  }

  if (fullname) {
    sts = ldh_ObjidToName(
        ldhses, objid, ldh_eName_Hierarchy, annot, sizeof(annot), &psize);
    strcat(annot, ".");
    strcat(annot, attr_name);
  } else {
    s = strrchr(name, '.');
    if (s)
      strcpy(annot, s + 1);
    else
      strcpy(annot, name);
  }

  brow_SetAnnotation(node, next_annot++, annot, strlen(annot));

  // Set class annotation
  if (((WNav*)brow->userdata)->gbl.show_class) {
    ldh_tSession lses;

    // Objects in mounted volumes has to use its own metavolumes.
    if (ldh_ExternObject(ldhses, objid))
      ldh_OpenMntSession(ldhses, objid, &lses);
    else
      lses = ldhses;

    sts = ldh_ObjidToName(lses, cdh_ClassIdToObjid(type_id), ldh_eName_Object,
        annot, sizeof(annot), &psize);
    if (ODD(sts))
      brow_SetAnnotation(node, next_annot++, annot, strlen(annot));

    if (lses != ldhses)
      ldh_CloseSession(lses);
  }

  // Set description annotation
  if (((WNav*)brow->userdata)->gbl.show_descrip) {
    char descr_attr[120];
    char* descr;

    strcpy(descr_attr, name);
    strcat(descr_attr, ".Description");

    sts = ldh_GetObjectPar(ldhses, objid, "RtBody", descr_attr, &descr, &psize);
    if (EVEN(sts))
      sts = ldh_GetObjectPar(
          ldhses, objid, "SysBody", descr_attr, &descr, &psize);
    if (ODD(sts)) {
      brow_SetAnnotation(node, next_annot++, descr, strlen(descr));
      free(descr);
    }
  }

  // Examine access
  ldh_GetSessionInfo(ldhses, &info);
  if (info.Access == ldh_eAccess_ReadWrite
      && !(flags & PWR_MASK_NOEDIT || flags & PWR_MASK_STATE))
    brow_SetAnnotPixmap(node, 1, brow->pixmap_morehelp);
}

WItemAttrObject::~WItemAttrObject()
{
}

int WItemAttrObject::close(double x, double y)
{
  double node_x, node_y;

  if (brow_IsOpen(node)) {
    // Close
    brow_GetNodePosition(node, &node_x, &node_y);
    brow_SetNodraw(brow->ctx);
    brow_CloseNode(brow->ctx, node);
    if (brow_IsOpen(node) & wnav_mOpen_Attributes)
      brow_RemoveAnnotPixmap(node, 1);
    brow_ResetOpen(node, wnav_mOpen_All);
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, node_y);
  }
  return 1;
}

int WItemAttrObject::open_attributes(double x, double y)
{
  double node_x, node_y;

  if (cdh_ObjidIsNull(objid))
    return 1;

  brow_GetNodePosition(node, &node_x, &node_y);

  if (brow_IsOpen(node)) {
    // Close
    brow_SetNodraw(brow->ctx);
    brow_CloseNode(brow->ctx, node);
    if (brow_IsOpen(node) & wnav_mOpen_Attributes)
      brow_RemoveAnnotPixmap(node, 1);
    brow_ResetOpen(node, wnav_mOpen_All);
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, node_y);
  } else {
    int sts;
    pwr_tOName parname;
    pwr_tClassId classid;
    pwr_tClassId orig_classid;
    unsigned long elements;
    ldh_sParDef* bodydef;
    int rows;
    int i, j;
    char body[20];
    int attr_exist = 0;
    int input_cnt = 0;
    int output_cnt = 0;
    int is_casted = 0;
    ldh_tSession lses;

    classid = type_id;

    // Objects in mounted volumes has to use its own metavolumes.
    if (ldh_ExternObject(ldhses, objid))
      ldh_OpenMntSession(ldhses, objid, &lses);
    else
      lses = ldhses;

    // Check if attrobject is casted
    if (flags & PWR_MASK_CASTATTR) {
      pwr_sAttrRef ar = cdh_ObjidToAref(objid);
      pwr_sAttrRef aar;

      sts = ldh_ArefANameToAref(lses, &ar, name, &aar);
      if (EVEN(sts))
        return sts;

      sts = ldh_GetAttrRefOrigTid(lses, &aar, &orig_classid);
      if (EVEN(sts))
        return sts;

      if (orig_classid != classid) {
        is_casted = 1;
        if (((WNav*)brow->userdata)->gbl.show_truedb)
          classid = orig_classid;
      }
    }

    // Create some attributes
    brow_SetNodraw(brow->ctx);

    for (i = 0; i < 3; i++) {
      if (i == 0)
        strcpy(body, "RtBody");
      else if (i == 1)
        strcpy(body, "DevBody");
      else
        strcpy(body, "SysBody");

      if (((WNav*)brow->userdata)->gbl.show_truedb)
        sts = ldh_GetTrueObjectBodyDef(lses, classid, body, 1, &bodydef, &rows);
      else
        sts = ldh_GetObjectBodyDef(lses, classid, body, 1, &bodydef, &rows);
      if (EVEN(sts))
        continue;
      for (j = 0; j < rows; j++) {
        if (is_casted) {
          // Remove any leading 'super.' in parname
          strcpy(parname, name);
          strcat(parname, ".");
          if (str_StartsWith(bodydef[j].ParName, "Super."))
            strcat(parname, &bodydef[j].ParName[6]);
          else
            strcat(parname, bodydef[j].ParName);
        } else {
          strcpy(parname, name);
          strcat(parname, ".");
          strcat(parname, bodydef[j].ParName);
        }

        if (bodydef[j].Flags & ldh_mParDef_Shadowed)
          continue;
        if (bodydef[j].Par->Output.Info.Flags & PWR_MASK_POINTER)
          continue;
        if (bodydef[j].Par->Output.Info.Flags & PWR_MASK_INVISIBLE
            && !((WNav*)brow->userdata)->gbl.show_truedb)
          continue;
        if (bodydef[j].Par->Output.Info.Flags & PWR_MASK_DISABLEATTR
            && !((WNav*)brow->userdata)->gbl.show_truedb && j > 0) {
          pwr_tDisableAttr disabled;
          pwr_sAttrRef aar;
          pwr_sAttrRef ar = cdh_ObjidToAref(objid);

          sts = ldh_ArefANameToAref(lses, &ar, parname, &aar);
          if (EVEN(sts))
            return sts;

          sts = ldh_AttributeDisabled(lses, &aar, &disabled);
          if (EVEN(sts))
            return sts;

          if (disabled)
            continue;
        }

        if (bodydef[j].Par->Output.Info.Flags & PWR_MASK_ARRAY) {
          elements = bodydef[j].Par->Output.Info.Elements;

          if (bodydef[j].ParClass == pwr_eClass_Output) {
            new WItemAttrArrayOutput(brow, ldhses, objid, node,
                flow_eDest_IntoLast, parname,
                bodydef[j].Par->Output.Info.Elements,
                bodydef[j].Par->Output.Info.Type,
                bodydef[j].Par->Output.TypeRef,
                bodydef[j].Par->Output.Info.Size,
                bodydef[j].Par->Output.Info.Flags, body, output_cnt);
            output_cnt++;
          } else
            new WItemAttrArray(brow, ldhses, objid, node, flow_eDest_IntoLast,
                parname, bodydef[j].Par->Output.Info.Elements,
                bodydef[j].Par->Output.Info.Type,
                bodydef[j].Par->Output.TypeRef,
                bodydef[j].Par->Output.Info.Size,
                bodydef[j].Par->Output.Info.Flags, body, 0);
          attr_exist = 1;
        } else if (bodydef[j].ParClass == pwr_eClass_Input) {
          if (bodydef[j].Par->Input.Info.Type == pwr_eType_Boolean) {
            if (bodydef[j].Par->Input.Info.Flags & PWR_MASK_NOREMOVE
                && bodydef[j].Par->Input.Info.Flags & PWR_MASK_NOINVERT)
              new WItemAttr(brow, ldhses, objid, node, flow_eDest_IntoLast,
                  parname, bodydef[j].Par->Input.Info.Type,
                  bodydef[j].Par->Input.TypeRef,
                  bodydef[j].Par->Input.Info.Size,
                  bodydef[j].Par->Input.Info.Flags, body, 0);
            else if (bodydef[j].Par->Input.Info.Flags & PWR_MASK_NOREMOVE)
              new WItemAttrInputInv(brow, ldhses, objid, node,
                  flow_eDest_IntoLast, parname, bodydef[j].Par->Input.Info.Type,
                  bodydef[j].Par->Input.TypeRef,
                  bodydef[j].Par->Input.Info.Size,
                  bodydef[j].Par->Input.Info.Flags, body, input_cnt);
            else if (bodydef[j].Par->Input.Info.Flags & PWR_MASK_NOINVERT)
              new WItemAttrInputF(brow, ldhses, objid, node,
                  flow_eDest_IntoLast, parname, bodydef[j].Par->Input.Info.Type,
                  bodydef[j].Par->Input.TypeRef,
                  bodydef[j].Par->Input.Info.Size,
                  bodydef[j].Par->Input.Info.Flags, body, input_cnt);
            else
              new WItemAttrInput(brow, ldhses, objid, node, flow_eDest_IntoLast,
                  parname, bodydef[j].Par->Input.Info.Type,
                  bodydef[j].Par->Input.TypeRef,
                  bodydef[j].Par->Input.Info.Size,
                  bodydef[j].Par->Input.Info.Flags, body, input_cnt);
          } else {
            if (bodydef[j].Par->Input.Info.Flags & PWR_MASK_NOREMOVE)
              new WItemAttr(brow, ldhses, objid, node, flow_eDest_IntoLast,
                  parname, bodydef[j].Par->Input.Info.Type,
                  bodydef[j].Par->Input.TypeRef,
                  bodydef[j].Par->Input.Info.Size,
                  bodydef[j].Par->Input.Info.Flags, body, 0);
            else
              new WItemAttrInputF(brow, ldhses, objid, node,
                  flow_eDest_IntoLast, parname, bodydef[j].Par->Input.Info.Type,
                  bodydef[j].Par->Input.TypeRef,
                  bodydef[j].Par->Input.Info.Size,
                  bodydef[j].Par->Input.Info.Flags, body, input_cnt);
          }
          attr_exist = 1;
          input_cnt++;
        } else if (bodydef[j].ParClass == pwr_eClass_Output) {
          if (bodydef[j].Par->Output.Info.Flags & PWR_MASK_NOREMOVE)
            new WItemAttr(brow, ldhses, objid, node, flow_eDest_IntoLast,
                parname, bodydef[j].Par->Output.Info.Type,
                bodydef[j].Par->Output.TypeRef,
                bodydef[j].Par->Output.Info.Size,
                bodydef[j].Par->Output.Info.Flags, body, 0);
          else
            new WItemAttrOutput(brow, ldhses, objid, node, flow_eDest_IntoLast,
                parname, bodydef[j].Par->Output.Info.Type,
                bodydef[j].Par->Output.TypeRef,
                bodydef[j].Par->Output.Info.Size,
                bodydef[j].Par->Output.Info.Flags, body, output_cnt);
          attr_exist = 1;
          output_cnt++;
        } else {
          if (bodydef[j].Par->Output.Info.Flags & PWR_MASK_CLASS)
            new WItemAttrObject(brow, ldhses, objid, node, flow_eDest_IntoLast,
                parname, bodydef[j].Par->Output.Info.Type,
                bodydef[j].Par->Output.Info.Size, false, 0,
                bodydef[j].Par->Output.Info.Flags, body, 0);
          else
            new WItemAttr(brow, ldhses, objid, node, flow_eDest_IntoLast,
                parname, bodydef[j].Par->Output.Info.Type,
                bodydef[j].Par->Output.TypeRef,
                bodydef[j].Par->Output.Info.Size,
                bodydef[j].Par->Output.Info.Flags, body, 0);
          attr_exist = 1;
        }
      }
      free((char*)bodydef);
    }

    if (lses != ldhses)
      ldh_CloseSession(lses);

    if (attr_exist && !is_root) {
      brow_SetOpen(node, wnav_mOpen_Attributes);
      brow_SetAnnotPixmap(node, 1, brow->pixmap_openattr);
    }
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, node_y);
  }
  return 1;
}

int WItemAttrObject::open_crossref(WNav* wnav, double x, double y)
{
  double node_x, node_y;
  int crossref_exist;
  int sts;
  pwr_tClassId classid;
  char* aname;
  pwr_sAttrRef objar;

  if (cdh_ObjidIsNull(objid))
    return 1;

  brow_GetNodePosition(node, &node_x, &node_y);

  if (brow_IsOpen(node)) {
    // Close
    brow_SetNodraw(wnav->brow->ctx);
    brow_CloseNode(wnav->brow->ctx, node);
    if (brow_IsOpen(node) & wnav_mOpen_Attributes)
      brow_RemoveAnnotPixmap(node, 1);
    brow_ResetOpen(node, wnav_mOpen_All);
    brow_ResetNodraw(wnav->brow->ctx);
    brow_Redraw(wnav->brow->ctx, node_y);
  } else {
    // Fetch the cross reference list
    crossref_exist = 0;
    brow_SetNodraw(wnav->brow->ctx);

    objar = aref();

    sts = ldh_GetAttrRefTid(wnav->ldhses, &objar, &classid);
    if (EVEN(sts))
      return sts;

    sts = ldh_AttrRefToName(ldhses, &objar, cdh_mNName, &aname, &size);
    if (EVEN(sts))
      return sts;

    switch (classid) {
    case pwr_cClass_Di:
    case pwr_cClass_Dv:
    case pwr_cClass_Do:
    case pwr_cClass_Po:
    case pwr_cClass_Av:
    case pwr_cClass_Ai:
    case pwr_cClass_Ao:
    case pwr_cClass_Iv:
    case pwr_cClass_Ii:
    case pwr_cClass_Io:
    case pwr_cClass_Sv:
    case pwr_cClass_ATv:
    case pwr_cClass_DTv:
      sts = wnav->crr_signal(wnav->brow, wnav->ldhses, NULL, aname, node);
      break;
    default:
      sts = wnav->crr_object(wnav->brow, wnav->ldhses, NULL, aname, node);
    }
    if (sts == NAV__OBJECTNOTFOUND)
      wnav->message('E', "Object not found in crossreferens file");
    else if (sts == NAV__NOCROSSREF)
      wnav->message('I', "There is no crossreferences for this object");
    else if (ODD(sts)) {
      brow_SetOpen(node, wnav_mOpen_Crossref);
      crossref_exist = 1;
    }
    brow_ResetNodraw(wnav->brow->ctx);
    if (crossref_exist)
      brow_Redraw(wnav->brow->ctx, node_y);
  }
  return 1;
}

WItemAttrArrayElem::WItemAttrArrayElem(WNavBrow* item_brow,
    ldh_tSesContext item_ldhses, pwr_tObjid item_objid, brow_tNode dest,
    flow_eDest dest_code, char* attr_name, int attr_element, int attr_type_id,
    pwr_tTid attr_tid, int attr_size, int attr_offset, int attr_flags,
    char* attr_body)
    : WItemBaseAttr(item_brow, item_ldhses, item_objid, attr_name, attr_type_id,
          attr_tid, attr_size, attr_flags, attr_body),
      element(attr_element), offset(attr_offset)
{
  char annot[120];
  ldh_sSessInfo info;
  char* s;

  type = wnav_eItemType_AttrArrayElem;

  sprintf(name, "%s[%d]", attr_name, element);
  s = strrchr(name, '.');
  if (s)
    strcpy(annot, s + 1);
  else
    strcpy(annot, name);

  switch (type_id) {
  case pwr_eType_Objid:
    brow_CreateNode(brow->ctx, attr_name, brow->nc_attr, dest, dest_code,
        (void*)this, 1, &node);
    brow_SetAnnotPixmap(node, 0, brow->pixmap_ref);
    break;
  case pwr_eType_Enum:
    brow_CreateNode(brow->ctx, attr_name, brow->nc_attr, dest, dest_code,
        (void*)this, 1, &node);
    brow_SetAnnotPixmap(node, 0, brow->pixmap_attrenum);
    break;
  case pwr_eType_Mask:
    brow_CreateNode(brow->ctx, attr_name, brow->nc_attr, dest, dest_code,
        (void*)this, 1, &node);
    brow_SetAnnotPixmap(node, 0, brow->pixmap_attrmask);
    break;
  case pwr_eType_Text:
    brow_CreateNode(brow->ctx, attr_name, brow->nc_attr_multiline, dest,
        dest_code, (void*)this, 1, &node);
    brow_SetAnnotPixmap(node, 0, brow->pixmap_attr);
    break;
  default:
    brow_CreateNode(brow->ctx, attr_name, brow->nc_attr, dest, dest_code,
        (void*)this, 1, &node);
    brow_SetAnnotPixmap(node, 0, brow->pixmap_attr);
  }
  brow_SetAnnotation(node, 0, annot, strlen(annot));

  // Examine access
  ldh_GetSessionInfo(ldhses, &info);
  if (info.Access == ldh_eAccess_ReadWrite
      && !(flags & PWR_MASK_NOEDIT || flags & PWR_MASK_STATE))
    brow_SetAnnotPixmap(node, 1, brow->pixmap_morehelp);

  update();
}

WItemAttrArrayElem::~WItemAttrArrayElem()
{
}

int WItemAttrArrayElem::get_value(char** value)
{
  int psize;
  char* attr_value;
  int sts;

  sts = ldh_GetObjectPar(ldhses, objid, body, attr, &attr_value, &psize);
  if (EVEN(sts))
    return sts;

  *value = (char*)malloc(size);
  memcpy(*value, attr_value + offset, size);
  free(attr_value);

  return WNAV__SUCCESS;
}

int WItemAttrArrayElem::open_children(double x, double y)
{
  double node_x, node_y;
  int sts;

  switch (type_id) {
  case pwr_eType_Enum:
  case pwr_eType_Mask:
  case pwr_eType_Objid:
  case pwr_eType_AttrRef:
    break;
  default:
    return WNAV__NOCHILDREN;
  }

  brow_GetNodePosition(node, &node_x, &node_y);

  if (brow_IsOpen(node)) {
    // Close
    brow_SetNodraw(brow->ctx);
    brow_CloseNode(brow->ctx, node);
    if (brow_IsOpen(node) & wnav_mOpen_Attributes)
      brow_RemoveAnnotPixmap(node, 1);
    if (brow_IsOpen(node) & wnav_mOpen_Children) {
      switch (type_id) {
      case pwr_eType_Enum:
        brow_SetAnnotPixmap(node, 0, brow->pixmap_attrenum);
        break;
      case pwr_eType_Mask:
        brow_SetAnnotPixmap(node, 0, brow->pixmap_attrmask);
        break;
      default:
        brow_SetAnnotPixmap(node, 0, brow->pixmap_attr);
      }
    }
    brow_ResetOpen(node, wnav_mOpen_All);
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, node_y);
  } else // if ( parent && !noedit)
  {
    switch (type_id) {
    case pwr_eType_Enum: {
      ldh_sValueDef* vd;
      int rows;

      sts = ldh_GetEnumValueDef(ldhses, tid, &vd, &rows);
      if (EVEN(sts))
        return WNAV__NOCHILDREN;

      // Create some children
      brow_SetNodraw(brow->ctx);

      for (int i = 0; i < rows; i++) {
        new WItemEnum(brow, ldhses, objid, vd[i].Value.Text, attr, type_id, tid,
            size, flags, body, vd[i].Value.Value, 1, element, node,
            flow_eDest_IntoLast);
      }
      free((char*)vd);
      break;
    }
    case pwr_eType_Mask: {
      ldh_sBitDef* bd;
      int rows;

      sts = ldh_GetMaskBitDef(ldhses, tid, &bd, &rows);
      if (EVEN(sts))
        return WNAV__NOCHILDREN;

      // Create some children
      brow_SetNodraw(brow->ctx);

      for (int i = 0; i < rows; i++) {
        new WItemMask(brow, ldhses, objid, bd[i].Bit->Text, attr, type_id, tid,
            size, flags, body, (unsigned int)bd[i].Bit->Value, 1, element, node,
            flow_eDest_IntoLast);
      }
      free((char*)bd);
      break;
    }
    case pwr_eType_Objid:
    case pwr_eType_AttrRef: {
      pwr_sClass_ReferenceList listbody;
      pwr_tOName oname;
      int nametype;
      wb_session* sp = (wb_session*)ldhses;
      int idx = 0;
      char* s;
      pwr_tCid cid_attrobj;
      pwr_tOName name_attrobj;
      pwr_tAName aname;

      try {
        // Get class for attribute object, lowest level
        wb_object o = sp->object(objid);

        strcpy(name_attrobj, name);
        if ((s = strrchr(name_attrobj, '.'))) {
          *s = 0;
          strcpy(aname, o.longName().name(cdh_mName_volumeStrict));
          strcat(aname, ".");
          strcat(aname, name_attrobj);

          wb_attribute a_attrobj = sp->attribute(aname);
          cid_attrobj = a_attrobj.tid();
        } else
          cid_attrobj = classid;

        sts = item_get_reflist_object(sp, classid, attr, &listbody);
        if (EVEN(sts))
          return WNAV__NOCHILDREN;

        if (type_id == pwr_eType_Objid) {
          brow_SetNodraw(brow->ctx);

          if (listbody.Filter & pwr_mRefListFilterMask_Other)
            new WItemEnumObject(brow, ldhses, objid, (char*)"Other", attr,
                item_eType_Other, tid, size, flags, body, &objid, 0, 0, idx++,
                node, flow_eDest_IntoLast);

          for (wb_object co = sp->object(listbody.ObjectClass[0]); co;
               co = co.next()) {
            if (listbody.Filter & pwr_mRefListFilterMask_Siblings) {
              // Check if objects are siblings
              wb_object p1 = o.parent();
              wb_object p2 = co.parent();
              if ((!p1 && !p2)
                  || (p1 && p2 && cdh_ObjidIsNotEqual(p1.oid(), p2.oid())))
                continue;
            }

            if (listbody.Filter & pwr_mRefListFilterMask_Children) {
              // Check if object is child
              wb_object p1 = co.parent();
              if (!p1)
                continue;

              if (cdh_ObjidIsNotEqual(p1.oid(), o.oid()))
                continue;
            }

            if (listbody.Filter & pwr_mRefListFilterMask_AllVolumes)
              nametype = cdh_mName_volumeStrict;
            else
              nametype = cdh_mName_pathStrict;

            strcpy(oname, co.longName().name(nametype));

            pwr_tOid oid = co.oid();
            new WItemEnumObject(brow, ldhses, objid, oname, attr, type_id, tid,
                size, flags, body, &oid, 1, element, idx++, node,
                flow_eDest_IntoLast);
          }
        } else {
          // type_id is AttrRef
          pwr_tAttrRef aref;

          brow_SetNodraw(brow->ctx);

          if (listbody.Filter & pwr_mRefListFilterMask_Other)
            new WItemEnumObject(brow, ldhses, objid, (char*)"Other", attr,
                item_eType_Other, tid, size, flags, body, &objid, 0, 0, idx++,
                node, flow_eDest_IntoLast);

          for (unsigned int i = 0; i
               < sizeof(listbody.ObjectClass) / sizeof(listbody.ObjectClass[0]);
               i++) {
            if (listbody.ObjectClass[i] == 0)
              break;

            if (listbody.Filter & pwr_mRefListFilterMask_AttrObjects) {
              for (sp->aref(listbody.ObjectClass[i], &aref); sp->oddSts();
                   sp->nextAref(listbody.ObjectClass[i], &aref, &aref)) {
                if (listbody.Filter & pwr_mRefListFilterMask_Siblings) {
                  // Check if object are siblings
                  wb_object co = sp->object(aref.Objid);
                  if (!co)
                    continue;

                  wb_object p1 = o.parent();
                  wb_object p2 = co.parent();
                  if ((!p1 && !p2)
                      || (p1 && p2 && cdh_ObjidIsNotEqual(p1.oid(), p2.oid())))
                    continue;
                }

                if (listbody.Filter & pwr_mRefListFilterMask_Children) {
                  // Check if object is child
                  wb_object co = sp->object(aref.Objid);
                  if (!co)
                    continue;

                  wb_object p1 = co.parent();
                  if (!p1)
                    continue;

                  if (cdh_ObjidIsNotEqual(p1.oid(), o.oid()))
                    continue;
                }

                wb_attribute ca = sp->attribute(&aref);
                if (listbody.Filter & pwr_mRefListFilterMask_AllVolumes)
                  nametype = cdh_mName_volumeStrict;
                else
                  nametype = cdh_mName_pathStrict;

                strcpy(oname, ca.longName().name(nametype));

                new WItemEnumObject(brow, ldhses, objid, oname, attr, type_id,
                    tid, size, flags, body, &aref, 1, element, idx++, node,
                    flow_eDest_IntoLast);
              }
            } else {
              for (wb_object co = sp->object(listbody.ObjectClass[i]); co;
                   co = co.next()) {
                if (listbody.Filter & pwr_mRefListFilterMask_Siblings) {
                  // Check if object are siblings
                  wb_object p1 = o.parent();
                  wb_object p2 = co.parent();
                  if ((!p1 && !p2)
                      || (p1 && p2 && cdh_ObjidIsNotEqual(p1.oid(), p2.oid())))
                    continue;
                }

                if (listbody.Filter & pwr_mRefListFilterMask_Children) {
                  // Check if object is child
                  wb_object p1 = co.parent();
                  if (!p1)
                    continue;

                  if (cdh_ObjidIsNotEqual(p1.oid(), o.oid()))
                    continue;
                }

                if (listbody.Filter & pwr_mRefListFilterMask_AllVolumes)
                  nametype = cdh_mName_volumeStrict;
                else
                  nametype = cdh_mName_pathStrict;

                strcpy(oname, co.longName().name(nametype));

                pwr_tAttrRef aref = cdh_ObjidToAref(co.oid());
                new WItemEnumObject(brow, ldhses, objid, oname, attr, type_id,
                    tid, size, flags, body, &aref, 1, element, idx++, node,
                    flow_eDest_IntoLast);
              }
            }
          }
        }
      } catch (wb_error& e) {
        brow_ResetNodraw(brow->ctx);
        brow_Redraw(brow->ctx, node_y);
        return WNAV__NOCHILDREN;
      }
      break;
    }
    default:
      return WNAV__NOCHILDREN;
    }

    brow_SetOpen(node, wnav_mOpen_Children);
    brow_SetAnnotPixmap(node, 0, brow->pixmap_openmap);
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, node_y);
  }
  return 1;
}

int WItemAttrArrayElem::close(double x, double y)
{
  double node_x, node_y;

  brow_GetNodePosition(node, &node_x, &node_y);

  if (brow_IsOpen(node)) {
    // Close
    brow_SetNodraw(brow->ctx);
    brow_CloseNode(brow->ctx, node);
    if (brow_IsOpen(node) & wnav_mOpen_Attributes)
      brow_RemoveAnnotPixmap(node, 1);
    if (brow_IsOpen(node) & wnav_mOpen_Children) {
      switch (type_id) {
      case pwr_eType_Enum:
        brow_SetAnnotPixmap(node, 0, brow->pixmap_attrenum);
        break;
      case pwr_eType_Mask:
        brow_SetAnnotPixmap(node, 0, brow->pixmap_attrmask);
        break;
      default:
        brow_SetAnnotPixmap(node, 0, brow->pixmap_attr);
      }
    }
    brow_ResetOpen(node, wnav_mOpen_All);
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, node_y);
  }
  return 1;
}

int WItemAttrArrayElem::update()
{
  int sts;
  int psize;
  void* value;
  char* buff = NULL;
  int len = 0;
  char buf[80];

  // Get the attribute value
  sts = ldh_GetObjectPar(ldhses, objid, body, attr, (char**)&value, &psize);
  if (EVEN(sts))
    return sts;

  switch (type_id) {
  case pwr_eType_Enum: {
    ldh_sValueDef* vd;
    int rows;
    bool found = false;

    sts = ldh_GetEnumValueDef(ldhses, tid, &vd, &rows);
    if (ODD(sts)) {
      for (int i = 0; i < rows; i++) {
        if (vd[i].Value.Value
            == *(pwr_tInt32*)((char*)value + size * element)) {
          strcpy(buf, vd[i].Value.Text);
          buff = buf;
          len = strlen(buf);
          found = true;
          break;
        }
      }
      free((char*)vd);
    }
    if (EVEN(sts) || !found)
      wnav_attrvalue_to_string(
          ldhses, type_id, (char*)value + size * element, &buff, &len);
    break;
  }
  default:
    wnav_attrvalue_to_string(
        ldhses, type_id, (char*)value + size * element, &buff, &len);
  }

  brow_SetAnnotation(node, 1, buff, len);
  free((char*)value);
  return WNAV__SUCCESS;
}

WItemEnum::WItemEnum(WNavBrow* item_brow, ldh_tSesContext item_ldhses,
    pwr_tObjid item_objid, char* attr_enum_name, char* attr_name,
    int attr_type_id, pwr_tTid attr_tid, int attr_size, int attr_flags,
    char* attr_body, unsigned int item_num, int item_is_element,
    int item_element, brow_tNode dest, flow_eDest dest_code)
    : WItemBaseAttr(item_brow, item_ldhses, item_objid, attr_name, attr_type_id,
          attr_tid, attr_size, attr_flags, attr_body),
      num(item_num), is_element(item_is_element), element(item_element)
{
  ldh_sSessInfo info;

  type = wnav_eItemType_Enum;
  sprintf(name, "%s%u", attr_name, num);
  strcpy(enum_name, attr_enum_name);

  brow_CreateNode(brow->ctx, enum_name, brow->nc_enum, dest, dest_code,
      (void*)this, 1, &node);

  brow_SetAnnotPixmap(node, 0, brow->pixmap_attr);
  brow_SetAnnotation(node, 0, enum_name, strlen(enum_name));

  // Examine access
  ldh_GetSessionInfo(ldhses, &info);
  if (info.Access == ldh_eAccess_ReadWrite
      && !(flags & PWR_MASK_NOEDIT || flags & PWR_MASK_STATE))
    brow_SetAnnotPixmap(node, 1, brow->pixmap_morehelp);

  update();
}

WItemEnum::~WItemEnum()
{
}

int WItemEnum::update()
{
  int sts;
  int psize;
  unsigned int* value;
  char* buf = NULL;

  // Get the attribute value
  if (!is_element) {
    sts = ldh_GetObjectPar(ldhses, objid, body, attr, (char**)&value, &psize);
    if (EVEN(sts))
      return sts;
  } else {
    sts = ldh_GetObjectPar(ldhses, objid, body, attr, &buf, &psize);
    if (EVEN(sts))
      return sts;
    value = (unsigned int*)(buf + size * element);
  }

  if (*value == num)
    brow_SetRadiobutton(node, 0, 1);
  else
    brow_SetRadiobutton(node, 0, 0);
  if (!is_element)
    free((char*)value);
  else
    free(buf);
  return WNAV__SUCCESS;
}

int WItemEnum::set()
{
  int sts;
  WItemAttr* item;
  WItemEnum* sibling_item;
  brow_tNode parent, sibling;
  char* buf;
  int psize;
  int ldh_cb_used = brow->ldh_cb_used;

  // Set the attribute value
  if (!is_element) {
    sts = ldh_SetObjectPar(ldhses, objid, body, attr, (char*)&num, sizeof(num));
    if (EVEN(sts))
      return sts;
  } else {
    sts = ldh_GetObjectPar(ldhses, objid, body, attr, &buf, &psize);
    if (EVEN(sts))
      return sts;
    *(unsigned int*)(buf + size * element) = num;

    sts = ldh_SetObjectPar(ldhses, objid, body, attr, buf, psize);
    if (EVEN(sts))
      return sts;

    // Warning!! the item will be deleted here by the ldh backcall
    free(buf);
  }

  if (!ldh_cb_used) {
    brow_SetRadiobutton(node, 0, 1);

    // Update parent
    sts = brow_GetParent(brow->ctx, node, &parent);
    if (EVEN(sts))
      return sts;
    brow_GetUserData(parent, (void**)&item);
    if (!is_element)
      item->update();
    else
      ((WItemAttrArrayElem*)item)->update();

    // Update all siblings
    sts = brow_GetChild(brow->ctx, parent, &sibling);
    while (ODD(sts)) {
      if (sibling != node) {
        brow_GetUserData(sibling, (void**)&sibling_item);
        sibling_item->update();
      }
      sts = brow_GetNextSibling(brow->ctx, sibling, &sibling);
    }
  }
  return WNAV__SUCCESS;
}

WItemMask::WItemMask(WNavBrow* item_brow, ldh_tSesContext item_ldhses,
    pwr_tObjid item_objid, char* attr_mask_name, char* attr_name,
    int attr_type_id, pwr_tTid attr_tid, int attr_size, int attr_flags,
    char* attr_body, unsigned int item_mask, int item_is_element,
    int item_element, brow_tNode dest, flow_eDest dest_code)
    : WItemBaseAttr(item_brow, item_ldhses, item_objid, attr_name, attr_type_id,
          attr_tid, attr_size, attr_flags, attr_body),
      mask(item_mask), is_element(item_is_element), element(item_element)
{
  ldh_sSessInfo info;

  type = wnav_eItemType_Mask;

  sprintf(name, "%s%u", attr_name, mask);
  strcpy(mask_name, attr_mask_name);

  brow_CreateNode(brow->ctx, mask_name, brow->nc_enum, dest, dest_code,
      (void*)this, 1, &node);

  brow_SetAnnotPixmap(node, 0, brow->pixmap_attr);
  brow_SetAnnotation(node, 0, mask_name, strlen(mask_name));

  // Examine access
  ldh_GetSessionInfo(ldhses, &info);
  if (info.Access == ldh_eAccess_ReadWrite
      && !(flags & PWR_MASK_NOEDIT || flags & PWR_MASK_STATE))
    brow_SetAnnotPixmap(node, 1, brow->pixmap_morehelp);

  update();
}

WItemMask::~WItemMask()
{
}

int WItemMask::update()
{
  int sts;
  int psize;
  unsigned int* value;
  char* buf = NULL;

  // Get the attribute value
  if (!is_element) {
    sts = ldh_GetObjectPar(ldhses, objid, body, attr, (char**)&value, &psize);
    if (EVEN(sts))
      return sts;
  } else {
    sts = ldh_GetObjectPar(ldhses, objid, body, attr, &buf, &psize);
    if (EVEN(sts))
      return sts;
    value = (unsigned int*)(buf + size * element);
  }

  if (*value & mask)
    brow_SetRadiobutton(node, 0, 1);
  else
    brow_SetRadiobutton(node, 0, 0);
  if (!is_element)
    free((char*)value);
  else
    free(buf);
  return WNAV__SUCCESS;
}

int WItemMask::set(int set_value)
{
  int sts;
  int psize;
  unsigned int* value;
  WItemAttr* item;
  brow_tNode parent;
  char* buf = NULL;
  int is_elem = is_element;
  int ldh_cb_used = brow->ldh_cb_used;

  // Get the attribute value
  if (!is_elem) {
    sts = ldh_GetObjectPar(ldhses, objid, body, attr, (char**)&value, &psize);
    if (EVEN(sts))
      return sts;

    if (set_value)
      *value |= mask;
    else
      *value &= ~mask;

    sts = ldh_SetObjectPar(ldhses, objid, body, attr, (char*)value, psize);
    if (EVEN(sts))
      return sts;
  } else {
    sts = ldh_GetObjectPar(ldhses, objid, body, attr, &buf, &psize);
    if (EVEN(sts))
      return sts;
    value = (unsigned int*)(buf + size * element);
    if (set_value)
      *value |= mask;
    else
      *value &= ~mask;

    sts = ldh_SetObjectPar(ldhses, objid, body, attr, buf, psize);
    if (EVEN(sts))
      return sts;

    // Warning!! the item will be deleted here by the ldh backcall
  }

  if (!ldh_cb_used) {
    if (*value & mask)
      brow_SetRadiobutton(node, 0, 1);
    else
      brow_SetRadiobutton(node, 0, 0);
  }

  if (!is_elem)
    free((char*)value);
  else
    free(buf);

  if (!ldh_cb_used) {
    // Update parent
    sts = brow_GetParent(brow->ctx, node, &parent);
    if (EVEN(sts))
      return sts;
    brow_GetUserData(parent, (void**)&item);
    if (!is_element)
      item->update();
    else
      ((WItemAttrArrayElem*)item)->update();
  }

  return WNAV__SUCCESS;
}

WItemEnumObject::WItemEnumObject(WNavBrow* item_brow,
    ldh_tSesContext item_ldhses, pwr_tObjid item_objid, char* attr_enum_name,
    char* attr_name, int attr_type_id, pwr_tTid attr_tid, int attr_size,
    int attr_flags, char* attr_body, void* item_enum_value, int item_is_element,
    int item_element, int item_idx, brow_tNode dest, flow_eDest dest_code)
    : WItemBaseAttr(item_brow, item_ldhses, item_objid, attr_name, attr_type_id,
          attr_tid, attr_size, attr_flags, attr_body),
      is_element(item_is_element), element(item_element)
{
  type = wnav_eItemType_EnumObject;
  switch (type_id) {
  case pwr_eType_Objid:
  case pwr_eType_TypeId:
    enum_aref.Objid = *(pwr_tObjid*)item_enum_value;
    break;
  case pwr_eType_AttrRef:
    enum_aref = *(pwr_tAttrRef*)item_enum_value;
    break;
  case item_eType_ObjectName:
    strncpy(enum_string, (char*)item_enum_value, sizeof(enum_string));
    break;
  case item_eType_Other:
    break;
  default:;
  }

  sprintf(name, "%s%d", attr_name, item_idx);
  strcpy(enum_name, attr_enum_name);

  brow_CreateNode(brow->ctx, enum_name, brow->nc_enumobject, dest, dest_code,
      (void*)this, 1, &node);

  // brow_SetAnnotPixmap( node, 0, brow->pixmap_attr);
  brow_SetAnnotation(node, 0, enum_name, strlen(enum_name));

  update();
}

WItemEnumObject::~WItemEnumObject()
{
}

int WItemEnumObject::update()
{
  int sts;
  int psize;
  char* buf = NULL;

  switch (type_id) {
  case pwr_eType_Objid: {
    pwr_tOid* value;
    // Get the attribute value
    if (!is_element) {
      sts = ldh_GetObjectPar(ldhses, objid, body, attr, (char**)&value, &psize);
      if (EVEN(sts))
        return sts;
    } else {
      sts = ldh_GetObjectPar(ldhses, objid, body, attr, &buf, &psize);
      if (EVEN(sts))
        return sts;
      value = (pwr_tOid*)(buf + size * element);
    }

    if (cdh_ObjidIsEqual(*value, enum_aref.Objid))
      brow_SetRadiobutton(node, 0, 1);
    else
      brow_SetRadiobutton(node, 0, 0);
    if (!is_element)
      free((char*)value);
    else
      free(buf);
    break;
  }
  case pwr_eType_TypeId: {
    pwr_tTypeId* value;
    pwr_tOid oid;

    // Get the attribute value
    if (!is_element) {
      sts = ldh_GetObjectPar(ldhses, objid, body, attr, (char**)&value, &psize);
      if (EVEN(sts))
        return sts;
    } else {
      sts = ldh_GetObjectPar(ldhses, objid, body, attr, &buf, &psize);
      if (EVEN(sts))
        return sts;
      value = (pwr_tTypeId*)(buf + size * element);
    }

    oid = cdh_TypeIdToObjid(*value);
    if (cdh_ObjidIsEqual(oid, enum_aref.Objid))
      brow_SetRadiobutton(node, 0, 1);
    else
      brow_SetRadiobutton(node, 0, 0);
    if (!is_element)
      free((char*)value);
    else
      free(buf);
    break;
  }
  case pwr_eType_AttrRef: {
    pwr_tAttrRef* value;
    // Get the attribute value
    if (!is_element) {
      sts = ldh_GetObjectPar(ldhses, objid, body, attr, (char**)&value, &psize);
      if (EVEN(sts))
        return sts;
    } else {
      sts = ldh_GetObjectPar(ldhses, objid, body, attr, &buf, &psize);
      if (EVEN(sts))
        return sts;
      value = (pwr_tAttrRef*)(buf + size * element);
    }

    if (cdh_ObjidIsEqual(value->Objid, enum_aref.Objid)
        && value->Offset == enum_aref.Offset && value->Size == enum_aref.Size)
      brow_SetRadiobutton(node, 0, 1);
    else
      brow_SetRadiobutton(node, 0, 0);
    if (!is_element)
      free((char*)value);
    else
      free(buf);
    break;
  }
  case item_eType_ObjectName: {
    pwr_tObjName value;
    // Get the attribute value

    sts = ldh_ObjidToName(
        ldhses, objid, cdh_mName_object, value, sizeof(value), &psize);
    if (EVEN(sts))
      return sts;

    if (streq(value, enum_string))
      brow_SetRadiobutton(node, 0, 1);
    else
      brow_SetRadiobutton(node, 0, 0);
    break;
  }
  default:;
  }
  return WNAV__SUCCESS;
}

int WItemEnumObject::set()
{
  int sts;
  WItemAttr* item;
  WItemEnum* sibling_item;
  brow_tNode parent, sibling;
  char* buf;
  int psize;
  int ldh_cb_used = brow->ldh_cb_used;

  // Set the attribute value

  switch (type_id) {
  case item_eType_Other: {
    brow_tObject parent;

    sts = brow_GetParent(brow->ctx, node, &parent);
    if (EVEN(sts))
      return sts;
    brow_GetUserData(parent, (void**)&item);

    item->close(0, 0);

    // Current item is removed now
    brow_SelectClear(item->brow->ctx);
    brow_SelectInsert(item->brow->ctx, item->node);
    return WNAV__NOCHILDREN;
  }
  case pwr_eType_Objid:

    if (!is_element) {
      sts = ldh_SetObjectPar(ldhses, objid, body, attr, (char*)&enum_aref.Objid,
          sizeof(enum_aref.Objid));
      if (EVEN(sts))
        return sts;
    } else {
      sts = ldh_GetObjectPar(ldhses, objid, body, attr, &buf, &psize);
      if (EVEN(sts))
        return sts;
      *(pwr_tOid*)(buf + size * element) = enum_aref.Objid;

      sts = ldh_SetObjectPar(ldhses, objid, body, attr, buf, psize);
      if (EVEN(sts))
        return sts;

      // Warning!! the item will be deleted here by the ldh backcall
      free(buf);
    }
    break;
  case pwr_eType_TypeId: {
    pwr_tTypeId value = cdh_TypeObjidToId(enum_aref.Objid);
    if (!is_element) {
      sts = ldh_SetObjectPar(
          ldhses, objid, body, attr, (char*)&value, sizeof(value));
      if (EVEN(sts))
        return sts;
    } else {
      sts = ldh_GetObjectPar(ldhses, objid, body, attr, &buf, &psize);
      if (EVEN(sts))
        return sts;
      *(pwr_tTypeId*)(buf + size * element) = value;

      sts = ldh_SetObjectPar(ldhses, objid, body, attr, buf, psize);
      if (EVEN(sts))
        return sts;

      // Warning!! the item will be deleted here by the ldh backcall
      free(buf);
    }
    break;
  }
  case pwr_eType_AttrRef:
    if (!is_element) {
      sts = ldh_SetObjectPar(
          ldhses, objid, body, attr, (char*)&enum_aref, sizeof(enum_aref));
      if (EVEN(sts))
        return sts;
    } else {
      sts = ldh_GetObjectPar(ldhses, objid, body, attr, &buf, &psize);
      if (EVEN(sts))
        return sts;
      *(pwr_tAttrRef*)(buf + size * element) = enum_aref;

      sts = ldh_SetObjectPar(ldhses, objid, body, attr, buf, psize);
      if (EVEN(sts))
        return sts;

      // Warning!! the item will be deleted here by the ldh backcall
      free(buf);
    }
    break;
  case item_eType_ObjectName: {
    sts = ldh_SetObjectName(ldhses, objid, enum_string);
    if (EVEN(sts))
      return sts;

    // Warning!! the item will be deleted here by the ldh backcall

    break;
  }
  default:;
  }

  if (!ldh_cb_used) {
    brow_SetRadiobutton(node, 0, 1);

    // Update parent
    sts = brow_GetParent(brow->ctx, node, &parent);
    if (EVEN(sts))
      return sts;
    brow_GetUserData(parent, (void**)&item);
    if (!is_element)
      item->update();
    else
      ((WItemAttrArrayElem*)item)->update();

    // Update all siblings
    sts = brow_GetChild(brow->ctx, parent, &sibling);
    while (ODD(sts)) {
      if (sibling != node) {
        brow_GetUserData(sibling, (void**)&sibling_item);
        sibling_item->update();
      }
      sts = brow_GetNextSibling(brow->ctx, sibling, &sibling);
    }
  }
  return WNAV__SUCCESS;
}

WItemCrossref::WItemCrossref(WNavBrow* item_brow, ldh_tSesContext item_ldhses,
    char* item_ref_name, char* item_ref_class, int item_write, brow_tNode dest,
    flow_eDest dest_code)
    : WItem(pwr_cNObjid, 0), brow(item_brow), ldhses(item_ldhses),
      write(item_write)
{
  int sts;
  char window_name[120];
  char* s;

  type = wnav_eItemType_Crossref;

  strcpy(name, item_ref_name);
  strcpy(ref_class, item_ref_class);

  // Get window objid
  strcpy(window_name, name);
  s = strrchr(window_name, '-');
  if (!s)
    return;

  strcpy(ref_name, s + 1);
  *s = 0;
  sts = ldh_NameToObjid(ldhses, &objid, window_name);
  if (EVEN(sts))
    return;

  brow_CreateNode(brow->ctx, "crr", brow->nc_object, dest, dest_code,
      (void*)this, 1, &node);

  if (write == 1)
    brow_SetAnnotPixmap(node, 0, brow->pixmap_crrwrite);
  else if (write == 2) {
    brow_SetAnnotPixmap(node, 0, brow->pixmap_crrwrite);
    brow_SetAnnotPixmap(node, 1, brow->pixmap_crrread);
  } else
    brow_SetAnnotPixmap(node, 0, brow->pixmap_crrread);

  brow_SetAnnotation(node, 0, name, strlen(name));

  // Set ref_class annotation
  brow_SetAnnotation(node, 1, ref_class, strlen(ref_class));
}

WItemCrossref::~WItemCrossref()
{
}

WItemDocBlock::WItemDocBlock(WNavBrow* item_brow, ldh_tSesContext item_ldhses,
    pwr_tObjid item_objid, char* item_block, int item_size, brow_tNode dest,
    flow_eDest dest_code)
    : WItem(item_objid, 0), brow(item_brow), ldhses(item_ldhses)
{
  int size = item_size;
  ldh_sSessInfo info;

  type = wnav_eItemType_DocBlock;

  brow_CreateNode(brow->ctx, "Documentation", brow->nc_attr_multiline, dest,
      dest_code, (void*)this, 1, &node);
  brow_SetAnnotPixmap(node, 0, brow->pixmap_docblock);

  // Set name
  brow_SetAnnotation(node, 0, "Documentation", strlen("Documentation"));
  if (item_block) {
    brow_SetAnnotation(node, 1, item_block, size);
    free(item_block);
  }

  // Examine access
  ldh_GetSessionInfo(ldhses, &info);
  if (info.Access == ldh_eAccess_ReadWrite)
    brow_SetAnnotPixmap(node, 1, brow->pixmap_morehelp);
}

WItemDocBlock::~WItemDocBlock()
{
}

int WItemDocBlock::update()
{
  char* block;
  int sts;
  int size;

  sts = ldh_GetDocBlock(ldhses, objid, &block, &size);
  if (EVEN(sts))
    return sts;

  if (block) {
    brow_SetAnnotation(node, 1, block, size);
    free(block);
  }

  return WNAV__SUCCESS;
}

int WItemDocBlock::get_value(char** value)
{
  int size;

  return ldh_GetDocBlock(ldhses, objid, value, &size);
}
