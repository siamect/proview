/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include "wb_adrep.h"
#include "wb_bdrep.h"
#include "wb_cdrep.h"
#include "wb_merep.h"
#include "wb_volume.h"

wb_treeimport::~wb_treeimport()
{
}

bool wb_treeimport::importTranslationTableInsert(pwr_tOix from, pwr_tOix to)
{
  std::pair<pwr_tOix, pwr_tOix> p(from, to);
  std::pair<std::map<pwr_tOix, pwr_tOix>::iterator, bool> result
      = m_translation_table.insert(p);

  return result.second;
}

bool wb_treeimport::importTranslationTableCidInsert(pwr_tCid from, pwr_tCid to)
{
  std::pair<pwr_tCid, pwr_tCid> p(from, to);
  std::pair<std::map<pwr_tCid, pwr_tCid>::iterator, bool> result
      = m_translation_table_cid.insert(p);

  return result.second;
}

void wb_treeimport::importTranslationTableClear()
{
  // while( ! m_translation_table.empty())
  //   m_translation_table.erase( m_translation_table.begin());
  m_translation_table.clear();
  m_translation_table_cid.clear();
}

pwr_tOix wb_treeimport::importTranslate(pwr_tOix oix)
{
  iterator_translation_table it = m_translation_table.find(oix);
  if (it == m_translation_table.end())
    return 0;
  return it->second;
}

pwr_tCid wb_treeimport::importTranslateCid(pwr_tCid cid)
{
  iterator_translation_table_cid it = m_translation_table_cid.find(cid);
  if (it == m_translation_table_cid.end())
    return 0;
  return it->second;
}

void wb_treeimport::importSetSourceVid(pwr_tVid vid)
{
  m_import_source_vid = vid;
}

bool wb_treeimport::importUpdateTree(wb_vrep* vrep)
{
  iterator_translation_table it;
  pwr_tStatus sts;

  // Update all imported objects, get objects from the translationtable
  for (it = m_translation_table.begin(); it != m_translation_table.end();
       it++) {
    pwr_tOid oid;
    oid.oix = it->second;
    oid.vid = vrep->vid();
    wb_orep* o = vrep->object(&sts, oid);
    if (EVEN(sts))
      throw wb_error(LDH__NOSUCHOBJ);

    o->ref();
    importUpdateObject(o, vrep);
    if (m_object_import_cb) {
      oid.oix = it->first;
      oid.vid = vrep->vid();
      wb_orep* os = vrep->object(&sts, oid);
      if (ODD(sts))
	os->ref();
      else
	os = 0;
      (m_object_import_cb)(o, os, m_object_import_cb_data);
      if (os)
	os->unref();
    }
    o->unref();
  }
  return true;
}

bool wb_treeimport::importUpdateSubClass(
    wb_adrep* subattr, char* body, wb_vrep* vrep, bool* modified)
{
  pwr_tStatus sts;
  pwr_tOix oix;
  pwr_tCid cid = subattr->subClass();
  wb_cdrep* cdrep = vrep->merep()->cdrep(&sts, cid);
  if (EVEN(sts))
    throw wb_error(sts);
  wb_bdrep* bdrep = cdrep->bdrep(&sts, pwr_eBix_rt);
  if (EVEN(sts))
    throw wb_error(sts);

  int subattr_elements = subattr->isArray() ? subattr->nElement() : 1;

  for (int i = 0; i < subattr_elements; i++) {
    wb_adrep* adrep = bdrep->adrep(&sts);
    while (ODD(sts)) {
      int elements = adrep->isArray() ? adrep->nElement() : 1;
      if (adrep->isClass()) {
        importUpdateSubClass(adrep,
            body + i * subattr->size() / subattr_elements + adrep->offset(),
            vrep, modified);
      } else {
        switch (adrep->type()) {
        case pwr_eType_Objid: {
          pwr_tOid* oidp = (pwr_tOid*)(body
              + i * subattr->size() / subattr_elements + adrep->offset());
          for (int j = 0; j < elements; j++) {
            if (oidp->vid == m_import_source_vid
                && (oix = importTranslate(oidp->oix))) {
              oidp->vid = vrep->vid();
              oidp->oix = oix;
              *modified = true;
            } else if (ldh_isSymbolicVid(oidp->vid)
                && (oix = importTranslateCid(oidp->oix))) {
              oidp->oix = oix;
              *modified = true;
            }
            oidp++;
          }
          break;
        }
        case pwr_eType_AttrRef: {
          pwr_sAttrRef* arp = (pwr_sAttrRef*)(body
              + i * subattr->size() / subattr_elements + adrep->offset());
          for (int j = 0; j < elements; j++) {
            if (arp->Objid.vid == m_import_source_vid
                && (oix = importTranslate(arp->Objid.oix))) {
              arp->Objid.vid = vrep->vid();
              arp->Objid.oix = oix;
              *modified = true;
            } else if (ldh_isSymbolicVid(arp->Objid.vid)
                && (oix = importTranslateCid(arp->Objid.oix))) {
              arp->Objid.oix = oix;
              *modified = true;
            }
            arp++;
          }
          break;
        }
        case pwr_eType_DataRef: {
          pwr_tDataRef* drp = (pwr_tDataRef*)(body
              + i * subattr->size() / subattr_elements + adrep->offset());
          for (int j = 0; j < elements; j++) {
            if (drp->Aref.Objid.vid == m_import_source_vid
                && (oix = importTranslate(drp->Aref.Objid.oix))) {
              drp->Aref.Objid.vid = vrep->vid();
              drp->Aref.Objid.oix = oix;
              *modified = true;
            }
            drp++;
          }
          break;
        }
        default:;
        }
      }
      wb_adrep* prev = adrep;
      adrep = adrep->next(&sts);
      delete prev;
    }
  }
  delete bdrep;
  delete cdrep;

  return true;
}

bool wb_treeimport::importUpdateObject(wb_orep* o, wb_vrep* vrep)
{
  pwr_tOix oix;
  pwr_tStatus sts;
  wb_cdrep* cdrep = vrep->merep()->cdrep(&sts, o->cid());
  if (EVEN(sts))
    throw wb_error(sts);

  for (int i = 0; i < 2; i++) {
    pwr_eBix bix = i ? pwr_eBix_rt : pwr_eBix_dev;

    wb_bdrep* bdrep = cdrep->bdrep(&sts, bix);
    if (EVEN(sts))
      continue;

    int size = bdrep->size();

    char* body = (char*)malloc(bdrep->size());
    vrep->readBody(&sts, o, bix, body);
    if (EVEN(sts))
      throw wb_error(sts);

    bool modified = false;

    wb_adrep* adrep = bdrep->adrep(&sts);
    while (ODD(sts)) {
      int elements = adrep->isArray() ? adrep->nElement() : 1;
      if (adrep->offset() < 0
          || ((int)(adrep->offset() + adrep->size()) > size))
        printf("(adrep->offset() < 0 || (adrep->offset() + adrep->size() > "
               "size))\n");

      if (adrep->isClass()) {
        importUpdateSubClass(adrep, body + adrep->offset(), vrep, &modified);
      } else {
        switch (adrep->type()) {
        case pwr_eType_Objid: {
          pwr_tOid* oidp = (pwr_tOid*)(body + adrep->offset());
          for (int j = 0; j < elements; j++) {
            if (oidp->vid == m_import_source_vid
                && (oix = importTranslate(oidp->oix))) {
              oidp->vid = vrep->vid();
              oidp->oix = oix;
              modified = true;
            } else if (ldh_isSymbolicVid(oidp->vid)
                && (oix = importTranslateCid(oidp->oix))) {
              oidp->oix = oix;
              modified = true;
            }
            oidp++;
          }
          break;
        }
        case pwr_eType_AttrRef: {
          pwr_sAttrRef* arp = (pwr_sAttrRef*)(body + adrep->offset());
          for (int j = 0; j < elements; j++) {
            if (arp->Objid.vid == m_import_source_vid
                && (oix = importTranslate(arp->Objid.oix))) {
              arp->Objid.vid = vrep->vid();
              arp->Objid.oix = oix;
              modified = true;
            } else if (ldh_isSymbolicVid(arp->Objid.vid)
                && (oix = importTranslateCid(arp->Objid.oix))) {
              arp->Objid.oix = oix;
              modified = true;
            }
            arp++;
          }
          break;
        }
        case pwr_eType_DataRef: {
          pwr_tDataRef* drp = (pwr_tDataRef*)(body + adrep->offset());
          for (int j = 0; j < elements; j++) {
            if (drp->Aref.Objid.vid == m_import_source_vid
                && (oix = importTranslate(drp->Aref.Objid.oix))) {
              drp->Aref.Objid.vid = vrep->vid();
              drp->Aref.Objid.oix = oix;
              modified = true;
            }
            drp++;
          }
          break;
        }
        default:;
        }
      }
      wb_adrep* prev = adrep;
      adrep = adrep->next(&sts);
      delete prev;
    }
    if (modified) {
      vrep->writeBody(&sts, o, bix, body);
      if (EVEN(sts))
        throw wb_error(sts);
    }
    free(body);
    delete bdrep;
  }

  delete cdrep;
  return true;
}
