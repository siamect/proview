/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2018 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

#ifndef wb_revision_h
#define wb_revision_h

#include <vector>
#include "pwr.h"
#include "wb_ldh.h"
#include "wb_session.h"
#include "wb_wnav.h"
#include "pwr_baseclasses.h"

typedef struct {
  char name[80];
  bool in_master;
  bool in_end_of_branch;
} wb_rev_info;

class wb_rev_item {
 public:
  char name[80];
  int level;
  char description[80];
  char version[40];
  pwr_tTime date;
  bool current;
  bool current_branch;
  bool in_manager;
  int idx;
  vector<wb_rev_item> vect;

  wb_rev_item() : level(0), current(false), current_branch(false), in_manager(false), idx(0) { 
    strcpy(name,""); strcpy(description,""); strcpy(version,"");}
    wb_rev_item( const wb_rev_item& x) : level(x.level), date(x.date), current(x.current), 
      current_branch(x.current_branch), in_manager(x.in_manager), idx(x.idx), vect(x.vect) {
      strcpy( name, x.name); strcpy( description, x.description); strcpy( version, x.version);
  }
};


class wb_version_manager 
{
 private:
  pwr_eVersionManagerEnum m_manager;
 protected:
  pwr_tStatus m_sts;

 public:
  wb_version_manager( pwr_eVersionManagerEnum manager) : m_manager(manager), m_sts(0) {}
  pwr_tStatus sts() { return m_sts;}
  virtual ~wb_version_manager() {}
  virtual void init() {}
  virtual int store_revision( char *name, char *descr, bool new_branch) { return 0;}
  virtual int restore_revision( char *name, char *branch, int checkout_master, int checkout_branch) { return 0;}
  virtual int get_current( char *name) { return 0;}
  virtual int check( vector<wb_rev_item>& v) { return 0;}
  virtual int check_add( char *filename) { return 0;}
  virtual bool modified() { return true;}
};

class wb_version_manager_git : public wb_version_manager
{
  static bool m_found;
  static bool m_found_tested;

  bool git_found();

 public:
  wb_version_manager_git() : wb_version_manager(pwr_eVersionManagerEnum_None) { init();}
  ~wb_version_manager_git() {}
  pwr_tFileName m_git_dir;
  pwr_tFileName m_work_tree;
  void init();
  int store_revision( char *name, char *descr, bool new_branch);
  int restore_revision( char *name, char *branch, int checkout_master, int checkout_branch);
  int get_current( char *name);
  int check( vector<wb_rev_item>& v);
  int check_add( char *filename);
  bool modified();
};

class wb_revision : public wb_status
{
 private:
  void *m_parent_ctx;
  wb_session *m_session;
  wb_version_manager *m_manager;
  pwr_eVersionManagerEnum m_manager_enum;
  vector<wb_rev_item> m_vect;
  bool m_read;
  int m_current_idx;
  int m_current_main_idx;
  int m_current_sub_idx;
  int m_next_idx;
  int (*m_command_cb)( void *ctx, char *cmd);

 public:
  wb_revision();
  wb_revision( void *parent_ctx, wb_session *ses);
  ~wb_revision() {
    if ( m_manager)
      delete m_manager;
  }

  pwr_tStatus create( int all, char *name, char *descr);
  pwr_tStatus restore( char *name);
  pwr_tStatus build_all();
  pwr_tStatus remove( char *name);
  bool set_current( char *name); 
  bool set_current( int idx); 
  void read_file();
  void read_file_meta();
  void write_file();
  int add( char *name, char *description, char *version, pwr_tTime *date, bool in_main, int sub_idx);
  void list();
  void *parent_ctx() { return m_parent_ctx;}
  void command_cb( int (*cmd_cb)(void *, char *)) { m_command_cb = cmd_cb;}
  wb_rev_item *vect( int idx) { return &m_vect[idx];}
  int size() { return (int) m_vect.size();}
  pwr_eVersionManagerEnum manager_enum() { return m_manager_enum;}
  void set_manager_enum( pwr_eVersionManagerEnum manager_enum) { m_manager_enum = manager_enum;}
  wb_rev_item *current();
  pwr_tStatus create_check();
  void get_info( wb_rev_info *info);
  void next_name( char *name);

  static char *branch_name( char *name);
  static pwr_tStatus info( wb_rev_info *info);
  static int check_add_file( char *filename);
};

#endif
