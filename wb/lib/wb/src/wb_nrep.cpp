/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <stdio.h>

#include "co_string.h"

#include "wb_nrep.h"
#include "wb_ldh_msg.h"

char wb_nrep::normname_tab[] = "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
                               "!!!!$!!!!!!!!-.!0123456789:!!!!!"
                               "!ABCDEFGHIJKLMNOPQRSTUVWXYZ[!]!_"
                               "!^^^^^^^^^^^^^^^^^^^^^^^^^^!!!!!"
                               "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
                               "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
                               "AAAAÄÅÆCEEEEIIII!NOOOOÖ×OUUUUY!!"
                               "^^^^^^^^^^^^^^^^!^^^^^^^^^^^^^!!";
char wb_nrep::idname_tab[] = "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
                             "!!!!$!!!()!!!-.!0123456789:!!!!!"
                             "!ABCDEFGHIJKLMNOPQRSTUVWXYZ[!]!_"
                             "!^^^^^^^^^^^^^^^^^^^^^^^^^^!!!!!"
                             "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
                             "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
                             "AAAAÄÅÆCEEEEIIII!NOOOOÖ×OUUUUY!!"
                             "^^^^^^^^^^^^^^^^!^^^^^^^^^^^^^!!";
char wb_nrep::objname_tab[] = "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
                              "!!!!$!!!!!!!!!!!0123456789!!!!!!"
                              "!ABCDEFGHIJKLMNOPQRSTUVWXYZ!!!!_"
                              "!^^^^^^^^^^^^^^^^^^^^^^^^^^!!!!!"
                              "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
                              "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
                              "AAAAÄÅÆCEEEEIIII!NOOOOÖ×OUUUUY!!"
                              "^^^^^^^^^^^^^^^^!^^^^^^^^^^^^^!!";
char wb_nrep::pathname_tab[] = "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
                               "!!!!$!!!!!!!!-!!0123456789:!!!!!"
                               "!ABCDEFGHIJKLMNOPQRSTUVWXYZ!!!!_"
                               "!^^^^^^^^^^^^^^^^^^^^^^^^^^!!!!!"
                               "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
                               "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
                               "AAAAÄÅÆCEEEEIIII!NOOOOÖ×OUUUUY!!"
                               "^^^^^^^^^^^^^^^^!^^^^^^^^^^^^^!!";
char wb_nrep::unatname_tab[] = "================================"
                               "================================"
                               "================================"
                               "================================"
                               "================================"
                               "================================"
                               "AAAAAAACEEEEIIII=NOOOOOOOUUUUY=="
                               "aaaaaaaceeeeiiii=nooooooouuuuy==";

#define nameDiff(s1, s2) ((long)(s1) - (long)(s2))

wb_nrep::wb_nrep() : m_nRef(0), num_seg(0), num_attr(0), vol_len(0), seg(0),
                     attr(0), m_hasSuper(false), m_shadowed(false)
{
  strcpy(oname, "");
}

wb_nrep::wb_nrep(const char* n)
    : m_nRef(0), num_seg(0), num_attr(0), vol_len(0), vol_offs(0), b_size(0),
      b_offset(0), seg(0), attr(0), m_hasSuper(false), m_shadowed(false)
{
  const char* s;
  int seg_cnt = 1;
  int attr_cnt = 0;
  int name_len = 0;

  if (*n != '_') {
    // Count number of segments and attributes

    for (s = n; *s; s++) {
      switch (*s) {
      case '-':
        seg_cnt++;
        break;
      case '.':
        attr_cnt++;
        break;
      }
      name_len++;
    }
    if (name_len >= (int)sizeof(oname)) {
      throw wb_error(LDH__BADNAME);
    }
  } else {
    name_type = wname_eType_Name;
    int enable_cnt = 0;
    seg_cnt = 2;
    attr_cnt = 1;
    for (s = n; *s; s++) {
      switch (*s) {
      case ')':
      case ']':
        enable_cnt = 1;
        break;
      case '[':
        enable_cnt = 0;
        break;
      case '.':
        if (enable_cnt)
          attr_cnt++;
        break;
      }
      name_len++;
    }
    if (name_len >= (int)sizeof(oname)) {
      throw wb_error(LDH__BADNAME);
    }
  }
  if (seg_cnt)
    seg = (wb_namesegments*)calloc(seg_cnt, sizeof(wb_namesegments));
  if (attr_cnt) {
    attr = (wb_nameattributes*)calloc(attr_cnt, sizeof(wb_nameattributes));
    for (int i = 0; i < attr_cnt; i++)
      attr[i].index = -1;
  }
  strcpy(oname, n);
  parse();
}

wb_nrep::wb_nrep(const wb_nrep& n)
{
  memcpy(this, &n, sizeof(*this));
  if (num_seg) {
    seg = (wb_namesegments*)calloc(num_seg, sizeof(wb_namesegments));
    memcpy(seg, n.seg, num_seg * sizeof(wb_namesegments));
  }
  if (num_attr) {
    attr = (wb_nameattributes*)calloc(num_attr, sizeof(wb_nameattributes));
    memcpy(attr, n.attr, num_attr * sizeof(wb_nameattributes));
  }
}

wb_nrep::~wb_nrep()
{
  free(seg);
  free(attr);
}

void wb_nrep::unref()
{
  if (--m_nRef == 0)
    delete this;
}

wb_nrep* wb_nrep::ref()
{
  m_nRef++;
  return this;
}

void wb_nrep::parse()
{
  int state = 0;
  char *s, *snn;

  snn = norm_name;

  if (oname[0] == '_') {
    // This is an identity name.
    for (s = oname; *s; s++, snn++) {
      switch (idname_tab[*(unsigned char*)s]) {
      case '!':
        throw wb_error(LDH__BADNAME);
      case '^':
        *snn = *s - 32;
        break;
      default:
        *snn = idname_tab[*(unsigned char*)s];
      }
      if (s == oname)
        continue;
      if (s == oname + 1) {
        switch (*s) {
        case 'V':
          name_type = wname_eType_Vid;
          continue;
        case 'O':
          name_type = wname_eType_Oid;
          continue;
        case 'A':
          name_type = wname_eType_Aid;
          continue;
        default:
          throw wb_error(LDH__BADNAME);
        }
      }

      /* States
         0: before ':'
         1: before '('
         2: before ')'
         3: attribute before '['
         4: attribute index before ']'
         5: attribute after  ']'
         6: offset.size before '.'
         7: offset.size before ']'
         8: offset.size after  ']'  */

      switch (state) {
      case 0: // before ':'
        switch (*s) {
        case ':':
          if (s == oname)
            throw wb_error(LDH__BADNAME);
          vol_offs = 2;
          vol_len = nameDiff(s, oname) - vol_offs;
          seg[0].offs = nameDiff(s + 1, oname);
          state = 1;
          break;
        case '(':
        case ')':
        case '[':
        case ']':
          throw wb_error(LDH__BADNAME);
        }
        break;
      case 1: // before '('
        switch (*s) {
        case '(':
          if (nameDiff(s, oname) == seg[0].offs)
            throw wb_error(LDH__BADNAME);
          seg[1].offs = nameDiff(s + 1, oname);
          seg[0].len = nameDiff(s, oname) - seg[0].offs;
          num_seg++;
          state = 2;
          break;
        case ')':
        case '[':
        case ']':
          throw wb_error(LDH__BADNAME);
        }
        break;
      case 2: // before ')'
        switch (*s) {
        case ')':
          if (nameDiff(s, oname) == seg[1].offs)
            throw wb_error(LDH__BADNAME);
          attr[0].offs = nameDiff(s + 1, oname);
          seg[1].len = nameDiff(s, oname) - seg[1].offs;
          num_seg++;
          state = 3;
          break;
        case '[':
        case ']':
          throw wb_error(LDH__BADNAME);
        }
        break;
      case 3: // after ')'
        switch (*s) {
        case '[':
          if (nameDiff(s, oname) == seg[1].offs + seg[1].len + 1) {
            // offset.size
            state = 7;
          }
          break;
        case ']':
        case '.':
          throw wb_error(LDH__BADNAME);
        default:
          attr[num_attr].len = nameDiff(s, oname) - attr[num_attr].offs;
          attr[num_attr].index = -1;
          state = 4;
        }
        break;
      case 4: // attribute before '['
        switch (*s) {
        case '.':
          if (nameDiff(s, oname) == attr[num_attr].offs)
            throw wb_error(LDH__BADNAME);
          attr[num_attr].len = nameDiff(s, oname) - attr[num_attr].offs;
          num_attr++;
          attr[num_attr].offs = nameDiff(s + 1, oname);
          state = 4;
          break;
        case '[':
          attr[num_attr].len = nameDiff(s, oname) - attr[num_attr].offs;
          attr[num_attr].index = 0;
          state = 5;
        }
        break;
      case 5: // attribute index before ']'
        switch (*s) {
        case ']':
          num_attr++;
          state = 6;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          attr[num_attr].index = attr[num_attr].index * 10 + (*s - '0');
          if (attr[num_attr].index > 65535)
            throw wb_error(LDH__BADNAME);
          break;
        default:
          throw wb_error(LDH__BADNAME);
        }
        break;
      case 6: // attribute after ']', '.' or nothing
        switch (*s) {
        case '.':
          attr[num_attr].offs = nameDiff(s + 1, oname);
          state = 4;
          break;
        default:
          throw wb_error(LDH__BADNAME);
        }
        break;
      case 7: // offset.size before '.'
        switch (*s) {
        case '.':
          b_size = 0;
          state = 8;
          break;
        case ']':
          throw wb_error(LDH__BADNAME);
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          b_offset = b_offset * 10 + (*s - '0');
          if (b_offset > 65535)
            throw wb_error(LDH__BADNAME);
          break;
        default:
          throw wb_error(LDH__BADNAME);
        }
        break;
      case 8: // offset.size before ']'
        switch (*s) {
        case ']':
          state = 9;
          break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          b_size = b_size * 10 + (*s - '0');
          if (b_size > 65535)
            throw wb_error(LDH__BADNAME);
          break;
        default:
          throw wb_error(LDH__BADNAME);
        }
        break;
      case 9: // offset.size after ']', must be nothing there!
        throw wb_error(LDH__BADNAME);
      }
    }

    switch (state) {
    case 0:
      if (s == oname)
        throw wb_error(LDH__BADNAME); // No segment name
      vol_len = nameDiff(s, oname);
      break;
    case 1:
      if (nameDiff(s, oname) == seg[num_seg].offs)
        throw wb_error(LDH__BADNAME);
      if (nameDiff(s, oname) - (vol_len + 1) == 0)
        break;
      seg[num_seg].len = nameDiff(s, oname) - seg[num_seg].offs;
      if (seg[num_seg].len)
        num_seg++;
      break;
    case 4:
      if (nameDiff(s, oname) == attr[num_attr].offs)
        throw wb_error(LDH__BADNAME);
      attr[num_attr].len = nameDiff(s, oname) - attr[num_attr].offs;
      if (attr[num_attr].len)
        num_attr++;
      break;
    case 2:
    case 3:
    case 5:
    case 7:
    case 8:
      throw wb_error(LDH__BADNAME);
    default:;
    }

    *snn = 0;
  } else {
    for (s = oname; *s; s++, snn++) {
      switch (normname_tab[*(unsigned char*)s]) {
      case '!':
        throw wb_error(LDH__BADNAME);
      case '^':
        *snn = *s - 32;
        break;
      default:
        *snn = normname_tab[*(unsigned char*)s];
      }

      /* States
         0: before ':'
         1: before '.'
         2: before '['
         3: before ']'
         4: after  ']'  */

      switch (state) {
      case 0: // before ':'
        switch (*s) {
        case ':':
          if (s == oname)
            throw wb_error(LDH__BADNAME); // No volume name
          vol_len = nameDiff(s, oname);
          if (*(s + 1))
            seg[0].offs = nameDiff(s + 1, oname);
          state = 1;
          break;
        case '-':
          if (s == oname)
            throw wb_error(LDH__BADNAME); // No segment name
          seg[0].offs = 0;
          seg[0].len = nameDiff(s, oname);
          num_seg++;
          seg[1].offs = nameDiff(s + 1, oname);
          state = 1;
          break;
        case '.':
          if (s != oname) {
            seg[0].offs = 0;
            seg[0].len = nameDiff(s, oname);
            num_seg++;
          }
          attr[0].offs = nameDiff(s + 1, oname);
          state = 2;
          break;
        case '[':
        case ']':
          throw wb_error(LDH__BADNAME);
        }
        break;
      case 1: // before '.'
        switch (*s) {
        case '-':
          if (nameDiff(s, oname) == seg[num_seg].offs)
            throw wb_error(LDH__BADNAME);
          seg[num_seg + 1].offs = nameDiff(s + 1, oname);
          seg[num_seg].len = seg[num_seg + 1].offs - seg[num_seg].offs - 1;
          num_seg++;
          break;
        case '.':
          // if ( nameDiff( s, oname) == seg[num_seg].offs) // Could be volume
          // object !!
          //   throw wb_error(LDH__BADNAME);
          attr[0].offs = nameDiff(s + 1, oname);
          seg[num_seg].len = attr[0].offs - seg[num_seg].offs - 1;
          num_seg++;
          state = 2;
          break;
        }
        break;
      case 2: // before '['
        switch (*s) {
        case '.':
          if (nameDiff(s, oname) == attr[num_attr].offs)
            throw wb_error(LDH__BADNAME);
          attr[num_attr + 1].offs = nameDiff(s + 1, oname);
          attr[num_attr].len
              = attr[num_attr + 1].offs - attr[num_attr].offs - 1;
          if (attr[num_attr].len == 5
              && str_NoCaseStrncmp(oname + attr[num_attr].offs, "Super", 5)
                  == 0) {
            attr[num_attr].isSuper = true;
            m_hasSuper = true;
          }
          num_attr++;
          break;
        case '[':
          if (nameDiff(s, oname) == attr[num_attr].offs)
            throw wb_error(LDH__BADNAME);
          attr[num_attr].len = nameDiff(s, oname) - attr[num_attr].offs;
          attr[num_attr].index = 0;
          state = 3;
          break;
        }
        break;
      case 3: /* within brackets */
        switch (*s) {
        case ']':
          num_attr++;
          state = 4;
          break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          attr[num_attr].index = attr[num_attr].index * 10 + (*s - '0');
          if (attr[num_attr].index > 65535)
            throw wb_error(LDH__BADNAME);
          break;
        default:
          throw wb_error(LDH__BADNAME);
        }
        break;
      case 4: // after brackets
        switch (*s) {
        case '.':
          attr[num_attr].offs = nameDiff(s + 1, oname);
          state = 2;
          break;
        default:
          throw wb_error(LDH__BADNAME);
        }
        break;
      }
    }

    switch (state) {
    case 0:
      if (s == oname)
        throw wb_error(LDH__BADNAME); // No segment name
      seg[0].offs = 0;
      seg[0].len = nameDiff(s, oname);
      if (seg[0].len > pwr_cSizObjName)
        throw wb_error(LDH__BADNAME);
      num_seg++;
      break;
    case 1:
      if (nameDiff(s, oname) == seg[num_seg].offs)
        throw wb_error(LDH__BADNAME);
      if (nameDiff(s, oname) - (vol_len + 1) == 0)
        break;
      seg[num_seg].len = nameDiff(s, oname) - seg[num_seg].offs;
      if (seg[num_seg].len > pwr_cSizObjName)
        throw wb_error(LDH__BADNAME);
      if (seg[num_seg].len)
        num_seg++;
      break;
    case 2:
      if (nameDiff(s, oname) == attr[num_attr].offs)
        throw wb_error(LDH__BADNAME);
      attr[num_attr].len = nameDiff(s, oname) - attr[num_attr].offs;
      if (attr[num_attr].len)
        num_attr++;
      break;
    case 3:
      throw wb_error(LDH__BADNAME);
    case 4:
      break;
    }
    *snn = 0;
  }
}

char* wb_nrep::object(char* res)
{
  return objectName(oname, res);
}

char* wb_nrep::normObject(char* res)
{
  return objectName(norm_name, res);
}

char* wb_nrep::segment(int idx, char* res)
{
  return segmentName(oname, idx, res);
}

char* wb_nrep::normSegment(int idx, char* res)
{
  return segmentName(norm_name, idx, res);
}

char* wb_nrep::path(char* res)
{
  return pathName(oname, res);
}

char* wb_nrep::normPath(char* res)
{
  return pathName(norm_name, res);
}

char* wb_nrep::volume(char* res)
{
  return volumeName(oname, res);
}

char* wb_nrep::normVolume(char* res)
{
  return volumeName(norm_name, res);
}

char* wb_nrep::attribute(int idx, char* res)
{
  return attributeName(oname, idx, res);
}

char* wb_nrep::normAttribute(int idx, char* res)
{
  return attributeName(norm_name, idx, res);
}

bool wb_nrep::objectIsEqual(const char* n)
{
  const char* s1 = norm_name + seg[num_seg - 1].offs;
  const char* s2 = n;
  char c;

  for (int i = 0; i < seg[num_seg - 1].len; i++) {
    if (normname_tab[*(unsigned char*)s2] == '^')
      c = *s2 - 32;
    else
      c = normname_tab[*(unsigned char*)s2];
    if (*s1 != c)
      return false;
    s1++;
    s2++;
  }
  if (*s2)
    return false;
  return true;
}

bool wb_nrep::volumeIsEqual(const char* n)
{
  const char* s1 = norm_name;
  const char* s2 = n;
  char c;

  for (int i = 0; i < vol_len; i++) {
    if (normname_tab[*(unsigned char*)s2] == '^')
      c = *s2 - 32;
    else
      c = normname_tab[*(unsigned char*)s2];
    if (*s1 != c)
      return false;
    s1++;
    s2++;
  }
  if (*s2)
    return false;
  return true;
}

bool wb_nrep::segmentIsEqual(const char* n, int idx)
{
  const char* s1 = norm_name + seg[idx].offs;
  const char* s2 = n;
  char c;

  if (idx < 0 || idx >= num_seg)
    return false;

  for (int i = 0; i < seg[idx].len; i++) {
    if (normname_tab[*(unsigned char*)s2] == '^')
      c = *s2 - 32;
    else
      c = normname_tab[*(unsigned char*)s2];
    if (*s1 != c)
      return false;
    s1++;
    s2++;
  }
  if (*s2)
    return false;
  return true;
}

bool wb_nrep::attributeIsEqual(const char* n, int idx)
{
  const char* s1 = norm_name + attr[idx].offs;
  const char* s2 = n;
  char c;

  if (idx < 0 || idx >= num_attr)
    return false;

  for (int i = 0; i < attr[idx].len; i++) {
    if (normname_tab[*(unsigned char*)s2] == '^')
      c = *s2 - 32;
    else
      c = normname_tab[*(unsigned char*)s2];
    if (*s1 != c)
      return false;
    s1++;
    s2++;
  }
  if (*s2)
    return false;
  return true;
}

char* wb_nrep::objectName(const char* n, char* res)
{
  static char result[80];

  if (!num_seg) {
    if (res) {
      strcpy(res, "");
      return res;
    } else {
      strcpy(result, "");
      return result;
    }
  } else {
    if (res) {
      strncpy(res, n + seg[num_seg - 1].offs, seg[num_seg - 1].len);
      res[seg[num_seg - 1].len] = 0;
      return res;
    } else {
      strncpy(result, n + seg[num_seg - 1].offs, seg[num_seg - 1].len);
      result[seg[num_seg - 1].len] = 0;
      return result;
    }
  }
}

char* wb_nrep::pathName(const char* n, char* res)
{
  static pwr_tOName result;

  if (num_seg <= 1) {
    if (res) {
      strcpy(res, "");
      return res;
    } else {
      strcpy(result, "");
      return result;
    }
  } else {
    if (res) {
      strncpy(res, n + seg[0].offs,
          seg[num_seg - 2].offs - seg[0].offs + seg[num_seg - 2].len);
      res[seg[num_seg - 2].offs - seg[0].offs + seg[num_seg - 2].len] = 0;
      return res;
    } else {
      strncpy(result, n + seg[0].offs,
          seg[num_seg - 2].offs - seg[0].offs + seg[num_seg - 2].len);
      result[seg[num_seg - 2].offs - seg[0].offs + seg[num_seg - 2].len] = 0;
      return result;
    }
  }
}

char* wb_nrep::segmentName(const char* n, int idx, char* res)
{
  static char result[80];

  if (idx >= num_seg || idx < 0) {
    if (res) {
      strcpy(res, "");
      return res;
    } else {
      strcpy(result, "");
      return result;
    }
  } else {
    if (res) {
      strncpy(res, n + seg[idx].offs, seg[idx].len);
      res[seg[idx].len] = 0;
      return res;
    } else {
      strncpy(result, n + seg[idx].offs, seg[idx].len);
      result[seg[idx].len] = 0;
      return result;
    }
  }
}

char* wb_nrep::attributeName(const char* n, int idx, char* res)
{
  static pwr_tOName result;

  if (idx >= num_attr || idx < 0) {
    if (res) {
      strcpy(res, "");
      return res;
    } else {
      strcpy(result, "");
      return result;
    }
  } else {
    if (res) {
      strncpy(res, n + attr[idx].offs, attr[idx].len);
      res[attr[idx].len] = 0;
      return res;
    } else {
      strncpy(result, n + attr[idx].offs, attr[idx].len);
      result[attr[idx].len] = 0;
      return result;
    }
  }
}

char* wb_nrep::volumeName(const char* n, char* res)
{
  static char result[80];
  if (vol_len == 0) {
    if (res) {
      strcpy(res, "");
      return res;
    } else {
      strcpy(result, "");
      return result;
    }
  } else {
    if (res) {
      strncpy(res, n + vol_offs, vol_len);
      res[vol_len] = 0;
      return res;
    } else {
      strncpy(result, n + vol_offs, vol_len);
      result[vol_len] = 0;
      return result;
    }
  }
}

char* wb_nrep::name(int ntype, char* res)
{
  return nameName(oname, ntype, res);
}

char* wb_nrep::normName(int ntype, char* res)
{
  return nameName(norm_name, ntype, res);
}

char* wb_nrep::nameName(const char* n, int ntype, char* res)
{
  static char result[512];
  int colon_added = 0;

  if (!res)
    res = result;
  if (ntype & cdh_mName_volume && ntype & cdh_mName_object)
    ntype |= cdh_mName_path;
  if (ntype & cdh_mName_path && ntype & cdh_mName_attribute)
    ntype |= cdh_mName_object;
  if (ntype & cdh_mName_volume && ntype & cdh_mName_attribute)
    ntype = ntype | cdh_mName_path | cdh_mName_object;
  strcpy(res, "");

  if (ntype & cdh_mName_idString) {
    if (!(ntype & cdh_mName_attribute)) {
      if (ntype & cdh_mName_volume && !(ntype & cdh_mName_object))
        strcat(res, "_V");
      else if (!(ntype & cdh_mName_volume))
        strcat(res, "_X");
      else
        strcat(res, "_O");
    } else
      strcat(res, "_A");
  }
  if (ntype & cdh_mName_volume)
    volumeName(n, res + strlen(res));
  else if (ntype & cdh_mName_ref)
    volumeName(n, res + strlen(res));
  if (ntype & cdh_mName_path) {
    if (ntype & cdh_mName_volume && hasVolume()) {
      strcat(res, ":");
      colon_added = 1;
    }
    pathName(n, res + strlen(res));
  }
  if (ntype & cdh_mName_object) {
    if (ntype & cdh_mName_path && hasPath())
      strcat(res, "-");
    else if (ntype & cdh_mName_volume && !hasPath() && hasVolume()
        && !colon_added)
      strcat(res, ":");
    objectName(n, res + strlen(res));
  }
  if (ntype & cdh_mName_attribute && hasAttribute()) {
    if (!m_hasSuper || m_shadowed || ntype & cdh_mName_trueAttr) {
      strcat(res, ".");
      strcat(res, n + attr[0].offs);
    } else {
      for (int i = 0; i < num_attr; i++) {
        if (!attr[i].isSuper) {
          strcat(res, ".");
          int l = strlen(res);
          strncat(res, n + attr[i].offs, attr[i].len);
          if (attr[i].index != -1)
            sprintf(&res[l + attr[i].len], "[%d]", attr[i].index);
          else
            res[l + attr[i].len] = 0;
        }
      }
    }
  }
  return res;
}

char* wb_nrep::unatName(const char* name)
{
  static char result[256];
  const char* s;
  char* su;

  su = result;

  for (s = name; *s; s++, su++) {
    if (unatname_tab[*(unsigned char*)s] == '=')
      *su = *s;
    else
      *su = unatname_tab[*(unsigned char*)s];
  }
  *su = 0;
  return result;
}

char* wb_nrep::segmentsAll(int idx, char* res)
{
  static char result[256];

  if (idx >= num_seg || idx < 0) {
    if (res) {
      strcpy(res, "");
      return res;
    } else {
      strcpy(result, "");
      return result;
    }
  } else {
    if (res) {
      strncpy(res, oname + seg[0].offs,
          seg[num_seg - 1].offs - seg[0].offs + seg[num_seg - 1].len);
      res[seg[num_seg - 1].offs - seg[0].offs + seg[num_seg - 1].len] = 0;
      return res;
    } else {
      strncpy(result, oname + seg[0].offs,
          seg[num_seg - 1].offs - seg[0].offs + seg[num_seg - 1].len);
      result[seg[num_seg - 1].offs - seg[0].offs + seg[num_seg - 1].len] = 0;
      return result;
    }
  }
}

char* wb_nrep::attributesAll(int idx, char* res, bool true_db)
{
  static char result[256];

  if (idx >= num_attr || idx < 0) {
    if (res) {
      strcpy(res, "");
      return res;
    } else {
      strcpy(result, "");
      return result;
    }
  } else {
    if (!m_hasSuper || m_shadowed || true_db) {
      if (res) {
        strcpy(res, oname + attr[idx].offs);
        return res;
      } else {
        strcpy(result, oname + attr[idx].offs);
        return result;
      }
    } else {
      strcpy(result, "");
      for (int i = idx; i < num_attr; i++) {
        if (!attr[i].isSuper) {
          if (result[0] != 0)
            strcat(result, ".");
          int l = strlen(result);
          strncat(result, oname + attr[i].offs, attr[i].len);
          if (attr[i].index != -1)
            sprintf(&result[l + attr[i].len], "[%d]", attr[i].index);
          else
            result[l + attr[i].len] = 0;
        }
      }
      if (res) {
        strcpy(res, result);
        return res;
      }
      return result;
    }
  }
}

bool wb_nrep::checkObjectName(const char* name)
{
  const char* s;

  for (s = name; *s; s++) {
    if (objname_tab[*(unsigned char*)s] == '!')
      return false;
  }
  return true;
}
