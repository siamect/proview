/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* wb_wda.cpp -- spreadsheet editor */

#include "co_string.h"
#include "co_time.h"

#include "cow_xhelp.h"

#include "wb_wda_msg.h"
#include "wb_wdanav.h"
#include "wb_wtt.h"

void Wda::message_cb(void* wda, char severity, const char* message)
{
  ((Wda*)wda)->message(severity, message);
}

void Wda::change_value_cb(void* wda)
{
  ((Wda*)wda)->change_value(1);
}

void Wda::activate_print()
{
  print("Speadsheet Editor");
}

void Wda::print_textfile()
{
  message(' ', "");
  wow->CreateInputDialog(
      this, "Save as", "Enter filename", file_selected_cb, 0, 40, 0, 0);
}

void Wda::file_selected_cb(void* ctx, void* data, char* text)
{
  pwr_tFileName filename;
  Wda* wda = (Wda*)ctx;
  int sts;

  if (strchr(text, '/'))
    strcpy(filename, text);
  else {
    strcpy(filename, "$pwrp_login/");
    strcat(filename, text);
  }
  if (strchr(filename, '.') == 0)
    strcat(filename, ".wda_txt");

  dcli_translate_filename(filename, filename);
  sts = wda->wdanav->print_textfile(filename);
  if (EVEN(sts)) {
    char tmp[280];
    snprintf(tmp, sizeof(tmp), "Unable to open file \"%s\"", filename);
    wda->message('E', tmp);
  } else {
    char msg[300];
    strcpy(msg, "Exported to ");
    strcat(msg, filename);
    wda->message('I', msg);
  }
}

void Wda::import_textfile()
{
  if (!editmode) {
    message('E', "Not in edit mode");
    return;
  }

  message(' ', "");
  wow->CreateFileList("Import Spreadsheet", "$pwrp_login", "*", "wda_txt",
      import_file_cb, 0, this, 1);
}

void Wda::import_file_cb(void* ctx, char* text, int ok_pressed)
{
  pwr_tFileName filename;
  Wda* wda = (Wda*)ctx;
  int sts;

  if (!wda->editmode) {
    wda->message('E', "Not in edit mode");
    return;
  }

  sprintf(filename, "$pwrp_login/%s.wda_txt", text);
  dcli_translate_filename(filename, filename);

  sts = wda->wdanav->import_textfile(filename);
  if (EVEN(sts)) {
    wda->message('E', "Import error, see message window");
  }
}

void Wda::set_editmode(int editmode, ldh_tSesContext ldhses)
{
  this->ldhses = ldhses;
  this->editmode = editmode;
  ((WdaNav*)wdanav)->set_editmode(editmode, ldhses);
  update_title();
}

int Wda::open_changevalue(char* name)
{
  int sts;

  sts = ((WdaNav*)wdanav)->select_by_name(name);
  if (EVEN(sts))
    return sts;

  change_value(0);
  return WDA__SUCCESS;
}

void Wda::open_class_dialog()
{
  pwr_tOName hierstr;
  char classstr[80];
  int size;
  int sts;
  char* s;

  if (cdh_ObjidIsNotNull(objid)) {
    sts = ldh_ObjidToName(
        ldhses, objid, ldh_eName_Hierarchy, hierstr, sizeof(hierstr), &size);
    if (EVEN(sts))
      strcpy(hierstr, "");
  } else
    strcpy(hierstr, "");

  if (classid != 0) {
    sts = ldh_ClassIdToName(ldhses, classid, classstr, sizeof(classstr), &size);
    if (EVEN(sts))
      strcpy(classstr, "");
    else if ((s = strchr(classstr, '-')))
      strcpy(classstr, s + 1);
  } else
    strcpy(classstr, "");

  open_class_dialog(hierstr, classstr, search_name);
}

void Wda::open_attr_dialog()
{
  // Get all attributes for this class
  int i, j;
  char body[20];
  ldh_sParDef* bodydef;
  int sts;
  int rows;
  int attr_cnt;
  char(*attr_vect)[80];

  // Count the attributes
  attr_cnt = 0;
  for (i = 0; i < 3; i++) {
    if (i == 0)
      strcpy(body, "RtBody");
    else if (i == 1)
      strcpy(body, "DevBody");
    else
      strcpy(body, "SysBody");

    sts = ldh_GetObjectBodyDef(ldhses, classid, body, 1, &bodydef, &rows);
    if (EVEN(sts))
      continue;
    for (j = 0; j < rows; j++)
      attr_cnt++;

    free((char*)bodydef);
  }

  attr_vect = (char(*)[80])calloc(attr_cnt + 1, 80);

  attr_cnt = 0;
  for (i = 0; i < 3; i++) {
    if (i == 0)
      strcpy(body, "RtBody");
    else if (i == 1)
      strcpy(body, "DevBody");
    else
      strcpy(body, "SysBody");

    sts = ldh_GetObjectBodyDef(ldhses, classid, body, 1, &bodydef, &rows);
    if (EVEN(sts))
      continue;
    for (j = 0; j < rows; j++)
      strcpy(attr_vect[attr_cnt++], bodydef[j].ParName);

    free((char*)bodydef);
  }
  strcpy(attr_vect[attr_cnt], "");

  wow->CreateList(
      "Attributes", (char*)attr_vect, 80, set_attr_cb, 0, (void*)this);
}

int Wda::next_attr()
{
  // Get all attributes for this class
  int i, j;
  char body[20];
  ldh_sParDef* bodydef;
  int sts;
  int rows;
  int get_next;

  if (streq(attribute, ""))
    // Get first attribute
    get_next = 1;
  else
    get_next = 0;
  for (i = 0; i < 3; i++) {
    if (i == 0)
      strcpy(body, "RtBody");
    else if (i == 1)
      strcpy(body, "DevBody");
    else
      strcpy(body, "SysBody");

    sts = ldh_GetObjectBodyDef(ldhses, classid, body, 1, &bodydef, &rows);
    if (EVEN(sts))
      continue;
    for (j = 0; j < rows; j++) {
      if (str_NoCaseStrcmp(attribute, bodydef[j].ParName) == 0)
        get_next = 1;
      else if (get_next) {
        strcpy(attribute, bodydef[j].ParName);
        sts = ((WdaNav*)wdanav)
                  ->update(objid, classid, attribute, attrobjects, search_name);
        free((char*)bodydef);
        return WDA__SUCCESS;
      }
    }
    free((char*)bodydef);
  }
  return WDA__NONEXTATTR;
}

int Wda::prev_attr()
{
  // Get all attributes for this class
  int i, j;
  char body[20];
  ldh_sParDef* bodydef;
  int sts;
  int rows;
  int get_last;
  char prev_attr[40];

  strcpy(prev_attr, "");
  if (streq(attribute, ""))
    // Get last attribute
    get_last = 1;
  else
    get_last = 0;
  for (i = 0; i < 3; i++) {
    if (i == 0)
      strcpy(body, "RtBody");
    else if (i == 1)
      strcpy(body, "DevBody");
    else
      strcpy(body, "SysBody");

    sts = ldh_GetObjectBodyDef(ldhses, classid, body, 1, &bodydef, &rows);
    if (EVEN(sts))
      continue;
    for (j = 0; j < rows; j++) {
      if (str_NoCaseStrcmp(attribute, bodydef[j].ParName) == 0) {
        if (streq(prev_attr, "")) {
          // get_last = 1;
          free((char*)bodydef);
          return WDA__NOPREVATTR;
        } else {
          strcpy(attribute, prev_attr);
          sts = ((WdaNav*)wdanav)
                    ->update(
                        objid, classid, attribute, attrobjects, search_name);
          free((char*)bodydef);
          return WDA__SUCCESS;
        }
      }
      strcpy(prev_attr, bodydef[j].ParName);
    }
    free((char*)bodydef);
  }

  if (get_last && !streq(prev_attr, "")) {
    strcpy(attribute, prev_attr);
    sts = ((WdaNav*)wdanav)
              ->update(objid, classid, attribute, attrobjects, search_name);
    return WDA__SUCCESS;
  }
  return WDA__NOPREVATTR;
}

void Wda::set_attr_cb(void* ctx, char* text, int ok_pressed)
{
  Wda* wda = (Wda*)ctx;
  int sts;

  strcpy(wda->attribute, text);
  sts = ((WdaNav*)wda->wdanav)
            ->update(wda->objid, wda->classid, wda->attribute, wda->attrobjects,
                wda->search_name);
  if (EVEN(sts))
    wda->wow->DisplayError("Spreadsheet error", wnav_get_message(sts));
}

Wda::~Wda()
{
}

Wda::Wda(void* wa_parent_ctx, ldh_tSesContext wa_ldhses, pwr_tObjid wa_objid,
    pwr_tClassId wa_classid, const char* wa_attribute, int wa_editmode,
    int wa_advanced_user, int wa_display_objectname)
    : parent_ctx(wa_parent_ctx), ldhses(wa_ldhses), objid(wa_objid),
      classid(wa_classid), editmode(wa_editmode), input_open(0),
      input_multiline(0), close_cb(0), redraw_cb(0), client_data(0),
      attrobjects(0)
{
  strcpy(attribute, wa_attribute);
  strcpy(search_name, "");
}
