/** 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2014 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

/* wb_logwnav.cpp -- Backupfile display window */

#include "glow_std.h"

#include <stdio.h>
#include <stdlib.h>

#include "co_cdh.h"
#include "co_time.h"
#include "co_dcli.h"
#include "pwr_names.h"

#include "flow.h"
#include "flow_browctx.h"
#include "flow_browapi.h"

#include "xnav_bitmap_export8.h"
#include "xnav_bitmap_export10.h"
#include "xnav_bitmap_export12.h"
#include "xnav_bitmap_export14.h"
#include "xnav_bitmap_export16.h"
#include "xnav_bitmap_export18.h"
#include "xnav_bitmap_export20.h"
#include "xnav_bitmap_export24.h"
#include "xnav_bitmap_leaf8.h"
#include "xnav_bitmap_leaf10.h"
#include "xnav_bitmap_leaf12.h"
#include "xnav_bitmap_leaf14.h"
#include "xnav_bitmap_leaf16.h"
#include "xnav_bitmap_leaf18.h"
#include "xnav_bitmap_leaf20.h"
#include "xnav_bitmap_leaf24.h"
#include "xnav_bitmap_map8.h"
#include "xnav_bitmap_map10.h"
#include "xnav_bitmap_map12.h"
#include "xnav_bitmap_map14.h"
#include "xnav_bitmap_map16.h"
#include "xnav_bitmap_map18.h"
#include "xnav_bitmap_map20.h"
#include "xnav_bitmap_map24.h"
#include "xnav_bitmap_openmap8.h"
#include "xnav_bitmap_openmap10.h"
#include "xnav_bitmap_openmap12.h"
#include "xnav_bitmap_openmap14.h"
#include "xnav_bitmap_openmap16.h"
#include "xnav_bitmap_openmap18.h"
#include "xnav_bitmap_openmap20.h"
#include "xnav_bitmap_openmap24.h"

#include "cow_msgwindow.h"
#include "wb_ldh.h"
#include "wb_expwnav.h"
#include "pwr_baseclasses.h"
#include "wb_ldh_msg.h"

//
//  Free pixmaps
//
void WbExpWNavBrow::free_pixmaps()
{
  brow_FreeAnnotPixmap( ctx, pixmap_export);
  brow_FreeAnnotPixmap( ctx, pixmap_leaf);
  brow_FreeAnnotPixmap( ctx, pixmap_map);
  brow_FreeAnnotPixmap( ctx, pixmap_openmap);
}

//
//  Create pixmaps for leaf, closed map and open map
//
void WbExpWNavBrow::allocate_pixmaps()
{
  flow_sPixmapData pixmap_data;
  int i;

  i = 0;
  pixmap_data[i].width =xnav_bitmap_export8_width;
  pixmap_data[i].height =xnav_bitmap_export8_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_export8_bits;
  pixmap_data[i].width =xnav_bitmap_export10_width;
  pixmap_data[i].height =xnav_bitmap_export10_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_export10_bits;
  pixmap_data[i].width =xnav_bitmap_export12_width;
  pixmap_data[i].height =xnav_bitmap_export12_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_export12_bits;
  pixmap_data[i].width =xnav_bitmap_export14_width;
  pixmap_data[i].height =xnav_bitmap_export14_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_export14_bits;
  pixmap_data[i].width =xnav_bitmap_export16_width;
  pixmap_data[i].height =xnav_bitmap_export16_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_export16_bits;
  pixmap_data[i].width =xnav_bitmap_export18_width;
  pixmap_data[i].height =xnav_bitmap_export18_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_export18_bits;
  pixmap_data[i].width =xnav_bitmap_export20_width;
  pixmap_data[i].height =xnav_bitmap_export20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_export20_bits;
  pixmap_data[i].width =xnav_bitmap_export20_width;
  pixmap_data[i].height =xnav_bitmap_export20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_export20_bits;
  pixmap_data[i].width =xnav_bitmap_export24_width;
  pixmap_data[i].height =xnav_bitmap_export24_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_export24_bits;

  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_export);

  i = 0;
  pixmap_data[i].width =xnav_bitmap_leaf8_width;
  pixmap_data[i].height =xnav_bitmap_leaf8_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_leaf8_bits;
  pixmap_data[i].width =xnav_bitmap_leaf10_width;
  pixmap_data[i].height =xnav_bitmap_leaf10_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_leaf10_bits;
  pixmap_data[i].width =xnav_bitmap_leaf12_width;
  pixmap_data[i].height =xnav_bitmap_leaf12_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_leaf12_bits;
  pixmap_data[i].width =xnav_bitmap_leaf14_width;
  pixmap_data[i].height =xnav_bitmap_leaf14_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_leaf14_bits;
  pixmap_data[i].width =xnav_bitmap_leaf16_width;
  pixmap_data[i].height =xnav_bitmap_leaf16_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_leaf16_bits;
  pixmap_data[i].width =xnav_bitmap_leaf18_width;
  pixmap_data[i].height =xnav_bitmap_leaf18_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_leaf18_bits;
  pixmap_data[i].width =xnav_bitmap_leaf20_width;
  pixmap_data[i].height =xnav_bitmap_leaf20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_leaf20_bits;
  pixmap_data[i].width =xnav_bitmap_leaf20_width;
  pixmap_data[i].height =xnav_bitmap_leaf20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_leaf20_bits;
  pixmap_data[i].width =xnav_bitmap_leaf24_width;
  pixmap_data[i].height =xnav_bitmap_leaf24_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_leaf24_bits;

  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_leaf);
  i = 0;
  pixmap_data[i].width =xnav_bitmap_map8_width;
  pixmap_data[i].height =xnav_bitmap_map8_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_map8_bits;
  pixmap_data[i].width =xnav_bitmap_map10_width;
  pixmap_data[i].height =xnav_bitmap_map10_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_map10_bits;
  pixmap_data[i].width =xnav_bitmap_map12_width;
  pixmap_data[i].height =xnav_bitmap_map12_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_map12_bits;
  pixmap_data[i].width =xnav_bitmap_map14_width;
  pixmap_data[i].height =xnav_bitmap_map14_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_map14_bits;
  pixmap_data[i].width =xnav_bitmap_map16_width;
  pixmap_data[i].height =xnav_bitmap_map16_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_map16_bits;
  pixmap_data[i].width =xnav_bitmap_map18_width;
  pixmap_data[i].height =xnav_bitmap_map18_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_map18_bits;
  pixmap_data[i].width =xnav_bitmap_map20_width;
  pixmap_data[i].height =xnav_bitmap_map20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_map20_bits;
  pixmap_data[i].width =xnav_bitmap_map20_width;
  pixmap_data[i].height =xnav_bitmap_map20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_map20_bits;
  pixmap_data[i].width =xnav_bitmap_map24_width;
  pixmap_data[i].height =xnav_bitmap_map24_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_map24_bits;

  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_map);

  i = 0;
  pixmap_data[i].width =xnav_bitmap_openmap8_width;
  pixmap_data[i].height =xnav_bitmap_openmap8_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_openmap8_bits;
  pixmap_data[i].width =xnav_bitmap_openmap10_width;
  pixmap_data[i].height =xnav_bitmap_openmap10_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_openmap10_bits;
  pixmap_data[i].width =xnav_bitmap_openmap12_width;
  pixmap_data[i].height =xnav_bitmap_openmap12_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_openmap12_bits;
  pixmap_data[i].width =xnav_bitmap_openmap14_width;
  pixmap_data[i].height =xnav_bitmap_openmap14_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_openmap14_bits;
  pixmap_data[i].width =xnav_bitmap_openmap16_width;
  pixmap_data[i].height =xnav_bitmap_openmap16_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_openmap16_bits;
  pixmap_data[i].width =xnav_bitmap_openmap18_width;
  pixmap_data[i].height =xnav_bitmap_openmap18_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_openmap18_bits;
  pixmap_data[i].width =xnav_bitmap_openmap20_width;
  pixmap_data[i].height =xnav_bitmap_openmap20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_openmap20_bits;
  pixmap_data[i].width =xnav_bitmap_openmap20_width;
  pixmap_data[i].height =xnav_bitmap_openmap20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_openmap20_bits;
  pixmap_data[i].width =xnav_bitmap_openmap24_width;
  pixmap_data[i].height =xnav_bitmap_openmap24_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_openmap24_bits;

  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_openmap);

}

//
// Create nodeclasses
//
void WbExpWNavBrow::create_nodeclasses()
{
  allocate_pixmaps();

  // Create common-class

  brow_CreateNodeClass( ctx, "LogDefault", 
		flow_eNodeGroup_Common, &nc_exp);
  brow_AddAnnotPixmap( nc_exp, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot( nc_exp, 2.8, 0.6, 0,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		0);
  brow_AddAnnot( nc_exp, 35, 0.6, 1,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		0);
  brow_AddAnnot( nc_exp, 45, 0.6, 2,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		0);
  brow_AddFrame( nc_exp, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Create common-class with radiobutton

  brow_CreateNodeClass( ctx, "LogDefault", 
		flow_eNodeGroup_Common, &nc_eexp);
  brow_AddAnnotPixmap( nc_eexp, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddRadiobutton( nc_eexp, 1.4, 0.03, 0.7, 0.7, 0, flow_eDrawType_Line, 1);
  brow_AddAnnot( nc_eexp, 2.8, 0.6, 0,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		0);
  brow_AddAnnot( nc_eexp, 35, 0.6, 1,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		0);
  brow_AddAnnot( nc_eexp, 45, 0.6, 2,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		0);
  brow_AddFrame( nc_eexp, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);

}

void WbExpWNavBrow::brow_setup()
{
  brow_sAttributes brow_attr;
  unsigned long mask;

  mask = 0;
  mask |= brow_eAttr_indentation;
  brow_attr.indentation = 0.5;
  mask |= brow_eAttr_annotation_space;
  brow_attr.annotation_space = 0.5;
  brow_SetAttributes( ctx, &brow_attr, mask); 
  brow_SetCtxUserData( ctx, expwnav);

  brow_EnableEvent( ctx, flow_eEvent_MB1Click, flow_eEventType_CallBack, 
	WbExpWNav::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_MB1DoubleClick, flow_eEventType_CallBack, 
	WbExpWNav::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_MB3Press, flow_eEventType_CallBack, 
	WbExpWNav::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_MB3Down, flow_eEventType_CallBack, 
	WbExpWNav::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_SelectClear, flow_eEventType_CallBack, 
	WbExpWNav::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_ObjectDeleted, flow_eEventType_CallBack, 
	WbExpWNav::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_Up, flow_eEventType_CallBack, 
	WbExpWNav::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_Down, flow_eEventType_CallBack, 
	WbExpWNav::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_Left, flow_eEventType_CallBack, 
	WbExpWNav::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_Right, flow_eEventType_CallBack, 
	WbExpWNav::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_ShiftRight, flow_eEventType_CallBack, 
	WbExpWNav::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_PF3, flow_eEventType_CallBack, 
	WbExpWNav::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_PageUp, flow_eEventType_CallBack, 
	WbExpWNav::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_PageDown, flow_eEventType_CallBack, 
	WbExpWNav::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_ScrollUp, flow_eEventType_CallBack, 
	WbExpWNav::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_ScrollDown, flow_eEventType_CallBack, 
	WbExpWNav::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Radiobutton, flow_eEventType_CallBack, 
	WbExpWNav::brow_cb);
}

//
// Backcall routine called at creation of the brow widget
// Enable event, create nodeclasses and insert the root objects.
//
int WbExpWNav::init_brow_cb( FlowCtx *fctx, void *client_data)
{
  WbExpWNav *expwnav = (WbExpWNav *) client_data;
  BrowCtx *ctx = (BrowCtx *)fctx;

  expwnav->brow = new WbExpWNavBrow( ctx, (void *)expwnav);

  expwnav->brow->brow_setup();
  expwnav->brow->create_nodeclasses();

  return 1;
}

WbExpWNav::WbExpWNav( void *l_parent_ctx, ldh_tSesContext l_ldhses, int l_type, 
		      int l_editmode) :
  parent_ctx(l_parent_ctx), ldhses(l_ldhses), type(l_type), editmode(l_editmode),
  show_all(0), dirlist(0)
{
}


//
//  Delete ev
//
WbExpWNav::~WbExpWNav()
{
  list_free();
}

WbExpWNavBrow::~WbExpWNavBrow()
{
  free_pixmaps();
}


//
//  Zoom
//
void WbExpWNav::zoom( double zoom_factor)
{
  brow_Zoom( brow->ctx, zoom_factor);
}

//
//  Return to base zoom factor
//
void WbExpWNav::unzoom()
{
  brow_UnZoom( brow->ctx);
}

//
// Callbacks from brow
//
int WbExpWNav::brow_cb( FlowCtx *ctx, flow_tEvent event)
{
  WbExpWNav		*expwnav;
  ItemExp 		*item;
  int			sts;

  if ( event->event == flow_eEvent_ObjectDeleted)
  {
    brow_GetUserData( event->object.object, (void **)&item);
    delete item;
    return 1;
  }

  brow_GetCtxUserData( (BrowCtx *)ctx, (void **) &expwnav);
  switch ( event->event) {
    case flow_eEvent_Key_Right: {
      brow_tNode	*node_list;
      int		node_count;
      int		value;

      brow_GetSelectedNodes( expwnav->brow->ctx, &node_list, &node_count);
      if ( !node_count)
        break;
      brow_GetUserData( node_list[0], (void **)&item);
      switch( item->type)
      {
        case expwitem_eItemType_Dir: 
	  brow_GetRadiobutton( node_list[0], 0, &value);
	  ((ItemDir *)item)->set( !value);
	  //sts = ((ItemDir *)item)->open_children();
          break;
        case expwitem_eItemType_Exp: 
	  brow_GetRadiobutton( node_list[0], 0, &value);
	  ((ItemExp *)item)->set( !value);
	  break;
        default: ;
      }
      free( node_list);
      break;
    }
    case flow_eEvent_Key_ShiftRight: {
      brow_tNode	*node_list;
      int		node_count;

      brow_GetSelectedNodes( expwnav->brow->ctx, &node_list, &node_count);
      if ( !node_count)
        break;
      brow_GetUserData( node_list[0], (void **)&item);
      switch( item->type)
      {
        case expwitem_eItemType_Dir: 
	  sts = ((ItemDir *)item)->open_children();
          break;
        default: ;
      }
      free( node_list);
      break;
    }
    case flow_eEvent_Key_Left:
    {
      brow_tNode	*node_list;
      int		node_count;
      brow_tObject	object;
      int		sts;
      
      brow_GetSelectedNodes( expwnav->brow->ctx, &node_list, &node_count);
      if ( !node_count)
        return 1;

      if ( brow_IsOpen( node_list[0]))
        // Close this node
        object = node_list[0];
      else {
        // Close parent
        sts = brow_GetParent( expwnav->brow->ctx, node_list[0], &object);
        if ( EVEN(sts)) {
          free( node_list);
          return 1;
        }
      }
      brow_GetUserData( object, (void **)&item);
      switch( item->type) {
        case expwitem_eItemType_Dir: 
	  ((ItemDir *)item)->close();
          break;
        default: ;
      }
      brow_SelectClear( expwnav->brow->ctx);
      brow_SetInverse( object, 1);
      brow_SelectInsert( expwnav->brow->ctx, object);
      if ( !brow_IsVisible( expwnav->brow->ctx, object, flow_eVisible_Full))
        brow_CenterObject( expwnav->brow->ctx, object, 0.25);
      free( node_list);
      break;
    }
    case flow_eEvent_Key_Up:
    {
      brow_tNode	*node_list;
      int		node_count;
      brow_tObject	object;
      int		sts;

      brow_GetSelectedNodes( expwnav->brow->ctx, &node_list, &node_count);
      if ( !node_count) {
        sts = brow_GetLastVisible( expwnav->brow->ctx, &object);
        if ( EVEN(sts)) return 1;
      }
      else {
	if ( !brow_IsVisible( expwnav->brow->ctx, node_list[0], flow_eVisible_Partial)) {
	  sts = brow_GetLastVisible( expwnav->brow->ctx, &object);
	  if ( EVEN(sts)) return 1;
	}
	else {
	  sts = brow_GetPrevious( expwnav->brow->ctx, node_list[0], &object);
	  if ( EVEN(sts)) {
            if ( node_count)
	      free( node_list);
            return 1;
 	  }
        }
      }
      brow_SelectClear( expwnav->brow->ctx);
      brow_SetInverse( object, 1);
      brow_SelectInsert( expwnav->brow->ctx, object);
      if ( !brow_IsVisible( expwnav->brow->ctx, object, flow_eVisible_Full))
        brow_CenterObject( expwnav->brow->ctx, object, 0.25);
      if ( node_count)
        free( node_list);
      break;
    }
    case flow_eEvent_Key_Down:
    {
      brow_tNode	*node_list;
      int		node_count;
      brow_tObject	object;
      int		sts;

      brow_GetSelectedNodes( expwnav->brow->ctx, &node_list, &node_count);
      if ( !node_count) {
        sts = brow_GetFirstVisible( expwnav->brow->ctx, &object);
        if ( EVEN(sts)) return 1;
      }
      else {
	if ( !brow_IsVisible( expwnav->brow->ctx, node_list[0], flow_eVisible_Partial)) {
	  sts = brow_GetFirstVisible( expwnav->brow->ctx, &object);
	  if ( EVEN(sts)) return 1;
	}
	else {
	  sts = brow_GetNext( expwnav->brow->ctx, node_list[0], &object);
	  if ( EVEN(sts)) {
            if ( node_count)
	      free( node_list);
            return 1;
 	  }
        }
      }
      brow_SelectClear( expwnav->brow->ctx);
      brow_SetInverse( object, 1);
      brow_SelectInsert( expwnav->brow->ctx, object);
      if ( !brow_IsVisible( expwnav->brow->ctx, object, flow_eVisible_Full))
        brow_CenterObject( expwnav->brow->ctx, object, 0.75);
      if ( node_count)
        free( node_list);
      break;
    }
    case flow_eEvent_SelectClear:
      brow_ResetSelectInverse( expwnav->brow->ctx);
      break;
    case flow_eEvent_MB1Click:
      // Select
      double ll_x, ll_y, ur_x, ur_y;
      int		sts;

      switch ( event->object.object_type)
      {
        case flow_eObjectType_Node:
          brow_MeasureNode( event->object.object, &ll_x, &ll_y,
			&ur_x, &ur_y);
	  if ( event->object.x < ll_x + 1.0)
          {
            // Simulate doubleclick
            flow_tEvent doubleclick_event;

            doubleclick_event = (flow_tEvent) calloc( 1, sizeof(*doubleclick_event));
            memcpy( doubleclick_event, event, sizeof(*doubleclick_event));
            doubleclick_event->event = flow_eEvent_MB1DoubleClick;
            sts = WbExpWNav::brow_cb( ctx, doubleclick_event);
            free( (char *) doubleclick_event);
            return sts;
          }

          if ( brow_FindSelectedObject( expwnav->brow->ctx, event->object.object))
          {
            brow_SelectClear( expwnav->brow->ctx);
          }
          else
          {
            brow_SelectClear( expwnav->brow->ctx);
            brow_SetInverse( event->object.object, 1);
            brow_SelectInsert( expwnav->brow->ctx, event->object.object);
          }
          break;
        default:
          brow_SelectClear( expwnav->brow->ctx);
      }
      break;
    case flow_eEvent_Key_PageDown: {
      brow_Page( expwnav->brow->ctx, 0.95);
      break;
    }
    case flow_eEvent_Key_PageUp: {
      brow_Page( expwnav->brow->ctx, -0.95);
      break;
    }
    case flow_eEvent_ScrollDown: {
      brow_Page( expwnav->brow->ctx, 0.10);
      break;
    }
    case flow_eEvent_ScrollUp: {
      brow_Page( expwnav->brow->ctx, -0.10);
      break;
    }
    case flow_eEvent_MB1DoubleClick: {
      switch ( event->object.object_type) {
        case flow_eObjectType_Node:
	  brow_GetUserData( event->object.object, (void **)&item);
	  switch( item->type) {
	  case expwitem_eItemType_Dir: 
	    sts = ((ItemDir *)item)->open_children();
	    break;
	  default: ;
	  }
	  break;
      default: ;
      }
    }
    case flow_eEvent_Radiobutton: {

      switch ( event->object.object_type) {
        case flow_eObjectType_Node:
          brow_GetUserData( event->object.object, (void **)&item);
          switch( item->type) {
            case expwitem_eItemType_Exp: 
	      ((ItemExp *)item)->set( !event->radiobutton.value);
              break;
            case expwitem_eItemType_Dir: 
	      ((ItemDir *)item)->set( !event->radiobutton.value);
              break;
            default:
              ;
          }
          break;
        default:
          ;
      }
      break;
    }
    default:
      ;
  }
  return 1;
}

void WbExpWNav::show()
{
  switch ( type) {
  case expw_eType_Import:
  case expw_eType_Export:
    show_export_import();
    break;
  case expw_eType_BuildDirectories:
    show_builddir();
    break;
  default: ;
  }
}

void WbExpWNav::show_export_import()
{

  pwr_tFileName fname;
  char line[400];
  char line_item[4][250];
  pwr_tFileName found_file;
  int num;
  int sts;
  char tag[20];

  brow_SetNodraw( brow->ctx);
  brow_DeleteAll( brow->ctx);

  dcli_translate_filename( fname, pwr_cNameDistribute);
  ifstream is( fname);

  while ( is.getline( line, sizeof(line))) {
    dcli_trim( line, line);
    if ( line[0] == '#' || line[0] == '!')
      continue;

    num = dcli_parse( line, " 	", "", (char *)line_item,
		     sizeof(line_item)/sizeof(line_item[0]),
		     sizeof(line_item[0]), 0);
    if ( !num)
      continue;

    if ( type == expw_eType_Export)
      strcpy( tag, "export");
    else
      strcpy( tag, "import");

    if ( strcmp( cdh_Low(line_item[0]), tag) == 0) {
      if ( num != 4) {
	printf("File corrupt " pwr_cNameDistribute);
	continue;
      }
      
      for ( sts = dcli_search_file( line_item[2], found_file, DCLI_DIR_SEARCH_INIT);
	    ODD(sts);
	    sts = dcli_search_file( line_item[2], found_file, DCLI_DIR_SEARCH_NEXT)) {
	
	// Check if file should be updated
	int update = 0;
	pwr_tFileName source, target;
	pwr_tTime source_time, target_time;
	
	strncpy( source, found_file, sizeof(source));
	strncpy( target, line_item[3], sizeof(target));
	
	sts = dcli_file_time( source, &source_time);
	
	if ( target[strlen(target)-1] == '/') {
	  // Target is a directory, add file name
	  char *s = strrchr( source, '/');
	  if ( !s)
	    strncat( target, source, sizeof(target));
	  else
	    strncat( target, s+1, sizeof(target));
	}
	
	dcli_translate_filename( target, target);
	sts = dcli_file_time( target, &target_time);	  
	
	if ( ODD(sts) && time_Acomp( &source_time, &target_time) != 1)
	  update = 0;
	else
	  update = 1;
	
	if ( !show_all && !update)
	  continue;
	  
	ItemExp *item = new ItemExp( this, found_file, line_item[3], 0, 0, flow_eDest_IntoLast);
	if ( update)
	  brow_SetRadiobutton( item->node, 0, 1);  
      }
      dcli_search_file( line_item[2], found_file, DCLI_DIR_SEARCH_END);
    }
  }
  
  is.close();    

  check_all();

  brow_ResetNodraw( brow->ctx);
  brow_Redraw( brow->ctx, 0);

}

void WbExpWNav::show_builddir()
{

  pwr_tFileName fname;
  char line[400];
  char line_item[4][250];
  pwr_tFileName found_file;
  int num;
  int sts;

  list_free();

  dcli_translate_filename( fname, pwr_cNameDistribute);
  ifstream is( fname);

  while ( is.getline( line, sizeof(line))) {
    dcli_trim( line, line);
    if ( line[0] == '#' || line[0] == '!')
      continue;

    num = dcli_parse( line, " 	", "", (char *)line_item,
		     sizeof(line_item)/sizeof(line_item[0]),
		     sizeof(line_item[0]), 0);
    if ( !num)
      continue;

    if ( strcmp( cdh_Low(line_item[0]), "builddir") == 0) {
      if ( num != 4) {
	printf("File corrupt " pwr_cNameDistribute);
	continue;
      }

      ExpWDir *dir = dir_find( line_item[1]);
      if ( !dir)
	dir = dir_insert( line_item[1], line_item[2], line_item[3]);
    }

    else if ( strcmp( cdh_Low(line_item[0]), "buildcopy") == 0) {
      int dir_update = 0;
      if ( num != 4) {
	printf("File corrupt " pwr_cNameDistribute);
	continue;
      }

      for ( sts = dcli_search_file( line_item[2], found_file, DCLI_DIR_SEARCH_INIT);
	    ODD(sts);
	    sts = dcli_search_file( line_item[2], found_file, DCLI_DIR_SEARCH_NEXT)) {

	// Check if file should be updated
	int update = 0;
	pwr_tFileName source, target;
	pwr_tTime source_time, target_time;

	strncpy( source, found_file, sizeof(source));
	strncpy( target, line_item[3], sizeof(target));

	sts = dcli_file_time( source, &source_time);

	if ( target[strlen(target)-1] == '/') {
	  // Target is a directory, add file name
	  char *s = strrchr( source, '/');
	  if ( !s)
	    strncat( target, source, sizeof(target));
	  else
	    strncat( target, s+1, sizeof(target));
	}
	
	dcli_translate_filename( target, target);
	sts = dcli_file_time( target, &target_time);	  
	
	if ( ODD(sts) && time_Acomp( &source_time, &target_time) != 1)
	  update = 0;
	else
	  update = 1;

	ExpWDir *dir = dir_find( line_item[1]);
	if ( !dir) {
	  printf("File corrupt " pwr_cNameDistribute);
	  continue;
	}

	dir->copy_insert( source, target, update);
	if ( update)
	  dir->update = 1;
      }

      dcli_search_file( line_item[1], found_file, DCLI_DIR_SEARCH_END);

      ItemExp *item = new ItemExp( this, found_file, line_item[1], 0, 0, flow_eDest_IntoLast);
      if ( dir_update)
	brow_SetRadiobutton( item->node, 0, 1);  
      
    }
    else if ( strcmp( cdh_Low(line_item[0]), "buildmake") == 0) {
      int update = 1;

      if ( num != 4) {
	printf("File corrupt " pwr_cNameDistribute);
	continue;
      }

      ExpWDir *dir = dir_find( line_item[1]);
      if ( !dir) {
	printf("File corrupt " pwr_cNameDistribute);
	continue;
      }

      dir->make_insert( line_item[2], line_item[3], update);
      if ( update)
	dir->update = 1;
    }
    else if ( strcmp( cdh_Low(line_item[0]), "buildexec") == 0) {
      int update = 1;

      if ( num != 4) {
	printf("File corrupt " pwr_cNameDistribute);
	continue;
      }

      ExpWDir *dir = dir_find( line_item[1]);
      if ( !dir) {
	printf("File corrupt " pwr_cNameDistribute);
	continue;
      }

      dir->exec_insert( line_item[2], line_item[3], update);
      if ( update)
	dir->update = 1;
    }
  }
  
  is.close();    

  redraw();
}

void WbExpWNav::set_show_all( int set) 
{ 
  show_all = set; 
  switch ( type) {
  case expw_eType_Export:
  case expw_eType_Import:
    show();
    break;
  case expw_eType_BuildDirectories:
    redraw();
    break;
  }
}

void WbExpWNav::redraw()
{
  brow_SetNodraw( brow->ctx);
  brow_DeleteAll( brow->ctx);

  for ( ExpWDir *dir = dirlist; dir; dir = dir->next) {
    ItemDir *item = new ItemDir( this, dir, dir->name, dir->description, 0, flow_eDest_IntoLast);
    if ( dir->update)
      brow_SetRadiobutton( item->node, 0, 1);
    if ( dir->open)
      item->open_children();
  }

  brow_ResetNodraw( brow->ctx);
  brow_Redraw( brow->ctx, 0);
}

ExpWDir *WbExpWNav::dir_find( char *name)
{
  for ( ExpWDir *dir = dirlist; dir; dir = dir->next) {
    if ( strcmp( dir->name, name) == 0)
      return dir;
  }
  return 0;
}

void WbExpWNav::list_free()
{
  ExpWDir *dp_next;
  for ( ExpWDir *dp = dirlist; dp; dp = dp_next) {
    ExpWCopy *cp_next;
    for ( ExpWCopy *cp = dp->copylist; cp; cp = cp_next) {
      cp_next = cp->next;
      delete cp;
    }
    ExpWMake *mp_next;
    for ( ExpWMake *mp = dp->makelist; mp; mp = mp_next) {
      mp_next = mp->next;
      delete mp;
    }
    ExpWExec *ep_next;
    for ( ExpWExec *ep = dp->execlist; ep; ep = ep_next) {
      ep_next = ep->next;
      delete ep;
    }
    dp_next = dp->next;
    delete dp;
  }
  dirlist = 0;
}

ExpWDir *WbExpWNav::dir_insert( char *name, char *options_str, char *description)
{
  int num;

  ExpWDir *dir = new ExpWDir();
  strncpy( dir->name, name, sizeof(dir->name));
  num = sscanf( options_str, "%d", &dir->options);
  if ( num != 1) {
    printf( "** BuildDirectory.Options syntax error\n");
    dir->options = 0;
  }
  strncpy( dir->description, description, sizeof(dir->description));

  if ( !dirlist)
    dirlist = dir;
  else {
    ExpWDir *dp;
    for ( dp = dirlist; dp->next; dp = dp->next) ;
    dp->next = dir;
  }
  return dir;
}

ExpWCopy *ExpWDir::copy_insert( char *source, char *target, int update)
{
  ExpWCopy *copy = new ExpWCopy();
  strncpy( copy->source, source, sizeof(copy->source));
  strncpy( copy->target, target, sizeof(copy->target));
  copy->update = update;

  if ( !copylist)
    copylist = copy;
  else {
    ExpWCopy *cp;
    for ( cp = copylist; cp->next; cp = cp->next) ;
    cp->next = copy;
  }
  return copy;
}

ExpWMake *ExpWDir::make_insert( char *dir, char *makefile, int update)
{
  ExpWMake *make = new ExpWMake();
  strncpy( make->dir, dir, sizeof(make->dir));
  strncpy( make->makefile, makefile, sizeof(make->makefile));
  make->update = update;

  if ( !makelist)
    makelist = make;
  else {
    ExpWMake *ep;
    for ( ep = makelist; ep->next; ep = ep->next) ;
    ep->next = make;
  }
  return make;
}

ExpWExec *ExpWDir::exec_insert( char *dir, char *command, int update)
{
  ExpWExec *exec = new ExpWExec();
  strncpy( exec->dir, dir, sizeof(exec->dir));
  strncpy( exec->command, command, sizeof(exec->command));
  exec->update = update;

  if ( !execlist)
    execlist = exec;
  else {
    ExpWExec *ep;
    for ( ep = execlist; ep->next; ep = ep->next) ;
    ep->next = exec;
  }
  return exec;
}

void WbExpWNav::clear()
{
  brow_DeleteAll( brow->ctx);
}

pwr_tStatus WbExpWNav::exp()
{
  int sts;
  ItemExp *item;
  pwr_tCmd cmd;
  brow_tNode node;
  int rval;
  
  switch ( type) {
  case expw_eType_Import:
  case expw_eType_Export: {
    for ( sts = brow_GetFirst( brow->ctx, &node); 
	  ODD(sts); 
	  sts = brow_GetNext( brow->ctx, node, &node)) {
      brow_GetRadiobutton( node, 0, &rval);  

      if ( rval) {
      
	brow_GetUserData( node, (void **)&item);

	sprintf( cmd, "cp -a %s %s", item->source, item->target);
	printf( "%s\n", cmd);
	sts = system( cmd);
	if ( sts != 0) {
	  char msg[250];
	  snprintf( msg, sizeof(msg), "Export error %d, %s", WEXITSTATUS(sts), cmd);
	  MsgWindow::message( 'E', msg, msgw_ePop_Default);
	}
      }
    }
    
    show();
    break;
  }
  case expw_eType_BuildDirectories: {
    for ( ExpWDir *dp = dirlist; dp; dp = dp->next) {
      if ( !dp->update)
	continue;
      
      for ( ExpWCopy *cp = dp->copylist; cp; cp = cp->next) {
	if ( !cp->update)
	  continue;

	sprintf( cmd, "cp -a %s %s", cp->source, cp->target);
	printf( "%s\n", cmd);
	sts = system( cmd);
	if ( sts != 0) {
	  char msg[250];
	  snprintf( msg, sizeof(msg), "Build error %d, %s", WEXITSTATUS(sts), cmd);
	  MsgWindow::message( 'E', msg, msgw_ePop_Default);
	}
      }
    }

    for ( ExpWDir *dp = dirlist; dp; dp = dp->next) {
      if ( !dp->update)
	continue;
      
      for ( ExpWMake *mp = dp->makelist; mp; mp = mp->next) {
	if ( !mp->update)
	  continue;

	sprintf( cmd, "cd %s;make %s", mp->dir, mp->makefile);
	printf( "%s\n", cmd);
	sts = system( cmd);
	if ( sts != 0) {
	  char msg[250];
	  snprintf( msg, sizeof(msg), "Build error %d, %s", WEXITSTATUS(sts), cmd);
	  MsgWindow::message( 'E', msg, msgw_ePop_Default);
	}
      }
      for ( ExpWExec *ep = dp->execlist; ep; ep = ep->next) {
	if ( !ep->update)
	  continue;

	sprintf( cmd, "cd %s;%s", ep->dir, ep->command);
	printf( "%s\n", cmd);
	sts = system( cmd);
	if ( sts != 0) {
	  char msg[250];
	  snprintf( msg, sizeof(msg), "Build error %d, %s", WEXITSTATUS(sts), cmd);
	  MsgWindow::message( 'E', msg, msgw_ePop_Default);
	}
      }
    }

    show();

    break;    
  }
  }

  return LDH__SUCCESS;
}
 
void WbExpWNav::check_all()
{

  switch ( type) {
  case expw_eType_Import:
  case expw_eType_Export: {
    int sts;
    brow_tNode node;

    for ( sts = brow_GetFirst( brow->ctx, &node); 
	  ODD(sts); 
	  sts = brow_GetNext( brow->ctx, node, &node))
      brow_SetRadiobutton( node, 0, 1);
    break;
  }
  case expw_eType_BuildDirectories: {
    for ( ExpWDir *dir = dirlist; dir; dir = dir->next) {
      dir->update = 1;
      for ( ExpWCopy *cp = dir->copylist; cp; cp = cp->next)
	cp->update = 1;
      for ( ExpWMake *mp = dir->makelist; mp; mp = mp->next)
	mp->update = 1;
      for ( ExpWExec *ep = dir->execlist; ep; ep = ep->next)
	ep->update = 1;
    }    
    redraw();
    break;
  }
  default: ;
  }
}
 
void WbExpWNav::check_clear()
{
  switch ( type) {
  case expw_eType_Import:
  case expw_eType_Export: {
    int sts;
    brow_tNode node;

    for ( sts = brow_GetFirst( brow->ctx, &node); 
	  ODD(sts); 
	  sts = brow_GetNext( brow->ctx, node, &node))
      brow_SetRadiobutton( node, 0, 0);
    break;
  }
  case expw_eType_BuildDirectories: {
    for ( ExpWDir *dir = dirlist; dir; dir = dir->next) {
      dir->update = 0;
      for ( ExpWCopy *cp = dir->copylist; cp; cp = cp->next)
	cp->update = 0;
      for ( ExpWMake *mp = dir->makelist; mp; mp = mp->next)
	mp->update = 0;
      for ( ExpWExec *ep = dir->execlist; ep; ep = ep->next)
	ep->update = 0;
    }    
    redraw();
    break;
  }
  default: ;
  }
}

void WbExpWNav::check_reset()
{
  show();
}


ItemExp::ItemExp( WbExpWNav *item_expwnav, char *item_source, char *item_target, ExpWList *item_listp,
		  brow_tNode dest, flow_eDest dest_code):
  expwnav(item_expwnav), button_value(0), listp(item_listp)
{

  type = expwitem_eItemType_Exp;
  strncpy( source, item_source, sizeof(source));
  strncpy( target, item_target, sizeof(target));

  if ( expwnav->editmode)
    brow_CreateNode( expwnav->brow->ctx, (char *)"Exp", expwnav->brow->nc_eexp,
		     dest, dest_code, (void *) this, 1, &node);
  else
    brow_CreateNode( expwnav->brow->ctx, (char *)"Exp", expwnav->brow->nc_exp,
		     dest, dest_code, (void *) this, 1, &node);

  int annot = 0;
  brow_SetAnnotation( node, annot++, source, strlen(source));
  brow_SetAnnotation( node, annot++, target, strlen(target));

  brow_SetAnnotPixmap( node, 0, expwnav->brow->pixmap_export);
           
}

void ItemExp::update()
{
  if ( button_value)
    brow_SetAnnotation( node, 1, "1", 1);
  else
    brow_SetAnnotation( node, 1, "0", 1);
}

void ItemExp::set( int value)
{
  button_value = value;
  brow_SetRadiobutton( node, 0, value);
  if ( listp)
    listp->update = value;
}

ItemDir::ItemDir( WbExpWNav *item_expwnav, ExpWDir *item_dir, char *item_name, char *item_description,
		  brow_tNode dest, flow_eDest dest_code):
  expwnav(item_expwnav), dir(item_dir), button_value(0)
{

  type = expwitem_eItemType_Dir;
  strncpy( name, item_name, sizeof(name));
  strncpy( description, item_description, sizeof(description));

  if ( expwnav->editmode)
    brow_CreateNode( expwnav->brow->ctx, (char *)"Dir", expwnav->brow->nc_eexp,
		     dest, dest_code, (void *) this, 1, &node);
  else
    brow_CreateNode( expwnav->brow->ctx, (char *)"Dir", expwnav->brow->nc_exp,
		     dest, dest_code, (void *) this, 1, &node);

  int annot = 0;
  brow_SetAnnotation( node, annot++, name, strlen(name));
  brow_SetAnnotation( node, annot++, description, strlen(description));

  // Check if map or leaf
  int child_exist = 0;
  if ( expwnav->show_all) {
    if ( dir->copylist || dir->execlist || dir->makelist)
      child_exist = 1;
  }
  else {
    if ( dir->execlist || dir->makelist)
      child_exist = 1;
    else {
      for ( ExpWCopy *cp = dir->copylist; cp; cp = cp->next) {
	if ( cp->update) {
	  child_exist = 1;
	  break;
	}
      }
    }
  }
  if ( child_exist)
    brow_SetAnnotPixmap( node, 0, expwnav->brow->pixmap_map);
  else
    brow_SetAnnotPixmap( node, 0, expwnav->brow->pixmap_leaf);           
}

void ItemDir::update()
{
  if ( button_value)
    brow_SetAnnotation( node, 1, "1", 1);
  else
    brow_SetAnnotation( node, 1, "0", 1);
}

void ItemDir::set( int value)
{
  button_value = value;
  brow_SetRadiobutton( node, 0, value);  
  dir->update = value;
}

int ItemDir::open_children()
{
  int child_exist = 0;

  if ( brow_IsOpen( node)) {
    // Close
    brow_SetNodraw( expwnav->brow->ctx);
    brow_CloseNode( expwnav->brow->ctx, node);
    if ( brow_IsOpen( node) & expw_mOpen_Children)
      brow_SetAnnotPixmap( node, 0, expwnav->brow->pixmap_map);
    brow_ResetOpen( node, expw_mOpen_All);
    brow_ResetNodraw( expwnav->brow->ctx);
    brow_Redraw( expwnav->brow->ctx, 0);
    dir->open = 0;
  }
  else {
    // Create some children
    brow_SetNodraw( expwnav->brow->ctx);

    for ( ExpWMake *mp = dir->makelist; mp; mp = mp->next) {
      pwr_tCmd cmd;
      sprintf( cmd, "make %s", mp->makefile);
      ItemExp *item = new ItemExp( expwnav, mp->dir, cmd, mp, node, flow_eDest_IntoLast);
      if ( mp->update)
	brow_SetRadiobutton( item->node, 0, 1);  
      child_exist = 1;
    }
    for ( ExpWExec *ep = dir->execlist; ep; ep = ep->next) {
      ItemExp *item = new ItemExp( expwnav, ep->dir, ep->command, ep, node, flow_eDest_IntoLast);
      if ( ep->update)
	brow_SetRadiobutton( item->node, 0, 1);  
      child_exist = 1;
    }
    for ( ExpWCopy *cp = dir->copylist; cp; cp = cp->next) {
      if ( !expwnav->show_all && !cp->update)
	continue;

      ItemExp *item = new ItemExp( expwnav, cp->source, cp->target, cp, node, flow_eDest_IntoLast);
      if ( cp->update)
	brow_SetRadiobutton( item->node, 0, 1);  
      child_exist = 1;
    }

    if ( child_exist) {
      brow_SetOpen( node, expw_mOpen_Children);
      brow_SetAnnotPixmap( node, 0, expwnav->brow->pixmap_openmap);
      dir->open = 1;
    }
    brow_ResetNodraw( expwnav->brow->ctx);
    if ( child_exist)
      brow_Redraw( expwnav->brow->ctx, 0);
    else
     return 0;
  }
  return 1;
}

int ItemDir::close()
{
  if ( brow_IsOpen( node)) {
    // Close
    brow_SetNodraw( expwnav->brow->ctx);
    brow_CloseNode( expwnav->brow->ctx, node);
    if ( brow_IsOpen( node) & expw_mOpen_Children)
      brow_SetAnnotPixmap( node, 0, expwnav->brow->pixmap_map);
    brow_ResetOpen( node, expw_mOpen_All);
    brow_ResetNodraw( expwnav->brow->ctx);
    brow_Redraw( expwnav->brow->ctx, 0);
    dir->open = 0;
  }
  return 1;
}
