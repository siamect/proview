/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* wb_logwnav.cpp -- Backupfile display window */

#include <stdio.h>

#include "pwr_baseclasses.h"
#include "pwr_names.h"

#include "co_string.h"
#include "co_time.h"

#include "cow_msgwindow.h"

#include "wb_expwnav.h"
#include "wb_ldh_msg.h"

//
//  Free pixmaps
//
void WbExpWNavBrow::free_pixmaps()
{
  brow_FreeAnnotPixmap(ctx, pixmap_export);
  brow_FreeAnnotPixmap(ctx, pixmap_leaf);
  brow_FreeAnnotPixmap(ctx, pixmap_map);
  brow_FreeAnnotPixmap(ctx, pixmap_openmap);
}

//
//  Create pixmaps for leaf, closed map and open map
//
void WbExpWNavBrow::allocate_pixmaps()
{
  brow_LoadPBMs(ctx, "xnav_bitmap_export", &pixmap_export);
  brow_LoadPBMs(ctx, "xnav_bitmap_leaf", &pixmap_leaf);
  brow_LoadPBMs(ctx, "xnav_bitmap_map", &pixmap_map);
  brow_LoadPBMs(ctx, "xnav_bitmap_openmap", &pixmap_openmap);
}

//
// Create nodeclasses
//
void WbExpWNavBrow::create_nodeclasses()
{
  allocate_pixmaps();

  // Create common-class

  brow_CreateNodeClass(ctx, "LogDefault", flow_eNodeGroup_Common, &nc_exp);
  brow_AddAnnotPixmap(nc_exp, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot(nc_exp, 2.8, 0.6, 0, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_exp, 35, 0.6, 1, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_exp, 45, 0.6, 2, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddFrame(nc_exp, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Create common-class with radiobutton

  brow_CreateNodeClass(ctx, "LogDefault", flow_eNodeGroup_Common, &nc_eexp);
  brow_AddAnnotPixmap(nc_eexp, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddRadiobutton(nc_eexp, 1.4, 0.03, 0.7, 0.7, 0, flow_eDrawType_Line, 1);
  brow_AddAnnot(nc_eexp, 2.8, 0.6, 0, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_eexp, 35, 0.6, 1, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_eexp, 45, 0.6, 2, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddFrame(nc_eexp, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);
}

void WbExpWNavBrow::brow_setup()
{
  brow_sAttributes brow_attr;
  unsigned long mask;

  mask = 0;
  mask |= brow_eAttr_indentation;
  brow_attr.indentation = 0.5;
  mask |= brow_eAttr_annotation_space;
  brow_attr.annotation_space = 0.5;
  brow_SetAttributes(ctx, &brow_attr, mask);
  brow_SetCtxUserData(ctx, expwnav);

  brow_EnableEvent(
      ctx, flow_eEvent_MB1Click, flow_eEventType_CallBack, WbExpWNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_MB1DoubleClick, flow_eEventType_CallBack,
      WbExpWNav::brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_MB3Press, flow_eEventType_CallBack, WbExpWNav::brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_MB3Down, flow_eEventType_CallBack, WbExpWNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_SelectClear, flow_eEventType_CallBack,
      WbExpWNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_ObjectDeleted, flow_eEventType_CallBack,
      WbExpWNav::brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_Key_Up, flow_eEventType_CallBack, WbExpWNav::brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_Key_Down, flow_eEventType_CallBack, WbExpWNav::brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_Key_Left, flow_eEventType_CallBack, WbExpWNav::brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_Key_Right, flow_eEventType_CallBack, WbExpWNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_Key_ShiftRight, flow_eEventType_CallBack,
      WbExpWNav::brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_Key_PF3, flow_eEventType_CallBack, WbExpWNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_Key_PageUp, flow_eEventType_CallBack,
      WbExpWNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_Key_PageDown, flow_eEventType_CallBack,
      WbExpWNav::brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_ScrollUp, flow_eEventType_CallBack, WbExpWNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_ScrollDown, flow_eEventType_CallBack,
      WbExpWNav::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_Radiobutton, flow_eEventType_CallBack,
      WbExpWNav::brow_cb);
}

//
// Backcall routine called at creation of the brow widget
// Enable event, create nodeclasses and insert the root objects.
//
int WbExpWNav::init_brow_cb(FlowCtx* fctx, void* client_data)
{
  WbExpWNav* expwnav = (WbExpWNav*)client_data;
  BrowCtx* ctx = (BrowCtx*)fctx;

  expwnav->brow = new WbExpWNavBrow(ctx, (void*)expwnav);

  expwnav->brow->brow_setup();
  expwnav->brow->create_nodeclasses();

  return 1;
}

WbExpWNav::WbExpWNav(
    void* l_parent_ctx, ldh_tSesContext l_ldhses, int l_type, int l_editmode)
    : parent_ctx(l_parent_ctx), ldhses(l_ldhses), type(l_type),
      editmode(l_editmode), show_all(0), dirlist(0)
{
}

//
//  Delete ev
//
WbExpWNav::~WbExpWNav()
{
  list_free();
}

WbExpWNavBrow::~WbExpWNavBrow()
{
  free_pixmaps();
}

//
//  Zoom
//
void WbExpWNav::zoom(double zoom_factor)
{
  brow_Zoom(brow->ctx, zoom_factor);
}

//
//  Return to base zoom factor
//
void WbExpWNav::unzoom()
{
  brow_UnZoom(brow->ctx);
}

//
// Callbacks from brow
//
int WbExpWNav::brow_cb(FlowCtx* ctx, flow_tEvent event)
{
  WbExpWNav* expwnav;
  ItemExp* item;
  int sts;

  if (event->event == flow_eEvent_ObjectDeleted) {
    brow_GetUserData(event->object.object, (void**)&item);
    delete item;
    return 1;
  }

  brow_GetCtxUserData((BrowCtx*)ctx, (void**)&expwnav);
  switch (event->event) {
  case flow_eEvent_Key_Right: {
    brow_tNode* node_list;
    int node_count;
    int value;

    brow_GetSelectedNodes(expwnav->brow->ctx, &node_list, &node_count);
    if (!node_count)
      break;
    brow_GetUserData(node_list[0], (void**)&item);
    switch (item->type) {
    case expwitem_eItemType_Dir:
      brow_GetRadiobutton(node_list[0], 0, &value);
      ((ItemDir*)item)->set(!value);
      // sts = ((ItemDir *)item)->open_children();
      break;
    case expwitem_eItemType_Exp:
      brow_GetRadiobutton(node_list[0], 0, &value);
      ((ItemExp*)item)->set(!value);
      break;
    default:;
    }
    free(node_list);
    break;
  }
  case flow_eEvent_Key_ShiftRight: {
    brow_tNode* node_list;
    int node_count;

    brow_GetSelectedNodes(expwnav->brow->ctx, &node_list, &node_count);
    if (!node_count)
      break;
    brow_GetUserData(node_list[0], (void**)&item);
    switch (item->type) {
    case expwitem_eItemType_Dir:
      sts = ((ItemDir*)item)->open_children();
      break;
    default:;
    }
    free(node_list);
    break;
  }
  case flow_eEvent_Key_Left: {
    brow_tNode* node_list;
    int node_count;
    brow_tObject object;
    int sts;

    brow_GetSelectedNodes(expwnav->brow->ctx, &node_list, &node_count);
    if (!node_count)
      return 1;

    if (brow_IsOpen(node_list[0]))
      // Close this node
      object = node_list[0];
    else {
      // Close parent
      sts = brow_GetParent(expwnav->brow->ctx, node_list[0], &object);
      if (EVEN(sts)) {
        free(node_list);
        return 1;
      }
    }
    brow_GetUserData(object, (void**)&item);
    switch (item->type) {
    case expwitem_eItemType_Dir:
      ((ItemDir*)item)->close();
      break;
    default:;
    }
    brow_SelectClear(expwnav->brow->ctx);
    brow_SetInverse(object, 1);
    brow_SelectInsert(expwnav->brow->ctx, object);
    if (!brow_IsVisible(expwnav->brow->ctx, object, flow_eVisible_Full))
      brow_CenterObject(expwnav->brow->ctx, object, 0.25);
    free(node_list);
    break;
  }
  case flow_eEvent_Key_Up: {
    brow_tNode* node_list;
    int node_count;
    brow_tObject object;
    int sts;

    brow_GetSelectedNodes(expwnav->brow->ctx, &node_list, &node_count);
    if (!node_count) {
      sts = brow_GetLastVisible(expwnav->brow->ctx, &object);
      if (EVEN(sts))
        return 1;
    } else {
      if (!brow_IsVisible(
              expwnav->brow->ctx, node_list[0], flow_eVisible_Partial)) {
        sts = brow_GetLastVisible(expwnav->brow->ctx, &object);
        if (EVEN(sts))
          return 1;
      } else {
        sts = brow_GetPrevious(expwnav->brow->ctx, node_list[0], &object);
        if (EVEN(sts)) {
          if (node_count)
            free(node_list);
          return 1;
        }
      }
    }
    brow_SelectClear(expwnav->brow->ctx);
    brow_SetInverse(object, 1);
    brow_SelectInsert(expwnav->brow->ctx, object);
    if (!brow_IsVisible(expwnav->brow->ctx, object, flow_eVisible_Full))
      brow_CenterObject(expwnav->brow->ctx, object, 0.25);
    if (node_count)
      free(node_list);
    break;
  }
  case flow_eEvent_Key_Down: {
    brow_tNode* node_list;
    int node_count;
    brow_tObject object;
    int sts;

    brow_GetSelectedNodes(expwnav->brow->ctx, &node_list, &node_count);
    if (!node_count) {
      sts = brow_GetFirstVisible(expwnav->brow->ctx, &object);
      if (EVEN(sts))
        return 1;
    } else {
      if (!brow_IsVisible(
              expwnav->brow->ctx, node_list[0], flow_eVisible_Partial)) {
        sts = brow_GetFirstVisible(expwnav->brow->ctx, &object);
        if (EVEN(sts))
          return 1;
      } else {
        sts = brow_GetNext(expwnav->brow->ctx, node_list[0], &object);
        if (EVEN(sts)) {
          if (node_count)
            free(node_list);
          return 1;
        }
      }
    }
    brow_SelectClear(expwnav->brow->ctx);
    brow_SetInverse(object, 1);
    brow_SelectInsert(expwnav->brow->ctx, object);
    if (!brow_IsVisible(expwnav->brow->ctx, object, flow_eVisible_Full))
      brow_CenterObject(expwnav->brow->ctx, object, 0.75);
    if (node_count)
      free(node_list);
    break;
  }
  case flow_eEvent_SelectClear:
    brow_ResetSelectInverse(expwnav->brow->ctx);
    break;
  case flow_eEvent_MB1Click:
    // Select
    double ll_x, ll_y, ur_x, ur_y;
    int sts;

    switch (event->object.object_type) {
    case flow_eObjectType_Node:
      brow_MeasureNode(event->object.object, &ll_x, &ll_y, &ur_x, &ur_y);
      if (event->object.x < ll_x + 1.0) {
        // Simulate doubleclick
        flow_tEvent doubleclick_event;

        doubleclick_event = (flow_tEvent)calloc(1, sizeof(*doubleclick_event));
        memcpy(doubleclick_event, event, sizeof(*doubleclick_event));
        doubleclick_event->event = flow_eEvent_MB1DoubleClick;
        sts = WbExpWNav::brow_cb(ctx, doubleclick_event);
        free((char*)doubleclick_event);
        return sts;
      }

      if (brow_FindSelectedObject(expwnav->brow->ctx, event->object.object)) {
        brow_SelectClear(expwnav->brow->ctx);
      } else {
        brow_SelectClear(expwnav->brow->ctx);
        brow_SetInverse(event->object.object, 1);
        brow_SelectInsert(expwnav->brow->ctx, event->object.object);
      }
      break;
    default:
      brow_SelectClear(expwnav->brow->ctx);
    }
    break;
  case flow_eEvent_Key_PageDown: {
    brow_Page(expwnav->brow->ctx, 0.95);
    break;
  }
  case flow_eEvent_Key_PageUp: {
    brow_Page(expwnav->brow->ctx, -0.95);
    break;
  }
  case flow_eEvent_ScrollDown: {
    brow_Page(expwnav->brow->ctx, 0.10);
    break;
  }
  case flow_eEvent_ScrollUp: {
    brow_Page(expwnav->brow->ctx, -0.10);
    break;
  }
  case flow_eEvent_MB1DoubleClick: {
    switch (event->object.object_type) {
    case flow_eObjectType_Node:
      brow_GetUserData(event->object.object, (void**)&item);
      switch (item->type) {
      case expwitem_eItemType_Dir:
        sts = ((ItemDir*)item)->open_children();
        break;
      default:;
      }
      break;
    default:;
    }
  }
  case flow_eEvent_Radiobutton: {
    switch (event->object.object_type) {
    case flow_eObjectType_Node:
      brow_GetUserData(event->object.object, (void**)&item);
      switch (item->type) {
      case expwitem_eItemType_Exp:
        ((ItemExp*)item)->set(!event->radiobutton.value);
        break;
      case expwitem_eItemType_Dir:
        ((ItemDir*)item)->set(!event->radiobutton.value);
        break;
      default:;
      }
      break;
    default:;
    }
    break;
  }
  default:;
  }
  return 1;
}

void WbExpWNav::show()
{
  switch (type) {
  case expw_eType_Import:
  case expw_eType_Export:
    show_export_import();
    break;
  case expw_eType_BuildDirectories:
    show_builddir();
    break;
  default:;
  }
}

void WbExpWNav::update()
{
  int sts;
  ItemDir* item;
  brow_tNode node;
  pwr_tString80* open_nodes;
  int select_exist = 0;
  expwitem_eItemType select_type = expwitem_eItemType_Exp;
  pwr_tString80 select_name;
  pwr_tFileName select_source;
  pwr_tFileName select_target;
  brow_tNode* node_list;
  int node_count;

  // Store selected node
  brow_GetSelectedNodes(brow->ctx, &node_list, &node_count);
  if (node_count) {
    select_exist = 1;
    brow_GetUserData(node_list[0], (void**)&item);
    select_type = item->type;

    switch (item->type) {
    case expwitem_eItemType_Dir:
      strcpy(select_name, item->name);
      break;
    case expwitem_eItemType_Exp:
      strcpy(select_source, ((ItemExp*)item)->source);
      strcpy(select_target, ((ItemExp*)item)->target);
      break;
    }
    free(node_list);
  }

  // Store all open nodes.
  int cnt = 0;
  for (sts = brow_GetFirst(brow->ctx, &node); ODD(sts);
       sts = brow_GetNextSibling(brow->ctx, node, &node)) {
    if (brow_IsOpen(node))
      cnt++;
  }

  open_nodes = (pwr_tString80*)calloc(cnt, sizeof(pwr_tString80));

  cnt = 0;
  for (sts = brow_GetFirst(brow->ctx, &node); ODD(sts);
       sts = brow_GetNextSibling(brow->ctx, node, &node)) {
    if (brow_IsOpen(node)) {
      brow_GetUserData(node, (void**)&item);

      switch (item->type) {
      case expwitem_eItemType_Exp:
        break;
      case expwitem_eItemType_Dir:
        strcpy(open_nodes[cnt], item->name);
        break;
      }
      cnt++;
    }
  }

  brow_SetNodraw(brow->ctx);

  show();

  if (cnt) {
    for (sts = brow_GetFirst(brow->ctx, &node); ODD(sts);
         sts = brow_GetNextSibling(brow->ctx, node, &node)) {
      brow_GetUserData(node, (void**)&item);

      switch (item->type) {
      case expwitem_eItemType_Exp:
        break;
      case expwitem_eItemType_Dir:
        for (int i = 0; i < cnt; i++) {
          if (streq(open_nodes[i], item->name)) {
            item->open_children();
          }
        }
        break;
      }
    }
  }

  // Select previously selected node
  if (select_exist) {
    brow_GetObjectList(brow->ctx, &node_list, &node_count);
    for (int i = 0; i < node_count; i++) {
      brow_GetUserData(node_list[i], (void**)&item);
      if (select_type == item->type
          && ((item->type == expwitem_eItemType_Exp
                  && streq(select_source, ((ItemExp*)item)->source)
                  && streq(select_target, ((ItemExp*)item)->target))
                 || (item->type == expwitem_eItemType_Dir
                        && streq(select_name, item->name)))) {
        brow_SelectInsert(brow->ctx, node_list[i]);
        brow_SetInverse(node_list[i], 1);
      }
    }
  }

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
  free(open_nodes);
}

void WbExpWNav::show_export_import()
{
  pwr_tFileName fname;
  char line[400];
  char line_item[4][250];
  pwr_tFileName found_file;
  int num;
  int sts;
  char tag[20];
  ItemExp* first_item = 0;

  brow_SetNodraw(brow->ctx);
  brow_DeleteAll(brow->ctx);

  dcli_translate_filename(fname, pwr_cNameDistribute);
  std::ifstream is(fname);

  while (is.getline(line, sizeof(line))) {
    str_trim(line, line);
    if (line[0] == '#' || line[0] == '!')
      continue;

    num = dcli_parse(line, " 	", "", (char*)line_item,
        sizeof(line_item) / sizeof(line_item[0]), sizeof(line_item[0]), 0);
    if (!num)
      continue;

    if (type == expw_eType_Export)
      strcpy(tag, "export");
    else
      strcpy(tag, "import");

    if (streq(cdh_Low(line_item[0]), tag)) {
      if (num != 4) {
        printf("File corrupt " pwr_cNameDistribute);
        continue;
      }

      for (sts
           = dcli_search_file(line_item[2], found_file, DCLI_DIR_SEARCH_INIT);
           ODD(sts); sts
           = dcli_search_file(line_item[2], found_file, DCLI_DIR_SEARCH_NEXT)) {
        // Check if file should be updated
        int update = 0;
        pwr_tFileName source, target;
        pwr_tTime source_time, target_time;

        strncpy(source, found_file, sizeof(source));
        strncpy(target, line_item[3], sizeof(target));

        sts = dcli_file_time(source, &source_time);

        if (target[strlen(target) - 1] == '/') {
          // Target is a directory, add file name
          char* s = strrchr(source, '/');
          if (!s)
            strncat(target, source, sizeof(target) - strlen(target) - 1);
          else
            strncat(target, s + 1, sizeof(target) - strlen(target) - 1);
        }

        dcli_translate_filename(target, target);
        sts = dcli_file_time(target, &target_time);

        if (ODD(sts) && time_Acomp(&source_time, &target_time) != 1)
          update = 0;
        else
          update = 1;

        if (!show_all && !update)
          continue;

        ItemExp* item = new ItemExp(
            this, found_file, line_item[3], 0, 0, flow_eDest_IntoLast);
        if (update)
          brow_SetRadiobutton(item->node, 0, 1);
        if (!first_item)
          first_item = item;
      }
      dcli_search_file(line_item[2], found_file, DCLI_DIR_SEARCH_END);
    }
  }

  is.close();

  if (!show_all && first_item)
    brow_CenterObject(brow->ctx, first_item->node, 0);

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
}

void WbExpWNav::show_builddir()
{
  pwr_tFileName fname;
  char line[400];
  char line_item[5][250];
  pwr_tFileName found_file;
  int num;
  int sts;

  list_free();

  dcli_translate_filename(fname, pwr_cNameDistribute);
  std::ifstream is(fname);

  while (is.getline(line, sizeof(line))) {
    str_trim(line, line);
    if (line[0] == '#' || line[0] == '!')
      continue;

    num = dcli_parse(line, " 	", "", (char*)line_item,
        sizeof(line_item) / sizeof(line_item[0]), sizeof(line_item[0]), 0);
    if (!num)
      continue;

    if (streq(cdh_Low(line_item[0]), "builddir")) {
      if (num != 4) {
        printf("File corrupt " pwr_cNameDistribute);
        continue;
      }

      ExpWDir* dir = dir_find(line_item[1]);
      if (!dir)
        dir = dir_insert(line_item[1], line_item[2], line_item[3]);
    }

    else if (streq(cdh_Low(line_item[0]), "buildcopy")) {
      int dir_update = 0;
      if (num != 4) {
        printf("File corrupt " pwr_cNameDistribute);
        continue;
      }

      for (sts
           = dcli_search_file(line_item[2], found_file, DCLI_DIR_SEARCH_INIT);
           ODD(sts); sts
           = dcli_search_file(line_item[2], found_file, DCLI_DIR_SEARCH_NEXT)) {
        // Check if file should be updated
        int update = 0;
        pwr_tFileName source, target;
        pwr_tTime source_time, target_time;

        strncpy(source, found_file, sizeof(source));
        strncpy(target, line_item[3], sizeof(target));

        sts = dcli_file_time(source, &source_time);

        if (target[strlen(target) - 1] == '/') {
          // Target is a directory, add file name
          char* s = strrchr(source, '/');
          if (!s)
            strncat(target, source, sizeof(target) - strlen(target) - 1);
          else
            strncat(target, s + 1, sizeof(target) - strlen(target) - 1);
        }

        dcli_translate_filename(target, target);
        sts = dcli_file_time(target, &target_time);

        if (ODD(sts) && time_Acomp(&source_time, &target_time) != 1)
          update = 0;
        else
          update = 1;

        ExpWDir* dir = dir_find(line_item[1]);
        if (!dir) {
          printf("File corrupt " pwr_cNameDistribute);
          continue;
        }

        dir->copy_insert(source, target, pwr_eFileConvertEnum_No, update);
        if (update)
          dir->update = 1;
      }

      dcli_search_file(line_item[1], found_file, DCLI_DIR_SEARCH_END);

      ItemExp* item = new ItemExp(
          this, found_file, line_item[1], 0, 0, flow_eDest_IntoLast);
      if (dir_update)
        brow_SetRadiobutton(item->node, 0, 1);
    }
    else if (streq(cdh_Low(line_item[0]), "buildconvert")) {
      int dir_update = 0;
      pwr_tFileConvertEnum conversion;

      if (num != 5) {
        printf("File corrupt " pwr_cNameDistribute);
        continue;
      }

      if (sscanf(line_item[2], "%d", &conversion) != 1) {
	printf("File corrupt " pwr_cNameDistribute);
	continue;
      }

      for (sts
           = dcli_search_file(line_item[3], found_file, DCLI_DIR_SEARCH_INIT);
           ODD(sts); sts
           = dcli_search_file(line_item[3], found_file, DCLI_DIR_SEARCH_NEXT)) {
        // Check if file should be updated
        int update = 0;
        pwr_tFileName source, target;
        pwr_tTime source_time, target_time;

        strncpy(source, found_file, sizeof(source));
        strncpy(target, line_item[4], sizeof(target));

        sts = dcli_file_time(source, &source_time);

        if (target[strlen(target) - 1] == '/') {
          // Target is a directory, add file name
          char* s = strrchr(source, '/');
          if (!s)
            strncat(target, source, sizeof(target) - strlen(target) - 1);
          else
            strncat(target, s + 1, sizeof(target) - strlen(target) - 1);
        }

        dcli_translate_filename(target, target);
        sts = dcli_file_time(target, &target_time);

        if (ODD(sts) && time_Acomp(&source_time, &target_time) != 1)
          update = 0;
        else
          update = 1;

        ExpWDir* dir = dir_find(line_item[1]);
        if (!dir) {
          printf("File corrupt " pwr_cNameDistribute);
          continue;
        }

        dir->copy_insert(source, target, conversion, update);
        if (update)
          dir->update = 1;
      }

      dcli_search_file(line_item[1], found_file, DCLI_DIR_SEARCH_END);

      ItemExp* item = new ItemExp(
          this, found_file, line_item[1], 0, 0, flow_eDest_IntoLast);
      if (dir_update)
        brow_SetRadiobutton(item->node, 0, 1);

    } else if (streq(cdh_Low(line_item[0]), "buildmake")) {
      if (num != 4) {
        printf("File corrupt " pwr_cNameDistribute);
        continue;
      }

      ExpWDir* dir = dir_find(line_item[1]);
      if (!dir) {
        printf("File corrupt " pwr_cNameDistribute);
        continue;
      }

      dir->make_insert(line_item[2], line_item[3], 1);
      dir->update = 1;
    } else if (streq(cdh_Low(line_item[0]), "buildexec")) {
      if (num != 4) {
        printf("File corrupt " pwr_cNameDistribute);
        continue;
      }

      ExpWDir* dir = dir_find(line_item[1]);
      if (!dir) {
        printf("File corrupt " pwr_cNameDistribute);
        continue;
      }

      dir->exec_insert(line_item[2], line_item[3], 1);
      dir->update = 1;
    }
  }

  is.close();

  redraw(0);
}

void WbExpWNav::set_show_all(int set)
{
  show_all = set;
  switch (type) {
  case expw_eType_Export:
  case expw_eType_Import:
    show();
    break;
  case expw_eType_BuildDirectories:
    redraw(!show_all);
    break;
  }
}

void WbExpWNav::redraw(int posit_top)
{
  ItemDir* first_item = 0;

  brow_SetNodraw(brow->ctx);
  brow_DeleteAll(brow->ctx);

  for (ExpWDir* dir = dirlist; dir; dir = dir->next) {
    ItemDir* item = new ItemDir(
        this, dir, dir->name, dir->description, 0, flow_eDest_IntoLast);
    if (dir->update)
      brow_SetRadiobutton(item->node, 0, 1);
    if (dir->open)
      item->open_children();
    if (!first_item)
      first_item = item;
  }

  if (first_item && posit_top)
    brow_CenterObject(brow->ctx, first_item->node, 0);

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
}

ExpWDir* WbExpWNav::dir_find(char* name)
{
  for (ExpWDir* dir = dirlist; dir; dir = dir->next) {
    if (streq(dir->name, name))
      return dir;
  }
  return 0;
}

void WbExpWNav::list_free()
{
  ExpWDir* dp_next;
  for (ExpWDir* dp = dirlist; dp; dp = dp_next) {
    ExpWCopy* cp_next;
    for (ExpWCopy* cp = dp->copylist; cp; cp = cp_next) {
      cp_next = cp->next;
      delete cp;
    }
    ExpWMake* mp_next;
    for (ExpWMake* mp = dp->makelist; mp; mp = mp_next) {
      mp_next = mp->next;
      delete mp;
    }
    ExpWExec* ep_next;
    for (ExpWExec* ep = dp->execlist; ep; ep = ep_next) {
      ep_next = ep->next;
      delete ep;
    }
    dp_next = dp->next;
    delete dp;
  }
  dirlist = 0;
}

ExpWDir* WbExpWNav::dir_insert(char* name, char* options_str, char* description)
{
  int num;

  ExpWDir* dir = new ExpWDir();
  strncpy(dir->name, name, sizeof(dir->name));
  num = sscanf(options_str, "%d", &dir->options);
  if (num != 1) {
    printf("** BuildDirectory.Options syntax error\n");
    dir->options = 0;
  }
  strncpy(dir->description, description, sizeof(dir->description));

  if (!dirlist)
    dirlist = dir;
  else {
    ExpWDir* dp;
    for (dp = dirlist; dp->next; dp = dp->next)
      ;
    dp->next = dir;
  }
  return dir;
}

ExpWCopy* ExpWDir::copy_insert(char* source, char* target, pwr_tFileConvertEnum conversion, 
			       int update)
{
  ExpWCopy* copy = new ExpWCopy();
  strncpy(copy->source, source, sizeof(copy->source));
  strncpy(copy->target, target, sizeof(copy->target));
  copy->conversion = conversion;
  copy->update = update;

  if (!copylist)
    copylist = copy;
  else {
    ExpWCopy* cp;
    for (cp = copylist; cp->next; cp = cp->next)
      ;
    cp->next = copy;
  }
  return copy;
}

ExpWMake* ExpWDir::make_insert(char* dir, char* makefile, int update)
{
  ExpWMake* make = new ExpWMake();
  strncpy(make->dir, dir, sizeof(make->dir));
  strncpy(make->makefile, makefile, sizeof(make->makefile));
  make->update = update;

  if (!makelist)
    makelist = make;
  else {
    ExpWMake* ep;
    for (ep = makelist; ep->next; ep = ep->next)
      ;
    ep->next = make;
  }
  return make;
}

ExpWExec* ExpWDir::exec_insert(char* dir, char* command, int update)
{
  ExpWExec* exec = new ExpWExec();
  strncpy(exec->dir, dir, sizeof(exec->dir));
  strncpy(exec->command, command, sizeof(exec->command));
  exec->update = update;

  if (!execlist)
    execlist = exec;
  else {
    ExpWExec* ep;
    for (ep = execlist; ep->next; ep = ep->next)
      ;
    ep->next = exec;
  }
  return exec;
}

void WbExpWNav::clear()
{
  brow_DeleteAll(brow->ctx);
}

pwr_tStatus WbExpWNav::exp()
{
  int sts;
  ItemExp* item;
  char cmd[660];
  brow_tNode node;
  int rval;

  switch (type) {
  case expw_eType_Import:
  case expw_eType_Export: {
    for (sts = brow_GetFirst(brow->ctx, &node); ODD(sts);
         sts = brow_GetNext(brow->ctx, node, &node)) {
      brow_GetRadiobutton(node, 0, &rval);

      if (rval) {
        brow_GetUserData(node, (void**)&item);

        sprintf(cmd, "cp %s %s", item->source, item->target);
        printf("%s\n", cmd);
        sts = system(cmd);
        if (sts != 0) {
          char msg[690];
          snprintf(
              msg, sizeof(msg), "Export error %d, %s", WEXITSTATUS(sts), cmd);
          MsgWindow::message('E', msg, msgw_ePop_Default);
        }
      }
    }

    show();
    break;
  }
  case expw_eType_BuildDirectories: {
    for (ExpWDir* dp = dirlist; dp; dp = dp->next) {
      if (!dp->update)
        continue;

      for (ExpWCopy* cp = dp->copylist; cp; cp = cp->next) {
        if (!cp->update)
          continue;

	switch (cp->conversion) {
	case pwr_eFileConvertEnum_No:
	  sprintf(cmd, "cp %s %s", cp->source, cp->target);
	  printf("%s\n", cmd);
	  break;
	case pwr_eFileConvertEnum_ISO88591_UTF8:
	  sprintf(cmd, "iconv -f ISO-8859-1 -t UTF8 < %s > %s", cp->source, cp->target);
	  printf("%s\n", cmd);
	  break;
	}
        sts = system(cmd);
        if (sts != 0) {
          // Check that directory exist, create if it doesn't
          pwr_tFileName target_dir;
          pwr_tTime target_time;
          char* s;

          strcpy(target_dir, cp->target);
          if ((s = strrchr(target_dir, '/'))) {
            *s = 0;
            sts = dcli_file_time(target_dir, &target_time);
            if (EVEN(sts)) {
              sprintf(cmd, "mkdir -p %s", target_dir);
              system(cmd);

              sprintf(cmd, "cp %s %s", cp->source, cp->target);
              printf("%s\n", cmd);
              sts = system(cmd);
            }
          }
          if (sts != 0) {
            char msg[690];
            snprintf(
                msg, sizeof(msg), "Build error %d, %s", WEXITSTATUS(sts), cmd);
            MsgWindow::message('E', msg, msgw_ePop_Default);
          }
        }
      }
    }

    for (ExpWDir* dp = dirlist; dp; dp = dp->next) {
      if (!dp->update)
        continue;

      for (ExpWMake* mp = dp->makelist; mp; mp = mp->next) {
        if (!mp->update)
          continue;

        if (streq(mp->makefile, ""))
          sprintf(cmd, "cd %s;make", mp->dir);
        else
          sprintf(cmd, "cd %s;make -f %s", mp->dir, mp->makefile);
        printf("%s\n", cmd);
        sts = system(cmd);
        if (sts != 0) {
          char msg[690];
          snprintf(
              msg, sizeof(msg), "Build error %d, %s", WEXITSTATUS(sts), cmd);
          MsgWindow::message('E', msg, msgw_ePop_Default);
        }
      }
      for (ExpWExec* ep = dp->execlist; ep; ep = ep->next) {
        if (!ep->update)
          continue;

        sprintf(cmd, "cd %s;%s", ep->dir, ep->command);
        printf("%s\n", cmd);
        sts = system(cmd);
        if (sts != 0) {
          char msg[690];
          snprintf(
              msg, sizeof(msg), "Build error %d, %s", WEXITSTATUS(sts), cmd);
          MsgWindow::message('E', msg, msgw_ePop_Default);
        }
      }
    }

    show();

    break;
  }
  }

  return LDH__SUCCESS;
}

void WbExpWNav::check_all()
{
  switch (type) {
  case expw_eType_Import:
  case expw_eType_Export: {
    int sts;
    brow_tNode node;

    for (sts = brow_GetFirst(brow->ctx, &node); ODD(sts);
         sts = brow_GetNext(brow->ctx, node, &node))
      brow_SetRadiobutton(node, 0, 1);
    break;
  }
  case expw_eType_BuildDirectories: {
    for (ExpWDir* dir = dirlist; dir; dir = dir->next) {
      dir->update = 1;
      for (ExpWCopy* cp = dir->copylist; cp; cp = cp->next)
        cp->update = 1;
      for (ExpWMake* mp = dir->makelist; mp; mp = mp->next)
        mp->update = 1;
      for (ExpWExec* ep = dir->execlist; ep; ep = ep->next)
        ep->update = 1;
    }
    redraw(0);
    break;
  }
  default:;
  }
}

void WbExpWNav::check_clear()
{
  switch (type) {
  case expw_eType_Import:
  case expw_eType_Export: {
    int sts;
    brow_tNode node;

    for (sts = brow_GetFirst(brow->ctx, &node); ODD(sts);
         sts = brow_GetNext(brow->ctx, node, &node))
      brow_SetRadiobutton(node, 0, 0);
    break;
  }
  case expw_eType_BuildDirectories: {
    for (ExpWDir* dir = dirlist; dir; dir = dir->next) {
      dir->update = 0;
      for (ExpWCopy* cp = dir->copylist; cp; cp = cp->next)
        cp->update = 0;
      for (ExpWMake* mp = dir->makelist; mp; mp = mp->next)
        mp->update = 0;
      for (ExpWExec* ep = dir->execlist; ep; ep = ep->next)
        ep->update = 0;
    }
    redraw(0);
    break;
  }
  default:;
  }
}

void WbExpWNav::check_reset()
{
  show();
}

ItemExp::ItemExp(WbExpWNav* item_expwnav, char* item_source, char* item_target,
    ExpWList* item_listp, brow_tNode dest, flow_eDest dest_code)
    : expwnav(item_expwnav), button_value(0), listp(item_listp)
{
  type = expwitem_eItemType_Exp;
  strncpy(source, item_source, sizeof(source));
  strncpy(target, item_target, sizeof(target));

  if (expwnav->editmode)
    brow_CreateNode(expwnav->brow->ctx, (char*)"Exp", expwnav->brow->nc_eexp,
        dest, dest_code, (void*)this, 1, &node);
  else
    brow_CreateNode(expwnav->brow->ctx, (char*)"Exp", expwnav->brow->nc_exp,
        dest, dest_code, (void*)this, 1, &node);

  int annot = 0;
  brow_SetAnnotation(node, annot++, source, strlen(source));
  brow_SetAnnotation(node, annot++, target, strlen(target));

  brow_SetAnnotPixmap(node, 0, expwnav->brow->pixmap_export);
}

ItemExp::~ItemExp()
{
}

void ItemExp::update()
{
  if (button_value)
    brow_SetAnnotation(node, 1, "1", 1);
  else
    brow_SetAnnotation(node, 1, "0", 1);
}

void ItemExp::set(int value)
{
  button_value = value;
  brow_SetRadiobutton(node, 0, value);
  if (listp)
    listp->update = value;
}

ItemDir::ItemDir(WbExpWNav* item_expwnav, ExpWDir* item_dir, char* item_name,
    char* item_description, brow_tNode dest, flow_eDest dest_code)
    : expwnav(item_expwnav), dir(item_dir), button_value(0)
{
  type = expwitem_eItemType_Dir;
  strncpy(name, item_name, sizeof(name));
  strncpy(description, item_description, sizeof(description));

  if (expwnav->editmode)
    brow_CreateNode(expwnav->brow->ctx, (char*)"Dir", expwnav->brow->nc_eexp,
        dest, dest_code, (void*)this, 1, &node);
  else
    brow_CreateNode(expwnav->brow->ctx, (char*)"Dir", expwnav->brow->nc_exp,
        dest, dest_code, (void*)this, 1, &node);

  int annot = 0;
  brow_SetAnnotation(node, annot++, name, strlen(name));
  brow_SetAnnotation(node, annot++, description, strlen(description));

  // Check if map or leaf
  int child_exist = 0;
  if (expwnav->show_all) {
    if (dir->copylist || dir->execlist || dir->makelist)
      child_exist = 1;
  } else {
    if (dir->execlist || dir->makelist)
      child_exist = 1;
    else {
      for (ExpWCopy* cp = dir->copylist; cp; cp = cp->next) {
        if (cp->update) {
          child_exist = 1;
          break;
        }
      }
    }
  }
  if (child_exist)
    brow_SetAnnotPixmap(node, 0, expwnav->brow->pixmap_map);
  else
    brow_SetAnnotPixmap(node, 0, expwnav->brow->pixmap_leaf);
}

ItemDir::~ItemDir()
{
}

void ItemDir::update()
{
  if (button_value)
    brow_SetAnnotation(node, 1, "1", 1);
  else
    brow_SetAnnotation(node, 1, "0", 1);
}

void ItemDir::set(int value)
{
  button_value = value;
  brow_SetRadiobutton(node, 0, value);
  dir->update = value;
}

int ItemDir::open_children()
{
  int child_exist = 0;

  if (brow_IsOpen(node)) {
    // Close
    brow_SetNodraw(expwnav->brow->ctx);
    brow_CloseNode(expwnav->brow->ctx, node);
    if (brow_IsOpen(node) & expw_mOpen_Children)
      brow_SetAnnotPixmap(node, 0, expwnav->brow->pixmap_map);
    brow_ResetOpen(node, expw_mOpen_All);
    brow_ResetNodraw(expwnav->brow->ctx);
    brow_Redraw(expwnav->brow->ctx, 0);
    dir->open = 0;
  } else {
    // Create some children
    brow_SetNodraw(expwnav->brow->ctx);

    for (ExpWMake* mp = dir->makelist; mp; mp = mp->next) {
      pwr_tCmd cmd;
      sprintf(cmd, "make %s", mp->makefile);
      ItemExp* item
          = new ItemExp(expwnav, mp->dir, cmd, mp, node, flow_eDest_IntoLast);
      if (mp->update)
        brow_SetRadiobutton(item->node, 0, 1);
      child_exist = 1;
    }
    for (ExpWExec* ep = dir->execlist; ep; ep = ep->next) {
      ItemExp* item = new ItemExp(
          expwnav, ep->dir, ep->command, ep, node, flow_eDest_IntoLast);
      if (ep->update)
        brow_SetRadiobutton(item->node, 0, 1);
      child_exist = 1;
    }
    for (ExpWCopy* cp = dir->copylist; cp; cp = cp->next) {
      if (!expwnav->show_all && !cp->update)
        continue;

      ItemExp* item = new ItemExp(
          expwnav, cp->source, cp->target, cp, node, flow_eDest_IntoLast);
      if (cp->update)
        brow_SetRadiobutton(item->node, 0, 1);
      child_exist = 1;
    }

    if (child_exist) {
      brow_SetOpen(node, expw_mOpen_Children);
      brow_SetAnnotPixmap(node, 0, expwnav->brow->pixmap_openmap);
      dir->open = 1;
    }
    brow_ResetNodraw(expwnav->brow->ctx);
    if (child_exist)
      brow_Redraw(expwnav->brow->ctx, 0);
    else
      return 0;
  }
  return 1;
}

int ItemDir::close()
{
  if (brow_IsOpen(node)) {
    // Close
    brow_SetNodraw(expwnav->brow->ctx);
    brow_CloseNode(expwnav->brow->ctx, node);
    if (brow_IsOpen(node) & expw_mOpen_Children)
      brow_SetAnnotPixmap(node, 0, expwnav->brow->pixmap_map);
    brow_ResetOpen(node, expw_mOpen_All);
    brow_ResetNodraw(expwnav->brow->ctx);
    brow_Redraw(expwnav->brow->ctx, 0);
    dir->open = 0;
  }
  return 1;
}
