/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <stdlib.h>

#include "pwr_baseclasses.h"

#include "co_string.h"
#include "co_time.h"

#include "rt_bckdef.h"
#include "rt_gdh.h"

#include "wb_bck.h"
#include "wb_ldh_msg.h"

wb_bck_list::~wb_bck_list()
{
  bck_sItem* ip;
  bck_sItem* next = m_first;
  while (next) {
    ip = next;
    next = ip->next;
    free(ip->valuep);
    free(ip);
  }
}

void wb_bck_list::add(pwr_tAttrRef* arp, void* value, unsigned int size)
{
  bck_sItem* ip = (bck_sItem*)malloc(sizeof(bck_sItem));
  ip->aref = *arp;
  ip->size = size;
  ip->valuep = malloc(size);
  memcpy(ip->valuep, value, size);
  ip->value2p = 0;
  ip->hide = 0;
  ip->next = 0;

  if (!m_first)
    m_first = ip;
  else
    m_last->next = ip;
  m_last = ip;
}

void wb_bck_list::add(bck_sItem* xp, void* value2)
{
  bck_sItem* ip = (bck_sItem*)malloc(sizeof(bck_sItem));
  ip->aref = xp->aref;
  ip->size = xp->size;
  ip->valuep = malloc(ip->size);
  memcpy(ip->valuep, xp->valuep, ip->size);
  if (value2) {
    ip->value2p = malloc(ip->size);
    memcpy(ip->value2p, value2, ip->size);
  } else
    ip->value2p = 0;
  ip->hide = 0;
  ip->next = 0;

  if (!m_first)
    m_first = ip;
  else
    m_last->next = ip;
  m_last = ip;
}

pwr_tStatus wb_bck_list::print(char* outfile)
{
  pwr_tFileName fname;
  FILE* fout;
  pwr_tStatus sts;

  dcli_translate_filename(fname, outfile);
  fout = fopen(fname, "w");
  if (!fout)
    return LDH__NOSUCHFILE;

  bck_sItem* ip = m_first;
  while (ip) {
    char str[1024];
    pwr_eType atype;
    int printed = 0;
    char* anamep;
    int size;

    sts = ldh_AttrRefToName(
        m_ldhses, &ip->aref, cdh_mName_volumeStrict, &anamep, &size);
    if (EVEN(sts)) {
      fclose(fout);
      return sts;
    }

    fprintf(fout, "%s", anamep);

    sts = ldh_GetAttrRefType(m_ldhses, &ip->aref, &atype);
    if (ODD(sts)) {
      sts = cdh_AttrValueToString(atype, ip->valuep, str, sizeof(str));
      if (ODD(sts)) {
        fprintf(fout, "\n	%s\n", str);
        printed = 1;
      }
    }

    if (!printed) {
      // Print as hex code
      unsigned char* p = (unsigned char*)ip->valuep;
      for (int i = 0; i < (int)ip->size; i++, p++) {
        if ((i % 16) == 0)
          fprintf(fout, "\n	");
        fprintf(fout, "%02x ", *p);
      }
      fprintf(fout, "\n");
    }
    ip = ip->next;
  }
  fclose(fout);

  return LDH__SUCCESS;
}

pwr_tStatus wb_bck_list::read_db(wb_bck_list* lp)
{
  pwr_eType atype;
  char* anamep;
  int size;
  void* valuep = NULL;
  pwr_tAName aname;
  pwr_tAttrRef aref;
  pwr_tCid cid;
  char* s;
  pwr_tStatus sts;

  m_type = bck_eType_Wb;

  bck_sItem* ip = lp->m_first;
  while (ip) {
    sts = ldh_AttrRefToName(
        m_ldhses, &ip->aref, cdh_mName_volumeStrict, &anamep, &size);
    if (EVEN(sts))
      return sts;

    sts = ldh_GetAttrRefType(m_ldhses, &ip->aref, &atype);
    if (ODD(sts)) {
      // Read value from database

      strncpy(aname, anamep, sizeof(aname));
      if ((s = strrchr(aname, '.')) && streq(s, ".ActualValue")) {
        *s = 0;

        sts = ldh_NameToAttrRef(m_ldhses, aname, &aref);
        if (EVEN(sts))
          return sts;

        sts = ldh_GetAttrRefTid(m_ldhses, &aref, &cid);
        if (EVEN(sts))
          return sts;

        switch (cid) {
        case pwr_cClass_Ao:
        case pwr_cClass_Do:
        case pwr_cClass_Io:
        case pwr_cClass_Av:
        case pwr_cClass_Dv:
        case pwr_cClass_Iv:
          // Read InitValue instead of ActualValue
          strcat(aname, ".InitialValue");
          sts = ldh_NameToAttrRef(m_ldhses, aname, &aref);
          if (EVEN(sts))
            return sts;

          valuep = malloc(ip->size);
          sts = ldh_ReadAttribute(m_ldhses, &aref, valuep, ip->size);

          break;
        default:
          valuep = malloc(ip->size);
          sts = ldh_ReadAttribute(m_ldhses, &ip->aref, valuep, ip->size);
        }
      } else {
        valuep = malloc(ip->size);
        sts = ldh_ReadAttribute(m_ldhses, &ip->aref, valuep, ip->size);
      }
    }

    add(&ip->aref, valuep, ip->size);

    free(valuep);
    ip = ip->next;
  }
  return LDH__SUCCESS;
}

pwr_tStatus wb_bck_list::diff(wb_bck_list* lp, char* outfile)
{
  pwr_tFileName fname;
  FILE* fout;
  pwr_tStatus sts;
  int diff_cnt = 0;

  dcli_translate_filename(fname, outfile);
  fout = fopen(fname, "w");
  if (!fout)
    return LDH__NOSUCHFILE;

  if (lp)
    fprintf(
        fout, "Backup difference: 1: %s, 2: %s\n", m_filename, lp->m_filename);
  else
    fprintf(fout, "Backup difference: 1: %s, 2: Workbench\n", m_filename);

  bck_sItem* ip = m_first;
  while (ip) {
    char str[1024];
    char str2[1024];
    pwr_eType atype;
    char* anamep;
    int size;

    sts = ldh_AttrRefToName(
        m_ldhses, &ip->aref, cdh_mName_volumeStrict, &anamep, &size);
    if (EVEN(sts)) {
      fclose(fout);
      return sts;
    }

    sts = ldh_GetAttrRefType(m_ldhses, &ip->aref, &atype);
    if (ODD(sts)) {
      void* value2p;

      bck_sItem* ip2 = lp->find(&ip->aref);
      if (ip2) {
        value2p = ip2->valuep;

        int is_equal = 0;
        switch (atype) {
        case pwr_eType_String:
        case pwr_eType_Text:
          is_equal
              = streq((const char*)value2p, (const char*)ip->valuep) ? 1 : 0;
          break;
        default:
          is_equal = memcmp(value2p, ip->valuep, ip->size) == 0 ? 1 : 0;
        }
        if (is_equal) {
          ip = ip->next;
          continue;
        }

        sts = cdh_AttrValueToString(atype, value2p, str2, sizeof(str2));
        if (EVEN(sts))
          strcpy(str2, "-");
      } else
        strcpy(str2, "-");

      sts = cdh_AttrValueToString(atype, ip->valuep, str, sizeof(str));
      if (EVEN(sts))
        strcpy(str, "-");

      fprintf(fout, "%s\n", anamep);
      fprintf(fout, "1>	%s\n", str);
      fprintf(fout, "2>	%s\n", str2);
      diff_cnt++;
    }

    ip = ip->next;
  }
  if (diff_cnt)
    fprintf(fout, "%d differences found\n", diff_cnt);
  else
    fprintf(fout, "No differences found\n");

  fclose(fout);

  return LDH__SUCCESS;
}

pwr_tStatus wb_bck_list::diff(wb_bck_list* lp, wb_bck_list* outlp)
{
  pwr_tStatus sts;
  int diff_cnt = 0;

  if (lp->m_type == bck_eType_Wb)
    outlp->m_type = bck_eType_WbDiff;
  else
    outlp->m_type = bck_eType_FileDiff;

  bck_sItem* ip = m_first;
  while (ip) {
    pwr_eType atype;
    char* anamep;
    int size;

    sts = ldh_AttrRefToName(
        m_ldhses, &ip->aref, cdh_mName_volumeStrict, &anamep, &size);
    if (EVEN(sts))
      return sts;

    sts = ldh_GetAttrRefType(m_ldhses, &ip->aref, &atype);
    if (ODD(sts)) {
      void* value2p;

      bck_sItem* ip2 = lp->find(&ip->aref);
      if (ip2) {
        value2p = ip2->valuep;

        int is_equal = 0;
        switch (atype) {
        case pwr_eType_String:
        case pwr_eType_Text:
          is_equal
              = streq((const char*)value2p, (const char*)ip->valuep) ? 1 : 0;
          break;
        default:
          is_equal = memcmp(value2p, ip->valuep, ip->size) == 0 ? 1 : 0;
        }
        if (is_equal) {
          ip = ip->next;
          continue;
        }
      } else
        value2p = 0;

      outlp->add(ip, value2p);
      diff_cnt++;
    }

    ip = ip->next;
  }

  return LDH__SUCCESS;
}

bck_sItem* wb_bck_list::find(pwr_tAttrRef* arp)
{
  for (bck_sItem* ip = m_first; ip; ip = ip->next) {
    if (cdh_ObjidIsEqual(arp->Objid, ip->aref.Objid)
        && arp->Offset == ip->aref.Offset && arp->Size == ip->aref.Size) {
      return ip;
    }
  }
  return 0;
}

pwr_tStatus wb_bck_list::read()
{
  FILE* f;
  BCK_FILEHEAD_STRUCT fh;
  bck_t_cycleheader ch;
  bck_t_writeheader dh;
  int c, d;
  unsigned char* datap = NULL;
  pwr_tStatus sts;
  int csts;
  char* namep = NULL;
  pwr_tAName aname;
  int size;

  m_type = bck_eType_File;

  // Open file

  f = fopen(m_filename, "rb");
  if (!f)
    return LDH__FILEOPEN;

  // Read header

  fseek(f, 0, 0);
  fread(&fh, sizeof fh, 1, f);
  if (fh.version != BCK_FILE_VERSION) {
    printf("This program is built with header version %d\n", BCK_FILE_VERSION);
    fclose(f);
    return LDH__BCKVERSION;
  }

  for (c = 0; c < 2; c++) {
    fseek(f, fh.curdata[c], 0);
    fread(&ch, sizeof ch, 1, f);

    /* Work thru the data segments */

    for (d = 0; d < (int)ch.segments; d++) {
      csts = fread(&dh, sizeof dh, 1, f);
      if (csts != 0) {
        if (dh.namesize > 0) {
          namep = (char*)malloc(dh.namesize + 1);
          csts = fread(namep, dh.namesize + 1, 1, f);
        } else
          namep = NULL;
        datap = (unsigned char*)malloc(dh.size);
        csts = fread(datap, dh.size, 1, f);
      }
      if (csts == 0) {
        printf("** Read error\n");
        break;
      }

      if (dh.valid) {
        sts = ldh_ObjidToName(m_ldhses, dh.objid, cdh_mName_volumeStrict, aname,
            sizeof(aname), &size);
        if (EVEN(sts)) {
          printf("** Error, %s%s not found in this environment",
              cdh_ObjidToString(dh.objid, 1), aname);
        } else {
          strncat(aname, namep, sizeof(aname) - strlen(aname) - 1);

          pwr_tAttrRef aref;
          sts = ldh_NameToAttrRef(m_ldhses, aname, &aref);
          if (EVEN(sts))
            printf("**Error, %s, no such attribute\n", aname);
          else
            add(&aref, datap, dh.size);
        }
      }
      free(datap);
      free(namep);
    }
  }

  fclose(f);

  return LDH__SUCCESS;
}

pwr_tStatus bck_dump(ldh_tSession ldhses, char* filename, char* out)
{
  pwr_tFileName fname;
  FILE *f, *fout;
  BCK_FILEHEAD_STRUCT fh;
  bck_t_cycleheader ch;
  bck_t_writeheader dh;
  char timstr[24];
  int c, d;
  unsigned char *datap = NULL, *p;
  int i;
  pwr_tStatus sts;
  int csts;
  char* namep = NULL;
  pwr_tAName aname;
  int size;

  // Open file

  dcli_translate_filename(fname, filename);
  f = fopen(fname, "rb");
  if (!f)
    return LDH__NOSUCHFILE;

  dcli_translate_filename(fname, out);
  fout = fopen(fname, "w");
  if (!fout) {
    fclose(f);
    return LDH__NOSUCHFILE;
  }

  // Read header and print it

  fseek(f, 0, 0);
  fread(&fh, sizeof fh, 1, f);
  fprintf(fout, "Layout version:       %d\n", fh.version);
  if (fh.version != BCK_FILE_VERSION) {
    printf("This program is built with header version %d\n", BCK_FILE_VERSION);
    fclose(f);
    fclose(fout);
    return LDH__BCKVERSION;
  }

  time_AtoAscii(
      &fh.creationtime, time_eFormat_DateAndTime, timstr, sizeof(timstr));

  fprintf(fout, "Created:              %s\n", timstr);

  for (c = 0; c < 2; c++) {
    fseek(f, fh.curdata[c], 0);
    fread(&ch, sizeof ch, 1, f);

    /* Work thru the data segments */

    for (d = 0; d < (int)ch.segments; d++) {
      csts = fread(&dh, sizeof dh, 1, f);
      if (csts != 0) {
        if (dh.namesize > 0) {
          namep = (char*)malloc(dh.namesize + 1);
          csts = fread(namep, dh.namesize + 1, 1, f);
        } else
          namep = NULL;
        datap = (unsigned char*)malloc(dh.size);
        csts = fread(datap, dh.size, 1, f);
      }
      if (csts == 0) {
        fprintf(fout, "Read error\n");
        break;
      }

      if (dh.valid) {
        sts = ldh_ObjidToName(ldhses, dh.objid, cdh_mName_volumeStrict, aname,
            sizeof(aname), &size);
        if (EVEN(sts))
          strcpy(aname, cdh_ObjidToString(dh.objid, 1));
        strncat(aname, namep, sizeof(aname) - strlen(aname) - 1);

        fprintf(fout, "%s", aname);

        char str[1024];
        pwr_tAttrRef aref;
        pwr_eType atype;
        int printed = 0;
        sts = ldh_NameToAttrRef(ldhses, aname, &aref);
        if (ODD(sts)) {
          sts = ldh_GetAttrRefType(ldhses, &aref, &atype);
          if (ODD(sts)) {
            sts = cdh_AttrValueToString(atype, datap, str, sizeof(str));
            if (ODD(sts)) {
              fprintf(fout, "\n	%s\n", str);
              printed = 1;
            }
          }
        }

        if (!printed) {
          // Print as hex code
          p = datap;
          for (i = 0; i < (int)dh.size; i++, p++) {
            if ((i % 16) == 0)
              fprintf(fout, "\n	");
            fprintf(fout, "%02x ", *p);
          }
          fprintf(fout, "\n");
        }
      }

      free(datap);
      free(namep);
    }
  }

  fclose(f);
  fclose(fout);

  return LDH__SUCCESS;
}
