/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2013 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "pwr.h"
#include "pwr_class.h"
#include "pwr_baseclasses.h"
#include "co_dcli.h"
#include "co_time.h"
#include "rt_gdh.h"
#include "rt_bckdef.h"
#include "wb_ldh.h"
#include "wb_bck.h"
#include "wb_ldh_msg.h"


wb_bck_list::~wb_bck_list() 
{
  bck_sItem *ip;
  bck_sItem *next = m_first;
  while ( next) {
    ip = next;
    next = ip->next;
    free( ip->valuep);
    free( ip);
  }
}

void wb_bck_list::add( pwr_tAttrRef *arp, void *value, unsigned int size) 
{
  bck_sItem *ip = (bck_sItem *)malloc( sizeof(bck_sItem));
  ip->aref = *arp;
  ip->size = size;
  ip->valuep = malloc(size);
  memcpy( ip->valuep, value, size);
  ip->value2p = 0;
  ip->hide = 0;
  ip->next = 0;
  
  if ( !m_first)
    m_first = ip;      
  else
    m_last->next = ip;
  m_last = ip;    
}

void wb_bck_list::add( bck_sItem *xp, void *value2) 
{
  bck_sItem *ip = (bck_sItem *)malloc( sizeof(bck_sItem));
  ip->aref = xp->aref;
  ip->size = xp->size;
  ip->valuep = malloc(ip->size);
  memcpy( ip->valuep, xp->valuep, ip->size);
  if ( value2) {
    ip->value2p = malloc(ip->size);
    memcpy( ip->value2p, value2, ip->size);
  }
  else
    ip->value2p = 0;
  ip->hide = 0;
  ip->next = 0;
  
  if ( !m_first)
    m_first = ip;      
  else
    m_last->next = ip;
  m_last = ip;    
}

pwr_tStatus wb_bck_list::print( char *outfile)
{
  pwr_tFileName fname;
  FILE *fout;
  pwr_tStatus sts;

  dcli_translate_filename( fname, outfile);
  fout = fopen( fname, "w");
  if ( !fout)
    return LDH__NOSUCHFILE;

  bck_sItem *ip = m_first;
  while (ip) {
    char str[1024];
    pwr_eType atype;
    int printed = 0;
    char *anamep;
    int size;

    sts = ldh_AttrRefToName( m_ldhses, &ip->aref, cdh_mName_volumeStrict, &anamep, &size);
    if ( EVEN(sts)) return sts;

    fprintf( fout, "%s", anamep);

    sts = ldh_GetAttrRefType( m_ldhses, &ip->aref, &atype);
    if ( ODD(sts)) {
      sts = cdh_AttrValueToString( atype, ip->valuep, str, sizeof(str));
      if ( ODD(sts)) {
	fprintf( fout, "\n	%s\n", str);
	printed = 1;
      }
    }
    
    if ( !printed) {
      // Print as hex code
      unsigned char *p = (unsigned char *)ip->valuep;
      for ( int i = 0; i < (int)ip->size; i++, p++) {
	if ((i % 16) == 0) fprintf( fout, "\n	");
	fprintf( fout, "%02x ", *p);
      }
      fprintf( fout, "\n");
    }
    ip = ip->next;
  }
  fclose( fout);

  return LDH__SUCCESS;
}

pwr_tStatus wb_bck_list::read_db( wb_bck_list *lp)
{
  pwr_eType atype;
  char *anamep;
  int size;
  void *valuep;
  pwr_tAName aname;
  pwr_tAttrRef aref;
  pwr_tCid cid;
  char *s;
  pwr_tStatus sts;

  m_type = bck_eType_Wb;

  bck_sItem *ip = lp->m_first;
  while (ip) {

    sts = ldh_AttrRefToName( m_ldhses, &ip->aref, cdh_mName_volumeStrict, &anamep, &size);
    if ( EVEN(sts)) return sts;

    sts = ldh_GetAttrRefType( m_ldhses, &ip->aref, &atype);
    if ( ODD(sts)) {
      // Read value from database

      strncpy( aname, anamep, sizeof(aname));
      if ( (s = strrchr( aname, '.')) && strcmp( s, ".ActualValue") == 0) {
	*s = 0;

	sts = ldh_NameToAttrRef( m_ldhses, aname, &aref);
	if ( EVEN(sts)) return sts;

	sts = ldh_GetAttrRefTid( m_ldhses, &aref, &cid);
	if ( EVEN(sts)) return sts;
	
	switch ( cid) {
	case pwr_cClass_Ao:
	case pwr_cClass_Do:
	case pwr_cClass_Io:
	case pwr_cClass_Av:
	case pwr_cClass_Dv:
	case pwr_cClass_Iv:
	  // Read InitValue instead of ActualValue
	  strcat( aname, ".InitialValue");
	  sts = ldh_NameToAttrRef( m_ldhses, aname, &aref);
	  if ( EVEN(sts)) return sts;
	  
	  valuep = malloc(ip->size);
	  sts = ldh_ReadAttribute( m_ldhses, &aref, valuep, ip->size);
	  
	  break;	
	default:
	  valuep = malloc(ip->size);
	  sts = ldh_ReadAttribute( m_ldhses, &ip->aref, valuep, ip->size);	  
	}
      }
      else {
	valuep = malloc(ip->size);
	sts = ldh_ReadAttribute( m_ldhses, &ip->aref, valuep, ip->size);	  
      }
    }

    add( &ip->aref, valuep, ip->size);

    free( valuep);
    ip = ip->next;
  }
  return LDH__SUCCESS;
}

pwr_tStatus wb_bck_list::diff( wb_bck_list *lp, char *outfile)
{
  pwr_tFileName fname;
  FILE *fout;
  pwr_tStatus sts;
  int diff_cnt = 0;

  dcli_translate_filename( fname, outfile);
  fout = fopen( fname, "w");
  if ( !fout)
    return LDH__NOSUCHFILE;

  if ( lp)
    fprintf( fout, "Backup difference: 1: %s, 2: %s\n", m_filename, lp->m_filename);
  else
    fprintf( fout, "Backup difference: 1: %s, 2: Workbench\n", m_filename);


  bck_sItem *ip = m_first;
  while (ip) {
    char str[1024];
    char str2[1024];
    pwr_eType atype;
    char *anamep;
    int size;

    sts = ldh_AttrRefToName( m_ldhses, &ip->aref, cdh_mName_volumeStrict, &anamep, &size);
    if ( EVEN(sts)) return sts;

    sts = ldh_GetAttrRefType( m_ldhses, &ip->aref, &atype);
    if ( ODD(sts)) {
      void *value2p;

      bck_sItem *ip2 = lp->find( &ip->aref);
      if ( ip2) {
	value2p = ip2->valuep;

	int is_equal = 0;
	switch ( atype) {
	case pwr_eType_String:
	case pwr_eType_Text:
	  is_equal = strcmp( (const char *)value2p, (const char *)ip->valuep) == 0 ? 1 : 0;
	  break;
	default:
	  is_equal = memcmp( value2p, ip->valuep, ip->size) == 0 ? 1 : 0;
	}
	if ( is_equal) {
	  ip = ip->next;
	  continue;
	}

	sts = cdh_AttrValueToString( atype, value2p, str2, sizeof(str2));
	if ( EVEN(sts))
	  strcpy( str2, "-");
      }      
      else
	strcpy( str2, "-");

      sts = cdh_AttrValueToString( atype, ip->valuep, str, sizeof(str));
      if ( EVEN(sts))
	strcpy( str, "-");

      fprintf( fout, "%s\n", anamep);
      fprintf( fout, "1>	%s\n", str);
      fprintf( fout, "2>	%s\n", str2);
      diff_cnt++;
    }
    
    ip = ip->next;
  }
  if ( diff_cnt)
    fprintf( fout, "%d differences found\n", diff_cnt);
  else
    fprintf( fout, "No differences found\n");

  fclose( fout);

  return LDH__SUCCESS;
}

pwr_tStatus wb_bck_list::diff( wb_bck_list *lp, wb_bck_list *outlp)
{
  pwr_tStatus sts;
  int diff_cnt = 0;

  if ( lp->m_type == bck_eType_Wb)
    outlp->m_type = bck_eType_WbDiff;
  else
    outlp->m_type = bck_eType_FileDiff;

  bck_sItem *ip = m_first;
  while (ip) {
    pwr_eType atype;
    char *anamep;
    int size;

    sts = ldh_AttrRefToName( m_ldhses, &ip->aref, cdh_mName_volumeStrict, &anamep, &size);
    if ( EVEN(sts)) return sts;

    sts = ldh_GetAttrRefType( m_ldhses, &ip->aref, &atype);
    if ( ODD(sts)) {
      void *value2p;

      bck_sItem *ip2 = lp->find( &ip->aref);
      if ( ip2) {
	value2p = ip2->valuep;

	int is_equal = 0;
	switch ( atype) {
	case pwr_eType_String:
	case pwr_eType_Text:
	  is_equal = strcmp( (const char *)value2p, (const char *)ip->valuep) == 0 ? 1 : 0;
	  break;
	default:
	  is_equal = memcmp( value2p, ip->valuep, ip->size) == 0 ? 1 : 0;
	}
	if ( is_equal) {
	  ip = ip->next;
	  continue;
	}
      }      
      else
	value2p = 0;

      outlp->add( ip, value2p);
      diff_cnt++;
    }
    
    ip = ip->next;
  }

  return LDH__SUCCESS;
}

bck_sItem *wb_bck_list::find( pwr_tAttrRef *arp)
{
  for ( bck_sItem *ip = m_first; ip; ip = ip->next) {
    if ( cdh_ObjidIsEqual( arp->Objid, ip->aref.Objid) && arp->Offset == ip->aref.Offset &&
	 arp->Size == ip->aref.Size) {
      return ip;
    }
  }
  return 0;
}

pwr_tStatus wb_bck_list::read() {
  FILE *f;
  BCK_FILEHEAD_STRUCT fh;
  bck_t_cycleheader ch;
  bck_t_writeheader dh;
  int c, d;
  unsigned char *datap;
  pwr_tStatus sts;
  int csts;
  char *namep;
  pwr_tAName aname;
  int size;

  m_type = bck_eType_File;

  // Open file

  f = fopen( m_filename, "rb");
  if ( !f)
    return LDH__NOSUCHFILE;

  // Read header

  fseek (f, 0, 0);
  fread (&fh, sizeof fh, 1, f);
  if (fh.version != BCK_FILE_VERSION) {
    printf ("This program is built with header version %d\n", BCK_FILE_VERSION);
    return LDH__BCKVERSION;
  }

  for (c=0; c<2; c++) {
    fseek(f, fh.curdata [c], 0);
    fread(&ch, sizeof ch, 1, f);

    /* Work thru the data segments */

    for ( d = 0; d < (int)ch.segments; d++) {
      csts = fread(&dh, sizeof dh, 1, f);
      if (csts != 0) {
	if (dh.namesize > 0) {
	  namep = (char *)malloc(dh.namesize + 1);
	  csts = fread(namep, dh.namesize + 1, 1, f);
	} else 
	  namep = NULL;
	datap = (unsigned char *)malloc(dh.size);
	csts = fread(datap, dh.size, 1, f);
      }
      if (csts == 0) {
	printf( "** Read error\n");
	break;
      }
	  
      if (dh.valid) {
	sts = ldh_ObjidToName( m_ldhses, dh.objid, cdh_mName_volumeStrict, aname, sizeof(aname), &size);
	if ( EVEN(sts)) {
	  printf( "** Error, %s%s not found in this environment", 
		  cdh_ObjidToString(0, dh.objid, 1), aname);
	}
	else {
	  strncat( aname, namep, sizeof(aname));

	  pwr_tAttrRef aref;
	  sts = ldh_NameToAttrRef( m_ldhses, aname, &aref);
	  if ( EVEN(sts))
	    printf("**Error, %s, no such attribute\n", aname);
	  else
	    add( &aref, datap, dh.size);
	}
      }
      free(datap);
      free(namep);
    }
  }

  fclose (f);

  return LDH__SUCCESS;
}

pwr_tStatus bck_dump( ldh_tSession ldhses, char *filename, char *out)
{
  pwr_tFileName fname;
  FILE *f, *fout;
  BCK_FILEHEAD_STRUCT fh;
  bck_t_cycleheader ch;
  bck_t_writeheader dh;
  char timstr [24];
  int c, d;
  unsigned char *datap, *p;
  int i;
  pwr_tStatus sts;
  int csts;
  char *namep;
  pwr_tAName aname;
  int size;
  int dump = 0;

  // Open file

  dcli_translate_filename( fname, filename);
  f = fopen( fname, "rb");
  if ( !f)
    return LDH__NOSUCHFILE;

  dcli_translate_filename( fname, out);
  fout = fopen( fname, "w");
  if ( !fout)
    return LDH__NOSUCHFILE;

  // Read header and print it

  fseek (f, 0, 0);
  fread (&fh, sizeof fh, 1, f);
  fprintf( fout, "Layout version:       %d\n", fh.version);
  if (fh.version != BCK_FILE_VERSION) {
    printf ("This program is built with header version %d\n", BCK_FILE_VERSION);
    return LDH__BCKVERSION;
  }

  time_AtoAscii(&fh.creationtime, time_eFormat_DateAndTime, timstr, sizeof(timstr));

  fprintf( fout, "Created:              %s\n", timstr);

  for (c=0; c<2; c++) {
    fseek(f, fh.curdata [c], 0);
    fread(&ch, sizeof ch, 1, f);

    /* Work thru the data segments */

    for ( d = 0; d < (int)ch.segments; d++) {
      csts = fread(&dh, sizeof dh, 1, f);
      if (csts != 0) {
	if (dh.namesize > 0) {
	  namep = (char *)malloc(dh.namesize + 1);
	  csts = fread(namep, dh.namesize + 1, 1, f);
	} else 
	  namep = NULL;
	datap = (unsigned char *)malloc(dh.size);
	csts = fread(datap, dh.size, 1, f);
      }
      if (csts == 0) {
	fprintf( fout, "Read error\n");
	break;
      }
	  
      if (dh.valid) {
	if ( dump) {
	  fprintf( fout, "%s%s", cdh_ObjidToString(0, dh.objid, 1), namep);

	  p = datap;
	  for ( i = 0; i < (int)dh.size; i++, p++) {
	    if ((i % 16) == 0) fprintf( fout, "\n	");
	    fprintf( fout, "%02x ", *p);
	  }
	  fprintf( fout, "\n");
	}
	else {
	  sts = ldh_ObjidToName( ldhses, dh.objid, cdh_mName_volumeStrict, aname, sizeof(aname), &size);
	  if ( EVEN(sts))
	    strcpy( aname, cdh_ObjidToString(0, dh.objid, 1));
	  strncat( aname, namep, sizeof(aname));

	  fprintf( fout, "%s", aname);

	  char str[1024];
	  pwr_tAttrRef aref;
	  pwr_eType atype;
	  int printed = 0;
	  sts = ldh_NameToAttrRef( ldhses, aname, &aref);
	  if ( ODD(sts)) {
	    sts = ldh_GetAttrRefType( ldhses, &aref, &atype);
	    if ( ODD(sts)) {
	      sts = cdh_AttrValueToString( atype, datap, str, sizeof(str));
	      if ( ODD(sts)) {
		fprintf( fout, "\n	%s\n", str);
		printed = 1;
	      }
	    }
	  }

	  if ( !printed) {
	    // Print as hex code
	    p = datap;
	    for ( i = 0; i < (int)dh.size; i++, p++) {
	      if ((i % 16) == 0) fprintf( fout, "\n	");
	      fprintf( fout, "%02x ", *p);
	    }
	    fprintf( fout, "\n");
	  }
	}
      }

      free(datap);
      free(namep);
    }
  }

  fclose (f);
  fclose (fout);

  return LDH__SUCCESS;
}

