/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include "pwr_names.h"

#include "co_dcli.h"
#include "co_msg.h"
#include "co_string.h"
#include "co_syi.h"
#include "co_time.h"

#include "rt_load.h"

#include "cow_msgwindow.h"

#include "ge.h"
#include "ge_graph.h"

#include "wb_foe_msg.h"
#include "wb_pwrb_msg.h"
#include "wb_utl_api.h"
#include "wb_build.h"
#include "wb_env.h"
#include "wb_lfu.h"
#include "wb_gcg.h"
#include "wb_foe.h"
#include "wb_merep.h"
#include "wb_dblock.h"
#include "wb_revision.h"

class build_dir {
public:
  build_dir()
  {
  }
  build_dir(const build_dir& x)
  {
    strcpy(src_dir, x.src_dir);
    strcpy(dest_dir, x.dest_dir);
  }
  pwr_tFileName src_dir;
  pwr_tFileName dest_dir;
};

wb_build::wb_build(wb_session ses, WNav* wnav)
    : m_session(ses), m_wnav(wnav), m_hierarchy(pwr_cNOid)
{
}

wb_build::~wb_build()
{
}

void wb_build::classlist(pwr_tCid cid)
{
  pwr_tStatus sumsts;

  // Build all objects of specified class
  sumsts = PWRB__NOBUILT;
  for (wb_object o = m_session.object(cid); o.oddSts(); o = o.next()) {
    // Call build method for object
    switch (cid) {
    case pwr_cClass_plc:
      plcpgm(o.oid());
      break;
    case pwr_cClass_XttGraph:
      xttgraph(o.oid());
      break;
    case pwr_cClass_OpPlaceWeb:
      opplaceweb(o.oid());
      break;
    case pwr_cClass_WebBrowserConfig:
      webbrowserconfig(o.oid());
      break;
    case pwr_cClass_WebGraph:
      webgraph(o.oid());
      break;
    case pwr_cClass_AppGraph:
      appgraph(o.oid());
      break;
    case pwr_cClass_Application:
      application(o.oid());
      break;
    case pwr_cClass_PlcProcess:
      application(o.oid());
      break;
    case pwr_eClass_ClassDef:
      classdef(o.oid());
      break;
    default:
      m_sts = PWRB__NOBUILT;
    }
    if (evenSts())
      sumsts = m_sts;
    else if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT
        && m_sts != PWRB__INLIBHIER)
      sumsts = m_sts;
  }
  m_sts = sumsts;
}

void wb_build::all(int no_export, int no_classvolumes, int no_flowfiles)
{
  char fname[280];
  int rebuild = 1;
  char currentnode[80];
  pwr_tFileName db_dir = "$pwrp_db";
  int sts;
  pwr_tTime t;
  pwr_tCmd cmd;
  std::vector<lfu_volume_info> vol;
  std::vector<lfu_boot_info> bvect;
  pwr_tStatus sumsts = PWRB__NOBUILT;

  dcli_translate_filename(db_dir, db_dir);

  sts = lfu_GetVolumeCnfAll(vol);

  // Check that no volume is locked
  for (unsigned int i = 0; i < vol.size(); i++) {
    switch (vol[i].cid) {
    case pwr_eClass_RootVolume:
    case pwr_eClass_SubVolume:
    case pwr_eClass_SharedVolume:
    case pwr_eClass_ClassVolume:
    case pwr_eClass_DetachedClassVolume:
      if (vol[i].volrep == ldh_eVolRep_Dbms)
        sprintf(fname, "%s/%s.dbms.lock", db_dir, cdh_Low(vol[i].name));
      else if (vol[i].volrep == ldh_eVolRep_Wbl)
        sprintf(fname, "%s/%s.wb_load.lock", db_dir, cdh_Low(vol[i].name));
      else
        sprintf(fname, "%s/%s.db.lock", db_dir, cdh_Low(vol[i].name));

      if (ODD(dcli_file_time(fname, &t))) {
        char msg[200];
        sprintf(msg, "Build:    Volume is locked %s.", vol[i].name);
        MsgWindow::message('E', msg, msgw_ePop_Yes);
        return;
      }
      break;
    default:;
    }
  }

  printf("-- Build all\n");

  wb_log::log(wlog_eCategory_BuildAll, 0, 0);
  wb_log::push();

  if (!opt.manual)
    rebuild = 0;

  int force = opt.force;
  opt.force = 1;

  // Save directory volume
  if (((wb_session*)m_wnav->ldhses)->cid() == pwr_eClass_DirectoryVolume)
    sts = lfu_SaveDirectoryVolume(m_wnav->ldhses, m_wnav->wow, 1);

  // Import, export files and build directories
  import_files(bld_ePass_BeforeNode);
  if (evenSts())
    sumsts = m_sts;
  else if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT
      && m_sts != PWRB__INLIBHIER)
    sumsts = m_sts;

  directories(0, bld_ePass_BeforeNode);
  if (m_sts == PWRB__MAKEUPDATED) {
    rebuild = 1;
    m_sts = PWRB__SUCCESS;
  } else if (evenSts())
    sumsts = m_sts;
  else if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT
      && m_sts != PWRB__INLIBHIER)
    sumsts = m_sts;

  if (!no_export) {
    export_files(bld_ePass_BeforeNode);
    if (evenSts())
      sumsts = m_sts;
    else if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT
        && m_sts != PWRB__INLIBHIER)
      sumsts = m_sts;
  }
  opt.force = force;

  // Build class volumes
  if (!no_classvolumes) {
    for (unsigned int i = 0; i < vol.size(); i++) {
      switch (vol[i].cid) {
      case pwr_eClass_ClassVolume:
      case pwr_eClass_DetachedClassVolume:
        sprintf(cmd, "create "
                     "snapshot/file=\"$pwrp_db/%s.wb_load\"/out=\"$pwrp_load/"
                     "%s.dbs\"",
            cdh_Low(vol[i].name), cdh_Low(vol[i].name));
        m_wnav->command(cmd);
        break;
      default:;
      }
    }
  }

  if (!no_flowfiles) {
    for (unsigned int i = 0; i < vol.size(); i++) {
      switch (vol[i].cid) {
      case pwr_eClass_ClassVolume:
      case pwr_eClass_DetachedClassVolume: {
        bool lock = false;
        if (wb_dblock::is_locked((char*)"$pwrp_db/directory.wb_load")) {
          wb_dblock::dbunlock((char*)"$pwrp_db/directory.wb_load");
          lock = true;
        }
        sprintf(
            cmd, "wb_cmd -c %s create flow/templ/all", cdh_Low(vol[i].name));
        sts = system(cmd);
        if (lock)
          wb_dblock::dblock((char*)"$pwrp_db/directory.wb_load");
        if (sts != 0) {
          printf("** Create flow for classvolume %s error\n", vol[i].name);
        }
        break;
      }
      default:;
      }
    }
  }

  // Build root, sub and shared volumes
  for (unsigned int i = 0; i < vol.size(); i++) {
    switch (vol[i].cid) {
    case pwr_eClass_RootVolume:
    case pwr_eClass_SubVolume:
    case pwr_eClass_SharedVolume:
      if (!no_classvolumes)
        sprintf(cmd, "wb_cmd -v %s update classes\\;build volume/name=%s/force",
            cdh_Low(vol[i].name), vol[i].name);
      else
        sprintf(cmd, "wb_cmd -v %s build volume/name=%s/force",
            cdh_Low(vol[i].name), vol[i].name);
      sts = system(cmd);
      if (sts != 0) {
        char msg[200];
        sprintf(msg, "Build:    Volume build error %s, build all terminated",
            vol[i].name);
        MsgWindow::message('E', msg, msgw_ePop_Yes);
        m_sts = 0;
        wb_log::pull();
        return;
      }
      if (!no_flowfiles) {
        sprintf(cmd, "wb_cmd -v %s create flow/all\\; create cross",
            cdh_Low(vol[i].name));
        system(cmd);
      }
      break;
    default:;
    }
  }

  // Build all nodes
  m_sts = lfu_create_bootfiles(0, 0, 1);
  if (EVEN(m_sts)) {
    char msg[200];
    sprintf(msg, "Build node error. Build all terminated");
    MsgWindow::message('E', msg, msgw_ePop_Yes);
    wb_log::pull();
    return;
  }

  syi_NodeName(&m_sts, currentnode, sizeof(currentnode));

  opt.force = 1;

  import_files(bld_ePass_AfterNode);
  if (evenSts())
    sumsts = m_sts;
  else if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT
      && m_sts != PWRB__INLIBHIER)
    sumsts = m_sts;

  directories(0, bld_ePass_AfterNode);
  if (evenSts())
    sumsts = m_sts;
  else if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT
      && m_sts != PWRB__INLIBHIER)
    sumsts = m_sts;

  export_files(bld_ePass_AfterNode);
  if (evenSts())
    sumsts = m_sts;
  else if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT
      && m_sts != PWRB__INLIBHIER)
    sumsts = m_sts;

  opt.force = force;

  wb_log::pull();

  m_sts = sumsts;
}

void wb_build::node(
    char* nodename, int nodetype, void* volumelist, int volumecnt)
{
  lfu_t_volumelist* vlist = (lfu_t_volumelist*)volumelist;
  pwr_tTime vtime;
  pwr_tTime btime;
  pwr_tFileName fname;
  pwr_tObjName vname;
  int bussid = -1;
  int rebuild = 1;
  pwr_tStatus status;
  char currentnode[80];
  char node[80];
  pwr_tStatus sumsts = PWRB__NOBUILT;

  printf("-- Build node %s\n", nodename);

  wb_log::push();

  if (!opt.manual)
    rebuild = 0;

  import_files(bld_ePass_BeforeNode);
  if (evenSts())
    sumsts = m_sts;
  else if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT
      && m_sts != PWRB__INLIBHIER)
    sumsts = m_sts;

  directories(0, bld_ePass_BeforeNode);
  if (m_sts == PWRB__MAKEUPDATED) {
    rebuild = 1;
    m_sts = PWRB__SUCCESS;
  } else if (evenSts())
    sumsts = m_sts;
  else if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT
      && m_sts != PWRB__INLIBHIER)
    sumsts = m_sts;

  export_files(bld_ePass_BeforeNode);
  if (evenSts())
    sumsts = m_sts;
  else if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT
      && m_sts != PWRB__INLIBHIER)
    sumsts = m_sts;

  cnf(nodename, volumelist, volumecnt);
  if (evenSts())
    sumsts = m_sts;
  else if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
    sumsts = m_sts;

  if (!opt.manual) {
    // Check if there is any new dbsfile
    for (int i = 0; i < volumecnt; i++) {
      if (str_NoCaseStrcmp(nodename, vlist[i].p1) == 0) {
        if (bussid == -1) {
          char systemname[80], systemgroup[80];
          pwr_tVid* vl;
          pwr_tString40* vnl;
          int vcnt;

          // Get time for current bootfile
          status = sscanf(vlist[i].p3, "%d", &bussid);
          if (status != 1) {
            // Bussid error
          }

          sprintf(fname, pwr_cNameBoot, load_cDirectory, vlist[i].p2, bussid);
          str_ToLower(fname, fname);
          dcli_translate_filename(fname, fname);
          status = lfu_ReadBootFile(
              fname, &btime, systemname, systemgroup, &vl, &vnl, &vcnt, 0, 0);
          if (EVEN(status)) {
            rebuild = 1;
          }
          strcpy(node, vlist[i].p2);
        }

        if (vlist[i].volume_id == m_session.vid()) {
          // Build current volume
          volume();
          if (evenSts()) {
            wb_log::pull();
            return;
          }
        }

        str_ToLower(vname, vlist[i].volume_name);
        if (vlist[i].volume_id >= cdh_cUserVolMin
            && vlist[i].volume_id <= cdh_cUserVolMax) {
          sprintf(fname, "$pwrp_load/%s.dbs", vname);
          dcli_translate_filename(fname, fname);
          m_sts = dcli_file_time(fname, &vtime);
          if (evenSts()) {
            // Dbs file is missing
            char msg[200];
            sprintf(msg, "Loadfile for volume %s not created", vname);
            MsgWindow::message('E', msg, msgw_ePop_Yes);
            wb_log::pull();
            return;
          }
          if (vtime.tv_sec > btime.tv_sec)
            rebuild = 1;
        }
      }
    }
  }

  if (m_wnav && m_wnav->ldhses) {
    wb_erep* erep = *(wb_env*)ldh_SessionToWB(m_wnav->ldhses);
    erep->checkVolumes(&m_sts, nodename);

    if (evenSts())
      return;
  }

  if (opt.force || opt.manual || rebuild) {
    m_sts = lfu_create_bootfile(nodename, nodetype,
        (lfu_t_volumelist*)volumelist, volumecnt, opt.debug);
    if (ODD(m_sts))
      wb_log::log(wlog_eCategory_NodeBuild, nodename, 0);
  } else
    m_sts = PWRB__NOBUILT;

  if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
    sumsts = m_sts;

  syi_NodeName(&m_sts, currentnode, sizeof(currentnode));

  import_files(bld_ePass_AfterNode);
  if (evenSts())
    sumsts = m_sts;
  else if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT
      && m_sts != PWRB__INLIBHIER)
    sumsts = m_sts;

  directories(0, bld_ePass_AfterNode);
  if (evenSts())
    sumsts = m_sts;
  else if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT
      && m_sts != PWRB__INLIBHIER)
    sumsts = m_sts;

  export_files(bld_ePass_AfterNode);
  if (evenSts())
    sumsts = m_sts;
  else if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT
      && m_sts != PWRB__INLIBHIER)
    sumsts = m_sts;

  if (ODD(sumsts) && sumsts != PWRB__NOBUILT) {
    char msg[200];

    sprintf(msg, "Build:    Node     %s", nodename);
    MsgWindow::message('I', msg, msgw_ePop_No);
  }
  wb_log::pull();

  m_sts = sumsts;
}

void wb_build::cnf(char* nodename, void* volumelist, int volumecnt)
{
  lfu_t_volumelist* vlist = (lfu_t_volumelist*)volumelist;
  pwr_tStatus sumsts = PWRB__NOBUILT;
  char src_fname[280];
  char dest_fname[280];
  std::vector<build_dir> users_dirv;
  build_dir node_dir;
  pwr_tFileName found_src_dir, found_dest_dir;
  char src_dir[260];
  char dest_dir[260];
  pwr_tStatus src_sts, dest_sts;
  int status;
  int bussid = 0;
  char node[80];

  bool found = false;
  for (int i = 0; i < volumecnt; i++) {
    if (str_NoCaseStrcmp(nodename, vlist[i].p1) == 0) {
      found = true;
      strncpy(node, vlist[i].p2, sizeof(node));
      status = sscanf(vlist[i].p3, "%d", &bussid);
      if (status != 1) {
        m_sts = PWRB__NOSUCHNODE;
        return;
      }
    }
  }
  if (!found) {
    m_sts = PWRB__NOSUCHNODE;
    return;
  }

  sprintf(node_dir.src_dir, "$pwrp_cnf/%s", node);
  src_sts = dcli_search_directory(
      node_dir.src_dir, found_src_dir, DCLI_DIR_SEARCH_INIT);
  dcli_search_directory(node_dir.src_dir, found_src_dir, DCLI_DIR_SEARCH_END);

  sprintf(node_dir.dest_dir, "$pwrp_load/%s", node);
  dest_sts = dcli_search_directory(
      node_dir.dest_dir, found_dest_dir, DCLI_DIR_SEARCH_INIT);
  dcli_search_directory(node_dir.dest_dir, found_dest_dir, DCLI_DIR_SEARCH_END);

  if (ODD(src_sts) && EVEN(dest_sts))
    // Create destination directory
    dcli_create_directory(node_dir.dest_dir);
  else if (EVEN(src_sts) && ODD(dest_sts))
    // Delete destination directory
    dcli_delete_directory(node_dir.dest_dir, 1);

  sprintf(src_dir, "%s/*", node_dir.src_dir);
  for (src_sts
       = dcli_search_directory(src_dir, found_src_dir, DCLI_DIR_SEARCH_INIT);
       ODD(src_sts); src_sts
       = dcli_search_directory(src_dir, found_src_dir, DCLI_DIR_SEARCH_NEXT)) {
    build_dir dir;

    char* s = strrchr(found_src_dir, '/');
    if (!s)
      continue;

    sprintf(dest_dir, "%s/%s", node_dir.dest_dir, s + 1);

    strcpy(dir.src_dir, found_src_dir);
    strcpy(dir.dest_dir, dest_dir);
    users_dirv.push_back(dir);
  }
  dcli_search_directory(src_dir, found_src_dir, DCLI_DIR_SEARCH_END);

  // Files on $pwrp_cnf

  // Update $pwrp_cnf/xtt_help.dat
  strcpy(src_fname, "$pwrp_cnf/xtt_help.dat");
  strcpy(dest_fname, "$pwrp_load/xtt_help.dat");
  update_file(dest_fname, src_fname);
  if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
    sumsts = m_sts;

  // Update $pwrp_cnf/xtt_setup.rtt_com
  strcpy(src_fname, "$pwrp_cnf/xtt_setup.rtt_com");
  strcpy(dest_fname, "$pwrp_load/xtt_setup.rtt_com");
  update_file(dest_fname, src_fname);
  if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
    sumsts = m_sts;

  // Update $pwrp_cnf/Rt_xtt
  strcpy(src_fname, "$pwrp_cnf/Rt_xtt");
  strcpy(dest_fname, "$pwrp_load/Rt_xtt");
  update_file(dest_fname, src_fname);
  if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
    sumsts = m_sts;

  // Update $pwrp_cnf/pwrp_stop.sh
  strcpy(src_fname, "$pwrp_cnf/pwrp_stop.sh");
  strcpy(dest_fname, "$pwrp_load/pwrp_stop.sh");
  update_file(dest_fname, src_fname);
  if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
    sumsts = m_sts;

  // Files on $pwrp_cnf/node

  // Update $pwrp_cnf/node/xtt_help.dat
  sprintf(src_fname, "%s/xtt_help.dat", node_dir.src_dir);
  sprintf(dest_fname, "%s/xtt_help.dat", node_dir.dest_dir);
  update_file(dest_fname, src_fname);
  if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
    sumsts = m_sts;

  // Update $pwrp_cnf/node/xtt_setup.rtt_com
  sprintf(src_fname, "%s/xtt_setup.rtt_com", node_dir.src_dir);
  sprintf(dest_fname, "%s/xtt_setup.rtt_com", node_dir.dest_dir);
  update_file(dest_fname, src_fname);
  if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
    sumsts = m_sts;

  // Update $pwrp_cnf/node/Rt_xtt
  sprintf(src_fname, "%s/Rt_xtt", node_dir.src_dir);
  sprintf(dest_fname, "%s/Rt_xtt", node_dir.dest_dir);
  update_file(dest_fname, src_fname);
  if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
    sumsts = m_sts;

  // Update $pwrp_cnf/node/pwrp_stop.sh
  sprintf(src_fname, "%s/pwrp_stop.sh", node_dir.src_dir);
  sprintf(dest_fname, "%s/pwrp_stop.sh", node_dir.dest_dir);
  update_file(dest_fname, src_fname);
  if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
    sumsts = m_sts;

  for (unsigned int i = 0; i < users_dirv.size(); i++) {
    dest_sts = dcli_search_directory(
        users_dirv[i].dest_dir, found_dest_dir, DCLI_DIR_SEARCH_INIT);
    dcli_search_directory(
        users_dirv[i].dest_dir, found_dest_dir, DCLI_DIR_SEARCH_END);

    if (EVEN(dest_sts))
      // Create destination directory
      dcli_create_directory(users_dirv[i].dest_dir);

    // Update $pwrp_cnf/node/user/xtt_help.dat
    sprintf(src_fname, "%s/%s", users_dirv[i].src_dir, "xtt_help.dat");
    sprintf(dest_fname, "%s/%s", users_dirv[i].dest_dir, "xtt_help.dat");
    update_file(dest_fname, src_fname);
    if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
      sumsts = m_sts;

    // Update $pwrp_cnf/node/user/xtt_setup.rtt_com
    sprintf(src_fname, "%s/%s", users_dirv[i].src_dir, "xtt_setup.rtt_com");
    sprintf(dest_fname, "%s/%s", users_dirv[i].dest_dir, "xtt_setup.rtt_com");
    update_file(dest_fname, src_fname);
    if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
      sumsts = m_sts;

    // Update $pwrp_cnf/node/user/Rt_xtt
    sprintf(src_fname, "%s/%s", users_dirv[i].src_dir, "Rt_xtt");
    sprintf(dest_fname, "%s/%s", users_dirv[i].dest_dir, "Rt_xtt");
    update_file(dest_fname, src_fname);
    if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
      sumsts = m_sts;
  }

  // Copy pwrp_alias.dat from $pwrp_cnf to $pwrp_load
  strcpy(src_fname, "$pwrp_cnf/pwrp_alias.dat");
  strcpy(dest_fname, "$pwrp_load/pwrp_alias.dat");
  update_file(dest_fname, src_fname);
  if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
    sumsts = m_sts;

  // Copy ld_appl_...txt from $pwrp_cnf to $pwrp_load
  sprintf(src_fname, pwr_cNameAppl, "$pwrp_cnf/", cdh_Low(node), bussid);
  sprintf(dest_fname, pwr_cNameAppl, "$pwrp_load/", cdh_Low(node), bussid);
  update_file(dest_fname, src_fname);
  if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
    sumsts = m_sts;

  m_sts = sumsts;
}

void wb_build::volume()
{
  switch (m_session.cid()) {
  case pwr_eClass_RootVolume:
  case pwr_eClass_SubVolume:
  case pwr_eClass_SharedVolume:
    rootvolume(0);
    break;
  case pwr_eClass_ClassVolume:
  case pwr_eClass_DetachedClassVolume:
    classvolume(0);
    break;
  default:;
  }
}

void wb_build::rootvolume(pwr_tVid vid)
{
  pwr_tStatus sumsts = 0, plcsts = 0;
  pwr_tOid oid;
  pwr_tTime modtime;
  pwr_tObjName vname;
  pwr_tFileName fname;
  pwr_tTime dbs_time, rtt_time;
  pwr_tCmd cmd;
  char msg[80];

  wb_log::push();

  if (!opt.manual) {
    // Build all plcpgm
    m_sts = gcg_comp_plcembed_all((ldh_tSession*)&m_session, opt.force);
    if (evenSts())
      return;

    classlist(pwr_cClass_plc);
    if (evenSts())
      return;
    plcsts = sumsts = m_sts;

    // Build all XttGraph
    classlist(pwr_cClass_XttGraph);
    if (evenSts())
      return;
    if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
      sumsts = m_sts;

    classlist(pwr_cClass_OpPlaceWeb);
    if (evenSts())
      return;
    if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
      sumsts = m_sts;

    classlist(pwr_cClass_WebBrowserConfig);
    if (evenSts())
      return;
    if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
      sumsts = m_sts;

    // Build all WebGraph
    classlist(pwr_cClass_WebGraph);
    if (evenSts())
      return;
    if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
      sumsts = m_sts;

    // Build all AppGraph
    classlist(pwr_cClass_AppGraph);
    if (evenSts())
      return;
    if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
      sumsts = m_sts;

    classlist(pwr_cClass_Application);
    if (evenSts())
      return;
    if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
      sumsts = m_sts;

    classlist(pwr_cClass_PlcProcess);
    if (evenSts())
      return;
    if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
      sumsts = m_sts;
  }
  wb_log::pull();

  // Create loadfiles
  oid.oix = 0;
  oid.vid = m_session.vid();
  wb_attribute a = m_session.attribute(oid, "SysBody", "Modified");
  if (!a) {
    m_sts = a.sts();
    return;
  }

  a.value(&modtime);
  if (!a) {
    m_sts = a.sts();
    return;
  }

  str_ToLower(vname, m_session.name());
  sprintf(fname, "$pwrp_load/%s.dbs", vname);
  dcli_translate_filename(fname, fname);
  m_sts = dcli_file_time(fname, &dbs_time);

  // Get time for classvolumes
  wb_merep* merep = ((wb_vrep*)m_session)->merep();
  pwr_tTime mtime = pwr_cNTime;
  pwr_tTime t;
  pwr_tStatus sts;
  for (wb_mvrep* mvrep = merep->volume(&sts); ODD(sts);
       mvrep = merep->nextVolume(&sts, mvrep->vid())) {
    mvrep->time(&t);
    if (time_Acomp(&t, &mtime) == 1)
      mtime = t;
  }

  if (opt.force || opt.manual || evenSts()
      || time_Acomp(&modtime, &dbs_time) == 1
      || time_Acomp(&mtime, &dbs_time) == 1 || plcsts != PWRB__NOBUILT) {
    m_sts = lfu_create_loadfile((ldh_tSession*)&m_session);
    if (evenSts())
      return;
    m_session.resetSts();
    m_sts = ldh_CreateLoadFile((ldh_tSession*)&m_session);
    if (evenSts())
      return;

    sprintf(msg, "Build:    Volume   Loadfiles created volume %s",
        m_session.name());
    MsgWindow::message('I', msg, msgw_ePop_No);

    wb_log::log(&m_session, wlog_eCategory_VolumeBuild, m_session.vid());

    sumsts = PWRB__SUCCESS;
  } else
    m_sts = sumsts;

  cdh_uVolumeId uvid;
  uvid.pwr = m_session.vid();
  sprintf(fname, "$pwrp_load/" pwr_cNameRttCrr, uvid.v.vid_3, uvid.v.vid_2,
      uvid.v.vid_1, uvid.v.vid_0);
  dcli_translate_filename(fname, fname);
  m_sts = dcli_file_time(fname, &rtt_time);
  if (opt.crossref && (evenSts() || time_Acomp(&modtime, &rtt_time) == 1)) {
    strcpy(cmd, "create crossreferencefiles");
    m_wnav->command(cmd);
    if (ODD(sumsts))
      sumsts = PWRB__SUCCESS;

    sprintf(msg, "Build:    Volume   Crossreference file generated volume %s",
        m_session.name());
    MsgWindow::message('I', msg, msgw_ePop_No);
  }

  WFoe::create_volume_xtthelpfile(&m_session, m_session.vid());

  m_sts = sumsts;
}

void wb_build::classvolume(pwr_tVid vid)
{
  pwr_tCmd cmd;
  pwr_tFileName fname;
  pwr_tObjName name;
  pwr_tTime wbl_time, dbs_time, h_time;
  pwr_tStatus fsts;
  pwr_tStatus sumsts = PWRB__NOBUILT;

  wb_log::push();

  if (!opt.manual) {
    // Build all ClassDef
    classlist(pwr_eClass_ClassDef);
    if (evenSts())
      return;
    if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
      sumsts = m_sts;
  }

  wb_log::pull();

  if (vid == 0) {
    // Build current volume
    str_ToLower(name, m_session.name());
  } else {
    wb_env env = m_session.env();
    wb_volume v = env.volume(vid);
    if (!v) {
      m_sts = v.sts();
      return;
    }
    strcpy(name, v.name());
  }

  // Get time for wb_load file
  sprintf(fname, "$pwrp_db/%s.wb_load", name);
  dcli_translate_filename(fname, fname);
  m_sts = dcli_file_time(fname, &wbl_time);
  if (evenSts())
    return;

  // Get time for dbs file
  sprintf(fname, "$pwrp_load/%s.dbs", name);
  dcli_translate_filename(fname, fname);
  fsts = dcli_file_time(fname, &dbs_time);

  // Get time for classvolumes
  wb_merep* merep = ((wb_erep*)m_session.env())->merep();
  pwr_tTime mtime = pwr_cNTime;
  pwr_tTime t;
  pwr_tStatus sts;
  for (wb_mvrep* mvrep = merep->volume(&sts); ODD(sts);
       mvrep = merep->nextVolume(&sts, mvrep->vid())) {
    if (m_session.vid() == mvrep->vid())
      continue;
    // Check only system class and manufact class volumes
    if (mvrep->vid() > cdh_cSystemClassVolMax
        && (mvrep->vid() < cdh_cManufactClassVolMin
               || mvrep->vid() > cdh_cManufactClassVolMax))
      continue;

    mvrep->time(&t);
    if (time_Acomp(&t, &mtime) == 1)
      mtime = t;
  }

  // Create new loadfile
  if (opt.force || EVEN(fsts) || wbl_time.tv_sec > dbs_time.tv_sec
      || mtime.tv_sec > dbs_time.tv_sec) {
    sprintf(cmd, "create snapshot/file=\"$pwrp_db/%s.wb_load\"", name);
    m_sts = m_wnav->command(cmd);
    sumsts = m_sts;
  } else
    m_sts = sumsts;

  // Get time for struct file
  sprintf(fname, "$pwrp_inc/pwr_%sclasses.h", name);
  dcli_translate_filename(fname, fname);
  fsts = dcli_file_time(fname, &h_time);

  // Create new struct file
  if (opt.force || EVEN(fsts) || wbl_time.tv_sec > h_time.tv_sec) {
    sprintf(cmd, "create struct/file=\"$pwrp_db/%s.wb_load\"", name);
    m_sts = m_wnav->command(cmd);
    sumsts = m_sts;
  } else
    m_sts = sumsts;

  if (sumsts != PWRB__NOBUILT) {
    char msg[80];

    sprintf(msg, "Build:    Volume   %s", name);
    MsgWindow::message('I', msg, msgw_ePop_No);
  }
}

void wb_build::planthier(pwr_tOid oid)
{
  pwr_tStatus sumsts;

  m_hierarchy = oid;

  // Build all plcpgm
  classlist(pwr_cClass_plc);
  if (evenSts())
    return;
  sumsts = m_sts;

  // Build all XttGraph
  classlist(pwr_cClass_XttGraph);
  if (evenSts())
    return;
  if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
    sumsts = m_sts;

  m_sts = sumsts;
}

void wb_build::nodehier(pwr_tOid oid)
{
  pwr_tStatus sumsts;
  m_hierarchy = oid;

  // Build all XttGraph
  classlist(pwr_cClass_XttGraph);
  if (evenSts())
    return;
  sumsts = m_sts;

  classlist(pwr_cClass_OpPlaceWeb);
  if (evenSts())
    return;
  if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
    sumsts = m_sts;

  classlist(pwr_cClass_WebBrowserConfig);
  if (evenSts())
    return;
  if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
    sumsts = m_sts;

  classlist(pwr_cClass_WebGraph);
  if (evenSts())
    return;
  if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
    sumsts = m_sts;

  classlist(pwr_cClass_AppGraph);
  if (evenSts())
    return;
  if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
    sumsts = m_sts;

  classlist(pwr_cClass_Application);
  if (evenSts())
    return;
  if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
    sumsts = m_sts;

  classlist(pwr_cClass_PlcProcess);
  if (evenSts())
    return;
  if (sumsts == PWRB__NOBUILT && m_sts != PWRB__NOBUILT)
    sumsts = m_sts;

  m_sts = sumsts;
}

void wb_build::plcpgm(pwr_tOid oid)
{
  int check_hierarchy = cdh_ObjidIsNotNull(m_hierarchy);
  int hierarchy_found = 0;

  wb_object o = m_session.object(oid);
  if (!o) {
    m_sts = o.sts();
    return;
  }

  // Check that no ancestor is a LibHier
  for (wb_object p = o.parent(); p.oddSts(); p = p.parent()) {
    if (p.cid() == pwr_eClass_LibHier) {
      m_sts = PWRB__INLIBHIER;
      return;
    }
    if (check_hierarchy && cdh_ObjidIsEqual(m_hierarchy, p.oid()))
      hierarchy_found = 1;
  }

  if (check_hierarchy && !hierarchy_found) {
    m_sts = PWRB__NOBUILT;
    return;
  }

  m_sts = utl_compile((ldh_tSession*)&m_session,
      ldh_SessionToWB((ldh_tSession*)&m_session),
      o.longName().name(cdh_mName_volumeStrict), 0, 0, 0, !opt.force, opt.debug,
      0, 0);
  if (oddSts() && m_sts != GSX__NOMODIF) {
    char msg[200];

    sprintf(msg, "Build:    PlcPgm    %s",
        o.longName().name(cdh_mName_path | cdh_mName_object));
    MsgWindow::message('I', msg, msgw_ePop_No, oid);
  } else if (m_sts == GSX__NOMODIF) {
    m_sts = PWRB__NOBUILT;
  } else {
    char msg[500];
    char msg2[256];
    msg_GetMsg(m_sts, msg, sizeof(msg));
    sprintf(msg2, ", PlcPgm %s",
        o.longName().name(cdh_mName_path | cdh_mName_object));
    strcat(msg, msg2);
    MsgWindow::message('E', msg, msgw_ePop_Yes, oid, msgw_eRow_Plc);
  }
}

void wb_build::xttgraph(pwr_tOid oid)
{
  pwr_tFileName src_fname, dest_fname;
  char cmd[520];
  pwr_tString80 action;
  pwr_tString80 name;
  pwr_tTime dest_time, src_time;
  int check_hierarchy = cdh_ObjidIsNotNull(m_hierarchy);
  int hierarchy_found = 0;
  int is_frame, is_applet;
  char java_name[80];
  pwr_tStatus fsts;
  int jexport;
  char* s;

  wb_object o = m_session.object(oid);
  if (!o) {
    m_sts = o.sts();
    return;
  }

  // Check that no ancestor is a LibHier
  for (wb_object p = o.parent(); p.oddSts(); p = p.parent()) {
    if (p.cid() == pwr_eClass_LibHier) {
      m_sts = PWRB__INLIBHIER;
      return;
    }
    if (check_hierarchy && cdh_ObjidIsEqual(m_hierarchy, p.oid()))
      hierarchy_found = 1;
  }

  if (check_hierarchy && !hierarchy_found) {
    m_sts = PWRB__NOBUILT;
    return;
  }

  wb_attribute a = m_session.attribute(oid, "RtBody", "Action");
  if (!a) {
    m_sts = a.sts();
    return;
  }

  a.value(&action);
  if (!a) {
    m_sts = a.sts();
    return;
  }

  if (strstr(action, ".pwg")) {
    strcpy(src_fname, "$pwrp_pop/");
    strcat(src_fname, action);
    dcli_translate_filename(src_fname, src_fname);
    m_sts = dcli_file_time(src_fname, &src_time);
    if (evenSts()) {
      m_sts = PWRB__NOBUILT;
      return;
    }

    strcpy(dest_fname, "$pwrp_exe/");
    strcat(dest_fname, action);
    dcli_translate_filename(dest_fname, dest_fname);
    m_sts = dcli_file_time(dest_fname, &dest_time);
    if (!opt.nocopy
        && (opt.force || evenSts() || src_time.tv_sec > dest_time.tv_sec)) {
      sprintf(cmd, "cp %s %s", src_fname, dest_fname);
      system(cmd);
      sprintf(cmd, "Build:    XttGraph copy $pwrp_pop/%s -> $pwrp_exe", action);
      MsgWindow::message('I', cmd, msgw_ePop_No, oid);

      strcpy(name, action);
      if ((s = strrchr(name, '.')))
        *s = 0;

      wb_revision::check_add_file(src_fname);
      wb_log::log(wlog_eCategory_GeBuild, name, 0);
      m_sts = PWRB__SUCCESS;
    } else
      m_sts = PWRB__NOBUILT;

    jexport = 0;
    fsts = grow_IsJava(src_fname, &is_frame, &is_applet, java_name);
    if (EVEN(fsts)) {
      m_sts = fsts;
      return;
    }
    if ((is_frame || is_applet) && streq(java_name, "")) {
      // Java name is not yet set, use the default java name
      strcpy(java_name, action);
      if ((s = strchr(java_name, '.')) != 0)
        *s = 0;
      java_name[0] = _toupper(java_name[0]);
    }
    if (is_frame) {
      // Check exported java frame
      sprintf(dest_fname, "$pwrp_pop/%s.java", java_name);
      dcli_translate_filename(dest_fname, dest_fname);
      fsts = dcli_file_time(dest_fname, &dest_time);
      if (opt.force || EVEN(fsts) || time_Acomp(&src_time, &dest_time) == 1)
        jexport = 1;
    }
    if (is_applet) {
      // Check exported java applet
      sprintf(dest_fname, "$pwrp_pop/%s_A.java", java_name);
      dcli_translate_filename(dest_fname, dest_fname);
      fsts = dcli_file_time(dest_fname, &dest_time);
      if (opt.force || EVEN(fsts) || time_Acomp(&src_time, &dest_time) == 1)
        jexport = 1;
    }
    if (jexport) {
      if (!m_wnav) {
        sprintf(cmd,
            "Build:    XttGraph  Unable to export java in this environment %s",
            action);
        MsgWindow::message('W', cmd, msgw_ePop_No, oid);
      } else {
        Ge* gectx = m_wnav->ge_new(action, 1);
        strcpy(cmd, "export java");
        m_sts = gectx->command(cmd);
        if (evenSts()) {
          msg_GetMsg(m_sts, cmd, sizeof(cmd));
          MsgWindow::message('E', cmd, msgw_ePop_Yes, oid);
          m_sts = PWRB__NOBUILT;
          delete gectx;
          return;
        }

        sprintf(cmd, "Build:    XttGraph  Export java %s", action);
        MsgWindow::message('I', cmd, msgw_ePop_No, oid);

        delete gectx;

        m_sts = PWRB__SUCCESS;
      }
    }
  }
}

void wb_build::webgraph(pwr_tOid oid)
{
  pwr_tFileName dest_fname;
  pwr_tFileName src_fname;
  char cmd[520];
  pwr_tString80 java_name;
  char name[280];
  pwr_tTime dest_time, src_time;
  int check_hierarchy = cdh_ObjidIsNotNull(m_hierarchy);
  int hierarchy_found = 0;
  int is_frame, is_applet;
  char jname[80];
  pwr_tStatus fsts;
  int jexport;
  int found;
  pwr_tFileName found_file, file_spec;
  pwr_tFileName graph_name, dir;
  char dev[80], type[80];
  int version;
  pwr_tString80 appletsignature = "";
  char* s;

  wb_object o = m_session.object(oid);
  if (!o) {
    m_sts = o.sts();
    return;
  }

  // Check that no ancestor is a LibHier
  for (wb_object p = o.parent(); p.oddSts(); p = p.parent()) {
    if (p.cid() == pwr_eClass_LibHier) {
      m_sts = PWRB__INLIBHIER;
      return;
    }
    if (check_hierarchy && cdh_ObjidIsEqual(m_hierarchy, p.oid()))
      hierarchy_found = 1;
  }

  if (check_hierarchy && !hierarchy_found) {
    m_sts = PWRB__NOBUILT;
    return;
  }

  wb_attribute a = m_session.attribute(oid, "RtBody", "Name");
  if (!a) {
    m_sts = a.sts();
    return;
  }

  a.value(java_name);
  if (!a) {
    m_sts = a.sts();
    return;
  }

  if (isupper(java_name[0])) {
    str_ToLower(java_name, java_name);
    java_name[0] = toupper(java_name[0]);

    // Get the .pwg file for this javaname
    strcpy(graph_name, cdh_Low(java_name));
    sprintf(name, "$pwrp_pop/%s.pwg", graph_name);

    dcli_translate_filename(name, name);
    m_sts = dcli_file_time(name, &src_time);
    if (evenSts()) {
      // Search in all pwg files
      found = 0;
      strcpy(file_spec, "$pwrp_pop/*.pwg");
      for (fsts = dcli_search_file(file_spec, found_file, DCLI_DIR_SEARCH_INIT);
           ODD(fsts); fsts
           = dcli_search_file(file_spec, found_file, DCLI_DIR_SEARCH_NEXT)) {
        fsts = grow_IsJava(found_file, &is_frame, &is_applet, jname);
        if (EVEN(fsts))
          continue;

        if (is_frame && streq(jname, java_name)) {
          dcli_parse_filename(found_file, dev, dir, graph_name, type, &version);
          strcpy(name, found_file);
          found = 1;
          break;
        }
      }
      dcli_search_file(file_spec, found_file, DCLI_DIR_SEARCH_END);

      if (!found) {
        char msg[200];
        sprintf(msg, "Graph for %s not found", java_name);
        MsgWindow::message('E', msg, msgw_ePop_Yes, oid);
        m_sts = PWRB__NOBUILT;
        return;
      }
    }

    m_sts = dcli_file_time(name, &src_time);
    if (evenSts())
      return;

    // Check exported java frame
    jexport = 0;
    sprintf(dest_fname, "$pwrp_pop/%s.java", java_name);
    dcli_translate_filename(dest_fname, dest_fname);
    fsts = dcli_file_time(dest_fname, &dest_time);
    if (opt.force || EVEN(fsts) || time_Acomp(&src_time, &dest_time) == 1)
      jexport = 1;

    if (jexport) {
      if (!m_wnav) {
        sprintf(cmd,
            "Build:    WebGraph  Unable to export java in this environment %s",
            java_name);
        MsgWindow::message('W', cmd, msgw_ePop_No, oid);
      } else {
        // Get signature from OpPlaceWeb
        for (wb_object p = o.parent(); p.oddSts(); p = p.parent()) {
          if (p.cid() == pwr_cClass_OpPlaceWeb) {
            wb_attribute a
                = m_session.attribute(p.oid(), "RtBody", "AppletSignature");
            if (!a) {
              m_sts = a.sts();
              return;
            }

            a.value(appletsignature);
            if (!a) {
              m_sts = a.sts();
              return;
            }
            str_trim(appletsignature, appletsignature);
            break;
          }
        }

        Ge* gectx = m_wnav->ge_new(graph_name, 1);
        if (streq(appletsignature, ""))
          strcpy(cmd, "export java");
        else
          sprintf(cmd, "export java /signature=\"%s\"", appletsignature);
        m_sts = gectx->command(cmd);
        if (evenSts()) {
          msg_GetMsg(m_sts, cmd, sizeof(cmd));
          MsgWindow::message('E', cmd, msgw_ePop_Yes, oid);
          m_sts = PWRB__NOBUILT;
          delete gectx;
          return;
        }
        delete gectx;

        sprintf(cmd, "Build:    WebGraph  Export java %s", java_name);
        MsgWindow::message('I', cmd, msgw_ePop_No, oid);

        m_sts = PWRB__SUCCESS;
      }
    }
  } else {
    // Copy from $pwrp_pop to $pwrp_web

    strcpy(graph_name, cdh_Low(java_name));

    str_ToLower(graph_name, graph_name);

    strcpy(src_fname, "$pwrp_pop/");
    strcat(src_fname, graph_name);

    if (strstr(src_fname, ".pwg") == 0)
      strcat(src_fname, ".pwg");

    dcli_translate_filename(src_fname, src_fname);
    m_sts = dcli_file_time(src_fname, &src_time);
    if (evenSts()) {
      m_sts = PWRB__NOBUILT;
      return;
    }

    strcpy(dest_fname, "$pwrp_web/");
    strcat(dest_fname, graph_name);

    if (strstr(dest_fname, ".pwg") == 0)
      strcat(dest_fname, ".pwg");

    dcli_translate_filename(dest_fname, dest_fname);
    m_sts = dcli_file_time(dest_fname, &dest_time);
    if (!opt.nocopy
        && (opt.force || evenSts() || src_time.tv_sec > dest_time.tv_sec)) {
      sprintf(cmd, "cp %s %s", src_fname, dest_fname);
      system(cmd);
      sprintf(
          cmd, "Build:    WebGraph copy $pwrp_pop/%s -> $pwrp_web", graph_name);
      MsgWindow::message('I', cmd, msgw_ePop_No, oid);

      strcpy(name, graph_name);
      if ((s = strrchr(name, '.')))
        *s = 0;

      wb_revision::check_add_file(src_fname);
      wb_log::log(wlog_eCategory_GeBuild, name, 0);
      m_sts = PWRB__SUCCESS;
    } else
      m_sts = PWRB__NOBUILT;
  }
}

void wb_build::appgraph(pwr_tOid oid)
{
  pwr_tFileName dest_fname;
  pwr_tFileName src_fname;
  char cmd[520];
  pwr_tString80 graph_name;
  pwr_tString80 name;
  pwr_tTime dest_time, src_time;
  int check_hierarchy = cdh_ObjidIsNotNull(m_hierarchy);
  int hierarchy_found = 0;
  char* s;

  if (opt.nocopy)
    return;

  wb_object o = m_session.object(oid);
  if (!o) {
    m_sts = o.sts();
    return;
  }

  // Check that no ancestor is a LibHier
  for (wb_object p = o.parent(); p.oddSts(); p = p.parent()) {
    if (p.cid() == pwr_eClass_LibHier) {
      m_sts = PWRB__INLIBHIER;
      return;
    }
    if (check_hierarchy && cdh_ObjidIsEqual(m_hierarchy, p.oid()))
      hierarchy_found = 1;
  }

  if (check_hierarchy && !hierarchy_found) {
    m_sts = PWRB__NOBUILT;
    return;
  }

  wb_attribute a = m_session.attribute(oid, "RtBody", "Name");
  if (!a) {
    m_sts = a.sts();
    return;
  }

  a.value(graph_name);
  if (!a) {
    m_sts = a.sts();
    return;
  }

  str_ToLower(graph_name, graph_name);

  strcpy(src_fname, "$pwrp_pop/");
  strcat(src_fname, graph_name);

  if (strstr(src_fname, ".pwg") == 0)
    strcat(src_fname, ".pwg");

  dcli_translate_filename(src_fname, src_fname);
  m_sts = dcli_file_time(src_fname, &src_time);
  if (evenSts()) {
    m_sts = PWRB__NOBUILT;
    return;
  }

  strcpy(dest_fname, "$pwrp_exe/");
  strcat(dest_fname, graph_name);

  if (strstr(dest_fname, ".pwg") == 0)
    strcat(dest_fname, ".pwg");

  dcli_translate_filename(dest_fname, dest_fname);
  m_sts = dcli_file_time(dest_fname, &dest_time);
  if (!opt.nocopy
      && (opt.force || evenSts() || src_time.tv_sec > dest_time.tv_sec)) {
    sprintf(cmd, "cp %s %s", src_fname, dest_fname);
    system(cmd);
    sprintf(
        cmd, "Build:    AppGraph copy $pwrp_pop/%s -> $pwrp_exe", graph_name);
    MsgWindow::message('I', cmd, msgw_ePop_No, oid);

    strcpy(name, graph_name);
    if ((s = strrchr(name, '.')))
      *s = 0;
    wb_revision::check_add_file(src_fname);
    wb_log::log(wlog_eCategory_GeBuild, name, 0);
    m_sts = PWRB__SUCCESS;
  } else
    m_sts = PWRB__NOBUILT;
}

void wb_build::opplaceweb(pwr_tOid oid)
{
  pwr_tTime modtime;
  pwr_tString80 file_name, name;
  pwr_tFileName fname;
  pwr_tFileName srcname;
  pwr_tTime ftime;
  pwr_tTime xtthelp_time, html_time;
  char* s;
  pwr_tStatus fsts;
  pwr_tStatus sts;
  char line[200];
  char volstr[20];
  int check_hierarchy = cdh_ObjidIsNotNull(m_hierarchy);
  int hierarchy_found = 0;

  wb_object o = m_session.object(oid);
  if (!o) {
    m_sts = o.sts();
    return;
  }

  // Check that no ancestor is a LibHier
  for (wb_object p = o.parent(); p.oddSts(); p = p.parent()) {
    if (p.cid() == pwr_eClass_LibHier) {
      m_sts = PWRB__INLIBHIER;
      return;
    }
    if (check_hierarchy && cdh_ObjidIsEqual(m_hierarchy, p.oid()))
      hierarchy_found = 1;
  }

  if (check_hierarchy && !hierarchy_found) {
    m_sts = PWRB__NOBUILT;
    return;
  }

  modtime = o.modTime();

  wb_attribute a = m_session.attribute(oid, "RtBody", "FileName");
  if (!a) {
    m_sts = a.sts();
    return;
  }
  a.value(&file_name);
  if (!a) {
    m_sts = a.sts();
    return;
  }
  // Parse the name of the start page
  if ((s = strrchr(file_name, '/')) || (s = strrchr(file_name, '<'))
      || (s = strrchr(file_name, ':')))
    strcpy(name, s + 1);
  else
    strcpy(name, file_name);

  if ((s = strrchr(name, '.')))
    *s = 0;

  sprintf(fname, "$pwrp_web/%s_opwin_menu.html", name);
  dcli_translate_filename(fname, fname);
  fsts = dcli_file_time(fname, &ftime);

  m_sts = PWRB__NOBUILT;
  if (opt.force || EVEN(fsts) || time_Acomp(&modtime, &ftime) == 1) {
    // modtime > ftime
    m_sts = Graph::generate_web((ldh_tSession*)&m_session, oid);
    if (evenSts())
      return;

    char msg[300];
    sprintf(msg, "Build:    OpPlaceWeb Webpage generated %s", fname);
    MsgWindow::message('I', msg, msgw_ePop_No, oid);
  }

  // Check if xtthelp should be converted to html
  dcli_translate_filename(fname, pwr_cNameProjectXttHelp);
  fsts = dcli_file_time(fname, &xtthelp_time);
  if (EVEN(fsts))
    return;

  dcli_translate_filename(fname, "$pwrp_web/xtt_help_index.html");
  fsts = dcli_file_time(fname, &html_time);
  if (opt.force || EVEN(fsts) || time_Acomp(&xtthelp_time, &html_time) == 1) {
    system("co_convert -d $pwrp_web -t " pwr_cNameProjectXttHelp);

    char msg[200];
    sprintf(msg, "Build:    OpPlaceWeb xtt_help.dat converted to html");
    MsgWindow::message('I', msg, msgw_ePop_No, oid);
    m_sts = PWRB__SUCCESS;
  }

  // Convert plc xtthelp files to html for all volumes
  strcpy(fname, pwr_cNameVolumeList);
  dcli_translate_filename(fname, fname);

  std::ifstream fpm(fname, std::ios::in);
  if (!fpm) {
    m_sts = 0;
    return;
  }

  while (fpm.getline(line, sizeof(line))) {
    int nr;
    char vol_array[7][80];
    pwr_tVid vid;

    if (line[0] == '#')
      continue;

    nr = dcli_parse(line, " ", "", (char*)vol_array,
        sizeof(vol_array) / sizeof(vol_array[0]), sizeof(vol_array[0]), 0);

    if (str_NoCaseStrcmp(vol_array[2], "RootVolume") == 0
        || str_NoCaseStrcmp(vol_array[2], "SubVolume") == 0
        || str_NoCaseStrcmp(vol_array[2], "SharedVolume") == 0) {
      sts = cdh_StringToVolumeId(vol_array[1], &vid);
      if (EVEN(sts)) {
        m_sts = 0;
        return;
      }

      sprintf(srcname, pwr_cNamePlcXttHelp,
          cdh_VolumeIdToFnString(volstr, sizeof(volstr), vid));
      dcli_translate_filename(fname, srcname);
      fsts = dcli_file_time(fname, &xtthelp_time);
      if (ODD(fsts)) {
        sprintf(fname, "$pwrp_web/xtthelp_%s_plc_index.html",
            cdh_VolumeIdToFnString(volstr, sizeof(volstr), vid));
        dcli_translate_filename(fname, fname);
        fsts = dcli_file_time(fname, &html_time);
        if (opt.force || EVEN(fsts)
            || time_Acomp(&xtthelp_time, &html_time) == 1) {
          char msg[200];
          pwr_tCmd cmd;

          sprintf(cmd, "co_convert -d $pwrp_web -t %s", srcname);
          system(cmd);

          sprintf(msg, "Build:    OpPlaceWeb plc xtthelp-file for volume %s "
                       "converted to html",
              vol_array[0]);
          MsgWindow::message('I', msg, msgw_ePop_No, oid);
          m_sts = PWRB__SUCCESS;
        }
      }
    }
  }
  fpm.close();

  // Generate wb history html file
  pwr_tCmd cmd;
  strcpy(cmd, "generate history");
  m_wnav->command(cmd);
}

void wb_build::application(pwr_tOid oid)
{
  pwr_tString80 buildcmd;
  pwr_tCmd cmd;
  int check_hierarchy = cdh_ObjidIsNotNull(m_hierarchy);
  int hierarchy_found = 0;
  int sts;

  wb_object o = m_session.object(oid);
  if (!o) {
    m_sts = o.sts();
    return;
  }

  // Check that no ancestor is a LibHier
  for (wb_object p = o.parent(); p.oddSts(); p = p.parent()) {
    if (p.cid() == pwr_eClass_LibHier) {
      m_sts = PWRB__INLIBHIER;
      return;
    }
    if (check_hierarchy && cdh_ObjidIsEqual(m_hierarchy, p.oid()))
      hierarchy_found = 1;
  }

  if (check_hierarchy && !hierarchy_found) {
    m_sts = PWRB__NOBUILT;
    return;
  }

  wb_attribute a = m_session.attribute(oid, "DevBody", "BuildCmd");
  if (!a) {
    m_sts = a.sts();
    return;
  }
  a.value(&buildcmd);
  if (!a) {
    m_sts = a.sts();
    return;
  }

  if (streq(buildcmd, "")) {
    m_sts = PWRB__NOBUILT;
    return;
  }

  // Exectute the build command
  dcli_translate_filename(cmd, buildcmd);
  sts = system(cmd);
  if (sts != 0) {
    char msg[300];

    sprintf(msg, "Build Application error %s",
        o.longName().name(cdh_mName_path | cdh_mName_object));
    MsgWindow::message('E', msg, msgw_ePop_Yes, oid);
    m_sts = PWRB__SUCCESS;
  } else {
    m_sts = PWRB__NOBUILT;
  }
}

#define MAXSYMBOLS 100

void wb_build::webbrowserconfig(pwr_tOid oid)
{
  pwr_tTime modtime;
  pwr_tFileName fname;
  pwr_tTime ftime;
  pwr_tStatus fsts;
  FILE* fp;
  int i, j;
  int found;
  char line[200];
  pwr_tObjName vname;

  strncpy(vname, m_session.name(), sizeof(vname));

  wb_object o = m_session.object(oid);
  if (!o) {
    m_sts = o.sts();
    return;
  }

  modtime = o.modTime();

  sprintf(fname, "$pwrp_db/pwrp_cnf_websymbols.dat");
  dcli_translate_filename(fname, fname);
  fsts = dcli_file_time(fname, &ftime);

  m_sts = PWRB__NOBUILT;
  if (opt.force || EVEN(fsts) || time_Acomp(&modtime, &ftime) == 1) {
    pwr_sClass_WebBrowserConfig body;
    int url_symbols_size
        = sizeof(body.URL_Symbols) / sizeof(body.URL_Symbols[0]);
    char sym_vect[MAXSYMBOLS][80];
    char value_vect[MAXSYMBOLS][80];
    char volume_vect[MAXSYMBOLS][80];
    int vect_cnt;
    int nr;
    char elemv[3][80];

    wb_attribute a = m_session.attribute(oid, "RtBody", "URL_Symbols");
    if (!a) {
      m_sts = a.sts();
      return;
    }
    a.value(body.URL_Symbols);
    if (!a) {
      m_sts = a.sts();
      return;
    }

    // Read the file and merge the symbols of this volume with other symbols in
    // the project
    vect_cnt = 0;
    fp = fopen(fname, "r");
    if (fp) {
      while (dcli_read_line(line, sizeof(line), fp)) {
        nr = dcli_parse(line, " ", "", (char*)elemv,
            sizeof(elemv) / sizeof(elemv[0]), sizeof(elemv[0]), 0);
        if (nr != 3)
          continue;

        // Skip old symbols from this volume
        if (str_NoCaseStrcmp(vname, elemv[0]) == 0)
          continue;

        strcpy(volume_vect[vect_cnt], elemv[0]);
        strcpy(sym_vect[vect_cnt], elemv[1]);
        strcpy(value_vect[vect_cnt], elemv[2]);
        vect_cnt++;
      }
      fclose(fp);
    }

    for (i = 0; i < url_symbols_size; i++) {
      nr = dcli_parse(body.URL_Symbols[i], " ", "", (char*)elemv,
          sizeof(elemv) / sizeof(elemv[0]), sizeof(elemv[0]), 0);
      if (nr != 2)
        continue;

      found = 0;
      for (j = 0; j < vect_cnt; j++) {
        if (str_NoCaseStrcmp(elemv[0], sym_vect[j]) == 0) {
          strcpy(value_vect[j], elemv[1]);
          found = 1;
          break;
        }
      }
      if (!found) {
        // Insert first
        for (j = MIN(vect_cnt, MAXSYMBOLS - 1); j > 0; j--) {
          strcpy(volume_vect[j], volume_vect[j - 1]);
          strcpy(sym_vect[j], sym_vect[j - 1]);
          strcpy(value_vect[j], value_vect[j - 1]);
        }
        strcpy(volume_vect[0], vname);
        strcpy(sym_vect[0], elemv[0]);
        strcpy(value_vect[0], elemv[1]);
        vect_cnt++;
        if (vect_cnt > MAXSYMBOLS)
          vect_cnt = MAXSYMBOLS;
      }
    }

    // Write the file
    fp = fopen(fname, "w");
    if (!fp) {
      char tmp[300];
      sprintf(tmp, "Build:    Unable to open file \"%s\"", fname);
      MsgWindow::message('E', tmp, msgw_ePop_No, oid);
      return;
    }

    for (i = 0; i < vect_cnt; i++)
      fprintf(fp, "%s %s %s\n", volume_vect[i], sym_vect[i], value_vect[i]);
    fclose(fp);
  }
}

void wb_build::classdef(pwr_tOid oid)
{
  pwr_tFileName src_fname, dest_fname;
  char cmd[520];
  pwr_tString80 action;
  pwr_tString80 name;
  pwr_tTime dest_time, src_time;
  int check_hierarchy = cdh_ObjidIsNotNull(m_hierarchy);
  int hierarchy_found = 0;
  char* s;

  wb_object o = m_session.object(oid);
  if (!o) {
    m_sts = o.sts();
    return;
  }

  // Check that no ancestor is a LibHier
  for (wb_object p = o.parent(); p.oddSts(); p = p.parent()) {
    if (p.cid() == pwr_eClass_LibHier) {
      m_sts = PWRB__INLIBHIER;
      return;
    }
    if (check_hierarchy && cdh_ObjidIsEqual(m_hierarchy, p.oid()))
      hierarchy_found = 1;
  }

  if (check_hierarchy && !hierarchy_found) {
    m_sts = PWRB__NOBUILT;
    return;
  }

  strcpy(action, cdh_Low(o.name()));
  strcat(action, ".pwg");

  strcpy(src_fname, "$pwrp_pop/");
  strcat(src_fname, action);
  dcli_translate_filename(src_fname, src_fname);
  m_sts = dcli_file_time(src_fname, &src_time);
  if (evenSts()) {
    m_sts = PWRB__NOBUILT;
    return;
  }

  strcpy(dest_fname, "$pwrp_exe/");
  strcat(dest_fname, action);
  dcli_translate_filename(dest_fname, dest_fname);
  m_sts = dcli_file_time(dest_fname, &dest_time);
  if (!opt.nocopy
      && (opt.force || evenSts() || src_time.tv_sec > dest_time.tv_sec)) {
    sprintf(cmd, "cp %s %s", src_fname, dest_fname);
    system(cmd);
    sprintf(cmd, "Build:    ClassDef copy $pwrp_pop/%s -> $pwrp_exe", action);
    MsgWindow::message('I', cmd, msgw_ePop_No, oid);

    strcpy(name, action);
    if ((s = strrchr(name, '.')))
      *s = 0;
    wb_log::log(wlog_eCategory_GeBuild, name, 0);
    m_sts = PWRB__SUCCESS;
  } else
    m_sts = PWRB__NOBUILT;
}

void wb_build::directories(char* dir, bld_ePass pass)
{
  pwr_tFileName fname;
  char line[400];
  char line_item[5][250];
  pwr_tFileName found_file;
  int num;
  int sts;
  char cmd[800];
  pwr_tMask current_options = 0;

  dcli_translate_filename(fname, pwr_cNameDistribute);
  std::ifstream is(fname);

  m_sts = PWRB__NOBUILT;

  while (is.getline(line, sizeof(line))) {
    str_trim(line, line);
    if (line[0] == '#' || line[0] == '!')
      continue;

    num = dcli_parse(line, " 	", "", (char*)line_item,
        sizeof(line_item) / sizeof(line_item[0]), sizeof(line_item[0]), 0);
    if (!num)
      continue;

    if (dir && str_NoCaseStrcmp(dir, line_item[1]) != 0)
      continue;

    if (streq(cdh_Low(line_item[0]), "builddir")) {
      if (num != 4) {
        printf("File corrupt " pwr_cNameDistribute);
        continue;
      }
      int sts = sscanf(line_item[2], "%d", &current_options);
      if (sts != 1) {
        printf("File corrupt " pwr_cNameDistribute);
        current_options = 0;
      }
      if (!((pass == bld_ePass_BeforeNode
                && !(current_options & pwr_mBuildDirectoryMask_BuildBeforeNode))
              || (pass == bld_ePass_AfterNode
                     && !(current_options
                            & pwr_mBuildDirectoryMask_BuildAfterNode))))
        wb_log::log(wlog_eCategory_DirectoryBuild, line_item[1], 0);
    } else if (streq(cdh_Low(line_item[0]), "buildcopy")) {
      if (num != 4) {
        printf("File corrupt " pwr_cNameDistribute);
        continue;
      }

      if ((pass == bld_ePass_BeforeNode
              && !(current_options & pwr_mBuildDirectoryMask_BuildBeforeNode))
          || (pass == bld_ePass_AfterNode
                 && !(current_options
                        & pwr_mBuildDirectoryMask_BuildAfterNode)))
        continue;

      for (sts
           = dcli_search_file(line_item[2], found_file, DCLI_DIR_SEARCH_INIT);
           ODD(sts); sts
           = dcli_search_file(line_item[2], found_file, DCLI_DIR_SEARCH_NEXT)) {
        // Check if file should be updated
        int update = 0;
        pwr_tFileName source, target;
        pwr_tFileName target_dir;
        pwr_tTime source_time, target_time;
        char* s;

        strncpy(source, found_file, sizeof(source));
        strncpy(target, line_item[3], sizeof(target));

        sts = dcli_file_time(source, &source_time);

        if (target[strlen(target) - 1] == '/') {
          // Target is a directory, add file name
          char* s = strrchr(source, '/');
          if (!s)
            strncat(target, source, sizeof(target) - strlen(target) - 1);
          else
            strncat(target, s + 1, sizeof(target) - strlen(target) - 1);
        }

        dcli_translate_filename(target, target);
        sts = dcli_file_time(target, &target_time);

        if (ODD(sts) && time_Acomp(&source_time, &target_time) != 1)
          update = 0;
        else
          update = 1;

        if (!opt.force && !update)
          continue;

        if (EVEN(sts)) {
          // Check that directory exist, create if it doesn't
          strcpy(target_dir, target);
          if ((s = strrchr(target_dir, '/'))) {
            *s = 0;
            sts = dcli_file_time(target_dir, &target_time);
            if (EVEN(sts)) {
              sprintf(cmd, "mkdir -p %s", target_dir);
              system(cmd);
            }
          }
        }
        sprintf(cmd, "cp %s %s", source, target);
        system(cmd);
        sprintf(
            cmd, "Build:    copy %s %s -> %s", line_item[1], source, target);
        MsgWindow::message('I', cmd, msgw_ePop_No);

        // wb_log::log( wlog_eCategory_GeBuild, name, 0);
        if (m_sts != PWRB__MAKEUPDATED)
          m_sts = PWRB__SUCCESS;
      }

      dcli_search_file(line_item[1], found_file, DCLI_DIR_SEARCH_END);
    } else if (streq(cdh_Low(line_item[0]), "buildconvert")) {
      pwr_tFileConvertEnum conversion;

      if (num != 5) {
        printf("File corrupt " pwr_cNameDistribute);
        continue;
      }

      if (sscanf(line_item[2], "%d", &conversion) != 1) {
        printf("File corrupt " pwr_cNameDistribute);
        continue;
      }

      if ((pass == bld_ePass_BeforeNode
              && !(current_options & pwr_mBuildDirectoryMask_BuildBeforeNode))
          || (pass == bld_ePass_AfterNode
                 && !(current_options
                        & pwr_mBuildDirectoryMask_BuildAfterNode)))
        continue;

      

      for (sts
           = dcli_search_file(line_item[3], found_file, DCLI_DIR_SEARCH_INIT);
           ODD(sts); sts
           = dcli_search_file(line_item[3], found_file, DCLI_DIR_SEARCH_NEXT)) {
        // Check if file should be updated
        int update = 0;
        pwr_tFileName source, target;
        pwr_tFileName target_dir;
        pwr_tTime source_time, target_time;
        char* s;

        strncpy(source, found_file, sizeof(source));
        strncpy(target, line_item[4], sizeof(target));

        sts = dcli_file_time(source, &source_time);

        if (target[strlen(target) - 1] == '/') {
          // Target is a directory, add file name
          char* s = strrchr(source, '/');
          if (!s)
            strncat(target, source, sizeof(target) - strlen(target) - 1);
          else
            strncat(target, s + 1, sizeof(target) - strlen(target) - 1);
        }

        dcli_translate_filename(target, target);
        sts = dcli_file_time(target, &target_time);

        if (ODD(sts) && time_Acomp(&source_time, &target_time) != 1)
          update = 0;
        else
          update = 1;

        if (!opt.force && !update)
          continue;

        if (EVEN(sts)) {
          // Check that directory exist, create if it doesn't
          strcpy(target_dir, target);
          if ((s = strrchr(target_dir, '/'))) {
            *s = 0;
            sts = dcli_file_time(target_dir, &target_time);
            if (EVEN(sts)) {
              sprintf(cmd, "mkdir -p %s", target_dir);
              system(cmd);
            }
          }
        }
	switch (conversion) {
	case pwr_eFileConvertEnum_No:
	  sprintf(cmd, "cp %s %s", source, target);
	  break;
	case pwr_eFileConvertEnum_ISO88591_UTF8:
	  sprintf(cmd, "iconv -f ISO-8859-1 -t UTF-8 < %s > %s", source, target);
	  break;
	}
        system(cmd);
        sprintf(
            cmd, "Build:    convert %s %s -> %s", line_item[2], source, target);
        MsgWindow::message('I', cmd, msgw_ePop_No);

        // wb_log::log( wlog_eCategory_GeBuild, name, 0);
        if (m_sts != PWRB__MAKEUPDATED)
          m_sts = PWRB__SUCCESS;
      }

      dcli_search_file(line_item[2], found_file, DCLI_DIR_SEARCH_END);
    } else if (streq(cdh_Low(line_item[0]), "buildmake")) {
      if (num != 4) {
        printf("File corrupt " pwr_cNameDistribute);
        continue;
      }

      if ((pass == bld_ePass_BeforeNode
              && !(current_options & pwr_mBuildDirectoryMask_BuildBeforeNode))
          || (pass == bld_ePass_AfterNode
                 && !(current_options
                        & pwr_mBuildDirectoryMask_BuildAfterNode)))
        continue;

      int update = 0;
      if (streq(line_item[3], ""))
        sprintf(cmd, "cd %s;make -q", line_item[2]);
      else
        sprintf(cmd, "cd %s;make -q -f %s", line_item[2], line_item[3]);

      sts = system(cmd);
      if (WEXITSTATUS(sts) != 0)
        update = 1;

      if (!opt.force && !update)
        continue;

      // Needs update
      if (opt.force) {
        // Execute make with -B, unconditionally make all targets
        if (streq(line_item[3], ""))
          sprintf(cmd, "cd %s;make -B", line_item[2]);
        else
          sprintf(cmd, "cd %s;make -B -f %s", line_item[2], line_item[3]);
      } else {
        if (streq(line_item[3], ""))
          sprintf(cmd, "cd %s;make", line_item[2]);
        else
          sprintf(cmd, "cd %s;make -f %s", line_item[2], line_item[3]);
      }
      sts = system(cmd);
      if (WEXITSTATUS(sts) != 0) {
        sprintf(cmd, "Build:    make error %s %s", line_item[2], line_item[3]);
        MsgWindow::message('E', cmd, msgw_ePop_Yes);
        m_sts = PWRB__MAKEERROR;
      } else {
        sprintf(cmd, "Build:    executed %s %s", line_item[2], line_item[3]);
        MsgWindow::message('I', cmd, msgw_ePop_No);
        m_sts = PWRB__MAKEUPDATED;
      }
      // wb_log::log( wlog_eCategory_GeBuild, name, 0);
    } else if (streq(cdh_Low(line_item[0]), "buildexec")) {
      if (num != 4) {
        printf("File corrupt " pwr_cNameDistribute);
        continue;
      }

      if ((pass == bld_ePass_BeforeNode
              && !(current_options & pwr_mBuildDirectoryMask_BuildBeforeNode))
          || (pass == bld_ePass_AfterNode
                 && !(current_options
                        & pwr_mBuildDirectoryMask_BuildAfterNode)))
        continue;

      sprintf(cmd, "cd %s;%s", line_item[2], line_item[3]);
      system(cmd);
      sprintf(cmd, "Build:    executed %s %s", line_item[2], line_item[3]);
      MsgWindow::message('I', cmd, msgw_ePop_No);

      // wb_log::log( wlog_eCategory_GeBuild, name, 0);
      if (m_sts != PWRB__MAKEUPDATED)
        m_sts = PWRB__SUCCESS;
    }
  }

  is.close();
}

void wb_build::export_import_files(int type, bld_ePass pass)
{
  pwr_tFileName fname;
  char line[400];
  char line_item[4][250];
  pwr_tFileName found_file;
  int num;
  int sts;
  char cmd[550];
  char tag[20];
  pwr_tMask current_options = 0;

  if (type == bld_eType_Export)
    strcpy(tag, "export");
  else
    strcpy(tag, "import");

  dcli_translate_filename(fname, pwr_cNameDistribute);
  std::ifstream is(fname);

  m_sts = PWRB__NOBUILT;

  while (is.getline(line, sizeof(line))) {
    str_trim(line, line);
    if (line[0] == '#' || line[0] == '!')
      continue;

    num = dcli_parse(line, " 	", "", (char*)line_item,
        sizeof(line_item) / sizeof(line_item[0]), sizeof(line_item[0]), 0);
    if (!num)
      continue;

    if (streq(cdh_Low(line_item[0]), tag)) {
      if (num != 4) {
        printf("File corrupt " pwr_cNameDistribute);
        continue;
      }

      sts = sscanf(line_item[1], "%d", &current_options);
      if (sts != 1) {
        printf("File corrupt " pwr_cNameDistribute);
        current_options = 0;
      }

      if (type == bld_eType_Import && pass == bld_ePass_BeforeNode
          && ((pass == bld_ePass_BeforeNode
                  && !(current_options
                         & pwr_mBuildDirectoryMask_BuildBeforeNode))
                 || (pass == bld_ePass_AfterNode
                        && !(current_options
                               & pwr_mBuildDirectoryMask_BuildAfterNode))))
        continue;

      if (type == bld_eType_Export
          && ((pass == bld_ePass_BeforeNode
                  && !(current_options & pwr_mBuildExportMask_BuildBeforeNode))
                 || (pass == bld_ePass_AfterNode
                        && !(current_options
                               & pwr_mBuildExportMask_BuildAfterNode))))
        continue;

      for (sts
           = dcli_search_file(line_item[2], found_file, DCLI_DIR_SEARCH_INIT);
           ODD(sts); sts
           = dcli_search_file(line_item[2], found_file, DCLI_DIR_SEARCH_NEXT)) {
        // Check if file should be updated
        int update = 0;
        pwr_tFileName source, target;
        pwr_tTime source_time, target_time;

        strncpy(source, found_file, sizeof(source));
        strncpy(target, line_item[3], sizeof(target));

        sts = dcli_file_time(source, &source_time);

        if (target[strlen(target) - 1] == '/') {
          // Target is a directory, add file name
          char* s = strrchr(source, '/');
          if (!s)
            strncat(target, source, sizeof(target) - strlen(target) - 1);
          else
            strncat(target, s + 1, sizeof(target) - strlen(target) - 1);
        }

        dcli_translate_filename(target, target);
        sts = dcli_file_time(target, &target_time);

        if (ODD(sts) && time_Acomp(&source_time, &target_time) != 1)
          update = 0;
        else
          update = 1;

        if (!opt.force && !update)
          continue;

        sprintf(cmd, "cp %s %s", source, target);
        system(cmd);
        sprintf(cmd, "Build:    %s %s -> %s", tag, source, target);
        MsgWindow::message('I', cmd, msgw_ePop_No);

        // wb_log::log( wlog_eCategory_GeBuild, name, 0);
        m_sts = PWRB__SUCCESS;
      }

      dcli_search_file(line_item[2], found_file, DCLI_DIR_SEARCH_END);
    }
  }

  is.close();
}

// Copy source file to target if needed
void wb_build::update_file(char* dest, char* src)
{
  pwr_tFileName src_fname, dest_fname;
  pwr_tTime dest_time, src_time;

  if (opt.nocopy) {
    m_sts = PWRB__NOBUILT;
    return;
  }

  dcli_translate_filename(src_fname, src);
  m_sts = dcli_file_time(src_fname, &src_time);
  if (oddSts()) {
    dcli_translate_filename(dest_fname, dest);
    m_sts = dcli_file_time(dest_fname, &dest_time);
    if (opt.force || evenSts() || src_time.tv_sec > dest_time.tv_sec) {
      char cmd[520];
      sprintf(cmd, "cp %s %s", src_fname, dest_fname);
      system(cmd);
      sprintf(cmd, "Build:    Copy %s -> %s", src, dest);
      MsgWindow::message('I', cmd, msgw_ePop_No);
      m_sts = PWRB__SUCCESS;
    } else
      m_sts = PWRB__NOBUILT;
  } else
    m_sts = PWRB__NOBUILT;
}
