/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2012 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

#ifndef wb_merep_h
#define wb_merep_h

#include "wb_mvrep.h"
#include "wb_attrname.h"
#include "wb_vrepdbs.h"
#include "co_tree.h"
#include <map>

using namespace std;

class wb_vrep;
class wb_tdrep;
class wb_adrep;
class wb_vrepdb;

typedef struct {
  pwr_tCid    subCid;         /**< Class Id for class attribute */
  pwr_tCid              hostCid;        /**< Class Id for owner class */
  pwr_tUInt32     idx;    /**< Index of offset data */
} merep_sClassAttrKey;

#define merep_cCattOffsetSize 20

typedef struct {
  tree_sNode    n;
  merep_sClassAttrKey key;
  int     numOffset;
  pwr_tUInt32   offset[merep_cCattOffsetSize];
  pwr_tUInt32		flags[merep_cCattOffsetSize];
} merep_sClassAttr;

class wb_merep {

  map<pwr_tVid, wb_mvrep*> m_mvrepdbs;

  wb_erep *m_erep;
  wb_vrep *m_vrep;
  tree_sTable *m_catt_tt;

  typedef map<pwr_tVid, wb_mvrep*>::iterator mvrep_iterator;

public:
  wb_merep( wb_erep *erep, wb_vrep *vrep = 0) : 
    m_erep(erep), m_vrep(vrep), m_catt_tt(0) {}
  ~wb_merep();
  wb_merep(const char *dirname, wb_erep *erep, wb_vrep *vrep = 0);
  wb_merep( const wb_merep& x, wb_vrep *vrep);
  wb_mvrep *volume(pwr_tStatus *sts);
  wb_mvrep *volume(pwr_tStatus *sts, pwr_tVid vid);
  wb_mvrep *volume(pwr_tStatus *sts, const char *name);

  bool compareMeta(const char *dirname, wb_merep *merep);
  void copyFiles(const char *dirname);
  void copyFiles(const char *dirname, wb_merep *merep);
  void checkFiles(wb_vrepdb *db, const char *dirname);

  wb_orep *object(pwr_tStatus *sts, pwr_tOid oid);
  void addDbs( pwr_tStatus *sts, wb_mvrep *mvrep);
  void removeDbs( pwr_tStatus *sts, wb_mvrep *mvrep);

  wb_cdrep *cdrep( pwr_tStatus *sts, const wb_orep& o);
  wb_cdrep *cdrep( pwr_tStatus *sts, pwr_tCid cid);
  wb_cdrep *cdrep( pwr_tStatus *sts, wb_name name);
  wb_tdrep *tdrep( pwr_tStatus *sts, const wb_adrep& a);
  wb_tdrep *tdrep( pwr_tStatus *sts, pwr_tTid tid);
  wb_tdrep *tdrep( pwr_tStatus *sts, wb_name name);

  int getAttrInfoRec( wb_attrname *attr, pwr_eBix bix, pwr_tCid cid, size_t *size,
                      size_t *offset, pwr_tTid *tid, int *elements,
                      pwr_eType *type, int *flags, int level);

  void classDependency( pwr_tStatus *sts, pwr_tCid cid,
      pwr_tCid **lst, pwr_sAttrRef **arlst, int *cnt);
  void classVersion( pwr_tStatus *sts, pwr_tCid cid, pwr_tTime *time);
  tree_sTable *buildCatt( pwr_tStatus *sts);
  void insertCattObject( pwr_tStatus *sts, pwr_tCid cid,
       wb_adrep *adp, int offset);
  tree_sTable *catt_tt() { return m_catt_tt;}
  void subClass( pwr_tCid supercid, pwr_tCid subcid, pwr_tCid *nextsubcid, pwr_tStatus *sts);
  wb_mvrep *nextVolume(pwr_tStatus *sts, pwr_tVid vid);
};

#endif

