/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* wb_wrev.cpp -- package window */

#include <typeinfo>

#include "co_dcli.h"
#include "co_string.h"
#include "co_time.h"

#include "cow_xhelp.h"

#include "wb_build.h"
#include "wb_error.h"
#include "wb_pkg.h"
#include "wb_rev_msg.h"
#include "wb_vrepmem.h"
#include "wb_wrev.h"
#include "wb_wtt.h"

void WRev::message_cb(void* wrev, char severity, const char* message)
{
  ((WRev*)wrev)->message(severity, message);
}

void WRev::set_clock_cursor_cb(void* wrev)
{
  ((WRev*)wrev)->set_clock_cursor();
}

void WRev::reset_cursor_cb(void* wrev)
{
  ((WRev*)wrev)->reset_cursor();
}

//
//  Callbackfunctions from menu entries
//
void WRev::store_ok_cb(WRev* wrev, char* text1, char* text2)
{
  pwr_tStatus sts;

  if (streq(text1, "")) {
    wrev->wow->DisplayError("Syntax Error", "Revision name is missing");
    return;
  }
  if (streq(text2, "")) {
    wrev->wow->DisplayError("Syntax Error", "Description is missing");
    return;
  }

  wrev->set_clock_cursor();

  sts = wrev->wrevnav->rev->create(1, text1, text2);
  if (EVEN(sts))
    wrev->wow->DisplayError("New Revision Error", wnav_get_message(sts));
  wrev->wrevnav->root_objects();
  wrev->reset_cursor();
}

void WRev::activate_store()
{
  char name[80];
  pwr_tStatus sts;

  message(' ', "");

  // Check if new revision is allowed
  sts = wrevnav->rev->create_check();
  if (EVEN(sts)) {
    wow->DisplayError("New Revision Error", "New revision can't be "
                                            "created\nCurrent revision is not "
                                            "at end of branch");
    return;
  }

  // Get next revision number
  wrevnav->rev->next_name(name);

  open_input_dialog(
      "Revision name", "Description", "New Revision", name, "", store_ok_cb);
}

void WRev::activate_restore()
{
  WItemRev** itemlist;
  int item_count;
  int sts;
  char text[200];

  message(' ', "");

  wb_session* session = (wb_session*)ldhses;
  if (session->cid() != pwr_eClass_DirectoryVolume) {
    wow->DisplayError(
        "Restore Error", "Activate Restore from the Directory volume");
    return;
  }

  sts = wrevnav->get_select(&itemlist, &item_count);
  if (EVEN(sts)) {
    message('E', "Select a revision");
    return;
  }

  if (item_count != 1 || typeid(*itemlist[0]) != typeid(WItemRevision)) {
    message('E', "Select one revision");
    free(itemlist);
    return;
  }

  strcpy(text, "Do you want to restore revision ");
  strcat(text, itemlist[0]->name);

  dialog_count++;
  wow->DisplayQuestion(
      this, "Restore revision", text, restore_ok, restore_cancel, itemlist[0]);

  free(itemlist);
}

void WRev::restore_cancel(void* ctx, void* data)
{
  WRev* wrev = (WRev*)ctx;
  wrev->dialog_count--;
}

void WRev::restore_ok(void* ctx, void* data)
{
  WRev* wrev = (WRev*)ctx;
  WItemRev* item = (WItemRev*)data;
  pwr_tStatus sts;

  wrev->dialog_count--;
  wrev->set_clock_cursor();

  sts = wrev->wrevnav->rev->restore(item->name);
  if (EVEN(sts))
    wrev->wow->DisplayError("Restore Error", wnav_get_message(sts));
  else if (sts == REV__NOBRANCH)
    wrev->wow->DisplayText(
        "Restore Info", "No changes can be made to this revision");
  wrev->wrevnav->root_objects();

  wb_session* session = (wb_session*)wrev->ldhses;
  if (session->cid() == pwr_eClass_DirectoryVolume) {
    wb_vrep* vrep = (wb_vrep*)(*session);
    ((wb_vrepmem*)vrep)->reloadWbl(&sts);
    if (((WUtility*)wrev->parent_ctx)->utype == wb_eUtility_WNav)
      ((WNav*)wrev->parent_ctx)->command((char*)"set refresh");
  }
  wrev->reset_cursor();
}

void WRev::delete_cancel(void* ctx, void* data)
{
  WRev* wrev = (WRev*)ctx;
  wrev->dialog_count--;
}
void WRev::delete_ok(void* ctx, void* data)
{
  WRev* wrev = (WRev*)ctx;
  WItemRev* item = (WItemRev*)data;

  wrev->dialog_count--;
  wrev->wrevnav->rev->remove(item->name);
  wrev->wrevnav->root_objects();
}

void WRev::activate_delete()
{
  WItemRev** itemlist;
  int item_count;
  int sts;
  char text[200];

  message(' ', "");

  sts = wrevnav->get_select(&itemlist, &item_count);
  if (EVEN(sts)) {
    message('E', "Select a revision");
    return;
  }

  if (item_count != 1 || typeid(*itemlist[0]) != typeid(WItemRevision)) {
    message('E', "Select one revision");
    free(itemlist);
    return;
  }

  strcpy(text, "Do you want to delete revision ");
  strcat(text, itemlist[0]->name);

  dialog_count++;
  wow->DisplayQuestion(
      this, "Delete revision", text, delete_ok, delete_cancel, itemlist[0]);
}

void WRev::activate_build()
{
  wb_build* build = new wb_build(*(wb_session*)ldhses, (WNav*)parent_ctx);

  build->all(1, 1);
  delete build;
}

void WRev::activate_zoom_in()
{
  double zoom_factor;

  wrevnav->get_zoom(&zoom_factor);
  if (zoom_factor > 40)
    return;

  wrevnav->zoom(1.18);
}

void WRev::activate_zoom_out()
{
  double zoom_factor;

  wrevnav->get_zoom(&zoom_factor);
  if (zoom_factor < 15)
    return;

  wrevnav->zoom(1.0 / 1.18);
}

void WRev::activate_zoom_reset()
{
  wrevnav->unzoom();
}

int WRev::rev_command_cb(void* ctx, char* cmd)
{
  WRev* rev = (WRev*)((WRevNav*)ctx)->parent_ctx;

  if (rev->command_cb)
    return (rev->command_cb)(rev, cmd);
  return 0;
}

WRev::~WRev()
{
}

WRev::WRev(void* wa_parent_ctx, ldh_tSession wa_ldhses)
    : parent_ctx(wa_parent_ctx), ldhses(wa_ldhses), close_cb(0), command_cb(0),
      dialog_count(0)
{
}
