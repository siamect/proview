/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <iostream>

#include "pwr_names.h"
#include "pwr_version.h"

#include "co_string.h"
#include "co_time.h"

#include "wb_lfu.h"
#include "wb_rev_msg.h"
#include "wb_revision.h"
#include "wb_utl_api.h"

wb_rev_item::wb_rev_item()
    : level(0), current(false), current_branch(false), in_manager(false), idx(0)
{
  strcpy(name, "");
  strcpy(description, "");
  strcpy(version, "");
}

wb_rev_item::wb_rev_item(const wb_rev_item& x)
    : level(x.level), date(x.date), current(x.current),
      current_branch(x.current_branch), in_manager(x.in_manager), idx(x.idx),
      vect(x.vect)
{
  strcpy(name, x.name);
  strcpy(description, x.description);
  strcpy(version, x.version);
}

wb_revision::wb_revision(void* parent_ctx, wb_session* ses)
    : m_parent_ctx(parent_ctx), m_session(ses), m_manager(0),
      m_manager_enum(pwr_eVersionManagerEnum_Git), m_read(false),
      m_current_idx(-1), m_current_main_idx(-1), m_current_sub_idx(-1),
      m_next_idx(0), m_command_cb(0)
{
  read_file();

  switch (m_manager_enum) {
  case pwr_eVersionManagerEnum_Git:
    m_manager = new wb_version_manager_git();
    if (EVEN(m_manager->sts())) {
      delete m_manager;
      m_manager = 0;
    }
    break;
  default:;
  }

  if (m_manager) {
    char current_name[80];

    m_sts = m_manager->check(m_vect);

    m_sts = m_manager->get_current(current_name);
    if (ODD(m_sts))
      set_current(current_name);
    else
      set_current(m_current_idx);
  } else {
    set_current(m_current_idx);
  }
}

wb_revision::wb_revision()
    : m_parent_ctx(0), m_session(0), m_manager(0),
      m_manager_enum(pwr_eVersionManagerEnum_None), m_read(false),
      m_current_idx(-1), m_current_main_idx(-1), m_current_sub_idx(-1),
      m_command_cb(0)
{
  read_file_meta();

  switch (m_manager_enum) {
  case pwr_eVersionManagerEnum_Git:
    m_manager = new wb_version_manager_git();
    if (EVEN(m_manager->sts())) {
      delete m_manager;
      m_manager = 0;
    }
    break;
  default:;
  }
}

wb_revision::~wb_revision()
{
  if (m_manager)
    delete m_manager;
}

void* wb_revision::parent_ctx()
{
  return m_parent_ctx;
}

void wb_revision::command_cb(int (*cmd_cb)(void*, char*))
{
  m_command_cb = cmd_cb;
}
wb_rev_item* wb_revision::vect(int idx)
{
  return &m_vect[idx];
}

int wb_revision::size()
{
  return (int)m_vect.size();
}

pwr_eVersionManagerEnum wb_revision::manager_enum()
{
  return m_manager_enum;
}

void wb_revision::set_manager_enum(pwr_eVersionManagerEnum manager_enum)
{
  m_manager_enum = manager_enum;
}

bool wb_revision::set_current(int idx)
{
  bool found = false;

  for (unsigned int i = 0; i < m_vect.size(); i++) {
    if (m_vect[i].idx == idx) {
      m_current_main_idx = i;
      m_current_sub_idx = -1;
      m_vect[i].current = true;
      m_current_idx = idx;
      found = true;
      break;
    }
    for (unsigned int j = 0; j < m_vect[i].vect.size(); j++) {
      if (m_vect[i].vect[j].idx == idx) {
        m_current_main_idx = i;
        m_current_sub_idx = j;
        m_vect[i].vect[j].current = true;
        m_vect[i].current_branch = true;
        m_current_idx = idx;
        found = true;
        break;
      }
    }
    if (found)
      break;
  }
  return found;
}

bool wb_revision::set_current(char* name)
{
  bool found = false;

  for (unsigned int i = 0; i < m_vect.size(); i++) {
    if (str_NoCaseStrcmp(name, m_vect[i].name) == 0) {
      m_current_idx = m_vect[i].idx;
      m_current_main_idx = i;
      m_current_sub_idx = -1;
      m_vect[i].current = true;
      found = true;
      break;
    }
    for (unsigned int j = 0; j < m_vect[i].vect.size(); j++) {
      if (str_NoCaseStrcmp(name, m_vect[i].vect[j].name) == 0) {
        m_current_idx = m_vect[i].vect[j].idx;
        m_current_main_idx = i;
        m_current_sub_idx = j;
        m_vect[i].vect[j].current = true;
        m_vect[i].current_branch = true;
        found = true;
        break;
      }
    }
    if (found)
      break;
  }
  return found;
}

char* wb_revision::branch_name(char* name)
{
  static char bname[80];

  strcpy(bname, "B_");
  strncat(bname, name, sizeof(bname) - strlen(bname) - 1);
  return bname;
}

pwr_tStatus wb_revision::create_check()
{
  // Create is allowed only if current revision is of an end of a branch
  if (m_current_sub_idx == -1 && m_current_main_idx == -1)
    // No revision stored yet
    return REV__SUCCESS;
  if (m_current_sub_idx == -1 && m_current_main_idx == (int)m_vect.size() - 1)
    // Last revision on main
    return REV__SUCCESS;
  if (m_current_sub_idx == -1 && m_vect[m_current_main_idx].vect.size() == 0)
    // Revision on main without any branch yet
    return REV__SUCCESS;
  if (m_current_sub_idx != -1
      && m_current_sub_idx == (int)m_vect[m_current_main_idx].vect.size() - 1)
    // Last revision on a branch
    return REV__SUCCESS;

  // Create not allowed
  return REV__CREATEPOS;
}

pwr_tStatus wb_revision::create(int all, char* name, char* descr)
{
  if (m_manager && !m_manager->modified())
    return REV__NOCHANGE;

  if (all) {
    // Get current volume
    ldh_sVolumeInfo info;
    pwr_tObjName current_volume;
    int has_current_volume = 0;
    int size;
    pwr_tFileName proot;
    pwr_tCmd cmd;
    bool in_main = false;
    int main_idx = 0;
    pwr_tFileName file_spec, found_file;
    pwr_tStatus lsts;

    // Create is allowed only if revision is an end node
    if (m_current_sub_idx == -1 && m_current_main_idx == -1) {
      in_main = true;
    } else if (m_current_sub_idx == -1
        && m_current_main_idx == (int)m_vect.size() - 1) {
      in_main = true;
    } else if (m_current_sub_idx == -1
        && m_vect[m_current_main_idx].vect.size() == 0) {
      main_idx = m_current_main_idx;
    } else if (m_current_sub_idx != -1
        && m_current_sub_idx
            == (int)m_vect[m_current_main_idx].vect.size() - 1) {
      main_idx = m_current_main_idx;
    } else
      return REV__CREATEPOS;

    dcli_translate_filename(proot, "$pwrp_root");

    m_sts = ldh_GetVolumeInfo(ldh_SessionToVol((ldh_tSession)m_session), &info);
    if (EVEN(m_sts))
      return m_sts;

    if (info.Class == pwr_eClass_RootVolume
        || info.Class == pwr_eClass_SubVolume
        || info.Class == pwr_eClass_SharedVolume) {
      m_sts = ldh_VolumeIdToName(ldh_SessionToWB((ldh_tSession)m_session),
          info.Volume, current_volume, sizeof(current_volume), &size);
      has_current_volume = 1;
    }
    if (!has_current_volume)
      sprintf(cmd, "wb_revision.sh create %s", proot);
    else
      sprintf(cmd, "wb_revision.sh create %s %s", proot, current_volume);
    m_sts = system(cmd);
    if (m_sts != 0) {
      if (m_sts >> 8 == 1)
        return REV__VOLLOCK;
      else
        return REV__CREATE;
    }
    if (has_current_volume) {
      // Create revision file for current volume
      sprintf(cmd, "wb dump/nofo/out=\"$pwrp_db/%s.wb_rev\"",
          cdh_Low(current_volume));
      if (m_command_cb)
        m_sts = (m_command_cb)(this, cmd);
    }

    // Commit revision
    if (m_manager) {
      // Check that the wb_rev files are added to repo
      strcpy(file_spec, "$pwrp_db/*.wb_rev");
      for (lsts = dcli_search_file(file_spec, found_file, DCLI_DIR_SEARCH_INIT);
           ODD(lsts);
           lsts = dcli_search_file(file_spec, found_file, DCLI_DIR_SEARCH_NEXT))
        m_manager->check_add(found_file);

      m_sts = m_manager->store_revision(name, descr, in_main);
      if (EVEN(m_sts))
        return m_sts;
    }

    // Add to revision file
    add(name, descr, (char*)pwrv_cPwrVersionStr, 0, in_main, main_idx);
    set_current(m_next_idx - 1);
    write_file();

    wb_log::log(wlog_eCategory_NewRevision, name, descr);
  } else {
    // Create revision for for current volume
    ldh_sVolumeInfo info;
    pwr_tObjName current_volume;
    int size;
    pwr_tCmd cmd;

    m_sts = ldh_GetVolumeInfo(ldh_SessionToVol((ldh_tSession)m_session), &info);
    if (EVEN(m_sts))
      return m_sts;

    if (!(info.Class == pwr_eClass_RootVolume
            || info.Class == pwr_eClass_SubVolume
            || info.Class == pwr_eClass_SharedVolume)) {
      return REV__VOLTYPE;
    }

    m_sts = ldh_VolumeIdToName(ldh_SessionToWB((ldh_tSession)m_session),
        info.Volume, current_volume, sizeof(current_volume), &size);
    sprintf(cmd, "wb dump/nofo/out=\"$pwrp_db/%s.wb_rev\"",
        cdh_Low(current_volume));
    if (m_command_cb)
      m_sts = (m_command_cb)(this, cmd);
  }

  return REV__SUCCESS;
}

pwr_tStatus wb_revision::restore(char* name)
{
  pwr_tFileName db_dir;
  char fname[280];
  int sts;
  pwr_tTime t;
  pwr_tCmd cmd;
  char project_name[80];
  std::vector<lfu_volume_info> vol;
  int main_idx = 0;
  int sub_idx = 0;
  int checkout_master = 0;
  int checkout_branch = 0;
  char branch[80];
  bool no_branch = false;

  // Find revision in table
  bool found = false;
  for (unsigned int i = 0; i < m_vect.size(); i++) {
    if (str_NoCaseStrcmp(m_vect[i].name, name) == 0) {
      main_idx = i;
      sub_idx = -1;
      found = true;
      break;
    }
    for (unsigned int j = 0; j < m_vect[i].vect.size(); j++) {
      if (str_NoCaseStrcmp(m_vect[i].vect[j].name, name) == 0) {
        main_idx = i;
        sub_idx = j;
        found = true;
        break;
      }
    }
    if (found)
      break;
  }

  if (main_idx == (int)m_vect.size() - 1)
    checkout_master = 1;
  else if (sub_idx == -1 && m_vect[main_idx].vect.size() == 0) {
    // Main revision without any branch revisions
    checkout_branch = 1;
    strcpy(branch, branch_name(name));
  } else if (sub_idx == (int)m_vect[main_idx].vect.size() - 1) {
    // End revision on a branch
    checkout_branch = 1;
    strcpy(branch, branch_name(m_vect[main_idx].name));
  } else {
    // A tag is restored
    no_branch = true;
  }

  if (!found)
    return REV__NOSUCHREV;

  // Checkout requested revision
  if (m_manager) {
    m_sts = m_manager->restore_revision(
        name, branch, checkout_master, checkout_branch);
    if (EVEN(m_sts))
      return m_sts;
  }

  dcli_translate_filename(db_dir, "$pwrp_db");
  utl_get_projectname(project_name);

  sts = lfu_GetVolumeCnfAll(vol);

  // Check that no volume is locked
  for (unsigned int i = 0; i < vol.size(); i++) {
    switch (vol[i].cid) {
    case pwr_eClass_RootVolume:
    case pwr_eClass_SubVolume:
    case pwr_eClass_SharedVolume:
    case pwr_eClass_ClassVolume:
    case pwr_eClass_DetachedClassVolume:
      if (vol[i].volrep == ldh_eVolRep_Dbms)
        sprintf(fname, "%s/%s.dbms.lock", db_dir, cdh_Low(vol[i].name));
      else if (vol[i].volrep == ldh_eVolRep_Wbl)
        sprintf(fname, "%s/%s.wb_load.lock", db_dir, cdh_Low(vol[i].name));
      else
        sprintf(fname, "%s/%s.db.lock", db_dir, cdh_Low(vol[i].name));

      if (ODD(dcli_file_time(fname, &t))) {
        printf("** Volume is locked, %s", vol[i].name);
        return REV__VOLLOCK;
      }
      break;
    default:;
    }
  }

  // Check that revision files exist for root, sub and shared volumes
  for (unsigned int i = 0; i < vol.size(); i++) {
    switch (vol[i].cid) {
    case pwr_eClass_RootVolume:
    case pwr_eClass_SubVolume:
    case pwr_eClass_SharedVolume:
      sprintf(fname, "%s/%s.wb_rev", db_dir, cdh_Low(vol[i].name));

      if (EVEN(dcli_file_time(fname, &t))) {
        printf("** Snapshot file is missing, %s, %s", vol[i].name, fname);
        return REV__REVFILE;
      }
      break;
    default:;
    }
  }

  // Build class volumes
  for (unsigned int i = 0; i < vol.size(); i++) {
    switch (vol[i].cid) {
    case pwr_eClass_ClassVolume:
    case pwr_eClass_DetachedClassVolume:
      sprintf(cmd, "create "
                   "snapshot/file=\"$pwrp_db/%s.wb_load\"/out=\"$pwrp_load/"
                   "%s.dbs\"",
          cdh_Low(vol[i].name), cdh_Low(vol[i].name));
      if (m_command_cb)
        sts = (m_command_cb)(this, cmd);
      break;
    default:;
    }
  }

  // Rename old databases
  for (unsigned int i = 0; i < vol.size(); i++) {
    switch (vol[i].cid) {
    case pwr_eClass_RootVolume:
    case pwr_eClass_SubVolume:
    case pwr_eClass_SharedVolume:
      if (vol[i].volrep == ldh_eVolRep_Dbms) {
        sprintf(cmd, "mysqldump -h %s -upwrp pwrp_%s_%s > "
                     "$pwrp_db/%s.dbms/pwrp_%s_%s.mysqldump",
            vol[i].server, project_name, cdh_Low(vol[i].name),
            cdh_Low(vol[i].name), project_name, cdh_Low(vol[i].name));
        system(cmd);

        sprintf(cmd, "mysqladmin -h %s -upwrp drop -f pwrp_%s_%s",
            vol[i].server, project_name, cdh_Low(vol[i].name));
        system(cmd);

        sprintf(cmd, "pwrp_env.sh save file %s/%s.dbms", db_dir,
            cdh_Low(vol[i].name));
        system(cmd);
      } else {
        sprintf(cmd, "pwrp_env.sh save file %s/%s.db", db_dir,
            cdh_Low(vol[i].name));
        system(cmd);
      }
      break;
    default:;
    }
  }

  // Load wbl revision files
  for (unsigned int i = 0; i < vol.size(); i++) {
    switch (vol[i].cid) {
    case pwr_eClass_RootVolume:
    case pwr_eClass_SubVolume:
    case pwr_eClass_SharedVolume:
      sprintf(cmd,
          "wb load/nofocode/load=\"$pwrp_db/%s.wb_rev\"/out=\"$pwrp_db/%s.lis",
          cdh_Low(vol[i].name), cdh_Low(vol[i].name));
      if (m_command_cb)
        (m_command_cb)(this, cmd);
      break;
    default:;
    }
  }

  wb_log::log(wlog_eCategory_RevisionRestore, name, 0);

  if (no_branch)
    return REV__NOBRANCH;

  return REV__SUCCESS;
}

pwr_tStatus wb_revision::build_all()
{
  pwr_tFileName db_dir;
  char fname[280];
  int sts;
  pwr_tTime t;
  pwr_tCmd cmd;
  char project_name[80];
  std::vector<lfu_volume_info> vol;

  dcli_translate_filename(db_dir, "$pwrp_db");
  utl_get_projectname(project_name);

  sts = lfu_GetVolumeCnfAll(vol);

  // Check that no volume is locked
  for (unsigned int i = 0; i < vol.size(); i++) {
    switch (vol[i].cid) {
    case pwr_eClass_RootVolume:
    case pwr_eClass_SubVolume:
    case pwr_eClass_SharedVolume:
    case pwr_eClass_ClassVolume:
    case pwr_eClass_DetachedClassVolume:
      if (vol[i].volrep == ldh_eVolRep_Dbms)
        sprintf(fname, "%s/%s.dbms.lock", db_dir, cdh_Low(vol[i].name));
      else if (vol[i].volrep == ldh_eVolRep_Wbl)
        sprintf(fname, "%s/%s.wb_load.lock", db_dir, cdh_Low(vol[i].name));
      else
        sprintf(fname, "%s/%s.db.lock", db_dir, cdh_Low(vol[i].name));

      if (ODD(dcli_file_time(fname, &t))) {
        printf("** Volume is locked, %s", vol[i].name);
        return REV__VOLLOCK;
      }
      break;
    default:;
    }
  }

  // Build class volumes
  for (unsigned int i = 0; i < vol.size(); i++) {
    switch (vol[i].cid) {
    case pwr_eClass_ClassVolume:
    case pwr_eClass_DetachedClassVolume:
      sprintf(cmd, "create "
                   "snapshot/file=\"$pwrp_db/%s.wb_load\"/out=\"$pwrp_load/"
                   "%s.dbs\"",
          cdh_Low(vol[i].name), cdh_Low(vol[i].name));
      if (m_command_cb)
        sts = (m_command_cb)(this, cmd);
      break;
    default:;
    }
  }

  // Build root, sub and shared volumes
  for (unsigned int i = 0; i < vol.size(); i++) {
    switch (vol[i].cid) {
    case pwr_eClass_RootVolume:
    case pwr_eClass_SubVolume:
    case pwr_eClass_SharedVolume:
      sprintf(cmd, "wb_cmd -v %s build volume/name=%s/force",
          cdh_Low(vol[i].name), vol[i].name);
      system(cmd);
      break;
    default:;
    }
  }

  // Build nodes

  return REV__SUCCESS;
}

pwr_tStatus wb_revision::remove(char* name)
{
  if (!m_read)
    read_file();

  bool found = false;
  for (unsigned int i = 0; i < m_vect.size(); i++) {
    if (str_NoCaseStrcmp(m_vect[i].name, name) == 0) {
      m_vect.erase(m_vect.begin() + i);
      found = true;
      break;
    }
  }

  if (found) {
    write_file();
    return 1;
  }
  return 0;
}

void wb_revision::read_file()
{
  pwr_tFileName fname;
  char line[200];
  char item_array[7][80];
  int sts;

  dcli_translate_filename(fname, pwr_cNameRevision);
  std::ifstream fp(fname, std::ios::in);
  if (!fp) {
    m_read = true;
    return;
  }

  while (fp.getline(line, sizeof(line))) {
    wb_rev_item item;
    int nr;

    nr = dcli_parse(line, " ", "", (char*)item_array,
        sizeof(item_array) / sizeof(item_array[0]), sizeof(item_array[0]), 0);

    if (nr == 3 && streq(item_array[0], "#!")
        && streq(item_array[1], "RevisionManager")) {
      if (streq(item_array[2], "1"))
        m_manager_enum = pwr_eVersionManagerEnum_Git;
      else
        m_manager_enum = pwr_eVersionManagerEnum_None;
      continue;
    }
    if (nr == 3 && streq(item_array[0], "#!")
        && streq(item_array[1], "Current")) {
      int current;
      int num;

      num = sscanf(item_array[2], "%d", &current);
      if (num == 1)
        m_current_idx = current;
      else
        m_current_idx = -1;
      continue;
    }
    if (nr != 6) {
      m_sts = 0;
      return;
    }

    sts = sscanf(item_array[0], "%d", &item.idx);
    if (sts != 1)
      printf("** Syntax error in configuration file\n");
    sts = sscanf(item_array[1], "%d", &item.level);
    if (sts != 1)
      printf("** Syntax error in configuration file\n");
    strncpy(item.name, item_array[2], sizeof(item.name));
    strncpy(item.description, item_array[3], sizeof(item.description));
    strncpy(item.version, item_array[4], sizeof(item.version));
    time_AsciiToA(item_array[5], &item.date);

    if (item.level == 0)
      m_vect.push_back(item);
    else if (m_vect.size() > 0)
      m_vect[m_vect.size() - 1].vect.push_back(item);

    if (m_next_idx < item.idx + 1)
      m_next_idx = item.idx + 1;
  }
  fp.close();

  m_read = true;
}

void wb_revision::read_file_meta()
{
  pwr_tFileName fname;
  char line[200];
  char item_array[6][80];

  dcli_translate_filename(fname, pwr_cNameRevision);
  std::ifstream fp(fname, std::ios::in);
  if (!fp) {
    m_read = true;
    return;
  }

  while (fp.getline(line, sizeof(line))) {
    wb_rev_item item;
    int nr;

    nr = dcli_parse(line, " ", "", (char*)item_array,
        sizeof(item_array) / sizeof(item_array[0]), sizeof(item_array[0]), 0);

    if (nr == 3 && streq(item_array[0], "#!")
        && streq(item_array[1], "RevisionManager")) {
      if (streq(item_array[2], "1"))
        m_manager_enum = pwr_eVersionManagerEnum_Git;
      else
        m_manager_enum = pwr_eVersionManagerEnum_None;
      continue;
    }
    if (nr == 3 && streq(item_array[0], "#!")
        && streq(item_array[1], "Current")) {
      int current;
      int num;

      num = sscanf(item_array[2], "%d", &current);
      if (num == 1)
        m_current_idx = current;
      else
        m_current_idx = -1;
      continue;
    }
    if (!streq(item_array[0], "#!"))
      break;
  }
  fp.close();
}

void wb_revision::write_file()
{
  pwr_tFileName fname;
  char timestr[40];

  if (!m_read)
    return;

  dcli_translate_filename(fname, pwr_cNameRevision);
  std::ofstream fp(fname, std::ios::out);
  if (!fp) {
    m_sts = 0;
    return;
  }

  fp << "#! RevisionManager " << m_manager_enum << '\n';
  fp << "#! Current " << m_current_idx << '\n';
  for (unsigned int i = 0; i < m_vect.size(); i++) {
    time_AtoAscii(
        &m_vect[i].date, time_eFormat_DateAndTime, timestr, sizeof(timestr));

    fp << m_vect[i].idx << " " << m_vect[i].level << " " << m_vect[i].name
       << " "
       << " \"" << m_vect[i].description << "\" " << m_vect[i].version << " \""
       << timestr << "\"\n";

    for (unsigned int j = 0; j < m_vect[i].vect.size(); j++) {
      time_AtoAscii(&m_vect[i].vect[j].date, time_eFormat_DateAndTime, timestr,
          sizeof(timestr));
      fp << m_vect[i].vect[j].idx << " " << m_vect[i].vect[j].level << " "
         << m_vect[i].vect[j].name << " "
         << " \"" << m_vect[i].vect[j].description << "\" "
         << m_vect[i].vect[j].version << " \"" << timestr << "\"\n";
    }
  }
  fp.close();
}

int wb_revision::add(char* name, char* description, char* version,
    pwr_tTime* date, bool in_main, int sub_idx)
{
  wb_rev_item item;

  if (!m_read)
    read_file();

  // Check that the name is unique
  for (unsigned int i = 0; i < m_vect.size(); i++) {
    if (str_NoCaseStrcmp(name, m_vect[i].name) == 0) {
      return 0;
    }
  }

  strncpy(item.name, name, sizeof(item.name));
  strncpy(item.description, description, sizeof(item.description));
  strncpy(item.version, version, sizeof(item.version));
  if (date)
    item.date = *date;
  else
    time_GetTime(&item.date);
  item.idx = m_next_idx++;

  if (in_main) {
    item.level = 0;
    m_vect.push_back(item);
  } else {
    item.level = 1;
    m_vect[sub_idx].vect.push_back(item);
  }
  return 1;
}

void wb_revision::list()
{
  char timestr[40];

  if (!m_read)
    read_file();

  std::cout << '\n';
  for (unsigned int i = 0; i < m_vect.size(); i++) {
    time_AtoAscii(
        &m_vect[i].date, time_eFormat_DateAndTime, timestr, sizeof(timestr));
    if (m_current_idx == (int)i)
      std::cout << "** ";
    else if (!m_vect[i].in_manager)
      std::cout << "!! ";
    else
      std::cout << "   ";
    for (int j = 0; j < m_vect[i].level; j++)
      std::cout << " ";
    std::cout << " " << m_vect[i].name << "  "
              << " " << m_vect[i].description << "  " << m_vect[i].version
              << "  " << timestr << '\n';
  }
  std::cout << '\n';
}

wb_rev_item* wb_revision::current()
{
  if (m_current_main_idx == -1 && m_current_sub_idx == -1)
    return 0;
  if (m_current_sub_idx == -1)
    return &m_vect[m_current_main_idx];
  return &m_vect[m_current_main_idx].vect[m_current_sub_idx];
}

void wb_revision::get_info(wb_rev_info* info)
{
  info->in_master = false;
  info->in_end_of_branch = false;

  if (m_current_main_idx == -1) {
    strcpy(info->name, "");
    info->in_end_of_branch = true;
    info->in_master = true;
  } else if (m_current_sub_idx == -1) {
    strcpy(info->name, m_vect[m_current_main_idx].name);
    if (m_vect[m_current_main_idx].vect.size() == 0)
      info->in_end_of_branch = true;
    if (m_current_main_idx == (int)m_vect.size() - 1) {
      info->in_end_of_branch = true;
      info->in_master = true;
    }
  } else {
    strcpy(info->name, m_vect[m_current_main_idx].vect[m_current_sub_idx].name);
    if (m_current_sub_idx == (int)m_vect[m_current_main_idx].vect.size() - 1)
      info->in_end_of_branch = true;
  }
}

pwr_tStatus wb_revision::info(wb_rev_info* info)
{
  pwr_tFileName fname;
  pwr_tStatus sts;
  pwr_tTime time;

  dcli_translate_filename(fname, pwr_cNameRevision);
  sts = dcli_file_time(fname, &time);
  if (EVEN(sts))
    return sts;

  wb_revision* rev = new wb_revision(0, 0);
  rev->get_info(info);
  delete rev;

  return REV__SUCCESS;
}

//
// Suggest next revision name
//
void wb_revision::next_name(char* name)
{
  char str[80];
  int num;
  int sts;

  if (m_vect.size() == 0) {
    // First version
    strcpy(name, "V1.0.0");
    return;
  }

  if (m_current_sub_idx == -1 && m_current_main_idx != (int)m_vect.size() - 1) {
    // New branch, add '-1'
    sprintf(name, "%s-1", m_vect[m_current_main_idx].name);
    return;
  }

  // Increment last number
  if (m_current_sub_idx == -1)
    strcpy(str, m_vect[m_current_main_idx].name);
  else
    strcpy(str, m_vect[m_current_main_idx].vect[m_current_sub_idx].name);
  for (char* s = &str[strlen(str) - 1]; s >= str; s--) {
    switch (*s) {
    case '.':
    case '-':
      sts = sscanf(s + 1, "%d", &num);
      if (sts == 1) {
        *(s + 1) = 0;
        sprintf(&str[strlen(str)], "%d", num + 1);
        strcpy(name, str);
        return;
      }
    default:;
    }
  }
  strcpy(name, "");
}

int wb_revision::check_add_file(char* filename)
{
  wb_revision rev;
  if (rev.m_manager)
    return rev.m_manager->check_add(filename);
  return 0;
}

wb_version_manager::wb_version_manager() : m_sts(0)
{
}

pwr_tStatus wb_version_manager::sts()
{
  return m_sts;
}

wb_version_manager::~wb_version_manager()
{
}

void wb_version_manager::init()
{
}

int wb_version_manager::store_revision(char* name, char* descr, bool new_branch)
{
  return 0;
}

int wb_version_manager::restore_revision(
    char* name, char* branch, int checkout_master, int checkout_branch)
{
  return 0;
}

int wb_version_manager::get_current(char* name)
{
  return 0;
}

int wb_version_manager::check(std::vector<wb_rev_item>& v)
{
  return 0;
}

int wb_version_manager::check_add(char* filename)
{
  return 0;
}

bool wb_version_manager::modified()
{
  return true;
}

bool wb_version_manager_git::m_found = false;
bool wb_version_manager_git::m_found_tested = false;

bool wb_version_manager_git::git_found()
{
  if (!m_found_tested) {
    int sts;

    sts = system("git --version > /dev/null 2> /dev/null");
    m_found = (sts == 0);
    m_found_tested = true;
    if (!m_found)
      m_sts = REV__NOGIT;
  }
  return m_found;
}

void wb_version_manager_git::init()
{
  pwr_tFileName fname;
  pwr_tTime t;
  bool new_git = false;

  if (!git_found())
    return;

  dcli_translate_filename(m_git_dir, "$pwrp_root/src/.git");
  dcli_translate_filename(m_work_tree, "$pwrp_root/src");
  if (EVEN(dcli_file_time(m_git_dir, &t))) {
    // No git repository found, init git

    system("git init $pwrp_root/src");
    new_git = true;
  }
  dcli_translate_filename(fname, "$pwrp_root/src/.gitignore");
  if (EVEN(dcli_file_time(fname, &t))) {
    std::ofstream fp(fname, std::ios::out);
    if (!fp)
      return;

    fp << "\
# Ignore editor journal files\n\
*~\n\
*#*\n\
# Ignore databases\n\
t.*\n\
*.t\n\
*.out\n\
*.db\n\
*.db.*\n\
*.db.lock\n\
*.db/*\n\
# Other temporary files\n\
*.gc\n\
*.gjl\n\
*.o\n\
plc_*_[0-9][0-9]]0-9][0-9]_*\n\
*.a\n\
pwrp_cnf_*.dat\n\
ld_appl_*.txt\n\
ld_boot_*.dat\n\
ld_node_*.dat\n\
*.dbs\n\
*.wb_dmp\n\
*.wb_load.*\n\
*.wb_dmp.*\n\
plc_*.opt_template\n\
plc_v*.dat\n\
*.log\n\
*.bck\n\
initdir.pwr_com\n\
initvol.pwr_com\n\
db/rt_eventlog_info.txt"
       << '\n';
  }

  if (new_git) {
    char cmd[570];
    snprintf(cmd, sizeof(cmd), "git --git-dir=%s --work-tree=%s add .",
        m_git_dir, m_work_tree);
    system(cmd);

    snprintf(cmd, sizeof(cmd),
        "git --git-dir=%s --work-tree=%s commit -m \"Initial commit\" -a",
        m_git_dir, m_work_tree);
    system(cmd);
  }
  m_sts = REV__SUCCESS;
}

int wb_version_manager_git::store_revision(
    char* name, char* descr, bool new_branch)
{
  char cmd[560];
  int sts;

  // Commit all changes
  snprintf(cmd, sizeof(cmd),
      "git --git-dir=%s --work-tree=%s commit -m \"%s\" -a", m_git_dir,
      m_work_tree, descr);

  sts = system(cmd);
  if (sts != 0) {
    printf("** Error from git commit %d\n", sts >> 8);
    return REV__GITERROR;
  }

  // Tag last commit
  snprintf(cmd, sizeof(cmd), "git --git-dir=%s --work-tree=%s tag \"%s\"\n",
      m_git_dir, m_work_tree, name);

  sts = system(cmd);
  if (sts != 0) {
    printf("** Error from git tag %d\n", sts >> 8);
    return REV__GITERROR;
  }

  if (new_branch) {
    // Create branch on last commit
    snprintf(cmd, sizeof(cmd),
        "git --git-dir=%s --work-tree=%s branch \"%s\"\n", m_git_dir,
        m_work_tree, wb_revision::branch_name(name));

    sts = system(cmd);
    if (sts != 0) {
      printf("** Error from git branch %d\n", sts >> 8);
      return REV__GITERROR;
    }
  }

  return REV__SUCCESS;
}

int wb_version_manager_git::restore_revision(
    char* name, char* branch, int checkout_master, int checkout_branch)
{
  char cmd[560];
  int sts;

  if (checkout_master) {
    // Checkout master branch
    snprintf(cmd, sizeof(cmd),
        "git --git-dir=%s --work-tree=%s checkout master", m_git_dir,
        m_work_tree);
  } else if (checkout_branch) {
    // Checkout supplied branch
    snprintf(cmd, sizeof(cmd),
        "git --git-dir=%s --work-tree=%s checkout \"%s\"", m_git_dir,
        m_work_tree, branch);
  } else {
    // Checkout supplied tag
    snprintf(cmd, sizeof(cmd),
        "git --git-dir=%s --work-tree=%s checkout \"%s\"", m_git_dir,
        m_work_tree, name);
  }

  sts = system(cmd);
  if (sts != 0) {
    printf("** Error from git checkout %d\n", sts >> 8);
    return REV__GITERROR;
  }
  return REV__SUCCESS;
}

int wb_version_manager_git::get_current(char* name)
{
  char cmd[840];
  int sts;
  pwr_tFileName fname = "$pwrp_tmp/current_tag.dat";
  char line[80];

  dcli_translate_filename(fname, fname);

  // Get current tag
  snprintf(cmd, sizeof(cmd), "git --git-dir=%s --work-tree=%s describe --tags "
                             "--abbrev=0 > %s 2>/dev/null",
      m_git_dir, m_work_tree, fname);
  sts = system(cmd);
  if (sts != 0) {
    // printf( "** Error from git describe %d\n", sts >> 8);
    return REV__GITERROR;
  }

  std::ifstream fp(fname, std::ios::in);
  if (!fp)
    return 0;

  if (!fp.getline(line, sizeof(line)))
    return 0;

  strcpy(name, line);
  fp.close();

  snprintf(cmd, sizeof(cmd), "rm -f %s", fname);
  system(cmd);

  return REV__SUCCESS;
}

int wb_version_manager_git::check(std::vector<wb_rev_item>& v)
{
  char cmd[810];
  int sts;
  pwr_tFileName fname = "$pwrp_tmp/git_tags.dat";
  char line[80];

  if (!git_found())
    return REV__NOGIT;

  dcli_translate_filename(fname, fname);

  // Get current tag
  snprintf(cmd, sizeof(cmd), "git --git-dir=%s --work-tree=%s tag > %s",
      m_git_dir, m_work_tree, fname);
  sts = system(cmd);
  if (sts != 0) {
    printf("** Error from git tag %d\n", sts >> 8);
    return REV__GITERROR;
  }

  std::ifstream fp(fname, std::ios::in);
  if (!fp)
    return 0;

  for (unsigned int i = 0; i < v.size(); i++) {
    v[i].in_manager = false;
    for (unsigned int j = 0; j < v[i].vect.size(); j++)
      v[i].vect[j].in_manager = false;
  }

  while (fp.getline(line, sizeof(line))) {
    for (unsigned int i = 0; i < v.size(); i++) {
      if (str_NoCaseStrcmp(v[i].name, line) == 0) {
        v[i].in_manager = true;
        break;
      }
      for (unsigned int j = 0; j < v[i].vect.size(); j++) {
        if (str_NoCaseStrcmp(v[i].vect[j].name, line) == 0) {
          v[i].vect[j].in_manager = true;
          break;
        }
      }
    }
  }
  fp.close();

  snprintf(cmd, sizeof(cmd), "rm -f %s", fname);
  system(cmd);

  return REV__SUCCESS;
}

int wb_version_manager_git::check_add(char* filename)
{
  char cmd[850];
  pwr_tFileName fname;
  int sts;

  dcli_translate_filename(fname, filename);

  sprintf(cmd, "git --git-dir=%s --work-tree=%s ls-files --error-unmatch %s "
               ">/dev/null 2>/dev/null",
      m_git_dir, m_work_tree, fname);
  sts = system(cmd);
  if (sts == 0)
    // File exist in repo
    return 1;

  sprintf(cmd, "git --git-dir=%s --work-tree=%s add %s", m_git_dir, m_work_tree,
      fname);
  sts = system(cmd);
  if (sts != 0)
    printf("** Git add error %d\n", sts);

  return 1;
}

bool wb_version_manager_git::modified()
{
  int sts;

  sts = system("git diff --exit-code");
  return sts != 0;
}
