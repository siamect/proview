/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2018 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#ifndef wb_wblnode_h
#define wb_wblnode_h

#include "wb_name.h"
#include "wb_wbl_parser.h"
#include "wb_wblfile.h"

class wb_wblnode;
class wb_vrepwbl;
class wb_vrep;
class wb_dbs;
class wb_import;
class wb_treeimport;

typedef enum {
  wbl_eNodeType_No,
  wbl_eNodeType_Type,
  wbl_eNodeType_TypeDef,
  wbl_eNodeType_ClassDef,
  wbl_eNodeType_ObjBodyDef,
  wbl_eNodeType_Attribute,
  wbl_eNodeType_BodyNode,
  wbl_eNodeType_AttrNode,
  wbl_eNodeType_Template,
  wbl_eNodeType_Volume,
  wbl_eNodeType_Buffer,
  wbl_eNodeType_Code
} wbl_eNodeType;

typedef wb_wblnode* ref_wblnode;

typedef struct {
  const char* sym;
  int value;
} wbl_sSym;

class wbl_class {
public:
  wbl_class() : cid(0), cix(0), templ(0), code(0)
  {
  }
  pwr_tCid cid;
  int cix;
  ref_wblnode templ;
  ref_wblnode code;
};

class wbl_type {
public:
  wbl_type() : tid(0), type(pwr_eType_), elements(0), size(0)
  {
  }
  pwr_tTid tid;
  pwr_eType type;
  int elements;
  size_t size;
};

class wbl_body {
public:
  wbl_body() : bix(pwr_eBix__), size(0)
  {
  }
  pwr_eBix bix;
  size_t size;
};

class wbl_attribute {
public:
  wbl_attribute() : tid(0), size(0), offset(0), elements(0), flags(0), index(0)
  {
  }
  pwr_tTid tid;
  size_t size;
  size_t offset;
  int elements;
  int flags;
  int index;
  pwr_eType type;
};

class wbl_template {
public:
  wbl_template() : created(0)
  {
  }
  bool created;
};

class wbl_object {
public:
  wbl_object();
  ~wbl_object()
  {
    if (rbody_size)
      free(rbody);
    if (dbody_size)
      free(dbody);
  }

  size_t rbody_size;
  size_t dbody_size;
  void* rbody;
  void* dbody;
  pwr_tCid m_cid;
  pwr_tTid m_tid;
  pwr_tOid m_oid;
  pwr_tTime m_ohtime;
  pwr_tTime m_rbtime;
  pwr_tTime m_dbtime;
  char cname[32];
  pwr_mClassDef m_flags;
  wb_wblnode* fth;
  wb_wblnode* bws;
  wb_wblnode* fws;
  wb_wblnode* fch;
  wb_wblnode* docblock;
  int is_built;

  wbl_class c;
  wbl_type ty;
  wbl_body b;
  wbl_attribute a;
  wbl_template templ;
};

class wb_wblnode : public wbl_ast_node {
  friend class wb_vrepwbl;

public:
  wb_wblnode() : node_type(wbl_eNodeType_No), file(0), o(0)
  {
  }
  ~wb_wblnode()
  {
    if (o)
      delete o;
  }

  void info(int level);
  wb_wblnode* getFirstChild()
  {
    return (wb_wblnode*)fch;
  }
  wb_wblnode* getNextSibling()
  {
    return (wb_wblnode*)fws;
  }
  void setNextSibling(wb_wblnode* n)
  {
    n->fws = fws;
    fws = n;
    if (fth->lch == this)
      fth->lch = n;
  }
  void setFirstChild(wb_wblnode* c)
  {
    if (fch)
      c->fws = fch;
    else
      lch = c;
    fch = c;
  }
  bool isType()
  {
    return (node_type == wbl_eNodeType_Type);
  }
  bool isTypeDef()
  {
    return (node_type == wbl_eNodeType_TypeDef);
  }
  bool isClassDef()
  {
    return (node_type == wbl_eNodeType_ClassDef);
  }
  bool isObjBodyDef()
  {
    return (node_type == wbl_eNodeType_ObjBodyDef);
  }
  bool isAttribute()
  {
    return (node_type == wbl_eNodeType_Attribute);
  }
  bool isBodyNode()
  {
    return (node_type == wbl_eNodeType_BodyNode);
  }
  bool isAttrNode()
  {
    return (node_type == wbl_eNodeType_AttrNode);
  }
  bool isTemplate()
  {
    return (node_type == wbl_eNodeType_Template);
  }
  bool isCode()
  {
    return (node_type == wbl_eNodeType_Code);
  }
  bool isVolume()
  {
    return (node_type == wbl_eNodeType_Volume);
  }
  bool isBuffer()
  {
    return (node_type == wbl_eNodeType_Buffer);
  }

  void setFile(wb_wblfile* f);
  char* getFileName()
  {
    static char r[] = "";
    if (file)
      return file->file_name;
    else
      return r;
  }
  pwr_tTime getFileTime()
  {
    if (file)
      return file->time;
    else {
      pwr_tTime t = { 0, 0 };
      return t;
    }
  }
  void registerNode(wb_vrepwbl* vol);
  void build(bool recursive);
  void postBuild();
  void buildObjBodyDef(ref_wblnode classdef);
  void buildAttribute(ref_wblnode classdef, ref_wblnode objbodydef, int* bindex,
      size_t* boffset);
  void buildBuffer(ref_wblnode classdef, ref_wblnode objbodydef, int* bindex,
      size_t* boffset);
  void buildTemplate(ref_wblnode classdef);
  void buildBody(ref_wblnode object);
  void buildAttr(ref_wblnode object, pwr_eBix bix);
  void buildBuff(ref_wblnode object, pwr_eBix bix, pwr_tCid buffer_cid,
      int buffer_offset, int buffer_size);
  void buildBuffAttr(ref_wblnode object, pwr_eBix bix, pwr_tCid buffer_cid,
      size_t buffer_offset, size_t buffer_size);
  void link(
      wb_vrepwbl* vol, ref_wblnode father_node, ref_wblnode parent_ast = 0);
  void info_link(int level);
  ref_wblnode find(wb_name* oname, int level);
  ref_wblnode get_o_lch();
  int classNameToCid(char* cname, pwr_tCid* cid);
  int stringToOix(const char* buf, pwr_tOix* oix) const;
  int stringToTime(const char* buf, pwr_tTime* time) const;
  pwr_tCid Cid()
  {
    return o->c.cid;
  }
  int attrStringToValue(int type_id, char* value_str, void* buffer_ptr,
      size_t buff_size, size_t attr_size);

  bool exportHead(wb_import& i);
  bool exportDbody(wb_import& i);
  bool exportRbody(wb_import& i);
  bool exportDocBlock(wb_import& i);
  bool exportTree(wb_treeimport& i, bool isRoot);

  static int lookup(int* type, const char* keyword, wbl_sSym* table);
  static int convconst(int* val, char* str);
  const char* name()
  {
    return getText();
  }
  bool docBlock(char** block, int* size) const;

  wbl_eNodeType node_type;
  wb_vrepwbl* m_vrep;
  wb_wblfile* file;

  wbl_object* o;
};

#endif
