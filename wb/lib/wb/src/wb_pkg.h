/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#ifndef wb_pkg_h
#define wb_pkg_h

#include "wb_lfu.h"

class pkg_node;

class pkg_file {
  friend class pkg_node;

private:
  char m_source[200];
  char m_target[200];
  char m_arname[80];
  pwr_tTime m_date;

public:
  pkg_file(char* source, char* target);
  char* source()
  {
    return m_source;
  }
  char* target()
  {
    return m_target;
  }
  pwr_tTime date()
  {
    return m_date;
  }
};

class pkg_pattern {
  friend class pkg_node;

private:
  char m_source[200];
  char m_target[200];
  std::vector<pkg_file> m_filelist;
  pkg_node* m_node;
  char m_severity;

public:
  pkg_pattern(const char* source, const char* target, char severity = 'W');
  pkg_pattern(const char* source);
  pkg_pattern(const pkg_pattern& x);
  char* source()
  {
    return m_source;
  }
  char* target()
  {
    return m_target;
  }
  bool hasTarget()
  {
    return m_target[0] != 0;
  }
  void fetchFiles();
  void node(pkg_node* node)
  {
    m_node = node;
  }
};

class pkg_volume {
  friend class pkg_node;

private:
  char m_name[80];
  char m_filename[200];
  pwr_tVid m_vid;
  pwr_tTime m_time;
  bool m_isSystem;

public:
  pkg_volume(char* name, char* filename, pwr_tVid vid, pwr_tTime time);
};

class pkg_depnode {
  friend class pkg_node;

private:
  char m_nodename[40];
  char m_project[40];

public:
  pkg_depnode(char* nodename, char* project);
};

class pkg_node {
private:
  std::vector<pkg_pattern> m_pattern;
  std::vector<pkg_file> m_filelist;
  std::vector<pkg_volume> m_volumelist;
  std::vector<pkg_depnode> m_depnodelist;
  char m_name[80];
  char m_bootnode[80];
  pwr_mOpSys m_opsys;
  int m_bus;
  pwr_tMask m_dstatus;
  bool m_valid;
  int m_errors;
  int m_warnings;
  char m_user[80];
  char m_custom_platform[80];
  char m_tmpdir[80];
  char m_blddir[80];

public:
  pkg_node(char* name);
  pkg_node(char* name, pwr_mOpSys opsys, int bus, pwr_tMask dstatus,
      char* bootnode, char* custom_platform);
  char* name()
  {
    return m_name;
  }
  pwr_mOpSys opsys()
  {
    return m_opsys;
  }
  int bus()
  {
    return m_bus;
  }
  pwr_tMask dstatus()
  {
    return m_dstatus;
  }
  char* bootnode()
  {
    return m_bootnode;
  }
  char* customPlatform()
  {
    return m_custom_platform;
  }
  bool valid()
  {
    return m_valid;
  }
  void setOpsys(pwr_mOpSys opsys)
  {
    m_opsys = opsys;
  }
  void setBus(int bus)
  {
    m_bus = bus;
  }
  void setDStatus(pwr_tMask dstatus)
  {
    m_dstatus = dstatus;
  }
  void setBootnode(char* bootnode);
  void setCustomPlatform(char* custom_platform);
  void setValid()
  {
    m_valid = true;
  }
  void push_back(pkg_pattern& pattern)
  {
    pattern.node(this);
    m_pattern.push_back(pattern);
  }
  void depnodeAdd(pkg_depnode& depnode)
  {
    m_depnodelist.push_back(depnode);
  }
  void checkVolume(char* filename);
  void checkNode();
  void fetchFiles(bool distribute);
  int compareFiles();
  void copyPackage(char* pkg_name);
  void incrWarnings()
  {
    m_warnings++;
  }
  void incrErrors()
  {
    m_errors++;
  }
};

class wb_pkg {
private:
  std::vector<pkg_node> m_nodelist;
  bool m_allnodes;

  void readConfig();

public:
  wb_pkg(char* nodelist, bool distribute = true, bool config_only = false,
      bool check = false, int* new_files = 0);
  pkg_node& getNode(char* name);
  void fetchFiles(bool distribute)
  {
    for (int i = 0; i < (int)m_nodelist.size(); i++)
      m_nodelist[i].fetchFiles(distribute);
  }

  static void copyPackage(char* pkg_name);
};

#endif
