/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include "co_string.h"

#include "wb_adrep.h"
#include "wb_bdrep.h"
#include "wb_cdrep.h"
#include "wb_merep.h"

void wb_bdrep::unref()
{
  if (--m_nRef == 0)
    delete this;
}

wb_bdrep* wb_bdrep::ref()
{
  m_nRef++;
  return this;
}

wb_bdrep::wb_bdrep(wb_orep& o)
    : m_nRef(0), m_orep(&o), m_sts(LDH__SUCCESS), m_merep(0)
{
  m_orep->ref();
}

wb_bdrep::wb_bdrep(wb_adrep* adrep) : m_nRef(0), m_merep(0)
{
  pwr_tStatus sts;
  m_orep = adrep->m_orep->parent(&sts);
  if (EVEN(sts))
    throw wb_error(sts);
  m_sts = LDH__SUCCESS;
}

wb_bdrep::~wb_bdrep()
{
  m_orep->unref();
}

wb_adrep* wb_bdrep::adrep(pwr_tStatus* sts)
{
  wb_orep* orep = m_orep->vrep()->first(sts, m_orep);
  if (EVEN(*sts))
    return 0;

  return new wb_adrep(*orep);
}

wb_adrep* wb_bdrep::adrep(pwr_tStatus* sts, const char* aname)
{
  wb_attrname n(aname);
  if (n.evenSts()) {
    *sts = n.sts();
    return 0;
  }

  wb_bdrep* bd = this;
  wb_adrep* adrep = 0;
  wb_adrep* old = 0;

  for (int i = 0; i < n.attributes(); i++) {
    bool next_attr = false;
    wb_name an(n.attribute(i));
    wb_orep* orep = bd->m_orep->vrep()->child(sts, bd->m_orep, an);
    while (EVEN(*sts)) {
      // Try Super attribute
      orep = bd->m_orep->vrep()->first(sts, bd->m_orep);
      if (EVEN(*sts)) {
        if (bd != this)
          delete bd;
        if (adrep)
          delete adrep;
        return 0;
      }

      if (str_NoCaseStrcmp(orep->name(), "Super") == 0) {
        if (adrep)
          old = adrep;

        adrep = new wb_adrep(*orep);
        if (old)
          adrep->add(old);
        delete old;

        wb_cdrep* cd = m_orep->vrep()->merep()->cdrep(sts, adrep->subClass());
        if (EVEN(*sts))
          return 0;

        if (bd != this)
          delete bd;
        bd = cd->bdrep(sts, pwr_eBix_rt);
        if (EVEN(*sts)) {
          delete cd;
          return 0;
        }

        delete cd;

        orep = bd->m_orep->vrep()->child(sts, bd->m_orep, an);
      } else {
        if (adrep && adrep->flags() & PWR_MASK_CASTATTR && n.hasSuper()) {
          // Allow additional super attributesegement for casted attributes
          next_attr = true;
          break;
        }
        orep->ref();
        orep->unref();
        *sts = LDH__NOSUCHATTR;
        return 0;
      }
    }
    if (next_attr)
      continue;
    if (adrep)
      old = adrep;

    adrep = new wb_adrep(*orep);
    if (i != 0) {
      if (n.hasAttrIndex(i - 1))
        adrep->add(old, n.attrIndex(i - 1));
      else
        adrep->add(old);
      delete old;
    }
    if (n.hasAttrIndex(i)
        && (n.attrIndex(i) >= adrep->nElement() || n.attrIndex(i) < 0)) {
      *sts = LDH__ATTRINDEX;
      return 0;
    }

    if ((i != n.attributes() - 1) && adrep->isClass()) {
      wb_cdrep* cd;
      if (m_merep)
        cd = m_merep->cdrep(sts, adrep->subClass());
      else
        cd = m_orep->vrep()->merep()->cdrep(sts, adrep->subClass());
      if (EVEN(*sts))
        return 0;

      if (bd != this)
        delete bd;
      bd = cd->bdrep(sts, pwr_eBix_rt);
      if (EVEN(*sts)) {
        delete cd;
        return 0;
      }

      delete cd;
    } else if ((i != n.attributes() - 1) && !adrep->isClass()) {
      // To many attribute
      delete adrep;
      *sts = LDH__NOSUCHATTR;
      return 0;
    }
  }

  return adrep;
}

wb_adrep* wb_bdrep::super(pwr_tStatus* sts)
{
  if (bix() != pwr_eBix_rt) {
    *sts = LDH__NOSUCHATTR;
    return 0;
  }

  wb_orep* orep = m_orep->vrep()->first(sts, m_orep);
  if (EVEN(*sts))
    return 0;

  if (str_NoCaseStrcmp(orep->name(), "Super") != 0) {
    *sts = LDH__NOSUCHATTR;
    orep->ref();
    orep->unref();
    return 0;
  }

  wb_adrep* adrep = new wb_adrep(*orep);
  return adrep;
}

pwr_eBix wb_bdrep::bix()
{
  return cdh_oixToBix(m_orep->oid().oix);
}

size_t wb_bdrep::size()
{
  pwr_tStatus sts;
  pwr_sObjBodyDef body;

  m_orep->vrep()->readBody(&sts, m_orep, pwr_eBix_sys, (void*)&body);
  if (EVEN(sts))
    throw wb_error(sts);

  return body.Size;
}

pwr_sAttrRef wb_bdrep::aref()
{
  pwr_tStatus sts;
  pwr_sObjBodyDef body;

  m_orep->vrep()->readBody(&sts, m_orep, pwr_eBix_sys, (void*)&body);
  if (EVEN(sts))
    throw wb_error(sts);

  pwr_sAttrRef aref;

  aref.Objid = pwr_cNOid;
  aref.Body = cdh_oixToBix(m_orep->oid().oix);
  aref.Offset = 0;
  aref.Size = body.Size;
  aref.Flags.m = 0; // ?? Is this right?

  return aref;
}

int wb_bdrep::nAttribute()
{
  pwr_tStatus sts;
  int attr_count = 0;
  wb_orep* old;

  wb_orep* orep = m_orep->vrep()->first(&sts, m_orep);
  while (ODD(sts)) {
    switch (orep->cid()) {
    case pwr_eClass_Param:
    case pwr_eClass_Intern:
    case pwr_eClass_Input:
    case pwr_eClass_Output:
    case pwr_eClass_ObjXRef:
    case pwr_eClass_AttrXRef:
    case pwr_eClass_Buffer:
      attr_count++;
      break;
    default:;
    }
    old = orep;
    orep = orep->after(&sts);
    old->ref();
    old->unref();
  }
  return attr_count;
}

pwr_tOid wb_bdrep::boid()
{
  return m_orep->oid();
}

pwr_tCid wb_bdrep::bcid()
{
  return m_orep->cid();
}

const char* wb_bdrep::name() const
{
  return m_orep->name();
}

wb_name wb_bdrep::longName() const
{
  return m_orep->longName();
}

pwr_tTime wb_bdrep::modTime()
{
  return m_orep->treeModTime();
}

char* wb_bdrep::structName()
{
  pwr_sObjBodyDef body;
  pwr_tStatus sts;

  m_orep->vrep()->readBody(&sts, m_orep, pwr_eBix_sys, (void*)&body);
  if (EVEN(sts))
    throw wb_error(sts);

  strcpy(m_structname, body.StructName);
  return m_structname;
}
