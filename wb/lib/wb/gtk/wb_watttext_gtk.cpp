/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* wb_watttext_gtk.cpp -- Display object attributes */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "cow_gtk.h"

#include "co_time.h"
#include "cow_xhelp.h"

#include "wb_watt_msg.h"
#include "wb_watttext_gtk.h"
#include "wb_wtt.h"

void WAttTextGtk::message(char severity, const char* message)
{
  gtk_label_set_text(GTK_LABEL(msg_label), message);
}

void WAttTextGtk::action_text_changed(GtkTextBuffer* w, gpointer data)
{
  WAttTextGtk* watttext = (WAttTextGtk*)data;

  if (watttext->init)
    return;

  watttext->modified = 1;
}

void WAttTextGtk::action_text_inserted(
    GtkTextBuffer* w, GtkTextIter* iter, gchar* str, gint len, gpointer data)
{
  WAttTextGtk* watttext = (WAttTextGtk*)data;

  int count = gtk_text_buffer_get_char_count(w);

  if (count > watttext->input_max_length) {
    // Remove inserted chars (note that iter now points at the end of the
    // inserted text)
    GtkTextIter start_iter;

    int offs = gtk_text_iter_get_offset(iter);
    gtk_text_buffer_get_iter_at_offset(w, &start_iter, offs - len);
    gtk_text_buffer_delete(w, &start_iter, iter);

    CoWowGtk wow(watttext->toplevel);
    wow.DisplayError("Error message", "Attribute size exceeded");
  } else
    watttext->message(' ', "");
}
//
//  Callbackfunctions from menu entries
//
void WAttTextGtk::activate_exit(GtkWidget* w, gpointer data)
{
  WAttText* watttext = (WAttText*)data;
  watttext->activate_exit();
}

void WAttTextGtk::activate_save(GtkWidget* w, gpointer data)
{
  WAttText* watttext = (WAttText*)data;

  watttext->set_attr_value();
  watttext->modified = 0;
}

void WAttTextGtk::activate_saveandclose(GtkWidget* w, gpointer data)
{
  WAttText* watttext = (WAttText*)data;

  watttext->set_attr_value();
  watttext->modified = 0;
  watttext->activate_exit();
}

void WAttTextGtk::activate_copy(GtkWidget* w, gpointer data)
{
  WAttTextGtk* watttext = (WAttTextGtk*)data;

  GtkClipboard* clipboard = gtk_clipboard_get(GDK_NONE);
  gtk_text_buffer_copy_clipboard(watttext->textbuffer, clipboard);
}

void WAttTextGtk::activate_cut(GtkWidget* w, gpointer data)
{
  WAttTextGtk* watttext = (WAttTextGtk*)data;

  GtkClipboard* clipboard = gtk_clipboard_get(GDK_NONE);
  gtk_text_buffer_cut_clipboard(watttext->textbuffer, clipboard, TRUE);
}

void WAttTextGtk::activate_paste(GtkWidget* w, gpointer data)
{
  WAttTextGtk* watttext = (WAttTextGtk*)data;

  GtkClipboard* clipboard = gtk_clipboard_get(GDK_NONE);
  gtk_text_buffer_paste_clipboard(watttext->textbuffer, clipboard, NULL, TRUE);
}

void WAttTextGtk::activate_ok(GtkWidget* w, gpointer data)
{
  WAttTextGtk* watttext = (WAttTextGtk*)data;

  watttext->set_attr_value();

  if (watttext->close_cb)
    (watttext->close_cb)(watttext);
  else
    delete watttext;
}

void WAttTextGtk::activate_apply(GtkWidget* w, gpointer data)
{
  WAttTextGtk* watttext = (WAttTextGtk*)data;

  watttext->set_attr_value();
  watttext->modified = 0;
}

void WAttTextGtk::activate_cancel(GtkWidget* w, gpointer data)
{
  WAttTextGtk* watttext = (WAttTextGtk*)data;

  if (watttext->close_cb)
    (watttext->close_cb)(watttext);
  else
    delete watttext;
}

void WAttTextGtk::activate_help(GtkWidget* w, gpointer data)
{
  CoXHelp::dhelp("objecttexteditor_refman", 0, navh_eHelpFile_Other,
      "$pwr_lang/man_dg.dat", true);
}

gboolean WAttTextGtk::action_inputfocus(
    GtkWidget* w, GdkEvent* event, gpointer data)
{
  WAttTextGtk* watttext = (WAttTextGtk*)data;

  if (watttext->editmode)
    gtk_widget_grab_focus(watttext->textview);

  return FALSE;
}

void WAttTextGtk::pop()
{
  gtk_window_present(GTK_WINDOW(toplevel));
}

void WAttTextGtk::set_editmode(int editmode, ldh_tSesContext ldhses)
{
  if (!this->editmode && editmode) {
    gtk_text_view_set_editable(GTK_TEXT_VIEW(textview), TRUE);
    gtk_text_view_set_cursor_visible(GTK_TEXT_VIEW(textview), TRUE);
  } else if (this->editmode && !editmode) {
    gtk_text_view_set_editable(GTK_TEXT_VIEW(textview), FALSE);
    gtk_text_view_set_cursor_visible(GTK_TEXT_VIEW(textview), FALSE);
  }

  if (ldhses != 0)
    this->ldhses = ldhses;
  this->editmode = editmode;
}

void WAttTextGtk::set_attr_value()
{
  int size = input_max_length + 1;
  pwr_tStatus sts;
  gchar *text, *textutf8;
  unsigned char* s;

  if (editmode) {
    GtkTextIter start_iter, end_iter;
    gtk_text_buffer_get_start_iter(textbuffer, &start_iter);
    gtk_text_buffer_get_end_iter(textbuffer, &end_iter);

    textutf8
        = gtk_text_buffer_get_text(textbuffer, &start_iter, &end_iter, FALSE);
    text = g_convert(textutf8, -1, "ISO8859-1", "UTF-8", NULL, NULL, NULL);
    g_free(textutf8);

    if (text) {
      // Replace ctrl characters with space
      for (s = (unsigned char*)text; *s; s++) {
        if (*s < ' ' && *s != 10 && *s != 13)
          *s = ' ';
      }

      sts = ldh_SetObjectPar(ldhses, aref.Objid, "DevBody", aname, text, size);
      g_free(text);
    } else
      wow->DisplayError("Input error", "Invalid character");
  }
}

WAttTextGtk::~WAttTextGtk()
{
  if (wow)
    delete wow;
  if (toplevel)
    gtk_widget_destroy(toplevel);
}

static gint delete_event(GtkWidget* w, GdkEvent* event, gpointer data)
{
  WAttTextGtk* watttext = (WAttTextGtk*)data;

  if (watttext->close_cb)
    (watttext->close_cb)(watttext);
  else
    delete watttext;

  return FALSE;
}

static void destroy_event(GtkWidget* w, gpointer data)
{
}

WAttTextGtk::WAttTextGtk(GtkWidget* wa_parent_wid, void* wa_parent_ctx,
    ldh_tSesContext wa_ldhses, pwr_sAttrRef wa_aref, int wa_editmode,
    pwr_tStatus* status)
    : WAttText(wa_parent_ctx, wa_ldhses, wa_aref, wa_editmode, status),
      parent_wid(wa_parent_wid), toplevel(0), init(1)
{
  int sts;
  int size;
  char* namep;

  if (EVEN(*status))
    return;

  sts = ldh_AttrRefToName(ldhses, &aref, ldh_eName_Hierarchy, &namep, &size);
  if (EVEN(sts)) {
    *status = sts;
    return;
  }

  toplevel = (GtkWidget*)g_object_new(GTK_TYPE_WINDOW, "default-height", 700,
      "default-width", 800, "title", CoWowGtk::convert_utf8(namep), NULL);

  g_signal_connect(toplevel, "delete_event", G_CALLBACK(delete_event), this);
  g_signal_connect(toplevel, "destroy", G_CALLBACK(destroy_event), this);
  g_signal_connect(
      toplevel, "focus-in-event", G_CALLBACK(action_inputfocus), this);

  CoWowGtk::SetWindowIcon(toplevel);

  // Menu
  // Accelerators
  GtkAccelGroup* accel_g
      = (GtkAccelGroup*)g_object_new(GTK_TYPE_ACCEL_GROUP, NULL);
  gtk_window_add_accel_group(GTK_WINDOW(toplevel), accel_g);

  GtkMenuBar* menu_bar = (GtkMenuBar*)g_object_new(GTK_TYPE_MENU_BAR, NULL);

  // File entry
  GtkWidget* file_close
      = gtk_image_menu_item_new_from_stock(GTK_STOCK_CLOSE, accel_g);
  g_signal_connect(file_close, "activate", G_CALLBACK(activate_exit), this);

  GtkWidget* file_save
      = gtk_image_menu_item_new_from_stock(GTK_STOCK_SAVE, accel_g);
  g_signal_connect(file_save, "activate", G_CALLBACK(activate_save), this);

  GtkWidget* file_saveandclose
      = gtk_menu_item_new_with_mnemonic("S_ave and close");
  g_signal_connect(
      file_saveandclose, "activate", G_CALLBACK(activate_saveandclose), this);
  gtk_widget_add_accelerator(file_saveandclose, "activate", accel_g, 't',
      GdkModifierType(GDK_CONTROL_MASK), GTK_ACCEL_VISIBLE);

  GtkMenu* file_menu = (GtkMenu*)g_object_new(GTK_TYPE_MENU, NULL);
  gtk_menu_shell_append(GTK_MENU_SHELL(file_menu), file_save);
  gtk_menu_shell_append(GTK_MENU_SHELL(file_menu), file_saveandclose);
  gtk_menu_shell_append(GTK_MENU_SHELL(file_menu), file_close);

  GtkWidget* file = gtk_menu_item_new_with_mnemonic("_File");
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_bar), file);
  gtk_menu_item_set_submenu(GTK_MENU_ITEM(file), GTK_WIDGET(file_menu));

  // Edit entry
  GtkWidget* edit_copy
      = gtk_image_menu_item_new_from_stock(GTK_STOCK_COPY, accel_g);
  g_signal_connect(edit_copy, "activate", G_CALLBACK(activate_copy), this);

  GtkWidget* edit_cut
      = gtk_image_menu_item_new_from_stock(GTK_STOCK_CUT, accel_g);
  g_signal_connect(edit_cut, "activate", G_CALLBACK(activate_cut), this);

  GtkWidget* edit_paste
      = gtk_image_menu_item_new_from_stock(GTK_STOCK_PASTE, accel_g);
  g_signal_connect(edit_paste, "activate", G_CALLBACK(activate_paste), this);

  GtkMenu* edit_menu = (GtkMenu*)g_object_new(GTK_TYPE_MENU, NULL);
  gtk_menu_shell_append(GTK_MENU_SHELL(edit_menu), edit_copy);
  gtk_menu_shell_append(GTK_MENU_SHELL(edit_menu), edit_cut);
  gtk_menu_shell_append(GTK_MENU_SHELL(edit_menu), edit_paste);

  GtkWidget* edit = gtk_menu_item_new_with_mnemonic("_Edit");
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_bar), edit);
  gtk_menu_item_set_submenu(GTK_MENU_ITEM(edit), GTK_WIDGET(edit_menu));

  // Help entry
  GtkWidget* help_help
      = gtk_image_menu_item_new_from_stock(GTK_STOCK_HELP, accel_g);
  g_signal_connect(help_help, "activate", G_CALLBACK(activate_help), this);

  GtkMenu* help_menu = (GtkMenu*)g_object_new(GTK_TYPE_MENU, NULL);
  gtk_menu_shell_append(GTK_MENU_SHELL(help_menu), help_help);

  GtkWidget* help = gtk_menu_item_new_with_mnemonic("_Help");
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_bar), help);
  gtk_menu_item_set_submenu(GTK_MENU_ITEM(help), GTK_WIDGET(help_menu));

  if (((WUtility*)parent_ctx)->utype == wb_eUtility_WNav)
    parent_ctx = ((WNav*)parent_ctx)->parent_ctx;
  utility = ((WUtility*)parent_ctx)->utype;

  textbuffer = gtk_text_buffer_new(NULL);
  g_signal_connect_after(
      textbuffer, "insert-text", G_CALLBACK(action_text_inserted), this);
  g_signal_connect_after(
      textbuffer, "changed", G_CALLBACK(action_text_changed), this);

  textview = gtk_text_view_new_with_buffer(textbuffer);
  GtkWidget* viewport = gtk_viewport_new(NULL, NULL);
  GtkWidget* scrolledwindow = gtk_scrolled_window_new(NULL, NULL);
  gtk_container_add(GTK_CONTAINER(viewport), textview);
  gtk_container_add(GTK_CONTAINER(scrolledwindow), viewport);

  button_ok = gtk_button_new_with_label("Ok");
  gtk_widget_set_size_request(button_ok, 70, 25);
  g_signal_connect(button_ok, "clicked", G_CALLBACK(activate_ok), this);
  button_apply = gtk_button_new_with_label("Apply");
  gtk_widget_set_size_request(button_apply, 70, 25);
  g_signal_connect(button_apply, "clicked", G_CALLBACK(activate_apply), this);
  button_cancel = gtk_button_new_with_label("Cancel");
  gtk_widget_set_size_request(button_cancel, 70, 25);
  g_signal_connect(button_cancel, "clicked", G_CALLBACK(activate_cancel), this);

  GtkWidget* hboxbuttons = gtk_hbox_new(TRUE, 40);
  gtk_box_pack_start(GTK_BOX(hboxbuttons), button_ok, FALSE, FALSE, 0);
  gtk_box_pack_start(GTK_BOX(hboxbuttons), button_apply, FALSE, FALSE, 0);
  gtk_box_pack_end(GTK_BOX(hboxbuttons), button_cancel, FALSE, FALSE, 0);

  msg_label = gtk_label_new("");
  gtk_widget_set_size_request(msg_label, -1, 25);

  vbox = gtk_vbox_new(FALSE, 0);
  gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET(menu_bar), FALSE, FALSE, 0);
  gtk_box_pack_start(GTK_BOX(vbox), scrolledwindow, TRUE, TRUE, 0);
  gtk_box_pack_start(GTK_BOX(vbox), hboxbuttons, FALSE, FALSE, 5);
  gtk_box_pack_start(GTK_BOX(vbox), msg_label, FALSE, FALSE, 5);

  gtk_container_add(GTK_CONTAINER(toplevel), vbox);
  gtk_widget_show_all(toplevel);

  if (utility == wb_eUtility_Wtt) {
    ((Wtt*)parent_ctx)
        ->register_utility((void*)this, wb_eUtility_AttrTextEditor);
  }

  char* value;
  ldh_sAttrRefInfo ainfo;

  sts = ldh_GetAttrRefInfo(ldhses, &aref, &ainfo);
  if (EVEN(sts)) {
    *status = sts;
    return;
  }

  char* s = strchr(namep, '.');
  if (!s)
    return;

  strncpy(aname, s + 1, sizeof(aname));

  sts = ldh_GetObjectPar(
      ldhses, aref.Objid, "DevBody", aname, (char**)&value, &size);
  if (EVEN(sts)) {
    *status = sts;
    return;
  }

  input_max_length = ainfo.size - 1;

  GtkTextIter start_iter, end_iter;
  gtk_text_buffer_get_start_iter(textbuffer, &start_iter);
  gtk_text_buffer_get_end_iter(textbuffer, &end_iter);
  gtk_text_buffer_delete(textbuffer, &start_iter, &end_iter);

  gtk_text_buffer_get_start_iter(textbuffer, &start_iter);

  char* textutf8 = g_convert(value, -1, "UTF-8", "ISO8859-1", NULL, NULL, NULL);
  gtk_text_buffer_insert(textbuffer, &start_iter, textutf8, -1);
  g_free(textutf8);

  free(value);

  if (!editmode) {
    gtk_text_view_set_editable(GTK_TEXT_VIEW(textview), FALSE);
    gtk_text_view_set_cursor_visible(GTK_TEXT_VIEW(textview), FALSE);
  }

  wow = new CoWowGtk(toplevel);
  init = 0;
}
