/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2014 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

/* wb_watttext_gtk.cpp -- Display object attributes */

#include "glow_std.h"

#include <stdio.h>
#include <stdlib.h>
#include <gtk/gtk.h>

#include "co_cdh.h"
#include "co_dcli.h"
#include "co_time.h"
#include "cow_wow_gtk.h"
#include "wb_watt_msg.h"
#include "flow.h"
#include "flow_browctx.h"
#include "flow_browapi.h"
#include "wb_watttext_gtk.h"
#include "wb_wtt.h"
#include "wb_wnav.h"
#include "cow_xhelp.h"

void WAttTextGtk::message( char severity, const char *message)
{
  gtk_label_set_text( GTK_LABEL(msg_label), message);
}

void WAttTextGtk::action_text_changed( GtkTextBuffer *w, gpointer data)
{
  WAttTextGtk *watttext = (WAttTextGtk *)data;

  if ( watttext->init)
    return;

  watttext->modified = 1;
}

void WAttTextGtk::action_text_inserted( GtkTextBuffer *w, GtkTextIter *iter, gchar *str, gint len, gpointer data)
{
  WAttTextGtk *watttext = (WAttTextGtk *)data;

  int count = gtk_text_buffer_get_char_count( w);  

  if ( count > watttext->input_max_length) {
    // Remove inserted chars (note that iter now points at the end of the inserted text)
    GtkTextIter start_iter;

    int offs = gtk_text_iter_get_offset( iter);
    gtk_text_buffer_get_iter_at_offset( w, &start_iter, offs - len);
    gtk_text_buffer_delete( w, &start_iter, iter);

    CoWowGtk wow( watttext->toplevel);
    wow.DisplayError( "Error message", "Attribute size exceeded");
  }
  else
    watttext->message( ' ', "");
}
//
//  Callbackfunctions from menu entries
//
void WAttTextGtk::activate_exit( GtkWidget *w, gpointer data)
{
  WAttText *watttext = (WAttText *)data;
  watttext->activate_exit();
}

void WAttTextGtk::activate_save( GtkWidget *w, gpointer data)
{
  WAttText *watttext = (WAttText *)data;

  watttext->set_attr_value();
  watttext->modified = 0;
}

void WAttTextGtk::activate_copy( GtkWidget *w, gpointer data)
{
  WAttTextGtk *watttext = (WAttTextGtk *)data;

  GtkClipboard *clipboard = gtk_clipboard_get( GDK_NONE);
  gtk_text_buffer_copy_clipboard( watttext->textbuffer, clipboard);
}

void WAttTextGtk::activate_cut( GtkWidget *w, gpointer data)
{
  WAttTextGtk *watttext = (WAttTextGtk *)data;

  GtkClipboard *clipboard = gtk_clipboard_get( GDK_NONE);
  gtk_text_buffer_cut_clipboard( watttext->textbuffer, clipboard, TRUE);
}

void WAttTextGtk::activate_paste( GtkWidget *w, gpointer data)
{
  WAttTextGtk *watttext = (WAttTextGtk *)data;

  GtkClipboard *clipboard = gtk_clipboard_get( GDK_NONE);
  gtk_text_buffer_paste_clipboard( watttext->textbuffer, clipboard, NULL, TRUE);
}

void WAttTextGtk::activate_ok( GtkWidget *w, gpointer data)
{
  WAttTextGtk *watttext = (WAttTextGtk *)data;

  watttext->set_attr_value();

  if ( watttext->close_cb)
    (watttext->close_cb)( watttext);
  else
    delete watttext;
}

void WAttTextGtk::activate_apply( GtkWidget *w, gpointer data)
{
  WAttTextGtk *watttext = (WAttTextGtk *)data;

  watttext->set_attr_value();
  watttext->modified = 0;
}

void WAttTextGtk::activate_cancel( GtkWidget *w, gpointer data)
{
  WAttTextGtk *watttext = (WAttTextGtk *)data;

  if ( watttext->close_cb)
    (watttext->close_cb)( watttext);
  else
    delete watttext;
}

void WAttTextGtk::activate_help( GtkWidget *w, gpointer data)
{
  CoXHelp::dhelp( "objecttexteditor_refman", 0, navh_eHelpFile_Other, 
		  "$pwr_lang/man_dg.dat", true);
}

gboolean WAttTextGtk::action_inputfocus( GtkWidget *w, GdkEvent *event, gpointer data)
{
  WAttTextGtk *watttext = (WAttTextGtk *)data;

  if ( watttext->editmode)
    gtk_widget_grab_focus( watttext->textview);

  return FALSE;
}

void WAttTextGtk::pop()
{
  gtk_window_present( GTK_WINDOW(toplevel));
}

void WAttTextGtk::set_editmode( int editmode, ldh_tSesContext ldhses)
{
  if ( !this->editmode && editmode) {
    gtk_text_view_set_editable( GTK_TEXT_VIEW(textview), TRUE);
    gtk_text_view_set_cursor_visible( GTK_TEXT_VIEW(textview), TRUE);
  }
  else if ( this->editmode && !editmode) {
    gtk_text_view_set_editable( GTK_TEXT_VIEW(textview), FALSE);
    gtk_text_view_set_cursor_visible( GTK_TEXT_VIEW(textview), FALSE);
  }

  if ( ldhses != 0)
    this->ldhses = ldhses;
  this->editmode = editmode;
}

void WAttTextGtk::set_attr_value()
{
  int size = input_max_length + 1;
  pwr_tStatus sts;
  gchar *text, *textutf8;
  unsigned char *s;

  if ( editmode) {
    GtkTextIter start_iter, end_iter;
    gtk_text_buffer_get_start_iter( textbuffer, &start_iter);
    gtk_text_buffer_get_end_iter( textbuffer, &end_iter);

    textutf8 = gtk_text_buffer_get_text( textbuffer, &start_iter, &end_iter,
				     FALSE);
    text = g_convert( textutf8, -1, "ISO8859-1", "UTF-8", NULL, NULL, NULL);
    g_free( textutf8);

    // Replace ctrl characters with space
    for ( s = (unsigned char *) text; *s; s++) {
      if ( *s < ' ' && *s != 10 && *s != 13)
	*s = ' ';
    }

    sts = ldh_SetObjectPar( ldhses, aref.Objid, "DevBody",
			    aname, text, size);
    g_free( text);
  }
}

WAttTextGtk::~WAttTextGtk()
{
  if ( wow)
    delete wow;
  if ( toplevel)
    gtk_widget_destroy( toplevel);
}

static gint delete_event( GtkWidget *w, GdkEvent *event, gpointer data)
{
  WAttTextGtk *watttext = (WAttTextGtk *)data;

  if ( watttext->close_cb)
    (watttext->close_cb)( watttext);
  else
    delete watttext;
  
  return FALSE;
}

static void destroy_event( GtkWidget *w, gpointer data)
{
}

WAttTextGtk::WAttTextGtk( 
	GtkWidget      	*wa_parent_wid,
	void 		*wa_parent_ctx, 
	ldh_tSesContext wa_ldhses, 
	pwr_sAttrRef 	wa_aref,
	int 		wa_editmode,
	pwr_tStatus	*status) :
  WAttText(wa_parent_ctx,wa_ldhses,wa_aref,wa_editmode,status),parent_wid(wa_parent_wid),
  toplevel(0), init(1)
{
  int sts;
  int size;
  char *namep;

  if ( EVEN(*status))
    return;

  sts = ldh_AttrRefToName( ldhses, &aref, ldh_eName_Hierarchy, 
			   &namep, &size);
  if ( EVEN(sts)) {
    *status = sts;
    return;
  }


  toplevel = (GtkWidget *) g_object_new( GTK_TYPE_WINDOW, 
					 "default-height", 700,
					 "default-width", 800,
					 "title", CoWowGtk::convert_utf8(namep),
					 NULL);

  g_signal_connect( toplevel, "delete_event", G_CALLBACK(delete_event), this);
  g_signal_connect( toplevel, "destroy", G_CALLBACK(destroy_event), this);
  g_signal_connect( toplevel, "focus-in-event", G_CALLBACK(action_inputfocus), this);

  CoWowGtk::SetWindowIcon( toplevel);

  // Menu
  // Accelerators
  GtkAccelGroup *accel_g = (GtkAccelGroup *) g_object_new(GTK_TYPE_ACCEL_GROUP, NULL);
  gtk_window_add_accel_group(GTK_WINDOW(toplevel), accel_g);

  GtkMenuBar *menu_bar = (GtkMenuBar *) g_object_new(GTK_TYPE_MENU_BAR, NULL);

  // File entry
  GtkWidget *file_close = gtk_image_menu_item_new_from_stock(GTK_STOCK_CLOSE, accel_g);
  g_signal_connect(file_close, "activate", G_CALLBACK(activate_exit), this);

  GtkWidget *file_save = gtk_image_menu_item_new_from_stock(GTK_STOCK_SAVE, accel_g);
  g_signal_connect(file_save, "activate", G_CALLBACK(activate_save), this);

  GtkMenu *file_menu = (GtkMenu *) g_object_new( GTK_TYPE_MENU, NULL);
  gtk_menu_shell_append(GTK_MENU_SHELL(file_menu), file_save);
  gtk_menu_shell_append(GTK_MENU_SHELL(file_menu), file_close);

  GtkWidget *file = gtk_menu_item_new_with_mnemonic("_File");
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_bar), file);
  gtk_menu_item_set_submenu(GTK_MENU_ITEM(file), GTK_WIDGET(file_menu));

  // Edit entry
  GtkWidget *edit_copy = gtk_image_menu_item_new_from_stock(GTK_STOCK_COPY, accel_g);
  g_signal_connect(edit_copy, "activate", G_CALLBACK(activate_copy), this);

  GtkWidget *edit_cut = gtk_image_menu_item_new_from_stock(GTK_STOCK_CUT, accel_g);
  g_signal_connect(edit_cut, "activate", G_CALLBACK(activate_cut), this);

  GtkWidget *edit_paste = gtk_image_menu_item_new_from_stock(GTK_STOCK_PASTE, accel_g);
  g_signal_connect(edit_paste, "activate", G_CALLBACK(activate_paste), this);

  GtkMenu *edit_menu = (GtkMenu *) g_object_new( GTK_TYPE_MENU, NULL);
  gtk_menu_shell_append(GTK_MENU_SHELL(edit_menu), edit_copy);
  gtk_menu_shell_append(GTK_MENU_SHELL(edit_menu), edit_cut);
  gtk_menu_shell_append(GTK_MENU_SHELL(edit_menu), edit_paste);

  GtkWidget *edit = gtk_menu_item_new_with_mnemonic("_Edit");
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_bar), edit);
  gtk_menu_item_set_submenu(GTK_MENU_ITEM(edit), GTK_WIDGET(edit_menu));

  // Help entry
  GtkWidget *help_help = gtk_image_menu_item_new_from_stock(GTK_STOCK_HELP, accel_g);
  g_signal_connect(help_help, "activate", G_CALLBACK(activate_help), this);

  GtkMenu *help_menu = (GtkMenu *) g_object_new( GTK_TYPE_MENU, NULL);
  gtk_menu_shell_append(GTK_MENU_SHELL(help_menu), help_help);

  GtkWidget *help = gtk_menu_item_new_with_mnemonic("_Help");
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_bar), help);
  gtk_menu_item_set_submenu(GTK_MENU_ITEM(help), GTK_WIDGET(help_menu));

  if ( ((WUtility *)parent_ctx)->utype == wb_eUtility_WNav)
    parent_ctx = ((WNav *)parent_ctx)->parent_ctx;
  utility = ((WUtility *)parent_ctx)->utype;
  
  textbuffer = gtk_text_buffer_new( NULL);
  g_signal_connect_after( textbuffer, "insert-text", 
 		    G_CALLBACK(action_text_inserted), this);
  g_signal_connect_after( textbuffer, "changed", 
 		    G_CALLBACK(action_text_changed), this);

  textview = gtk_text_view_new_with_buffer( textbuffer);
  GtkWidget *viewport = gtk_viewport_new( NULL, NULL);
  GtkWidget *scrolledwindow = gtk_scrolled_window_new(NULL, NULL);
  gtk_container_add( GTK_CONTAINER(viewport), textview);
  gtk_container_add( GTK_CONTAINER(scrolledwindow), viewport);

  button_ok = gtk_button_new_with_label( "Ok");
  gtk_widget_set_size_request( button_ok, 70, 25);
  g_signal_connect( button_ok, "clicked", 
 		    G_CALLBACK(activate_ok), this);
  button_apply = gtk_button_new_with_label( "Apply");
  gtk_widget_set_size_request( button_apply, 70, 25);
  g_signal_connect( button_apply, "clicked", 
 		    G_CALLBACK(activate_apply), this);
  button_cancel = gtk_button_new_with_label( "Cancel");
  gtk_widget_set_size_request( button_cancel, 70, 25);
  g_signal_connect( button_cancel, "clicked", 
 		    G_CALLBACK(activate_cancel), this);

  GtkWidget *hboxbuttons = gtk_hbox_new( TRUE, 40);
  gtk_box_pack_start( GTK_BOX(hboxbuttons), button_ok, FALSE, FALSE, 0);
  gtk_box_pack_start( GTK_BOX(hboxbuttons), button_apply, FALSE, FALSE, 0);
  gtk_box_pack_end( GTK_BOX(hboxbuttons), button_cancel, FALSE, FALSE, 0);

  msg_label = gtk_label_new( "");
  gtk_widget_set_size_request( msg_label, -1, 25);

  vbox = gtk_vbox_new( FALSE, 0);
  gtk_box_pack_start( GTK_BOX(vbox), GTK_WIDGET(menu_bar), FALSE, FALSE, 0);
  gtk_box_pack_start( GTK_BOX(vbox), scrolledwindow, TRUE, TRUE, 0);
  gtk_box_pack_start( GTK_BOX(vbox), hboxbuttons, FALSE, FALSE, 5);
  gtk_box_pack_start( GTK_BOX(vbox), msg_label, FALSE, FALSE, 5);

  gtk_container_add( GTK_CONTAINER(toplevel), vbox);
  gtk_widget_show_all( toplevel);

  if ( utility == wb_eUtility_Wtt) {
    ((Wtt *)parent_ctx)->register_utility( (void *) this,
					   wb_eUtility_AttrTextEditor);
  }

  char *value;
  ldh_sAttrRefInfo ainfo;

  sts = ldh_GetAttrRefInfo( ldhses, &aref, &ainfo);
  if ( EVEN(sts)) {
    *status = sts;
    return;
  }

  char *s = strchr( namep, '.');
  if ( !s)
    return;

  strncpy( aname, s+1, sizeof(aname));

  sts = ldh_GetObjectPar( ldhses, aref.Objid, "DevBody",
			  aname, (char **)&value, &size);
  if (EVEN(sts)) {
    *status = sts;
    return;
  }

  input_max_length = ainfo.size - 1;

  GtkTextIter start_iter, end_iter;
  gtk_text_buffer_get_start_iter( textbuffer, &start_iter);
  gtk_text_buffer_get_end_iter( textbuffer, &end_iter);
  gtk_text_buffer_delete( textbuffer, &start_iter, &end_iter);
  
  gtk_text_buffer_get_start_iter( textbuffer, &start_iter);

  char *textutf8 = g_convert( value, -1, "UTF-8", "ISO8859-1", NULL, NULL, NULL);
  gtk_text_buffer_insert( textbuffer, &start_iter, textutf8, -1);
  g_free( textutf8);

  free( value);

  if ( !editmode) {
    gtk_text_view_set_editable( GTK_TEXT_VIEW(textview), FALSE);
    gtk_text_view_set_cursor_visible( GTK_TEXT_VIEW(textview), FALSE);
  }

  wow = new CoWowGtk( toplevel);
  init = 0;
}











