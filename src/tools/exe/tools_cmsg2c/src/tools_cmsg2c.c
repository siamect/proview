/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/*
 * Creates a .c-file from a .cmsg file
 *
 * The -b branch flag must be set if you want to generate messages for PROVIEW.
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "pwr_lst.h"
#include "pwr_msg.h"

#define MSG_NEW_STRING(str) strncpy(malloc(strlen(str) + 1), str, strlen(str) + 1)

typedef struct s_FacilityCB sFacilityCB;

struct s_FacilityCB {
  struct LstHead FacL;
  char* facnam;
  int facnum;
};

static char* inFile;

static struct LstHead lFacH;
static sFacilityCB* CurrFac = NULL;

static void usage()
{
  printf("Usage: tools_cmsg2c [-b branch] input_file output_file\n");
  exit(1);
}

void lex_FacName(char* facnam)
{
  sFacilityCB* facp = (sFacilityCB*)calloc(1, sizeof(sFacilityCB));

  facp->facnam = MSG_NEW_STRING(facnam);
  CurrFac = facp;
}

void lex_FacNum(int facnum)
{
  struct LstHead * fl;

  /*
   * To do: Check that the facility number is within the valid range
   *
   */

  /* Insert in ascending order */
  LstForEach(fl, &lFacH) {
    if (LstEntry(fl, sFacilityCB, FacL)->facnum > facnum) {
      break;
    }
  }

  CurrFac->facnum = facnum;
  LstInsert(fl, &CurrFac->FacL);
  CurrFac = NULL;
}

static void lex(FILE* fp) {
  char buffer[500];
  int next_is_facnum = 0;
  int lineno = 1;
  while (fgets(buffer, 500, fp) != NULL) {
    if (strstr(buffer, "msg_sFacility")) {
      char* facnam = strstr(buffer, "msg_sFacility") + 14; // "MYfacility[] = "
      facnam[strchr(facnam, '[')-facnam] = '\0'; // "MYfacility"
      if (!strstr(facnam, "facility")) {
        fprintf(stderr, "Syntax error in file %s line %d\n", inFile, lineno);
        exit(1);
      }
      lex_FacName(facnam);
      next_is_facnum = 1;
    } else if (next_is_facnum) {
      char *line = buffer;
      while (!isdigit(line[0])) {
        line++; // "1337,"
      }
      line[strchr(line, ',')-line] = '\0';
      char* end;
      int facnum = strtol(line, &end, 10);
      if (!facnum) {
        fprintf(stderr, "Syntax error in file %s line %d\n", inFile, lineno);
        exit(1);
      }
      lex_FacNum(facnum);
      next_is_facnum = 0;
    }
    lineno++;
  }
}

static void CopyFile(FILE* ifp, FILE* ofp)
{
  int c;
  while ((c = getc(ifp)) != EOF)
    putc(c, ofp);
}

static void WriteFacility(FILE* cfp, char* branch)
{
  struct LstHead * fl;
  int i = 0;

  fprintf(cfp, "static msg_sFacility *Facilities[] = {\n");

  LstForEach(fl, &lFacH) {
    if (i++)
      fprintf(cfp, ",\n");

    fprintf(cfp, "\t%-20s /* %4d */", LstEntry(fl, sFacilityCB, FacL)->facnam, LstEntry(fl, sFacilityCB, FacL)->facnum);
  }

  fprintf(cfp, "};\n\n");
  if (LstEmpty(&lFacH))
    fprintf(cfp, "msg_sHead %sMsgHead = {0, 0};\n", branch ? branch : "pwrp");
  else
    fprintf(cfp, "msg_sHead %sMsgHead = {MSG_NOF(Facilities), Facilities};\n",
        branch ? branch : "pwrp");
}

int main(int argc, char** argv)
{
  FILE* in;
  FILE* cfp = NULL;
  int bmsg = 0;
  char* branch = NULL;
  char* outFile;

  if (argc < 3)
    usage();

  if (argv[1][0] == '-') {
    if (argv[1][1] == 'b') {
      branch = argv[2];
      bmsg = 1;
    } else
      usage();
    if (argc != 5)
      usage();
  } else if (argc != 3)
    usage();

  inFile = bmsg ? argv[3] : argv[1];
  outFile = bmsg ? argv[4] : argv[2];

  if (!(in = fopen(inFile, "r"))) {
    printf("Can't open input file: %s", inFile);
    exit(1);
  }

  LstInit(&lFacH);

  lex(in);

  if (!(cfp = fopen(outFile, "w+"))) {
    printf("Can't open output file: %s", outFile);
    fclose(in);
    exit(1);
  }

  rewind(in);
  fprintf(cfp, "#include \"pwr_msg.h\"\n\n");
  CopyFile(in, cfp);
  WriteFacility(cfp, branch);

  fclose(in);
  fclose(cfp);

  return 0;
}
