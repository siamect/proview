/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/*
 * Creates a .cmsg file and a .h file from a .msg-file
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "pwr_lst.h"
#include "pwr_msg.h"

#define MSG_NEW_STRING(str) strncpy(malloc(strlen(str) + 1), str, strlen(str) + 1)

typedef struct s_FacilityCB sFacilityCB;
typedef struct s_MsgCB sMsgCB;

struct s_MsgCB {
  struct LstHead MsgL;
  msg_sMsg m;
  msg_eSeverity Severity;
};

struct s_FacilityCB {
  struct LstHead FacL;
  struct LstHead MsgH;
  msg_sFacility f;
};

static char* inFile;

static struct LstHead lFacH;

void lex_FacName(const char* FacName)
{
  sFacilityCB* facp = (sFacilityCB*)calloc(1, sizeof(sFacilityCB));

  LstInit(&facp->MsgH);
  facp->f.FacName = MSG_NEW_STRING(FacName);

  LstInsert(&lFacH, &facp->FacL);
}

void lex_FacNum(int FacNum)
{
  LstEntry(lFacH.prev, sFacilityCB, FacL)->f.FacNum = FacNum;
}

void lex_FacPrefix(const char* Prefix)
{
  char *str = strncpy(malloc(strlen(Prefix) + 3), Prefix, strlen(Prefix)+1);
  strcat(str, "__\0");
  LstEntry(lFacH.prev, sFacilityCB, FacL)->f.Prefix = str;
}

void lex_MsgName(const char* MsgName)
{
  sMsgCB* msgp = (sMsgCB*)calloc(1, sizeof(sMsgCB));
  int len = strlen(MsgName);
  msgp->m.MsgName = malloc(len + 1);

  int i;
  for (i = 0; i < len; i++)
    msgp->m.MsgName[i] = toupper(MsgName[i]);
  msgp->m.MsgName[i] = '\0';

  LstInsert(&LstEntry(lFacH.prev, sFacilityCB, FacL)->MsgH, &msgp->MsgL);
}

static void TranslateFormatSpec(const char* msgstr, char** transstr)
{
  char* l;
  const char* m = msgstr;
  int extra = 0;
  int len = 0;

  /* '"' will be substituted with  '\"', allocate space for it */
  while (*m) {
    if (*m == '"')
      extra++;
    m++;
    len++;
  }

  *transstr = (char*)malloc(len + extra + 1);
  l = *transstr;
  m = msgstr;

  while (*m != '\0') {
    if (*m == '"') {
      *l++ = '\\';
      *l++ = '"';
    } else {
      *l++ = *m;
    }
    m++;
  }
  *l = '\0';
}

void lex_MsgText(const char* Text)
{
  struct LstHead* ml = LstEntry(lFacH.prev, sFacilityCB, FacL)->MsgH.prev;

  TranslateFormatSpec(
      Text, &LstEntry(ml, sMsgCB, MsgL)->m.MsgTxt); /* convert any VMS-style form spec */
}

void lex_MsgSeverity(msg_eSeverity Severity)
{
  struct LstHead* ml = LstEntry(lFacH.prev, sFacilityCB, FacL)->MsgH.prev;
  LstEntry(ml, sMsgCB, MsgL)->Severity = Severity;
}

static void lex(FILE* fp) {
  char buffer[500];
  int lineno = 1;
  while (fgets(buffer, 500, fp) != NULL) {
    if (strstr(buffer, ".facility")) {
      char *line = strstr(buffer, ".facility") + 10;
      while (isspace(line[0])) {
        line++;
      }
      char *facnam = line; // "ASD,123 "
      char *facnum0 = strchr(line, ',')+1; // "123 "
      facnam[strchr(facnam, ',')-facnam] = '\0'; // "ASD"
      char* tmp = facnum0;
      while (isdigit(tmp[0])) {
        tmp++;
      }
      facnum0[tmp-facnum0] = '\0';
      tmp = NULL;
      int facnum = strtol(facnum0, &tmp, 10);
      if (!facnum) {
        fprintf(stderr, "Syntax error in file %s line %d\n", inFile, lineno);
        exit(1);
      }
      lex_FacName(facnam);
      lex_FacNum(facnum);
      lex_FacPrefix(facnam);
    } else if (isalnum(buffer[0])) { // "mymsg   <my message text>  /error"
      char *msgname = buffer; // msgname = "mymsg   <my message text>  /error"
      char *tmp = msgname;
      while (isalnum(tmp[0]) || tmp[0] == '_') {
        tmp++;
      }
      tmp[0] = '\0'; // msgname = "mymsg"
      tmp++;

      while (tmp[0] != '<') {
        tmp++;
      }
      tmp++;
      char* msgtxt = tmp; // msgtxt = "my message text>  /error"
      while (tmp[0] != '>') {
        tmp++;
      }
      tmp[0] = '\0'; // msgtxt = "my message text"
      tmp++;

      char *msgseverity = tmp; // "  /error"
      while (isspace(msgseverity[0])) {
        msgseverity++; // "/error"
      }
      lex_MsgName(msgname);
      lex_MsgText(msgtxt);
      if (msgseverity[1] == 'w') {
        lex_MsgSeverity(msg_eSeverity_Warning);
      } else if (msgseverity[1] == 's') {
        lex_MsgSeverity(msg_eSeverity_Success);
      } else if (msgseverity[1] == 'e') {
        lex_MsgSeverity(msg_eSeverity_Error);
      } else if (msgseverity[1] == 'i') {
        lex_MsgSeverity(msg_eSeverity_Info);
      } else if (msgseverity[1] == 'f') {
        lex_MsgSeverity(msg_eSeverity_Fatal);
      } else {
        fprintf(stderr, "Syntax error in file %s line %d\n", inFile, lineno);
        exit(1);
      }
    }
    lineno++;
  }
}

static void WriteFiles(char* fname, FILE* cfp, FILE* hfp, FILE *pfp)
{
  struct LstHead * fl;
  struct LstHead * ml;
  int idx;
  int facid;
  char prefix[32];
  char name[64];
  char msgName[64];
  int msg;

  fprintf(hfp, "#ifndef %s_h\n", fname);
  fprintf(hfp, "#define %s_h\n\n", fname);

  LstForEach(fl, &lFacH) {
    facid = 0x800 + LstEntry(fl, sFacilityCB, FacL)->f.FacNum;
    snprintf(name, sizeof(name), "%s_FACILITY", LstEntry(fl, sFacilityCB, FacL)->f.FacName);
    fprintf(hfp, "#define %-29s %9d /* x%08x */\n", name, facid, facid);
    facid = facid << 16;

    if (LstEntry(fl, sFacilityCB, FacL)->f.Prefix)
      strncpy(prefix, LstEntry(fl, sFacilityCB, FacL)->f.Prefix, sizeof(prefix));
    else
      snprintf(prefix, sizeof(prefix), "%s_", LstEntry(fl, sFacilityCB, FacL)->f.FacName);

    snprintf(msgName, sizeof(msgName), "%smsg", LstEntry(fl, sFacilityCB, FacL)->f.FacName);
    fprintf(cfp, "static msg_sMsg %s[] = {\n", msgName);

    idx = 1;
    LstForEach(ml, &LstEntry(fl, sFacilityCB, FacL)->MsgH) {
      if (idx != 1)
        fprintf(cfp, ",\n");

      msg = facid + 0x8000 + (idx << 3) + LstEntry(ml, sMsgCB, MsgL)->Severity;
      snprintf(name, sizeof(name), "%s%s", prefix, LstEntry(ml, sMsgCB, MsgL)->m.MsgName);
      fprintf(hfp, "#define %-29s %9.9d /* x%08x */\n", name, msg, msg);
      if (pfp)
	fprintf(pfp, "%s = %d\n", name, msg);
      fprintf(cfp, "\t{\"%s\", \"%s\"}", LstEntry(ml, sMsgCB, MsgL)->m.MsgName,
          LstEntry(ml, sMsgCB, MsgL)->m.MsgTxt);
      idx++;
    }
    fprintf(cfp, "\n};\n\n");

    fprintf(cfp, "static msg_sFacility %sfacility[] = {\n\t",
        LstEntry(fl, sFacilityCB, FacL)->f.FacName);
    fprintf(cfp, "{%d, \"%s\", \"%s\", MSG_NOF(%s), %s}\n",
        LstEntry(fl, sFacilityCB, FacL)->f.FacNum, LstEntry(fl, sFacilityCB, FacL)->f.FacName, prefix, msgName, msgName);
    fprintf(cfp, "};\n\n");
  }

  fprintf(hfp, "\n#endif\n");
}

int main(int argc, char** argv)
{
  FILE* cfp = NULL;
  FILE* hfp = NULL;
  FILE* pfp = NULL;
  FILE* in = NULL;

  if (!(argc == 4 || argc == 5)) {
    printf("Usage: co_msg2cmsg msg-file c_msg-file h-file [py-file]\n");
    exit(2);
  }

  inFile = argv[1];
  if (!(in = fopen(inFile, "r"))) {
    printf("Can't open input file: %s\n", inFile);
    exit(2);
  }

  if (!(cfp = fopen(argv[2], "w"))) {
    printf("Can't open c_msg-output file: %s\n", argv[2]);
    fclose(in);
    exit(2);
  }

  if (!(hfp = fopen(argv[3], "w"))) {
    printf("Can't open h-output file: %s\n", argv[3]);
    fclose(in);
    fclose(cfp);
    exit(2);
  }

  if (argc >= 5) {
    if (!(pfp = fopen(argv[4], "w"))) {
      printf("Can't open python-output file: %s\n", argv[4]);
      fclose(in);
      fclose(cfp);
      fclose(hfp);
      exit(2);
    }
  }

  LstInit(&lFacH);
  lex(in);

  char fname[256];
  char* p = NULL;
  if ((p = strrchr(argv[2], '/')))
    strncpy(fname, p + 1, sizeof(fname));
  else
    strncpy(fname, argv[2], sizeof(fname));

  if ((p = strchr(fname, '.')))
    *p = '\0';

  WriteFiles(fname, cfp, hfp, pfp);

  fclose(in);
  fclose(cfp);
  fclose(hfp);
  if (pfp)
    fclose(pfp);

  return 0;
}
