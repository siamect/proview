/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_plc_process.c -- <short description>

   Runs the PLC programs of a node.  */

#include <stdio.h>

#if defined OS_LINUX
#include <sched.h>
#endif

#include <pwd.h>

#include "co_string.h"

#include "rt_qdb.h"
#include "rt_c_plcthread.h"
#include "rt_proc.h"
#include "rt_gdh.h"
#include "rt_gdh_msg.h"
#include "rt_ini_msg.h"
#include "rt_plc_msg.h"
#include "rt_plc_rt.h"
#include "rt_csup.h"
#include "rt_ini_event.h"
#include "rt_lck.h"
#include "rt_aproc.h"
#include "rt_pwr_msg.h"

static plc_sProcess* init_process();
static pwr_tStatus init_plc(plc_sProcess*, char* name);
static void init_threads(plc_sProcess*);
static void start_threads(plc_sProcess*);
static void run_threads(plc_sProcess*);
static void stop_threads(plc_sProcess*);
static void clean_all(plc_sProcess*);
static void link_io_base_areas(plc_sProcess*);
static void link_io_copy_areas(plc_sThread*);
static void dlink_area(plc_sDlink*, char*, int);
static void create_threads(plc_sProcess*);
static void create_thread(plc_sThread*, plc_sProctbl*, plc_sProcess*);
static void init_grafcet();
static void save_values(plc_sProcess*);
static void set_values(plc_sProcess*);
extern void plc_thread();

/* When you use pthread_cond_timedwait is the shortest timeout always > 1
 * CLK_TCK
 * So if you want to run a PLC-program with the same frequency as the scheduler
 * you need to use a rt-timer. In this version there is no slip detection if
 * you use a rt-timer. You need to set USE_RT_TIMER to 1 in rt_plc_thread.c
 * and rt_plc_process.c
 */
#define USE_RT_TIMER 0

int main(int argc, char* argv[])
{
  pwr_tStatus sts = 0;
  int event;
  plc_sProcess* pp;
  /*
    struct rlimit rlim;
    int i;
  */
  /* Set core dump file size limit to infinite */
  /*
    rlim.rlim_cur =  RLIM_INFINITY;
    rlim.rlim_max =  RLIM_INFINITY;
    sts = setrlimit(RLIMIT_CORE, &rlim);
    printf("%d\n", sts);
    i = 1/0;
    printf("%d\n", i);
  */
  if (argc > 1 && streq(argv[1], "-m")) {
    io_methods_print();
    exit(0);
  }

  pp = init_process(argv[0]);
  if (!pp) {
    errh_Fatal("Plc process terminated");
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  qcom_WaitAnd(
      &sts, &pp->eventQ, &qcom_cQini, ini_mEvent_newPlcInit, qcom_cTmoEternal);

  init_plc(pp, argv[0]);
  create_threads(pp);
  init_threads(pp);

  qcom_SignalOr(&sts, &qcom_cQini, ini_mEvent_newPlcInitDone | pp->sigmask);
  qcom_WaitAnd(
      &sts, &pp->eventQ, &qcom_cQini, ini_mEvent_newPlcStart, qcom_cTmoEternal);

  set_values(pp);
  start_threads(pp);
  run_threads(pp);
  time_Uptime(&sts, &pp->PlcProcess->StartTime, NULL);

  qcom_SignalOr(&sts, &qcom_cQini, ini_mEvent_newPlcStartDone | pp->sigmask);

  errh_SetStatus(PWR__SRUN);

  qcom_WaitOr(&sts, &pp->eventQ, &qcom_cQini,
      ini_mEvent_terminate | ini_mEvent_oldPlcStop, qcom_cTmoEternal, &event);

  switch (event) {
  case ini_mEvent_terminate:
    errh_SetStatus(PWR__SRVTERM);

    stop_threads(pp);
    clean_all(pp);
    lck_Unlink(&sts, lck_eLock_NMps);
    lck_Unlink(&sts, lck_eLock_Time);
    lck_Unlink(&sts, lck_eLock_Str);
    break;
  case ini_mEvent_oldPlcStop:
    errh_SetStatus(PWR__SRVTERM);

    time_Uptime(&sts, &pp->PlcProcess->StopTime, NULL);
    stop_threads(pp);
    save_values(pp);

    qcom_SignalOr(&sts, &qcom_cQini, ini_mEvent_oldPlcStopDone | pp->sigmask);

    clean_all(pp);
    break;
  default:;
  }

  exit(0);
}

static plc_sProcess* init_process(char* name)
{
  plc_sProcess* pp;
  pwr_tStatus sts = PLC__SUCCESS;
  pwr_tOid pp_oid;
  pwr_tOid sim_oid;
  int found = 0;
  char busidstr[10];
  char pp_name[80];
  pwr_tObjName oname;
  int busid;
  char* s;
  int idx = 0;

  errh_Init("pwr_plc", errh_eAnix_plc);
  errh_SetStatus(PWR__SRVSTARTUP);

  pp = (plc_sProcess*)calloc(1, sizeof(*pp));
  if (pp == NULL) {
    errh_Fatal("Out of virtual memory");
    exit(0);
  }

  sts = gdh_Init("pwr_plc");
  if (EVEN(sts)) {
    errh_Fatal("gdh_Init, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  lck_Create(&sts, lck_eLock_Time);
  if (EVEN(sts))
    errh_Fatal("lock create time, %m", sts);
  lck_Create(&sts, lck_eLock_Str);
  if (EVEN(sts))
    errh_Fatal("lock create str, %m", sts);
  lck_Create(&sts, lck_eLock_NMps);
  if (EVEN(sts))
    errh_Fatal("lock create NMps, %m", sts);

  if (strstr(name, "rt_plc_core") != 0)
    pp->is_core = 1;

  /* Get PlcProcess object */
  if (!pp->is_core) {
    busid = qcom_MyBus(&sts);
    if (EVEN(sts))
      return 0;

    sprintf(busidstr, "_%04d_", busid);
    s = strstr(name, busidstr);
    if (s) {
      strncpy(pp_name, s + 6, sizeof(pp_name));
      if ((s = strchr(pp_name, '.')))
        *s = 0;
    } else {
      strcpy(pp_name, "");
    }

    idx = 0;
    for (sts = gdh_GetClassList(pwr_cClass_PlcProcess, &pp_oid); ODD(sts);
         sts = gdh_GetNextObject(pp_oid, &pp_oid)) {
      sts = gdh_ObjidToName(pp_oid, oname, sizeof(oname), cdh_mName_object);
      if (EVEN(sts))
        return 0;

      if (str_NoCaseStrcmp(pp_name, oname) == 0) {
        found = 1;
        break;
      }
      idx++;
    }
  } else {
    sts = gdh_GetClassList(pwr_cClass_PlcProcess, &pp_oid);
    if (ODD(sts)) {
      found = 1;
      idx = 0;
    }
  }
  if (!found) {
    errh_Error("PlcProcess object not found, %s", pp_name);
    return 0;
  }

  pp->index = idx;
  if (idx < 20)
    pp->sigmask = ini_mEvent_plc1 << idx;
  pp->oid = pp_oid;

  if (errh_eAnix_plc1 + pp->index < errh_eAnix__)
    errh_SetAnix(errh_eAnix_plc1 + pp->index);
  errh_SetName(pp_name);

  sts = gdh_ObjidToPointer(pp_oid, (void*)&pp->PlcProcess);
  if (EVEN(sts))
    return 0;

  sts = gdh_GetClassList(pwr_cClass_SimulateConfig, &sim_oid);
  if (ODD(sts)) {
    sts = gdh_ObjidToPointer(sim_oid, (void*)&pp->SimConfig);
    if (EVEN(sts))
      return 0;
  }

  qcom_CreateQ(&sts, &pp->eventQ, NULL, "plcEvent");
  if (EVEN(sts)) {
    errh_Fatal("qcom_CreateQ(eventQ), %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  sts = thread_MutexInit(&pp->io_copy_mutex);
  if (EVEN(sts)) {
    errh_Fatal("thread_MutexInit(io_copy_mutex), %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  return pp;
}

static pwr_tStatus init_plc(plc_sProcess* pp, char* name)
{
  pwr_tStatus sts = PLC__SUCCESS;
  pwr_tObjid oid;
  pwr_tObjid io_oid;
  pwr_tObjid thread_oid;
  int sec;
  int msec;
  int i;
  pwr_tCid cid;

  sts = gdh_GetNodeObject(0, &oid);
  if (EVEN(sts)) {
    errh_Fatal("gdh_GetNodeObject, %m", sts);
    exit(sts);
  }

  sts = gdh_ObjidToPointer(oid, (void*)&pp->Node);
  if (EVEN(sts))
    return sts;

#if defined OS_LINUX
  if (pp->PlcProcess->CpuMask != 0) {
    cpu_set_t mask;

    CPU_ZERO(&mask);
    for (i = 0; i < 32; i++) {
      if (pp->PlcProcess->CpuMask & 1 << i)
        CPU_SET(i, &mask);
    }

    sts = sched_setaffinity(0, sizeof(mask), &mask);
    if (sts < 0)
      errh_Error("Unable to set affinity mask");
    else
      errh_Info("Affinity mask set to %d", pp->PlcProcess->CpuMask);
  }
#endif

  i = 0;
  sts = gdh_GetChild(pp->oid, &thread_oid);
  while (ODD(sts)) {
    sts = gdh_GetObjectClass(thread_oid, &cid);
    if (EVEN(sts))
      return sts;

    if (cid == pwr_cClass_PlcThread)
      pp->PlcProcess->PlcThreadObjects[i++] = thread_oid;

    sts = gdh_GetNextSibling(thread_oid, &thread_oid);
  }
  for (; i > sizeof(pp->PlcProcess->PlcThreadObjects)
           / sizeof(pp->PlcProcess->PlcThreadObjects[0]);
       i++)
    pp->PlcProcess->PlcThreadObjects[i] = pwr_cNObjid;

  aproc_RegisterObject(pp->oid);

  sts = gdh_GetClassList(pwr_cClass_IOHandler, &io_oid);
  if (EVEN(sts)) {
    errh_Error("Found no IOHandler-object\n%m", sts);
    return sts;
  }

  sts = gdh_ObjidToPointer(io_oid, (void*)&pp->IOHandler);
  if (EVEN(sts))
    return sts;

  /* Set subscription defaults for PLC job */

  sts = gdh_SetSubscriptionDefaults(
      (pwr_tInt32)(pp->PlcProcess->SubscriptionInterval * 1000.), 10000);

  sec = pp->PlcProcess->SubscriptionInterval;
  msec = (int)((pp->PlcProcess->SubscriptionInterval - sec) * 1000.);
  errh_Info("Setting subscription defaults to %d.%03d seconds", sec, msec);

  sts = gdh_ObjidToName(oid, pp->nodeName, sizeof(pp->nodeName), cdh_mNName);
  if (EVEN(sts))
    return sts;

  init_grafcet(pp);
  link_io_base_areas(pp);
  pp->system_time = (pwr_tTime*)pp->base.atv_a.p;

  return sts;
}

static void init_threads(plc_sProcess* pp)
{
  int i;
  plc_sThread* tp;
  pwr_tStatus sts;
  long int phase;

  for (i = 0, tp = pp->thread; i < pp->thread_count; i++, tp++) {
    /* Tell thread it is time for phase 2.  */
    que_Put(&sts, &tp->q_in, &tp->event, (void*)2);
    phase = (long int)que_Get(&sts, &tp->q_out, NULL, NULL);
    pwr_Assert(phase == 2);
  }
}

static void start_threads(plc_sProcess* pp)
{
  int i;
  plc_sThread* tp;
  pwr_tStatus sts;
  long int phase;

  for (i = 0, tp = pp->thread; i < pp->thread_count; i++, tp++) {
    /* Tell thread it is time for phase 3, start.  */
    que_Put(&sts, &tp->q_in, &tp->event, (void*)3);
    phase = (long int)que_Get(&sts, &tp->q_out, NULL, NULL);
    pwr_Assert(phase == 3);
  }
}

static void run_threads(plc_sProcess* pp)
{
  int i;
  plc_sThread* tp;
  pwr_tStatus sts;
  long int phase;

  for (i = 0, tp = pp->thread; i < pp->thread_count; i++, tp++) {
    /* Tell thread it is time for phase 4, run.  */
    que_Put(&sts, &tp->q_in, &tp->event, (void*)4);
    phase = (long int)que_Get(&sts, &tp->q_out, NULL, NULL);
    pwr_Assert(phase == 4);
  }
}

/* Wait for ALL of the threads to finish. If a thread'
   CycleTime <> 0, then we assume that there in fact is an active
   thread at that index, and therefore we wait until the
   process terminates. When ALL threads have terminated,
   then we lower the job priority for this job. This is done
   to avoid competing with a new PLC job for the CPU resources
   while we clean up before exiting.  */

static void stop_threads(plc_sProcess* pp)
{
  pwr_tInt32 i;
  pwr_tStatus sts;
  plc_sThread* tp;

  for (i = 0, tp = pp->thread; i < pp->thread_count; i++, tp++) {
    tp->exit = TRUE;
/* Tell thread it is time for phase 4, stop.  */

    que_Put(&sts, &tp->q_in, &tp->event, (void*)4);
  }
}

static void clean_all(plc_sProcess* pp)
{
  pwr_tStatus sts;

  sts = gdh_UnrefObjectInfoAll();
  if (EVEN(sts))
    errh_Error("gdh_UnrefObjectInfoAll, %m", sts);
}

/* Link to I/O base areas.
   Create area if it doesn't exist.
   All threads write to base area.  */

static void link_io_base_areas(plc_sProcess* pp)
{
  dlink_area((plc_sDlink*)&pp->base.ai_a, "pwrNode-active-io-ai",
      pp->IOHandler->AiCount * sizeof(pwr_tFloat32));
  dlink_area((plc_sDlink*)&pp->base.ao_a, "pwrNode-active-io-ao",
      pp->IOHandler->AoCount * sizeof(pwr_tFloat32));
  dlink_area((plc_sDlink*)&pp->base.av_a, "pwrNode-active-io-av",
      pp->IOHandler->AvCount * sizeof(pwr_tFloat32));
  dlink_area((plc_sDlink*)&pp->base.ca_a, "pwrNode-active-io-ca",
      pp->IOHandler->CoCount * sizeof(pwr_tInt32));
  dlink_area((plc_sDlink*)&pp->base.co_a, "pwrNode-active-io-co",
      pp->IOHandler->CoCount * sizeof(pwr_tInt32));
  dlink_area((plc_sDlink*)&pp->base.di_a, "pwrNode-active-io-di",
      pp->IOHandler->DiCount * sizeof(pwr_tBoolean));
  dlink_area((plc_sDlink*)&pp->base.do_a, "pwrNode-active-io-do",
      pp->IOHandler->DoCount * sizeof(pwr_tBoolean));
  dlink_area((plc_sDlink*)&pp->base.dv_a, "pwrNode-active-io-dv",
      pp->IOHandler->DvCount * sizeof(pwr_tBoolean));
  dlink_area((plc_sDlink*)&pp->base.ii_a, "pwrNode-active-io-ii",
      pp->IOHandler->IiCount * sizeof(pwr_tInt32));
  dlink_area((plc_sDlink*)&pp->base.io_a, "pwrNode-active-io-io",
      pp->IOHandler->IoCount * sizeof(pwr_tInt32));
  dlink_area((plc_sDlink*)&pp->base.iv_a, "pwrNode-active-io-iv",
      pp->IOHandler->IvCount * sizeof(pwr_tInt32));
  dlink_area((plc_sDlink*)&pp->base.atv_a, "pwrNode-active-io-atv",
      pp->IOHandler->ATvCount * sizeof(pwr_tTime));
  dlink_area((plc_sDlink*)&pp->base.dtv_a, "pwrNode-active-io-dtv",
      pp->IOHandler->DTvCount * sizeof(pwr_tDeltaTime));
  dlink_area((plc_sDlink*)&pp->base.sv_a, "pwrNode-active-io-sv",
      pp->IOHandler->SvCount * sizeof(pwr_tString80));
  dlink_area((plc_sDlink*)&pp->base.bi_a, "pwrNode-active-io-bi",
      pp->IOHandler->BiSize);
  dlink_area((plc_sDlink*)&pp->base.bo_a, "pwrNode-active-io-bo",
      pp->IOHandler->BoSize);
  dlink_area((plc_sDlink*)&pp->base.av_i, "pwrNode-active-io-av_init",
      pp->IOHandler->AvCount * sizeof(pwr_tUInt64));
  dlink_area((plc_sDlink*)&pp->base.dv_i, "pwrNode-active-io-dv_init",
      pp->IOHandler->DvCount * sizeof(pwr_tUInt64));
  dlink_area((plc_sDlink*)&pp->base.iv_i, "pwrNode-active-io-iv_init",
      pp->IOHandler->IvCount * sizeof(pwr_tUInt64));
  dlink_area((plc_sDlink*)&pp->base.ai_i, "pwrNode-active-io-ai_init",
      pp->IOHandler->AiCount * sizeof(pwr_tUInt64));
  dlink_area((plc_sDlink*)&pp->base.ao_i, "pwrNode-active-io-ao_init",
      pp->IOHandler->AoCount * sizeof(pwr_tUInt64));
  dlink_area((plc_sDlink*)&pp->base.di_i, "pwrNode-active-io-di_init",
      pp->IOHandler->DiCount * sizeof(pwr_tUInt64));
  dlink_area((plc_sDlink*)&pp->base.do_i, "pwrNode-active-io-do_init",
      pp->IOHandler->DoCount * sizeof(pwr_tUInt64));
  dlink_area((plc_sDlink*)&pp->base.ii_i, "pwrNode-active-io-ii_init",
      pp->IOHandler->IiCount * sizeof(pwr_tUInt64));
  dlink_area((plc_sDlink*)&pp->base.io_i, "pwrNode-active-io-io_init",
      pp->IOHandler->IoCount * sizeof(pwr_tUInt64));
  dlink_area((plc_sDlink*)&pp->base.atv_i, "pwrNode-active-io-atv_init",
      pp->IOHandler->ATvCount * sizeof(pwr_tTime));
  dlink_area((plc_sDlink*)&pp->base.dtv_i, "pwrNode-active-io-dtv_init",
      pp->IOHandler->DTvCount * sizeof(pwr_tDeltaTime));
  dlink_area((plc_sDlink*)&pp->base.sv_i, "pwrNode-active-io-sv_init",
      pp->IOHandler->SvCount * sizeof(pwr_tString80));
  dlink_area((plc_sDlink*)&pp->base.bi_i, "pwrNode-active-io-bi_init",
      pp->IOHandler->BiCount * sizeof(pwr_tUInt64));
  dlink_area((plc_sDlink*)&pp->base.bi_isize, "pwrNode-active-io-bi_initsize",
      pp->IOHandler->BiCount * sizeof(pwr_tUInt64));
  dlink_area((plc_sDlink*)&pp->base.bo_i, "pwrNode-active-io-bo_init",
      pp->IOHandler->BoCount * sizeof(pwr_tUInt64));
  dlink_area((plc_sDlink*)&pp->base.bo_isize, "pwrNode-active-io-bo_initsize",
      pp->IOHandler->BoCount * sizeof(pwr_tUInt64));
}

/* Link to I/O copy areas.
   Create area if it doesn't exist.
   All threads read from owned copy area.  */

static void link_io_copy_areas(plc_sThread* tp)
{
  plc_sProcess* pp = tp->pp;

  tp->copy.ai_a = pp->base.ai_a;
  tp->copy.ai_a.p = calloc(1, tp->copy.ai_a.size);

  tp->copy.ao_a = pp->base.ao_a;
  tp->copy.ao_a.p = calloc(1, tp->copy.ao_a.size);

  tp->copy.av_a = pp->base.av_a;
  tp->copy.av_a.p = calloc(1, tp->copy.av_a.size);

  tp->copy.ca_a = pp->base.ca_a;
  tp->copy.ca_a.p = calloc(1, tp->copy.ca_a.size);

  tp->copy.co_a = pp->base.co_a;
  tp->copy.co_a.p = calloc(1, tp->copy.co_a.size);

  tp->copy.di_a = pp->base.di_a;
  tp->copy.di_a.p = calloc(1, tp->copy.di_a.size);

  tp->copy.do_a = pp->base.do_a;
  tp->copy.do_a.p = calloc(1, tp->copy.do_a.size);

  tp->copy.dv_a = pp->base.dv_a;
  tp->copy.dv_a.p = calloc(1, tp->copy.dv_a.size);

  tp->copy.ii_a = pp->base.ii_a;
  tp->copy.ii_a.p = calloc(1, tp->copy.ii_a.size);

  tp->copy.io_a = pp->base.io_a;
  tp->copy.io_a.p = calloc(1, tp->copy.io_a.size);

  tp->copy.iv_a = pp->base.iv_a;
  tp->copy.iv_a.p = calloc(1, tp->copy.iv_a.size);

  tp->copy.atv_a = pp->base.atv_a;
  tp->copy.atv_a.p = calloc(1, tp->copy.atv_a.size);

  tp->copy.dtv_a = pp->base.dtv_a;
  tp->copy.dtv_a.p = calloc(1, tp->copy.dtv_a.size);

  tp->copy.sv_a = pp->base.sv_a;
  tp->copy.sv_a.p = calloc(1, tp->copy.sv_a.size);

  tp->copy.bi_a = pp->base.bi_a;
  tp->copy.bi_a.p = calloc(1, tp->copy.bi_a.size);

  tp->copy.bo_a = pp->base.bo_a;
  tp->copy.bo_a.p = calloc(1, tp->copy.bo_a.size);
}

static void dlink_area(plc_sDlink* dp, char* name, int size)
{
  pwr_tStatus sts;

  if ((dp->size = size) == 0)
    return; /* We have no objects of this type.  */

  sts = gdh_RefObjectInfo(name, &dp->p, &dp->sid, dp->size);
  if (EVEN(sts)) {
    errh_Error("Direct link object %s, %m", name, sts);
    exit(sts);
  }
}

static void create_threads(plc_sProcess* pp)
{
  plc_sThread* tp;
  plc_sProctbl** ptp;
  extern plc_sProctbl* plc_proctbllist[];

  /* Count our threads.  */
  for (ptp = plc_proctbllist; ptp != NULL && *ptp != NULL; ptp++)
    pp->thread_count++;

  tp = pp->thread = calloc(pp->thread_count, sizeof(*tp));

  for (ptp = plc_proctbllist; ptp != NULL && *ptp != NULL; ptp++, tp++)
    create_thread(tp, *ptp, pp);
}

static void create_thread(plc_sThread* tp, plc_sProctbl* ptp, plc_sProcess* pp)
{
  pwr_tStatus sts;
  long int phase;
  pwr_tOid oid;

  if (!pp->is_core)
    tp->aref = cdh_ObjidToAref(ptp->thread);
  else {    
    sts = gdh_GetClassList(pwr_cClass_PlcThread, &oid);
    if (EVEN(sts)) {
      errh_Error("Can't find PlcThread object, %m", sts);
      return;
    }
    tp->aref = cdh_ObjidToAref(oid);
    ptp->thread = tp->aref.Objid;
  }
  tp->init = ptp->init;
  tp->exec = ptp->exec;
  tp->first_scan = 1;

  tp->PlcThread = pwrb_PlcThread_Init(&sts, tp);
  tp->csup_lh = csup_Init(&sts, ptp->thread, tp->f_scan_time);

  tp->i_scan_time = tp->f_scan_time * 1000.0 + 0.5;

  time_FloatToD(&tp->scan_time, tp->f_scan_time);

  tp->pp = pp;

  plc_inittimer(tp);
  tp->exit = FALSE;
  link_io_copy_areas(tp);

  que_Create(&sts, &tp->q_in);
  que_Create(&sts, &tp->q_out);

  sts = gdh_ObjidToName(ptp->thread, tp->name, sizeof(tp->name), cdh_mNName);
  if (EVEN(sts)) {
    errh_Error("Get name of thread object %s, %m",
        cdh_ObjidToString(ptp->thread, 0), sts);
    return;
  }

  sts = gdh_ObjidToPointer(ptp->thread, (void*)&tp->PlcThread);
  if (EVEN(sts)) {
    errh_Error("Direct link to thread object \"%s\", %m", tp->name, sts);
    return;
  }

  sts = thread_Create(&tp->tid, tp->name, (void* (*)()) & plc_thread, tp);
  if (EVEN(sts)) {
    errh_Error("Creating thread \"%s\", %m", tp->name, sts);
    return;
  }

  /* Wait for thread to initialize.  */
  phase = (long int)que_Get(&sts, &tp->q_out, NULL, NULL);
  pwr_Assert(phase == 1);
}

/* Initializes all init steps on own node. */

static void init_grafcet()
{
  pwr_tStatus sts;
  pwr_tObjid oid;
  pwr_sClass_initstep* o;

  sts = gdh_GetClassList(pwr_cClass_initstep, &oid);
  while (ODD(sts)) {
    sts = gdh_ObjidToPointer(oid, (void*)&o);
    if (EVEN(sts)) {
      errh_Error("Initialize all GRAFCET init steps, %m", sts);
      return;
    }
    if (!o->StatusInit) {
      /* This InitStep is not initialized. */
      o->Status[0] = 1;
      o->StatusInit = 1;
    }
    sts = gdh_GetNextObject(oid, &oid);
  }
}

static void save_values(plc_sProcess* pp)
{
  int i;

  for (i = 0; i < pp->IOHandler->AvCount; i++) {
    pwr_tFloat32* p = gdh_TranslateRtdbPointer(pp->base.av_i.p->Value[i]);
    if (p != NULL)
      *p = pp->base.av_a.p->Value[i];
  }
  for (i = 0; i < pp->IOHandler->IvCount; i++) {
    pwr_tInt32* p = gdh_TranslateRtdbPointer(pp->base.iv_i.p->Value[i]);
    if (p != NULL)
      *p = pp->base.iv_a.p->Value[i];
  }
  for (i = 0; i < pp->IOHandler->DvCount; i++) {
    pwr_tBoolean* p = gdh_TranslateRtdbPointer(pp->base.dv_i.p->Value[i]);
    if (p != NULL)
      *p = pp->base.dv_a.p->Value[i];
  }
  for (i = 0; i < pp->IOHandler->AiCount; i++) {
    pwr_tFloat32* p = gdh_TranslateRtdbPointer(pp->base.ai_i.p->Value[i]);
    if (p != NULL)
      *p = pp->base.ai_a.p->Value[i];
  }
  for (i = 0; i < pp->IOHandler->AoCount; i++) {
    pwr_tFloat32* p = gdh_TranslateRtdbPointer(pp->base.ao_i.p->Value[i]);
    if (p != NULL)
      *p = pp->base.ao_a.p->Value[i];
  }
  for (i = 0; i < pp->IOHandler->DiCount; i++) {
    pwr_tBoolean* p = gdh_TranslateRtdbPointer(pp->base.di_i.p->Value[i]);
    if (p != NULL)
      *p = pp->base.di_a.p->Value[i];
  }
  for (i = 0; i < pp->IOHandler->DoCount; i++) {
    pwr_tBoolean* p = gdh_TranslateRtdbPointer(pp->base.do_i.p->Value[i]);
    if (p != NULL)
      *p = pp->base.do_a.p->Value[i];
  }
  for (i = 0; i < pp->IOHandler->IiCount; i++) {
    pwr_tInt32* p = gdh_TranslateRtdbPointer(pp->base.ii_i.p->Value[i]);
    if (p != NULL)
      *p = pp->base.ii_a.p->Value[i];
  }
  for (i = 0; i < pp->IOHandler->IoCount; i++) {
    pwr_tInt32* p = gdh_TranslateRtdbPointer(pp->base.io_i.p->Value[i]);
    if (p != NULL)
      *p = pp->base.io_a.p->Value[i];
  }
  for (i = 0; i < pp->IOHandler->BiCount; i++) {
    char* p = gdh_TranslateRtdbPointer(pp->base.bi_i.p->Value[i]);
    unsigned int idx = pp->base.bi_isize.p->Value[i] >> 32;
    unsigned int size = 0xFFFFFFFF & pp->base.bi_isize.p->Value[i];
    if (p != NULL && idx + size <= pp->IOHandler->BiSize)
      memcpy(p, &pp->base.bi_a.p->Value[idx], size);
  }
  for (i = 0; i < pp->IOHandler->BoCount; i++) {
    char* p = gdh_TranslateRtdbPointer(pp->base.bo_i.p->Value[i]);
    unsigned int idx = pp->base.bo_isize.p->Value[i] >> 32;
    unsigned int size = 0xFFFFFFFF & pp->base.bo_isize.p->Value[i];
    if (p != NULL && idx + size <= pp->IOHandler->BoSize)
      memcpy(p, &pp->base.bo_a.p->Value[idx], size);
  }
}

static void set_values(plc_sProcess* pp)
{
  int i;

  for (i = 0; i < pp->IOHandler->AvCount; i++) {
    pwr_tFloat32* p = gdh_TranslateRtdbPointer(pp->base.av_i.p->Value[i]);
    if (p != NULL)
      pp->base.av_a.p->Value[i] = *p;
  }
  for (i = 0; i < pp->IOHandler->IvCount; i++) {
    pwr_tInt32* p = gdh_TranslateRtdbPointer(pp->base.iv_i.p->Value[i]);
    if (p != NULL)
      pp->base.iv_a.p->Value[i] = *p;
  }
  for (i = 0; i < pp->IOHandler->DvCount; i++) {
    pwr_tBoolean* p = gdh_TranslateRtdbPointer(pp->base.dv_i.p->Value[i]);
    if (p != NULL)
      pp->base.dv_a.p->Value[i] = *p;
  }
  for (i = 0; i < pp->IOHandler->AiCount; i++) {
    pwr_tFloat32* p = gdh_TranslateRtdbPointer(pp->base.ai_i.p->Value[i]);
    if (p != NULL)
      pp->base.ai_a.p->Value[i] = *p;
  }
  for (i = 0; i < pp->IOHandler->AoCount; i++) {
    pwr_tFloat32* p = gdh_TranslateRtdbPointer(pp->base.ao_i.p->Value[i]);
    if (p != NULL)
      pp->base.ao_a.p->Value[i] = *p;
  }
  for (i = 0; i < pp->IOHandler->DiCount; i++) {
    pwr_tBoolean* p = gdh_TranslateRtdbPointer(pp->base.di_i.p->Value[i]);
    if (p != NULL)
      pp->base.di_a.p->Value[i] = *p;
  }
  for (i = 0; i < pp->IOHandler->DoCount; i++) {
    pwr_tBoolean* p = gdh_TranslateRtdbPointer(pp->base.do_i.p->Value[i]);
    if (p != NULL)
      pp->base.do_a.p->Value[i] = *p;
  }
  for (i = 0; i < pp->IOHandler->IiCount; i++) {
    pwr_tInt32* p = gdh_TranslateRtdbPointer(pp->base.ii_i.p->Value[i]);
    if (p != NULL)
      pp->base.ii_a.p->Value[i] = *p;
  }
  for (i = 0; i < pp->IOHandler->IoCount; i++) {
    pwr_tInt32* p = gdh_TranslateRtdbPointer(pp->base.io_i.p->Value[i]);
    if (p != NULL)
      pp->base.io_a.p->Value[i] = *p;
  }
  for (i = 0; i < pp->IOHandler->BiCount; i++) {
    char* p = gdh_TranslateRtdbPointer(pp->base.bi_i.p->Value[i]);
    unsigned int idx = pp->base.bi_isize.p->Value[i] >> 32;
    unsigned int size = 0xFFFFFFFF & pp->base.bi_isize.p->Value[i];
    if (p != NULL && idx + size <= pp->IOHandler->BiSize)
      memcpy(&pp->base.bi_a.p->Value[idx], p, size);
  }
  for (i = 0; i < pp->IOHandler->BoCount; i++) {
    char* p = gdh_TranslateRtdbPointer(pp->base.bo_i.p->Value[i]);
    unsigned int idx = pp->base.bo_isize.p->Value[i] >> 32;
    unsigned int size = 0xFFFFFFFF & pp->base.bo_isize.p->Value[i];
    if (p != NULL && idx + size <= pp->IOHandler->BoSize)
      memcpy(&pp->base.bo_a.p->Value[idx], p, size);
  }
}
