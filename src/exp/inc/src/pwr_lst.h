/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#ifndef pwr_lst_h
#define pwr_lst_h

/* pwr_lst.h -- list macros
*/

struct LstHead {
  struct LstHead *next, *prev;
};

/*
 * LstInsert(s_LstLink_T* next, s_LstLink_T elem) inserts the element \a into
 * the linked list before the element \a next.
 *
 * Before:
 * a <-> c
 *
 * Calling LstInsert(c, b)
 * a <- b   (a <- b)
 * b -> c   (a <- b -> c)
 * a -> b   (a <-> b -> c)
 * b <- c   (a <-> b <-> c)
 */
static inline void LstInsert(struct LstHead *p, struct LstHead *e)
{
    e->prev = p->prev;
    e->next = p;
    p->prev->next = e;
    p->prev = e;
}

/*
 * LstRemove(s_LstLink_T) removes the element from the linked list, which is
 * done by modifying the next element to point at the previous and vice versa.
 */
static inline void LstRemove(struct LstHead *p)
{
    p->next->prev = p->prev;
    p->prev->next = p->next;
}

/*
 * LstNull(s_LstLink_T) sets the linked list to NULL.
 */
static inline void LstNull(struct LstHead *p)
{
    p->next = p->prev = NULL;
}

/*
 * LstIsNull(s_LstLink_T) checks if the linked list is NULL.
 */
static inline int LstIsNull(struct LstHead *p)
{
    return (p->next == NULL && p->prev == NULL);
}

/*
 * LstInit(s_LstLink_T) initializes the linked list.
 */
static inline void LstInit(struct LstHead *h)
{
    h->next = h->prev = h;
}

/*
 * LstEntry(s_LstLink_T*, sTimer, ll) fetches the struct sTimer corresponding to
 * the list pointer \a ptr.
 * It does this by calculating the offset of a list pointers \a ll within the
 * struct sTimer, and then subtracts that from the list pointer \a ptr.
 */
#ifndef offsetof
#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
#endif

#ifndef container_of
#define container_of(ptr, type, member) ({			          \
    const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
    (type *)( (char *)__mptr - offsetof(type,member) );})
#endif

#define LstEntry(ptr, type, member) container_of(ptr, type, member)

/*
 * LstEmpty(s_LstLink_T) checks if the linked list is empty.
 */
static inline int LstEmpty(struct LstHead *h)
{
    return h->next == h;
}

/*
 * LstForEach(i, listHead) is a convenience macro for:
 * for (i = listHead->next; i != listHead, i = i->next)
 */
#define LstForEach(pos, head) \
    for (pos = (head)->next; pos != (head); pos = pos->next)

#endif
