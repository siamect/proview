#
# ProviewR   Open Source Process Control.
# Copyright (C) 2005-2019 SSAB EMEA AB.
#
# This file is part of ProviewR.
#
# This program is free software; you can redistribute it and/or 
# modify it under the terms of the GNU General Public License as 
# published by the Free Software Foundation, either version 2 of 
# the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful 
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License 
# along with ProviewR. If not, see <http://www.gnu.org/licenses/>
#
# Linking ProviewR statically or dynamically with other modules is
# making a combined work based on ProviewR. Thus, the terms and
# conditions of the GNU General Public License cover the whole 
# combination.
#
# In addition, as a special exception, the copyright holders of
# ProviewR give you permission to, from the build function in the
# ProviewR Configurator, combine ProviewR with modules generated by the
# ProviewR PLC Editor to a PLC program, regardless of the license
# terms of these modules. You may copy and distribute the resulting
# combined work under the terms of your choice, provided that every 
# copy of the combined work is accompanied by a complete copy of 
# the source code of ProviewR (the version used to produce the
# combined work), being distributed under the terms of the GNU 
# General Public License plus this exception.
#

import os
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
from scipy.interpolate import interp1d
import co
from rt_mva_msg import *

# adapted from http://matplotlib.org/examples/specialty_plots/hinton_demo.html
def hinton(matrix, max_weight=None, ax=None):
    """Draw Hinton diagram for visualizing a weight matrix."""
    ax = ax if ax is not None else plt.gca()

    if not max_weight:
        max_weight = 2**np.ceil(np.log(np.abs(matrix).max())/np.log(2))

    ax.patch.set_facecolor('lightgray')
    ax.set_aspect('equal', 'box')
    ax.xaxis.set_major_locator(plt.NullLocator())
    ax.yaxis.set_major_locator(plt.NullLocator())

    for (x, y), w in np.ndenumerate(matrix):
        color = 'red' if w > 0 else 'blue'
        size = np.sqrt(np.abs(w))
        if size > 0.98: size = 0.98        
        rect = plt.Rectangle([x - size / 2, y - size / 2], size, size,
                             facecolor=color, edgecolor=color)
        ax.add_patch(rect)

    nticks = matrix.shape[0]
    ax.xaxis.tick_top()
    ax.set_xticks(range(nticks))
    ax.set_xticklabels(list(matrix.columns), rotation=90)
    ax.set_yticks(range(nticks))
    ax.set_yticklabels(matrix.columns)
    ax.grid(False)

    ax.autoscale_view()
    ax.invert_yaxis()



class WData:
    """WData class, container for measuring data.

    wd 	 Frame with data except time column
    wdtime Frame with time column
    wdname Attribute names
    wdcol  Column names A1, A2 etc
    """

    OP_NO = 0
    OP_COPY = 1
    OP_NORM = 2
    OP_SQUARE = 3
    OP_SQUAREROOT = 4
    OP_EXP = 5
    OP_LOG = 6
    OP_INTEGRAL = 7
    OP_DERIVATE = 8
    OP_ADD = 9
    OP_SUB = 10
    OP_MULTIPLY = 11
    OP_DIVIDE = 12
    OP_CURVE = 13
    OP_CONSTANT = 14
    OP_SHIFT = 15
        
    operations = ((OP_NO, 'No'),
                  (OP_COPY, 'Copy'),
                  (OP_NORM, 'Norm'),
                  (OP_SQUARE, 'Square'),
                  (OP_SQUAREROOT, 'Squareroot'),
                  (OP_EXP, 'Exp'),
                  (OP_LOG, 'Log'),
                  (OP_INTEGRAL, 'Integral'),
                  (OP_DERIVATE, 'Derivate'),
                  (OP_ADD, 'Add'),
                  (OP_SUB, 'Sub'),
                  (OP_MULTIPLY, 'Multiply'),
                  (OP_DIVIDE, 'Divide'),
                  (OP_CURVE, 'Curve'),
                  (OP_CONSTANT, 'Const'),
                  (OP_SHIFT, 'Shift'))

    def __init__(self):
        self.set = False
        self.name = ''
        self.wd = None
        self.wdname = None
        self.wdcol = None
        self.wdtime = None
        self.origdata = None
        self.origcol = None
        self.add_replace = 0
        
    def empty(self):
        """Returns true is no data is set yet."""
        return not self.set

    def rows(self):
        """Number of rows in wd."""
        if self.empty():
            return 0
        return self.wd.shape[0]

    def columns(self):
        """Number of columns in wd."""
        if self.empty():
            return 0
        return self.wd.shape[1]
    
    def set_data(self, data, col, name):
        """Insert new data."""
        self.origdata = data
        self.origcol = self.origdata.columns
        
        self.wd = self.origdata.loc[:,self.origcol[1]:]
        self.wdtime = self.origdata.loc[:,self.origcol[0]]
        self.wd.columns = col
        self.wdcol = col
        self.wdname = name 
        self.set = True

    def set_add_replace(self, ar):
        self.add_replace = ar;
        
    def read_file(self, file):
    
        self.origdata = pd.read_csv(file, parse_dates=[0])
        self.origcol = self.origdata.columns
        self.wd = self.origdata.loc[:,self.origcol[1]:]
        self.wdtime = self.origdata.loc[:,self.origcol[0]]
        self.set = True

        self.wdcol = []
        self.wdname = []

        i = 0
        while i < self.columns():
            colname = "A" + str(i+1)
            self.wdcol.append(colname)
            self.wdname.append(self.origcol[i+1])
            i += 1

        self.wd.columns = self.wdcol

    def save_orig(self, file):
        self.origdata.to_csv(file, index=False)

    def save_wd(self, file):
        save = self.wd
        save.columns = self.wdname
        save.insert(0, 'Time', self.wdtime)
        save.to_csv(file, index=False)
                
    def set_name(self, name):
        self.name = name

    def plot(self, mask):
        if self.empty():
            return

        cols = []
        i = 0;
        for name in self.wdname:
            if mask[i]:
                cols.append(self.wdcol[i])
            i += 1
                     
        if len(cols) != 0:
            plotdata = self.wd[cols]
        else:
            plotdata = self.wd
        ax = plotdata.plot()
        ax.legend(loc='center left', bbox_to_anchor=(1, 0.5));
        ax.get_figure().canvas.set_window_title('Plot ' + self.name)

        plt.show()

    def indplot(self, mask):
        if self.empty():
            return

        cols = []
        i = 0;
        ccnt = 0
        for name in self.wdname:
            if mask[i]:
                cols.append(self.wdcol[i])
                ccnt += 1
            i += 1
                     

        if len(cols) != 0:
            plotdata = self.wd[cols]
        else:
            plotdata = self.wd
            ccnt = self.columns()
            cols = self.wdcol
        
        layo = ccnt * 100 + 10

        j = 0
        fig = plt.figure()
        fig.canvas.set_window_title('Plot ' + self.name)
        while j < ccnt:
            plt.subplot(layo+j+1)
            plt.plot(self.wdtime, plotdata[cols[j]])
            plt.legend(loc='center left', bbox_to_anchor=(1, 0.5));
            j = j + 1

        plt.show()

    def scatterplot(self, mask):
        if self.empty():
            return

        cols = []
        i = 0;
        for name in self.wdname:
            if mask[i]:
                cols.append(self.wdcol[i])
            i += 1
                     
        if len(cols) != 0:
            plotdata = self.wd[cols]
        else:
            plotdata = self.wd
        
        ax = plotdata.plot()
        ax.clear()
        pd.tools.plotting.scatter_matrix(plotdata, diagonal="kde", ax=ax)
        ax.get_figure().canvas.set_window_title('Scatterplot ' + self.name)
        plt.tight_layout()
        plt.show()

    def correlation_plot(self, mask):
        if self.empty():
            return

        cols = []
        i = 0;
        for name in self.wdname:
            if mask[i]:
                cols.append(self.wdcol[i])
            i += 1
                     
        if len(cols) != 0:
            plotdata = self.wd[cols]
        else:
            plotdata = self.wd
        corrmat = plotdata.corr()
        fig = plt.figure()
        fig.canvas.set_window_title('Correlation Plot ' + self.name)
        hinton(corrmat)
        plt.show()

    def correlation2_plot(self, mask):
        if self.empty():
            return

        cols = []
        i = 0;
        for name in self.wdname:
            if mask[i]:
                cols.append(self.wdcol[i])
            i += 1
                     
        if len(cols) != 0:
            plotdata = self.wd[cols]
        else:
            plotdata = self.wd
        corrmat = plotdata.corr()
        fig = plt.figure()
        fig.canvas.set_window_title('Correlation Heatmap ' + self.name)
        sns.heatmap(corrmat, vmin=-1., vmax=1., square=False, cmap='RdBu_r', annot=True).xaxis.tick_top()
        plt.show()

    def regression_plot(self, mask):
        if self.empty():
            return

        cols = []
        i = 0;
        for name in self.wdname:
            if mask[i]:
                cols.append(self.wdcol[i])
            i += 1
                     
        if len(cols) != 2:
            raise co.Error(0, 'Select two attributes')

        plotdata = self.wd[cols]
        fig = plt.figure()
        fig.canvas.set_window_title('Linear Regression Plot ' + self.name)
        sns.regplot(x=cols[0],y=cols[1],data=plotdata)
        plt.show()

    def revert(self):
        if self.empty():
            return
    
        self.wd = self.origdata.loc[:,self.origcol[1]:]
        self.wdtime = self.origdata.loc[:,self.origcol[0]]

        self.wdcol = []
        self.wdname = []

        i = 0
        while i < self.columns():
            colname = "A" + str(i+1)
            self.wdcol.append(colname)
            self.wdname.append(self.origcol[i+1])
            i += 1

        self.wd.columns = self.wdcol

    def moveup(self, mask):
        cix = []
        i = 0;
        for name in self.wdname:
            if mask[i]:
                cix.append(i)
            i += 1
                     
        if len(cix) != 1:
            raise co.Error(0, "Select one attribute")

        if cix[0] == 0:
            raise co.Error(0, "Can't move top object")
    
        cols = list(self.wd)
        cols[cix[0]-1],cols[cix[0]] = cols[cix[0]],cols[cix[0]-1]
        self.wdname[cix[0]-1],self.wdname[cix[0]] = self.wdname[cix[0]],self.wdname[cix[0]-1]
        self.wd = self.wd.ix[:,cols]
        self.wd.columns = self.wdcol

    def movedown(self, mask):
        cix = []
        i = 0;
        for name in self.wdname:
            if mask[i]:
                cix.append(i)
            i += 1
                     
        if len(cix) != 1:
            raise co.Error(0, "Select one attributes")
            return

        if cix[0] == len(self.wdname) - 1:
            raise co.Error(0, "Can't move bottom object")
            return
    
        cols = list(self.wd)
        cols[cix[0]],cols[cix[0]+1] = cols[cix[0]+1],cols[cix[0]]
        self.wdname[cix[0]],self.wdname[cix[0]+1] = self.wdname[cix[0]+1],self.wdname[cix[0]]
        self.wd = self.wd.ix[:,cols]
        self.wd.columns = self.wdcol

    def delete_columns(self, mask):
        i = 0
        new_wdcol = []
        new_wdname = []
        cols = []
        for name in self.wdname:
            if not mask[i]:
                new_wdcol.append(self.wdcol[i])
                new_wdname.append(self.wdname[i])
            i += 1
                     
        if len(new_wdname) == len(self.wdname):
            raise co.Error(0, "No columns selected")
        
        if len(new_wdcol) != 0:
            self.wd = self.wd[new_wdcol]
            self.wdcol = new_wdcol
            self.wdname = new_wdname

            i = 0
            while i < self.columns():
                colname = "A" + str(i+1)
                self.wdcol[i] = colname
                i += 1
            self.wd.columns = self.wdcol
        
    def clip(self, minvalue, maxvalue):
        self.wd = self.wd[minvalue:maxvalue]
        self.wdtime = self.wdtime[minvalue:maxvalue]
        self.wd = self.wd.reset_index(drop=True)
        self.wdtime = self.wdtime.reset_index(drop=True)

    def split(self, value):
        wdata = WData()
        wdata.origdata = self.origdata
        wdata.origcol = self.origcol
        wdata.wd = self.wd[value:]
        wdata.wdtime = self.wdtime[value:]
        wdata.wd = wdata.wd.reset_index(drop=True)
        wdata.wdtime = wdata.wdtime.reset_index(drop=True)
        wdata.wdcol = self.wdcol[:]
        wdata.wdname = self.wdname[:]
        wdata.set = True

        self.wd = self.wd[:value]
        self.wdtime = self.wdtime[:value]
        return wdata

    def concat(self, ccwd, ccname, ccwdtime):
        # Remove superfluous columns
        i = 0
        cccol = []
        new_ccname = []
        for wname in self.wdname:
            found = False
            for cname in ccname:
                if cname == wname:
                    found = True
                    cccol.append(self.wdcol[i])
                    new_ccname.append(cname)
                    break
            if not found:
                raise co.Error(0, "Columns don't match")                

            i += 1
        ccwd = ccwd[cccol]
        t1 = self.wdtime[len(self.wdtime)-1] + (self.wdtime[len(self.wdtime)-1] - self.wdtime[len(self.wdtime)-2])
        t2 = ccwdtime[0]
        ccwdtime -= t2-t1
        self.wd = pd.concat([self.wd, ccwd])
        self.wdtime = pd.concat([self.wdtime, ccwdtime])
        self.wd = self.wd.reset_index(drop=True)
        self.wdtime = self.wdtime.reset_index(drop=True)

        
    def concat_file(self, file):
        ccdata = pd.read_csv(file, parse_dates=[0])
        ccname = ccdata.columns
        ccwd = ccdata.loc[:,ccname[1]:]
        ccwdtime = ccdata.loc[:,ccname[0]]

        # Remove superfluous columns
        i = 0
        cccol = []
        new_ccname = []
        for wname in self.wdname:
            found = False
            for cname in ccname:
                if cname == wname:
                    found = True
                    cccol.append(self.wdcol[i])
                    new_ccname.append(cname)
                    break
            if not found:
                raise co.Error(0, "Columns don't match")

            i += 1
        ccwd = ccwd[new_ccname]
        ccwd.columns = self.wdcol
        t1 = self.wdtime[len(self.wdtime)-1] + (self.wdtime[len(self.wdtime)-1] - self.wdtime[len(self.wdtime)-2])
        t2 = ccwdtime[0]
        ccwdtime -= t2-t1
        self.wd = pd.concat([self.wd, ccwd])
        self.wdtime = pd.concat([self.wdtime, ccwdtime])
        self.wd = self.wd.reset_index(drop=True)
        self.wdtime = self.wdtime.reset_index(drop=True)

    def multiply(self, value):
        ccwd = self.wd.copy()
        ccname = self.wdname
        ccwdtime = self.wdtime.copy()
        i = 0
        while i < value - 1:
            self.concat(ccwd, ccname, ccwdtime)
            i += 1

    def parse_arg(self, arg):
        level = 0
        found = False
        idx = 0
        a1 = ""
        a2 = ""
        for c in arg:
            if c == '(':
                level += 1
            elif c == ')':
                level -= 1
            elif c == ',' and level == 0:
                found = True
                break
            idx += 1

        if found:
            a1 = arg[0:idx]
            a2 = arg[idx+1:]
        else:
            a1 = arg
        return a1, a2

    def parse_op(self, str, opv, par1v, par2v):
        idx = str.find('(')
        if idx == -1:
            op = 'No'
            return self.OP_NO
        else:
            ridx = str.rfind(')')
            if ridx == -1:
                raise co.Error(0, "Syntax error, parenthesis mismatch " + str(idx))

            arg = str[idx+1:ridx]
            op = str[0:idx]
            found = 0
            for oper in self.operations:
                if oper[1] == op:
                    found = 1
                    a1, a2 = self.parse_arg(arg)
                    opv.append(oper[0])
                    par1v.append(a1)
                    par2v.append(a2)
                    self.parse_op(a1, opv, par1v, par2v)
                    if a2 != "":
                        self.parse_op(a2, opv, par1v, par2v)
                    return 1
            if not found:
                raise co.Error(0, "Syntax error, unknown operator " + str(op))

    def save_formula(self, file):
        fp = open(file, 'w')
        for name in self.wdname:
            fp.write(name + "\n")
        fp.close()

    def apply_formula(self, file):
        if not os.path.exists(file):
            raise co.Error(MVA__NOFRM, 'Unable to find formula file')
        
        formulas = []
        fp = open(file, 'r')
        for name in fp:
            formulas.append(name.rstrip())
        fp.close()        

        for formula in formulas:
            opv = []
            par1v = []
            par2v = []

            sts = self.parse_op(formula, opv, par1v, par2v)

            i = len(opv) - 1
            for op in reversed(opv):
                self.exec_op(op, par1v[i], par2v[i])
                i -= 1

        self.formula_trim(formulas)

    def formula_trim(self, formulas):

        keep = [False] * len(self.wdname)
        kept = [False] * len(formulas)
        i = 0
        for name in self.wdname:
            j = 0
            for formula in formulas:
                if name == formula and not kept[j]:                
                    keep[i] = True
                    kept[j] = True
                    break
                j += 1
            i += 1

        i = 0
        new_wdcol = []
        new_wdname = []
        cols = []
        for name in self.wdname:
            if keep[i]:
                new_wdcol.append(self.wdcol[i])
                new_wdname.append(self.wdname[i])
            i += 1
                     
        if len(new_wdname) == len(self.wdname):
            return
        
        if len(new_wdcol) != 0:
            self.wd = self.wd[new_wdcol]
            self.wdcol = new_wdcol
            self.wdname = new_wdname

            i = 0
            while i < self.columns():
                colname = "A" + str(i+1)
                self.wdcol[i] = colname
                i += 1
            self.wd.columns = self.wdcol
        
    def exec_op(self, op, par1, par2):

        arg1 = None
        found1 = False
        found2 = False
        i1 = 0
        i2 = 0
        for name in self.wdname:
            if name == par1:
                found1 = True
                break
            i1 += 1

        if op == self.OP_SHIFT:
            arg1 = par2
        elif op == self.OP_CURVE:
            arg1 = par2
        elif op == self.OP_CONSTANT:
            arg1 = par1
            i1 = -1
        elif par2 != "":
            for name in self.wdname:
                if name == par2:
                    found2 = True
                    break
                i2 += 1

        self.op_exec(op, i1, i2, arg1)

    def op_exec(self, op, cix1, cix2, arg1):
        if cix1 != -1:
            ser = pd.Series(self.wd[self.wdcol[cix1]])
        
        if op == self.OP_COPY:
            colname = self.wdname[cix1]
        elif op == self.OP_NORM:
            mean = ser.mean()
            ser -= mean
            colname = "Norm(" + self.wdname[cix1] + ")"
        elif op == self.OP_SQUARE:
            ser = np.square(ser)
            colname = "Square(" + self.wdname[cix1] + ")"
        elif op == self.OP_SQUAREROOT:
            ser = np.sqrt(ser)
            colname = "Sqrt(" + self.wdname[cix1] + ")"
        elif op == self.OP_EXP:
            ser = np.exp(ser)
            colname = "Exp(" + self.wdname[cix1] + ")"
        elif op == self.OP_LOG:
            ser = np.log(ser)
            colname = "Log(" + self.wdname[cix1] + ")"
        elif op == self.OP_INTEGRAL:
            igl = []
            acc = 0
            i = 0
            dmean = ser.mean()

            for val in ser.values:    
                igl.append(acc)
                if i != len(ser) - 1:
                    dt = self.wdtime[i+1]-self.wdtime[i]
                else:
                    dt = old_dt
                acc += val * (dt.seconds + dt.microseconds/1000000.0)
                i += 1
                old_dt = dt

            ser = pd.Series(igl)
            colname = "Integral(" + self.wdname[cix1] + ")"
        elif op == self.OP_DERIVATE:
            der = []
            old_val = 0
            i = 0
            for val in ser.values:
                if i != len(ser) - 1:
                    dt = self.wdtime[i+1]-self.wdtime[i]
                else:
                    dt = old_dt
                der.append((val - old_val)/(dt.seconds + dt.microseconds/1000000.0))
                i += 1
                old_dt = dt
                old_val = val

            ser = pd.Series(der)
            colname = "Derivate(" + self.wdname[cix1] + ")"
        elif op == self.OP_ADD:
            add = []
            i = 0
            for val in ser.values:
                val2 = self.wd[self.wdcol[cix2]][i]
                add.append(val + val2)
                i += 1
            ser = pd.Series(add)
            colname = "Add(" + self.wdname[cix1] + "," + self.wdname[cix2] + ")"
        elif op == self.OP_SUB:
            sub = []
            i = 0
            for val in ser.values:
                val2 = self.wd[self.wdcol[cix2]][i]
                sub.append(val - val2)
                i += 1
            ser = pd.Series(sub)
            colname = "Sub(" + self.wdname[cix1] + "," + self.wdname[cix2] + ")"
        elif op == self.OP_MULTIPLY:
            mul = []
            i = 0
            for val in ser.values:
                val2 = self.wd[self.wdcol[cix2]][i]
                mul.append(val * val2)
                i += 1
            ser = pd.Series(mul)
            colname = "Multiply(" + self.wdname[cix1] + "," + self.wdname[cix2] + ")"
        elif op == self.OP_DIVIDE:
            div = []
            i = 0
            for val in ser.values:
                cval = self.wd[self.wdcol[cix2]][i]
                div.append(val/cval if cval else 0)
                i += 1
            ser = pd.Series(div)
            colname = "Divide(" + self.wdname[cix1] + "," + self.wdname[cix2] + ")"

        elif op == self.OP_CURVE:
            if arg1 == '':
                raise co.Error(0, 'No curve file is supplied')
            
            fname = co.translateFilename(arg1)
            curveframe = pd.read_csv(fname, header=None)
            fcurve = interp1d(curveframe.loc[:,0],curveframe.loc[:,1], fill_value='extrapolate')

            curve = fcurve(ser.values)
            ser = pd.Series(curve)
            colname = "Curve(" + self.wdname[cix1] + "," + arg1 + ")"

        elif op == self.OP_CONSTANT:
            value = float(arg1)

            const = [value] * len(self.wd)
            ser = pd.Series(const)
            colname = "Const(" + str(value) + ")"

        elif op == self.OP_SHIFT:
            shiftvalue = int(arg1)

            shift = []
            i = 0
            for val in ser.values:
                if shiftvalue > 0:
                    if i < shiftvalue:
                        val = 0
                    else:
                        val = ser.values[i-shiftvalue]
                else:
                    if i - shiftvalue >= len(self.wd):
                        val = 0
                    else:
                        val = ser.values[i-shiftvalue]
                shift.append(val)
                i += 1
            ser = pd.Series(shift)
            colname = "Shift(" + self.wdname[cix1] + "," + str(shiftvalue) + ")"
        else:
            raise co.Error(0, 'No action is selected')

        idx = len(self.wdname)

        if self.add_replace == 1:
            self.wd[self.wdcol[cix1]] = ser
            self.wdname[cix1] = colname
        else:
            self.wdname.append(colname)
            colname = "A" + str(idx+1)
            self.wdcol.append(colname)
            self.wd[self.wdcol[idx]] = ser
    

