#!/usr/bin/python3
#
# ProviewR   Open Source Process Control.
# Copyright (C) 2005-2019 SSAB EMEA AB.
#
# This file is part of ProviewR.
#
# This program is free software; you can redistribute it and/or 
# modify it under the terms of the GNU General Public License as 
# published by the Free Software Foundation, either version 2 of 
# the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful 
# but WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License 
# along with ProviewR. If not, see <http://www.gnu.org/licenses/>
#
# Linking ProviewR statically or dynamically with other modules is
# making a combined work based on ProviewR. Thus, the terms and
# conditions of the GNU General Public License cover the whole 
# combination.
#
# In addition, as a special exception, the copyright holders of
# ProviewR give you permission to, from the build function in the
# ProviewR Configurator, combine ProviewR with modules generated by the
# ProviewR PLC Editor to a PLC program, regardless of the license
# terms of these modules. You may copy and distribute the resulting
# combined work under the terms of your choice, provided that every 
# copy of the combined work is accompanied by a complete copy of 
# the source code of ProviewR (the version used to produce the
# combined work), being distributed under the terms of the GNU 
# General Public License plus this exception.
#

# Maintenance supervision server

import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
from scipy.interpolate import interp1d
import sys
import math
import time
import datetime
import getopt
import os
import pwrrt
import co
import rt
from rt_mva import *
from rt_mva_msg import *

class SupObj:
    def __init__(self, sup):
        global scantime
        
        self.sup = sup
        self.name = sup.name()
        self.sts = 0
        self.limitsts = [None] * 10 

        aname = sup.fullName() + '.ScanTime'
        a = pwrrt.attribute(aname)
        self.scantime = a.value()
        self.cnt = 0
        self.interval = self.scantime/scantime

        self.dsup = []
        i = 0
        while i < 10:
            dsup = rt.DSup(sup.fullName() + '.Limits[' + str(i) + '].Sup')
            self.dsup.append(dsup)
            i += 1

    def setSts(self, sts):
        if self.sts != sts:
            self.sts = sts
            a = pwrrt.attribute(self.sup.fullName() + '.Status')
            a.setValue(sts)

    def evenSts(self):
        return (self.sts & 1) == 0

    def oddSts(self):
        return (self.sts & 1) != 0

    def setLimitSts(self, idx, sts):
        if self.limitsts[idx] != sts:
            self.limitsts[idx] = sts
            a = pwrrt.attribute(self.sup.fullName() + '.Limits[' + str(idx) + '].Status')
            a.setValue(sts)

#
# Open function, backcall from application
#
def open_cb():
    global olist

    pwrrt.login('pwrp', 'pwrp')

    olist = []
    cid = pwrrt.Cid('LinRegSup')
    for attr in cid.attrObjects():
        o = SupObj(attr)
        olist.append(o)
        o.setSts(MVA__NORMAL)
        
#
# Close function, backcall from application
#
def close_cb():
    print('Closing down')
        
#
# Scan function, backcall from application
#
def scan_cb():
    global olist

    for o in olist:
        if o.cnt < o.interval:
            o.cnt += 1
            continue

        o.cnt = 0
        process(o)

#
# Handling of a LinRegSup object
#
def process(o):
    if o.evenSts() and o.sts != MVA__STDLOW and o.sts != MVA__SCORELOW and \
           o.sts != MVA__SERVERTIMEOUT and o.sts != MVA__SERVERREAD:
        return

    a = pwrrt.attribute(o.sup.fullName() + '.Server')
    server = a.value()
    a = pwrrt.attribute(o.sup.fullName() + '.FormulaFile')
    formulafile = co.translateFilename(a.value())
    a = pwrrt.attribute(o.sup.fullName() + '.MeasuringTime')
    measuringtime = a.value()
    a = pwrrt.attribute(o.sup.fullName() + '.PointInterval')
    pointinterval = a.value()
    a = pwrrt.attribute(o.sup.fullName() + '.MaxNoOfPoints')
    maxnoofpoints = a.value()
    a = pwrrt.attribute(o.sup.fullName() + '.StdDeviationMinLimit')
    stdmin = a.value()
    a = pwrrt.attribute(o.sup.fullName() + '.ScoreMinLimit')
    scoremin = a.value()
    a = pwrrt.attribute(o.sup.fullName() + '.CondAttr')
    condattr = a.value().strip()
    i = 0
    options = 0
    dataoid = []
    dataattr = []
    dataname = []
    origcol = ['Time']
    datacol = []
    isobject = []
    
    # If condition attribute, insert attribute first in list
    if condattr != '':
        options = pwrrt.FRAME_OPTIONS_CONDITION
        idx = condattr.find('.')
        dataoid.append(condattr[:idx])
        dataattr.append(condattr[idx+1:])
        isobject.append(False)
        
    # Insert other attributes
    while i < 10:
        a = pwrrt.attribute(o.sup.fullName() + '.Attributes[' + str(i) + ']')
        attr = a.value().strip()
        if attr == '':
            break;
    
        idx = attr.find('.')
        dataname.append(attr)
        origcol.append(attr)
        dataoid.append(attr[:idx])
        dataattr.append(attr[idx+1:])
        datacol.append('A' + str(i+1))
        isobject.append(False)
        i += 1
        
    # Fetch data from server
    try:
        result = pwrrt.getSevItemsDataFrame( server, dataoid, dataattr, isobject,
             measuringtime, 'now', pointinterval, maxnoofpoints, '-', options)
    except RuntimeError as e:
        print(str(e), e)
        if str(e) == '%QCOM-E-TMO, time out':
            o.setSts(MVA__SERVERTIMEOUT)
        else:
            o.setSts(MVA__SERVERREAD)
        return
    if result == None:
        o.setSts(MVA__NODATA)
        return

    sts = MVA__NORMAL

    origdata = pd.DataFrame(data=result)
    origdata.columns = origcol

    wf = WData()
    wf.set_data(origdata, datacol, dataname)

    # Check standard deviation
    if stdmin > 0:
        std = wf.wd[datacol[0]].std()
        a = pwrrt.attribute(o.sup.fullName() + '.CurrentStdDeviation')
        a.setValue(std)
        if std < stdmin:
            o.setSts(MVA__STDLOW)
            a = pwrrt.attribute(o.sup.fullName() + '.CurrentScore')
            a.setValue(0.0)
            return
                
    try:
        print('Apply formula')
        wf.apply_formula(formulafile)
    except co.Error as e:
        o.setSts(e.status)
        return

    # Fit linear regression model
    slr = LinearRegression()
    reg = slr.fit(wf.wd.iloc[:,1:], wf.wd.iloc[:,0:1])
    #print('coef', slr.coef_)
    #print('intercept', slr.intercept_)

    # Check score
    if scoremin > 0:
        pred = slr.predict(wf.wd.iloc[:,1:])
        score = r2_score(pred, wf.wd.iloc[:,0:1])
        a = pwrrt.attribute(o.sup.fullName() + '.CurrentScore')
        a.setValue(score)
        if score < scoremin:
            sts = MVA__SCORELOW

    if (sts & 1) != 0:
        a = pwrrt.attribute(o.sup.fullName() + '.LastScan')
        a.setValue(datetime.datetime.now().strftime('%d-%b-%Y %H:%M:%S'))

    # Check coefficient limits
    i = 0
    while i < len(slr.coef_[0]):
        a = pwrrt.attribute(o.sup.fullName() + '.Limits[' + str(i) + '].InitCoef')
        initcoef = a.value()
        a = pwrrt.attribute(o.sup.fullName() + '.Limits[' + str(i) + '].LastCoef')
        a.setValue(slr.coef_[0][i])
        a = pwrrt.attribute(o.sup.fullName() + '.Limits[' + str(i) + '].Deviation')
        a.setValue(slr.coef_[0][i] - initcoef)

        a = pwrrt.attribute(o.sup.fullName() + '.Limits[' + str(i) + '].MinLimit')
        minlimit = a.value()
        a = pwrrt.attribute(o.sup.fullName() + '.Limits[' + str(i) + '].MaxLimit')
        maxlimit = a.value()
        if (sts & 1) != 0:
            if slr.coef_[0][i] >= maxlimit or slr.coef_[0][i] <= minlimit: 
                o.setLimitSts(i, MVA__COEFLIMIT)
                if not o.dsup[i].active:
                    o.dsup[i].setDetect()
            else:
                o.setLimitSts(i, MVA__COEF)
                if o.dsup[i].active:
                    o.dsup[i].setReturn()
        i += 1

    o.setSts(sts)


# Init gdh
pwrrt.init('MaintSupServer')

# Get server object
cid = pwrrt.Cid('MaintSupServer')
server = None
for o in cid.objects():
    server = o
    break

if server == None:
    exit()
    
a = o.attribute('ScanTime')
scantime = a.value()


# Create application
a = pwrrt.application('MaintSupServer',o.fullName(), 29, scantime,
                      open_cb, scan_cb, close_cb, None)
a.mainloop()
 
