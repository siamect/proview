/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <map>

#include "co_cdh.h"
#include "co_dcli.h"
#include "co_error.h"
#include "co_string.h"
#include "co_syi.h"
#include "co_time.h"

#include "rt_aproc.h"
#include "rt_gdh.h"
#include "rt_ini_event.h"
#include "rt_mh_util.h"
#include "rt_post.h"
#include "rt_pwr_msg.h"
#include "rt_qcom_msg.h"

static rt_post* post = 0;
std::map<pid_t, pwr_ePostType> rt_post::dispatchProcesses;

typedef union alau_Event ala_uEvent;
union alau_Event {
  mh_sMsgInfo Info;
  mh_sAck Ack;
  mh_sMessage Msg;
  mh_sReturn Return;
  mh_sBlock Block;
};

rt_post::rt_post()
    : scan_time(1), conf(0), udb(0), sent_sms_startidx(0), sent_sms_endidx(0),
      sent_email_startidx(0), sent_email_endidx(0)
{
  pwr_tStatus sts;

  strcpy(systemgroup, "");
  syi_NodeName(&sts, nodename, sizeof(nodename));
}

void rt_post::open()
{
  pwr_tStatus sts;
  pwr_tObjid oid;
  pwr_tFileName filename;

  // Open server configuration object PostConfig
  sts = gdh_GetClassList(pwr_cClass_PostConfig, &oid);
  if (ODD(sts)) {
    sts = gdh_ObjidToPointer(oid, (void**)&conf);
    if (EVEN(sts))
      throw co_error(sts);

    aproc_RegisterObject(oid);
  } else {
    errh_Info("No Post configuration");
    errh_SetStatus(0);
    exit(0);
  }

  conf->Status = PWR__SRVSTARTUP;

  // Connect to mh
  mh_UtilWaitForMh();

  sts = mh_OutunitConnect(oid, mh_eOutunitType_Post, 0, mh_ack_bc, mh_alarm_bc,
      mh_block_bc, mh_cancel_bc, mh_clear_alarmlist_bc, mh_clear_blocklist_bc,
      mh_info_bc, mh_return_bc, NULL);
  if (EVEN(sts)) {
    errh_Error("Post terminated: %m", sts);
    conf->Status = sts;
    exit(0);
  }

  // Load user database

  sts = gdh_GetObjectInfo(
      "pwrNode-System.SystemGroup", &systemgroup, sizeof(systemgroup));
  if (EVEN(sts)) {
    errh_Error("Post terminated: %m", sts);
    conf->Status = sts;
    exit(0);
  }

  udb = new GeUser();
  sts = dcli_get_defaultfilename(user_cFilename, filename, "");
  udb->load(filename);

  conf->Status = PWR__SRUN;
}

int rt_post::check_dispatch()
{
  int wstatus;
  pid_t wpid;

  for (auto proc_it = dispatchProcesses.begin(); proc_it != dispatchProcesses.end();)
  {
    wpid = waitpid(proc_it->first, &wstatus, WNOHANG);

    if (wpid > 0)
    {
      if (WEXITSTATUS(wstatus))
      {
        errh_Error(
            "Unable to send mail/sms to recipient. Check configuration!");
      }
      else
      {
        try
        {
          switch (proc_it->second)
          {
          case pwr_ePostType_Mail:
            post->conf->SentEmail++;
            break;
          case pwr_ePostType_SMS:
            post->conf->SentSMS++;
            break;
          default:
            errh_Warning("Unknown rt_post dispatch process!");
          }
          proc_it = dispatchProcesses.erase(proc_it);
          continue;
        }
        catch (std::exception& e)
        {
          errh_Warning("Error checking rt_post dispatch process");
        }
      }
    }
    else if (wpid == -1)
    {
      // Pretty much implies ECHILD since WNOHANG is used and options are correct...
      // If all is good, this would never happen though...

      // Clear dispatch list since we don't have any children to tend to anyways...
      dispatchProcesses.clear();
      return -1;
    }
    proc_it++;
  }

  return 0;
}

void rt_post::close()
{
  short unsigned int retries_left = 10;
  // Wait for any children still trying to send mail/sms...
  while (!dispatchProcesses.empty() && retries_left--)
  {
    // Break in the odd event of an error upon waiting for children. -1 indicate an error...
    // Otherwise check again after a while. If the mail/sms service is having problems this can take a while.
    // Abort after 10 retries
    if (check_dispatch() < 0)
      break;
    sleep(1);
  }

  mh_OutunitDisconnect();
}

void rt_post::scan()
{
  pwr_tStatus sts = 1;

  // Check if any sending processes have finished.
  // Don't care about the return value...
  if (!dispatchProcesses.empty())
    check_dispatch();

  while (ODD(sts))
    sts = mh_OutunitReceive();

  aproc_TimeStamp(scantime(), 5);
}

void rt_post::init(qcom_sQid* qid)
{
  qcom_sQid qini;
  qcom_sQattr qAttr;
  pwr_tStatus sts;

  sts = gdh_Init("rt_post");
  if (EVEN(sts)) {
    errh_Fatal("gdh_Init, %m", sts);
    exit(sts);
  }

  errh_Init("pwr_post", errh_eAnix_post);
  errh_SetStatus(PWR__SRVSTARTUP);

  if (!qcom_Init(&sts, 0, "pwr_post")) {
    errh_Fatal("qcom_Init, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  qAttr.type = qcom_eQtype_private;
  qAttr.quota = 100;
  if (!qcom_CreateQ(&sts, qid, &qAttr, "events")) {
    errh_Fatal("qcom_CreateQ, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  qini = qcom_cQini;
  if (!qcom_Bind(&sts, qid, &qini)) {
    errh_Fatal("qcom_Bind(Qini), %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(-1);
  }
}

pwr_tStatus rt_post::mh_ack_bc(mh_sAck* MsgP)
{
  return 1;
}
pwr_tStatus rt_post::mh_return_bc(mh_sReturn* MsgP)
{
  return 1;
}
pwr_tStatus rt_post::mh_alarm_bc(mh_sMessage* MsgP)
{

  pid_t cpid;
  ala_uEvent* event = (ala_uEvent*)MsgP;
  int sts;
  char str[256];
  char user[80];
  char group[80];
  char* s;
  pwr_tTime etime, current;
  pwr_tDeltaTime diff;
  int rcvnum;
  char rcv_array[10][80];
  char text[400];

  if (!post || post->conf->Disable)
    return 1;

  if (!((event->Info.EventFlags & pwr_mEventFlagsMask_Email) ||
        (event->Info.EventFlags & pwr_mEventFlagsMask_SMS)))
    return 1;

  // Skip events older than 10 minutes
  etime = net_NetTimeToTime(&event->Info.EventTime);
  time_GetTime(&current);
  time_Adiff(&diff, &current, &etime);

  if (time_DToFloat(0, &diff) > 600)
    return 1;

  // Check if already handled
  if (event->Info.EventFlags & pwr_mEventFlagsMask_Email) {
    if (post->email_check(&event->Info.Id))
      return 1;
    else
      post->email_register(&event->Info.Id);
  }
  if (event->Info.EventFlags & pwr_mEventFlagsMask_SMS)
  {
    if (post->sms_check(&event->Info.Id))
      return 1;
    else
      post->sms_register(&event->Info.Id);
  }

  post->replace_symbol(str, event->Msg.Receiver);

  rcvnum = dcli_parse(str, ",", "", (char*)rcv_array,
      sizeof(rcv_array) / sizeof(rcv_array[0]), sizeof(rcv_array[0]), 0);

  for (int i = 0; i < rcvnum; i++) {
    str_trim(str, rcv_array[i]);

    s = strrchr(str, '.');
    if (s) {
      *s = 0;
      strncpy(group, post->systemgroup, sizeof(group));
      strncat(group, ".", sizeof(group) - strlen(group) - 1);
      strncat(group, str, sizeof(group) - strlen(group) - 1);
      strncpy(user, s + 1, sizeof(user));
    } else {
      strncpy(group, post->systemgroup, sizeof(group));
      strncpy(user, str, sizeof(user));
    }

    SystemName* sn = new SystemName(group);
    sts = sn->parse();
    if (EVEN(sts)) {
      delete sn;
      errh_Error("Post systemgroup parse error, %m", sts);
      continue;
    }

    SystemList* sl = post->udb->find_system(sn);
    delete sn;
    if (!sl) {
      errh_Error("No such system group, %s", group);
      continue;
    }

    UserList* ul = (UserList*)sl->find_user(user);
    if (!ul) {
      errh_Error("No such user, %s", user);
      continue;
    }

    if (event->Info.EventFlags & pwr_mEventFlagsMask_Email
        && !streq(post->conf->EmailCmd, "")) {
      char address[40];
      pwr_tCmd cmd;

      ul->get_email(address, sizeof(address));

      post->format_email_text(MsgP, text, sizeof(text));
      post->format_cmd(cmd, post->conf->EmailCmd, address, text);

      if (post->conf->Options & pwr_mPostOptionsMask_Log)
        errh_Info("Email: %s", cmd);

      // Fork and execute command
      if ((cpid = fork()) == -1)
      {
        errh_Warning("Unable to fork a process for sending Email!");
      }
      else if (cpid == 0)
      {
        execl("/bin/sh", "sh", "-c", cmd, (char*)0);
        _exit(EXIT_FAILURE);
      }
      else
      {
        dispatchProcesses.insert(std::make_pair(cpid, pwr_ePostType_Mail));
      }
    }
    if (event->Info.EventFlags & pwr_mEventFlagsMask_SMS
        && !streq(post->conf->SMS_Cmd, "")) {
      char sms[40];
      pwr_tCmd cmd;

      ul->get_sms(sms, sizeof(sms));

      post->format_sms_text(MsgP, text, sizeof(text));
      post->format_cmd(cmd, post->conf->SMS_Cmd, sms, text);

      if (post->conf->Options & pwr_mPostOptionsMask_Log)
        errh_Info("SMS: %s", cmd);

      // Fork and execute command
      if ((cpid = fork()) == -1)
      {
        errh_Warning("Unable to fork a process for sending SMS!");
      }
      else if (cpid == 0)
      {
        execl("/bin/sh", "sh", "-c", cmd, (char*)0);
        _exit(EXIT_FAILURE);
      }
      else
      {
        dispatchProcesses.insert(std::make_pair(cpid, pwr_ePostType_SMS));
      }
    }
  }
  return 1;
}
pwr_tStatus rt_post::mh_block_bc(mh_sBlock* MsgP)
{
  return 1;
}
pwr_tStatus rt_post::mh_cancel_bc(mh_sReturn* MsgP)
{
  return 1;
}
pwr_tStatus rt_post::mh_info_bc(mh_sMessage* MsgP)
{
  return mh_alarm_bc(MsgP);
}
pwr_tStatus rt_post::mh_clear_alarmlist_bc(pwr_tNodeIndex nix)
{
  return 1;
}
pwr_tStatus rt_post::mh_clear_blocklist_bc(pwr_tNodeIndex nix)
{
  return 1;
}

void rt_post::format_sms_text(mh_sMessage* MsgP, char* text, unsigned int size)
{
  ala_uEvent* event = (ala_uEvent*)MsgP;
  char prio[2];

  switch (event->Info.EventPrio) {
  case mh_eEventPrio_A:
    strcpy(prio, "A");
    break;
  case mh_eEventPrio_B:
    strcpy(prio, "B");
    break;
  case mh_eEventPrio_C:
    strcpy(prio, "C");
    break;
  case mh_eEventPrio_D:
    strcpy(prio, "D");
    break;
  default:
    strcpy(prio, "?");
  }

  if (conf->Options & pwr_mPostOptionsMask_SingleLineSMS)
    snprintf(text, size, "Proview %s Prio %s, %s, %s", nodename, prio,
        event->Msg.EventText, event->Msg.EventName);
  else
    snprintf(text, size, "Proview %s Prio %s,\n%s,\n%s", nodename, prio,
        event->Msg.EventText, event->Msg.EventName);
}

void rt_post::format_email_text(
    mh_sMessage* MsgP, char* text, unsigned int size)
{
  ala_uEvent* event = (ala_uEvent*)MsgP;
  char prio[2];
  pwr_tTime etime;
  char timstr[40];

  switch (event->Info.EventPrio) {
  case mh_eEventPrio_A:
    strcpy(prio, "A");
    break;
  case mh_eEventPrio_B:
    strcpy(prio, "B");
    break;
  case mh_eEventPrio_C:
    strcpy(prio, "C");
    break;
  case mh_eEventPrio_D:
    strcpy(prio, "D");
    break;
  default:
    strcpy(prio, "?");
  }

  etime = net_NetTimeToTime(&event->Info.EventTime);
  time_AtoAscii(&etime, time_eFormat_DateAndTime, timstr, sizeof(timstr));

  snprintf(text, size, "Proview alarm from node %s\nPriority %s\nEvent time "
                       "%s\n\nEvent text:  %s\nEvent name:  %s",
      nodename, prio, timstr, event->Msg.EventText, event->Msg.EventName);
}

void rt_post::format_cmd(char* cmd, char* format, char* address, char* text)
{
  char* s1;
  pwr_tCmd str;

  strncpy(cmd, format, sizeof(pwr_tCmd));

  // Replace $address with address
  s1 = strstr(cmd, "$address");
  if (s1) {
    strncpy(str, s1 + strlen("$address"), sizeof(str));
    *s1 = 0;
    strncat(cmd, address, sizeof(pwr_tCmd));
    strncat(cmd, str, sizeof(pwr_tCmd));
  }

  // Replace $text with text
  s1 = strstr(cmd, "$text");
  if (s1) {
    strncpy(str, s1 + strlen("$text"), sizeof(str));
    *s1 = 0;
    strncat(cmd, text, sizeof(pwr_tCmd));
    strncat(cmd, str, sizeof(pwr_tCmd));
  }
}

void rt_post::replace_symbol(char* outstr, char* instr)
{
  char *s, *t, *u = NULL;
  int symbolmode = 0;
  char symbol[80];
  char csymbol[80];
  int size;
  int found;

  s = instr;
  t = outstr;

  while (1) {
    if (symbolmode) {
      if (*s == ',' || *s == ' ' || *s == '	' || *s == 0) {
        // End of symbol
        size = (long int)s - (long int)(u + 1);
        strncpy(symbol, u + 1, size);
        symbol[size] = 0;

        // Find the symbol
        found = 0;
        for (unsigned int j = 0;
             j < sizeof(conf->Symbols) / sizeof(conf->Symbols[0]); j++) {
          str_trim(csymbol, conf->Symbols[j].Name);
          if (streq(symbol, csymbol)) {
            // Found, insert the value
            strcpy(t, conf->Symbols[j].Value);
            t += strlen(conf->Symbols[j].Value);
            found = 1;
            break;
          }
        }
        if (!found) {
          // Not found
          strcpy(t, "$");
          t++;
          strcat(t, symbol);
          t += strlen(symbol);
        }
        symbolmode = 0;
        *t = *s;
        t++;
      }
    } else {
      if (*s == '$') {
        symbolmode = 1;
        u = s;
      } else {
        *t = *s;
        t++;
      }
    }
    if (*s == 0)
      break;
    s++;
  }
}

void rt_post::email_register(mh_sEventId* id)
{
  memcpy(&sent_email[sent_email_endidx], id, sizeof(sent_email[0]));
  sent_email_endidx++;
  if (sent_email_endidx >= sizeof(sent_email) / sizeof(sent_email[0]))
    sent_email_endidx = 0;
  if (sent_email_endidx == sent_email_startidx)
    sent_email_startidx++;
  if (sent_email_startidx >= sizeof(sent_email) / sizeof(sent_email[0]))
    sent_email_startidx = 0;
}

int rt_post::email_check(mh_sEventId* id)
{
  unsigned int i;

  for (i = sent_email_startidx;; i++) {
    if (i >= sizeof(sent_email) / sizeof(sent_email[0]))
      i = 0;

    if (i == sent_email_endidx)
      break;

    if (memcmp(&sent_email[i], id, sizeof(*id)) == 0)
      return 1;
  }
  return 0;
}

void rt_post::sms_register(mh_sEventId* id)
{
  memcpy(&sent_sms[sent_sms_endidx], id, sizeof(sent_sms[0]));
  sent_sms_endidx++;
  if (sent_sms_endidx >= sizeof(sent_sms) / sizeof(sent_sms[0]))
    sent_sms_endidx = 0;
  if (sent_sms_endidx == sent_sms_startidx)
    sent_sms_startidx++;
  if (sent_sms_startidx >= sizeof(sent_sms) / sizeof(sent_sms[0]))
    sent_sms_startidx = 0;
}

int rt_post::sms_check(mh_sEventId* id)
{
  unsigned int i;

  for (i = sent_sms_startidx;; i++) {
    if (i >= sizeof(sent_sms) / sizeof(sent_sms[0]))
      i = 0;

    if (i == sent_sms_endidx)
      break;

    if (memcmp(&sent_sms[i], id, sizeof(*id)) == 0)
      return 1;
  }
  return 0;
}

int main()
{
  pwr_tStatus sts;
  int tmo = 0;
  char mp[2000];
  qcom_sQid qid = qcom_cNQid;
  qcom_sGet get;
  int swap = 0;
  bool first_scan = true;

  post = new rt_post();
  post->init(&qid);

  try {
    post->open();
  } catch (co_error& e) {
    errh_Error((char*)e.what().c_str());
    errh_Fatal("rt_post aborting");
    errh_SetStatus(PWR__SRVTERM);
    exit(0);
  }

  aproc_TimeStamp(post->scantime(), 10);
  errh_SetStatus(PWR__SRUN);

  first_scan = true;
  for (;;) {
    if (first_scan) {
      tmo = (int)(post->scantime() * 1000 - 1);
    }

    get.maxSize = sizeof(mp);
    get.data = mp;
    qcom_Get(&sts, &qid, &get, tmo);
    if (sts == QCOM__TMO || sts == QCOM__QEMPTY) {
      if (!swap)
        post->scan();
    } else {
      ini_mEvent new_event;
      qcom_sEvent* ep = (qcom_sEvent*)get.data;

      new_event.m = ep->mask;
      if (new_event.b.oldPlcStop && !swap) {
        errh_SetStatus(PWR__SRVRESTART);
        post->conf->Status = PWR__SRVRESTART;
        swap = 1;
        post->close();
      } else if (new_event.b.swapDone && swap) {
        swap = 0;
        post->open();
        errh_SetStatus(PWR__SRUN);
        post->conf->Status = PWR__SRUN;
      } else if (new_event.b.terminate) {
        exit(0);
      }
    }
    first_scan = false;
  }
}
