/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2012 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */


#include <math.h>
#include <float.h>
#include <stdlib.h>

#include "rt_post.h"
#include "co_error.h"
#include "rt_gdh.h"
#include "co_cdh.h"
#include "co_time.h"
#include "co_dcli.h"
#include "co_syi.h"
#include "rt_errh.h"
#include "rt_qcom.h"
#include "rt_ini_event.h"
#include "rt_aproc.h"
#include "rt_pwr_msg.h"
#include "rt_qcom_msg.h"
#include "rt_mh_util.h"

static rt_post *post = 0;

typedef union alau_Event ala_uEvent;
union alau_Event 
{
    mh_sMsgInfo Info;
    mh_sAck	Ack;
    mh_sMessage Msg;
    mh_sReturn  Return;
    mh_sBlock   Block;
};

rt_post::rt_post() : scan_time(1), conf(0), udb(0), sent_sms_startidx(0), sent_sms_endidx(0), 
		     sent_email_startidx(0), sent_email_endidx(0)
{ 
  pwr_tStatus sts;

  strcpy( systemgroup, ""); 
  syi_NodeName( &sts, nodename, sizeof(nodename));
}

void rt_post::open()
{
  pwr_tStatus sts;
  pwr_tObjid oid;
  pwr_tFileName filename;

  // Open server configuration object PostConfig
  sts = gdh_GetClassList( pwr_cClass_PostConfig, &oid);
  if ( ODD(sts)) {
    sts = gdh_ObjidToPointer( oid, (void **)&conf);
    if ( EVEN(sts)) throw co_error( sts);

    aproc_RegisterObject( oid);
  }
  else {
    errh_Info( "No Post configuration");
    errh_SetStatus( 0);
    exit(0);
  }

  conf->Status = PWR__SRVSTARTUP;

  // Connect to mh
  mh_UtilWaitForMh();

  sts = mh_OutunitConnect(
		oid,
		mh_eOutunitType_Post,
		0,
		mh_ack_bc,
		mh_alarm_bc,
		mh_block_bc,
		mh_cancel_bc,
		mh_clear_alarmlist_bc,
		mh_clear_blocklist_bc,
		mh_info_bc,
		mh_return_bc
		);
  if ( EVEN(sts)) {
    errh_Error( "Post terminated: %m", sts);
    conf->Status = sts;
    exit(0);
  }

  // Load user database
	
  sts = gdh_GetObjectInfo( "pwrNode-System.SystemGroup", &systemgroup, 
			   sizeof(systemgroup));
  if ( EVEN(sts)) {
    errh_Error( "Post terminated: %m", sts);
    conf->Status = sts;
    exit(0);
  }

  udb = new GeUser();
  sts = dcli_get_defaultfilename( user_cFilename, filename, "");
  udb->load( filename);

  conf->Status = PWR__SRUN;

}

void rt_post::close()
{
  mh_OutunitDisconnect();
}

void rt_post::scan()
{
  pwr_tStatus sts = 1;

  while (ODD(sts))
    sts = mh_OutunitReceive();

  aproc_TimeStamp( scantime(), 5);
}

void rt_post::init( qcom_sQid *qid)
{
  qcom_sQid qini;
  qcom_sQattr qAttr;
  pwr_tStatus sts;

  sts = gdh_Init("rt_post");
  if ( EVEN(sts)) {
    errh_Fatal( "gdh_Init, %m", sts);
    exit(sts);
  }

  errh_Init("pwr_post", errh_eAnix_post);
  errh_SetStatus( PWR__SRVSTARTUP);

  if (!qcom_Init(&sts, 0, "pwr_post")) {
    errh_Fatal("qcom_Init, %m", sts); 
    errh_SetStatus( PWR__SRVTERM);
   exit(sts);
  } 

  qAttr.type = qcom_eQtype_private;
  qAttr.quota = 100;
  if (!qcom_CreateQ(&sts, qid, &qAttr, "events")) {
    errh_Fatal("qcom_CreateQ, %m", sts);
    errh_SetStatus( PWR__SRVTERM);
    exit(sts);
  } 

  qini = qcom_cQini;
  if (!qcom_Bind(&sts, qid, &qini)) {
    errh_Fatal("qcom_Bind(Qini), %m", sts);
    errh_SetStatus( PWR__SRVTERM);
    exit(-1);
  }
}

pwr_tStatus rt_post::mh_ack_bc( mh_sAck *MsgP)
{
  return 1;
}
pwr_tStatus rt_post::mh_return_bc( mh_sReturn *MsgP)
{
  return 1;
}
pwr_tStatus rt_post::mh_alarm_bc( mh_sMessage *MsgP)
{
  ala_uEvent 	*event = (ala_uEvent *) MsgP;
  int sts;
  char str[256];
  char user[80];
  char group[80];
  char *s;
  pwr_tTime etime, current;
  pwr_tDeltaTime diff;
  int rcvnum;
  char rcv_array[10][80];
  char text[400];

  if ( !post || post->conf->Disable)
    return 1;

  if ( !event->Info.EventFlags & pwr_mEventFlagsMask_Email ||
       !event->Info.EventFlags & pwr_mEventFlagsMask_SMS)
    return 1;

  // Skip events older than 10 minutes
  etime = net_NetTimeToTime( &event->Info.EventTime);
  time_GetTime( &current);
  time_Adiff( &diff, &current, &etime);

  if ( time_DToFloat( 0, &diff) > 600)
    return 1;

  // Check if already handled
  if ( event->Info.EventFlags & pwr_mEventFlagsMask_Email) {
    if ( post->email_check( &event->Info.Id))
      return 1;
    else
      post->email_register( &event->Info.Id);
  }
  

  if ( event->Info.EventFlags & pwr_mEventFlagsMask_SMS) {
    if ( post->sms_check( &event->Info.Id))
      return 1;
    else
      post->sms_register( &event->Info.Id);
  }

  post->replace_symbol( str, event->Msg.Receiver);

  rcvnum = dcli_parse( str, ",", "",
		     (char *) rcv_array, sizeof( rcv_array)/sizeof( rcv_array[0]),
		     sizeof( rcv_array[0]), 0);
  
  for ( int i = 0; i < rcvnum; i++) {

    dcli_trim( str, rcv_array[i]);

    s = strrchr( str, '.');
    if ( s) {
      *s = 0;
      strncpy( group, post->systemgroup, sizeof(group));
      strncat( group, ".", sizeof(group));
      strncat( group, str, sizeof(group));
      strncpy( user, s+1, sizeof(user));
    }
    else {
      strncpy( group, post->systemgroup, sizeof(group));
      strncpy( user, str, sizeof(user));
    }
  
    SystemName *sn = new SystemName( group);
    sts = sn->parse();
    if ( EVEN(sts)) {
      delete sn;
      errh_Error( "Post systemgroup parse error, %m", sts);
      continue;
    }

    SystemList *sl = post->udb->find_system( sn);
    delete sn;
    if ( !sl) {
      errh_Error( "No such system group, %s", group);
      continue;
    }

    UserList *ul = (UserList *) sl->find_user( user);
    if ( !ul) {
      errh_Error( "No such user, %s", user);
      continue;
    }
  
    if ( event->Info.EventFlags & pwr_mEventFlagsMask_Email &&
	 strcmp( post->conf->EmailCmd, "") != 0) {
      char address[40];
      pwr_tCmd cmd;
      
      ul->get_email( address, sizeof(address));
      
      post->format_email_text( MsgP, text, sizeof(text));
      post->format_cmd( cmd,  post->conf->EmailCmd, address, text);

      if ( post->conf->Log)
	errh_Info( "Email: %s", cmd);

      system( cmd);
      post->conf->SentEmail++;
      
    }
    if ( event->Info.EventFlags & pwr_mEventFlagsMask_SMS &&
	 strcmp( post->conf->SMS_Cmd, "") != 0) {
      char sms[40];
      pwr_tCmd cmd;
    
      ul->get_sms( sms, sizeof(sms));

      post->format_sms_text( MsgP, text, sizeof(text));
      post->format_cmd( cmd,  post->conf->SMS_Cmd, sms, text);
      
      if ( post->conf->Log)
	errh_Info( "SMS: %s", cmd);

      system( cmd);
      post->conf->SentSMS++;
    }
  }
  return 1;
}
pwr_tStatus rt_post::mh_block_bc( mh_sBlock *MsgP)
{
  return 1;
}
pwr_tStatus rt_post::mh_cancel_bc( mh_sReturn *MsgP)
{
  return 1;
}
pwr_tStatus rt_post::mh_info_bc( mh_sMessage *MsgP)
{
  return 1;
}
pwr_tStatus rt_post::mh_clear_alarmlist_bc( pwr_tNodeIndex nix)
{
  return 1;
}
pwr_tStatus rt_post::mh_clear_blocklist_bc( pwr_tNodeIndex nix)
{
  return 1;
}

void rt_post::format_sms_text( mh_sMessage *MsgP, char *text, unsigned int size)
{
  ala_uEvent 	*event = (ala_uEvent *) MsgP;
  char 		prio[2];
  
  switch ( event->Info.EventPrio) {
  case mh_eEventPrio_A:
    strcpy( prio, "A");
    break;
  case mh_eEventPrio_B:
    strcpy( prio, "B");
    break;
  case mh_eEventPrio_C:
    strcpy( prio, "C");
    break;
  case mh_eEventPrio_D:
    strcpy( prio, "D");
    break;
  default:
    strcpy( prio, "?");
  }

  snprintf( text, size, "Proview %s Prio %s,\n%s,\n%s", nodename, prio, event->Msg.EventText,
	    event->Msg.EventName);
}

void rt_post::format_email_text( mh_sMessage *MsgP, char *text, unsigned int size)
{
  ala_uEvent 	*event = (ala_uEvent *) MsgP;
  char prio[2];
  pwr_tTime etime;
  char timstr[40];
  
  switch ( event->Info.EventPrio) {
  case mh_eEventPrio_A:
    strcpy( prio, "A");
    break;
  case mh_eEventPrio_B:
    strcpy( prio, "B");
    break;
  case mh_eEventPrio_C:
    strcpy( prio, "C");
    break;
  case mh_eEventPrio_D:
    strcpy( prio, "D");
    break;
  default:
    strcpy( prio, "?");
  }

  etime = net_NetTimeToTime( &event->Info.EventTime);
  time_AtoAscii( &etime, time_eFormat_DateAndTime, timstr, sizeof(timstr));

  snprintf( text, size, "Proview alarm from node %s\nPriority %s\nEvent time %s\n\nEvent text:  %s\nEvent name:  %s", 
	    nodename, prio, timstr, event->Msg.EventText, event->Msg.EventName);
}

void rt_post::format_cmd( char *cmd, char *format, char *address, char *text)
{
  char *s1;
  pwr_tCmd str;

  strncpy( cmd, format, sizeof(pwr_tCmd));

  // Replace $address with address
  s1 = strstr( cmd, "$address");
  if ( s1) {
    strncpy( str, s1 + strlen("$address"), sizeof(str));
    *s1 = 0;
    strncat( cmd, address, sizeof(pwr_tCmd));
    strncat( cmd, str, sizeof(pwr_tCmd));
  }

  // Replace $text with text
  s1 = strstr( cmd, "$text");
  if ( s1) {
    strncpy( str, s1 + strlen("$text"), sizeof(str));
    *s1 = 0;
    strncat( cmd, text, sizeof(pwr_tCmd));
    strncat( cmd, str, sizeof(pwr_tCmd));
  }
}

void rt_post::replace_symbol( char *outstr, char *instr)
{
  char *s, *t, *u;
  int symbolmode = 0;
  char symbol[80];
  char csymbol[80];
  int size;
  int found;

  s = instr;
  t = outstr;

  while ( 1) {
    if ( symbolmode) {
      if ( *s == ',' || *s == ' ' || *s == '	' || *s == 0) {
	// End of symbol
	size = (long int) s - (long int)(u+1);
	strncpy( symbol, u + 1, size);
	symbol[size] = 0;

	// Find the symbol
	found = 0;
	for ( unsigned int j = 0; j < sizeof(conf->Symbols)/sizeof(conf->Symbols[0]); j++) {
	  dcli_trim( csymbol, conf->Symbols[j].Name);
	  if ( strcmp( symbol, csymbol) == 0) {
	    // Found, insert the value
	    strcpy( t, conf->Symbols[j].Value);
	    t += strlen( conf->Symbols[j].Value);
	    found = 1;
	    break;
	  }
	}	
	if ( !found) {
	  // Not found
	  strcpy( t, "$");
	  t++;
	  strcat( t, symbol);
	  t += strlen(symbol);
	}
	symbolmode = 0;
	*t = *s;
	t++;
      }
    }
    else {
      if ( *s == '$') {
	symbolmode = 1;
	u = s;
      }
      else {
	*t = *s;
	t++;
      }	
    }
    if ( *s == 0)
      break;
    s++;
  }
}

void rt_post::email_register( mh_sEventId *id) {
  memcpy( &sent_email[sent_email_endidx], id, sizeof(sent_email[0]));
  sent_email_endidx++;
  if ( sent_email_endidx >= sizeof(sent_email)/sizeof(sent_email[0]))
    sent_email_endidx = 0;
  if ( sent_email_endidx == sent_email_startidx)
    sent_email_startidx++;
  if ( sent_email_startidx >= sizeof(sent_email)/sizeof(sent_email[0]))
    sent_email_startidx = 0;
}

int rt_post::email_check( mh_sEventId *id)
{
  unsigned int i;

  for( i = sent_email_startidx; ; i++) {
    if ( i >= sizeof(sent_email)/sizeof(sent_email[0]))
      i = 0;

    if ( i == sent_email_endidx)
      break;

    if ( memcmp( &sent_email[i], id, sizeof(*id)))
      return 1;

  }
  return 0;
}

void rt_post::sms_register( mh_sEventId *id) {
  memcpy( &sent_sms[sent_sms_endidx], id, sizeof(sent_sms[0]));
  sent_sms_endidx++;
  if ( sent_sms_endidx >= sizeof(sent_sms)/sizeof(sent_sms[0]))
    sent_sms_endidx = 0;
  if ( sent_sms_endidx == sent_sms_startidx)
    sent_sms_startidx++;
  if ( sent_sms_startidx >= sizeof(sent_sms)/sizeof(sent_sms[0]))
    sent_sms_startidx = 0;
}

int rt_post::sms_check( mh_sEventId *id)
{
  unsigned int i;

  for( i = sent_sms_startidx; ; i++) {
    if ( i >= sizeof(sent_sms)/sizeof(sent_sms[0]))
      i = 0;

    if ( i == sent_sms_endidx)
      break;

    if ( memcmp( &sent_sms[i], id, sizeof( *id)) == 0)
      return 1;

  }
  return 0;
}

int main()
{
  pwr_tStatus sts;
  int tmo;
  char mp[2000];
  qcom_sQid qid = qcom_cNQid;
  qcom_sGet get;
  int swap = 0;
  bool first_scan = true;

  post = new rt_post();
  post->init( &qid);

  try {
    post->open();
  }
  catch ( co_error& e) {
    errh_Error( (char *)e.what().c_str());
    errh_Fatal( "rt_post aborting");
    errh_SetStatus( PWR__SRVTERM);
    exit(0);
  }

  aproc_TimeStamp(post->scantime(), 10);
  errh_SetStatus( PWR__SRUN);

  first_scan = true;
  for (;;) {
    if ( first_scan) {
      tmo = (int) (post->scantime() * 1000 - 1);
    }

    get.maxSize = sizeof(mp);
    get.data = mp;
    qcom_Get( &sts, &qid, &get, tmo);
    if (sts == QCOM__TMO || sts == QCOM__QEMPTY) {
      if ( !swap)
	post->scan();
    } 
    else {
      ini_mEvent  new_event;
      qcom_sEvent *ep = (qcom_sEvent*) get.data;

      new_event.m  = ep->mask;
      if (new_event.b.oldPlcStop && !swap) {
	errh_SetStatus( PWR__SRVRESTART);
	post->conf->Status = PWR__SRVRESTART;
        swap = 1;
	post->close();
      } else if (new_event.b.swapDone && swap) {
        swap = 0;
	post->open();
	errh_SetStatus( PWR__SRUN);
	post->conf->Status = PWR__SRUN;
      } else if (new_event.b.terminate) {
	exit(0);
      }
    }
    first_scan = false;
  }

}






