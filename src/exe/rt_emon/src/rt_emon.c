/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2020 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_eventmonitor.c -- Runtime environment - Message Handler */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "co_cdh.h"
#include "co_string.h"
#include "co_syi.h"
#include "co_time.h"
#include "co_timelog.h"

#include "rt_aproc.h"
#include "rt_c_iohandler.h"
#include "rt_c_node.h"
#include "rt_ini_event.h"
#include "rt_mh_util.h"
#include "rt_mh_blockdb.h"
#include "rt_mh_log.h"
#include "rt_pwr_msg.h"
#include "rt_qcom_msg.h"
#include "rt_redu.h"

/* Local defines */

#define cTimerOpenBlock 600.
#define cTimerOutunitSync 5.
#define cNodes 256
#define cTimers 4

#define cBlockDbIdx (eTimer_BlockDbOpen - 1)
#define cDetectIdx (eTimer_ScanDetect - 1)
#define cMessageIdx (eTimer_ScanMessage - 1)
#define cOutunitIdx (eTimer_OutunitSync - 1)

/* Local types */

typedef struct s_Active sActive;
typedef struct s_Appl sAppl;
typedef struct s_ApplActive sApplActive;
typedef struct s_Block sBlock;
typedef struct s_Event sEvent;
typedef struct s_EventTab sEventTab;
typedef struct s_SupActive sSupActive;
typedef struct s_EventList sEventList;
typedef struct s_NodeInfo sNodeInfo;
typedef struct s_Outunit sOutunit;
typedef struct s_ProcLink sProcLink;
typedef struct s_SaveBlock sSaveBlock;
typedef struct s_Sup sSup;
typedef struct s_Timer sTimer;
typedef struct s_ASup sASup;
typedef struct s_ASupComp sASupComp;
typedef struct s_DSup sDSup;
typedef struct s_DSupComp sDSupComp;
typedef union u_Event uEvent;

struct s_ProcLink {
  struct LstHead proc_l;
  mh_eSource source;
  pwr_tNodeIndex nix;
  qcom_sQid qid;
  qcom_sAid aid;
  co_sPlatform platform;
};

struct s_Appl {
  sProcLink link; /* Link in process list */
  struct LstHead appl_l; /* Link in application list */
  struct LstHead active_l; /* Head of application alarm list */
  pwr_tUInt32 activeMessages; /* Active messages */
  mh_eApplState state;
  mh_eApplState oldState;
  pwr_tObjid aid;
  pwr_tTime birthTime;
};

struct s_Active {
  struct LstHead active_l; /* Link in active list */
  pwr_tUInt32 idx; /* Event index of alarm */
  pwr_tUInt32 returnIdx; /* Event index of return message */
  pwr_tUInt32 ackIdx; /* Event index of ack message */
  mh_eSource source; /* Originator of alarm */
  pwr_tAttrRef object; /* Object associated with alarm */
  pwr_tAttrRef supObject; /* Supervisor object */
  pwr_tObjid outunit; /* Optional outunit destination */
  pwr_tAName objName;
  pwr_tAName eventName;
  mh_mEventFlags eventFlags;
  pwr_eEventTypeEnum eventType;
  mh_uEventInfo status;
  mh_eEvent event;
  pwr_tAttrRef eventSound;
  pwr_tString256 eventMoreText;
  pwr_tString256 receiver;
  pwr_tBoolean local;
  sEventTab* detect_etp;
  sEventTab* return_etp;
  sEventTab* ack_etp;
};

struct s_NodeInfo {
  pwr_tNid nid;
  sAppl appl;
  sApplActive* hp;
  gdh_eLinkState oldLinkState;
  gdh_eLinkState newLinkState;
  pwr_tString40 name;
  pwr_tString80 fullname;
  pwr_tBoolean initiated;
  pwr_tBoolean check;
  pwr_tBoolean checkInit;
  pwr_tUInt32 handlerEventIdx[14];
  int occupied;
};

struct s_Block {
  sActive link;
  struct LstHead block_l;
  mh_sOutunitBlock outunitBlock;
  mh_sOutunitBlock outunitUnblock;
  mh_sEventId targetId;
};

union u_Event {
  mh_sMsgInfo info;
  mh_sMessage message;
  mh_sAck ack;
  mh_sBlock block;
  mh_sReturn ret;
};

struct s_Event {
  pwr_tUInt32 idx;
  pwr_tObjid outunit;
  pwr_tAttrRef object;
  pwr_tAName objName;
  mh_eEvent event;
  pwr_eEventTypeEnum eventType;
  pwr_tUInt32 msgSize;
  pwr_tBoolean local;
  sEventTab* etp;
  uEvent msg;
};

struct s_EventTab {
  tree_sNode node;
  pwr_tUInt32 idx;
  mh_eEvent event;
  sActive* ap;
  sEvent* ep;
};

struct s_EventList {
  pwr_tUInt32 idx;
  pwr_tUInt32 oldIdx;
  pwr_tUInt32 size;
  sEvent list[1];
  /* Here comes the event list */
};

struct s_SaveBlock {
  mh_sOutunitBlock outunitBlock;
  mh_sEventId targetId;
};

struct s_Timer {
  pwr_tBoolean TimerFlag pwr_dAlignLW;
  pwr_tBoolean* TimerNext pwr_dAlignLW;
  pwr_tUInt32 TimerCount pwr_dAlignLW;
  pwr_tBoolean* TimerDO pwr_dAlignLW;
  pwr_tFloat32 TimerTime pwr_dAlignLW;
  pwr_tBoolean TimerDODum pwr_dAlignW;
  pwr_tObjid TimerObjDId pwr_dAlignW;
  pwr_tInt32 TimerAcc pwr_dAlignW;
  pwr_tFloat32 TimerMin pwr_dAlignW;
  pwr_tFloat32 TimerMax pwr_dAlignW;
};

struct s_Sup {
  pwr_tBoolean* ControlP pwr_dAlignLW;
  pwr_tBoolean Control pwr_dAlignLW;
  pwr_tBoolean Action pwr_dAlignW;
  pwr_tBoolean Acked pwr_dAlignW;
  pwr_tBoolean Blocked pwr_dAlignW;
  pwr_tString80 Description pwr_dAlignW;
  pwr_tBoolean DetectOn pwr_dAlignW;
  pwr_tString80 DetectText pwr_dAlignW;
  pwr_tString80 ReturnText pwr_dAlignW;
  mh_eEvent EventType pwr_dAlignW;
  mh_eEventPrio EventPriority pwr_dAlignW;
  mh_mEventFlags EventFlags pwr_dAlignW;
  pwr_tAttrRef Sound pwr_dAlignW;
  pwr_tText256 MoreText pwr_dAlignW;
  pwr_tString40 Recipient pwr_dAlignW;
  /* Internal attributes */
  pwr_sAttrRef Attribute pwr_dAlignW;
  mh_uEventInfo AlarmStatus pwr_dAlignW;
  pwr_tBoolean AlarmCheck pwr_dAlignW;
  pwr_tBoolean DetectCheck pwr_dAlignW;
  pwr_tBoolean DetectSend pwr_dAlignW;
  pwr_tTime DetectTime pwr_dAlignLW;
  pwr_tBoolean ReturnCheck pwr_dAlignW;
  pwr_tBoolean ReturnSend pwr_dAlignW;
  pwr_tTime ReturnTime pwr_dAlignLW;
  pwr_tTime AckTime pwr_dAlignLW;
  pwr_tObjid AckOutunit pwr_dAlignW;
};

struct s_SupActive {
  sActive link;
  struct LstHead sup_l;
  struct LstHead detect_l;
  struct LstHead timer_l;
  mh_eAgent agent;
  mh_uEventInfo alarmVisibility;
  mh_eSupType supType;
  gdh_tDlid supDlid;
  pwr_sAttrRef attribute;
  gdh_tDlid attrDlid;
  void* actualValue;
  pwr_tBoolean found;
  sSup* sup;
  pwr_tUInt32 supInfoSize;
  void* supInfoP;
  void* op;
  sTimer* timer;
  pwr_tCid cid;
  void (*detect_exec)(sSupActive* sp);
};

struct s_ASup {
  pwr_tFloat32* InP pwr_dAlignLW;
  pwr_tFloat32 In pwr_dAlignLW;
  sSup Sup pwr_dAlignLW;
  mh_sASupInfo Info pwr_dAlignW;
  sTimer Timer pwr_dAlignLW;
};

struct s_ASupComp {
  sSup Sup pwr_dAlignLW;
  mh_sASupInfo Info pwr_dAlignW;
  sTimer Timer pwr_dAlignLW;
};

struct s_DSup {
  pwr_tBoolean* InP pwr_dAlignLW;
  pwr_tBoolean In pwr_dAlignLW;
  sSup Sup pwr_dAlignLW;
  mh_sDSupInfo Info pwr_dAlignW;
  sTimer Timer pwr_dAlignLW;
};

struct s_DSupComp {
  sSup Sup pwr_dAlignLW;
  mh_sDSupInfo Info pwr_dAlignW;
  sTimer Timer pwr_dAlignLW;
};

struct s_ApplActive {
  sActive link;
  struct LstHead active_l;
  mh_sApplMessage message;
  pwr_tTime ackTime;
  pwr_tObjid ackOutunit;
  pwr_tTime returnTime;
  pwr_tString80 returnText;
  mh_eEvent returnType; /* Return or Cancel */
  sAppl* ap; /* Pointer to owner appl */
};

struct s_Outunit {
  sProcLink link; /* Link in process list */
  struct LstHead outunit_l; /* Link in outunit list */
  pwr_tTime birthTime; /* Time when outunit was started */
  pwr_tObjid outunit; /* Object id of outunit object */
  mh_eOutunitType type; /* Type of outunit */
  pwr_tUInt32 ver; /* Outunit version */
  pwr_tUInt32 ackGen; /* Generation of last ack received from outunit */
  pwr_tUInt32 blockGen; /* Generation of last block received from outunit */
  pwr_tUInt32 eventIdx; /* Index of last sent event to outunit */
  pwr_tUInt32 eventGen; /* Generation of eventlist when last sent to outunit */
  pwr_tUInt32 maxIdx; /*  */
  pwr_tUInt32 syncedIdx; /*  */
  pwr_tUInt32 lastSentIdx; /* Last event sent to outunit */
  pwr_tTime lastSentTime; /* Time when last event is sent to outunit */
  pwr_tBoolean check;
  pwr_tBoolean linkUp;
  pwr_mEventTypeMask selEventType;
  pwr_tUInt32 selGen; /* Index of last received select list from outunit */
  pwr_tUInt32 selSize; /* Size of last received select list from outunit */
  mh_sSelL sel_l[mh_cSelLSize];
};

typedef enum {
  eSupListState__ = 0,
  eSupListState_Init = 1,
  eSupListState_Scan = 2,
  eSupListState_NoSup = 3,
  eSupListState_Wait = 4,
  eSupListState_Restart = 5,
  eSupListState_
} eSupListState;

typedef enum {
  eTimer_BlockDbOpen = 1,
  eTimer_ScanDetect = 2,
  eTimer_ScanMessage = 3,
  eTimer_OutunitSync = 4
} eTimer;

typedef enum {
  eHEvent_None = 0,
  eHEvent_LinkStart,
  eHEvent_LinkUp,
  eHEvent_LinkDown,
  eHEvent_Booted,
  eHEvent_RestartInit,
  eHEvent_RestartComplete,
  eHEvent_OutunitRestart
} eHEvent;

typedef struct {
  eTimer type;
  int multiple;
  int count;
  pwr_tBoolean active;
} sTimerData;

struct sLocal {
  pwr_sClass_MessageHandler* emon;
  pwr_tOName emonName;
  pwr_tObjid emonObject;
  struct LstHead outunit_l;
  mh_sHead head;
  struct LstHead active_l;
  sEventList* event_l;
  struct LstHead proc_l;
  struct LstHead appl_l;
  struct LstHead sup_l;
  struct LstHead block_l;
  struct LstHead blockFree_l;
  struct LstHead detect_l;
  struct LstHead timer_l;
  struct LstHead handlerFree_l;
  eSupListState supListState;
  tree_sTable* eventTab;
  pwr_tBoolean newBlock;
  pwr_tFloat32 detectTimerTime;
  sTimerData timers[cTimers];
  double timerTime;
  pwr_tDeltaTime timerTimeDelta;
  pwr_tBoolean timerActive;
  sSaveBlock* blockSave;
  void* blockDb;
  pwr_tUInt32 blockSaveSize;
  char blockDbName[256];
  sNodeInfo nodeDb[cNodes];
  pwr_tBoolean outunitServer;
  pwr_sClass_IOHandler* iohp;
  pwr_tOid iohObject;
  pwr_tOName iohName;
  pwr_sNode* nodep;
  pwr_tOid nodeObject;
  pwr_tOName nodeName;
  pwr_tUInt32 handlerListCount;
  pwr_tBoolean applAlarmQuotaSent;
  redu_tCtx redu;
};

/* Global variables */

/* Local variables */

static char cText_Restart[] = "Canceled due to restart";
static char cText_Block[] = "Canceled due to blocking";
static struct sLocal l;

/* Local function definitions */

static void msgToV3(mh_eEvent type, uEvent* up);
static sActive* activeListGet(pwr_tUInt32);
static void activeListInsert(sActive*, sEvent*, mh_eSource);
static void activeListRemove(sActive*);
static void applConnect(mh_sHead*, sAppl*, mh_uApplReply*);
static void applDisconnect(mh_sHead*, sAppl*, mh_uApplReply*);
static void applGetMsgInfo(mh_sHead*, sAppl*, mh_uApplReply*);
static void applLogState(sAppl*);
static void applMessage(mh_sHead*, sAppl*, mh_uApplReply*);
static void applReturn(mh_sHead*, sAppl*, mh_uApplReply*);
static void aSup_exec(sSupActive*);
static sBlock* blockListAlloc();
static void blockListFree(sBlock*);
static void cancelAlarm(sActive*, char*);
static void checkOutunits();
static void cSup_exec(sSupActive*);
static void dSup_exec(sSupActive*);
static void enableQcomEvents(qcom_sQid);
static void enableQcomAllHandlers(qcom_sQid);
static void eventListInit();
static sEvent* eventListInsert(mh_eEvent, char*, sActive*);
static void eventToOutunits(sEvent*);
static void formatApplEvent(
    mh_eEvent, char*, sApplActive*, uEvent*, pwr_tUInt32*);
static void formatOutunitEvent(
    mh_eEvent, char*, sBlock*, uEvent*, pwr_tUInt32*);
static void formatSupEvent(
    mh_eEvent, char*, sSupActive*, uEvent*, pwr_tUInt32*);
static void fromApplication(qcom_sGet*);
static void fromHandler(qcom_sGet*);
static void fromMessageUnit(qcom_sGet*);
static void fromOutunit(qcom_sGet*);
static void fromQcom(qcom_sGet*);
static void fromEvent(qcom_sGet*);
static mh_eAgent getAgent(sSupActive*);
static void handleAlarm(sSupActive*);
static void handleInfo(sSupActive*);
static void handleMessage(qcom_sGet*);
static void handleReturn(sSupActive*);
static void handlerEvent(pwr_eSystemEventTypeEnum, pwr_tNodeIndex, int);
static void handlerEvent_cb(int, int);
static sApplActive* handlerListAlloc(pwr_eSystemEventTypeEnum);
static void handlerListFree(sApplActive*);
static void getHandlerObject();
static void initBlockList();
static void initNodeDb();
static pwr_tStatus initSupActiveCB(
    pwr_tAttrRef*, pwr_tClassId, sSupActive**, pwr_tBoolean, pwr_tBoolean);
static pwr_tStatus initSupList();
static pwr_tStatus initSupListClass(pwr_tClassId);
static pwr_tBoolean isForOutunit(sOutunit*, pwr_tObjid, pwr_tObjid,
    pwr_tString80, mh_mEventFlags, pwr_eEventTypeEnum, pwr_tBoolean);
static pwr_tBoolean isValidApplication(
    mh_sHead*, qcom_sAid*, sAppl**, mh_uApplReply*);
static pwr_tBoolean isValidOutunit(mh_sHead*, qcom_sAid*, sOutunit**);
static void linkActive(qcom_sGet*);
static void linkConnect(qcom_sGet*);
static void linkDisconnect(qcom_sGet*);
static void linkStalled(qcom_sGet*);
static void outunitAborted(sOutunit*);
static void outunitAck(mh_sHead*, sOutunit*);
static void outunitBlock(mh_sHead*, sOutunit*);
static void outunitInfo(mh_sHead*, sOutunit*);
static void outunitDisconnect(mh_sHead*, sOutunit*);
static void outunitLog(sOutunit*, char*);
static void outunitSync(mh_sHead*, sOutunit*);
static void outunitAlarmReq(mh_sHead* hp, sOutunit* op);
static void procDown(qcom_sAid*);
static void receive(qcom_sQid);
static void reInitSupList();
static pwr_tStatus reInitSupListClass(pwr_tClassId);
static pwr_tBoolean reSendEventToOutunit(sOutunit*, sEventTab*);
static void saveBlockList();
static void scanDetectList();
static void scanSupList();
static void scanTimerList();
static void sendEventListToOutunit(sOutunit*);
static pwr_tBoolean sendEventToOutunit(sOutunit*, sEventTab*);
static pwr_tStatus sendMessage(
    mh_eMsg, qcom_sQid*, co_sPlatform*, void*, pwr_tUInt32);
static pwr_tStatus sendToOutunit(
    sOutunit*, mh_eMsg, int, unsigned int, void*, int);
static void setTimerActive(int, pwr_tBoolean);
static sSupActive* supListGet(pwr_tAttrRef*);
static void timeOut();
static void timerIn(sSupActive*, sTimer*);
static void updateAlarm(sActive*, sEvent*);
static void updateAlarmInfo(sActive*);
static void updateSupActive(sSupActive*);
static sNodeInfo* node_get(pwr_tNid nid);
static sNodeInfo* node_insert(pwr_tNid nid);
static pwr_tStatus emon_redu_init();
static pwr_tStatus emon_redu_send();
static pwr_tStatus emon_redu_receive();

int main()
{
  pwr_tStatus sts;
  qcom_sQid myQid = { mh_cProcHandler, 0 };
  qcom_sNode myNode;
  qcom_sQattr qAttr;

  errh_Init("pwr_emon", errh_eAnix_emon);
  errh_SetStatus(PWR__SRVSTARTUP);

  if (!qcom_Init(&sts, 0, "pwr_emon")) {
    errh_Fatal("qcom_Init, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  qAttr.type = qcom_eQtype_private;
  qAttr.quota = 100;
  if (!qcom_CreateQ(&sts, &myQid, &qAttr, "pwr_emon")) {
    if (sts == QCOM__QALLREXIST) {
      if (!qcom_AttachQ(&sts, &myQid)) {
        if (!qcom_DeleteQ(&sts, &myQid)) {
          errh_Fatal("qcom_DeleteQ, %m", sts);
          exit(sts);
        }
        if (!qcom_CreateQ(&sts, &myQid, &qAttr, "pwr_emon")) {
          errh_Fatal("qcom_CreateQ, %m", sts);
          exit(sts);
        }
      }
    } else {
      errh_Fatal("qcom_CreateQ, %m", sts);
      errh_SetStatus(PWR__SRVTERM);
      exit(sts);
    }
  }
  l.head.qid = myQid;

  if (!qcom_MyNode(&sts, &myNode)) {
    errh_Fatal("qcom_MyNode, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }
  l.head.qid = myQid;

  l.head.platform.os = myNode.os;
  l.head.platform.hw = myNode.hw;

  sts = gdh_Init("pwr_emon");
  if (EVEN(sts)) {
    errh_Error("gdh_Init, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  /* Wait for local nethandler to start */

  while (EVEN(gdh_NethandlerRunning()))
    sleep(1);

  l.newBlock = TRUE;
  l.detectTimerTime = 1.0;
  l.timerActive = FALSE;

  l.blockSave = NULL;
  l.blockDb = NULL;
  l.outunitServer = FALSE;

  l.eventTab = tree_CreateTable(&sts, sizeof(pwr_tUInt32),
      offsetof(sEventTab, idx), sizeof(sEventTab), 200, tree_Comp_uint32);

  /* Init Handler head */

  l.head.ver = mh_cVersion;
  net_GetTime(&l.head.birthTime);
  l.head.source = mh_eSource_Handler;

  l.head.nix = l.head.qid.nid;
  enableQcomEvents(myQid);
  enableQcomAllHandlers(myQid);

  getHandlerObject();

  eventListInit();

  LstInit(&l.outunit_l);
  LstInit(&l.active_l);
  LstInit(&l.proc_l);
  LstInit(&l.appl_l);
  LstInit(&l.sup_l);
  LstInit(&l.block_l);
  LstInit(&l.blockFree_l);
  LstInit(&l.detect_l);
  LstInit(&l.timer_l);
  LstInit(&l.handlerFree_l);

  l.supListState = eSupListState_Init;

  if (l.emon->BlockFile) {
    initBlockList();
    setTimerActive(cBlockDbIdx, TRUE);
  }

  initNodeDb();

  sts = emon_redu_init();

  sts = sendMessage(mh_eMsg_HandlerHello, NULL, NULL, NULL, 0);

  setTimerActive(cMessageIdx, TRUE);
  setTimerActive(cOutunitIdx, TRUE);

  mh_UtilWake();

  handlerEvent(pwr_eSystemEventTypeEnum_NodeUp, l.head.nix, 1);

  errh_SetStatus(PWR__SRUN);

  for (;;) {
    receive(myQid);
  }
}

static sActive* activeListGet(pwr_tUInt32 idx)
{
  sEventTab* etp;
  pwr_tStatus sts;

  etp = tree_Find(&sts, l.eventTab, &idx);
  if (etp)
    return etp->ap;

  return NULL;
}

/* Puts an active link block at the end of the active list and at the end
   of the event index list pointed to by ep.  */

static void activeListInsert(sActive* ap, sEvent* ep, mh_eSource source)
{
  int inserted;
  struct LstHead * al;
  struct LstHead * bl;

  /* Check that not already inserted */
  inserted = 0;
  LstForEach(al, &l.active_l) {
    if (ap == LstEntry(al, sActive, active_l)) {
      inserted = 1;
      break;
    }
  }

  ap->idx = ep->idx;
  ap->source = source;

  if (!inserted) {
    al = &l.active_l;
    LstInsert(al, &ap->active_l);
  }

  switch (ap->event) {
  case mh_eEvent_Alarm:
  case mh_eEvent_MaintenanceAlarm:
  case mh_eEvent_SystemAlarm:
  case mh_eEvent_UserAlarm1:
  case mh_eEvent_UserAlarm2:
  case mh_eEvent_UserAlarm3:
  case mh_eEvent_UserAlarm4:
    ++l.emon->AlarmCount;
    break;
  case mh_eEvent_Block:
  case mh_eEvent_Reblock:
    bl = &l.block_l;
    LstInsert(bl, &((sBlock*)ap)->block_l);
    ++l.emon->BlockCount;
    break;
  case mh_eEvent_Info:
  case mh_eEvent_InfoSuccess:
    break;
  default:
    errh_Error("activeListInsert, program error, event: %d", ap->event);
    break;
  }
}

/* Removes a active link block from the active list and event index list. */

static void activeListRemove(sActive* ap)
{
  pwr_tStatus sts;
  sApplActive* aap;
  sBlock* bp;

  if (LstIsNull(&ap->active_l))
    return;

  LstRemove(&ap->active_l);
  LstNull(&ap->active_l);
  ap->idx = 0;
  ap->ackIdx = 0;
  ap->returnIdx = 0;

  switch (ap->event) {
  case mh_eEvent_Alarm:
  case mh_eEvent_MaintenanceAlarm:
  case mh_eEvent_SystemAlarm:
  case mh_eEvent_UserAlarm1:
  case mh_eEvent_UserAlarm2:
  case mh_eEvent_UserAlarm3:
  case mh_eEvent_UserAlarm4:
    --l.emon->AlarmCount;
    break;
  case mh_eEvent_Block:
  case mh_eEvent_Unblock:
  case mh_eEvent_Reblock:
  case mh_eEvent_CancelBlock:
    bp = (sBlock*)ap;
    LstRemove(&bp->block_l);
    LstNull(&bp->block_l);
    --l.emon->BlockCount;
    break;
  case mh_eEvent_Info:
  case mh_eEvent_InfoSuccess:
    break;
  default:
    errh_Error("activeListRemove, program error, event: %d", ap->event);
    break;
  }

  /* remove from event table */

  if (ap->detect_etp != NULL) {
    ap->detect_etp->ap = NULL;
    if (ap->detect_etp->ep == NULL)
      tree_Remove(&sts, l.eventTab, &ap->detect_etp->idx);
    ap->detect_etp = NULL;
  }
  if (ap->return_etp != NULL) {
    ap->return_etp->ap = NULL;
    if (ap->return_etp->ep == NULL)
      tree_Remove(&sts, l.eventTab, &ap->return_etp->idx);
    ap->return_etp = NULL;
  }
  if (ap->ack_etp != NULL) {
    ap->ack_etp->ap = NULL;
    if (ap->ack_etp->ep == NULL)
      tree_Remove(&sts, l.eventTab, &ap->ack_etp->idx);
    ap->ack_etp = NULL;
  }

  if (ap->source == mh_eSource_Application
      || ap->source == mh_eSource_Handler) {
    aap = (sApplActive*)ap;

    LstRemove(&aap->active_l); /* Remove from application alarm list */
    LstNull(&aap->active_l);
    if (aap->ap->activeMessages > 0)
      --aap->ap->activeMessages;
    if (ap->source == mh_eSource_Application)
      free(ap);
    else
      handlerListFree((sApplActive*)ap);
  }
}

static void applConnect(mh_sHead* hp, sAppl* ap, mh_uApplReply* reply)
{
  switch (ap->state) {
  case mh_eApplState_New:
  case mh_eApplState_Restarted:
  case mh_eApplState_Aborted:
    reply->Connect.Sts = MH__SUCCESS;
    ap->state = mh_eApplState_Connected;
    break;
  case mh_eApplState_Connected:
    errh_Info("ApplConnect, this should not happen");
    reply->Connect.Sts = MH__EVENTERR;
    break;
  default:
    errh_Info("applConnect, program error, state: %d", ap->state);
    reply->Connect.Sts = MH__PROGERR;
    break;
  }

  applLogState(ap);
  reply->Connect.NoOfActMessages = ap->activeMessages;
}

static void applDisconnect(mh_sHead* hp, sAppl* ap, mh_uApplReply* Reply)
{
  ap->state = mh_eApplState_Disconnected;
  applLogState(ap);

  /* Cancel all active messages */

  LstRemove(&ap->appl_l); /* Remove from application list */
  LstNull(&ap->appl_l);
  LstRemove(&ap->link.proc_l); /* Remove from process link */
  LstNull(&ap->link.proc_l);
  free(ap); /* Free control block */
  Reply->Sts = MH__SUCCESS;
}

static void applLogState(sAppl* ap)
{
  static char* StateText[mh_eApplState_] = {
    "NoState", "Aborted", "Connected", "Disconnected", "New", "Restarted",
  };
  char mess[256];

  if (ap->state == ap->oldState)
    return;

  sprintf(mess, "Link to application qid: %s, oid: %s, state: %s",
      qcom_QidToString(NULL, &ap->link.qid, 1), cdh_ObjidToString(ap->aid, 0),
      (ap->state < mh_eApplState_ ? StateText[ap->state] : "Progerror"));
  errh_Info(mess);

  ap->oldState = ap->state;
}

static void applGetMsgInfo(mh_sHead* hp, sAppl* ap, mh_uApplReply* Reply)
{
  pwr_tUInt32* TargetIdxP = (pwr_tUInt32*)(hp + 1);
  sActive* cp;
  sApplActive* aap;
  struct LstHead * al;

  switch (ap->state) {
  case mh_eApplState_Connected:
    break;
  case mh_eApplState_New:
  case mh_eApplState_Restarted:
  case mh_eApplState_Aborted:
    Reply->Info.Sts = MH__EVENTERR;
    errh_Info("applGetMsgInfo, this should not happen");
    return;
  default:
    Reply->Info.Sts = MH__PROGERR;
    errh_Info("applGetMsgInfo, program error, state: %d", ap->state);
    return;
  }

  LstForEach(al, &l.active_l) {
    cp = LstEntry(al, sActive, active_l);
    if (cp->source == mh_eSource_Application || 
	cp->source == mh_eSource_Handler) {
      aap = (sApplActive*)cp;
      if (aap->link.idx >= *TargetIdxP)
	break;
    }
  }

  if (al != &ap->active_l) {
    Reply->Info.Sts = MH__SUCCESS;
    Reply->Info.Message = aap->message;
  } else
    Reply->Info.Sts = MH__NOMOREMSG;
}

static void applMessage(mh_sHead* hp, sAppl* ap, mh_uApplReply* reply)
{
  pwr_tStatus sts;
  mh_sApplMessage* ip = (mh_sApplMessage*)(hp + 1);
  sEvent* ep;
  sApplActive* aap;
  pwr_tAName ObjName;

  switch (ap->state) {
  case mh_eApplState_Connected:
    break;
  case mh_eApplState_New:
  case mh_eApplState_Restarted:
  case mh_eApplState_Aborted:
    reply->Message.Sts = MH__EVENTERR;
    errh_Info("applMessage, this should not happen");
    return;
  default:
    reply->Message.Sts = MH__PROGERR;
    errh_Info("applMessage, program error, state: %d", ap->state);
    return;
  }

  /* get object name from gdh */

  if (cdh_ObjidIsNotEqual(ip->Object, pwr_cNObjid)) {
    sts = gdh_ObjidToName(ip->Object, ObjName, sizeof(ObjName), cdh_mNName);
    if (EVEN(sts)) {
      reply->Message.Sts = MH__NOSUCHOBJ;
      return;
    }
  } else {
    ObjName[0] = '\0';
  }

  aap = (sApplActive*)calloc(1, sizeof(sApplActive));
  if (aap == NULL) {
    reply->Message.Sts = MH__NOSPACE;
    return;
  }

  aap->link.source = mh_eSource_Application;
  aap->link.object = cdh_ObjidToAref(ip->Object);
  aap->link.supObject = cdh_ObjidToAref(ip->SupObject);
  aap->link.outunit = ip->Outunit;
  strncpy(aap->link.objName, ObjName, sizeof(aap->link.objName));
  str_ToUpper(aap->link.objName, NULL);
  strncpy(aap->link.eventName, ip->EventName, sizeof(aap->link.eventName));
  aap->link.eventFlags = ip->EventFlags;
  aap->link.eventSound = ip->EventSound;
  strncpy(aap->link.eventMoreText, ip->EventMoreText,
      sizeof(aap->link.eventMoreText));
  aap->link.event = ip->EventType;
  aap->link.eventType = ip->EventType;

  aap->message = *ip;

  if ((ip->EventType == mh_eEvent_Info
          || ip->EventType == mh_eEvent_InfoSuccess)
      && !(ip->EventFlags & mh_mEventFlags_InfoWindow)) {
    ep = eventListInsert(ip->EventType, NULL, (sActive*)aap);
    free(aap);
  } else {
    if (ap->activeMessages > l.emon->MaxApplAlarms) {
      reply->Message.Sts = MH__APPLQUOTA;
      free(aap);
      if (!l.applAlarmQuotaSent) {
        handlerEvent(pwr_eSystemEventTypeEnum_ApplAlarmQuota, l.head.nix, 1);
        l.applAlarmQuotaSent = 1;
      }
      return;
    }

    /* Insert in application alarm list */
    LstInsert(&ap->active_l, &aap->active_l);
    aap->ap = ap;

    ++ap->activeMessages;

    ep = eventListInsert(ip->EventType, NULL, (sActive*)aap);
    activeListInsert((sActive*)aap, ep, mh_eSource_Application);
    updateAlarm((sActive*)aap, ep);
  }

  reply->Message.Sts = MH__SUCCESS;
  reply->Message.Idx = ep->idx;
  eventToOutunits(ep);
}

static pwr_tStatus applReply(qcom_sGet* get, void* msg, pwr_tUInt32 msgSize)
{
  pwr_tStatus sts;
  mh_sHead* hp;
  unsigned int size = sizeof(l.head) + msgSize;
  qcom_sPut put;

  if ((put.data = (char*)qcom_Alloc(&sts, size)) == NULL) {
    errh_Error("applReply: qcom_alloc, %m", sts);
    return sts;
  }

  hp = (mh_sHead*)put.data;
  *hp = l.head;
  hp->type = mh_eMsg_ApplReply;

  memcpy(hp + 1, msg, msgSize);

  put.type.b = mh_cMsgClass;
  put.type.s = mh_eMsg_ApplReply;
  put.reply = l.head.qid;
  put.size = size;
  put.allocate = 0;

  qcom_Reply(&sts, get, &put);
  if (EVEN(sts)) {
    errh_Error("applReply, qcom_Reply\n%m", sts);
    qcom_Free(NULL, put.data);
  }

  return sts;
}

static void applReturn(mh_sHead* hp, sAppl* ApplP, mh_uApplReply* reply)
{
  sActive* ap;
  mh_sApplReturn* ip = (mh_sApplReturn*)(hp + 1);
  sEvent* ep;
  sApplActive* aap;

  switch (ApplP->state) {
  case mh_eApplState_Connected:
    break;
  case mh_eApplState_New:
  case mh_eApplState_Restarted:
  case mh_eApplState_Aborted:
    errh_Info("applReturn, this should not happen");
    reply->Connect.Sts = MH__EVENTERR;
    return;
  default:
    errh_Info("applReturn, program error, state: %d", ApplP->state);
    reply->Connect.Sts = MH__PROGERR;
    return;
  }

  if ((ap = activeListGet(ip->TargetIdx)) == NULL) {
    /* Alarm does not exist */
    errh_Info("applReturn, Got a return on a nonexisting alarm!");
    reply->Sts = MH__NONEXALARM;
    return;
  }

  if ((ap->status.Event.Status & mh_mEventStatus_NotRet) == 0) {
    /* Alarm already returned */
    reply->Sts = MH__ALLRET;
    return;
  }

  aap = (sApplActive*)ap;

  if (aap->ap != ApplP) { /* Alarm not owned by this application */
    errh_Info("applReturn, Got a return on an alarm not owned by application!");
    reply->Sts = MH__NOTOWNED;
    return;
  }

  time_GetTime(&aap->returnTime);
  strncpy(aap->returnText, ip->ReturnText, sizeof(pwr_tString80));
  aap->returnType = ip->ReturnType;
  ep = eventListInsert(aap->returnType, NULL, ap);

  switch (aap->link.event) {
  case mh_eEvent_Alarm:
  case mh_eEvent_MaintenanceAlarm:
  case mh_eEvent_SystemAlarm:
  case mh_eEvent_UserAlarm1:
  case mh_eEvent_UserAlarm2:
  case mh_eEvent_UserAlarm3:
  case mh_eEvent_UserAlarm4:
    updateAlarm(ap, ep);
    break;
  case mh_eEvent_Info:
  case mh_eEvent_InfoSuccess:
    if (aap->link.eventFlags & mh_mEventFlags_InfoWindow)
      updateAlarm(ap, ep);
    break;
  default:
    errh_Info("applReturn, Return on unknown event type: %d", aap->link.event);
    reply->Sts = MH__EVENTERR;
    return;
  }

  reply->Sts = MH__SUCCESS;
  eventToOutunits(ep);
}

static sBlock* blockListAlloc()
{
  struct LstHead * bl;
  struct LstHead * ll;
  sBlock* bp;
  const int alloc = 100;
  int i;

  ll = &l.blockFree_l;

  if (LstEmpty(ll)) {
    bp = (sBlock*)calloc(alloc, sizeof(sBlock));
    if (bp != NULL) {
      for (i = 0; i < alloc; i++, bp++)
        LstInsert(ll, &bp->link.active_l);
      l.emon->FreeCount += alloc;
    } else {
      return NULL;
    }
  }

  bl = ll->next;
  LstRemove(bl);
  --l.emon->FreeCount;
  return LstEntry(bl, sBlock, link.active_l);
}

static void blockListFree(sBlock* bp)
{
  memset(bp, 0, sizeof(*bp));
  LstInsert(&l.blockFree_l, &bp->link.active_l);
  ++l.emon->FreeCount;
  return;
}

/* Detect an ASup object.

   !!! NOTE: This should be the same as the macro used by PLC,
             in rt_plc_macro_sup.h  */

static void aSup_exec(sSupActive* sp)
{
  pwr_sClass_ASup* o = (pwr_sClass_ASup*)sp->op;
  pwr_tFloat32 In = *(pwr_tFloat32*)sp->actualValue;

  if ((o->High && In <= o->CtrlLimit - o->Hysteres)
      || (!o->High && In >= o->CtrlLimit + o->Hysteres)) {
    if (o->Action)
      o->Action = FALSE;
    if (o->ReturnCheck) {
      time_GetTime(&o->ReturnTime);
      o->ReturnCheck = FALSE;
      o->ReturnSend = TRUE;
    }
    if (o->AlarmCheck && !o->DetectCheck) {
      o->TimerFlag = FALSE;
      o->DetectCheck = TRUE;
    }
  } else if ((o->High && In > o->CtrlLimit)
      || (!o->High && In < o->CtrlLimit)) {
    if (!o->Action) {
      o->Action = TRUE;
    }
    if (o->Suppressed) {
      if (o->ReturnCheck) {
        time_GetTime(&o->ReturnTime);
        o->ReturnCheck = FALSE;
        o->ReturnSend = TRUE;
      } else if (o->DetectSend)
        o->DetectSend = FALSE;
    }
    if (o->AlarmCheck && o->DetectOn && !o->Blocked && !o->Suppressed) {
      if (o->DetectCheck) {
        o->ActualValue = In;
        timerIn(sp, (sTimer*)&o->TimerFlag);
        time_GetTime(&o->DetectTime);
        o->DetectCheck = FALSE;
      }
      if (!o->TimerFlag) {
        o->DetectSend = TRUE;
        o->ReturnCheck = TRUE;
        o->Acked = FALSE;
        o->AlarmCheck = FALSE;
      }
    }
  }
}

/* Cancel an alarm.  */

static void cancelAlarm(sActive* ap, char* text)
{
  sEvent* ep;
  sSupActive* sp;

  ep = eventListInsert(mh_eEvent_Cancel, text, ap);
  ap->status.All = 0;
  if (ap->source == mh_eSource_Scanner) {
    sp = (sSupActive*)ap;
    sp->sup->AlarmCheck = FALSE;
    sp->sup->ReturnSend = FALSE;
    sp->sup->ReturnCheck = FALSE;
    sp->sup->DetectSend = FALSE;
    sp->sup->Acked = TRUE;
    sp->sup->DetectCheck = TRUE;
    sp->sup->AlarmCheck = TRUE;
    sp->sup->AlarmStatus.All = 0;
    sp->timer->TimerCount = 0;
    if (sp->supType == mh_eSupType_Cycle) {
      pwr_sClass_CycleSup* cp = (pwr_sClass_CycleSup*)sp->op;
      cp->Delayed = FALSE;
      cp->DelayNoted = FALSE;
    }
  }
  updateAlarmInfo(ap);
  activeListRemove(ap);
  eventToOutunits(ep);
}

static void sendAlarmStatus(sOutunit* op)
{
  struct LstHead * al;
  sEvent* ep;
  sActive* ap;
  mh_sAlarmStatus* msg;
  int msg_size;
  int sts;
  pwr_tBoolean is_for_outunit;

  /* Count alarms */
  int count = 0;
  LstForEach(al, &l.active_l) {
    ap = LstEntry(al, sActive, active_l);

    if (!ap->detect_etp)
      continue;

    switch (ap->detect_etp->event) {
    case mh_eEvent_Info:
    case mh_eEvent_InfoSuccess:
    case mh_eEvent_Alarm:
    case mh_eEvent_MaintenanceAlarm:
    case mh_eEvent_SystemAlarm:
    case mh_eEvent_UserAlarm1:
    case mh_eEvent_UserAlarm2:
    case mh_eEvent_UserAlarm3:
    case mh_eEvent_UserAlarm4:

      ep = ap->detect_etp->ep;

      if (ap->detect_etp->event == mh_eEvent_Info
          || ap->detect_etp->event == mh_eEvent_InfoSuccess) {
        if (ep && !(ep->msg.info.EventFlags & mh_mEventFlags_InfoWindow))
          break;
        if (ep && ep->msg.info.EventFlags & mh_mEventFlags_InfoWindow
            && !(ep->msg.info.EventFlags & mh_mEventFlags_Ack))
          break;
      }

      if (ep)
        is_for_outunit = isForOutunit(op, ep->outunit, ep->object.Objid,
            ep->objName, ep->msg.info.EventFlags, ep->eventType, ep->local);
      else
        is_for_outunit = isForOutunit(op, ap->outunit, ap->object.Objid,
            ap->objName, ap->eventFlags, ap->eventType, ap->local);
      if (is_for_outunit)
        count++;
      break;
    default:;
    }
  }

  msg_size = sizeof(mh_sAlarmStatus) + (count - 1) * sizeof(mh_sAlarmSts);
  msg = (mh_sAlarmStatus*)calloc(1, msg_size);
  msg->Nix = l.head.nix;
  msg->Count = count;

  count = 0;
  LstForEach(al, &l.active_l) {
    ap = LstEntry(al, sActive, active_l);

    if (!ap->detect_etp)
      continue;

    switch (ap->detect_etp->event) {
    case mh_eEvent_Info:
    case mh_eEvent_InfoSuccess:
    case mh_eEvent_Alarm:
    case mh_eEvent_MaintenanceAlarm:
    case mh_eEvent_SystemAlarm:
    case mh_eEvent_UserAlarm1:
    case mh_eEvent_UserAlarm2:
    case mh_eEvent_UserAlarm3:
    case mh_eEvent_UserAlarm4:

      ep = ap->detect_etp->ep;

      if (ap->detect_etp->event == mh_eEvent_Info
          || ap->detect_etp->event == mh_eEvent_InfoSuccess) {
        if (ep && !(ep->msg.info.EventFlags & mh_mEventFlags_InfoWindow))
          break;
        if (ep && ep->msg.info.EventFlags & mh_mEventFlags_InfoWindow
            && !(ep->msg.info.EventFlags & mh_mEventFlags_Ack))
          break;
      }

      if (ep)
        is_for_outunit = isForOutunit(op, ep->outunit, ep->object.Objid,
            ep->objName, ep->msg.info.EventFlags, ep->eventType, ep->local);
      else
        is_for_outunit = isForOutunit(op, ap->outunit, ap->object.Objid,
            ap->objName, ap->eventFlags, ap->eventType, ap->local);
      if (is_for_outunit) {
        msg->Sts[count].Idx = ap->idx;
        msg->Sts[count].Status = ap->status.Event.Status;
        count++;
      }
      break;
    default:;
    }
  }
  sts = sendToOutunit(
      op, mh_eMsg_HandlerAlarmStatus, 0, op->outunit.oix, msg, msg_size);
  free((char*)msg);
}

static void checkOutunits()
{
  sOutunit* op;
  struct LstHead * ol;

  LstForEach(ol, &l.outunit_l) {
    op = LstEntry(ol, sOutunit, outunit_l);

    if (op->linkUp && op->type == mh_eOutunitType_Operator && op->ver >= 5)
      /* Set alarm status to operator */
      sendAlarmStatus(op);
    else {
      /* Send sync */
      if (op->linkUp && op->syncedIdx != op->eventIdx) {
        if (op->check) {
          sendToOutunit(op, mh_eMsg_HandlerSync, 0, 0, NULL, 0);
        } else {
          op->check = 1;
        }
      }
    }
  }
}

static void cSup_exec(sSupActive* sp)
{
  pwr_sClass_CycleSup* o = (pwr_sClass_CycleSup*)sp->op;
  pwr_tTime dnow;
  pwr_tTime nextLimit;
  int diff;

  //  time_Uptime(NULL, &dnow, NULL);
  time_GetTimeMonotonic(&dnow);
  nextLimit.tv_nsec = o->NextLimit.tv_nsec;
  nextLimit.tv_sec = o->NextLimit.tv_sec;
  o->DetectCount++;

  if (time_Acomp(&nextLimit, NULL) == 0 && o->DetectCount < 20)
    return;

  diff = time_Acomp(&dnow, &nextLimit);

  if (diff > 0 || (o->Delayed && !o->DelayNoted)) {
    if (o->AlarmCheck && o->DetectOn && !o->Blocked) {
      if (o->DetectCheck) {
        timerIn(sp, (sTimer*)&o->TimerFlag);
        if (o->Delayed) {
          o->DetectTime = o->DelayedTime;
        } else {
          time_GetTime(&o->DetectTime);
        }
        o->DetectCheck = FALSE;
      }
      if (!o->TimerFlag) {
        o->DetectSend = TRUE;
        o->ReturnCheck = TRUE;
        o->Acked = FALSE;
        o->AlarmCheck = FALSE;
        o->DelayNoted = TRUE;
        if (o->DelayAction == 2) {
          int prev_rwflag = l.iohp->IOReadWriteFlag;
          l.iohp->IOReadWriteFlag = FALSE;
          l.nodep->EmergBreakTrue = TRUE;
          errh_SetStatus(MH__IOSTALLED);
          if (prev_rwflag)
            errh_Fatal("CycleSup delayed with action Stop I/O");
        }
      }
    }
  } else if (diff <= 0 || (o->Delayed && o->Timely)) {
    if (o->ReturnCheck) {
      if (o->Timely) {
        o->ReturnTime = o->TimelyTime;
      } else {
        time_GetTime(&o->ReturnTime);
      }
      o->ReturnCheck = FALSE;
      o->ReturnSend = TRUE;
    }
    if (o->AlarmCheck && !o->DetectCheck) {
      o->DelayNoted = FALSE;
      o->TimerCount = 0;
      o->DetectCheck = TRUE;
      o->Delayed = FALSE;
    }
  }
}

static void dSup_exec(sSupActive* sp)
{
  pwr_sClass_DSup* o = (pwr_sClass_DSup*)sp->op;
  pwr_tBoolean In = *(pwr_tBoolean*)sp->actualValue;

  if (In != o->CtrlPosition) {
    if (o->Action)
      o->Action = FALSE;
    if (o->ReturnCheck) {
      time_GetTime(&o->ReturnTime);
      o->ReturnCheck = FALSE;
      o->ReturnSend = TRUE;
    }
    if (o->AlarmCheck && !o->DetectCheck) {
      o->TimerFlag = FALSE;
      o->DetectCheck = TRUE;
    }
  } else {
    if (!o->Action) {
      o->Action = TRUE;
    }
    if (o->Suppressed) {
      if (o->ReturnCheck) {
        time_GetTime(&o->ReturnTime);
        o->ReturnCheck = FALSE;
        o->ReturnSend = TRUE;
      } else if (o->DetectSend)
        o->DetectSend = FALSE;
    }
    if (o->AlarmCheck && o->DetectOn && !o->Blocked && !o->Suppressed) {
      if (o->DetectCheck) {
        o->ActualValue = In;
        timerIn(sp, (sTimer*)&o->TimerFlag);
        if (!(o->EventFlags & pwr_mEventFlagsMask_UserDetectTime))
          time_GetTime(&o->DetectTime);
        o->DetectCheck = FALSE;
      }
      if (!o->TimerFlag) {
        o->DetectSend = TRUE;
        o->ReturnCheck = TRUE;
        o->Acked = FALSE;
        o->AlarmCheck = FALSE;
      }
    }
  }
}

static void enableQcomEvents(qcom_sQid myQ)
{
  int sts;
  qcom_sQid otherQue;

  otherQue = qcom_cQnetEvent;
  if (!qcom_Bind(&sts, &myQ, &otherQue)) {
    errh_Fatal("qcom_Bind(QnetEvent), %m", sts);
    exit(-1);
  }

  otherQue = qcom_cQapplEvent;
  if (!qcom_Bind(&sts, &myQ, &otherQue)) {
    errh_Fatal("qcom_Bind(QapplEvent), %m", sts);
    exit(-1);
  }

  otherQue = qcom_cQini;
  if (!qcom_Bind(&sts, &myQ, &otherQue)) {
    errh_Fatal("qcom_Bind(Qini), %m", sts);
    exit(-1);
  }
}

static void enableQcomAllHandlers(qcom_sQid myQ)
{
  int sts;
  qcom_sQid allHandQid = mh_cProcAllHandlers;

  if (!qcom_Bind(&sts, &myQ, &allHandQid)) {
    errh_Fatal("qcom_Bind(ProcAllHandlers), %m", sts);
    exit(-1);
  }
}

static void eventListInit()
{
  l.event_l = (sEventList*)calloc(
      1, sizeof(sEventList) + sizeof(sEvent) * l.emon->EventListSize);
  if (l.event_l == NULL) {
    errh_Error("Allocating event list");
    exit(0);
  }
  l.event_l->idx = 0; /* Index 0 not used for events */
  l.event_l->oldIdx = 0;
  l.event_l->size = l.emon->EventListSize;
}

static sEvent* eventListInsert(mh_eEvent event, char* text, sActive* ap)
{
  pwr_tStatus sts;
  sEvent* ep;
  pwr_tUInt32 idx;
  sEventTab* etp;

  idx = ++l.event_l->idx;
  l.emon->EventCount = idx;

  if (l.event_l->idx == 1) {
    l.event_l->oldIdx = 1;
    l.emon->EventCount = 1;
  } else if (l.event_l->idx > l.event_l->size) {
    l.event_l->oldIdx += 1;
  }

  ep = &l.event_l->list[idx % l.event_l->size];
  ep->idx = idx;
  ep->outunit = ap->outunit;
  ep->object = ap->object;
  ep->local = ap->local;
  ep->eventType = ap->eventType;
  memcpy(ep->objName, ap->objName, sizeof(ap->objName));
  ep->event = event;
  memset(&ep->msg, 0, sizeof(ep->msg));

  if (ep->etp != NULL) {
    ep->etp->ep = NULL;
    if (ep->etp->ap == NULL)
      tree_Remove(&sts, l.eventTab, &ep->etp->idx);
  }
  ep->etp = etp = tree_Insert(&sts, l.eventTab, &idx);

  if ((ap->event != mh_eEvent_Info && ap->event != mh_eEvent_InfoSuccess)
      || (ap->eventFlags & mh_mEventFlags_InfoWindow) != 0)
    etp->ap = ap;
  else
    etp->ap = NULL;
  etp->event = event;
  etp->ep = ep;

  switch (event) {
  case mh_eEvent_Info:
  case mh_eEvent_InfoSuccess:
  case mh_eEvent_Alarm:
  case mh_eEvent_MaintenanceAlarm:
  case mh_eEvent_SystemAlarm:
  case mh_eEvent_UserAlarm1:
  case mh_eEvent_UserAlarm2:
  case mh_eEvent_UserAlarm3:
  case mh_eEvent_UserAlarm4:
  case mh_eEvent_Block:
  case mh_eEvent_Reblock:
    ap->idx = idx;
    ap->detect_etp = etp;
    break;
  case mh_eEvent_Unblock:
    ap->returnIdx = idx;
    ap->return_etp = etp;
    break;
  case mh_eEvent_Ack:
    ap->ackIdx = idx;
    ap->ack_etp = etp;
    break;
  case mh_eEvent_Return:
  case mh_eEvent_Cancel:
    ap->returnIdx = idx;
    ap->return_etp = etp;
    break;
  case mh_eEvent_CancelBlock: /* Is this correct ??*/
  default:
    errh_Error("eventListInsert, program error, event: %d", event);
    break;
  }

  switch (ap->source) {
  case mh_eSource_Scanner:
    formatSupEvent(event, text, (sSupActive*)ap, &ep->msg, &ep->msgSize);
    break;
  case mh_eSource_Application:
  case mh_eSource_Handler:
    formatApplEvent(event, text, (sApplActive*)ap, &ep->msg, &ep->msgSize);
    break;
  case mh_eSource_Outunit:
    formatOutunitEvent(event, text, (sBlock*)ap, &ep->msg, &ep->msgSize);
    break;
  default:
    errh_Error("eventListInsert, programming error, source: %d", ap->source);
    break;
  }
  // printf( "** eventListInsert %s ap: %u\n", ep->objName, (unsigned
  // int)ep->etp->ap);

  return ep;
}

static void eventToOutunits(sEvent* ep)
{
  struct LstHead * ol;
  sOutunit* op;

  LstForEach(ol, &l.outunit_l) {
    op = LstEntry(ol, sOutunit, outunit_l);
    if (op->syncedIdx == op->eventIdx)
      sendEventListToOutunit(op);
  }
}

static void formatApplEvent(mh_eEvent event, char* text, sApplActive* aap,
    uEvent* up, pwr_tUInt32* size)
{
  mh_sAck* acp;
  mh_sReturn* rp;
  mh_sMessage* mp;
  mh_sMsgInfo* ip = &up->message.Info;

  ip->Id.Nix = l.head.nix;
  ip->Id.BirthTime = l.head.birthTime;
  ip->EventFlags = aap->link.eventFlags;
  ip->EventType = event;

  switch (event) {
  case mh_eEvent_Alarm:
  case mh_eEvent_MaintenanceAlarm:
  case mh_eEvent_SystemAlarm:
  case mh_eEvent_UserAlarm1:
  case mh_eEvent_UserAlarm2:
  case mh_eEvent_UserAlarm3:
  case mh_eEvent_UserAlarm4:
  case mh_eEvent_Info:
  case mh_eEvent_InfoSuccess:
    mp = &up->message;
    ip->Id.Idx = aap->link.idx;
    ip->EventTime = net_TimeToNetTime(&aap->message.EventTime);
    if (aap->link.event == mh_eEvent_Alarm
        || aap->link.event == mh_eEvent_MaintenanceAlarm
        || aap->link.event == mh_eEvent_SystemAlarm
        || aap->link.event == mh_eEvent_UserAlarm1
        || aap->link.event == mh_eEvent_UserAlarm2
        || aap->link.event == mh_eEvent_UserAlarm3
        || aap->link.event == mh_eEvent_UserAlarm4)
      ip->EventPrio = aap->message.EventPrio;
    strncpy(mp->EventText, aap->message.EventText, sizeof(mp->EventText));
    mp->SupInfo.SupType = aap->message.SupInfo.SupType;
    memcpy(&mp->SupInfo, &aap->message.SupInfo, sizeof(mh_uSupInfo));
    mp->EventSound = aap->link.eventSound;
    strncpy(mp->EventMoreText, aap->message.EventMoreText,
        sizeof(mp->EventMoreText));
    mp->Object = aap->link.object;
    mp->SupObject = aap->link.supObject;
    strncpy(mp->EventName, aap->link.eventName, sizeof(mp->EventName));
    *size = sizeof(mh_sMessage);

    break;
  case mh_eEvent_Ack:
    acp = &up->ack;
    ip->Id.Idx = aap->link.ackIdx;
    ip->EventTime = net_TimeToNetTime(&aap->ackTime);
    if (aap->link.event == mh_eEvent_Alarm
        || aap->link.event == mh_eEvent_MaintenanceAlarm
        || aap->link.event == mh_eEvent_SystemAlarm
        || aap->link.event == mh_eEvent_UserAlarm1
        || aap->link.event == mh_eEvent_UserAlarm2
        || aap->link.event == mh_eEvent_UserAlarm3
        || aap->link.event == mh_eEvent_UserAlarm4)
      ip->EventPrio = aap->message.EventPrio;
    acp->TargetId.Nix = l.head.nix;
    acp->TargetId.BirthTime = l.head.birthTime;
    acp->TargetId.Idx = aap->link.idx;
    acp->DetectTime = net_TimeToNetTime(&aap->message.EventTime);
    acp->Outunit = aap->ackOutunit;
    acp->SupInfo.SupType = aap->message.SupInfo.SupType;
    memcpy(&acp->SupInfo, &aap->message.SupInfo, sizeof(mh_uSupInfo));
    acp->Object = aap->link.object;
    acp->SupObject = aap->link.supObject;
    strncpy(acp->EventName, aap->link.eventName, sizeof(acp->EventName));
    *size = sizeof(mh_sAck);

    break;
  case mh_eEvent_Cancel:
    rp = &up->ret;
    ip->Id.Idx = aap->link.returnIdx;
    net_GetTime(&ip->EventTime);
    if (aap->link.event == mh_eEvent_Alarm
        || aap->link.event == mh_eEvent_MaintenanceAlarm
        || aap->link.event == mh_eEvent_SystemAlarm
        || aap->link.event == mh_eEvent_UserAlarm1
        || aap->link.event == mh_eEvent_UserAlarm2
        || aap->link.event == mh_eEvent_UserAlarm3
        || aap->link.event == mh_eEvent_UserAlarm4)
      ip->EventPrio = aap->message.EventPrio;
    strncpy(rp->EventText, aap->returnText, sizeof(rp->EventText));
    rp->TargetId.Nix = l.head.nix;
    rp->TargetId.BirthTime = l.head.birthTime;
    rp->TargetId.Idx = aap->link.idx;
    rp->DetectTime = net_TimeToNetTime(&aap->message.EventTime);
    rp->SupInfo.SupType = aap->message.SupInfo.SupType;
    memcpy(&rp->SupInfo, &aap->message.SupInfo, sizeof(mh_uSupInfo));
    rp->Object = aap->link.object;
    rp->SupObject = aap->link.supObject;
    strncpy(rp->EventName, aap->link.eventName, sizeof(rp->EventName));
    *size = sizeof(mh_sReturn);

    break;
  case mh_eEvent_Return:
    rp = &up->ret;
    ip->Id.Idx = aap->link.returnIdx;
    ip->EventTime = net_TimeToNetTime(&aap->returnTime);
    if (aap->link.event == mh_eEvent_Alarm
        || aap->link.event == mh_eEvent_MaintenanceAlarm
        || aap->link.event == mh_eEvent_SystemAlarm
        || aap->link.event == mh_eEvent_UserAlarm1
        || aap->link.event == mh_eEvent_UserAlarm2
        || aap->link.event == mh_eEvent_UserAlarm3
        || aap->link.event == mh_eEvent_UserAlarm4)
      ip->EventPrio = aap->message.EventPrio;
    strncpy(rp->EventText, aap->returnText, sizeof(rp->EventText));
    rp->TargetId.Nix = l.head.nix;
    rp->TargetId.BirthTime = l.head.birthTime;
    rp->TargetId.Idx = aap->link.idx;
    rp->DetectTime = net_TimeToNetTime(&aap->message.EventTime);
    rp->SupInfo.SupType = aap->message.SupInfo.SupType;
    memcpy(&rp->SupInfo, &aap->message.SupInfo, sizeof(mh_uSupInfo));
    rp->Object = aap->link.object;
    rp->SupObject = aap->link.supObject;
    strncpy(rp->EventName, aap->link.eventName, sizeof(rp->EventName));
    *size = sizeof(mh_sReturn);

    break;
  default:
    errh_Error("formatApplEvent, program error, event: %d", event);
    break;
  }
}

static void formatSupEvent(
    mh_eEvent event, char* text, sSupActive* sp, uEvent* up, pwr_tUInt32* size)
{
  sSup* sup;
  mh_sAck* acp;
  mh_sReturn* rp;
  mh_sMessage* mp;
  mh_sMsgInfo* ip = &up->message.Info;

  ip->Id.Nix = l.head.nix;
  ip->Id.BirthTime = l.head.birthTime;
  ip->EventFlags = sp->link.eventFlags;
  ip->EventType = event;
  sup = sp->sup;

  switch (event) {
  case mh_eEvent_Alarm:
  case mh_eEvent_MaintenanceAlarm:
  case mh_eEvent_SystemAlarm:
  case mh_eEvent_UserAlarm1:
  case mh_eEvent_UserAlarm2:
  case mh_eEvent_UserAlarm3:
  case mh_eEvent_UserAlarm4:
  case mh_eEvent_Info:
  case mh_eEvent_InfoSuccess:
    mp = &up->message;
    ip->Id.Idx = sp->link.idx;
    ip->EventTime = net_TimeToNetTime(&sup->DetectTime);
    strncpy(mp->EventText, sup->DetectText, sizeof(mp->EventText));
    if (sp->link.event == mh_eEvent_Alarm
        || sp->link.event == mh_eEvent_MaintenanceAlarm
        || sp->link.event == mh_eEvent_SystemAlarm
        || sp->link.event == mh_eEvent_UserAlarm1
        || sp->link.event == mh_eEvent_UserAlarm2
        || sp->link.event == mh_eEvent_UserAlarm3
        || sp->link.event == mh_eEvent_UserAlarm4)
      ip->EventPrio = sup->EventPriority;
    mp->SupInfo.SupType = sp->supType;
    if (sp->supInfoSize > sizeof(mp->SupInfo.mh_uSupInfo_u)) {
      errh_Error("formatSupEvent, program error, size: %d", sp->supInfoSize);
      sp->supInfoSize = sizeof(mp->SupInfo.mh_uSupInfo_u);
    }
    mp->EventSound = sp->link.eventSound;
    strncpy(mp->EventMoreText, sup->MoreText, sizeof(mp->EventMoreText));
    mp->Object = sp->link.object;
    mp->SupObject = sp->link.supObject;
    strncpy(mp->EventName, sp->link.eventName, sizeof(mp->EventName));
    strncpy(mp->Receiver, sup->Recipient, sizeof(mp->Receiver));
    memcpy(&mp->SupInfo.mh_uSupInfo_u, sp->supInfoP, sp->supInfoSize);
    *size = sizeof(mh_sMessage);

    break;
  case mh_eEvent_Ack:
    acp = &up->ack;
    ip->Id.Idx = sp->link.ackIdx;
    ip->EventTime = net_TimeToNetTime(&sup->AckTime);
    if (sp->link.event == mh_eEvent_Alarm
        || sp->link.event == mh_eEvent_MaintenanceAlarm
        || sp->link.event == mh_eEvent_SystemAlarm
        || sp->link.event == mh_eEvent_UserAlarm1
        || sp->link.event == mh_eEvent_UserAlarm2
        || sp->link.event == mh_eEvent_UserAlarm3
        || sp->link.event == mh_eEvent_UserAlarm4)
      ip->EventPrio = sup->EventPriority;
    acp->TargetId.Idx = sp->link.idx;
    acp->TargetId.Nix = l.head.nix;
    acp->TargetId.BirthTime = l.head.birthTime;
    acp->DetectTime = net_TimeToNetTime(&sup->DetectTime);
    acp->Outunit = sup->AckOutunit;
    acp->Object = sp->link.object;
    acp->SupObject = sp->link.supObject;
    strncpy(acp->EventName, sp->link.eventName, sizeof(acp->EventName));
    *size = sizeof(mh_sAck);

    break;
  case mh_eEvent_Return:
    rp = &up->ret;
    ip->Id.Idx = sp->link.returnIdx;
    ip->EventTime = net_TimeToNetTime(&sup->ReturnTime);
    if (sp->link.event == mh_eEvent_Alarm
        || sp->link.event == mh_eEvent_MaintenanceAlarm
        || sp->link.event == mh_eEvent_SystemAlarm
        || sp->link.event == mh_eEvent_UserAlarm1
        || sp->link.event == mh_eEvent_UserAlarm2
        || sp->link.event == mh_eEvent_UserAlarm3
        || sp->link.event == mh_eEvent_UserAlarm4)
      ip->EventPrio = sup->EventPriority;
    strncpy(rp->EventText, sup->ReturnText, sizeof(rp->EventText));
    rp->TargetId.Idx = sp->link.idx;
    rp->TargetId.Nix = l.head.nix;
    rp->TargetId.BirthTime = l.head.birthTime;
    rp->DetectTime = net_TimeToNetTime(&sup->DetectTime);
    rp->SupInfo.SupType = sp->supType;
    if (sp->supInfoSize > sizeof(rp->SupInfo.mh_uSupInfo_u)) {
      errh_Error("formatSupEvent, program error, size: %d", sp->supInfoSize);
      sp->supInfoSize = sizeof(rp->SupInfo.mh_uSupInfo_u);
    }
    rp->Object = sp->link.object;
    rp->SupObject = sp->link.supObject;
    strncpy(rp->EventName, sp->link.eventName, sizeof(rp->EventName));
    memcpy(&rp->SupInfo.mh_uSupInfo_u, sp->supInfoP, sp->supInfoSize);
    *size = sizeof(mh_sReturn);

    break;
  case mh_eEvent_Cancel:
    rp = &up->ret;
    ip->Id.Idx = sp->link.returnIdx;
    if (sp->link.event == mh_eEvent_Alarm
        || sp->link.event == mh_eEvent_MaintenanceAlarm
        || sp->link.event == mh_eEvent_SystemAlarm
        || sp->link.event == mh_eEvent_UserAlarm1
        || sp->link.event == mh_eEvent_UserAlarm2
        || sp->link.event == mh_eEvent_UserAlarm3
        || sp->link.event == mh_eEvent_UserAlarm4)
      ip->EventPrio = sup->EventPriority;
    net_GetTime(&ip->EventTime);
    strncpy(rp->EventText, text, sizeof(rp->EventText));
    rp->TargetId.Idx = sp->link.idx;
    rp->TargetId.Nix = l.head.nix;
    rp->TargetId.BirthTime = l.head.birthTime;
    rp->DetectTime = net_TimeToNetTime(&sup->DetectTime);
    rp->SupInfo.SupType = sp->supType;
    rp->Object = sp->link.object;
    rp->SupObject = sp->link.supObject;
    strncpy(rp->EventName, sp->link.eventName, sizeof(rp->EventName));
    if (sp->supInfoSize > sizeof(rp->SupInfo.mh_uSupInfo_u)) {
      errh_Error("formatSupEvent, program error, size: %d", sp->supInfoSize);
      sp->supInfoSize = sizeof(rp->SupInfo.mh_uSupInfo_u);
    }
    memcpy(&rp->SupInfo.mh_uSupInfo_u, sp->supInfoP, sp->supInfoSize);
    *size = sizeof(mh_sReturn);
    break;
  default:
    errh_Error("formatSupEvent, program error, event: %d", event);
    break;
  }

  msgToV3(event, up);
}

static void formatOutunitEvent(
    mh_eEvent event, char* text, sBlock* bp, uEvent* up, pwr_tUInt32* size)
{
  mh_sBlock* bmp = &up->block;
  mh_sMsgInfo* ip = &up->message.Info;

  ip->Id.Nix = l.head.nix;
  ip->Id.BirthTime = l.head.birthTime;
  ip->EventFlags = bp->link.eventFlags;
  ip->EventType = event;
  bmp->Status = bp->link.status.Event.Status;

  switch (event) {
  case mh_eEvent_Block:
    ip->EventTime = bp->outunitBlock.time;
    ip->EventPrio = bp->outunitBlock.prio;
    ip->Id.Idx = bp->link.idx;
    bmp->Outunit = bp->outunitBlock.outunit;
    bmp->Object = bp->link.object;
    strncpy(bmp->EventName, bp->link.eventName, sizeof(bmp->EventName));
    *size = sizeof(mh_sBlock);
    break;
  case mh_eEvent_Unblock:
    ip->EventTime = bp->outunitUnblock.time;
    ip->Id.Idx = bp->link.returnIdx;
    ip->EventPrio = bp->outunitBlock.prio;
    bmp->TargetId.Idx = bp->link.idx;
    bmp->TargetId.Nix = l.head.nix;
    bmp->TargetId.BirthTime = l.head.birthTime;
    bmp->Outunit = bp->outunitUnblock.outunit;
    bmp->DetectTime = bp->outunitBlock.time;
    bmp->Object = bp->link.object;
    strncpy(bmp->EventName, bp->link.eventName, sizeof(bmp->EventName));
    *size = sizeof(mh_sBlock);
    break;
  case mh_eEvent_Reblock:
    ip->EventTime = bp->outunitBlock.time;
    ip->Id.Idx = bp->link.idx;
    ip->EventPrio = bp->outunitBlock.prio;
    bmp->TargetId.Idx = bp->link.returnIdx;
    bmp->TargetId.Nix = l.head.nix;
    bmp->TargetId.BirthTime = l.head.birthTime;
    bmp->Outunit = bp->outunitBlock.outunit;
    bmp->DetectTime = bp->outunitUnblock.time;
    bmp->Object = bp->link.object;
    strncpy(bmp->EventName, bp->link.eventName, sizeof(bmp->EventName));
    *size = sizeof(mh_sBlock);
    break;
  default:
    errh_Error("formatOutUnitEvent, program error, event: %d", event);
    break;
  }
  msgToV3(event, up);
}

static void fromApplication(qcom_sGet* get)
{
  sAppl* ap;
  mh_uApplReply reply;
  mh_sHead* hp = (mh_sHead*)get->data;
  qcom_sAid* aid = &get->sender;
  struct timespec hold = { 0, 10000 };

  get->reply = hp->qid;

  if (!isValidApplication(hp, aid, &ap, &reply)) {
    applReply(get, &reply, sizeof(reply));
    return;
  }

  switch (hp->type) {
  case mh_eMsg_ApplMessage:
    applMessage(hp, ap, &reply);
    break;
  case mh_eMsg_ApplReturn:
    applReturn(hp, ap, &reply);
    break;
  case mh_eMsg_ApplConnect:
    applConnect(hp, ap, &reply);
    break;
  case mh_eMsg_ApplDisconnect:
    applDisconnect(hp, ap, &reply);
    break;
  case mh_eMsg_ApplGetMsgInfo:
    applGetMsgInfo(hp, ap, &reply);
    break;
  default:
    errh_Info("fromApplication, program error, type: %d", hp->type);
    reply.Sts = MH__PROGERR;
    break;
  }

  nanosleep(&hold, NULL);

  applLogState(ap);
  applReply(get, &reply, sizeof(reply));
}

static void fromHandler(qcom_sGet* get)
{
  mh_sHead* hp = (mh_sHead*)get->data;

  switch (hp->type) {
  case mh_eMsg_ProcDown:
    if (!(hp->ver == mh_cVersion
            || (mh_cVersion == 5 && (hp->ver == 3 || hp->ver == 4)))) {
      /* Different versions, not yet implemented (V5 is compatible with V3 and
       * V4 */
      errh_Info("fromHandler, Received a Message with different version");
      break;
    }

    if (qcom_QidIsEqual(&hp->qid, &l.head.qid))
      break; /* Message is from this handler */
    procDown((qcom_sAid*)(hp + 1));
    break;
  default:
    break;
  }
}

static void fromMessageUnit(qcom_sGet* get)
{
  mh_sHead* hp = (mh_sHead*)get->data;

  switch (hp->source) {
  case mh_eSource_Outunit:
    fromOutunit(get);
    break;
  case mh_eSource_Application:
    fromApplication(get);
    break;
  case mh_eSource_Handler:
    fromHandler(get);
    break;
  default:
    errh_Error("fromMessageUnit, programming error, source: %d", hp->source);
    break;
  }
}

static void fromOutunit(qcom_sGet* get)
{
  sOutunit* op;
  mh_sHead* hp = (mh_sHead*)get->data;
  qcom_sAid* aid = &get->sender;

  if (hp->type == mh_eMsg_OutunitHello) {
    sendMessage(mh_eMsg_HandlerHello, &hp->qid, &hp->platform, NULL, 0);
    return;
  }

  if (!isValidOutunit(hp, aid, &op))
    return;

  switch (hp->type) {
  case mh_eMsg_OutunitAck:
    outunitAck(hp, op);
    break;
  case mh_eMsg_OutunitBlock:
    outunitBlock(hp, op);
    break;
  case mh_eMsg_OutunitDisconnect:
    outunitDisconnect(hp, op);
    break;
  case mh_eMsg_OutunitInfo:
    outunitInfo(hp, op);
    break;
  case mh_eMsg_Sync:
    outunitSync(hp, op);
    break;
  case mh_eMsg_OutunitSync:
    sendToOutunit(op, mh_eMsg_Sync, 0, 0, NULL, 0);
    break;
  case mh_eMsg_OutunitAlarmReq:
    outunitAlarmReq(hp, op);
    break;
  default:
    errh_Error("fromOutunit, program error, type: %d", hp->type);
    break;
  }
}

static void fromQcom(qcom_sGet* gp)
{
  qcom_sQid qid;
  qcom_sAid* aid;

  switch (gp->type.s) {
  case qcom_eStype_applConnect:
    break;
  case qcom_eStype_applDisconnect:
    aid = &((qcom_sAppl*)gp->data)->aid;
    procDown(aid);
    /* Inform other handlers */
    qid = mh_cProcAllHandlers;
    sendMessage(mh_eMsg_ProcDown, &qid, NULL, aid, sizeof(*aid));
    break;
  case qcom_eStype_linkActive:
    linkActive(gp);
    break;
  case qcom_eStype_linkConnect:
    linkConnect(gp);
    break;
  case qcom_eStype_linkDisconnect:
    linkDisconnect(gp);
    break;
  case qcom_eStype_linkStalled:
    linkStalled(gp);
    break;
  default:
    errh_Error("fromQcom, program error, type: %d", gp->type.s);
    break;
  }
}

static void fromEvent(qcom_sGet* get)
{
  static int sav_event = 0;
  ini_mEvent cur_event;
  ini_mEvent new_event;
  qcom_sEvent* ep = (qcom_sEvent*)get->data;

  if (get->type.s != qcom_cIini)
    return;

  cur_event.m = sav_event;
  new_event.m = ep->mask;

  if (new_event.b.swapDone & !cur_event.b.swapDone) {
    struct LstHead * ol;
    sOutunit* op;

    errh_Info("Warm restart completed.");

    handlerEvent(pwr_eSystemEventTypeEnum_NodeRestart, l.head.nix, 0);
    reInitSupList();

    if (!LstEmpty(&l.sup_l)) {
      l.supListState = eSupListState_Scan;
      setTimerActive(cMessageIdx, TRUE);
      if (!LstEmpty(&l.detect_l)) {
        scanTimerList();
        scanDetectList();
        setTimerActive(cDetectIdx, TRUE);
      }
      scanSupList();
    } else {
      l.supListState = eSupListState_NoSup;
      setTimerActive(cMessageIdx, FALSE);
      errh_Info("No supervise objects.");
    }
    LstForEach(ol, &l.outunit_l) {
      op = LstEntry(ol, sOutunit, outunit_l);
      sendToOutunit(op, mh_eMsg_OutunitClear, 0, 0, NULL, 0);
    }
    LstForEach(ol, &l.outunit_l) {
      op = LstEntry(ol, sOutunit, outunit_l);
      sendEventListToOutunit(op);
    }
    pwrb_IOHandler_Exec(handlerEvent_cb, 1);

  } else if (new_event.b.swapInit & !cur_event.b.swapInit) {
    l.supListState = eSupListState_Wait;
    errh_Info("Warm restart initiated.");
    handlerEvent(pwr_eSystemEventTypeEnum_NodeRestart, l.head.nix, 1);
  } else if (new_event.b.simLoadStart & !cur_event.b.simLoadStart) {
    struct LstHead * ol;
    sOutunit* op;

    l.supListState = eSupListState_Wait;
    handlerEvent(pwr_eSystemEventTypeEnum_SimulateLoad, l.head.nix, 1);

    LstForEach(ol, &l.outunit_l) {
      op = LstEntry(ol, sOutunit, outunit_l);
      if (op->syncedIdx == op->eventIdx)
        sendToOutunit(op, mh_eMsg_OutunitClear, 0, 0, NULL, 0);
    }
    printf("rt_emon: SimLoadStart\n");
  } else if (new_event.b.simLoadDone & !cur_event.b.simLoadDone) {
    printf("rt_emon: SimLoadDone\n");
    handlerEvent(pwr_eSystemEventTypeEnum_SimulateLoad, l.head.nix, 0);
    reInitSupList();

    if (!LstEmpty(&l.sup_l)) {
      l.supListState = eSupListState_Scan;
      setTimerActive(cMessageIdx, TRUE);
      if (!LstEmpty(&l.detect_l)) {
        scanTimerList();
        scanDetectList();
        setTimerActive(cDetectIdx, TRUE);
      }
      scanSupList();
    } else {
      l.supListState = eSupListState_NoSup;
      setTimerActive(cMessageIdx, FALSE);
    }
  } else if (new_event.b.terminate & !cur_event.b.terminate) {
    exit(0);
  }

  sav_event = ep->mask;
}

static void getHandlerObject()
{
  pwr_tStatus sts;
  pwr_tObjid nodeOid;
  pwr_sAttrRef aref;
  pwr_tDlid dlid;
  pwr_tBoolean created = FALSE;

  sts = gdh_GetNodeObject(pwr_cNNodeId, &nodeOid);
  if (EVEN(sts)) {
    errh_Fatal("Couldn't get node object\n%m", sts);
    exit(sts);
  }
  sts = gdh_ObjidToName(nodeOid, l.emonName, sizeof(l.emonName), cdh_mNName);
  if (EVEN(sts)) {
    errh_Fatal("Couldn't get node name\n%m", sts);
    exit(sts);
  }

  strcat(l.emonName, "-MessageHandler");

  sts = gdh_GetClassList(pwr_cClass_MessageHandler, &l.emonObject);
  if (EVEN(sts)) {
    strcpy(l.emonName, "pwrNode-MessageHandler");
    sts = gdh_CreateObject(l.emonName, pwr_cClass_MessageHandler,
        sizeof(pwr_sClass_MessageHandler), &l.emonObject, pwr_cNObjid, 0,
        pwr_cNObjid);
    if (EVEN(sts)) {
      errh_Fatal("Couldn't create message handler object\n%m", sts);
      exit(sts);
    }
    created = TRUE;
  }
  aref = cdh_ObjidToAref(l.emonObject);
  sts = gdh_DLRefObjectInfoAttrref(&aref, (pwr_tAddress*)&l.emon, &dlid);
  if (EVEN(sts)) {
    errh_Fatal("Couldn't get direct link to message handler object\n%m", sts);
    exit(sts);
  }

  if (created) {
    l.emon->EventListSize = mh_cMaxEvents;
    l.emon->MaxApplAlarms = mh_cMaxApplAlarm;
    l.emon->DetectTimer = mh_cDetectTimer;
    l.emon->MessageTimer = mh_cMessageTimer;
    l.emon->OutunitServer = FALSE;
  }

  l.outunitServer = l.emon->OutunitServer;
  l.emon->AlarmCount = 0;
  l.emon->EventCount = 0;

  l.timerTime = MIN(l.emon->DetectTimer, l.emon->MessageTimer);
  l.timerTime = MIN(l.timerTime, cTimerOpenBlock);
  l.timerTime = MAX(l.timerTime, 0.1); /* Not faster than 10 Hz */
  l.timerTimeDelta.tv_sec = floor(l.timerTime);
  l.timerTimeDelta.tv_nsec = (l.timerTime - l.timerTimeDelta.tv_sec) * 1e9;

  l.timers[cBlockDbIdx].type = eTimer_BlockDbOpen;
  l.timers[cBlockDbIdx].multiple = MAX(1, cTimerOpenBlock / l.timerTime);
  l.timers[cBlockDbIdx].count = 0;
  l.timers[cBlockDbIdx].active = FALSE;

  l.timers[cDetectIdx].type = eTimer_ScanDetect;
  l.timers[cDetectIdx].multiple = MAX(1, l.emon->DetectTimer / l.timerTime);
  l.timers[cDetectIdx].count = 0;
  l.timers[cDetectIdx].active = FALSE;
  l.detectTimerTime = l.timerTime * l.timers[cDetectIdx].multiple;

  l.timers[cMessageIdx].type = eTimer_ScanMessage;
  l.timers[cMessageIdx].multiple = MAX(1, l.emon->MessageTimer / l.timerTime);
  l.timers[cMessageIdx].count = 0;
  l.timers[cMessageIdx].active = FALSE;

  l.timers[cOutunitIdx].type = eTimer_OutunitSync;
  l.timers[cOutunitIdx].multiple = MAX(1, cTimerOutunitSync / l.timerTime);
  l.timers[cOutunitIdx].count = 0;
  l.timers[cOutunitIdx].active = FALSE;

  aproc_RegisterObject(l.emonObject);

  /* Get IOHandler object */
  sts = gdh_GetClassList(pwr_cClass_IOHandler, &l.iohObject);
  if (EVEN(sts)) {
    errh_Info("Could not find IO handler object, %m", sts);
    return;
  }
  sts = gdh_ObjidToName(l.iohObject, l.iohName, sizeof(l.iohName), cdh_mNName);
  if (EVEN(sts)) {
    errh_Info("Could not find IO handler object, %m", sts);
    return;
  }

  l.iohp = NULL;
  gdh_ObjidToPointer(l.iohObject, (void*)&l.iohp);

  sts = gdh_GetNodeObject(0, &l.nodeObject);
  if (ODD(sts))
    sts = gdh_ObjidToPointer(l.nodeObject, (void**)&l.nodep);
  if (EVEN(sts)) {
    errh_Fatal("No node object found\n%m", sts);
    exit(sts);
  }
  sts = gdh_ObjidToName(
      l.nodeObject, l.nodeName, sizeof(l.nodeName), cdh_mNName);
  if (EVEN(sts)) {
    errh_Info("Could not find node object, %m", sts);
    exit(sts);
  }
}

static mh_eAgent getAgent(sSupActive* sap)
{
  pwr_tStatus sts;
  pwr_tClassId cid;
  pwr_tObjid Parent = sap->link.supObject.Objid;

  while (TRUE) {
    sts = gdh_GetParent(Parent, &Parent);
    if (sts == GDH__NO_PARENT) {
      return mh_eAgent_MH;
    } else if (EVEN(sts)) {
      errh_Error("%s\n%m", "Error getting parent of SupObject.", sts);
      return mh_eAgent_None;
    } else if (cdh_ObjidIsEqual(Parent, pwr_cNObjid)) {
      return mh_eAgent_MH;
    }
    sts = gdh_GetObjectClass(Parent, &cid);
    if (EVEN(sts)) {
      errh_Error("%s\n%m", "Error getting class of SupObject parent.", sts);
      return mh_eAgent_None;
    }
    if (cid == pwr_cClass_Av || cid == pwr_cClass_Dv) {
      return mh_eAgent_MH;
    } else if (cid == pwr_cClass_Ai || cid == pwr_cClass_Ao
        || cid == pwr_cClass_Co || cid == pwr_cClass_Di || cid == pwr_cClass_Do
        || cid == pwr_cClass_Po) {
      return mh_eAgent_IO;
    } else if (cid == pwr_cClass_plc) {
      return mh_eAgent_Plc;
    }
  }
}

static void handleAlarm(sSupActive* sp)
{
  sEvent* ep;

  ep = eventListInsert(sp->sup->EventType, NULL, (sActive*)sp);
  activeListInsert((sActive*)sp, ep, mh_eSource_Scanner);
  updateAlarm((sActive*)sp, ep);

  eventToOutunits(ep);
}

static void handleInfo(sSupActive* sp)
{
  sEvent* ep;

  if (sp->link.eventFlags & mh_mEventFlags_InfoWindow) {
    sp->link.eventFlags |= mh_mEventFlags_Ack;
    sp->link.eventFlags |= mh_mEventFlags_Return;
  }

  ep = eventListInsert(sp->link.eventType, NULL, (sActive*)sp);
  if (sp->link.eventFlags & mh_mEventFlags_InfoWindow) {
    activeListInsert((sActive*)sp, ep, mh_eSource_Scanner);
    updateAlarm((sActive*)sp, ep);
  }

  eventToOutunits(ep);
}

static void handleMessage(qcom_sGet* get)
{
  pwr_tStatus sts;
  mh_sHead* hp;
  XDR xdrs;

  switch ((int)get->type.b) {
  case mh_cMsgClass:
    hp = (mh_sHead*)get->data;
    if (hp->xdr) {
      int type = ntohl(hp->type);
      int source = ntohl(hp->source);

      xdrmem_create(&xdrs, (char*)hp, get->size, XDR_DECODE);
      sts = mh_NetXdrMessage(&xdrs, get->type.s, hp);
      if (EVEN(sts)) {
        errh_Error("XDR_DECODE. Type = %d,%d, Size = %d, Source = %d, Nix = "
                   "%x, pid = %x",
            type, get->type.s, get->size, source, get->sender.nid,
            (int)get->sender.aix);
      }
    }
    fromMessageUnit(get);
    break;
  case qcom_eBtype_qcom:
    fromQcom(get);
    break;
  case qcom_eBtype_event:
    fromEvent(get);
    break;
  default:
    errh_Info("handleMessage, unexpected message type, type: %d", get->type.b);
    break;
  }
}

static void handleReturn(sSupActive* sp)
{
  sEvent* ep = NULL;

  switch (sp->link.event) {
  case mh_eEvent_Alarm:
  case mh_eEvent_MaintenanceAlarm:
  case mh_eEvent_SystemAlarm:
  case mh_eEvent_UserAlarm1:
  case mh_eEvent_UserAlarm2:
  case mh_eEvent_UserAlarm3:
  case mh_eEvent_UserAlarm4:
    ep = eventListInsert(mh_eEvent_Return, NULL, (sActive*)sp);
    updateAlarm((sActive*)sp, ep);
    break;
  case mh_eEvent_Info:
  case mh_eEvent_InfoSuccess:
    if (sp->link.eventFlags & mh_mEventFlags_InfoWindow) {
      ep = eventListInsert(mh_eEvent_Return, NULL, (sActive*)sp);
      updateAlarm((sActive*)sp, ep);
    } else {
      if (sp->link.eventFlags & mh_mEventFlags_Return)
        ep = eventListInsert(mh_eEvent_Return, NULL, (sActive*)sp);
      sp->sup->DetectCheck = TRUE; /* Activate detection */
      sp->sup->AlarmCheck = TRUE; /* Activate alarm supervision */
    }
    break;
  default:
    errh_Info(
        "return: Return on unknown event type, event: %d", sp->link.event);
    break;
  }

  eventToOutunits(ep);
}

static void handlerEvent(
    pwr_eSystemEventTypeEnum event, pwr_tNodeIndex nix, int status)
{
  mh_sApplMessage* ip;
  sApplActive* hp = NULL;
  sEvent* ep = NULL;
  pwr_tBoolean local = FALSE;
  pwr_sClass_SystemSup* ssup;
  pwr_tOName attr;
  pwr_tAttrRef aref;
  sNodeInfo* node = node_get(nix);

  if (event
      >= (int)sizeof(l.emon->SystemEvents) / sizeof(l.emon->SystemEvents[0]))
    return;

  ssup = &l.emon->SystemEvents[event];
  if (!node)
    return;
  if (!ssup->DetectOn)
    return;

  if (status == 1) {
    // Alarm or info event
    switch (ssup->EventType) {
    case mh_eEvent_Alarm:
    case mh_eEvent_MaintenanceAlarm:
    case mh_eEvent_SystemAlarm:
    case mh_eEvent_UserAlarm1:
    case mh_eEvent_UserAlarm2:
    case mh_eEvent_UserAlarm3:
    case mh_eEvent_UserAlarm4:
    case mh_eEvent_Info:
    case mh_eEvent_InfoSuccess:
      hp = handlerListAlloc(event);
      break;
    case mh_eEvent_Return:
      break;
    default:
      errh_Info(
          "handlerEvent, unexpected event type, event: %d", ssup->EventType);
      return;
    }
  } else {
    // Return event
    hp = (sApplActive*)activeListGet(node->handlerEventIdx[event]);
  }
  if (!hp)
    return;

  if (status == 1) {
    switch (ssup->EventType) {
    case mh_eEvent_Alarm:
    case mh_eEvent_MaintenanceAlarm:
    case mh_eEvent_SystemAlarm:
    case mh_eEvent_UserAlarm1:
    case mh_eEvent_UserAlarm2:
    case mh_eEvent_UserAlarm3:
    case mh_eEvent_UserAlarm4:
    case mh_eEvent_Info:
    case mh_eEvent_InfoSuccess:

      ip = &hp->message;
      ip->EventFlags = ssup->EventFlags;
      ip->EventPrio = ssup->EventPriority;
      time_GetTime(&ip->EventTime);
      ip->EventType = ssup->EventType;
      strncpy(ip->EventText, ssup->DetectText, sizeof(ip->EventText) - 1);
      strncat(ip->EventText, " ", sizeof(ip->EventText) - 1);
      strncat(ip->EventText, node->name, sizeof(ip->EventText) - 1);
      ip->EventSound = ssup->Sound;
      strncpy(ip->EventMoreText, ssup->MoreText, sizeof(ip->EventMoreText));
      ip->SupObject = l.emonObject;

      switch (event) {
      case pwr_eSystemEventTypeEnum_NodeUp:
      case pwr_eSystemEventTypeEnum_EmergBreakReboot:
      case pwr_eSystemEventTypeEnum_EmergBreakFixedOutput:
      case pwr_eSystemEventTypeEnum_EmergBreakStopIO:
      case pwr_eSystemEventTypeEnum_SystemStatusError:
      case pwr_eSystemEventTypeEnum_SystemStatusWarning:
        ip->Object = l.nodeObject;
        strncpy(ip->EventName, l.nodeName, sizeof(ip->EventName) - 1);
        break;
      case pwr_eSystemEventTypeEnum_IOErrorSoftLimit:
      case pwr_eSystemEventTypeEnum_IOErrorHardLimit:
        ip->Object = l.iohObject;
        strncpy(ip->EventName, l.iohName, sizeof(ip->EventName) - 1);
        break;
      default:
        ip->Object = l.emonObject;
        strncpy(ip->EventName, l.emonName, sizeof(ip->EventName) - 1);
      }

      hp->link.local = local;
      hp->link.source = mh_eSource_Handler;
      hp->link.object = cdh_ObjidToAref(ip->Object);
      strncpy(hp->link.objName, ip->EventName, sizeof(hp->link.objName));
      str_ToUpper(hp->link.objName, NULL);
      strncpy(hp->link.eventName, ip->EventName, sizeof(hp->link.eventName));
      hp->link.eventFlags = ip->EventFlags;
      hp->link.event = ip->EventType;
      hp->link.eventSound = ip->EventSound;
      strncpy(hp->link.eventMoreText, ip->EventMoreText,
          sizeof(hp->link.eventMoreText));
      strncpy(hp->link.receiver, ssup->Recipient, sizeof(hp->link.receiver));
      sprintf(attr, "SystemEvents[%d]", event);
      aref = cdh_ObjidToAref(l.emonObject);
      gdh_ArefANameToAref(&aref, attr, &hp->link.supObject);

      /* Insert in application alarm list */
      LstInsert(&node->appl.active_l, &hp->active_l);
      hp->ap = (sAppl*)&node->appl;
      ++hp->ap->activeMessages;
      ep = eventListInsert(ssup->EventType, NULL, (sActive*)hp);
      activeListInsert((sActive*)hp, ep, mh_eSource_Handler);
      updateAlarm((sActive*)hp, ep);

      if (ssup->EventFlags & mh_mEventFlags_Return)
        node->handlerEventIdx[event] = hp->link.idx;
      else
        node->handlerEventIdx[event] = 0;
      ssup->DetectTime = ip->EventTime;

      break;
    default:;
    }
  } else {
    if ((hp->link.status.Event.Status & mh_mEventStatus_NotRet) == 0)
      return; /* already returned */

    time_GetTime(&hp->returnTime);
    hp->returnType = mh_eEvent_Return;
    if (!streq(ssup->ReturnText, "")) {
      strncpy(hp->returnText, ssup->ReturnText, sizeof(hp->returnText) - 1);
      strncat(hp->returnText, " ", sizeof(hp->returnText) - 1);
      strncat(hp->returnText, node->name, sizeof(hp->returnText) - 1);
    }
    ep = eventListInsert(mh_eEvent_Return, NULL, (sActive*)hp);
    updateAlarm((sActive*)hp, ep);

    ssup->ReturnTime = hp->returnTime;
  }

  eventToOutunits(ep);
}

static void handlerEvent_cb(int event, int status)
{
  handlerEvent(event, l.head.nix, status);
}

static sApplActive* handlerListAlloc(pwr_eSystemEventTypeEnum event)
{
  struct LstHead * hl;
  struct LstHead * ll;
  sApplActive* hp;
  const int Alloc = 50;
  int i;

  if (l.handlerListCount == l.emon->MaxSystemAlarms - 1
      && event != pwr_eSystemEventTypeEnum_SystemAlarmQuota) {
    handlerEvent(pwr_eSystemEventTypeEnum_SystemAlarmQuota, l.head.nix, 1);
    return NULL;
  }

  if (l.handlerListCount >= l.emon->MaxSystemAlarms)
    return NULL;

  ll = &l.handlerFree_l;

  if (LstEmpty(ll)) {
    hp = (sApplActive*)calloc(Alloc, sizeof(sApplActive));
    if (hp != NULL) {
      for (i = 0; i < Alloc; i++, hp++)
        LstInsert(ll, &hp->link.active_l);
      l.emon->AlarmMaxCount += Alloc;
    } else {
      return NULL;
    }
  }

  hl = ll->next;
  LstRemove(hl);
  LstNull(hl);
  --l.emon->AlarmMaxCount;
  l.handlerListCount++;

  return LstEntry(hl, sApplActive, link.active_l);
}

static void handlerListFree(sApplActive* hp)
{
  // return;
  memset(hp, 0, sizeof(*hp));
  LstInsert(&l.handlerFree_l, &hp->link.active_l);
  ++l.emon->AlarmMaxCount;
  l.handlerListCount--;
  return;
}

static void initBlockList()
{
  pwr_tStatus sts;
  pwr_tUInt32 blocks;
  char msg[80];
  sSaveBlock* sp;
  sBlock* bp;
  sEvent* ep;
  pwr_tUInt32 size;
  char hostspec[12];
  pwr_tNodeIndex nix;
  int i;

  char* env = getenv("pwrp_load");
  hostspec[0] = '\0'; /* Prevent warnings from gcc */

  sprintf(
      l.blockDbName, "%s/ld_bdb_%06x.dat", env != NULL ? env : "", l.head.nix);

  l.blockDb = mh_BlockDbOpen(l.blockDbName, &size);
  if (l.blockDb == NULL)
    return;

  if (size == 0)
    return;

  l.blockSaveSize = MAX(size, 100 * sizeof(sSaveBlock));
  l.blockSave = calloc(1, l.blockSaveSize);
  if (l.blockSave == NULL) {
    errh_Error("InitBlockList, %m", MH__NOSPACE);
    exit(MH__NOSPACE);
  }
  l.blockDb = mh_BlockDbGet(l.blockDb, &size, (char*)l.blockSave);
  if (l.blockDb == NULL)
    return;
  blocks = size / sizeof(sSaveBlock);
  sprintf(msg, "found %d blocks in blockdb", blocks);
  errh_Info(msg);

  for (i = 0, sp = l.blockSave; i < blocks; i++, sp++) {
    sts = gdh_GetObjectNodeIndex(sp->outunitBlock.object, &nix);
    if (EVEN(sts) || nix != l.head.nix) {
      errh_Error("%s\n%m", "InitBlockList, object not owned or known", sts);
      continue;
    }

    bp = blockListAlloc();
    if (bp == NULL) {
      errh_Error("InitBlockList, %m", MH__NOSPACE);
      exit(MH__NOSPACE);
    }
    bp->link.event = mh_eEvent_Block;
    bp->link.eventFlags = mh_mEventFlags_Force;
    bp->link.source = mh_eSource_Outunit;
    bp->link.object = cdh_ObjidToAref(sp->outunitBlock.object);
    sts = gdh_ObjidToName(sp->outunitBlock.object, bp->link.objName,
        sizeof(bp->link.objName), cdh_mNName);
    if (EVEN(sts)) {
      errh_Error("%s\n%m", "InitBlockList, couldn't block object", sts);
      blockListFree(bp);
      continue;
    }
    strncpy(bp->link.eventName, bp->link.objName, sizeof(bp->link.eventName));
    str_ToUpper(bp->link.objName, NULL);
    bp->outunitBlock = sp->outunitBlock;
    bp->targetId = sp->targetId;
    bp->link.status.Event.Prio = (pwr_tUInt8)sp->outunitBlock.prio;
    bp->link.status.Event.Status = mh_mEventStatus_Block;
    sts = gdh_SetAlarmBlockLevel(sp->outunitBlock.object, bp->link.status.All);
    ep = eventListInsert(bp->link.event, NULL, (sActive*)bp);
    activeListInsert((sActive*)bp, ep, mh_eSource_Outunit);
  }
}

/* Initialize the node database.  */

static void initNodeDb()
{
  int i;

  pwr_tStatus sts;
  sNodeInfo* np;
  qcom_sNode qnode;

  // return;

  memset(l.nodeDb, 0, sizeof(l.nodeDb));

  np = &l.nodeDb[0];
  np->occupied = 1;

  qcom_MyNode(&sts, &qnode);
  np->nid = qnode.nid;
  strncpy(np->name, qnode.name, sizeof(np->name));

  for (i = 0; i < cNodes; i++) {
    LstInit(&l.nodeDb[i].appl.active_l);
  }
}

/* Initialize a SupActiveCB record.  */

static pwr_tStatus initSupActiveCB(pwr_tAttrRef* SupObject, pwr_tClassId cid,
    sSupActive** spp, pwr_tBoolean Allocate, pwr_tBoolean NewAttribute)
{
  pwr_tStatus sts;
  sASup* asp = NULL;
  sDSup* dsp = NULL;
  sASupComp* ascompp = NULL;
  sDSupComp* dscompp = NULL;
  pwr_sClass_NodeLinkSup* nlsp = NULL;
  pwr_sClass_CycleSup* csp = NULL;
  pwr_tAttrRef Object = {{0, 0}, 0, 0, 0, {0}};
  sSupActive* sp;
  gdh_tDlid Dlid;
  pwr_tBoolean IsAlias = 0;

  sts = gdh_IsAlias(SupObject->Objid, &IsAlias);
  if (IsAlias)
    return 2;

  /* Get pointer to supervisory object */
  switch (cid) {
  case pwr_cClass_ASup:
    sts = gdh_DLRefObjectInfoAttrref(SupObject, (pwr_tAddress*)&asp, &Dlid);
    break;
  case pwr_cClass_DSup:
    sts = gdh_DLRefObjectInfoAttrref(SupObject, (pwr_tAddress*)&dsp, &Dlid);
    break;
  case pwr_cClass_ASupComp:
    sts = gdh_DLRefObjectInfoAttrref(SupObject, (pwr_tAddress*)&ascompp, &Dlid);
    break;
  case pwr_cClass_DSupComp:
    sts = gdh_DLRefObjectInfoAttrref(SupObject, (pwr_tAddress*)&dscompp, &Dlid);
    break;
  case pwr_cClass_NodeLinkSup:
    sts = gdh_DLRefObjectInfoAttrref(SupObject, (pwr_tAddress*)&nlsp, &Dlid);
    break;
  case pwr_cClass_CycleSup:
    sts = gdh_DLRefObjectInfoAttrref(SupObject, (pwr_tAddress*)&csp, &Dlid);
    break;
  default:
    return 2;
  }

  if (EVEN(sts)) {
    errh_Fatal("Couldn't get direct link to sup object\n%m", sts);
    return sts;
  }

  /* Get attrref of supervised object */

  switch (cid) {
  case pwr_cClass_ASup:
    Object = asp->Sup.Attribute;
    break;
  case pwr_cClass_DSup:
    Object = dsp->Sup.Attribute;
    break;
  case pwr_cClass_ASupComp:
    Object = ascompp->Sup.Attribute;
    break;
  case pwr_cClass_DSupComp:
    Object = dscompp->Sup.Attribute;
    break;
  case pwr_cClass_NodeLinkSup:
    Object = *SupObject;
    break;
  case pwr_cClass_CycleSup:
    Object = *SupObject;
    break;
  default:;
  }

  /* Allocate and initiate supervisor control block */
  if (Allocate) {
    sp = (sSupActive*)calloc(1, sizeof(sSupActive));
    if (sp == NULL) {
      errh_Error("Error calloc, InitSupActiveCB");
      return 1;
    }
  } else
    sp = *spp;

  sp->link.source = mh_eSource_Scanner;
  sp->link.object = Object;
  sp->link.supObject = *SupObject;
  sp->link.objName[0] = '\0';

  sts = gdh_AttrrefToName(
      &Object, sp->link.objName, sizeof(sp->link.objName), cdh_mNName);
  if (EVEN(sts))
    errh_Error("Couldn't get name for supervised object, %s\n%m",
        cdh_ObjidToString(SupObject->Objid, 0), sts);
  strncpy(sp->link.eventName, sp->link.objName, sizeof(sp->link.eventName));
  str_ToUpper(sp->link.objName, NULL);

  switch (cid) {
  case pwr_cClass_ASup:
    sp->supType = mh_eSupType_Analog;
    sp->supDlid = Dlid;
    sp->sup = &asp->Sup;
    sp->supInfoSize = sizeof(mh_sASupInfo);
    sp->supInfoP = &asp->Info;
    sp->attribute = asp->Sup.Attribute;
    sp->link.eventSound = asp->Sup.Sound;
    sp->timer = &asp->Timer;
    sp->op = (void*)asp;
    sp->agent = getAgent(sp);
    sp->cid = cid;
    if (sp->agent == mh_eAgent_MH)
      sp->detect_exec = aSup_exec;
    break;
  case pwr_cClass_DSup:
    sp->supType = mh_eSupType_Digital;
    sp->supDlid = Dlid;
    sp->sup = &dsp->Sup;
    sp->supInfoSize = sizeof(mh_sDSupInfo);
    sp->supInfoP = &dsp->Info;
    sp->attribute = dsp->Sup.Attribute;
    sp->link.eventSound = dsp->Sup.Sound;
    sp->timer = &dsp->Timer;
    sp->op = (void*)dsp;
    sp->agent = getAgent(sp);
    sp->cid = cid;
    if (sp->agent == mh_eAgent_MH)
      sp->detect_exec = dSup_exec;
    break;
  case pwr_cClass_ASupComp:
    sp->supType = mh_eSupType_Analog;
    sp->supDlid = Dlid;
    sp->sup = &ascompp->Sup;
    sp->supInfoSize = sizeof(mh_sASupInfo);
    sp->supInfoP = &ascompp->Info;
    sp->attribute = ascompp->Sup.Attribute;
    sp->link.eventSound = ascompp->Sup.Sound;
    sp->timer = &ascompp->Timer;
    sp->op = (void*)ascompp;
    sp->agent = getAgent(sp);
    sp->cid = cid;
    break;
  case pwr_cClass_DSupComp:
    sp->supType = mh_eSupType_Digital;
    sp->supDlid = Dlid;
    sp->sup = &dscompp->Sup;
    sp->supInfoSize = sizeof(mh_sDSupInfo);
    sp->supInfoP = &dscompp->Info;
    sp->attribute = dscompp->Sup.Attribute;
    sp->link.eventSound = dscompp->Sup.Sound;
    sp->timer = &dscompp->Timer;
    sp->op = (void*)dscompp;
    sp->agent = getAgent(sp);
    sp->cid = cid;
    break;
  case pwr_cClass_NodeLinkSup:
    sp->supType = mh_eSupType_Link;
    sp->supDlid = Dlid;
    sp->sup = (sSup*)&nlsp->ControlP;
    sp->supInfoSize = 0;
    sp->supInfoP = NULL;
    sp->link.eventSound = nlsp->Sound;
    sp->attribute = Object;
    sp->attribute.Offset = pwr_Offset(nlsp, LinkUp);
    sp->attribute.Size = sizeof(nlsp->LinkUp);
    sp->attribute.Flags.m = 0;
    nlsp->Attribute = sp->attribute;
    sp->timer = (sTimer*)&nlsp->TimerFlag;
    sp->op = (void*)nlsp;
    sp->agent = mh_eAgent_None;
    sp->cid = cid;
    break;
  case pwr_cClass_CycleSup:
    sp->supType = mh_eSupType_Cycle;
    sp->supDlid = Dlid;
    sp->sup = (sSup*)&csp->ControlP;
    sp->supInfoSize = 0;
    sp->supInfoP = NULL;
    sp->link.eventSound = csp->Sound;
    sp->attribute = Object;
    sp->attribute.Offset = pwr_Offset(csp, DelayLimit);
    sp->attribute.Size = sizeof(csp->DelayLimit);
    sp->attribute.Flags.m = 0;
    csp->Attribute = sp->attribute;
    sp->timer = (sTimer*)&csp->TimerFlag;
    sp->op = (void*)csp;
    sp->agent = mh_eAgent_MH;
    sp->detect_exec = cSup_exec;
    sp->cid = cid;
    break;
  default:
    errh_Error("initSupActiveCB, program error, cid: %u", cid);
    break;
  }

  sp->link.eventFlags = sp->sup->EventFlags;
  sp->link.eventType = sp->sup->EventType;
  sp->link.event = sp->sup->EventType;

  if (sp->agent == mh_eAgent_MH) {
    sts = gdh_DLRefObjectInfoAttrref(
        &sp->attribute, (pwr_tAddress*)&sp->actualValue, &sp->attrDlid);
    if (EVEN(sts)) {
      errh_Error("%s, %s\n%m", "Couldn't link to supervised attribute",
          cdh_ObjidToString(SupObject->Objid, 0), sts);
      sp->agent = mh_eAgent_None;
    }
  }

  /* Initiate flags to make detection possible by PLC */

  if (NewAttribute) {
    sp->sup->AlarmCheck = FALSE;
    sp->sup->ReturnSend = FALSE;
    sp->sup->ReturnCheck = FALSE;
    sp->sup->DetectSend = FALSE;
    sp->sup->Acked = TRUE;
    sp->sup->DetectCheck = TRUE;
    sp->sup->AlarmCheck = TRUE;
    sp->sup->AlarmStatus.All = 0;
  }

  *spp = sp;
  return sts;
}

/* Initialize the Supervisor list.  */

static pwr_tStatus initSupList()
{
  pwr_tStatus sts;

  /* Get class list and loop trough Sup objects */

  sts = initSupListClass(pwr_cClass_ASup);
  if (EVEN(sts))
    errh_Error("Initiate list of ASup's\n%m", sts);

  sts = initSupListClass(pwr_cClass_DSup);
  if (EVEN(sts))
    errh_Error("Initialize list of DSup's\n%m", sts);

  sts = initSupListClass(pwr_cClass_ASupComp);
  if (EVEN(sts))
    errh_Error("Initiate list of ASupComp's\n%m", sts);

  sts = initSupListClass(pwr_cClass_DSupComp);
  if (EVEN(sts))
    errh_Error("Initialize list of DSupComp's\n%m", sts);

  sts = initSupListClass(pwr_cClass_NodeLinkSup);
  if (EVEN(sts))
    errh_Error("Initialize list of LinkSup's\n%m", sts);

  sts = initSupListClass(pwr_cClass_CycleSup);
  if (EVEN(sts))
    errh_Error("Initialize list of CycleSup's\n%m", sts);

  if (LstEmpty(&l.sup_l))
    errh_Info("No sup objects");

  return (sts);
}

static pwr_tStatus initSupListClass(pwr_tClassId cid)
{
  pwr_tStatus sts;
  struct LstHead * sl;
  struct LstHead * dl;
  sSupActive* sp;
  pwr_tAttrRef aref;

  sl = &l.sup_l;
  dl = &l.detect_l;

  /* Loop trough objects in class list.  */

  for (sts = gdh_GetClassListAttrRef(cid, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(cid, &aref, &aref)) {
    if (aref.Objid.vid < cdh_cUserVolMin)
      continue;

    sts = initSupActiveCB(&aref, cid, &sp, 1, 1);
    if (ODD(sts)) {
      LstInsert(sl, &sp->sup_l);
      sl = &sp->sup_l;
      l.emon->BlockMaxCount++;
      if (sp->agent == mh_eAgent_MH) {
        LstInsert(dl, &sp->detect_l);
        dl = &sp->detect_l;
        l.emon->EventFirstIdx++;
      }
    }
  }

  if (sts == GDH__NO_TYPE || sts == GDH__NOSUCHOBJ)
    sts = MH__SUCCESS;

  return (sts);
}

static pwr_tBoolean isForOutunit(sOutunit* op, pwr_tObjid outunit,
    pwr_tObjid object, pwr_tString80 objName, mh_mEventFlags eventFlags,
    pwr_eEventTypeEnum eventType, pwr_tBoolean local)
{
  int i;

  if (op->selGen == 0)
    return FALSE;

  if (op->type == mh_eOutunitType_Logger)
    return TRUE; /* Logger gets all events */

  if (local)
    if (op->link.nix != l.head.nix)
      return FALSE;

  if (cdh_ObjidIsEqual(outunit, op->outunit))
    return TRUE; /* Send message dedicated for this Outunit */
  else if (cdh_ObjidIsNotEqual(outunit, pwr_cNObjid))
    return FALSE; /* This message is dedicated to other Outunit */

  if ((eventFlags & mh_mEventFlags_Force) != 0)
    return TRUE; /* Send forced message */

  if (cdh_ObjidIsEqual(object, pwr_cNObjid))
    return TRUE; /* Send message not associated with object */

  /* Check select list */
  if (op->selEventType == 0 || op->selEventType & eventType) {
    for (i = 0; i < op->selSize; i++)
      if (strncmp(op->sel_l[i].objName, objName, op->sel_l[i].len) == 0)
        return TRUE;
  }
  return FALSE;
}

static pwr_tBoolean isValidApplication(
    mh_sHead* hp, qcom_sAid* aid, sAppl** appl, mh_uApplReply* Reply)
{
  sAppl* ap;
  struct LstHead * al;

  if (!(hp->ver == mh_cVersion
          || (mh_cVersion == 5
                 && (hp->ver == 4
                        || hp->ver
                            == 3)))) { /* V5 is compatible with V3 and V4 */
    /* Different versions, not yet implemented */
    errh_Info("isValidApplication: Received a Message with different version");
    Reply->Sts = MH__VERSION;
    return FALSE;
  }

  /* Find outunit in outunit list */

  LstForEach(al, &l.appl_l)
    if (cdh_ObjidIsEqual(LstEntry(al, sAppl, appl_l)->aid, hp->aid))
      break;

  if (al == &l.appl_l) {
    /* Application not known, make it known */
    ap = (sAppl*)calloc(1, sizeof(*ap));
    if (ap == NULL) {
      errh_Error("applConnect, error calloc\n%m", MH__NOSPACE);
      Reply->Sts = MH__NOSPACE;
      return FALSE;
    }
    ap->link.source = mh_eSource_Application;
    ap->link.qid = hp->qid;
    ap->link.aid = *aid; /* QCOM ApplId */
    ap->link.platform = hp->platform;
    ap->birthTime = net_NetTimeToTime(&hp->birthTime);
    ap->aid = hp->aid;
    ap->state = mh_eApplState_New;
    /* Insert in application list */
    LstInsert(&l.appl_l, &ap->appl_l);
    /* Insert in process list */
    LstInsert(&l.proc_l, &ap->link.proc_l);
    LstInit(&ap->active_l); /* Init application alarm list */
  } else {
    ap = LstEntry(al, sAppl, appl_l);

    if (ap->birthTime.tv_sec != hp->birthTime.tv_sec) {
      /* Different times, i.e. the application is restarted */
      ap->link.source = mh_eSource_Application;
      ap->link.qid = hp->qid;
      ap->link.aid = *aid; /* QCOM ApplId */
      ap->link.platform = hp->platform;
      ap->birthTime = net_NetTimeToTime(&hp->birthTime);
      ap->aid = hp->aid;
      ap->state = mh_eApplState_Restarted;
    }
  }

  applLogState(ap);
  *appl = ap;
  Reply->Sts = MH__SUCCESS;
  return TRUE;
}

static pwr_tBoolean isValidOutunit(
    mh_sHead* hp, qcom_sAid* aid, sOutunit** outunit)
{
  sOutunit* op;
  struct LstHead * ol;

  if (!(hp->ver == mh_cVersion
          || (mh_cVersion == 5
                 && (hp->ver == 4
                        || hp->ver
                            == 3)))) { /* V5 is compatible with V3 and V4 */
    /* Different versions, not yet implemented */
    errh_Info("isValidOutunit: Received a Message with different version");
    return FALSE;
  }

  /* Find outunit in outunit list */

  LstForEach(ol, &l.outunit_l)
    if (cdh_ObjidIsEqual(LstEntry(ol, sOutunit, outunit_l)->outunit, hp->outunit))
      break;

  if (ol == &l.outunit_l) {
    /* Outunit not known, make it known */
    op = (sOutunit*)calloc(1, sizeof(*op));
    if (op == NULL) {
      errh_Error("Error calloc, OutUnitHello");
      return 1;
    }
    op->link.source = mh_eSource_Outunit;
    op->link.qid = hp->qid;
    op->link.aid = *aid; /* QCOM ApplId */
    op->link.platform = hp->platform;
    op->link.nix = hp->nix;
    op->birthTime = net_NetTimeToTime(&hp->birthTime);
    op->ver = hp->ver;
    op->outunit = hp->outunit;
    /* Insert in outunit list */
    LstInsert(&l.outunit_l, &op->outunit_l);
    /* Insert in process list */
    LstInsert(&l.proc_l, &op->link.proc_l);
    op->linkUp = TRUE;
    outunitLog(op, "New outunit");
  } else {
    op = LstEntry(ol, sOutunit, outunit_l);

    if (op->birthTime.tv_sec != hp->birthTime.tv_sec) {
      if (hp->type == mh_eMsg_OutunitInfo) {
        // sendToOutunit(op, mh_eMsg_OutunitClear, 0, 0, NULL, 0);
        if (hp->nix == l.head.nix)
          handlerEvent(pwr_eSystemEventTypeEnum_OutunitRestart, hp->nix, 1);

        // return FALSE;

        /* Different times, i.e. the outunit is restarted */
        op->link.source = mh_eSource_Outunit;
        op->link.qid = hp->qid;
        op->link.aid = *aid; /* QCOM ApplId */
        op->link.platform = hp->platform;
        op->link.nix = hp->nix;
        op->birthTime = net_NetTimeToTime(&hp->birthTime);
        op->outunit = hp->outunit;
        op->selGen = 0;
        op->eventGen = 0;
        op->linkUp = TRUE;
        outunitLog(op, "Outunit restarted");
      } else
        return FALSE;
    }
  }

  *outunit = op;
  return TRUE;
}

static void linkActive(qcom_sGet* msg)
{
  qcom_sNode* node = (qcom_sNode*)msg->data;

  if (node->connection != qcom_eNodeConnectionFull)
    return;

  errh_Info("Active, link to node %s (%s)", node->name,
      cdh_NodeIdToString(NULL, node->nid, 0, 0));
}

static void linkConnect(qcom_sGet* msg)
{
  pwr_tStatus sts;
  struct LstHead * ol;
  qcom_sNode* qnode = (qcom_sNode*)msg->data;
  int nix = qnode->nid;

  if (qnode->connection != qcom_eNodeConnectionFull)
    return;

  errh_Info("Connected, link to node %s (%s)", qnode->name,
      cdh_NodeIdToString(NULL, qnode->nid, 0, 0));
  handlerEvent(pwr_eSystemEventTypeEnum_LinkDown, qnode->nid, 0);

  sNodeInfo* node = node_get(nix);
  if (!node)
    node = node_insert(nix);
  node->newLinkState = gdh_eLinkState_Up;
  node->check = TRUE;

  LstForEach(ol, &l.outunit_l)
    if (nix == LstEntry(ol, sOutunit, outunit_l)->link.qid.nid) {
      LstEntry(ol, sOutunit, outunit_l)->linkUp = TRUE;
    }

  sts = sendMessage(mh_eMsg_HandlerHello, NULL, NULL, NULL,
      0); /* Left to do !!! Send to specific node */
}

static void linkDisconnect(qcom_sGet* msg)
{
  struct LstHead * ol;
  qcom_sNode* qnode = (qcom_sNode*)msg->data;
  int nix = qnode->nid;

  if (qnode->connection != qcom_eNodeConnectionFull)
    return;

  errh_Info("Disconnected, link to node %s (%s)", qnode->name,
      cdh_NodeIdToString(NULL, qnode->nid, 0, 0));
  handlerEvent(pwr_eSystemEventTypeEnum_LinkDown, qnode->nid, 1);

  sNodeInfo* node = node_get(qnode->nid);
  if (node) {
    node->newLinkState = gdh_eLinkState_Down;
    node->check = TRUE;
  }

  LstForEach(ol, &l.outunit_l)
    if (nix == LstEntry(ol, sOutunit, outunit_l)->link.qid.nid) {
      LstEntry(ol, sOutunit, outunit_l)->linkUp = FALSE;
    }
}

static void linkStalled(qcom_sGet* msg)
{
  qcom_sNode* qnode = (qcom_sNode*)msg->data;

  if (qnode->connection != qcom_eNodeConnectionFull)
    return;

  errh_Info("Stalled, link to node %s (%s)", qnode->name,
      cdh_NodeIdToString(NULL, qnode->nid, 0, 0));
}

static void outunitAborted(sOutunit* op)
{
  outunitLog(op, "Outunit aborted");

  LstRemove(&op->outunit_l); /* Remove from outunit list */
  LstNull(&op->outunit_l);
  LstRemove(&op->link.proc_l); /* Remove from process link */
  LstNull(&op->link.proc_l);
  free(op); /* Free control block */
}

static void outunitAck(mh_sHead* hp, sOutunit* op)
{
  sActive* ap;
  mh_sOutunitAck* ip = (mh_sOutunitAck*)(hp + 1);
  sEvent* ep;
  sSupActive* sp;
  sApplActive* aap;

  op->ackGen = ip->ackGen;
  sendToOutunit(op, mh_eMsg_Sync, 0, 0, NULL, 0);

  if ((ap = activeListGet(ip->targetIdx)) == NULL) {
    /* Alarm does not exist */
    return;
  } else if ((ap->status.Event.Status & mh_mEventStatus_NotAck) == 0) {
    /* Alarm already acked */
    return;
  }

  timelog_ss(4, "emon, acked", ap->objName);

  switch (ap->source) {
  case mh_eSource_Scanner:
    sp = (sSupActive*)ap;
    sp->sup->AckOutunit = op->outunit; /* Update ack outunit in sup object */
    time_GetTime(&sp->sup->AckTime); /* Update ack time in sup object */
    break;
  case mh_eSource_Application:
  case mh_eSource_Handler:
    aap = (sApplActive*)ap;
    aap->ackOutunit = op->outunit;
    time_GetTime(&aap->ackTime);
    break;
  default:
    errh_Error("outunitAck, programming error, source: %d", ap->source);
    return;
  }

  ep = eventListInsert(mh_eEvent_Ack, NULL, ap);

  switch (ap->event) {
  case mh_eEvent_Alarm:
  case mh_eEvent_MaintenanceAlarm:
  case mh_eEvent_SystemAlarm:
  case mh_eEvent_UserAlarm1:
  case mh_eEvent_UserAlarm2:
  case mh_eEvent_UserAlarm3:
  case mh_eEvent_UserAlarm4:
    updateAlarm(ap, ep);
    break;
  case mh_eEvent_Info:
  case mh_eEvent_InfoSuccess:
    if ((ap->eventFlags & mh_mEventFlags_InfoWindow) != 0)
      updateAlarm(ap, ep);
    break;
  default:
    errh_Info("outunitAck, Ack on unknown event type, event: %d", ap->event);
    break;
  }

  eventToOutunits(ep);
}

static void outunitBlock(mh_sHead* hp, sOutunit* op)
{
  pwr_tStatus sts;
  sBlock* bp = NULL;
  mh_sOutunitBlock* ip = (mh_sOutunitBlock*)(hp + 1);
  sEvent* ep;
  struct LstHead * bl;
  pwr_tNodeIndex nix;

  op->blockGen = ip->blockGen;
  sendToOutunit(op, mh_eMsg_Sync, 0, 0, NULL, 0);

  LstForEach(bl, &l.block_l)
    if (cdh_ObjidIsEqual(ip->object, LstEntry(bl, sBlock, block_l)->link.object.Objid))
      bp = LstEntry(bl, sBlock, block_l);

  if (bp == NULL) {
    sts = gdh_GetObjectNodeIndex(ip->object, &nix);
    if (EVEN(sts) || nix != l.head.nix) {
      errh_Error("%s\n%m", "OutunitBlock: object not owned by this node", sts);
      return;
    }
    if (ip->prio == 0) { /* object already unblocked */
      sts = gdh_SetAlarmBlockLevel(ip->object, 0);
      return; /* object already unblocked */
    }

    bp = blockListAlloc();
    if (bp == NULL) {
      errh_Error("%s\n%m", "OutunitBlock", MH__NOSPACE);
      return;
    }

    bp->link.event = mh_eEvent_Block;
    bp->link.eventType = bp->link.event;
    bp->link.eventFlags = mh_mEventFlags_Force;
    bp->link.source = mh_eSource_Outunit;
    bp->link.object = cdh_ObjidToAref(ip->object);
    sts = gdh_ObjidToName(
        ip->object, bp->link.objName, sizeof(bp->link.objName), cdh_mNName);
    if (EVEN(sts)) {
      errh_Error(
          "%s\n%m", "OutunitBlock: couldn't get name of blocked object", sts);
      blockListFree(bp);
      return;
    }
    strncpy(bp->link.eventName, bp->link.objName, sizeof(bp->link.eventName));
    str_ToUpper(bp->link.objName, NULL);
  } else if (bp->outunitBlock.prio != ip->prio) { /* new block level */
    if (bp->link.idx >= l.event_l->oldIdx) {
      /* Block message still in event list, update status */
      l.event_l->list[bp->link.idx % l.event_l->size].msg.block.Status = 0;
    }
    if (ip->prio == 0)
      bp->link.event = mh_eEvent_Unblock;
    else
      bp->link.event = mh_eEvent_Reblock;
  } else { /* object already have this block level */
    return;
  }

  l.newBlock = TRUE;

  switch (bp->link.event) {
  case mh_eEvent_Block:
    bp->outunitBlock = *ip;
    net_GetTime(&bp->outunitBlock.time); /* Update block time */
    bp->link.status.Event.Prio = (pwr_tUInt8)ip->prio;
    bp->link.status.Event.Status = mh_mEventStatus_Block;
    bp->targetId.Nix = l.head.nix;
    bp->targetId.BirthTime = l.head.birthTime;
    break;
  case mh_eEvent_Reblock:
    bp->outunitUnblock = bp->outunitBlock;
    bp->outunitBlock = *ip;
    net_GetTime(&bp->outunitBlock.time); /* Update block time */
    bp->link.status.Event.Prio = (pwr_tUInt8)ip->prio;
    bp->link.status.Event.Status = mh_mEventStatus_Block;
    break;
  case mh_eEvent_Unblock:
    bp->outunitUnblock = *ip;
    net_GetTime(&bp->outunitUnblock.time); /* Update unblock time */
    bp->link.status.All = 0;
    break;
  default:
    errh_Error("outunitBlock, program error (1), event: %d", bp->link.event);
    break;
  }

  sts = gdh_SetAlarmBlockLevel(ip->object, bp->link.status.All);
  ep = eventListInsert(bp->link.event, NULL, (sActive*)bp);
  switch (bp->link.event) {
  case mh_eEvent_Unblock:
    activeListRemove((sActive*)bp);
    blockListFree(bp);
    break;
  case mh_eEvent_Block:
    bp->targetId.Idx = bp->link.idx;
    activeListInsert((sActive*)bp, ep, mh_eSource_Outunit);
    break;
  case mh_eEvent_Reblock:
    bp->targetId.Idx = bp->link.idx;
    activeListRemove((sActive*)bp);
    activeListInsert((sActive*)bp, ep, mh_eSource_Outunit);
    break;
  default:
    errh_Error("outunitBlock, program error (2), event: %d", bp->link.event);
    break;
  }

  eventToOutunits(ep);
  saveBlockList();
}

static void outunitInfo(mh_sHead* hp, sOutunit* op)
{
  mh_sOutunitInfo* ip = (mh_sOutunitInfo*)(hp + 1);

  op->outunit = hp->outunit;
  op->type = ip->type;
  op->selEventType = ip->selEventType;
  if (op->selGen != ip->selGen) {
    op->selSize = MIN(ip->selSize, mh_cSelLSize);
    if (ip->selSize > 0)
      memcpy(&op->sel_l[0], ip + 1, op->selSize * sizeof(mh_sSelL));
    op->selGen = ip->selGen;
    op->eventGen++;
    op->maxIdx = op->syncedIdx = op->eventIdx = 0;
    op->check = 0;
  }

  sendToOutunit(op, mh_eMsg_Sync, 0, 0, NULL, 0);
  sendEventListToOutunit(op);
}

static void outunitDisconnect(mh_sHead* hp, sOutunit* op)
{
  outunitLog(op, "Outunit disconnected");

  LstRemove(&op->outunit_l); /* Remove from outunit list */
  LstNull(&op->outunit_l);
  LstRemove(&op->link.proc_l); /* Remove from process link */
  LstNull(&op->link.proc_l);
  free(op); /* Free control block */
}

static void outunitLog(sOutunit* op, char* text)
{
  errh_Info("%s (%s, qid: %s, oid: %s)", text, qcom_NodeName(op->link.qid.nid),
      qcom_QidToString(NULL, &op->link.qid, 1),
      cdh_ObjidToString(op->outunit, 0));
}

static void outunitSync(mh_sHead* hp, sOutunit* op)
{
  if (hp->eventGen != op->eventGen)
    return;

  // printf( "Sync: hp: %d opidx %d opsync %d\n", hp->eventIdx, op->eventIdx,
  // op->syncedIdx);

  if (op->eventIdx == op->syncedIdx)
    return;

  if (op->eventIdx == hp->eventIdx) {
    if (op->check) {
      op->check = 0;
    }
    op->syncedIdx = hp->eventIdx;
  }
  sendEventListToOutunit(op);
}

static void outunitAlarmReq(mh_sHead* hp, sOutunit* op)
{
  mh_sOutunitAlarmReq* msg = (mh_sOutunitAlarmReq*)(hp + 1);
  int i;
  struct LstHead * al;
  sActive* ap;
  int ok;

  /* Find events in active list */
  for (i = 0; i < msg->Count; i++) {
    LstForEach(al, &l.active_l) {
      ap = LstEntry(al, sActive, active_l);

      if (ap->idx == msg->Idx[i]) {
        if (!ap->detect_etp->ap)
          /* Not active any more, don't resend */
          break;

        ok = reSendEventToOutunit(op, ap->detect_etp);
        if (ok) {
          if (ap->idx > op->eventIdx)
            op->eventIdx
                = ap->idx; /* Message was sent, update last sent index */
          op->maxIdx = l.event_l->idx;
          op->check = 0;
        }
        break;
      }
    }
  }
  /* Avoid sync mismatch */
  op->syncedIdx = op->eventIdx;
}

static void procDown(qcom_sAid* aid)
{
  struct LstHead * pl;

  LstForEach(pl, &l.proc_l)
    if (LstEntry(pl, sProcLink, proc_l)->aid.nid == aid->nid && LstEntry(pl, sProcLink, proc_l)->aid.aix == aid->aix) {
      switch (LstEntry(pl, sProcLink, proc_l)->source) {
      case mh_eSource_Outunit:
        outunitAborted((sOutunit*)LstEntry(pl, sProcLink, proc_l));
        break;
      case mh_eSource_Application:
        break;
      default:
        errh_Error(
            "procDown, programming error, source: %d", LstEntry(pl, sProcLink, proc_l)->source);
        break;
      }
      return;
    }
}

#define SET_TIMEOUT                                                            \
  if (l.timerActive) {                                                         \
    tmo = l.timerTime * 1000.; /* Milli seconds */                             \
    time_GetTime(&curTime);                                                    \
    time_Aadd(&next_tmo, &curTime, &l.timerTimeDelta);                         \
  } else                                                                       \
    tmo = qcom_cTmoEternal;

static void receive(qcom_sQid myQ)
{
  pwr_tStatus sts;
  static char mp[2000];
  qcom_sGet get;
  int tmo;
  pwr_tTime curTime, next_tmo;
  pwr_tDeltaTime diff;

  SET_TIMEOUT

  while (1) {
    if (l.redu && l.nodep->RedundancyState == pwr_eRedundancyState_Passive) {
      if (l.supListState == eSupListState_Init) {
        initSupList();
        if (!LstEmpty(&l.sup_l))
          l.supListState = eSupListState_Scan;
        else
          l.supListState = eSupListState_NoSup;
      }

      sts = emon_redu_receive();

      /* Read other messages */
      while (ODD(sts)) {
        get.maxSize = sizeof(mp);
        get.data = mp;
        qcom_Get(&sts, &myQ, &get, 0);
        if (sts == QCOM__TMO || sts == QCOM__QEMPTY)
          break;
        if ((int)get.type.b == mh_cMsgClass)
          continue;
        handleMessage(&get);
      }
      pwrs_Node_Exec(handlerEvent_cb);
    } else {
      get.maxSize = sizeof(mp);
      get.data = mp;
      qcom_Get(&sts, &myQ, &get, tmo);
      if (sts == QCOM__TMO || sts == QCOM__QEMPTY) {
        timeOut();
        SET_TIMEOUT;

        if (l.redu && l.nodep->RedundancyState == pwr_eRedundancyState_Active)
          sts = emon_redu_send();

      } else if (EVEN(sts))
        errh_Error("Receive: qcom_Get, timout: %d\n%m", tmo, sts);
      else {
        handleMessage(&get);

        if (!l.timerActive) {
          tmo = qcom_cTmoEternal;
          continue;
        }

        time_GetTime(&curTime);
        if (time_Acomp(&curTime, &next_tmo) > 0) {
          timeOut();
          SET_TIMEOUT
        } else {
          time_Asub((pwr_tTime*)&diff, &next_tmo, (pwr_tDeltaTime*)&curTime);
          tmo = diff.tv_sec * 1000 + diff.tv_nsec / 1000000;
          /* Never wait more than l.timerTime */
          tmo = MIN(l.timerTime * 1000, tmo);
        }
      }
    }
    aproc_TimeStamp(((float)tmo) / 1000, 2);
  }
}

static void reInitSupList()
{
  pwr_tStatus sts;
  struct LstHead * sl;
  sSupActive* sp;
  sActive* ap;

  LstForEach(sl, &l.sup_l)
    LstEntry(sl, sSupActive, sup_l)->found = FALSE;

  sts = reInitSupListClass(pwr_cClass_ASup);
  if (EVEN(sts))
    errh_Error("Reinitialize list of ASup's\n%m", sts);

  sts = reInitSupListClass(pwr_cClass_DSup);
  if (EVEN(sts))
    errh_Error("Reinitialize list of DSup's\n%m", sts);

  sts = reInitSupListClass(pwr_cClass_NodeLinkSup);
  if (EVEN(sts))
    errh_Error("Reinitialize list of LinkSup's\n%m", sts);

  sts = reInitSupListClass(pwr_cClass_CycleSup);
  if (EVEN(sts))
    errh_Error("Reinitialize list of CycleSup's\n%m", sts);

  LstForEach(sl, &l.sup_l) {
    sp = LstEntry(sl, sSupActive, sup_l);
    if (!sp->found) {
      if ((ap = activeListGet(sp->link.idx)) != NULL)
        cancelAlarm(ap, cText_Restart);

      sl = sp->sup_l.prev;
      LstRemove(&sp->sup_l);
      LstNull(&sp->sup_l);
      l.emon->BlockMaxCount--;
      gdh_DLUnrefObjectInfo(sp->supDlid);
      if (sp->agent == mh_eAgent_MH) {
        gdh_DLUnrefObjectInfo(sp->attrDlid);
        if (!LstIsNull(&sp->timer_l)) {
          LstRemove(&sp->timer_l);
          LstNull(&sp->timer_l);
          l.emon->EventLastIdx--;
        }
        LstRemove(&sp->detect_l);
        LstNull(&sp->detect_l);
        l.emon->EventFirstIdx--;
      }
      free(sp);
    }
  }
}

static pwr_tStatus reInitSupListClass(pwr_tClassId cid)
{
  pwr_tStatus sts;
  struct LstHead * sl;
  struct LstHead * dl;
  sSupActive* sp;
  pwr_tAttrRef aref;

  dl = &l.detect_l;
  sl = &l.sup_l;

  /* Loop through objects in class list.  */

  for (sts = gdh_GetClassListAttrRef(cid, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(cid, &aref, &aref)) {
    if (aref.Objid.vid < cdh_cUserVolMin)
      continue;

    if ((sp = supListGet(&aref)) == NULL) {
      sts = initSupActiveCB(&aref, cid, &sp, 1, 1);
      if (ODD(sts)) {
        LstInsert(sl, &sp->sup_l);
        sl = &sp->sup_l;
        l.emon->BlockMaxCount++;
        sp->found = TRUE;
        if (sp->agent == mh_eAgent_MH) {
          LstInsert(dl, &sp->detect_l);
          dl = &sp->detect_l;
          l.emon->EventFirstIdx++;
        }
      }
    } else {
      updateSupActive(sp);
    }
  }

  if (sts == GDH__NO_TYPE || sts == GDH__NOSUCHOBJ)
    sts = MH__SUCCESS;

  return (sts);
}

static pwr_tBoolean reSendEventToOutunit(sOutunit* op, sEventTab* etp)
{
  pwr_tStatus sts;
  pwr_tUInt32 size;
  uEvent event;
  sSupActive* sp;
  sActive* ap = etp->ap;
  mh_mEventStatus Status;

  Status = 0;

  if (etp->ap == NULL) {
    errh_Error("reSendEventToOutunit: etp->ap == NULL");
    errh_Error("idx: %d, event: %d, ep: %d", etp->idx, etp->event, etp->ep);
    exit(2);
  }

  switch (ap->source) {
  case mh_eSource_Scanner:
    sp = (sSupActive*)ap;
    formatSupEvent(etp->event, NULL, (sSupActive*)ap, &event, &size);
    Status = sp->sup->AlarmStatus.All;
    break;
  case mh_eSource_Application:
  case mh_eSource_Handler:
    formatApplEvent(etp->event, NULL, (sApplActive*)ap, &event, &size);
    Status = ap->status.All;
    break;
  case mh_eSource_Outunit:
    formatOutunitEvent(etp->event, NULL, (sBlock*)ap, &event, &size);
    Status = ap->status.All;
    break;
  default:
    errh_Error("reSendEventToOutunit, programming error");
    errh_Error("ap: %d", ap);
    errh_Error("source %d", ap->source);
    errh_Error("idx: %d, event: %d, ep: %d", etp->idx, etp->event, etp->ep);
    return FALSE;
  }

  switch (event.message.Info.EventType) {
  case mh_eEvent_Alarm:
  case mh_eEvent_MaintenanceAlarm:
  case mh_eEvent_SystemAlarm:
  case mh_eEvent_UserAlarm1:
  case mh_eEvent_UserAlarm2:
  case mh_eEvent_UserAlarm3:
  case mh_eEvent_UserAlarm4:
  case mh_eEvent_Info:
  case mh_eEvent_InfoSuccess:
    event.message.Status = Status;
    break;
  default:
    break;
  }

  sts = sendToOutunit(op, mh_eMsg_Event, etp->event, 0, &event.message, size);

  return ODD(sts);
}

static void saveBlockList()
{
  unsigned long size;
  sSaveBlock* sp;
  struct LstHead * bl;
  sBlock* bp;

  if (l.blockDb == NULL)
    return;

  if (l.emon->BlockCount > l.blockSaveSize / sizeof(sSaveBlock)) {
    free(l.blockSave);
    l.blockSaveSize = 2 * l.emon->BlockCount;
    l.blockSave = calloc(l.blockSaveSize, sizeof(sSaveBlock));
    if (l.blockSave == NULL) {
      errh_Error("%s\n%m", "SaveBlockList", MH__NOSPACE);
      return;
    }
  }

  sp = l.blockSave;
  size = 0;
  LstForEach(bl, &l.block_l) {
    bp = LstEntry(bl, sBlock, block_l);
    sp->outunitBlock = bp->outunitBlock;
    sp->targetId = bp->targetId;
    sp++;
    size += sizeof(sSaveBlock);
  }

  l.blockDb = mh_BlockDbPut(l.blockDb, size, (char*)l.blockSave);
}

static void scanDetectList()
{
  struct LstHead * dl;

  LstForEach(dl, &l.detect_l) {
    sSupActive* sp = LstEntry(dl, sSupActive, detect_l);
    if (sp->detect_exec != NULL)
      sp->detect_exec(sp);
  }
}

static void scanSupList()
{
  pwr_tStatus sts;
  mh_uEventInfo AlarmVisibility;
  sSupActive* sp;
  struct LstHead * sl;

  LstForEach(sl, &l.sup_l) {
    sp = LstEntry(sl, sSupActive, sup_l);
    if (l.newBlock) {
      sts = gdh_GetAlarmInfo(
          sp->link.object.Objid, NULL, NULL, NULL, NULL, &AlarmVisibility.All);
      if (sp->alarmVisibility.All != AlarmVisibility.All) {
        if (sp->sup->EventPriority <= AlarmVisibility.Event.Prio) {
          sp->sup->Blocked = TRUE;
          if (sp->sup->AlarmStatus.Event.Status != 0) {
            cancelAlarm((sActive*)sp, cText_Block);
          }
        } else {
          sp->sup->Blocked = FALSE;
        }
        sp->alarmVisibility.All = AlarmVisibility.All;
      }
    }
    if (!sp->sup->Blocked) {
      if (sp->sup->DetectSend) {
        sp->sup->DetectSend = FALSE;
        sp->link.eventFlags = sp->sup->EventFlags;

        switch (sp->link.event) {
        case mh_eEvent_Info:
        case mh_eEvent_InfoSuccess:
          handleInfo(sp);
          break;
        case mh_eEvent_Alarm:
        case mh_eEvent_MaintenanceAlarm:
        case mh_eEvent_SystemAlarm:
        case mh_eEvent_UserAlarm1:
        case mh_eEvent_UserAlarm2:
        case mh_eEvent_UserAlarm3:
        case mh_eEvent_UserAlarm4:
        default:
          handleAlarm(sp);
          break;
        }
      } else if (sp->sup->ReturnSend) {
        sp->sup->ReturnSend = FALSE;
        handleReturn(sp);
      }
    }
  }
  l.newBlock = FALSE;
}

static void scanTimerList()
{
  struct LstHead * sl, *nsl;
  sTimer* tp;

  for (sl = l.timer_l.next; sl != &l.timer_l; sl = nsl) {
    tp = LstEntry(sl, sSupActive, timer_l)->timer;
    nsl = sl->next;
    if (tp->TimerCount <= 1 || !tp->TimerFlag) {
      tp->TimerCount = 0;
      tp->TimerFlag = FALSE;
      LstRemove(sl);
      LstNull(sl);
      l.emon->EventLastIdx--;
    } else {
      tp->TimerCount--;
    }
  }
}

static void sendEventListToOutunit(sOutunit* op)
{
  pwr_tStatus sts;
  sEvent* ep;
  sActive* ap;
  sEventTab* etp;
  pwr_tBoolean ok;

  if (op->maxIdx < l.event_l->oldIdx) {
    op->eventGen++;
    op->maxIdx = l.event_l->idx;
    op->syncedIdx = op->eventIdx = 0;
    op->check = 0;
  }

  /* !!! To do !!! If there is a big gap between last synced and
     next event, then we have to call a number of unnecessary
     isForOutunit.  */

  for (etp = tree_FindSuccessor(&sts, l.eventTab, &op->syncedIdx); etp != NULL;
       etp = tree_Successor(&sts, l.eventTab, etp)) {
    if (etp->ap && etp->ap->idx == 0) {
      /* Fix, this node should have been removed in activeListRemove ! */
      unsigned int idx = etp->idx;

      etp = tree_Successor(&sts, l.eventTab, etp);
      tree_Remove(&sts, l.eventTab, &idx);
      if (etp == NULL)
        break;
    }

    if ((ep = etp->ep) != NULL) {
      if (isForOutunit(op, ep->outunit, ep->object.Objid, ep->objName,
              ep->msg.info.EventFlags, ep->eventType, ep->local))
        break;
    } else if ((ap = etp->ap) != NULL) {
      if (isForOutunit(op, ap->outunit, ap->object.Objid, ap->objName,
              ap->eventFlags, ap->eventType, ap->local))
        break;
    } else {
      errh_Error("ap == NULL && ep == NULL");
    }
  }

  if (etp == NULL)
    return;

  if (op->lastSentIdx == etp->idx) {
    /* Wait before resending it */
    pwr_tTime current;
    pwr_tDeltaTime dt;
    float df;

    time_GetTime(&current);
    time_Adiff_NE(&dt, &current, &op->lastSentTime);
    df = time_DToFloat(0, &dt);
    if (df < 1)
      return;
  }

  if (etp->ep != NULL) {
    ok = sendEventToOutunit(op, etp);
  } else {
    ok = reSendEventToOutunit(op, etp);
  }

  if (ok) {
    op->eventIdx = etp->idx; /* Message was sent, update last sent index */
    op->maxIdx = l.event_l->idx;
    op->check = 0;
    op->lastSentIdx = etp->idx;
    time_GetTime(&op->lastSentTime);
  }
}

static pwr_tBoolean sendEventToOutunit(sOutunit* op, sEventTab* etp)
{
  pwr_tStatus sts;
  sEvent* ep = etp->ep;

  sts = sendToOutunit(
      op, mh_eMsg_Event, ep->msg.info.EventType, 0, &ep->msg, ep->msgSize);

  if (EVEN(sts)) {
    //    errh_Error("%s\n%m", "sendEventToOutunit", sts);
    return NO;
  }

  return YES;
}

static pwr_tStatus sendMessage(mh_eMsg type, qcom_sQid* qid,
    co_sPlatform* platform, void* msg, pwr_tUInt32 msgSize)
{
  pwr_tStatus sts;
  char* mp;
  mh_sHead* hp;
  unsigned int size = sizeof(l.head) + msgSize;
  qcom_sQid target;
  int prio = 0;

  mp = calloc(1, size);
  if (mp == NULL) {
    errh_Error("SendMessage: Error malloc");
    return MH__QCOMALLOCMSG;
  }

  memcpy(mp, &l.head, sizeof(l.head));
  hp = (mh_sHead*)mp;
  hp->type = type;
  hp->eventGen = 0;
  hp->eventIdx = 0;
  hp->ackGen = 0;
  hp->selGen = 0;

  memcpy(mp + sizeof(l.head), msg, msgSize);

  if (qid == NULL) {
    target = mh_cProcAllOutunits;
  } else {
    target = *qid;
  }

  sts = mh_NetSendMessage(&target, platform, prio, 0, 0, (mh_sHead*)mp, size);
  if (EVEN(sts) && sts != QCOM__LINKDOWN) {
    errh_Error("%s\n%m", "SendMessage: mh_NetSendMessage", sts);
  }

  free(mp);

  return sts;
}

static pwr_tStatus sendToOutunit(sOutunit* op, mh_eMsg type, int subType,
    unsigned int id, void* msg, int msgSize)
{
  pwr_tStatus sts;
  char* mp;
  mh_sHead* hp;
  unsigned int size = sizeof(l.head) + msgSize;
  int prio = 0;

  if (!op->linkUp)
    return QCOM__LINKDOWN;

  mp = malloc(size);
  if (mp == NULL) {
    errh_Error("SendMessage: Error malloc");
    return MH__QCOMALLOCMSG;
  }

  memcpy(mp, &l.head, sizeof(l.head));
  hp = (mh_sHead*)mp;

  memcpy(mp + sizeof(l.head), msg, msgSize);

  hp->type = type;
  hp->eventGen = op->eventGen;
  hp->eventIdx = op->eventIdx;
  hp->ackGen = op->ackGen;
  hp->blockGen = op->blockGen;
  hp->selGen = op->selGen;

  // printf( "sendToOutunit: eventIdx %d\n", hp->eventIdx);
  sts = mh_NetSendMessage(&op->link.qid, &op->link.platform, prio, subType, id,
      (mh_sHead*)mp, size);
  if (EVEN(sts) && sts != QCOM__LINKDOWN) {
    errh_Error("%s\n%m", "SendMessage: mh_NetSendMessage", sts);
  }

  free(mp);

  return sts;
}

static void setTimerActive(int timerIdx, pwr_tBoolean active)
{
  int i;

  l.timers[timerIdx].active = active;
  l.timers[timerIdx].count = 0;

  for (i = 0, l.timerActive = FALSE; i < cTimers; i++)
    l.timerActive |= l.timers[i].active;
}

/* This routine search suplist for a sup object.  */

static sSupActive* supListGet(pwr_tAttrRef* arp)
{
  struct LstHead * sl;

  LstForEach(sl, &l.sup_l) {
    sSupActive* sp = LstEntry(sl, sSupActive, sup_l);

    if (cdh_ArefIsEqual(&sp->link.supObject, arp))
      return sp;
  }

  return NULL;
}

static void timeOut()
{
  if (l.timers[cDetectIdx].active
      && ++l.timers[cDetectIdx].count >= l.timers[cDetectIdx].multiple) {
    l.timers[cDetectIdx].count = 0;
    if (l.supListState == eSupListState_Scan) {
      scanTimerList();
      scanDetectList();
    } else
      setTimerActive(cDetectIdx, FALSE);
  }

  if (l.timers[cMessageIdx].active
      && ++l.timers[cMessageIdx].count >= l.timers[cMessageIdx].multiple) {
    l.timers[cMessageIdx].count = 0;

    if (l.supListState == eSupListState_Scan) {
      scanSupList();
    } else if (l.supListState == eSupListState_Init) {
      if (qcom_EventMask(NULL, &qcom_cQini) & ini_mEvent_newPlcStartDone) {
        initSupList();
        if (!LstEmpty(&l.sup_l)) {
          l.supListState = eSupListState_Scan;
          if (!LstEmpty(&l.detect_l)) {
            scanTimerList();
            scanDetectList();
            setTimerActive(cDetectIdx, TRUE);
          }
          scanSupList();
        } else {
          l.supListState = eSupListState_NoSup;
          setTimerActive(cMessageIdx, FALSE);
        }
      }
    } else
      setTimerActive(cMessageIdx, FALSE);
  }

  if (l.timers[cBlockDbIdx].active
      && ++l.timers[cBlockDbIdx].count >= l.timers[cBlockDbIdx].multiple) {
    l.timers[cBlockDbIdx].count = 0;
    if (l.blockDb == NULL) {
      l.blockDb = mh_BlockDbOpen(l.blockDbName, NULL);
      if (l.blockDb != NULL)
        saveBlockList();
    }
  }

  if (l.timers[cOutunitIdx].active
      && ++l.timers[cOutunitIdx].count >= l.timers[cOutunitIdx].multiple) {
    l.timers[cOutunitIdx].count = 0;
    checkOutunits();
  }

  pwrs_Node_Exec(handlerEvent_cb);
  pwrb_IOHandler_Exec(handlerEvent_cb, 0);
}

static void timerIn(sSupActive* s, sTimer* t)
{
  t->TimerCount = t->TimerTime / l.detectTimerTime;
  if (!t->TimerFlag && t->TimerCount > 0) {
    if (LstIsNull(&s->timer_l)) {
      LstInsert(&l.timer_l, &s->timer_l);
      l.emon->EventLastIdx++;
    }
    t->TimerFlag = TRUE;
  }
}

static void updateAlarm(sActive* ap, sEvent* ep)
{
  sSupActive* sp;
  sApplActive* aap;

  sp = (sSupActive*)ap;
  aap = (sApplActive*)ap;

  switch (ep->event) {
  case mh_eEvent_Alarm:
  case mh_eEvent_MaintenanceAlarm:
  case mh_eEvent_SystemAlarm:
  case mh_eEvent_UserAlarm1:
  case mh_eEvent_UserAlarm2:
  case mh_eEvent_UserAlarm3:
  case mh_eEvent_UserAlarm4:
    ap->status.Event.Status = mh_mEventStatus_NotRet | mh_mEventStatus_NotAck;
    if (ap->source == mh_eSource_Scanner) {
      ap->status.Event.Prio = sp->sup->EventPriority;
      if (sp->sup->EventFlags & mh_mEventFlags_Returned)
        ap->status.Event.Status &= ~mh_mEventStatus_NotRet;
    } else {
      ap->status.Event.Prio = aap->message.EventPrio;
      if (aap->message.EventFlags & mh_mEventFlags_Returned)
        ap->status.Event.Status &= ~mh_mEventStatus_NotRet;
    }

    ep->msg.message.Status = ap->status.All;
    break;
  case mh_eEvent_Info:
  case mh_eEvent_InfoSuccess:
    ap->status.Event.Status = mh_mEventStatus_NotRet | mh_mEventStatus_NotAck;
    if (ap->source == mh_eSource_Scanner) {
      ap->status.Event.Prio = 0;
      if (sp->sup->EventFlags & mh_mEventFlags_Returned)
        ap->status.Event.Status &= ~mh_mEventStatus_NotRet;
    } else {
      ap->status.Event.Prio = 0;
      if (aap->message.EventFlags & mh_mEventFlags_Returned)
        ap->status.Event.Status &= ~mh_mEventStatus_NotRet;
    }
    ep->msg.message.Status = ap->status.All;
    break;
  case mh_eEvent_Ack:
    ap->status.Event.Status &= ~mh_mEventStatus_NotAck;
    if (ap->source == mh_eSource_Scanner)
      sp->sup->Acked = TRUE; /* Set Acked flag in sup object TRUE */
    if (ap->idx >= l.event_l->oldIdx) {
      /* Alarm message still in event list, update status */
      l.event_l->list[ap->idx % l.event_l->size].msg.message.Status
          = ap->status.All;
    }
    break;
  case mh_eEvent_Return:
    ap->status.Event.Status &= ~mh_mEventStatus_NotRet;
    if (ap->idx >= l.event_l->oldIdx) {
      /* Alarm message still in event list, update status */
      l.event_l->list[ap->idx % l.event_l->size].msg.message.Status
          = ap->status.All;
    }
    break;
  default:
    break;
  }

  if (((ap->status.Event.Status
           & (mh_mEventStatus_NotRet | mh_mEventStatus_NotAck))
          == 0)) { /* The alarm is acked and unactive, remove it from alarm list
                      */
    ap->status.All = 0;
    updateAlarmInfo(ap);
    if (ap->source == mh_eSource_Scanner) {
      sp->sup->DetectCheck = TRUE; /* Activate detection */
      sp->sup->AlarmCheck = TRUE; /* Activate alarm supervision */
      sp->sup->AlarmStatus.All = ap->status.All;
      if (sp->supType == mh_eSupType_Cycle) {
        pwr_sClass_CycleSup* cp = (pwr_sClass_CycleSup*)sp->op;
        cp->DelayNoted = FALSE;
        cp->Delayed = FALSE;
      }
    }
    activeListRemove(ap);
  } else {
    if (ap->source == mh_eSource_Scanner)
      sp->sup->AlarmStatus.All = ap->status.All;
    else
      aap->message.EventStatus = (mh_mEventStatus)ap->status.Event.Status;
    updateAlarmInfo(ap);
  }
}

static void updateAlarmInfo(sActive* iap)
{
  sActive* ap;
  struct LstHead * al;
  mh_uEventInfo maxAlarm;

  if (cdh_ObjidIsEqual(iap->object.Objid,
          pwr_cNObjid)) /* No object associated with this alarm */
    return;

  /* Search alarm list for ocurrence of object */
  maxAlarm.All = 0;
  LstForEach(al, &l.active_l) {
    ap = LstEntry(al, sActive, active_l);
    if (cdh_ArefIsEqual(&iap->object, &ap->object))
      if (ap->event == mh_eEvent_Alarm
          || ap->event == mh_eEvent_MaintenanceAlarm
          || ap->event == mh_eEvent_SystemAlarm
          || ap->event == mh_eEvent_UserAlarm1
          || ap->event == mh_eEvent_UserAlarm2
          || ap->event == mh_eEvent_UserAlarm3
          || ap->event == mh_eEvent_UserAlarm4)
        maxAlarm.All = MAX(maxAlarm.All, ap->status.All);
  }

  gdh_SetAlarmLevel(iap->object.Objid, maxAlarm.All);
}

static void updateSupActive(sSupActive* sp)
{
  pwr_tStatus sts = 0;
  sActive* ap;
  sASup* asp;
  sDSup* dsp;
  sASupComp* ascompp;
  sDSupComp* dscompp;
  sSup* sup = NULL;
  mh_eAgent agent;
  pwr_tClassId cid = 0;
  pwr_tBoolean newAttribute;
  struct LstHead* dl = &l.detect_l;

  /* Get pointer to supervisory object */

  if (sp->supType == mh_eSupType_Analog) {
    switch (sp->cid) {
    case pwr_cClass_ASup:
      sts = gdh_AttrRefToPointer(&sp->link.supObject, (pwr_tAddress*)&asp);
      sup = &asp->Sup;
      cid = sp->cid;
      break;
    case pwr_cClass_ASupComp:
      sts = gdh_AttrRefToPointer(&sp->link.supObject, (pwr_tAddress*)&ascompp);
      sup = &ascompp->Sup;
      cid = sp->cid;
      break;
    }
  } else if (sp->supType == mh_eSupType_Digital) {
    switch (sp->cid) {
    case pwr_cClass_DSup:
      sts = gdh_AttrRefToPointer(&sp->link.supObject, (pwr_tAddress*)&dsp);
      sup = &dsp->Sup;
      cid = sp->cid;
      break;
    case pwr_cClass_DSupComp:
      sts = gdh_AttrRefToPointer(&sp->link.supObject, (pwr_tAddress*)&dscompp);
      sup = &dscompp->Sup;
      cid = sp->cid;
      break;
    }
  } else if (sp->supType == mh_eSupType_Link) {
    return; /* Supervised attribute can't change. */
  } else if (sp->supType == mh_eSupType_Cycle) {
    return; /**to do**/
  }

  if (EVEN(sts)) {
    errh_Error("%s\n%m", "Couldn't get pointer to sup object", sts);
    return;
  }

  /* Compare attribute  */
  if (memcmp(&sup->Attribute, &sp->attribute, sizeof(sp->attribute)) == 0) {
    newAttribute = FALSE;
  } else {
    newAttribute = TRUE;
    if ((ap = activeListGet(sp->link.idx)) != NULL)
      cancelAlarm(ap, cText_Restart);
  }

  gdh_DLUnrefObjectInfo(sp->supDlid);
  if (sp->agent == mh_eAgent_MH)
    gdh_DLUnrefObjectInfo(sp->attrDlid);
  agent = sp->agent;
  initSupActiveCB(&sp->link.supObject, cid, &sp, 0, newAttribute);
  sp->found = TRUE;
  if (sp->agent != agent) {
    if (sp->agent == mh_eAgent_MH) {
      LstInsert(dl, &sp->detect_l);
      l.emon->EventFirstIdx++;
    } else {
      LstRemove(&sp->detect_l);
      LstNull(&sp->detect_l);
      l.emon->EventFirstIdx--;
      if (!LstIsNull(&sp->timer_l)) {
        LstRemove(&sp->timer_l);
        LstNull(&sp->timer_l);
        l.emon->EventLastIdx--;
      }
    }
  }
}

static void msgToV3(mh_eEvent type, uEvent* up)
{
  switch (type) {
  case mh_eEvent_Alarm:
  case mh_eEvent_Info:
  case mh_eEvent_InfoSuccess: {
    mh_sMessage* mp = &up->message;

    mp->Info.Object_V3 = mp->Object.Objid;
    mp->Info.SupObject_V3 = mp->SupObject.Objid;
    strncpy(
        mp->Info.EventName_V3, mp->EventName, sizeof(mp->Info.EventName_V3));
    mp->Info.EventName_V3[sizeof(mp->Info.EventName_V3) - 1] = 0;
    break;
  }
  case mh_eEvent_Ack: {
    mh_sAck* mp = &up->ack;

    mp->Info.Object_V3 = mp->Object.Objid;
    mp->Info.SupObject_V3 = mp->SupObject.Objid;
    strncpy(
        mp->Info.EventName_V3, mp->EventName, sizeof(mp->Info.EventName_V3));
    mp->Info.EventName_V3[sizeof(mp->Info.EventName_V3) - 1] = 0;
    break;
  }
  case mh_eEvent_Return:
  case mh_eEvent_Cancel: {
    mh_sReturn* mp = &up->ret;

    mp->Info.Object_V3 = mp->Object.Objid;
    mp->Info.SupObject_V3 = mp->SupObject.Objid;
    strncpy(
        mp->Info.EventName_V3, mp->EventName, sizeof(mp->Info.EventName_V3));
    mp->Info.EventName_V3[sizeof(mp->Info.EventName_V3) - 1] = 0;
    break;
  }
  default:;
  }
}

static sNodeInfo* node_get(pwr_tNid nid)
{
  int i;

  if (nid == 0)
    return &l.nodeDb[0];

  for (i = 0; i < cNodes; i++) {
    if (l.nodeDb[i].occupied && l.nodeDb[i].nid == nid)
      return &l.nodeDb[i];
  }
  return 0;
}

static sNodeInfo* node_insert(pwr_tNid nid)
{
  int i;
  qcom_sNode qnode;
  pwr_tStatus sts;

  for (i = 1; i < cNodes; i++) {
    if (!l.nodeDb[i].occupied) {
      qcom_Node(&sts, &qnode, nid);
      if (EVEN(sts))
        return 0;
      l.nodeDb[i].occupied = 1;
      l.nodeDb[i].nid = nid;
      strncpy(l.nodeDb[i].name, qnode.name, sizeof(l.nodeDb[0].name));
      return &l.nodeDb[i];
    }
  }
  return 0;
}

static pwr_tStatus emon_redu_init()
{
  pwr_tStatus sts;
  pwr_tOid child;
  void* p;
  pwr_tCid cid;

  l.redu = 0;

  for (sts = gdh_GetChild(l.emonObject, &child); ODD(sts);
       sts = gdh_GetNextSibling(child, &child)) {
    sts = gdh_GetObjectClass(child, &cid);
    if (EVEN(sts))
      continue;
    if (cid == pwr_cClass_RedcomPacket) {
      sts = gdh_ObjidToPointer(child, &p);
      if (EVEN(sts))
        return sts;

      sts = redu_init(&l.redu, l.nodep, p);
      if (EVEN(sts))
        return sts;

      break;
    }
  }
  return MH__SUCCESS;
}

typedef struct {
  redu_sHeader h;
  pwr_tUInt32 size;
  pwr_tUInt32 actives;
  pwr_tUInt32 outunits;
  pwr_tUInt32 events;
  pwr_tTime time;
} redu_sEvMsgHeader;

typedef struct {
  pwr_tUInt32 idx;
  pwr_tUInt32 returnIdx;
  pwr_tUInt32 ackIdx;
  mh_eSource source;
  pwr_tAttrRef object;
  pwr_tAttrRef supObject;
  pwr_tObjid outunit;
  mh_mEventFlags eventFlags;
  pwr_eEventTypeEnum eventType;
  mh_uEventInfo status;
  pwr_tTime detectTime;
  pwr_tTime returnTime;
  pwr_tTime ackTime;
  pwr_tUInt32 detect_etp;
  pwr_tUInt32 return_etp;
  pwr_tUInt32 ack_etp;
  pwr_tUInt32 detect_event;
  pwr_tUInt32 return_event;
  pwr_tUInt32 ack_event;
} redu_sEvActive;

typedef struct {
  pwr_tTime birthTime;
  pwr_tObjid outunit;
  mh_eOutunitType type;
  pwr_tUInt32 ver;
  pwr_tNodeIndex nix;
  qcom_sQid qid;
  co_sPlatform platform;
  pwr_tUInt32 ackGen;
  pwr_tUInt32 blockGen;
  pwr_tUInt32 eventIdx;
  pwr_tUInt32 eventGen;
  pwr_tUInt32 maxIdx;
  pwr_tUInt32 syncedIdx;
  pwr_tUInt32 lastSentIdx;
  pwr_tTime lastSentTime;
  pwr_tUInt32 selGen;
  pwr_tUInt32 selSize;
  mh_sSelL sel_l[mh_cSelLSize];
} redu_sEvOutunit;

typedef struct {
  pwr_tUInt32 idx;
  pwr_tUInt32 oldIdx;
  pwr_tUInt32 size;
} redu_sEvEventList;

typedef struct {
  pwr_tUInt32 idx;
  pwr_tObjid outunit;
  pwr_tAttrRef object;
  pwr_tAName objName;
  mh_eEvent event;
  pwr_eEventTypeEnum eventType;
  pwr_tUInt32 msgSize;
  pwr_tBoolean local;
  uEvent msg;
  mh_eSource activeSource;
  pwr_tAttrRef activeSupObject;
  pwr_tUInt32 etp;
} redu_sEvEvent;

#define NOIDX 0xffffffff

static pwr_tStatus emon_redu_send()
{
  pwr_tStatus sts;
  void* msg;
  struct LstHead * al;
  sActive* ap;
  sSupActive* sp;
  int size;
  int active_cnt;
  int outunit_cnt;
  int event_cnt;
  redu_sEvActive* activep;
  redu_sEvOutunit* outunitp;
  redu_sEvEventList* eventlistp;
  redu_sEvEvent* eventp;
  sOutunit* op;
  struct LstHead * ol;
  sEvent* ep;
  int i;

  // Count active
  active_cnt = 0;
  LstForEach(al, &l.active_l)
    active_cnt++;

  // Count outunits
  outunit_cnt = 0;
  LstForEach(ol, &l.outunit_l) {
    op = LstEntry(ol, sOutunit, outunit_l);

    if (op->outunit.vid != l.nodeObject.vid)
      outunit_cnt++;
  }

  // Count events
  event_cnt = l.event_l->idx - l.event_l->oldIdx + 1;

  size = sizeof(redu_sEvMsgHeader) + active_cnt * sizeof(redu_sEvEvent)
      + outunit_cnt * sizeof(redu_sEvOutunit) + +sizeof(redu_sEvEventList)
      + event_cnt * sizeof(redu_sEvEvent);

  msg = malloc(size);
  ((redu_sEvMsgHeader*)msg)->h.type = redu_eMsgType_Cyclic;
  ((redu_sEvMsgHeader*)msg)->size = size - sizeof(redu_sEvMsgHeader);
  ((redu_sEvMsgHeader*)msg)->actives = active_cnt;
  ((redu_sEvMsgHeader*)msg)->outunits = outunit_cnt;
  ((redu_sEvMsgHeader*)msg)->events = event_cnt;

  activep = (redu_sEvActive*)((char*)msg + sizeof(redu_sEvMsgHeader));
  LstForEach(al, &l.active_l) {
    ap = LstEntry(al, sActive, active_l);

    activep->idx = ap->idx;
    activep->returnIdx = ap->returnIdx;
    activep->ackIdx = ap->ackIdx;
    activep->source = ap->source;
    activep->object = ap->object;
    activep->supObject = ap->supObject;
    activep->outunit = ap->outunit;
    activep->eventFlags = ap->eventFlags;
    activep->eventType = ap->eventType;
    activep->status = ap->status;
    if (ap->detect_etp) {
      activep->detect_etp = ap->detect_etp->idx;
      activep->detect_event = ap->detect_etp->event;
    } else
      activep->detect_etp = NOIDX;
    if (ap->return_etp) {
      activep->return_etp = ap->return_etp->idx;
      activep->return_event = ap->return_etp->event;
    } else
      activep->return_etp = NOIDX;
    if (ap->ack_etp) {
      activep->ack_etp = ap->ack_etp->idx;
      activep->ack_event = ap->ack_etp->event;
    } else
      activep->ack_etp = NOIDX;

    if (ap->source == mh_eSource_Scanner) {
      sp = (sSupActive*)ap;
      activep->detectTime = sp->sup->DetectTime;
      activep->returnTime = sp->sup->ReturnTime;
      activep->ackTime = sp->sup->AckTime;
    }

    activep++;
  }

  /* Outunits, only remote */
  outunitp = (redu_sEvOutunit*)activep;
  LstForEach(ol, &l.outunit_l) {
    op = LstEntry(ol, sOutunit, outunit_l);

    if (op->outunit.vid != l.nodeObject.vid) {
      outunitp->outunit = op->outunit;
      outunitp->type = op->type;
      outunitp->ver = op->ver;
      outunitp->qid = op->link.qid;
      outunitp->platform = op->link.platform;
      outunitp->nix = op->link.nix;
      outunitp->birthTime = op->birthTime;
      outunitp->ackGen = op->ackGen;
      outunitp->blockGen = op->blockGen;
      outunitp->eventIdx = op->eventIdx;
      outunitp->eventGen = op->eventGen;
      outunitp->maxIdx = op->maxIdx;
      outunitp->syncedIdx = op->syncedIdx;
      outunitp->lastSentIdx = op->lastSentIdx;
      outunitp->lastSentTime = op->lastSentTime;
      outunitp->selGen = op->selGen;
      outunitp->selSize = op->selSize;
      memcpy(outunitp->sel_l, op->sel_l, sizeof(outunitp->sel_l));
      outunitp++;
    }
  }

  /* EventList */
  eventlistp = (redu_sEvEventList*)outunitp;
  eventlistp->idx = l.event_l->idx;
  eventlistp->oldIdx = l.event_l->oldIdx;
  eventlistp->size = l.event_l->size;

  /* Events */
  eventp = (redu_sEvEvent*)((char*)outunitp + sizeof(*eventlistp));
  for (i = l.event_l->oldIdx; i <= l.event_l->idx; i++) {
    ep = &l.event_l->list[i % l.event_l->size];

    eventp->idx = ep->idx;
    eventp->object = ep->object;
    eventp->outunit = ep->outunit;
    strncpy(eventp->objName, ep->objName, sizeof(eventp->objName));
    eventp->event = ep->event;
    eventp->eventType = ep->eventType;
    eventp->msgSize = ep->msgSize;
    eventp->local = ep->local;
    eventp->msg = ep->msg;
    if (ep->etp && ep->etp->ap) {
      eventp->activeSource = ep->etp->ap->source;
      if (ep->etp->ap->source == mh_eSource_Scanner
          || ep->etp->ap->source == mh_eSource_Handler)
        eventp->activeSupObject = ep->etp->ap->supObject;
    }
    if (ep->etp)
      eventp->etp = ep->etp->idx;
    else
      eventp->etp = NOIDX;

    eventp++;
  }

  l.redu->packetp->PacketSize
      = ((redu_sEvMsgHeader*)msg)->size + sizeof(redu_sEvMsgHeader);
  l.redu->packetp->TransmitCnt++;

  sts = redu_send(l.redu, msg,
      ((redu_sEvMsgHeader*)msg)->size + sizeof(redu_sEvMsgHeader),
      l.redu->msgid_cyclic);

  free(msg);

  return sts;
}

static pwr_tStatus emon_redu_receive()
{
  pwr_tStatus sts;
  void* msg;
  int size;
  unsigned int timeout = l.timerTime * 1000;
  pwr_tTime start_time;
  pwr_tTime end_time;
  pwr_tDeltaTime dtime;
  redu_sEvActive* activep;
  redu_sEvOutunit* outunitp;
  redu_sEvOutunit* outunit_start;
  redu_sEvEventList* eventlistp;
  redu_sEvEvent* eventp;
  redu_sEvEvent* event_start;
  int actives;
  int outunits;
  int events;
  int i;
  struct LstHead * al;
  sActive *ap = NULL, *tp;
  sSupActive* sp;
  sEvent* ep;
  sOutunit* op;
  struct LstHead * ol;
  int found;

  sts = redu_receive(l.redu, timeout, &size, &msg);
  if (sts == QCOM__TMO)
    return sts;
  else if (EVEN(sts)) {
    struct timespec ts = { timeout / 1000, (timeout * 1000000) % 1000000000 };
    // Wait to avoid looping
    nanosleep(&ts, NULL);
    return sts;
  }

  switch (((redu_sHeader*)msg)->type) {
  case redu_eMsgType_Cyclic:
    if (l.redu->packetp)
      l.redu->packetp->PacketSize = size;

    actives = ((redu_sEvMsgHeader*)msg)->actives;
    outunits = ((redu_sEvMsgHeader*)msg)->outunits;
    events = ((redu_sEvMsgHeader*)msg)->events;

    /* Unpack message */

    time_GetTime(&start_time);

    /* EventList */
    eventlistp = (redu_sEvEventList*)((char*)msg + sizeof(redu_sEvMsgHeader)
        + ((redu_sEvMsgHeader*)msg)->actives * sizeof(redu_sEvActive)
        + ((redu_sEvMsgHeader*)msg)->outunits * sizeof(redu_sEvOutunit));

    /* Events */
    event_start
        = (redu_sEvEvent*)((char*)eventlistp + sizeof(redu_sEvEventList));

    tree_EmptyTable(&sts, l.eventTab);

    /* Insert events */
    for (i = eventlistp->oldIdx; i <= eventlistp->idx; i++) {
      eventp = event_start + i - eventlistp->oldIdx;
      ep = &l.event_l->list[i % l.event_l->size];
      ep->idx = eventp->idx;
      ep->outunit = eventp->outunit;
      ep->object = eventp->object;
      ep->local = eventp->local;
      ep->event = eventp->event;
      ep->eventType = ep->eventType;
      strncpy(ep->objName, eventp->objName, sizeof(ep->objName));
      ep->msg = eventp->msg;
      if (eventp->etp == NOIDX)
        ep->etp = 0;
      else {
        ep->etp = tree_Insert(&sts, l.eventTab, &ep->idx);
        ep->etp->ep = ep;
        ep->etp->event = ep->event;
      }
      // printf( "Event add,    idx %d %s sup_oix:%d %u %u\n", ep->etp->idx,
      // ep->objName, ep->etp->ap ? ep->etp->ap->supObject.Objid.oix : 0,
      // (unsigned int)ep->etp->node.left, (unsigned int)ep->etp->node.right);
    }

    l.event_l->idx = eventlistp->idx;
    l.event_l->oldIdx = eventlistp->oldIdx;

    /* Active list */
    /* Find removed elements in active list */
    LstForEach(al, &l.active_l) {
      ap = LstEntry(al, sActive, active_l);
      if (ap->source == mh_eSource_Scanner
          || ap->source == mh_eSource_Handler) {
        sp = (sSupActive*)ap;
        sp->found = 0;
      }
    }

    activep = (redu_sEvActive*)((char*)msg + sizeof(redu_sEvMsgHeader));
    for (i = 0; i < actives; i++) {
      if (activep->source == mh_eSource_Scanner
          || activep->source == mh_eSource_Handler) {
        LstForEach(al, &l.active_l) {
          ap = LstEntry(al, sActive, active_l);
          if ((activep->source == mh_eSource_Scanner
                  || activep->source == mh_eSource_Handler)
              && cdh_ArefIsEqual(&activep->supObject, &ap->supObject)) {
            sp = (sSupActive*)ap;
            sp->found = 1;
            break;
          }
        }
      }
      activep++;
    }

    for (al = l.active_l.next; al != &l.active_l;) {
      ap = LstEntry(al, sActive, active_l);
      al = al->next;
      if (ap->source == mh_eSource_Scanner
          || ap->source == mh_eSource_Handler) {
        sp = (sSupActive*)ap;
        if (!sp->found) {
          ap->status.Event.Status &= ~mh_mEventStatus_NotRet;
          ap->status.Event.Status &= ~mh_mEventStatus_NotAck;
          if (sp->sup) {
            sp->sup->DetectCheck = TRUE;
            sp->sup->AlarmCheck = TRUE;
            sp->sup->ReturnCheck = FALSE;
            sp->sup->AlarmStatus.All = ap->status.All;
          }
          // printf( "Active remove, idx %d %s\n", ap->detect_etp->idx,
          // ap->detect_etp->ep ? ap->detect_etp->ep->objName : "");
          activeListRemove(ap);
        }
      }
    }

    /* Add new elements in active list and update existing */
    activep = (redu_sEvActive*)((char*)msg + sizeof(redu_sEvMsgHeader));
    for (i = 0; i < actives; i++) {
      found = 0;
      if (activep->source == mh_eSource_Scanner
          || activep->source == mh_eSource_Handler) {
        LstForEach(al, &l.active_l) {
          ap = LstEntry(al, sActive, active_l);
          if ((activep->source == mh_eSource_Scanner
                  || activep->source == mh_eSource_Handler)
              && cdh_ArefIsEqual(&activep->supObject, &ap->supObject)) {
            sp = (sSupActive*)ap;
            found = 1;
            break;
          }
        }
      }

      if (!found) {
        /* Add to active list */
        sp = supListGet(&activep->supObject);
        ap = (sActive*)sp;
        if (sp == NULL) {
          activep++;
          continue;
        }
        LstForEach(al, &l.active_l) {
          tp = LstEntry(al, sActive, active_l);
          if (ap == tp)
            /* Already in active list */
            found = 1;
        }
      }

      if (activep->detect_etp == NOIDX)
        ap->detect_etp = 0;
      else {
        ap->detect_etp = tree_Find(&sts, l.eventTab, &activep->detect_etp);
        if (ap->detect_etp == 0) {
          ap->detect_etp = tree_Insert(&sts, l.eventTab, &activep->detect_etp);
          ap->detect_etp->ep = 0;
        }
        ap->detect_etp->event = activep->detect_event;
        ap->detect_etp->ap = ap;
      }
      if (activep->return_etp == NOIDX)
        ap->return_etp = 0;
      else {
        ap->return_etp = tree_Find(&sts, l.eventTab, &activep->return_etp);
        if (ap->return_etp == 0) {
          ap->return_etp = tree_Insert(&sts, l.eventTab, &activep->return_etp);
          ap->return_etp->ep = 0;
        }
        ap->return_etp->event = activep->return_event;
        ap->return_etp->ap = ap;
      }
      if (activep->ack_etp == NOIDX)
        ap->ack_etp = 0;
      else {
        ap->ack_etp = tree_Find(&sts, l.eventTab, &activep->ack_etp);
        if (ap->ack_etp == 0) {
          ap->ack_etp = tree_Insert(&sts, l.eventTab, &activep->ack_etp);
          ap->ack_etp->ep = 0;
        }
        ap->ack_etp->event = activep->ack_event;
        ap->ack_etp->ap = ap;
      }

      switch (ap->detect_etp->event) {
      case mh_eEvent_Info:
      case mh_eEvent_InfoSuccess:
      case mh_eEvent_Alarm:
      case mh_eEvent_MaintenanceAlarm:
      case mh_eEvent_SystemAlarm:
      case mh_eEvent_UserAlarm1:
      case mh_eEvent_UserAlarm2:
      case mh_eEvent_UserAlarm3:
      case mh_eEvent_UserAlarm4:
        break;
      default:
        timelog_ss(4, "emon etp type error", ap->objName);
        activep++;
        continue;
      }
      if (!found) {
        struct LstHead * al;
        struct LstHead * bl;

        // printf( "Active add, idx %d %s\n", ap->detect_etp->idx,
        // ap->detect_etp->ep ? ap->detect_etp->ep->objName : "");
        // if ( sp->sup) {
        // sp->sup->DetectTime = activep->detectTime;
        // sp->sup->AckTime = activep->ackTime;
        // sp->sup->ReturnTime = activep->returnTime;
        // sp->sup->AlarmCheck = FALSE;
        // sp->sup->DetectCheck = FALSE;
        // sp->sup->ReturnCheck = TRUE;
        // sp->sup->AlarmStatus.All = activep->status.All;
        //}
        /* Insert in active list */

        al = &l.active_l;
        LstInsert(al, &ap->active_l);

        switch (ap->event) {
        case mh_eEvent_Alarm:
        case mh_eEvent_MaintenanceAlarm:
        case mh_eEvent_SystemAlarm:
        case mh_eEvent_UserAlarm1:
        case mh_eEvent_UserAlarm2:
        case mh_eEvent_UserAlarm3:
        case mh_eEvent_UserAlarm4:
          ++l.emon->AlarmCount;
          break;
        case mh_eEvent_Block:
        case mh_eEvent_Reblock:
          bl = &l.block_l;
          LstInsert(bl, &((sBlock*)ap)->block_l);
          ++l.emon->BlockCount;
          break;
        case mh_eEvent_Info:
        case mh_eEvent_InfoSuccess:
          break;
        default:
          errh_Error("activeListInsert, program error, event: %d", ap->event);
          break;
        }

        // printf( "Active add,    idx %d %s\n", ap->detect_etp->idx,
        // ap->detect_etp->ep ? ap->detect_etp->ep->objName : "");
      }
      ap->idx = activep->idx;
      ap->outunit = activep->outunit;
      ap->status = activep->status;
      activep++;
    }

    /* Outunits */
    outunit_start = (redu_sEvOutunit*)activep;

    /* Remove outunits */
    for (ol = l.outunit_l.next; ol != &l.outunit_l;) {
      op = LstEntry(ol, sOutunit, outunit_l);
      ol = ol->next;

      if (op->outunit.vid == l.nodeObject.vid)
        continue;

      found = 0;
      outunitp = outunit_start;
      for (i = 0; i < outunits; i++) {
        if (cdh_ObjidIsEqual(outunitp->outunit, op->outunit)) {
          found = 1;
          break;
        }
        outunitp++;
      }
      if (!found) {
        outunitAborted(op);
        printf("Outunit removed, (%d,%d)\n", op->outunit.oix, op->outunit.vid);
      }
    }

    /* Add outunits */
    outunitp = outunit_start;
    for (i = 0; i < outunits; i++) {
      found = 0;
      for (ol = l.outunit_l.next; ol != &l.outunit_l;) {
        op = LstEntry(ol, sOutunit, outunit_l);
        ol = ol->next;

        if (cdh_ObjidIsEqual(outunitp->outunit, op->outunit)) {
          found = 1;
          op->link.qid = outunitp->qid;
          op->birthTime = outunitp->birthTime;
          op->ackGen = outunitp->ackGen;
          op->blockGen = outunitp->blockGen;
          op->eventIdx = outunitp->eventIdx;
          op->eventGen = outunitp->eventGen;
          op->maxIdx = outunitp->maxIdx;
          op->syncedIdx = outunitp->syncedIdx;
          op->lastSentIdx = outunitp->lastSentIdx;
          op->lastSentTime = outunitp->lastSentTime;
          op->selGen = outunitp->selGen;
          op->selSize = outunitp->selSize;
          memcpy(op->sel_l, outunitp->sel_l, sizeof(op->sel_l));
          break;
        }
      }
      if (!found) {
        op = (sOutunit*)calloc(1, sizeof(*op));
        if (op == NULL) {
          errh_Error("Error calloc, emon_redu_receive");
          return 1;
        }
        op->link.source = mh_eSource_Outunit;
        op->link.qid = outunitp->qid;
        op->link.aid = qcom_cNAid;
        op->link.platform = outunitp->platform;
        op->link.nix = outunitp->nix;
        op->birthTime = outunitp->birthTime;
        op->outunit = outunitp->outunit;
        op->type = outunitp->type;
        op->ver = outunitp->ver;
        op->ackGen = outunitp->ackGen;
        op->blockGen = outunitp->blockGen;
        op->eventIdx = outunitp->eventIdx;
        op->eventGen = outunitp->eventGen;
        op->maxIdx = outunitp->maxIdx;
        op->syncedIdx = outunitp->syncedIdx;
        op->lastSentIdx = outunitp->lastSentIdx;
        op->lastSentTime = outunitp->lastSentTime;
        op->selGen = outunitp->selGen;
        op->selSize = outunitp->selSize;
        memcpy(op->sel_l, outunitp->sel_l, sizeof(op->sel_l));
        /* Insert in outunit list */
        LstInsert(&l.outunit_l, &op->outunit_l);
        /* Insert in process list */
        LstInsert(&l.proc_l, &op->link.proc_l);
        op->linkUp = TRUE;
        outunitLog(op, "New outunit");
        printf("Outunit added,  (%d,%d)\n", op->outunit.oix, op->outunit.vid);
      }
      outunitp++;
    }

    time_GetTime(&end_time);
    time_Adiff_NE(&dtime, &end_time, &start_time);
    time_DToFloat(&l.redu->msg_time, &dtime);
    if (l.redu->packetp) {
      l.redu->packetp->ReceiveCnt++;
      l.redu->packetp->UnpackTime = l.redu->msg_time;
    }

    break;
  case redu_eMsgType_TableVersionRequest:
    sts = redu_send_table_version(l.redu);
    break;
  case redu_eMsgType_TableVersion:
    break;
  default:
    printf("Redu: Unknown message type %d\n", ((redu_sHeader*)msg)->type);
  }
  qcom_Free(&sts, msg);
  return MH__SUCCESS;
}
