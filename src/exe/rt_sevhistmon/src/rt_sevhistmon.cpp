/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <unistd.h>

#include <iostream>

#include "pwr_baseclasses.h"

#include "co_cdh.h"
#include "co_error.h"
#include "co_string.h"
#include "co_time.h"
#include "co_syi.h"

#include "rt_gdh.h"
#include "rt_qcom_msg.h"
#include "rt_ini_event.h"
#include "rt_aproc.h"
#include "rt_mh_outunit.h"
#include "rt_mh_util.h"
#include "rt_sev_net.h"
#include "rt_sevhistmon.h"
#include "rt_sev_msg.h"
#include "rt_pwr_msg.h"

static int plog = 1;

#define evbuf_next_idx(idx)                                  \
  idx++;                                                     \
  if (idx >= sizeof(event_buffer) / sizeof(event_buffer[0])) \
    idx = 0;

#define evbuf_previous_idx(idx)                               \
  if (idx == 0)                                               \
    idx = sizeof(event_buffer) / sizeof(event_buffer[0]) - 1; \
  else                                                        \
    idx--;

static rt_sevhistmon* shm;

int rt_sevhistmon::init()
{
  pwr_tStatus sts;
  qcom_sQid qid;
  qcom_sQid qini;
  qcom_sNode node;
  pwr_tNid nid;
  pwr_tOName oname;

  errh_Init("pwr_sevhistmon", errh_eAnix_sevhistmon);
  errh_SetStatus(PWR__SRVSTARTUP);

  sts = gdh_Init("rt_sevhistmon");
  if (EVEN(sts))
    throw co_error(sts);

  // Get the config object
  sts = gdh_GetClassList(pwr_cClass_SevHistMonitor, &m_confoid);
  if (EVEN(sts)) {
    errh_SetStatus(0);
    errh_CErrLog(PWR__SRVNOTCONF, 0);
    exit(0);
  }

  m_sts = gdh_ObjidToName(
      m_confoid, oname, sizeof(oname), cdh_mName_volumeStrict);
  if (EVEN(m_sts))
    throw co_error(m_sts);

  m_sts = gdh_RefObjectInfo(
      oname, (void**)&m_confp, &m_conf_refid, sizeof(*m_confp));
  if (EVEN(m_sts))
    throw co_error(m_sts);

  aproc_RegisterObject(m_confoid);

  m_confp->Status = m_server_status = PWR__SRVSTARTUP;
  m_scantime = m_confp->ScanTime;
  if (m_scantime < 0.01)
    m_scantime = 0.01;

  // Create a queue to server
  qcom_sQattr attr;

  qid.qix = sev_eProcSevClient;
  qid.nid = 0;
  attr.type = qcom_eQtype_private;
  attr.quota = 100;

  if (!qcom_CreateQ(&sts, &qid, &attr, "SevClient")) {
    if (sts == QCOM__QALLREXIST) {
      if (!qcom_AttachQ(&sts, &qid)) {
        if (!qcom_DeleteQ(&sts, &qid))
          throw co_error(sts);
        if (!qcom_CreateQ(&sts, &qid, &attr, "SevClient"))
          throw co_error(sts);
      }
    } else
      throw co_error(sts);
  }

  qini = qcom_cQini;
  if (!qcom_Bind(&sts, &qid, &qini))
    throw co_error(sts);

  // Get all qcom nodes
  qcom_MyNode(&m_sts, &node);
  if (EVEN(m_sts))
    throw co_error(m_sts);

  sev_node myn;
  myn.nid = node.nid;
  strncpy(myn.name, node.name, sizeof(myn.name));
  m_nodes.push_back(myn);

  for (nid = qcom_cNNid; qcom_NextNode(&sts, &node, nid); nid = node.nid) {
    sev_node n;
    if (node.nid == m_nodes[0].nid)
      continue;

    n.nid = node.nid;
    strncpy(n.name, node.name, sizeof(n.name));
    m_nodes.push_back(n);
  }

  while (EVEN(gdh_NethandlerRunning()))
    sleep(1);

  init_objects();
  init_events();

  return 1;
}

int rt_sevhistmon::init_objects()
{
  pwr_tStatus sts;
  pwr_tOid hs_oid;
  pwr_tAttrRef h_aref;
  pwr_tAttrRef uaref;
  pwr_tTid a_tid;
  unsigned int a_size, a_offset, a_dim;
  pwr_tAName hname;
  pwr_tOName oname;

  // Get all SevHist and SevHistThread objects
  int thread_cnt = 0;
  for (sts = gdh_GetClassList(pwr_cClass_SevHistThread, &hs_oid); ODD(sts);
       sts = gdh_GetNextObject(hs_oid, &hs_oid)) {
    sev_sevhistthread hs;

    m_sts
        = gdh_ObjidToName(hs_oid, oname, sizeof(oname), cdh_mName_volumeStrict);
    if (EVEN(m_sts))
      throw co_error(m_sts);

    m_sts = gdh_RefObjectInfo(
        oname, (void**)&hs.threadp, &hs.refid, sizeof(*hs.threadp));
    if (EVEN(m_sts))
      throw co_error(m_sts);

    hs.oid = hs_oid;
    hs.scantime = hs.threadp->ScanTime;
    strncpy(hs.nodename, hs.threadp->ServerNode, sizeof(hs.nodename));
    if (strcmp(hs.nodename, "localhost") == 0)
      syi_NodeName(&m_sts, hs.nodename, sizeof(hs.nodename));
    hs.threadp->NoOfItems = 0;
    hs.size = 0;

    bool found = false;
    for (unsigned int i = 0; i < m_nodes.size(); i++) {
      if (str_NoCaseStrcmp(hs.nodename, m_nodes[i].name) == 0) {
        hs.nid = m_nodes[i].nid;
        found = true;
        break;
      }
    }
    if (thread_cnt < (int)(sizeof(m_confp->ThreadObjects)
                         / sizeof(m_confp->ThreadObjects[0])))
      m_confp->ThreadObjects[thread_cnt++] = hs_oid;
    if (!found) {
      pwr_tOName oname;

      m_sts = gdh_ObjidToName(
          hs_oid, oname, sizeof(oname), cdh_mName_volumeStrict);
      if (EVEN(m_sts))
        throw co_error(m_sts);

      errh_Error("Unknown nodename, %s", oname);
      hs.threadp->Status = SEV__UNKNOWNNODE;
      hs.configerror = 1;
    } else
      hs.threadp->Status = SEV__INIT;
    m_hs.push_back(hs);
  }

  for (int i = thread_cnt; i < int(sizeof(m_confp->ThreadObjects)
                                   / sizeof(m_confp->ThreadObjects[0]));
       i++)
    m_confp->ThreadObjects[i] = pwr_cNOid;

  for (sts = gdh_GetClassListAttrRef(pwr_cClass_SevHist, &h_aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_SevHist, &h_aref, &h_aref)) {
    sev_sevhist h;
    int hs_idx;

    m_sts = gdh_DLRefObjectInfoAttrref(&h_aref, (void**)&h.hsp, &h.hs_refid);
    if (EVEN(m_sts))
      throw co_error(m_sts);

    h.aref = h.hsp->Attribute;

    m_sts = gdh_AttrrefToName(
        &h_aref, hname, sizeof(hname), cdh_mName_volumeStrict);
    if (EVEN(m_sts))
      throw co_error(m_sts);

    hs_idx = -1;
    for (int i = 0; i < (int)m_hs.size(); i++) {
      if (cdh_ObjidIsEqual(h.hsp->ThreadObject, m_hs[i].oid)) {
        hs_idx = i;
        break;
      }
    }
    if (hs_idx == -1) {
      errh_Error("Invalid HistServerObject %s", hname);
      continue;
    }

    m_sts = gdh_GetAttributeCharAttrref(
        &h.hsp->Attribute, &a_tid, &a_size, &a_offset, &a_dim);
    if (EVEN(m_sts)) {
      errh_Error("Invalid SevHist Attribute %s", hname);
      continue;
    }

    h.sevid.nid = m_nodes[0].nid;
    h.sevid.rix = m_next_rix++;
    h.storagetime = h.hsp->StorageTime;
    h.deadband = h.hsp->DeadBand;
    h.options = h.hsp->Options;
    h.disabled = h.hsp->Disable;
    strncpy(h.description, h.hsp->Description, sizeof(h.description));

    // Get unit from attribute object
    sts = gdh_ArefANameToAref(&h.hsp->Attribute, "Unit", &uaref);
    if (ODD(sts)) {
      sts = gdh_GetObjectInfoAttrref(&uaref, &h.unit, sizeof(h.unit));
      if (EVEN(sts))
        strcpy(h.unit, "");
    } else
      strcpy(h.unit, "");

    h.type = (pwr_eType)a_tid;
    h.size = a_size;
    h.scantime = m_hs[hs_idx].scantime;

    if (!correct_histtype(h.type)) {
      errh_Error("Invalid SevHist Attribute type %s", hname);
      continue;
    }

    m_sts = gdh_AttrrefToName(
        &h.hsp->Attribute, h.aname, sizeof(h.aname), cdh_mName_volumeStrict);
    if (EVEN(m_sts))
      throw co_error(m_sts);

    m_sts = gdh_RefObjectInfo(h.aname, &h.datap, &h.refid, h.size);
    if (EVEN(m_sts)) {
      errh_Error("Unable to link to Attribute %s", h.aname);
      continue;
    }
    m_hs[hs_idx].size += h.size;
    m_hs[hs_idx].sevhistlist.push_back(h);
    m_hs[hs_idx].threadp->NoOfItems++;
  }

  init_sevhistobjects();
  init_sevexport();

  set_status();

  return 1;
}

int rt_sevhistmon::init_sevexport()
{
  pwr_tStatus sts;
  pwr_tAttrRef h_aref;
  pwr_tTid a_tid;
  unsigned int a_size, a_offset, a_dim;
  pwr_tAName hname;

  for (sts = gdh_GetClassListAttrRef(pwr_cClass_SevExport, &h_aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_SevExport, &h_aref, &h_aref)) {
    sev_sevexport h;
    int hs_idx;

    m_sts = gdh_DLRefObjectInfoAttrref(&h_aref, (void**)&h.hsp, &h.hs_refid);
    if (EVEN(m_sts))
      throw co_error(m_sts);

    h.aref = h.hsp->Attribute;

    m_sts = gdh_AttrrefToName(
        &h_aref, hname, sizeof(hname), cdh_mName_volumeStrict);
    if (EVEN(m_sts))
      throw co_error(m_sts);

    hs_idx = -1;
    for (int i = 0; i < (int)m_hs.size(); i++) {
      if (cdh_ObjidIsEqual(h.hsp->ThreadObject, m_hs[i].oid)) {
        hs_idx = i;
        break;
      }
    }
    if (hs_idx == -1) {
      errh_Error("Invalid HistServerObject %s", hname);
      continue;
    }

    m_sts = gdh_GetAttributeCharAttrref(
        &h.hsp->Attribute, &a_tid, &a_size, &a_offset, &a_dim);
    if (EVEN(m_sts)) {
      errh_Error("Invalid SevHist Attribute %s", hname);
      continue;
    }

    h.sevid.nid = m_nodes[0].nid;
    h.sevid.rix = m_next_rix++;
    h.options = h.hsp->Options;
    h.disabled = h.hsp->Disable;
    strncpy(h.description, h.hsp->Description, sizeof(h.description));

    h.type = (pwr_eType)a_tid;
    h.size = a_size;
    h.scantime = m_hs[hs_idx].scantime;

    if (!correct_exporttype(h.type)) {
      errh_Error("Invalid SevHist Attribute type %s", hname);
      continue;
    }

    m_sts = gdh_AttrrefToName(
        &h.hsp->Attribute, h.aname, sizeof(h.aname), cdh_mName_volumeStrict);
    if (EVEN(m_sts))
      throw co_error(m_sts);

    m_sts = gdh_RefObjectInfo(h.aname, &h.datap, &h.refid, h.size);
    if (EVEN(m_sts)) {
      errh_Error("Unable to link to Attribute %s", h.aname);
      continue;
    }
    m_hs[hs_idx].size += h.size;
    m_hs[hs_idx].sevexportlist.push_back(h);
    m_hs[hs_idx].threadp->NoOfItems++;
  }
  return 1;
}

int rt_sevhistmon::init_sevhistobjects()
{
  pwr_tStatus sts;
  pwr_tAttrRef h_aref;
  pwr_tTid a_tid;
  unsigned int a_size, a_offset, a_dim;
  pwr_tAName hname;

  for (sts = gdh_GetClassListAttrRef(pwr_cClass_SevHistObject, &h_aref);
       ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_SevHistObject, &h_aref, &h_aref)) {
    sev_sevhistobject h;
    int hs_idx;

    m_sts = gdh_DLRefObjectInfoAttrref(&h_aref, (void**)&h.hsp, &h.hs_refid);
    if (EVEN(m_sts))
      throw co_error(m_sts);

    h.aref = h.hsp->Object;

    m_sts = gdh_AttrrefToName(
        &h_aref, hname, sizeof(hname), cdh_mName_volumeStrict);
    if (EVEN(m_sts))
      throw co_error(m_sts);

    hs_idx = -1;
    for (int i = 0; i < (int)m_hs.size(); i++) {
      if (cdh_ObjidIsEqual(h.hsp->ThreadObject, m_hs[i].oid)) {
        hs_idx = i;
        break;
      }
    }
    if (hs_idx == -1) {
      errh_Error("Invalid HistServerObject %s", hname);
      continue;
    }

    m_sts = gdh_GetAttributeCharAttrref(
        &h.hsp->Object, &a_tid, &a_size, &a_offset, &a_dim);
    if (EVEN(m_sts)) {
      errh_Error("Invalid SevHistObject Attribute %s", hname);
      continue;
    }

    h.storagetime = h.hsp->StorageTime;
    h.deadband = h.hsp->DeadBand;
    h.options = h.hsp->Options;
    h.disabled = h.hsp->Disable;
    strncpy(h.description, h.hsp->Description, sizeof(h.description));

    h.scantime = m_hs[hs_idx].scantime;

    h.sevid.nid = m_nodes[0].nid;
    h.sevid.rix = m_next_rix++;

    // Time to fetch all attributes for the object and put them into a list
    m_sts = gdh_AttrrefToName(
        &h.hsp->Object, hname, sizeof(hname), cdh_mName_volumeStrict);
    if (EVEN(m_sts))
      throw co_error(m_sts);
    strcpy(h.aname, hname);
    get_sevhistobjectattributes(hname, &h.sevhistobjectattrlist, hs_idx, true);
    h.datasize = 0;
    for (size_t k = 0; k < h.sevhistobjectattrlist.size(); k++)
      h.datasize += h.sevhistobjectattrlist[k].size;

    // Check if this object have a chance to be stored in one table
    if (h.datasize >= 65536) {
      errh_Warning(
          "SevHistObject Attribute %s is to big(maxsize 65536), ignored",
          hname);
      continue;
    }
    if (h.sevhistobjectattrlist.size() > 200) {
      errh_Warning(
          "SevHistObject Attribute %s has to many attributes(max 200), ignored",
          hname);
      continue;
    }

    m_hs[hs_idx].size += h.datasize;
    m_hs[hs_idx].threadp->NoOfItems += h.sevhistobjectattrlist.size();

    m_hs[hs_idx].sevhistobjectlist.push_back(h);

    // for( size_t k = 0; k < m_hs[hs_idx].sevhistobjectlist.size(); k++ ) {
    //  std::cout << m_hs[hs_idx].sevhistobjectlist[k].aname << '\n';
    //  for( size_t l = 0; l <
    //  m_hs[hs_idx].sevhistobjectlist[k].sevhistobjectattrlist.size(); l++ ) {
    //    std::cout <<
    //    m_hs[hs_idx].sevhistobjectlist[k].sevhistobjectattrlist[l].aname <<
    //    '\n';
    //  }
    //}
  }
  return 1;
}

void rt_sevhistmon::insert_sevhistobjectattr(pwr_sAttrRef* aref,
    pwr_tAName objectname, // Name of object,
    int hs_idx, std::vector<sev_sevhistobjectattr>* listP)
{
  pwr_tTid a_tid;
  unsigned int a_size, a_offset, a_dim;
  sev_sevhistobjectattr oattr;

  m_sts = gdh_GetAttributeCharAttrref(aref, &a_tid, &a_size, &a_offset, &a_dim);
  if (EVEN(m_sts)) {
    errh_Error("Invalid SevHist Attribute %s", objectname);
    return;
  }

  oattr.type = (pwr_eType)a_tid;
  oattr.size = a_size;
  oattr.unit[0] = '\0';

  if (!correct_histtype(oattr.type)) {
    errh_Error("Invalid SevHist Attribute type %s, ignored\n", objectname);
    return;
  }
  // We ignore description fields
  std::string str = objectname;
  if (str.find(".Description") != std::string::npos) {
    errh_Info("Ignoring SevHist Attribute %s\n", objectname);
    return;
  }

  strncpy(oattr.aname, objectname, sizeof(pwr_tAName));

  m_sts
      = gdh_RefObjectInfo(oattr.aname, &oattr.datap, &oattr.refid, oattr.size);
  if (EVEN(m_sts)) {
    errh_Error("Unable to link to Attribute %s", oattr.aname);
    return;
  }
  listP->push_back(oattr);
}

int rt_sevhistmon::get_sevhistobjectattributes(
    pwr_tAName objectname, // Name of object
    std::vector<sev_sevhistobjectattr>* listP, // Pointer to list
    int hs_idx, pwr_tBoolean first)
{
  pwr_tAName attrname;
  pwr_sAttrRef attrref;
  pwr_tStatus sts;
  pwr_tTid tid;
  unsigned int i;
  int rows, j, elements;
  char idx[20];
  pwr_tUInt32 size, offs, elem;
  pwr_tBoolean tgtdynamic = 0;
  pwr_tObjid volobject;
  pwr_tClassId volclass;

  sts = gdh_NameToAttrref(pwr_cNObjid, objectname, &attrref);
  if (EVEN(sts))
    return sts;

  if (first) {
    volobject.vid = attrref.Objid.vid;
    volobject.oix = pwr_cNObjectIx;
    if (ODD(gdh_GetObjectClass(volobject, &volclass)))
      tgtdynamic = volclass == pwr_eClass_DynamicVolume;

    if (tgtdynamic) {
      if (attrref.Flags.b.Indirect)
        return 2;

      attrref.Offset = 0;
      attrref.Flags.b.Indirect = 0;
      attrref.Flags.b.Object = 1;

      sts = gdh_GetObjectSize(attrref.Objid, (pwr_tUInt32*)&attrref.Size);
      if (EVEN(sts))
        return sts;

      // Insert list element
      insert_sevhistobjectattr(&attrref, objectname, hs_idx, listP);
      return sts;
    }
  }

  sts = gdh_GetAttrRefTid(&attrref, &tid);
  if (EVEN(sts))
    return sts;

  if (cdh_tidIsCid(tid)) {
    sts = gdh_GetAttributeCharacteristics(
        objectname, NULL, &size, &offs, &elem);
    if (EVEN(sts))
      return sts;

    if (elem > 1) {
      for (i = 0; i < elem; i++) {
        strcpy(attrname, objectname);
        sprintf(idx, "[%d]", i);
        strcat(attrname, idx);

        // call again ...
        sts = get_sevhistobjectattributes(attrname, listP, hs_idx, 0);
      }

    } else {
      gdh_sAttrDef* bd;
      sts = gdh_GetObjectBodyDef(tid, &bd, &rows, attrref.Objid);
      if (EVEN(sts))
        return sts;

      for (int i = 0; (int)i < rows; i++) {
        if (bd[i].attr->Param.Info.Flags & PWR_MASK_RTVIRTUAL
            || bd[i].attr->Param.Info.Flags & PWR_MASK_PRIVATE)
          continue;

        if (bd[i].attr->Param.Info.Flags & PWR_MASK_ARRAY)
          elements = bd[i].attr->Param.Info.Elements;
        else
          elements = 1;

        if (bd[i].attr->Param.Info.Flags & PWR_MASK_CLASS) {
          if (elements == 1) {
            strcpy(attrname, objectname);
            strcat(attrname, ".");
            strcat(attrname, bd[i].attrName);

            // call again ...
            sts = get_sevhistobjectattributes(attrname, listP, hs_idx, 0);
          } else {
            for (j = 0; j < elements; j++) {
              strcpy(attrname, objectname);
              strcat(attrname, ".");
              strcat(attrname, bd[i].attrName);
              sprintf(idx, "[%d]", j);
              strcat(attrname, idx);

              // call again ...
              sts = get_sevhistobjectattributes(attrname, listP, hs_idx, 0);
            }
          }
        } else {
          if (elements > 1) {
            for (j = 0; j < elements; j++) {
              strcpy(attrname, objectname);
              strcat(attrname, ".");
              strcat(attrname, bd[i].attrName);
              sprintf(idx, "[%d]", j);
              strcat(attrname, idx);

              // call again ...
              sts = get_sevhistobjectattributes(attrname, listP, hs_idx, 0);
            }
          } else {
            strcpy(attrname, objectname);
            strcat(attrname, ".");
            strcat(attrname, bd[i].attrName);

            // call again ...
            sts = get_sevhistobjectattributes(attrname, listP, hs_idx, 0);
          }
        }
      }
      free((char*)bd);
    }
  } else {
    sts = gdh_GetAttributeCharacteristics(
        objectname, &tid, &size, &offs, &elem);
    if (EVEN(sts))
      return sts;

    if (elem > 1) {
      for (i = 0; i < elem; i++) {
        strcpy(attrname, objectname);
        sprintf(idx, "[%d]", i);
        strcat(attrname, idx);

        // call again ...
        sts = get_sevhistobjectattributes(attrname, listP, hs_idx, 0);
      }
    } else {
      // Insert list element
      insert_sevhistobjectattr(&attrref, objectname, hs_idx, listP);
    }
  }

  return sts;
}

bool rt_sevhistmon::correct_histtype(const pwr_eType type)
{
  switch (type) {
  case pwr_eType_Boolean:
  case pwr_eType_Int64:
  case pwr_eType_Int32:
  case pwr_eType_Int16:
  case pwr_eType_Int8:
  case pwr_eType_UInt64:
  case pwr_eType_UInt32:
  case pwr_eType_UInt16:
  case pwr_eType_UInt8:
  case pwr_eType_Float32:
  case pwr_eType_Float64:
  case pwr_eType_String:
  case pwr_eType_Time:
    return true;
  default:
    return false;
  }
}

bool rt_sevhistmon::correct_exporttype(const pwr_eType type)
{
  switch (type) {
  case pwr_eType_Boolean:
  case pwr_eType_Int64:
  case pwr_eType_Int32:
  case pwr_eType_Int16:
  case pwr_eType_Int8:
  case pwr_eType_UInt64:
  case pwr_eType_UInt32:
  case pwr_eType_UInt16:
  case pwr_eType_UInt8:
  case pwr_eType_Float32:
  case pwr_eType_Float64:
  case pwr_eType_String:
  case pwr_eType_Enum:
  case pwr_eType_Mask:
  case pwr_eType_Status:
  case pwr_eType_NetStatus:
  case pwr_eType_Time:
  case pwr_eType_DeltaTime:
    return true;
  default:
    return false;
  }
}

int rt_sevhistmon::close_objects()
{
  for (unsigned int i = 0; i < m_hs.size(); i++) {
    for (unsigned int j = 0; j < m_hs[i].sevhistlist.size(); j++) {
      gdh_UnrefObjectInfo(m_hs[i].sevhistlist[j].hs_refid);
      gdh_UnrefObjectInfo(m_hs[i].sevhistlist[j].refid);
    }
    for (unsigned int j = 0; j < m_hs[i].sevexportlist.size(); j++) {
      gdh_UnrefObjectInfo(m_hs[i].sevexportlist[j].hs_refid);
      gdh_UnrefObjectInfo(m_hs[i].sevexportlist[j].refid);
    }
    for (unsigned int j = 0; j < m_hs[i].sevhistobjectlist.size(); j++) {
      gdh_UnrefObjectInfo(m_hs[i].sevhistobjectlist[j].hs_refid);
      for (unsigned int k = 0; k < m_hs[i].sevhistobjectlist[j].sevhistobjectattrlist.size(); k++)
	gdh_UnrefObjectInfo(m_hs[i].sevhistobjectlist[j].sevhistobjectattrlist[k].refid);
    }
    gdh_UnrefObjectInfo(m_hs[i].refid);
  }
  m_hs.clear();

  return 1;
}

int rt_sevhistmon::close()
{
  close_objects();
  m_confp->Status = PWR__SRVTERM;
  errh_SetStatus(PWR__SRVTERM);

  gdh_UnrefObjectInfo(m_conf_refid);
  return 1;
}

int rt_sevhistmon::send_data()
{
  qcom_sQid tgt;
  qcom_sPut put;
  pwr_tStatus sts, lsts;
  int msize;
  sev_sMsgHistDataStore* msg;
  sev_sHistData* dp;
  int stime;
  pwr_tTime current_time;
  pwr_tStatus conf_sts = SEV__SUCCESS;
  int connected;

  for (unsigned int i = 0; i < m_hs.size(); i++) {
    if (m_hs[i].configerror)
      continue;

    connected = 0;
    for (unsigned int j = 0; j < m_nodes.size(); j++) {
      if (m_hs[i].nid == m_nodes[j].nid) {
        connected = m_nodes[j].connected;
        break;
      }
    }
    if (!connected)
      continue;

    stime = int(m_hs[i].scantime / m_scantime + 0.5);
    if (!stime || m_loopcnt % stime != 0)
      continue;

    m_hs[i].threadp->ScanCount++;

    msize = m_hs[i].sevhistlist.size() * (sizeof(*dp) - sizeof(dp->data))
        + m_hs[i].size;
    msize += sizeof(*msg) - sizeof(msg->Data);

    unsigned int histobjectsize
        = (m_hs[i].sevhistobjectlist.size() * (sizeof(*dp) - sizeof(dp->data)));
    msize += histobjectsize;

    msg = (sev_sMsgHistDataStore*)qcom_Alloc(&lsts, msize);

    put.size = msize;
    put.data = msg;
    put.allocate = 0;

    msg->Type = sev_eMsgType_HistDataStore;
    msg->Version = sev_cNetVersion;
    time_GetTime(&current_time);
    msg->Time = net_TimeToNetTime(&current_time);
    msg->ServerThread = m_hs[i].threadp->ServerThread;

    dp = (sev_sHistData*)&msg->Data;
    for (unsigned int j = 0; j < m_hs[i].sevhistlist.size(); j++) {
      if (!m_hs[i].sevhistlist[j].hsp->Disable) {
        if (m_hs[i].sevhistlist[j].hsp->Options & pwr_mSevOptionsMask_Event) {
          if (m_hs[i].sevhistlist[j].hsp->Trigger)
            m_hs[i].sevhistlist[j].hsp->Trigger = 0;
          else
            continue;
        }
        dp->sevid = m_hs[i].sevhistlist[j].sevid;
        dp->type = m_hs[i].sevhistlist[j].type;
        dp->size = m_hs[i].sevhistlist[j].size;
        memcpy(&dp->data, m_hs[i].sevhistlist[j].datap, dp->size);
        dp = (sev_sHistData*)((char*)dp + sizeof(*dp) - sizeof(dp->data)
            + dp->size);
      }
    }

    void* dpp;
    for (unsigned int j = 0; j < m_hs[i].sevhistobjectlist.size(); j++) {
      if (!m_hs[i].sevhistobjectlist[j].hsp->Disable) {
        if (m_hs[i].sevhistobjectlist[j].hsp->Options
            & pwr_mSevOptionsMask_Event) {
          if (m_hs[i].sevhistobjectlist[j].hsp->Trigger)
            m_hs[i].sevhistobjectlist[j].hsp->Trigger = 0;
          else
            continue;
        }

        dp->sevid = m_hs[i].sevhistobjectlist[j].sevid;
        dp->size = m_hs[i].sevhistobjectlist[j].datasize;
        dpp = &(dp->data);
        for (unsigned int k = 0;
             k < m_hs[i].sevhistobjectlist[j].sevhistobjectattrlist.size();
             k++) {
          // dp->type =
          // m_hs[i].sevhistobjectlist[j].sevhistobjectattrlist[k].type;
          // printf("sevhistobj[%d].attrlist[%d].aname: %s size:%d\n", j, k,
          // m_hs[i].sevhistobjectlist[j].sevhistobjectattrlist[k].aname,
          // m_hs[i].sevhistobjectlist[j].sevhistobjectattrlist[k].size);
          // if( m_hs[i].sevhistobjectlist[j].sevhistobjectattrlist[k].type ==
          // pwr_eType_String ) {
          //  printf("text:%s\n",
          //  (char*)m_hs[i].sevhistobjectlist[j].sevhistobjectattrlist[k].datap);
          //}
          memcpy(dpp,
              m_hs[i].sevhistobjectlist[j].sevhistobjectattrlist[k].datap,
              m_hs[i].sevhistobjectlist[j].sevhistobjectattrlist[k].size);
          dpp = (sev_sHistData*)((char*)dpp
              + m_hs[i].sevhistobjectlist[j].sevhistobjectattrlist[k].size);
        }
        dp = (sev_sHistData*)((char*)dp + sizeof(*dp) - sizeof(dp->data)
            + dp->size);
      }
    }

    tgt.nid = m_hs[i].nid;
    tgt.qix = sev_eProcSevServer;

    put.size = (char*)dp - (char*)msg;
    put.reply.nid = m_nodes[0].nid;
    put.reply.qix = sev_eProcSevClient;
    put.type.b = (qcom_eBtype)sev_cMsgClass;
    put.type.s = (qcom_eStype)sev_eMsgType_HistDataStore;
    put.msg_id = m_msg_id++;

    if (!qcom_Put(&sts, &tgt, &put)) {
      m_hs[i].threadp->ErrorCount++;
      if (sts == QCOM__NOQ)
	m_hs[i].threadp->Status = SEV__HISTDATAQ;
      else
	m_hs[i].threadp->Status = sts;
      conf_sts = sts;
      qcom_Free(&sts, put.data);
      continue;
    }
    m_hs[i].threadp->SendCount++;
    m_hs[i].threadp->Status = sts;
  }

  set_status();
  return 1;
}

int rt_sevhistmon::send_exportdata()
{
  qcom_sQid tgt;
  qcom_sPut put;
  pwr_tStatus sts, lsts;
  int msize;
  sev_sMsgExportData* msg;
  sev_sHistData* dp;
  int stime;
  pwr_tTime current_time;
  pwr_tStatus conf_sts = SEV__SUCCESS;
  int connected;

  for (unsigned int i = 0; i < m_hs.size(); i++) {
    if (m_hs[i].configerror)
      continue;

    if (m_hs[i].sevexportlist.size() == 0)
      continue;

    connected = 0;
    for (unsigned int j = 0; j < m_nodes.size(); j++) {
      if (m_hs[i].nid == m_nodes[j].nid) {
        connected = m_nodes[j].connected;
        break;
      }
    }
    if (!connected)
      continue;

    stime = int(m_hs[i].scantime / m_scantime + 0.5);
    if (!stime || m_loopcnt % stime != 0)
      continue;

    msize = m_hs[i].sevexportlist.size() * (sizeof(*dp) - sizeof(dp->data))
        + m_hs[i].size;
    msize += sizeof(*msg) - sizeof(msg->Data);

    msg = (sev_sMsgExportData*)qcom_Alloc(&lsts, msize);

    put.size = msize;
    put.data = msg;
    put.allocate = 0;

    msg->Type = sev_eMsgType_ExportData;
    msg->Version = sev_cNetVersion;
    time_GetTime(&current_time);
    msg->Time = net_TimeToNetTime(&current_time);
    msg->ServerThread = m_hs[i].threadp->ServerThread;


    dp = (sev_sHistData*)&msg->Data;
    for (unsigned int j = 0; j < m_hs[i].sevexportlist.size(); j++) {
      if (!m_hs[i].sevexportlist[j].hsp->Disable) {
        if (m_hs[i].sevexportlist[j].hsp->Options
            & pwr_mSevExportOptionsMask_Event) {
	  if (m_hs[i].sevexportlist[j].hsp->Trigger)
	    m_hs[i].sevexportlist[j].hsp->Trigger = 0;
	  else
	    continue;
	}

        dp->sevid = m_hs[i].sevexportlist[j].sevid;
        dp->type = m_hs[i].sevexportlist[j].type;
        dp->size = m_hs[i].sevexportlist[j].size;
        memcpy(&dp->data, m_hs[i].sevexportlist[j].datap, dp->size);
        dp = (sev_sHistData*)((char*)dp + sizeof(*dp) - sizeof(dp->data)
            + dp->size);
      }
    }

    tgt.nid = m_hs[i].nid;
    tgt.qix = sev_eProcSevImport;

    put.size = (char*)dp - (char*)msg;
    put.reply.nid = m_nodes[0].nid;
    put.reply.qix = sev_eProcSevClient;
    put.type.b = (qcom_eBtype)sev_cMsgClass;
    put.type.s = (qcom_eStype)sev_eMsgType_ExportData;
    put.msg_id = m_msg_id++;

    if (!qcom_Put(&sts, &tgt, &put)) {
      m_hs[i].threadp->ErrorCount++;
      if (sts == QCOM__NOQ)
	m_hs[i].threadp->Status = SEV__EXPORTQ;
      else
	m_hs[i].threadp->Status = sts;
      conf_sts = sts;
      qcom_Free(&sts, put.data);
      continue;
    }
    m_hs[i].threadp->SendCount++;
    m_hs[i].threadp->Status = sts;
  }

  set_status();
  return 1;
}

void rt_sevhistmon::set_status()
{
  pwr_tStatus sts = m_server_status;

  for (unsigned int i = 0; i < m_nodes.size(); i++) {
    if (m_nodes[i].connected && m_nodes[i].status != 0
        && errh_Severity(m_nodes[i].status) > errh_Severity(sts))
      sts = m_nodes[i].status;
  }

  for (unsigned int i = 0; i < m_hs.size(); i++) {
    if (EVEN(m_hs[i].threadp->Status)
        && errh_Severity(m_hs[i].threadp->Status) > errh_Severity(sts)) {
      sts = m_hs[i].threadp->Status;
    }
  }
  m_confp->Status = sts;
  errh_SetStatus(sts);
}

int rt_sevhistmon::retry_connect()
{
  pwr_tStatus sts;

  for (unsigned int i = 0; i < m_nodes.size(); i++) {
    if (m_nodes[i].is_server && !m_nodes[i].connected)
      send_connect(m_nodes[i].nid, &sts);
  }
  return 1;
}

int rt_sevhistmon::connect()
{
  pwr_tStatus sts;

  for (unsigned int i = 0; i < m_nodes.size(); i++) {
    // Check if this node should be connected
    bool found = false;
    for (unsigned int j = 0; j < m_hs.size(); j++) {
      if (m_hs[j].configerror)
        continue;
      if (str_NoCaseStrcmp(m_nodes[i].name, m_hs[j].nodename) == 0) {
        found = true;
        break;
      }
    }
    if (!found)
      continue;

    m_nodes[i].is_server = 1;

    send_connect(m_nodes[i].nid, &sts);
  }
  return 1;
}

bool rt_sevhistmon::send_connect(pwr_tNid nid, pwr_tStatus* sts)
{
  sev_sMsgAny* msg;
  qcom_sQid tgt;
  qcom_sPut put;
  pwr_tStatus lsts;

  if (plog)
    printf("rt_sevhistmon: Send connect %d\n", nid);

  tgt.nid = nid;
  tgt.qix = sev_eProcSevServer;

  put.reply.nid = m_nodes[0].nid;
  put.reply.qix = sev_eProcSevClient;
  put.type.b = (qcom_eBtype)sev_cMsgClass;
  put.type.s = (qcom_eStype)sev_eMsgType_NodeUp;
  put.msg_id = m_msg_id++;
  put.size = sizeof(*msg);
  msg = (sev_sMsgAny*)qcom_Alloc(&lsts, put.size);
  put.data = msg;
  put.allocate = 0;

  msg->Type = sev_eMsgType_NodeUp;

  if (!qcom_Put(sts, &tgt, &put)) {
    qcom_Free(&lsts, put.data);
  }

  tgt.nid = nid;
  tgt.qix = sev_eProcSevImport;

  put.reply.nid = m_nodes[0].nid;
  put.reply.qix = sev_eProcSevClient;
  put.type.b = (qcom_eBtype)sev_cMsgClass;
  put.type.s = (qcom_eStype)sev_eMsgType_NodeUp;
  put.msg_id = m_msg_id++;
  put.size = sizeof(*msg);
  msg = (sev_sMsgAny*)qcom_Alloc(&lsts, put.size);
  put.data = msg;
  put.allocate = 0;

  msg->Type = sev_eMsgType_NodeUp;

  if (!qcom_Put(sts, &tgt, &put)) {
    qcom_Free(&lsts, put.data);
  }

  return ODD(*sts);
}

bool rt_sevhistmon::send_server_status_request(pwr_tStatus* sts)
{
  int stime;
  float scantime = 30;
  pwr_tStatus send_sts;

  *sts = SEV__SUCCESS;

  stime = int(scantime / m_scantime + 0.5);
  if (!stime || m_loopcnt % stime != 0)
    return false;

  for (unsigned int i = 0; i < m_nodes.size(); i++) {
    if (m_nodes[i].connected) {
      send_server_status_request(m_nodes[i].nid, &send_sts);
      if (EVEN(send_sts))
        *sts = send_sts;
    }
  }
  return true;
}

bool rt_sevhistmon::send_server_status_request(pwr_tNid nid, pwr_tStatus* sts)
{
  sev_sMsgAny* msg;
  qcom_sQid tgt;
  qcom_sPut put;
  pwr_tStatus lsts;

  tgt.nid = nid;
  tgt.qix = sev_eProcSevServer;

  put.reply.nid = m_nodes[0].nid;
  put.reply.qix = sev_eProcSevClient;
  put.type.b = (qcom_eBtype)sev_cMsgClass;
  put.type.s = (qcom_eStype)sev_eMsgType_ServerStatusRequest;
  put.msg_id = m_msg_id++;
  put.size = sizeof(*msg);
  msg = (sev_sMsgAny*)qcom_Alloc(&lsts, put.size);
  put.data = msg;
  put.allocate = 0;

  msg->Type = sev_eMsgType_NodeUp;

  if (!qcom_Put(sts, &tgt, &put)) {
    qcom_Free(&lsts, put.data);
  }

  return ODD(*sts);
}

void rt_sevhistmon::receive_server_status(
    sev_sMsgServerStatus* msg, pwr_tNid nid)
{
  for (unsigned int i = 0; i < m_nodes.size(); i++) {
    if (nid == m_nodes[i].nid) {
      m_nodes[i].status = msg->Status;
      break;
    }
  }
}

int rt_sevhistmon::send_itemlist(pwr_tNid nid)
{
  int item_cnt = 0;
  int attr_cnt = 0;
  int objectitem_cnt = 0;
  qcom_sQid tgt;
  qcom_sPut put;
  pwr_tStatus sts, lsts;
  int size = 0;
  pwr_tAName aname;
  char* s;

  // Identify node
  bool found = false;
  for (unsigned int i = 0; i < m_nodes.size(); i++) {
    if (nid == m_nodes[i].nid) {
      found = true;
      m_nodes[i].connected = 1;
      printf("rt_sevhistmon: node %s connected\n", m_nodes[i].name);
      break;
    }
  }

  int histobjectsize = 0;

  // Count items for this node
  for (unsigned int i = 0; i < m_hs.size(); i++) {
    if (m_hs[i].configerror)
      continue;
    if (nid == m_hs[i].nid) {
      item_cnt += m_hs[i].sevhistlist.size();
      attr_cnt += m_hs[i].sevhistlist.size();
      objectitem_cnt += m_hs[i].sevhistobjectlist.size();
      for (size_t j = 0; j < m_hs[i].sevhistobjectlist.size(); j++) {
        attr_cnt += m_hs[i].sevhistobjectlist[j].sevhistobjectattrlist.size();
        histobjectsize
            += (m_hs[i].sevhistobjectlist[j].sevhistobjectattrlist.size()
                * sizeof(sev_sHistAttr));
      }
    }
  }
  if (m_sevhistevents) {
    item_cnt++;
  }

  if (item_cnt == 0 && objectitem_cnt == 0)
    return 1;

  if (item_cnt != 0) {
    size = sizeof(sev_sMsgHistItems) + (item_cnt - 1) * sizeof(sev_sHistItem);
    size += objectitem_cnt * (sizeof(sev_sHistItem) - sizeof(sev_sHistAttr))
        + histobjectsize;
  } else {
    size += sizeof(sev_sMsgHistItems)
        + (objectitem_cnt - 1) * (sizeof(sev_sHistItem) - sizeof(sev_sHistAttr))
        + histobjectsize;
  }

  put.size = size;
  put.data = qcom_Alloc(&lsts, put.size);
  put.allocate = 0;

  ((sev_sMsgHistItems*)put.data)->Type = sev_eMsgType_HistItems;
  ((sev_sMsgHistItems*)put.data)->Status = SEV__SUCCESS;

  ((sev_sMsgHistItems*)put.data)->NumItems = item_cnt + objectitem_cnt;
  ((sev_sMsgHistItems*)put.data)->NumAttributes = attr_cnt;

  int k = 0;
  for (unsigned int i = 0; i < m_hs.size(); i++) {
    if (m_hs[i].configerror)
      continue;
    if (nid == m_hs[i].nid) {
      for (unsigned int j = 0; j < m_hs[i].sevhistlist.size(); j++) {
        ((sev_sMsgHistItems*)put.data)->Items[k].attrnum = 1;
        ((sev_sMsgHistItems*)put.data)->Items[k].oid
            = m_hs[i].sevhistlist[j].aref.Objid;
        strcpy(aname, m_hs[i].sevhistlist[j].aname);
        s = strchr(aname, '.');
        if (!s)
          continue;
        *s = 0;
        strcpy(((sev_sMsgHistItems*)put.data)->Items[k].oname, aname);
        strcpy(((sev_sMsgHistItems*)put.data)->Items[k].attr[0].aname, s + 1);
        ((sev_sMsgHistItems*)put.data)->Items[k].storagetime
            = net_DeltaTimeToNetTime(&m_hs[i].sevhistlist[j].storagetime);
        ((sev_sMsgHistItems*)put.data)->Items[k].deadband
            = m_hs[i].sevhistlist[j].deadband;
        ((sev_sMsgHistItems*)put.data)->Items[k].options
            = m_hs[i].sevhistlist[j].options;
        ((sev_sMsgHistItems*)put.data)->Items[k].attr[0].type
            = m_hs[i].sevhistlist[j].type;
        ((sev_sMsgHistItems*)put.data)->Items[k].attr[0].size
            = m_hs[i].sevhistlist[j].size;
        ((sev_sMsgHistItems*)put.data)->Items[k].sevid
            = m_hs[i].sevhistlist[j].sevid;
        strncpy(((sev_sMsgHistItems*)put.data)->Items[k].description,
            m_hs[i].sevhistlist[j].description,
            sizeof(((sev_sMsgHistItems*)put.data)->Items[0].description));
        strncpy(((sev_sMsgHistItems*)put.data)->Items[k].attr[0].unit,
            m_hs[i].sevhistlist[j].unit,
            sizeof(((sev_sMsgHistItems*)put.data)->Items[0].attr[0].unit));
        ((sev_sMsgHistItems*)put.data)->Items[k].scantime
            = m_hs[i].sevhistlist[j].scantime;
        k++;
      }
    }
  }

  if (m_sevhistevents) {
    ((sev_sMsgHistItems*)put.data)->Items[k].attrnum = 0;
    ((sev_sMsgHistItems*)put.data)->Items[k].oid = m_sevhistevents->hs_oid;
    strcpy(
        ((sev_sMsgHistItems*)put.data)->Items[k].oname, m_sevhistevents->oname);
    ((sev_sMsgHistItems*)put.data)->Items[k].storagetime
        = net_DeltaTimeToNetTime(&m_sevhistevents->storagetime);
    ((sev_sMsgHistItems*)put.data)->Items[k].deadband = 0;
    ((sev_sMsgHistItems*)put.data)->Items[k].options = m_sevhistevents->options;
    ((sev_sMsgHistItems*)put.data)->Items[k].attr[0].type = (pwr_eType)0;
    ((sev_sMsgHistItems*)put.data)->Items[k].attr[0].size = 0;
    ((sev_sMsgHistItems*)put.data)->Items[k].sevid.nid = m_nodes[0].nid;
    ((sev_sMsgHistItems*)put.data)->Items[k].sevid.rix = 0;
    strncpy(((sev_sMsgHistItems*)put.data)->Items[k].description,
        m_sevhistevents->description,
        sizeof(((sev_sMsgHistItems*)put.data)->Items[0].description));
    strcpy(((sev_sMsgHistItems*)put.data)->Items[k].attr[0].unit, "");
    // Put the table size in scan time. Only used for hdf5 databases.
    ((sev_sMsgHistItems*)put.data)->Items[k].scantime
        = m_sevhistevents->table_size;
    k++;
  }

  // Add the objectitems at the end of the message
  sev_sHistItem* buffP = &((sev_sMsgHistItems*)put.data)->Items[k];
  for (unsigned int i = 0; i < m_hs.size(); i++) {
    if (m_hs[i].configerror)
      continue;
    if (nid == m_hs[i].nid) {
      int numberOfAttributes;
      for (unsigned int j = 0; j < m_hs[i].sevhistobjectlist.size(); j++) {
        buffP->oid = m_hs[i].sevhistobjectlist[j].aref.Objid;
        strcpy(aname, m_hs[i].sevhistobjectlist[j].aname);
        strcpy(buffP->oname, aname);
        buffP->storagetime
            = net_DeltaTimeToNetTime(&m_hs[i].sevhistobjectlist[j].storagetime);
        buffP->deadband = m_hs[i].sevhistobjectlist[j].deadband;
        buffP->options = m_hs[i].sevhistobjectlist[j].options;
        buffP->sevid = m_hs[i].sevhistobjectlist[j].sevid;
        strncpy(buffP->description, m_hs[i].sevhistobjectlist[j].description,
            sizeof(pwr_tString80));
        buffP->scantime = m_hs[i].sevhistobjectlist[j].scantime;
        buffP->attrnum
            = m_hs[i].sevhistobjectlist[j].sevhistobjectattrlist.size();
        for (size_t jj = 0;
             jj < m_hs[i].sevhistobjectlist[j].sevhistobjectattrlist.size();
             jj++) {
          strcpy(aname,
              m_hs[i].sevhistobjectlist[j].sevhistobjectattrlist[jj].aname);
          // Point out attribute name
          s = strchr(aname, '.');
          if (!s)
            continue;
          *s = 0;
          strcpy(buffP->attr[jj].aname, s + 1);
          buffP->attr[jj].type
              = m_hs[i].sevhistobjectlist[j].sevhistobjectattrlist[jj].type;
          buffP->attr[jj].size
              = m_hs[i].sevhistobjectlist[j].sevhistobjectattrlist[jj].size;
          strncpy(buffP->attr[jj].unit,
              m_hs[i].sevhistobjectlist[j].sevhistobjectattrlist[jj].unit,
              sizeof(pwr_tString16));
        }
        numberOfAttributes = buffP->attrnum;
        // buffP points after the last attribute written
        buffP = (sev_sHistItem*)&buffP->attr[numberOfAttributes];
      }
    }
  }

  tgt.nid = nid;
  tgt.qix = sev_eProcSevServer;

  put.reply.nid = m_nodes[0].nid;
  put.reply.qix = sev_eProcSevClient;
  put.type.b = (qcom_eBtype)sev_cMsgClass;
  put.type.s = (qcom_eStype)sev_eMsgType_HistItems;
  put.msg_id = m_msg_id++;

  if (!qcom_Put(&sts, &tgt, &put)) {
    printf("rt_sevhistmon: ItemList send ERROR sts:%d\n", sts);
    qcom_Free(&sts, put.data);
    return 0;
  }

  // If all nodes are connected, set running status
  if (!m_allconnected) {
    bool all_conn = true;
    for (unsigned int i = 0; i < m_nodes.size(); i++) {
      printf("Sev %s %d %d\n", m_nodes[i].name, m_nodes[i].is_server,
          m_nodes[i].connected);
      if (m_nodes[i].is_server && !m_nodes[i].connected) {
        all_conn = false;
        break;
      }
    }
    if (all_conn) {
      m_allconnected = 1;
      m_server_status = PWR__SRUN;
      set_status();
    }
  }
  printf("rt_sevhistmon: ItemList sent\n");
  return 1;
}

int rt_sevhistmon::send_exportitemlist(pwr_tNid nid)
{
  int item_cnt = 0;
  int attr_cnt = 0;
  qcom_sQid tgt;
  qcom_sPut put;
  pwr_tStatus sts, lsts;
  int size = 0;
  pwr_tAName aname;
  char* s;

  // Identify node
  bool found = false;
  for (unsigned int i = 0; i < m_nodes.size(); i++) {
    if (nid == m_nodes[i].nid) {
      found = true;
      m_nodes[i].connected = 1;
      printf("rt_sevhistmon: node %s connected\n", m_nodes[i].name);
      break;
    }
  }

  // Count items for this node
  for (unsigned int i = 0; i < m_hs.size(); i++) {
    if (m_hs[i].configerror)
      continue;
    if (nid == m_hs[i].nid) {
      item_cnt += m_hs[i].sevexportlist.size();
      attr_cnt += m_hs[i].sevexportlist.size();
    }
  }

  if (item_cnt == 0)
    return 1;

  size = sizeof(sev_sMsgExportItems) + (item_cnt - 1) * sizeof(sev_sExportItem);

  put.size = size;
  put.data = qcom_Alloc(&lsts, put.size);
  put.allocate = 0;

  ((sev_sMsgExportItems*)put.data)->Type = sev_eMsgType_ExportItems;
  ((sev_sMsgExportItems*)put.data)->Status = SEV__SUCCESS;

  ((sev_sMsgExportItems*)put.data)->NumItems = item_cnt;

  int k = 0;
  for (unsigned int i = 0; i < m_hs.size(); i++) {
    if (m_hs[i].configerror)
      continue;
    if (nid == m_hs[i].nid) {
      for (unsigned int j = 0; j < m_hs[i].sevexportlist.size(); j++) {
        ((sev_sMsgExportItems*)put.data)->Items[k].oid
            = m_hs[i].sevexportlist[j].aref.Objid;
        strcpy(aname, m_hs[i].sevexportlist[j].aname);
        s = strchr(aname, '.');
        if (!s)
          continue;
        *s = 0;
        strcpy(((sev_sMsgExportItems*)put.data)->Items[k].oname, aname);
        strcpy(((sev_sMsgExportItems*)put.data)->Items[k].aname, s + 1);
        ((sev_sMsgExportItems*)put.data)->Items[k].options
            = m_hs[i].sevexportlist[j].options;
        ((sev_sMsgExportItems*)put.data)->Items[k].type
            = m_hs[i].sevexportlist[j].type;
        ((sev_sMsgExportItems*)put.data)->Items[k].size
            = m_hs[i].sevexportlist[j].size;
        ((sev_sMsgExportItems*)put.data)->Items[k].sevid
            = m_hs[i].sevexportlist[j].sevid;
        strncpy(((sev_sMsgExportItems*)put.data)->Items[k].description,
            m_hs[i].sevexportlist[j].description,
            sizeof(((sev_sMsgExportItems*)put.data)->Items[0].description));
        ((sev_sMsgExportItems*)put.data)->Items[k].scantime
            = m_hs[i].sevexportlist[j].scantime;
        k++;
      }
    }
  }

  tgt.nid = nid;
  tgt.qix = sev_eProcSevImport;

  put.reply.nid = m_nodes[0].nid;
  put.reply.qix = sev_eProcSevClient;
  put.type.b = (qcom_eBtype)sev_cMsgClass;
  put.type.s = (qcom_eStype)sev_eMsgType_ExportItems;
  put.msg_id = m_msg_id++;

  if (!qcom_Put(&sts, &tgt, &put)) {
    printf("rt_sevhistmon: ExportItemList send ERROR sts:%d\n", sts);
    qcom_Free(&sts, put.data);
    return 0;
  }

  // If all nodes are connected, set running status
  if (!m_allconnected) {
    bool all_conn = true;
    for (unsigned int i = 0; i < m_nodes.size(); i++) {
      printf("Sev %s %d %d\n", m_nodes[i].name, m_nodes[i].is_server,
          m_nodes[i].connected);
      if (m_nodes[i].is_server && !m_nodes[i].connected) {
        all_conn = false;
        break;
      }
    }
    if (all_conn) {
      m_allconnected = 1;
      m_server_status = PWR__SRUN;
      set_status();
    }
  }
  printf("rt_sevhistmon: ExportItemList sent\n");
  return 1;
}

pwr_tStatus rt_sevhistmon::mh_ack_bc(mh_sAck* msg)
{
  sev_sEvent ed;

  ed.type = msg->Info.EventType;
  ed.time = msg->Info.EventTime;
  strcpy(ed.eventtext, "");
  strncpy(ed.eventname, msg->EventName, sizeof(ed.eventname));
  ed.eventprio = msg->Info.EventPrio;
  ed.eventid_idx = msg->Info.Id.Idx;
  ed.eventid_nix = msg->Info.Id.Nix;
  ed.eventid_birthtime = msg->Info.Id.BirthTime.tv_sec;
  ed.sup_aref_vid = msg->SupObject.Objid.vid;
  ed.sup_aref_oix = msg->SupObject.Objid.oix;
  ed.sup_aref_offset = msg->SupObject.Offset;
  ed.sup_aref_size = msg->SupObject.Size;
  ed.eventstatus = 0;

  if (shm->m_sevhistevents)
    shm->m_sevhistevents->evbuf_insert(&ed);
  return 1;
}

pwr_tStatus rt_sevhistmon::mh_return_bc(mh_sReturn* msg)
{
  sev_sEvent ed;

  ed.type = msg->Info.EventType;
  ed.time = msg->Info.EventTime;
  strncpy(ed.eventtext, msg->EventText, sizeof(ed.eventtext));
  strncpy(ed.eventname, msg->EventName, sizeof(ed.eventname));
  ed.eventprio = msg->Info.EventPrio;
  ed.eventid_idx = msg->Info.Id.Idx;
  ed.eventid_nix = msg->Info.Id.Nix;
  ed.eventid_birthtime = msg->Info.Id.BirthTime.tv_sec;
  ed.sup_aref_vid = msg->SupObject.Objid.vid;
  ed.sup_aref_oix = msg->SupObject.Objid.oix;
  ed.sup_aref_offset = msg->SupObject.Offset;
  ed.sup_aref_size = msg->SupObject.Size;
  ed.eventstatus = 0;

  if (shm->m_sevhistevents)
    shm->m_sevhistevents->evbuf_insert(&ed);

  return 1;
}

pwr_tStatus rt_sevhistmon::mh_alarm_bc(mh_sMessage* msg)
{
  sev_sEvent ed;

  ed.type = msg->Info.EventType;
  ed.time = msg->Info.EventTime;
  strncpy(ed.eventtext, msg->EventText, sizeof(ed.eventtext));
  strncpy(ed.eventname, msg->EventName, sizeof(ed.eventname));
  ed.eventprio = msg->Info.EventPrio;
  ed.eventid_idx = msg->Info.Id.Idx;
  ed.eventid_nix = msg->Info.Id.Nix;
  ed.eventid_birthtime = msg->Info.Id.BirthTime.tv_sec;
  ed.sup_aref_vid = msg->SupObject.Objid.vid;
  ed.sup_aref_oix = msg->SupObject.Objid.oix;
  ed.sup_aref_offset = msg->SupObject.Offset;
  ed.sup_aref_size = msg->SupObject.Size;
  ed.eventstatus = msg->Status;

  printf("alarm_bc, %u\n", msg->Status);
  if (shm->m_sevhistevents)
    shm->m_sevhistevents->evbuf_insert(&ed);

  return 1;
}

pwr_tStatus rt_sevhistmon::mh_block_bc(mh_sBlock* msg)
{
  sev_sEvent ed;

  ed.type = msg->Info.EventType;
  ed.time = msg->Info.EventTime;
  strcpy(ed.eventtext, "");
  strncpy(ed.eventname, msg->EventName, sizeof(ed.eventname));
  ed.eventprio = msg->Info.EventPrio;
  ed.eventid_idx = msg->Info.Id.Idx;
  ed.eventid_nix = msg->Info.Id.Nix;
  ed.eventid_birthtime = msg->Info.Id.BirthTime.tv_sec;
  ed.sup_aref_vid = msg->SupObject.Objid.vid;
  ed.sup_aref_oix = msg->SupObject.Objid.oix;
  ed.sup_aref_offset = msg->SupObject.Offset;
  ed.sup_aref_size = msg->SupObject.Size;
  ed.eventstatus = 0;

  if (shm->m_sevhistevents)
    shm->m_sevhistevents->evbuf_insert(&ed);

  return 1;
}

pwr_tStatus rt_sevhistmon::mh_cancel_bc(mh_sReturn* msg)
{
  sev_sEvent ed;

  ed.type = msg->Info.EventType;
  ed.time = msg->Info.EventTime;
  strcpy(ed.eventtext, "");
  strncpy(ed.eventname, msg->EventName, sizeof(ed.eventname));
  ed.eventprio = msg->Info.EventPrio;
  ed.eventid_idx = msg->Info.Id.Idx;
  ed.eventid_nix = msg->Info.Id.Nix;
  ed.eventid_birthtime = msg->Info.Id.BirthTime.tv_sec;
  ed.sup_aref_vid = msg->SupObject.Objid.vid;
  ed.sup_aref_oix = msg->SupObject.Objid.oix;
  ed.sup_aref_offset = msg->SupObject.Offset;
  ed.sup_aref_size = msg->SupObject.Size;
  ed.eventstatus = 0;

  if (shm->m_sevhistevents)
    shm->m_sevhistevents->evbuf_insert(&ed);

  return 1;
}

pwr_tStatus rt_sevhistmon::mh_info_bc(mh_sMessage* msg)
{
  sev_sEvent ed;

  ed.type = msg->Info.EventType;
  ed.time = msg->Info.EventTime;
  strncpy(ed.eventtext, msg->EventText, sizeof(ed.eventtext));
  strncpy(ed.eventname, msg->EventName, sizeof(ed.eventname));
  ed.eventprio = msg->Info.EventPrio;
  ed.eventid_idx = msg->Info.Id.Idx;
  ed.eventid_nix = msg->Info.Id.Nix;
  ed.eventid_birthtime = msg->Info.Id.BirthTime.tv_sec;
  ed.sup_aref_vid = msg->SupObject.Objid.vid;
  ed.sup_aref_oix = msg->SupObject.Objid.oix;
  ed.sup_aref_offset = msg->SupObject.Offset;
  ed.sup_aref_size = msg->SupObject.Size;
  ed.eventstatus = 0;

  if (shm->m_sevhistevents)
    shm->m_sevhistevents->evbuf_insert(&ed);

  return 1;
}

pwr_tStatus rt_sevhistmon::mh_clear_alarmlist_bc(pwr_tNodeIndex nix)
{
  pwr_tStatus sts;
  sev_sEvent ed;
  gdh_sNodeInfo info;
  pwr_tTime current_time;

  sts = gdh_GetNodeInfo(nix, &info);
  time_GetTime(&current_time);

  memset(&ed, 0, sizeof(ed));
  ed.type = sev_eEvent_ClearAlarmList;
  ed.time = net_TimeToNetTime(&current_time);
  ed.sup_aref_vid = info.nix;
  strncpy(ed.eventname, info.nodename, sizeof(ed.eventname));

  if (shm->m_sevhistevents)
    shm->m_sevhistevents->evbuf_insert(&ed);
  return 1;
}

pwr_tStatus rt_sevhistmon::mh_clear_blocklist_bc(pwr_tNodeIndex nix)
{
  return 1;
}

void sev_sevhistevents::evbuf_insert(sev_sEvent* ev)
{
  // Check if event already exist
  if (evbuf_last != ev_cInit) {
    for (unsigned int idx = evbuf_last;;) {
      if (event_buffer[idx].eventid_idx == ev->eventid_idx
          && event_buffer[idx].eventid_nix == ev->eventid_nix
          && event_buffer[idx].eventid_birthtime == ev->eventid_birthtime) {
        return;
      }
      if (idx == evbuf_oldest)
        break;
      evbuf_previous_idx(idx);
    }
  }

  if (evbuf_last == ev_cInit) {
    // First insert
    evbuf_last = 0;
    evbuf_oldest = 0;
    memcpy(&event_buffer[evbuf_last], ev, sizeof(event_buffer[0]));
  } else {
    unsigned int idx = evbuf_last;
    evbuf_next_idx(idx);
    if (idx == evbuf_oldest
        && ((evbuf_sent == evbuf_oldest) || evbuf_sent == ev_cInit))
      evbuf_send();

    evbuf_next_idx(evbuf_last);
    if (evbuf_oldest == evbuf_last) {
      evbuf_next_idx(evbuf_oldest);
    }
    memcpy(&event_buffer[evbuf_last], ev, sizeof(event_buffer[0]));
  }
}

void sev_sevhistevents::evbuf_send()
{
  if (evbuf_last == ev_cInit)
    return;

  unsigned int num;
  if (evbuf_sent == ev_cInit) {
    if (evbuf_oldest <= evbuf_last)
      num = evbuf_last - evbuf_oldest + 1;
    else
      num = sizeof(event_buffer) / sizeof(event_buffer[0]) + evbuf_last
          - evbuf_oldest + 1;
  } else {
    if (evbuf_sent <= evbuf_last)
      num = evbuf_last - evbuf_sent;
    else
      num = sizeof(event_buffer) / sizeof(event_buffer[0]) + evbuf_last
          - evbuf_sent;
  }
  if (!num)
    return;

  pwr_tStatus sts;
  qcom_sPut put;
  qcom_sQid tgt;

  put.size = sizeof(sev_sMsgEventsStore) + (num - 1) * sizeof(sev_sEvent);
  put.data = qcom_Alloc(&sts, put.size);
  put.allocate = 0;

  ((sev_sMsgEventsStore*)put.data)->Type = sev_eMsgType_EventsStore;
  ((sev_sMsgEventsStore*)put.data)->Version = sev_cNetVersion;
  ((sev_sMsgEventsStore*)put.data)->Oid = monitor->m_sevhistevents->hs_oid;
  ((sev_sMsgEventsStore*)put.data)->NumEvents = num;
  ((sev_sMsgEventsStore*)put.data)->NumEvents = num;

  unsigned int ev_cnt = 0;
  if (evbuf_sent == ev_cInit) {
    for (unsigned int idx = evbuf_oldest;;) {
      printf("evbuf_send, %u\n", event_buffer[idx].eventstatus);
      memcpy(&((sev_sMsgEventsStore*)put.data)->Events[ev_cnt],
          &event_buffer[idx], sizeof(sev_sEvent));
      ev_cnt++;
      evbuf_sent = idx;
      if (idx == evbuf_last)
        break;
      evbuf_next_idx(idx);
    }
  } else if (evbuf_sent != evbuf_last) {
    unsigned int start_idx = evbuf_sent;
    evbuf_next_idx(start_idx);
    for (unsigned int idx = start_idx;;) {
      memcpy(&((sev_sMsgEventsStore*)put.data)->Events[ev_cnt],
          &event_buffer[idx], sizeof(sev_sEvent));
      ev_cnt++;
      evbuf_sent = idx;
      if (idx == evbuf_last)
        break;
      evbuf_next_idx(idx);
    }
  }

  tgt.nid = monitor->m_hs[event_thread_idx].nid;
  tgt.qix = sev_eProcSevServer;

  put.reply.nid = monitor->m_nodes[0].nid;
  put.reply.qix = sev_eProcSevClient;
  put.type.b = (qcom_eBtype)sev_cMsgClass;
  put.type.s = (qcom_eStype)sev_eMsgType_EventsStore;
  put.msg_id = monitor->m_msg_id++;

  if (!qcom_Put(&sts, &tgt, &put)) {
    monitor->m_hs[event_thread_idx].threadp->ErrorCount++;
    if (sts == QCOM__NOQ)
      monitor->m_hs[event_thread_idx].threadp->Status = SEV__EVENTSQ;
    else
      monitor->m_hs[event_thread_idx].threadp->Status = sts;
    qcom_Free(&sts, put.data);
  }
  monitor->m_hs[event_thread_idx].threadp->SendCount++;
  monitor->m_hs[event_thread_idx].threadp->Status = sts;
}

int rt_sevhistmon::init_events()
{
  pwr_tOid he_oid;
  pwr_tStatus sts;
  pwr_tOName oname;
  int he_cnt = 0;

  // Get SevHistEvents objects
  for (sts = gdh_GetClassList(pwr_cClass_SevHistEvents, &he_oid); ODD(sts);
       sts = gdh_GetNextObject(he_oid, &he_oid)) {
    he_cnt++;

    sts = gdh_ObjidToName(he_oid, oname, sizeof(oname), cdh_mName_volumeStrict);
    if (EVEN(m_sts))
      throw co_error(m_sts);

    if (he_cnt > 1) {
      errh_Error("SevHistEvents object ignored, %s", oname);
      continue;
    }

    sev_sevhistevents* h = new sev_sevhistevents(this);
    int hs_idx;

    pwr_tAttrRef aref = cdh_ObjidToAref(he_oid);

    sts = gdh_DLRefObjectInfoAttrref(&aref, (void**)&h->hsp, &h->hs_refid);
    if (EVEN(sts))
      throw co_error(sts);

    hs_idx = -1;
    for (int i = 0; i < (int)m_hs.size(); i++) {
      if (cdh_ObjidIsEqual(h->hsp->ThreadObject, m_hs[i].oid)) {
        hs_idx = i;
        break;
      }
    }
    if (hs_idx == -1) {
      errh_Error("Invalid thread object in SevHistEvents, %s", oname);
      continue;
    }

    h->storagetime = h->hsp->StorageTime;
    h->options = h->hsp->Options;
    h->table_size = h->hsp->TableSize;
    strcpy(h->description, h->hsp->Description);
    h->disabled = h->hsp->Disable;
    h->event_thread_idx = hs_idx;
    h->hs_oid = he_oid;
    strcpy(h->oname, oname);

    m_hs[hs_idx].threadp->NoOfItems++;

    // Wait for mh has flagged initizated
    mh_UtilWaitForMh();

    sts = mh_OutunitConnect(he_oid, mh_eOutunitType_SevHistEvents, 0, mh_ack_bc,
        mh_alarm_bc, mh_block_bc, mh_cancel_bc, mh_clear_alarmlist_bc,
        mh_clear_blocklist_bc, mh_info_bc, mh_return_bc, 0);
    if (EVEN(sts))
      return sts;

    m_sevhistevents = h;
  }

  return 1;
}

int rt_sevhistmon::mainloop()
{
  qcom_sQid qid;
  int tmo = int(1000 * m_scantime);
  qcom_sGet get;
  void* mp;
  pwr_tStatus sts;

  qid.nid = 0;
  qid.qix = sev_eProcSevClient;

  shm = this;

  for (;;) {
    memset(&get, 0, sizeof(get));
    mp = qcom_Get(&sts, &qid, &get, tmo);
    if (sts == QCOM__TMO || !mp) {
      m_loopcnt++;
      send_data();
      send_exportdata();
      send_server_status_request(&sts);

      if (!m_allconnected) {
        int reconnect_time = int(20.0 / m_scantime);

        if (m_loopcnt % reconnect_time == 0)
          retry_connect();
      }
      aproc_TimeStamp(m_scantime, 5);

      if (m_sevhistevents) {
        sts = mh_OutunitReceive();
        while (ODD(sts))
          sts = mh_OutunitReceive();

        m_sevhistevents->evbuf_send();
      }

      continue;
    }

    switch ((int)get.type.b) {
    case sev_cMsgClass:
      switch ((int)get.type.s) {
      case sev_eMsgType_NodeUp:
	if (plog)
	  printf("rt_sevhistmon: Node up received\n");
        send_itemlist(get.sender.nid);
        break;
      case sev_eMsgType_ExportNodeUp:
	if (plog)
	  printf("rt_sevhistmon: Export node up received\n");
        send_exportitemlist(get.sender.nid);
        break;
      case sev_eMsgType_HistItemsRequest:
	if (plog)
	  printf("rt_sevhistmon: Export histitems request received\n");
        send_itemlist(get.sender.nid);
        break;
      case sev_eMsgType_ExportItemsRequest:
        send_exportitemlist(get.sender.nid);
        break;
      case sev_eMsgType_ServerStatus:
        receive_server_status((sev_sMsgServerStatus*)mp, get.sender.nid);
        break;
      default:;
      }
      break;
    case qcom_eBtype_event: {
      ini_mEvent new_event;
      qcom_sEvent* ep = (qcom_sEvent*)get.data;

      new_event.m = ep->mask;
      if (new_event.b.oldPlcStop && !m_swap) {
        m_swap = 1;
        errh_SetStatus(PWR__SRVRESTART);
        m_confp->Status = PWR__SRVRESTART;
        close();
      } else if (new_event.b.swapDone && m_swap) {
        m_swap = 0;
        try {
          init_objects();
          connect();
        } catch (co_error& e) {
          errh_Error("SevHistMonitor terminating, %m", e.sts());
          exit(0);
        }
        errh_SetStatus(PWR__SRUN);
        m_confp->Status = PWR__SRUN;
        errh_Info("Warm restart completed");
      } else if (new_event.b.terminate) {
        m_confp->Status = PWR__SRVTERM;
        exit(0);
      }
      break;
    }
    default:;
    }

    qcom_Free(&sts, mp);
  }
}

int main()
{
  rt_sevhistmon client;

  try {
    client.init();
    client.connect();
  } catch (co_error& e) {
    errh_Error("SevHistMonitor terminating, %m", e.sts());
    exit(0);
  }

  client.mainloop();

  client.close();
}
