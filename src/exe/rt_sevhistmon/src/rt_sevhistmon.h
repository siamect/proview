/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#ifndef rt_sevhistmon_h
#define rt_sevhistmon_h

#include <vector>

#include "pwr_class.h"

#define ev_cInit 0xFFFF

class rt_sevhistmon;

class sev_sevhist {
  public:
  pwr_tAttrRef aref;
  pwr_tAName aname;
  pwr_sClass_SevHist* hsp;
  pwr_tRefId hs_refid;
  pwr_tRefId refid;
  void* datap;
  pwr_tDeltaTime storagetime;
  pwr_tFloat32 deadband;
  pwr_tMask options;
  pwr_eType type;
  unsigned int size;
  pwr_tRefId sevid;
  pwr_tString80 description;
  pwr_tString16 unit;
  pwr_tFloat32 scantime;
  pwr_tBoolean disabled;
};

class sev_sevexport {
  public:
  pwr_tAttrRef aref;
  pwr_tAName aname;
  pwr_sClass_SevExport* hsp;
  pwr_tRefId hs_refid;
  pwr_tRefId refid;
  void* datap;
  pwr_tMask options;
  pwr_eType type;
  unsigned int size;
  pwr_tRefId sevid;
  pwr_tString80 description;
  pwr_tFloat32 scantime;
  pwr_tBoolean disabled;
  sev_sevexport() {}
  sev_sevexport(const sev_sevexport& x) : aref(x.aref), hsp(x.hsp), hs_refid(x.hs_refid),
    refid(x.refid), datap(x.datap), options(x.options), type(x.type), size(x.size),
    sevid(x.sevid), scantime(x.scantime), disabled(x.disabled) { 
    strcpy(aname, x.aname); 
    strcpy( description, x.description);
  }
};

class sev_sevhistevents {
  public:
  sev_sevhistevents(rt_sevhistmon* m)
      : event_thread_idx(0), evbuf_oldest(ev_cInit), evbuf_last(ev_cInit),
        evbuf_sent(ev_cInit), monitor(m)
  {
  }

  pwr_sClass_SevHistEvents* hsp;
  pwr_tString80 description;
  pwr_tOid hs_oid;
  pwr_tRefId hs_refid;
  pwr_tDeltaTime storagetime;
  pwr_tMask options;
  pwr_tUInt32 table_size;
  pwr_tBoolean disabled;
  unsigned int event_thread_idx;
  sev_sEvent event_buffer[20];
  unsigned int evbuf_oldest;
  unsigned int evbuf_last;
  unsigned int evbuf_sent;
  rt_sevhistmon* monitor;
  pwr_tOName oname;

  void evbuf_insert(sev_sEvent* ev);
  void evbuf_send();
};

class sev_sevhistobjectattr {
  public:
  pwr_tAttrRef aref;
  pwr_tString80 description;
  pwr_tString16 unit;
  pwr_tAName aname;
  pwr_tRefId refid;
  void* datap;
  pwr_eType type;
  unsigned int size;
};

class sev_sevhistobject {
  public:
  pwr_tAttrRef aref;
  pwr_tAName aname;
  pwr_sClass_SevHistObject* hsp;
  pwr_tRefId hs_refid;
  pwr_tDeltaTime storagetime;
  pwr_tFloat32 deadband;
  pwr_tMask options;
  pwr_tRefId sevid;
  pwr_tString80 description;
  pwr_tFloat32 scantime;
  unsigned int datasize;
  pwr_tBoolean disabled;
  std::vector<sev_sevhistobjectattr> sevhistobjectattrlist;
};

class sev_sevhistthread {
  public:
  sev_sevhistthread() : configerror(0)
  {
  }
  pwr_tOid oid;
  pwr_tFloat32 scantime;
  char nodename[80];
  pwr_tNid nid;
  unsigned int size;
  pwr_sClass_SevHistThread* threadp;
  pwr_tRefId refid;
  int configerror;
  std::vector<sev_sevhist> sevhistlist;
  std::vector<sev_sevhistobject> sevhistobjectlist;
  std::vector<sev_sevexport> sevexportlist;
};

class sev_node {
  public:
  sev_node() : is_server(0), connected(0), ctime(0), status(0)
  {
  }
  pwr_tNid nid;
  char name[80];
  int is_server;
  int connected;
  double ctime;
  pwr_tStatus status;
};

class rt_sevhistmon {
  public:
  rt_sevhistmon()
      : m_msg_id(0), m_next_rix(0), m_loopcnt(0), m_allconnected(0),
        m_server_status(0), m_swap(0), m_sevhistevents(0)
  {
  }

  pwr_tStatus m_sts;
  std::vector<sev_sevhistthread> m_hs;
  std::vector<sev_node> m_nodes;
  unsigned int m_msg_id;
  unsigned int m_next_rix;
  unsigned int m_loopcnt;
  float m_scantime;
  pwr_sClass_SevHistMonitor* m_confp;
  pwr_tOid m_confoid;
  pwr_tRefId m_conf_refid;
  int m_allconnected;
  pwr_tStatus m_server_status;
  int m_swap;
  sev_sevhistevents* m_sevhistevents;

  int init();
  int init_objects();
  int init_sevhistobjects();
  int init_events();
  int init_sevexport();
  void insert_sevhistobjectattr(pwr_sAttrRef* aref, pwr_tAName objectname,
      int hs_idx, std::vector<sev_sevhistobjectattr>* listP);
  int get_sevhistobjectattributes(pwr_tAName objectname,
      std::vector<sev_sevhistobjectattr>* listP, int hs_idx,
      pwr_tBoolean first);
  bool correct_histtype(const pwr_eType type);
  bool correct_exporttype(const pwr_eType type);
  int close();
  int close_objects();
  int mainloop();
  void set_status();
  int connect();
  int retry_connect();
  bool send_connect(pwr_tNid nid, pwr_tStatus* sts);
  bool send_server_status_request(pwr_tStatus* sts);
  bool send_server_status_request(pwr_tNid nid, pwr_tStatus* sts);
  void receive_server_status(sev_sMsgServerStatus* msg, pwr_tNid nid);
  int send_itemlist(pwr_tNid nid);
  int send_data();
  int send_exportitemlist(pwr_tNid nid);
  int send_exportdata();
  void evbuf_insert(sev_sEvent* ev);
  void evbuf_send();
  static pwr_tStatus mh_ack_bc(mh_sAck* MsgP);
  static pwr_tStatus mh_return_bc(mh_sReturn* MsgP);
  static pwr_tStatus mh_alarm_bc(mh_sMessage* MsgP);
  static pwr_tStatus mh_block_bc(mh_sBlock* MsgP);
  static pwr_tStatus mh_cancel_bc(mh_sReturn* MsgP);
  static pwr_tStatus mh_info_bc(mh_sMessage* MsgP);
  static pwr_tStatus mh_clear_alarmlist_bc(pwr_tNodeIndex nix);
  static pwr_tStatus mh_clear_blocklist_bc(pwr_tNodeIndex nix);
};
#endif
