/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

/* rt_io_comm.c -- io handler */

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "pwr.h"
#include "co_time.h"
#include "co_cdh.h"
#include "rt_gdh.h"
#include "pwr_baseclasses.h"
#include "rt_io_base.h"
#include "rt_plc_utl.h"
#include "rt_errh.h"
#include "rt_csup.h"
#include "rt_qcom.h"
#include "rt_aproc.h"
#include "rt_qcom_msg.h"
#include "rt_ini_event.h"
#include "rt_pwr_msg.h"

static pwr_sClass_IOHandler *init (qcom_sQid *qid, lst_sEntry **csup_lh, pwr_sNode **nodep, io_mProcess process, errh_eAnix errh_anix, char *oname, float *cycletime);

static void usage()
{
  printf( "\n\n\
rt_io_comm     I/O Communication program\n\
\n\
     -m        Print loaded I/O methods\n\
     -p        Optional process, IoComm, User, User2, User3 or User4.\n\
     -a        Optional errh anix. A value between 61 and 80. Only if process is specified.\n\
     -o        Optional application object. Only if process is specified.\n\
     -c        Optional cycle time in seconds. Only if process is specified.\n\
\n");
}

int main (int argc, char **argv)
{
  pwr_tStatus sts = 1;
  io_tCtx io_ctx;
  io_tCtx io_ctx_swap;
  pwr_sClass_IOHandler *ihp;
  int swap_io;
  int close_io;
  int init_io;
  qcom_sQid qid = qcom_cNQid;
  int tmo;
  char mp[2000];
  qcom_sGet get;
  pwr_tTime now;
  pwr_tTime next;
  pwr_tTime after;
  pwr_tDeltaTime cycle;
  lst_sEntry *csup_lh;
  int delay_action = 0;
  pwr_sNode *nodep;
  pwr_tBoolean old_emergency_break = 0;
  io_mProcess process = io_mProcess_IoComm;
  errh_eAnix errh_anix = errh_eAnix_io;
  pwr_tOName oname = "";
  int i;
  float cycletime = 0;

  for ( i = 1; i < argc; i++) {
    if ( strcmp( argv[i], "-m") == 0) {
      io_methods_print();
      exit(0);
    }
    else if ( strcmp( argv[i], "-h") == 0) {
      usage();
      exit(0);
    }
    else if ( strcmp( argv[i], "-p") == 0) {
      if ( argc <= i+1) {
	usage();
	exit(0);
      }
      if ( cdh_NoCaseStrcmp( argv[i+1], "iocomm") == 0)
	process = io_mProcess_IoComm;
      else if ( cdh_NoCaseStrcmp( argv[i+1], "user") == 0)
	process = io_mProcess_User;
      else if ( cdh_NoCaseStrcmp( argv[i+1], "user2") == 0)
	process = io_mProcess_User2;
      else if ( cdh_NoCaseStrcmp( argv[i+1], "user3") == 0)
	process = io_mProcess_User3;
      else if ( cdh_NoCaseStrcmp( argv[i+1], "user4") == 0)
	process = io_mProcess_User4;
      else {
	usage();
	exit(0);
      }
      i++;
    }
    else if ( strcmp( argv[i], "-a") == 0) {
      if ( argc <= i+1) {
	usage();
	exit(0);
      }
      sts = sscanf( argv[i+1], "%d", (int *)&errh_anix);
      if ( sts != 1 || errh_anix < errh_eAnix_appl1 || errh_anix > errh_eAnix_appl20) {
	usage();
	exit(0);
      }
      i++;
    }
    else if ( strcmp( argv[i], "-c") == 0) {
      if ( argc <= i+1) {
	usage();
	exit(0);
      }
      sts = sscanf( argv[i+1], "%f", &cycletime);
      if ( sts != 1) {
	usage();
	exit(0);
      }
      i++;
    }
    else if ( strcmp( argv[i], "-o") == 0) {
      if ( argc <= i+1) {
	usage();
	exit(0);
      }
      strncpy( oname, argv[i+1], sizeof(oname));
      i++;
    }
  }

  ihp = init(&qid, &csup_lh, &nodep, process, errh_anix, oname, &cycletime);

  plc_UtlWaitForPlc();

  /* Prepare the swap context */
  sts = io_init_swap(process, pwr_cNObjid, &io_ctx_swap, 1, cycletime);

  for (close_io = swap_io = 0, init_io = 1;;) {

    if (init_io) {
      double f;
      
      sts = io_init(process, pwr_cNObjid, &io_ctx, 1, cycletime);
      if ( ODD(sts)) 
	errh_SetStatus( PWR__SRUN);
      init_io = 0;
      tmo = cycletime * 1000.;
      f = floor(cycletime);
      cycle.tv_sec = f;
      cycle.tv_nsec = (cycletime - f) * 1.0e9;
      cycle.tv_nsec++;
      time_GetTimeMonotonic(&next);
      time_Aadd(NULL, &next, &cycle);
    }

    get.maxSize = sizeof(mp);
    get.data = mp;
    qcom_Get(&sts,&qid, &get, tmo);
    if (sts == QCOM__TMO || sts == QCOM__QEMPTY) {

      if ( nodep->EmergBreakTrue && !old_emergency_break)
        sts = io_swap(io_ctx_swap, io_eEvent_IoCommEmergencyBreak);

      sts = io_read(io_ctx);
      if (EVEN(sts)) {
	ihp->IOReadWriteFlag = FALSE;
	errh_Error("IO read, %m", sts);
      }
      sts = io_write(io_ctx);
      if (EVEN(sts)) {
	ihp->IOReadWriteFlag = FALSE;
	errh_Error("IO write, %m", sts);
      }

      if ( nodep->EmergBreakTrue && !old_emergency_break)
        sts = io_swap(io_ctx, io_eEvent_EmergencyBreak);
      old_emergency_break = nodep->EmergBreakTrue;

      if (swap_io) 
      {
        sts = io_swap(io_ctx_swap, io_eEvent_IoCommSwap);
      }
      io_ScanSupLst( io_ctx->SupCtx);

      time_GetTime(&now);
      time_GetTimeMonotonic(&after);
      next = after;
      time_Aadd(NULL, &next, &cycle);
      delay_action = csup_Exec(&sts, csup_lh, (pwr_tDeltaTime *) &next,
                            (pwr_tDeltaTime *) &after, &now);
      if (delay_action == 2)
	ihp->IOReadWriteFlag = FALSE;

      aproc_TimeStamp(cycletime, 5);
    } else {
      ini_mEvent  new_event;
      qcom_sEvent *ep = (qcom_sEvent*) get.data;

      new_event.m  = ep->mask;
      if (new_event.b.oldPlcStop && !swap_io) {
        swap_io = 1;
	close_io = 1;
	errh_SetStatus(PWR__SRVRESTART);
      } else if (new_event.b.swapDone && swap_io) {
        swap_io = 0;
	init_io = 1;
      } else if (new_event.b.terminate) {
        exit(0);
      }
      if (close_io) {    
	io_close(io_ctx);
	close_io = 0;
      }
    }
  }
}

static pwr_sClass_IOHandler *
init (qcom_sQid *qid, lst_sEntry **csup_lh, pwr_sNode **nodep, io_mProcess process, errh_eAnix errh_anix,
      char *oname, float *cycletime)
{
  pwr_tStatus sts = 1;
  pwr_sClass_IOHandler *ihp;
  qcom_sQattr qAttr;
  qcom_sQid qini;
  pwr_tOid oid;
  pwr_tOid node_oid;
  char pname[20];

  switch ( process) {
  case io_mProcess_User:
    strcpy( pname, "pwr_io_user");
    break;
  case io_mProcess_User2:
    strcpy( pname, "pwr_io_user2");
    break;
  case io_mProcess_User3:
    strcpy( pname, "pwr_io_user3");
    break;
  case io_mProcess_User4:
    strcpy( pname, "pwr_io_user4");
    break;
  default:
    strcpy( pname, "pwr_io");
  }

  errh_Init(pname, errh_anix);

  if (!qcom_Init(&sts, 0, pname)) {
    errh_Fatal("qcom_Init, %m", sts);
    exit(sts);
  } 

  qAttr.type = qcom_eQtype_private;
  qAttr.quota = 100;
  if (!qcom_CreateQ(&sts, qid, &qAttr, "events")) {
    errh_Fatal("qcom_CreateQ, %m", sts);
    exit(sts);
  } 

  qini = qcom_cQini;
  if (!qcom_Bind(&sts, qid, &qini)) {
    errh_Fatal("qcom_Bind(Qini), %m", sts);
    exit(-1);
  }

  sts = gdh_Init(pname);
  if (EVEN(sts)) {
    errh_Fatal("rt_io_comm aborted\n%m", sts);
    exit(sts);
  }

  sts = io_get_iohandler_object(&ihp, &oid);
  if (EVEN(sts)) {
    errh_Fatal("rt_io_comm aborted, no IoHandler object found\n%m", sts);
    exit(sts);
  }

  sts = gdh_GetNodeObject( 0, &node_oid);
  if (EVEN(sts)) {
    errh_Fatal("rt_io_comm aborted, no node object found\n%m", sts);
    exit(sts);
  }

  sts = gdh_ObjidToPointer( node_oid, (void **)nodep);
  if (EVEN(sts)) {
    errh_Fatal("rt_io_comm aborted, no node object found\n%m", sts);
    exit(sts);
  }

  if ( strcmp( oname, "") != 0) {
    /* Register this object instead of IoHandler */
    sts = gdh_NameToObjid( oname, &oid);
    if ( EVEN(sts)) {
      errh_Fatal("rt_io_comm aborted, application object not found\n%m", sts);
      exit(sts);
    }    
  }

  aproc_RegisterObject( oid);

  if ( *cycletime == 0)
    *cycletime = ihp->CycleTimeBus;

  *csup_lh = csup_Init(&sts, oid, *cycletime);

  return ihp;
}









