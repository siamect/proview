/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* cnv_topdf.cpp --
   Convert xtt help file to postscript. */

/*_Include files_________________________________________________________*/

#include <iomanip>

extern "C" {
#include "co_cdh.h"
#include "co_dcli.h"
}
#include "co_lng.h"
#include "co_string.h"

#include "cnv_image.h"
#include "cnv_topdf.h"

#define pdf_cHead "%PDF-1.4"

void CnvPdfObj::print_begin()
{
  offset = topdf->fp[topdf->cf].tellp();

  switch (type) {
  case pdf_eObjType_Catalog:
    topdf->fp[topdf->cf] << number << " 0 obj\n"
                         << "  << /Type /Catalog\n"
                         << "     /Outlines 2 0 R\n"
                         << "     /Pages " << number + topdf->v_outline.size()
                         << " 0 R\n";

    if (topdf->use_outlines)
      topdf->fp[topdf->cf] << "     /PageMode /UseOutlines\n";

    topdf->fp[topdf->cf] << "  >>\n"
                         << "endobj\n\n";
    break;

  case pdf_eObjType_Outline:
    topdf->fp[topdf->cf] << number << " 0 obj\n"
                         << "  << /Type /Outlines\n";
    if (first)
      topdf->fp[topdf->cf] << "     /First " << first + 1 << " 0 R\n";
    if (last)
      topdf->fp[topdf->cf] << "     /Last " << last + 1 << " 0 R\n";
    topdf->fp[topdf->cf] << "     /Count " << count << '\n'
                         << "  >>\n"
                         << "endobj\n\n";
    break;
  case pdf_eObjType_Pages:
    topdf->fp[topdf->cf] << number + topdf->v_outline.size() << " 0 obj\n"
                         << "  << /Type /Pages\n"
                         << "     /Kids [\n";
    for (int i = 1; i < (int)topdf->v_pages.size(); i++)
      topdf->fp[topdf->cf] << "              "
                           << topdf->v_outline.size() + topdf->v_pages[i].number
                           << " 0 R\n";

    topdf->fp[topdf->cf] << "           ]\n"
                         << "     /Count " << topdf->v_pages.size() - 1 << '\n'
                         << "  >>\n"
                         << "endobj\n\n";
    break;

  case pdf_eObjType_Page:
    topdf->fp[topdf->cf] << number + topdf->v_outline.size() << " 0 obj\n"
                         << "  << /Type /Page\n"
                         << "     /Parent " << topdf->v_outline.size() + 1
                         << " 0 R\n"
                         << "     /Mediabox [0 0 " << ps_cPageWidth << " "
                         << ps_cPageHeight << "]\n"
                         << "     /Contents "
                         << number - 1 + topdf->v_outline.size()
            + topdf->v_pages.size()
                         << " 0 R\n";
    if (resource == -1) {
      topdf->fp[topdf->cf] << "     /Resources << /Procset "
                           << topdf->v_outline.size() + topdf->v_pages.size()
              + topdf->v_content.size() + 1
                           << " 0 R\n"
                           << "                   /Font <<\n";
      for (int i = 1; i < (int)topdf->v_font.size(); i++)
        topdf->fp[topdf->cf]
            << "                         /F" << topdf->v_font[i].number - 1
            << " "
            << topdf->v_font[i].number + topdf->v_outline.size()
                + topdf->v_pages.size() + topdf->v_content.size()
            << " 0 R\n";

      topdf->fp[topdf->cf] << "                          >>\n"
                           << "                >>\n";
    } else {
      topdf->fp[topdf->cf] << "     /Resources "
                           << topdf->v_outline.size() + topdf->v_pages.size()
              + topdf->v_content.size() + +topdf->v_font.size() + resource + 1
                           << " 0 R\n";
    }
    topdf->fp[topdf->cf] << "  >>\n"
                         << "endobj\n\n";
    break;

  case pdf_eObjType_Content:
    topdf->fp[topdf->cf] << number + topdf->v_outline.size()
            + topdf->v_pages.size()
                         << " 0 obj\n"
                         << "  << /Length " << length << " >>\n"
                         << "stream\n";
    start = (int)topdf->fp[topdf->cf].tellp();
    break;

  case pdf_eObjType_Process:
    topdf->fp[topdf->cf] << number + topdf->v_outline.size()
            + topdf->v_pages.size() + topdf->v_content.size()
                         << " 0 obj\n"
                         << "  [/PDF /Text]\n"
                         << "endobj\n\n";
    break;

  case pdf_eObjType_Font:
    topdf->fp[topdf->cf] << number + topdf->v_outline.size()
            + topdf->v_pages.size() + topdf->v_content.size()
                         << " 0 obj\n"
                         << "  << /Type /Font\n"
                         << "     /Subtype /Type1\n"
                         << "     /Name /F" << number - 1 << '\n'
                         << "     /BaseFont /" << fontname << '\n'
                         << "     /Encoding /WinAnsiEncoding\n"
                         << "  >>\n"
                         << "endobj\n\n";
    break;

  case pdf_eObjType_OutlineO:
    topdf->fp[topdf->cf] << number << " 0 obj\n"
                         << "  << /Title (" << text << ")\n"
                         << "     /Parent " << parent + 1 << " 0 R\n";
    if (prev)
      topdf->fp[topdf->cf] << "     /Prev " << prev + 1 << " 0 R\n";
    if (next)
      topdf->fp[topdf->cf] << "     /Next " << next + 1 << " 0 R\n";
    if (first)
      topdf->fp[topdf->cf] << "     /First " << first + 1 << " 0 R\n";
    if (last)
      topdf->fp[topdf->cf] << "     /Last " << last + 1 << " 0 R\n";
    if (count)
      topdf->fp[topdf->cf] << "     /Count " << count << '\n';
    topdf->fp[topdf->cf] << "     /Dest [" << dest
                         << " 0 R /XYZ null 700 null]\n"
                         << "  >>\n"
                         << "endobj\n\n";
    break;

  case pdf_eObjType_Image:
    print_image();
    break;

  case pdf_eObjType_Resource:
    topdf->fp[topdf->cf] << number + topdf->v_outline.size()
            + topdf->v_pages.size() + topdf->v_content.size()
            + topdf->v_font.size()
                         << " 0 obj\n"
                         << "  << /ProcSet [/PDF /Text /ImageB]\n"
                         << "     /XObject <<\n";

    for (int i = 0; i < xobject_cnt; i++) {
      topdf->fp[topdf->cf] << "                  /Im" << xobject[i] + 1 << " "
                           << xobject[i] + 1 + topdf->v_outline.size()
              + topdf->v_pages.size() + topdf->v_content.size()
              + topdf->v_font.size() + topdf->v_resource.size()
                           << " 0 R\n";
    }
    topdf->fp[topdf->cf] << "              >>\n"
                         << "     /Font <<\n";
    for (int i = 1; i < (int)topdf->v_font.size(); i++)
      topdf->fp[topdf->cf] << "               /F" << topdf->v_font[i].number - 1
                           << " "
                           << topdf->v_font[i].number + topdf->v_outline.size()
              + topdf->v_pages.size() + topdf->v_content.size()
                           << " 0 R\n";

    topdf->fp[topdf->cf] << "           >>\n"
                         << "  >>\n"
                         << "endobj\n";
    break;
  }
}

void CnvPdfObj::print_end()
{
  switch (type) {
  case pdf_eObjType_Content:
    length = (int)topdf->fp[topdf->cf].tellp() - start;
    topdf->fp[topdf->cf] << "endstream\n"
                         << "endobj\n\n";
    break;
  default:;
  }
}

int CnvPdfObj::print_image()
{
  pwr_tCmd cmd;
  cnv_tImImage image;
  cnv_tPixmap pixmap;
  pwr_tFileName fname;
  int sts;
  int width, height;
  char c;

  if (strchr(text, '/') != 0)
    dcli_translate_filename(fname, text);
  else {
    // Try $pwr_doc/help/
    strcpy(fname, "$pwr_doc/help/");
    strcat(fname, text);
    dcli_translate_filename(fname, fname);
  }
  sts = cnv_get_image(fname, &image, &pixmap);
  if (EVEN(sts)) {
    // Try $pwr_exe
    strcpy(fname, "$pwr_exe/");
    strcat(fname, text);
    dcli_translate_filename(fname, fname);

    sts = cnv_get_image(fname, &image, &pixmap);
    if (EVEN(sts)) {
      // Try $pwrp_exe
      strcpy(fname, "$pwrp_exe/");
      strcat(fname, text);
      dcli_translate_filename(fname, fname);

      sts = cnv_get_image(fname, &image, &pixmap);
      if (EVEN(sts))
        return 0;
    }
  }

  width = cnv_image_width(image);
  height = cnv_image_height(image);

  topdf->fp[topdf->cf] << number + topdf->v_outline.size()
          + topdf->v_pages.size() + topdf->v_content.size()
          + topdf->v_font.size() + topdf->v_resource.size()
                       << " 0 obj\n"
                       << "  << /Type /XObject\n"
                       << "     /Subtype /Image\n"
                       << "     /Width " << width << '\n'
                       << "     /Height " << height << '\n'
                       << "     /ColorSpace /DeviceRGB\n"
                       << "     /BitsPerComponent 8\n"
                       << "     /Filter /DCTDecode\n"
                       << "     /Length " << length << '\n'
                       << "  >>\n"
                       << "stream\n";

  start = (int)topdf->fp[topdf->cf].tellp();

  sprintf(fname, "/tmp/pwr_cnv_%08u.jpg", dcli_random());
  cnv_print_image(image, fname);

  std::ifstream fimg(fname);
  while (fimg.get(c))
    topdf->fp[topdf->cf].put(c);

  topdf->fp[topdf->cf] << '\n';
  length = (int)topdf->fp[topdf->cf].tellp() - start;
  topdf->fp[topdf->cf] << "endstream\n"
                       << "endobj\n";

  cnv_free_image(image, pixmap);
  fimg.close();
  sprintf(cmd, "rm -f %s", fname);
  system(cmd);
  return 1;
}

void CnvToPdf::print_text(const char* text, CnvStyle& style, int mode)
{
  char str[1000];

  cnv_text(str, text);

  if (style.sidebreak && mode & ps_mPrintMode_Pos) {
    if (page_number[cf] == 0) {
      // First header, no pagebreak
      page_number[cf] = 1;
    } else {
      print_pagebreak(0);
    }
  } else if (style.pagebreak && mode & ps_mPrintMode_Pos) {
    print_pagebreak(0);
  }

  if (mode & ps_mPrintMode_Pos || mode & ps_mPrintMode_Start) {
    y -= style.top_offset;

    if (y - style.bottom_offset < ps_cBottomMargin) {
      print_pagebreak(0);
    }
  } else
    y += style.bottom_offset;

  if (!(mode & ps_mPrintMode_FixX)) {
    if (style.alignment == cnv_eAlignment_Center) {
      x = ps_cLeftMargin / 2 + (ps_cPageWidth - ps_cLeftMargin / 2) / 2
          - 0.50 * strlen(text) * style.font_size / 2;
      if (x < ps_cLeftMargin / 2)
        x = ps_cLeftMargin / 2;
    } else
      x = ps_cLeftMargin + style.indentation;
  }

  int pmode = mode & 31;

  if (!streq(text, "")) {
    switch (pmode) {
    case ps_mPrintMode_Pos:
    case ps_mPrintMode_KeepY: {
      // Full path with beginning and end
      fp[cf] << "  BT\n"
             << "    " << fontname(style) << " " << style.font_size << " Tf\n"
             << "    " << x << " " << y << " Td\n"
             << "    (" << str << ") Tj\n"
             << "  ET" << '\n';
      break;
    }
    case ps_mPrintMode_Start: {
      // Start new path
      fp[cf] << "  BT\n"
             << "    " << fontname(style) << " " << style.font_size << " Tf\n"
             << "    " << x << " " << y << " Td\n"
             << "    (" << str << ") Tj\n";
      break;
    }
    case ps_mPrintMode_Continue: {
      // Continue current path
      fp[cf] << "    " << fontname(style) << " " << style.font_size << " Tf\n"
             << "    " << x << " " << y << " Td\n"
             << "    (" << str << ") Tj\n";
      break;
    }
    case ps_mPrintMode_End: {
      // Continue and close current path
      fp[cf] << "    " << fontname(style) << " " << style.font_size << " Tf\n"
             << "    (" << str << ") Tj\n"
             << "  ET" << '\n';
      break;
    }
    default:;
    }
  } else {
    switch (pmode) {
    case ps_mPrintMode_Start: {
      // Start new path
      fp[cf] << "  BT\n"
             << "    " << x << " " << y << " Td\n";
      break;
    }
    case ps_mPrintMode_End: {
      // Continue and close current path
      fp[cf] << "  ET" << '\n';
      break;
    }
    default:;
    }
  }
  y -= style.bottom_offset;
}

void CnvToPdf::draw_rect(double lw, double x, double y, double w, double h)
{
  fp[cf] << "  " << lw << " w\n"
         << "  " << x << " " << y << " " << w << " " << h << " re S\n";
}

void CnvToPdf::draw_arc(
    double lw, double x, double y, double w, double h, int angle1, int angle2)
{
  fp[cf] << "  " << lw << " w\n";
  if ((angle1 == 0 && angle2 >= 90) || (angle1 == 90 && angle2 >= 360)
      || (angle1 == 180 && angle2 >= 270) || (angle1 == 270 && angle2 >= 180))
    fp[cf] << "  " << x + w << " " << y + h / 2 << " m"
           << "  " << x + w << " " << y + h << " " << x + w << " " << y + h
           << " " << x + w / 2 << " " << y + h << " "
           << " c\n";
  if ((angle1 == 0 && angle2 >= 180) || (angle1 == 90 && angle2 >= 90)
      || (angle1 == 180 && angle2 >= 360) || (angle1 == 270 && angle2 >= 270))
    fp[cf] << "  " << x + w / 2 << " " << y + h << " m"
           << "  " << x << " " << y + h << " " << x << " " << y + h << " " << x
           << " " << y + h / 2 << " "
           << " c\n";
  if ((angle1 == 0 && angle2 >= 270) || (angle1 == 90 && angle2 >= 180)
      || (angle1 == 180 && angle2 >= 90) || (angle1 == 270 && angle2 >= 360))
    fp[cf] << "  " << x << " " << y + h / 2 << " m"
           << "  " << x << " " << y << " " << x << " " << y << " " << x + w / 2
           << " " << y << " "
           << " c\n";
  if ((angle1 == 0 && angle2 >= 360) || (angle1 == 90 && angle2 >= 270)
      || (angle1 == 180 && angle2 >= 180) || (angle1 == 270 && angle2 >= 90))
    fp[cf] << "  " << x + w / 2 << " " << y << " m"
           << "  " << x + w << " " << y << " " << x + w << " " << y << " "
           << x + w << " " << y + h / 2 << " "
           << " c\n";
  fp[cf] << "  S\n";
}

void CnvToPdf::draw_line(
    double lw, double x1, double y1, double x2, double y2, int dashed, int gray)
{
  fp[cf] << "  " << lw << " w\n";
  if (dashed)
    fp[cf] << "  [2 3] 1 d\n";
  if (gray)
    fp[cf] << " 0.7 G\n";
  fp[cf] << "  " << x1 << " " << y1 << " m\n"
         << "  " << x2 << " " << y2 << " l S\n";
  if (dashed)
    fp[cf] << "  [] 0 d\n";
  if (gray)
    fp[cf] << "  0 G\n";
}
void CnvToPdf::draw_arrow(
    double x1, double y1, double x2, double y2, double x3, double y3, int gray)
{
  if (gray)
    fp[cf] << " 0.7 G\n"
           << " 0.7 g\n";
  fp[cf] << "  " << x1 << " " << y1 << " m\n"
         << "  " << x2 << " " << y2 << " l\n"
         << "  " << x3 << " " << y3 << " l\n"
         << "  " << x1 << " " << y1 << " l\n"
         << "  B\n";
  if (gray)
    fp[cf] << "  0 G\n"
           << "  0 g\n";
}

void CnvToPdf::draw_text(double x, double y, char* text, int bold, double size)
{
  char fontname[20];

  if (bold)
    strcpy(fontname, "/F2");
  else
    strcpy(fontname, "/F1");

  fp[cf] << "  BT\n"
         << "    " << fontname << " " << size << " Tf\n"
         << "    " << x << " " << y << " Td\n"
         << "    (" << text << ") Tj\n"
         << "  ET" << '\n';
}

void CnvToPdf::print_pagebreak(int last)
{
  if (page_number[cf] == 0)
    page_number[cf] = 1;
  if (page_number[cf] != 1 || last) {
    double page_x;

    page_x = ps_cPageNumX;

    if (!(prev_ci == ps_eId_TitlePage || prev_ci == ps_eId_InfoPage)) {
      prev_ci = ci;

      fp[cf] << "  1 w\n"
             << "  " << 10 << " " << ps_cPageHeight - 20 << " m\n"
             << "  " << ps_cPageWidth + 65 << " " << ps_cPageHeight - 20
             << " l\n"
             << "  S\n"
             << "  BT\n"
             << "    /F1 10 Tf\n"
             << "    "
             << ps_cPageWidth / 2 - 10 * 0.5 * strlen(previous_chapter) << " "
             << ps_cPageNumY << " Td\n"
             << "    (" << previous_chapter << ") Tj\n"
             << "  ET\n"
             << "  BT\n"
             << "    /F1 10 Tf\n"
             << "    " << page_x << " " << ps_cPageNumY << " Td\n"
             << "    (" << page_number[cf] - 1 << ") Tj\n"
             << "  ET\n";
    }

    if (page_number[cf] > 1 && v_content.size() > 0) {
      v_content[page_number[cf] - 2].print_end();
    }
  }

  if (last)
    return;

  if (conf_pass) {
    CnvPdfObj o1 = CnvPdfObj(this, pdf_eObjType_Page, v_pages.size() + 1);
    v_pages.push_back(o1);

    CnvPdfObj o2 = CnvPdfObj(this, pdf_eObjType_Content, v_content.size() + 1);
    v_content.push_back(o2);
  }

  if ((int)v_content.size() > page_number[cf] - 1)
    v_content[page_number[cf] - 1].print_begin();

  page_number[cf]++;

  y = ps_cPageHeight - ps_cTopMargin;
}

void CnvToPdf::print_content()
{
  int size = content.tab.size();
  int level = 0;
  int prev[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  int current = v_outline.size();
  int root = 1;
  int parent[4] = { 0, 0, 0, 0 };
  int offset = current;

  if (!current)
    return;

  v_outline[root].first = current;
  v_outline[root].last = current + size - 1;
  v_outline[root].count = size;
  parent[level] = root;

  for (int i = 0; i < size; i++) {
    level = content.tab[i].header_level;
    if (level < 0)
      level = 0;

    CnvPdfObj o1 = CnvPdfObj(this, pdf_eObjType_OutlineO, current + 1);
    strcpy(o1.text, content.tab[i].text);
    o1.parent = parent[level];
    if (parent[level] != root) {
      v_outline[parent[level]].last = current;
      v_outline[parent[level]].count++;
    }
    if (i != size - 1) {
      if (content.tab[i + 1].header_level > content.tab[i].header_level) {
        parent[level + 1] = current;
        o1.first = current + 1;
      }
    }
    if (prev[level]) {
      o1.prev = prev[level];
      v_outline[o1.prev].next = current;
    }
    o1.dest = size + offset + content.tab[i].page_number;

    prev[level] = current;
    v_outline.push_back(o1);
    current++;

    if (i != size - 1) {
      int next_level = content.tab[i + 1].header_level;
      if (next_level < 0)
        next_level = 0;
      if (level > next_level) {
        for (int j = next_level + 1; j <= level; j++)
          prev[j] = 0;
      }
    }
  }
}

CnvToPdf::~CnvToPdf()
{
}

void CnvToPdf::close()
{
  cf = ps_eFile_Body;
  print_pagebreak(1);
  // print_content();

  for (int i = 0; i < (int)v_font.size(); i++) {
    v_font[i].print_begin();
    v_font[i].print_end();
  }

  for (int i = 0; i < (int)v_resource.size(); i++) {
    v_resource[i].print_begin();
    v_resource[i].print_end();
  }

  for (int i = 0; i < (int)v_image.size(); i++) {
    v_image[i].print_begin();
    v_image[i].print_end();
  }

  xref_offset = fp[cf].tellp();
  fp[cf] << '\n'
         << "xref\n"
         << "0 "
         << v_outline.size() + v_pages.size() + v_content.size() + v_font.size()
          + v_resource.size() + v_image.size() + 1
         << '\n'
         << "0000000000 65535 f \n";

  for (int i = 0; i < (int)v_outline.size(); i++) {
    fp[cf].fill('0');
    fp[cf].width(10);
    fp[cf] << v_outline[i].offset << " 00000 n \n";
  }
  for (int i = 0; i < (int)v_pages.size(); i++) {
    fp[cf].fill('0');
    fp[cf].width(10);
    fp[cf] << v_pages[i].offset << " 00000 n \n";
  }
  for (int i = 0; i < (int)v_content.size(); i++) {
    fp[cf].fill('0');
    fp[cf].width(10);
    fp[cf] << v_content[i].offset << " 00000 n \n";
  }
  for (int i = 0; i < (int)v_font.size(); i++) {
    fp[cf].fill('0');
    fp[cf].width(10);
    fp[cf] << v_font[i].offset - start_offset << " 00000 n \n";
  }
  for (int i = 0; i < (int)v_resource.size(); i++) {
    fp[cf].fill('0');
    fp[cf].width(10);
    fp[cf] << v_resource[i].offset - start_offset << " 00000 n \n";
  }
  for (int i = 0; i < (int)v_image.size(); i++) {
    fp[cf].fill('0');
    fp[cf].width(10);
    fp[cf] << v_image[i].offset - start_offset << " 00000 n \n";
  }

  fp[cf] << '\n'
         << "trailer\n"
         << "  << /Size "
         << v_outline.size() + v_pages.size() + v_content.size() + v_font.size()
         << '\n'
         << "     /Root 1 0 R\n"
         << "  >>\n"
         << "startxref\n"
         << xref_offset - start_offset << '\n'
         << "%%EOF\n";

  fp[ps_eFile_Body].close();
}

static void image_pixel(void* userdata, std::ofstream& fp, unsigned char* rgb)
{
  unsigned char transp[3] = { 255, 0, 255 };
  int grey;

  if (*rgb == transp[0] && *(rgb + 1) == transp[1] && *(rgb + 2) == transp[2])
    grey = 255;
  else
    grey = (int)((0.0 + *rgb + *(rgb + 1) + *(rgb + 2)) / 3 + 0.5);

  fp << (unsigned char)grey;
}

void CnvToPdf::print_horizontal_line()
{
  y -= 3;
  fp[cf] << "  1 w\n"
         << "  " << ps_cLeftMargin - 50 << " " << y << " m\n"
         << "  " << ps_cPageWidth << " " << y << " l\n"
         << "  S\n";

  y -= 3;
}

int CnvToPdf::print_image_inline(const char* filename)
{
  cnv_tImImage image;
  cnv_tPixmap pixmap;
  pwr_tFileName fname;
  int sts;
  int width, height;
  double scalex = 0.71;
  double scaley = 0.78;

  x = ps_cLeftMargin;

  // Try $pwr_doc/help/
  strcpy(fname, "$pwr_doc/help/");
  strcat(fname, filename);
  dcli_translate_filename(fname, fname);

  sts = cnv_get_image(fname, &image, &pixmap);
  if (EVEN(sts)) {
    // Try $pwr_exe
    strcpy(fname, "$pwr_exe/");
    strcat(fname, filename);
    dcli_translate_filename(fname, fname);

    sts = cnv_get_image(fname, &image, &pixmap);
    if (EVEN(sts)) {
      // Try $pwrp_exe
      strcpy(fname, "$pwrp_exe/");
      strcat(fname, filename);
      dcli_translate_filename(fname, fname);

      sts = cnv_get_image(fname, &image, &pixmap);
      if (EVEN(sts))
        return 0;
    }
  }

  width = cnv_image_width(image);
  height = cnv_image_height(image);

  if (width * scalex > ps_cPageWidth - ps_cLeftMargin) {
    x = ps_cPageWidth - width * scalex;
    if (x < 50) {
      double scale_factor = (ps_cPageWidth - 50) / (width * scalex);
      x = 50;
      scalex = scalex * scale_factor;
      scaley = scaley * scale_factor;
    }
  }

  if (y - height * scaley + 20 < ps_cBottomMargin)
    print_pagebreak(0);

  fp[cf] << "  q\n"
         << scalex * width << " 0 0 " << scaley * height << " " << x << " "
         << y - scaley * height << " cm\n"
         << "  BI\n"
         << "    /W " << width << '\n'
         << "    /H " << height << '\n'
         << "    /CS /G\n"
         << "    /BPC 8\n"
         << "  ID\n";

  cnv_image_pixel_iter(image, image_pixel, 0, fp[cf]);

  fp[cf] << '\n'
         << "EI\n"
         << "  Q\n";
  fp[cf].flags(
      ((fp[cf].flags() & ~std::ios_base::hex) & ~std::ios_base::uppercase)
      | std::ios_base::dec);

  cnv_free_image(image, pixmap);
  y -= height * scaley;

  return 1;
}

int CnvToPdf::print_image(const char* filename)
{
  cnv_tImImage image;
  cnv_tPixmap pixmap;
  pwr_tFileName fname;
  int sts;
  int width, height;
  double scalex = 0.71;
  double scaley = 0.78;

  im_cnt++;
  x = ps_cLeftMargin;

  if (strchr(filename, '/') != 0)
    dcli_translate_filename(fname, filename);
  else {
    // Try $pwr_doc/help/
    strcpy(fname, "$pwr_doc/help/");
    strcat(fname, filename);
    dcli_translate_filename(fname, fname);
  }
  sts = cnv_get_image(fname, &image, &pixmap);
  if (EVEN(sts)) {
    // Try $pwr_exe
    strcpy(fname, "$pwr_exe/");
    strcat(fname, filename);
    dcli_translate_filename(fname, fname);

    sts = cnv_get_image(fname, &image, &pixmap);
    if (EVEN(sts)) {
      // Try $pwrp_exe
      strcpy(fname, "$pwrp_exe/");
      strcat(fname, filename);
      dcli_translate_filename(fname, fname);

      sts = cnv_get_image(fname, &image, &pixmap);
      if (EVEN(sts))
        return 0;
    }
  }

  width = cnv_image_width(image);
  height = cnv_image_height(image);

  if (width * scalex > ps_cPageWidth - ps_cLeftMargin) {
    x = ps_cPageWidth - width * scalex;
    if (x < 50) {
      double scale_factor = (ps_cPageWidth - 50) / (width * scalex);
      x = 50;
      scalex = scalex * scale_factor;
      scaley = scaley * scale_factor;
    }
  }

  if (y - height * scaley + 20 < ps_cBottomMargin)
    print_pagebreak(0);

  fp[cf] << "  q\n"
         << "  " << scalex * width << " 0 0 " << scaley * height << " " << x
         << " " << y - scaley * height << " cm\n"
         << "  /Im" << im_cnt << " Do\n"
         << "  Q\n";

  if (conf_pass) {
    if (v_pages[v_pages.size() - 1].resource == -1) {
      v_pages[v_pages.size() - 1].resource = v_resource.size();

      CnvPdfObj o1
          = CnvPdfObj(this, pdf_eObjType_Resource, v_resource.size() + 1);
      v_resource.push_back(o1);
    }
    v_resource[v_resource.size() - 1]
        .xobject[v_resource[v_resource.size() - 1].xobject_cnt]
        = v_image.size();
    v_resource[v_resource.size() - 1].xobject_cnt++;

    CnvPdfObj o2 = CnvPdfObj(this, pdf_eObjType_Image, v_image.size() + 1);
    strcpy(o2.text, filename);
    v_image.push_back(o2);
  }

  cnv_free_image(image, pixmap);
  y -= height * scaley;

  return 1;
}

void CnvToPdf::open()
{
  y = ps_cPageHeight - ps_cTopMargin;
  im_cnt = 0;

  if (conf_pass) {
    fp[ps_eFile_Body].open(filename[ps_eFile_Body]);
    fp[ps_eFile_Body] << setiosflags(std::ios::fixed) << std::setprecision(6);
    start_offset = fp[ps_eFile_Body].tellp();
  } else {
    print_content();

    conf_pass = true;
    page_number[cf] = v_content.size() + 1;
    print_pagebreak(1);
    conf_pass = false;
    for (int i = 0; i < (int)v_image.size(); i++) {
      v_image[i].print_begin();
      v_image[i].print_end();
    }
    // if ( v_content.size() > 0 && v_content[v_content.size()-1].length == 0)
    //  v_content[v_content.size()-1].length = (int) fp[ps_eFile_Body].tellp()
    //  -
    //	v_content[v_content.size()-1].start;
    fp[ps_eFile_Body].seekp(start_offset);
    strcpy(previous_chapter, "");
    strcpy(current_chapter, "");
  }
  cf = ps_eFile_Body;
  page_number[cf] = 0;

  if (conf_pass) {
    CnvPdfObj o1 = CnvPdfObj(this, pdf_eObjType_Catalog, v_outline.size() + 1);
    v_outline.push_back(o1);

    CnvPdfObj o2 = CnvPdfObj(this, pdf_eObjType_Outline, v_outline.size() + 1);
    v_outline.push_back(o2);

    CnvPdfObj o3 = CnvPdfObj(this, pdf_eObjType_Pages, v_pages.size() + 1);
    v_pages.push_back(o3);

    CnvPdfObj o4 = CnvPdfObj(this, pdf_eObjType_Process, v_font.size() + 1);
    v_font.push_back(o4);

    CnvPdfObj o5 = CnvPdfObj(this, pdf_eObjType_Font, v_font.size() + 1);
    strcpy(o5.fontname, "Helvetica");
    v_font.push_back(o5);

    CnvPdfObj o6 = CnvPdfObj(this, pdf_eObjType_Font, v_font.size() + 1);
    strcpy(o6.fontname, "Helvetica-Bold");
    v_font.push_back(o6);

    CnvPdfObj o7 = CnvPdfObj(this, pdf_eObjType_Font, v_font.size() + 1);
    strcpy(o7.fontname, "Helvetica-Oblique");
    v_font.push_back(o7);

    CnvPdfObj o8 = CnvPdfObj(this, pdf_eObjType_Font, v_font.size() + 1);
    strcpy(o8.fontname, "TimesNewRoman");
    v_font.push_back(o8);

    CnvPdfObj o9 = CnvPdfObj(this, pdf_eObjType_Font, v_font.size() + 1);
    strcpy(o9.fontname, "TimesNewRoman,Bold");
    v_font.push_back(o9);

    CnvPdfObj o10 = CnvPdfObj(this, pdf_eObjType_Font, v_font.size() + 1);
    strcpy(o10.fontname, "Courier");
    v_font.push_back(o10);
  }

  fp[cf] << pdf_cHead << '\n';

  for (int i = 0; i < (int)v_outline.size(); i++) {
    v_outline[i].print_begin();
    v_outline[i].print_end();
  }
  for (int i = 0; i < (int)v_pages.size(); i++) {
    v_pages[i].print_begin();
    v_pages[i].print_end();
  }

  print_pagebreak(0);

  for (int i = 1; i < ps_cMaxLevel; i++)
    header_number[i] = 0;
}

char* CnvToPdf::fontname(CnvStyle& style)
{
  static char str[80];
  char name[80];

  strcpy(name, style.font.c_str());
  if (str_StartsWith(name, "Helvetica-Bold"))
    strcpy(str, "/F2");
  else if (str_StartsWith(name, "Helvetica-Oblique"))
    strcpy(str, "/F3");
  else if (str_StartsWith(name, "Helvetica"))
    strcpy(str, "/F1");
  else if (str_StartsWith(name, "TimesNewRoman-Bold"))
    strcpy(str, "/F5");
  else if (str_StartsWith(name, "TimesNewRoman"))
    strcpy(str, "/F4");
  else if (str_StartsWith(name, "Courier"))
    strcpy(str, "/F6");
  else
    strcpy(str, "/F1");

  return str;
}
