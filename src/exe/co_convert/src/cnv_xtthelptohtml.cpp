/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2018 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* cnv_xtthelptohtml.cpp --
   Convert xtt help file to html. */

/*_Include files_________________________________________________________*/

#include <stdlib.h>

extern "C" {
#include "co_cdh.h"
#include "co_dcli.h"
}
#include "co_lng.h"
#include "co_string.h"

#include "cnv_ctx.h"
#include "cnv_xtthelptohtml.h"

#define CNV_TAB 18

static int replace_url_symbols(const pwr_tURL in, pwr_tURL out);
static int find_symbol(char* name, char* value);

void CnvXtthelpToHtml::subject_to_fname(
    char* fname, const char* subject, int path)
{
  char *s, *t;

  if (path) {
    strcpy(fname, ctx->dir);
    strcat(fname, ctx->rx->name);
  } else
    strcpy(fname, ctx->rx->name);
  strcat(fname, "_");
  t = fname + strlen(fname);
  for (s = (char*)subject; *s; s++, t++) {
    if (*s == ' ' || *s == '(' || *s == ')')
      *t = '_';
    else
      *t = *s;
  }
  *t = 0;
  strcat(fname, ".html");
}

void* CnvXtthelpToHtml::insert(navh_eItemType item_type, const char* text1,
    const char* text2, const char* text3, const char* link,
    const char* link_bookmark, const char* file_name, navh_eHelpFile file_type,
    int help_index, const char* bookmark, int coding)
{
  int i;
  static int in_table = 0;

  if ((text2 && !streq(text2, "")) || (text3 && !streq(text3, ""))) {
    if (!in_table && cf) {
      cf->f << "<TABLE>\n";
      in_table = 1;
    }
  } else {
    if (in_table && cf) {
      // Close table (keep if empty line)
      if (!(text1 && streq(text1, "")
              && (item_type == navh_eItemType_Help
                     || item_type == navh_eItemType_HelpCode
                     || item_type == navh_eItemType_HelpBold))) {
        cf->f << "</TABLE>\n";
        in_table = 0;
      }
    }
  }
  switch (item_type) {
  case navh_eItemType_Topic: {
    pwr_tFileName fname;
    char codingstr[40] = "ISO-8859-1";

    if (coding == lng_eCoding_UTF_8)
      strcpy(codingstr, "UTF-8");

    subject_to_fname(fname, text1, 1);
    cf = new CnvFile();
    cf->f.open(fname);
    cf->f << "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 "
             "Transitional//EN\"\"http://www.w3.org/TR/REC-html40/loose.dtd>\n"
          << "<!--NewPage-->\n"
          << "<HTML>\n"
          << "<HEAD>\n"
          << "<META http-equiv=\"Content-Type\" content=\"text/html; charset="
          << codingstr << "\">\n"
          << "<!-- Generated by co_convert.-->\n"
          << "<TITLE>\n"
          << "Help topic: " << text1 << '\n'
          << "</TITLE>\n"
          << "<LINK REL =\"stylesheet\" TYPE=\"text/css\" HREF=\"../pcss.css\" "
             "TITLE=\"Style\">\n"
          << "</HEAD>\n"
          <<
        //"<H2>" << text1 << "</H2><BR>\n" <<
        "<P>\n";
    return NULL;
  }
  case navh_eItemType_EndTopic: {
    if (!cf)
      break;

    cf->f.close();
    delete cf;
    cf = 0;
    return NULL;
  }
  case navh_eItemType_Help:
  case navh_eItemType_HelpCode: {
    if (!cf)
      break;

    if (item_type == navh_eItemType_HelpCode && !in_table) {
      cf->f << "<CODE>";
      for (const char* s = text1; s && *s == ' '; s++)
        cf->f << "&nbsp;";
    }

    pwr_tFileName fname;
    if (!streq(link, "")) {
      if (strncmp(link, "$web:", 5) == 0) {
        replace_url_symbols(&link[5], fname);
        // if ( strncmp( &link[5], "$pwrp_web/", 10) == 0)
        //   strcpy( fname, &link[15]);
        // else
        //   strcpy( fname, &link[5]);
      } else if (strncmp(link, "$class:", 7) == 0) {
        char* s;

        // Get prefix from file
        strcpy(fname, "./orm/");
        s = (char*)strrchr(file_name, '/');
        if (s)
          strcat(fname, s + 1);
        s = strchr(fname, '_');
        if (s)
          *(s + 1) = 0;
        strcat(fname, &link[7]);
        strcat(fname, ".html");
      } else if ((strstr(link, ".htm") != 0) || (strstr(link, ".pdf") != 0)) {
        strcpy(fname, link);
      } else {
        subject_to_fname(fname, link, 0);

        if (!streq(link_bookmark, "")) {
          strcat(fname, "#");
          strcat(fname, link_bookmark);
        } else if (file_name && !streq(file_name, "")) {
          char* s = (char*)strrchr(file_name, '/');
          if (s)
            strcpy(fname, s + 1);
          else
            strcpy(fname, file_name);
          s = strchr(fname, '.');
          if (s)
            *s = 0;
          strcat(fname, "_");
          strcat(fname, link);
          strcat(fname, ".html");
        }
      }
      if (!in_table)
        cf->f << "<A HREF=\"" << fname << "\">";
    } else if (bookmark) {
      if (in_table) {
        cf->f << "</TABLE>\n";
        in_table = 0;
      }
      cf->f << "<A NAME=\"" << bookmark << "\">";
    }

    if (!in_table) {
      cf->f << text1;
      if (!streq(link, "") || bookmark)
        cf->f << "<BR></A>\n";
      else
        cf->f << "<BR>\n";
      if (item_type == navh_eItemType_HelpCode)
        cf->f << "</CODE>";
    } else {
      cf->f << "<TR><TD>";
      if (!streq(link, ""))
        cf->f << "<A HREF=\"" << fname << "\">";
      else if (bookmark != 0)
        cf->f << "<A NAME=\"" << bookmark << "\">";
      cf->f << text1;
      if (!streq(text2, "") || !streq(text3, "")) {
        for (i = 0; i < (int)(CNV_TAB - strlen(text1)); i++)
          cf->f << "&nbsp;";
        cf->f << "&nbsp;&nbsp;</TD><TD>" << text2;
        if (!streq(text3, "")) {
          for (i = 0; i < (int)(CNV_TAB - strlen(text2)); i++)
            cf->f << "&nbsp;";
          cf->f << "&nbsp;&nbsp;</TD><TD>" << text3;
        }
      }
      if (!streq(link, "") || bookmark)
        cf->f << "</A>\n";
      else
        cf->f << '\n';
      cf->f << "</TD></TR>";
    }
    return NULL;
  }
  case navh_eItemType_HelpBold: {
    if (!cf)
      break;

    pwr_tFileName fname;
    if (!streq(link, "")) {
      if (strncmp(link, "$web:", 5) == 0) {
        replace_url_symbols(&link[5], fname);
        // if ( strncmp( &link[5], "$pwrp_web/", 10) == 0)
        //  strcpy( fname, &link[15]);
        // else
        //  strcpy( fname, &link[5]);
      } else if (strncmp(link, "$class:", 7) == 0) {
        char* s;

        // Get prefix from file
        strcpy(fname, "./orm/");
        s = (char*)strrchr(file_name, '/');
        if (s)
          strcat(fname, s + 1);
        s = strchr(fname, '_');
        if (s)
          *(s + 1) = 0;
        strcat(fname, &link[7]);
        strcat(fname, ".html");
      } else if ((strstr(link, ".htm") != 0) || (strstr(link, ".pdf") != 0)) {
        strcpy(fname, link);
      } else {
        subject_to_fname(fname, link, 0);
        if (!streq(link_bookmark, "")) {
          strcat(fname, "#");
          strcat(fname, link_bookmark);
        }
      }
      if (!in_table)
        cf->f << "<A HREF=\"" << fname << "\">";
    } else if (bookmark) {
      if (!in_table)
        cf->f << "<A NAME=\"" << bookmark << "\">";
    }

    if (!in_table) {
      cf->f << "<B>" << text1 << "</B>";
      if (!streq(link, "") || bookmark)
        cf->f << "<BR></A>\n";
      else
        cf->f << "<BR>\n";
    } else {
      cf->f << "<TR><TD><B>";
      if (!streq(link, ""))
        cf->f << "<A HREF=\"" << fname << "\">";
      else if (bookmark != 0)
        cf->f << "<A NAME=\"" << bookmark << "\">";
      cf->f << text1;
      if (!streq(link, "") || bookmark)
        cf->f << "</A>";
      if (!streq(text2, "") || !streq(text3, "")) {
        for (i = 0; i < (int)(CNV_TAB - strlen(text1)); i++)
          cf->f << "&nbsp;";
        cf->f << "&nbsp;&nbsp;</B></TD><TD><B>" << text2;
        if (!streq(text3, "")) {
          for (i = 0; i < (int)(CNV_TAB - strlen(text2)); i++)
            cf->f << "&nbsp;";
          cf->f << "&nbsp;&nbsp;</B></TD><TD><B>" << text3;
        }
      }
      if (!streq(link, "") || bookmark)
        cf->f << "</A>\n";
      else
        cf->f << '\n';
      cf->f << "</B></TD></TR>";
    }
    return NULL;
  }
  case navh_eItemType_HelpHeader: {
    if (!cf)
      break;

    cf->f << "<H1>" << text1 << "</H1>\n";
    return NULL;
  }
  case navh_eItemType_Header: {
    if (!cf)
      break;

    if (bookmark != 0)
      cf->f << "<A NAME=\"" << bookmark << "\">";
    cf->f << "<H3>" << text1 << "</H3>";
    if (bookmark != 0)
      cf->f << "</A>";
    cf->f << '\n';
    return NULL;
  }
  case navh_eItemType_HeaderLarge: {
    if (!cf)
      break;

    if (bookmark != 0)
      cf->f << "<A NAME=\"" << bookmark << "\">";
    cf->f << "<H2>" << text1 << "</H2>";
    if (bookmark != 0)
      cf->f << "</A>";
    cf->f << '\n';
    return NULL;
  }
  case navh_eItemType_HorizontalLine: {
    if (!cf)
      break;

    cf->f << "<HR>\n";
    return NULL;
  }
  case navh_eItemType_Image: {
    if (!cf)
      break;

    cf->f << "<IMG SRC=\"" << text1 << "\"><BR>\n";
    return NULL;
  }
  default:
    return 0;
  }
  return 0;
}

static int replace_url_symbols(const pwr_tURL in, pwr_tURL out)
{
  char *s, *t;
  char* sym_start;
  char sym_value[80];
  char sym_name[80];
  pwr_tURL tmp;
  int skip_sym = 0;
  pwr_tURL url;

  strncpy(url, in, sizeof(pwr_tURL));

  sym_start = 0;
  t = tmp;
  for (s = url; *s; s++) {
    if (*s == '\\' && *(s + 1) == '$')
      skip_sym = 1;
    if (*s == '$' && !skip_sym) {
      if (sym_start) {
        strncpy(sym_name, sym_start + 1, s - (sym_start + 1));
        sym_name[s - sym_start - 1] = 0;
        if (find_symbol(sym_name, sym_value)) {
          strcpy(t, sym_value);
          t += strlen(sym_value);
        } else {
          strncpy(t, sym_start, s - sym_start);
          t += s - sym_start;
        }
      }
      sym_start = s;
    } else if (*s == '$' && skip_sym) {
      skip_sym = 0;
      *t++ = *s;
    } else if (sym_start) {
      if (!(isdigit(*s) || isalpha(*s) || *s == '_')) {
        // End of symbol
        strncpy(sym_name, sym_start + 1, s - (sym_start + 1));
        sym_name[s - sym_start - 1] = 0;
        if (find_symbol(sym_name, sym_value)) {
          strcpy(t, sym_value);
          t += strlen(sym_value);
        } else {
          strncpy(t, sym_start, s - sym_start);
          t += s - sym_start;
        }
        sym_start = 0;
        *t++ = *s;
      }
    } else
      *t++ = *s;
  }
  if (sym_start) {
    strcpy(sym_name, sym_start + 1);
    if (find_symbol(sym_name, sym_value))
      strcpy(t, sym_value);
    else
      strcpy(t, sym_start);
  } else
    *t = 0;

  strcpy(out, tmp);
  return 1;
}

#define MAXSYMBOLS 100

static int find_symbol(char* name, char* value)
{
  static int loaded = 0;
  static char sym_vect[MAXSYMBOLS][80];
  static char value_vect[MAXSYMBOLS][80];
  static int vect_cnt;
  int nr;
  char elemv[3][80];
  int j;
  int found = 0;

  // Read the file
  if (!loaded) {
    FILE* fp;
    char line[200];
    pwr_tFileName fname;

    vect_cnt = 0;

    sprintf(fname, "$pwrp_db/pwrp_cnf_websymbols.dat");
    dcli_translate_filename(fname, fname);

    fp = fopen(fname, "r");
    if (!fp)
      return 0;

    while (dcli_read_line(line, sizeof(line), fp)) {
      nr = dcli_parse(line, " ", "", (char*)elemv,
          sizeof(elemv) / sizeof(elemv[0]), sizeof(elemv[0]), 0);
      if (nr != 3)
        continue;
      strcpy(sym_vect[vect_cnt], elemv[1]);
      strcpy(value_vect[vect_cnt], elemv[2]);
      vect_cnt++;
    }
    fclose(fp);
    loaded = 1;
  }

  if (!vect_cnt)
    return 0;

  for (j = 0; j < vect_cnt; j++) {
    if (cdh_NoCaseStrcmp(name, sym_vect[j]) == 0) {
      strcpy(value, value_vect[j]);
      found = 1;
      break;
    }
  }
  if (!found)
    return 0;

  return 1;
}
