/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include "pwr_version.h"

#include "co_dcli.h"
#include "co_cdh.h"
#include "co_string.h"
#include "co_time.h"

#include "cnv_ctx.h"
#include "cnv_wbltoh.h"

typedef struct {
  char name[40];
  unsigned int id;
} struct_tCixArray;

int CnvWblToH::init(char* first)
{
  pwr_tFileName struct_filename;
  pwr_tFileName fname;
  pwr_tFileName found_file;
  int sts;
  char timestr[80];

  time_AtoAscii(0, time_eFormat_DateAndTime, timestr, sizeof(timestr));

  get_filename(ctx->rw, struct_filename, ctx->hpp);
  strcpy(fname, ctx->dir);
  strcat(fname, struct_filename);
  fp_struct.open(fname);

  ctx->set_dependfile(fname);

  if (ctx->hpp) {
    if (streq(CnvCtx::low(ctx->rw->volume_name), "pwrb"))
      sprintf(fname, "pwr_%sclasses_hpp", "base");
    else if (streq(CnvCtx::low(ctx->rw->volume_name), "pwrs"))
      sprintf(fname, "pwr_%sclasses_hpp", "system");
    else
      sprintf(fname, "pwr_%sclasses_hpp", CnvCtx::low(ctx->rw->volume_name));
  } else {
    if (streq(CnvCtx::low(ctx->rw->volume_name), "pwrb"))
      sprintf(fname, "pwr_%sclasses_h", "base");
    else if (streq(CnvCtx::low(ctx->rw->volume_name), "pwrs"))
      sprintf(fname, "pwr_%sclasses_h", "system");
    else
      sprintf(fname, "pwr_%sclasses_h", CnvCtx::low(ctx->rw->volume_name));
  }

  sts = volname_to_id();
  if (sts == 0) {
    // printf( "** Can't get volume id\n");
    // exit(0);
  }

  fp_struct
      << "/*  File " << struct_filename << ".\n"
      << " *\n"
      << " *  Generated by co_convert " << pwrv_cPwrVersionStr << " " << timestr
      << ".\n"
      << " *  Do not edit this file.\n"
      << " *\n"
      << " *  Contains type and struct declarations for the types and classes\n"
      << " *  in volume " << ctx->rw->volume_name << ".\n"
      << " */\n\n"
      << "#ifndef " << fname << '\n'
      << "#define " << fname << '\n'
      << '\n'
      << "#ifndef pwr_class_h\n"
      << "#include \"pwr_class.h\"\n"
      << "#endif\n"
      << "#ifndef pwr_systemclasses_h\n"
      << "#include \"pwr_systemclasses.h\"\n"
      << "#endif\n"
      << '\n'
      << '\n';

  // If there is a template file on the source dir, insert this file here
  strcpy(fname, ctx->rw->source_dir);
  strcat(fname, "/");
  strcat(fname, struct_filename);
  strcat(fname, "_template");

  sts = dcli_search_file(fname, found_file, DCLI_DIR_SEARCH_INIT);
  if (EVEN(sts))
    return 1;

  dcli_search_file(fname, found_file, DCLI_DIR_SEARCH_END);

  FILE* fp_template = fopen(found_file, "r");
  int c;
  while ((c = fgetc(fp_template)) != EOF)
    fp_struct.put(c);
  fclose(fp_template);

  fp_struct << '\n';

  return 1;
}

int CnvWblToH::close()
{
  fp_struct << "#endif\n";

  fp_struct.close();

  ctx->print_depend();

  return 1;
}

int CnvWblToH::class_exec()
{
  // Open class struct file
  pwr_tFileName struct_filename;
  char fname[512];
  char volume_name_low[40];

  strcpy(volume_name_low, CnvCtx::low(ctx->rw->volume_name));

  get_filename(ctx->rw, struct_filename, ctx->hpp);
  if (ctx->hpp)
    sprintf(fname, "%s%s_c_%s.hpp", ctx->dir, volume_name_low,
        CnvCtx::low(ctx->rw->class_name));
  else
    sprintf(fname, "%s%s_c_%s.h", ctx->dir, volume_name_low,
        CnvCtx::low(ctx->rw->class_name));
  if (!ctx->common_structfile_only) {
    fp_cstruc.open(fname);
  }
  struct_class_open = 1;
  sprintf(
      fname, "%s_c_%s_h", volume_name_low, CnvCtx::low(ctx->rw->class_name));

  if (!ctx->common_structfile_only)
    fp_cstruc << "/*	Generated by co_convert 		*/\n\n"
              << "#ifndef " << fname << '\n'
              << "#define " << fname << '\n'
              << '\n'
              << "#ifndef pwr_class_h\n"
              << "#include \"pwr_class.h\"\n"
              << "#endif\n"
              << '\n'
              << '\n';

  // Add into index file
  struct_cclass_written = 0;
  struct_cclass_endwritten = 0;
  struct_filler_cnt = 0;

  return 1;
}

int CnvWblToH::body_exec()
{
  int sts;
  char cclass_name[80];
  unsigned int cix;
  pwr_tClassId cid;
  char struct_name[80];

  attr_count = 0;
  attr_next_alignlw = 1; // Align first attribute on longword

  if (streq(CnvCtx::low(ctx->rw->body_name), "devbody")) {
    if (ctx->hpp)
      strcpy(struct_name, "pwr_dClass_");
    else
      strcpy(struct_name, "pwr_sdClass_");
  } else {
    if (ctx->hpp)
      strcpy(struct_name, "pwr_Class_");
    else
      strcpy(struct_name, "pwr_sClass_");
  }
  if (streq(ctx->rw->body_structname, ""))
    strcat(struct_name, ctx->rw->class_name);
  else
    strcat(struct_name, ctx->rw->body_structname);

  // For systemclasses classindex is defined as a pwr_eCix...
  if (str_StartsWith(ctx->rw->class_id, "pwr_eCix_")) {
    sts = cixstr_to_classid(ctx->rw->class_id, &cid);
    if (EVEN(sts)) {
      printf("Error, unknown classid %s", ctx->rw->class_id);
      return sts;
    }
  } else {
    // Classindex is a number
    sts = sscanf(ctx->rw->class_id, "%d", &cix);
    if (sts != 1) {
      printf("Error, unknown classid %s", ctx->rw->class_id);
      return 0;
    }
    cix_to_classid(cix, &cid);
  }
  if (streq(ctx->rw->body_structname, ""))
    strcpy(cclass_name, ctx->rw->class_name);
  else
    strcpy(cclass_name, ctx->rw->body_structname);

  if (!struct_cclass_written) {
    fp_struct << '\n'
              << "#ifndef pwr_cClass_" << cclass_name << '\n'
              << "#define pwr_cClass_" << cclass_name << " " << cid << "UL\n"
              << '\n';
    if (!ctx->common_structfile_only)
      fp_cstruc << '\n'
                << "#ifndef pwr_cClass_" << cclass_name << '\n'
                << "#define pwr_cClass_" << cclass_name << " " << cid << "UL\n"
                << '\n';
    struct_cclass_written = 1;
  }

  if (streq(CnvCtx::low(ctx->rw->body_name), "rtbody")
      && ctx->rw->class_devonly) {
    fp_struct << "/*  Class: " << ctx->rw->class_name << '\n'
              << "    Body:  " << ctx->rw->body_name << '\n'
              << "    Body is virtual\n"
              << "*/\n\n";
    return 1;
  }

  fp_struct << "/*_* Class: " << ctx->rw->class_name << '\n'
            << "    Body:  " << ctx->rw->body_name << '\n'
            << "    @Aref " << ctx->rw->class_name << " " << struct_name << '\n'
            << "*/\n";
  if (!ctx->common_structfile_only)
    fp_cstruc << "/*  Body:  " << ctx->rw->body_name << "  */\n";

  if (ctx->hpp)
    fp_struct << '\n' << "class " << struct_name << " ";
  else
    fp_struct << '\n' << "typedef struct {\n";
  if (!ctx->common_structfile_only) {
    if (ctx->hpp)
      fp_cstruc << '\n' << "class " << struct_name << " ";
    else
      fp_cstruc << '\n' << "typedef struct {\n";
  }
  return 1;
}

int CnvWblToH::body_close()
{
  char struct_name[80];

  if (streq(CnvCtx::low(ctx->rw->body_name), "rtbody")
      && ctx->rw->class_devonly)
    return 1;

  if (attr_count == 0) {
    // Write a dummy element...
    fp_struct << "  int dummy;\n";
    if (!ctx->common_structfile_only)
      fp_cstruc << "  int dummy;\n";
  }

  if (streq(CnvCtx::low(ctx->rw->body_name), "devbody"))
    strcpy(struct_name, "pwr_sdClass_");
  else
    strcpy(struct_name, "pwr_sClass_");
  if (streq(ctx->rw->body_structname, ""))
    strcat(struct_name, ctx->rw->class_name);
  else
    strcat(struct_name, ctx->rw->body_structname);

  if (ctx->hpp) {
    fp_struct << "};" << '\n';
    if (!ctx->common_structfile_only)
      fp_cstruc << "};" << '\n';
  } else {
    fp_struct << "} " << struct_name << ";" << '\n';
    if (!ctx->common_structfile_only)
      fp_cstruc << "} " << struct_name << ";" << '\n';
  }

  fp_struct << '\n';
  if (!ctx->common_structfile_only)
    fp_cstruc << '\n';

  return 1;
}

int CnvWblToH::class_close()
{
  if (!struct_cclass_written) {
    fp_struct << '\n'
              << "#ifndef pwr_cClass_" << ctx->rw->class_name << '\n'
              << "#define pwr_cClass_" << ctx->rw->class_name << " "
              << ctx->rw->class_id << "UL\n"
              << '\n';
    if (!ctx->common_structfile_only && struct_class_open)
      fp_cstruc << '\n'
                << "#ifndef pwr_cClass_" << ctx->rw->class_name << '\n'
                << "#define pwr_cClass_" << ctx->rw->class_name << " "
                << ctx->rw->class_id << "UL\n"
                << '\n';

    struct_cclass_written = 1;
  }

  // endif pwr_cClass...
  if (!struct_cclass_endwritten) {
    fp_struct << "#endif\n" << '\n';

    if (!ctx->common_structfile_only && struct_class_open)
      fp_cstruc << "#endif\n" << '\n';
    struct_cclass_endwritten = 1;
  }

  // Close class structfile
  if (!ctx->common_structfile_only && struct_class_open)
    fp_cstruc << "#endif\n" << '\n';
  if (!ctx->common_structfile_only && struct_class_open) {
    fp_cstruc.close();
    struct_class_open = 0;
  }

  return 1;
}

//
// Alignment rules for gcc on x86_64:
// Pointer long, double, pointer or struct that contains long, double or
// pointer:
// aligned on 8 byte.
//
// Struct that contains long, double or pointer: next element aligned on 8
// bytes.
//
//
//

int CnvWblToH::attribute_exec()
{
  int i;
  char type_name[80];
  char pgmname[80];
  int sts;
  char alignstr[40];

  if (attr_next_alignlw || ctx->rw->attr_pointer || ctx->rw->attr_isclass
      || streq(CnvCtx::low(ctx->rw->attr_type), "input")
      || streq(CnvCtx::low(ctx->rw->attr_type), "buffer")
      || streq(CnvCtx::low(ctx->rw->attr_typeref), "int64")
      || streq(CnvCtx::low(ctx->rw->attr_typeref), "uint64")
      || streq(CnvCtx::low(ctx->rw->attr_typeref), "float64")
      || streq(CnvCtx::low(ctx->rw->attr_typeref), "time")
      || streq(CnvCtx::low(ctx->rw->attr_typeref), "deltatime")
      || streq(CnvCtx::low(ctx->rw->attr_typeref), "castid")
      || streq(CnvCtx::low(ctx->rw->attr_typeref), "disableattr")
      || streq(CnvCtx::low(ctx->rw->attr_typeref), "dataref")
      || streq(ctx->rw->attr_name, "TimerFlag"))
    strcpy(alignstr, " pwr_dAlignLW");
  else
    strcpy(alignstr, " pwr_dAlignW");

  if (ctx->rw->attr_isclass
      || streq(CnvCtx::low(ctx->rw->attr_type), "buffer")
      || ctx->rw->attr_pointer
      || streq(CnvCtx::low(ctx->rw->attr_typeref), "castid")
      || streq(CnvCtx::low(ctx->rw->attr_typeref), "disableattr"))
    // Align next attribute on longword
    attr_next_alignlw = 1;
  else
    attr_next_alignlw = 0;

  if (streq(CnvCtx::low(ctx->rw->body_name), "rtbody")
      && ctx->rw->class_devonly)
    return 1;

  //  if ( attr_rtvirtual)
  //    return 1;

  if (streq(ctx->rw->attr_pgmname, ""))
    strcpy(pgmname, ctx->rw->attr_name);
  else
    strcpy(pgmname, ctx->rw->attr_pgmname);

  if (str_StartsWith(CnvCtx::low(ctx->rw->attr_typeref), "pwr_etype_"))
    strcpy(ctx->rw->attr_typeref, &ctx->rw->attr_typeref[strlen("pwr_etype_")]);
  else if (str_StartsWith(CnvCtx::low(ctx->rw->attr_typeref), "pwr_etypedef_"))
    strcpy(
        ctx->rw->attr_typeref, &ctx->rw->attr_typeref[strlen("pwr_etypedef_")]);

  if (streq(CnvCtx::low(ctx->rw->attr_type), "buffer")) {
    strcpy(type_name, "pwr_s");
    if (ctx->rw->attr_typeref[11] == '$')
      strcat(type_name, &ctx->rw->attr_typeref[12]);
    else
      strcat(type_name, &ctx->rw->attr_typeref[11]);
  } else if (streq(CnvCtx::low(ctx->rw->attr_typeref), "attrref")) {
    strcpy(type_name, "pwr_s");
    strcat(type_name, ctx->rw->attr_typeref);
  } else if (ctx->rw->attr_isclass) {
    if (ctx->hpp)
      strcpy(type_name, "pwr_Class_");
    else
      strcpy(type_name, "pwr_sClass_");
    strcat(type_name, ctx->rw->attr_typeref);
  } else {
    strcpy(type_name, "pwr_t");
    strcat(type_name, ctx->rw->attr_typeref);
  }
  // For backward compatibility...
  if (streq(type_name, "pwr_tObjId"))
    strcpy(type_name, "pwr_tObjid");

  // Check type for baseclasses
  if (streq(CnvCtx::low(ctx->rw->volume_name), "pwrb")) {
    sts = check_typename(ctx->rw->attr_typeref_volume, type_name);
    if (EVEN(sts)) {
      printf("Error, unknown attribute type '%s'", type_name);
      return sts;
    }
  }

  if (ctx->hpp && attr_count == 0) {
    if (ctx->rw->attr_isclass && streq(pgmname, "Super")) {
      fp_struct << ": public " << type_name << " {\n"
                << " public:\n";
      if (!ctx->common_structfile_only)
        fp_cstruc << type_name << " {\n"
                  << " public:\n";
      attr_count++;
      return 1;
    } else {
      fp_struct << " {\n"
                << " public:\n";
      if (!ctx->common_structfile_only)
        fp_cstruc << " {\n"
                  << " public:\n";
    }
  }

  if (streq(CnvCtx::low(ctx->rw->attr_type), "input")) {
    if (ctx->rw->attr_array && ctx->rw->attr_pointer) {
      fp_struct << "  " << type_name;
      if (!ctx->common_structfile_only)
        fp_cstruc << "  " << type_name;
      for (i = 0; i < int(35 - strlen(type_name)); i++) {
        fp_struct << ' ';
        if (!ctx->common_structfile_only)
          fp_cstruc << ' ';
      }
      fp_struct << " **" << pgmname << "P[" << ctx->rw->attr_elements << "]"
                << alignstr << ";\n";
      if (!ctx->common_structfile_only)
        fp_cstruc << " **" << pgmname << "P[" << ctx->rw->attr_elements << "]"
                  << alignstr << ";\n";
    } else if (ctx->rw->attr_array) {
      fp_struct << "  " << type_name;
      if (!ctx->common_structfile_only)
        fp_cstruc << "  " << type_name;
      for (i = 0; i < int(35 - strlen(type_name)); i++) {
        fp_struct << ' ';
        if (!ctx->common_structfile_only)
          fp_cstruc << ' ';
      }
      fp_struct << " *" << pgmname << "P[" << ctx->rw->attr_elements << "]"
                << alignstr << ";\n";
      if (!ctx->common_structfile_only)
        fp_cstruc << " *" << pgmname << "P[" << ctx->rw->attr_elements << "]"
                  << alignstr << ";\n";
    } else if (ctx->rw->attr_pointer) {
      fp_struct << "  " << type_name;
      if (!ctx->common_structfile_only)
        fp_cstruc << "  " << type_name;
      for (i = 0; i < int(35 - strlen(type_name)); i++) {
        fp_struct << ' ';
        if (!ctx->common_structfile_only)
          fp_cstruc << ' ';
      }
      fp_struct << " **" << pgmname << "P" << alignstr << ";\n";
      if (!ctx->common_structfile_only)
        fp_cstruc << " **" << pgmname << "P" << alignstr << ";\n";
    } else {
      fp_struct << "  " << type_name;
      if (!ctx->common_structfile_only)
        fp_cstruc << "  " << type_name;
      for (i = 0; i < int(35 - strlen(type_name)); i++) {
        fp_struct << ' ';
        if (!ctx->common_structfile_only)
          fp_cstruc << ' ';
      }
      fp_struct << " *" << pgmname << "P" << alignstr << ";\n";
      if (!ctx->common_structfile_only)
        fp_cstruc << " *" << pgmname << "P" << alignstr << ";\n";
    }
  }

  if (ctx->rw->attr_array && ctx->rw->attr_pointer) {
    // Should be "'typename' *" which is changed to "pwr_tUInt64 "
    // to get correct alignment for elements
    fp_struct << "  "
              << "pwr_tUInt64";
    if (!ctx->common_structfile_only)
      fp_cstruc << "  "
                << "pwr_tUInt64";
    for (i = 0; i < int(35 - strlen("pwr_tUInt64")); i++) {
      fp_struct << ' ';
      if (!ctx->common_structfile_only)
        fp_cstruc << ' ';
    }
    fp_struct << " " << pgmname << "[" << ctx->rw->attr_elements << "]"
              << alignstr << ";\n";
    if (!ctx->common_structfile_only)
      fp_cstruc << " " << pgmname << "[" << ctx->rw->attr_elements << "]"
                << alignstr << ";\n";
  } else if (ctx->rw->attr_array) {
    fp_struct << "  " << type_name;
    if (!ctx->common_structfile_only)
      fp_cstruc << "  " << type_name;
    for (i = 0; i < int(35 - strlen(type_name)); i++) {
      fp_struct << ' ';
      if (!ctx->common_structfile_only)
        fp_cstruc << ' ';
    }
    fp_struct << ' ' << pgmname << "[" << ctx->rw->attr_elements << "]"
              << alignstr << ";\n";
    if (!ctx->common_structfile_only)
      fp_cstruc << pgmname << "[" << ctx->rw->attr_elements << "]" << alignstr
                << ";\n";
  } else if (ctx->rw->attr_pointer) {
    fp_struct << "  " << type_name;
    if (!ctx->common_structfile_only)
      fp_cstruc << "  " << type_name;
    for (i = 0; i < int(35 - strlen(type_name)); i++) {
      fp_struct << ' ';
      if (!ctx->common_structfile_only)
        fp_cstruc << ' ';
    }
    fp_struct << " *" << pgmname << alignstr << ";\n";
    if (!ctx->common_structfile_only)
      fp_cstruc << " *" << pgmname << alignstr << ";\n";
  } else {
    fp_struct << "  " << type_name;
    if (!ctx->common_structfile_only)
      fp_cstruc << "  " << type_name;
    for (i = 0; i < int(35 - strlen(type_name)); i++) {
      fp_struct << ' ';
      if (!ctx->common_structfile_only)
        fp_cstruc << ' ';
    }
    fp_struct << ' ' << pgmname << alignstr << ";\n";
    if (!ctx->common_structfile_only)
      fp_cstruc << pgmname << alignstr << ";\n";
  }

  attr_count++;
  return 1;
}

int CnvWblToH::typedef_exec()
{
  if (streq(ctx->rw->typedef_typeref, "Mask")
      || streq(ctx->rw->typedef_typeref, "Enum")) {
    if (streq(ctx->rw->typedef_pgmname, ""))
      strcpy(ctx->rw->typedef_pgmname, ctx->rw->typedef_name);

    fp_struct << "/*_* " << ctx->rw->typedef_typeref << ": "
              << ctx->rw->typedef_name << '\n'
              << "    @Aref " << ctx->rw->typedef_name << " "
              << ctx->rw->typedef_name << '\n'
              << "*/\n\n"
              << "typedef pwr_t" << ctx->rw->typedef_typeref << " pwr_t"
              << ctx->rw->typedef_name << ";\n\n"
              << "typedef enum {\n";
  } else if (streq(ctx->rw->typedef_typeref, "String")) {
    if (ctx->rw->typedef_elements > 1)
      fp_struct << "typedef char pwr_t" << ctx->rw->typedef_name << "["
                << ctx->rw->typedef_elements << "];\n\n";
    else
      fp_struct << "typedef char pwr_t" << ctx->rw->typedef_name << ";\n\n";
  } else {
    if (ctx->rw->typedef_elements > 1)
      fp_struct << "typedef pwr_t" << ctx->rw->typedef_typeref << " pwr_t"
                << ctx->rw->typedef_name << "[" << ctx->rw->typedef_elements
                << "];\n\n";
    else
      fp_struct << "typedef pwr_t" << ctx->rw->typedef_typeref << " pwr_t"
                << ctx->rw->typedef_name << ";\n\n";
  }

  struct_class_open = 1;
  return 1;
}

int CnvWblToH::typedef_close()
{
  if (streq(ctx->rw->typedef_pgmname, ""))
    strcpy(ctx->rw->typedef_pgmname, ctx->rw->typedef_name);

  if (streq(ctx->rw->typedef_typeref, "Mask"))
    fp_struct << "} pwr_m" << ctx->rw->typedef_pgmname << ";\n\n";
  else if (streq(ctx->rw->typedef_typeref, "Enum"))
    fp_struct << "} pwr_e" << ctx->rw->typedef_pgmname << ";\n\n";

  struct_class_open = 0;
  return 1;
}

int CnvWblToH::bit_exec()
{
  char pgmname[80];
  int i;

  if (streq(ctx->rw->typedef_pgmname, ""))
    strcpy(ctx->rw->typedef_pgmname, ctx->rw->typedef_name);

  if (streq(ctx->rw->bit_pgmname, ""))
    strcpy(pgmname, ctx->rw->bit_name);
  else
    strcpy(pgmname, ctx->rw->bit_pgmname);

  if (streq(ctx->rw->bit_type, "Bit")) {
    fp_struct << "  pwr_m" << ctx->rw->typedef_pgmname << "_" << pgmname;
    for (i = 0;
         i < int(30 - strlen(ctx->rw->typedef_pgmname) - strlen(pgmname)); i++)
      fp_struct << ' ';
    fp_struct << " = " << ctx->rw->bit_value << "UL,\n";
  } else if (streq(ctx->rw->bit_type, "Value")) {
    fp_struct << "  pwr_e" << ctx->rw->typedef_pgmname << "_" << pgmname;
    for (i = 0;
         i < int(30 - strlen(ctx->rw->typedef_pgmname) - strlen(pgmname)); i++)
      fp_struct << ' ';
    fp_struct << " = " << (int)ctx->rw->bit_value << ",\n";
  }
  return 1;
}

int CnvWblToH::volname_to_id()
{
  FILE* fp;
  pwr_tFileName fname;
  char line[400];
  char line_part[4][80];
  int nr;
  int sts;
  unsigned int vid_0, vid_1, vid_2, vid_3;

  strcpy(struct_volid, "");

  strcpy(fname, ctx->rw->source_dir);
  strcat(fname, CnvCtx::low(ctx->rw->volume_name));
  strcat(fname, "_v.wb_load");

  fp = fopen(fname, "r");
  if (!fp) {
    strcpy(fname, ctx->rw->current_file);
    fp = fopen(fname, "r");
    if (!fp) {
      printf("** Unable to find Volume declaration\n");
      return 0;
    }
  }

  while (1) {
    sts = CnvCtx::read_line(line, sizeof(line), fp);
    if (!sts)
      break;
    else {
      str_trim(line, line);
      if (streq(line, ""))
        continue;

      if (line[0] == '!')
        continue;

      nr = dcli_parse(line, " 	=", "", (char*)line_part,
          sizeof(line_part) / sizeof(line_part[0]), sizeof(line_part[0]), 0);
      if (streq(CnvCtx::low(line_part[0]), "volume")) {
        if (nr > 3) {
          strcpy(struct_volid, line_part[3]);
          break;
        }
      }
    }
  }
  fclose(fp);

  if (streq(struct_volid, ""))
    return 0;

  if (sscanf(struct_volid, "%d.%d.%d.%d", &vid_3, &vid_2, &vid_1, &vid_0) != 4)
    return 0;

  struct_vid_0 = vid_0;
  struct_vid_1 = vid_1;

  return 1;
}

void CnvWblToH::cix_to_classid(unsigned int cix, pwr_tClassId* cid)
{
  cdh_uTypeId lcid;

  lcid.pwr = pwr_cNClassId;
  lcid.c.vid_1 = struct_vid_1;
  lcid.c.vid_0 = struct_vid_0;
  lcid.c.cix = cix;

  *cid = lcid.pwr;
}

int CnvWblToH::cixstr_to_classid(char* cix_str, pwr_tClassId* cid)
{
  int found;
  struct_tCixArray* cix_p;
  struct_tCixArray cix_array[] = { { "pwr_eCix_ClassDef", pwr_eCix_ClassDef },
    { "pwr_eCix_Type", pwr_eCix_Type },
    { "pwr_eCix_TypeDef", pwr_eCix_TypeDef },
    { "pwr_eCix_ObjBodyDef", pwr_eCix_ObjBodyDef },
    { "pwr_eCix_Param", pwr_eCix_Param }, { "pwr_eCix_Input", pwr_eCix_Input },
    { "pwr_eCix_Output", pwr_eCix_Output },
    { "pwr_eCix_Intern", pwr_eCix_Intern },
    { "pwr_eCix_Buffer", pwr_eCix_Buffer },
    { "pwr_eCix_ObjXRef", pwr_eCix_ObjXRef },
    { "pwr_eCix_Layout", pwr_eCix_Layout },
    { "pwr_eCix_Group", pwr_eCix_Group },
    { "pwr_eCix_GroupRef", pwr_eCix_GroupRef },
    { "pwr_eCix_TypeHier", pwr_eCix_TypeHier },
    { "pwr_eCix_ClassHier", pwr_eCix_ClassHier },
    { "pwr_eCix_ModHier", pwr_eCix_ModHier },
    { "pwr_eCix_PlantHier", pwr_eCix_PlantHier },
    { "pwr_eCix_PlcProgram", pwr_eCix_PlcProgram },
    { "pwr_eCix_PlcWindow", pwr_eCix_PlcWindow },
    { "pwr_eCix_PlcNode", pwr_eCix_PlcNode },
    { "pwr_eCix_PlcConnection", pwr_eCix_PlcConnection },
    { "pwr_eCix_Point", pwr_eCix_Point },
    { "pwr_eCix_GraphPlcProgram", pwr_eCix_GraphPlcProgram },
    { "pwr_eCix_GraphPlcWindow", pwr_eCix_GraphPlcWindow },
    { "pwr_eCix_GraphPlcNode", pwr_eCix_GraphPlcNode },
    { "pwr_eCix_GraphPlcConnection", pwr_eCix_GraphPlcConnection },
    { "pwr_eCix_PlcPgm", pwr_eCix_PlcPgm },
    { "pwr_eCix_Hierarchy", pwr_eCix_Hierarchy },
    { "pwr_eCix_NodeHier", pwr_eCix_NodeHier },
    { "pwr_eCix_PgmDef", pwr_eCix_PgmDef }, { "pwr_eCix_Node", pwr_eCix_Node },
    { "pwr_eCix_Appl", pwr_eCix_Appl }, { "pwr_eCix_System", pwr_eCix_System },
    { "pwr_eCix_LibHier", pwr_eCix_LibHier },
    { "pwr_eCix_DocHier", pwr_eCix_DocHier },
    { "pwr_eCix_AttrXRef", pwr_eCix_AttrXRef },
    { "pwr_eCix_Menu", pwr_eCix_Menu },
    { "pwr_eCix_MenuSeparator", pwr_eCix_MenuSeparator },
    { "pwr_eCix_MenuCascade", pwr_eCix_MenuCascade },
    { "pwr_eCix_MenuButton", pwr_eCix_MenuButton },
    { "pwr_eCix_Object", pwr_eCix_Object },
    { "pwr_eCix_DbCallBack", pwr_eCix_DbCallBack },
    { "pwr_eCix_Alias", pwr_eCix_Alias },
    { "pwr_eCix_RootVolume", pwr_eCix_RootVolume },
    { "pwr_eCix_SubVolume", pwr_eCix_SubVolume },
    { "pwr_eCix_SharedVolume", pwr_eCix_SharedVolume },
    { "pwr_eCix_DynamicVolume", pwr_eCix_DynamicVolume },
    { "pwr_eCix_SystemVolume", pwr_eCix_SystemVolume },
    { "pwr_eCix_ClassVolume", pwr_eCix_ClassVolume },
    { "pwr_eCix_DetachedClassVolume", pwr_eCix_DetachedClassVolume },
    { "pwr_eCix_WorkBenchVolume", pwr_eCix_WorkBenchVolume },
    { "pwr_eCix_DirectoryVolume", pwr_eCix_DirectoryVolume },
    { "pwr_eCix_CreateVolume", pwr_eCix_CreateVolume },
    { "pwr_eCix_MountVolume", pwr_eCix_MountVolume },
    { "pwr_eCix_MountObject", pwr_eCix_MountObject },
    { "pwr_eCix_RtMenu", pwr_eCix_RtMenu },
    { "pwr_eCix_VolatileVolume", pwr_eCix_VolatileVolume },
    { "pwr_eCix_MenuRef", pwr_eCix_MenuRef }, { "pwr_eCix_Bit", pwr_eCix_Bit },
    { "pwr_eCix_Value", pwr_eCix_Value },
    { "pwr_eCix_Method", pwr_eCix_Method },
    { "pwr_eCix_RtMethod", pwr_eCix_RtMethod },
    { "pwr_eCix_ExternVolume", pwr_eCix_ExternVolume },
    { "pwr_eCix_Hier", pwr_eCix_Hier },
    { "pwr_eCix_Security", pwr_eCix_Security },
    { "pwr_eCix_ReferenceList", pwr_eCix_ReferenceList },
    { "pwr_eCix_Block", pwr_eCix_Block },
    { "pwr_eCix_BlockAttribute", pwr_eCix_BlockAttribute },
    { "pwr_eCix_SubBlock", pwr_eCix_SubBlock }, 
    { "pwr_eCix_MountDynObject", pwr_eCix_MountDynObject }, 
    { "", 0 } };

  found = 0;
  for (cix_p = cix_array; !streq(cix_p->name, ""); cix_p++) {
    if (streq(cix_str, cix_p->name)) {
      found = 1;
      break;
    }
  }
  if (!found)
    return 0;

  cix_to_classid(cix_p->id, cid);
  return 1;
}

void CnvWblToH::get_filename(CnvReadWbl* rw, char* struct_file, int hpp)
{
  strcpy(struct_file, "pwr_");

  if (streq(CnvCtx::low(rw->volume_name), "pwrb"))
    strcat(struct_file, "base");
  else if (streq(CnvCtx::low(rw->volume_name), "pwrs"))
    // To separate from pwr_systemclasses.h
    strcat(struct_file, "system");
  else
    strcat(struct_file, CnvCtx::low(rw->volume_name));

  if (hpp)
    strcat(struct_file, "classes.hpp");
  else
    strcat(struct_file, "classes.h");
}

int CnvWblToH::check_typename(char* type_volume, char* type_name)
{
  // Only types in pwrs can be typechecked
  if (streq(type_volume, "pwrs") || streq(type_volume, "")) {
    char* name;
    char valid_names[][40] = { "pwr_tAddress", "pwr_tBit", "pwr_tBitMask",
      "pwr_tBoolean", "pwr_tFloat32", "pwr_tFloat64", "pwr_tGeneration",
      "pwr_tChar", "pwr_tString", "pwr_tText", "pwr_tInt8", "pwr_tInt16",
      "pwr_tInt32", "pwr_tStatus", "pwr_tNetStatus", "pwr_tInt64",
      "pwr_tUInt64", "pwr_tUInt8", "pwr_tUInt16", "pwr_tUInt32",
      "pwr_tVolumeId", "pwr_tObjectIx", "pwr_tMask", "pwr_tEnum",
      "pwr_tClassId", "pwr_tTypeId", "pwr_tVersion", "pwr_tPwrVersion",
      "pwr_tProjVersion", "pwr_tUserId", "pwr_tDbId", "pwr_tNodeId",
      "pwr_tNodeIndex", "pwr_tDlid", "pwr_tSubid", "pwr_tTime",
      "pwr_tDeltaTime", "pwr_tRefId", "pwr_tObjid", "pwr_sAttrRef",
      "pwr_sPlcNode", "pwr_sPlcConnection", "pwr_sPlcWindow", "pwr_sPlcProgram",
      "pwr_tString256", "pwr_tString132", "pwr_tString80", "pwr_tString40",
      "pwr_tString32", "pwr_tString16", "pwr_tString8", "pwr_tString1",
      "pwr_tText256", "pwr_tText1024", "pwr_tText8192", "pwr_tURL",
      "pwr_tOpSysEnum", "pwr_tPrivMask", "pwr_tProString40", "pwr_tDataRef",
      "pwr_tVoid", "pwr_tConfigStatusEnum", "pwr_tSafetyLevelEnum", "pwr_tPgmName",
      "pwr_tAdefFlags", "pwr_tObjName", "pwr_sClass_BlockAttribute", 
      "pwr_Class_BlockAttribute", "" };

    for (name = valid_names[0]; !streq(name, "");
         name += sizeof(valid_names[0])) {
      if (streq(name, type_name))
        return 1;
    }
    return 0;
  } else
    return 1;
}
