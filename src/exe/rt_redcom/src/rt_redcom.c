/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_redcom.c -- Redundance communication monitor. */

#include <errno.h>
#include <netdb.h>
#include <sched.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>

#include "pwr_names.h"

#include "co_dcli.h"
#include "co_string.h"
#include "co_timelog.h"
#include "co_tree.h"

#include "rt_qdb.h"
#include "rt_net.h"
#include "rt_qmon.h"
#include "rt_gdh.h"
#include "rt_que.h"
#include "rt_thread.h"
#include "rt_proc.h"
#include "rt_thread_msg.h"
#include "rt_pwr_msg.h"
#include "rt_ini_event.h"
#include "rt_redu.h"
#include "rt_aproc.h"
#include "rt_redu_msg.h"

#define RTT_RXMIN 0.0500 /* seconds */
#define RTT_RXMAX 10.000 /* seconds */
#define EXPORT_BUF_WARN_LEVEL 300000
#define EXPORT_BUF_QUOTA 600000
#define K_FILTER 0.99

typedef enum {
  eAction__ = 0,
  eAction_export,
  eAction_import,
  eAction_tmo,
  eAction_
} eAction;

typedef union {
  pwr_tBitMask m;
  pwr_32Bits(pwr_Bits(version, 3), , , pwr_Bits(first, 1), pwr_Bits(middle, 1),
      pwr_Bits(last, 1), pwr_Bits(fill_0, 2), ,

      pwr_Bits(bcast, 1), pwr_Bits(resent, 1), pwr_Bits(fill_1, 6), , , , , ,
      pwr_Bits(fill_2, 8), , , , , , , , pwr_Bits(event, 8), , , , , , , ) b;

#define mSeg_first pwr_Bit(3)
#define mSeg_middle pwr_Bit(4)
#define mSeg_last pwr_Bit(5)
#define mSeg_single (mSeg_first | mSeg_middle | mSeg_last)
} mSeg;

typedef struct sLink sLink;
typedef struct sHead sHead;
typedef struct sCseg sCseg;
typedef struct sEseg sEseg;
typedef struct sIseg sIseg;

struct sHead {
  pwr_tNodeId nid pwr_dPacked; /* Node identitiy. */
  int birth pwr_dPacked; /* Time when link was born. */
  mSeg flags pwr_dPacked;
  qdb_sAck lack;
  qdb_sAck rack;
  int prio;
  int state;
};

typedef struct {
  pwr_tNodeId nid; /* node identity */
  pwr_tBoolean initiated; /* are values valid */
  pwr_tUInt32 birth; /* current incarnation identity */
  char name[80]; /* ascii name of node (nul-terminated)
                    zero-length means empty slot */
  struct in_addr naddr;
  int port;
  int version; /* Qcom protocol version */

  qdb_sLink link; /* Qmon link information. */
  pwr_tBoolean up; /* communication is up/down */
  qdb_mNode flags;
  pwr_tUInt32 upcnt; /* # of times up */
  pwr_tTime timeup; /* Most recent time link came up */
  pwr_tTime timedown; /* Most recent time link went down */

  qdb_sCount get;
  qdb_sCount put;
  pwr_tUInt32 thrown_bufs;
  pwr_tUInt32 thrown_segs;
  pwr_tUInt32 lost_segs;

  qdb_sBuffer* bp;

  pwr_tBoolean in_arp;
  struct arpreq arp;

  struct sockaddr_in sa;

  void* mon; /* Monitor private data. */
  pwr_eRedundancyState redundancy_state;
  pwr_tUInt32 min_resend_time;
  pwr_tUInt32 max_resend_time;
  pwr_tUInt32 export_buf_quota;
  pwr_tFloat32 ack_delay;
  pwr_tUInt32 seg_size;
} redu_sNode;

struct sCseg {
  eAction action;
  lst_sEntry le;
};

struct sEseg {
  sCseg c;
  sHead head;
  unsigned int size;
  sLink* lp;
  lst_sEntry le_bcast;
  lst_sEntry le_seg;
  unsigned int id;
  qdb_sBuffer* bp;
  char* p;
  int bytes;
  pwr_tTime tmo;
  int sent;
  pwr_tTime send_ts;
};

struct sIseg {
  sCseg c;
  sHead head;
  unsigned int size;
  int ts_recv;
  sLink* lp;
  pwr_tStatus sts;
  char buff[1];
};

typedef union {
  eAction action;
  sCseg c;
  sEseg e;
  sIseg i;
} uSeg;

struct sLink {
  tree_sNode tree;
  pwr_tNodeId nid;
  int idx;
  lst_sEntry lh_send;
  lst_sEntry lh_win;
  que_sQue q_in;
  redu_sNode* np;
  thread_s thread;
  qdb_sBuffer* bp[redu_ePrio__];
  char* p[redu_ePrio__];
  pwr_tDeltaTime ack_delay;
  unsigned int exp_buf_quota;
  sIseg tmo;
  thread_sMutex eseg_mutex;
  pwr_tTime receive_time;
  int passive_timeout;
};

typedef struct {
  sHead head;
  qdb_sInfo info;
  struct sockaddr_in sa;
  struct iovec iov[3];
  struct msghdr msg;
} sMsg;

typedef enum {
  eEvent__ = 0,
  eEvent_connect,
  eEvent_down,
  eEvent_user,
  eEvent_ack,
  eEvent_set_active,
  eEvent_set_passive,
  eEvent_set_off,
  eEvent_
} eEvent;

struct {
  sHead head;
  pwr_tNid nid;
  pwr_sNode* nodep;
  pwr_sClass_RedcomConfig* config;
  pwr_tUInt32 min_resend_time;
  pwr_tUInt32 max_resend_time;
  pwr_tUInt32 export_buf_quota;
  pwr_tFloat32 ack_delay;
  pwr_tUInt32 seg_size;
  int port;
  struct sockaddr_in sa;
  int sock;
  redu_sNode redu_node[2];
  int redu_nodes;
  struct {
    lst_sEntry lh;
    thread_sMutex mutex;
    int count;
  } eseg;
  struct {
    lst_sEntry lh;
    thread_sMutex mutex;
    int count;
  } iseg;
  struct {
    int count;
    tree_sTable* table;
    thread_sMutex mutex;
  } links;
  thread_sMutex bcast;
  thread_sMutex send_mutex;
  struct {
    thread_s thread;
    thread_sMutex mutex;
    thread_sCond cond;
  } import;
  struct {
    thread_s thread;
  } export;
  struct {
    thread_s thread;
  } cyclic;
  qdb_sLinkInfo link_info;
  pwr_tStatus sts;
  struct {
    int initialized;
    pwr_tBoolean force_old;
    pwr_tBoolean emergbreaktrue_old;
    pwr_eUpDownEnum linkstate_old;
    pwr_tStatus systemstatus_old;
    pwr_tTime startup_time;
    int startup_timeout;
  } sup;
  int pending_set_active;
  pwr_tTime pending_set_active_time;
  pwr_tTime last_switch_time;
  pwr_eRedundancyState default_redundancy_state;
} l;

static pwr_tStatus redu_sts = PWR__SRVSTARTUP;
static int tics_per_sec = 0;
static unsigned int redu_segment_size = 8192 - sizeof(sHead);

static void cancel_links();
static pwr_tBoolean clean_insert(lst_sEntry*, sEseg*, pwr_tBoolean);
static sEseg* create_connect(sLink*);
static void create_links();
static void decode_head(sHead*, sHead*);
static void decode_info(qdb_sInfo*);
static void encode_head(sHead*, sHead*);
static void encode_info(qdb_sInfo*, qdb_sInfo*);
static sEseg* eseg_alloc(thread_sMutex*);
static sEseg* eseg_build(qdb_sBuffer*);
static void eseg_free(sEseg*);
static char* event_string(eEvent);
static pwr_tBoolean expired(pwr_tTime*);
static void* export_thread();
static sLink* get_link(pwr_tNodeId, sMsg*);
static void get_tmo(sLink*, pwr_tBoolean, pwr_tTime*);
static void* import_thread();
static void* cyclic_thread();
static void ini_link_info(qdb_sLinkInfo*);
static sIseg* iseg_alloc();
static void iseg_free(sIseg*);
static void iseg_import(sLink*, sIseg*);
static void lack(sLink*, sIseg*);
static void link_active(sLink*);
static void link_connect(sLink*, sIseg*);
static void link_purge(sLink*);
static void link_disconnect(sLink*);
static void link_import(sLink*, sIseg*);
static void link_redisconnect(sLink*);
static void link_send(sLink*);
static void link_stalled(sLink*);
static void* link_thread(sLink*);
static pwr_tDeltaTime* link_tmo(sLink*);
static sLink* new_link(pwr_tNodeId, sMsg*);
static void open_socket();
static sEseg* pending_send(sLink*);
static void send_ack(sLink*);
static void set_link_info(sLink*, qdb_sLinkInfo*);
static void set_rack(sLink*, sIseg*);
static void set_recvmsg(sIseg*, sMsg*);
static void seg_send(sLink*, sEseg*);
static void set_sendmsg(sLink*, sEseg*, sMsg*);
static void start_rto(sLink*);
static void update_rtt(sLink*, sEseg*);
static void window_insert(sLink*, sEseg*);
static void window_remove(sLink*, sEseg*);
static sEseg* window_tmo(sLink*);
static void check_link_status();
static void set_status(pwr_tStatus);
static void purge(void);
static pwr_tStatus redu_node_init();
static redu_sNode* get_node(pwr_tNodeId nid);
static void state_change_request(
    sLink* lp, sIseg* sp, pwr_eRedundancyState state);
static sEseg* request_state_change(sLink* lp, pwr_eRedundancyState state);
static void send_state_change();

int main(int argc, char* argv[])
{
  pwr_tStatus sts;
  qcom_sQid qid = { redu_cQixExport, 0 };
  qcom_sQattr qattr;
  qcom_sQid my_q = qcom_cNQid;
  pwr_tOid oid;

  errh_Init("pwr_redcom", errh_eAnix_redcom);
  errh_SetStatus(PWR__SRVSTARTUP);

  if (!qcom_Init(&sts, NULL, "pwr_redcom")) {
    errh_Fatal("qcom_Init, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  sts = gdh_Init("pwr_redcom");
  if (EVEN(sts)) {
    errh_Fatal("gdh_Init, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  /* Get node object */
  sts = gdh_GetNodeObject(pwr_cNNodeId, &oid);
  if (ODD(sts))
    sts = gdh_ObjidToPointer(oid, (void**)&l.nodep);
  if (EVEN(sts)) {
    errh_Error("No node object, terminated");
    errh_SetStatus(0);
    exit(sts);
  }

  /* Get configuration object */
  sts = gdh_GetClassList(pwr_cClass_RedcomConfig, &oid);
  if (EVEN(sts)) {
    errh_Error("No config object, terminated");
    errh_SetStatus(0);
    exit(sts);
  }

  sts = gdh_ObjidToPointer(oid, (void**)&l.config);
  if (EVEN(sts)) {
    errh_Error("Config object, %m", sts);
    errh_SetStatus(sts);
    exit(sts);
  }
  aproc_RegisterObject(oid);

  l.nid = ntohl(qdb->my_node->sa.sin_addr.s_addr);

  sts = redu_node_init();
  if (EVEN(sts)) {
    exit(0);
  }

  qattr.type = qcom_eQtype_private;
  qattr.quota = 1000;

  if (!qcom_CreateQ(&sts, &qid, &qattr, "Export")) {
    qcom_DeleteQ(&sts, &qid);
    if (!qcom_CreateQ(&sts, &qid, &qattr, "Export")) {
      errh_Fatal("qcom_CreateQ, %m", sts);
      errh_SetStatus(PWR__SRVTERM);
      exit(sts);
    }
  }

  if (!qcom_CreateQ(&sts, &my_q, NULL, "events")) {
    errh_Fatal("qcom_CreateQ, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  l.head.nid = l.nid;
  l.head.birth = qdb->my_node->link[0].birth = time_Clock(NULL, NULL);
  ini_link_info(&l.link_info);

  do {
    lst_Init(NULL, &l.eseg.lh, NULL);
    lst_Init(NULL, &l.iseg.lh, NULL);
    open_socket();
    sts = thread_MutexInit(&l.eseg.mutex);
    sts = thread_MutexInit(&l.iseg.mutex);
    sts = thread_MutexInit(&l.links.mutex);
    sts = thread_MutexInit(&l.send_mutex);
    sts = thread_MutexInit(&l.import.mutex);
    sts = thread_CondInit(&l.import.cond);

    l.links.table = tree_CreateTable(&sts, sizeof(pwr_tNodeId),
        offsetof(sLink, nid), sizeof(sLink), 100, tree_Comp_nid);

    create_links();

    thread_Create(&l.import.thread, "import", import_thread, NULL);
    thread_Create(&l.export.thread, "export", export_thread, NULL);
    thread_Create(&l.cyclic.thread, "cyclic", cyclic_thread, NULL);

  } while (0);

  if (l.nodep->RedundancyState == pwr_eRedundancyState_Init
      || l.nodep->RedundancyState == pwr_eRedundancyState_Passive) {
    l.pending_set_active = 1;
    time_GetTimeMonotonic(&l.pending_set_active_time);
    l.sup.startup_timeout = 1;
    l.sup.startup_time = l.pending_set_active_time;
  }

  check_link_status();
  set_status(PWR__SRUN);

  qcom_WaitAnd(
      &sts, &my_q, &qcom_cQini, ini_mEvent_terminate, qcom_cTmoEternal);

  set_status(PWR__SRVTERM);
  errh_Info("Closing down, %m", sts);
  cancel_links();
  thread_Cancel(&l.import.thread);
  thread_Cancel(&l.export.thread);
  thread_Cancel(&l.cyclic.thread);

  qcom_Exit(&sts);
  errh_Info("Exiting");
  exit(REDU__SUCCESS);
}
static pwr_tStatus redu_node_init()
{
  pwr_tFileName fname;
  FILE* fp;
  char buffer[256];
  char name[80];
  char s_nid[80];
  char s_naddr[80];
  char s_port[80];
  char s_state[10];
  char s_min_resend_time[20];
  char s_max_resend_time[20];
  char s_export_buf_quota[20];
  char s_ack_delay[20];
  char s_seg_size[20];
  char* s;
  int errors = 0;
  struct in_addr naddr;
  struct arpreq arpreq;
  int n, n2;
  int sts;
  int nid = 1;
  redu_sNode* np;
  int local_found = 0;

  sprintf(fname, pwr_cNameRedcom, "$pwrp_load/", qdb->my_node->link[0].name,
      qdb->g->bus);
  dcli_translate_filename(fname, fname);
  fp = fopen(fname, "r");
  if (!fp)
    return 0;

  while ((s = fgets(buffer, sizeof(buffer) - 1, fp)) != NULL) {
    if (*s == '#' || *s == '!') {
      s++;
      continue;
    }

    n = sscanf(s, "%s %s %s %s %s %s %s %s %s %s", name, s_nid, s_naddr, s_port,
        s_state, s_min_resend_time, s_max_resend_time, s_export_buf_quota,
        s_ack_delay, s_seg_size);

    if (n != 10) {
      errh_Error("Syntax error in %s", fname);
      errors++;
    }

    if (streq(name, qdb->my_node->link[0].name)) {
      local_found = 1;
      l.port = atoi(s_port);
      if (l.port == 0)
        l.port = redu_cPort;
      redu_segment_size = atoi(s_seg_size);
      if (redu_segment_size == 0)
	redu_segment_size = 8192;
      // l.nodep->RedundancyState = atoi(s_state);
      l.default_redundancy_state = atoi(s_state);
      l.min_resend_time = atoi(s_min_resend_time);
      l.max_resend_time = atoi(s_max_resend_time);
      l.export_buf_quota = atoi(s_export_buf_quota);
      n2 = sscanf(s_ack_delay, "%f", &l.ack_delay);
      if (n2 != 1)
        l.ack_delay = 0.001;
    } else {
      sts = net_StringToAddr(s_naddr, &naddr);
      if (EVEN(sts)) {
        errh_Error("Address error in %s", fname);
        errors++;
      }
      np = &l.redu_node[nid - 1];

      np->nid = naddr.s_addr;
      strcpy(np->name, name);
      np->naddr.s_addr = htonl(naddr.s_addr);
      np->port = atoi(s_port);
      if (np->port == 0)
        np->port = redu_cPort;
      np->min_resend_time = atoi(s_min_resend_time);
      np->max_resend_time = atoi(s_max_resend_time);
      np->export_buf_quota = atoi(s_export_buf_quota);
      n2 = sscanf(s_ack_delay, "%f", &np->ack_delay);
      if (n2 != 1)
        np->ack_delay = 0.001;
      np->seg_size = atoi(s_seg_size);
      if (np->seg_size == 0)
        np->seg_size = 8192;

      np->sa.sin_family = AF_INET;
      np->sa.sin_addr.s_addr = htonl(naddr.s_addr);
      np->sa.sin_port = htons(np->port);

      np->get.timer_max = 30;
      np->put.timer_max = 10;

      memset(&arpreq, 0, sizeof(arpreq));
      memcpy(&arpreq.arp_pa.sa_data, &naddr, sizeof(naddr));
      inet_GetArpEntry(&sts, 0, &arpreq);

      l.redu_nodes++;
      nid++;
      if (nid - 1 > sizeof(l.redu_node) / sizeof(l.redu_node[0]))
        break;
    }
  }
  fclose(fp);

  if (!local_found) {
    errh_Error("No local node in node file %s", fname);
    errors++;
  }

  if (errors)
    return 0;

  return 1;
}

static int export_alloc_check(sLink* lp)
{
  if (lp->np->link.export_alloc_cnt > EXPORT_BUF_WARN_LEVEL
      && redu_sts != REDU__BUFFHIGH)
    set_status(REDU__BUFFHIGH);
  if (lp->np->link.export_alloc_cnt > lp->exp_buf_quota) {
    link_purge(lp);
    return 1;
  }
  return 0;
}

static void export_alloc_sub(sEseg* sp)
{
  if (!sp || !sp->lp)
    return;

  sp->lp->np->link.export_alloc_cnt -= sp->size;
  if (sp->lp->np->link.export_alloc_cnt < 0)
    sp->lp->np->link.export_alloc_cnt = 0;
  if (redu_sts == REDU__BUFFHIGH
      && sp->lp->np->link.export_alloc_cnt < EXPORT_BUF_WARN_LEVEL)
    set_status(PWR__SRUN);
  l.config->Link[sp->lp->idx].ExportAlloc = sp->lp->np->link.export_alloc_cnt;
}

static void cancel_links()
{
  pwr_tStatus sts;
  sLink* lp;

  for (lp = tree_Minimum(&sts, l.links.table); lp != NULL;
       lp = tree_Successor(&sts, l.links.table, lp))
    thread_Cancel(&lp->thread);
}

/* Free unsent segments from que that has not been
   sent which will be replaced by new segment  */

static pwr_tBoolean clean_insert(
    lst_sEntry* le, sEseg* esp, pwr_tBoolean pending)
{
  lst_sEntry *se, *li;
  sEseg *sp, *nsp;
  pwr_tBoolean ret_pend = FALSE;
  pwr_tBoolean first = FALSE;

  li = le;
  if (esp->bp != NULL) {
    if (esp->bp->b.msg_id > 0) {
      if ((!pending) && (esp->head.flags.b.first)) {
        thread_MutexLock(&esp->lp->eseg_mutex);
        for (sp = lst_Succ(NULL, le, &se); se != le; sp = nsp) {
          li = se;
          nsp = lst_Succ(NULL, se, &se);

          if (sp->bp != NULL) {
            if (sp->bp->b.msg_id == esp->bp->b.msg_id) {
              if (sp->head.flags.b.first)
                first = TRUE;
              if (first) {
                eseg_free(sp);
                li = se;
              } else {
                // break;
              }
            } else if (first) {
              break;
            }
          } else if (first) {
            break;
          }
        }
        thread_MutexUnlock(&esp->lp->eseg_mutex);

        if (!esp->head.flags.b.last && first)
          ret_pend = TRUE;
        if (!first)
          li = le;
      } else if (pending) {
        thread_MutexLock(&esp->lp->eseg_mutex);
        for (sp = lst_Succ(NULL, le, &se); se != le; sp = nsp) {
          li = se;
          nsp = lst_Succ(NULL, se, &se);

          if (sp->bp != NULL) {
            if ((sp->bp->b.msg_id == esp->bp->b.msg_id)
                && (sp->bp == esp->bp)) {
              first = TRUE;
              li = se;
            } else if (first) {
              break;
            }
          } else if (first) {
            break;
          }
        }
        thread_MutexUnlock(&esp->lp->eseg_mutex);

        if (!first)
          li = le;
        ret_pend = !esp->head.flags.b.last;
      }
    }
  }

  /* Prioritize */
  if (!first) {
    thread_MutexLock(&esp->lp->eseg_mutex);
    for (sp = lst_Pred(NULL, le, &se); se != le; sp = lst_Pred(NULL, se, &se)) {
      li = se;

      if (sp->head.prio <= esp->head.prio)
        break;
    }
    if (se == le)
      lst_InsertPred(NULL, li, &esp->c.le, esp);
    else
      lst_InsertSucc(NULL, li, &esp->c.le, esp);
    thread_MutexUnlock(&esp->lp->eseg_mutex);
  } else {
    /* Insert new item */
    thread_MutexLock(&esp->lp->eseg_mutex);
    lst_InsertPred(NULL, li, &esp->c.le, esp);
    thread_MutexUnlock(&esp->lp->eseg_mutex);
  }

  return ret_pend;
}

static sEseg* create_connect(sLink* lp)
{
  sEseg* sp;

  sp = eseg_alloc(&l.eseg.mutex);
  sp->head.flags.b.event = eEvent_connect;
  sp->head.prio = redu_ePrio_0;
  sp->head.state = l.nodep->RedundancyState;
  sp->lp = lp;
  sp->c.action = eAction_export;

  /* Init receive timeout */
  if (l.nodep->RedundancyState == pwr_eRedundancyState_Init
      || l.nodep->RedundancyState == pwr_eRedundancyState_Passive) {
    time_GetTimeMonotonic(&lp->receive_time);
    lp->passive_timeout = 0;
  }
  return sp;
}

static void create_links()
{
  pwr_tStatus sts;
  int i;
  sLink* lp;

  for (i = 0; i < l.redu_nodes; i++)
    tree_Insert(&sts, l.links.table, &l.redu_node[i].nid);

  for (lp = tree_Minimum(&sts, l.links.table); lp != NULL;
       lp = tree_Successor(&sts, l.links.table, lp))
    new_link(lp->nid, NULL);
}

static void decode_head(sHead* tp, sHead* sp)
{
  tp->nid = ntohl(sp->nid);
  tp->birth = ntohl(sp->birth);
  tp->flags.m = ntohl(sp->flags.m);
  tp->lack.seq = ntohl(sp->lack.seq);
  tp->lack.ts = ntohl(sp->lack.ts);
  tp->rack.seq = ntohl(sp->rack.seq);
  tp->rack.ts = ntohl(sp->rack.ts);
  tp->prio = ntohl(sp->prio);
  tp->state = ntohl(sp->state);
}

static void decode_info(qdb_sInfo* ip)
{
  ip->sender.aix = ntohl(ip->sender.aix);
  ip->sender.nid = ntohl(ip->sender.nid);
  ip->pid = ntohl(ip->pid);
  ip->receiver.qix = ntohl(ip->receiver.qix);
  ip->receiver.nid = ntohl(ip->receiver.nid);
  ip->reply.qix = ntohl(ip->reply.qix);
  ip->reply.nid = ntohl(ip->reply.nid);
  ip->type.b = ntohl(ip->type.b);
  ip->type.s = ntohl(ip->type.s);
  ip->rid = ntohl(ip->rid);
  ip->tmo = ntohl(ip->tmo);
  ip->size = ntohl(ip->size);
  ip->flags.m = ntohl(ip->flags.m);
  ip->status = ntohl(ip->status);
}

static void encode_head(sHead* tp, sHead* sp)
{
  tp->nid = htonl(sp->nid);
  tp->birth = htonl(sp->birth);
  tp->flags.m = htonl(sp->flags.m);
  tp->lack.seq = htonl(sp->lack.seq);
  tp->lack.ts = htonl(sp->lack.ts);
  tp->rack.seq = htonl(sp->rack.seq);
  tp->rack.ts = htonl(sp->rack.ts);
  tp->prio = htonl(sp->prio);
  tp->state = htonl(sp->state);
}

static void encode_info(qdb_sInfo* tp, qdb_sInfo* sp)
{
  tp->sender.aix = htonl(sp->sender.aix);
  tp->sender.nid = htonl(sp->sender.nid);
  tp->pid = htonl(sp->pid);
  tp->receiver.qix = htonl(sp->receiver.qix);
  tp->receiver.nid = htonl(sp->receiver.nid);
  tp->reply.qix = htonl(sp->reply.qix);
  tp->reply.nid = htonl(sp->reply.nid);
  tp->type.b = htonl(sp->type.b);
  tp->type.s = htonl(sp->type.s);
  tp->rid = htonl(sp->rid);
  tp->tmo = htonl(sp->tmo);
  tp->size = htonl(sp->size);
  tp->flags.m = htonl(sp->flags.m);
  tp->status = htonl(sp->status);
}

static sEseg* eseg_alloc(thread_sMutex* mp)
{
  sEseg* sp;

  sp = lst_RemoveSucc(mp, &l.eseg.lh, NULL);
  if (sp == NULL) {
    sp = (sEseg*)calloc(1, sizeof(*sp));

    lst_Init(NULL, &sp->le_bcast, sp);
    lst_Init(NULL, &sp->le_seg, sp);
    lst_Init(NULL, &sp->c.le, sp);
  }

  return sp;
}

/* Build segments for a buffer.
   If buffer is to be broadcasted then allocate
   for all active links.  */

static sEseg* eseg_build(qdb_sBuffer* bp)
{
  pwr_tStatus sts;
  int size;
  sEseg* sp = NULL;
  sEseg* msp = NULL;
  sEseg* csp;
  sEseg* mcsp;
  sLink* lp;
  char* p;
  int ii;
  pwr_tBoolean bcast = bp->c.flags.b.broadcast;

  thread_MutexLock(&l.eseg.mutex);
  if (bcast)
    thread_MutexLock(&l.links.mutex);
  do {
    if (bcast) {
      for (lp = tree_Minimum(&sts, l.links.table); lp != NULL;
           lp = tree_Successor(&sts, l.links.table, lp)) {
        if (lp->np->link.flags.b.connected)
          break;
      }
    } else {
      bp->b.info.receiver.nid = l.redu_node[0].nid;
      switch (bp->b.prio) {
      case redu_ePrio_1:
        bp->b.info.receiver.qix = redu_cQixPrio1;
        break;
      case redu_ePrio_2:
        bp->b.info.receiver.qix = redu_cQixPrio2;
        break;
      case redu_ePrio_3:
        bp->b.info.receiver.qix = redu_cQixPrio3;
        break;
      case redu_ePrio_4:
        bp->b.info.receiver.qix = redu_cQixPrio4;
        break;
      case redu_ePrio_5:
        bp->b.info.receiver.qix = redu_cQixPrio5;
        break;
      case redu_ePrio_6:
        bp->b.info.receiver.qix = redu_cQixPrio6;
        break;
      case redu_ePrio_7:
        bp->b.info.receiver.qix = redu_cQixPrio7;
        break;
      case redu_ePrio_8:
        bp->b.info.receiver.qix = redu_cQixPrio8;
        break;
      case redu_ePrio_9:
        bp->b.info.receiver.qix = redu_cQixPrio9;
        break;
      case redu_ePrio_10:
        bp->b.info.receiver.qix = redu_cQixPrio10;
        break;
      }
      lp = get_link(bp->b.info.receiver.nid, NULL);
    }

    if (lp == NULL)
      break;

    for (msp = NULL, size = bp->b.info.size + sizeof(bp->b.info), ii = 0,
        p = (char*)&bp->b.info;
         size > 0; ii++, p += redu_segment_size, size -= redu_segment_size) {
      sp = eseg_alloc(NULL);
      sp->p = p;
      sp->bp = bp;
      sp->lp = lp;
      sp->id = ii;
      sp->size = MIN(size, redu_segment_size);
      sp->head.flags.b.event = eEvent_user;
      sp->head.flags.b.bcast = bcast;
      sp->head.prio = bp->b.prio;
      sp->head.state = l.nodep->RedundancyState;
      if (msp == NULL) {
        sp->head.flags.b.first = 1;
        msp = sp;
        /* todo initiera msp->le_seg.item = msp */
      } else {
        sp->head.flags.b.middle = 1;
        lst_InsertPred(NULL, &msp->le_seg, &sp->le_seg, sp);
      }
      lp->np->link.export_alloc_cnt += sp->size;
      l.config->Link[lp->idx].ExportAlloc = lp->np->link.export_alloc_cnt;
    }

    sp->head.flags.b.middle = 0;
    sp->head.flags.b.last = 1;

    if (bcast) {
      for (lp = tree_Successor(&sts, l.links.table, lp); lp != NULL;
           lp = tree_Successor(&sts, l.links.table, lp)) {
        mcsp = NULL;
        sp = msp;
        ii = 0;
        do {
          csp = eseg_alloc(NULL);
          csp->p = sp->p;
          csp->bp = bp;
          csp->lp = lp;
          csp->head.flags.m = sp->head.flags.m;
          csp->head.prio = bp->b.prio;
          csp->head.state = l.nodep->RedundancyState;
          csp->size = sp->size;
          csp->id = ii++;
          if (mcsp == NULL) {
            mcsp = csp;
            /* todo initiera msp->le_seg.item = msp */
          } else {
            lst_InsertPred(NULL, &mcsp->le_seg, &csp->le_seg, sp);
          }
          lst_InsertPred(NULL, &sp->le_bcast, &csp->le_bcast, csp);
          sp = lst_Succ(NULL, &sp->le_seg, NULL);

          csp->lp->np->link.export_alloc_cnt += csp->size;
          l.config->Link[csp->lp->idx].ExportAlloc
              = csp->lp->np->link.export_alloc_cnt;

        } while (sp != msp);
      }
    }

  } while (0);

  if (bcast)
    thread_MutexUnlock(&l.links.mutex);
  thread_MutexUnlock(&l.eseg.mutex);

  return msp;
}

static void eseg_free(sEseg* sp)
{
  pwr_tBoolean bcast = sp->head.flags.b.bcast;

  if (bcast)
    thread_MutexLock(&l.bcast);

  export_alloc_sub(sp);

  lst_Remove(NULL, &sp->c.le);
  if (lst_IsEmpty(NULL, &sp->le_bcast) && lst_IsEmpty(NULL, &sp->le_seg)) {
    if (sp->bp != NULL) {
      qdb_ScopeLock
      {
        qdb_Free(NULL, sp->bp);
      }
      qdb_ScopeUnlock;
    }
  } else {
    lst_Remove(NULL, &sp->le_bcast);
    lst_Remove(NULL, &sp->le_seg);
  }

  if (bcast)
    thread_MutexUnlock(&l.bcast);

  memset(sp, 0, sizeof(*sp));
  lst_Init(NULL, &sp->le_bcast, sp);
  lst_Init(NULL, &sp->le_seg, sp);
  lst_Init(NULL, &sp->c.le, sp);
  lst_InsertPred(&l.eseg.mutex, &l.eseg.lh, &sp->c.le, sp);
}

static char* event_string(eEvent event)
{
  static char* es[eEvent_ + 1] = { "<<low>>", "connect", "down", "user", "ack",
    "set active", "set passive", "set off", "<<high>>" };

  if (event <= eEvent__)
    return es[eEvent__];
  else if (event >= eEvent_)
    return es[eEvent_];
  else
    return es[event];
}

static pwr_tBoolean expired(pwr_tTime* clock)
{
  pwr_tTime now;

  time_GetTimeMonotonic(&now);
  return (time_Acomp(clock, &now) == -1);
}

static void* export_thread()
{
  pwr_tStatus sts;
  sEseg* sp;
  sEseg* ssp;
  sEseg* esp;
  qdb_sBuffer* bp;
  qdb_sQue* qp = NULL;
  qcom_sQid qid = { redu_cQixExport, 0 };

  qdb_ScopeLock
  {
    qp = qdb_Que(&sts, &qid, NULL);
  }
  qdb_ScopeUnlock;

  while (qdb->g->up) {
    sched_yield();
    qdb_ScopeLock
    {
      bp = qdb_Get(&sts, qp, qcom_cTmoEternal, NULL, 0);
      if (bp != NULL)
        bp = qdb_DetachBuffer(&sts, bp);
    }
    qdb_ScopeUnlock;

    if (bp == NULL)
      continue;
    pwr_Assert(bp->c.type == qdb_eBuffer_base);

    sp = eseg_build(bp);
    if (sp == NULL) {
      qdb_ScopeLock
      {
        qdb_Free(NULL, bp);
      }
      qdb_ScopeUnlock;
      continue;
    }
    export_alloc_check(sp->lp);

    thread_MutexLock(&l.bcast);

    thread_MutexLock(&sp->lp->eseg_mutex);
    esp = sp;
    do {
      ssp = esp;
      do {
        ssp->c.action = eAction_export;
        que_Put(NULL, &ssp->lp->q_in, &ssp->c.le, ssp);
        ssp = lst_Succ(NULL, &ssp->le_seg, NULL);
      } while (ssp != esp);
      esp = lst_Succ(NULL, &ssp->le_bcast, NULL);
    } while (esp != sp);
    thread_MutexUnlock(&sp->lp->eseg_mutex);

    thread_MutexUnlock(&l.bcast);
  }

  return NULL;
}

static sLink* get_link(pwr_tNodeId nid, sMsg* mp)
{
  pwr_tStatus sts;
  sLink* lp;

  if (nid == l.nid)
    return NULL;

  thread_MutexLock(&l.links.mutex);

  lp = tree_Find(&sts, l.links.table, &nid);

  thread_MutexUnlock(&l.links.mutex);

  return lp;
}

static void get_tmo(sLink* lp, pwr_tBoolean do_inc, pwr_tTime* tmo)
{
  float rto;
  pwr_tTime now;
  pwr_tDeltaTime drto;

  rto = lp->np->link.rtt_rto;

  if (rto > lp->np->link.rtt_rxmax) {
    rto = lp->np->link.rtt_rxmax;
    if (lp->np->link.flags.b.active)
      link_stalled(lp);
  } else if (do_inc) {
    lp->np->link.rtt_rto *= 2;
    if (lp->np->link.rtt_rto > lp->np->link.rtt_rxmax)
      lp->np->link.rtt_rto = lp->np->link.rtt_rxmax + 0.01;
    l.config->Link[lp->idx].Timeout = lp->np->link.rtt_rto;
  }

  time_GetTimeMonotonic(&now);
  time_Aadd(tmo, &now, time_FloatToD(&drto, rto));
}

static void* import_thread()
{
  sMsg msg;
  sIseg* sp;
  sLink* last_link = NULL;
  int bytes;
  thread_sMutex* mp = &l.import.mutex;

  thread_MutexLock(mp);

  for (sp = iseg_alloc();;) {
    set_recvmsg(sp, &msg);
    bytes = recvmsg(l.sock, &msg.msg, 0);

    if (bytes == -1 && errno != EHOSTDOWN && errno != EHOSTUNREACH) {
      errh_Error("recvmsg failed %m(%d)", errno_Status(errno), errno);
      sched_yield();
      continue;
    }

    sp->size = bytes - sizeof(sp->head);
    sp->ts_recv = time_Clock(NULL, NULL);
    decode_head(&sp->head, &msg.head);
    if (last_link != NULL && sp->head.nid == last_link->nid)
      sp->lp = last_link;
    else
      sp->lp = last_link = get_link(sp->head.nid, &msg);
    if (sp->lp == NULL) {
      char volstr[20];
      errh_Warning("Request from unknown node %s",
          cdh_VolumeIdToString(volstr, sizeof(volstr), sp->head.nid, 0, 0));
      continue;
    }
    sp->c.action = eAction_import;
    sp->lp->np->get.segs++;
    sp->lp->np->get.bytes += bytes;
    sp->lp->np->link.sa = msg.sa;
    que_Put(NULL, &sp->lp->q_in, &sp->c.le, sp);
    sp = iseg_alloc();
  }
  return NULL;
}

static void ini_link_info(qdb_sLinkInfo* lp)
{
  qdb_sNode* my_np = qdb->my_node;

  strcpy(lp->name, my_np->link[0].name);

  lp->version = ntohl(my_np->version);
  lp->nid = ntohl(l.nid);
  lp->birth = ntohl(my_np->link[0].birth);
  lp->bus = ntohl(qdb->g->bus);
  lp->os = ntohl(my_np->os);
  lp->hw = ntohl(my_np->hw);
  lp->bo = ntohl(my_np->bo);
  lp->ft = ntohl(my_np->ft);
}

static sIseg* iseg_alloc()
{
  sIseg* sp;

  sp = lst_RemoveSucc(&l.iseg.mutex, &l.iseg.lh, NULL);
  if (sp == NULL) {
    sp = (sIseg*)calloc(1, sizeof(*sp) + redu_segment_size - 1);
    lst_Init(NULL, &sp->c.le, sp);
    sp->size = redu_segment_size;
  }

  return sp;
}

static void iseg_free(sIseg* sp)
{
  pwr_Assert(!lst_IsLinked(NULL, &sp->c.le));
  memset(sp, 0, sizeof(*sp) + redu_segment_size - 1);
  lst_Init(NULL, &sp->c.le, sp);
  sp->size = redu_segment_size;
  lst_InsertPred(&l.iseg.mutex, &l.iseg.lh, &sp->c.le, sp);
}

static void iseg_import(sLink* lp, sIseg* sp)
{
  pwr_tStatus sts;
  int diff;
  qdb_sInfo* ip;
  qdb_sQue* qp;
  qcom_sQid qid;
  int prio;

  if (!lp->np->link.flags.b.connected) {
    return;
  }

  diff = sp->head.lack.seq - lp->np->link.rack.seq;
  if (diff != 1) {
    return;
  }

  prio = sp->head.prio;
  if (prio < 0 || prio >= redu_ePrio__)
    return;

  if (sp->head.flags.b.first) {
    // pwr_Assert(lp->bp[prio] == NULL);
    ip = (qdb_sInfo*)sp->buff;
    decode_info(ip);
    qdb_ScopeLock
    {
      if (lp->bp[prio] != NULL) {
        lp->np->link.err_seg_seq++;
        qdb_Free(NULL, lp->bp[prio]);
      }
      lp->bp[prio] = qdb_Alloc(&sts, qdb_eBuffer_base, ip->size);
    }
    qdb_ScopeUnlock;

    if (lp->bp[prio] == NULL) {
      purge();
      return;
    }
    lp->bp[prio]->c.flags.m |= ip->flags.m & qdb_mBuffer_maskExport;
    lp->p[prio] = (char*)&lp->bp[prio]->b.info;
  } else if (!sp->head.flags.b.first) {
    // pwr_Assert(lp->bp[prio] != NULL);
    // pwr_Assert(lp->p[prio] != NULL);
    if (lp->bp[prio] == NULL) {
      lp->np->link.err_seg_seq++;
      return;
    }
  }

  memcpy(lp->p[prio], sp->buff, sp->size);
  lp->p[prio] += sp->size;

  if (sp->head.flags.b.last) {
    lp->bp[prio]->c.flags.b.imported = 1;

    qdb_ScopeLock
    {
      qid.qix = lp->bp[prio]->b.info.receiver.qix;
      qid.nid = qdb->my_nid;
      qp = qdb_Que(&sts, &qid, NULL);
      if (qp == NULL) {
        /* To do !!!  Send notification reply if requested. */
        qdb_Free(NULL, lp->bp[prio]);
      } else {
        qdb_Put(NULL, lp->bp[prio], qp);
      }
    }
    qdb_ScopeUnlock;

    lp->bp[prio] = NULL;
  }
}

/* An ack message has arrived from a remote node.
   Free the segments in window that have been
   succesfully received at remote node.  */

static void lack(sLink* lp, sIseg* isp)
{
  lst_sEntry* se;
  int diff;
  sEseg *sp, *nsp;
  thread_sMutex* mx;

  for (sp = lst_Succ(NULL, &lp->lh_win, &se); se != &lp->lh_win; sp = nsp) {
    nsp = lst_Succ(NULL, se, &se);
    diff = isp->head.rack.seq - sp->head.lack.seq;

    if (diff >= 0) {
      /* This segment is either the acked segment or an older,
         it can be released.  */

      if (diff == 0 && isp->head.rack.ts == sp->head.lack.ts)
        // update_rtt(lp, isp);
        update_rtt(lp, sp);

      window_remove(lp, sp);

      mx = &sp->lp->eseg_mutex;
      thread_MutexLock(mx);
      eseg_free(sp);
      thread_MutexUnlock(mx);
    } else {
      /* This is the oldest not acked segment. */
      lp->np->link.lack = sp->head.lack;
      l.config->Link[lp->idx].LackSequenceNumber = sp->head.lack.seq;
      break;
    }
  }
}

static void link_active(sLink* lp)
{
  if (lp->np->link.flags.b.active) {
    pwr_Assert(lp->np->link.flags.b.connected);
    return;
  }

  start_rto(lp);
  lp->np->link.flags.b.active = 1;
  lp->np->link.flags.b.connected = 1;
  errh_Info("Active, link to %s (%s)", lp->np->name,
      cdh_NodeIdToString(NULL, lp->np->nid, 0, 0));
  lp->np->flags.b.active = 1;
  lp->np->flags.b.connected = 1;
  check_link_status();
  l.config->Link[lp->idx].State = pwr_eUpDownEnum_Up;
}

static void link_connect(sLink* lp, sIseg* sp)
{
  if (l.pending_set_active) {
    l.pending_set_active = 0;
    timelog(1, "Pending set active reset");
  }

  lp->np->link.flags.b.active = 1;
  l.config->Link[lp->idx].State = pwr_eUpDownEnum_Up;

  if (lp->np->link.flags.b.connected)
    return;

  lp->np->link.flags.b.connected = 1;
  errh_Info("Connected, link to %s (%s)", lp->np->name,
      cdh_NodeIdToString(NULL, lp->np->nid, 0, 0));
  lp->np->birth = sp->head.birth;
  time_GetTime(&lp->np->timeup);
  lp->np->flags.b.connected = 1;
  lp->np->flags.b.active = 1;
  set_link_info(lp, (qdb_sLinkInfo*)sp->buff);

  check_link_status();
}

static void link_disconnect(sLink* lp)
{
  sEseg* sp;
  int i;

  if (!lp->np->link.flags.b.connected) {
    pwr_Assert(!lp->np->link.flags.b.active);
    return;
  }

  lp->np->link.pending_rack = NO;
  lp->np->link.flags.b.active = 0;
  l.config->Link[lp->idx].State = pwr_eUpDownEnum_Down;
  lp->np->link.flags.b.connected = 0;
  memset(&lp->np->link.lack, 0, sizeof(lp->np->link.lack));
  memset(&lp->np->link.rack, 0, sizeof(lp->np->link.rack));
  lp->np->link.seq = 0;
  start_rto(lp);
  lp->np->link.rack_tmo = pwr_cNTime;

  /* Empty send list */

  thread_MutexLock(&lp->eseg_mutex);
  for (sp = lst_Succ(NULL, &lp->lh_send, NULL); sp != NULL;
       sp = lst_Succ(NULL, &lp->lh_send, NULL)) {
    lst_Remove(NULL, &sp->c.le);
    eseg_free(sp);
  }

  /* Empty window list */

  for (sp = lst_Succ(NULL, &lp->lh_win, NULL); sp != NULL;
       sp = lst_Succ(NULL, &lp->lh_win, NULL)) {
    lst_Remove(NULL, &sp->c.le);
    eseg_free(sp);
  }
  thread_MutexUnlock(&lp->eseg_mutex);

  lp->np->link.win_count = 0;

  errh_Info("Disconnected, link to  %s (%s)", lp->np->name,
      cdh_NodeIdToString(NULL, lp->np->nid, 0, 0));
  qdb_ScopeLock
  {
    for (i = 0; i < redu_ePrio__; i++) {
      if (lp->bp[i] != NULL)
        qdb_Free(NULL, lp->bp[i]);
    }
    lp->np->flags.b.active = 0;
    lp->np->flags.b.connected = 0;
  }
  qdb_ScopeUnlock;

  for (i = 0; i < redu_ePrio__; i++) {
    lp->bp[i] = NULL;
    lp->p[i] = NULL;
  }
  lp->np->link.export_alloc_cnt = 0;
  l.config->Link[lp->idx].ExportAlloc = lp->np->link.export_alloc_cnt;
  sp = create_connect(lp);
  lst_InsertSucc(NULL, &lp->lh_send, &sp->c.le, sp);

  check_link_status();
}

static void link_purge(sLink* lp)
{
  sEseg *sp, *nsp;
  int purge = 0;
  int alloc_cnt = 0;

  if (!lp->np->link.flags.b.connected) {
    pwr_Assert(!lp->np->link.flags.b.active);
    return;
  }

  /* Purge send list */

  int i = 0;
  thread_MutexLock(&lp->eseg_mutex);
  for (sp = lst_Succ(NULL, &lp->lh_send, NULL); sp != NULL; sp = nsp) {
    nsp = lst_Succ(NULL, &sp->c.le, NULL);
    if (!purge && i > 50 && sp->head.flags.b.first)
      purge = 1;

    if (purge) {
      eseg_free(sp);
    } else
      alloc_cnt += sp->size;
    i++;
  }
  thread_MutexUnlock(&lp->eseg_mutex);
  printf("redcom link_purge: %d cnt %d (%d)\n", i,
      lp->np->link.export_alloc_cnt, alloc_cnt);
  lp->np->link.export_alloc_cnt = alloc_cnt;
  lp->np->link.export_purge_cnt++;
  l.config->Link[lp->idx].ExportPurged = lp->np->link.export_purge_cnt;
  l.config->Link[lp->idx].ExportAlloc = lp->np->link.export_alloc_cnt;
}

static void check_state(sLink* lp, sIseg* sp)
{
  pwr_tDeltaTime dt;
  pwr_tFloat32 ft;

  time_Adiff(&dt, &lp->receive_time, &l.last_switch_time);
  time_DToFloat(&ft, &dt);
  if (ft < l.config->LinkTimeout)
    return;

  switch (sp->head.state) {
  case pwr_eRedundancyState_Active:
    switch (l.nodep->RedundancyState) {
    case pwr_eRedundancyState_Init:
    case pwr_eRedundancyState_Active:
      state_change_request(lp, sp, pwr_eRedundancyState_Passive);
      timelog(1, "redcom state to Passive, remote is Active");
      break;
    }
    break;
  case pwr_eRedundancyState_Passive:
    switch (l.nodep->RedundancyState) {
    case pwr_eRedundancyState_Init:
    case pwr_eRedundancyState_Passive:
      state_change_request(lp, sp, pwr_eRedundancyState_Active);
      timelog(1, "redcom state to Active, remote is Passive");
      break;
    }
    break;
  case pwr_eRedundancyState_Init:
    switch (l.nodep->RedundancyState) {
    case pwr_eRedundancyState_Init:
      if (l.default_redundancy_state == pwr_eRedundancyState_Active)
        state_change_request(lp, sp, pwr_eRedundancyState_Active);
      else
        state_change_request(lp, sp, pwr_eRedundancyState_Passive);
      timelog(1, "redcom state to Active, remote is Init");
      break;
    }
    break;
  }
}

static void link_import(sLink* lp, sIseg* sp)
{
  time_GetTimeMonotonic(&lp->receive_time);

  if (!lp->np->link.flags.b.active && lp->np->birth == sp->head.birth)
    link_active(lp);
  else if (lp->np->birth != sp->head.birth && lp->np->link.flags.b.connected)
    link_disconnect(lp);
  else if (lp->np->birth != sp->head.birth && !lp->np->link.flags.b.connected)
    link_redisconnect(lp);

  if (l.pending_set_active) {
    l.pending_set_active = 0;
    timelog(1, "Pending set active reset");
  }

  switch (sp->head.flags.b.event) {
  case eEvent_user:
    check_state(lp, sp);
    if (lp->np->link.flags.b.active) {
      lack(lp, sp);
      iseg_import(lp, sp);
      set_rack(lp, sp);
    }
    break;
  case eEvent_ack:
    check_state(lp, sp);
    if (lp->np->link.flags.b.active) {
      lack(lp, sp);
    }
    break;
  case eEvent_connect:
    check_state(lp, sp);
    link_connect(lp, sp);
    lack(lp, sp);
    set_rack(lp, sp);
    break;
  case eEvent_set_active:
    timelog(1, "redcom Active received");
    state_change_request(lp, sp, pwr_eRedundancyState_Active);

    lack(lp, sp);
    set_rack(lp, sp);
    break;
  case eEvent_set_passive:
    timelog(1, "redcom Passive received");
    state_change_request(lp, sp, pwr_eRedundancyState_Passive);
    lack(lp, sp);
    set_rack(lp, sp);
    break;
  case eEvent_set_off:
    state_change_request(lp, sp, pwr_eRedundancyState_Off);
    lack(lp, sp);
    set_rack(lp, sp);
    break;
  default:
    break;
  }

  iseg_free(sp);
}

static void link_redisconnect(sLink* lp)
{
  sEseg* sp;

  pwr_Assert(!lp->np->link.flags.b.connected);
  pwr_Assert(!lp->np->link.flags.b.active);

  lp->np->link.pending_rack = NO;
  start_rto(lp);
  lp->np->link.rack_tmo = pwr_cNTime;

  sp = lst_Succ(NULL, &lp->lh_win, NULL);
  if (sp == NULL) {
    sp = lst_Succ(NULL, &lp->lh_send, NULL);
    sp->tmo = pwr_cNTime;
  }
  // pwr_Assert(sp != NULL);
  // pwr_Assert(sp->head.flags.b.event == eEvent_connect);
}

static void link_send(sLink* lp)
{
  sEseg* sp;

  if ((sp = window_tmo(lp)) != NULL) {
    seg_send(lp, sp);
  } else if ((sp = pending_send(lp)) != NULL) {
    window_insert(lp, sp);
    seg_send(lp, sp);
  } else if (lp->np->link.pending_rack && expired(&lp->np->link.rack_tmo)) {
    send_ack(lp);
  }
}

static void link_stalled(sLink* lp)
{
  if (!lp->np->link.flags.b.active)
    return;

  lp->np->link.flags.b.active = 0;
  errh_Info("Stalled, link to node %s (%s)", lp->np->name,
      cdh_NodeIdToString(NULL, lp->np->nid, 0, 0));
  lp->np->flags.b.active = 0;
  l.config->Link[lp->idx].State = pwr_eUpDownEnum_Down;
  check_link_status();
}

static void* link_thread(sLink* lp)
{
  uSeg* sp;
  pwr_tBoolean pending = FALSE;

  for (;;) {
    sp = que_Get(NULL, &lp->q_in, link_tmo(lp), &lp->tmo);

    switch (sp->action) {
    case eAction_export:
      /*      lst_InsertPred(NULL, &lp->lh_send, &sp->c.le, sp); */
      pending = clean_insert(&lp->lh_send, (sEseg*)sp, pending);
      if (pending)
        continue;
      else
        break;
    case eAction_import:
      link_import(lp, &sp->i);
      if (pending)
        continue;
      else
        break;
    case eAction_tmo:
      /* Nothing to do, all is done in link_send. */
      break;
    default:
      errh_Bugcheck(2, "unknown action");
    }
    link_send(lp);
  }

  return NULL;
}

static pwr_tDeltaTime* link_tmo(sLink* lp)
{
  pwr_tDeltaTime diff_send = pwr_cNDeltaTime;
  pwr_tDeltaTime diff_rack = pwr_cNDeltaTime;
  pwr_tTime clock;
  pwr_tDeltaTime tmo = pwr_cNDeltaTime;
  sEseg* sp;

  time_GetTimeMonotonic(&clock);

  if (lst_Succ(NULL, &lp->lh_send, NULL) != NULL
      && lp->np->link.win_count < lp->np->link.win_max)
    return time_ZeroD(&lp->np->link.timer);

  if (lp->np->link.pending_rack) {
    time_Adiff(&diff_rack, &lp->np->link.rack_tmo, &clock);
    if (time_Dcomp(&diff_rack, 0) == -1)
      diff_rack = pwr_cNDeltaTime;
  }

  if ((sp = lst_Succ(NULL, &lp->lh_win, NULL)) != NULL) {
    time_Adiff(&diff_send, &sp->tmo, &clock);
    if (time_Dcomp(&diff_send, 0) == -1)
      diff_send = pwr_cNDeltaTime;
  }

  if (lp->np->link.pending_rack && sp != NULL) {
    if (time_Dcomp(&diff_rack, &diff_send) == -1)
      tmo = diff_rack;
    else
      tmo = diff_send;
  } else if (lp->np->link.pending_rack) {
    tmo = diff_rack;
  } else if (sp != NULL) {
    tmo = diff_send;
  } else {
    lp->np->link.timer.tv_sec = 999999999;
    lp->np->link.timer.tv_nsec = 0;
    return &lp->np->link.timer;
  }

  lp->np->link.timer = tmo;
  return &lp->np->link.timer;
}

static redu_sNode* get_node(pwr_tNodeId nid)
{
  int i;

  for (i = 0; i < l.redu_nodes; i++) {
    if (l.redu_node[i].nid == nid)
      return &l.redu_node[i];
  }
  return 0;
}

static sLink* new_link(pwr_tNodeId nid, sMsg* mp)
{
  pwr_tStatus sts;
  sLink* lp;
  sEseg* sp;
  float rtt_rxmin, rtt_rxmax;
  float ack_delay;

  if (nid == l.nid)
    return NULL;

  lp = tree_Insert(&sts, l.links.table, &nid);
  pwr_Assert(lp != NULL);

  if (!tics_per_sec)
    tics_per_sec = sysconf(_SC_CLK_TCK);

  l.links.count++;

  lp->np = get_node(nid);
  lp->idx = l.links.count - 1;
  rtt_rxmin = (float)lp->np->min_resend_time / 1000;
  if (feqf(rtt_rxmin, 0.0f))
    rtt_rxmin = RTT_RXMIN;
  rtt_rxmax = (float)lp->np->max_resend_time / 1000;
  if (feqf(rtt_rxmax, 0.0f))
    rtt_rxmax = RTT_RXMAX;
  ack_delay = lp->np->ack_delay;
  time_FloatToD(&lp->ack_delay, lp->np->ack_delay);
  lp->exp_buf_quota = lp->np->export_buf_quota;
  if (lp->exp_buf_quota == 0)
    lp->exp_buf_quota = EXPORT_BUF_QUOTA;
  lp->np->link.export_quota = lp->exp_buf_quota;

  que_Create(NULL, &lp->q_in);
  lst_Init(NULL, &lp->lh_send, NULL);
  lst_Init(NULL, &lp->lh_win, NULL);
  lp->np->link.win_max = 1;
  lp->np->link.rtt_rxmax = rtt_rxmax;
  lp->np->link.rtt_rxmin = rtt_rxmin;
  lp->tmo.c.action = eAction_tmo;
  sts = thread_MutexInit(&lp->eseg_mutex);

  if (mp != NULL) {
    lp->np->sa = mp->sa;
  }

  sp = create_connect(lp);
  que_Put(NULL, &lp->q_in, &sp->c.le, sp);

  thread_Create(&lp->thread, lp->np->name, link_thread, lp);

  strncpy(l.config->Link[lp->idx].NodeName, lp->np->name,
      sizeof(l.config->Link[0].NodeName));
  l.config->Link[lp->idx].MaxResendTime = lp->np->link.rtt_rxmax;
  l.config->Link[lp->idx].MinResendTime = lp->np->link.rtt_rxmin;
  l.config->Link[lp->idx].ExportQuota = lp->np->link.export_quota;
  l.config->Link[lp->idx].SegmentSize = redu_segment_size;
  l.config->Link[lp->idx].AckDelay = lp->np->ack_delay;

  return lp;
}

static void open_socket()
{
  if ((l.sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
    errh_Error("socket failed: %s", strerror(errno));
    exit(errno_ExitErrno(errno));
  }

  l.sa.sin_family = AF_INET;
  l.sa.sin_addr.s_addr = htonl(INADDR_ANY);
  l.sa.sin_port = htons(l.port);

  if ((bind(l.sock, (struct sockaddr*)&l.sa, sizeof(l.sa))) < 0) {
    errh_Error("bind failed: %s", strerror(errno));
    close(l.sock);
    exit(errno_ExitErrno(errno));
  }
}

static sEseg* pending_send(sLink* lp)
{
  sEseg* sp;

  if (lp->np->link.win_count >= lp->np->link.win_max)
    return NULL;

  thread_MutexLock(&lp->eseg_mutex);
  sp = lst_RemoveSucc(NULL, &lp->lh_send, NULL);
  thread_MutexUnlock(&lp->eseg_mutex);
  return sp;
}

static void send_ack(sLink* lp)
{
  sHead head;
  sMsg msg;
  int bytes;

  head.flags.b.event = eEvent_ack;
  head.flags.m |= mSeg_single;
  head.lack.seq = lp->np->link.seq;
  head.lack.ts = time_Clock(NULL, NULL);
  head.nid = l.head.nid;
  head.birth = l.head.birth;
  head.rack = lp->np->link.rack;
  head.prio = redu_ePrio_0;
  head.state = l.nodep->RedundancyState;

  set_sendmsg(lp, NULL, &msg);
  encode_head(&msg.head, &head);

  thread_MutexLock(&l.send_mutex);
  // printf( "sendmsg ack\n");
  bytes = sendmsg(l.sock, &msg.msg, 0);
  thread_MutexUnlock(&l.send_mutex);

  if (bytes != -1) {
    lp->np->link.pending_rack = NO;
    lp->np->put.segs++;
    lp->np->put.bytes += bytes;
  }

  sched_yield();
}

static void set_link_info(sLink* lp, qdb_sLinkInfo* ip)
{
  redu_sNode* np = lp->np;

  strcpy(np->name, ip->name);

  np->version = ntohl(ip->version);
  np->nid = ntohl(ip->nid);
  np->birth = ntohl(ip->birth);
  lp->np->link.bus = ntohl(ip->bus);
}

static void set_rack(sLink* lp, sIseg* sp)
{
  int diff;

  if (!lp->np->link.flags.b.connected)
    return;

  if (sp->head.lack.seq == 0)
    return;

  diff = sp->head.lack.seq - lp->np->link.rack.seq;
  if (diff == 0 || diff == 1) {
    lp->np->link.rack = sp->head.lack;
    l.config->Link[lp->idx].RackSequenceNumber = sp->head.lack.seq;
  } else if (diff > 1) {
    if ((++lp->np->link.err_seq % 20) == 1) {
      errh_Info("%s, %d sequence error %d segments %s : (%d)[%d]\n",
          lp->np->name, lp->np->link.err_seq, diff - 1,
          event_string(sp->head.flags.b.event), sp->head.lack.seq,
          sp->head.rack.seq);
    }
    return;
  } else {
    if ((++lp->np->link.err_red % 20) == 1) {
      errh_Info("%s, %d redundant segment %s : (%d)[%d]\n", lp->np->name,
          lp->np->link.err_red, event_string(sp->head.flags.b.event),
          sp->head.lack.seq, sp->head.rack.seq);
    }
    return;
  }

  if (sp->head.flags.b.event == eEvent_ack)
    return;

  if (sp->head.flags.b.resent) {
    lp->np->link.pending_rack = YES;
    time_GetTimeMonotonic(&lp->np->link.rack_tmo);
  } else if (lp->np->link.pending_rack) {
    time_GetTimeMonotonic(&lp->np->link.rack_tmo);
  } else {
    lp->np->link.pending_rack = YES;
    time_GetTimeMonotonic(&lp->np->link.rack_tmo);
    time_Aadd(&lp->np->link.rack_tmo, &lp->np->link.rack_tmo,
        &lp->ack_delay); /* lp->rack_tmo; */
  }
}

static void set_recvmsg(sIseg* sp, sMsg* mp)
{
  mp->iov[0].iov_base = (char*)&mp->head;
  mp->iov[0].iov_len = sizeof(mp->head);
  mp->iov[1].iov_base = (char*)sp->buff;
  mp->iov[1].iov_len = redu_segment_size;

  memset(&mp->sa, 0, sizeof(mp->sa));

  memset(&mp->msg, 0, sizeof(mp->msg));
  mp->msg.msg_iov = mp->iov;
  mp->msg.msg_iovlen = 2;

  mp->msg.msg_name = (void*)&mp->sa;
  mp->msg.msg_namelen = sizeof(mp->sa);
}

static void seg_send(sLink* lp, sEseg* sp)
{
  sMsg msg;

  sp->head.lack.ts = time_Clock(NULL, NULL);
  sp->head.nid = l.head.nid;
  sp->head.birth = l.head.birth;
  sp->head.rack = sp->lp->np->link.rack;
  sp->head.state = l.nodep->RedundancyState;

  thread_MutexLock(&l.send_mutex);

  set_sendmsg(lp, sp, &msg);
  encode_head(&msg.head, &sp->head);

  sp->bytes = sendmsg(l.sock, &msg.msg, 0);
  thread_MutexUnlock(&l.send_mutex);

  if (sp->bytes == -1) {
    if (errno != EHOSTDOWN && errno != EHOSTUNREACH) {
      errh_Error("sendmsg to node %s (%s) failed\n(%d) %s", sp->lp->np->name,
          cdh_NodeIdToString(NULL, sp->lp->nid, 0, 0), errno, strerror(errno));
    }
  } else {
    lp->np->link.pending_rack = NO;
    lp->np->put.segs++;
    lp->np->put.bytes += sp->bytes;
  }
  if (lst_IsSucc(NULL, &lp->lh_win, &sp->c.le)) {
    if (!sp->head.flags.b.resent) {
      start_rto(lp);
      sp->head.flags.b.resent = 1;
    }
    get_tmo(lp, YES, &sp->tmo);
  } else {
    get_tmo(lp, NO, &sp->tmo);
  }
  sp->sent = 1;
  time_GetTimeMonotonic(&sp->send_ts);

  sched_yield();
}

static void set_sendmsg(sLink* lp, sEseg* sp, sMsg* mp)
{
  int i = 0;
  int size = 0;
  char* p;

  pwr_Assert(lp != NULL);

  memset(&mp->msg, 0, sizeof(mp->msg));
  mp->msg.msg_iov = mp->iov;

  mp->iov[i].iov_base = (char*)&mp->head;
  mp->iov[i++].iov_len = sizeof(mp->head);

  if (sp == NULL) {
    ;
  } else if (sp->head.flags.b.event == eEvent_connect) {
    mp->iov[i].iov_base = (char*)&l.link_info;
    mp->iov[i++].iov_len = sizeof(l.link_info);
  } else if (sp->bp != NULL) {
    p = (char*)sp->p;
    size = sp->size;
    if (sp->head.flags.b.first) {
      encode_info(&mp->info, (qdb_sInfo*)p);
      mp->iov[i].iov_base = (char*)&mp->info;
      mp->iov[i++].iov_len = sizeof(mp->info);
      p += sizeof(mp->info);
      size -= sizeof(mp->info);
    }
    mp->iov[i].iov_base = p;
    mp->iov[i++].iov_len = size;
  }

  mp->msg.msg_iovlen = i;
  mp->msg.msg_name = (void*)&lp->np->sa;
  mp->msg.msg_namelen = sizeof(lp->np->sa);
}

static void start_rto(sLink* lp)
{
  double rto;

  rto = lp->np->link.rtt_srtt + (4.0 * lp->np->link.rtt_var);

  if (rto < lp->np->link.rtt_rxmin)
    rto = lp->np->link.rtt_rxmin;
  else if (rto > lp->np->link.rtt_rxmax)
    rto = lp->np->link.rtt_rxmax;

  lp->np->link.rtt_rto = rto;
  l.config->Link[lp->idx].Timeout = rto;
}

static void update_rtt(sLink* lp, sEseg* sp)
{
  pwr_tDeltaTime dt;
  float delta;
  pwr_tTime now;

  if (sp->head.rack.seq == 0)
    return;

  time_GetTimeMonotonic(&now);
  time_Adiff(&dt, &now, &sp->send_ts);
  time_DToFloat(&lp->np->link.rtt_rtt, &dt);

  delta = lp->np->link.rtt_rtt - lp->np->link.rtt_srtt;
  lp->np->link.rtt_srtt += delta / 8;

  if (delta < 0.0)
    delta = -delta; /* |delta| */

  lp->np->link.rtt_var += (delta - lp->np->link.rtt_var) / 4;

  l.config->Link[lp->idx].LastRtt = lp->np->link.rtt_rtt;
}

static void window_insert(sLink* lp, sEseg* sp)
{
  pwr_Assert(!lst_IsLinked(NULL, &sp->c.le));
  lst_InsertPred(NULL, &lp->lh_win, &sp->c.le, sp);
  lp->np->link.win_count++;
  sp->head.lack.seq = ++lp->np->link.seq;
}

static void window_remove(sLink* lp, sEseg* sp)
{
  pwr_Assert(lst_IsLinked(NULL, &sp->c.le));
  lst_Remove(NULL, &sp->c.le);
  lp->np->link.win_count--;
}

static sEseg* window_tmo(sLink* lp)
{
  sEseg* sp = lst_Succ(NULL, &lp->lh_win, NULL);

  if (sp == NULL || !expired(&sp->tmo))
    return NULL;

  return sp;
}

static void check_link_status()
{
  pwr_tStatus sts;
  pwr_tStatus linksts = PWR__SRUN;
  sLink* lp;

  for (lp = tree_Minimum(&sts, l.links.table); lp != NULL;
       lp = tree_Successor(&sts, l.links.table, lp)) {
    if (!lp->np->link.flags.b.active)
      linksts = REDU__DOWN;
  }
  if (linksts != l.sts) {
    if (errh_Severity(linksts) >= errh_Severity(redu_sts))
      errh_SetStatus(linksts);
    else if (errh_Severity(l.sts) >= errh_Severity(redu_sts)
        && errh_Severity(linksts) < errh_Severity(redu_sts))
      errh_SetStatus(redu_sts);
    l.sts = linksts;
  }
}

static void set_status(pwr_tStatus sts)
{
  if (sts != redu_sts) {
    if (errh_Severity(sts) >= errh_Severity(l.sts))
      errh_SetStatus(sts);
    else if (errh_Severity(redu_sts) >= errh_Severity(l.sts)
        && errh_Severity(sts) < errh_Severity(l.sts))
      errh_SetStatus(l.sts);
    redu_sts = sts;
  }
}

static void purge(void)
{
  pwr_tStatus sts;
  sLink* lp;

  for (lp = tree_Minimum(&sts, l.links.table); lp != NULL;
       lp = tree_Successor(&sts, l.links.table, lp))
    link_purge(lp);
  errh_Error("Links purged, qdb pool exhausted");
}

static void state_change_request(
    sLink* lp, sIseg* sp, pwr_eRedundancyState state)
{
  if (l.pending_set_active) {
    l.pending_set_active = 0;
    timelog(1, "Pending set active reset");
  }

  if (state != l.nodep->RedundancyState) {
    switch (state) {
    case pwr_eRedundancyState_Active:
    case pwr_eRedundancyState_Passive:
    case pwr_eRedundancyState_Off:
    case pwr_eRedundancyState_Init:
      l.nodep->RedundancyState = state;
      qdb->my_node->redundancy_state = l.nodep->RedundancyState;

      break;
    }

    switch (state) {
    case pwr_eRedundancyState_Passive:
      time_GetTimeMonotonic(&lp->receive_time);
      time_GetTimeMonotonic(&l.last_switch_time);
      lp->passive_timeout = 1;
      send_state_change();
      break;
    case pwr_eRedundancyState_Active:
      time_GetTimeMonotonic(&l.last_switch_time);
      send_state_change();
      break;
    default:;
    }
  }
}

static sEseg* request_state_change(sLink* lp, pwr_eRedundancyState state)
{
  sEseg* sp;

  sp = eseg_alloc(&l.eseg.mutex);
  switch (state) {
  case pwr_eRedundancyState_Active:
    sp->head.flags.b.event = eEvent_set_active;
    break;
  case pwr_eRedundancyState_Passive:
    sp->head.flags.b.event = eEvent_set_passive;
    break;
  case pwr_eRedundancyState_Off:
    sp->head.flags.b.event = eEvent_set_off;
    break;
  default:
    return 0;
  }
  sp->lp = lp;
  sp->c.action = eAction_export;
  sp->head.prio = redu_ePrio_0;
  sp->head.state = l.nodep->RedundancyState;

  que_Put(NULL, &lp->q_in, &sp->c.le, sp);

  return sp;
}

static void failover_detection()
{
  pwr_tTime current;
  sLink* lp;
  pwr_tStatus sts;

  time_GetTimeMonotonic(&current);

  if (l.sup.startup_timeout) {
    /* Disable timeout for a while after startup */
    pwr_tDeltaTime dt;
    float ftime;
    float timeout = l.config->StartupTimeout;

    time_Adiff(&dt, &current, &l.sup.startup_time);
    ftime = time_DToFloat(0, &dt);
    if (ftime > timeout)
      l.sup.startup_timeout = 0;
  }

  /* When force is removed, initialize again */
  if (!l.config->Force && l.sup.force_old)
    l.sup.initialized = 0;

  if (!l.config->Force && l.sup.initialized) {
    if (l.nodep->RedundancyState == pwr_eRedundancyState_Active) {
      /* State is active */
      if (l.config->FailoverReason & pwr_mFailoverReasonMask_EmergencyBreak
          && l.nodep->EmergBreakTrue && !l.sup.emergbreaktrue_old) {
        l.config->SetPassive = 1;
        timelog(1, "Emergency break, set passive");
      } else if (l.config->FailoverReason & pwr_mFailoverReasonMask_SystemStatus
          && (errh_SeverityError(l.nodep->SystemStatus)
                 || errh_SeverityFatal(l.nodep->SystemStatus))
          && !(errh_SeverityError(l.sup.systemstatus_old)
                 || errh_SeverityFatal(l.sup.systemstatus_old))) {
        l.config->SetPassive = 1;
        timelog(1, "Even SystemStatus, set passive");
      }
    } else {
      /* State if passive, check for overtaking */
      if (l.config->FailoverReason & pwr_mFailoverReasonMask_ActiveTimeout) {
        if (l.config->Link[0].State == pwr_eUpDownEnum_Down
            && l.sup.linkstate_old == pwr_eUpDownEnum_Up) {
          l.config->SetActive = 1;
          timelog(1, "Link down, set active");
        }

        for (lp = tree_Minimum(&sts, l.links.table); lp != NULL;
             lp = tree_Successor(&sts, l.links.table, lp)) {
          if (l.config->Link[lp->idx].State == pwr_eUpDownEnum_Up
              && l.config->LinkTimeout > 0 && !l.sup.startup_timeout) {
            pwr_tDeltaTime dt;
            float ftime;
            float timeout = l.config->LinkTimeout;

            if (lp->passive_timeout)
              timeout = 2.0 * timeout;

            time_Adiff(&dt, &current, &lp->receive_time);
            ftime = time_DToFloat(0, &dt);
            if (ftime > timeout) {
              timelog(1, "Link timeout, set active");
              l.config->SetActive = 1;
            }
            l.config->Link[lp->idx].TimeMean
                = K_FILTER * l.config->Link[lp->idx].TimeMean
                + (1.0 - K_FILTER) * ftime;
            if (ftime > l.config->Link[lp->idx].TimeMax)
              l.config->Link[lp->idx].TimeMax = ftime;
          }
        }
      }
    }
  }
  l.sup.force_old = l.config->Force;
  l.sup.emergbreaktrue_old = l.nodep->EmergBreakTrue;
  l.sup.linkstate_old = l.config->Link[0].State;
  l.sup.systemstatus_old = l.nodep->SystemStatus;
  if (!l.sup.initialized)
    l.sup.initialized = 1;
}

static void* cyclic_thread()
{
  sLink* lp;
  pwr_tStatus sts;
  struct timespec ts;
  pwr_tDeltaTime dt;
  pwr_tTime current;
  pwr_tFloat32 ftime;

  time_FloatToD(&dt, l.config->CycleTime);

  ts.tv_sec = dt.tv_sec;
  ts.tv_nsec = dt.tv_nsec;

  for (;;) {
    aproc_TimeStamp(l.config->CycleTime, 5.0);

    if (l.nodep->RedundancyState == pwr_eRedundancyState_Init
        || l.nodep->RedundancyState == pwr_eRedundancyState_Passive) {
      if (l.pending_set_active) {
        time_GetTimeMonotonic(&current);
        time_Adiff(&dt, &current, &l.pending_set_active_time);
        ftime = time_DToFloat(0, &dt);
        if (ftime > 5) {
          l.config->SetActive = 1;
          l.pending_set_active = 0;
          timelog(1, "Pending set active timed out");
        }
      }
    } else {
      if (l.pending_set_active) {
        timelog(1, "Pending set active reset");
        l.pending_set_active = 0;
      }
    }

    failover_detection();

    if (l.config->SetActive) {
      timelog(1, "redcom SetActive");

      if (l.nodep->RedundancyState != pwr_eRedundancyState_Active)
        time_GetTimeMonotonic(&l.last_switch_time);

      for (lp = tree_Minimum(&sts, l.links.table); lp != NULL;
           lp = tree_Successor(&sts, l.links.table, lp))
        request_state_change(lp, pwr_eRedundancyState_Passive);
      l.config->SetActive = 0;
      l.nodep->RedundancyState = pwr_eRedundancyState_Active;
      qdb->my_node->redundancy_state = l.nodep->RedundancyState;
      send_state_change();
    }
    if (l.config->SetPassive) {
      timelog(1, "redcom SetPassive");

      if (l.nodep->RedundancyState != pwr_eRedundancyState_Passive)
        time_GetTimeMonotonic(&l.last_switch_time);

      for (lp = tree_Minimum(&sts, l.links.table); lp != NULL;
           lp = tree_Successor(&sts, l.links.table, lp)) {
        request_state_change(lp, pwr_eRedundancyState_Active);
        time_GetTimeMonotonic(&lp->receive_time);
        lp->passive_timeout = 1;
      }
      l.config->SetPassive = 0;
      l.pending_set_active = 0;
      l.nodep->RedundancyState = pwr_eRedundancyState_Passive;
      qdb->my_node->redundancy_state = l.nodep->RedundancyState;
      send_state_change();
    }
    if (l.config->SetOff) {
      for (lp = tree_Minimum(&sts, l.links.table); lp != NULL;
           lp = tree_Successor(&sts, l.links.table, lp))
        request_state_change(lp, pwr_eRedundancyState_Off);
      l.config->SetOff = 0;
      l.nodep->RedundancyState = pwr_eRedundancyState_Off;
      qdb->my_node->redundancy_state = l.nodep->RedundancyState;
    }
    nanosleep(&ts, NULL);
  }
  return NULL;
}

void send_state_change()
{
  pwr_tStatus sts;
  qcom_sPut put;
  qcom_sQid qmon_qid = { qcom_cImonAction, 0 };

  memset(&put, 0, sizeof(put));
  put.type.b = (qcom_eBtype)qmon_cMsgClassAction;
  switch (l.nodep->RedundancyState) {
  case pwr_eRedundancyState_Active:
    put.type.s = (qcom_eStype)qmon_eMsgTypeAction_NodeActive;
    timelog(1, "redcom to qmon NodeActive");
    break;
  case pwr_eRedundancyState_Passive:
    put.type.s = (qcom_eStype)qmon_eMsgTypeAction_NodePassive;
    timelog(1, "redcom to qmon NodePassive");
    break;
  }
  put.size = 4;
  put.data = qcom_Alloc(&sts, put.size);
  put.allocate = 0;

  qcom_Put(&sts, &qmon_qid, &put);
}
