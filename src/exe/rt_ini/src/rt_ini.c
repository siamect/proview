/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/prctl.h>
#include <sys/capability.h>

#include "co_dcli.h"
#include "co_string.h"
#include "co_time.h"
#include "co_ver.h"

#include "rt_bck_load.h"
#include "rt_errh.h"
#include "rt_errh_msg.h"
#include "rt_errl.h"
#include "rt_ini_alias.h"
#include "rt_ini_event.h"
#include "rt_ini_load.h"
#include "rt_ini_msg.h"
#include "rt_io_base.h"
#include "rt_lck.h"
#include "rt_mh_util.h"
#include "rt_pwr_msg.h"
#include "rt_qcom.h"
#include "rt_qini.h"
#include "rt_redu.h"

#include "ini.h"
#include "ini_rc.h"

#define RT_INI_PIDFILE "/run/pwr/pwr.pid\0"

static ini_sContext* createContext(int argc, char** argv);
static int checkErrors(ini_sContext* cp);
static pwr_tStatus events(ini_sContext* cp);
static void daemonize();
static void create_pidfile();
static pwr_tStatus interactive(int argc, char** argv, ini_sContext* cp);
static pwr_tStatus stop(ini_sContext* cp);
static void create_locks();
static void delete_locks();
static void load_backup();
static void logChanges(ini_sContext* cp);
static void logCardinality(ini_sContext* cp);
static pwr_tStatus restart(ini_sContext* cp);
static pwr_tStatus terminate();
static pwr_tStatus start(ini_sContext* cp);
static void usage(char*);
static void ini_errl_cb(void* userdata, char* str, char severity,
    pwr_tStatus sts, int anix, int message_type);

static int pid_fd = -1;
static char* pid_filename = NULL;

void set_valid_time()
{ /* Set valid utc time */
}

int main(int argc, char** argv)
{
  ini_sContext* cp;
  pwr_tStatus sts;

  set_valid_time();

  cp = createContext(argc, argv);

  ver_WriteVersionInfo("ProviewR Runtime Environment");

  // If we are running from an unprivileged shell we won't have an inheritable flag set which is needed to set ambient capabilites
  // TODO Later we should pinpoint the exact needed privileges for each process we spawn.

  // Get current caps
  cap_t proc_caps = cap_get_proc();
  cap_value_t pwr_caps[] = { CAP_SYS_NICE, CAP_SYS_BOOT, CAP_NET_BIND_SERVICE, CAP_NET_RAW, CAP_NET_ADMIN, CAP_NET_BROADCAST };
  size_t num_caps = sizeof(pwr_caps) / sizeof(cap_value_t);
  // Set inheritable flag on the caps we want
  cap_set_flag(proc_caps, CAP_INHERITABLE, num_caps, pwr_caps, CAP_SET);
  // Set the process caps with inheritable flag set
  cap_set_proc(proc_caps);

  // Set our ambient set so that our currently cap unaware processes may inherit and set the effective bit
  // TODO Set this on a per process basis giving our processes only the capabilities they need. But for now, it'll do...
  // Each process could also lower their permitted set and thus forever loose that capability...
  prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, CAP_NET_ADMIN, 0, 0);
  prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, CAP_NET_BROADCAST, 0, 0);
  prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, CAP_NET_RAW, 0, 0);
  prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, CAP_SYS_BOOT, 0, 0);
  prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, CAP_NET_BIND_SERVICE, 0, 0);
  prctl(PR_CAP_AMBIENT, PR_CAP_AMBIENT_RAISE, CAP_SYS_NICE, 0, 0);

  if (cp->flags.b.restart) {
    sts = interactive(argc, argv, cp);
  } else if (cp->flags.b.stop) {
    sts = stop(cp);
  } else {
    // Now lets daemonize if asked to
    if (cp->flags.b.daemonize) {
      daemonize();
    }

    sts = start(cp);

    // Now lets create the pid file before starting our endless event loop
    if (cp->flags.b.daemonize) {
      create_pidfile();
    }

    sts = events(cp);
    errh_LogInfo(&cp->log, "Ich sterbe!!");
  }

  exit(sts);
}

static pwr_tStatus start(ini_sContext* cp)
{
  pwr_tStatus sts;
  char console[80];
  int state;

  int fd;

  if (streq(cp->console, ""))
    strcpy(console, "/dev/console");
  else
    strcpy(console, cp->console);
  if ((fd = open(console, O_APPEND | O_WRONLY)) == -1)
    errl_Init(NULL, ini_errl_cb, cp);
  else {
    close(fd);
    errl_Init(console, ini_errl_cb, cp);
  }

  errh_Init("pwr_ini", errh_eAnix_ini);

  if (cp->flags.b.interactive)
    errh_Interactive();

  mh_UtilCreateEvent();

  ini_CheckContext(&sts, cp);

  ini_ReadBootFile(&sts, cp);
  ini_ReadNodeFile(&sts, cp);
  ini_CheckNode(&sts, cp);

  cp->me = tree_Find(&sts, cp->nid_t, &cp->node.nid);
  if (cp->me == NULL) {
    errh_LogFatal(
        &cp->log, "Cannot find my own node in %s\n", cp->nodefile.name);
    exit(QCOM__WEIRD);
  }

  if (!checkErrors(cp))
    exit(0);

  if (cp->flags.b.verbose)
    logCardinality(cp);

  ini_CreateDb(&sts, cp);

  ini_LoadNode(&sts, cp);

  ini_BuildNode(&sts, cp);

  if (cp->np != NULL) {
    if (cp->np->ErrLogTerm[0] != '\0') {
      errh_LogInfo(&cp->log, "Setting log terminal to: %s", cp->np->ErrLogTerm);
      errl_SetTerm(cp->np->ErrLogTerm);
    }

    /* Logfile is always $pwrp_log/pwr.log from V4.0.0 and handled by Linux log
     * rotation */

    char fname[256];
    sprintf(fname, "$pwrp_log/pwr_%s.log", cp->nodename);
    dcli_translate_filename(fname, fname);
    errl_SetFile(fname);
    errh_LogInfo(&cp->log, "Setting log file to: %s", fname);

    /*
        if (cp->np->ErrLogFile[0] != '\0') {
          struct tm *tp;
          char fname[256];
          time_t t;

          time(&t);
          tp = localtime(&t);
          strftime(fname, sizeof(fname), cp->np->ErrLogFile, tp );
          dcli_translate_filename( fname, fname);
          errl_SetFile(fname);
          errh_LogInfo(&cp->log, "Setting log file to: %s", cp->np->ErrLogFile);
        }
    */
  }

  ini_SetSystemStatus(cp, PWR__STARTUP);
  errh_SetStatus(PWR__STARTUP);

  sts = ini_RcReadAndSet(cp->dir, cp->nodename, cp->busid);
  if (EVEN(sts))
    errh_LogError(&cp->log, "ini_RcReadAndSet, %m", sts);

  sts = ini_SetAttribute(cp->aliasfile.name, cp->nodename, 0);
  if (EVEN(sts) && sts != INI__FILE)
    errh_LogError(&cp->log, "ini_SetAttribute, %m", sts);

  qini_BuildDb(&sts, cp->nid_t, cp->me, NULL, cp->busid);

  sts = redu_get_initial_state(cp->nodename, cp->busid, &state);
  if (ODD(sts)) {
    cp->np->RedundancyState = state;
    qcom_SetRedundancyState(state);
  }

  create_locks();

  io_init_signals();

  load_backup();

  ini_ProcTable(&sts, cp);
  ini_ProcIter(&sts, cp, proc_mProcess_system, 0, ini_ProcLoad);
  ini_ProcIter(&sts, cp, proc_mProcess_system, 0, ini_ProcStart);
  ini_ProcIter(&sts, cp, proc_mProcess_system, 0, ini_ProcPrio);

  net_Connect(&sts, &gdbroot->my_aid, &gdbroot->my_qid, NULL, "pwr_ini");
  /*if (!qcom_Init(&sts, 0)) {*/
  if (EVEN(sts)) {
    errh_LogFatal(&cp->log, "net_Connect, %m", sts);
    exit(sts);
  }

  qcom_SignalOr(
      &sts, &qcom_cQini, ini_mEvent_newPlcInit | ini_mEvent_newPlcStart);

  ini_ProcIter(&sts, cp, proc_mProcess_user, 0, ini_ProcLoad);
  ini_ProcIter(&sts, cp, proc_mProcess_user, 0, ini_ProcStart);
  ini_ProcIter(&sts, cp, proc_mProcess_user, 0, ini_ProcPrio);

  qcom_CreateQ(&sts, &cp->eventQ, NULL, "iniEvent");
  if (EVEN(sts)) {
    errh_LogFatal(&cp->log, "qcom_CreateQ, %m", sts);
    exit(sts);
  }

  qcom_WaitAnd(&sts, &cp->eventQ, &qcom_cQini,
      ini_mEvent_newPlcStartDone | cp->plc_sigmask, qcom_cTmoEternal);

  sts = ini_SetAttributeAfterPlc(cp->aliasfile.name, cp->nodename, 0);
  if (EVEN(sts) && sts != INI__FILE)
    errh_LogError(&cp->log, "ini_SetAttributeAfterPlc, %m", sts);

  ini_SetSystemStatus(cp, PWR__RUNNING);
  errh_SetStatus(PWR__SRUN);

  return sts;
}

static pwr_tStatus interactive(int argc, char** argv, ini_sContext* cp)
{
  pwr_tStatus sts;
  qcom_sQid qid;
  qcom_sPut put;
  qcom_sGet get;
  char *bp, *sp;
  int i;
  int len;
  int totlen;

  errh_Interactive();

  if (!qcom_Init(&sts, 0, "pwr_ini_restart")) {
    errh_LogFatal(&cp->log, "qcom_Init, %m", sts);
    exit(sts);
  }

  qcom_CreateQ(&sts, &cp->myQ, NULL, "pwr_ini_restart");
  if (EVEN(sts)) {
    errh_LogFatal(&cp->log, "qcom_CreateQ, %m", sts);
    exit(sts);
  }

  for (i = 0, totlen = 0; i < argc; i++) {
    len = strlen(argv[i]);
    totlen += 1 + len;
    errh_LogInfo(&cp->log, "argv[%d]: %d \"%s\"", i, len, argv[i]);
  }
  bp = malloc(totlen);
  for (i = 0, sp = bp; i < argc; i++) {
    len = strlen(argv[i]);
    memcpy(sp, argv[i], len + 1);
    sp += len + 1;
  }

  qid.qix = 550715;
  qid.nid = 0;
  put.type.b = 10;
  put.type.s = 1;
  put.reply = cp->myQ;
  put.data = bp;
  put.size = totlen;
  put.allocate = 1;

  qcom_Put(&sts, &qid, &put);

  while (1) {
    char* s;

    get.data = NULL;
    s = qcom_Get(&sts, &cp->myQ, &get, 100000);
    if (sts == QCOM__TMO && sts == QCOM__QEMPTY) {
      break;
    } else if (s != NULL) {
      printf("%s\n", s);
      qcom_Free(NULL, s);
    }
    if (get.type.s == 2)
      break;
  }

  return sts;
}

static pwr_tStatus stop(ini_sContext* cp)
{
  pwr_tStatus sts;
  qcom_sQid qid;
  qcom_sPut put;
  char data[] = "Shutdown you fool!";
  /*  qcom_sGet	get;
    char		*bp, *sp;
    int		i;
    int		len;
    int		totlen; */

  //  errh_Interactive();

  if (!qcom_Init(&sts, 0, "pwr_ini_stop")) {
    exit(sts);
  }

  //  qcom_CreateQ(&sts, &cp->myQ, NULL, "pwr_ini_restart");
  //  if (EVEN(sts)) {
  //    errh_LogFatal(&cp->log, "qcom_CreateQ, %m", sts);
  //    exit(sts);
  //  }

  //  for (i = 0, totlen = 0; i < argc; i++) {
  //    len = strlen(argv[i]);
  //    totlen += 1 + len;
  //    errh_LogInfo(&cp->log, "argv[%d]: %d \"%s\"", i, len, argv[i]);
  //  }
  //  bp = malloc(totlen);
  //  for (i = 0, sp = bp; i < argc; i++) {
  //    len = strlen(argv[i]);
  //    memcpy(sp, argv[i], len + 1);
  //    sp += len + 1;
  // }

  qid.qix = 550715;
  qid.nid = 0;
  put.type.b = 11;
  put.type.s = 1;
  put.reply.qix = 0;
  put.reply.nid = 0;
  put.data = data;
  put.size = sizeof(data) + 1;
  put.allocate = 1;
  qcom_Put(&sts, &qid, &put);

  //  while (1) {
  //    char *s;

  //    get.data = NULL;
  //    s = qcom_Get(&sts, &cp->myQ, &get, 100000);
  //    if (sts == QCOM__TMO && sts == QCOM__QEMPTY) {
  //      break;
  //    } else if (s != NULL) {
  //      printf("%s\n", s);
  //      qcom_Free(NULL, s);
  //    }
  //    if (get.type.s == 2)
  //      break;
  //  }

  return 0;
}

static pwr_tStatus restart(ini_sContext* cp)
{
  pwr_tStatus sts;
  char time[24];
  lst_sEntry* pl;
  ini_sProc* pp;

  ini_CheckContext(&sts, cp);

  ini_ReadBootFile(&sts, cp);
  ini_CheckNode(&sts, cp);

  checkErrors(cp);

  if (cp->flags.b.verbose)
    logCardinality(cp);

  qcom_SignalAnd(&sts, &qcom_cQini, 0);
  qcom_SignalOr(&sts, &qcom_cQini, ini_mEvent_swapInit);

  ini_ReloadNode(&sts, cp);

  if (cp->flags.b.verbose)
    logChanges(cp);

  qcom_SignalOr(&sts, &qcom_cQini, ini_mEvent_rebuildInit);
  ini_RebuildNode(&sts, cp);
  ini_DecodeBodies(&sts, cp, 0);
  ini_DecodeBodies(&sts, cp, 1);

  if (cp->flags.b.verbose)
    errh_LogInfo(&cp->log, "Update bodies of io objects");
  ini_UpdateBodies(&sts, cp, 1);
  io_init_signals();

  ini_ProcTable(&sts, cp);

  // ini_ProcLoad(&sts, cp, cp->plc);
  // ini_ProcStart(&sts, cp, cp->plc);
  ini_ProcIter(&sts, cp, proc_mProcess_user, ini_mProc_plc, ini_ProcLoad);
  ini_ProcIter(&sts, cp, proc_mProcess_user, ini_mProc_plc, ini_ProcStart);

  qcom_SignalOr(&sts, &qcom_cQini, ini_mEvent_newPlcInit);
  qcom_WaitAnd(&sts, &cp->eventQ, &qcom_cQini,
      ini_mEvent_newPlcInitDone | cp->plc_sigmask, qcom_cTmoEternal);
  errh_LogInfo(&cp->log, "Entering time critical period, stopping old PLC");
  qcom_SignalAnd(&sts, &qcom_cQini, ~cp->plc_sigmask);
  qcom_SignalOr(&sts, &qcom_cQini, ini_mEvent_oldPlcStop);
  qcom_WaitAnd(&sts, &cp->eventQ, &qcom_cQini,
      ini_mEvent_oldPlcStopDone | cp->plc_sigmask, qcom_cTmoEternal);
  qcom_SignalAnd(&sts, &qcom_cQini, ~ini_mEvent_oldPlcStop);

  ini_UpdateBodies(&sts, cp, 0);

  qcom_SignalAnd(&sts, &qcom_cQini, ~cp->plc_sigmask);
  qcom_SignalOr(&sts, &qcom_cQini, ini_mEvent_newPlcStart);
  qcom_WaitAnd(&sts, &cp->eventQ, &qcom_cQini,
      ini_mEvent_newPlcStartDone | cp->plc_sigmask, qcom_cTmoEternal);
  errh_LogInfo(&cp->log, "Time critical period over, new PLC is running");
  qcom_SignalOr(&sts, &qcom_cQini, ini_mEvent_swapDone);

  for (pp = lst_Succ(NULL, &cp->proc_lh, &pl); pp != NULL;
       pp = lst_Succ(NULL, pl, &pl)) {
    if (pp->flags.m & ini_mProc_plc && pp->objectp) {
      pwr_sClass_PlcProcess* plc = pp->objectp;

      time_GetTime(&plc->LastChgTime);
      if (time_Dcomp(&plc->StartTime, &plc->StopTime) == 1)
        time_Dsub(&plc->StallTime, &plc->StartTime, &plc->StopTime);
      else
        plc->StallTime = pwr_cNDeltaTime;
      time_DtoAscii(&plc->StallTime, 1, time, sizeof(time));
      cp->np->RestartStallTime = plc->StallTime;
    }
  }
  cp->log.put.type.s = 2;
  errh_LogInfo(&cp->log, "IO stall time: %s", time);

  ini_FreeBodies(&sts, cp, 0);
  ini_FreeBodies(&sts, cp, 1);

  return sts;
}

static pwr_tStatus terminate()
{
  pwr_tStatus sts;

  qcom_SignalAnd(&sts, &qcom_cQini, 0);
  qcom_SignalOr(&sts, &qcom_cQini, ini_mEvent_terminate);

  // qcom_SignalOr(&sts, &qcom_cQini, ini_mEvent_oldPlcStop);
  // qcom_WaitAnd(&sts, &cp->eventQ, &qcom_cQini, ini_mEvent_oldPlcStopDone,
  // qcom_cTmoEternal);

  qcom_Exit(NULL);

  /* Kill programs which until now doesn't handle qcom */
  /*
    for (pp = lst_Succ(NULL, &cp->proc_lh, &pl); pp != NULL; pp = lst_Succ(NULL,
    pl, &pl)) {
      if (str_StartsWith(pp->proc.name, "pwr_webmonmh")) {
        kill(pp->proc.pid, SIGKILL);
      }
      else if (str_StartsWith(pp->proc.name, "pwr_webmon")) {
        kill(pp->proc.pid, SIGKILL);
      }
    }
  */
  /* Now sleep for a while */

  sleep(3);

  /* Unlink shared memory and semaphores */

  gdb_UnlinkDb();
  qdb_UnlinkDb();
  delete_locks();

  /* Destroy message handler semaphore */

  mh_UtilDestroyEvent();

  /* Unlink errlog message queue */
  errl_Unlink();

  // if (cp->flags.b.daemonize) {
  //   if (pid_fd != -1) {
  //      lockf(pid_fd, F_ULOCK, 0);
  //      close(pid_fd);
  //    }

  //   if (pid_filename != NULL) {
  //     unlink(pid_filename);
  //   }
  // }

  exit(EXIT_SUCCESS);
}

static int ask_yes_no(char* text)
{
  char ans;
  printf("%s ? [Y/n]: ", text);
  scanf("%c", &ans);
  return (ans == 'y' || ans == 'Y');
}

static int checkErrors(ini_sContext* cp)
{
  if (cp->warnings == 0 && cp->errors == 0 && cp->fatals == 0)
    return 1;

  if (cp->fatals > 0) {
    errh_LogFatal(&cp->log,
        "Found %d warning(s), %d error(s) and %d fatal error(s)", cp->warnings,
        cp->errors, cp->fatals);
    if (cp->flags.b.ignoreFatal) {
      errh_LogInfo(
          &cp->log, "Ignoring fatal errors, errors and warnings, continued...");
      return 1;
    } else {
      return ask_yes_no("Do you want to continue");
    }
  }
  if (cp->errors > 0) {
    errh_LogError(&cp->log,
        "Found %d warning(s), %d error(s) and %d fatal error(s)", cp->warnings,
        cp->errors, cp->fatals);
    if (cp->flags.b.ignoreError) {
      errh_LogInfo(&cp->log, "Ignoring errors and warnings, continued...");
      return 1;
    } else {
      return ask_yes_no("Do you want to continue");
    }
  }
  if (cp->warnings > 0) {
    errh_LogWarning(&cp->log,
        "Found %d warning(s), %d error(s) and %d fatal error(s)", cp->warnings,
        cp->errors, cp->fatals);
    if (cp->flags.b.ignoreWarning) {
      errh_LogInfo(&cp->log, "Ignoring warnings, continued...");
      return 1;
    } else {
      return ask_yes_no("Do you want to continue");
    }
  }
  return 1;
}

static ini_sContext* createContext(int argc, char** argv)
{
  int i, j;
  ini_sContext* cp;
  pwr_tStatus sts;

  if (argc > 1 && streq(argv[1], "--version")) {
    system("cat $pwr_exe/rt_version.dat");
    exit(1);
  }
  if (!(cp = ini_CreateContext(&sts))) {
    fprintf(stderr, "%s: could not allocate context\n", argv[0]);
    exit(1);
  }

  for (i = 1; i < argc; i++) {
    if (argv[i][0] == '-') {
      int i_incr = 0;
      for (j = 1;
           argv[i][j] != 0 && argv[i][j] != ' ' && argv[i][j] != '	';
           j++) {
        switch (argv[i][j]) {
        case 'a':
          if (i + 1 >= argc
              || !(argv[i][j + 1] == ' ' || argv[i][j + 1] != '	')) {
            usage(argv[0]);
            exit(0);
          }
          cp->flags.b.applfile = 1;
          strcpy(cp->applfile.name, argv[i + 1]);
          i++;
          i_incr = 1;
          break;
        case 'b':
          if (i + 1 >= argc
              || !(argv[i][j + 1] == ' ' || argv[i][j + 1] != '	')) {
            usage(argv[0]);
            exit(0);
          }
          cp->flags.b.bootfile = 1;
          strcpy(cp->bootfile.name, argv[i + 1]);
          break;
        case 'c':
          if (i + 1 >= argc
              || !(argv[i][j + 1] == ' ' || argv[i][j + 1] != '	')) {
            usage(argv[0]);
            exit(0);
          }
          strcpy(cp->console, argv[i + 1]);
          i++;
          i_incr = 1;
          break;
        case 'd':
          if (i + 1 >= argc
              || !(argv[i][j + 1] == ' ' || argv[i][j + 1] != '	')) {
            usage(argv[0]);
            exit(0);
          }
          strcpy(cp->dir, argv[i + 1]);
          i++;
          i_incr = 1;
          break;
        case 'e':
          cp->flags.b.ignoreError = 1;
          break;
        case 'f':
          cp->flags.b.ignoreFatal = 1;
          break;
        case 'h':
          if (i + 1 >= argc
              || !(argv[i][j + 1] == ' ' || argv[i][j + 1] != '	')) {
            usage(argv[0]);
            exit(0);
          }
          cp->flags.b.hostname = 1;
          strcpy(cp->hostname, argv[i + 1]);
          i++;
          i_incr = 1;
          break;
        case 'i':
          cp->flags.b.interactive = 1;
          break;
        case 'n':
          if (i + 1 >= argc
              || !(argv[i][j + 1] == ' ' || argv[i][j + 1] != '	')) {
            usage(argv[0]);
            exit(0);
          }
          cp->flags.b.nodename = 1;
          strcpy(cp->nodename, argv[i + 1]);
          i++;
          i_incr = 1;
          break;
        case 'p':
          if (i + 1 >= argc
              || !(argv[i][j + 1] == ' ' || argv[i][j + 1] != '	')) {
            usage(argv[0]);
            exit(0);
          }
          cp->flags.b.plcfile = 1;
          cp->plcfile = (ini_sFile*)calloc(1, sizeof(ini_sFile));
          cp->plcfile_cnt = 1;
          strcpy(cp->plcfile[0].name, argv[i + 1]);
          cp->plcfile[0].logOpenFail = errh_LogInfo;
          i++;
          i_incr = 1;
          break;
        case 'q':
          if (i + 1 >= argc
              || !(argv[i][j + 1] == ' ' || argv[i][j + 1] != '	')) {
            usage(argv[0]);
            exit(0);
          }
          cp->flags.b.busid = 1;
          cp->busid = atoi(argv[i + 1]);
          break;
        case 'r':
          cp->flags.b.restart = 1;
          cp->flags.b.interactive = 1;
          break;
        case 's':
          cp->flags.b.stop = 1;
          break;
        case 'v':
          cp->flags.b.verbose = 1;
          break;
        case 'w':
          cp->flags.b.ignoreWarning = 1;
          break;
        case 'A':
          if (i + 1 >= argc
              || !(argv[i][j + 1] == ' ' || argv[i][j + 1] != '	')) {
            usage(argv[0]);
            exit(0);
          }
          cp->flags.b.aliasfile = 1;
          strcpy(cp->aliasfile.name, argv[i + 1]);
          i++;
          i_incr = 1;
          break;
        case 'D':
          cp->flags.b.daemonize = 1;
          break;
        case 'P':
          if (i + 1 >= argc
              || !(argv[i][j + 1] == ' ' || argv[i][j + 1] != '	')) {
            usage(argv[0]);
            exit(0);
          }
          cp->flags.b.daemonize = 1;
          pid_filename = strdup(argv[i + 1]);
          i++;
          i_incr = 1;
          break;
        case '?':
          usage(argv[0]);
          break;
        default:
          usage(argv[0]);
          exit(0);
        }
        if (i_incr)
          break;
      }
    }
  }

  return cp;
}
static void usage(char* name)
{
  fprintf(stderr, "usage: %s -a arg -b arg -d arg -efg arg -hip arg -q arg -ru "
                  "arg -s arg -vwA arg -H arg\n",
      name);
  fprintf(stderr, "  -?    : give help\n");
  fprintf(stderr, "  -a arg: use 'arg' as application file\n");
  fprintf(stderr, "  -b arg: use 'arg' as boot file\n");
  fprintf(stderr, "  -d arg: use files from directory 'arg'\n");
  fprintf(stderr, "  -e    : ignore errors\n");
  fprintf(stderr, "  -f    : ignore fatal errors\n");
  fprintf(stderr, "  -g arg: setgid to 'arg' before starting\n");
  fprintf(stderr, "  -h    : give help\n");
  fprintf(stderr, "  -i    : interactive, log to stdout\n");
  fprintf(stderr, "  -p arg: use 'arg' as PLC\n");
  fprintf(stderr, "  -q arg: use 'arg' as qcom bus id\n");
  fprintf(stderr, "  -r    : restart with new versions of loadfiles and PLC\n");
  fprintf(stderr, "  -s    : stop of Proview/R\n");
  fprintf(stderr, "  -u arg: setuid to 'arg' before starting\n");
  fprintf(stderr, "  -v    : verbose\n");
  fprintf(stderr, "  -w    : ignore warnings\n");
  fprintf(stderr, "  -A arg: use 'arg' as alias file\n");
  fprintf(stderr,
      "  -D    : Daemonize rt_ini. Default PID file is /run/pwr/pwr.pid\n");
  fprintf(stderr, "  -p    : PID file, implies -D\n");
  fprintf(stderr, "  -H arg: use 'arg' as hostname\n");
  fprintf(stderr, "  -N arg: use 'arg' as nodename\n");
  exit(1);
}

static void logChanges(ini_sContext* cp)
{
  lst_sEntry* vl;
  lst_sEntry* ol;
  ivol_sVolume* vp;
  ivol_sObject* iop;
  int cre, upd, upd_io;

  for (vp = lst_Succ(NULL, &cp->vol_lh, &vl); vp != NULL;
       vp = lst_Succ(NULL, vl, &vl)) {
    cre = upd = upd_io = 0;
    for (iop = lst_Succ(NULL, &vp->cre_lh, &ol); iop != NULL;
         iop = lst_Succ(NULL, ol, &ol)) {
      errh_LogInfo(&cp->log, "cre: %s\n", iop->oh.name);
      cre++;
    }
    for (iop = lst_Succ(NULL, &vp->upd_io_lh, &ol); iop != NULL;
         iop = lst_Succ(NULL, ol, &ol)) {
      printf("upd: %s, (", iop->op->g.f.name.orig);
      if (iop->flags.b.father)
        printf("father, ");
      if (iop->flags.b.name)
        printf("name, ");
      if (iop->flags.b.server)
        printf("server, ");
      if (iop->flags.b.classid)
        printf("class, ");
      if (iop->flags.b.size)
        printf("size, ");
      if (iop->flags.b.flags)
        printf("flags, ");
      if (iop->flags.b.body)
        printf("body, ");
      printf(")\n");
      upd_io++;
    }
    for (iop = lst_Succ(NULL, &vp->upd_lh, &ol); iop != NULL;
         iop = lst_Succ(NULL, ol, &ol)) {
      printf("upd: %s, (", iop->op->g.f.name.orig);
      if (iop->flags.b.father)
        printf("father, ");
      if (iop->flags.b.name)
        printf("name, ");
      if (iop->flags.b.server)
        printf("server, ");
      if (iop->flags.b.classid)
        printf("class, ");
      if (iop->flags.b.size)
        printf("size, ");
      if (iop->flags.b.flags)
        printf("flags, ");
      if (iop->flags.b.body)
        printf("body, ");
      printf(")\n");
      upd++;
    }
    errh_LogInfo(&cp->log, "Volume: %s, id: %d, cre: %d, upd_io: %d, upd: %d\n",
        vp->volume.name, vp->vid, cre, upd_io, upd);
  }
}

static void logCardinality(ini_sContext* cp)
{
  lst_sEntry* vl;
  ivol_sVolume* vp;

  errh_LogInfo(&cp->log, "Cardinality: %d, bodysize: %d\n",
      cp->node.cardinality, cp->node.bodySize);
  for (vp = lst_Succ(NULL, &cp->vol_lh, &vl); vp != NULL;
       vp = lst_Succ(NULL, vl, &vl))
    errh_LogInfo(&cp->log,
        "Volume: %s, id: %d, cardinality: %d, bodysize: %d\n", vp->volume.name,
        vp->vid, vp->volume.cardinality, vp->volume.rbodySize);
}

static pwr_tStatus events(ini_sContext* cp)
{
  lst_sEntry* pl;
  ini_sProc* pp;
  pid_t pid;
  pid_t last_pid = 1;
  pwr_tStatus sts = INI__SUCCESS;
  qcom_sGet get;
  int tmo_ms = 1000;

  cp->myQ.qix = 550715;
  cp->myQ.nid = 0;

  qcom_CreateQ(&sts, &cp->myQ, NULL, "events");
  if (EVEN(sts)) {
    errh_LogFatal(&cp->log, "qcom_CreateQ, %m", sts);
    exit(sts);
  }

  for (;;) {
    int status;

    get.data = NULL;
    qcom_Get(&sts, &cp->myQ, &get, tmo_ms);

    /* Request for termination ?? */
    if (sts != QCOM__TMO && sts != QCOM__QEMPTY && get.type.b == 11) {
      sts = terminate(cp);
      return sts;
    }

    /* Request for restart */
    if (sts != QCOM__TMO && sts != QCOM__QEMPTY && get.data != NULL) {
      int len, i, argc, totlen;
      char **argv, *s;
      ini_sContext* ncp;

      for (argc = 0, s = get.data, totlen = 0; totlen < get.size; argc++) {
        len = strlen(s);
        s += len + 1;
        totlen += len + 1;
      }
      argv = (char**)calloc(sizeof(void*), argc);
      for (i = 0, s = get.data; i < argc; i++) {
        len = strlen(s);
        argv[i] = s;
        s += len + 1;
      }
      ncp = createContext(argc, argv);
      if (ncp != NULL) {
        ncp->log.put.type.b = 10;
        ncp->log.put.type.s = 1;
        ncp->log.send = 1;
        ncp->log.put.reply = cp->myQ;
        ncp->log.logQ = get.reply;
        ncp->eventQ = cp->eventQ;
        ncp->yourQ = get.reply;
        restart(ncp);
        free(ncp);
      }
      free(argv);
      qcom_Free(NULL, get.data);
    }

    if (lst_Succ(NULL, &cp->proc_lh, &pl) == NULL)
      break;
    pid = waitpid(-1, &status, WNOHANG | WUNTRACED);
    if (pid == 0)
      continue;
    if (pid == last_pid)
      break;

    for (pp = lst_Succ(NULL, &cp->proc_lh, &pl); pp != NULL;
         pp = lst_Succ(NULL, pl, &pl)) {
      if (pp->proc.pid == pid) {
        errh_LogInfo(&cp->log, "Process %s exited with status %d",
            pp->proc.name, status);
        break;
      }
    }
  }

  return INI__SUCCESS;
}

static void create_locks()
{
  pwr_tStatus sts;

  lck_Create(&sts, lck_eLock_Time);
  if (EVEN(sts))
    errh_Fatal("lock create time, %m", sts);
  lck_Create(&sts, lck_eLock_Str);
  if (EVEN(sts))
    errh_Fatal("lock create str, %m", sts);
  lck_Create(&sts, lck_eLock_NMps);
  if (EVEN(sts))
    errh_Fatal("lock create NMps, %m", sts);
}

static void delete_locks()
{
  pwr_tStatus sts;

  lck_Delete(&sts, lck_eLock_Time);
  if (EVEN(sts))
    errh_Fatal("lock delete time, %m", sts);
  lck_Delete(&sts, lck_eLock_Str);
  if (EVEN(sts))
    errh_Fatal("lock delete str, %m", sts);
  lck_Delete(&sts, lck_eLock_NMps);
  if (EVEN(sts))
    errh_Fatal("lock delete NMps, %m", sts);
}

static void load_backup()
{
  pwr_tObjid oid;
  pwr_sClass_AvArea* avp;
  pwr_sClass_DvArea* dvp;
  pwr_sClass_IvArea* ivp;
  pwr_sClass_ATvArea* atvp;
  pwr_sClass_DTvArea* dtvp;
  pwr_sClass_SvArea* svp;
  pwr_sClass_InitArea* iavp;
  pwr_sClass_InitArea* idvp;
  pwr_sClass_InitArea* iivp;
  pwr_sClass_InitArea* iatvp;
  pwr_sClass_InitArea* idtvp;
  pwr_sClass_InitArea* isvp;
  pwr_tStatus sts;
  int i;
  pwr_sClass_IOHandler* iop;
  pwr_sAttrRef aref;

  sts = io_get_iohandler_object(&iop, NULL);
  if (EVEN(sts)) {
    errh_Error("io_get_iohandler_object, %m", sts);
    return;
  }

  sts = gdh_NameToObjid("pwrNode-active-io-av", &oid);
  if (EVEN(sts)) {
    errh_Error("gdh_NameToObjid(pwrNode-active-io-av, &oid), %m", sts);
    return;
  }

  sts = gdh_ObjidToPointer(oid, (void*)&avp);
  if (EVEN(sts)) {
    errh_Error("gdh_ObjidToPointer(oid, (void *) &avp), %m", sts);
    return;
  }

  sts = gdh_NameToObjid("pwrNode-active-io-av_init", &oid);
  if (EVEN(sts)) {
    errh_Error("gdh_NameToObjid(pwrNode-active-io-av_init, &oid), %m", sts);
    return;
  }

  sts = gdh_ObjidToPointer(oid, (void*)&iavp);
  if (EVEN(sts)) {
    errh_Error("gdh_ObjidToPointer(oid, (void *) &iavp), %m", sts);
    return;
  }

  sts = gdh_NameToObjid("pwrNode-active-io-dv", &oid);
  if (EVEN(sts)) {
    errh_Error("gdh_NameToObjid(pwrNode-active-io-dv, &oid), %m", sts);
    return;
  }

  sts = gdh_ObjidToPointer(oid, (void*)&dvp);
  if (EVEN(sts)) {
    errh_Error("gdh_ObjidToPointer(oid, (void *) &dvp), %m", sts);
    return;
  }

  sts = gdh_NameToObjid("pwrNode-active-io-dv_init", &oid);
  if (EVEN(sts)) {
    errh_Error("gdh_NameToObjid(pwrNode-active-io-dv_init, &oid), %m", sts);
    return;
  }

  sts = gdh_ObjidToPointer(oid, (void*)&idvp);
  if (EVEN(sts)) {
    errh_Error("gdh_ObjidToPointer(oid, (void *) &idvp), %m", sts);
    return;
  }

  sts = gdh_NameToObjid("pwrNode-active-io-iv", &oid);
  if (EVEN(sts)) {
    errh_Error("gdh_NameToObjid(pwrNode-active-io-iv, &oid), %m", sts);
    return;
  }

  sts = gdh_ObjidToPointer(oid, (void*)&ivp);
  if (EVEN(sts)) {
    errh_Error("gdh_ObjidToPointer(oid, (void *) &ivp), %m", sts);
    return;
  }

  sts = gdh_NameToObjid("pwrNode-active-io-atv", &oid);
  if (EVEN(sts)) {
    errh_Error("gdh_NameToObjid(pwrNode-active-io-atv, &oid), %m", sts);
    return;
  }

  sts = gdh_ObjidToPointer(oid, (void*)&atvp);
  if (EVEN(sts)) {
    errh_Error("gdh_ObjidToPointer(oid, (void *) &atvp), %m", sts);
    return;
  }

  sts = gdh_NameToObjid("pwrNode-active-io-dtv", &oid);
  if (EVEN(sts)) {
    errh_Error("gdh_NameToObjid(pwrNode-active-io-dtv, &oid), %m", sts);
    return;
  }

  sts = gdh_ObjidToPointer(oid, (void*)&dtvp);
  if (EVEN(sts)) {
    errh_Error("gdh_ObjidToPointer(oid, (void *) &dtvp), %m", sts);
    return;
  }

  sts = gdh_NameToObjid("pwrNode-active-io-sv", &oid);
  if (EVEN(sts)) {
    errh_Error("gdh_NameToObjid(pwrNode-active-io-sv, &oid), %m", sts);
    return;
  }

  sts = gdh_ObjidToPointer(oid, (void*)&svp);
  if (EVEN(sts)) {
    errh_Error("gdh_ObjidToPointer(oid, (void *) &svp), %m", sts);
    return;
  }

  sts = gdh_NameToObjid("pwrNode-active-io-iv_init", &oid);
  if (EVEN(sts)) {
    errh_Error("gdh_NameToObjid(pwrNode-active-io-iv_init, &oid), %m", sts);
    return;
  }

  sts = gdh_ObjidToPointer(oid, (void*)&iivp);
  if (EVEN(sts)) {
    errh_Error("gdh_ObjidToPointer(oid, (void *) &iivp), %m", sts);
    return;
  }

  sts = gdh_NameToObjid("pwrNode-active-io-atv_init", &oid);
  if (EVEN(sts)) {
    errh_Error("gdh_NameToObjid(pwrNode-active-io-atv_init, &oid), %m", sts);
    return;
  }

  sts = gdh_ObjidToPointer(oid, (void*)&iatvp);
  if (EVEN(sts)) {
    errh_Error("gdh_ObjidToPointer(oid, (void *) &iatvp), %m", sts);
    return;
  }

  sts = gdh_NameToObjid("pwrNode-active-io-dtv_init", &oid);
  if (EVEN(sts)) {
    errh_Error("gdh_NameToObjid(pwrNode-active-io-dtv_init, &oid), %m", sts);
    return;
  }

  sts = gdh_ObjidToPointer(oid, (void*)&idtvp);
  if (EVEN(sts)) {
    errh_Error("gdh_ObjidToPointer(oid, (void *) &idtvp), %m", sts);
    return;
  }

  sts = gdh_NameToObjid("pwrNode-active-io-sv_init", &oid);
  if (EVEN(sts)) {
    errh_Error("gdh_NameToObjid(pwrNode-active-io-sv_init, &oid), %m", sts);
    return;
  }

  sts = gdh_ObjidToPointer(oid, (void*)&isvp);
  if (EVEN(sts)) {
    errh_Error("gdh_ObjidToPointer(oid, (void *) &isvp), %m", sts);
    return;
  }

  for (i = 0; i < iop->AvCount; i++) {
    pwr_tFloat32* ifp = gdh_TranslateRtdbPointer(iavp->Value[i]);
    avp->Value[i] = *ifp;
  }

  for (i = 0; i < iop->DvCount; i++) {
    pwr_tBoolean* ibp = gdh_TranslateRtdbPointer(idvp->Value[i]);
    dvp->Value[i] = *ibp;
  }

  for (i = 0; i < iop->IvCount; i++) {
    pwr_tInt32* iip = gdh_TranslateRtdbPointer(iivp->Value[i]);
    ivp->Value[i] = *iip;
  }

  for (i = 1; i < iop->ATvCount; i++) {
    pwr_tTime* iatp = gdh_TranslateRtdbPointer(iatvp->Value[i]);
    atvp->Value[i] = *iatp;
  }

  for (i = 0; i < iop->DTvCount; i++) {
    pwr_tDeltaTime* idtp = gdh_TranslateRtdbPointer(idtvp->Value[i]);
    dtvp->Value[i] = *idtp;
  }

  for (i = 0; i < iop->SvCount; i++) {
    char* istrp = gdh_TranslateRtdbPointer(isvp->Value[i]);
    strncpy(svp->Value[i], istrp, sizeof(svp->Value[0]));
  }

  typedef struct {
    union {
      pwr_tFloat32* f;
      pwr_tInt32* i;
      pwr_tBoolean* b;
      pwr_tTime* at;
      pwr_tDeltaTime* dt;
      pwr_tString80* str;
    } actval_p;
    pwr_tUInt32 validx;
    union {
      pwr_sClass_Av* av;
      pwr_sClass_Iv* iv;
      pwr_sClass_Dv* dv;
      pwr_sClass_Ai* ai;
      pwr_sClass_Ao* ao;
      pwr_sClass_Ii* ii;
      pwr_sClass_Io* io;
      pwr_sClass_Di* di;
      pwr_sClass_Do* dox;
      pwr_sClass_Co* co;
      pwr_sClass_ATv* atv;
      pwr_sClass_DTv* dtv;
      pwr_sClass_Sv* sv;
    } op;
  } ini_sRestoreSig;

  ini_sRestoreSig* rsav = NULL;
  ini_sRestoreSig* rsdv = NULL;
  ini_sRestoreSig* rsiv = NULL;
  ini_sRestoreSig* rsatv = NULL;
  ini_sRestoreSig* rsdtv = NULL;
  ini_sRestoreSig* rssv = NULL;
  ini_sRestoreSig* rsai = NULL;
  ini_sRestoreSig* rsao = NULL;
  ini_sRestoreSig* rsii = NULL;
  ini_sRestoreSig* rsio = NULL;
  ini_sRestoreSig* rsdi = NULL;
  ini_sRestoreSig* rsdo = NULL;
  ini_sRestoreSig* rsco = NULL;
  pwr_tInt32** rscoa = NULL;

  // Store ActualValue pointers
  rsav = calloc(sizeof(ini_sRestoreSig), iop->AvCount);
  i = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Av, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Av, &aref, &aref)) {
    if (i >= iop->AvCount)
      break;

    sts = gdh_AttrRefToPointer(&aref, (pwr_tAddress*)&rsav[i].op.av);
    if (EVEN(sts)) {
      errh_Error("gdh_AttrRefToPointer Iv, %m", sts);
      goto error;
    }

    rsav[i].actval_p.f = rsav[i].op.av->ActualValue;
    rsav[i].validx = rsav[i].op.av->ValueIndex;
    i++;
  }

  rsdv = calloc(sizeof(ini_sRestoreSig), iop->DvCount);
  i = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Dv, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Dv, &aref, &aref)) {
    if (i >= iop->DvCount)
      break;

    sts = gdh_AttrRefToPointer(&aref, (pwr_tAddress*)&rsdv[i].op.dv);
    if (EVEN(sts)) {
      errh_Error("gdh_AttrRefToPointer Iv, %m", sts);
      goto error;
    }

    rsdv[i].actval_p.b = rsdv[i].op.dv->ActualValue;
    rsdv[i].validx = rsdv[i].op.dv->ValueIndex;
    i++;
  }

  rsiv = calloc(sizeof(ini_sRestoreSig), iop->IvCount);
  i = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Iv, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Iv, &aref, &aref)) {
    if (i >= iop->IvCount)
      break;

    sts = gdh_AttrRefToPointer(&aref, (pwr_tAddress*)&rsiv[i].op.iv);
    if (EVEN(sts)) {
      errh_Error("gdh_AttrRefToPointer Iv, %m", sts);
      goto error;
    }

    rsiv[i].actval_p.i = rsiv[i].op.iv->ActualValue;
    rsiv[i].validx = rsiv[i].op.iv->ValueIndex;
    i++;
  }

  rsatv = calloc(sizeof(ini_sRestoreSig), iop->ATvCount);
  i = 1;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_ATv, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_ATv, &aref, &aref)) {
    if (i >= iop->ATvCount)
      break;

    sts = gdh_AttrRefToPointer(&aref, (pwr_tAddress*)&rsatv[i].op.atv);
    if (EVEN(sts)) {
      errh_Error("gdh_AttrRefToPointer ATv, %m", sts);
      goto error;
    }

    rsatv[i].actval_p.at = rsatv[i].op.atv->ActualValue;
    rsatv[i].validx = rsatv[i].op.atv->ValueIndex;
    i++;
  }

  rsdtv = calloc(sizeof(ini_sRestoreSig), iop->DTvCount);
  i = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_DTv, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_DTv, &aref, &aref)) {
    if (i >= iop->DTvCount)
      break;

    sts = gdh_AttrRefToPointer(&aref, (pwr_tAddress*)&rsdtv[i].op.dtv);
    if (EVEN(sts)) {
      errh_Error("gdh_AttrRefToPointer DTv, %m", sts);
      goto error;
    }

    rsdtv[i].actval_p.dt = rsdtv[i].op.dtv->ActualValue;
    rsdtv[i].validx = rsdtv[i].op.dtv->ValueIndex;
    i++;
  }

  rssv = calloc(sizeof(ini_sRestoreSig), iop->SvCount);
  i = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Sv, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Sv, &aref, &aref)) {
    if (i >= iop->SvCount)
      break;

    sts = gdh_AttrRefToPointer(&aref, (pwr_tAddress*)&rssv[i].op.sv);
    if (EVEN(sts)) {
      errh_Error("gdh_AttrRefToPointer Sv, %m", sts);
      goto error;
    }

    rssv[i].actval_p.str = rssv[i].op.sv->ActualValue;
    rssv[i].validx = rssv[i].op.sv->ValueIndex;
    i++;
  }

  rsai = calloc(sizeof(ini_sRestoreSig), iop->AiCount);
  i = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Ai, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Ai, &aref, &aref)) {
    if (i >= iop->AiCount)
      break;

    sts = gdh_AttrRefToPointer(&aref, (pwr_tAddress*)&rsai[i].op.ai);
    if (EVEN(sts)) {
      errh_Error("gdh_AttrRefToPointer Iv, %m", sts);
      goto error;
    }

    rsai[i].actval_p.f = rsai[i].op.ai->ActualValue;
    rsai[i].validx = rsai[i].op.ai->ValueIndex;
    i++;
  }

  rsao = calloc(sizeof(ini_sRestoreSig), iop->AoCount);
  i = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Ao, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Ao, &aref, &aref)) {
    if (i >= iop->AoCount)
      break;

    sts = gdh_AttrRefToPointer(&aref, (pwr_tAddress*)&rsao[i].op.ao);
    if (EVEN(sts)) {
      errh_Error("gdh_AttrRefToPointer Iv, %m", sts);
      goto error;
    }

    rsao[i].actval_p.f = rsao[i].op.ao->ActualValue;
    rsao[i].validx = rsao[i].op.ao->ValueIndex;
    i++;
  }

  rsii = calloc(sizeof(ini_sRestoreSig), iop->IiCount);
  i = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Ii, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Ii, &aref, &aref)) {
    if (i >= iop->IiCount)
      break;

    sts = gdh_AttrRefToPointer(&aref, (pwr_tAddress*)&rsii[i].op.ii);
    if (EVEN(sts)) {
      errh_Error("gdh_AttrRefToPointer Iv, %m", sts);
      goto error;
    }

    rsii[i].actval_p.i = rsii[i].op.ii->ActualValue;
    rsii[i].validx = rsii[i].op.ii->ValueIndex;
    i++;
  }

  rsio = calloc(sizeof(ini_sRestoreSig), iop->IoCount);
  i = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Io, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Io, &aref, &aref)) {
    if (i >= iop->IoCount)
      break;

    sts = gdh_AttrRefToPointer(&aref, (pwr_tAddress*)&rsio[i].op.io);
    if (EVEN(sts)) {
      errh_Error("gdh_AttrRefToPointer Iv, %m", sts);
      goto error;
    }

    rsio[i].actval_p.i = rsio[i].op.io->ActualValue;
    rsio[i].validx = rsio[i].op.io->ValueIndex;
    i++;
  }

  rsdi = calloc(sizeof(ini_sRestoreSig), iop->DiCount);
  i = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Di, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Di, &aref, &aref)) {
    if (i >= iop->DiCount)
      break;

    sts = gdh_AttrRefToPointer(&aref, (pwr_tAddress*)&rsdi[i].op.di);
    if (EVEN(sts)) {
      errh_Error("gdh_AttrRefToPointer Iv, %m", sts);
      goto error;
    }

    rsdi[i].actval_p.b = rsdi[i].op.di->ActualValue;
    rsdi[i].validx = rsdi[i].op.di->ValueIndex;
    i++;
  }

  rsdo = calloc(sizeof(ini_sRestoreSig), iop->DoCount);
  i = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Do, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Do, &aref, &aref)) {
    if (i >= iop->DoCount)
      break;

    sts = gdh_AttrRefToPointer(&aref, (pwr_tAddress*)&rsdo[i].op.dox);
    if (EVEN(sts)) {
      errh_Error("gdh_AttrRefToPointer Iv, %m", sts);
      goto error;
    }

    rsdo[i].actval_p.b = rsdo[i].op.dox->ActualValue;
    rsdo[i].validx = rsdo[i].op.dox->ValueIndex;
    i++;
  }

  rsco = calloc(sizeof(ini_sRestoreSig), iop->CoCount);
  rscoa = calloc(sizeof(pwr_tInt32*), iop->CoCount);
  i = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Co, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Co, &aref, &aref)) {
    if (i >= iop->CoCount)
      break;

    sts = gdh_AttrRefToPointer(&aref, (pwr_tAddress*)&rsco[i].op.co);
    if (EVEN(sts)) {
      errh_Error("gdh_AttrRefToPointer Iv, %m", sts);
      goto error;
    }

    rsco[i].actval_p.i = rsco[i].op.co->RawValue;
    rsco[i].validx = rsco[i].op.co->ValueIndex;
    rscoa[i] = rsco[i].op.co->AbsValue;
    i++;
  }

  sts = bck_LoadBackup();
  if (EVEN(sts)) {
    errh_Error("bck_LoadBackup, %m", sts);
    goto error;
  }

  // Set stored ActualValue pointers
  for (i = 0; i < iop->AvCount; i++) {
    rsav[i].op.av->ActualValue = rsav[i].actval_p.f;
    rsav[i].op.av->ValueIndex = rsav[i].validx;
  }
  free(rsav);

  for (i = 0; i < iop->DvCount; i++) {
    rsdv[i].op.dv->ActualValue = rsdv[i].actval_p.b;
    rsdv[i].op.dv->ValueIndex = rsdv[i].validx;
  }
  free(rsdv);

  for (i = 0; i < iop->IvCount; i++) {
    rsiv[i].op.iv->ActualValue = rsiv[i].actval_p.i;
    rsiv[i].op.iv->ValueIndex = rsiv[i].validx;
  }
  free(rsiv);

  for (i = 1; i < iop->ATvCount; i++) {
    rsatv[i].op.atv->ActualValue = rsatv[i].actval_p.at;
    rsatv[i].op.atv->ValueIndex = rsatv[i].validx;
  }
  free(rsatv);

  for (i = 0; i < iop->DTvCount; i++) {
    rsdtv[i].op.dtv->ActualValue = rsdtv[i].actval_p.dt;
    rsdtv[i].op.dtv->ValueIndex = rsdtv[i].validx;
  }
  free(rsdtv);

  for (i = 0; i < iop->SvCount; i++) {
    rssv[i].op.sv->ActualValue = rssv[i].actval_p.str;
    rssv[i].op.sv->ValueIndex = rssv[i].validx;
  }
  free(rssv);

  for (i = 0; i < iop->AiCount; i++) {
    rsai[i].op.ai->ActualValue = rsai[i].actval_p.f;
    rsai[i].op.ai->ValueIndex = rsai[i].validx;
  }
  free(rsai);

  for (i = 0; i < iop->AoCount; i++) {
    rsao[i].op.ao->ActualValue = rsao[i].actval_p.f;
    rsao[i].op.ao->ValueIndex = rsao[i].validx;
  }
  free(rsao);

  for (i = 0; i < iop->IiCount; i++) {
    rsii[i].op.ii->ActualValue = rsii[i].actval_p.i;
    rsii[i].op.ii->ValueIndex = rsii[i].validx;
  }
  free(rsii);

  for (i = 0; i < iop->IoCount; i++) {
    rsio[i].op.io->ActualValue = rsio[i].actval_p.i;
    rsio[i].op.io->ValueIndex = rsio[i].validx;
  }
  free(rsio);

  for (i = 0; i < iop->DiCount; i++) {
    rsdi[i].op.di->ActualValue = rsdi[i].actval_p.b;
    rsdi[i].op.di->ValueIndex = rsdi[i].validx;
  }
  free(rsdi);

  for (i = 0; i < iop->DoCount; i++) {
    rsdo[i].op.dox->ActualValue = rsdo[i].actval_p.b;
    rsdo[i].op.dox->ValueIndex = rsdo[i].validx;
  }
  free(rsdo);

  for (i = 0; i < iop->CoCount; i++) {
    rsco[i].op.co->RawValue = rsco[i].actval_p.i;
    rsco[i].op.co->AbsValue = rscoa[i];
    rsco[i].op.co->ValueIndex = rsco[i].validx;
  }
  free(rsco);
  free(rscoa);

  for (i = 0; i < iop->AvCount; i++) {
    pwr_tFloat32* ifp = gdh_TranslateRtdbPointer(iavp->Value[i]);
    *ifp = avp->Value[i];
  }

  for (i = 0; i < iop->DvCount; i++) {
    pwr_tBoolean* ibp = gdh_TranslateRtdbPointer(idvp->Value[i]);
    *ibp = dvp->Value[i];
  }

  for (i = 0; i < iop->IvCount; i++) {
    pwr_tInt32* iip = gdh_TranslateRtdbPointer(iivp->Value[i]);
    *iip = ivp->Value[i];
  }

  for (i = 1; i < iop->ATvCount; i++) {
    pwr_tTime* iatp = gdh_TranslateRtdbPointer(iatvp->Value[i]);
    *iatp = atvp->Value[i];
  }

  for (i = 0; i < iop->DTvCount; i++) {
    pwr_tDeltaTime* idtp = gdh_TranslateRtdbPointer(idtvp->Value[i]);
    *idtp = dtvp->Value[i];
  }

  for (i = 0; i < iop->SvCount; i++) {
    char* istrp = gdh_TranslateRtdbPointer(isvp->Value[i]);
    strncpy(istrp, svp->Value[i], 80);
  }

  return; // Normal execution

error:
  if (rsav != NULL)
    free(rsav);
  if (rsdv != NULL)
    free(rsdv);
  if (rsiv != NULL)
    free(rsiv);
  if (rsatv != NULL)
    free(rsatv);
  if (rsdtv != NULL)
    free(rsdtv);
  if (rssv != NULL)
    free(rssv);
  if (rsai != NULL)
    free(rsai);
  if (rsao != NULL)
    free(rsao);
  if (rsii != NULL)
    free(rsii);
  if (rsio != NULL)
    free(rsio);
  if (rsdi != NULL)
    free(rsdi);
  if (rsdo != NULL)
    free(rsdo);
  if (rsco != NULL)
    free(rsco);
  if (rscoa != NULL)
    free(rscoa);
}

static void ini_errl_cb(void* userdata, char* str, char severity,
    pwr_tStatus sts, int anix, int message_type)
{
  ini_sContext* cp = (ini_sContext*)userdata;

  if (anix == 0 || !cp->np)
    return;
  if (anix >= sizeof(cp->np->ProcStatus) / sizeof(cp->np->ProcStatus[0])) {
    printf("Init: undefined anix %d\n", anix);
    return;
  }

  switch (message_type) {
  case errh_eMsgType_Log:
    if (sts == 0) {
      switch (severity) {
      case 'S':
      case 'I':
        sts = PWR__SRVINFO;
        break;
      case 'E':
        sts = PWR__SRVERROR;
        break;
      case 'W':
        sts = PWR__SRVWARNING;
        break;
      case 'F':
        sts = PWR__SRVFATAL;
        break;
      }
    }
    cp->np->ProcMsgSeverity[anix - 1] = sts;
    strncpy(cp->np->ProcMessage[anix - 1], &str[49],
        sizeof(cp->np->ProcMessage[0]));
    cp->np->ProcMessage[anix - 1][sizeof(cp->np->ProcMessage[0]) - 1] = 0;
    break;
  case errh_eMsgType_Status:
    cp->np->ProcStatus[anix - 1] = sts;
    break;
  }
}

/**
 * @brief create_pidfile Creates a pidfile for the process for things like
 * systemd to keep track of.
 */
static void create_pidfile()
{
  char str[256];

  if (pid_filename == NULL)
    pid_filename = strdup(RT_INI_PIDFILE);

  pid_fd = open(pid_filename, O_RDWR | O_CREAT, 0640);
  if (pid_fd < 0) {
    exit(EXIT_FAILURE);
  }

  if (lockf(pid_fd, F_TLOCK, 0) < 0) {
    exit(EXIT_FAILURE);
  }

  sprintf(str, "%d\n", getpid());
  write(pid_fd, str, strlen(str));
}

/**
 * @brief daemonize Forks twice in order to detach itself properly. Closes all
 * file descriptors currently open.
 */
static void daemonize()
{
  pid_t pid = 0;
  int fd;

  // First fork
  pid = fork();
  if (pid < 0)
    exit(EXIT_FAILURE);
  // Let the parent exit
  if (pid > 0)
    exit(EXIT_SUCCESS);

  // Set the process to be session leader
  if (setsid() < 0)
    exit(EXIT_FAILURE);

  // Second fork
  pid = fork();
  if (pid < 0)
    exit(EXIT_FAILURE);
  // Bye bye parent
  if (pid > 0)
    exit(EXIT_SUCCESS);

  umask(002);
  chdir("/");

  // Close all file descriptors
  for (fd = sysconf(_SC_OPEN_MAX); fd > 0; fd--)
    close(fd);

  // Reopen some fds
  stdin = fopen("/dev/null", "r");
  stdout = fopen("/dev/null", "w+");
  stderr = fopen("/dev/null", "w+");
}
