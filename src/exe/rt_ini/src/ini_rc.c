/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <stdlib.h>

#include "pwr_names.h"

#include "co_string.h"

#include "rt_gdb.h"

#include "ini_rc.h"

typedef struct {
  char* name;
  int* var;
  int val;
} ini_sRc;

static pwr_tStatus setRcValue(ini_sRc* def_rc, char* name, int interval)
{
  ini_sRc* rc;

  for (rc = def_rc; rc && rc->name; rc++) {
    if (streq(rc->name, name)) {
      *rc->var = interval;
      return 1;
    }
  }

  printf("There is no variable named %s\n", name);
  return 0;
}

pwr_tStatus ini_RcReadAndSet(const char* dir, const char* nodename, int busid)
{
  ini_sRc def_rc[]
      = { { "cacheTrim", (int*)&gdbroot->db->cache_trim_int, 1000 },
          { "sancAdd", (int*)&gdbroot->db->sanc_add_int, 1000 },
          { "sancExpired", (int*)&gdbroot->db->sanc_exp_int, 60000 },
          { "sansCheck", (int*)&gdbroot->db->sans_chk_int, 1500 },
          { "subcCheck", (int*)&gdbroot->db->subc_chk_int, 3000 },
          { NULL, NULL, 0 } };

  FILE* fp;
  ini_sRc* rc;
  char* s;
  char buf[256];
  char name[128];
  char filename[128];
  int interval;

  for (rc = def_rc; rc && rc->name; rc++)
    *rc->var = rc->val;

  sprintf(filename, pwr_cNameRc, dir, nodename, busid);

  str_ToLower(filename, filename);
  fp = fopen(filename, "r");
  if (fp == NULL)
    return 1;

  printf("-- Reading rc file %s\n", filename);
  for (s = fgets(buf, sizeof(buf) - 1, fp); s != NULL;
       s = fgets(buf, sizeof(buf) - 1, fp)) {
    if (buf[0] == '#' || buf[0] == 0)
      continue;
    printf("-- %s", buf);
    name[0] = '\0';
    sscanf(buf, "%s %d\n", name, &interval);
    if (name[0] == '\0')
      continue;
    setRcValue(def_rc, name, interval);
  }
  fclose(fp);

  return 1;
}
