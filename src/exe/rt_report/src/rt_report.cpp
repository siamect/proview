/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include "co_cdh.h"
#include "co_dcli.h"
#include "co_error.h"
#include "co_string.h"
#include "co_syi.h"
#include "co_time.h"

#include "rt_aproc.h"
#include "rt_gdh.h"
#include "rt_ini_event.h"
#include "rt_pwr_msg.h"
#include "rt_qcom_msg.h"
#include "rt_report.h"

static rt_report* report = 0;

rt_report::rt_report()
    : scan_time(1), conf(0), first_scan(1), old_sec(0), old_min(0), old_hour(0),
      old_mday(0), old_wday(0), old_yday(0), now_sec(0), now_min(0),
      now_hour(0), now_mday(0), now_wday(0), now_yday(0)
{
  strcpy(display, "");
}

void rt_report::open()
{
  pwr_tStatus sts;
  pwr_tObjid oid;
  pwr_tFileName filename;

  // Open server configuration object ReportConfig
  sts = gdh_GetClassList(pwr_cClass_ReportConfig, &oid);
  if (ODD(sts)) {
    sts = gdh_ObjidToPointer(oid, (void**)&conf);
    if (EVEN(sts))
      throw co_error(sts);

    aproc_RegisterObject(oid);
  } else {
    errh_Info("No Report configuration");
    errh_SetStatus(0);
    exit(0);
  }

  for (sts = gdh_GetClassList(pwr_cClass_Report, &oid); ODD(sts);
       sts = gdh_GetNextObject(oid, &oid)) {
    report_sObject o;
    pwr_tAttrRef aref;

    aref = cdh_ObjidToAref(oid);

    sts = gdh_DLRefObjectInfoAttrref(&aref, (void**)&o.p, &o.dlid);
    repv.push_back(o);
  }

  sts = gdh_GetObjectInfo(
      "pwrNode-System.SystemGroup", &systemgroup, sizeof(systemgroup));
  if (EVEN(sts)) {
    errh_Error("Report terminated: %m", sts);
    conf->Status = sts;
    exit(0);
  }

  udb = new GeUser();
  sts = dcli_get_defaultfilename(user_cFilename, filename, "");
  udb->load(filename);

  conf->Status = PWR__SRUN;
}

void rt_report::close()
{
  repv.clear();
}

void rt_report::scan()
{
  periodic_scan();

  for (unsigned int i = 0; i < repv.size(); i++) {
    if (repv[i].p->Trigger || periodic_check(repv[i].p)) {
      repv[i].p->Trigger = 0;

      create_report(repv[i].p);
    }
  }

  aproc_TimeStamp(scantime(), 5);
}

int rt_report::periodic_check(pwr_sClass_Report* o)
{
  int offset = (int)time_DToFloat(0, &o->TimeOffset);

  switch (o->Periodicity) {
  case pwr_ePeriodicEnum_No:
    return 0;
  case pwr_ePeriodicEnum_Hourly:
    if (now_min < old_min)
      o->Sent = 0;
    if (!o->Sent) {
      if (now_min >= offset) {
        o->Sent = 1;
        if (now_min < offset + 60)
          return 1;
      }
    }
    break;
  case pwr_ePeriodicEnum_Daily:
    if (now_hour < old_hour)
      o->Sent = 0;
    if (!o->Sent) {
      if (now_hour >= offset) {
        o->Sent = 1;
        if (now_hour < offset + 60)
          return 1;
      }
    }
    break;
  case pwr_ePeriodicEnum_Weekly:
    if (now_wday < old_wday)
      o->Sent = 0;
    if (!o->Sent) {
      if (now_wday >= offset) {
        o->Sent = 1;
        if (now_wday < offset + 600)
          return 1;
      }
    }
    break;
  case pwr_ePeriodicEnum_Monthly:
    if (now_mday < old_mday)
      o->Sent = 0;
    if (!o->Sent) {
      if (now_mday >= offset) {
        o->Sent = 1;
        if (now_mday < offset + 3600)
          return 1;
      }
    }
    break;
  case pwr_ePeriodicEnum_Yearly:
    if (now_yday < old_yday)
      o->Sent = 0;
    if (!o->Sent) {
      if (now_yday >= offset) {
        o->Sent = 1;
        if (now_yday < offset + 3600)
          return 1;
      }
    }
    break;
  }
  return 0;
}

void rt_report::periodic_scan()
{
  struct tm tm;
  struct timespec t;

  old_sec = now_sec;
  old_min = now_min;
  old_hour = now_hour;
  old_mday = now_mday;
  old_wday = now_wday;
  old_yday = now_yday;

  clock_gettime(CLOCK_REALTIME, &t);
  localtime_r(&t.tv_sec, &tm);

  now_sec = tm.tm_sec;
  now_min = tm.tm_min * 60 + now_sec;
  now_hour = tm.tm_hour * 3600 + now_min;
  now_mday = tm.tm_mday * 24 * 3600 + now_hour;
  now_wday = tm.tm_wday * 24 * 3600 + now_hour;
  now_yday = tm.tm_yday * 24 * 3600 + now_hour;
}

void rt_report::create_report(pwr_sClass_Report* o)
{
  std::ifstream fin;
  std::ofstream fout;
  char line[500];
  char newline[500];
  pwr_tFileName fname;
  char str[256];
  char user[80];
  char group[80];
  char* s;
  char rcv_array[10][80];
  char subject[80];
  int rcvnum;
  pwr_tStatus sts;
  char address[40];
  pwr_tFileName cnvfile;
  pwr_tFileName tmpfile = "$pwrp_lis/report.tmp";
  pwr_tString256 conf_cmd;
  int first = 1;

  dcli_translate_filename(fname, o->TemplateFile);
  fin.open(fname);
  if (!fin) {
    // o->Status = GLOW__FILEOPEN;
    return;
  }

  dcli_translate_filename(fname, tmpfile);
  fout.open(fname);
  if (!fout) {
    // o->Status = GLOW__FILEOPEN;
    return;
  }

  fout << "<topic> index <style> report\n";

  while (fin.getline(line, sizeof(line))) {
    str_trim(newline, line);
    if (first && streq(newline, ""))
      continue;

    if (str_NoCaseStrncmp(newline, "<execute>", 9) == 0) {
      parse(&line[9]);
    } else {
      first = 0;

      replace_value(newline, sizeof(newline), line);

      fout << newline << '\n';
    }
  }

  fout << "</topic>\n";

  fin.close();
  fout.close();

  if (o->Media & pwr_mReportMediaMask_Email) {
    // Send email
    char text[400];
    pwr_tCmd cmd;

    switch (o->DocumentFormat) {
    case pwr_eDocumentFormatEnum_PDF:
      // Convert to pdf
      if (!streq(display, ""))
        sprintf(cmd, "export DISPLAY=%s;co_convert -f -d %s %s", display,
            "$pwrp_lis", tmpfile);
      else
        sprintf(cmd, "co_convert -f -d %s %s", "$pwrp_lis", tmpfile);
      system(cmd);
      strcpy(cnvfile, "$pwrp_lis/report.pdf");
      break;
    case pwr_eDocumentFormatEnum_Html:
      // Convert to pdf
      if (!streq(display, ""))
        sprintf(cmd, "export DISPLAY=%s;co_convert -s -d %s %s", display,
            "$pwrp_lis", tmpfile);
      else
        sprintf(cmd, "co_convert -s -d %s %s", "$pwrp_lis", tmpfile);
      system(cmd);
      strcpy(cnvfile, "$pwrp_lis/report_index.html");
      break;
    default:
      // Convert to text
      sprintf(cmd, "co_convert -j -d %s %s", "$pwrp_lis", tmpfile);
      system(cmd);
      strcpy(cnvfile, "$pwrp_lis/report.txt");
    }

    replace_symbol(str, o->Recipient);

    rcvnum = dcli_parse(str, ",", "", (char*)rcv_array,
        sizeof(rcv_array) / sizeof(rcv_array[0]), sizeof(rcv_array[0]), 0);

    for (int i = 0; i < rcvnum; i++) {
      str_trim(str, rcv_array[i]);

      s = strrchr(str, '.');
      if (s) {
        *s = 0;
        strncpy(group, systemgroup, sizeof(group));
        strncat(group, ".", sizeof(group) - strlen(group) - 1);
        strncat(group, str, sizeof(group) - strlen(group) - 1);
        strncpy(user, s + 1, sizeof(user));
      } else {
        strncpy(group, systemgroup, sizeof(group));
        strncpy(user, str, sizeof(user));
      }

      SystemName* sn = new SystemName(group);
      sts = sn->parse();
      if (EVEN(sts)) {
        delete sn;
        errh_Error("Report systemgroup parse error, %m", sts);
        continue;
      }

      SystemList* sl = udb->find_system(sn);
      delete sn;
      if (!sl) {
        errh_Error("No such system group, %s", group);
        continue;
      }

      UserList* ul = (UserList*)sl->find_user(user);
      if (!ul) {
        errh_Error("No such user, %s", user);
        continue;
      }

      ul->get_email(address, sizeof(address));

      snprintf(text, sizeof(text), "Proview report\n%s\n", o->Subject);
      strcpy(text, "Proview report");
      strncpy(subject, o->Subject, sizeof(subject));

      str_trim(conf_cmd, o->EmailCmd);
      if (streq(conf_cmd, ""))
        strncpy(conf_cmd, conf->EmailCmd, sizeof(conf_cmd));

      format_cmd(
          cmd, sizeof(cmd), conf_cmd, address, text, subject, cnvfile, 0);

      if (conf->Options & pwr_mPostOptionsMask_Log)
        errh_Info("Email: %s", cmd);

      system(cmd);
      conf->SentEmail++;

      sprintf(cmd, "rm %s", tmpfile);
      system(cmd);
    }
  }

  if (o->Media & pwr_mReportMediaMask_SMS) {
    // Send SMS
    char text[1000];
    char cmd[1000];

    // Convert to text
    sprintf(cmd, "co_convert -j -d %s %s", "$pwrp_lis", tmpfile);
    system(cmd);
    strcpy(cnvfile, "$pwrp_lis/report.txt");

    replace_symbol(str, o->Recipient);

    rcvnum = dcli_parse(str, ",", "", (char*)rcv_array,
        sizeof(rcv_array) / sizeof(rcv_array[0]), sizeof(rcv_array[0]), 0);

    for (int i = 0; i < rcvnum; i++) {
      str_trim(str, rcv_array[i]);

      s = strrchr(str, '.');
      if (s) {
        *s = 0;
        strncpy(group, systemgroup, sizeof(group));
        strncat(group, ".", sizeof(group) - strlen(group) - 1);
        strncat(group, str, sizeof(group) - strlen(group) - 1);
        strncpy(user, s + 1, sizeof(user));
      } else {
        strncpy(group, systemgroup, sizeof(group));
        strncpy(user, str, sizeof(user));
      }

      SystemName* sn = new SystemName(group);
      sts = sn->parse();
      if (EVEN(sts)) {
        delete sn;
        errh_Error("Report systemgroup parse error, %m", sts);
        continue;
      }

      SystemList* sl = udb->find_system(sn);
      delete sn;
      if (!sl) {
        errh_Error("No such system group, %s", group);
        continue;
      }

      UserList* ul = (UserList*)sl->find_user(user);
      if (!ul) {
        errh_Error("No such user, %s", user);
        continue;
      }

      ul->get_sms(address, sizeof(address));

      dcli_translate_filename(fname, cnvfile);

      std::ifstream ftext;
      ftext.open(fname);
      if (!ftext) {
        // o->Status = GLOW__FILEOPEN;
        return;
      }

      unsigned int j = 0;
      while (ftext.good() && j < sizeof(text) - 1) {
        text[j++] = ftext.get();
      }
      ftext.close();

      if (j == 0)
        return;
      text[j - 1] = 0;

      // snprintf( text, sizeof(text), "Proview report\n%s\n", o->Subject);
      // strcpy( text, "Proview report");
      strncpy(subject, o->Subject, sizeof(subject));

      str_trim(conf_cmd, o->SMS_Cmd);
      if (streq(conf_cmd, ""))
        strncpy(conf_cmd, conf->SMS_Cmd, sizeof(conf_cmd));

      format_cmd(
          cmd, sizeof(cmd), conf_cmd, address, subject, text, cnvfile, 0);

      if (conf->Options & pwr_mPostOptionsMask_Log)
        errh_Info("SMS: %s", cmd);

      if (conf->Options & pwr_mPostOptionsMask_SingleLineSMS) {
        for (char* s = cmd; *s; s++) {
          // Replace LF with space
          if (*s == 10)
            *s = ' ';
        }
      }

      system(cmd);
      conf->SentSMS++;

      sprintf(cmd, "rm %s", tmpfile);
      system(cmd);
    }
  }
  if (o->Media & pwr_mReportMediaMask_Printer) {
    // Convert to postscript
    char cmd[520];
    pwr_tFileName target_file;

    if (!streq(display, ""))
      sprintf(cmd, "export DISPLAY=%s;co_convert -n -d %s %s", display,
          "$pwrp_lis", tmpfile);
    else
      sprintf(cmd, "co_convert -n -d %s %s", "$pwrp_lis", tmpfile);
    system(cmd);

    strcpy(cnvfile, "$pwrp_lis/report.ps");

    if (!streq(o->TargetFile, "")) {
      strcpy(target_file, o->TargetFile);
      snprintf(cmd, sizeof(cmd), "mv %s %s", cnvfile, target_file);
      system(cmd);
    } else
      strcpy(target_file, cnvfile);

    str_trim(conf_cmd, o->PrintCmd);
    if (streq(conf_cmd, ""))
      strncpy(conf_cmd, conf->PrintCmd, sizeof(conf_cmd));

    format_cmd(cmd, sizeof(cmd), conf_cmd, 0, 0, 0, target_file, 0);

    if (conf->Options & pwr_mPostOptionsMask_Log)
      errh_Info("Print: %s", cmd);

    system(cmd);

    sprintf(cmd, "rm %s", tmpfile);
    system(cmd);
  }
  if (o->Media & pwr_mReportMediaMask_File) {
    // Print to file
    pwr_tCmd cmd;

    switch (o->DocumentFormat) {
    case pwr_eDocumentFormatEnum_PDF:
      // Convert to pdf
      if (!streq(display, ""))
        sprintf(cmd, "export DISPLAY=%s;co_convert -f -d %s %s", display,
            "$pwrp_lis", tmpfile);
      else
        sprintf(cmd, "co_convert -f -d %s %s", "$pwrp_lis", tmpfile);
      system(cmd);
      strcpy(cnvfile, "$pwrp_lis/report.pdf");
      break;
    case pwr_eDocumentFormatEnum_Html:
      // Convert to pdf
      if (!streq(display, ""))
        sprintf(cmd, "export DISPLAY=%s;co_convert -s -d %s %s", display,
            "$pwrp_lis", tmpfile);
      else
        sprintf(cmd, "co_convert -t -d %s %s", "$pwrp_lis", tmpfile);
      system(cmd);
      strcpy(cnvfile, "$pwrp_lis/report_index.html");
      break;
    case pwr_eDocumentFormatEnum_Postscript:
      // Convert to Postscript
      if (!streq(display, ""))
        sprintf(cmd, "export DISPLAY=%s;co_convert -n -d %s %s", display,
            "$pwrp_lis", tmpfile);
      else
        sprintf(cmd, "co_convert -n -d %s %s", "$pwrp_lis", tmpfile);
      system(cmd);
      strcpy(cnvfile, "$pwrp_lis/report.ps");
      break;
    default:
      // Convert to text
      sprintf(cmd, "co_convert -j -d %s %s", "$pwrp_lis", tmpfile);
      system(cmd);
      strcpy(cnvfile, "$pwrp_lis/report.txt");
    }

    // Rename file to target filename
    if (!streq(o->TargetFile, "")) {
      snprintf(cmd, sizeof(cmd), "mv %s %s", cnvfile, o->TargetFile);

      if (strstr(o->TargetFile, "$date") != 0) {
        char timstr[40];
        pwr_tCmd conf_cmd;

        sts = time_AtoAscii(
            0, time_eFormat_FileDateAndTime, timstr, sizeof(timstr));
        strcpy(conf_cmd, cmd);
        format_cmd(cmd, sizeof(cmd), conf_cmd, 0, 0, 0, 0, timstr);
      }

      system(cmd);
    }
    sprintf(cmd, "rm %s", tmpfile);

    if (conf->Options & pwr_mPostOptionsMask_Log)
      errh_Info("File: %s", cmd);

    system(cmd);
  }
}

int rt_report::replace_value(char* out, unsigned int size, char* in)
{
  char str[500] = "";
  char str2[500] = "";
  char valstr[500];
  char *s1, *s2, *t;
  unsigned long len;
  unsigned long slen = 0;
  char vvect[4][400];
  int nr;
  pwr_tStatus sts;
  char fstr[400];
  char format[40];
  char buf[400];
  pwr_tTypeId a_tid = 0;
  pwr_tUInt32 a_size;
  pwr_tUInt32 a_offs;
  pwr_tUInt32 a_elem;
  pwr_eType a_type;
  int flen;
  char timstr[40];

  s1 = in;
  while ((s2 = strstr(s1, "<value"))) {
    for (t = s2; *t != '>' && *t != 0; t++)
      ;
    if (*t != '>')
      return 0;

    len = s2 - s1;
    strncat(str, s1, len);
    slen += len;
    str[slen] = 0;

    len = t - (s2 + 7);
    strncpy(valstr, s2 + 7, len);
    valstr[len] = 0;

    // Parse value string
    nr = dcli_parse(valstr, " 	=", "", (char*)vvect,
        sizeof(vvect) / sizeof(vvect[0]), sizeof(vvect[0]), 0);
    int format_found = 0;
    int value_found = 0;
    for (int i = 0; i < nr; i++) {
      if (str_NoCaseStrcmp(vvect[i], "attr") == 0 && nr > i + 1) {
        sts = gdh_GetAttributeCharacteristics(
            vvect[i + 1], &a_tid, &a_size, &a_offs, &a_elem);

        sts = gdh_GetObjectInfo(vvect[i + 1], buf, sizeof(buf));
        if (EVEN(sts))
          return sts;

        i++;
        value_found = 1;
      }
      if (str_NoCaseStrcmp(vvect[i], "format") == 0 && nr > i + 1) {
        strncpy(format, vvect[i + 1], sizeof(format));

        i++;
        format_found = 1;
      }
    }

    if (!value_found || !format_found)
      return 0;

    a_type = (pwr_eType)pwr_TypeId(pwr_Tix(a_tid));
    sts = gdh_AttrValueToString(
        a_type, a_tid, buf, fstr, sizeof(fstr), &flen, format);
    if (EVEN(sts))
      return sts;

    strcat(str, fstr);
    slen += strlen(fstr);
    s1 = t + 1;
  }

  strcat(str, s1);

  s1 = str;
  slen = 0;
  if ((s2 = strstr(str, "<date"))) {
    for (t = s2; *t != '>' && *t != 0; t++)
      ;
    if (*t != '>')
      return 0;

    len = s2 - s1;
    strncat(str2, s1, len);
    slen += len;
    str2[slen] = 0;

    len = t - (s2 + 5);
    strncpy(valstr, s2 + 5, len);
    valstr[len] = 0;

    // Parse value string
    nr = dcli_parse(valstr, " 	=", "", (char*)vvect,
        sizeof(vvect) / sizeof(vvect[0]), sizeof(vvect[0]), 0);
    int format_found = 0;
    for (int i = 0; i < nr; i++) {
      if (str_NoCaseStrcmp(vvect[i], "format") == 0 && nr > i + 1) {
        strncpy(format, vvect[i + 1], sizeof(format));

        i++;
        format_found = 1;
      }
    }

    if (format_found) {
      switch (format[1]) {
      case '1':
        // Format %1t, only time, no hundredth
        sts = time_AtoAscii(0, time_eFormat_Time, timstr, sizeof(timstr));
        timstr[8] = 0;
        break;
      case '2':
        // Format %2t, only time, with hundredth
        sts = time_AtoAscii(0, time_eFormat_Time, timstr, sizeof(timstr));
        break;
      case '3':
        // Format %3t, compressed date and time, no hundredth
        sts = time_AtoAscii(
            0, time_eFormat_ComprDateAndTime, timstr, sizeof(timstr));
        timstr[17] = 0;
        break;
      case '4':
        // Format %4t, date only
        sts = time_AtoAscii(
            0, time_eFormat_DateAndTime, timstr, sizeof(timstr));
        timstr[11] = 0;
        break;
      case '5':
        // Format %5t, compressed date only
        sts = time_AtoAscii(
            0, time_eFormat_ComprDateAndTime, timstr, sizeof(timstr));
        timstr[8] = 0;
        break;
      default:
        sts = time_AtoAscii(
            0, time_eFormat_DateAndTime, timstr, sizeof(timstr));
      }
    } else {
      sts = time_AtoAscii(0, time_eFormat_DateAndTime, timstr, sizeof(timstr));
    }
    strcat(str2, timstr);
    slen += strlen(timstr);

    strcat(str2, t + 1);
    strcpy(str, str2);
  }

  strncpy(out, str, size);
  return 1;
}

void rt_report::init(qcom_sQid* qid)
{
  qcom_sQid qini;
  qcom_sQattr qAttr;
  pwr_tStatus sts;

  sts = gdh_Init("rt_report");
  if (EVEN(sts)) {
    errh_Fatal("gdh_Init, %m", sts);
    exit(sts);
  }

  errh_Init("pwr_report", errh_eAnix_report);
  errh_SetStatus(PWR__SRVSTARTUP);

  if (!qcom_Init(&sts, 0, "pwr_report")) {
    errh_Fatal("qcom_Init, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  qAttr.type = qcom_eQtype_private;
  qAttr.quota = 100;
  if (!qcom_CreateQ(&sts, qid, &qAttr, "events")) {
    errh_Fatal("qcom_CreateQ, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  qini = qcom_cQini;
  if (!qcom_Bind(&sts, qid, &qini)) {
    errh_Fatal("qcom_Bind(Qini), %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(-1);
  }
}

void rt_report::replace_symbol(char* outstr, char* instr)
{
  char *s, *t, *u = NULL;
  int symbolmode = 0;
  char symbol[80];
  char csymbol[80];
  int size;
  int found;

  s = instr;
  t = outstr;

  while (1) {
    if (symbolmode) {
      if (*s == ',' || *s == ' ' || *s == '	' || *s == 0) {
        // End of symbol
        size = (long int)s - (long int)(u + 1);
        strncpy(symbol, u + 1, size);
        symbol[size] = 0;

        // Find the symbol
        found = 0;
        for (unsigned int j = 0;
             j < sizeof(conf->Symbols) / sizeof(conf->Symbols[0]); j++) {
          str_trim(csymbol, conf->Symbols[j].Name);
          if (streq(symbol, csymbol)) {
            // Found, insert the value
            strcpy(t, conf->Symbols[j].Value);
            t += strlen(conf->Symbols[j].Value);
            found = 1;
            break;
          }
        }
        if (!found) {
          // Not found
          strcpy(t, "$");
          t++;
          strcat(t, symbol);
          t += strlen(symbol);
        }
        symbolmode = 0;
        *t = *s;
        t++;
      }
    } else {
      if (*s == '$') {
        symbolmode = 1;
        u = s;
      } else {
        *t = *s;
        t++;
      }
    }
    if (*s == 0)
      break;
    s++;
  }
}

void rt_report::format_cmd(char* cmd, int cmd_size, const char* format,
    const char* address, const char* subject, const char* text,
    const char* reportfile, const char* date)
{
  char* s1;
  pwr_tCmd str;

  strncpy(cmd, format, cmd_size);

  // Replace $address with address
  if (address) {
    s1 = strstr(cmd, "$address");
    if (s1) {
      strncpy(str, s1 + strlen("$address"), sizeof(str));
      *s1 = 0;
      strncat(cmd, address, cmd_size);
      strncat(cmd, str, cmd_size);
    }
  }

  // Replace $text with text
  if (text) {
    s1 = strstr(cmd, "$text");
    if (s1) {
      strncpy(str, s1 + strlen("$text"), sizeof(str));
      *s1 = 0;
      strncat(cmd, text, cmd_size);
      strncat(cmd, str, cmd_size);
    }
  }

  // Replace $subject with subject
  if (subject) {
    s1 = strstr(cmd, "$subject");
    if (s1) {
      strncpy(str, s1 + strlen("$subject"), sizeof(str));
      *s1 = 0;
      strncat(cmd, subject, cmd_size);
      strncat(cmd, str, cmd_size);
    }
  }

  // Replace $reportfile with reportfile
  if (reportfile) {
    s1 = strstr(cmd, "$reportfile");
    if (s1) {
      strncpy(str, s1 + strlen("$reportfile"), sizeof(str));
      *s1 = 0;
      strncat(cmd, reportfile, cmd_size);
      strncat(cmd, str, cmd_size);
    }
  }

  // Replace $date with date
  if (date) {
    s1 = strstr(cmd, "$date");
    if (s1) {
      strncpy(str, s1 + strlen("$date"), sizeof(str));
      *s1 = 0;
      strncat(cmd, date, cmd_size);
      strncat(cmd, str, cmd_size);
    }
  }
}

int rt_report::parse(char* line)
{
  char line_array[7][80];
  int num;
  char aline[200];
  char rline[200];

  replace_value(rline, sizeof(rline), line);
  str_trim(aline, rline);

  num = dcli_parse(line, " 	", "", (char*)line_array,
      sizeof(line_array) / sizeof(line_array[0]), sizeof(line_array[0]), 0);

  if (num > 0 && str_NoCaseStrcmp(line_array[0], "print") == 0) {
    if (num > 1 && str_NoCaseStrcmp(line_array[1], "graph") == 0) {
      std::ofstream fout;
      pwr_tFileName fname;
      pwr_tFileName tmpfile = "$pwrp_lis/report_print.rtt_com";
      pwr_tCmd cmd;
      int sts;
      float btime = 2;
      float atime = 0;
      pwr_tAName object_str = "";
      char graph_str[80] = "";
      pwr_tFileName image_str = "";
      int argcnt;

      if (num < 4)
        return 0;

      argcnt = 0;
      for (int i = 2; i < num; i++) {
        if (str_NoCaseStrncmp(line_array[i], "btime=", 6) == 0) {
          sts = sscanf(&line_array[i][6], "%f", &btime);
          if (sts != 1)
            btime = 2;
        } else if (str_NoCaseStrncmp(line_array[i], "atime=", 6) == 0) {
          sts = sscanf(&line_array[i][6], "%f", &atime);
          if (sts != 1)
            atime = 2;
        } else if (str_NoCaseStrncmp(line_array[i], "object=", 6) == 0) {
          strncpy(object_str, line_array[i], sizeof(object_str));
          argcnt++; // Replaces graph
        } else {
          if (argcnt == 0)
            strncpy(graph_str, line_array[i], sizeof(graph_str));
          else if (argcnt == 1)
            strncpy(image_str, line_array[i], sizeof(image_str));
          argcnt++;
        }
      }

      dcli_translate_filename(fname, tmpfile);
      fout.open(fname);
      if (!fout)
        return 0;

      fout << "main()\n";
      if (streq(graph_str, ""))
        fout << "  open graph /" << object_str
             << '\n'; // Should be with /hide but it sometimes doesn't work...
      else
        fout << "  open graph " << graph_str << '\n';
      if (!feqf(btime, 0.0f))
        fout << "  wait " << btime << '\n';
      if (streq(graph_str, ""))
        fout << "  export graph /" << object_str << " /file=\"" << line_array[3]
             << "\"\n";
      else
        fout << "  export graph /graph=" << graph_str << " /file=\""
             << image_str << "\"\n";
      if (!feqf(atime, 0.0f))
        fout << "  wait " << atime << '\n';
      fout << "endmain\n";
      fout.close();

      strcpy(cmd, "rt_xtt_cmd ");
      if (!streq(display, "")) {
        strcpy(cmd, "export DISPLAY=");
        strcat(cmd, display);
        strcat(cmd, ";");
      } else
        strcpy(cmd, "");
      strcat(cmd, "rt_xtt_cmd ");
      strcat(cmd, " -i -q  @");
      strcat(cmd, fname);

      system(cmd);
      sprintf(cmd, "rm %s", fname);
      system(cmd);
    } else
      return 0;
  } else if (str_StartsWith(aline, "system(")
      && aline[strlen(aline) - 1] == ')') {
    aline[strlen(aline) - 1] = 0;
    system(&aline[7]);
  } else
    return 0;

  return 1;
}

int main(int argc, char* argv[])
{
  pwr_tStatus sts;
  int tmo = 0;
  char mp[2000];
  qcom_sQid qid = qcom_cNQid;
  qcom_sGet get;
  int swap = 0;
  bool first_scan = true;

  report = new rt_report();
  report->init(&qid);

  if (argc > 1) {
    if (streq(argv[1], "-d") && argc > 2)
      strcpy(report->display, argv[2]);
  }

  try {
    report->open();
  } catch (co_error& e) {
    errh_Error((char*)e.what().c_str());
    errh_Fatal("rt_report aborting");
    errh_SetStatus(PWR__SRVTERM);
    exit(0);
  }

  aproc_TimeStamp(report->scantime(), 10);
  errh_SetStatus(PWR__SRUN);

  first_scan = true;
  for (;;) {
    if (first_scan) {
      tmo = (int)(report->scantime() * 1000 - 1);
    }

    get.maxSize = sizeof(mp);
    get.data = mp;
    qcom_Get(&sts, &qid, &get, tmo);
    if (sts == QCOM__TMO || sts == QCOM__QEMPTY) {
      if (!swap)
        report->scan();
    } else {
      ini_mEvent new_event;
      qcom_sEvent* ep = (qcom_sEvent*)get.data;

      new_event.m = ep->mask;
      if (new_event.b.oldPlcStop && !swap) {
        errh_SetStatus(PWR__SRVRESTART);
        report->conf->Status = PWR__SRVRESTART;
        swap = 1;
        report->close();
      } else if (new_event.b.swapDone && swap) {
        swap = 0;
        report->open();
        errh_SetStatus(PWR__SRUN);
        report->conf->Status = PWR__SRUN;
      } else if (new_event.b.terminate) {
        exit(0);
      }
    }
    first_scan = false;
  }
}
