/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2014 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

#include <iostream>
#include <fstream>
#include <math.h>
#include <float.h>
#include <stdlib.h>

#include "rt_report.h"
#include "co_error.h"
#include "rt_gdh.h"
#include "co_cdh.h"
#include "co_time.h"
#include "co_dcli.h"
#include "co_syi.h"
#include "rt_errh.h"
#include "rt_qcom.h"
#include "rt_ini_event.h"
#include "rt_aproc.h"
#include "rt_pwr_msg.h"
#include "rt_qcom_msg.h"

static rt_report *report = 0;

rt_report::rt_report() : scan_time(1), conf(0), first_scan(1),
			 old_sec(0), old_min(0), old_hour(0), old_mday(0), 
			 old_wday(0), old_yday(0), 
			 now_sec(0), now_min(0), now_hour(0), now_mday(0), 
			 now_wday(0), now_yday(0)
{ 
  strcpy( display, "");
}

void rt_report::open()
{
  pwr_tStatus sts;
  pwr_tObjid oid;
  pwr_tFileName filename;

  // Open server configuration object ReportConfig
  sts = gdh_GetClassList( pwr_cClass_ReportConfig, &oid);
  if ( ODD(sts)) {
    sts = gdh_ObjidToPointer( oid, (void **)&conf);
    if ( EVEN(sts)) throw co_error( sts);

    aproc_RegisterObject( oid);
  }
  else {
    errh_Info( "No Report configuration");
    errh_SetStatus( 0);
    exit(0);
  }

  for ( sts = gdh_GetClassList( pwr_cClass_Report, &oid);
	ODD(sts);
	sts = gdh_GetNextObject( oid, &oid)) {
    report_sObject o;
    pwr_tAttrRef aref;

    aref = cdh_ObjidToAref( oid);

    sts = gdh_DLRefObjectInfoAttrref( &aref, (void **)&o.p, &o.dlid);
    repv.push_back( o);
  }

  sts = gdh_GetObjectInfo( "pwrNode-System.SystemGroup", &systemgroup, 
			   sizeof(systemgroup));
  if ( EVEN(sts)) {
    errh_Error( "Report terminated: %m", sts);
    conf->Status = sts;
    exit(0);
  }

  udb = new GeUser();
  sts = dcli_get_defaultfilename( user_cFilename, filename, "");
  udb->load( filename);

  conf->Status = PWR__SRUN;

}

void rt_report::close()
{
  repv.clear();
}

void rt_report::scan()
{
  periodic_scan();

  for ( unsigned int i = 0; i < repv.size(); i++) {
    if ( repv[i].p->Trigger || periodic_check( repv[i].p)) {
      repv[i].p->Trigger = 0;

      create_report( repv[i].p);
    }
  }

  aproc_TimeStamp( scantime(), 5);
}

int rt_report::periodic_check( pwr_sClass_Report *o)
{
  int offset = (int) time_DToFloat( 0, &o->TimeOffset);

  switch ( o->Periodicity) {
  case pwr_ePeriodicEnum_No:
    return 0;
#if 0
    if ( now_sec < old_sec)
      o->Sent = 0;
    if ( !o->Sent) {	
      if ( now_sec >= offset) {
	o->Sent = 1;
	if ( now_sec < offset + 10)
	  return 1;
      }
    }
    break;
#endif
  case pwr_ePeriodicEnum_Hourly:
    if ( now_min < old_min)
      o->Sent = 0;
    if ( !o->Sent) {	
      if ( now_min >= offset) {
	o->Sent = 1;
	if ( now_min < offset + 60)
	  return 1;
      }
    }
    break;
  case pwr_ePeriodicEnum_Daily:
    if ( now_hour < old_hour)
      o->Sent = 0;
    if ( !o->Sent) {	
      if ( now_hour >= offset) {
	o->Sent = 1;
	if ( now_hour < offset + 60)
	  return 1;
      }
    }
    break;
  case pwr_ePeriodicEnum_Weekly:
    if ( now_wday < old_wday)
      o->Sent = 0;
    if ( !o->Sent) {	
      if ( now_wday >= offset) {
	o->Sent = 1;
	if ( now_wday < offset + 600)
	  return 1;
      }
    }
    break;
  case pwr_ePeriodicEnum_Monthly:
    if ( now_mday < old_mday)
      o->Sent = 0;
    if ( !o->Sent) {	
      if ( now_mday >= offset) {
	o->Sent = 1;
	if ( now_mday < offset + 3600)
	  return 1;
      }
    }
    break;
  case pwr_ePeriodicEnum_Yearly:
    if ( now_yday < old_yday)
      o->Sent = 0;
    if ( !o->Sent) {	
      if ( now_yday >= offset) {
	o->Sent = 1;
	if ( now_yday < offset + 3600)
	  return 1;
      }
    }
    break;
  }
  return 0;
}

void rt_report::periodic_scan()
{
  struct tm tm;
  struct timespec t;
  
  old_sec = now_sec;
  old_min = now_min;
  old_hour = now_hour;
  old_mday = now_mday;
  old_wday = now_wday;
  old_yday = now_yday;

  clock_gettime( CLOCK_REALTIME, &t);
  localtime_r( &t.tv_sec, &tm);

  now_sec = tm.tm_sec;
  now_min = tm.tm_min * 60 + now_sec;
  now_hour = tm.tm_hour * 3600 + now_min;
  now_mday = tm.tm_mday * 24 * 3600 + now_hour;
  now_wday = tm.tm_wday * 24 * 3600 + now_hour;
  now_yday = tm.tm_yday * 24 * 3600 + now_hour;
}


void rt_report::create_report( pwr_sClass_Report *o)
{
  ifstream fin;
  ofstream fout;
  char line[500];
  char newline[500];
  pwr_tFileName fname;
  char str[256];
  char user[80];
  char group[80];
  char *s;
  char rcv_array[10][80];
  char subject[80];
  int rcvnum;
  pwr_tStatus sts;
  char address[40];
  pwr_tFileName cnvfile;
  pwr_tFileName tmpfile = "$pwrp_lis/report.tmp";
  pwr_tString256 conf_cmd;
  int first = 1;

  dcli_translate_filename( fname, o->TemplateFile);
  fin.open( fname);
  if ( !fin) {
    // o->Status = GLOW__FILEOPEN;
    return;
  }

  dcli_translate_filename( fname, tmpfile);
  fout.open( fname);
  if ( !fout) {
    // o->Status = GLOW__FILEOPEN;
    return;
  }

  fout << "<topic> index <style> report" << endl;

  while ( fin.getline( line, sizeof(line))) {
    dcli_trim( newline, line);
    if ( first && strcmp( newline, "") == 0)
      continue;

    if ( cdh_NoCaseStrncmp( newline, "<execute>", 9) == 0) {
      parse( &line[9]);
    }
    else {
      first = 0;

      replace_value( newline, sizeof(newline), line);

      fout << newline << endl;
    }
  }  

  fout << "</topic>" << endl;

  fin.close();
  fout.close();    

  if ( o->Media & pwr_mReportMediaMask_Email) {
    // Send email
    char text[400];
    pwr_tCmd cmd;

    switch ( o->DocumentFormat) {
    case pwr_eDocumentFormatEnum_PDF:
      // Convert to pdf
      if ( strcmp( display, "") != 0)
	sprintf( cmd, "export DISPLAY=%s;co_convert -f -d %s %s", 
		 display, "$pwrp_lis", tmpfile);
      else
	sprintf( cmd, "co_convert -f -d %s %s", 
	       "$pwrp_lis", tmpfile);
      system( cmd);
      strcpy( cnvfile, "$pwrp_lis/report.pdf");
      break;
    case pwr_eDocumentFormatEnum_Html:
      // Convert to pdf
      if ( strcmp( display, "") != 0)
	sprintf( cmd, "export DISPLAY=%s;co_convert -s -d %s %s", 
		 display, "$pwrp_lis", tmpfile);
      else
	sprintf( cmd, "co_convert -s -d %s %s", 
		 "$pwrp_lis", tmpfile);
      system( cmd);
      strcpy( cnvfile, "$pwrp_lis/report_index.html");
      break;
    default:
      // Convert to text
      sprintf( cmd, "co_convert -j -d %s %s", 
	       "$pwrp_lis", tmpfile);
      system( cmd);
      strcpy( cnvfile, "$pwrp_lis/report.txt");
    }
    

    replace_symbol( str, o->Recipient);

    rcvnum = dcli_parse( str, ",", "",
			 (char *) rcv_array, sizeof( rcv_array)/sizeof( rcv_array[0]),
			 sizeof( rcv_array[0]), 0);
  
    for ( int i = 0; i < rcvnum; i++) {

      dcli_trim( str, rcv_array[i]);
      
      s = strrchr( str, '.');
      if ( s) {
	*s = 0;
	strncpy( group, systemgroup, sizeof(group));
	strncat( group, ".", sizeof(group));
	strncat( group, str, sizeof(group));
	strncpy( user, s+1, sizeof(user));
      }
      else {
	strncpy( group, systemgroup, sizeof(group));
	strncpy( user, str, sizeof(user));
      }
  
      SystemName *sn = new SystemName( group);
      sts = sn->parse();
      if ( EVEN(sts)) {
	delete sn;
	errh_Error( "Report systemgroup parse error, %m", sts);
	continue;
      }

      SystemList *sl = udb->find_system( sn);
      delete sn;
      if ( !sl) {
	errh_Error( "No such system group, %s", group);
	continue;
      }

      UserList *ul = (UserList *) sl->find_user( user);
      if ( !ul) {
	errh_Error( "No such user, %s", user);
	continue;
      }

      ul->get_email( address, sizeof(address));


      snprintf( text, sizeof(text), "Proview report\n%s\n", o->Subject);
      strcpy( text, "Proview report");
      strncpy( subject, o->Subject, sizeof(subject));

      dcli_trim( conf_cmd, o->EmailCmd);
      if ( strcmp( conf_cmd, "") == 0)
	strncpy( conf_cmd, conf->EmailCmd, sizeof(conf_cmd));

      format_cmd( cmd, sizeof(cmd), conf_cmd, address, text, subject, 
		  cnvfile, 0);

      if (conf->Options & pwr_mPostOptionsMask_Log)
	errh_Info( "Email: %s", cmd);

      system( cmd);
      conf->SentEmail++;

      sprintf( cmd, "rm %s", tmpfile);
      system( cmd);
    }
  }

  if ( o->Media & pwr_mReportMediaMask_SMS) {
    // Send SMS
    char text[1000];
    char cmd[1000];

    // Convert to text
    sprintf( cmd, "co_convert -j -d %s %s", 
	     "$pwrp_lis", tmpfile);
    system( cmd);
    strcpy( cnvfile, "$pwrp_lis/report.txt");


    replace_symbol( str, o->Recipient);

    rcvnum = dcli_parse( str, ",", "",
			 (char *) rcv_array, sizeof( rcv_array)/sizeof( rcv_array[0]),
			 sizeof( rcv_array[0]), 0);
  
    for ( int i = 0; i < rcvnum; i++) {

      dcli_trim( str, rcv_array[i]);
      
      s = strrchr( str, '.');
      if ( s) {
	*s = 0;
	strncpy( group, systemgroup, sizeof(group));
	strncat( group, ".", sizeof(group));
	strncat( group, str, sizeof(group));
	strncpy( user, s+1, sizeof(user));
      }
      else {
	strncpy( group, systemgroup, sizeof(group));
	strncpy( user, str, sizeof(user));
      }
  
      SystemName *sn = new SystemName( group);
      sts = sn->parse();
      if ( EVEN(sts)) {
	delete sn;
	errh_Error( "Report systemgroup parse error, %m", sts);
	continue;
      }

      SystemList *sl = udb->find_system( sn);
      delete sn;
      if ( !sl) {
	errh_Error( "No such system group, %s", group);
	continue;
      }

      UserList *ul = (UserList *) sl->find_user( user);
      if ( !ul) {
	errh_Error( "No such user, %s", user);
	continue;
      }

      ul->get_sms( address, sizeof(address));


      dcli_translate_filename( fname, cnvfile);

      ifstream ftext;
      ftext.open( fname);
      if ( !ftext) {
	// o->Status = GLOW__FILEOPEN;
	return;
      }

      unsigned int j = 0;
      while( ftext.good() && j < sizeof(text) - 1) {
	text[j++] = ftext.get();
      }
      ftext.close();

      if ( j == 0)
	return;
      text[j-1] = 0;
      
      // snprintf( text, sizeof(text), "Proview report\n%s\n", o->Subject);
      // strcpy( text, "Proview report");
      strncpy( subject, o->Subject, sizeof(subject));

      dcli_trim( conf_cmd, o->SMS_Cmd);
      if ( strcmp( conf_cmd, "") == 0)
	strncpy( conf_cmd, conf->SMS_Cmd, sizeof(conf_cmd));

      format_cmd( cmd, sizeof(cmd), conf_cmd, address, subject, text, 
		  cnvfile, 0);

      if (conf->Options & pwr_mPostOptionsMask_Log)
	errh_Info( "SMS: %s", cmd);

      if ( conf->Options & pwr_mPostOptionsMask_SingleLineSMS) {
	for ( char *s = cmd; *s; s++) {
	  // Replace LF with space
	  if ( *s == 10)
	    *s = ' ';
	}
      }

      system( cmd);
      conf->SentSMS++;

      sprintf( cmd, "rm %s", tmpfile);
      system( cmd);
    }
  }
  if ( o->Media & pwr_mReportMediaMask_Printer) {
    // Convert to postscript
    pwr_tCmd cmd;
    pwr_tFileName target_file;

    if ( strcmp( display, "") != 0)
      sprintf( cmd, "export DISPLAY=%s;co_convert -n -d %s %s", 
	       display, "$pwrp_lis", tmpfile);
    else
      sprintf( cmd, "co_convert -n -d %s %s", 
	       "$pwrp_lis", tmpfile);
    system( cmd);

    strcpy( cnvfile, "$pwrp_lis/report.ps");

    if ( strcmp( o->TargetFile, "") != 0) {
      strcpy( target_file, o->TargetFile);
      snprintf( cmd, sizeof(cmd), "mv %s %s", cnvfile, target_file);
      system( cmd);
    }
    else
      strcpy( target_file, cnvfile);

    dcli_trim( conf_cmd, o->PrintCmd);
    if ( strcmp( conf_cmd, "") == 0)
      strncpy( conf_cmd, conf->PrintCmd, sizeof(conf_cmd));

    format_cmd( cmd, sizeof(cmd), conf_cmd, 0, 0, 0, 
		target_file, 0);

    if (conf->Options & pwr_mPostOptionsMask_Log)
      errh_Info( "Print: %s", cmd);

    system( cmd);
 
    sprintf( cmd, "rm %s", tmpfile);
    system( cmd);
  }
  if ( o->Media & pwr_mReportMediaMask_File) {
    // Print to file
    pwr_tCmd cmd;

    switch ( o->DocumentFormat) {
    case pwr_eDocumentFormatEnum_PDF:
      // Convert to pdf
      if ( strcmp( display, "") != 0)
	sprintf( cmd, "export DISPLAY=%s;co_convert -f -d %s %s", 
		 display, "$pwrp_lis", tmpfile);
      else
	sprintf( cmd, "co_convert -f -d %s %s", 
		 "$pwrp_lis", tmpfile);
      system( cmd);
      strcpy( cnvfile, "$pwrp_lis/report.pdf");
      break;
    case pwr_eDocumentFormatEnum_Html:
      // Convert to pdf
      if ( strcmp( display, "") != 0)
	sprintf( cmd, "export DISPLAY=%s;co_convert -s -d %s %s", 
		 display, "$pwrp_lis", tmpfile);
      else
	sprintf( cmd, "co_convert -t -d %s %s", 
		 "$pwrp_lis", tmpfile);
      system( cmd);
      strcpy( cnvfile, "$pwrp_lis/report_index.html");
      break;
    case pwr_eDocumentFormatEnum_Postscript:
      // Convert to Postscript
      if ( strcmp( display, "") != 0)
	sprintf( cmd, "export DISPLAY=%s;co_convert -n -d %s %s", 
		 display, "$pwrp_lis", tmpfile);
      else
	sprintf( cmd, "co_convert -n -d %s %s", 
		 "$pwrp_lis", tmpfile);
      system( cmd);
      strcpy( cnvfile, "$pwrp_lis/report.ps");
      break;
    default:
      // Convert to text
      sprintf( cmd, "co_convert -j -d %s %s", 
	       "$pwrp_lis", tmpfile);
      system( cmd);
      strcpy( cnvfile, "$pwrp_lis/report.txt");
    }
    
    // Rename file to target filename
    if ( strcmp( o->TargetFile, "") != 0) {
      snprintf( cmd, sizeof(cmd), "mv %s %s", cnvfile, o->TargetFile);

      if ( strstr( o->TargetFile, "$date") != 0) {
	char timstr[40];
	pwr_tCmd conf_cmd;

	sts = time_AtoAscii( 0, time_eFormat_FileDateAndTime,
			     timstr, sizeof(timstr));
	strcpy( conf_cmd, cmd);
	format_cmd( cmd, sizeof(cmd), conf_cmd, 0, 0, 0, 0, timstr);
      }

      system( cmd);
    }
    sprintf( cmd, "rm %s", tmpfile);

    if (conf->Options & pwr_mPostOptionsMask_Log)
      errh_Info( "File: %s", cmd);

    system( cmd);
  }
}

int rt_report::replace_value( char *out, unsigned int size, 
			       char *in)
{
  char str[500] = "";
  char str2[500] = "";
  char valstr[500];
  char *s1, *s2, *t;
  unsigned long len;
  unsigned long slen = 0;
  char vvect[4][400];
  int nr;
  pwr_tStatus sts;
  char fstr[400];
  char format[40];
  char buf[400];
  pwr_tTypeId a_tid;
  pwr_tUInt32 a_size;
  pwr_tUInt32 a_offs;
  pwr_tUInt32 a_elem;
  pwr_eType a_type;
  int flen;
  char timstr[40];

  s1 = in;
  while ( (s2 = strstr( s1, "<value"))) {

    for ( t = s2; *t != '>' && *t != 0; t++) ;
    if ( *t != '>') 
      return 0;

    len = s2 - s1;
    strncat( str, s1, len);
    slen += len;
    str[slen] = 0;

    len = t - (s2 + 7);
    strncpy( valstr, s2+7, len);
    valstr[len] = 0;

    // Parse value string
    nr = dcli_parse( valstr, " 	=", "", (char *)vvect, 
		     sizeof( vvect) / sizeof( vvect[0]), sizeof( vvect[0]), 0);
    int format_found = 0;
    int value_found = 0;
    for ( int i = 0; i < nr; i++) {
      if ( cdh_NoCaseStrcmp( vvect[i], "attr") == 0 && nr > i + 1) {
	sts = gdh_GetAttributeCharacteristics( vvect[i+1], &a_tid,
					       &a_size, &a_offs, &a_elem);

	sts = gdh_GetObjectInfo( vvect[i+1], buf, sizeof(buf));
	if ( EVEN(sts)) return sts;

	i++;
	value_found = 1;
      }
      if ( cdh_NoCaseStrcmp( vvect[i], "format") == 0 && nr > i + 1) {
	strncpy( format, vvect[i+1], sizeof(format));

	i++;
	format_found = 1;
      }
    }

    if ( !value_found || !format_found)
      return 0;

    a_type = (pwr_eType)pwr_TypeId( pwr_Tix(a_tid));
    sts = gdh_AttrValueToString( a_type, a_tid, buf, fstr, 
				 sizeof(fstr), &flen, format);
    if ( EVEN(sts)) return sts;

    strcat( str, fstr);
    slen += strlen(fstr);
    s1 = t + 1;
  }

  strcat( str, s1);

  s1 = str;
  slen = 0;
  if ( (s2 = strstr( str, "<date"))) {

    for ( t = s2; *t != '>' && *t != 0; t++) ;
    if ( *t != '>') 
      return 0;

    len = s2 - s1;
    strncat( str2, s1, len);
    slen += len;
    str2[slen] = 0;

    len = t - (s2 + 5);
    strncpy( valstr, s2+5, len);
    valstr[len] = 0;

    // Parse value string
    nr = dcli_parse( valstr, " 	=", "", (char *)vvect, 
		     sizeof( vvect) / sizeof( vvect[0]), sizeof( vvect[0]), 0);
    int format_found = 0;
    for ( int i = 0; i < nr; i++) {
      if ( cdh_NoCaseStrcmp( vvect[i], "format") == 0 && nr > i + 1) {
	strncpy( format, vvect[i+1], sizeof(format));

	i++;
	format_found = 1;
      }
    }

    if ( format_found) {
      switch ( format[1]) {
      case '1': 
	// Format %1t, only time, no hundredth
	sts = time_AtoAscii( 0, time_eFormat_Time, 
			     timstr, sizeof(timstr));
	timstr[8] = 0;
	break;
      case '2': 
	// Format %2t, only time, with hundredth
	sts = time_AtoAscii( 0, time_eFormat_Time,
			     timstr, sizeof(timstr));
	break;
      case '3': 
	// Format %3t, compressed date and time, no hundredth
	sts = time_AtoAscii( 0, time_eFormat_ComprDateAndTime,
			     timstr, sizeof(timstr));
	timstr[17] = 0;
	break;
      case '4':
	// Format %4t, date only
	sts = time_AtoAscii( 0, time_eFormat_DateAndTime, 
			     timstr, sizeof(timstr));
	timstr[11] = 0;
	break;
      case '5':
	// Format %5t, compressed date only
	sts = time_AtoAscii( 0, time_eFormat_ComprDateAndTime, 
			     timstr, sizeof(timstr));
	timstr[8] = 0;
	break;
      default:
	sts = time_AtoAscii( 0, time_eFormat_DateAndTime, 
			     timstr, sizeof(timstr));
      }
    }
    else {
      sts = time_AtoAscii( 0, time_eFormat_DateAndTime, 
			   timstr, sizeof(timstr));
    }
    strcat( str2, timstr);
    slen += strlen(timstr);

    strcat( str2, t+1);
    strcpy( str, str2);
  }

  strncpy( out, str, size);
  return 1;
}

void rt_report::init( qcom_sQid *qid)
{
  qcom_sQid qini;
  qcom_sQattr qAttr;
  pwr_tStatus sts;

  sts = gdh_Init("rt_report");
  if ( EVEN(sts)) {
    errh_Fatal( "gdh_Init, %m", sts);
    exit(sts);
  }

  errh_Init("pwr_report", errh_eAnix_report);
  errh_SetStatus( PWR__SRVSTARTUP);

  if (!qcom_Init(&sts, 0, "pwr_report")) {
    errh_Fatal("qcom_Init, %m", sts); 
    errh_SetStatus( PWR__SRVTERM);
   exit(sts);
  } 

  qAttr.type = qcom_eQtype_private;
  qAttr.quota = 100;
  if (!qcom_CreateQ(&sts, qid, &qAttr, "events")) {
    errh_Fatal("qcom_CreateQ, %m", sts);
    errh_SetStatus( PWR__SRVTERM);
    exit(sts);
  } 

  qini = qcom_cQini;
  if (!qcom_Bind(&sts, qid, &qini)) {
    errh_Fatal("qcom_Bind(Qini), %m", sts);
    errh_SetStatus( PWR__SRVTERM);
    exit(-1);
  }
}

void rt_report::replace_symbol( char *outstr, char *instr)
{
  char *s, *t, *u;
  int symbolmode = 0;
  char symbol[80];
  char csymbol[80];
  int size;
  int found;

  s = instr;
  t = outstr;

  while ( 1) {
    if ( symbolmode) {
      if ( *s == ',' || *s == ' ' || *s == '	' || *s == 0) {
	// End of symbol
	size = (long int) s - (long int)(u+1);
	strncpy( symbol, u + 1, size);
	symbol[size] = 0;

	// Find the symbol
	found = 0;
	for ( unsigned int j = 0; j < sizeof(conf->Symbols)/sizeof(conf->Symbols[0]); j++) {
	  dcli_trim( csymbol, conf->Symbols[j].Name);
	  if ( strcmp( symbol, csymbol) == 0) {
	    // Found, insert the value
	    strcpy( t, conf->Symbols[j].Value);
	    t += strlen( conf->Symbols[j].Value);
	    found = 1;
	    break;
	  }
	}	
	if ( !found) {
	  // Not found
	  strcpy( t, "$");
	  t++;
	  strcat( t, symbol);
	  t += strlen(symbol);
	}
	symbolmode = 0;
	*t = *s;
	t++;
      }
    }
    else {
      if ( *s == '$') {
	symbolmode = 1;
	u = s;
      }
      else {
	*t = *s;
	t++;
      }	
    }
    if ( *s == 0)
      break;
    s++;
  }
}

void rt_report::format_cmd( char *cmd, int cmd_size,
			    const char *format, const char *address, 
			    const char *subject, const char *text, 
			    const char *reportfile, const char *date)
{
  char *s1;
  pwr_tCmd str;

  strncpy( cmd, format, cmd_size);

  // Replace $address with address
  if ( address) {
    s1 = strstr( cmd, "$address");
    if ( s1) {
      strncpy( str, s1 + strlen("$address"), sizeof(str));
      *s1 = 0;
      strncat( cmd, address, cmd_size);
      strncat( cmd, str, cmd_size);
    }
  }

  // Replace $text with text
  if ( text) {
    s1 = strstr( cmd, "$text");
    if ( s1) {
      strncpy( str, s1 + strlen("$text"), sizeof(str));
      *s1 = 0;
      strncat( cmd, text, cmd_size);
      strncat( cmd, str, cmd_size);
    }
  }

  // Replace $subject with subject
  if ( subject) {
    s1 = strstr( cmd, "$subject");
    if ( s1) {
      strncpy( str, s1 + strlen("$subject"), sizeof(str));
      *s1 = 0;
      strncat( cmd, subject, cmd_size);
      strncat( cmd, str, cmd_size);
    }
  }

  // Replace $reportfile with reportfile
  if ( reportfile) {
    s1 = strstr( cmd, "$reportfile");
    if ( s1) {
      strncpy( str, s1 + strlen("$reportfile"), sizeof(str));
      *s1 = 0;
      strncat( cmd, reportfile, cmd_size);
      strncat( cmd, str, cmd_size);
    }
  }

  // Replace $date with date
  if ( date) {
    s1 = strstr( cmd, "$date");
    if ( s1) {
      strncpy( str, s1 + strlen("$date"), sizeof(str));
      *s1 = 0;
      strncat( cmd, date, cmd_size);
      strncat( cmd, str, cmd_size);
    }
  }
}

int rt_report::parse( char *line) 
{
  char line_array[5][80];
  int num;

  num = dcli_parse( line, " 	", "",
		    (char *) line_array, sizeof( line_array)/sizeof( line_array[0]),
		    sizeof( line_array[0]), 0);

  if ( num > 0 && cdh_NoCaseStrcmp( line_array[0], "print") == 0) {
    if ( num > 1 && cdh_NoCaseStrcmp( line_array[1], "graph") == 0) {
      ofstream fout;
      pwr_tFileName fname;
      pwr_tFileName tmpfile = "$pwrp_lis/report_print.rtt_com";
      pwr_tCmd cmd;

      if ( num < 4)
	return 0;

      dcli_translate_filename( fname, tmpfile);
      fout.open( fname);
      if ( !fout)
	return 0;
      
      fout << "open graph  " << line_array[2] << endl; // Should be with /hide but it sometimes doesn't work...
      fout << "wait 2 " << endl;
      fout << "export graph /graph=" << line_array[2] << " /file=\"" << line_array[3] << "\"" << endl;

      strcpy( cmd, "rt_xtt_cmd ");
      if ( strcmp( display, "") != 0) {
	strcpy( cmd, "export DISPLAY=");
	strcat( cmd, display);
	strcat( cmd, ";");
      }
      else
	strcpy( cmd, "");
      strcat( cmd, "rt_xtt_cmd ");
      strcat( cmd, " -i -q  @");
      strcat( cmd, fname);

      system( cmd);
      sprintf( cmd, "rm %s", fname);
      system( cmd);
    }
    else
      return 0;
  }
  else 
    return 0;

  return 1;
}

int main( int argc, char *argv[])
{
  pwr_tStatus sts;
  int tmo;
  char mp[2000];
  qcom_sQid qid = qcom_cNQid;
  qcom_sGet get;
  int swap = 0;
  bool first_scan = true;

  report = new rt_report();
  report->init( &qid);

  if ( argc > 1) {
    if ( strcmp( argv[1], "-d") == 0 && argc > 2)
      strcpy( report->display, argv[2]);
  }

  try {
    report->open();
  }
  catch ( co_error& e) {
    errh_Error( (char *)e.what().c_str());
    errh_Fatal( "rt_report aborting");
    errh_SetStatus( PWR__SRVTERM);
    exit(0);
  }

  aproc_TimeStamp(report->scantime(), 10);
  errh_SetStatus( PWR__SRUN);

  first_scan = true;
  for (;;) {
    if ( first_scan) {
      tmo = (int) (report->scantime() * 1000 - 1);
    }

    get.maxSize = sizeof(mp);
    get.data = mp;
    qcom_Get( &sts, &qid, &get, tmo);
    if (sts == QCOM__TMO || sts == QCOM__QEMPTY) {
      if ( !swap)
	report->scan();
    } 
    else {
      ini_mEvent  new_event;
      qcom_sEvent *ep = (qcom_sEvent*) get.data;

      new_event.m  = ep->mask;
      if (new_event.b.oldPlcStop && !swap) {
	errh_SetStatus( PWR__SRVRESTART);
	report->conf->Status = PWR__SRVRESTART;
        swap = 1;
	report->close();
      } else if (new_event.b.swapDone && swap) {
        swap = 0;
	report->open();
	errh_SetStatus( PWR__SRUN);
	report->conf->Status = PWR__SRUN;
      } else if (new_event.b.terminate) {
	exit(0);
      }
    }
    first_scan = false;
  }

}






