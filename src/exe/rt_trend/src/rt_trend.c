/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_trend.c

   This file contains the access routines to the datastorage
   of data to trendplot.   */

#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "pwr_baseclasses.h"
#include "co_cdh.h"
#include "co_time.h"
#include "rt_gdh.h"
#include "rt_ds_msg.h"
#include "rt_gdh_msg.h"
#include "rt_qcom_msg.h"
#include "rt_ini_event.h"
#include "rt_aproc.h"
#include "rt_pwr_msg.h"

#define Log_Error(a, b)                                                        \
  errh_CErrLog(DS__ERROR, errh_ErrArgAF(b), errh_ErrArgMsg(a), NULL)
#define Log_Error_Exit(a, b)                                                   \
  {                                                                            \
    Log_Error(a, b);                                                           \
    exit(a);                                                                   \
  }
#define If_Error_Log_Exit(a, b)                                                \
  if ((a & 1) != 1)                                                            \
  Log_Error_Exit(a, b)

typedef struct s_ListEntry {
  struct s_ListEntry* next;
  pwr_sClass_DsTrend* o; /* Pointer to DsTrend object */
  pwr_tSubid o_subid; /* SubId for DsTrend object */
} trend_sListEntry;

typedef struct s_ListEntryTC {
  struct s_ListEntryTC* next;
  pwr_sClass_DsTrendCurve* o; /* Pointer to DsTrendCurve object */
  pwr_tSubid o_subid; /* SubId for DsTrendCurve object */
  void* datap[10];
  pwr_tSubid data_subid[10];
  unsigned int data_size[10];
  pwr_sClass_CircBuffHeader* buffheadp[10];
  void* buffp[10];
  pwr_tSubid buff_subid[10];
  unsigned int buff_size[10];
  pwr_sClass_CircBuffHeader* timeheadp;
  void* timebuffp;
  pwr_tSubid timebuff_subid;
  unsigned int timebuff_size;
  unsigned int time_size;
  unsigned int multiple;
  unsigned int multiple_cnt;
  int first_scan;
} trend_sListEntryTC;

typedef struct {
  pwr_tUInt32 scantime;
  pwr_tFloat32 scantime_tc;
  unsigned int dstrend_multiple;
  unsigned int dstrend_multiple_cnt;
  trend_sListEntry* o_list;
  trend_sListEntryTC* o_list_tc;
} trend_sCtx, *trend_tCtx;

static pwr_tStatus InitTrendlist(trend_tCtx ctx);
static void CloseTrendlist(trend_tCtx ctx);
static pwr_tBoolean IsValidType(pwr_eTix Type);
static void StoreData(trend_tCtx ctx);
static int IsDisabled(pwr_tAttrRef* aaref);

int main(int argc, char** argv)
{
  pwr_tStatus sts;
  pwr_tObjid ObjId;
  pwr_sClass_DsTrendConf* TConfP;
  pwr_tBoolean InitOK;
  pwr_tTime CurrentTime, LastScan, NextScan;
  pwr_tDeltaTime ScanDeltaTime, WaitTime;
  qcom_sQid qini;
  qcom_sQattr qAttr;
  int tmo;
  char mp[2000];
  qcom_sQid qid = qcom_cNQid;
  qcom_sGet get;
  int swap = 0;
  trend_tCtx ctx;

  errh_Init("pwr_trend", errh_eAnix_trend);
  errh_SetStatus(PWR__SRVSTARTUP);

  sts = gdh_Init("ds_trend");
  If_Error_Log_Exit(sts, "gdh_Init");

  if (!qcom_Init(&sts, 0, "pwr_trend")) {
    errh_Fatal("qcom_Init, %m", sts);
    exit(sts);
  }

  qAttr.type = qcom_eQtype_private;
  qAttr.quota = 100;
  if (!qcom_CreateQ(&sts, &qid, &qAttr, "events")) {
    errh_Fatal("qcom_CreateQ, %m", sts);
    exit(sts);
  }

  qini = qcom_cQini;
  if (!qcom_Bind(&sts, &qid, &qini)) {
    errh_Fatal("qcom_Bind(Qini), %m", sts);
    exit(-1);
  }

  ctx = (trend_tCtx)calloc(1, sizeof(trend_sCtx));

  /* Wait until local nethandler has started */
  while (EVEN(gdh_NethandlerRunning()))
    sleep(1);

  /* Fetch ScanTime */
  sts = gdh_GetClassList(pwr_cClass_DsTrendConf, &ObjId);
  if (EVEN(sts)) {
    errh_Info("Couldn't get the DsTrendConf object. Used ScanTime = 1 s");
    ctx->scantime = 1;
    ctx->scantime_tc = 1.0;
  } else {
    gdh_ObjidToPointer(ObjId, (pwr_tAddress*)&TConfP);
    ctx->scantime = TConfP->ScanTime;
    if (ctx->scantime > 3600)
      ctx->scantime = 3600;
    else if (ctx->scantime < 1)
      ctx->scantime = 1;

    ctx->scantime_tc = TConfP->ScanTime;
    if (ctx->scantime_tc > 3600)
      ctx->scantime_tc = 3600;
  }
  ctx->dstrend_multiple = (int)(ctx->scantime / ctx->scantime_tc + 0.5);

  aproc_RegisterObject(ObjId);

  InitOK = FALSE;
  sts = InitTrendlist(ctx);
  if (EVEN(sts)) {
    /* This should be removed when we can wait for init messages. */
    errh_SetStatus(0);
    errh_Info("No DsTrend objects configured");
    exit(0);
  }

  /* If even sts, just wait for init message */

  time_GetTimeMonotonic(&LastScan);
  time_FloatToD(&ScanDeltaTime, ctx->scantime_tc);

  aproc_TimeStamp(ctx->scantime, 5.0);
  errh_SetStatus(PWR__SRUN);

  for (;;) {
    time_GetTimeMonotonic(&CurrentTime);
    time_Aadd(&NextScan, &LastScan, &ScanDeltaTime);
    if (time_Acomp(&CurrentTime, &NextScan) < 0) {
      time_Adiff(&WaitTime, &NextScan, &CurrentTime);
      tmo = 1000 * time_DToFloat(0, &WaitTime);

      get.maxSize = sizeof(mp);
      get.data = mp;
      qcom_Get(&sts, &qid, &get, tmo);
      if (sts == QCOM__TMO || sts == QCOM__QEMPTY) {
        if (!swap)
          StoreData(ctx);
      } else {
        ini_mEvent new_event;
        qcom_sEvent* ep = (qcom_sEvent*)get.data;

        new_event.m = ep->mask;
        if (new_event.b.oldPlcStop && !swap) {
          swap = 1;
          errh_SetStatus(PWR__SRVRESTART);
          CloseTrendlist(ctx);
        } else if (new_event.b.swapDone && swap) {
          swap = 0;
          sts = InitTrendlist(ctx);
          errh_SetStatus(PWR__SRUN);
          errh_Info("Warm restart completed");
        } else if (new_event.b.terminate) {
          exit(0);
        }
      }
    } else if (!swap)
      StoreData(ctx);

    LastScan = NextScan;

    aproc_TimeStamp(ctx->scantime, 5.0);
  }
}

/* Set up subscriptions for every local DsTrend object and
   initialize the DsTrend objects.  */

static void CloseTrendlist(trend_tCtx ctx)
{
  trend_sListEntry *ep, *tmp;

  /* Free old list */

  ep = ctx->o_list;
  while (ep != NULL) {
    tmp = ep;
    gdh_UnrefObjectInfo(ep->o->DataSubId);
    gdh_UnrefObjectInfo(ep->o_subid);
    ep = tmp->next;
    free(tmp);
  }
  ctx->o_list = NULL;
}

static pwr_tStatus InitTrendlist(trend_tCtx ctx)
{
  pwr_tStatus sts;
  pwr_tUInt32 dummy;
  pwr_tTypeId type;
  int tix;
  pwr_tAttrRef aref;
  pwr_tAttrRef oaref;
  pwr_tAName name;
  pwr_tDisableAttr disabled;

  /* Init DsTrend objects */
  /* Scan through typelist and insert valid objects in list and initiate */
  /* the DsTrend objects. */

  for (sts = gdh_GetClassListAttrRef(pwr_cClass_DsTrend, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_DsTrend, &aref, &aref)) {
    trend_sListEntry* ep;
    pwr_sClass_DsTrend* o;

    sts = gdh_AttrrefToName(&aref, name, sizeof(name), cdh_mNName);
    if (EVEN(sts))
      continue;

    /* Check if parent object is disabled */
    sts = gdh_AttrArefToObjectAref(&aref, &oaref);
    if (ODD(sts)) {
      sts = gdh_ArefDisabled(&oaref, &disabled);
      if (ODD(sts) && disabled)
        continue;
    }

    ep = calloc(1, sizeof(*ep));
    if (ep == NULL) {
      errh_CErrLog(DS__ERRALLOC, NULL);
      errh_SetStatus(PWR__SRVTERM);
      exit(DS__ERRALLOC);
    }

    sts = gdh_RefObjectInfo(
        name, (pwr_tAddress*)&ep->o, &ep->o_subid, sizeof(*ep->o));
    if (EVEN(sts)) {
      errh_Error("Couldn't get subscription for '%s'\n%m", name, sts);
      free(ep);
      continue;
    }
    o = ep->o;

    /* Set init values */
    o->BufferStatus[0] = 1;
    o->BufferStatus[1] = 1;
    o->NoOfBuffers = 2;
    o->NoOfBufElement = 239;

    /* Initiate DsTrend object, sampled attribute must be on local node */

    sts = gdh_DLRefObjectInfoAttrref((pwr_sAttrRef*)&o->DataName,
        (pwr_tAddress*)&o->DataPointer, &o->DataSubId);
    if (EVEN(sts)) {
      if (sts == GDH__RTDBNULL && IsDisabled(&o->DataName))
        continue;

      errh_Error(
          "Couldn't get direct link to %s's attribute DataName\n%m", name, sts);
      gdh_UnrefObjectInfo(ep->o_subid);
      free(ep);
      continue;
    }

    sts = gdh_GetAttributeCharAttrref(
        (pwr_sAttrRef*)&o->DataName, &type, &dummy, &dummy, &dummy);
    if (EVEN(sts)) {
      errh_Error(
          "Couldn't get datatype for %s's attribute DataName\n%m", name, sts);
      gdh_UnrefObjectInfo(ep->o_subid);
      free(ep);
      continue;
    }
    tix = cdh_TypeIdToIndex(type);

    if (!IsValidType(tix)) {
      errh_Error("No valid datatype for %s's attribute DataName\n%m", name,
          DS__ERRTYPE);
      gdh_UnrefObjectInfo(ep->o_subid);
      free(ep);
      continue;
    }

    o->DataType = tix;
    if (o->Multiple == 0)
      o->Multiple = 1;
    o->NoOfSample = (o->StorageTime * ctx->scantime) / o->Multiple;

    if (o->NoOfSample > o->NoOfBufElement)
      o->NoOfSample = o->NoOfBufElement;

    o->ScanTime = ctx->scantime;

    ep->next = ctx->o_list;
    ctx->o_list = ep;
  }

  /* Init DsTrendCurve objects */

  /* Scan through typelist and insert valid objects in list and initiate
     the DsTrend objects.  */

  for (sts = gdh_GetClassListAttrRef(pwr_cClass_DsTrendCurve, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_DsTrendCurve, &aref, &aref)) {
    trend_sListEntryTC* ep;
    pwr_sClass_DsTrendCurve* o;
    int i;
    int found;

    sts = gdh_AttrrefToName(&aref, name, sizeof(name), cdh_mNName);
    if (EVEN(sts))
      continue;

    /* Check if parent object is disabled */
    sts = gdh_AttrArefToObjectAref(&aref, &oaref);
    if (ODD(sts)) {
      sts = gdh_ArefDisabled(&oaref, &disabled);
      if (ODD(sts) && disabled)
        continue;
    }

    ep = calloc(1, sizeof(*ep));
    if (ep == NULL) {
      errh_CErrLog(DS__ERRALLOC, NULL);
      errh_SetStatus(PWR__SRVTERM);
      exit(DS__ERRALLOC);
    }

    ep->first_scan = 1;

    sts = gdh_RefObjectInfo(
        name, (pwr_tAddress*)&ep->o, &ep->o_subid, sizeof(*ep->o));
    if (EVEN(sts)) {
      errh_Error("Couldn't get subscription for '%s'\n%m", name, sts);
      free(ep);
      continue;
    }
    o = ep->o;

    if (o->Function & 1) {
      /* Data stored by user */
      gdh_UnrefObjectInfo(ep->o_subid);
      free(ep);
      continue;
    }

    ep->multiple = (int)(o->ScanTime / ctx->scantime_tc + 0.5);
    o->NoOfSample
        = (int)(o->StorageTime / ctx->scantime_tc * ep->multiple + 0.5);

    /* Initiate DsTrendCuve object, sampled attribute must be on local node */

    found = 0;
    for (i = 0; i < 10; i++) {
      if (cdh_ObjidIsNull(o->Attribute[i].Objid))
        continue;

      /* Link to attribute */
      sts = gdh_DLRefObjectInfoAttrref((pwr_sAttrRef*)&o->Attribute[i],
          (pwr_tAddress*)&ep->datap[i], &ep->data_subid[i]);
      if (EVEN(sts)) {
        if (sts == GDH__RTDBNULL && IsDisabled(&o->Attribute[i]))
          continue;

        errh_Error("Couldn't get direct link to %s's attribute %d, %m", name,
            i + 1, sts);
        ep->datap[i] = 0;
        continue;
      }

      sts = gdh_GetAttributeCharAttrref(
          (pwr_sAttrRef*)&o->Attribute[i], &type, &dummy, &dummy, &dummy);
      if (EVEN(sts)) {
        errh_Error(
            "Couldn't get datatype for %s's attribute DataName\n%m", name, sts);
        gdh_UnrefObjectInfo(ep->data_subid[i]);
        ep->datap[i] = 0;
        continue;
      }
      tix = cdh_TypeIdToIndex(type);
      ep->data_size[i] = cdh_TypeToSize(type);

      if (!IsValidType(tix)) {
        errh_Error("No valid datatype for %s's attribute DataName\n%m", name,
            DS__ERRTYPE);
        gdh_UnrefObjectInfo(ep->data_subid[i]);
        ep->datap[i] = 0;
        continue;
      }

      o->AttributeType[i] = type;

      /* Link to buffer */
      sts = gdh_DLRefObjectInfoAttrref((pwr_sAttrRef*)&o->Buffers[i],
          (pwr_tAddress*)&ep->buffheadp[i], &ep->buff_subid[i]);
      if (EVEN(sts)) {
        errh_Error(
            "Couldn't get direct link to %s's buffer %d, %m", name, i + 1, sts);
        gdh_UnrefObjectInfo(ep->data_subid[i]);
        ep->datap[i] = 0;
        continue;
      }
      ep->buffp[i] = (char*)ep->buffheadp[i]
          + pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader));

      /* Get buffer size */
      sts = gdh_GetAttributeCharAttrref(
          &o->Buffers[i], 0, &ep->buff_size[i], 0, 0);
      if (EVEN(sts))
        return sts;

      ep->buff_size[i] -= pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader));

      found = 1;
    }
    if (!found) {
      errh_Error("No valid attributes for %s", name);
      gdh_UnrefObjectInfo(ep->o_subid);
      free(ep);
      continue;
    }

    /* Link to time buffer */
    if (cdh_ObjidIsNotNull(o->TimeBuffer.Objid)) {
      sts = gdh_DLRefObjectInfoAttrref((pwr_sAttrRef*)&o->TimeBuffer,
          (pwr_tAddress*)&ep->timeheadp, &ep->timebuff_subid);
      if (EVEN(sts)) {
        errh_Error(
            "Couldn't get direct link to %s's time buffer, %m", name, sts);
        ep->timeheadp = 0;
        ep->timebuffp = 0;
      } else
        ep->timebuffp = (char*)ep->timeheadp
            + pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader));

      if (o->TimeResolution == pwr_eTimeResolutionEnum_Nanosecond)
        ep->time_size = 8;
      else
        ep->time_size = 4;

      /* Get buffer size */
      sts = gdh_GetAttributeCharAttrref(
          &o->TimeBuffer, 0, &ep->timebuff_size, 0, 0);
      if (EVEN(sts))
        return sts;

      ep->timebuff_size -= pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader));
    }

    /* Calculate number of samples */
    for (i = 0; i < 10; i++) {
      if (!ep->datap[i])
        continue;

      if (o->NoOfSample > ep->buff_size[i] / ep->data_size[i])
        o->NoOfSample = ep->buff_size[i] / ep->data_size[i];
    }
    if (ep->timebuffp) {
      if (o->NoOfSample > ep->timebuff_size / ep->time_size)
        o->NoOfSample = ep->timebuff_size / ep->time_size;
    }
    for (i = 0; i < 10; i++) {
      if (!ep->datap[i])
        continue;

      ep->buffheadp[i]->Size = o->NoOfSample;
      ep->buffheadp[i]->ElementSize = ep->data_size[i];
    }
    if (ep->timebuffp) {
      ep->timeheadp->Size = o->NoOfSample;
      ep->timeheadp->ElementSize = ep->time_size;
    }

    ep->next = ctx->o_list_tc;
    ctx->o_list_tc = ep;
  }

  if (ctx->o_list == NULL && ctx->o_list_tc == NULL)
    return DS__NOOBJECT;
  else
    return DS__SUCCESS;
}

static pwr_tBoolean IsValidType(pwr_eTix type)
{
  pwr_tBoolean valid = TRUE;

  switch (type) {
  case pwr_eTix_Boolean:
  case pwr_eTix_Float32:
  case pwr_eTix_Float64:
  case pwr_eTix_Int8:
  case pwr_eTix_Int16:
  case pwr_eTix_Int32:
  case pwr_eTix_UInt8:
  case pwr_eTix_UInt16:
  case pwr_eTix_UInt32:
    break;
  default:
    valid = FALSE;
    break;
  }

  return valid;
}

/* Store data for all DsTrend objects in list. */

static void StoreData(trend_tCtx ctx)
{
  if (ctx->dstrend_multiple_cnt == 0) {
    trend_sListEntry* ep;
    pwr_tFloat32* BuffP;
    pwr_sClass_DsTrend* o;

    /* Scan the DsTrendlist */

    for (ep = ctx->o_list; ep != NULL; ep = ep->next) {
      o = ep->o;

      /* If position equal first position in buffer  */

      if (o->NextWriteIndex[o->WriteBuffer] == 0) {
        o->BufferStatus[o->WriteBuffer] = 1;
        time_GetTime(&o->BufferTime[o->WriteBuffer]);
      }

      if (o->NextMultiple == 0) {
        /* Store data in buffer */

        BuffP = &o->DataBuffer[o->NextWriteIndex[o->WriteBuffer]
            + (o->WriteBuffer * o->NoOfBufElement)];

        switch (o->DataType) {
        case pwr_eTix_Boolean:
          *BuffP = *(pwr_tBoolean*)o->DataPointer;
          break;
        case pwr_eTix_Float32:
          *BuffP = *(pwr_tFloat32*)o->DataPointer;
          break;
        case pwr_eTix_Float64:
          *BuffP = *(pwr_tFloat64*)o->DataPointer;
          break;
        case pwr_eTix_Int8:
          *BuffP = *(pwr_tInt8*)o->DataPointer;
          break;
        case pwr_eTix_Int16:
          *BuffP = *(pwr_tInt16*)o->DataPointer;
          break;
        case pwr_eTix_Int32:
          *BuffP = *(pwr_tInt32*)o->DataPointer;
          break;
        case pwr_eTix_UInt8:
          *BuffP = *(pwr_tUInt8*)o->DataPointer;
          break;
        case pwr_eTix_UInt16:
          *BuffP = *(pwr_tUInt16*)o->DataPointer;
          break;
        case pwr_eTix_UInt32:
          *BuffP = *(pwr_tUInt32*)o->DataPointer;
          break;
        default:
          *BuffP = 0.0 /* Prevent invalid float */;
          break;
        }

        o->NextWriteIndex[o->WriteBuffer]++;
        o->NextMultiple = o->Multiple;

        /* If buffert full then mark next buffer*/

        if (o->NextWriteIndex[o->WriteBuffer] >= o->NoOfSample) {
          o->BufferStatus[o->WriteBuffer] = 0; /* sts = read */
          o->NextWriteIndex[o->WriteBuffer] = 0; /* First position */
          o->WriteBuffer = 1 - o->WriteBuffer; /* Change buffer */
        }
      }
      o->NextMultiple--;
    }
  }
  if (ctx->dstrend_multiple_cnt >= ctx->dstrend_multiple - 1)
    ctx->dstrend_multiple_cnt = 0;
  else
    ctx->dstrend_multiple_cnt++;

  /* Scan the DsTrendCurveList */

  if (ctx->o_list_tc) {
    trend_sListEntryTC* ep;
    void* BuffP;
    pwr_sClass_DsTrendCurve* o;
    int i;
    unsigned int current_index = 0;
    unsigned int first_index = 0;
    pwr_tTime time;
    int first_sample;

    for (ep = ctx->o_list_tc; ep != NULL; ep = ep->next) {
      o = ep->o;

      if (ep->multiple_cnt == 0) {
        first_sample = 0;

        if (ep->first_scan) {
          if (ep->buffheadp[0]) {
            if (ep->buffheadp[0]->LastIndex == 0
                && ep->buffheadp[0]->FirstIndex == 0) {
              current_index = 0;
              first_sample = 1;
            } else
              current_index = ep->buffheadp[0]->LastIndex + 1;
          } else
            first_sample = 1;
          ep->first_scan = 0;
        } else {
          current_index = o->LastIndex + 1;
          first_index = o->FirstIndex;
        }
        if (current_index >= o->NoOfSample)
          current_index = 0;

        if (current_index == first_index && !first_sample) {
          first_index++;
          if (first_index >= o->NoOfSample)
            first_index = 0;
        }

        /* Store data in buffer */
        if (ep->timebuffp) {
          time_GetTime(&time);
          BuffP = (char*)ep->timebuffp + current_index * ep->time_size;
          if (ep->time_size == 8) {
            unsigned int tv_sec = (unsigned int)time.tv_sec;
            unsigned int tv_nsec = (unsigned int)time.tv_nsec;
            memcpy(BuffP, &tv_sec, 4);
            memcpy(BuffP + 4, &tv_nsec, 4);
          } else {
            unsigned int tv_sec = (unsigned int)time.tv_sec;
            memcpy(BuffP, &tv_sec, 4);
          }
          ep->timeheadp->LastIndex = current_index;
          ep->timeheadp->FirstIndex = first_index;
        }

        for (i = 0; i < 10; i++) {
          if (ep->datap[i]) {
            BuffP = (char*)ep->buffp[i] + current_index * ep->data_size[i];
            memcpy(BuffP, ep->datap[i], ep->data_size[i]);

            ep->buffheadp[i]->LastIndex = current_index;
            ep->buffheadp[i]->FirstIndex = first_index;
          }
        }

        o->LastIndex = current_index;
        o->FirstIndex = first_index;
        first_sample = 0;
      }

      if (ep->multiple_cnt >= ep->multiple - 1)
        ep->multiple_cnt = 0;
      else
        ep->multiple_cnt++;
    }
  }
}

/* Check if signal is disabled */
/* aaref points to ActualValue */
static int IsDisabled(pwr_tAttrRef* aaref)
{
  pwr_tDisableAttr disabled;
  pwr_tAName name;
  pwr_tAttrRef oaref;
  pwr_tStatus sts;
  char* s;

  sts = gdh_AttrrefToName(aaref, name, sizeof(name), cdh_mNName);
  if (EVEN(sts))
    return 0;

  if ((s = strrchr(name, '.')))
    *s = 0;
  else
    return 0;

  sts = gdh_NameToAttrref(pwr_cNObjid, name, &oaref);
  if (EVEN(sts))
    return 0;

  sts = gdh_ArefDisabled(&oaref, &disabled);
  if (ODD(sts) && disabled)
    return 1;
  return 0;
}
