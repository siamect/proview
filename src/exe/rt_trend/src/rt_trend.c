/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2014 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

/* rt_trend.c 

   This file contains the access routines to the datastorage 
   of data to trendplot.   */

#if defined OS_VMS
# include <stdio.h>
# include <stdlib.h>
#elif defined OS_POSIX
# include <stdio.h>
# include <stdlib.h>
# include <signal.h>
# include <errno.h>
# include <unistd.h>
# include <time.h>
# include <signal.h>
# include <string.h>
#endif

#include "pwr.h"
#include "pwr_class.h"
#include "pwr_baseclasses.h"
#include "co_cdh.h"
#include "co_time.h"
#include "rt_errh.h"
#include "rt_gdh.h"
#include "rt_ds_msg.h"
#include "rt_gdh_msg.h"
#include "rt_qcom_msg.h"
#include "rt_qcom.h"
#include "rt_ini_event.h"
#include "rt_aproc.h"
#include "rt_pwr_msg.h"

#define Log_Error(a, b) errh_CErrLog(DS__ERROR, errh_ErrArgAF(b), errh_ErrArgMsg(a), NULL)
#define Log(b) errh_CErrLog(DS__LOG, errh_ErrArgAF(b), NULL)
#define Log_Error_Exit(a, b) {Log_Error(a, b); exit(a);}
#define If_Error_Log(a, b) if ((a & 1) != 1) Log_Error(a, b)
#define If_Error_Log_Exit(a, b) if ((a & 1) != 1) Log_Error_Exit(a, b)


typedef struct s_ListEntry {
  struct s_ListEntry	*next;
  pwr_sClass_DsTrend  	*o;     	/* Pointer to DsTrend object */
  pwr_tSubid		o_subid; 	/* SubId for DsTrend object */  
} trend_sListEntry;

typedef struct s_ListEntryTC {
  struct s_ListEntryTC  *next;
  pwr_sClass_DsTrendCurve *o;     /* Pointer to DsTrendCurve object */
  pwr_tSubid		o_subid; /* SubId for DsTrendCurve object */  
  void			*datap[10];
  pwr_tSubid		data_subid[10];
  unsigned int		data_size[10];
  pwr_sClass_CircBuffHeader *buffheadp[10];
  void			*buffp[10];
  pwr_tSubid		buff_subid[10];
  unsigned int	       	buff_size[10];
  pwr_sClass_CircBuffHeader *timeheadp;
  void			*timebuffp;
  pwr_tSubid		timebuff_subid;
  unsigned int	       	timebuff_size;
  unsigned int		time_size;
  unsigned int		multiple;
  unsigned int		multiple_cnt;
  int			first_scan;
} trend_sListEntryTC;

typedef struct {
  pwr_tUInt32 		scantime;
  pwr_tFloat32		scantime_tc;
  unsigned int		dstrend_multiple;
  unsigned int		dstrend_multiple_cnt;
  trend_sListEntry 	*o_list;
  trend_sListEntryTC 	*o_list_tc;
} trend_sCtx, *trend_tCtx;


static pwr_tStatus InitTrendList( trend_tCtx ctx);
static void CloseTrendList( trend_tCtx ctx);
static pwr_tBoolean IsValidType(pwr_eTix Type);
static void StoreData( trend_tCtx ctx);
static int IsDisabled( pwr_tAttrRef *aaref);


int main (int argc, char **argv)
{
  pwr_tStatus	    sts;
  pwr_tObjid	    ObjId;
  pwr_sClass_DsTrendConf *TConfP;
  pwr_tBoolean    InitOK;
  pwr_tTime		CurrentTime, LastScan, NextScan;
  pwr_tDeltaTime	ScanDeltaTime, WaitTime;
  qcom_sQid qini;
  qcom_sQattr qAttr;
  int tmo;
  char mp[2000];
  qcom_sQid qid = qcom_cNQid;
  qcom_sGet get;
  int swap = 0;
  trend_tCtx ctx;

  errh_Init("pwr_trend", errh_eAnix_trend);
  errh_SetStatus( PWR__SRVSTARTUP);

  sts = gdh_Init("ds_trend");
  If_Error_Log_Exit(sts, "gdh_Init");

  if (!qcom_Init(&sts, 0, "pwr_trend")) {
    errh_Fatal("qcom_Init, %m", sts);
    exit(sts);
  } 

  qAttr.type = qcom_eQtype_private;
  qAttr.quota = 100;
  if (!qcom_CreateQ(&sts, &qid, &qAttr, "events")) {
    errh_Fatal("qcom_CreateQ, %m", sts);
    exit(sts);
  } 

  qini = qcom_cQini;
  if (!qcom_Bind(&sts, &qid, &qini)) {
    errh_Fatal("qcom_Bind(Qini), %m", sts);
    exit(-1);
  }

  ctx = (trend_tCtx) calloc( 1, sizeof(trend_sCtx));

  /* Wait until local nethandler has started */
  while(EVEN(gdh_NethandlerRunning()))
    sleep(1);

  /* Fetch ScanTime */
  sts = gdh_GetClassList(pwr_cClass_DsTrendConf, &ObjId);
  if (EVEN(sts)) {
    errh_Info("Couldn't get the DsTrendConf object. Used ScanTime = 1 s");
    ctx->scantime = 1;
    ctx->scantime_tc = 1.0;
  } 
  else {
    gdh_ObjidToPointer(ObjId, (pwr_tAddress *)&TConfP);
    ctx->scantime = TConfP->ScanTime;
    if ( ctx->scantime > 3600)
      ctx->scantime = 3600;
    else if ( ctx->scantime < 1)
      ctx->scantime = 1;

    ctx->scantime_tc = TConfP->ScanTime;
    if ( ctx->scantime_tc > 3600)
      ctx->scantime_tc = 3600;
  }
  ctx->dstrend_multiple = (int) (ctx->scantime / ctx->scantime_tc + 0.5);

  aproc_RegisterObject( ObjId);

  InitOK = FALSE;
  sts = InitTrendList( ctx);
  if ( EVEN(sts)) { 
    /* This should be removed when we can wait for init messages. */
    errh_SetStatus(0);
    errh_Info("No DsTrend objects configured");
    exit(0);
  }

  /* If even sts, just wait for init message */

  time_GetTimeMonotonic(&LastScan);
  time_FloatToD( &ScanDeltaTime, ctx->scantime_tc);

  aproc_TimeStamp( ctx->scantime, 5.0);
  errh_SetStatus( PWR__SRUN);

  for (;;) {

    time_GetTimeMonotonic(&CurrentTime);
    time_Aadd(&NextScan, &LastScan, &ScanDeltaTime);
    if (time_Acomp(&CurrentTime, &NextScan) < 0) { 
      time_Adiff(&WaitTime, &NextScan, &CurrentTime);
      tmo = 1000 * time_DToFloat( 0, &WaitTime);

      get.maxSize = sizeof(mp);
      get.data = mp;
      qcom_Get( &sts, &qid, &get, tmo);
      if (sts == QCOM__TMO || sts == QCOM__QEMPTY) {
	if ( !swap)
	  StoreData( ctx);
      } 
      else {
	ini_mEvent  new_event;
	qcom_sEvent *ep = (qcom_sEvent*) get.data;

	new_event.m  = ep->mask;
	if (new_event.b.oldPlcStop && !swap) {
	  swap = 1;
	  errh_SetStatus( PWR__SRVRESTART);
	  CloseTrendList( ctx);
	} 
	else if (new_event.b.swapDone && swap) {
	  swap = 0;
	  sts = InitTrendList( ctx);
	  errh_SetStatus( PWR__SRUN);
	  errh_Info("Warm restart completed");
	}
	else if (new_event.b.terminate) {
	  exit(0);
	}
      }
    }
    else if ( !swap)
      StoreData( ctx);

    LastScan = NextScan;

    aproc_TimeStamp( ctx->scantime, 5.0);
  }

  return 1;
}

/* Set up subscriptions for every local DsTrend object and 
   initialize the DsTrend objects.  */

static void CloseTrendList( trend_tCtx ctx)
{
  trend_sListEntry	    *ep, *tmp;

  /* Free old list */

  ep = ctx->o_list;
  while (ep != NULL) {
    tmp = ep;
    gdh_UnrefObjectInfo(ep->o->DataSubId);
    gdh_UnrefObjectInfo(ep->o_subid);
    ep = tmp->next;
    free(tmp);
  }
  ctx->o_list = NULL;
}

static pwr_tStatus InitTrendList( trend_tCtx ctx)
{
  pwr_tStatus	    sts;
  pwr_tUInt32	    dummy;
  pwr_tTypeId	    type;
  int		    tix;
  pwr_tAttrRef	    aref;
  pwr_tAttrRef	    oaref;
  pwr_tAName   	    name;
  pwr_tDisableAttr  disabled;

  /* Init DsTrend objects */
  /* Scan through typelist and insert valid objects in list and initiate */
  /* the DsTrend objects. */

  for ( sts = gdh_GetClassListAttrRef(pwr_cClass_DsTrend, &aref); 
	ODD(sts); 
	sts = gdh_GetNextAttrRef( pwr_cClass_DsTrend, &aref, &aref) ) {
    trend_sListEntry    *ep;
    pwr_sClass_DsTrend  *o;

    sts = gdh_AttrrefToName( &aref, name, sizeof(name), cdh_mNName);  
    if (EVEN(sts))
      continue;

    /* Check if parent object is disabled */
    sts = gdh_AttrArefToObjectAref( &aref, &oaref);
    if ( ODD(sts)) {
      sts = gdh_ArefDisabled( &oaref, &disabled);
      if ( ODD(sts) && disabled)
	continue;
    }

    ep = calloc(1, sizeof(*ep));
    if (ep == NULL) {
      errh_CErrLog(DS__ERRALLOC, NULL);
      errh_SetStatus( PWR__SRVTERM);
      exit(DS__ERRALLOC);
    }

    sts = gdh_RefObjectInfo(name, (pwr_tAddress *)&ep->o, 
		      &ep->o_subid, sizeof(*ep->o));
    if (EVEN(sts)) {
      errh_Error("Couldn't get subscription for '%s'\n%m", name, sts);
      free(ep);
      continue;
    }
    o = ep->o;       

   /* Set init values */
    o->BufferStatus[0] = 1;
    o->BufferStatus[1] = 1;
    o->NoOfBuffers = 2;
    o->NoOfBufElement = 239;

    /* Initiate DsTrend object, sampled attribute must be on local node */	  

    sts = gdh_DLRefObjectInfoAttrref((pwr_sAttrRef *)&o->DataName, 
		  (pwr_tAddress *)&o->DataPointer, &o->DataSubId);
    if (EVEN(sts)) {
      if ( sts == GDH__RTDBNULL && IsDisabled( &o->DataName))
	  continue;

      errh_Error("Couldn't get direct link to %s's attribute DataName\n%m", name, sts);
      gdh_UnrefObjectInfo(ep->o_subid);
      free(ep);
      continue;
    }

    sts = gdh_GetAttributeCharAttrref((pwr_sAttrRef *)&o->DataName,
					&type, &dummy, &dummy, &dummy);
    if (EVEN(sts)) {
      errh_Error("Couldn't get datatype for %s's attribute DataName\n%m", name, sts);
      gdh_UnrefObjectInfo(ep->o_subid);
      free(ep);
      continue;
    }
    tix = cdh_TypeIdToIndex(type);

    if (!IsValidType(tix)) {
      errh_Error("No valid datatype for %s's attribute DataName\n%m", name, DS__ERRTYPE);
      gdh_UnrefObjectInfo(ep->o_subid);
      free(ep);
      continue;
    }
      
    o->DataType = tix;
    if ( o->Multiple == 0)
      o->Multiple = 1;
    o->NoOfSample = (o->StorageTime * ctx->scantime) / o->Multiple;

    if(o->NoOfSample > o->NoOfBufElement)
      o->NoOfSample = o->NoOfBufElement;

    o->ScanTime = ctx->scantime;

    ep->next = ctx->o_list;
    ctx->o_list = ep;
  }

  /* Init DsTrendCurve objects */

  /* Scan through typelist and insert valid objects in list and initiate
     the DsTrend objects.  */

  for (sts = gdh_GetClassListAttrRef(pwr_cClass_DsTrendCurve, &aref); 
       ODD(sts); 
       sts = gdh_GetNextAttrRef( pwr_cClass_DsTrendCurve, &aref, &aref) ) {
    trend_sListEntryTC  *ep;
    pwr_sClass_DsTrendCurve  *o;
    int i;
    int found;

    sts = gdh_AttrrefToName( &aref, name, sizeof(name), cdh_mNName);  
    if (EVEN(sts))
      continue;

    /* Check if parent object is disabled */
    sts = gdh_AttrArefToObjectAref( &aref, &oaref);
    if ( ODD(sts)) {
      sts = gdh_ArefDisabled( &oaref, &disabled);
      if ( ODD(sts) && disabled)
	continue;
    }

    ep = calloc(1, sizeof(*ep));
    if (ep == NULL) {
      errh_CErrLog(DS__ERRALLOC, NULL);
      errh_SetStatus( PWR__SRVTERM);
      exit(DS__ERRALLOC);
    }

    ep->first_scan = 1;

    sts = gdh_RefObjectInfo(name, (pwr_tAddress *)&ep->o, 
		      &ep->o_subid, sizeof(*ep->o));
    if (EVEN(sts)) {
      errh_Error("Couldn't get subscription for '%s'\n%m", name, sts);
      free(ep);
      continue;
    }
    o = ep->o;       

    if ( o->Function & 1) {
      /* Data stored by user */
      gdh_UnrefObjectInfo(ep->o_subid);
      free(ep);
      continue;
    }

    ep->multiple = (int) (o->ScanTime / ctx->scantime_tc + 0.5);
    o->NoOfSample = (int) (o->StorageTime / ctx->scantime_tc * ep->multiple + 0.5);

    /* Initiate DsTrendCuve object, sampled attribute must be on local node */	  

    found = 0;
    for ( i = 0; i < 10; i++) {
      if ( cdh_ObjidIsNull( o->Attribute[i].Objid))
	continue;

      /* Link to attribute */
      sts = gdh_DLRefObjectInfoAttrref((pwr_sAttrRef *)&o->Attribute[i], 
				       (pwr_tAddress *)&ep->datap[i], &ep->data_subid[i]);
      if (EVEN(sts)) {
	if ( sts == GDH__RTDBNULL && IsDisabled( &o->Attribute[i]))
	  continue;
	
	errh_Error("Couldn't get direct link to %s's attribute %d, %m", name, i+1, sts);
	ep->datap[i] = 0;
	continue;
      }
     
      sts = gdh_GetAttributeCharAttrref((pwr_sAttrRef *)&o->Attribute[i],
					&type, &dummy, &dummy, &dummy);
      if (EVEN(sts)) {
	errh_Error("Couldn't get datatype for %s's attribute DataName\n%m", name, sts);
	gdh_UnrefObjectInfo(ep->data_subid[i]);
	ep->datap[i] = 0;
	continue;
      }
      tix = cdh_TypeIdToIndex(type);
      ep->data_size[i] = cdh_TypeToSize( type);

      if (!IsValidType(tix)) {
	errh_Error("No valid datatype for %s's attribute DataName\n%m", name, DS__ERRTYPE);
	gdh_UnrefObjectInfo(ep->data_subid[i]);
	ep->datap[i] = 0;
	continue;
      }
      
      o->AttributeType[i] = type;

      /* Link to buffer */
      sts = gdh_DLRefObjectInfoAttrref((pwr_sAttrRef *)&o->Buffers[i], 
				       (pwr_tAddress *)&ep->buffheadp[i], &ep->buff_subid[i]);
      if (EVEN(sts)) {
	errh_Error("Couldn't get direct link to %s's buffer %d, %m", name, i+1, sts);
	gdh_UnrefObjectInfo(ep->data_subid[i]);
	ep->datap[i] = 0;
	continue;
      }
      ep->buffp[i] = (char *)ep->buffheadp[i] + pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader));

      /* Get buffer size */
      sts = gdh_GetAttributeCharAttrref( &o->Buffers[i], 0, &ep->buff_size[i], 0, 0);
      if ( EVEN(sts)) return sts;

      ep->buff_size[i] -= pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader));

      found = 1;
    }
    if ( !found) {
      errh_Error("No valid attributes for %s", name);
      gdh_UnrefObjectInfo(ep->o_subid);
      free(ep);
      continue;
    }

    /* Link to time buffer */
    if ( cdh_ObjidIsNotNull( o->TimeBuffer.Objid)) {
      sts = gdh_DLRefObjectInfoAttrref((pwr_sAttrRef *)&o->TimeBuffer, 
				       (pwr_tAddress *)&ep->timeheadp, &ep->timebuff_subid);
      if (EVEN(sts)) {
	errh_Error("Couldn't get direct link to %s's time buffer, %m", name, sts);
	ep->timeheadp = 0;
	ep->timebuffp = 0;
      }
      else
 	ep->timebuffp = (char *)ep->timeheadp + pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader));
	
      if ( o->TimeResolution == pwr_eTimeResolutionEnum_Nanosecond)
	ep->time_size = 8;
      else
	ep->time_size = 4;

      /* Get buffer size */
      sts = gdh_GetAttributeCharAttrref( &o->TimeBuffer, 0, &ep->timebuff_size, 0, 0);
      if ( EVEN(sts)) return sts;

      ep->timebuff_size -= pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader));
    }

    /* Calculate number of samples */
    for ( i = 0; i < 10; i++) {
      if ( !ep->datap[i])
	continue;

      if ( o->NoOfSample > ep->buff_size[i] / ep->data_size[i])
	o->NoOfSample = ep->buff_size[i] / ep->data_size[i];
    }
    if ( ep->timebuffp) {
      if ( o->NoOfSample > ep->timebuff_size / ep->time_size)
	o->NoOfSample = ep->timebuff_size / ep->time_size;
    }
    for ( i = 0; i < 10; i++) {
      if ( !ep->datap[i])
	continue;

      ep->buffheadp[i]->Size = o->NoOfSample;
      ep->buffheadp[i]->ElementSize = ep->data_size[i];
    }
    if ( ep->timebuffp) {
      ep->timeheadp->Size = o->NoOfSample;
      ep->timeheadp->ElementSize = ep->time_size;
    }
     
    ep->next = ctx->o_list_tc;
    ctx->o_list_tc = ep;
  }

  if ( ctx->o_list == NULL && ctx->o_list_tc == NULL)
    return DS__NOOBJECT;
  else
    return DS__SUCCESS;
}

static pwr_tBoolean IsValidType( pwr_eTix type)
{
  pwr_tBoolean valid = TRUE;

  switch (type) {
  case	pwr_eTix_Boolean:
  case	pwr_eTix_Float32:
  case	pwr_eTix_Float64:
  case	pwr_eTix_Int8:
  case	pwr_eTix_Int16:
  case	pwr_eTix_Int32:
  case	pwr_eTix_UInt8:
  case	pwr_eTix_UInt16:
  case	pwr_eTix_UInt32:
    break;
  default:
    valid = FALSE;
    break;
  }

  return valid;

}

/* Store data for all DsTrend objects in list. */

static void StoreData( trend_tCtx ctx)
{

  if ( ctx->dstrend_multiple_cnt == 0) {
    trend_sListEntry    *ep;
    pwr_tFloat32       	*BuffP;
    pwr_sClass_DsTrend	*o;

    /* Scan the DsTrendList */

    for (ep = ctx->o_list; ep != NULL; ep = ep->next) {
      o = ep->o;

      /* If position equal first position in buffer  */

      if(o->NextWriteIndex[o->WriteBuffer] == 0) {
	o->BufferStatus[o->WriteBuffer] = 1;
	time_GetTime(&o->BufferTime[o->WriteBuffer]);
      }    

      if(o->NextMultiple == 0) {
	/* Store data in buffer */

	BuffP = &o->DataBuffer[ o->NextWriteIndex[o->WriteBuffer] + (o->WriteBuffer * o->NoOfBufElement)];

	switch (o->DataType) {
	case pwr_eTix_Boolean :
	  *BuffP = *(pwr_tBoolean *)o->DataPointer;
	  break;
	case pwr_eTix_Float32 :
	  *BuffP = *(pwr_tFloat32 *)o->DataPointer;
	  break;
	case pwr_eTix_Float64 :
	  *BuffP = *(pwr_tFloat64 *)o->DataPointer;
	  break;
	case pwr_eTix_Int8 :
	  *BuffP = *(pwr_tInt8 *)o->DataPointer;
	  break;
	case pwr_eTix_Int16  :
	  *BuffP = *(pwr_tInt16 *)o->DataPointer;
	  break;
	case pwr_eTix_Int32  :
	  *BuffP = *(pwr_tInt32 *)o->DataPointer;
	  break;
	case pwr_eTix_UInt8  :
	  *BuffP = *(pwr_tUInt8 *)o->DataPointer;
	  break;
	case pwr_eTix_UInt16  :
	  *BuffP = *(pwr_tUInt16 *)o->DataPointer;
	  break;
	case pwr_eTix_UInt32  :
	  *BuffP = *(pwr_tUInt32 *)o->DataPointer;
	  break;
	default	:
	  *BuffP = 0.0 /* Prevent invalid float */;
	  break;
	}
	
	o->NextWriteIndex[o->WriteBuffer]++;
	o->NextMultiple = o->Multiple;
	
	/* If buffert full then mark next buffer*/

	if (o->NextWriteIndex[o->WriteBuffer] >= o->NoOfSample) {
	  o->BufferStatus[o->WriteBuffer] = 0;	    /* sts = read */
	  o->NextWriteIndex[o->WriteBuffer] = 0;    /* First position */
	  o->WriteBuffer = 1 - o->WriteBuffer;	    /* Change buffer */
	}	 	     
      }	
      o->NextMultiple--;
    }
  }
  if ( ctx->dstrend_multiple_cnt >= ctx->dstrend_multiple - 1)
    ctx->dstrend_multiple_cnt = 0;
  else
    ctx->dstrend_multiple_cnt++;

  /* Scan the DsTrendCurveList */

  if ( ctx->o_list_tc) {
    trend_sListEntryTC  *ep;
    void       	*BuffP;
    pwr_sClass_DsTrendCurve *o;
    int			i;
    unsigned int current_index;
    unsigned int first_index = 0;
    pwr_tTime time;
    int first_sample;

    for (ep = ctx->o_list_tc; ep != NULL; ep = ep->next) {
      o = ep->o;

      if( ep->multiple_cnt == 0) {
	first_sample = 0;

	if ( ep->first_scan) {
	  if ( ep->buffheadp[0]) {
	    if ( ep->buffheadp[0]->LastIndex == 0 && ep->buffheadp[0]->FirstIndex == 0) {
	      current_index = 0;
	      first_sample = 1;
	    }
	    else
	      current_index = ep->buffheadp[0]->LastIndex + 1;
	  }	    
	  else
	    first_sample = 1;
	  ep->first_scan = 0;
	}	
	else {
	  current_index = o->LastIndex + 1;
	  first_index = o->FirstIndex;
	}
	if ( current_index >= o->NoOfSample)
	  current_index = 0;

	if ( current_index == first_index && !first_sample) {
	  first_index++;
	  if ( first_index >= o->NoOfSample)
	    first_index = 0;
	}

	/* Store data in buffer */
	if ( ep->timebuffp) {
	  time_GetTime( &time);
	  BuffP = (char *)ep->timebuffp + current_index * ep->time_size;
	  if ( ep->time_size == 8) {
	    unsigned int tv_sec = (unsigned int)time.tv_sec;
	    unsigned int tv_nsec = (unsigned int)time.tv_nsec;
	    memcpy( BuffP, &tv_sec, 4);
	    memcpy( BuffP+4, &tv_nsec, 4);
	  }
	  else {
	    unsigned int tv_sec = (unsigned int)time.tv_sec;
	    memcpy( BuffP, &tv_sec, 4);
	  }
	  ep->timeheadp->LastIndex = current_index;
	  ep->timeheadp->FirstIndex = first_index;
	}

	for ( i = 0; i < 10; i++) {
	  if ( ep->datap[i]) {

	    BuffP = (char *)ep->buffp[i] + current_index * ep->data_size[i];
	    memcpy( BuffP, ep->datap[i], ep->data_size[i]);
	    
	    ep->buffheadp[i]->LastIndex = current_index;
	    ep->buffheadp[i]->FirstIndex = first_index;
	  }
	}	

	o->LastIndex = current_index;
	o->FirstIndex = first_index;
	first_sample = 0;
      }

      if ( ep->multiple_cnt >= ep->multiple - 1)
	ep->multiple_cnt = 0;
      else
	ep->multiple_cnt++;	
    }
  }
}
	
/* Check if signal is disabled */
/* aaref points to ActualValue */
static int IsDisabled( pwr_tAttrRef *aaref)
{
  pwr_tDisableAttr disabled;
  pwr_tAName name;
  pwr_tAttrRef oaref;
  pwr_tStatus sts;
  char *s;
  
  sts = gdh_AttrrefToName( aaref, name, sizeof(name), cdh_mNName);  
  if ( EVEN(sts)) return 0;

  if ( (s = strrchr( name, '.')))
    *s = 0;
  else
    return 0;
       
  sts = gdh_NameToAttrref( pwr_cNObjid, name, &oaref);
  if ( EVEN(sts)) return 0;

  sts = gdh_ArefDisabled( &oaref, &disabled);
  if ( ODD(sts) && disabled)
    return 1;
  return 0;
}
