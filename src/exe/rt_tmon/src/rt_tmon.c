/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_tmon.c -- Timer Monitor */

#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "pwr_lst.h"
#include "co_time.h"
#include "rt_cvol.h"
#include "rt_cvolcm.h"
#include "rt_gdh.h"
#include "rt_gdh_msg.h"
#include "rt_sancm.h"
#include "rt_sansm.h"
#include "rt_subcm.h"
#include "rt_subsm.h"
#include "rt_aproc.h"
#include "rt_pwr_msg.h"
#include "rt_ini_event.h"
#include "rt_qcom_msg.h"

typedef struct s_Timer sTimer;

struct s_Timer {
  struct LstHead ll;
  time_tClock clock;
  pwr_tBoolean wrapped;
  void* data;
  void (*exec)();
};

static struct LstHead timer_lh;
static struct LstHead wrap_lh;
static struct LstHead free_lh;

static time_tClock now_clock;
static time_tClock last_clock;

static void event(qcom_sGet* get);

static void sancAdd(sTimer* tp);

static void sancExpired(sTimer* tp);

static void sansCheck(sTimer* tp);

static void subbCheck(sTimer* tp);

static void subcCheck(sTimer* tp);

static void cacheTrim(sTimer* tp);

static void insertTimer(sTimer* tp);

static sTimer* newTimer(time_tClock* clock, void* data, void (*exec)());

static void freeTimer(sTimer* tp);

static sTimer* allocTimer();

static void setTimer(sTimer* tp, time_tClock offs);

static time_tClock msToClock(time_tClock* ic, int ms);

static void waitClock(time_tClock c, int* tmo_ms);

static void setInterval(time_tClock* c, pwr_tUInt32 i);

static void executeExpired(struct LstHead * lh, pwr_tBoolean force);

static void getNewTimers();

static void getWaitClock(time_tClock* wait_clock, time_tClock last_clock);

static void init();

static void toggleWrapped();

int main(int argc, char** argv)
{
  pwr_tStatus sts;
  time_tClock wait_clock;
  qcom_sQid my_q = qcom_cNQid;
  qcom_sGet get;
  int tmo_ms = 0;

  // mcheck(memCheck);

  init();

  if (!qcom_CreateQ(&sts, &my_q, NULL, "events")) {
    exit(sts);
  }
  if (!qcom_Bind(&sts, &my_q, &qcom_cQini)) {
    exit(-1);
  }

  gdbroot->db->log.b.tmon = 0;

  for (wait_clock = 0;;) {
    if (wait_clock != 0) {
      waitClock(wait_clock, &tmo_ms);
    } else {
      tmo_ms = 0;
    }

    aproc_TimeStamp(((float)tmo_ms) / 1000, 5);

    get.data = NULL;
    qcom_Get(&sts, &my_q, &get, tmo_ms);
    if (sts != QCOM__TMO && sts != QCOM__QEMPTY) {
      if (get.type.b == qcom_eBtype_event) {
        event(&get);
      }
      qcom_Free(&sts, get.data);
    }

    now_clock = time_Clock(NULL, NULL);
    if (now_clock < last_clock) {
      errh_Info("The uptime clock has wrapped");
      toggleWrapped();
      executeExpired(&wrap_lh, 1);
    }

    getNewTimers();
    executeExpired(&timer_lh, 0);

    last_clock = now_clock;
    now_clock = time_Clock(NULL, NULL);

    getWaitClock(&wait_clock, last_clock);
  }
}

static void event(qcom_sGet* get)
{
  qcom_sEvent* ep = (qcom_sEvent*)get->data;
  ini_mEvent new_event;

  if (get->type.s != qcom_cIini)
    return;

  new_event.m = ep->mask;
  if (new_event.b.terminate) {
    exit(0);
  }
}

/* .  */

static void sancAdd(sTimer* tp)
{
  static time_tClock cycle;
  static pwr_tBoolean first = 1;
  gdb_sNode* np;
  pool_sQlink* nl;

  if (first) {
#ifdef OS_LINUX
    cycle = 1 * sysconf(_SC_CLK_TCK);
#else
    cycle = 1 * CLK_TCK;
#endif
    setInterval(&cycle, gdbroot->db->sanc_add_int);
    first = 0;
  }

  if (gdbroot->db->log.b.tmon)
    errh_Info("sancAdd: %u", tp->clock);

  for (nl = pool_Qsucc(NULL, gdbroot->pool, &gdbroot->db->nod_lh);
       nl != &gdbroot->db->nod_lh; nl = pool_Qsucc(NULL, gdbroot->pool, nl)) {
    np = pool_Qitem(nl, gdb_sNode, nod_ll);

    if (!np->flags.b.active || np == gdbroot->my_node || np == gdbroot->no_node)
      continue;

    sancm_Add(NULL, np);
  }

  setTimer(tp, cycle);

  insertTimer(tp);
}

/* .  */

static void sancExpired(sTimer* tp)
{
  static time_tClock cycle;
  static pwr_tBoolean first = 1;
  gdb_sNode* np;
  pool_sQlink* nl;

  if (first) {
#ifdef OS_LINUX
    cycle = 60 * sysconf(_SC_CLK_TCK);
#else
    cycle = 60 * CLK_TCK;
#endif
    setInterval(&cycle, gdbroot->db->sanc_exp_int);
    first = 0;
  }

  if (gdbroot->db->log.b.tmon)
    errh_Info("sancExpired: %u", tp->clock);

  for (nl = pool_Qsucc(NULL, gdbroot->pool, &gdbroot->db->nod_lh);
       nl != &gdbroot->db->nod_lh;) {
    np = pool_Qitem(nl, gdb_sNode, nod_ll);
    nl = pool_Qsucc(NULL, gdbroot->pool, nl);

    if (!np->flags.b.active || np == gdbroot->my_node || np == gdbroot->no_node)
      continue;
    sancm_Remove(NULL, np);
    sancm_MoveExpired(NULL, np);
  }

  setTimer(tp, cycle);

  insertTimer(tp);
}

/* .  */

static void sansCheck(sTimer* tp)
{
  static time_tClock cycle;
  static pwr_tBoolean first = 1;
  gdb_sNode* np;
  pool_sQlink* nl;

  if (first) {
#ifdef OS_LINUX
    cycle = 2 * sysconf(_SC_CLK_TCK);
#else
    cycle = 2 * CLK_TCK;
#endif
    setInterval(&cycle, gdbroot->db->sans_chk_int);
    first = 0;
  }

  if (gdbroot->db->log.b.tmon)
    errh_Info("sansCheck: %u", tp->clock);

  sansm_Check();

  for (nl = pool_Qsucc(NULL, gdbroot->pool, &gdbroot->db->nod_lh);
       nl != &gdbroot->db->nod_lh;) {
    np = pool_Qitem(nl, gdb_sNode, nod_ll);
    nl = pool_Qsucc(NULL, gdbroot->pool, nl);

    if (!np->flags.b.active || np == gdbroot->my_node || np == gdbroot->no_node)
      continue;

    sansm_Update(np);
  }

  setTimer(tp, cycle);

  insertTimer(tp);
}

/* .  */

static void subcCheck(sTimer* tp)
{
  static time_tClock cycle;
  static pwr_tBoolean first = 1;

  if (first) {
    setInterval(&cycle, gdbroot->db->subc_chk_int);
    first = 0;
  }

  if (gdbroot->db->log.b.tmon)
    errh_Info("subcCheck: %u", tp->clock);

  subcm_CheckTimeout();

  setTimer(tp, cycle);

  insertTimer(tp);
}

/* Send a subscription buffer and reschedule it.  */

static void subbCheck(sTimer* tp)
{
  sub_sBuffer* bp = (sub_sBuffer*)tp->data;

  if (gdbroot->db->log.b.tmon)
    errh_Info("subbCheck: %u", tp->clock);

  if (subsm_SendBuffer(bp)) {
    setTimer(tp, msToClock(NULL, bp->dt));
    insertTimer(tp);
  } else {
    freeTimer(tp);
  }
}

/* .  */

static void cacheTrim(sTimer* tp)
{
  static time_tClock cycle;
  static pwr_tBoolean first = 1;

  if (first) {
#ifdef OS_LINUX
    cycle = 1 * sysconf(_SC_CLK_TCK);
#else
    cycle = 1 * CLK_TCK;
#endif
    setInterval(&cycle, gdbroot->db->cache_trim_int);
    first = 0;
  }

  if (gdbroot->db->log.b.tmon)
    errh_Info("cacheTrim: %u", tp->clock);

  cvolcm_TrimOld();
  cvol_Qtrim(&gdbroot->db->cacheNew);

  setTimer(tp, cycle);

  insertTimer(tp);
}

/* .  */

static void insertTimer(sTimer* tp)
{
  struct LstHead * tl;
  sTimer* tip;

  if (LstEmpty(&timer_lh)) {
    LstInsert(&timer_lh, &tp->ll);
    return;
  }

  for (tl = timer_lh.prev; tl != &timer_lh; tl = tl->prev) {
    tip = LstEntry(tl, sTimer, ll);

    if (tp->wrapped) {
      if (!tip->wrapped || tip->clock < tp->clock)
        break;
    } else if (!tip->wrapped && tip->clock < tp->clock)
      break;
  }

  tl = tl->next;
  LstInsert(tl, &tp->ll);
}

/* .  */

static sTimer* newTimer(time_tClock* clock, void* data, void (*exec)())
{
  sTimer* tp = allocTimer();

  tp->data = data;
  tp->exec = exec;

  if (clock == NULL)
    tp->clock = now_clock;
  else {
    tp->clock = *clock;
    tp->wrapped = (*clock < now_clock);
  }

  return tp;
}

/* .  */

static void freeTimer(sTimer* tp)
{
  memset(tp, 0, sizeof(*tp));
  LstInsert(&free_lh, &tp->ll);
}

/* .  */

static sTimer* allocTimer()
{
  const int cAllocCount = 100;
  sTimer* ftp;
  struct LstHead * ftl;
  int i;

  if (LstEmpty(&free_lh)) {
    ftp = (sTimer*)calloc(cAllocCount, sizeof(sTimer));
    for (i = 0; i < cAllocCount; i++, ftp++) {
      LstInsert(&free_lh, &ftp->ll);
    }
  }

  ftl = free_lh.next;
  LstRemove(ftl);
  return LstEntry(ftl, sTimer, ll);
}

static void setTimer(sTimer* tp, time_tClock offs)
{
  tp->clock = time_Clock(NULL, NULL) + offs;
  tp->wrapped = (tp->clock < now_clock);
}

/* Convert mille seconds to clock format.  */

static time_tClock msToClock(time_tClock* ic, int ms)
{
  time_tClock c;

#ifdef OS_LINUX
  c = ms * sysconf(_SC_CLK_TCK) / 1000;
#else
  c = ms * CLK_TCK / 1000;
#endif

  if (ic != NULL)
    *ic = c;

  return c;
}

/* Wait for a while.  */

static void waitClock(time_tClock diff, int* tmo_ms)
{
  //    pwr_tTime  rmt;
  //    pwr_tTime  wait;
  static int tics_per_sec = 0;

  if (tics_per_sec == 0) {
    tics_per_sec = sysconf(_SC_CLK_TCK);
  }
  //    printf("waitClock: %d\n", diff);
  //    time_ClockToD(NULL, (pwr_tDeltaTime *)&wait, diff);
  *tmo_ms = diff * 1000 / tics_per_sec;
//    *tmo_ms = wait.tv_sec * 1000 + wait.tv_nsec / 1000000;
//    nanosleep(&wait, &rmt);
}

/* .  */

static void setInterval(time_tClock* c,

    pwr_tUInt32 i)
{
  if (i == 0)
    return;

#ifdef OS_LINUX
  *c = i * sysconf(_SC_CLK_TCK) / 1000;
#else
  *c = i * CLK_TCK / 1000;
#endif
}

static void executeExpired(struct LstHead * lh, pwr_tBoolean force)
{
  struct LstHead * tl;
  sTimer* tp;

  gdb_AssumeUnlocked;

  gdb_ScopeLock
  {
    LstForEach(tl, lh) {
      tp = LstEntry(tl, sTimer, ll);

      if (force || (!tp->wrapped && tp->clock <= now_clock)) {
        LstRemove(tl);
        LstNull(tl);
        tp->exec(tp);
      } else
        break;
    }
  }
  gdb_ScopeUnlock;
}

static void getNewTimers()
{
  pool_sQlink* tql;
  sub_sBuffer* bp;
  gdb_sTmonQlink* tqp;
  time_tClock clock;

  gdb_AssumeUnlocked;

  gdb_ScopeLock
  {
    /* Get all new timers and insert them into local timer queue.  */

    for (tql = pool_Qsucc(NULL, gdbroot->pool, &gdbroot->db->tmonq_lh);
         tql != &gdbroot->db->tmonq_lh;
         tql = pool_Qsucc(NULL, gdbroot->pool, &gdbroot->db->tmonq_lh)) {
      tqp = pool_Qitem(tql, gdb_sTmonQlink, ll);

      switch (tqp->type) {
      case gdb_eTmon_subbCheck:
        bp = pool_Qitem(tql, sub_sBuffer, tmonq.ll);
        if (gdbroot->db->log.b.tmon)
          errh_Info("New buffer: %x", bp->nid);
        clock = msToClock(&clock, tqp->dt) + now_clock;
        insertTimer(newTimer(&clock, bp, subbCheck));
        break;
      default:
        break;
      }

      pool_Qremove(NULL, gdbroot->pool, &tqp->ll);
    }
  }
  gdb_ScopeUnlock;
}

static void getWaitClock(time_tClock* wait_clock, time_tClock last_clock)
{
  int diff;
  struct LstHead * tl;
  sTimer* tp;

  tl = timer_lh.next;
  tp = LstEntry(tl, sTimer, ll);

  if (now_clock < last_clock) {
    if (tp->wrapped) {
      diff = tp->clock - now_clock;
      if (diff < 0)
        *wait_clock = 0;
      else
        *wait_clock = diff;
    } else
      *wait_clock = 0;

  } else {
    diff = tp->clock - now_clock;
    if (diff < 0)
      *wait_clock = 0;
    else
      *wait_clock = diff;
  }
}

static void init()
{
  pwr_tStatus sts;

  /* Initialize.  */
  errh_Init("pwr_tmon", errh_eAnix_tmon);
  errh_SetStatus(PWR__SRVSTARTUP);

  qcom_Init(&sts, 0, "pwr_tmon");
  if (EVEN(sts)) {
    errh_Error("qcom_Init, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  sts = gdh_Init("pwr_tmon");
  if (EVEN(sts)) {
    errh_Error("gdh_Init, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  gdbroot->db->tmon = gdbroot->my_qid;
  gdbroot->is_tmon = 1;

  LstInit(&timer_lh);
  LstInit(&wrap_lh);
  LstInit(&free_lh);

  last_clock = now_clock = time_Clock(NULL, NULL);

  gdb_ScopeLock
  {
    cacheTrim(newTimer(NULL, NULL, cacheTrim));
    sancAdd(newTimer(NULL, NULL, sancAdd));
    sancExpired(newTimer(NULL, NULL, sancExpired));
    sansCheck(newTimer(NULL, NULL, sansCheck));
    subcCheck(newTimer(NULL, NULL, subcCheck));
  }
  gdb_ScopeUnlock;

  errh_SetStatus(PWR__SRUN);
}

static void toggleWrapped()
{
  struct LstHead * tl;
  struct LstHead * ntl;
  sTimer* tp;
  struct LstHead* tlh = &timer_lh;

  for (tl = tlh->next; tl != tlh; tl = ntl) {
    tp = LstEntry(tl, sTimer, ll);
    ntl = tl->next;

    if (!tp->wrapped) {
      LstRemove(tl);
      LstInsert(&wrap_lh, &tp->ll);
    } else
      tp->wrapped = 0;
  }
}
