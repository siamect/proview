/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2014 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

/* rt_elog_dump.c -- <short description>

   Author Jonas Nylund.

   Dumps the rt_eventlog.db to a file.
   If the eventlog doesn't exist a errormess will appear.
   */

#include <stdio.h>
#include <string.h>
#include <time.h>
#include <stdarg.h>
#include <db.h>
#include "co_time.h"
#include "rt_mh_def.h"
#include "co_dcli.h"
#include "rt_elog.h"

void ReadFromDBAndPutInFile(FILE *outFile);

void Init(char *fname);

void WriteColumnNames(FILE *outFile);

int Write(sEvent *sp, FILE *outFile);

void printMess(sEvent *sp, FILE *outFile);
void printAck(sEvent *sp, FILE *outFile);
void printRet(sEvent *sp, FILE *outFile);
void printBlock(sEvent *sp, FILE *outFile);
void printMsgInfo(mh_sMsgInfo *mp, FILE *outFile);


void printEventFlags(FILE *outFile, int flags);

void convertEventType(int type, char *ret);

void convertEventPrio(int prio, char *ret);

DB *dataBaseP = NULL;
static int current_pos = 0;
static int current_col = 0;
//static int cols[] = {8, 22, 8, 22, 22, 17, 3, 40, 40, 8, 22, 8, 2, 8, 8, 8, 1};
static int cols[] = {8, 30, 38, 60, 82, 99, 102, 142, 182, 190, 202, 210, 212, 220, 228, 236, 237};

void usage()
{
  printf( "\n"
	  "  rt_elog_dump   Dump eventlog to text file\n"
	  "\n"
	  "  > rt_elog_dump [dumpfile] [database]\n"
	  "\n"
	  "           dumpfile      Name of dumpfile, default " DUMPFILE "\n"
	  "           database      Database file, default " DATABASE "\n\n");
}

void new_row( FILE *fp)
{
  current_col = 0;
  current_pos = 0;
  
  fprintf( fp, "\n");
}

int col_print( FILE *fp, char *format, ...)
{
  va_list ap;
  int i;
  char buf[200];
  int sts;
  int incr;

  va_start( ap, format);
  sts = vsprintf( buf, format, ap);
  va_end( ap);

  fprintf( fp, "%s", buf);
  current_pos += strlen(buf);

  incr = 0;
  for ( i = 0; i < cols[current_col] - current_pos - 1; i++) {
    incr++;
    fprintf( fp, " ");
  }
  fprintf( fp, " ");
  incr++;
  current_pos += incr;
  current_col++;
  
  return sts;
}

int 
main (int argc, char *argv[])
{
  FILE *outFile;
  pwr_tInt32 ret;

  if (argc > 1 && (strcmp(argv[1], "-h") == 0 || strcmp(argv[1], "--help") == 0)) {
    usage();
    exit(0);
  }

  if(argc == 3)
  {
    if(argv[2] != NULL)
      outFile = fopen(argv[2], "w");
  }
  else
    outFile = fopen(DUMPFILE, "w");

  if(outFile == NULL)
  {
    printf("** Unable to open file, terminating\n");
    exit(1);
  }
  if(argc > 1)
    Init(argv[1]);
  else
    Init(DATABASE);
  ReadFromDBAndPutInFile(outFile);
  new_row(outFile);
  fclose(outFile);
  if((ret = dataBaseP->close(dataBaseP,0) != 0))
  {
    printf("error db_close: %s\n", db_strerror(ret));
  }
  if(argc == 3)
    printf("-- Dumpfile successfully created, %s\n", argv[2]);
  else
    printf("-- Dumpfile successfully created, %s\n", DUMPFILE);
  return 0;

}

void
Init (char *fname)
{
  pwr_tInt32 ret;
  char dbName[200];
  
  dcli_translate_filename( dbName, fname);

  /*create the database if it's not already created*/
  if((ret = db_create(&dataBaseP, NULL, 0)) != 0)
  {
    /*error creating db-handle send the mess to errh, then exit*/
    printf("error db_create: %s\n", db_strerror(ret));
    printf("** Error when creating db handle, terminating\n");
    exit(1);
  }

#if (DB_VERSION_MAJOR > 3) && (DB_VERSION_MINOR > 0)
  ret = dataBaseP->open(dataBaseP, NULL, dbName, NULL, DATABASETYPE, DB_RDONLY, 0);
#else
  ret = dataBaseP->open(dataBaseP, dbName, NULL, DATABASETYPE, DB_RDONLY, 0);
#endif


  if(ret != 0)
  {
    /*error opening/creating db send the mess to errh, then exit*/
    printf("error db_open: %s\n", db_strerror(ret));
    exit(1);
  }
}


void ReadFromDBAndPutInFile(FILE *outFile)
{
  pwr_tInt32 ret, sts;
  pwr_tUInt32 nrOfEvents = 0;
  sEvent *eventp;
  DBT data, key;
  DBC *dbcp;
  
  WriteColumnNames(outFile);
  
  /* Acquire a cursor for the database. */ 
  if ((ret = dataBaseP->cursor(dataBaseP, NULL, &dbcp, 0)) != 0) 
  {
    printf("error dataBaseP->cursor: %s\n", db_strerror(ret)); 
    exit(1);
  }

  /* Initialize the key/data return pair. */
  memset(&key, 0, sizeof(key));
  memset(&data, 0, sizeof(data));
  
  if((ret = dbcp->c_get(dbcp, &key, &data, DB_FIRST)) == 0)
  {
    eventp = data.data;
    sts = Write(eventp, outFile);
    nrOfEvents++;
  }
  
  while((ret = dbcp->c_get(dbcp, &key, &data, DB_NEXT)) == 0)
  {
    eventp = data.data;
    sts = Write(eventp, outFile);
    nrOfEvents++;
  }
  if(ret != DB_NOTFOUND)
  {
    printf("error dbcp->c_get: %s\n", db_strerror(ret));
    printf("** Error reading post number %u, terminating\n", nrOfEvents);
    exit(1);
  }
  printf("-- Number of events written to file: %u\n", nrOfEvents);
  /*Close the cursor*/
  if((ret = dbcp->c_close(dbcp)) != 0)
  {
    printf("Error dbcp->c_close(): %s\n", db_strerror(ret));
  }       
}  
  
void WriteColumnNames(FILE *outFile)
{
  col_print(outFile, "Nid");
  col_print(outFile, "BirthTime");
  col_print(outFile, "Idx");
  col_print(outFile, "EventFlags");
  col_print(outFile, "EventTime");
  col_print(outFile, "EventType");
  col_print(outFile, "Prio");
  col_print(outFile, "EventText");
  col_print(outFile, "EventName");
  col_print(outFile, "TargetIdx");
  col_print(outFile, "DetectTime");
  col_print(outFile, "AValue");
  col_print(outFile, "CtrlLimit");
  col_print(outFile, "Hysteres");
  col_print(outFile, "Unit");
  col_print(outFile, "DValue");
  col_print(outFile, "High");
}

int
Write (
  sEvent *sp,
  FILE *outFile
)
{
  switch (sp->EventType) {
  case mh_eEvent_Alarm:
  case mh_eEvent_MaintenanceAlarm:
  case mh_eEvent_SystemAlarm:
  case mh_eEvent_UserAlarm1:
  case mh_eEvent_UserAlarm2:
  case mh_eEvent_UserAlarm3:
  case mh_eEvent_UserAlarm4:
  case mh_eEvent_Info:
    printMess(sp, outFile);
    break;
  case mh_eEvent_Ack:
    printAck(sp, outFile);
    break;
  case mh_eEvent_Cancel:
  case mh_eEvent_Return:
    printRet(sp, outFile);
    break;
  case mh_eEvent_Block:
  case mh_eEvent_Unblock:
  case mh_eEvent_Reblock:
  case mh_eEvent_CancelBlock:
    printBlock(sp, outFile);
    break;
  default:
    printf("rt_elog_dump: Error in Write unknown EventType");
    break;
  }  
  return 1;
}

void
printMess (
  sEvent *sp,
  FILE *outFile
)
{
  new_row( outFile);
  printMsgInfo(&(sp->Mess.message.Info), outFile);


  //EventText
  //Status
  //TargetIdx
  //DetectTime
  //AValue
  //CtrlLimit
  //Hysteres
  //Unit
  //DValue
  //High
  col_print(outFile, "\"%s\"", sp->Mess.message.EventText);
  col_print(outFile, "%s", sp->Mess.message.EventName);
  col_print(outFile,"");
  col_print(outFile,"");
  switch (sp->Mess.message.SupInfo.SupType) {
    case mh_eSupType_Analog:
      col_print(outFile, "%.2f", sp->Mess.message.SupInfo.mh_uSupInfo_u.A.ActualValue);
      col_print(outFile, "%.2f", sp->Mess.message.SupInfo.mh_uSupInfo_u.A.CtrlLimit);
      col_print(outFile, "%.2f", sp->Mess.message.SupInfo.mh_uSupInfo_u.A.Hysteres);
      col_print(outFile, "%s",   sp->Mess.message.SupInfo.mh_uSupInfo_u.A.Unit);
      col_print(outFile,"");
      col_print(outFile, "%u", sp->Mess.message.SupInfo.mh_uSupInfo_u.A.High);
      break;
    case mh_eSupType_Digital:
      col_print(outFile,"");
      col_print(outFile,"");
      col_print(outFile,"");
      col_print(outFile,"");
      col_print(outFile, "%u", sp->Mess.message.SupInfo.mh_uSupInfo_u.D.ActualValue);
      col_print(outFile, "%u", sp->Mess.message.SupInfo.mh_uSupInfo_u.D.High);
      break;
    case mh_eSupType__:  
    case mh_eSupType_None:
    case mh_eSupType_Link:
    case mh_eSupType_:
      break;  
  }
}

void
printAck (
  sEvent *sp,
  FILE *outFile
)
{
  char time_str[40];
  pwr_tTime event_time;
  
  new_row( outFile);
  printMsgInfo(&(sp->Mess.ack.Info), outFile);
  
  //EventText
  //Status
  //TargetIdx
  //DetectTime
  //AValue
  //CtrlLimit
  //Hysteres
  //Unit
  //DValue
  //High

  col_print(outFile,"\"\"");
  col_print(outFile, "%s", sp->Mess.ack.EventName);
  col_print(outFile, "%u", sp->Mess.ack.TargetId.Idx);

  event_time = net_NetTimeToTime(&(sp->Mess.ack.DetectTime));    
  time_AtoAscii(&event_time, time_eFormat_ComprDateAndTime, time_str, sizeof(time_str));
  col_print(outFile, "%s", time_str);

  switch (sp->Mess.ack.SupInfo.SupType) {
    case mh_eSupType_Analog:
      col_print(outFile, "%.2f", sp->Mess.ack.SupInfo.mh_uSupInfo_u.A.ActualValue);
      col_print(outFile, "%.2f", sp->Mess.ack.SupInfo.mh_uSupInfo_u.A.CtrlLimit);
      col_print(outFile, "%.2f", sp->Mess.ack.SupInfo.mh_uSupInfo_u.A.Hysteres);
      col_print(outFile, "%s",   sp->Mess.ack.SupInfo.mh_uSupInfo_u.A.Unit);
      col_print(outFile,"");
      col_print(outFile, "%u", sp->Mess.ack.SupInfo.mh_uSupInfo_u.A.High);
      break;
    case mh_eSupType_Digital:
      col_print(outFile,"");
      col_print(outFile,"");
      col_print(outFile,"");
      col_print(outFile,"");
      col_print(outFile, "%u", sp->Mess.ack.SupInfo.mh_uSupInfo_u.D.ActualValue);
      col_print(outFile, "%u", sp->Mess.ack.SupInfo.mh_uSupInfo_u.D.High);
      break;    
    case mh_eSupType__:  
    case mh_eSupType_None:
    case mh_eSupType_Link:
    case mh_eSupType_:
      break;  
  }
}

void
printRet (
  sEvent *sp,
  FILE *outFile
)
{
  char time_str[40];
  new_row( outFile);
  printMsgInfo(&(sp->Mess.ret.Info), outFile);
  pwr_tTime event_time;
  
  //EventText
  //Status
  //TargetIdx
  //DetectTime
  //AValue
  //CtrlLimit
  //Hysteres
  //Unit
  //DValue
  //High
  col_print(outFile, "\"%s\"", sp->Mess.ret.EventText);
  col_print(outFile, "%s", sp->Mess.ret.EventName);
  col_print(outFile, "%u", sp->Mess.ret.TargetId.Idx);

  event_time = net_NetTimeToTime(&(sp->Mess.ret.DetectTime));    
  time_AtoAscii( &event_time, time_eFormat_ComprDateAndTime, time_str, sizeof(time_str));
  col_print(outFile, "%s", time_str);

  switch (sp->Mess.ret.SupInfo.SupType) {
    case mh_eSupType_Analog:
      col_print(outFile, "%.2f", sp->Mess.ret.SupInfo.mh_uSupInfo_u.A.ActualValue);
      col_print(outFile, "%.2f", sp->Mess.ret.SupInfo.mh_uSupInfo_u.A.CtrlLimit);
      col_print(outFile, "%.2f", sp->Mess.ret.SupInfo.mh_uSupInfo_u.A.Hysteres);
      col_print(outFile, "%s",   sp->Mess.ret.SupInfo.mh_uSupInfo_u.A.Unit);
      col_print(outFile,"");
      col_print(outFile, "%u", sp->Mess.ret.SupInfo.mh_uSupInfo_u.A.High);
      break;
    case mh_eSupType_Digital:
      col_print(outFile,"");
      col_print(outFile,"");
      col_print(outFile,"");
      col_print(outFile,"");
      col_print(outFile, "%u", sp->Mess.ret.SupInfo.mh_uSupInfo_u.D.ActualValue);
      col_print(outFile, "%u", sp->Mess.ret.SupInfo.mh_uSupInfo_u.D.High);
      break;  
    case mh_eSupType__:  
    case mh_eSupType_None:
    case mh_eSupType_Link:
    case mh_eSupType_:
      break;  
  
  }

}

void
printBlock (
  sEvent *sp,
  FILE *outFile
)
{
  char time_str[40];
  pwr_tTime event_time;

  new_row( outFile);
  printMsgInfo(&(sp->Mess.block.Info), outFile);
  //EventText
  //Status
  //TargetIdx
  //DetectTime
  //AValue
  //CtrlLimit
  //Hysteres
  //Unit
  //DValue
  //High
  col_print(outFile, "\"\"");
  col_print(outFile, "%s", sp->Mess.block.EventName);
  col_print(outFile, "%u", sp->Mess.block.TargetId.Idx);

  event_time = net_NetTimeToTime( &(sp->Mess.block.DetectTime));        
  time_AtoAscii(&event_time, time_eFormat_ComprDateAndTime, time_str, sizeof(time_str));
  col_print(outFile, "%s", time_str);
    
  col_print(outFile,"");
  col_print(outFile,"");
  col_print(outFile,"");
  col_print(outFile,"");
  col_print(outFile,"");
  col_print(outFile,"");
}

void
printMsgInfo (
  mh_sMsgInfo *mp,
  FILE *outFile
)
{
  char time_str[40];
  pwr_tTime event_time;
  
  col_print(outFile, "%d", mp->Id.Nix);
  
  event_time = net_NetTimeToTime(&(mp->Id.BirthTime));        
  time_AtoAscii(&event_time, time_eFormat_ComprDateAndTime, time_str, sizeof(time_str));
  col_print(outFile, "%s", time_str);
  
  col_print(outFile, "%d",mp->Id.Idx);
  /*
  sp->Object
  sp->SupObject
  */
  printEventFlags(outFile, mp->EventFlags);

  event_time = net_NetTimeToTime(&(mp->EventTime));      
  time_AtoAscii( &event_time, time_eFormat_ComprDateAndTime, time_str, sizeof(time_str));
  col_print(outFile, "%s", time_str);
  
  // col_print(outFile, "%s",mp->EventName_V3);
  
  convertEventType(mp->EventType, time_str);
  col_print(outFile, "%s", time_str);
  
  convertEventPrio(mp->EventPrio, time_str);
  col_print(outFile, "%s",time_str);
}


void printEventFlags(FILE *outFile, int flags)
{
  char buf[80];

  buf[0] = 0;
  if (flags & mh_mEventFlags_Return)
    strcat( buf, "Return/");
  if(flags & mh_mEventFlags_Ack)
    strcat( buf, "Ack/");
  if(flags & mh_mEventFlags_Bell)
    strcat( buf, "Bell/");
  if(flags & mh_mEventFlags_Force)
    strcat( buf, "Force/");
  if(flags & mh_mEventFlags_InfoWindow)
    strcat( buf, "InfoWind/");
  if(flags & mh_mEventFlags_Returned)
    strcat( buf, "Returned/");
  if(flags & mh_mEventFlags_NoObject)
    strcat( buf, "NoObject/");
  /* Remove last / */
  if ( strlen(buf) > 0)
    buf[strlen(buf)-1] = 0;
  else
    strcpy( buf, "-");

  col_print(outFile, "%s", buf);
}



void convertEventType(int type, char *ret)
{
  switch (type) {
  case mh_eEvent_Alarm:
    strcpy(ret, "Alarm");
    break;
  case mh_eEvent_MaintenanceAlarm:
    strcpy(ret, "MaintenanceAlarm");
    break;
  case mh_eEvent_SystemAlarm:
    strcpy(ret, "SystemAlarm");
    break;
  case mh_eEvent_UserAlarm1:
    strcpy(ret, "UserAlarm1");
    break;
  case mh_eEvent_UserAlarm2:
    strcpy(ret, "UserAlarm2");
    break;
  case mh_eEvent_UserAlarm3:
    strcpy(ret, "UserAlarm3");
    break;
  case mh_eEvent_UserAlarm4:
    strcpy(ret, "UserAlarm4");
    break;
  case mh_eEvent_Info:
    strcpy(ret, "Info");
    break;
  case mh_eEvent_Ack:
    strcpy(ret, "Ack");
    break;
  case mh_eEvent_Cancel:
    strcpy(ret, "Cancel");
    break;
  case mh_eEvent_Return:
    strcpy(ret, "Return");
    break;
  case mh_eEvent_Block:
    strcpy(ret, "Block");
    break;
  case mh_eEvent_Unblock:
    strcpy(ret, "Unblock");
    break;
  case mh_eEvent_Reblock:
    strcpy(ret, "Reblock");
    break;
  case mh_eEvent_CancelBlock:
    strcpy(ret, "CancelBlock");
    break;
  default:
    strcpy(ret, " ");
    break;
  }
}  

void convertEventPrio(int prio, char *ret)
{
  switch (prio) {
  case mh_eEventPrio_A:
    strcpy(ret, "A");
    break;
  case mh_eEventPrio_B:
    strcpy(ret, "B");
    break;
  case mh_eEventPrio_C:
    strcpy(ret, "C");
    break;
  case mh_eEventPrio_D:
    strcpy(ret, "D");
    break;
  default:
    strcpy(ret, "-");
    break;
  }
}  

