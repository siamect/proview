/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 **/

/* rt_elog_dump.c -- <short description>

   Author Jonas Nylund.

   Dumps the rt_eventlog.db to a file.
   If the eventlog doesn't exist a errormess will appear.
   */

#include <stdarg.h>

#include "co_string.h"

#include "rt_elog.h"

void ReadFromDBAndPutInFile(FILE* outFile);

void Init(char* fname);

void WriteColumnNames(FILE* outFile);

int Write(sEvent* sp, FILE* outFile);

void printMess(sEvent* sp, FILE* outFile);
void printAck(sEvent* sp, FILE* outFile);
void printRet(sEvent* sp, FILE* outFile);
void printBlock(sEvent* sp, FILE* outFile);
void printMsgInfo(mh_sMsgInfo* mp, FILE* outFile);

void printEventFlags(FILE* outFile, int flags);

void convertEventType(int type, char* ret);

void convertEventPrio(int prio, char* ret);

DB* dataBaseP = NULL;
static int current_pos = 0;
static int current_col = 0;
// static int cols[] = {8, 22, 8, 22, 22, 17, 3, 40, 40, 8, 22, 8, 2, 8, 8, 8,
// 1};
static int cols[] = { 8, 30, 38, 60, 82, 99, 102, 142, 182, 190, 202, 210, 212,
  220, 228, 236, 237 };

void usage()
{
  printf("\n"
         "  rt_elog_dump   Dump eventlog to text file\n"
         "\n"
         "  > rt_elog_dump [database] [dumpfile]\n"
         "\n"
         "           database      Database file, default " DATABASE "\n\n"
         "           dumpfile      Name of dumpfile, default " DUMPFILE "\n\n");
}

void new_row(FILE* fp)
{
  current_col = 0;
  current_pos = 0;

  fprintf(fp, "\n");
}

int col_print(FILE* fp, char* format, ...)
{
  va_list ap;
  int i;
  char buf[200];
  int sts;
  int incr;

  va_start(ap, format);
  sts = vsprintf(buf, format, ap);
  va_end(ap);

  fprintf(fp, "%s", buf);
  current_pos += strlen(buf);

  incr = 0;
  for (i = 0; i < cols[current_col] - current_pos - 1; i++) {
    incr++;
    fprintf(fp, " ");
  }
  fprintf(fp, " ");
  incr++;
  current_pos += incr;
  current_col++;

  return sts;
}

int main(int argc, char* argv[])
{
  FILE* outFile = NULL;
  pwr_tInt32 ret;

  if (argc > 1
      && (streq(argv[1], "-h") || streq(argv[1], "--help"))) {
    usage();
    exit(0);
  }

  if (argc == 3) {
    if (argv[2] != NULL)
      outFile = fopen(argv[2], "w");
  } else
    outFile = fopen(DUMPFILE, "w");

  if (outFile == NULL) {
    printf("** Unable to open file, terminating\n");
    exit(1);
  }
  if (argc > 1)
    Init(argv[1]);
  else
    Init(DATABASE);
  ReadFromDBAndPutInFile(outFile);
  new_row(outFile);
  fclose(outFile);
  if ((ret = dataBaseP->close(dataBaseP, 0) != 0)) {
    printf("error db_close: %s\n", db_strerror(ret));
  }
  if (argc == 3)
    printf("-- Dumpfile successfully created, %s\n", argv[2]);
  else
    printf("-- Dumpfile successfully created, %s\n", DUMPFILE);
  return 0;
}

void Init(char* fname)
{
  pwr_tInt32 ret;
  char dbName[200];

  dcli_translate_filename(dbName, fname);

  /*create the database if it's not already created*/
  if ((ret = db_create(&dataBaseP, NULL, 0)) != 0) {
    /*error creating db-handle send the mess to errh, then exit*/
    printf("error db_create: %s\n", db_strerror(ret));
    printf("** Error when creating db handle, terminating\n");
    exit(1);
  }

#if (DB_VERSION_MAJOR > 3) && (DB_VERSION_MINOR > 0)
  ret = dataBaseP->open(
      dataBaseP, NULL, dbName, NULL, DATABASETYPE, DB_RDONLY, 0);
#else
  ret = dataBaseP->open(dataBaseP, dbName, NULL, DATABASETYPE, DB_RDONLY, 0);
#endif

  if (ret != 0) {
    /*error opening/creating db send the mess to errh, then exit*/
    printf("error db_open: %s\n", db_strerror(ret));
    exit(1);
  }
}

void ReadFromDBAndPutInFile(FILE* outFile)
{
  pwr_tInt32 ret, sts;
  pwr_tUInt32 nrOfEvents = 0;
  sEvent* eventp;
  DBT data, key;
  DBC* dbcp;

  WriteColumnNames(outFile);

  /* Acquire a cursor for the database. */
  if ((ret = dataBaseP->cursor(dataBaseP, NULL, &dbcp, 0)) != 0) {
    printf("error dataBaseP->cursor: %s\n", db_strerror(ret));
    exit(1);
  }

  /* Initialize the key/data return pair. */
  memset(&key, 0, sizeof(key));
  memset(&data, 0, sizeof(data));

  if ((ret = dbcp->c_get(dbcp, &key, &data, DB_FIRST)) == 0) {
    eventp = data.data;
    sts = Write(eventp, outFile);
    nrOfEvents++;
  }

  while ((ret = dbcp->c_get(dbcp, &key, &data, DB_NEXT)) == 0) {
    eventp = data.data;
    sts = Write(eventp, outFile);
    nrOfEvents++;
  }
  if (ret != DB_NOTFOUND) {
    printf("error dbcp->c_get: %s\n", db_strerror(ret));
    printf("** Error reading post number %u, terminating\n", nrOfEvents);
    exit(1);
  }
  printf("-- Number of events written to file: %u\n", nrOfEvents);
  /*Close the cursor*/
  if ((ret = dbcp->c_close(dbcp)) != 0) {
    printf("Error dbcp->c_close(): %s\n", db_strerror(ret));
  }
}

void WriteColumnNames(FILE* outFile)
{
  col_print(outFile, "Nid");
  col_print(outFile, "BirthTime");
  col_print(outFile, "Idx");
  col_print(outFile, "EventFlags");
  col_print(outFile, "EventTime");
  col_print(outFile, "EventType");
  col_print(outFile, "Prio");
  col_print(outFile, "EventText");
  col_print(outFile, "EventName");
  col_print(outFile, "TargetIdx");
  col_print(outFile, "DetectTime");
  col_print(outFile, "AValue");
  col_print(outFile, "CtrlLimit");
  col_print(outFile, "Hysteres");
  col_print(outFile, "Unit");
  col_print(outFile, "DValue");
  col_print(outFile, "High");
}

int Write(sEvent* sp, FILE* outFile)
{
  switch (sp->EventType) {
  case mh_eEvent_Alarm:
  case mh_eEvent_MaintenanceAlarm:
  case mh_eEvent_SystemAlarm:
  case mh_eEvent_UserAlarm1:
  case mh_eEvent_UserAlarm2:
  case mh_eEvent_UserAlarm3:
  case mh_eEvent_UserAlarm4:
  case mh_eEvent_Info:
    printMess(sp, outFile);
    break;
  case mh_eEvent_Ack:
    printAck(sp, outFile);
    break;
  case mh_eEvent_Cancel:
  case mh_eEvent_Return:
    printRet(sp, outFile);
    break;
  case mh_eEvent_Block:
  case mh_eEvent_Unblock:
  case mh_eEvent_Reblock:
  case mh_eEvent_CancelBlock:
    printBlock(sp, outFile);
    break;
  default:
    printf("rt_elog_dump: Error in Write unknown EventType");
    break;
  }
  return 1;
}

void printMess(sEvent* sp, FILE* outFile)
{
  new_row(outFile);
  printMsgInfo(&(sp->Mess.message.Info), outFile);

  // EventText
  // Status
  // TargetIdx
  // DetectTime
  // AValue
  // CtrlLimit
  // Hysteres
  // Unit
  // DValue
  // High
  col_print(outFile, "\"%s\"", sp->Mess.message.EventText);
  col_print(outFile, "%s", sp->Mess.message.EventName);
  col_print(outFile, "");
  col_print(outFile, "");
  switch (sp->Mess.message.SupInfo.SupType) {
  case mh_eSupType_Analog:
    col_print(
        outFile, "%.2f", sp->Mess.message.SupInfo.mh_uSupInfo_u.A.ActualValue);
    col_print(
        outFile, "%.2f", sp->Mess.message.SupInfo.mh_uSupInfo_u.A.CtrlLimit);
    col_print(
        outFile, "%.2f", sp->Mess.message.SupInfo.mh_uSupInfo_u.A.Hysteres);
    col_print(outFile, "%s", sp->Mess.message.SupInfo.mh_uSupInfo_u.A.Unit);
    col_print(outFile, "");
    col_print(outFile, "%u", sp->Mess.message.SupInfo.mh_uSupInfo_u.A.High);
    break;
  case mh_eSupType_Digital:
    col_print(outFile, "");
    col_print(outFile, "");
    col_print(outFile, "");
    col_print(outFile, "");
    col_print(
        outFile, "%u", sp->Mess.message.SupInfo.mh_uSupInfo_u.D.ActualValue);
    col_print(outFile, "%u", sp->Mess.message.SupInfo.mh_uSupInfo_u.D.High);
    break;
  case mh_eSupType__:
  case mh_eSupType_None:
  case mh_eSupType_Link:
  case mh_eSupType_:
    break;
  }
}

void printAck(sEvent* sp, FILE* outFile)
{
  char time_str[40];
  pwr_tTime event_time;

  new_row(outFile);
  printMsgInfo(&(sp->Mess.ack.Info), outFile);

  // EventText
  // Status
  // TargetIdx
  // DetectTime
  // AValue
  // CtrlLimit
  // Hysteres
  // Unit
  // DValue
  // High

  col_print(outFile, "\"\"");
  col_print(outFile, "%s", sp->Mess.ack.EventName);
  col_print(outFile, "%u", sp->Mess.ack.TargetId.Idx);

  event_time = net_NetTimeToTime(&(sp->Mess.ack.DetectTime));
  time_AtoAscii(
      &event_time, time_eFormat_ComprDateAndTime, time_str, sizeof(time_str));
  col_print(outFile, "%s", time_str);

  switch (sp->Mess.ack.SupInfo.SupType) {
  case mh_eSupType_Analog:
    col_print(
        outFile, "%.2f", sp->Mess.ack.SupInfo.mh_uSupInfo_u.A.ActualValue);
    col_print(outFile, "%.2f", sp->Mess.ack.SupInfo.mh_uSupInfo_u.A.CtrlLimit);
    col_print(outFile, "%.2f", sp->Mess.ack.SupInfo.mh_uSupInfo_u.A.Hysteres);
    col_print(outFile, "%s", sp->Mess.ack.SupInfo.mh_uSupInfo_u.A.Unit);
    col_print(outFile, "");
    col_print(outFile, "%u", sp->Mess.ack.SupInfo.mh_uSupInfo_u.A.High);
    break;
  case mh_eSupType_Digital:
    col_print(outFile, "");
    col_print(outFile, "");
    col_print(outFile, "");
    col_print(outFile, "");
    col_print(outFile, "%u", sp->Mess.ack.SupInfo.mh_uSupInfo_u.D.ActualValue);
    col_print(outFile, "%u", sp->Mess.ack.SupInfo.mh_uSupInfo_u.D.High);
    break;
  case mh_eSupType__:
  case mh_eSupType_None:
  case mh_eSupType_Link:
  case mh_eSupType_:
    break;
  }
}

void printRet(sEvent* sp, FILE* outFile)
{
  char time_str[40];
  new_row(outFile);
  printMsgInfo(&(sp->Mess.ret.Info), outFile);
  pwr_tTime event_time;

  // EventText
  // Status
  // TargetIdx
  // DetectTime
  // AValue
  // CtrlLimit
  // Hysteres
  // Unit
  // DValue
  // High
  col_print(outFile, "\"%s\"", sp->Mess.ret.EventText);
  col_print(outFile, "%s", sp->Mess.ret.EventName);
  col_print(outFile, "%u", sp->Mess.ret.TargetId.Idx);

  event_time = net_NetTimeToTime(&(sp->Mess.ret.DetectTime));
  time_AtoAscii(
      &event_time, time_eFormat_ComprDateAndTime, time_str, sizeof(time_str));
  col_print(outFile, "%s", time_str);

  switch (sp->Mess.ret.SupInfo.SupType) {
  case mh_eSupType_Analog:
    col_print(
        outFile, "%.2f", sp->Mess.ret.SupInfo.mh_uSupInfo_u.A.ActualValue);
    col_print(outFile, "%.2f", sp->Mess.ret.SupInfo.mh_uSupInfo_u.A.CtrlLimit);
    col_print(outFile, "%.2f", sp->Mess.ret.SupInfo.mh_uSupInfo_u.A.Hysteres);
    col_print(outFile, "%s", sp->Mess.ret.SupInfo.mh_uSupInfo_u.A.Unit);
    col_print(outFile, "");
    col_print(outFile, "%u", sp->Mess.ret.SupInfo.mh_uSupInfo_u.A.High);
    break;
  case mh_eSupType_Digital:
    col_print(outFile, "");
    col_print(outFile, "");
    col_print(outFile, "");
    col_print(outFile, "");
    col_print(outFile, "%u", sp->Mess.ret.SupInfo.mh_uSupInfo_u.D.ActualValue);
    col_print(outFile, "%u", sp->Mess.ret.SupInfo.mh_uSupInfo_u.D.High);
    break;
  case mh_eSupType__:
  case mh_eSupType_None:
  case mh_eSupType_Link:
  case mh_eSupType_:
    break;
  }
}

void printBlock(sEvent* sp, FILE* outFile)
{
  char time_str[40];
  pwr_tTime event_time;

  new_row(outFile);
  printMsgInfo(&(sp->Mess.block.Info), outFile);
  // EventText
  // Status
  // TargetIdx
  // DetectTime
  // AValue
  // CtrlLimit
  // Hysteres
  // Unit
  // DValue
  // High
  col_print(outFile, "\"\"");
  col_print(outFile, "%s", sp->Mess.block.EventName);
  col_print(outFile, "%u", sp->Mess.block.TargetId.Idx);

  event_time = net_NetTimeToTime(&(sp->Mess.block.DetectTime));
  time_AtoAscii(
      &event_time, time_eFormat_ComprDateAndTime, time_str, sizeof(time_str));
  col_print(outFile, "%s", time_str);

  col_print(outFile, "");
  col_print(outFile, "");
  col_print(outFile, "");
  col_print(outFile, "");
  col_print(outFile, "");
  col_print(outFile, "");
}

void printMsgInfo(mh_sMsgInfo* mp, FILE* outFile)
{
  char time_str[40];
  pwr_tTime event_time;

  col_print(outFile, "%d", mp->Id.Nix);

  event_time = net_NetTimeToTime(&(mp->Id.BirthTime));
  time_AtoAscii(
      &event_time, time_eFormat_ComprDateAndTime, time_str, sizeof(time_str));
  col_print(outFile, "%s", time_str);

  col_print(outFile, "%d", mp->Id.Idx);
  /*
  sp->Object
  sp->SupObject
  */
  printEventFlags(outFile, mp->EventFlags);

  event_time = net_NetTimeToTime(&(mp->EventTime));
  time_AtoAscii(
      &event_time, time_eFormat_ComprDateAndTime, time_str, sizeof(time_str));
  col_print(outFile, "%s", time_str);

  // col_print(outFile, "%s",mp->EventName_V3);

  convertEventType(mp->EventType, time_str);
  col_print(outFile, "%s", time_str);

  convertEventPrio(mp->EventPrio, time_str);
  col_print(outFile, "%s", time_str);
}

void printEventFlags(FILE* outFile, int flags)
{
  char buf[80];

  buf[0] = 0;
  if (flags & mh_mEventFlags_Return)
    strcat(buf, "Return/");
  if (flags & mh_mEventFlags_Ack)
    strcat(buf, "Ack/");
  if (flags & mh_mEventFlags_Bell)
    strcat(buf, "Bell/");
  if (flags & mh_mEventFlags_Force)
    strcat(buf, "Force/");
  if (flags & mh_mEventFlags_InfoWindow)
    strcat(buf, "InfoWind/");
  if (flags & mh_mEventFlags_Returned)
    strcat(buf, "Returned/");
  if (flags & mh_mEventFlags_NoObject)
    strcat(buf, "NoObject/");
  /* Remove last / */
  if (strlen(buf) > 0)
    buf[strlen(buf) - 1] = 0;
  else
    strcpy(buf, "-");

  col_print(outFile, "%s", buf);
}

void convertEventType(int type, char* ret)
{
  switch (type) {
  case mh_eEvent_Alarm:
    strcpy(ret, "Alarm");
    break;
  case mh_eEvent_MaintenanceAlarm:
    strcpy(ret, "MaintenanceAlarm");
    break;
  case mh_eEvent_SystemAlarm:
    strcpy(ret, "SystemAlarm");
    break;
  case mh_eEvent_UserAlarm1:
    strcpy(ret, "UserAlarm1");
    break;
  case mh_eEvent_UserAlarm2:
    strcpy(ret, "UserAlarm2");
    break;
  case mh_eEvent_UserAlarm3:
    strcpy(ret, "UserAlarm3");
    break;
  case mh_eEvent_UserAlarm4:
    strcpy(ret, "UserAlarm4");
    break;
  case mh_eEvent_Info:
    strcpy(ret, "Info");
    break;
  case mh_eEvent_Ack:
    strcpy(ret, "Ack");
    break;
  case mh_eEvent_Cancel:
    strcpy(ret, "Cancel");
    break;
  case mh_eEvent_Return:
    strcpy(ret, "Return");
    break;
  case mh_eEvent_Block:
    strcpy(ret, "Block");
    break;
  case mh_eEvent_Unblock:
    strcpy(ret, "Unblock");
    break;
  case mh_eEvent_Reblock:
    strcpy(ret, "Reblock");
    break;
  case mh_eEvent_CancelBlock:
    strcpy(ret, "CancelBlock");
    break;
  default:
    strcpy(ret, " ");
    break;
  }
}

void convertEventPrio(int prio, char* ret)
{
  switch (prio) {
  case mh_eEventPrio_A:
    strcpy(ret, "A");
    break;
  case mh_eEventPrio_B:
    strcpy(ret, "B");
    break;
  case mh_eEventPrio_C:
    strcpy(ret, "C");
    break;
  case mh_eEventPrio_D:
    strcpy(ret, "D");
    break;
  default:
    strcpy(ret, "-");
    break;
  }
}
