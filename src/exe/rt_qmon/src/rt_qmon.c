/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2020 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_qmon.c -- Qcom monitor. */

#include <errno.h>
#include <sched.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>

#include "co_string.h"
#include "co_tree.h"
#include "co_timelog.h"

#include "rt_qdb.h"
#include "rt_net.h"
#include "rt_que.h"
#include "rt_proc.h"
#include "rt_thread_msg.h"
#include "rt_pwr_msg.h"
#include "rt_ini_event.h"
#include "rt_qmon.h"

#define RTT_RXMIN 0.0500 /* seconds */
#define RTT_RXMAX 10.000 /* seconds */
#define EXPORT_BUF_WARN_LEVEL 300000
#define EXPORT_BUF_QUOTA 600000
//#define IS_SECONDARY_NID(nid) ((nid)&0x80000000)
#define SECONDARY_NID(nid) ((nid) | 0x80000000)
#define NID_LIX(nid) (((nid)&0x80000000) ? 1 : 0)
#define NID(nid) ((nid)&0x7fffffff)

typedef enum {
  eAction__ = 0,
  eAction_export,
  eAction_import,
  eAction_tmo,
  eAction_
} eAction;

typedef union {
  pwr_tBitMask m;
  pwr_32Bits(pwr_Bits(version, 3), , , pwr_Bits(first, 1), pwr_Bits(middle, 1),
      pwr_Bits(last, 1), pwr_Bits(fill_0, 2), ,

      pwr_Bits(bcast, 1), pwr_Bits(resent, 1), pwr_Bits(fill_1, 6), , , , , ,
      pwr_Bits(fill_2, 8), , , , , , , , pwr_Bits(event, 8), , , , , , , ) b;

#define mSeg_first pwr_Bit(3)
#define mSeg_middle pwr_Bit(4)
#define mSeg_last pwr_Bit(5)
#define mSeg_single (mSeg_first | mSeg_middle | mSeg_last)
} mSeg;

typedef struct sLink sLink;
typedef struct sHead sHead;
typedef struct sCseg sCseg;
typedef struct sEseg sEseg;
typedef struct sIseg sIseg;

struct sHead {
  pwr_tNodeId nid pwr_dPacked; /* Node identitiy. */
  int birth pwr_dPacked; /* Time when link was born. */
  mSeg flags pwr_dPacked;
  qdb_sAck lack;
  qdb_sAck rack;
};

struct sCseg {
  eAction action;
  lst_sEntry le;
};

struct sEseg {
  sCseg c;
  sHead head;
  unsigned int size;
  sLink* lp;
  lst_sEntry le_bcast;
  lst_sEntry le_seg;
  unsigned int id;
  qdb_sBuffer* bp;
  char* p;
  int bytes;
  pwr_tTime tmo;
  int sent;
  pwr_tTime send_ts;
};

struct sIseg {
  sCseg c;
  sHead head;
  unsigned int size;
  int ts_recv;
  sLink* lp;
  pwr_tStatus sts;
  char buff[1];
};

typedef union {
  eAction action;
  sCseg c;
  sEseg e;
  sIseg i;
} uSeg;

struct sLink {
  tree_sNode tree;
  pwr_tNodeId nid;
  pwr_tNodeId rnid;
  unsigned int lix;
  lst_sEntry lh_send;
  lst_sEntry lh_win;
  que_sQue q_in;
  qdb_sNode* np;
  thread_s thread;
  qdb_sBuffer* bp;
  char* p;
  pwr_tDeltaTime ack_delay;
  unsigned int exp_buf_quota;
  sIseg tmo;
  thread_sMutex eseg_mutex;
};

typedef struct {
  sHead head;
  qdb_sInfo info;
  struct sockaddr_in sa;
  struct iovec iov[3];
  struct msghdr msg;
} sMsg;

typedef enum {
  eEvent__ = 0,
  eEvent_connect,
  eEvent_down,
  eEvent_user,
  eEvent_ack,
  eEvent_connectPassive,
  eEvent_redcomActive,
  eEvent_redcomPassive,
  eEvent_
} eEvent;

struct {
  sHead head;
  struct sockaddr_in sa;
  int sock;
  struct {
    lst_sEntry lh;
    thread_sMutex mutex;
    int count;
  } eseg;
  struct {
    lst_sEntry lh;
    thread_sMutex mutex;
    int count;
  } iseg;
  struct {
    int count;
    tree_sTable* table;
    thread_sMutex mutex;
  } links;
  thread_sMutex bcast;
  thread_sMutex send_mutex;
  struct {
    thread_s thread;
    thread_sMutex mutex;
    thread_sCond cond;
  } import;
  struct {
    thread_s thread;
  } export;
  struct {
    thread_s thread;
  } action;
  qdb_sLinkInfo link_info;
  pwr_tStatus sts;
  qcom_sQid action_qid;
} l;

static pwr_tStatus qcom_sts = PWR__SRVSTARTUP;
static int tics_per_sec = 0;
static unsigned int qcom_segment_size = 8192 - sizeof(sHead);

static void cancel_links();
static pwr_tBoolean clean_insert(lst_sEntry*, sEseg*, pwr_tBoolean);
static sEseg* create_connect(sLink*);
static void create_links();
static void decode_head(sHead*, sHead*);
static void decode_info(qdb_sInfo*);
static void encode_head(sHead*, sHead*);
static void encode_info(qdb_sInfo*, qdb_sInfo*);
static sEseg* eseg_alloc(thread_sMutex*);
static sEseg* eseg_build(qdb_sBuffer*);
static void eseg_free(sEseg*);
static char* event_string(eEvent);
static pwr_tBoolean expired(pwr_tTime*);
static void* export_thread();
static sLink* get_link(pwr_tNodeId, sMsg*);
static void get_tmo(sLink*, pwr_tBoolean, pwr_tTime*);
static void* import_thread();
static void ini_link_info(qdb_sLinkInfo*);
static sIseg* iseg_alloc();
static void iseg_free(sIseg*);
static void iseg_import(sLink*, sIseg*);
static void lack(sLink*, sIseg*);
static void link_active(sLink*);
static void link_connect(sLink*, sIseg*);
static void link_purge(sLink*);
static void link_disconnect(sLink*);
static void link_import(sLink*, sIseg*);
static void link_redisconnect(sLink*);
static void link_send(sLink*);
static void link_stalled(sLink*);
static void link_redcom_active(sLink*, sIseg*);
static void link_redcom_passive(sLink*, sIseg*);
static void* link_thread(sLink*);
static pwr_tDeltaTime* link_tmo(sLink*);
static sLink* new_link(pwr_tNodeId, sMsg*);
static void open_socket();
static sEseg* pending_send(sLink*);
static void send_ack(sLink*);
static void set_link_info(sLink*, qdb_sLinkInfo*);
static void set_rack(sLink*, sIseg*);
static void set_recvmsg(sIseg*, sMsg*);
static void seg_send(sLink*, sEseg*);
static void set_sendmsg(sLink*, sEseg*, sMsg*);
static void start_rto(sLink*);
static void update_rtt(sLink*, sEseg*);
static void window_insert(sLink*, sEseg*);
static void window_remove(sLink*, sEseg*);
static sEseg* window_tmo(sLink*);
static void check_link_status();
static void set_status(pwr_tStatus);
static void purge(void);
static void* action_thread();
static sEseg* send_action(sLink*, qmon_eMsgTypeAction);

int main(int argc, char* argv[])
{
  pwr_tStatus sts;
  qcom_sQid qid = qdb_cQexport;
  qcom_sQid neth_qid;
  qcom_sQid my_q = qcom_cNQid;
  int noneth = 0;
  qcom_sQattr qattr;

  /* Vänta en stund ... */
  //  sleep(5);

  if (argc > 1 && streq(argv[1], "-n"))
    noneth = 1;

  /* Wait for scheduler to be set */
  proc_SchedWait();

  errh_Init("pwr_qmon", errh_eAnix_qmon);
  errh_SetStatus(PWR__SRVSTARTUP);

  if (!qcom_Init(&sts, NULL, "pwr_qmon")) {
    errh_Fatal("qcom_Init, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  qcom_segment_size = qdb->my_node->link[0].seg_size - sizeof(sHead);
  if (qcom_segment_size == 0)
    qcom_segment_size = 8192 - sizeof(sHead);

  if (!qcom_CreateQ(&sts, &my_q, NULL, "events")) {
    errh_Fatal("qcom_CreateQ, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  qattr.type = qcom_eQtype_private;
  qattr.quota = 1000;
  l.action_qid.qix = qcom_cImonAction;
  l.action_qid.nid = 0;
  if (!qcom_CreateQ(&sts, &l.action_qid, &qattr, "Action")) {
    qcom_DeleteQ(&sts, &l.action_qid);
    if (!qcom_CreateQ(&sts, &l.action_qid, &qattr, "Action")) {
      errh_Fatal("qcom_CreateQ, %m", sts);
      errh_SetStatus(PWR__SRVTERM);
      exit(sts);
    }
  }

  if (!qcom_AttachQ(&sts, &qid)) {
    errh_Fatal("qcom_AttachQ, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }
  l.head.nid = qdb->my_node->nid;
  l.head.birth = qdb->my_node->link[0].birth = time_Clock(NULL, NULL);
  ini_link_info(&l.link_info);

  neth_qid.qix = net_cProcHandler;
  neth_qid.nid = qcom_cNNid;

  if (!noneth) {
    for (;;) {
      qdb_sQue* qp = NULL;

      qdb_ScopeLock
      {
        qp = qdb_Que(NULL, &neth_qid, NULL);
      }
      qdb_ScopeUnlock;

      if (qp != NULL)
        break;

      errh_Info("Waiting for Nethandler to start...");
      sleep(1);
    }
  }

  do {
    lst_Init(NULL, &l.eseg.lh, NULL);
    lst_Init(NULL, &l.iseg.lh, NULL);
    open_socket();
    sts = thread_MutexInit(&l.eseg.mutex);
    sts = thread_MutexInit(&l.iseg.mutex);
    sts = thread_MutexInit(&l.links.mutex);
    sts = thread_MutexInit(&l.bcast);
    sts = thread_MutexInit(&l.send_mutex);
    sts = thread_MutexInit(&l.import.mutex);
    sts = thread_CondInit(&l.import.cond);

    l.links.table = tree_CreateTable(&sts, sizeof(pwr_tNodeId),
        offsetof(sLink, nid), sizeof(sLink), 100, tree_Comp_nid);

    create_links();

    thread_Create(&l.import.thread, "import", import_thread, NULL);
    thread_Create(&l.export.thread, "export", export_thread, NULL);
    thread_Create(&l.action.thread, "action", action_thread, NULL);

  } while (0);

  check_link_status();
  set_status(PWR__SRUN);

  qcom_WaitAnd(
      &sts, &my_q, &qcom_cQini, ini_mEvent_terminate, qcom_cTmoEternal);

  //  sts = thread_Wait(NULL);	/* Wait forever */

  set_status(PWR__SRVTERM);
  errh_Info("Closing down, %m", sts);
  cancel_links();
  thread_Cancel(&l.import.thread);
  thread_Cancel(&l.export.thread);

  qcom_Exit(&sts);
  errh_Info("Exiting");
  exit(QCOM__SUCCESS);
}

static int export_alloc_check(sLink* lp)
{
  if (lp->np->link[lp->lix].export_alloc_cnt > EXPORT_BUF_WARN_LEVEL
      && qcom_sts != QCOM__BUFFHIGH)
    set_status(QCOM__BUFFHIGH);
  if (lp->np->link[lp->lix].export_alloc_cnt > lp->exp_buf_quota) {
    link_purge(lp);
    return 1;
  }
  return 0;
}

static void export_alloc_sub(sEseg* sp)
{
  if (!sp || !sp->lp)
    return;

  sp->lp->np->link[sp->lp->lix].export_alloc_cnt -= sp->size;
  if (sp->lp->np->link[sp->lp->lix].export_alloc_cnt < 0)
    sp->lp->np->link[sp->lp->lix].export_alloc_cnt = 0;
  if (qcom_sts == QCOM__BUFFHIGH
      && sp->lp->np->link[sp->lp->lix].export_alloc_cnt < EXPORT_BUF_WARN_LEVEL)
    set_status(PWR__SRUN);
}

static void cancel_links()
{
  pwr_tStatus sts;
  sLink* lp;

  for (lp = tree_Minimum(&sts, l.links.table); lp != NULL;
       lp = tree_Successor(&sts, l.links.table, lp))
    thread_Cancel(&lp->thread);
}

/* Free unsent segments from que that has not been
   sent which will be replaced by new segment  */

static pwr_tBoolean clean_insert(
    lst_sEntry* le, sEseg* esp, pwr_tBoolean pending)
{
  lst_sEntry *se, *li;
  sEseg *sp, *nsp;
  pwr_tBoolean ret_pend = FALSE;
  pwr_tBoolean first = FALSE;

  li = le;
  if (esp->bp != NULL) {
    if (esp->bp->b.msg_id > 0) {
      if ((!pending) && (esp->head.flags.b.first)) {
        thread_MutexLock(&esp->lp->eseg_mutex);
        for (sp = lst_Succ(NULL, le, &se); se != le; sp = nsp) {
          li = se;
          nsp = lst_Succ(NULL, se, &se);

          if (sp->bp != NULL) {
            if (sp->bp->b.msg_id == esp->bp->b.msg_id) {
              if (sp->head.flags.b.first)
                first = TRUE;
              if (first) {
                eseg_free(sp);
                li = se;
              } else {
                // break;
              }
            } else if (first) {
              break;
            }
          } else if (first) {
            break;
          }
        }
        thread_MutexUnlock(&esp->lp->eseg_mutex);

        if (!esp->head.flags.b.last && first)
          ret_pend = TRUE;
        if (!first)
          li = le;
      } else if (pending) {
        thread_MutexLock(&esp->lp->eseg_mutex);
        for (sp = lst_Succ(NULL, le, &se); se != le; sp = nsp) {
          li = se;
          nsp = lst_Succ(NULL, se, &se);

          if (sp->bp != NULL) {
            if ((sp->bp->b.msg_id == esp->bp->b.msg_id)
                && (sp->bp == esp->bp)) {
              first = TRUE;
              li = se;
            } else if (first) {
              break;
            }
          } else if (first) {
            break;
          }
        }
        thread_MutexUnlock(&esp->lp->eseg_mutex);

        if (!first)
          li = le;
        ret_pend = !esp->head.flags.b.last;
      }
    }
  }

  /* Insert new item */
  thread_MutexLock(&esp->lp->eseg_mutex);
  lst_InsertPred(NULL, li, &esp->c.le, esp);
  thread_MutexUnlock(&esp->lp->eseg_mutex);

  return ret_pend;
}

static sEseg* create_connect(sLink* lp)
{
  sEseg* sp;

  sp = eseg_alloc(&l.eseg.mutex);
  if (qdb->my_node->redundancy_state == pwr_eRedundancyState_Passive
      || qdb->my_node->redundancy_state == pwr_eRedundancyState_Init) {
    sp->head.flags.b.event = eEvent_connectPassive;
    timelog(1, "qmon sending connect Passive");
  } else {
    sp->head.flags.b.event = eEvent_connect;
    timelog(1, "qmon sending connect");
  }
  sp->lp = lp;
  sp->c.action = eAction_export;

  return sp;
}

static void create_links()
{
  pwr_tStatus sts;
  pool_sQlink* nl;
  qdb_sNode* np;
  sLink* lp;

  qdb_ScopeLock
  {
    for (nl = pool_Qsucc(NULL, &qdb->pool, &qdb->g->node_lh);
         nl != &qdb->g->node_lh; nl = pool_Qsucc(NULL, &qdb->pool, nl)) {
      np = pool_Qitem(nl, qdb_sNode, node_ll);
      if (np == qdb->my_node)
        continue;
      if (np == qdb->no_node)
        continue;
      tree_Insert(&sts, l.links.table, &np->nid);
      if (np->link_cnt > 1) {
        pwr_tNodeId nid = SECONDARY_NID(np->nid);
        tree_Insert(&sts, l.links.table, &nid);
      }
    }
  }
  qdb_ScopeUnlock;

  for (lp = tree_Minimum(&sts, l.links.table); lp != NULL;
       lp = tree_Successor(&sts, l.links.table, lp))
    new_link(lp->nid, NULL);
}

static void decode_head(sHead* tp, sHead* sp)
{
  tp->nid = ntohl(sp->nid);
  tp->birth = ntohl(sp->birth);
  tp->flags.m = ntohl(sp->flags.m);
  tp->lack.seq = ntohl(sp->lack.seq);
  tp->lack.ts = ntohl(sp->lack.ts);
  tp->rack.seq = ntohl(sp->rack.seq);
  tp->rack.ts = ntohl(sp->rack.ts);
}

static void decode_info(qdb_sInfo* ip)
{
  ip->sender.aix = ntohl(ip->sender.aix);
  ip->sender.nid = ntohl(ip->sender.nid);
  ip->pid = ntohl(ip->pid);
  ip->receiver.qix = ntohl(ip->receiver.qix);
  ip->receiver.nid = ntohl(ip->receiver.nid);
  ip->reply.qix = ntohl(ip->reply.qix);
  ip->reply.nid = ntohl(ip->reply.nid);
  ip->type.b = ntohl(ip->type.b);
  ip->type.s = ntohl(ip->type.s);
  ip->rid = ntohl(ip->rid);
  ip->tmo = ntohl(ip->tmo);
  ip->size = ntohl(ip->size);
  ip->flags.m = ntohl(ip->flags.m);
  ip->status = ntohl(ip->status);
}

static void encode_head(sHead* tp, sHead* sp)
{
  tp->nid = htonl(sp->nid);
  tp->birth = htonl(sp->birth);
  tp->flags.m = htonl(sp->flags.m);
  tp->lack.seq = htonl(sp->lack.seq);
  tp->lack.ts = htonl(sp->lack.ts);
  tp->rack.seq = htonl(sp->rack.seq);
  tp->rack.ts = htonl(sp->rack.ts);
}

static void encode_info(qdb_sInfo* tp, qdb_sInfo* sp)
{
  tp->sender.aix = htonl(sp->sender.aix);
  tp->sender.nid = htonl(sp->sender.nid);
  tp->pid = htonl(sp->pid);
  tp->receiver.qix = htonl(sp->receiver.qix);
  tp->receiver.nid = htonl(sp->receiver.nid);
  tp->reply.qix = htonl(sp->reply.qix);
  tp->reply.nid = htonl(sp->reply.nid);
  tp->type.b = htonl(sp->type.b);
  tp->type.s = htonl(sp->type.s);
  tp->rid = htonl(sp->rid);
  tp->tmo = htonl(sp->tmo);
  tp->size = htonl(sp->size);
  tp->flags.m = htonl(sp->flags.m);
  tp->status = htonl(sp->status);
}

static sEseg* eseg_alloc(thread_sMutex* mp)
{
  sEseg* sp;

  sp = lst_RemoveSucc(mp, &l.eseg.lh, NULL);
  if (sp == NULL) {
    sp = (sEseg*)calloc(1, sizeof(*sp));

    lst_Init(NULL, &sp->le_bcast, sp);
    lst_Init(NULL, &sp->le_seg, sp);
    lst_Init(NULL, &sp->c.le, sp);
  }

  return sp;
}

/* Build segments for a buffer.
   If buffer is to be broadcasted then allocate
   for all active links.  */

static sEseg* eseg_build(qdb_sBuffer* bp)
{
  pwr_tStatus sts;
  int size;
  sEseg* sp = NULL;
  sEseg* msp = NULL;
  sEseg* csp;
  sEseg* mcsp;
  sLink* lp;
  char* p;
  int ii;
  pwr_tBoolean bcast = bp->c.flags.b.broadcast;

  thread_MutexLock(&l.eseg.mutex);
  if (bcast)
    thread_MutexLock(&l.links.mutex);
  do {
    if (bcast) {
      for (lp = tree_Minimum(&sts, l.links.table); lp != NULL;
           lp = tree_Successor(&sts, l.links.table, lp)) {
        if (lp->np->link[lp->lix].flags.b.connected)
          break;
      }
    } else {
      lp = get_link(bp->b.info.receiver.nid, NULL);
      if (lp->lix != lp->np->clx)
        lp = get_link(SECONDARY_NID(bp->b.info.receiver.nid), NULL);
    }

    if (lp == NULL)
      break;

    for (msp = NULL, size = bp->b.info.size + sizeof(bp->b.info), ii = 0,
        p = (char*)&bp->b.info;
         size > 0; ii++, p += qcom_segment_size, size -= qcom_segment_size) {
      sp = eseg_alloc(NULL);
      sp->p = p;
      sp->bp = bp;
      sp->lp = lp;
      sp->id = ii;
      sp->size = MIN(size, qcom_segment_size);
      sp->head.flags.b.event = eEvent_user;
      sp->head.flags.b.bcast = bcast;
      if (msp == NULL) {
        sp->head.flags.b.first = 1;
        msp = sp;
        /* todo initiera msp->le_seg.item = msp */
      } else {
        sp->head.flags.b.middle = 1;
        lst_InsertPred(NULL, &msp->le_seg, &sp->le_seg, sp);
      }
      lp->np->link[lp->lix].export_alloc_cnt += sp->size;
    }

    sp->head.flags.b.middle = 0;
    sp->head.flags.b.last = 1;

    if (bcast) {
      for (lp = tree_Successor(&sts, l.links.table, lp); lp != NULL;
           lp = tree_Successor(&sts, l.links.table, lp)) {
        mcsp = NULL;
        sp = msp;
        ii = 0;
        do {
          csp = eseg_alloc(NULL);
          csp->p = sp->p;
          csp->bp = bp;
          csp->lp = lp;
          csp->head.flags.m = sp->head.flags.m;
          csp->size = sp->size;
          csp->id = ii++;
          if (mcsp == NULL) {
            mcsp = csp;
            /* todo initiera msp->le_seg.item = msp */
          } else {
            lst_InsertPred(NULL, &mcsp->le_seg, &csp->le_seg, sp);
          }
          lst_InsertPred(NULL, &sp->le_bcast, &csp->le_bcast, csp);
          sp = lst_Succ(NULL, &sp->le_seg, NULL);

          csp->lp->np->link[lp->lix].export_alloc_cnt += csp->size;

        } while (sp != msp);
      }
    }

  } while (0);

  if (bcast)
    thread_MutexUnlock(&l.links.mutex);
  thread_MutexUnlock(&l.eseg.mutex);

  return msp;
}

static void eseg_free(sEseg* sp)
{
  pwr_tBoolean bcast = sp->head.flags.b.bcast;

  if (bcast)
    thread_MutexLock(&l.bcast);

  export_alloc_sub(sp);

  lst_Remove(NULL, &sp->c.le);
  if (lst_IsEmpty(NULL, &sp->le_bcast) && lst_IsEmpty(NULL, &sp->le_seg)) {
    if (sp->bp != NULL) {
      qdb_ScopeLock
      {
        qdb_Free(NULL, sp->bp);
      }
      qdb_ScopeUnlock;
    }
  } else {
    lst_Remove(NULL, &sp->le_bcast);
    lst_Remove(NULL, &sp->le_seg);
  }

  if (bcast)
    thread_MutexUnlock(&l.bcast);

  memset(sp, 0, sizeof(*sp));
  lst_Init(NULL, &sp->le_bcast, sp);
  lst_Init(NULL, &sp->le_seg, sp);
  lst_Init(NULL, &sp->c.le, sp);
  lst_InsertPred(&l.eseg.mutex, &l.eseg.lh, &sp->c.le, sp);
}

static char* event_string(eEvent event)
{
  static char* es[eEvent_ + 1]
      = { "<<low>>", "connect", "down", "user", "ack", "<<high>>" };

  if (event <= eEvent__)
    return es[eEvent__];
  else if (event >= eEvent_)
    return es[eEvent_];
  else
    return es[event];
}

static pwr_tBoolean expired(pwr_tTime* clock)
{
  pwr_tTime now;

  time_GetTimeMonotonic(&now);
  return (time_Acomp(clock, &now) == -1);
}

static void* export_thread()
{
  pwr_tStatus sts;
  sEseg* sp;
  sEseg* ssp;
  sEseg* esp;
  qdb_sBuffer* bp;
  qdb_sQue* qp = NULL;

  qdb_ScopeLock
  {
    qp = qdb_Que(&sts, &qdb->g->qid_export, NULL);
  }
  qdb_ScopeUnlock;

  while (qdb->g->up) {
    sched_yield();
    qdb_ScopeLock
    {
      bp = qdb_Get(&sts, qp, qcom_cTmoEternal, NULL, 0);
      if (bp != NULL)
        bp = qdb_DetachBuffer(&sts, bp);
    }
    qdb_ScopeUnlock;

    if (bp == NULL)
      continue;
    pwr_Assert(bp->c.type == qdb_eBuffer_base);

    sp = eseg_build(bp);
    if (sp == NULL) {
      qdb_ScopeLock
      {
        qdb_Free(NULL, bp);
      }
      qdb_ScopeUnlock;
      continue;
    }
    export_alloc_check(sp->lp);

    thread_MutexLock(&l.bcast);

    thread_MutexLock(&sp->lp->eseg_mutex);
    esp = sp;
    do {
      ssp = esp;
      do {
        ssp->c.action = eAction_export;
        que_Put(NULL, &ssp->lp->q_in, &ssp->c.le, ssp);
        ssp = lst_Succ(NULL, &ssp->le_seg, NULL);
      } while (ssp != esp);
      esp = lst_Succ(NULL, &ssp->le_bcast, NULL);
    } while (esp != sp);
    thread_MutexUnlock(&sp->lp->eseg_mutex);

    thread_MutexUnlock(&l.bcast);
  }

  return NULL;
}

static sLink* get_link(pwr_tNodeId nid, sMsg* mp)
{
  pwr_tStatus sts;
  sLink* lp;

  if (nid == qdb->my_node->nid)
    return NULL;
  if (nid == qdb->no_node->nid)
    return NULL;

  thread_MutexLock(&l.links.mutex);

  lp = tree_Find(&sts, l.links.table, &nid);

  thread_MutexUnlock(&l.links.mutex);

  return lp;
}

static void get_tmo(sLink* lp, pwr_tBoolean do_inc, pwr_tTime* tmo)
{
  float rto;
  pwr_tTime now;
  pwr_tDeltaTime drto;

  rto = lp->np->link[lp->lix].rtt_rto;

  if (rto > lp->np->link[lp->lix].rtt_rxmax) {
    rto = lp->np->link[lp->lix].rtt_rxmax;
    if (lp->np->link[lp->lix].flags.b.active)
      link_stalled(lp);
  } else if (do_inc) {
    lp->np->link[lp->lix].rtt_rto *= 2;
    if (lp->np->link[lp->lix].rtt_rto > lp->np->link[lp->lix].rtt_rxmax)
      lp->np->link[lp->lix].rtt_rto = lp->np->link[lp->lix].rtt_rxmax + 0.01;
  }

  time_GetTimeMonotonic(&now);
  time_Aadd(tmo, &now, time_FloatToD(&drto, rto));
}

static void* import_thread()
{
  sMsg msg;
  sIseg* sp;
  sLink* last_link = NULL;
  int bytes;
  thread_sMutex* mp = &l.import.mutex;

  thread_MutexLock(mp);

  for (sp = iseg_alloc();;) {
    set_recvmsg(sp, &msg);
    bytes = recvmsg(l.sock, &msg.msg, 0);

    if (bytes == -1 && errno != EHOSTDOWN && errno != EHOSTUNREACH) {
      errh_Error("recvmsg failed %m(%d)", errno_Status(errno), errno);
      sched_yield();
      continue;
    }

    sp->size = bytes - sizeof(sp->head);
    sp->ts_recv = time_Clock(NULL, NULL);
    decode_head(&sp->head, &msg.head);
    // if ( IS_SECONDARY_NID(sp->head.nid))
    //  printf( "Secondary nid\n");
    if (last_link != NULL && sp->head.nid == last_link->nid)
      sp->lp = last_link;
    else
      sp->lp = last_link = get_link(sp->head.nid, &msg);
    if (sp->lp == NULL) {
      char volstr[20];
      errh_Warning("Request from unknown node %s (%s)",
          cdh_VolumeIdToString(volstr, sizeof(volstr), sp->head.nid, 0, 0),
          inet_ntoa(msg.sa.sin_addr));
      continue;
    }
    // printf( "Import from %d %s lix %d clx %d\n", sp->head.nid,
    // sp->lp->np->link[sp->lp->lix].name, sp->lp->lix, sp->lp->np->clx);
    sp->c.action = eAction_import;
    sp->lp->np->get.segs++;
    sp->lp->np->get.bytes += bytes;
    sp->lp->np->link[sp->lp->lix].sa = msg.sa;
    que_Put(NULL, &sp->lp->q_in, &sp->c.le, sp);
    sp = iseg_alloc();
  }
  return NULL;
}

static void ini_link_info(qdb_sLinkInfo* lp)
{
  qdb_sNode* my_np = qdb->my_node;

  strcpy(lp->name, my_np->link[0].name);

  lp->version = ntohl(my_np->version);
  lp->nid = ntohl(my_np->nid);
  lp->birth = ntohl(my_np->link[0].birth);
  lp->bus = ntohl(qdb->g->bus);
  lp->os = ntohl(my_np->os);
  lp->hw = ntohl(my_np->hw);
  lp->bo = ntohl(my_np->bo);
  lp->ft = ntohl(my_np->ft);
}

static sIseg* iseg_alloc()
{
  sIseg* sp;

  sp = lst_RemoveSucc(&l.iseg.mutex, &l.iseg.lh, NULL);
  if (sp == NULL) {
    sp = (sIseg*)calloc(1, sizeof(*sp) + qcom_segment_size - 1);
    lst_Init(NULL, &sp->c.le, sp);
    sp->size = qcom_segment_size;
  }

  return sp;
}

static void iseg_free(sIseg* sp)
{
  pwr_Assert(!lst_IsLinked(NULL, &sp->c.le));
  memset(sp, 0, sizeof(*sp) + qcom_segment_size - 1);
  lst_Init(NULL, &sp->c.le, sp);
  sp->size = qcom_segment_size;
  lst_InsertPred(&l.iseg.mutex, &l.iseg.lh, &sp->c.le, sp);
}

static void iseg_import(sLink* lp, sIseg* sp)
{
  pwr_tStatus sts;
  int diff;
  qdb_sInfo* ip;
  qdb_sQue* qp;
  qcom_sQid receiver;

  if (!lp->np->link[lp->lix].flags.b.connected) {
    return;
  }

  diff = sp->head.lack.seq - lp->np->link[lp->lix].rack.seq;
  if (diff != 1) {
    return;
  }

  if (sp->head.flags.b.first) {
    // pwr_Assert(lp->bp == NULL);
    ip = (qdb_sInfo*)sp->buff;
    decode_info(ip);
    qdb_ScopeLock
    {
      if (lp->bp != NULL) {
        lp->np->link[lp->lix].err_seg_seq++;
        qdb_Free(NULL, lp->bp);
      }
      lp->bp = qdb_Alloc(&sts, qdb_eBuffer_base, ip->size);
    }
    qdb_ScopeUnlock;
    if (lp->bp == NULL) {
      purge();
      return;
    }
    lp->bp->c.flags.m |= ip->flags.m & qdb_mBuffer_maskExport;
    lp->p = (char*)&lp->bp->b.info;
  } else if (!sp->head.flags.b.first) {
    // pwr_Assert(lp->bp != NULL);
    // pwr_Assert(lp->p != NULL);
    if (lp->bp == NULL) {
      lp->np->link[lp->lix].err_seg_seq++;
      return;
    }
  }

  memcpy(lp->p, sp->buff, sp->size);
  lp->p += sp->size;

  if (sp->head.flags.b.last) {
    lp->bp->c.flags.b.imported = 1;

    qdb_ScopeLock
    {
      receiver = lp->bp->b.info.receiver;
      qp = qdb_Que(&sts, &receiver, NULL);
      if (qp == NULL) {
        /* To do !!!  Send notification reply if requested. */
        qdb_Free(NULL, lp->bp);
      } else {
        qdb_Put(NULL, lp->bp, qp);
      }
    }
    qdb_ScopeUnlock;

    lp->bp = NULL;
  }
}

/* An ack message has arrived from a remote node.
   Free the segments in window that have been
   succesfully received at remote node.  */

static void lack(sLink* lp, sIseg* isp)
{
  lst_sEntry* se;
  int diff;
  sEseg *sp, *nsp;
  thread_sMutex* mx;

  for (sp = lst_Succ(NULL, &lp->lh_win, &se); se != &lp->lh_win; sp = nsp) {
    nsp = lst_Succ(NULL, se, &se);
    diff = isp->head.rack.seq - sp->head.lack.seq;

    if (diff >= 0) {
      /* This segment is either the acked segment or an older,
         it can be released.  */

      if (diff == 0 && isp->head.rack.ts == sp->head.lack.ts)
        // update_rtt(lp, isp);
        update_rtt(lp, sp);

      window_remove(lp, sp);

      mx = &sp->lp->eseg_mutex;
      thread_MutexLock(mx);
      eseg_free(sp);
      thread_MutexUnlock(mx);
    } else {
      /* This is the oldest not acked segment. */
      lp->np->link[lp->lix].lack = sp->head.lack;
      break;
    }
  }
}

static void link_active(sLink* lp)
{
  pwr_tStatus sts;

  if (lp->np->link[lp->lix].flags.b.active) {
    pwr_Assert(lp->np->link[lp->lix].flags.b.connected);
    return;
  }

  start_rto(lp);
  lp->np->link[lp->lix].flags.b.active = 1;
  lp->np->link[lp->lix].flags.b.connected = 1;
  errh_Info("Active, link to %s (%s)", lp->np->link[lp->lix].name,
      cdh_NodeIdToString(NULL, lp->np->nid, 0, 0));
  qdb_ScopeLock
  {
    lp->np->link[lp->lix].qflags.b.active = 1;
    lp->np->link[lp->lix].qflags.b.connected = 1;
    if (lp->np->clx == lp->lix)
      qdb_NetEvent(&sts, lp->np, qcom_eStype_linkActive);
  }
  qdb_ScopeUnlock;
  check_link_status();
}

static void link_connect(sLink* lp, sIseg* sp)
{
  pwr_tStatus sts;

  if (sp->head.flags.b.event == eEvent_connect)
    lp->np->clx = lp->lix;
  else if (sp->head.flags.b.event == eEvent_connectPassive) {
    if (lp->np->clx == lp->lix) {
      if (lp->lix == 1)
        lp->np->clx = 0;
      else if (lp->lix == 0 && lp->np->link_cnt > 1)
        lp->np->clx = 1;
    }
  }
  lp->np->link[lp->lix].flags.b.active = 1;

  if (lp->np->link[lp->lix].flags.b.connected)
    return;

  lp->np->link[lp->lix].flags.b.connected = 1;
  errh_Info("Connected, link to %s (%s)", lp->np->link[lp->lix].name,
      cdh_NodeIdToString(NULL, lp->np->nid, 0, 0));
  qdb_ScopeLock
  {
    lp->np->link[lp->lix].birth = sp->head.birth;
    time_GetTime(&lp->np->link[lp->lix].timeup);
    lp->np->link[lp->lix].qflags.b.connected = 1;
    lp->np->link[lp->lix].qflags.b.active = 1;
    set_link_info(lp, (qdb_sLinkInfo*)sp->buff);
    if (lp->np->clx == lp->lix && sp->head.flags.b.event == eEvent_connect)
      qdb_NetEvent(&sts, lp->np, qcom_eStype_linkConnect);
  }
  qdb_ScopeUnlock;

  check_link_status();
}

static void link_disconnect(sLink* lp)
{
  pwr_tStatus sts;
  sEseg* sp;

  if (!lp->np->link[lp->lix].flags.b.connected) {
    pwr_Assert(!lp->np->link[lp->lix].flags.b.active);
    return;
  }

  lp->np->link[lp->lix].pending_rack = NO;
  lp->np->link[lp->lix].flags.b.active = 0;
  lp->np->link[lp->lix].flags.b.connected = 0;
  memset(&lp->np->link[lp->lix].lack, 0, sizeof(lp->np->link[0].lack));
  memset(&lp->np->link[lp->lix].rack, 0, sizeof(lp->np->link[0].rack));
  lp->np->link[lp->lix].seq = 0;
  start_rto(lp);
  lp->np->link[lp->lix].rack_tmo = pwr_cNTime;

  /* Empty send list */

  thread_MutexLock(&lp->eseg_mutex);
  for (sp = lst_Succ(NULL, &lp->lh_send, NULL); sp != NULL;
       sp = lst_Succ(NULL, &lp->lh_send, NULL)) {
    lst_Remove(NULL, &sp->c.le);
    eseg_free(sp);
  }

  /* Empty window list */

  for (sp = lst_Succ(NULL, &lp->lh_win, NULL); sp != NULL;
       sp = lst_Succ(NULL, &lp->lh_win, NULL)) {
    lst_Remove(NULL, &sp->c.le);
    eseg_free(sp);
  }
  thread_MutexUnlock(&lp->eseg_mutex);

  lp->np->link[lp->lix].win_count = 0;

  errh_Info("Disconnected, link to  %s (%s)", lp->np->link[lp->lix].name,
      cdh_NodeIdToString(NULL, lp->np->nid, 0, 0));
  qdb_ScopeLock
  {
    if (lp->bp != NULL) {
      qdb_Free(NULL, lp->bp);
    }
    lp->np->link[lp->lix].qflags.b.active = 0;
    lp->np->link[lp->lix].qflags.b.connected = 0;
    if (lp->np->clx == lp->lix)
      qdb_NetEvent(&sts, lp->np, qcom_eStype_linkDisconnect);
  }
  qdb_ScopeUnlock;

  lp->bp = NULL;
  lp->p = NULL;
  lp->np->link[lp->lix].export_alloc_cnt = 0;
  sp = create_connect(lp);
  lst_InsertSucc(NULL, &lp->lh_send, &sp->c.le, sp);

  check_link_status();
}

static void link_redcom_active(sLink* lp, sIseg* sp)
{
  pwr_tStatus sts;

  if (lp->np->clx == lp->lix)
    return;

  // Disconnect previous link
  qdb_ScopeLock
  {
    qdb_NetEvent(&sts, lp->np, qcom_eStype_linkDisconnect);
  }
  qdb_ScopeUnlock;

  lp->np->clx = lp->lix;
  errh_Info("Primary link to %s (%s)", lp->np->link[lp->lix].name,
      cdh_NodeIdToString(NULL, lp->np->nid, 0, 0));
  qdb_ScopeLock
  {
    if (lp->np->clx == lp->lix)
      qdb_NetEvent(&sts, lp->np, qcom_eStype_linkConnect);
  }
  qdb_ScopeUnlock;

  check_link_status();
}

static void link_redcom_passive(sLink* lp, sIseg* sp)
{
  pwr_tStatus sts;

  if (lp->np->clx != lp->lix)
    return;

  if (lp->np->link_cnt < 2)
    return;

  // Disconnect previous link
  qdb_ScopeLock
  {
    qdb_NetEvent(&sts, lp->np, qcom_eStype_linkDisconnect);
  }
  qdb_ScopeUnlock;

  lp->np->clx = !lp->lix;

  errh_Info("Primary link to %s (%s)", lp->np->link[lp->np->clx].name,
      cdh_NodeIdToString(NULL, lp->np->nid, 0, 0));
  qdb_ScopeLock
  {
    if (lp->np->link[lp->np->clx].flags.b.active)
      qdb_NetEvent(&sts, lp->np, qcom_eStype_linkConnect);
  }
  qdb_ScopeUnlock;

  check_link_status();
}

static void link_purge(sLink* lp)
{
  sEseg *sp, *nsp;
  int purge = 0;
  int alloc_cnt = 0;

  if (!lp->np->link[lp->lix].flags.b.connected) {
    pwr_Assert(!lp->np->link[lp->lix].flags.b.active);
    return;
  }

  /* Purge send list */

  int i = 0;
  thread_MutexLock(&lp->eseg_mutex);
  for (sp = lst_Succ(NULL, &lp->lh_send, NULL); sp != NULL; sp = nsp) {
    nsp = lst_Succ(NULL, &sp->c.le, NULL);
    if (!purge && i > 50 && sp->head.flags.b.first)
      purge = 1;

    if (purge) {
      eseg_free(sp);
    } else
      alloc_cnt += sp->size;
    i++;
  }
  thread_MutexUnlock(&lp->eseg_mutex);
  printf("link_purge: %d cnt %d (%d)\n", i,
      lp->np->link[lp->lix].export_alloc_cnt, alloc_cnt);
  lp->np->link[lp->lix].export_alloc_cnt = alloc_cnt;
  lp->np->link[lp->lix].export_purge_cnt++;
}

static void link_import(sLink* lp, sIseg* sp)
{
  if (!lp->np->link[lp->lix].flags.b.active
      && lp->np->link[lp->lix].birth == sp->head.birth)
    link_active(lp);
  else if (lp->np->link[lp->lix].birth != sp->head.birth
      && lp->np->link[lp->lix].flags.b.connected)
    link_disconnect(lp);
  else if (lp->np->link[lp->lix].birth != 0
      && lp->np->link[lp->lix].birth != sp->head.birth
      && !lp->np->link[lp->lix].flags.b.connected)
    link_redisconnect(lp);

  switch (sp->head.flags.b.event) {
  case eEvent_user:
    if (lp->lix != lp->np->clx) {
      lack(lp, sp);
      set_rack(lp, sp);
      // printf( "Import from backup, rejected %s\n",
      // lp->np->link[lp->lix].name);
      break;
    }
    if (lp->np->link[lp->lix].flags.b.active) {
      lack(lp, sp);
      iseg_import(lp, sp);
      set_rack(lp, sp);
      // printf( "Import from %s\n", lp->np->link[lp->lix].name);
    }
    break;
  case eEvent_ack:
    if (lp->np->link[lp->lix].flags.b.active) {
      lack(lp, sp);
    }
    break;
  case eEvent_connect:
  case eEvent_connectPassive:
    timelog_ss(1, "Qmon connect received from", lp->np->link[lp->lix].name);
    link_connect(lp, sp);
    lack(lp, sp);
    set_rack(lp, sp);
    // printf( "Connect from %s\n", lp->np->link[lp->lix].name);
    break;
  case eEvent_redcomActive:
    lack(lp, sp);
    set_rack(lp, sp);
    link_redcom_active(lp, sp);
    timelog_ss(1, "Active received from", lp->np->link[lp->lix].name);
    break;
  case eEvent_redcomPassive:
    lack(lp, sp);
    set_rack(lp, sp);
    link_redcom_passive(lp, sp);
    timelog_ss(1, "Passive received from", lp->np->link[lp->lix].name);
    break;
  default:
    break;
  }

  iseg_free(sp);
}

static void link_redisconnect(sLink* lp)
{
  sEseg* sp;

  pwr_Assert(!lp->np->link[lp->lix].flags.b.connected);
  pwr_Assert(!lp->np->link[lp->lix].flags.b.active);

  lp->np->link[lp->lix].pending_rack = NO;
  start_rto(lp);
  lp->np->link[lp->lix].rack_tmo = pwr_cNTime;

  sp = lst_Succ(NULL, &lp->lh_win, NULL);
  if (sp == NULL)
    sp = lst_Succ(NULL, &lp->lh_send, NULL);
  pwr_Assert(sp != NULL);
  pwr_Assert(sp->head.flags.b.event == eEvent_connect
      || sp->head.flags.b.event == eEvent_connectPassive);

  sp->tmo = pwr_cNTime;
}

static void link_send(sLink* lp)
{
  sEseg* sp;

  if ((sp = window_tmo(lp)) != NULL) {
    seg_send(lp, sp);
  } else if ((sp = pending_send(lp)) != NULL) {
    window_insert(lp, sp);
    seg_send(lp, sp);
  } else if (lp->np->link[lp->lix].pending_rack
      && expired(&lp->np->link[lp->lix].rack_tmo)) {
    send_ack(lp);
  }
}

static void link_stalled(sLink* lp)
{
  pwr_tStatus sts;

  if (!lp->np->link[lp->lix].flags.b.active)
    return;

  lp->np->link[lp->lix].flags.b.active = 0;
  errh_Info("Stalled, link to node %s (%s)", lp->np->link[lp->lix].name,
      cdh_NodeIdToString(NULL, lp->np->nid, 0, 0));
  qdb_ScopeLock
  {
    lp->np->link[lp->lix].qflags.b.active = 0;
    if (lp->np->clx == lp->lix)
      qdb_NetEvent(&sts, lp->np, qcom_eStype_linkStalled);
  }
  qdb_ScopeUnlock;
  check_link_status();
}

static void* link_thread(sLink* lp)
{
  uSeg* sp;
  pwr_tBoolean pending = FALSE;

  for (;;) {
    sp = que_Get(NULL, &lp->q_in, link_tmo(lp), &lp->tmo);

    switch (sp->action) {
    case eAction_export:
      /*      lst_InsertPred(NULL, &lp->lh_send, &sp->c.le, sp); */
      pending = clean_insert(&lp->lh_send, (sEseg*)sp, pending);
      if (pending)
        continue;
      else
        break;
    case eAction_import:
      link_import(lp, &sp->i);
      if (pending)
        continue;
      else
        break;
    case eAction_tmo:
      /* Nothing to do, all is done in link_send. */
      break;
    default:
      errh_Bugcheck(2, "unknown action");
    }
    link_send(lp);
  }

  return NULL;
}

static pwr_tDeltaTime* link_tmo(sLink* lp)
{
  pwr_tDeltaTime diff_send = pwr_cNDeltaTime;
  pwr_tDeltaTime diff_rack = pwr_cNDeltaTime;
  pwr_tTime clock;
  pwr_tDeltaTime tmo = pwr_cNDeltaTime;
  sEseg* sp;

  time_GetTimeMonotonic(&clock);

  if (lst_Succ(NULL, &lp->lh_send, NULL) != NULL
      && lp->np->link[lp->lix].win_count < lp->np->link[lp->lix].win_max)
    return time_ZeroD(&lp->np->link[lp->lix].timer);

  if (lp->np->link[lp->lix].pending_rack) {
    time_Adiff(&diff_rack, &lp->np->link[lp->lix].rack_tmo, &clock);
    if (time_Dcomp(&diff_rack, 0) == -1)
      diff_rack = pwr_cNDeltaTime;
  }

  if ((sp = lst_Succ(NULL, &lp->lh_win, NULL)) != NULL) {
    time_Adiff(&diff_send, &sp->tmo, &clock);
    if (time_Dcomp(&diff_send, 0) == -1)
      diff_send = pwr_cNDeltaTime;
  }

  if (lp->np->link[lp->lix].pending_rack && sp != NULL) {
    if (time_Dcomp(&diff_rack, &diff_send) == -1)
      tmo = diff_rack;
    else
      tmo = diff_send;
  } else if (lp->np->link[lp->lix].pending_rack) {
    tmo = diff_rack;
  } else if (sp != NULL) {
    tmo = diff_send;
  } else {
    lp->np->link[lp->lix].timer.tv_sec = 999999999;
    lp->np->link[lp->lix].timer.tv_nsec = 0;
    return &lp->np->link[lp->lix].timer;
  }

  lp->np->link[lp->lix].timer = tmo;
  return &lp->np->link[lp->lix].timer;
}

static sLink* new_link(pwr_tNodeId nid, sMsg* mp)
{
  pwr_tStatus sts;
  sLink* lp;
  sEseg* sp;
  float rtt_rxmin, rtt_rxmax;
  float ack_delay;

  if (nid == qdb->my_node->nid)
    return NULL;
  if (nid == qdb->no_node->nid)
    return NULL;

  lp = tree_Insert(&sts, l.links.table, &nid);
  pwr_Assert(lp != NULL);

  lp->lix = NID_LIX(nid);

  if (!tics_per_sec)
    tics_per_sec = sysconf(_SC_CLK_TCK);

  l.links.count++;

  qdb_ScopeLock
  {
    lp->np = qdb_AddNode(&sts, NID(nid), 0);
  }
  qdb_ScopeUnlock;

  pwr_Assert(lp->np != NULL);

  rtt_rxmin = (float)(MAX(lp->np->link[lp->lix].min_resend_time,
                  qdb->my_node->link[0].min_resend_time))
      / 1000;
  if (feqf(rtt_rxmin, 0.0f))
    rtt_rxmin = RTT_RXMIN;
  rtt_rxmax = (float)(MAX(lp->np->link[lp->lix].max_resend_time,
                  qdb->my_node->link[0].max_resend_time))
      / 1000;
  if (feqf(rtt_rxmax, 0.0f))
    rtt_rxmax = RTT_RXMAX;
  ack_delay
      = MAX(lp->np->link[lp->lix].ack_delay, qdb->my_node->link[0].ack_delay);
  time_FloatToD(&lp->ack_delay, qdb->my_node->link[0].ack_delay);
  lp->exp_buf_quota = MAX(lp->np->link[lp->lix].export_buf_quota,
      qdb->my_node->link[0].export_buf_quota);
  if (lp->exp_buf_quota == 0)
    lp->exp_buf_quota = EXPORT_BUF_QUOTA;
  lp->np->link[lp->lix].export_quota = lp->exp_buf_quota;

  que_Create(NULL, &lp->q_in);
  lst_Init(NULL, &lp->lh_send, NULL);
  lst_Init(NULL, &lp->lh_win, NULL);
  lp->np->link[lp->lix].win_max = 1;
  lp->np->link[lp->lix].rtt_rxmax = rtt_rxmax;
  lp->np->link[lp->lix].rtt_rxmin = rtt_rxmin;
  lp->tmo.c.action = eAction_tmo;
  sts = thread_MutexInit(&lp->eseg_mutex);

  if (mp != NULL) {
    lp->np->sa = mp->sa;
  }

  sp = create_connect(lp);
  que_Put(NULL, &lp->q_in, &sp->c.le, sp);

  thread_Create(&lp->thread, lp->np->link[lp->lix].name, link_thread, lp);

  return lp;
}

static void open_socket()
{
  if ((l.sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
    errh_Error("socket failed: %s", strerror(errno));
    exit(errno_ExitErrno(errno));
  }

  l.sa.sin_family = AF_INET;
  l.sa.sin_addr.s_addr = htonl(INADDR_ANY);
  l.sa.sin_port = qdb->my_node->sa.sin_port;

  if ((bind(l.sock, (struct sockaddr*)&l.sa, sizeof(l.sa))) < 0) {
    errh_Error("bind failed: %s", strerror(errno));
    close(l.sock);
    exit(errno_ExitErrno(errno));
  }
}

static sEseg* pending_send(sLink* lp)
{
  sEseg* sp;

  if (lp->np->link[lp->lix].win_count >= lp->np->link[lp->lix].win_max)
    return NULL;

  thread_MutexLock(&lp->eseg_mutex);
  sp = lst_RemoveSucc(NULL, &lp->lh_send, NULL);
  thread_MutexUnlock(&lp->eseg_mutex);
  return sp;
}

static void send_ack(sLink* lp)
{
  sHead head;
  sMsg msg;
  int bytes;

  head.flags.b.event = eEvent_ack;
  head.flags.m |= mSeg_single;
  head.lack.seq = lp->np->link[lp->lix].seq;
  head.lack.ts = time_Clock(NULL, NULL);
  head.nid = l.head.nid;
  if (qdb->my_node->is_secondary)
    head.nid = SECONDARY_NID(l.head.nid);
  head.birth = l.head.birth;
  head.rack = lp->np->link[lp->lix].rack;

  set_sendmsg(lp, NULL, &msg);
  encode_head(&msg.head, &head);

  thread_MutexLock(&l.send_mutex);
  // printf( "sendmsg ack\n");
  bytes = sendmsg(l.sock, &msg.msg, 0);
  thread_MutexUnlock(&l.send_mutex);

  if (bytes != -1) {
    lp->np->link[lp->lix].pending_rack = NO;
    lp->np->put.segs++;
    lp->np->put.bytes += bytes;
  }

  sched_yield();
}

static void set_link_info(sLink* lp, qdb_sLinkInfo* ip)
{
  qdb_sNode* np = lp->np;

  strcpy(np->link[lp->lix].name, ip->name);

  np->version = ntohl(ip->version);
  np->nid = ntohl(ip->nid);
  np->link[lp->lix].birth = ntohl(ip->birth);
  lp->np->link[lp->lix].bus = ntohl(ip->bus);
  np->os = ntohl(ip->os);
  np->hw = ntohl(ip->hw);
  np->bo = ntohl(ip->bo);
  np->ft = ntohl(ip->ft);
}

static void set_rack(sLink* lp, sIseg* sp)
{
  int diff;

  if (!lp->np->link[lp->lix].flags.b.connected)
    return;

  if (sp->head.lack.seq == 0)
    return;

  diff = sp->head.lack.seq - lp->np->link[lp->lix].rack.seq;
  if (diff == 0 || diff == 1) {
    lp->np->link[lp->lix].rack = sp->head.lack;
  } else if (diff > 1) {
    if ((++lp->np->link[lp->lix].err_seq % 20) == 1) {
      errh_Info("%s, %d sequence error %d segments %s : (%d)[%d]\n",
          lp->np->link[lp->lix].name, lp->np->link[lp->lix].err_seq, diff - 1,
          event_string(sp->head.flags.b.event), sp->head.lack.seq,
          sp->head.rack.seq);
    }
    return;
  } else {
    if ((++lp->np->link[lp->lix].err_red % 20) == 1) {
      errh_Info("%s, %d redundant segment %s : (%d)[%d]\n",
          lp->np->link[lp->lix].name, lp->np->link[lp->lix].err_red,
          event_string(sp->head.flags.b.event), sp->head.lack.seq,
          sp->head.rack.seq);
    }
    return;
  }

  if (sp->head.flags.b.event == eEvent_ack)
    return;

  if (sp->head.flags.b.resent) {
    lp->np->link[lp->lix].pending_rack = YES;
    time_GetTimeMonotonic(&lp->np->link[lp->lix].rack_tmo);
  } else if (lp->np->link[lp->lix].pending_rack) {
    time_GetTimeMonotonic(&lp->np->link[lp->lix].rack_tmo);
  } else {
    lp->np->link[lp->lix].pending_rack = YES;
    time_GetTimeMonotonic(&lp->np->link[lp->lix].rack_tmo);
    time_Aadd(&lp->np->link[lp->lix].rack_tmo, &lp->np->link[lp->lix].rack_tmo,
        &lp->ack_delay); /* lp->rack_tmo; */
  }
}

static void set_recvmsg(sIseg* sp, sMsg* mp)
{
  mp->iov[0].iov_base = (char*)&mp->head;
  mp->iov[0].iov_len = sizeof(mp->head);
  mp->iov[1].iov_base = (char*)sp->buff;
  mp->iov[1].iov_len = qcom_segment_size;

  memset(&mp->sa, 0, sizeof(mp->sa));
  memset(&mp->msg, 0, sizeof(mp->msg));
  mp->msg.msg_iov = mp->iov;
  mp->msg.msg_iovlen = 2;

  mp->msg.msg_name = (void*)&mp->sa;
  mp->msg.msg_namelen = sizeof(mp->sa);
}

static void seg_send(sLink* lp, sEseg* sp)
{
  sMsg msg;

  sp->head.lack.ts = time_Clock(NULL, NULL);
  sp->head.nid = l.head.nid;
  if (qdb->my_node->is_secondary)
    sp->head.nid = SECONDARY_NID(l.head.nid);
  sp->head.birth = l.head.birth;
  sp->head.rack = sp->lp->np->link[lp->lix].rack;

  thread_MutexLock(&l.send_mutex);

  set_sendmsg(lp, sp, &msg);
  encode_head(&msg.head, &sp->head);

  // printf( "sendmsg segment\n");
  sp->bytes = sendmsg(l.sock, &msg.msg, 0);
  thread_MutexUnlock(&l.send_mutex);

  if (sp->bytes == -1) {
    if (errno != EHOSTDOWN && errno != EHOSTUNREACH) {
      errh_Error("sendmsg to node %s (%s) failed\n(%d) %s",
          sp->lp->np->link[lp->lix].name,
          cdh_NodeIdToString(NULL, sp->lp->nid, 0, 0), errno, strerror(errno));
    }
  } else {
    lp->np->link[lp->lix].pending_rack = NO;
    lp->np->put.segs++;
    lp->np->put.bytes += sp->bytes;
  }
  if (lst_IsSucc(NULL, &lp->lh_win, &sp->c.le)) {
    if (!sp->head.flags.b.resent) {
      start_rto(lp);
      sp->head.flags.b.resent = 1;
    }
    get_tmo(lp, YES, &sp->tmo);
  } else {
    get_tmo(lp, NO, &sp->tmo);
  }
  sp->sent = 1;
  time_GetTimeMonotonic(&sp->send_ts);

  sched_yield();
}

static void set_sendmsg(sLink* lp, sEseg* sp, sMsg* mp)
{
  int i = 0;
  int size = 0;
  char* p;

  pwr_Assert(lp != NULL);

  memset(&mp->msg, 0, sizeof(mp->msg));
  mp->msg.msg_iov = mp->iov;

  mp->iov[i].iov_base = (char*)&mp->head;
  mp->iov[i++].iov_len = sizeof(mp->head);

  if (sp == NULL) {
    ;
  } else if (sp->head.flags.b.event == eEvent_connect
      || sp->head.flags.b.event == eEvent_connectPassive) {
    mp->iov[i].iov_base = (char*)&l.link_info;
    mp->iov[i++].iov_len = sizeof(l.link_info);
  } else if (sp->bp != NULL) {
    p = (char*)sp->p;
    size = sp->size;
    if (sp->head.flags.b.first) {
      encode_info(&mp->info, (qdb_sInfo*)p);
      mp->iov[i].iov_base = (char*)&mp->info;
      mp->iov[i++].iov_len = sizeof(mp->info);
      p += sizeof(mp->info);
      size -= sizeof(mp->info);
    }
    mp->iov[i].iov_base = p;
    mp->iov[i++].iov_len = size;
  }

  mp->msg.msg_iovlen = i;
  mp->msg.msg_name = (void*)&lp->np->link[lp->lix].sa;
  mp->msg.msg_namelen = sizeof(lp->np->link[0].sa);
}

static void start_rto(sLink* lp)
{
  double rto;

  rto = lp->np->link[lp->lix].rtt_srtt + (4.0 * lp->np->link[lp->lix].rtt_var);

  if (rto < lp->np->link[lp->lix].rtt_rxmin)
    rto = lp->np->link[lp->lix].rtt_rxmin;
  else if (rto > lp->np->link[lp->lix].rtt_rxmax)
    rto = lp->np->link[lp->lix].rtt_rxmax;

  lp->np->link[lp->lix].rtt_rto = rto;
}

static void update_rtt(sLink* lp, sEseg* sp)
{
  pwr_tDeltaTime dt;
  float delta;
  pwr_tTime now;

  if (sp->head.rack.seq == 0)
    return;

  time_GetTimeMonotonic(&now);
  time_Adiff(&dt, &now, &sp->send_ts);
  time_DToFloat(&lp->np->link[lp->lix].rtt_rtt, &dt);

  delta = lp->np->link[lp->lix].rtt_rtt - lp->np->link[lp->lix].rtt_srtt;
  lp->np->link[lp->lix].rtt_srtt += delta / 8;

  if (delta < 0.0)
    delta = -delta; /* |delta| */

  lp->np->link[lp->lix].rtt_var += (delta - lp->np->link[lp->lix].rtt_var) / 4;
}

static void window_insert(sLink* lp, sEseg* sp)
{
  pwr_Assert(!lst_IsLinked(NULL, &sp->c.le));
  lst_InsertPred(NULL, &lp->lh_win, &sp->c.le, sp);
  lp->np->link[lp->lix].win_count++;
  sp->head.lack.seq = ++lp->np->link[lp->lix].seq;
}

static void window_remove(sLink* lp, sEseg* sp)
{
  pwr_Assert(lst_IsLinked(NULL, &sp->c.le));
  lst_Remove(NULL, &sp->c.le);
  lp->np->link[lp->lix].win_count--;
}

static sEseg* window_tmo(sLink* lp)
{
  sEseg* sp = lst_Succ(NULL, &lp->lh_win, NULL);

  if (sp == NULL || !expired(&sp->tmo))
    return NULL;

  return sp;
}

static void check_link_status()
{
  pwr_tStatus sts;
  pwr_tStatus linksts = PWR__SRUN;
  sLink* lp;

  for (lp = tree_Minimum(&sts, l.links.table); lp != NULL;
       lp = tree_Successor(&sts, l.links.table, lp)) {
    if (!lp->np->link[lp->lix].flags.b.active)
      linksts = QCOM__DOWN;
  }
  if (linksts != l.sts) {
    if (errh_Severity(linksts) >= errh_Severity(qcom_sts))
      errh_SetStatus(linksts);
    else if (errh_Severity(l.sts) >= errh_Severity(qcom_sts)
        && errh_Severity(linksts) < errh_Severity(qcom_sts))
      errh_SetStatus(qcom_sts);
    l.sts = linksts;
  }
}

static void set_status(pwr_tStatus sts)
{
  if (sts != qcom_sts) {
    if (errh_Severity(sts) >= errh_Severity(l.sts))
      errh_SetStatus(sts);
    else if (errh_Severity(qcom_sts) >= errh_Severity(l.sts)
        && errh_Severity(sts) < errh_Severity(l.sts))
      errh_SetStatus(l.sts);
    qcom_sts = sts;
  }
}

static void purge(void)
{
  pwr_tStatus sts;
  sLink* lp;

  for (lp = tree_Minimum(&sts, l.links.table); lp != NULL;
       lp = tree_Successor(&sts, l.links.table, lp))
    link_purge(lp);
  errh_Error("Links purged, qdb pool exhausted");
}

static void*

action_thread()
{
  pwr_tStatus sts;
  qcom_sGet get;
  void* msg;
  sLink* lp;

  while (qdb->g->up) {
    memset(&get, 0, sizeof(get));

    msg = qcom_Get(&sts, &l.action_qid, &get, qcom_cTmoEternal);
    if (ODD(sts)) {
      switch ((int)get.type.b) {
      case qmon_cMsgClassAction: {
        switch (get.type.s) {
        case qmon_eMsgTypeAction_NodeActive:
        case qmon_eMsgTypeAction_NodePassive:
          for (lp = tree_Minimum(&sts, l.links.table); lp != NULL;
               lp = tree_Successor(&sts, l.links.table, lp))
            send_action(lp, get.type.s);

          break;
        case qmon_eMsgTypeAction_Connect: {
          sLink* lp;
          sEseg* sp;
          pwr_tNodeId nid;

          nid = *(pwr_tNodeId*)msg;
          lp = get_link(nid, NULL);
          if (!lp)
            break;
          lp->np->link[lp->lix].birth = time_Clock(NULL, NULL);
          sp = create_connect(lp);
          que_Put(NULL, &lp->q_in, &sp->c.le, sp);
          break;
        }
        case qmon_eMsgTypeAction_Disconnect: {
          sLink* lp;
          pwr_tNodeId nid;

          nid = *(pwr_tNodeId*)msg;

          lp = get_link(nid, NULL);
          if (!lp)
            break;
          link_disconnect(lp);
          break;
        }
        default:;
        }
        break;
      }
      default:;
      }
      qcom_Free(&sts, msg);
    }
  }
  return NULL;
}

static sEseg* send_action(sLink* lp, qmon_eMsgTypeAction action)
{
  sEseg* sp;

  sp = eseg_alloc(&l.eseg.mutex);
  switch (action) {
  case qmon_eMsgTypeAction_NodeActive:
    timelog(1, "qmon send NodeActive");
    sp->head.flags.b.event = eEvent_redcomActive;
    break;
  case qmon_eMsgTypeAction_NodePassive:
    timelog(1, "qmon send NodePassive");
    sp->head.flags.b.event = eEvent_redcomPassive;
    break;
  default:
    return 0;
  }
  sp->lp = lp;
  sp->c.action = eAction_export;

  que_Put(NULL, &lp->q_in, &sp->c.le, sp);

  return sp;
}
