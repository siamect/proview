/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_linksup.c -- Runtime environment - Link Watch */

#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "pwr_lst.h"
#include "co_cdh.h"
#include "co_time.h"
#include "rt_ini_event.h"
#include "rt_gdh_msg.h"
#include "rt_plc_timer.h"
#include "rt_plc_utl.h"
#include "rt_aproc.h"
#include "rt_pwr_msg.h"

/* In this version, only cTimerTimeScan is used.
   To save resources we only have one PAMS timer. */

#define cTimerTimeScan 1000 /* ms */
#define cTimerTimeDetect cTimerTimeScan

typedef enum {
  eListState__ = 0,
  eListState_Init = 1,
  eListState_Scan = 2,
  eListState_NoNodeLink = 3,
  eListState_Wait = 4,
  eListState_
} eListState;

typedef enum { eTimer_ScanMessage = 1 } eTimer;

typedef struct s_Node sNode;

struct s_Node {
  struct LstHead node_l;
  struct LstHead timer_l;
  pwr_tObjid oid;
  pwr_sClass_NodeLinkSup node;
  pwr_sClass_NodeLinkSup* o;
  gdh_tDlid dlid;
  pwr_tBoolean found;
  plc_sTimer* timer;
  pwr_tStatus* subvalue;
};

static eListState list_state = eListState_Init;
static struct LstHead node_l;
static struct LstHead timer_l;

static void detect(pwr_sClass_NodeLinkSup*, pwr_tBoolean, sNode*);
static void event(qcom_sGet*);
static sNode* init_node(pwr_tObjid, sNode*, pwr_tBoolean);
static pwr_tStatus init_nodes();
static sNode* get_nodes(pwr_tObjid);
static void reinit_nodes();
static void scan_nodes();
static void scan_timers();
static void update_node(sNode*);

int main(int argc, char** argv)
{
  pwr_tStatus sts;
  qcom_sQid my_q = qcom_cNQid;
  qcom_sGet get;

  errh_Init("pwr_linksup", errh_eAnix_linksup);
  errh_SetStatus(PWR__SRVSTARTUP);

  if (!qcom_Init(&sts, NULL, "pwr_linksup")) {
    errh_Error("qcom_Init, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  sts = gdh_Init("pwr_linksup");
  if (EVEN(sts)) {
    errh_Fatal("gdh_Init, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  if (!qcom_CreateQ(&sts, &my_q, NULL, "events")) {
    errh_Fatal("qcom_CreateQ, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }
  if (!qcom_Bind(&sts, &my_q, &qcom_cQini)) {
    errh_Fatal("qcom_Bind(Qini), %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(-1);
  }

  /* Wait for local nethandler to start */

  while (EVEN(gdh_NethandlerRunning()))
    sleep(1);

  plc_UtlWaitForPlc();

  LstInit(&node_l);
  LstInit(&timer_l);

  init_nodes();
  if (!LstEmpty(&node_l)) {
    list_state = eListState_Scan;
  } else {
    errh_Info("No nodes to supervise, exiting");
    errh_SetStatus(pwr_cNStatus);
    exit(0);
  }

  errh_SetStatus(PWR__SRUN);

  for (;;) {
    scan_timers();
    scan_nodes();
    get.data = NULL;
    if (qcom_Get(&sts, &my_q, &get, cTimerTimeScan) != NULL) {
      if (get.type.b == qcom_eBtype_event) {
        event(&get);
      } else {
        errh_Info("unexpected message type, type: %d", get.type.b);
      }
      qcom_Free(&sts, get.data);
    }
    aproc_TimeStamp(((float)cTimerTimeScan) / 1000, 5);
  }
}

/* Detect a NodeLink object.
   NOTE: This should be the same as the macro DSup_exec
   for DSup used by PLC, in rt_plc_macro_sup.h  */

static void detect(pwr_sClass_NodeLinkSup* o, pwr_tBoolean con, sNode* np)
{
  /* For DSup we compare with control position, but for NodeLink
     we only detect LinkDown  */

  if (o->LinkUp) {
    if (o->Action)
      o->Action = FALSE;
    if (o->ReturnCheck) {
      time_GetTime(&o->ReturnTime);
      o->ReturnCheck = FALSE;
      o->ReturnSend = TRUE;
    }
    if (o->AlarmCheck && !o->DetectCheck) {
      o->TimerFlag = FALSE;
      o->DetectCheck = TRUE;
    }
  } else if (con) {
    if (!o->Action)
      o->Action = TRUE;
    if (o->AlarmCheck && o->DetectOn && !o->Blocked) {
      if (o->DetectCheck) {
        o->TimerCount = (o->TimerTime * 1000) / cTimerTimeDetect;
        if (!o->TimerFlag && o->TimerCount > 0) {
          if (LstIsNull(&np->timer_l)) {
            LstInsert(&timer_l, &np->timer_l);
          }
          o->TimerFlag = TRUE;
        }
        time_GetTime(&o->DetectTime);
        o->DetectCheck = FALSE;
      }
      if (!o->TimerFlag) {
        o->DetectSend = TRUE;
        o->ReturnCheck = TRUE;
        o->Acked = FALSE;
        o->AlarmCheck = FALSE;
      }
    }
  }
}

static void event(qcom_sGet* get)
{
  static int sav_event = 0;
  ini_mEvent cur_event;
  ini_mEvent new_event;
  qcom_sEvent* ep = (qcom_sEvent*)get->data;

  if (get->type.s != qcom_cIini)
    return;

  cur_event.m = sav_event;
  new_event.m = ep->mask;

  if (new_event.b.swapDone & !cur_event.b.swapDone) {
    errh_Info("Warm restart completed.");
    reinit_nodes();
    if (!LstEmpty(&node_l)) {
      list_state = eListState_Scan;
      scan_timers();
      scan_nodes();
    } else {
      list_state = eListState_NoNodeLink;
      errh_Info("No NodeLink objects.");
    }
  } else if (new_event.b.swapInit & !cur_event.b.swapInit) {
    list_state = eListState_Wait;
    errh_Info("Warm restart initiated.");
  } else if (new_event.b.terminate & !cur_event.b.terminate) {
    exit(0);
  }

  sav_event = ep->mask;
}

/* Initiates a sNode.  */

static sNode* init_node(pwr_tObjid oid, sNode* np, pwr_tBoolean new_sub)
{
  pwr_tStatus sts;
  pwr_sAttrRef aref;
  pwr_sClass_NodeLinkSup* o = NULL;
  gdh_tDlid dlid = pwr_cNDlid;
  pwr_tBoolean is_alias = 0;

  sts = gdh_IsAlias(oid, &is_alias);
  if (is_alias)
    return NULL;

  /* Allocate and initiate NodeLink control block */
  if (np == NULL) {
    aref = cdh_ObjidToAref(oid);
    sts = gdh_DLRefObjectInfoAttrref(&aref, (pwr_tAddress*)&o, &dlid);
    if (EVEN(sts)) {
      errh_Error("Couldn't get direct link to NodeLink object, %m", sts);
      return NULL;
    }
    np = (sNode*)calloc(1, sizeof(sNode));
    if (np == NULL) {
      if (cdh_DlidIsNotNull(dlid))
        gdh_DLUnrefObjectInfo(dlid);
      errh_Error("Error calloc, sNode");
      return NULL;
    }
    memcpy(&np->node, o, sizeof(np->node));
    np->dlid = dlid;
    np->o = o;
    np->oid = oid;
    np->timer = (void*)&o->TimerFlag;
  }

  /* Setup subscription to supervised Node object's attribute CurVersion. */

  if (new_sub) {
    int dt;
    int tmo;

    dt = MAX(1, (int)(o->SubscriptionInterval * 1000));
    tmo = MAX(2 * dt / 100, 100); /* 10 s */
    sts = gdh_SetSubscriptionDefaults(dt, tmo);

    aref.Objid = o->Node;
    sts = gdh_ClassAttrToAttrref(pwr_eClass_Node, ".SystemStatus", &aref);
    sts = gdh_SubRefObjectInfoAttrref(&aref, &o->SubId);
    if (EVEN(sts)) {
      errh_Error("Couldn't get link to Node object, %m", sts);
      o->SystemStatus = PWR__NETTIMEOUT;
    } else
      gdh_SubAssociateBuffer(
          o->SubId, (void**)&np->subvalue, sizeof(pwr_tStatus));
  }

  return np;
}

/* This routine initiates the NodeLink list.  */

static pwr_tStatus init_nodes()
{
  pwr_tStatus sts;
  struct LstHead * nl;
  sNode* np;
  pwr_tObjid oid;

  nl = &node_l;

  for (sts = gdh_GetClassList(pwr_cClass_NodeLinkSup, &oid); ODD(sts);
       sts = gdh_GetNextObject(oid, &oid)) {
    np = init_node(oid, NULL, 1);
    if (np != NULL) {
      LstInsert(nl, &np->node_l);
      nl = &np->node_l;
    }
  }

  if (LstEmpty(&node_l))
    errh_Info("No NodeLink objects");

  return (sts);
}

/* This routine search nodelink list for a nodelink object.  */

static sNode* get_nodes(pwr_tObjid oid)
{
  struct LstHead * nl;

  LstForEach(nl, &node_l) {
    if (cdh_ObjidIsEqual(LstEntry(nl, sNode, node_l)->oid, oid))
      return LstEntry(nl, sNode, node_l);
  }

  return NULL;
}

static void reinit_nodes()
{
  pwr_tStatus sts;
  struct LstHead * nl;
  sNode* np;
  pwr_tObjid oid;

  /* Mark all links in the NodeLink list */
  LstForEach(nl, &node_l)
    LstEntry(nl, sNode, node_l)->found = FALSE;

  for (sts = gdh_GetClassList(pwr_cClass_NodeLinkSup, &oid); ODD(sts);
       sts = gdh_GetNextObject(oid, &oid)) {
    if ((np = get_nodes(oid)) == NULL) {
      np = init_node(oid, NULL, 1);
      if (np != NULL) {
        LstInsert(nl, &np->node_l);
        nl = &np->node_l;
        np->found = TRUE;
      }
    } else {
      update_node(np);
    }
  }

  LstForEach(nl, &node_l) {
    np = LstEntry(nl, sNode, node_l);
    if (!np->found) {
      nl = np->node_l.prev;
      LstRemove(&np->node_l);
      LstNull(&np->node_l);
      gdh_SubUnrefObjectInfo(np->o->SubId);
      gdh_DLUnrefObjectInfo(np->dlid);
      free(np);
    }
  }
}

static void scan_nodes()
{
  struct LstHead * nl;
  pwr_tStatus sts;
  pwr_tBoolean Old;
  pwr_tTime LastUpdate, Timeout, CurrentTime;
  pwr_tDeltaTime Delta;
  pwr_tBoolean LinkUp;

  time_GetTime(&CurrentTime);

  LstForEach(nl, &node_l) {
    sNode* np = LstEntry(nl, sNode, node_l);
    pwr_sClass_NodeLinkSup* o = np->o;
    LinkUp = 0;
    sts = gdh_GetSubscriptionOldness(o->SubId, &Old, &LastUpdate, NULL);
    if (ODD(sts)) {
      /* IF (CurrentTime < LastUpdate + TimeoutTime) THEN LinkUp */
      Delta.tv_sec = o->TimeoutTime;
      Delta.tv_nsec = 0;
      time_Aadd(&Timeout, &LastUpdate, &Delta);
      if (time_Acomp(&CurrentTime, &Timeout) < 0)
        LinkUp = 1;
      o->SystemStatus = *np->subvalue;
    }

    if (o->LinkUp && !LinkUp) {
      o->LinkUp = 0;
      o->DownTime = CurrentTime;
      o->SystemStatus = PWR__NETTIMEOUT;
    } else if (!o->LinkUp && LinkUp) {
      o->LinkUp = 1;
      o->UpTime = CurrentTime;
      o->UpCount++;
    }

    detect(o, 1, np);
  }
}

static void scan_timers()
{
  struct LstHead * nl, *nxtnl;
  plc_sTimer* tp;

  for (nl = timer_l.next; nl != &timer_l; nl = nxtnl) {
    tp = LstEntry(nl, sNode, timer_l)->timer;
    nxtnl = nl->next;
    if (tp->TimerCount <= 1 || !tp->TimerFlag) {
      tp->TimerCount = 0;
      tp->TimerFlag = FALSE;
      LstRemove(nl);
      LstNull(nl);
    } else {
      tp->TimerCount--;
    }
  }
}

static void update_node(sNode* np)
{
  pwr_tBoolean new_sub;

  /* Check that the same Node object is supervised   */
  if (cdh_ObjidIsEqual(np->node.Node, np->o->Node)
      && feqf(np->node.SubscriptionInterval, np->o->SubscriptionInterval)) {
    new_sub = FALSE;
  } else {
    gdh_SubUnrefObjectInfo(np->o->SubId);
    np->o->SubId = pwr_cNSubid;
    new_sub = TRUE;
  }

  np = init_node(np->oid, np, new_sub);
  np->found = TRUE;
}
