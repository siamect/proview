/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_tmon.c -- Timer Monitor
*/

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#include "pwr.h"

static pwr_tTime* addTime(pwr_tTime* t1, pwr_tTime* t2);

static pwr_tTime* msToTime(pwr_tTime* it, int ms);

static pwr_tTime* subTime(pwr_tTime* t1, pwr_tTime* t2);

static pwr_tTime* nowTime(pwr_tTime* tp);

static void waitTime(pwr_tTime* t);

int main(int argc, char** argv)
{
  pwr_tStatus sts;
  pwr_tTime time;
  pwr_tTime now;
  int sec, nsec;

  for (sec = 0, nsec = 10000000;;) {
    nowTime(&now);
    printf("%d:%d\n", now.tv_sec, now.tv_nsec);
    waitTime(&now);
    nsec += 10000000;
    sec += nsec / 1000000000;
    nsec %= 1000000000;
  }
}

/* Add time2 to time1.  */

static pwr_tTime* addTime(pwr_tTime* t1, pwr_tTime* t2)
{
  int tv_nsec = t1->tv_nsec + t2->tv_nsec;
  int tv_sec = (int)t1->tv_sec + (int)t2->tv_sec;

  t1->tv_sec = (tv_sec + tv_nsec / 1000000000);
  t1->tv_nsec = tv_nsec % 1000000000;

  return t1;
}

/* Convert mille seconds to time format.  */

static pwr_tTime* msToTime(pwr_tTime* it, int ms)
{
  static pwr_tTime time;
  pwr_tTime* t = &time;

  if (it != NULL)
    t = it;

  t->tv_sec = ms / 1000;
  t->tv_nsec = (ms % 1000) * 1000000;

  return t;
}

/* Subtract time2 from time1.  */

static pwr_tTime* subTime(pwr_tTime* t1, pwr_tTime* t2)
{
  int tv_nsec = t1->tv_nsec - t2->tv_nsec;
  int tv_sec = (int)t1->tv_sec - (int)t2->tv_sec;

  tv_sec = tv_sec + tv_nsec / 1000000000;
  tv_nsec = tv_nsec % 1000000000;
  if (tv_nsec < 0 && tv_sec > 0) {
    tv_sec--;
    tv_nsec += 1000000000;
  } else if (tv_sec < 0 && tv_nsec > 0) {
    tv_sec++;
    tv_nsec -= 1000000000;
  }

  t1->tv_sec = tv_sec;
  t1->tv_nsec = tv_nsec;
  return t1;
}

/* Get current uptime.  */

static pwr_tTime* nowTime(pwr_tTime* tp)
{
  return tp;
}

/* Wait for a while.  */

static void waitTime(pwr_tTime* t)
{
  pwr_tStatus sts;
  pwr_tTime now;
  pwr_tTime then = *t;
  char tims[24];
  short len;
  struct dsc$descriptor_s tims_desc = {
    sizeof(tims) - 1, DSC$K_DTYPE_T, DSC$K_CLASS_S,
  };
}
