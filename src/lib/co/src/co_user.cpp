/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <stdlib.h>
#include <unistd.h>

#if defined OS_CYGWIN
#include <crypt.h>
#endif

#include <iostream>

#include "co_string.h"
#include "co_user.h"

extern "C" {
#include "pwr_privilege.h"
#include "co_cdh.h"
#include "co_user_msg.h"
}

static int check_file(char* filename);

GeUser::GeUser() : root(NULL)
{
  strcpy(version, "");
  strcpy(fname, "");
}

GeUser::~GeUser()
{
  SystemList *sl, *next;

  for (sl = root; sl;) {
    next = sl->next;
    delete sl;
    sl = next;
  }
}

void GeUser::clear()
{
  SystemList *sl, *next;

  for (sl = root; sl;) {
    next = sl->next;
    delete sl;
    sl = next;
  }
  root = 0;
}

int GeUser::load(char* filename)
{
  std::ifstream fp;
  int type;
  int end_found = 0;
  char dummy[40];

  strcpy(fname, filename);

  if (!check_file(filename))
    return USER__FILEOPEN;

  fp.open(filename);
  if (!fp)
    return USER__FILEOPEN;

  for (;;) {
    fp >> type;

    switch (type) {
    case user_eData_GeUser:
      break;
    case user_eData_GeUserVersion:
      fp.get();
      fp.getline(version, sizeof(version));
      if (!streq(version, user_cVersion)) {
        return USER__DBVERSION;
      }
      break;
    case user_eData_GeNextId:
      fp >> next_id;
      break;
    case user_eData_System:
      load_system(fp);
      break;
    case user_eData_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeUser:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }

  fp.close();
  return 1;
}

int GeUser::save(char* filename)
{
  std::ofstream fp;
  SystemList* sl;

  fp.open(filename);
  if (!fp)
    return USER__FILEOPEN;

  fp << int(user_eData_GeUser) << '\n';

  fp << int(user_eData_GeUserVersion) << FSPACE << user_cVersion << '\n';
  fp << int(user_eData_GeNextId) << FSPACE << next_id << '\n';
  for (sl = root; sl != NULL; sl = sl->next)
    sl->save(fp);

  fp << int(user_eData_End) << '\n';

  fp.close();
  return 1;
}

int GeUser::load_system(std::ifstream& fp)
{
  // Insert
  SystemList* system_list = new SystemList(0, "", 0, 0, 0);
  SystemList* sl = root;
  if (!sl)
    root = system_list;
  else {
    while (sl->next)
      sl = sl->next;
    sl->next = system_list;
  }
  system_list->load(fp);
  return 1;
}

int GeUser::add_system(
    char* name, pwr_tMask attributes, char* description, pwr_tOix id)
{
  int sts;

  SystemName* sn = new SystemName(name);
  sts = sn->parse();
  if (EVEN(sts)) {
    delete sn;
    return sts;
  }

  if (id == user_cNId)
    id = get_next_id();
  else if (id >= next_id)
    next_id = id + 1;

  SystemList* sl = find_system(sn);
  if (sl)
    return USER__SYSTEMALREXIST;

  SystemName* parent = sn->parent();
  if (!parent) {
    SystemList* sl;

    SystemList* system_list
        = new SystemList(id, name, 0, attributes, description);
    // Insert as last sibling to root
    if (!root)
      root = system_list;
    else {
      for (sl = root; sl->next; sl = sl->next)
        ;
      sl->next = system_list;
    }
  } else {
    parent->parse();
    SystemList* sl = find_system(parent);
    if (!sl) {
      delete sn;
      delete parent;
      return USER__NOSUCHSYSTEM;
    }
    sl->add_system(id, sn, attributes, description);
    delete parent;
  }
  delete sn;
  return USER__SUCCESS;
}

int GeUser::remove_system(char* name)
{
  int sts;
  SystemList *sl_p, *prev = NULL;

  SystemName* sn = new SystemName(name);
  sts = sn->parse();
  if (EVEN(sts)) {
    delete sn;
    return sts;
  }

  SystemList* sl = find_system(sn);
  if (!sl) {
    delete sn;
    return USER__NOSUCHSYSTEM;
  }
  if (sl->childlist || sl->userlist) {
    delete sn;
    return USER__SYSTEMNOTEMPTY;
  }

  SystemName* parent = sn->parent();
  if (!parent) {
    for (sl_p = root; sl_p; sl_p = sl_p->next) {
      if (sl_p == sl) {
        if (sl == root)
          root = sl->next;
        else
          prev->next = sl->next;
        delete sl;
        delete sn;
        return USER__SUCCESS;
      }
      prev = sl_p;
    }
  } else {
    parent->parse();
    SystemList* parent_system = find_system(parent);
    if (!parent_system)
      return USER__NOSUCHSYSTEM;

    sts = parent_system->remove_system(sl);
    delete sn;
    delete parent;
    return sts;
  }
  return USER__NOSUCHSYSTEM;
}

int GeUser::modify_system(char* name, pwr_tMask attributes, char* description)
{
  int sts;

  SystemName* sn = new SystemName(name);
  sts = sn->parse();
  if (EVEN(sts)) {
    delete sn;
    return sts;
  }

  SystemList* sl = find_system(sn);
  if (!sl) {
    delete sn;
    return USER__NOSUCHSYSTEM;
  }

  sl->modify(attributes, description);
  return USER__SUCCESS;
}

int GeUser::get_system_data(
    const char* name, pwr_tMask* attributes, pwr_tOix* id, char* description)
{
  int sts;

  SystemName* sn = new SystemName(name);
  sts = sn->parse();
  if (EVEN(sts)) {
    delete sn;
    return sts;
  }

  SystemList* sl = find_system(sn);
  if (!sl) {
    delete sn;
    return USER__NOSUCHSYSTEM;
  }

  sl->get_data(attributes, id, description);
  return USER__SUCCESS;
}

int GeUser::remove_user(char* system, char* user)
{
  int sts;

  SystemName* sn = new SystemName(system);
  sts = sn->parse();
  if (EVEN(sts)) {
    delete sn;
    return sts;
  }

  SystemList* sl = find_system(sn);
  if (!sl) {
    delete sn;
    return USER__NOSUCHSYSTEM;
  }
  sts = sl->remove_user(user);
  delete sn;
  return sts;
}

int GeUser::modify_user(char* system, char* user, char* password,
    unsigned int priv, char* fullname, char* description, char* email,
    char* phone, char* sms)
{
  int sts;
  UserList* ul;

  SystemName* sn = new SystemName(system);
  sts = sn->parse();
  if (EVEN(sts)) {
    delete sn;
    return sts;
  }

  SystemList* sl = find_system(sn);
  delete sn;
  if (!sl)
    return USER__NOSUCHSYSTEM;

  ul = (UserList*)sl->find_user(user);
  if (!ul)
    return USER__NOSUCHUSER;
  ul->modify(password, priv, fullname, description, email, phone, sms);

  return USER__SUCCESS;
}

int GeUser::get_user_data(char* system, char* user, char* password,
    pwr_tMask* priv, pwr_tOix* id, char* fullname, char* description,
    char* email, char* phone, char* sms)
{
  int sts;
  UserList* ul;

  SystemName* sn = new SystemName(system);
  sts = sn->parse();
  if (EVEN(sts)) {
    delete sn;
    return sts;
  }

  SystemList* sl = find_system(sn);
  delete sn;
  if (!sl)
    return USER__NOSUCHSYSTEM;

  ul = (UserList*)sl->find_user(user);
  if (!ul)
    return USER__NOSUCHUSER;
  ul->get_data(password, priv, id, fullname, description, email, phone, sms);

  return USER__SUCCESS;
}

SystemList* GeUser::find_system(SystemName* name)
{
  SystemList* sl;

  for (sl = root; sl; sl = sl->next) {
    if (str_NoCaseStrcmp(sl->name, name->segment(0)) == 0) {
      if (name->segments == sl->level + 1)
        return sl;
      return sl->find_system(name);
    }
  }
  return NULL;
}

int GeUser::add_user(char* system, char* user, char* password, pwr_tMask priv,
    char* fullname, char* description, char* email, char* phone, char* sms,
    pwr_tOix id)
{
  SystemList* sl;
  int sts;

  // Find system
  SystemName* sn = new SystemName(system);
  sts = sn->parse();
  if (EVEN(sts)) {
    delete sn;
    return sts;
  }
  sl = find_system(sn);
  if (!sl)
    return USER__NOSUCHSYSTEM;

  if (id == user_cNId)
    id = get_next_id();
  else if (id >= next_id)
    next_id = id + 1;

  sl->add_user(
      id, user, password, priv, fullname, description, email, phone, sms);
  return USER__SUCCESS;
}

int GeUser::get_user(const char* gu_system, const char* gu_user,
    const char* gu_password, unsigned int* priv)
{
  UserList* ul;
  SystemList* sl;
  SystemName *sn, *parent;
  int sts;
  char system[80];
  char password[80];
  char user[80];

  str_ToLower(system, gu_system);
  str_ToLower(user, gu_user);
  strcpy(password, gu_password);

  // Find system
  sn = new SystemName(system);
  sts = sn->parse();
  if (EVEN(sts)) {
    delete sn;
    return USER__NOSUCHSYSTEM;
  }

  while (sn) {
    sl = find_system(sn);
    if (sl) {
      ul = (UserList*)sl->find_user(user);
      if (ul) {
        sts = ul->check_password(password);
        if (EVEN(sts))
          return sts;
        *priv = ul->priv;
        return USER__SUCCESS;
      }
      if (!(sl->attributes & user_mSystemAttr_UserInherit))
        break;
    }
    parent = sn->parent();
    if (parent)
      parent->parse();
    delete sn;
    sn = parent;
  }
  return USER__NOSUCHUSER;
}

int GeUser::get_user_priv(
    const char* gu_system, const char* gu_user, unsigned int* priv)
{
  UserList* ul;
  SystemList* sl;
  SystemName *sn, *parent;
  int sts;
  char system[80];
  char user[80];

  str_ToLower(system, gu_system);
  str_ToLower(user, gu_user);

  // Find system
  sn = new SystemName(system);
  sts = sn->parse();
  if (EVEN(sts)) {
    delete sn;
    return USER__NOSUCHSYSTEM;
  }

  while (sn) {
    sl = find_system(sn);
    if (sl) {
      ul = (UserList*)sl->find_user(user);
      if (ul) {
        *priv = ul->priv;
        return USER__SUCCESS;
      }
      if (!(sl->attributes & user_mSystemAttr_UserInherit))
        break;
    }
    parent = sn->parent();
    if (parent)
      parent->parse();
    delete sn;
    sn = parent;
  }
  return USER__NOSUCHUSER;
}

void GeUser::print(int brief)
{
  SystemList* sl;

  std::cout << '\n' << "Proview user database " << user_cVersion << "\n\n";
  for (sl = root; sl != NULL; sl = sl->next)
    sl->print(brief);
  std::cout << '\n';
}

void GeUser::print_all(int brief)
{
  SystemList* sl;

  std::cout << '\n' << "Proview user database " << user_cVersion << "\n\n";
  for (sl = root; sl != NULL; sl = sl->next)
    sl->print_all(brief);
  std::cout << '\n';
}

SystemList::SystemList(pwr_tOix sl_id, const char* sl_name, int sl_level,
    unsigned int sl_attributes, char* sl_descr)
    : level(sl_level), attributes(sl_attributes), id(sl_id), next(0),
      childlist(0), userlist(0)
{
  strcpy(name, sl_name);
  if (sl_descr)
    strncpy(description, sl_descr, sizeof(description));
  else
    strcpy(description, "");
}

SystemList::~SystemList()
{
  SystemList *sl, *next_sl;
  UserList *ul, *next_ul;

  for (ul = (UserList*)userlist; ul;) {
    next_ul = ul->next;
    delete ul;
    ul = next_ul;
  }
  for (sl = childlist; sl;) {
    next_sl = sl->next;
    delete sl;
    sl = next_sl;
  }
}

int SystemList::load(std::ifstream& fp)
{
  int type;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    fp >> type;

    switch (type) {
    case user_eData_SystemName:
      fp.get();
      fp.getline(name, sizeof(name));
      break;
    case user_eData_SystemLevel:
      fp >> level;
      break;
    case user_eData_SystemAttributes:
      fp >> attributes;
      break;
    case user_eData_SystemId:
      fp >> id;
      break;
    case user_eData_SystemDescription:
      fp.get();
      fp.getline(description, sizeof(description));
      break;
    case user_eData_User:
      load_user(fp);
      break;
    case user_eData_System:
      load_system(fp);
      break;
    case user_eData_End:
      end_found = 1;
      break;
    default:
      std::cout << "System:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
  return 1;
}

int SystemList::load_user(std::ifstream& fp)
{
  // Insert
  UserList* user_list = new UserList(0, "", "", 0, 0, 0, 0, 0, 0);
  UserList* ul = userlist;
  if (!ul)
    userlist = user_list;
  else {
    while (ul->next)
      ul = ul->next;
    ul->next = user_list;
  }
  user_list->load(fp);
  return 1;
}

int SystemList::load_system(std::ifstream& fp)
{
  // Insert
  SystemList* system_list = new SystemList(0, "", 0, 0, 0);
  SystemList* sl = childlist;
  if (!sl)
    childlist = system_list;
  else {
    while (sl->next)
      sl = sl->next;
    sl->next = system_list;
  }
  system_list->load(fp);
  return 1;
}

void SystemList::save(std::ofstream& fp)
{
  UserList* ul;
  SystemList* sl;

  fp << int(user_eData_System) << '\n';
  fp << int(user_eData_SystemName) << FSPACE << name << '\n';
  fp << int(user_eData_SystemLevel) << FSPACE << level << '\n';
  fp << int(user_eData_SystemAttributes) << FSPACE << attributes << '\n';
  fp << int(user_eData_SystemId) << FSPACE << id << '\n';
  fp << int(user_eData_SystemDescription) << FSPACE << description << '\n';
  for (ul = (UserList*)userlist; ul != NULL; ul = ul->next)
    ul->save(fp);
  for (sl = childlist; sl; sl = sl->next)
    sl->save(fp);
  fp << int(user_eData_End) << '\n';
}

void SystemList::print(int brief)
{
  UserList* ul;
  SystemList* sl;
  int i, j;

  for (i = 0; i < level; i++)
    std::cout << ". ";
  std::cout << name;
  std::cout << " ";
  for (j = 0; j < int(22 - 2 * i - strlen(name)); j++)
    std::cout << " ";
  if (attributes & user_mSystemAttr_UserInherit)
    std::cout << "UserInherit";
  std::cout << '\n';
  for (ul = (UserList*)userlist; ul; ul = ul->next)
    ul->print(brief);
  for (sl = childlist; sl; sl = sl->next)
    sl->print(brief);
}

void SystemList::print_all(int brief)
{
  UserList* ul;
  SystemList* sl;
  int i, j;

  for (i = 0; i < level; i++)
    std::cout << ". ";
  std::cout << name;
  std::cout << " ";
  for (j = 0; j < int(22 - 2 * i - strlen(name)); j++)
    std::cout << " ";
  if (attributes & user_mSystemAttr_UserInherit)
    std::cout << "UserInherit";
  std::cout << '\n';
  for (ul = (UserList*)userlist; ul; ul = ul->next)
    ul->print_all(brief);
  for (sl = childlist; sl; sl = sl->next)
    sl->print_all(brief);
}

SystemList* SystemList::find_system(SystemName* name)
{
  SystemList* sl;

  for (sl = childlist; sl; sl = sl->next) {
    if (str_NoCaseStrcmp(sl->name, name->segment(sl->level)) == 0) {
      if (name->segments == sl->level + 1)
        return sl;
      return sl->find_system(name);
    }
  }
  return NULL;
}

void* SystemList::find_user(char* name)
{
  UserList* ul;

  for (ul = (UserList*)userlist; ul != NULL; ul = ul->next) {
    if (str_NoCaseStrcmp(ul->name, name) == 0)
      return ul;
  }
  return NULL;
}

int SystemList::add_user(pwr_tOix ident, char* user, char* password,
    pwr_tMask priv, char* fullname, char* description, char* email, char* phone,
    char* sms)
{
  UserList* ul;

  // Check if user exist
  ul = (UserList*)find_user(user);
  if (ul)
    return USER__USERALREXIST;

  ul = new UserList(
      ident, user, password, priv, fullname, description, email, phone, sms);
  UserList* u = userlist;
  if (!u)
    userlist = ul;
  else {
    while (u->next)
      u = u->next;
    u->next = ul;
  }
  return USER__SUCCESS;
}

int SystemList::add_system(
    pwr_tOix ident, SystemName* name, pwr_tMask attributes, char* description)
{
  SystemList* sl;

  // Check if system exist
  sl = find_system(name);
  if (sl)
    return USER__SYSTEMALREXIST;

  sl = new SystemList(
      ident, name->segment(level + 1), level + 1, attributes, description);
  SystemList* s = childlist;
  if (!s)
    childlist = sl;
  else {
    while (s->next)
      s = s->next;
    s->next = sl;
  }
  return USER__SUCCESS;
}

int SystemList::remove_system(SystemList* sys)
{
  SystemList *sl, *prev = NULL;

  for (sl = childlist; sl; sl = sl->next) {
    if (sl == sys) {
      if (sl == childlist)
        childlist = sl->next;
      else
        prev->next = sl->next;
      delete sl;
      return USER__SUCCESS;
    }
    prev = sl;
  }
  return USER__NOSUCHSYSTEM;
}

int SystemList::remove_user(char* user)
{
  UserList *ul, *ul_p, *prev = NULL;

  ul = (UserList*)find_user(user);
  if (!ul)
    return USER__NOSUCHUSER;

  for (ul_p = (UserList*)userlist; ul_p; ul_p = ul_p->next) {
    if (ul == ul_p) {
      if (ul == (UserList*)userlist)
        userlist = ul->next;
      else
        prev->next = ul->next;
      delete ul;
      return USER__SUCCESS;
    }
    prev = ul_p;
  }
  return USER__NOSUCHUSER;
}

void SystemList::modify(unsigned int attributes, char* description)
{
  this->attributes = attributes;
  if (description)
    strncpy(this->description, description, sizeof(this->description));
}

void SystemList::get_data(
    pwr_tMask* attributes, pwr_tOix* id, char* description)
{
  *attributes = this->attributes;
  *id = this->id;
  strcpy(description, this->description);
}

UserList::UserList(pwr_tOix ul_id, const char* ul_name, const char* ul_password,
    pwr_tMask ul_priv, const char* ul_fullname, const char* ul_description,
    const char* ul_email, const char* ul_phone, const char* ul_sms)
    : priv(ul_priv), id(ul_id), next(NULL)
{
  strcpy(name, ul_name);
  strcpy(password, ul_password);
  if (ul_fullname)
    strncpy(fullname, ul_fullname, sizeof(fullname));
  else
    strcpy(fullname, "");
  if (ul_description)
    strncpy(description, ul_description, sizeof(description));
  else
    strcpy(description, "");
  if (ul_email)
    strncpy(email, ul_email, sizeof(email));
  else
    strcpy(email, "");
  if (ul_phone)
    strncpy(phone, ul_phone, sizeof(phone));
  else
    strcpy(phone, "");
  if (ul_sms)
    strncpy(sms, ul_sms, sizeof(sms));
  else
    strcpy(sms, "");
};

int UserList::load(std::ifstream& fp)
{
  int type;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    fp >> type;

    switch (type) {
    case user_eData_User:
      break;
    case user_eData_UserName:
      fp.get();
      fp.getline(name, sizeof(name));
      break;
    case user_eData_UserPassword:
      fp.get();
      fp.getline(password, sizeof(password));
      break;
    case user_eData_UserPrivilege:
      fp >> priv;
      priv = idecrypt(priv);
      break;
    case user_eData_UserId:
      fp >> id;
      break;
    case user_eData_UserFullName:
      fp.get();
      fp.getline(fullname, sizeof(fullname));
      break;
    case user_eData_UserDescription:
      fp.get();
      fp.getline(description, sizeof(description));
      break;
    case user_eData_UserEmail:
      fp.get();
      fp.getline(email, sizeof(email));
      break;
    case user_eData_UserPhone:
      fp.get();
      fp.getline(phone, sizeof(phone));
      break;
    case user_eData_UserSms:
      fp.get();
      fp.getline(sms, sizeof(sms));
      break;
    case user_eData_End:
      end_found = 1;
      break;
    default:
      std::cout << "User:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
  return 1;
}

void UserList::save(std::ofstream& fp)
{
  fp << int(user_eData_User) << '\n';
  fp << int(user_eData_UserName) << FSPACE << name << '\n';
  fp << int(user_eData_UserPassword) << FSPACE << password << '\n';
  fp << int(user_eData_UserPrivilege) << FSPACE << icrypt(priv) << '\n';
  fp << int(user_eData_UserId) << FSPACE << id << '\n';
  fp << int(user_eData_UserFullName) << FSPACE << fullname << '\n';
  fp << int(user_eData_UserDescription) << FSPACE << description << '\n';
  fp << int(user_eData_UserEmail) << FSPACE << email << '\n';
  fp << int(user_eData_UserPhone) << FSPACE << phone << '\n';
  fp << int(user_eData_UserSms) << FSPACE << sms << '\n';
  fp << int(user_eData_End) << '\n';
}

void UserList::print_all(int brief)
{
  if (brief)
    return;
  print(brief);
  for (int i = 0; i < 6; i++)
    std::cout << ". ";
  std::cout << "  "
            << "Password    " << password << '\n';
}

void UserList::print(int brief)
{
  int i;
  char priv_str[300];

  if (brief) {
    for (i = 0; i < 6; i++)
      std::cout << ". ";
    std::cout << name << " ";
    for (i = 0; i < int(10 - strlen(name)); i++)
      std::cout << " ";
    GeUser::priv_to_string(priv, priv_str, sizeof(priv_str));
    std::cout << priv_str;
    std::cout << "(" << priv << ")\n";
  } else {
    for (i = 0; i < 6; i++)
      std::cout << ". ";
    std::cout << name << '\n';

    for (i = 0; i < 6; i++)
      std::cout << ". ";
    std::cout << "  "
              << "Id          " << id << '\n';

    for (i = 0; i < 6; i++)
      std::cout << ". ";
    std::cout << "  "
              << "Priv        ";
    GeUser::priv_to_string(priv, priv_str, sizeof(priv_str));
    std::cout << priv_str;
    std::cout << "(" << priv << ")\n";

    for (i = 0; i < 6; i++)
      std::cout << ". ";
    std::cout << "  "
              << "FullName    " << fullname << '\n';

    for (i = 0; i < 6; i++)
      std::cout << ". ";
    std::cout << "  "
              << "Description " << description << '\n';

    for (i = 0; i < 6; i++)
      std::cout << ". ";
    std::cout << "  "
              << "Email       " << email << '\n';

    for (i = 0; i < 6; i++)
      std::cout << ". ";
    std::cout << "  "
              << "Phone       " << phone << '\n';

    for (i = 0; i < 6; i++)
      std::cout << ". ";
    std::cout << "  "
              << "Sms         " << sms << '\n';
  }
}

void UserList::get_sms(char* s, int size)
{
  strncpy(s, sms, size);
}
void UserList::get_email(char* s, int size)
{
  strncpy(s, email, size);
}

char* UserList::pwcrypt(const char* str)
{
  static char cstr[200];

  strcpy(cstr, crypt(str, "aa"));

  return cstr;
}

unsigned int UserList::icrypt(unsigned int i)
{
  return ~(i + 123456);
}

unsigned int UserList::idecrypt(unsigned int i)
{
  return ~i - 123456;
}

void UserList::modify(char* password, pwr_tMask priv, char* fullname,
    char* description, char* email, char* phone, char* sms)
{
  strcpy(this->password, password);
  this->priv = priv;
  if (fullname)
    strncpy(this->fullname, fullname, sizeof(this->fullname));
  if (description)
    strncpy(this->description, description, sizeof(this->description));
  if (email)
    strncpy(this->email, email, sizeof(this->email));
  if (phone)
    strncpy(this->phone, phone, sizeof(this->phone));
  if (sms)
    strncpy(this->sms, sms, sizeof(this->sms));
}

void UserList::get_data(char* password, unsigned int* priv, pwr_tOix* id,
    char* fullname, char* description, char* email, char* phone, char* sms)
{
  strcpy(password, this->password);
  *priv = this->priv;
  *id = this->id;
  strcpy(fullname, this->fullname);
  strcpy(description, this->description);
  strcpy(email, this->email);
  strcpy(phone, this->phone);
  strcpy(sms, this->sms);
}

int UserList::check_password(char* password)
{
  if (streq(this->password, password))
    return USER__SUCCESS;
  return USER__NOTAUTHORIZED;
}

SystemName::SystemName(const char* system_name) : segments(0)
{
  strcpy(pathname, system_name);
}

int SystemName::parse()
{
  char *seg_start, *t;

  t = pathname;
  seg_start = pathname;
  for (t = pathname;; t++) {
    if (*t == '.' || *t == 0) {
      strncpy(segname[segments], seg_start, t - seg_start);
      segname[segments][t - seg_start] = 0;
      if (streq(segname[segments], ""))
        return USER__INVSYSNAME;
      segments++;
      if (segments >= int(sizeof(segname) / sizeof(segname[0])))
        break;
      seg_start = t + 1;
      if (*t == 0)
        break;
    }
  }
  return 1;
}

SystemName* SystemName::parent()
{
  char parent_name[80];

  if (segments == 1)
    return 0;

  strcpy(parent_name, segname[0]);
  for (int i = 1; i < segments - 1; i++) {
    strcat(parent_name, ".");
    strcat(parent_name, segname[i]);
  }

  return new SystemName(parent_name);
}

char* GeUser::get_status(int sts)
{
  static char str[80];

  switch (sts) {
  case USER__SUCCESS:
    strcpy(str, "Success");
    break;
  case USER__INVSYSNAME:
    strcpy(str, "Invalid system name");
    break;
  case USER__NOSUCHSYSTEM:
    strcpy(str, "No such system");
    break;
  case USER__NOSUCHUSER:
    strcpy(str, "No such user");
    break;
  case USER__NOTAUTHORIZED:
    strcpy(str, "User not autorized");
    break;
  case USER__USERALREXIST:
    strcpy(str, "User already exist");
    break;
  case USER__SYSTEMALREXIST:
    strcpy(str, "System already exist");
    break;
  case USER__SYSTEMNOTEMPTY:
    strcpy(str, "System is not empty");
    break;
  default:
    strcpy(str, "Undefined message");
  }
  return str;
}

// Fix because of bug in the cc-compiler on VMS
static int check_file(char* filename)
{
  FILE* fp;

  fp = fopen(filename, "r");
  if (!fp)
    return 0;

  fclose(fp);
  return 1;
}

void GeUser::priv_to_string(unsigned int priv, char* str, int size)
{
  char buff[300];

  buff[0] = 0;
  if (priv & pwr_mPrv_RtRead)
    strcat(buff, "RtRead ");
  if (priv & pwr_mPrv_RtWrite)
    strcat(buff, "RtWrite ");
  if (priv & pwr_mPrv_RtEventsBlock)
    strcat(buff, "RtEventsBlock ");
  if (priv & pwr_mPrv_RtEventsAck)
    strcat(buff, "RtEventsAck ");
  if (priv & pwr_mPrv_RtPlc)
    strcat(buff, "RtPlc ");
  if (priv & pwr_mPrv_RtNavigator)
    strcat(buff, "RtNavigator ");
  if (priv & pwr_mPrv_System)
    strcat(buff, "System ");
  if (priv & pwr_mPrv_Maintenance)
    strcat(buff, "Maintenance ");
  if (priv & pwr_mPrv_Process)
    strcat(buff, "Process ");
  if (priv & pwr_mPrv_Instrument)
    strcat(buff, "Instrument ");
  if (priv & pwr_mPrv_Operator1)
    strcat(buff, "Operator1 ");
  if (priv & pwr_mPrv_Operator2)
    strcat(buff, "Operator2 ");
  if (priv & pwr_mPrv_Operator3)
    strcat(buff, "Operator3 ");
  if (priv & pwr_mPrv_Operator4)
    strcat(buff, "Operator4 ");
  if (priv & pwr_mPrv_Operator5)
    strcat(buff, "Operator5 ");
  if (priv & pwr_mPrv_Operator6)
    strcat(buff, "Operator6 ");
  if (priv & pwr_mPrv_Operator7)
    strcat(buff, "Operator7 ");
  if (priv & pwr_mPrv_Operator8)
    strcat(buff, "Operator8 ");
  if (priv & pwr_mPrv_Operator9)
    strcat(buff, "Operator9 ");
  if (priv & pwr_mPrv_Operator10)
    strcat(buff, "Operator10 ");
  if (priv & pwr_mPrv_DevRead)
    strcat(buff, "DevRead ");
  if (priv & pwr_mPrv_DevPlc)
    strcat(buff, "DevPlc ");
  if (priv & pwr_mPrv_DevConfig)
    strcat(buff, "DevConfig ");
  if (priv & pwr_mPrv_DevClass)
    strcat(buff, "DevClass ");
  if (priv & pwr_mPrv_Administrator)
    strcat(buff, "Administrator ");
  if (priv & pwr_mPrv_SevRead)
    strcat(buff, "SevRead ");
  if (priv & pwr_mPrv_SevAdmin)
    strcat(buff, "SevAdmin ");
  strncpy(str, buff, size);
  str[size - 1] = 0;
}

void GeUser::rt_priv_to_string(unsigned int priv, char* str, int size)
{
  char buff[300];

  buff[0] = 0;
  if (priv & pwr_mPrv_RtRead)
    strcat(buff, "RtRead ");
  if (priv & pwr_mPrv_RtWrite)
    strcat(buff, "RtWrite ");
  if (priv & pwr_mPrv_RtEventsBlock)
    strcat(buff, "RtEventsBlock ");
  if (priv & pwr_mPrv_RtEventsAck)
    strcat(buff, "RtEventsAck ");
  if (priv & pwr_mPrv_RtPlc)
    strcat(buff, "RtPlc ");
  if (priv & pwr_mPrv_RtNavigator)
    strcat(buff, "RtNavigator ");
  if (priv & pwr_mPrv_System)
    strcat(buff, "System ");
  if (priv & pwr_mPrv_Maintenance)
    strcat(buff, "Maintenance ");
  if (priv & pwr_mPrv_Process)
    strcat(buff, "Process ");
  if (priv & pwr_mPrv_Instrument)
    strcat(buff, "Instrument ");
  if (priv & pwr_mPrv_Operator1)
    strcat(buff, "Operator1 ");
  if (priv & pwr_mPrv_Operator2)
    strcat(buff, "Operator2 ");
  if (priv & pwr_mPrv_Operator3)
    strcat(buff, "Operator3 ");
  if (priv & pwr_mPrv_Operator4)
    strcat(buff, "Operator4 ");
  if (priv & pwr_mPrv_Operator5)
    strcat(buff, "Operator5 ");
  if (priv & pwr_mPrv_Operator6)
    strcat(buff, "Operator6 ");
  if (priv & pwr_mPrv_Operator7)
    strcat(buff, "Operator7 ");
  if (priv & pwr_mPrv_Operator8)
    strcat(buff, "Operator8 ");
  if (priv & pwr_mPrv_Operator9)
    strcat(buff, "Operator9 ");
  if (priv & pwr_mPrv_Operator10)
    strcat(buff, "Operator10 ");
  if (priv & pwr_mPrv_SevRead)
    strcat(buff, "SevRead ");
  if (priv & pwr_mPrv_SevAdmin)
    strcat(buff, "SevAdmin ");
  strncpy(str, buff, size);
  str[size - 1] = 0;
}

void GeUser::dev_priv_to_string(unsigned int priv, char* str, int size)
{
  char buff[300];

  buff[0] = 0;
  if (priv & pwr_mPrv_DevRead)
    strcat(buff, "DevRead ");
  if (priv & pwr_mPrv_DevPlc)
    strcat(buff, "DevPlc ");
  if (priv & pwr_mPrv_DevConfig)
    strcat(buff, "DevConfig ");
  if (priv & pwr_mPrv_DevClass)
    strcat(buff, "DevClass ");
  if (priv & pwr_mPrv_Administrator)
    strcat(buff, "Administrator ");
  strncpy(str, buff, size);
  str[size - 1] = 0;
}

SystemList* GeUser::get_system(UserList* user)
{
  SystemList* sl = root;
  while (sl) {
    UserList* ul = sl->userlist;
    while (ul) {
      if (ul == user)
        return sl;
      ul = ul->next;
    }
    SystemList* found_sl = get_system_child(sl, user);
    if (found_sl)
      return found_sl;
    sl = sl->next;
  }

  return 0;
}

SystemList* GeUser::get_system_child(SystemList* system, UserList* user)
{
  SystemList* sl = system->childlist;
  while (sl) {
    UserList* ul = sl->userlist;
    while (ul) {
      if (ul == user)
        return sl;
      ul = ul->next;
    }
    SystemList* found_sl = get_system_child(sl, user);
    if (found_sl)
      return found_sl;
    sl = sl->next;
  }

  return 0;
}

bool GeUser::get_system_name(SystemList* system, char* name)
{
  SystemList* sl = root;
  while (sl) {
    if (sl == system) {
      strcpy(name, sl->name);
      return true;
    }
    if (get_system_name_child(sl, system, name)) {
      char tmp[256];
      strcpy(tmp, name);
      strcpy(name, sl->name);
      strcat(name, ".");
      strcat(name, tmp);
      return true;
    }
    sl = sl->next;
  }
  return false;
}

bool GeUser::get_system_name_child(
    SystemList* s, SystemList* system, char* name)
{
  SystemList* sl = s->childlist;
  while (sl) {
    if (sl == system) {
      strcpy(name, sl->name);
      return true;
    }
    if (get_system_name_child(sl, system, name)) {
      char tmp[256];
      strcpy(tmp, name);
      strcpy(name, sl->name);
      strcat(name, ".");
      strcat(name, tmp);
      return true;
    }
    sl = sl->next;
  }
  return false;
}
