/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */
#ifndef co_string_h
#define co_string_h

#include <string.h>

/*! \file co_string.h
    \brief General useful string manipulation functions.
 */

/*! \def streq(a,b)
    \brief Checks if two strings \a a and \a b are equal

    strcmp returns 0 (i.e. false) if the strings are equal, which is not obvious
    streq(a,b) is more readable and easier to understand than strcmp(a,b) == 0
 */
#define streq(a,b) (strcmp((a),(b)) == 0)

/*! \def str_StartsWith(str,prefix)
    \brief Checks if the \a str starts with the substring \a prefix
 */
#define str_StartsWith(str, prefix) (strncmp(str, prefix, strlen(prefix)) == 0)

#ifdef __cplusplus
extern "C" {
#endif

/*! \fn char* str_ToLower(char* dst, const char* src)
    \brief Converts the string \a src to lower case,
    puts the result in \a dst and returns \a dst

    Handles all ISO 8859-1 characters, not only ASCII.
    If src is NULL, dst is used also as input string.

    \param dst	Output string.
    \param src	Input string.
    \return 	Returns dst.
*/
char* str_ToLower(char* dst, const char* src);

/*! \fn char* str_ToUpper(char* dst, const char* src)
    \brief Converts the string \a src to upper case,
    puts the result in \a dst and returns \a dst

    Handles all ISO 8859-1 characters, not only ASCII.
    If src is NULL, dst is used also as input string.

    \param dst	Output string.
    \param src	Input string.
    \return 	Returns dst.
*/
char* str_ToUpper(char* dst, const char* src);

/*! \fn int str_NoCaseStrcmp(const char* s, const char* t)
    \brief Compares two strings \a s and \a t, disregarding their case.

     This routine works only on alphabetic characters.
     It works on the standard ascii a-z and on the
     DEC multinational extensions.

     The function exploits the fact that only bit 5 changes
     when you change the case of a character.

     \return The uppercase offset between the two first differing characters.
*/
int str_NoCaseStrcmp(const char* s, const char* t);

/*! \fn int str_NoCaseStrncmp(const char* s, const char* t, size_t n)
    \brief Compares the first n (at most) characters of two strings
    \a s and \a t, disregarding their case.

    This routine works only on alphabetic characters.
    It works on the standard ascii a-z and on the
    DEC multinational extensions.

    The function exploits the fact that only bit 5 changes
    when you change the case of a character.

    \return The uppercase offset between the two first differing characters.
*/
int str_NoCaseStrncmp(const char* s, const char* t, size_t n);

/*! \fn char* str_Strcpy(char* dst, const char* src)
    \brief Copies \a src into \a dst character by character to allow
    overlapping source and destination buffers.
*/
char* str_Strcpy(char* dst, const char* src);

/*! \fn char* str_Strncpy(char* dst, const char* src, size_t n)
    \brief Copies the first n (at most) characters of \a src into \a dst
    character by character to allow overlapping source and destination buffers.
*/
char* str_Strncpy(char* dst, const char* src, size_t n);

/*! \fn int str_StrncpyCutOff(char* dst, const char* src, size_t n, int cutleft)
    \brief Copies the first n (at most) characters of \a src into \a dst
    character by character to allow overlapping source and destination buffers.
    Cuts of the string if it is to long, and replaces the ending with '...'

    For example str_StrncpyCutOff(dst, '0123456789', 8) will return '0123...',
    which is 8 characters including the terminating NULL character.

    \param src Input string.
    \param dst Output string.
    \param n Size of out string.
    \param cutleft Whether to cut the first characters of the string instead of the last.
    \return 1 if the string was cut off, else 0.
*/
int str_StrncpyCutOff(char* dst, const char* src, size_t n, int cutleft);

/*! \fn int str_trim(char* dst, const char* src)
    \brief Copies \a src to \a dst trimming leading and trailing whitespace

    For example: after str_trim(dst, '  test  '), dst will be 'test'.

    \param src Input string.
    \param dst Output string.
*/
void str_trim(char *dst, const char *src);

#ifdef __cplusplus
}
#endif

#endif
