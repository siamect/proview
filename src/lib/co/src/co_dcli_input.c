/**
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2019 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 **/

/* co_dcli_input.c
   Commandline input. */

/*_Include files_________________________________________________________*/

#include <fcntl.h>
#include <stdarg.h>
#include <termios.h>
#include <unistd.h>

#include "pwr_class.h"
#include "co_dcli.h"
#include "co_dcli_input.h"
#include "co_dcli_msg.h"
#include "co_string.h"

/***********************  D E F I N E ' S *******************************/

#define DCLI_K_MAXLEN 0

#define DCLI_TERM 1000
#define DCLI_K_DELETE 127
#define DCLI_K_ARROW_UP 274
#define DCLI_K_ARROW_DOWN 275
#define DCLI_K_ARROW_RIGHT 276
#define DCLI_K_ARROW_LEFT 277
#define DCLI_K_TIMEOUT 282
#define DCLI_K_RETURN 10
#define DCLI_K_BACKSPACE 8
#define DCLI_K_CTRLC 3
#define DCLI_K_ESCAPE 27

static unsigned short state_table[3][256];

/***********************  T Y P E D E F ' S *****************************/

/*__Local function prototypes_________________________________________*/

static int r_print(dcli_sChannel* chn, char* format, ...)
{
  char buff[400];
  int sts;
  va_list ap;
  int len;

  va_start(ap, format);
  len = vsprintf(buff, format, ap);
  va_end(ap);
  sts = dcli_qio_writew(chn, buff, len);
  return sts;
}

/*************************************************************************
*
* Name:		init_state_table()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Initialization of the stat_table used by dcli_get_input.
*
**************************************************************************/

static int init_state_table()
{
  static int done = 0;

  if (!done) {
    state_table[0][DCLI_K_RETURN] = DCLI_TERM + DCLI_K_RETURN;
    state_table[0][DCLI_K_CTRLC] = DCLI_TERM + DCLI_K_CTRLC;
    state_table[0][DCLI_K_DELETE] = DCLI_TERM + DCLI_K_DELETE;
    state_table[0][DCLI_K_BACKSPACE] = DCLI_TERM + DCLI_K_BACKSPACE;
    state_table[0][DCLI_K_ESCAPE] = 1;
    state_table[0][155] = 2;
    state_table[1][91] = 2; /* state ESCAPE */
    state_table[2][65] = DCLI_TERM + DCLI_K_ARROW_UP;
    state_table[2][66] = DCLI_TERM + DCLI_K_ARROW_DOWN;
    state_table[2][67] = DCLI_TERM + DCLI_K_ARROW_RIGHT;
    state_table[2][68] = DCLI_TERM + DCLI_K_ARROW_LEFT;
    done = 1;
  }
  return DCLI__SUCCESS;
}

static void store_cursorpos(dcli_sChannel* chn)
{
  char char_ins[] = { 27, 55, 0 };

  r_print(chn, "%s", char_ins);
}

static void restore_cursorpos(dcli_sChannel* chn)
{
  char char_ins[] = { 27, 56, 0 };

  r_print(chn, "%s", char_ins);
}

static void eofline_erase(dcli_sChannel* chn)
{
  char char_ins[] = { 27, 91, 48, 75, 0 };

  r_print(chn, "%s", char_ins);
}

static void cursor_rel(dcli_sChannel* chn, int x, int y)
{
  char cursor_f[] = { 27, 91, 0, 0, 67, 0 };
  char cursor_b[] = { 27, 91, 0, 0, 68, 0 };
  char cursor_u[] = { 27, 91, 0, 0, 65, 0 };
  char cursor_d[] = { 27, 91, 0, 0, 66, 0 };

  if (y > 0) {
    cursor_f[2] = y / 10 + 48;
    cursor_f[3] = y - (y / 10) * 10 + 48;
    r_print(chn, "%s", cursor_f);
  } else if (y < 0) {
    cursor_b[2] = -y / 10 + 48;
    cursor_b[3] = -y + (y / 10) * 10 + 48;
    r_print(chn, "%s", cursor_b);
  }
  if (x > 0) {
    cursor_u[2] = x / 10 + 48;
    cursor_u[3] = x - (x / 10) * 10 + 48;
    r_print(chn, "%s", cursor_u);
  } else if (x < 0) {
    cursor_d[2] = -x / 10 + 48;
    cursor_d[3] = -x + (x / 10) * 10 + 48;
    r_print(chn, "%s", cursor_d);
  }
}

static void char_delete(dcli_sChannel* chn, int n)
{
  char char_del[5] = { 27, 91, 0, 80, 0 };

  char_del[2] = n;
  r_print(chn, "%s", char_del);
}

static void char_insert_nob(dcli_sChannel* chn, int n)
{
  char char_ins[] = { 27, 91, 0, 0, 64, 0 };

  char_ins[2] = n / 10 + 48;
  char_ins[3] = n - (n / 10) * 10 + 48;
  r_print(chn, "%s", char_ins);
}

int dcli_get_input(dcli_sChannel* chn, char* input_str,
    unsigned long* terminator, int maxlen, unsigned long option, int timeout)
{
  unsigned char c;
  char* input_ptr;
  int i;
  int sts;
  int state;

  input_ptr = input_str;

  for (i = 0; i < maxlen; i++) {
    if ((option & DCLI_OPT_TIMEOUT) == 0)
      dcli_qio_readw(chn, (char*)&c, 1);
    else {
      sts = dcli_qio_read(chn, timeout, (char*)&c, 1);
      if (!sts) {
        /* Timeout */
        *terminator = DCLI_K_TIMEOUT;
        *input_ptr = '\0';
        return 1;
      }
    }

    state = DCLI_TERM;
    while (state > 0) {
      if (state == DCLI_TERM)
        /* first time */
        state = 0;

      state = state_table[state][c];
      if (state > DCLI_TERM) {
        *terminator = state - DCLI_TERM;
        switch (*terminator) {
        case DCLI_K_RETURN:
        case DCLI_K_CTRLC: {
          *input_ptr = '\0';
          if (((option & DCLI_OPT_NOECHO) == 0)
              && ((option & DCLI_OPT_NOSCROLL) == 0))
            r_print(chn, "\n\r");
          return 1;
        }
        default: {
          *input_ptr = '\0';
          return 1;
        }
        }
      } else if (state > 0)
        dcli_qio_readw(chn, (char*)&c, 1);
    }

    if (c > 31) {
      /* Some ordinary charachter */
      *input_ptr = c;
      input_ptr++;
      if ((option & DCLI_OPT_NOECHO) == 0) {
        char_insert_nob(chn, 1);
        r_print(chn, "%c", c);
      }
    }
  }
  *terminator = DCLI_K_MAXLEN;
  *input_ptr = '\0';
  if ((option & DCLI_OPT_NOECHO) == 0)
    r_print(chn, "\n\r");
  return 1;
}

/*************************************************************************
*
* Name:		dcli_recall_create()
*
* Type		int
*
* Type		Parameter	IOGF	Description
* dcli_sRecall **recall		O	recall buffer.
*
* Description:
*	Create a recall buffer.
*
**************************************************************************/

int dcli_recall_create(dcli_sRecall** recall)
{
  *recall = calloc(1, sizeof(dcli_sRecall));
  if (*recall == 0)
    return DCLI__NOMEMORY;
  (*recall)->first_command = -1;
  return DCLI__SUCCESS;
}

void dcli_recall_free(dcli_sRecall* recall)
{
  free((char*)recall);
}

/*************************************************************************
*
* Name:		dcli_recall_insert()
*
* Type		int
*
* Type		Parameter	IOGF	Description
* dcli_sRecall 	*recall		I	recall buffer.
* char		*command	I	string to insert in recall.
*
* Description:
*	Inserts a command in the recall buffer.
*
**************************************************************************/

static int dcli_recall_insert(dcli_sRecall* recall, char* command)
{
  if (*command == 0)
    return DCLI__SUCCESS;
  if (streq((char*)recall->command[recall->last_command], command))
    return DCLI__SUCCESS;

  recall->last_command++;
  if (recall->last_command >= DCLI_RECALL_MAX)
    recall->last_command = 0;
  strncpy(&(recall->command[recall->last_command][0]), command, 400);
  if (recall->first_command == recall->last_command)
    recall->first_command++;
  if (recall->first_command > DCLI_RECALL_MAX)
    recall->first_command = 0;
  if (recall->first_command == -1)
    recall->first_command = 0;
  return DCLI__SUCCESS;
}

/*************************************************************************
*
* Name:		dcli_recall_getcommand()
*
* Type		int
*
* Type		Parameter	IOGF	Description
* dcli_sRecall 	*recall		I	recall buffer.
* int		nr		I	index of returned command.
* char		*command	O	command.
*
* Description:
*	Returns a command from the recall buffer.
*
**************************************************************************/

static int dcli_recall_getcommand(dcli_sRecall* recall, int nr, char* command)
{
  int index;

  if ((nr >= DCLI_RECALL_MAX) || (nr < 0)) {
    *command = 0;
    return 1;
  }
  index = recall->last_command - nr;
  if (index < 0)
    index += DCLI_RECALL_MAX;
  strcpy(command, &(recall->command[index][0]));
  return 1;
}

int dcli_input_init(dcli_sChannel* chn, dcli_sRecall** recall_buf)
{
  int sts;

  init_state_table();

  sts = dcli_qio_assign("stdin", chn);
  if (EVEN(sts))
    return sts;

  if (recall_buf) {
    sts = dcli_recall_create(recall_buf);
    if (EVEN(sts))
      return sts;
  }
  return DCLI__SUCCESS;
}

int dcli_input_end(dcli_sChannel* chn, dcli_sRecall* recall_buf)
{
  if (recall_buf)
    dcli_recall_free(recall_buf);
  dcli_qio_reset(chn);
  return DCLI__SUCCESS;
}

int dcli_get_input_command(dcli_sChannel* chn, const char* prompt, char* cmd,
    int maxlen, dcli_sRecall* recall_buf)
{
  unsigned long option = 0;
  unsigned long terminator;
  int sts;

  sts = dcli_get_input_string(
      chn, cmd, &terminator, maxlen, recall_buf, option, 0, 0, 0, prompt);
  return sts;
}

/*************************************************************************
*
* Name:		dcli_get_input_string()
*
* Type		int
*
* Type		Parameter	IOGF	Description
* char		*chn		I	channel.
* char		*out_string	O	input string
* unsigned long	*out_terminator	O	terminator
* int		out_maxlen	I	max charachters.
* unsigned long	recall		I	recall buffer.
* unsigned long	option		I	option mask.
* int		timeout		I	timeout time
* int		(* timeout_func) () I	timeout function
* unsigned long	timeout_arg	I	timeout function argument
* char		*prompt		I	prompt string.
*
* Description:
*	Read a input string.
*
**************************************************************************/

int dcli_get_input_string(dcli_sChannel* chn, char* out_string,
    unsigned long* out_terminator, int out_maxlen, dcli_sRecall* recall,
    unsigned long option, int timeout, int (*timeout_func)(), void* timeout_arg,
    const char* prompt)
{
  char input_str[400];
  char out_str[400];
  char dum_str[400];
  int maxlen = 399;
  unsigned long terminator;
  int index;
  int recall_index = 0;

  if (prompt != NULL)
    r_print(chn, "%s", prompt);

  terminator = 0;
  index = 0;
  out_str[0] = 0;
  while (1) {
    dcli_get_input(chn, input_str, &terminator, maxlen, option, timeout);

    if (terminator == DCLI_K_RETURN)
      break;
    if ((terminator == DCLI_K_ARROW_LEFT) && ((option & DCLI_OPT_NOEDIT) != 0))
      break;
    if ((terminator == DCLI_K_ARROW_RIGHT) && ((option & DCLI_OPT_NOEDIT) != 0))
      break;
    if ((terminator == DCLI_K_DELETE) && ((option & DCLI_OPT_NOEDIT) != 0))
      break;
    if ((terminator == DCLI_K_BACKSPACE) && ((option & DCLI_OPT_NOEDIT) != 0))
      break;
    if ((terminator == DCLI_K_ARROW_UP) && ((option & DCLI_OPT_NORECALL) != 0))
      break;
    if ((terminator == DCLI_K_ARROW_DOWN)
        && ((option & DCLI_OPT_NORECALL) != 0))
      break;
    if ((terminator == DCLI_K_TIMEOUT) && ((option & DCLI_OPT_NOEDIT) != 0)) {
      if (timeout_func != NULL)
        (timeout_func)(timeout_arg);
      else
        break;
    }

    if ((option & DCLI_OPT_NOEDIT) == 0) {
      switch (terminator) {
      case DCLI_K_TIMEOUT:
        strcpy(dum_str, (char*)&out_str[index]);
        strcpy((char*)&out_str[index], input_str);
        index += strlen(input_str);
        strcpy((char*)&out_str[index], dum_str);
        if (timeout_func != NULL) {
          store_cursorpos(chn);
          (timeout_func)(timeout_arg);
          restore_cursorpos(chn);
        }
        break;
      case DCLI_K_ARROW_LEFT:
        strcpy(dum_str, (char*)&out_str[index]);
        strcpy(&out_str[index], input_str);
        index += strlen(input_str);
        strcpy(&out_str[index], dum_str);
        if (index > 0) {
          index--;
          cursor_rel(chn, 0, -1);
        }
        break;
      case DCLI_K_ARROW_RIGHT:
        strcpy(dum_str, (char*)&out_str[index]);
        strncpy((char*)&out_str[index], input_str, strlen(input_str));
        index += strlen(input_str);
        strcpy((char*)&out_str[index], dum_str);
        if (index < (int)strlen(out_str)) {
          index++;
          cursor_rel(chn, 0, 1);
        }
        break;
      case DCLI_K_BACKSPACE:
        strcpy(dum_str, (char*)&out_str[index]);
        strncpy(&out_str[index], input_str, strlen(input_str));
        index += strlen(input_str);
        strcpy(&out_str[index], dum_str);
        if (index > 0) {
          cursor_rel(chn, 0, -index);
          index = 0;
        }
        break;
      case DCLI_K_DELETE:
        strcpy(dum_str, (char*)&out_str[index]);
        strncpy(&out_str[index], input_str, strlen(input_str));
        index += strlen(input_str);
        strcpy(&out_str[index], dum_str);
        if (index > 0) {
          strcpy(dum_str, &out_str[index]);
          index--;
          cursor_rel(chn, 0, -1);
          strcpy(&out_str[index], dum_str);
          char_delete(chn, 1);
        }
        break;
      }
    }
    if ((option & DCLI_OPT_NORECALL) == 0) {
      switch (terminator) {
      case DCLI_K_ARROW_UP:
        if (!recall)
          break;
        index += strlen(input_str);
        recall_index++;
        if (recall_index > DCLI_RECALL_MAX)
          recall_index = DCLI_RECALL_MAX + 1;
        dcli_recall_getcommand(recall, recall_index - 1, out_str);
        cursor_rel(chn, 0, -index);
        eofline_erase(chn);
        index = strlen(out_str);
        r_print(chn, "%s", out_str);
        break;
      case DCLI_K_ARROW_DOWN:
        if (!recall)
          break;
        index += strlen(input_str);
        recall_index--;
        if (recall_index < 0)
          recall_index = 0;
        dcli_recall_getcommand(recall, recall_index - 1, out_str);
        cursor_rel(chn, 0, -index);
        eofline_erase(chn);
        index = strlen(out_str);
        r_print(chn, "%s", out_str);
        break;
      }
    }
  }
  strcpy(dum_str, (char*)&out_str[index]);
  strncpy(&out_str[index], input_str, strlen(input_str));
  index += strlen(input_str);
  strcpy(&out_str[index], dum_str);
  strcpy(out_string, out_str);
  if ((option & DCLI_OPT_NORECALL) == 0) {
    /* Save in recall buffer */
    recall_index = 0;
    dcli_recall_insert(recall, out_string);
  }
  *out_terminator = terminator;
  return DCLI__SUCCESS;
}

/************************************************************************
*
* Name:	dcli_qio_assign(char *s, dcli_sChannel *chn)
*
* Type:	int
*
* TYPE		PARAMETER	IOGF	DESCRIPTION
* char		*s		     I	    String
* int		*chn		 O	    Kanal
*
* Description:	Gör en assign av s till kanalnummer chn
*************************************************************************/
int dcli_qio_assign(char* s, dcli_sChannel* chn)
{
  int chan = -1;
  int sts;

  if (streq(s, "stdin"))
    chan = STDIN_FILENO;
  else {
    chan = open(s, O_RDWR | O_NOCTTY);
    if (chan == -1) {
      printf("No such device\n");
      return 0;
    }
  }
  sts = dcli_qio_set_attr(&chan, 10);
  *chn = (dcli_sChannel)chan;
  return 1;
}

/************************************************************************
*
* Name:	dcli_qio_set_attr( dcli_sChannel *chn, int tmo)
*
* Type:	int
*
* TYPE		PARAMETER	IOGF	DESCRIPTION
* char		*s		     I	    String
* int		*chn		 O	    Kanal
*
* Description:	Set attributes to a tty
*************************************************************************/
int dcli_qio_set_attr(dcli_sChannel* chn, int tmo)
{
  int chan;
  int sts;
  struct termios t;

  chan = *(int*)chn;

  sts = tcgetattr(chan, &t);
  if (sts != 0)
    return 0;

  t.c_cc[VMIN] = 0;
  t.c_cc[VTIME] = tmo;
  t.c_lflag &= ~ICANON;
  t.c_lflag &= ~ECHO;
  /* t.c_iflag ...*/
  sts = tcflush(chan, TCIFLUSH);
  sts = tcsetattr(chan, TCSAFLUSH, &t);

  return 1;
}

/************************************************************************
*
* Name:	dcli_qio_reset(char *s, dcli_sChannel *chn)
*
* Type:	int
*
* TYPE		PARAMETER	IOGF	DESCRIPTION
* char		*s		     I	    String
* int		*chn		 O	    Kanal
*
* Description:	Reset the channel before exit
*************************************************************************/
int dcli_qio_reset(dcli_sChannel* chn)
{
  int chan;
  int sts;
  struct termios t;

  chan = *(int*)chn;

  sts = tcgetattr(chan, &t);
  if (sts != 0)
    return 0;

  t.c_cc[VMIN] = 0;
  t.c_cc[VTIME] = 0;
  t.c_lflag |= ICANON;
  t.c_lflag |= ECHO;
  /* t.c_iflag ...*/
  sts = tcflush(chan, TCIFLUSH);
  sts = tcsetattr(chan, TCSAFLUSH, &t);

  return 1;
}

/************************************************************************
*
* Name:	dcli_qio_readw( dcli_sChannel chn, char *buf, int len)
*
* Type:	int
*
* TYPE		PARAMETER	IOGF	DESCRIPTION
* int		chn         I       Kanal
* char		*buf         O      Läst buffer
* int		len         I       Antal tecken som får läsas
*
* Description:	Läser med qiow från chn till buf
*************************************************************************/
int dcli_qio_readw(dcli_sChannel* chn, char* buf, int len)
{
  int n = 0;

  while (n == 0)
    n = read(*chn, buf, len);
  return 1;
}

/************************************************************************
*
* Name:	dcli_qio_read( dcli_sChannel chn, int tmo, char *buf, int len)
*
* Type:	int
*
* TYPE		PARAMETER	IOGF	DESCRIPTION
* int		chn         I       Kanal
* int		tmo         I       Timout-tid
* char		*buf         O      Läst buffer
* int		len         I       Antal tecken som får läsas
*
* Description:	Läser med qio från chn till buf med timout-tid tmo (ms)
*************************************************************************/
int dcli_qio_read(dcli_sChannel* chn, int tmo, char* buf, int len)
{
  int n;

  n = read(*(int*)chn, buf, len);
  if (n == 0)
    /* Timeout */
    return 0;
  return 1;
}

/************************************************************************
*
* Name:	dcli_qio_writew(dcli_sChannel *chn, char *buf, int len)
*
* Type:	int
*
* TYPE		PARAMETER	IOGF	DESCRIPTION
* int		chn         I       Kanal
* char		*buf        I       Buffer
* int		len         I       Antal tecken som ska skrivas
*
* Description:	Skriver med qiow från buf till chn
*************************************************************************/
int dcli_qio_writew(dcli_sChannel* chn, char* buf, int len)
{
  if (*(int*)chn == STDIN_FILENO)
    write(STDOUT_FILENO, buf, len);
  else
    write(*(int*)chn, buf, len);
  return 1;
}

/************************************************************************
*
* Name:	dcli_qio_write(dcli_sChannel *chn, int tmo, char *buf, int len)
*
* Type:	int
*
* TYPE		PARAMETER	IOGF	DESCRIPTION
* int		chn         I       Kanal
* int		tmo         I       Timout-tid
* char		*buf         O      Läst buffer
* int		len         I       Antal tecken som får läsas
*
* Description:	Skriver med qio från buf till chn med timout-tid tmo (ms)
*************************************************************************/
int dcli_qio_write(dcli_sChannel* chn, int tmo, char* buf, int len)
{
  if (*(int*)chn == STDIN_FILENO)
    write(STDOUT_FILENO, buf, len);
  else
    write(*(int*)chn, buf, len);
  return 1;
}
