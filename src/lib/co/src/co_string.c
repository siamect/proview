/**
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2018 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 **/

#include <ctype.h>

#include "co_string.h"

char* str_ToLower(char* dst, const char* src)
{
  char* rs = dst;

  if (dst == NULL)
    return NULL;
  if (src == NULL)
    src = dst;
  
  while (*src)
    if ((*src >= 65 && *src <= 90) || (((unsigned char) *src) >= 192 && ((unsigned char) *src) <= 222))
      *dst++ = (*src++) + 32;
    else
      *dst++ = *src++;

  *dst = *src; /* Copy the null byte.  */

  return rs;
}

char* str_ToUpper(char* dst, const char* src)
{
  char* rs = dst;

  if (dst == NULL)
    return NULL;
  if (src == NULL)
    src = dst;

  while (*src)
    if ((*src >= 97 && *src <= 122) || (((unsigned char) *src) >= 224 && ((unsigned char) *src) <= 254))
      *dst++ = (*src++) - 32;
    else
      *dst++ = *src++;

  *dst = *src; /* Copy the null byte.  */

  return rs;
}

int str_NoCaseStrcmp(const char* s, const char* t)
{
  while (*s && *t && !(((*s) ^ (*t)) & ~(1 << 5)))
    s++, t++;

  return (isalpha(*s) ? ((*s) & ~(1 << 5)) : *s)
      - (isalpha(*t) ? ((*t) & ~(1 << 5)) : *t);
}

int str_NoCaseStrncmp(const char* s, const char* t, size_t n)
{
  int i;

  for (i = 0; i < n && *s && *t && !(((*s) ^ (*t)) & ~(1 << 5)); i++)
    s++, t++;

  if (n == i)
    return 0;
  
  return (isalpha(*s) ? ((*s) & ~(1 << 5)) : *s)
      - (isalpha(*t) ? ((*t) & ~(1 << 5)) : *t);
}

char* str_Strcpy(char* dest, const char* src)
{
  const char* s;
  char* t;

  for (s = src, t = dest; *s; s++, t++)
    *t = *s;
  *t = 0;

  return dest;
}

char* str_Strncpy(char* dest, const char* src, size_t n)
{
  const char* s;
  char* t;
  unsigned int i;

  for (s = src, t = dest, i = 0; *s && i < n; s++, t++, i++)
    *t = *s;
  if (i < n)
    *t = 0;

  return dest;
}

int str_StrncpyCutOff(char* t, const char* s, size_t n, int cutleft)
{
  if (strlen(s) < n) {
    str_Strcpy(t, s);
    return 0;
  }

  if (cutleft) {
    str_Strcpy(t, s + strlen(s) - n + 1);
    if (n > 5) {
      t[0] = '.';
      t[1] = '.';
      t[2] = '.';
    }
  } else {
    str_Strncpy(t, s, n);
    t[n - 1] = 0;
    if (n > 5) {
      t[n - 2] = '.';
      t[n - 3] = '.';
      t[n - 4] = '.';
    }
  }
  return 1;
}

void str_trim(char *out, const char *in)
{
  // skip leading whitespace
  while (isspace((unsigned char) *in))
    in++;
  
  // Skip trailing whitespace
  const char *end = in + strlen(in) - 1;
  while (end > in && isspace((unsigned char) *end)) end--;
  end++;

  int length = end - in;
  str_Strncpy(out, in, length);
  out[length] = 0;
}
