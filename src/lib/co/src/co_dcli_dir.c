/**
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 **/

/* xtt_dcli_dir.c
   This module contains routines for handling files and directories in dcli. */

/*_Include files_________________________________________________________*/

#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>

#include "co_cdh.h"
#include "co_dcli.h"
#include "co_dcli_msg.h"
#include "co_string.h"

/* Search for one or several files.
*  The file name can contain wildcard, *.
*  Should be called for the first time with new = DCLI_DIR_SEARCH_INIT.
*  If more then one file is searched for, the next files are found with
*  calls where new = DCLI_DIR_SEARCH_NEXT. When the search is finished,
*  one call with DCLI_DIR_SEARCH_END should be made.
*  Two parallell searches are not allowed as data is stored internally.
*
*  file_name	File name, can contain wildcard.
*  found_file	Found file.
*  new		DCLI_DIR_SEARCH_INIT, DCLI_DIR_SEARCH_NEXT or
* DCLI_DIR_SEARCH_END.
*/

int dcli_search_file(const char* name, char* found_file, int new)
{
  static DIR* directory;
  static char pattern[200];
  static char dir[200];
  char dev[2], dir2[200], file[80], type[80];
  char cwd[200];
  int version;
  int found;
  static int wildcard;
  struct dirent* dir_entry;

  if (new == DCLI_DIR_SEARCH_INIT) {
    dcli_parse_filename(name, dev, dir, file, type, &version);
    dcli_replace_env(dir, dir2);
    if (dir2[0] != '/') {
      /* Add cwd to the path */
      if (getcwd(cwd, sizeof(cwd)) == NULL)
        return DCLI__NOFILE;
      strcpy(dir, cwd);
      if (dir[strlen(dir) - 1] != '/')
        strcat(dir, "/");
      strcat(dir, dir2);
    } else
      strcpy(dir, dir2);

    directory = opendir(dir);
    if (directory == NULL)
      return DCLI__NOFILE;

    strcpy(pattern, file);
    strcat(pattern, type);
    if (strchr(pattern, '*') != 0)
      wildcard = 1;
    else
      wildcard = 0;
    // if ( wildcard)
    //   dcli_toupper( pattern, pattern);
  }

  if (new == DCLI_DIR_SEARCH_INIT || new == DCLI_DIR_SEARCH_NEXT) {
    found = 0;
    while ((dir_entry = readdir(directory)) != NULL) {
      if (streq(dir_entry->d_name, ".")
          || streq(dir_entry->d_name, ".."))
        continue;

      if (wildcard) {
        if (dcli_wildcard(pattern, dir_entry->d_name) == 0) {
          strcpy(found_file, dir);
          strcat(found_file, dir_entry->d_name);
          found = 1;
        }
      } else {
        if (streq(pattern, dir_entry->d_name)) {
          strcpy(found_file, dir);
          strcat(found_file, dir_entry->d_name);
          found = 1;
        }
      }
      if (found)
        break;
    }
    if (!found)
      return DCLI__NOFILE;
    else
      return DCLI__SUCCESS;
  }

  if (new == DCLI_DIR_SEARCH_END) {
    if (directory)
      closedir(directory);
  }

  return DCLI__SUCCESS;
}

/* Search for one or several directories.
*  The file name can contain wildcard, *.
*  Should be called for the first time with new = DCLI_DIR_SEARCH_INIT.
*  If more then one file is searched for, the next files are found with
*  calls where new = DCLI_DIR_SEARCH_NEXT. When the search is finished,
*  one call with DCLI_DIR_SEARCH_END should be made.
*  Two parallell searches are not allowed as data is stored internally.
*
*  file_name	File name, can contain wildcard.
*  found_file	Found file.
*  new		DCLI_DIR_SEARCH_INIT, DCLI_DIR_SEARCH_NEXT or
* DCLI_DIR_SEARCH_END.
*/

int dcli_search_directory(const char* name, char* found_file, int new)
{
  static DIR* directory;
  static char pattern[200];
  static char dir[200];
  char dev[2], dir2[200], file[80], type[80];
  char cwd[200];
  int version;
  int found;
  static int wildcard;
  struct dirent* dir_entry;

  if (new == DCLI_DIR_SEARCH_INIT) {
    dcli_parse_filename(name, dev, dir, file, type, &version);
    dcli_replace_env(dir, dir2);
    if (dir2[0] != '/') {
      /* Add cwd to the path */
      if (getcwd(cwd, sizeof(cwd)) == NULL)
        return DCLI__NOFILE;
      strcpy(dir, cwd);
      if (dir[strlen(dir) - 1] != '/')
        strcat(dir, "/");
      strcat(dir, dir2);
    } else
      strcpy(dir, dir2);

    directory = opendir(dir);
    if (directory == NULL)
      return DCLI__NOFILE;

    strcpy(pattern, file);
    strcat(pattern, type);
    if (strchr(pattern, '*') != 0)
      wildcard = 1;
    else
      wildcard = 0;
    // if ( wildcard)
    //   dcli_toupper( pattern, pattern);
  }

  if (new == DCLI_DIR_SEARCH_INIT || new == DCLI_DIR_SEARCH_NEXT) {
    found = 0;
    while ((dir_entry = readdir(directory)) != NULL) {
      struct stat st;

      if (streq(dir_entry->d_name, ".")
          || streq(dir_entry->d_name, ".."))
        continue;

      if (fstatat(dirfd(directory), dir_entry->d_name, &st, 0) < 0)
        continue;

      if (!S_ISDIR(st.st_mode))
        continue;

      if (wildcard) {
        if (dcli_wildcard(pattern, dir_entry->d_name) == 0) {
          strcpy(found_file, dir);
          strcat(found_file, dir_entry->d_name);
          found = 1;
        }
      } else {
        if (streq(pattern, dir_entry->d_name)) {
          strcpy(found_file, dir);
          strcat(found_file, dir_entry->d_name);
          found = 1;
        }
      }
      if (found)
        break;
    }
    if (!found)
      return DCLI__NOFILE;
    else
      return DCLI__SUCCESS;
  }

  if (new == DCLI_DIR_SEARCH_END) {
    if (directory)
      closedir(directory);
  }

  return DCLI__SUCCESS;
}

/*************************************************************************
*
* Name:		dcli_get_files
*
*
**************************************************************************/

int dcli_get_files(
    char* dir, char* pattern, pwr_tString40* filelist[], int* filecnt)
{
  pwr_tStatus sts;
  pwr_tFileName file_spec, found_file;
  int cnt = 0;
  int idx = 0;
  char* s;

  strcpy(file_spec, dir);
  strcat(file_spec, "/");
  strcat(file_spec, pattern);
  dcli_translate_filename(file_spec, file_spec);
  sts = dcli_search_file(file_spec, found_file, DCLI_DIR_SEARCH_INIT);
  while (ODD(sts)) {
    cnt++;
    sts = dcli_search_file(file_spec, found_file, DCLI_DIR_SEARCH_NEXT);
  }
  dcli_search_file(file_spec, found_file, DCLI_DIR_SEARCH_END);

  if (!cnt) {
    *filecnt = 0;
    return 0;
  }

  *filelist = calloc(cnt, sizeof(pwr_tString40));

  sts = dcli_search_file(file_spec, found_file, DCLI_DIR_SEARCH_INIT);
  while (ODD(sts)) {
    if ((s = strrchr(found_file, '/'))) {
      strncpy((*filelist)[idx], s + 1, sizeof(pwr_tString40));
      (*filelist)[idx][sizeof(pwr_tString40) - 1] = 0;
    } else {
      strncpy((*filelist)[idx], found_file, sizeof(pwr_tString40));
      (*filelist)[idx][sizeof(pwr_tString40) - 1] = 0;
    }
    idx++;

    sts = dcli_search_file(file_spec, found_file, DCLI_DIR_SEARCH_NEXT);
  }
  dcli_search_file(file_spec, found_file, DCLI_DIR_SEARCH_END);
  *filecnt = cnt;

  return DCLI__SUCCESS;
}

/*************************************************************************
*
* Name:		dcli_parse_filename
*
* Typ		int
*
* Typ		Parameter	IOGF	Beskrivning
*
* Beskrivning:
*	Delar upp ett filnamn i device, directory, namn, typ och version.
*
* Parameterar
*	filenam		*char	I  Filnamn som ska delas.
*	dev		*char	O  device.
*	dir		*char	O  directory.
*	file		*char	O  filnamn.
*	type		*char	O  typ.
*	version		*int	O  version.
*
**************************************************************************/

int dcli_parse_filename(const char* filename, char* dev, char* dir, char* file,
    char* type, int* version)
{
  char* s;
  char ldev[200];
  char ldir[200];
  char lfile[200];
  char ltype[80];

  if ((s = strstr(filename, "::")))
    s += 2;
  else
    s = (char*)filename;
  strcpy(ldev, "");
  strcpy(ldir, s);

  /* Directory */
  if ((s = strrchr(ldir, '/')))
    s++;
  else
    s = ldir;
  strcpy(lfile, s);
  *s = 0;

  /* File */
  if ((s = strchr(lfile, '.')) == 0)
    s = &lfile[strlen(lfile)];
  strcpy(ltype, s);
  *s = 0;

  /* Type */
  // if ( (s = strchr( ltype+1, '.')) != 0)
  //  *s = 0;
  // if ( (s = strchr( ltype+1, ';')) != 0)
  //  *s = 0;

  *version = 0;

  strcpy(dev, ldev);
  strcpy(dir, ldir);
  strcpy(file, lfile);
  strcpy(type, ltype);
  return 1;
}

int dcli_create_directory(char* path)
{
  pwr_tFileName fname;

  dcli_translate_filename(fname, path);
  if (mkdir(fname, 0777) != 0)
    return 0;

  return 1;
}

int dcli_delete_directory(char* path, int force)
{
  pwr_tFileName fname;

  dcli_translate_filename(fname, path);
  if (rmdir(fname) != 0) {
    if (!force)
      return 0;
    if (errno == ENOTEMPTY) {
      pwr_tCmd cmd;
      sprintf(cmd, "rm -r %s", path);
      system(cmd);
    }
  }

  return 1;
}
