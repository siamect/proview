/** 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2011 SSAB Oxelosund AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

/* co_time.c -- Utilities for time management.
   NOTE! to convert timespecs to tm's, the threadsafe version of localtime,
         localtime_r must be used, which doesn't exist on DEC.  */

#include "co_time.h"
#include "co_time_msg.h"


#ifdef OS_ELN
# include stdio
# include ctype
# include string
# include stdlib
# include descrip
# include errno
# include limits
# include times
#else
# include <stdio.h>
# include <string.h>
# include <ctype.h>
# include <stdlib.h>
#endif

#if defined OS_LYNX
# include <sys/times.h>
#elif defined OS_LINUX || defined OS_MACOS || defined OS_FREEBSD
# include <time.h>
#endif

#if defined OS_LYNX
# define assertAbs(p) do {\
    pwr_Assert(p->tv_sec >= 0 && p->tv_nsec >= 0 && p->tv_nsec < 1000000000);\
  } while (0)
#else
# define assertAbs(p) do {\
    pwr_Assert(p->tv_nsec >= 0 && p->tv_nsec < 1000000000);\
  } while (0)
#endif

#define assertDelta(p) do {\
  pwr_Assert((p->tv_sec > 0) ? (p->tv_nsec >= 0 && p->tv_nsec <  1000000000) : TRUE);\
  pwr_Assert((p->tv_sec < 0) ? (p->tv_nsec <= 0 && p->tv_nsec > -1000000000) : TRUE);\
} while (0)

#define ONEDAY 86400

/* String representations of months.  */

static const char *monStr[] =
{
  "JAN", "FEB", "MAR", "APR", "MAY", "JUN",
  "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"
};

static pwr_tStatus  validateTm    (struct tm *tms);


/* Validate data in struct tm.  */

static pwr_tStatus
validateTm (
  struct tm *tms
)
{
  int year;

  /* Check generic ranges.  */

  if (69 > tms->tm_year || tms->tm_year > 137) /* EPOCH is 1970 end feb 2038 */
    return TIME__RANGE;
  else if (0 > tms->tm_mon || tms->tm_mon > 11)
    return TIME__RANGE;
  else if(1 > tms->tm_mday || tms->tm_mday > 31)
    return TIME__RANGE;
  else if(0 >  tms->tm_hour || tms->tm_hour > 23)
    return TIME__RANGE;
  else if(0 > tms->tm_min || tms->tm_min > 59)
    return TIME__RANGE;
  else if(0 > tms->tm_sec || tms->tm_sec > 59) /* Should be 61 according to POSIX */
    return TIME__RANGE;

  /*
   * validate date
   */
  switch (tms->tm_mon) {
  case 1:
    /* check for leap year */
    year = tms->tm_year + 1900;
    if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {
      if (tms->tm_mday > 29)
  return TIME__RANGE;
    } else {
      if (tms->tm_mday > 28)
  return TIME__RANGE;
    }
    break;

  case 3:
  case 5:
  case 8:
  case 10:
    if (tms->tm_mday > 30)
      return TIME__RANGE;
    break;

  case 0:
  case 2:
  case 4:
  case 6:
  case 7:
  case 9:
  case 11:
    if (tms->tm_mday > 31)
      return TIME__RANGE;
    break;

  default:
    return TIME__RANGE;
  }
  return TIME__SUCCESS;
}

//! Test if time is Null.
int
time_IsNull (
  pwr_tTime *t1
)
{

  assertAbs(t1);

  return (t1->tv_sec == pwr_cNTime.tv_sec) && (t1->tv_nsec == pwr_cNTime.tv_nsec);
}

//! Add an absolute time and a delta time.
/*! Add two timespecs, result = t + d, where:

   -  'result' and 't' is an absolute time, and
   -  'd' is a delta time.

  If 'result' argument is NULL
  then 't' will be used as resultant.
  Returns the address to the resulting time.
*/

pwr_tTime *
time_Aadd (
  pwr_tTime   *result,
  pwr_tTime   *t,
  pwr_tDeltaTime  *a
)
{
  pwr_tTime   *r = result;
  pwr_tInt64  tv_nsec;

  assertAbs(t);
  assertDelta(a);

  if (result == NULL) r = t;

  tv_nsec = t->tv_nsec + a->tv_nsec;
  r->tv_sec = t->tv_sec + a->tv_sec + (tv_nsec / 1000000000);
  r->tv_nsec = tv_nsec % 1000000000;

  return r;
}

//! Compare two timespecs.
/*!   Returns \n
    1 if t1  > t2 \n
    0 if t1 == t2 \n
   -1 if t1  < t2 \n

   If argument 't2' is NULL the comparison will
   be done as if t2 == 0.
*/

int
time_Acomp (
  pwr_tTime *t1,
  pwr_tTime *t2
)
{
  static pwr_tTime null = {0, 0};

  if (t2 == NULL) t2 = &null;

  assertAbs(t1);
  assertAbs(t2);

  if (t1->tv_sec == t2->tv_sec)
  {
    if ( t1->tv_nsec == t2->tv_nsec)
      return 0;
    return ((t1->tv_nsec > t2->tv_nsec) ? 1 : -1);
  }
  else
    return ((t1->tv_sec > t2->tv_sec) ? 1 : -1);
}

//! Subtract a time from a time,
/*!   r = t - s

   Result is always a delta time.
*/

pwr_tDeltaTime *
time_Adiff (
  pwr_tDeltaTime  *r,
  pwr_tTime   *t,
  pwr_tTime   *s
)
{
  pwr_tInt64     tv_nsec = t->tv_nsec - s->tv_nsec;
  pwr_tInt64     tv_sec  = t->tv_sec  - s->tv_sec;

  pwr_Assert(r != NULL);
  assertAbs(t);
  assertAbs(s);

  tv_sec  = tv_sec + tv_nsec / 1000000000;
  tv_nsec = tv_nsec % 1000000000;
  if (tv_nsec < 0 && tv_sec > 0) {
    tv_sec--;
    tv_nsec += 1000000000;
  } else if (tv_sec < 0 && tv_nsec > 0) {
    tv_sec++;
    tv_nsec -= 1000000000;
  }

  r->tv_sec = tv_sec;
  r->tv_nsec = tv_nsec;

  return r;
}

//! Subtract a delta time from a time,
/*!   r = t - s

   Result is always an abstime.
*/

pwr_tTime *
time_Asub (
  pwr_tTime   *result,
  pwr_tTime   *t,
  pwr_tDeltaTime  *s
)
{
  pwr_tInt64     tv_nsec = t->tv_nsec - s->tv_nsec;
  pwr_tInt64     tv_sec  = t->tv_sec  - s->tv_sec;
  pwr_tTime   *r = result;

  assertAbs(t);
  assertDelta(s);

  if (r == NULL) r = t;

  tv_sec  += tv_nsec / 1000000000;
  tv_nsec %= 1000000000;
  if (tv_nsec < 0 && tv_sec > 0) {
    tv_sec--;
    tv_nsec += 1000000000;
  } else if (tv_sec < 0 && tv_nsec > 0) {
    tv_sec++;
    tv_nsec -= 1000000000;
  }

  r->tv_sec = tv_sec;
  r->tv_nsec = tv_nsec;
  return r;

}

//! Take the absolute walue of a delta time.
/*!
   'result' = |'t'|

   A NULL address => abs value is written to 't'.
   Returns the address to the resulting time.
*/

pwr_tDeltaTime *
time_Dabs (
  pwr_tDeltaTime  *result,
  pwr_tDeltaTime  *t
)
{
  pwr_tDeltaTime  *r = result;

  assertDelta(t);

  if (r == NULL) r = t;

  if (r->tv_sec < 0)  r->tv_sec  = -r->tv_sec;
  if (r->tv_nsec < 0) r->tv_nsec = -r->tv_nsec;

  return r;
}

//! Add two delta times, the result is also delta.
/*!   If 'result' is NULL then 'a' will be added to 't'.  */

pwr_tDeltaTime *
time_Dadd (
  pwr_tDeltaTime  *result,
  pwr_tDeltaTime  *t,
  pwr_tDeltaTime  *a
)
{
  pwr_tDeltaTime  *r = result;
  pwr_tInt64     tv_nsec, tv_sec;

  assertDelta(t);
  assertDelta(a);

  if (result == NULL) r = t;

  tv_nsec = t->tv_nsec + a->tv_nsec;
  tv_sec = t->tv_sec + a->tv_sec + (tv_nsec / 1000000000);
  tv_nsec = tv_nsec % 1000000000;

  if (tv_nsec < 0 && tv_sec > 0) {
    tv_sec--;
    tv_nsec += 1000000000;
  } else if (tv_sec < 0 && tv_nsec > 0) {
    tv_sec++;
    tv_nsec -= 1000000000;
  }

  r->tv_sec = tv_sec;
  r->tv_nsec = tv_nsec;

  return r;
}

//! Compare two delta times.
/*!   Returns \n
    1 if t1  > t2 \n
    0 if t1 == t2 \n
   -1 if t1  < t2 \n

   If argument 't2' is NULL the comparison will
   be done as if t2 == 0.
*/

int
time_Dcomp (
  pwr_tDeltaTime  *t1,
  pwr_tDeltaTime  *t2
)
{
  static pwr_tDeltaTime null = {0, 0};

  if (t2 == NULL)
    t2 = &null;

  assertDelta(t1);
  assertDelta(t2);

  if (t1->tv_sec == t2->tv_sec) {
    if (t1->tv_nsec == t2->tv_nsec)
      return 0;
    return ((t1->tv_nsec > t2->tv_nsec) ? 1 : -1);
  }
  return ((t1->tv_sec > t2->tv_sec) ? 1 : -1);
}

//! Negate a delta time,
/*!
   result = -d

  If 'result' argument is NULL
  then 'd' will be used as resultant.
  Returns the address to the resulting time.
*/

pwr_tDeltaTime *
time_Dneg (
  pwr_tDeltaTime  *result,
  pwr_tDeltaTime  *t
)
{
  pwr_tDeltaTime  *r = result;

  assertDelta(t);

  if (r == NULL) r = t;

  r->tv_sec  = -r->tv_sec;
  r->tv_nsec = -r->tv_nsec;

  return r;
}

//! Subtract two delta times.
/*! The result is also delta.  */

pwr_tDeltaTime *
time_Dsub (
  pwr_tDeltaTime  *result,
  pwr_tDeltaTime  *t,
  pwr_tDeltaTime  *s
)
{
  pwr_tInt64     tv_nsec = t->tv_nsec - s->tv_nsec;
  pwr_tInt64     tv_sec  = t->tv_sec  - s->tv_sec;
  pwr_tDeltaTime  *r = result;

  assertDelta(t);
  assertDelta(s);

  if (r == NULL) r = t;

  tv_sec  = tv_sec + tv_nsec / 1000000000;
  tv_nsec = tv_nsec % 1000000000;
  if (tv_nsec < 0 && tv_sec > 0) {
    tv_sec--;
    tv_nsec += 1000000000;
  } else if (tv_sec < 0 && tv_nsec > 0) {
    tv_sec++;
    tv_nsec -= 1000000000;
  }

  r->tv_sec = tv_sec;
  r->tv_nsec = tv_nsec;

  return r;
}

//! Convert a delta time to ascii string.

pwr_tStatus
time_DtoAscii (
  pwr_tDeltaTime  *dt,
  int     hundreds,
  char      *buf,
  int     bufsize
)
{
  char tmpStr[24];
  div_t day, hour, min;

  if (dt == NULL)
    return TIME__IVDTIME;

  day  = div(dt->tv_sec, 24 * 3600);
  hour = div(day.rem, 3600);
  min  = div(hour.rem, 60);

  if (day.quot) {
    if (hundreds) {
      long int nsec = dt->tv_nsec/10000000;
      sprintf(tmpStr, "%d %d:%02d:%02d.%02ld", day.quot, hour.quot, min.quot, min.rem, nsec);
    }
    else
      sprintf(tmpStr, "%d %d:%02d:%02d", day.quot, hour.quot, min.quot, min.rem);
  } else {
    if (hundreds) {
      long int nsec = dt->tv_nsec/10000000;
      sprintf(tmpStr, "%d:%02d:%02d.%02ld", hour.quot, min.quot, min.rem, nsec);
    }
    else
      sprintf(tmpStr, "%d:%02d:%02d", hour.quot, min.quot, min.rem);
  }

  strncpy(buf, tmpStr, bufsize);
  buf[bufsize-1] = '\0';

  return TIME__SUCCESS;
}


//! Convert timespec to ascii
/*!
   NOTE: Not thread safe.  */

pwr_tStatus
time_AtoAscii (
  pwr_tTime *ts,
  time_eFormat  format,
  char    *buf,
  int   bufsize
)
{
  struct tm *tmpTm;
  int   buflen;
  char    tmpStr[16];
  pwr_tTime time;
  pwr_tTime *tp;


  if (ts == NULL)
  {
    time_GetTime(&time);
    tp = &time;
  }
  else
    tp = ts;

  time_t sec = tp->tv_sec;
  tmpTm = localtime(&sec);
  if (EVEN(time_TmToAscii(tmpTm, format, buf, bufsize)))
    return TIME__RANGE;


  sprintf(tmpStr, ".%02d", (int)(tp->tv_nsec / 10000000));
  buflen = strlen(buf);
  if (strlen(tmpStr) + buflen < (unsigned int) bufsize)
    strcpy(&buf[buflen], tmpStr);

  return TIME__SUCCESS;
}

//! Convert ascii to timespec.
pwr_tStatus
time_AsciiToD (
  const char      *tstr,
  pwr_tDeltaTime  *ts
)
{
  char *sp,*dp;
  char buf[64];
  int day, hour, min, sec, hun = 0;
  int useday = 1;

  strncpy(buf, tstr, sizeof(buf) - 1);
  buf[sizeof(buf) - 1] = '\0';
  sp = buf;

  day = strtoul(sp, &dp, 10);
  if (dp == NULL)
    return TIME__RANGE;

  if (*dp == ':') {
    hour = day;
    day = 0;
    useday = 0;
    if (hour > 23)
      return TIME__RANGE;
  }
  else if (*dp != ' ')
    return TIME__RANGE;
  sp = dp + 1;

  if (useday) {
    if (day > 24855)
      return TIME__RANGE;
    hour =  strtoul(sp, &dp, 10);
    if (dp == NULL || *dp != ':' || hour > 23)
      return TIME__RANGE;
    sp = dp + 1;
  }

  min = strtoul(sp, &dp, 10);
  if (dp == NULL || *dp != ':' || min > 59)
    return TIME__RANGE;
  sp = dp + 1;

  sec = strtoul(sp, &dp, 10);
  if ((dp && *dp && *dp != ' ' && *dp != '.') || sec > 59)
    return TIME__RANGE;

  if (dp && *dp == '.') {
    hun =  strtoul(dp + 1, &dp, 10);
    if ((dp && *dp && *dp != ' ') || hun > (10000000 - 1))
      return TIME__RANGE;
  }


  ts->tv_sec = day * 24 * 3600 + hour * 3600 + min * 60 + sec;
  ts->tv_nsec = hun * 10000000;

  return TIME__SUCCESS;
}


//! Convert ascii time to timespec.

pwr_tStatus
time_AsciiToA (
  const char  *tstr,
  pwr_tTime   *ts
)
{
  struct tm   tmpTm;
  int       tmphs = 0;
  char        *dotp;
  char        buf[64];
  pwr_tStatus sts;

  strncpy(buf, tstr, sizeof(buf) - 1);
  buf[sizeof(buf) - 1] = '\0';

  if ((dotp = strchr(buf, '.'))) {
    int len;
    char *cp;

    *dotp = '\0';
    dotp++;
    len = strlen(dotp);
    if (len > 2) /* only hundreds of seconds */
      *(dotp + 2) = 0;

    if (*dotp == '0') dotp++; /* remove first zero */
    tmphs = strtoul(dotp, &cp, 0);
    if (*cp)
      return TIME__RANGE;
    if (len == 1)
      tmphs *= 10;

  }

  sts = time_AsciiToTm(buf, &tmpTm);
  if (EVEN(sts))
    return sts;

  ts->tv_sec = mktime(&tmpTm);
  ts->tv_nsec = tmphs * 10000000;
  return TIME__SUCCESS;
}

//! Convert time struct to string.

pwr_tStatus
time_TmToAscii (
  struct tm *tmptr,
  time_eFormat  format,
  char    *buf,
  int   bufsize
)
{
  pwr_tStatus sts;

  *buf = '\0';
  if (EVEN(sts = validateTm(tmptr)))
    return sts;

  if (format == time_eFormat_DateAndTime) {
    int i;
    strftime(buf, bufsize, "%d-%b-%Y %H:%M:%S", tmptr);
    for (i = 3; i < 6; i++)
      buf[i] = toupper(buf[i]);
  } else if (format == time_eFormat_ComprDateAndTime) {
    strftime(buf, bufsize, "%y-%m-%d %H:%M:%S", tmptr);
  } else if (format == time_eFormat_NumDateAndTime) {
    strftime(buf, bufsize, "%Y-%m-%d %H:%M:%S", tmptr);
  } else {
    strftime(buf, bufsize, "%H:%M:%S", tmptr);
  }

  return TIME__SUCCESS;
}

//! Convert timestring to struct.

pwr_tStatus
time_AsciiToTm (
  const char *tstr,
  struct tm *tmptr
)
{
  char    tmpMonStr[4];
  char    *cp;
  struct tm tt;
  int   i;
  pwr_tStatus sts;

  sscanf(tstr, "%02d-%3c-%4d %02d:%02d:%02d", &tt.tm_mday,
         tmpMonStr, &tt.tm_year, &tt.tm_hour, &tt.tm_min, &tt.tm_sec);

  tmpMonStr[3] = '\0';
  tt.tm_year -= 1900;


  /* We don't handle this in current version */

  tt.tm_wday = -1;
  tt.tm_yday = -1;
  tt.tm_isdst = -1;


  /* check month */
  for (cp = tmpMonStr; *cp; cp++)
    *cp = toupper(*cp);

  tt.tm_mon = -1;
  for (i=0; i<12; i++) {
    if (strcmp(tmpMonStr, monStr[i]) == 0) {
      tt.tm_mon = i;
      break;
    }
  }

  if (EVEN(sts = validateTm(&tt)))
    return sts;

  *tmptr = tt;

  return TIME__SUCCESS;
}

/* Compatibility-function that substitutes co_TimeToAsc.  */

pwr_tStatus
time_FormAsciiToA (
  const char *tstr,
  short   dissolution,
  short   formType,
  pwr_tTime *ts
)
{
  struct tm tmpTm;
  int   i;
  int   year;
  int   month;
  int   day;
  int   tmphs = 0;
  char    *dotp;
  char    buf[64];
  pwr_tStatus sts;
  char    *cp = (char *)tstr;

  /* Format of the date string should be YYYY-MM-DD HH:MM[:SS.CC] */
  while (*cp && isspace(*cp))
    cp++;

  /* Get year */
  for (i = 0; i < 4; i++,cp++) {
    if (*cp == '\0' || !isdigit(*cp))
      return TIME__RANGE;
    buf[i] = *cp;
  }
  buf[i] = '\0';
  year = atoi(buf);
  if (*cp == '\0' || *cp != '-')
      return TIME__RANGE;
  cp++;


  /* Get month */
  for (i = 0; i < 2; i++,cp++) {
    if (*cp == '\0' || !isdigit(*cp))
      return TIME__RANGE;
    buf[i] = *cp;
  }
  buf[i] = '\0';
  month = atoi(buf) - 1;
  if (month < 0 || month > 11)
    return TIME__RANGE;
  if (*cp == '\0' || *cp != '-')
    return TIME__RANGE;
  cp++;


  /* Get Day */
  for (i = 0; i < 2; i++,cp++) {
    if (*cp == '\0' || !isdigit(*cp))
      return TIME__RANGE;
    buf[i] = *cp;
  }
  buf[i] = '\0';
  day = atoi(buf);

  /* Build a new date string on VMS format, dd-mmm-yyyy ...*/
  sprintf(buf, "%02d-%s-%d%s", day, monStr[month], year, cp);

  if (dissolution == MINUTE) {
     strcat(buf, ":00");
  } else if (dissolution == HUNDRED) {
    if ((dotp = strchr(buf, '.'))) {
      int len;
      char *cp;

      *dotp = '\0';
      dotp++;
      len = strlen(dotp);
      if (len > 2) /* only hundreds of seconds */
        *(dotp + 2) = 0;

      if (*dotp == '0') dotp++;
      tmphs = strtoul(dotp, &cp, 0);
      if (*cp)
        return TIME__RANGE;
      if (len == 1)
        tmphs *= 10;
    }
  }

  sts = time_AsciiToTm(buf, &tmpTm);
  if (EVEN(sts))
    return sts;

  ts->tv_sec = mktime(&tmpTm);
  ts->tv_nsec = tmphs * 10000000;
  return TIME__SUCCESS;
}

/* .  */

void
time_AtoFormAscii (
  pwr_tTime *ts,
  short   dissolution,
  short   formType,
  char    buf[],
  int   bufsize
)
{
  int   len;
  struct tm *tmpTm;
  char   tmphs[16];
  pwr_tTime time, *tp;

  if (ts == NULL) {
    time_GetTime(&time);
    tp = &time;
  } else {
    tp = ts;
  }

  switch (formType) {
  case GB:
  case SWE:
  default: {
    time_t sec = tp->tv_sec;
    tmpTm = localtime(&sec);

    switch (dissolution) {
    case HUNDRED:
      len = strftime(buf, bufsize, "%Y-%m-%d %H:%M:%S", tmpTm);
      if (len != 0 && len + 4 <= bufsize) {
        sprintf(tmphs, ".%02d", (int)(tp->tv_nsec / 10000000));
        strcat(buf, tmphs);
      }
      break;

    case MINUTE:
      strftime(buf, bufsize, "%Y-%m-%d %H:%M", tmpTm);
      break;

    case SECOND:
    default:
      strftime(buf, bufsize, "%Y-%m-%d %H:%M:%S", tmpTm);
      break;
    }
  }
  }
}

//! Convert millisec to timespec.

pwr_tDeltaTime *
time_MsToD (
  pwr_tDeltaTime  *dt,
  pwr_tInt32    ms
)
{
  static pwr_tDeltaTime time;
  static pwr_tDeltaTime *t = &time;

  if (dt != NULL) t = dt;

  t->tv_sec  = ms / 1000;
  t->tv_nsec = (ms % 1000) * 1000000;

  return t;
}

//! Convert float to time.

pwr_tDeltaTime *
time_FloatToD (
  pwr_tDeltaTime  *dt,
  pwr_tFloat32    f
)
{
  static pwr_tDeltaTime time;
  static pwr_tDeltaTime *t = &time;

  if (dt != NULL) t = dt;

  t->tv_sec  = f;
  t->tv_nsec = (f - t->tv_sec) * 1e9;

  return t;
}

pwr_tDeltaTime *
time_Float64ToD (
  pwr_tDeltaTime  *dt,
  pwr_tFloat64    f
)
{
  static pwr_tDeltaTime time;
  static pwr_tDeltaTime *t = &time;

  if (dt != NULL) t = dt;

  t->tv_sec  = f;
  t->tv_nsec = (f - t->tv_sec) * 1e9;

  return t;
}


//! Convert time to float.

pwr_tFloat32
time_DToFloat (
  pwr_tFloat32    *f,
  pwr_tDeltaTime  *dt
)
{
  static pwr_tFloat32 flt;

  flt =  1e-9 * dt->tv_nsec  + dt->tv_sec;

  if (f != NULL) *f = flt;

  return flt;
}

time_tClock
time_DtoClock (
  pwr_tStatus *status,
  pwr_tDeltaTime *tp
)
{
  pwr_dStatus(sts, status, TIME__SUCCESS);

  return tp->tv_sec * 100 + tp->tv_nsec / 10000000;
}

pwr_tDeltaTime *
time_ClockToD (
  pwr_tStatus *status,
  pwr_tDeltaTime *tp,
  time_tClock clock
)
{
  pwr_tDeltaTime time;
  pwr_dStatus(sts, status, TIME__SUCCESS);

  if (tp == NULL)
    tp = &time;

  tp->tv_sec = clock / 100;
  tp->tv_nsec = clock % 100 * 10000000;

  return tp;
}

pwr_tDeltaTime *
time_ZeroD (
  pwr_tDeltaTime *tp
)
{
  static pwr_tDeltaTime time;

  if (tp == NULL)
    tp = &time;

  memset(tp, 0, sizeof(*tp));

  return tp;
}

void time_Sleep( float time)
{
#ifdef OS_VMS
	int sts;
        sts = lib$wait(&time);
#elif OS_ELN
	LARGE_INTEGER	l_time;

	l_time.high = -1;	
	l_time.low = - time * 10000000;	
	ker$wait_any( NULL, NULL, &l_time);
#elif defined(OS_LYNX) || defined (OS_LINUX) || defined(OS_MACOS) || defined OS_FREEBSD
	pwr_tDeltaTime	p_time;
	struct timespec ts;

	time_FloatToD( &p_time, time);
	ts.tv_sec = p_time.tv_sec;
	ts.tv_nsec = p_time.tv_nsec;
	nanosleep( &ts, NULL);
#endif
}

int time_GetTime( pwr_tTime *ts)
{
  struct timespec t;
  int sts;
  
  sts = clock_gettime( CLOCK_REALTIME, &t);

  ts->tv_sec = t.tv_sec;
  ts->tv_nsec = t.tv_nsec;
  return sts;
}

int time_GetTimeMonotonic( pwr_tTime *ts)
{
  struct timespec t;
  int sts;
  
  sts = clock_gettime( CLOCK_MONOTONIC, &t);

  ts->tv_sec = t.tv_sec;
  ts->tv_nsec = t.tv_nsec;
  return sts;
}

//! Calculate start and end time for month.
int time_PeriodMonth( pwr_tTime *time, 
		      pwr_tTime *from,
		      pwr_tTime *to,
		      int previous)
{
    struct tm	*tm;
    int		days, month, year;
    time_t 	t;
    time_t 	sec = time->tv_sec;

    tm = localtime(&sec);

    sec = time->tv_sec - (tm->tm_mday - 1) * ONEDAY;

    tm = localtime(&sec);

    tm->tm_sec = 0; 
    tm->tm_min = 0; 
    tm->tm_hour = 0; 
    tm->tm_mday = 1; 

    t = mktime(tm);

    year = tm->tm_year + 1900;
    if ( previous) {
      if ( tm->tm_mon == 0) {
	month = 11;
	year--;
      }
      else
	month = tm->tm_mon - 1;
    }
    else 
      month = tm->tm_mon;

    switch ( month) {
    case 1: 
      if (( year % 4 == 0 && year % 100 != 0) || (year + 1900) % 400 == 0)
	days = 29;
      else
	days = 28;
      break;
    case 3:
    case 5:
    case 8:
    case 10:
      days = 30;
      break;      
    default:
      days = 31;
    }

    if ( previous) {
      if ( to) {
	to->tv_sec = t;
	to->tv_nsec = 0;
      }
    }      
    else {
      if ( from) {
	from->tv_sec = t;
	from->tv_nsec = 0;
      }
    }

    if ( previous)
      sec  = t - (days - 1) * ONEDAY;
    else
      sec = t + (days + 1) * ONEDAY;
      
    tm = localtime(&sec);

    tm->tm_sec = 0; 
    tm->tm_min = 0; 
    tm->tm_hour = 0; 
    tm->tm_mday = 1; 

    t = mktime(tm);

    if ( previous) {
      if ( from) {
	from->tv_sec = t;
	from->tv_nsec = 0;
      }
    }      
    else {
      if ( to) {
	to->tv_sec = t;
	to->tv_nsec = 0;
      }
    }

    return 1;
}

//! Calculate start and end time for month.
static int time_PeriodYear( pwr_tTime *time, 
			    pwr_tTime *from,
			    pwr_tTime *to,
			    int previous)
{
    struct tm	*tm;
    int		days, year;
    time_t 	t;
    time_t 	sec = time->tv_sec;

    tm = localtime(&sec);

    sec = time->tv_sec - (tm->tm_yday - 1) * ONEDAY;

    tm = localtime(&sec);

    tm->tm_sec = 0; 
    tm->tm_min = 0; 
    tm->tm_hour = 0; 
    tm->tm_mon = 0; 
    tm->tm_mday = 1; 

    t = mktime(tm);

    year = tm->tm_year + 1900;
    if ( previous)
	year--;

    if (( year % 4 == 0 && year % 100 != 0) || (year + 1900) % 400 == 0)
      days = 365;
    else
      days = 366;

    if ( previous) {
      if ( to) {
	to->tv_sec = t;
	to->tv_nsec = 0;
      }
    }      
    else {
      if ( from) {
	from->tv_sec = t;
	from->tv_nsec = 0;
      }
    }

    if ( previous)
      sec  = t - (days - 1) * ONEDAY;
    else
      sec = t + (days + 1) * ONEDAY;
      
    tm = localtime(&sec);

    tm->tm_sec = 0; 
    tm->tm_min = 0; 
    tm->tm_hour = 0; 
    tm->tm_mon = 0; 
    tm->tm_mday = 1; 

    t = mktime(tm);

    if ( previous) {
      if ( from) {
	from->tv_sec = t;
	from->tv_nsec = 0;
      }
    }      
    else {
      if ( to) {
	to->tv_sec = t;
	to->tv_nsec = 0;
      }
    }

    return 1;
}

//! Calculate start and end time for previous week.
/*! Computes dates for monday to sunday in the
    previous week from the time now.
    Output times are only date, e g 1-MAY-1992 00:00:00.00.
*/

int time_PeriodPreviousWeek( pwr_tTime *time, 
			     pwr_tTime *from,
			     pwr_tTime *to)
{
    struct tm	*tm;
    int		days;
    pwr_tTime   t;

    time_t sec = time->tv_sec;
    tm = localtime(&sec);
    if (tm->tm_wday == 0) /* Sunday */
      days = 13;
    else
      days = tm->tm_wday + 6;

    tm->tm_sec = 0;
    tm->tm_min = 0;
    tm->tm_hour = 0;
    t.tv_sec = mktime(tm);

    if ( from) {
      from->tv_sec = t.tv_sec - days * ONEDAY;
      from->tv_nsec = 0;
    }
    if ( to) {
      to->tv_sec = t.tv_sec + (7 - days) * ONEDAY;
      to->tv_nsec = 0;
    }

    return 1;
}

void time_PreviousDayBreak( pwr_tTime *time, 
			    pwr_tTime *daybreak)
{
    struct tm	*tm;

    time_t sec = time->tv_sec;
    tm = localtime(&sec);

    tm->tm_sec = 0;
    tm->tm_min = 0;
    tm->tm_hour = 0;

    daybreak->tv_sec = mktime(tm);
    daybreak->tv_nsec = 0;
}

static void time_PeriodSec( pwr_tTime *from, pwr_tTime *to, pwr_tTime *center, int sec)
{
  pwr_tStatus sts;
  pwr_tTime current;

  sts = time_GetTime( &current);
  to->tv_sec = center->tv_sec + sec/2;
  to->tv_nsec = center->tv_nsec;
  if ( time_Acomp( to, &current) == 1)
    *to = current;
  from->tv_sec = to->tv_sec - sec;
  from->tv_nsec = to->tv_nsec;
}

void time_Period( time_ePeriod period, pwr_tTime *from, pwr_tTime *to, pwr_tTime *center, 
		  int daybreak)
{
  int	    sts;
  pwr_tTime current;

  switch ( period) {
  case time_ePeriod_OneMinute:
    if ( !center) {
      time_Period( time_ePeriod_LastMinute, from, to, center, daybreak);
      return;
    }
    time_PeriodSec( from, to, center, 60);
    break;
  case time_ePeriod_10Minutes:
    if ( !center) {
      time_Period( time_ePeriod_Last10Minutes, from, to, center, daybreak);
      return;
    }
    time_PeriodSec( from, to, center, 600);
    break;
  case time_ePeriod_OneHour:
    if ( !center) {
      time_Period( time_ePeriod_LastHour, from, to, center, daybreak);
      return;
    }
    time_PeriodSec( from, to, center, 3600);
    break;
  case time_ePeriod_OneDay:
    if ( !center) {
      time_Period( time_ePeriod_LastHour, from, to, center, daybreak);
      return;
    }
    time_PeriodSec( from, to, center, ONEDAY);
    break;
  case time_ePeriod_OneWeek:
    if ( !center) {
      time_Period( time_ePeriod_LastWeek, from, to, center, daybreak);
      return;
    }
    time_PeriodSec( from, to, center, 7 * ONEDAY);
    break;
  case time_ePeriod_OneMonth:
    if ( !center) {
      time_Period( time_ePeriod_LastMonth, from, to, center, daybreak);
      return;
    }
    time_PeriodMonth( center, from, to, 0);
    int middle = from->tv_sec + (to->tv_sec - from->tv_sec) / 2;
    int half = middle - from->tv_sec;
    if ( center->tv_sec >= middle - ONEDAY/2 &&
	 center->tv_sec <= middle + ONEDAY/2)
      return;

    if ( center->tv_sec < middle) {
      // Take period from previous month
      time_PeriodMonth( center, from, to, 1);
      middle = from->tv_sec + (to->tv_sec - from->tv_sec) / 2;
      half = middle - from->tv_sec;
    }
    to->tv_sec = center->tv_sec + half;
    from->tv_sec = center->tv_sec - half;

    sts = time_GetTime( &current);
    if ( time_Acomp( to, &current) == 1) {
      from->tv_sec = current.tv_sec - (to->tv_sec - from->tv_sec);
      from->tv_nsec = current.tv_sec;
      *to = current;
    }
    break;
  case time_ePeriod_LastMinute:
    sts = time_GetTime( to);
    from->tv_sec = to->tv_sec - 60;
    from->tv_nsec = to->tv_nsec;
    break;
  case time_ePeriod_Last10Minutes:
    sts = time_GetTime( to);
    from->tv_sec = to->tv_sec - 600;
    from->tv_nsec = to->tv_nsec;
    break;
  case time_ePeriod_LastHour:
    sts = time_GetTime( to);
    from->tv_sec = to->tv_sec - 3600;
    from->tv_nsec = to->tv_nsec;
    break;
  case time_ePeriod_Today:
    sts = time_GetTime( from);
    *to = *from;

    time_PreviousDayBreak( from, from);

    if ( daybreak) {
      to->tv_sec += ONEDAY;
      time_PreviousDayBreak( to, to);
    }
    break;
  case time_ePeriod_Yesterday:
    sts = time_GetTime( to);
    time_PreviousDayBreak( to, to);
    
    from->tv_sec = to->tv_sec - ONEDAY;
    from->tv_nsec = 0;
    break;
  case time_ePeriod_ThisWeek:
    sts = time_GetTime( &current);

    sts = time_PeriodPreviousWeek( &current, 0, from);

    *to = current;
    if ( daybreak) {
      to->tv_sec += ONEDAY;
      time_PreviousDayBreak( to, to);
    }
    break;
  case time_ePeriod_LastWeek:
    sts = time_GetTime( &current);

    sts = time_PeriodPreviousWeek( &current, from, to);
    break;
  case time_ePeriod_ThisMonth:
    sts = time_GetTime( &current);

    sts = time_PeriodMonth( &current, 0, from, 1);

    *to = current;
    if ( daybreak) {
      to->tv_sec += ONEDAY;
      time_PreviousDayBreak( to, to);
    }
    break;
  case time_ePeriod_LastMonth:
    sts = time_GetTime( &current);

    sts = time_PeriodMonth( &current, from, to, 1);
    break;
  case time_ePeriod_OneYear:
  case time_ePeriod_ThisYear:
    sts = time_GetTime( &current);

    sts = time_PeriodYear( &current, 0, from, 1);

    *to = current;
    if ( daybreak) {
      to->tv_sec += ONEDAY;
      time_PreviousDayBreak( to, to);
    }
    break;
  default: {
    // time_ePeriod_All: 
    struct tm	*tm;

    sts = time_GetTime( to);
    if ( daybreak) {
      to->tv_sec += ONEDAY;
      time_PreviousDayBreak( to, to);
    }

    time_t sec = to->tv_sec;
    tm = localtime(&sec);
    tm->tm_sec = 0; 
    tm->tm_min = 0; 
    tm->tm_hour = 0; 
    tm->tm_mday = 1; 
    tm->tm_mon = 0; 
    tm->tm_year = 70; 
    from->tv_sec = mktime(tm); 
    from->tv_nsec = 0;    

    break;
  }
  }
}

void time_PreviousPeriod( time_ePeriod period, pwr_tTime *prev_from, pwr_tTime *prev_to,
			  pwr_tTime *from, pwr_tTime *to)
{

  switch ( period) {
  case time_ePeriod_OneMinute:
  case time_ePeriod_LastMinute:
    *to = *from = *prev_from;
    from->tv_sec -= 60;
    if ( from->tv_sec < 0) {
      from->tv_sec = 0;
      to->tv_sec = 60;
    }
    break;
  case time_ePeriod_10Minutes:
  case time_ePeriod_Last10Minutes:
    *to = *from = *prev_from;
    from->tv_sec -= 600;
    if ( from->tv_sec < 0) {
      from->tv_sec = 0;
      to->tv_sec = 600;
    }
    break;
  case time_ePeriod_OneHour:
  case time_ePeriod_LastHour:
    *to = *from = *prev_from;
    from->tv_sec -= 3600;
    if ( from->tv_sec < 0) {
      from->tv_sec = 0;
      to->tv_sec = 3660;
    }
    break;
  case time_ePeriod_OneDay:
  case time_ePeriod_Today:
  case time_ePeriod_Yesterday:
    *to = *from = *prev_from;
    from->tv_sec -= ONEDAY;
    if ( from->tv_sec < 0) {
      from->tv_sec = 0;
      to->tv_sec = ONEDAY;
    }
    break;
  case time_ePeriod_OneWeek:
  case time_ePeriod_ThisWeek:
  case time_ePeriod_LastWeek:
    *to = *from = *prev_from;
    from->tv_sec -= ONEDAY * 7;
    if ( from->tv_sec < 0) {
      from->tv_sec = 0;
      to->tv_sec = ONEDAY * 7;
    }
    break;
  case time_ePeriod_OneMonth:
  case time_ePeriod_ThisMonth:
  case time_ePeriod_LastMonth:
    time_PeriodMonth( prev_from, from, to, 1);
    from->tv_sec += prev_from->tv_sec - to->tv_sec;
    from->tv_nsec = prev_from->tv_nsec;
    *to = *prev_from;
    if ( from->tv_sec < 0) {
      from->tv_sec = 0;
      to->tv_sec = ONEDAY * 30;
    }
    break;
  case time_ePeriod_OneYear:
  case time_ePeriod_ThisYear:
    time_PeriodYear( prev_from, from, to, 1);
    from->tv_sec += prev_from->tv_sec - to->tv_sec;
    from->tv_nsec = prev_from->tv_nsec;
    *to = *prev_from;
    if ( from->tv_sec < 0) {
      from->tv_sec = 0;
      to->tv_sec = ONEDAY * 365;
    }
    break;
  case time_ePeriod_AllTime:
    time_Period( period, from, to, 0, 1);
    break;
  case time_ePeriod_UserDefined:
    // Same lenth of intervall as before
    *to = *from = *prev_from;
    from->tv_sec -= prev_to->tv_sec - prev_from->tv_sec;
    if ( from->tv_sec < 0) {
      from->tv_sec = 0;
      to->tv_sec = prev_to->tv_sec - prev_from->tv_sec;
    }
    break;
  default: ;
  }
}

void time_NextPeriod( time_ePeriod period, pwr_tTime *prev_from, pwr_tTime *prev_to,
		      pwr_tTime *from, pwr_tTime *to)
{
  int	    sts;
  pwr_tTime current;

  sts = time_GetTime( &current);

  switch ( period) {
  case time_ePeriod_OneMinute:
  case time_ePeriod_LastMinute:
    *to = *from = *prev_to;
    to->tv_sec += 60;
    if ( time_Acomp( &current, to) != 1) {
      *to = current;
      from->tv_sec = current.tv_sec - 60;
      from->tv_nsec = current.tv_nsec;
    }
    break;
  case time_ePeriod_10Minutes:
  case time_ePeriod_Last10Minutes:
    *to = *from = *prev_to;
    to->tv_sec += 600;
    if ( time_Acomp( &current, to) != 1) {
      *to = current;
      from->tv_sec = current.tv_sec - 600;
      from->tv_nsec = current.tv_nsec;
    }
    break;
  case time_ePeriod_OneHour:
  case time_ePeriod_LastHour:
    *to = *from = *prev_to;
    to->tv_sec += 3600;
    if ( time_Acomp( &current, to) != 1) {
      *to = current;
      from->tv_sec = current.tv_sec - 3600;
      from->tv_nsec = current.tv_nsec;
    }
    break;
  case time_ePeriod_OneDay:
  case time_ePeriod_Today:
  case time_ePeriod_Yesterday:
    *to = *from = *prev_to;
    to->tv_sec += ONEDAY;
    if ( time_Acomp( &current, to) != 1) {
      *to = current;
      from->tv_sec = current.tv_sec - ONEDAY;
      from->tv_nsec = current.tv_nsec;
    }
    break;
  case time_ePeriod_OneWeek:
  case time_ePeriod_ThisWeek:
  case time_ePeriod_LastWeek:
    *to = *from = *prev_to;
    to->tv_sec += 7 * ONEDAY;
    if ( time_Acomp( &current, to) != 1) {
      *to = current;
      from->tv_sec = current.tv_sec - 7 * ONEDAY;
      from->tv_nsec = current.tv_nsec;
    }
    break;
  case time_ePeriod_OneMonth:
  case time_ePeriod_ThisMonth:
  case time_ePeriod_LastMonth:
    time_PeriodMonth( prev_to, from, to, 0);
    to->tv_sec += prev_to->tv_sec - from->tv_sec;
    *from = *prev_to;
    if ( time_Acomp( &current, to) != 1) {
      *to = current;
      from->tv_sec = current.tv_sec - 30 * ONEDAY;
      from->tv_nsec = current.tv_nsec;
    }
    break;
  case time_ePeriod_OneYear:
  case time_ePeriod_ThisYear:
    time_PeriodYear( prev_to, from, to, 0);
    to->tv_sec += prev_to->tv_sec - from->tv_sec;
    *from = *prev_to;
    if ( time_Acomp( &current, to) != 1) {
      *to = current;
      from->tv_sec = current.tv_sec - 365 * ONEDAY;
      from->tv_nsec = current.tv_nsec;
    }
    break;
    break;
  case time_ePeriod_AllTime:
    time_Period( period, from, to, 0, 1);
    break;
  case time_ePeriod_UserDefined:
    // Same lenth of intervall as before
    *to = *from = *prev_to;
    to->tv_sec += prev_to->tv_sec - prev_from->tv_sec;
    if ( time_Acomp( &current, to) != 1) {
      *to = current;
      from->tv_sec = current.tv_sec - (prev_to->tv_sec - prev_from->tv_sec);
      from->tv_nsec = current.tv_nsec;
    }
    break;
  default: ;
  }
}

int time_PeriodZoomIn( time_ePeriod *period)
{
  int changed = 1;
  switch( *period) {
  case time_ePeriod_Last10Minutes:
  case time_ePeriod_10Minutes:
    *period = time_ePeriod_OneMinute;
    break;
  case time_ePeriod_OneHour:
  case time_ePeriod_LastHour:
    *period = time_ePeriod_10Minutes;
    break;
  case time_ePeriod_Today:
  case time_ePeriod_Yesterday:
  case time_ePeriod_OneDay:
    *period = time_ePeriod_OneHour;
    break;
  case time_ePeriod_ThisWeek:
  case time_ePeriod_LastWeek:
  case time_ePeriod_OneWeek:
    *period = time_ePeriod_OneDay;
    break;
  case time_ePeriod_ThisMonth:
  case time_ePeriod_LastMonth:
  case time_ePeriod_OneMonth:
    *period = time_ePeriod_OneWeek;
    break;
  case time_ePeriod_ThisYear:
  case time_ePeriod_OneYear:
    *period = time_ePeriod_OneMonth;
    break;
  case time_ePeriod_AllTime:
    *period = time_ePeriod_OneYear;
    break;
  default:
    changed = 0;
  }
  return changed;
}

int time_PeriodZoomOut( time_ePeriod *period)
{
  int changed = 1;

  switch( *period) {
  case time_ePeriod_OneMinute:
  case time_ePeriod_LastMinute:
    *period = time_ePeriod_10Minutes;
    break;
  case time_ePeriod_Last10Minutes:
  case time_ePeriod_10Minutes:
    *period = time_ePeriod_OneHour;
    break;
  case time_ePeriod_OneHour:
  case time_ePeriod_LastHour:
    *period = time_ePeriod_OneDay;
    break;
  case time_ePeriod_Today:
  case time_ePeriod_Yesterday:
  case time_ePeriod_OneDay:
    *period = time_ePeriod_OneWeek;
    break;
  case time_ePeriod_ThisWeek:
  case time_ePeriod_LastWeek:
  case time_ePeriod_OneWeek:
    *period = time_ePeriod_OneMonth;
    break;
  case time_ePeriod_ThisMonth:
  case time_ePeriod_LastMonth:
  case time_ePeriod_OneMonth:
    *period = time_ePeriod_OneYear;
    break;
  case time_ePeriod_ThisYear:
  case time_ePeriod_OneYear:
    *period = time_ePeriod_AllTime;
    break;
  default:
    changed = 0;
  }
  return changed;
}
