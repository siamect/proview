/**
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 **/

/* co_time.c -- Utilities for time management.
   NOTE! to convert timespecs to tm's, the threadsafe version of localtime,
         localtime_r must be used, which doesn't exist on DEC.  */

#include <ctype.h>
#ifdef OS_MACOS
#include <errno.h>
#endif
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#include "co_string.h"
#include "co_time.h"
#include "co_time_msg.h"

#define assertAbs(p)                                                           \
  do {                                                                         \
    pwr_Assert(p->tv_nsec >= 0 && p->tv_nsec < 1000000000);                    \
  } while (0)
#define notATime(p) (p->tv_nsec < 0 || p->tv_nsec >= 1000000000)

#define assertDelta(p)                                                         \
  do {                                                                         \
    pwr_Assert((p->tv_sec > 0) ? (p->tv_nsec >= 0 && p->tv_nsec < 1000000000)  \
                               : TRUE);                                        \
    pwr_Assert((p->tv_sec < 0) ? (p->tv_nsec <= 0 && p->tv_nsec > -1000000000) \
                               : TRUE);                                        \
  } while (0)
#define notADeltaTime(p)                                                       \
  (((p->tv_sec > 0) && (p->tv_nsec < 0 || p->tv_nsec >= 1000000000))           \
      || ((p->tv_sec == 0)                                                     \
             && (p->tv_nsec <= -1000000000 || p->tv_nsec >= 1000000000))       \
      || ((p->tv_sec < 0) && (p->tv_nsec > 0 || p->tv_nsec <= -1000000000)))

#define ONEDAY 86400

/* String representations of months.  */

static const char* monStr[] = { "JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL",
  "AUG", "SEP", "OCT", "NOV", "DEC" };

#ifdef OS_MACOS
int clock_gettime(clockid_t clockid, struct timespec* pt)
{
  if (clockid == CLOCK_REALTIME) {
    struct timeval tv;

    gettimeofday(&tv, 0);

    pt->tv_sec = tv.tv_sec;
    pt->tv_nsec = tv.tv_usec * 1000;
  } else if (clockid == CLOCK_MONOTONIC) {
    // TODO
    struct timeval tv;

    gettimeofday(&tv, 0);

    pt->tv_sec = tv.tv_sec;
    pt->tv_nsec = tv.tv_usec * 1000;
  } else {
    errno = EINVAL;
    return -1;
  }

  return 0;
}
#endif

/* Validate data in struct tm.  */

static pwr_tStatus validateTm(struct tm* tms)
{
  int year;

  /* Check generic ranges.  */

  if (69 > tms->tm_year /*|| tms->tm_year > 137*/) /* EPOCH is 1970 end feb 2038 */
    return TIME__RANGE;
  else if (0 > tms->tm_mon || tms->tm_mon > 11)
    return TIME__RANGE;
  else if (1 > tms->tm_mday || tms->tm_mday > 31)
    return TIME__RANGE;
  else if (0 > tms->tm_hour || tms->tm_hour > 23)
    return TIME__RANGE;
  else if (0 > tms->tm_min || tms->tm_min > 59)
    return TIME__RANGE;
  else if (0 > tms->tm_sec
      || tms->tm_sec > 59) /* Should be 61 according to POSIX */
    return TIME__RANGE;

  /*
   * validate date
   */
  switch (tms->tm_mon) {
  case 1:
    /* check for leap year */
    year = tms->tm_year + 1900;
    if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {
      if (tms->tm_mday > 29)
        return TIME__RANGE;
    } else {
      if (tms->tm_mday > 28)
        return TIME__RANGE;
    }
    break;

  case 3:
  case 5:
  case 8:
  case 10:
    if (tms->tm_mday > 30)
      return TIME__RANGE;
    break;

  case 0:
  case 2:
  case 4:
  case 6:
  case 7:
  case 9:
  case 11:
    if (tms->tm_mday > 31)
      return TIME__RANGE;
    break;

  default:
    return TIME__RANGE;
  }
  return TIME__SUCCESS;
}

//! Test if time is Null.
int time_IsNull(pwr_tTime* t1)
{
  assertAbs(t1);

  return (t1->tv_sec == pwr_cNTime.tv_sec)
      && (t1->tv_nsec == pwr_cNTime.tv_nsec);
}

//! Add an absolute time and a delta time.
/*! Add two timespecs, result = t + d, where:

   -  'result' and 't' is an absolute time, and
   -  'd' is a delta time.

  If 'result' argument is NULL
  then 't' will be used as resultant.
  Returns the address to the resulting time.

  Input arguments containing invalid times will
  cause an exception.
*/

pwr_tTime* time_Aadd(pwr_tTime* result, pwr_tTime* t, pwr_tDeltaTime* a)
{
  pwr_tInt64 tv_nsec = t->tv_nsec + a->tv_nsec;
  pwr_tInt64 tv_sec = t->tv_sec + a->tv_sec;
  pwr_tTime* r = result;

  assertAbs(t);
  assertDelta(a);

  if (result == NULL)
    r = t;

  tv_sec += tv_nsec / 1000000000;
  tv_nsec %= 1000000000;
  if (tv_nsec < 0 && tv_sec > 0) {
    tv_sec--;
    tv_nsec += 1000000000;
  } else if (tv_sec < 0 && tv_nsec > 0) {
    tv_sec++;
    tv_nsec -= 1000000000;
  }

  r->tv_sec = tv_sec;
  r->tv_nsec = tv_nsec;
  return r;
}

//! Add an absolute time and a delta time.
/*! Add two timespecs, result = t + d, where:

   -  'result' and 't' is an absolute time, and
   -  'd' is a delta time.

  If 'result' argument is NULL
  then 't' will be used as resultant.
  Returns the address to the resulting time.

  If any input argument contains an invalid time
  an invalid time, pwr_cNotATime, is returned.
*/

pwr_tTime* time_Aadd_NE(pwr_tTime* result, pwr_tTime* t, pwr_tDeltaTime* a)
{
  pwr_tInt64 tv_nsec = t->tv_nsec + a->tv_nsec;
  pwr_tInt64 tv_sec = t->tv_sec + a->tv_sec;
  pwr_tTime* r = result;

  if (result == NULL)
    r = t;

  if (notATime(t) || notADeltaTime(a)) {
    *r = pwr_cNotATime;
    return r;
  }

  tv_sec += tv_nsec / 1000000000;
  tv_nsec %= 1000000000;
  if (tv_nsec < 0 && tv_sec > 0) {
    tv_sec--;
    tv_nsec += 1000000000;
  } else if (tv_sec < 0 && tv_nsec > 0) {
    tv_sec++;
    tv_nsec -= 1000000000;
  }

  r->tv_sec = tv_sec;
  r->tv_nsec = tv_nsec;
  return r;
}

//! Compare two timespecs.
/*!   Returns \n
    1 if t1  > t2 \n
    0 if t1 == t2 \n
   -1 if t1  < t2 \n

   If argument 't2' is NULL the comparison will
   be done as if t2 == 0.

  Input arguments containing invalid times will
  cause an exception.
*/

int time_Acomp(pwr_tTime* t1, pwr_tTime* t2)
{
  static pwr_tTime null = { 0, 0 };

  if (t2 == NULL)
    t2 = &null;

  assertAbs(t1);
  assertAbs(t2);

  if (t1->tv_sec == t2->tv_sec) {
    if (t1->tv_nsec == t2->tv_nsec)
      return 0;
    return ((t1->tv_nsec > t2->tv_nsec) ? 1 : -1);
  } else
    return ((t1->tv_sec > t2->tv_sec) ? 1 : -1);
}

//! Compare two timespecs.
/*!   Returns \n
    1 if t1  > t2 \n
    0 if t1 == t2 \n
   -1 if t1  < t2 \n

   If argument 't2' is NULL the comparison will
   be done as if t2 == 0.

   If any input argument contains an invalid time
   -2 is returned.
*/
int time_Acomp_NE(pwr_tTime* t1, pwr_tTime* t2)
{
  static pwr_tTime null = { 0, 0 };

  if (t2 == NULL)
    t2 = &null;

  if (notATime(t1) || notATime(t2))
    return -2;

  if (t1->tv_sec == t2->tv_sec) {
    if (t1->tv_nsec == t2->tv_nsec)
      return 0;
    return ((t1->tv_nsec > t2->tv_nsec) ? 1 : -1);
  } else
    return ((t1->tv_sec > t2->tv_sec) ? 1 : -1);
}

//! Subtract a time from a time,
/*!   r = t - s

  Result is always a delta time.

  Input arguments containing invalid times will
  cause an exception.
*/

pwr_tDeltaTime* time_Adiff(pwr_tDeltaTime* r, pwr_tTime* t, pwr_tTime* s)
{
  pwr_tInt64 tv_nsec = t->tv_nsec - s->tv_nsec;
  pwr_tInt64 tv_sec = t->tv_sec - s->tv_sec;

  pwr_Assert(r != NULL);
  assertAbs(t);
  assertAbs(s);

  tv_sec = tv_sec + tv_nsec / 1000000000;
  tv_nsec = tv_nsec % 1000000000;
  if (tv_nsec < 0 && tv_sec > 0) {
    tv_sec--;
    tv_nsec += 1000000000;
  } else if (tv_sec < 0 && tv_nsec > 0) {
    tv_sec++;
    tv_nsec -= 1000000000;
  }

  r->tv_sec = tv_sec;
  r->tv_nsec = tv_nsec;

  return r;
}

//! Subtract a time from a time,
/*!   r = t - s

  Result is always a delta time.

  If any input argument contains an invalid time
  an invalid time, pwr_cNotADeltaTime, is returned.
*/

pwr_tDeltaTime* time_Adiff_NE(pwr_tDeltaTime* r, pwr_tTime* t, pwr_tTime* s)
{
  pwr_tInt64 tv_nsec = t->tv_nsec - s->tv_nsec;
  pwr_tInt64 tv_sec = t->tv_sec - s->tv_sec;

  if (r == NULL || notATime(t) || notATime(s)) {
    *r = pwr_cNotADeltaTime;
    return r;
  }

  tv_sec = tv_sec + tv_nsec / 1000000000;
  tv_nsec = tv_nsec % 1000000000;
  if (tv_nsec < 0 && tv_sec > 0) {
    tv_sec--;
    tv_nsec += 1000000000;
  } else if (tv_sec < 0 && tv_nsec > 0) {
    tv_sec++;
    tv_nsec -= 1000000000;
  }

  r->tv_sec = tv_sec;
  r->tv_nsec = tv_nsec;

  return r;
}

//! Subtract a delta time from a time,
/*!   r = t - s

  Result is always an abstime.

  Input arguments containing invalid times will
  cause an exception.
*/

pwr_tTime* time_Asub(pwr_tTime* result, pwr_tTime* t, pwr_tDeltaTime* s)
{
  pwr_tInt64 tv_nsec = t->tv_nsec - s->tv_nsec;
  pwr_tInt64 tv_sec = t->tv_sec - s->tv_sec;
  pwr_tTime* r = result;

  assertAbs(t);
  assertDelta(s);

  if (r == NULL)
    r = t;

  tv_sec += tv_nsec / 1000000000;
  tv_nsec %= 1000000000;
  if (tv_nsec < 0 && tv_sec > 0) {
    tv_sec--;
    tv_nsec += 1000000000;
  } else if (tv_sec < 0 && tv_nsec > 0) {
    tv_sec++;
    tv_nsec -= 1000000000;
  }

  r->tv_sec = tv_sec;
  r->tv_nsec = tv_nsec;
  return r;
}

//! Subtract a delta time from a time,
/*!   r = t - s

  Result is always an abstime.

  If any input argument contains an invalid time
  an invalid time, pwr_cNotATime, is returned.
*/

pwr_tTime* time_Asub_NE(pwr_tTime* result, pwr_tTime* t, pwr_tDeltaTime* s)
{
  pwr_tInt64 tv_nsec = t->tv_nsec - s->tv_nsec;
  pwr_tInt64 tv_sec = t->tv_sec - s->tv_sec;
  pwr_tTime* r = result;

  if (r == NULL)
    r = t;

  if (notATime(t) || notADeltaTime(s)) {
    *r = pwr_cNotATime;
    return r;
  }

  tv_sec += tv_nsec / 1000000000;
  tv_nsec %= 1000000000;
  if (tv_nsec < 0 && tv_sec > 0) {
    tv_sec--;
    tv_nsec += 1000000000;
  } else if (tv_sec < 0 && tv_nsec > 0) {
    tv_sec++;
    tv_nsec -= 1000000000;
  }

  r->tv_sec = tv_sec;
  r->tv_nsec = tv_nsec;
  return r;
}

//! Take the absolute walue of a delta time.
/*!
   'result' = |'t'|

   A NULL address => abs value is written to 't'.
   Returns the address to the resulting time.

   Input arguments containing invalid times will
   cause an exception.
*/

pwr_tDeltaTime* time_Dabs(pwr_tDeltaTime* result, pwr_tDeltaTime* t)
{
  pwr_tDeltaTime* r = result;

  assertDelta(t);

  if (r == NULL)
    r = t;
  else {
    r->tv_sec = t->tv_sec;
    r->tv_nsec = t->tv_nsec;
  }
  
  if (r->tv_sec < 0)
    r->tv_sec = -r->tv_sec;
  if (r->tv_nsec < 0)
    r->tv_nsec = -r->tv_nsec;

  return r;
}

//! Take the absolute walue of a delta time.
/*!
   'result' = |'t'|

   A NULL address => abs value is written to 't'.
   Returns the address to the resulting time.

   If any input argument contains an invalid time
   an invalid time, pwr_cNotADeltaTime, is returned.
*/

pwr_tDeltaTime* time_Dabs_NE(pwr_tDeltaTime* result, pwr_tDeltaTime* t)
{
  pwr_tDeltaTime* r = result;

  if (r == NULL)
    r = t;
  else {
    r->tv_sec = t->tv_sec;
    r->tv_nsec = t->tv_nsec;
  }

  if (notADeltaTime(t)) {
    *r = pwr_cNotADeltaTime;
    return r;
  }

  if (r->tv_sec < 0)
    r->tv_sec = -r->tv_sec;
  if (r->tv_nsec < 0)
    r->tv_nsec = -r->tv_nsec;

  return r;
}

//! Add two delta times, the result is also delta.
/*!   If 'result' is NULL then 'a' will be added to 't'.

  Input arguments containing invalid times will
  cause an exception.
*/

pwr_tDeltaTime* time_Dadd(
    pwr_tDeltaTime* result, pwr_tDeltaTime* t, pwr_tDeltaTime* a)
{
  pwr_tDeltaTime* r = result;
  pwr_tInt64 tv_nsec, tv_sec;

  assertDelta(t);
  assertDelta(a);

  if (result == NULL)
    r = t;

  tv_nsec = t->tv_nsec + a->tv_nsec;
  tv_sec = t->tv_sec + a->tv_sec + (tv_nsec / 1000000000);
  tv_nsec = tv_nsec % 1000000000;

  if (tv_nsec < 0 && tv_sec > 0) {
    tv_sec--;
    tv_nsec += 1000000000;
  } else if (tv_sec < 0 && tv_nsec > 0) {
    tv_sec++;
    tv_nsec -= 1000000000;
  }

  r->tv_sec = tv_sec;
  r->tv_nsec = tv_nsec;

  return r;
}

//! Add two delta times, the result is also delta.
/*!   If 'result' is NULL then 'a' will be added to 't'.

  If any input argument contains an invalid time
  an invalid time, pwr_cNotADeltaTime, is returned.
*/

pwr_tDeltaTime* time_Dadd_NE(
    pwr_tDeltaTime* result, pwr_tDeltaTime* t, pwr_tDeltaTime* a)
{
  pwr_tDeltaTime* r = result;
  pwr_tInt64 tv_nsec, tv_sec;

  if (result == NULL)
    r = t;

  if (notADeltaTime(t) || notADeltaTime(a)) {
    *r = pwr_cNotADeltaTime;
    return r;
  }

  tv_nsec = t->tv_nsec + a->tv_nsec;
  tv_sec = t->tv_sec + a->tv_sec + (tv_nsec / 1000000000);
  tv_nsec = tv_nsec % 1000000000;

  if (tv_nsec < 0 && tv_sec > 0) {
    tv_sec--;
    tv_nsec += 1000000000;
  } else if (tv_sec < 0 && tv_nsec > 0) {
    tv_sec++;
    tv_nsec -= 1000000000;
  }

  r->tv_sec = tv_sec;
  r->tv_nsec = tv_nsec;

  return r;
}

//! Compare two delta times.
/*!   Returns \n
    1 if t1  > t2 \n
    0 if t1 == t2 \n
   -1 if t1  < t2 \n

   If argument 't2' is NULL the comparison will
   be done as if t2 == 0.

   Input arguments containing invalid times will
   cause an exception.
*/

int time_Dcomp(pwr_tDeltaTime* t1, pwr_tDeltaTime* t2)
{
  static pwr_tDeltaTime null = { 0, 0 };

  if (t2 == NULL)
    t2 = &null;

  assertDelta(t1);
  assertDelta(t2);

  if (t1->tv_sec == t2->tv_sec) {
    if (t1->tv_nsec == t2->tv_nsec)
      return 0;
    return ((t1->tv_nsec > t2->tv_nsec) ? 1 : -1);
  }
  return ((t1->tv_sec > t2->tv_sec) ? 1 : -1);
}

//! Compare two delta times.
/*!   Returns \n
    1 if t1  > t2 \n
    0 if t1 == t2 \n
   -1 if t1  < t2 \n

   If argument 't2' is NULL the comparison will
   be done as if t2 == 0.

   If any input argument contains an invalid time
   -2 is returned.
*/

int time_Dcomp_NE(pwr_tDeltaTime* t1, pwr_tDeltaTime* t2)
{
  static pwr_tDeltaTime null = { 0, 0 };

  if (t2 == NULL)
    t2 = &null;

  if (notADeltaTime(t1) || notADeltaTime(t2))
    return -2;

  if (t1->tv_sec == t2->tv_sec) {
    if (t1->tv_nsec == t2->tv_nsec)
      return 0;
    return ((t1->tv_nsec > t2->tv_nsec) ? 1 : -1);
  }
  return ((t1->tv_sec > t2->tv_sec) ? 1 : -1);
}

//! Negate a delta time,
/*!
   result = -d

  If 'result' argument is NULL
  then 'd' will be used as resultant.
  Returns the address to the resulting time.

  Input arguments containing invalid times will
  cause an exception.
*/

pwr_tDeltaTime* time_Dneg(pwr_tDeltaTime* result, pwr_tDeltaTime* t)
{
  pwr_tDeltaTime* r = result;

  assertDelta(t);

  if (r == NULL)
    r = t;
  else {
    r->tv_sec = t->tv_sec;
    r->tv_nsec = t->tv_nsec;
  }

  r->tv_sec = -r->tv_sec;
  r->tv_nsec = -r->tv_nsec;

  return r;
}

//! Negate a delta time,
/*!
   result = -d

  If 'result' argument is NULL
  then 'd' will be used as resultant.
  Returns the address to the resulting time.

  If any input argument contains an invalid time
  an invalid time, pwr_cNotADeltaTime, is returned.
*/

pwr_tDeltaTime* time_Dneg_NE(pwr_tDeltaTime* result, pwr_tDeltaTime* t)
{
  pwr_tDeltaTime* r = result;

  if (r == NULL)
    r = t;
  else {
    r->tv_sec = t->tv_sec;
    r->tv_nsec = t->tv_nsec;
  }

  if (notADeltaTime(t)) {
    *r = pwr_cNotADeltaTime;
    return r;
  }

  r->tv_sec = -r->tv_sec;
  r->tv_nsec = -r->tv_nsec;

  return r;
}

//! Subtract two delta times.
/*! The result is also delta.

    Input arguments containing invalid times will
    cause an exception.
*/

pwr_tDeltaTime* time_Dsub(
    pwr_tDeltaTime* result, pwr_tDeltaTime* t, pwr_tDeltaTime* s)
{
  pwr_tInt64 tv_nsec = t->tv_nsec - s->tv_nsec;
  pwr_tInt64 tv_sec = t->tv_sec - s->tv_sec;
  pwr_tDeltaTime* r = result;

  assertDelta(t);
  assertDelta(s);

  if (r == NULL)
    r = t;

  tv_sec = tv_sec + tv_nsec / 1000000000;
  tv_nsec = tv_nsec % 1000000000;
  if (tv_nsec < 0 && tv_sec > 0) {
    tv_sec--;
    tv_nsec += 1000000000;
  } else if (tv_sec < 0 && tv_nsec > 0) {
    tv_sec++;
    tv_nsec -= 1000000000;
  }

  r->tv_sec = tv_sec;
  r->tv_nsec = tv_nsec;

  return r;
}

//! Subtract two delta times.
/*! The result is also delta.

    If any input argument contains an invalid time
    an invalid time, pwr_cNotADeltaTime, is returned.
*/

pwr_tDeltaTime* time_Dsub_NE(
    pwr_tDeltaTime* result, pwr_tDeltaTime* t, pwr_tDeltaTime* s)
{
  pwr_tInt64 tv_nsec = t->tv_nsec - s->tv_nsec;
  pwr_tInt64 tv_sec = t->tv_sec - s->tv_sec;
  pwr_tDeltaTime* r = result;

  if (r == NULL)
    r = t;

  if (notADeltaTime(t) || notADeltaTime(s)) {
    *r = pwr_cNotADeltaTime;
    return r;
  }

  tv_sec = tv_sec + tv_nsec / 1000000000;
  tv_nsec = tv_nsec % 1000000000;
  if (tv_nsec < 0 && tv_sec > 0) {
    tv_sec--;
    tv_nsec += 1000000000;
  } else if (tv_sec < 0 && tv_nsec > 0) {
    tv_sec++;
    tv_nsec -= 1000000000;
  }

  r->tv_sec = tv_sec;
  r->tv_nsec = tv_nsec;

  return r;
}

//! Convert a delta time to ascii string.

pwr_tStatus time_DtoAscii(
    pwr_tDeltaTime* dt, int hundreds, char* buf, int bufsize)
{
  char tmpStr[32];
  div_t day, hour, min;
  pwr_tDeltaTime t;
  int neg = 0;

  if (dt == NULL)
    return TIME__IVDTIME;

  if (notADeltaTime(dt)) {
    strncpy(buf, "NotADeltaTime", bufsize);
    buf[bufsize - 1] = '\0';
    return TIME__NADT;
  }

  if (dt->tv_sec < 0 || dt->tv_nsec < 0) {    
    neg = 1;
#if defined(HW_X86_64)
    t.tv_sec = labs(dt->tv_sec);
    t.tv_nsec = labs(dt->tv_nsec);
#else
    t.tv_sec = abs(dt->tv_sec);
    t.tv_nsec = abs(dt->tv_nsec);
#endif
    dt = &t;
  }

  day = div(dt->tv_sec, 24 * 3600);
  hour = div(day.rem, 3600);
  min = div(hour.rem, 60);

  if (day.quot) {
    if (hundreds) {
      long int nsec = dt->tv_nsec / 10000000;
      sprintf(tmpStr, "%s%d %d:%02d:%02d.%02ld", neg?"-":"", day.quot, hour.quot, min.quot,
          min.rem, nsec);
    } else
      sprintf(
          tmpStr, "%s%d %d:%02d:%02d", neg?"-":"", day.quot, hour.quot, min.quot, min.rem);
  } else {
    if (hundreds) {
      long int nsec = dt->tv_nsec / 10000000;
      sprintf(tmpStr, "%s%d:%02d:%02d.%02ld", neg?"-":"", hour.quot, min.quot, min.rem, nsec);
    } else
      sprintf(tmpStr, "%s%d:%02d:%02d", neg?"-":"", hour.quot, min.quot, min.rem);
  }

  strncpy(buf, tmpStr, bufsize);
  buf[bufsize - 1] = '\0';

  return TIME__SUCCESS;
}

//! Convert timespec to ascii
/*!
   NOTE: Not thread safe.  */

pwr_tStatus time_AtoAscii(
    pwr_tTime* ts, time_eFormat format, char* buf, int bufsize)
{
  struct tm* tmpTm;
  int buflen;
  char tmpStr[16];
  pwr_tTime time;
  pwr_tTime* tp;

  if (ts && notATime(ts)) {
    strncpy(buf, "NotATime", bufsize);
    buf[bufsize - 1] = '\0';
    return TIME__NAT;
  }

  if (ts == NULL) {
    time_GetTime(&time);
    tp = &time;
  } else
    tp = ts;

  time_t sec = tp->tv_sec;
  tmpTm = localtime(&sec);
  if (EVEN(time_TmToAscii(tmpTm, format, buf, bufsize)))
    return TIME__RANGE;

  buflen = strlen(buf);
  switch (format) {
  case time_eFormat_FileDateAndTime:
  case time_eFormat_FileDate:
  case time_eFormat_TimeAndDate:
    break;
  default:
    sprintf(tmpStr, ".%02d", (int)(tp->tv_nsec / 10000000));
    if (strlen(tmpStr) + buflen < (unsigned int)bufsize)
      strcpy(&buf[buflen], tmpStr);
  }

  return TIME__SUCCESS;
}

//! Get current time in ascii
char* time_GetTimeAscii(time_eFormat format)
{
  static char buf[80];
  time_AtoAscii(0, format, buf, sizeof(buf));
  return buf;
}

//! Convert ascii to timespec.
pwr_tStatus time_AsciiToD(const char* tstr, pwr_tDeltaTime* ts)
{
  char *sp, *dp;
  char buf[64];
  int day, hour = 0, min, sec, hun = 0;
  int useday = 1;
  int neg = 0;

  if ( streq( tstr, "NotADeltaTime")) {
    *ts = pwr_cNotADeltaTime;
    return TIME__SUCCESS;
  }
  if (*tstr == '-') {
    strncpy(buf, &tstr[1], sizeof(buf) - 1);
    neg = 1;
  }
  else 
    strncpy(buf, tstr, sizeof(buf) - 1);
  buf[sizeof(buf) - 1] = '\0';
  sp = buf;

  day = strtoul(sp, &dp, 10);
  if (dp == NULL)
    return TIME__RANGE;

  if (*dp == ':') {
    hour = day;
    day = 0;
    useday = 0;
    if (hour > 23)
      return TIME__RANGE;
  } else if (*dp != ' ')
    return TIME__RANGE;
  sp = dp + 1;

  if (useday) {
    if (day > 24855)
      return TIME__RANGE;
    hour = strtoul(sp, &dp, 10);
    if (dp == NULL || *dp != ':' || hour > 23)
      return TIME__RANGE;
    sp = dp + 1;
  }

  min = strtoul(sp, &dp, 10);
  if (dp == NULL || *dp != ':' || min > 59)
    return TIME__RANGE;
  sp = dp + 1;

  sec = strtoul(sp, &dp, 10);
  if ((dp && *dp && *dp != ' ' && *dp != '.') || sec > 59)
    return TIME__RANGE;

  if (dp && *dp == '.') {
    hun = strtoul(dp + 1, &dp, 10);
    if ((dp && *dp && *dp != ' ') || hun > (10000000 - 1))
      return TIME__RANGE;
  }

  ts->tv_sec = day * 24 * 3600 + hour * 3600 + min * 60 + sec;
  ts->tv_nsec = hun * 10000000;
  if (neg) {
    ts->tv_sec = -ts->tv_sec;
    ts->tv_nsec = -ts->tv_nsec;
  }

  return TIME__SUCCESS;
}

//! Convert ascii time to timespec.

pwr_tStatus time_AsciiToA(const char* tstr, pwr_tTime* ts)
{
  struct tm tmpTm;
  int tmphs = 0;
  char* dotp;
  char buf[64];
  pwr_tStatus sts;

  if ( streq( tstr, "NotATime")) {
    *ts = pwr_cNotATime;
    return TIME__SUCCESS;
  }
  strncpy(buf, tstr, sizeof(buf) - 1);
  buf[sizeof(buf) - 1] = '\0';

  if ((dotp = strchr(buf, '.'))) {
    int len;
    char* cp;

    *dotp = '\0';
    dotp++;
    len = strlen(dotp);
    if (len > 2) /* only hundreds of seconds */
      *(dotp + 2) = 0;

    if (*dotp == '0')
      dotp++; /* remove first zero */
    tmphs = strtoul(dotp, &cp, 0);
    if (*cp)
      return TIME__RANGE;
    if (len == 1)
      tmphs *= 10;
  }

  sts = time_AsciiToTm(buf, &tmpTm);
  if (EVEN(sts))
    return sts;

  ts->tv_sec = mktime(&tmpTm);
  if (ts->tv_sec == -1)
    return TIME__RANGE;
  ts->tv_nsec = tmphs * 10000000;
  return TIME__SUCCESS;
}

//! Convert time struct to string.

pwr_tStatus time_TmToAscii(
    struct tm* tmptr, time_eFormat format, char* buf, int bufsize)
{
  pwr_tStatus sts;

  *buf = '\0';
  if (EVEN(sts = validateTm(tmptr)))
    return sts;

  if (format == time_eFormat_DateAndTime) {
    strftime(buf, bufsize, "%d-xxx-%Y %H:%M:%S", tmptr);
    strncpy(&buf[3], monStr[tmptr->tm_mon], 3);
  } else if (format == time_eFormat_DateAndTimeLoc) {
    strftime(buf, bufsize, "%d-%b-%Y %H:%M:%S", tmptr);
  } else if (format == time_eFormat_FileDateAndTime) {
    strftime(buf, bufsize, "%Y%m%d_%H%M%S", tmptr);
  } else if (format == time_eFormat_FileDate) {
    strftime(buf, bufsize, "%Y%m%d", tmptr);
  } else if (format == time_eFormat_ComprDateAndTime) {
    strftime(buf, bufsize, "%y-%m-%d %H:%M:%S", tmptr);
  } else if (format == time_eFormat_NumDateAndTime) {
    strftime(buf, bufsize, "%Y-%m-%d %H:%M:%S", tmptr);
  } else if (format == time_eFormat_TimeAndDate) {
    strftime(buf, bufsize, "%H:%M:%S %d/%m/%y", tmptr);
  } else {
    strftime(buf, bufsize, "%H:%M:%S", tmptr);
  }

  return TIME__SUCCESS;
}

//! Convert timestring to struct.

pwr_tStatus time_AsciiToTm(const char* tstr, struct tm* tmptr)
{
  char tmpMonStr[4];
  char* cp;
  struct tm tt;
  int i;
  pwr_tStatus sts;
  int monstr = 0;

  if (tstr[5] == '-') {
    sscanf(tstr, "%02d-%02d-%4d %02d:%02d:%02d", &tt.tm_mday, &tt.tm_mon,
	   &tt.tm_year, &tt.tm_hour, &tt.tm_min, &tt.tm_sec);
    tt.tm_mon--;
  }
  else if (tstr[4] == '-') {
    sscanf(tstr, "%4d-%02d-%02d %02d:%02d:%02d", &tt.tm_year, &tt.tm_mon,
	   &tt.tm_mday, &tt.tm_hour, &tt.tm_min, &tt.tm_sec);
    tt.tm_mon--;
  }
  else {
    sscanf(tstr, "%02d-%3c-%4d %02d:%02d:%02d", &tt.tm_mday, tmpMonStr,
	   &tt.tm_year, &tt.tm_hour, &tt.tm_min, &tt.tm_sec);
    monstr = 1;
  }

  tmpMonStr[3] = '\0';
  tt.tm_year -= 1900;

  /* We don't handle this in current version */

  tt.tm_wday = -1;
  tt.tm_yday = -1;
  tt.tm_isdst = -1;

  /* check month */
  if (monstr) {
    for (cp = tmpMonStr; *cp; cp++)
      *cp = toupper(*cp);

    tt.tm_mon = -1;
    for (i = 0; i < 12; i++) {
      if (streq(tmpMonStr, monStr[i])) {
	tt.tm_mon = i;
	break;
      }
    }
  }

  if (EVEN(sts = validateTm(&tt)))
    return sts;

  *tmptr = tt;

  return TIME__SUCCESS;
}

/* Compatibility-function that substitutes co_TimeToAsc.  */

pwr_tStatus time_FormAsciiToA(
    const char* tstr, short dissolution, short formType, pwr_tTime* ts)
{
  struct tm tmpTm;
  int i;
  int year;
  int month;
  int day;
  int tmphs = 0;
  char* dotp;
  char buf[64];
  pwr_tStatus sts;
  char* cp = (char*)tstr;

  /* Format of the date string should be YYYY-MM-DD HH:MM[:SS.CC] */
  while (*cp && isspace(*cp))
    cp++;

  /* Get year */
  for (i = 0; i < 4; i++, cp++) {
    if (*cp == '\0' || !isdigit(*cp))
      return TIME__RANGE;
    buf[i] = *cp;
  }
  buf[i] = '\0';
  year = atoi(buf);
  if (*cp == '\0' || *cp != '-')
    return TIME__RANGE;
  cp++;

  /* Get month */
  for (i = 0; i < 2; i++, cp++) {
    if (*cp == '\0' || !isdigit(*cp))
      return TIME__RANGE;
    buf[i] = *cp;
  }
  buf[i] = '\0';
  month = atoi(buf) - 1;
  if (month < 0 || month > 11)
    return TIME__RANGE;
  if (*cp == '\0' || *cp != '-')
    return TIME__RANGE;
  cp++;

  /* Get Day */
  for (i = 0; i < 2; i++, cp++) {
    if (*cp == '\0' || !isdigit(*cp))
      return TIME__RANGE;
    buf[i] = *cp;
  }
  buf[i] = '\0';
  day = atoi(buf);

  /* Build a new date string on VMS format, dd-mmm-yyyy ...*/
  sprintf(buf, "%02d-%s-%d%s", day, monStr[month], year, cp);

  if (dissolution == MINUTE) {
    strcat(buf, ":00");
  } else if (dissolution == HUNDRED) {
    if ((dotp = strchr(buf, '.'))) {
      int len;
      char* cp;

      *dotp = '\0';
      dotp++;
      len = strlen(dotp);
      if (len > 2) /* only hundreds of seconds */
        *(dotp + 2) = 0;

      if (*dotp == '0')
        dotp++;
      tmphs = strtoul(dotp, &cp, 0);
      if (*cp)
        return TIME__RANGE;
      if (len == 1)
        tmphs *= 10;
    }
  }

  sts = time_AsciiToTm(buf, &tmpTm);
  if (EVEN(sts))
    return sts;

  ts->tv_sec = mktime(&tmpTm);
  ts->tv_nsec = tmphs * 10000000;
  return TIME__SUCCESS;
}

/* .  */

void time_AtoFormAscii(
    pwr_tTime* ts, short dissolution, short formType, char buf[], int bufsize)
{
  int len;
  struct tm* tmpTm;
  char tmphs[16];
  pwr_tTime time, *tp;

  if (ts == NULL) {
    time_GetTime(&time);
    tp = &time;
  } else {
    tp = ts;
  }

  switch (formType) {
  case GB:
  case SWE:
  default: {
    time_t sec = tp->tv_sec;
    tmpTm = localtime(&sec);

    switch (dissolution) {
    case HUNDRED:
      len = strftime(buf, bufsize, "%Y-%m-%d %H:%M:%S", tmpTm);
      if (len != 0 && len + 4 <= bufsize) {
        sprintf(tmphs, ".%02d", (int)(tp->tv_nsec / 10000000));
        strcat(buf, tmphs);
      }
      break;

    case MINUTE:
      strftime(buf, bufsize, "%Y-%m-%d %H:%M", tmpTm);
      break;

    case SECOND:
    default:
      strftime(buf, bufsize, "%Y-%m-%d %H:%M:%S", tmpTm);
      break;
    }
  }
  }
}

//! Convert millisec to timespec.
/*!
   Not thread safe if dt is NULL.  */

pwr_tDeltaTime* time_MsToD(pwr_tDeltaTime* dt, pwr_tInt32 ms)
{
  static pwr_tDeltaTime time;
  pwr_tDeltaTime* t = &time;

  if (dt != NULL)
    t = dt;

  t->tv_sec = ms / 1000;
  t->tv_nsec = (ms % 1000) * 1000000;

  return t;
}

//! Convert float to time.
/*!
   Not thread safe if dt is NULL.  */

pwr_tDeltaTime* time_FloatToD(pwr_tDeltaTime* dt, pwr_tFloat32 f)
{
  static pwr_tDeltaTime time;
  pwr_tDeltaTime* t = &time;

  if (dt != NULL)
    t = dt;

  if (isnan(f)) {
    *t = pwr_cNotADeltaTime;
    return t;
  }

  t->tv_sec = f;
  t->tv_nsec = (f - t->tv_sec) * 1e9;

  return t;
}

//! Convert double to time.
/*!
   Not thread safe if dt is NULL.  */

pwr_tDeltaTime* time_Float64ToD(pwr_tDeltaTime* dt, pwr_tFloat64 f)
{
  static pwr_tDeltaTime time;
  pwr_tDeltaTime* t = &time;

  if (dt != NULL)
    t = dt;

  if (isnan(f)) {
    *t = pwr_cNotADeltaTime;
    return t;
  }

  t->tv_sec = f;
  t->tv_nsec = (f - t->tv_sec) * 1e9;

  return t;
}

//! Convert time to Float32.
/*!
   Not thread safe if f is NULL.
*/

pwr_tFloat32 time_DToFloat(pwr_tFloat32* f, pwr_tDeltaTime* dt)
{
  static pwr_tFloat32 flt;
  pwr_tFloat32* fp = &flt;

  if (f != NULL)
    fp = f;

  if (notADeltaTime(dt)) {
    *fp = NAN;
    return *fp;
  }

  *fp = 1e-9 * dt->tv_nsec + dt->tv_sec;

  return *fp;
}

//! Convert time to Float64.

pwr_tFloat64 time_DToFloat64(pwr_tFloat64* f, pwr_tDeltaTime* dt)
{
  static pwr_tFloat64 flt;
  pwr_tFloat64* fp = &flt;

  if (f != NULL)
    fp = f;

  if (notADeltaTime(dt)) {
    *fp = NAN;
    return *fp;
  }

  *fp = 1e-9 * dt->tv_nsec + dt->tv_sec;

  return *fp;
}

//! Convert delta time to clock time.
time_tClock time_DtoClock(pwr_tStatus* status, pwr_tDeltaTime* tp)
{
  pwr_dStatus(sts, status, TIME__SUCCESS);

  return tp->tv_sec * 100 + tp->tv_nsec / 10000000;
}

//! Convert clock time to delta time.
pwr_tDeltaTime* time_ClockToD(
    pwr_tStatus* status, pwr_tDeltaTime* tp, time_tClock clock)
{
  pwr_tDeltaTime time;
  pwr_dStatus(sts, status, TIME__SUCCESS);

  if (tp == NULL)
    tp = &time;

  tp->tv_sec = clock / 100;
  tp->tv_nsec = clock % 100 * 10000000;

  return tp;
}

//! Zero a delta time.
pwr_tDeltaTime* time_ZeroD(pwr_tDeltaTime* tp)
{
  static pwr_tDeltaTime time;

  if (tp == NULL)
    tp = &time;

  memset(tp, 0, sizeof(*tp));

  return tp;
}

void time_Sleep(float time)
{
  pwr_tDeltaTime p_time;
  struct timespec ts;

  time_FloatToD(&p_time, time);
  ts.tv_sec = p_time.tv_sec;
  ts.tv_nsec = p_time.tv_nsec;
  nanosleep(&ts, NULL);
}

//! Get current time.
int time_GetTime(pwr_tTime* ts)
{
  struct timespec t;
  int sts;

  sts = clock_gettime(CLOCK_REALTIME, &t);

  ts->tv_sec = t.tv_sec;
  ts->tv_nsec = t.tv_nsec;
  return sts;
}

//! Get current monotonic time.
int time_GetTimeMonotonic(pwr_tTime* ts)
{
  struct timespec t;
  int sts;

  sts = clock_gettime(CLOCK_MONOTONIC, &t);

  ts->tv_sec = t.tv_sec;
  ts->tv_nsec = t.tv_nsec;
  return sts;
}

//! Calculate start and end time for month.
int time_PeriodMonth(
    pwr_tTime* time, pwr_tTime* from, pwr_tTime* to, int previous)
{
  struct tm* tm;
  int days, month, year;
  time_t t;
  time_t sec = time->tv_sec;

  tm = localtime(&sec);

  sec = time->tv_sec - (tm->tm_mday - 1) * ONEDAY;

  tm = localtime(&sec);

  tm->tm_sec = 0;
  tm->tm_min = 0;
  tm->tm_hour = 0;
  tm->tm_mday = 1;

  t = mktime(tm);

  year = tm->tm_year + 1900;
  if (previous) {
    if (tm->tm_mon == 0) {
      month = 11;
      year--;
    } else
      month = tm->tm_mon - 1;
  } else
    month = tm->tm_mon;

  switch (month) {
  case 1:
    if ((year % 4 == 0 && year % 100 != 0) || (year + 1900) % 400 == 0)
      days = 29;
    else
      days = 28;
    break;
  case 3:
  case 5:
  case 8:
  case 10:
    days = 30;
    break;
  default:
    days = 31;
  }

  if (previous) {
    if (to) {
      to->tv_sec = t;
      to->tv_nsec = 0;
    }
  } else {
    if (from) {
      from->tv_sec = t;
      from->tv_nsec = 0;
    }
  }

  if (previous)
    sec = t - (days - 1) * ONEDAY;
  else
    sec = t + (days + 1) * ONEDAY;

  tm = localtime(&sec);

  tm->tm_sec = 0;
  tm->tm_min = 0;
  tm->tm_hour = 0;
  tm->tm_mday = 1;

  t = mktime(tm);

  if (previous) {
    if (from) {
      from->tv_sec = t;
      from->tv_nsec = 0;
    }
  } else {
    if (to) {
      to->tv_sec = t;
      to->tv_nsec = 0;
    }
  }

  return 1;
}

//! Calculate start and end time for year.
static int time_PeriodYear(
    pwr_tTime* time, pwr_tTime* from, pwr_tTime* to, int previous)
{
  struct tm* tm;
  int days, year;
  time_t t;
  time_t sec = time->tv_sec;

  tm = localtime(&sec);

  sec = time->tv_sec - (tm->tm_yday - 1) * ONEDAY;

  tm = localtime(&sec);

  tm->tm_sec = 0;
  tm->tm_min = 0;
  tm->tm_hour = 0;
  tm->tm_mon = 0;
  tm->tm_mday = 1;

  t = mktime(tm);

  year = tm->tm_year + 1900;
  if (previous)
    year--;

  if ((year % 4 == 0 && year % 100 != 0) || (year + 1900) % 400 == 0)
    days = 365;
  else
    days = 366;

  if (previous) {
    if (to) {
      to->tv_sec = t;
      to->tv_nsec = 0;
    }
  } else {
    if (from) {
      from->tv_sec = t;
      from->tv_nsec = 0;
    }
  }

  if (previous)
    sec = t - (days - 1) * ONEDAY;
  else
    sec = t + (days + 1) * ONEDAY;

  tm = localtime(&sec);

  tm->tm_sec = 0;
  tm->tm_min = 0;
  tm->tm_hour = 0;
  tm->tm_mon = 0;
  tm->tm_mday = 1;

  t = mktime(tm);

  if (previous) {
    if (from) {
      from->tv_sec = t;
      from->tv_nsec = 0;
    }
  } else {
    if (to) {
      to->tv_sec = t;
      to->tv_nsec = 0;
    }
  }

  return 1;
}

//! Calculate start and end time for previous week.
/*! Computes dates for monday to sunday in the
    previous week from the time now.
    Output times are only date, e g 1-MAY-1992 00:00:00.00.
*/

int time_PeriodPreviousWeek(pwr_tTime* time, pwr_tTime* from, pwr_tTime* to)
{
  struct tm* tm;
  int days;
  pwr_tTime t;

  time_t sec = time->tv_sec;
  tm = localtime(&sec);
  if (tm->tm_wday == 0) /* Sunday */
    days = 13;
  else
    days = tm->tm_wday + 6;

  tm->tm_sec = 0;
  tm->tm_min = 0;
  tm->tm_hour = 0;
  t.tv_sec = mktime(tm);

  if (from) {
    from->tv_sec = t.tv_sec - days * ONEDAY;
    from->tv_nsec = 0;
  }
  if (to) {
    to->tv_sec = t.tv_sec + (7 - days) * ONEDAY;
    to->tv_nsec = 0;
  }

  return 1;
}

//! Calculate previous daybreak.
void time_PreviousDayBreak(pwr_tTime* time, pwr_tTime* daybreak)
{
  struct tm* tm;

  time_t sec = time->tv_sec;
  tm = localtime(&sec);

  tm->tm_sec = 0;
  tm->tm_min = 0;
  tm->tm_hour = 0;

  daybreak->tv_sec = mktime(tm);
  daybreak->tv_nsec = 0;
}

static void time_PeriodSec(
    pwr_tTime* from, pwr_tTime* to, pwr_tTime* center, int sec)
{
  pwr_tStatus sts;
  pwr_tTime current;

  sts = time_GetTime(&current);
  to->tv_sec = center->tv_sec + sec / 2;
  to->tv_nsec = center->tv_nsec;
  if (time_Acomp(to, &current) == 1)
    *to = current;
  from->tv_sec = to->tv_sec - sec;
  from->tv_nsec = to->tv_nsec;
}

void time_Period(time_ePeriod period, pwr_tTime* from, pwr_tTime* to,
    pwr_tTime* center, int daybreak)
{
  int sts;
  pwr_tTime current;

  switch (period) {
  case time_ePeriod_OneSecond:
    if (!center) {
      time_Period(time_ePeriod_LastSecond, from, to, center, daybreak);
      return;
    }
    time_PeriodSec(from, to, center, 1);
    break;
  case time_ePeriod_10Seconds:
    if (!center) {
      time_Period(time_ePeriod_10Seconds, from, to, center, daybreak);
      return;
    }
    time_PeriodSec(from, to, center, 10);
    break;
  case time_ePeriod_OneMinute:
    if (!center) {
      time_Period(time_ePeriod_LastMinute, from, to, center, daybreak);
      return;
    }
    time_PeriodSec(from, to, center, 60);
    break;
  case time_ePeriod_10Minutes:
    if (!center) {
      time_Period(time_ePeriod_Last10Minutes, from, to, center, daybreak);
      return;
    }
    time_PeriodSec(from, to, center, 600);
    break;
  case time_ePeriod_OneHour:
    if (!center) {
      time_Period(time_ePeriod_LastHour, from, to, center, daybreak);
      return;
    }
    time_PeriodSec(from, to, center, 3600);
    break;
  case time_ePeriod_OneDay:
    if (!center) {
      sts = time_GetTime(to);
      *from = *to;
      from->tv_sec -= ONEDAY;
      return;
    }
    time_PeriodSec(from, to, center, ONEDAY);
    break;
  case time_ePeriod_OneWeek:
    if (!center) {
      time_Period(time_ePeriod_LastWeek, from, to, center, daybreak);
      return;
    }
    time_PeriodSec(from, to, center, 7 * ONEDAY);
    break;
  case time_ePeriod_OneMonth:
    if (!center) {
      time_Period(time_ePeriod_LastMonth, from, to, center, daybreak);
      return;
    }
    time_PeriodMonth(center, from, to, 0);
    int middle = from->tv_sec + (to->tv_sec - from->tv_sec) / 2;
    int half = middle - from->tv_sec;
    if (center->tv_sec >= middle - ONEDAY / 2
        && center->tv_sec <= middle + ONEDAY / 2)
      return;

    if (center->tv_sec < middle) {
      // Take period from previous month
      time_PeriodMonth(center, from, to, 1);
      middle = from->tv_sec + (to->tv_sec - from->tv_sec) / 2;
      half = middle - from->tv_sec;
    }
    to->tv_sec = center->tv_sec + half;
    from->tv_sec = center->tv_sec - half;

    sts = time_GetTime(&current);
    if (time_Acomp(to, &current) == 1) {
      from->tv_sec = current.tv_sec - (to->tv_sec - from->tv_sec);
      from->tv_nsec = current.tv_sec;
      *to = current;
    }
    break;
  case time_ePeriod_LastSecond:
    sts = time_GetTime(to);
    from->tv_sec = to->tv_sec - 1;
    from->tv_nsec = to->tv_nsec;
    break;
  case time_ePeriod_Last10Seconds:
    sts = time_GetTime(to);
    from->tv_sec = to->tv_sec - 10;
    from->tv_nsec = to->tv_nsec;
    break;
  case time_ePeriod_LastMinute:
    sts = time_GetTime(to);
    from->tv_sec = to->tv_sec - 60;
    from->tv_nsec = to->tv_nsec;
    break;
  case time_ePeriod_Last10Minutes:
    sts = time_GetTime(to);
    from->tv_sec = to->tv_sec - 600;
    from->tv_nsec = to->tv_nsec;
    break;
  case time_ePeriod_LastHour:
    sts = time_GetTime(to);
    from->tv_sec = to->tv_sec - 3600;
    from->tv_nsec = to->tv_nsec;
    break;
  case time_ePeriod_Today:
    sts = time_GetTime(from);
    *to = *from;

    time_PreviousDayBreak(from, from);

    if (daybreak) {
      to->tv_sec += ONEDAY;
      time_PreviousDayBreak(to, to);
    }
    break;
  case time_ePeriod_Yesterday:
    sts = time_GetTime(to);
    time_PreviousDayBreak(to, to);

    from->tv_sec = to->tv_sec - ONEDAY;
    from->tv_nsec = 0;
    break;
  case time_ePeriod_ThisWeek:
    sts = time_GetTime(&current);

    sts = time_PeriodPreviousWeek(&current, 0, from);

    *to = current;
    if (daybreak) {
      to->tv_sec += ONEDAY;
      time_PreviousDayBreak(to, to);
    }
    break;
  case time_ePeriod_LastWeek:
    sts = time_GetTime(&current);

    sts = time_PeriodPreviousWeek(&current, from, to);
    break;
  case time_ePeriod_ThisMonth:
    sts = time_GetTime(&current);

    sts = time_PeriodMonth(&current, 0, from, 1);

    *to = current;
    if (daybreak) {
      to->tv_sec += ONEDAY;
      time_PreviousDayBreak(to, to);
    }
    break;
  case time_ePeriod_LastMonth:
    sts = time_GetTime(&current);

    sts = time_PeriodMonth(&current, from, to, 1);
    break;
  case time_ePeriod_OneYear:
  case time_ePeriod_ThisYear:
    sts = time_GetTime(&current);

    sts = time_PeriodYear(&current, 0, from, 1);

    *to = current;
    if (daybreak) {
      to->tv_sec += ONEDAY;
      time_PreviousDayBreak(to, to);
    }
    break;
  default: {
    // time_ePeriod_All:
    struct tm* tm;

    sts = time_GetTime(to);
    if (daybreak) {
      to->tv_sec += ONEDAY;
      time_PreviousDayBreak(to, to);
    }

    time_t sec = to->tv_sec;
    tm = localtime(&sec);
    tm->tm_sec = 0;
    tm->tm_min = 0;
    tm->tm_hour = 0;
    tm->tm_mday = 1;
    tm->tm_mon = 0;
    tm->tm_year = 70;
    from->tv_sec = mktime(tm);
    from->tv_nsec = 0;

    break;
  }
  }
}

void time_PreviousPeriod(time_ePeriod period, pwr_tTime* prev_from,
    pwr_tTime* prev_to, pwr_tTime* from, pwr_tTime* to)
{
  switch (period) {
  case time_ePeriod_OneSecond:
  case time_ePeriod_LastSecond:
    *to = *from = *prev_from;
    from->tv_sec -= 1;
    if (from->tv_sec < 0) {
      from->tv_sec = 0;
      to->tv_sec = 1;
    }
    break;
  case time_ePeriod_10Seconds:
  case time_ePeriod_Last10Seconds:
    *to = *from = *prev_from;
    from->tv_sec -= 10;
    if (from->tv_sec < 0) {
      from->tv_sec = 0;
      to->tv_sec = 10;
    }
    break;
  case time_ePeriod_OneMinute:
  case time_ePeriod_LastMinute:
    *to = *from = *prev_from;
    from->tv_sec -= 60;
    if (from->tv_sec < 0) {
      from->tv_sec = 0;
      to->tv_sec = 60;
    }
    break;
  case time_ePeriod_10Minutes:
  case time_ePeriod_Last10Minutes:
    *to = *from = *prev_from;
    from->tv_sec -= 600;
    if (from->tv_sec < 0) {
      from->tv_sec = 0;
      to->tv_sec = 600;
    }
    break;
  case time_ePeriod_OneHour:
  case time_ePeriod_LastHour:
    *to = *from = *prev_from;
    from->tv_sec -= 3600;
    if (from->tv_sec < 0) {
      from->tv_sec = 0;
      to->tv_sec = 3660;
    }
    break;
  case time_ePeriod_OneDay:
  case time_ePeriod_Today:
  case time_ePeriod_Yesterday:
    *to = *from = *prev_from;
    from->tv_sec -= ONEDAY;
    if (from->tv_sec < 0) {
      from->tv_sec = 0;
      to->tv_sec = ONEDAY;
    }
    break;
  case time_ePeriod_OneWeek:
  case time_ePeriod_ThisWeek:
  case time_ePeriod_LastWeek:
    *to = *from = *prev_from;
    from->tv_sec -= ONEDAY * 7;
    if (from->tv_sec < 0) {
      from->tv_sec = 0;
      to->tv_sec = ONEDAY * 7;
    }
    break;
  case time_ePeriod_OneMonth:
  case time_ePeriod_ThisMonth:
  case time_ePeriod_LastMonth:
    time_PeriodMonth(prev_from, from, to, 1);
    from->tv_sec += prev_from->tv_sec - to->tv_sec;
    from->tv_nsec = prev_from->tv_nsec;
    *to = *prev_from;
    if (from->tv_sec < 0) {
      from->tv_sec = 0;
      to->tv_sec = ONEDAY * 30;
    }
    break;
  case time_ePeriod_OneYear:
  case time_ePeriod_ThisYear:
    time_PeriodYear(prev_from, from, to, 1);
    from->tv_sec += prev_from->tv_sec - to->tv_sec;
    from->tv_nsec = prev_from->tv_nsec;
    *to = *prev_from;
    if (from->tv_sec < 0) {
      from->tv_sec = 0;
      to->tv_sec = ONEDAY * 365;
    }
    break;
  case time_ePeriod_AllTime:
    time_Period(period, from, to, 0, 1);
    break;
  case time_ePeriod_UserDefined:
    // Same lenth of intervall as before
    *to = *from = *prev_from;
    from->tv_sec -= prev_to->tv_sec - prev_from->tv_sec;
    if (from->tv_sec < 0) {
      from->tv_sec = 0;
      to->tv_sec = prev_to->tv_sec - prev_from->tv_sec;
    }
    break;
  default:;
  }
}

void time_NextPeriod(time_ePeriod period, pwr_tTime* prev_from,
    pwr_tTime* prev_to, pwr_tTime* from, pwr_tTime* to)
{
  int sts;
  pwr_tTime current;

  sts = time_GetTime(&current);

  switch (period) {
  case time_ePeriod_OneSecond:
  case time_ePeriod_LastSecond:
    *to = *from = *prev_to;
    to->tv_sec += 1;
    if (time_Acomp(&current, to) != 1) {
      *to = current;
      from->tv_sec = current.tv_sec - 1;
      from->tv_nsec = current.tv_nsec;
    }
    break;
  case time_ePeriod_10Seconds:
  case time_ePeriod_Last10Seconds:
    *to = *from = *prev_to;
    to->tv_sec += 10;
    if (time_Acomp(&current, to) != 1) {
      *to = current;
      from->tv_sec = current.tv_sec - 10;
      from->tv_nsec = current.tv_nsec;
    }
    break;
  case time_ePeriod_OneMinute:
  case time_ePeriod_LastMinute:
    *to = *from = *prev_to;
    to->tv_sec += 60;
    if (time_Acomp(&current, to) != 1) {
      *to = current;
      from->tv_sec = current.tv_sec - 60;
      from->tv_nsec = current.tv_nsec;
    }
    break;
  case time_ePeriod_10Minutes:
  case time_ePeriod_Last10Minutes:
    *to = *from = *prev_to;
    to->tv_sec += 600;
    if (time_Acomp(&current, to) != 1) {
      *to = current;
      from->tv_sec = current.tv_sec - 600;
      from->tv_nsec = current.tv_nsec;
    }
    break;
  case time_ePeriod_OneHour:
  case time_ePeriod_LastHour:
    *to = *from = *prev_to;
    to->tv_sec += 3600;
    if (time_Acomp(&current, to) != 1) {
      *to = current;
      from->tv_sec = current.tv_sec - 3600;
      from->tv_nsec = current.tv_nsec;
    }
    break;
  case time_ePeriod_OneDay:
  case time_ePeriod_Today:
  case time_ePeriod_Yesterday:
    *to = *from = *prev_to;
    to->tv_sec += ONEDAY;
    if (time_Acomp(&current, to) != 1) {
      *to = current;
      from->tv_sec = current.tv_sec - ONEDAY;
      from->tv_nsec = current.tv_nsec;
    }
    break;
  case time_ePeriod_OneWeek:
  case time_ePeriod_ThisWeek:
  case time_ePeriod_LastWeek:
    *to = *from = *prev_to;
    to->tv_sec += 7 * ONEDAY;
    if (time_Acomp(&current, to) != 1) {
      *to = current;
      from->tv_sec = current.tv_sec - 7 * ONEDAY;
      from->tv_nsec = current.tv_nsec;
    }
    break;
  case time_ePeriod_OneMonth:
  case time_ePeriod_ThisMonth:
  case time_ePeriod_LastMonth:
    time_PeriodMonth(prev_to, from, to, 0);
    to->tv_sec += prev_to->tv_sec - from->tv_sec;
    *from = *prev_to;
    if (time_Acomp(&current, to) != 1) {
      *to = current;
      from->tv_sec = current.tv_sec - 30 * ONEDAY;
      from->tv_nsec = current.tv_nsec;
    }
    break;
  case time_ePeriod_OneYear:
  case time_ePeriod_ThisYear:
    time_PeriodYear(prev_to, from, to, 0);
    to->tv_sec += prev_to->tv_sec - from->tv_sec;
    *from = *prev_to;
    if (time_Acomp(&current, to) != 1) {
      *to = current;
      from->tv_sec = current.tv_sec - 365 * ONEDAY;
      from->tv_nsec = current.tv_nsec;
    }
    break;
  case time_ePeriod_AllTime:
    time_Period(period, from, to, 0, 1);
    break;
  case time_ePeriod_UserDefined:
    // Same lenth of intervall as before
    *to = *from = *prev_to;
    to->tv_sec += prev_to->tv_sec - prev_from->tv_sec;
    if (time_Acomp(&current, to) != 1) {
      *to = current;
      from->tv_sec = current.tv_sec - (prev_to->tv_sec - prev_from->tv_sec);
      from->tv_nsec = current.tv_nsec;
    }
    break;
  default:;
  }
}

int time_PeriodZoomIn(time_ePeriod* period)
{
  int changed = 1;
  switch (*period) {
  case time_ePeriod_Last10Seconds:
  case time_ePeriod_10Seconds:
    *period = time_ePeriod_OneSecond;
    break;
  case time_ePeriod_LastMinute:
  case time_ePeriod_OneMinute:
    *period = time_ePeriod_10Seconds;
    break;
  case time_ePeriod_Last10Minutes:
  case time_ePeriod_10Minutes:
    *period = time_ePeriod_OneMinute;
    break;
  case time_ePeriod_OneHour:
  case time_ePeriod_LastHour:
    *period = time_ePeriod_10Minutes;
    break;
  case time_ePeriod_Today:
  case time_ePeriod_Yesterday:
  case time_ePeriod_OneDay:
    *period = time_ePeriod_OneHour;
    break;
  case time_ePeriod_ThisWeek:
  case time_ePeriod_LastWeek:
  case time_ePeriod_OneWeek:
    *period = time_ePeriod_OneDay;
    break;
  case time_ePeriod_ThisMonth:
  case time_ePeriod_LastMonth:
  case time_ePeriod_OneMonth:
    *period = time_ePeriod_OneWeek;
    break;
  case time_ePeriod_ThisYear:
  case time_ePeriod_OneYear:
    *period = time_ePeriod_OneMonth;
    break;
  case time_ePeriod_AllTime:
    *period = time_ePeriod_OneYear;
    break;
  default:
    changed = 0;
  }
  return changed;
}

int time_PeriodZoomOut(time_ePeriod* period)
{
  int changed = 1;

  switch (*period) {
  case time_ePeriod_OneSecond:
  case time_ePeriod_LastSecond:
    *period = time_ePeriod_10Seconds;
    break;
  case time_ePeriod_Last10Seconds:
  case time_ePeriod_10Seconds:
    *period = time_ePeriod_OneMinute;
    break;
  case time_ePeriod_OneMinute:
  case time_ePeriod_LastMinute:
    *period = time_ePeriod_10Minutes;
    break;
  case time_ePeriod_Last10Minutes:
  case time_ePeriod_10Minutes:
    *period = time_ePeriod_OneHour;
    break;
  case time_ePeriod_OneHour:
  case time_ePeriod_LastHour:
    *period = time_ePeriod_OneDay;
    break;
  case time_ePeriod_Today:
  case time_ePeriod_Yesterday:
  case time_ePeriod_OneDay:
    *period = time_ePeriod_OneWeek;
    break;
  case time_ePeriod_ThisWeek:
  case time_ePeriod_LastWeek:
  case time_ePeriod_OneWeek:
    *period = time_ePeriod_OneMonth;
    break;
  case time_ePeriod_ThisMonth:
  case time_ePeriod_LastMonth:
  case time_ePeriod_OneMonth:
    *period = time_ePeriod_OneYear;
    break;
  case time_ePeriod_ThisYear:
  case time_ePeriod_OneYear:
    *period = time_ePeriod_AllTime;
    break;
  default:
    changed = 0;
  }
  return changed;
}

//! Print an absolute time. The format should contain %s.

int time_PrintA(const char* format, pwr_tTime* ts)
{
  char timstr[40];

  time_AtoAscii(ts, time_eFormat_DateAndTime, timstr, sizeof(timstr));
  return printf(format, timstr);
}
