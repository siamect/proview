/**
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 **/

/* co_dcli_file.c -- File handling in dcli */

#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>

#include "co_cdh.h"
#include "co_dcli.h"
#include "co_dcli_msg.h"
#include "co_log.h"
#include "co_string.h"

typedef enum {
  dcli_eTrans_EnvVar,
  dcli_eTrans_Dir,
  dcli_eTrans_File
} dcli_eTrans;

static char dcli_default_directory[200] = "";

void dcli_set_default_directory(char* dir)
{
  strcpy(dcli_default_directory, dir);
}

int dcli_get_defaultfilename(const char* inname, char* outname, const char* ext)
{
  pwr_tFileName filename;
  const char *s, *s2;

  if (strchr(inname, '/'))
    str_Strcpy(outname, inname);
  else if ((s = strchr(inname, ':'))) {
    /* Replace VMS disp to env variable */
    strcpy(filename, "$");
    strncat(filename, inname, s - inname);
    filename[s - inname + 1] = 0;
    strcat(filename, "/");
    strcat(filename, s + 1);
    dcli_replace_env(filename, outname);
  } else {
    if (streq(dcli_default_directory, "")) {
      char cwd[200];

      if (getcwd(cwd, sizeof(cwd)) != NULL) {
        strcpy(filename, cwd);
        strcat(filename, "/");
      } else
        strcpy(filename, "");
      strcat(filename, inname);
      dcli_replace_env(filename, outname);
    } else {
      strcpy(filename, dcli_default_directory);
      if ((filename[strlen(filename) - 1] != '/') && (inname[0] != '/'))
        strcat(filename, "/");
      strcat(filename, inname);
      dcli_replace_env(filename, outname);
    }
  }

  /* Look for extention in filename */
  if (ext != NULL) {
    s = strrchr(inname, ':');
    if (s == 0)
      s = (char*)inname;

    s2 = strrchr(s, '>');
    if (s2 == 0) {
      s2 = strrchr(s, ']');
      if (s2 == 0)
        s2 = s;
    }

    s = strrchr(s2, '.');
    if (s == 0 || s == s2) {
      /* No extention found, add extention */
      strcat(outname, ext);
    }
  }

  return DCLI__SUCCESS;
}

/*************************************************************************
*
* Name:		dcli_replace_env()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Replace env variables in UNIX filenames.
*	A string that starts with $ and ends with . or / will replaced
*	if then string is found by getenv. Only lower case variables
*	will be detected.
*
**************************************************************************/
int dcli_replace_env(const char* str, char* newstr)
{
  char* s;
  char* t;
  char* u = NULL;
  int symbolmode;
  long int size;
  char* value;
  char symbol[80];
  char lower_symbol[80];
  pwr_tCmd news;

  symbolmode = 0;
  s = (char*)str;
  t = news;

  while (*s != 0) {
    if (*s == '$') {
      if (*(s + 1) == '$') {
        /* '$$: insert pid */
        char pid[20];
        sprintf(pid, "%d", getpid());
        strncpy(t, pid, strlen(pid));
        t += strlen(pid);
        s++;
      } else {
        symbolmode = 1;
        u = s + 1;
        *t = *s;
        t++;
      }
    } else if (symbolmode && (*s == '/' || *s == '.')) {
      /* End of potential symbol */
      size = (long int)s - (long int)u;
      strncpy(symbol, u, size);
      symbol[size] = 0;
      if (streq(symbol, "HOME"))
        strcpy(lower_symbol, symbol);
      else
        str_ToLower(lower_symbol, symbol);
      if ((value = getenv(lower_symbol)) == NULL) {
        /* It was no symbol */
        if (str_StartsWith(str, "$pwr")) {
          log_debug("Warning! Could not resolve environment variable $%s\n", lower_symbol);
        }
        *t = *s;
        t++;
      } else {
        /* Symbol found */
        t -= strlen(symbol) + 1;
        strcpy(t, value);
        t += strlen(value);
        *t = *s;
        t++;
      }
      symbolmode = 0;
    } else {
      *t = *s;
      t++;
    }
    s++;
  }

  if (symbolmode) {
    /* End of potential symbol */
    size = (long int)s - (long int)u;
    strncpy(symbol, u, size);
    symbol[size] = 0;
    if (streq(symbol, "HOME"))
      strcpy(lower_symbol, symbol);
    else
      str_ToLower(lower_symbol, symbol);
    if ((value = getenv(lower_symbol)) == NULL) {
      /* It was no symbol */
      if (str_StartsWith(str, "$pwr")) {
        log_debug("Warning! Could not resolve environment variable $%s\n", lower_symbol);
      }
      *t = 0;
    } else {
      /* Symbol found */
      t -= strlen(symbol) + 1;
      strcpy(t, value);
      t += strlen(value);
      *t = 0;
    }
  } else
    *t = 0;

  strcpy(newstr, news);
  return 1;
}

/*************************************************************************
*
* Name:		dcli_fgetname()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Get filename for a filedescriptor.
*	This function is not implementet on all os, therefor a defaultname
*	should be supplied which is returned for this os.
*
**************************************************************************/
char* dcli_fgetname(FILE* fp, char* name, char* def_name)
{
  dcli_translate_filename(name, def_name);
  return name;
}

/*************************************************************************
*
* Name:		dcli_translate_filename()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Translate VMS or unix filename to the current platform.
*
**************************************************************************/

int dcli_translate_filename(char* out, const char* in)
{
  char out_name[200];
  const char* s;
  char* t;
  int i;
  int state = 0;
  int sts;

  if (strchr(in, ':') != 0 || strchr(in, '[') != 0 || strchr(in, '<') != 0) {
    // Convert from VMS to unix
    for (i = 0, s = in, t = out_name; *s; i++, s++) {
      if (i == 0) {
        if (strchr(in, ':') != 0) {
          state = dcli_eTrans_EnvVar;
          *t++ = '$';
          *t++ = *s;
        } else if (*s == '[' || *s == '<') {
          if (*(s + 1) == '.')
            s++;
          else
            *t++ = '/';
          state = dcli_eTrans_Dir;
        } else {
          state = dcli_eTrans_File;
          *t++ = *s;
        }
        continue;
      }
      switch (state) {
      case dcli_eTrans_EnvVar:
        if (*s == ':') {
          *t++ = '/';
          if (*(s + 1) == '[' || *(s + 1) == '<') {
            state = dcli_eTrans_Dir;
            s++;
          } else
            state = dcli_eTrans_File;
        } else
          *t++ = *s;
        break;
      case dcli_eTrans_Dir:
        if (*s == '.') {
          *t++ = '/';
        } else if (*s == ']' || *s == '>') {
          *t++ = '/';
          state = dcli_eTrans_File;
        } else
          *t++ = *s;
        break;
      case dcli_eTrans_File:
        *t++ = *s;
        break;
      }
    }
    *t = 0;
    sts = dcli_replace_env(out_name, out);
    return sts;
  } else {
    // Already unix syntax
    if (in[0] == '~') {
      strcpy(out_name, "$HOME");
      strcat(&out_name[5], &in[1]);
    } else
      strcpy(out_name, in);

    sts = dcli_replace_env(out_name, out);
    return sts;
  }
}

pwr_tStatus dcli_file_time(char* filename, pwr_tTime* time)
{
  struct stat info;

  if (stat(filename, &info) != -1) {
    time->tv_sec = info.st_mtime;
    time->tv_nsec = 0;
    return DCLI__SUCCESS;
  }
  return DCLI__NOFILE;
}

pwr_tStatus dcli_file_ctime(char* filename, pwr_tTime* time)
{
  struct stat info;

  if (stat(filename, &info) != -1) {
    time->tv_sec = info.st_ctime;
    time->tv_nsec = 0;
    return DCLI__SUCCESS;
  }
  return DCLI__NOFILE;
}

void dcli_save_file_versions(char* fname)
{
  pwr_tFileName newname;
  pwr_tFileName oldname;

  for (int i = 9; i >= 0; i--) {
    snprintf(newname, sizeof(newname), "%s.%d", fname, i + 1);
    if (i == 0)
      strncpy(oldname, fname, sizeof(oldname));
    else
      snprintf(oldname, sizeof(oldname), "%s.%d", fname, i);

    pwr_tTime t;
    int sts = dcli_file_time(oldname, &t);
    if (EVEN(sts))
      continue;

    char cmd[6 + sizeof(oldname) + 1 + sizeof(newname) + 1];
    snprintf(cmd, sizeof(cmd), "mv -f %s %s", oldname, newname);
    // printf( "%s -> %s\n", oldname, newname);
    system(cmd);
  }
}
