/**
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 **/

#include <stdio.h>

#include <string.h>

#include "co_msg.h"
#include "pwr_msg.h"

#define FACNUM(sts) (((sts >> 16) & 0x0fff) - 0x800)
#define MSGIDX(sts) ((sts & 0x7fff) >> 3)

/* The heads of the message lists.  */

extern msg_sHead coMsgHead;
extern msg_sHead opMsgHead;
extern msg_sHead qcomMsgHead;
extern msg_sHead rtMsgHead;
extern msg_sHead wbMsgHead;
extern msg_sHead geMsgHead;
extern msg_sHead flowMsgHead;
extern msg_sHead glowMsgHead;
extern msg_sHead pwrpMsgHead;

static const msg_sHead* heads[]
    = { &rtMsgHead, &pwrpMsgHead, &qcomMsgHead, &coMsgHead, &opMsgHead,
        &wbMsgHead, &geMsgHead, &flowMsgHead, &glowMsgHead, NULL };

static msg_sFacility* facility(int facNum, int idx);

static msg_sFacility* IsRightHead(const msg_sHead* h, int facNum, int idx,
    int* invalidIdx /* Only valid if NULL is returned */
    );

/* Check if a given messagenumber exists,
   return string representation if valid.  */

char* msg_GetMsg(const int sts, char* buf, int bufSize)
{
  return msg_GetMessage(sts, 0xf, buf, bufSize);
}

/* Checks if a given messagenumber exists,
  return string representation if valid.  */

char* msg_GetText(const int sts, char* buf, int bufSize)
{
  return msg_GetMessage(sts, 1, buf, bufSize);
}

/* Return the address to the Facility which contains the
   FacNum and MsgIdx.  */

static msg_sFacility* facility(int facNum, int idx)
{
  msg_sFacility* f = NULL;
  int i, invalidIdx;

  for (i = 0; heads[i] != NULL; i++) {
    if (heads[i]->NofFacility != 0) {
      f = IsRightHead(heads[i], facNum, idx, &invalidIdx);
      if (f != NULL || invalidIdx)
        break;
    }
  }
  return f;
}

/* Returns the address to the Facility which contains the
   FacNum and MsgIdx.

   'invalidIdx will be set to TRUE if the facnum is found
   but the idx  isn't valid.  */

static msg_sFacility* IsRightHead(
    const msg_sHead* h, int facNum, int idx, int* invalidIdx)
{
  int i;
  msg_sFacility** f = h->Facility;
  *invalidIdx = 0;

  for (i = 0; i < h->NofFacility; i++) {
    if (f[i]->FacNum == facNum) {
      if ((idx > f[i]->NofMsg) || (idx < 1)) {
        *invalidIdx = 1;
        return NULL;
      } else {
        return f[i];
      }
    }
  }

  return NULL;
}

static char get_severity(pwr_tStatus sts)
{
  switch (sts & 7) {
  case 0:
    return 'W';
  case 1:
    return 'S';
  case 2:
    return 'E';
  case 3:
    return 'I';
  case 4:
    return 'F';
  default:
    return '?';
  }
}

char* msg_GetMessage(
    const pwr_tStatus sts, unsigned int flags, char* buf, int bufSize)
{
  int facNum = FACNUM(sts);
  int idx = MSGIDX(sts);
  msg_sFacility* f = facility(facNum, idx);
  char msg[256];
  char* s = msg;
  char* facName = "NONAME";
  char* msgName = "NOMSG";
  char text[sizeof("Message number 00000000")];
  char* msgTxt = text;

  if (f != NULL) {
    facName = f->FacName;
    msgName = f->Msg[idx - 1].MsgName;
    msgTxt = f->Msg[idx - 1].MsgTxt;
  } else {
    sprintf(text, "Message number %08X", sts);
  }

  if ((flags & 0xf) == 0xf)
    *s++ = '%';
  if (flags & 0x8)
    s += sprintf(s, "%s", facName);
  if (flags & 0x4) {
    if (flags & 0x8)
      *s++ = '-';
    *s++ = get_severity(sts);
  }
  if (flags & 0x2) {
    if (flags & 0xc)
      *s++ = '-';
    s += sprintf(s, "%s", msgName);
  }
  if (flags & 0x1) {
    if (flags & ~0x1)
      s += sprintf(s, ", ");
    s += sprintf(s, "%s", msgTxt);
  }

  *s = '\0';

  strncpy(buf, msg, bufSize - 1);
  buf[bufSize - 1] = '\0';

  return buf;
}
