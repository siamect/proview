/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* co_nav_crr.cpp
   This module contains routines for displaying crossreferences. */

/*_Include files_________________________________________________________*/

#include <ctype.h>
#include <stdlib.h>

extern "C" {
#include "co_cdh.h"
#include "co_ccm.h"
#include "co_time.h"
#include "co_dcli.h"
#include "co_ccm_msg.h"
}
#include "co_nav_crr.h"
#include "co_dcli_msg.h"
#include "co_nav_msg.h"
#include "co_string.h"

/*** Local funktions ***************************************************/

static int nav_get_signal_line(
    FILE* file, char* line, int size, int* spaces, char* text, int* lines);
static char* nav_VolumeIdToStr(pwr_tVolumeId volumeid);

/*************************************************************************
*
* Name:		nav_get_signal_line()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Reads a line i a proview signal or plcmodule list.
*	Returns the read line (line), number of spaces to the first charachter,
*	the number of lines read( empty lines are not returned),
*	and the first word (text).
*	Returns NAV__EOF if end of file.
*
**************************************************************************/

static int nav_get_signal_line(
    FILE* file, char* line, int size, int* spaces, char* text, int* lines)
{
  char* s;
  char* f;

  *lines = 0;
  while (1) {
    if (dcli_read_line(line, size, file) == 0)
      return NAV__EOF;
    (*lines)++;

    /* Get number of spaces before text */
    *spaces = 0;
    for (s = line; !((*s == 0) || ((*s != ' ') && (*s != 9))); s++) {
      (*spaces)++;
      if (*s == 9)
        (*spaces) += 7;
    }
    strcpy(text, s);

    /* Get end of text */
    for (f = text; !((*f == 0) || (*f == ' ') || (*f == 9)); f++)
      ;
    *f = 0;

    /* Check the text, if no text read next line */
    if (text[0] == 0)
      continue;
    if (text[0] == '-') {
      if (*spaces > 30) {
        /* Next line is a header */
        if (dcli_read_line(line, size, file) == 0)
          return NAV__EOF;
        (*lines)++;
      }
      continue;
    }
    break;
  }
  return NAV__SUCCESS;
}

/*************************************************************************
*
* Name:		nav_crr_signal()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*		Prints the cross references to a signal.
*
**************************************************************************/

int NavCrr::crr_signal(char* filename, char* signalname)
{
  pwr_tFileName default_filename;
  char line[1000];
  int object_spaces;
  pwr_tAName object;
  pwr_tAName objname;
  int spaces;
  int first;
  int sts;
  char* s;
  int wildcard;
  int signalcount = 0;
  int crossref_count = 0;
  pwr_tFileName filestr;
  int lines;
  pwr_tVolumeId volid;
  pwr_tObjid objid;
  pwr_tAName line_part[2];
  int nr;
  int write;
  int single_file = 0;
  pwr_tFileName file_spec;

  if (filename && streq(filename, "*")) {
    strcpy(file_spec, "$pwrp_load/rtt_crr_*.dat");
    sts = dcli_search_file(file_spec, filestr, DCLI_DIR_SEARCH_INIT);
    if (EVEN(sts))
      return sts;
  }

  str_ToUpper(signalname, signalname);

  /* Check if wildcard */
  s = strchr(signalname, '*');
  if (s == 0)
    wildcard = 0;
  else
    wildcard = 1;

  /* Open file */
  while (1) {
    FILE* file;

    /* Open file */
    if (filename && streq(filename, "*")) {
      file = fopen(filestr, "r");
    } else if (filename == NULL) {
      /* Open file, first get the volume id */
      if (!wildcard) {
        sts = (name_to_objid_cb)(parent_ctx, signalname, &objid);
        if (EVEN(sts))
          return NAV__OBJECTNOTFOUND;
        volid = objid.vid;
      } else {
        sts = (get_volume_cb)(parent_ctx, &volid, 0);
        if (EVEN(sts))
          return sts;
      }

      sprintf(default_filename, "%srtt_crr_%s.dat", dcli_pwr_dir("pwrp_load"),
          nav_VolumeIdToStr(volid));
      dcli_get_defaultfilename(default_filename, filestr, NULL);
      file = fopen(filestr, "r");
      single_file = 1;
    } else {
      dcli_get_defaultfilename(filename, filestr, ".lis");
      file = fopen(filestr, "r");
      single_file = 1;
    }

    if (file == 0)
      return NAV__NOFILE;

    /* Get the hierarchy */
    sts = nav_get_signal_line(
        file, line, sizeof(line), &spaces, object, &lines);
    if (EVEN(sts))
      goto finish;
    object_spaces = spaces;

    first = 1;
    while (1) {
      if ((s = strchr(object, ':')))
        strcpy(objname, s + 1);
      else
        strcpy(objname, object);

      str_ToUpper(objname, objname);

      sts = dcli_wildcard(signalname, objname);
      if (!sts) {
        /* Hit, print this object */
        signalcount++;

        sts = nav_get_signal_line(
            file, line, sizeof(line), &spaces, object, &lines);
        if (EVEN(sts))
          goto finish;
        while (spaces > object_spaces) {
          str_trim(line, line);

          if (line[0] == 'W' || line[0] == '>')
            write = 1;
          else
            write = 0;

          nr = dcli_parse(&line[2], " 	", "", (char*)line_part,
              sizeof(line_part) / sizeof(line_part[0]), sizeof(line_part[0]),
              0);
          if (streq(line_part[nr - 1], "") && nr > 2)
            nr--;
          (insert_cb)(parent_ctx, parent_node, navc_eItemType_Crossref,
              line_part[nr - 2], line_part[nr - 1], write);
          crossref_count++;
          sts = nav_get_signal_line(
              file, line, sizeof(line), &spaces, object, &lines);
          if (EVEN(sts))
            goto finish;
        }
        if (!wildcard)
          goto finish;
      } else {
        sts = nav_get_signal_line(
            file, line, sizeof(line), &spaces, object, &lines);
        if (EVEN(sts))
          goto finish;
        while (spaces > object_spaces) {
          sts = nav_get_signal_line(
              file, line, sizeof(line), &spaces, object, &lines);
          if (EVEN(sts))
            goto finish;
        }
      }
    }

  finish:
    fclose(file);

    if (single_file)
      break;

    if (filename && streq(filename, "*")) {
      sts = dcli_search_file(file_spec, filestr, DCLI_DIR_SEARCH_NEXT);
      if (EVEN(sts))
        break;
    }
  }

  if (filename && streq(filename, "*"))
    dcli_search_file(file_spec, filestr, DCLI_DIR_SEARCH_END);

  if (signalcount == 0)
    return NAV__OBJECTNOTFOUND;

  if (crossref_count == 0)
    return NAV__NOCROSSREF;

  return NAV__SUCCESS;
}

/*************************************************************************
*
* Name:		nav_crr_object()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*		Prints the cross references to a object that is not a signal.
*
**************************************************************************/

int NavCrr::crr_object(char* filename, char* objectname)
{
  pwr_tFileName default_filename;
  char line[1000];
  int object_spaces;
  pwr_tAName object;
  pwr_tAName objname;
  int spaces;
  int first;
  int sts;
  char* s;
  int wildcard;
  pwr_tFileName filestr;
  int lines;
  pwr_tVolumeId volid;
  pwr_tObjid objid;
  int crossref_count = 0;
  pwr_tAName line_part[2];
  int nr;
  int write;
  int single_file = 0;
  pwr_tFileName file_spec;
  int signalcount = 0;

  if (filename && streq(filename, "*")) {
    strcpy(file_spec, "$pwrp_load/rtt_crro_*.dat");
    sts = dcli_search_file(file_spec, filestr, DCLI_DIR_SEARCH_INIT);
    if (EVEN(sts))
      return sts;
  }

  str_ToUpper(objectname, objectname);

  /* Check if wildcard */
  s = strchr(objectname, '*');
  if (s == 0)
    wildcard = 0;
  else
    wildcard = 1;

  while (1) {
    FILE* file;

    /* Open file */
    if (filename && streq(filename, "*")) {
      file = fopen(filestr, "r");
    } else if (filename == NULL) {
      /* Open file, first get the volume id */
      if (!wildcard) {
        sts = (name_to_objid_cb)(parent_ctx, objectname, &objid);
        if (EVEN(sts))
          return NAV__OBJECTNOTFOUND;
        volid = objid.vid;
      } else {
        sts = (get_volume_cb)(parent_ctx, &volid, 0);
        if (EVEN(sts))
          return sts;
      }

      sprintf(default_filename, "%srtt_crro_%s.dat", dcli_pwr_dir("pwrp_load"),
          nav_VolumeIdToStr(volid));
      dcli_get_defaultfilename(default_filename, filestr, NULL);
      file = fopen(filestr, "r");
      single_file = 1;
    } else {
      dcli_get_defaultfilename(filename, filestr, ".lis");
      file = fopen(filestr, "r");
      single_file = 1;
    }

    if (file == 0)
      return NAV__NOFILE;

    /* Get the object */
    sts = nav_get_signal_line(
        file, line, sizeof(line), &spaces, object, &lines);
    if (EVEN(sts))
      goto finish;
    object_spaces = spaces;

    first = 1;
    while (1) {
      if ((s = strchr(object, ':')))
        strcpy(objname, s + 1);
      else
        strcpy(objname, object);

      str_ToUpper(objname, objname);

      sts = dcli_wildcard(objectname, objname);
      if (sts) {
        pwr_tAName subname;
        strcpy(subname, objectname);
        strcat(subname, ".*");

        sts = dcli_wildcard(subname, objname);
      }
      if (!sts) {
        /* Hit, print this object */
        signalcount++;

        sts = nav_get_signal_line(
            file, line, sizeof(line), &spaces, object, &lines);
        if (EVEN(sts))
          goto finish;
        while (spaces > object_spaces) {
          str_trim(line, line);

          if (line[0] == 'W') {
            write = 1;
          } else if (line[0] == '>') {
            write = 2;
          } else
            write = 0;

          nr = dcli_parse(&line[2], " 	", "", (char*)line_part,
              sizeof(line_part) / sizeof(line_part[0]), sizeof(line_part[0]),
              0);
          if (streq(line_part[nr - 1], "") && nr > 2)
            nr--;
          if (nr > 2 && line_part[nr - 3][0] == '#')
            write = 1;
          else if (nr > 2 && line_part[nr - 3][0] == '&')
            write = 2;
          (insert_cb)(parent_ctx, parent_node, navc_eItemType_Crossref,
              line_part[nr - 2], line_part[nr - 1], write);
          crossref_count++;

          sts = nav_get_signal_line(
              file, line, sizeof(line), &spaces, object, &lines);
          if (EVEN(sts))
            goto finish;
        }
      } else {
        if (!wildcard && signalcount)
          goto finish;

        sts = nav_get_signal_line(
            file, line, sizeof(line), &spaces, object, &lines);
        if (EVEN(sts))
          goto finish;
      }

      while (spaces != object_spaces) {
        sts = nav_get_signal_line(
            file, line, sizeof(line), &spaces, object, &lines);
        if (EVEN(sts))
          goto finish;
      }
    }

  finish:
    fclose(file);

    if (single_file)
      break;

    if (filename && streq(filename, "*")) {
      sts = dcli_search_file(file_spec, filestr, DCLI_DIR_SEARCH_NEXT);
      if (EVEN(sts))
        break;
    }
  }

  if (filename && streq(filename, "*"))
    dcli_search_file(file_spec, filestr, DCLI_DIR_SEARCH_END);

  if (signalcount == 0)
    return NAV__OBJECTNOTFOUND;

  if (crossref_count == 0)
    return NAV__NOCROSSREF;

  return NAV__SUCCESS;
}

/*************************************************************************
*
* Name:		nav_crr_code()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*		Prints the cross references to a fuction or string
*		in arithm objects.
*
**************************************************************************/

int NavCrr::crr_code(
    char* filename, char* str, int brief, int func, int case_sensitive)
{
  pwr_tFileName default_filename;
  FILE* file;
  char line[1000];
  char tst_line[1000];
  pwr_tAName object;
  pwr_tAName objname;
  int spaces;
  int first;
  int sts;
  char* s;
  int signalcount = 0;
  pwr_tFileName filestr;
  int lines;
  char title[80];
  pwr_tVolumeId volid;
  int objname_written;
  int hit;
  char* tst_char;
  pwr_tVid prev_volid = 0;
  int vol_cnt = 0;
  int end_of_file;

  while (1) {
    end_of_file = 0;

    /* Open file */
    if (filename == NULL) {
      sts = (get_volume_cb)(parent_ctx, &volid, prev_volid);
      if (EVEN(sts))
        break;

      prev_volid = volid;

      sprintf(default_filename, "%srtt_crrc_%s.dat", dcli_pwr_dir("pwrp_load"),
          nav_VolumeIdToStr(volid));
      dcli_get_defaultfilename(default_filename, filestr, NULL);
      file = fopen(filestr, "r");
    } else {
      if (vol_cnt == 1)
        break;

      dcli_get_defaultfilename(filename, filestr, ".lis");
      file = fopen(filestr, "r");
    }
    vol_cnt++;

    if (file == 0)
      continue;

    /* Case sensitive if any lowercase */
    if (!case_sensitive)
      for (s = str; *s != 0; s++) {
        if (*s != '_' && !isupper(*s))
          case_sensitive = 1;
      }

    while (!str_StartsWith(line, " _Obj_ ")) {
      sts = nav_get_signal_line(
          file, line, sizeof(line), &spaces, object, &lines);
      if (EVEN(sts)) {
        fclose(file);
        end_of_file = 1;
        break;
      }
    }
    if (end_of_file)
      continue;

    first = 1;
    while (1) {
      strcpy(objname, &line[7]);
      for (s = objname; !(*s == 32 || *s == 9 || *s == 0); s++)
        ;
      *s = 0;

      sts = nav_get_signal_line(
          file, line, sizeof(line), &spaces, object, &lines);
      objname_written = 0;
      while (!str_StartsWith(line, " _Obj_ ")) {
        if (!case_sensitive)
          str_ToUpper(tst_line, line);
        else
          strcpy(tst_line, line);

        hit = 0;
        if (!func) {
          if (strstr(tst_line, str) != 0)
            hit = 1;
        } else {
          if ((s = strstr(tst_line, str)) != 0) {
            hit = 1;
            /* Check char after */
            tst_char = s + strlen(str);
            if (isalpha(*tst_char) || isdigit(*tst_char) || *tst_char == '_')
              hit = 0;
            /* Check char before */
            if (s != tst_line) {
              tst_char = s - 1;
              if (isalpha(*tst_char) || isdigit(*tst_char) || *tst_char == '_')
                hit = 0;
            }
          }
        }
        if (hit) {
          /* Hit, print this object */
          if (signalcount == 0) {
            if (func) {
              sprintf(title, "Crossreferens list Function  \"%s\"\n\n", str);
              (insert_cb)(parent_ctx, parent_node, navc_eItemType_Header, title,
                  NULL, 0);
            } else {
              sprintf(title, "Crossreferens list String    \"%s\"\n\n", str);
              (insert_cb)(parent_ctx, parent_node, navc_eItemType_Header, title,
                  NULL, 0);
            }
          }
          signalcount++;

          if (!objname_written) {
            (insert_cb)(parent_ctx, parent_node, navc_eItemType_Crossref,
                objname, (char*)"", 2);
            objname_written = 1;
          }

          strcpy(tst_line, "     ");
          strcat(tst_line, line);
          (insert_cb)(
              parent_ctx, parent_node, navc_eItemType_Text, tst_line, NULL, 0);

          if (brief) {
            while (!str_StartsWith(line, " _Obj_ ")) {
              sts = nav_get_signal_line(
                  file, line, sizeof(line), &spaces, object, &lines);
              if (EVEN(sts)) {
                end_of_file = 1;
                break;
              }
            }
            if (end_of_file)
              break;
          } else {
            sts = nav_get_signal_line(
                file, line, sizeof(line), &spaces, object, &lines);
            if (EVEN(sts)) {
              end_of_file = 1;
              break;
            }
          }
        } else {
          sts = nav_get_signal_line(
              file, line, sizeof(line), &spaces, object, &lines);
          if (EVEN(sts)) {
            end_of_file = 1;
            break;
          }
        }
        if (end_of_file)
          break;
      }
      if (end_of_file)
        break;
    }

    fclose(file);
  }

  if (signalcount == 0) {
    if (func)
      return NAV__STRINGNOTFOUND;
    else
      return NAV__FUNCTIONNOTFOUND;
  }
  return NAV__SUCCESS;
}

/*************************************************************************
*
* Name:		get_signals()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*		Returns all signals under an object.
*
**************************************************************************/

int NavCrr::get_signals(char* filename, char* objectname)
{
  pwr_tFileName default_filename;
  char line[1000];
  int object_spaces;
  pwr_tAName object;
  pwr_tAName objname;
  int spaces;
  int first;
  int sts;
  char* s;
  int signalcount = 0;
  pwr_tFileName filestr;
  int lines;
  pwr_tVolumeId volid;
  pwr_tObjid objid;

  str_ToUpper(objectname, objectname);

  /* Open file */
  while (1) {
    FILE* file;

    /* Open file */
    if (filename) {
      file = fopen(filestr, "r");
    } else {
      /* Open file, first get the volume id */
      sts = (name_to_objid_cb)(parent_ctx, objectname, &objid);
      if (EVEN(sts))
        return NAV__OBJECTNOTFOUND;
      volid = objid.vid;

      sprintf(default_filename, "%srtt_crrs_%s.dat", dcli_pwr_dir("pwrp_load"),
          nav_VolumeIdToStr(volid));
      dcli_get_defaultfilename(default_filename, filestr, NULL);
      file = fopen(filestr, "r");
    }

    if (file == 0)
      return NAV__NOFILE;

    /* Get the hierarchy */
    sts = nav_get_signal_line(
        file, line, sizeof(line), &spaces, object, &lines);
    if (EVEN(sts))
      goto finish;
    object_spaces = spaces;

    first = 1;
    while (1) {
      if ((s = strchr(object, ':')))
        strcpy(objname, s + 1);
      else
        strcpy(objname, object);

      str_ToUpper(objname, objname);

      if (str_StartsWith(objname, objectname)
          && (objname[strlen(objectname)] == 0
                 || objname[strlen(objectname)] == '.'
                 || objname[strlen(objectname)] == '-')) {
        /* Hit, print this object */
        signalcount++;

        (insert_cb)(
            parent_ctx, parent_node, navc_eItemType_Crossref, object, 0, 0);
        signalcount++;

        sts = nav_get_signal_line(
            file, line, sizeof(line), &spaces, object, &lines);
        if (EVEN(sts))
          goto finish;
      } else {
        sts = nav_get_signal_line(
            file, line, sizeof(line), &spaces, object, &lines);
        if (EVEN(sts))
          goto finish;
      }
    }

  finish:
    fclose(file);

    break;
  }

  if (signalcount == 0)
    return NAV__OBJECTNOTFOUND;

  return NAV__SUCCESS;
}

/*************************************************************************
*
* Name:		nav_VolumeIdToStr()
*
* Type		* char
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Converts an VolumeId to a string.
*	The returned string is static and must be used befor next call
*	of the function.
*
**************************************************************************/

static char* nav_VolumeIdToStr(pwr_tVolumeId volumeid)
{
  static char str[80];
  unsigned char volid[4];

  memcpy(&volid, &volumeid, sizeof(volid));
  sprintf(
      str, "%3.3u_%3.3u_%3.3u_%3.3u", volid[3], volid[2], volid[1], volid[0]);
  return str;
}
