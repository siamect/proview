/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_ndc.c -- Network data conversion.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Vax f-float.  */

union vax_f {
  int i;
  struct {
    unsigned int f22_16 : 7;
    unsigned int exp : 8;
    unsigned int sign : 1;
    unsigned int f15_0 : 16;
  } b;
};

/* IEEE single.  */

union i3e_s {
  int i;
  struct {
    unsigned int f22_0 : 23;
    unsigned int exp : 8;
    unsigned int sign : 1;
  } b;
  struct {
    unsigned int f22_7 : 16;
    unsigned int f6_0 : 7;
    unsigned int exp : 8;
    unsigned int sign : 1;
  } v;
};

/* Vax f-float.  */

union vax_f_be {
  int i;
  struct {
    unsigned int f15_0 : 16;
    unsigned int sign : 1;
    unsigned int exp : 8;
    unsigned int f22_16 : 7;
  } b;
};

/* IEEE single.  */

union i3e_s_be {
  int i;
  struct {
    unsigned int sign : 1;
    unsigned int exp : 8;
    unsigned int f22_0 : 23;
  } b;
  struct {
    unsigned int sign : 1;
    unsigned int exp : 8;
    unsigned int f6_0 : 7;
    unsigned int f22_7 : 16;
  } v;
};

#define VAX_F_BIAS 0x81
#define I3E_S_BIAS 0x7f
#define VAX_D_BIAS 0x81
#define VAX_G_BIAS 0x401
#define I3E_D_BIAS 0x3ff

#define IBYTE0(s) (((*(int*)s) >> 0x18) & 0x000000ff)
#define IBYTE1(s) (((*(int*)s) >> 0x08) & 0x0000ff00)
#define IBYTE2(s) (((*(int*)s) << 0x08) & 0x00ff0000)
#define IBYTE3(s) (((*(int*)s) << 0x18) & 0xff000000)

#define CONVERT_INT(t, s)                                                      \
  (*(int*)t = (IBYTE0(s) | IBYTE1(s) | IBYTE2(s) | IBYTE3(s)))

#define SBYTE0(s) (((*(short*)s) >> 0x08) & 0x00ff)
#define SBYTE1(s) (((*(short*)s) << 0x08) & 0xff00)

#define CONVERT_SHORT(t, s) (*(short*)t = (SBYTE0(s) | SBYTE1(s)))

#define CONVERT_BOOL(t, s) (*(int*)t = (0 != *(int*)s))

static char* print_bin(int* i)
{
  static char buff[80];
  int b;

  buff[0] = '\0';

  for (b = 0; b < 32; b++) {
    strcat(buff, ((*i & (1 << b)) ? "1" : "0"));
    if ((b + 1) % 8 == 0)
      strcat(buff, " ");
  }

  return buff;
}

/* .  */

static int encode_sfloat(int count, char* tp, char* sp, int* size)
{
  int i;
  union vax_f* vp;
  union i3e_s i3e;

  for (i = count; i > 0; i--) {
    vp = ((union vax_f*)sp);

    if (vp->b.f22_16 == 0x7f && vp->b.exp == 0xff
        && vp->b.f15_0 == 0xffff) { /* High value.  */
      i3e.i = 0, i3e.b.exp = 0xff;
    } else if (vp->b.f22_16 == 0 && vp->b.exp == 0
        && vp->b.f15_0 == 0) { /* Low value.  */
      i3e.i = 0;
    } else {
      i3e.b.exp = vp->b.exp - VAX_F_BIAS + I3E_S_BIAS;
      i3e.v.f22_7 = vp->b.f15_0;
      i3e.v.f6_0 = vp->b.f22_16;
    }

    i3e.b.sign = vp->b.sign;

    CONVERT_INT(tp, &i3e.i);
    tp += sizeof(float);
    sp += sizeof(float);
    *size -= sizeof(float);
  }

  return 1;
}

/* .  */

static int decode_vaxfloat(int count, char* tp, char* sp, int* size)
{
  int i;
  union vax_f_be v;
  union i3e_s_be* i3ep;

  for (i = count; i > 0; i--) {
    i3ep = ((union i3e_s_be*)tp);
    CONVERT_INT(&v, sp);

    if (v.b.f22_16 == 0x7f && v.b.exp == 0xff
        && v.b.f15_0 == 0xffff) { /* High value.  */
      i3ep->i = 0, i3ep->b.exp = 0xff;
    } else if (v.b.f22_16 == 0 && v.b.exp == 0
        && v.b.f15_0 == 0) { /* Low value.  */
      i3ep->i = 0;
    } else {
      i3ep->b.exp = v.b.exp - VAX_F_BIAS + I3E_S_BIAS;
      i3ep->v.f22_7 = v.b.f15_0;
      i3ep->v.f6_0 = v.b.f22_16;
    }

    i3ep->b.sign = v.b.sign;

    tp += sizeof(float);
    sp += sizeof(float);
    *size -= sizeof(float);
  }

  return 1;
}

/* .  */

static int decode_sfloat(int count, char* tp, char* sp, int* size)
{
  int i;
  union vax_f* vp;
  union i3e_s i3e;

  for (i = count; i > 0; i--) {
    vp = ((union vax_f*)tp);
    CONVERT_INT(&i3e.i, sp);

    if (i3e.b.f22_0 == 0x0 && i3e.b.exp == 0xff) { /* High value.  */
      vp->b.f22_16 = 0x7f;
      vp->b.exp = 0xff;
      vp->b.f15_0 = 0xffff;
    } else if (i3e.b.f22_0 == 0x0 && i3e.b.exp == 0x00) { /* Low value.  */
      vp->i = 0;
    } else {
      vp->b.exp = i3e.b.exp - I3E_S_BIAS + VAX_F_BIAS;
      vp->b.f22_16 = i3e.v.f6_0;
      vp->b.f15_0 = i3e.v.f22_7;
    }

    vp->b.sign = i3e.b.sign;

    tp += sizeof(float);
    sp += sizeof(float);
    *size -= sizeof(float);
  }

  return 1;
}

typedef struct {
  int b_int_v[10];
  float a_float_v[100];
  int a_int;
  short int a_short_v[5];
  int a_int_v[5];
  char a_char;
  float a_float;
} sTest;

main()
{
  sTest src;
  sTest trg;
  float a = 1234567890.123456;
  float b = 1.1;
  int i;
  int size;
  FILE* fp;

  float av[9];
  float bv[9];
  av[0] = 0.19550715;
  av[1] = 1.9550715;
  av[2] = 19.550715;
  av[3] = 195.50715;
  av[4] = 1955.0715;
  av[5] = 19550.715;
  av[6] = 195507.15;
  av[7] = 1955071.5;
  av[8] = 19550715.;

  printf("a1 ..............:% 22.10f %12e %s\n", av[0], av[0],
      print_bin((int*)&av[0]));
  printf("a2 ..............:% 22.10f %12e %s\n", av[1], av[1],
      print_bin((int*)&av[1]));
  printf("a3 ..............:% 22.10f %12e %s\n", av[2], av[2],
      print_bin((int*)&av[2]));
  printf("a4 ..............:% 22.10f %12e %s\n", av[3], av[3],
      print_bin((int*)&av[3]));
  printf("a5 ..............:% 22.10f %12e %s\n", av[4], av[4],
      print_bin((int*)&av[4]));
  printf("a6 ..............:% 22.10f %12e %s\n", av[5], av[5],
      print_bin((int*)&av[5]));
  printf("a7 ..............:% 22.10f %12e %s\n", av[6], av[6],
      print_bin((int*)&av[6]));
  printf("a8 ..............:% 22.10f %12e %s\n", av[7], av[7],
      print_bin((int*)&av[7]));
  printf("a9 ..............:% 22.10f %12e %s\n", av[8], av[8],
      print_bin((int*)&av[8]));

  fp = fopen("/view/pwr_x2_3_1/vobs/pwr_src/src/lib/rt/tst/test_vax.dat", "rb");
  if (fp == NULL)
    exit(0);

  size = fread(av, sizeof(av), 1, fp);
  printf("\nRead %d objects\n\n", size);

  printf("a1 ..............:% 22.10f %12e %s\n", av[0], av[0],
      print_bin((int*)&av[0]));
  printf("a2 ..............:% 22.10f %12e %s\n", av[1], av[1],
      print_bin((int*)&av[1]));
  printf("a3 ..............:% 22.10f %12e %s\n", av[2], av[2],
      print_bin((int*)&av[2]));
  printf("a4 ..............:% 22.10f %12e %s\n", av[3], av[3],
      print_bin((int*)&av[3]));
  printf("a5 ..............:% 22.10f %12e %s\n", av[4], av[4],
      print_bin((int*)&av[4]));
  printf("a6 ..............:% 22.10f %12e %s\n", av[5], av[5],
      print_bin((int*)&av[5]));
  printf("a7 ..............:% 22.10f %12e %s\n", av[6], av[6],
      print_bin((int*)&av[6]));
  printf("a8 ..............:% 22.10f %12e %s\n", av[7], av[7],
      print_bin((int*)&av[7]));
  printf("a9 ..............:% 22.10f %12e %s\n", av[8], av[8],
      print_bin((int*)&av[8]));

  size = 9 * sizeof(float);
  decode_vaxfloat(9, (char*)bv, (char*)&av, &size);
  printf("\ndeocde\n\n", size);

  printf("a1 ..............:% 22.10f %12e %s\n", bv[0], bv[0],
      print_bin((int*)&bv[0]));
  printf("a2 ..............:% 22.10f %12e %s\n", bv[1], bv[1],
      print_bin((int*)&bv[1]));
  printf("a3 ..............:% 22.10f %12e %s\n", bv[2], bv[2],
      print_bin((int*)&bv[2]));
  printf("a4 ..............:% 22.10f %12e %s\n", bv[3], bv[3],
      print_bin((int*)&bv[3]));
  printf("a5 ..............:% 22.10f %12e %s\n", bv[4], bv[4],
      print_bin((int*)&bv[4]));
  printf("a6 ..............:% 22.10f %12e %s\n", bv[5], bv[5],
      print_bin((int*)&bv[5]));
  printf("a7 ..............:% 22.10f %12e %s\n", bv[6], bv[6],
      print_bin((int*)&bv[6]));
  printf("a8 ..............:% 22.10f %12e %s\n", bv[7], bv[7],
      print_bin((int*)&bv[7]));
  printf("a9 ..............:% 22.10f %12e %s\n", bv[8], bv[8],
      print_bin((int*)&bv[8]));

  size = fread(&src, sizeof(src), 1, fp);
  printf("\nRead %d objects\n\n", size);

  for (i = 0; i < 10; i++)
    CONVERT_INT(&trg.b_int_v[i], &src.b_int_v[i]);

  size = sizeof(trg.a_float_v);
  decode_vaxfloat(100, (char*)trg.a_float_v, (char*)src.a_float_v, &size);

  CONVERT_INT(&trg.a_int, &src.a_int);

  for (i = 0; i < 5; i++)
    CONVERT_SHORT(&trg.a_short_v[i], &src.a_short_v[i]);

  for (i = 0; i < 5; i++)
    CONVERT_INT(&trg.a_int_v[i], &src.a_int_v[i]);

  trg.a_char = src.a_char;

  size = sizeof(trg.a_float);
  decode_vaxfloat(1, (char*)&trg.a_float, (char*)&src.a_float, &size);

  for (i = 0; i < 10; i++) {
    printf("b_int_v[%3.3d] ..:% 12.12d %s\n", i, trg.b_int_v[i],
        print_bin(&trg.b_int_v[i]));
  }

  for (i = 0; i < 100; i++) {
    printf("a_float_v[%3.3d] :% 22.10f %15e %s\n", i, trg.a_float_v[i],
        trg.a_float_v[i], print_bin((int*)&trg.a_float_v[i]));
  }

  printf("a_int .........:% 12.12d %s\n", trg.a_int, print_bin(&trg.a_int));

  for (i = 0; i < 5; i++) {
    printf("a_short_v[%3.3d] :% 12.12d\n", i, trg.a_short_v[i]);
  }

  for (i = 0; i < 5; i++) {
    printf("a_int_v[%3.3d] ..:% 12.12d %s\n", i, trg.a_int_v[i],
        print_bin(&trg.a_int_v[i]));
  }

  printf("a_char ........: %c\n", trg.a_char);

  printf("a_float .......:% 22.10f %15e %s\n", trg.a_float, trg.a_float,
      print_bin((int*)&trg.a_float));

  fclose(fp);

  exit(1);
}
