/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_cmvolsm.c -- Cached volumes
   This module contains the meta cache handling routines for the server monitor.
   */

#include <string.h>

#include "co_time.h"
#include "rt_gdh_msg.h"
#include "rt_vol.h"
#include "rt_cmvolsm.h"

/** Handle GetCclass message */
void cmvolsm_GetCclass(qcom_sGet* get)
{
  pwr_tStatus sts;
  pwr_tStatus lsts;
  int size;
  net_sGetCclassR* rmp = NULL;
  net_sGetCclass* mp = get->data;
  qcom_sPut put;
  gdb_sAttribute* ap;
  net_sCattribute* cap;
  gdb_sClass* cp;
  gdb_sObject* cop;
  int i;
  pwr_tBoolean equal = FALSE;
  const int maxacnt
      = ((net_cSizeLarge - sizeof(*rmp)) / sizeof(rmp->attr[0])) + 1;
  int maxaidx = 0;
  int acnt = 0;
  pwr_tTime mp_time;

  gdb_AssumeUnlocked;

  gdb_ScopeLock
  {
    cp = hash_Search(&sts, gdbroot->cid_ht, &mp->cid);
    if (cp == NULL)
      break;

    cop = pool_Address(NULL, gdbroot->pool, cp->cor);
    mp_time = net_NetTimeToTime(&mp->time);
    if (time_Acomp(&mp_time, &cop->u.n.time) == 0) {
      equal = TRUE;
      size = sizeof(*rmp);
    } else {
      acnt = MIN(maxacnt, cp->acount - mp->aidx);
      maxaidx = acnt + mp->aidx;
      size = sizeof(*rmp) + MAX(0, (acnt - 1)) * sizeof(rmp->attr[0]);
    }

    rmp = net_Alloc(&sts, &put, size, net_eMsg_getCclassR);
    if (rmp == NULL) {
      errh_Error("cmvolsm_GetCclass. net_Alloc, size %d, cid %d, error %m",
          size, mp->cid, sts);
      break;
    }

    rmp->ver = net_cVersion;
    rmp->sts = 1;
    rmp->equal = equal;

    if (equal) {
      rmp->acntmsg = 0;
      rmp->cclass.size = 0;
      rmp->cclass.acount = 0;

      break;
    }

    rmp->cclass.cid = mp->cid;
    rmp->cclass.time = net_TimeToNetTime(&cop->u.n.time);
    rmp->cclass.size = cp->size;
    rmp->cclass.acount = cp->acount;

    for (i = mp->aidx, ap = &cp->attr[mp->aidx], cap = rmp->attr; i < maxaidx;
         i++, ap++, cap++) {
      cap->aix = ap->aix;
      cap->flags = ap->flags;
      cap->type = ap->type;
      cap->offs = ap->offs;
      cap->size = ap->size;
      cap->elem = ap->elem;
      cap->moffset = ap->moffset;
    }

    rmp->acntmsg = acnt;
    rmp->saidx = mp->aidx;
    rmp->naidx = (i == cp->acount) ? UINT_MAX : i;
  }
  gdb_ScopeUnlock;

  if (EVEN(sts)) {
    rmp = net_Alloc(&lsts, &put, sizeof(*rmp), net_eMsg_getCclassR);
    if (EVEN(lsts)) {
      errh_Error("cmvolsm_GetCclass. net_Alloc, size %d, cid %d, error %m",
          sizeof(*rmp), mp->cid, lsts);
      return;
    }
    rmp->ver = net_cVersion;
  }

  if (EVEN(sts))
    rmp->sts = sts;
  else
    rmp->sts = 1;

  net_Reply(&lsts, get, &put, 0);
}

/** Handle GetGclass message */
void cmvolsm_GetGclass(qcom_sGet* get)
{
  pwr_tStatus sts;
  pwr_tStatus lsts;
  int size;
  net_sGetGclassR* rmp = NULL;
  net_sGetGclass* mp = get->data;
  qcom_sPut put;
  pwr_tVolumeId cvid;
  gdb_sVolume* vp;
  pwr_sClassDef* cbp;
  pwr_sObjBodyDef* bbp;
  pwr_sParam* abp;
  gdb_sAttribute* ap;
  net_sGattribute* gap;
  gdb_sClass* cp;
  gdb_sObject* cop;
  gdb_sObject* bop;
  gdb_sObject* aop;
  int i;
  const int maxacnt
      = ((net_cSizeLarge - sizeof(*rmp)) / sizeof(rmp->attr[0])) + 1;
  int maxaidx;
  int acnt;

  gdb_AssumeUnlocked;

  gdb_ScopeLock
  {
    cp = hash_Search(&sts, gdbroot->cid_ht, &mp->cid);
    if (cp == NULL)
      break;

    cvid = mp->cid >> 16;
    vp = hash_Search(&sts, gdbroot->vid_ht, &cvid);
    if (vp == NULL)
      break;

    cop = pool_Address(NULL, gdbroot->pool, cp->cor);
    acnt = MIN(maxacnt, cp->acount - mp->aidx);
    maxaidx = acnt + mp->aidx;
    size = sizeof(*rmp) + MAX(0, (acnt - 1)) * sizeof(rmp->attr[0]);

    rmp = net_Alloc(&sts, &put, size, net_eMsg_getGclassR);
    if (rmp == NULL) {
      errh_Error("cvolsm_GetGclass. net_Alloc, size %d, cid %d, error %m", size,
          mp->cid, sts);
      break;
    }
    rmp->ver = net_cVersion;

    strcpy(rmp->vname, vp->g.name.orig);
    rmp->gclass.time = net_TimeToNetTime(&cop->u.n.time);
    rmp->gclass.co = cop->g;
    rmp->gclass.dbsFlags = cop->u.n.lflags.m;

    if (mp->aidx == 0) {
      cbp = pool_Address(&sts, gdbroot->rtdb, cp->cbr);
      if (cbp == NULL)
        break;
      rmp->gclass.cb.Editor = cbp->Editor;
      rmp->gclass.cb.Method = cbp->Method;
      rmp->gclass.cb.Flags = (pwr_tUInt32)cbp->Flags.m;
      rmp->gclass.cb.NumOfObjBodies = cbp->NumOfObjBodies;
      rmp->gclass.cb.PopEditor = cbp->PopEditor;

      bop = pool_Address(&sts, gdbroot->pool, cp->bor);
      if (bop == NULL)
        break;
      rmp->gclass.bo = bop->g;

      bbp = pool_Address(&sts, gdbroot->rtdb, cp->bbr);
      if (bbp == NULL)
        break;
      strcpy(rmp->gclass.bb.StructName, bbp->StructName);
      rmp->gclass.bb.NumOfParams = bbp->NumOfParams;
      rmp->gclass.bb.Size = bbp->Size;
      rmp->gclass.bb.NextAix = bbp->NextAix;
      rmp->gclass.bb.Flags = bbp->Flags;
    }

    rmp->gclass.size = cp->size;
    rmp->gclass.acount = cp->acount;

    for (i = mp->aidx, ap = &cp->attr[mp->aidx], gap = rmp->attr; i < maxaidx;
         i++, ap++, gap++) {
      aop = pool_Address(&sts, gdbroot->pool, ap->aor);
      if (aop == NULL)
        break;
      gap->ao = aop->g;

      abp = pool_Address(&sts, gdbroot->rtdb, ap->abr);
      if (aop == NULL)
        break;
      strcpy(gap->ab.Info.PgmName, abp->Info.PgmName);
      gap->ab.Info.Type = abp->Info.Type;
      gap->ab.Info.Offset = abp->Info.Offset;
      gap->ab.Info.Size = abp->Info.Size;
      gap->ab.Info.Flags = abp->Info.Flags;
      gap->ab.Info.Elements = abp->Info.Elements;
      gap->ab.Info.ParamIndex = abp->Info.ParamIndex;
      gap->ab.TypeRef = abp->TypeRef;
    }

    rmp->acntmsg = acnt;
    rmp->saidx = mp->aidx;
    rmp->naidx = (i == cp->acount) ? UINT_MAX : i;
  }
  gdb_ScopeUnlock;

  if (EVEN(sts)) {
    if (rmp != NULL)
      net_Free(NULL, rmp);

    rmp = net_Alloc(&lsts, &put, sizeof(*rmp), net_eMsg_getGclassR);
    if (EVEN(lsts)) {
      errh_Error("cmvolsm_GetGclass. net_Alloc, size %d, cid %d, error %m",
          sizeof(*rmp), mp->cid, lsts);
      return;
    }
    rmp->ver = net_cVersion;
  }

  if (EVEN(sts))
    rmp->sts = sts;
  else
    rmp->sts = 1;

  net_Reply(&lsts, get, &put, 0);
}
