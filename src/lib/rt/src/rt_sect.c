/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/shm.h> // for shared memory
#include <sys/stat.h> // for "S_IRWXU" etc.

#include "rt_sect.h"
#include "rt_errh.h"

pwr_tBoolean sect_must_create = 0;

static void segName(sect_sHead* shp, char* name);

/* Construct the name of a section.
   It does not access the database! */

static void segName(sect_sHead* shp, char* name)
{
  static int doinit = 1;
  static char buf[4];
  if (doinit) {
    char* str = getenv(pwr_dEnvBusId);
    strncpy(buf, (str ? str : "XXX"), 3);
    buf[3] = '\0';
  }
  sprintf(shp->name, "%.*s_%.3s", (int)sizeof(shp->name) - 4 - 1, name, buf);
}

/* Map (and optionally create) a shared memory section.
   Name must not be more than 15 characters because of $ASCEFC.
   Returns the virtual address of the newly mapped (created) section.  */

sect_sHead* sect_Alloc(pwr_tStatus* sts, pwr_tBoolean* created, sect_sHead* shp,
    size_t size, char* name, unsigned int flags)
{
  pwr_tStatus lsts = 1;
  sect_sHead* lshp = NULL;

  if (shp == NULL)
    shp = lshp = (sect_sHead*)calloc(1, sizeof(*lshp));
  if (shp == NULL)
    pwr_Return(NULL, sts, 2 /*SECT__VIRMEM*/);

  do {
    if (shp->flags.b.mapped) {
      lsts = 2 /*SECT__WASMAPPED*/;
      break;
    }

    shp->base = NULL;
    segName(shp, name);

    {
      int shm_fd;
      int shMemFlags = O_RDWR;
      mode_t shMemMode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP;
      key_t shm_key;
      int shm_id;

      *created = 0;
      /* Create unique key */
      shm_fd = open(shp->name, shMemFlags, shMemMode);

      if (sect_must_create && shm_fd != -1) { /* Do we need to check errno ? */
        errh_Info(
            "sect_Alloc: %s already exists. It will be unlinked and created\n",
            shp->name);
        if (unlink(shp->name) == -1) {
          lsts = 2;
          errh_Error(
              "sect_Alloc: unlink failed on !%s! errno: %d", shp->name, errno);
          break;
        }
        shMemFlags |= O_CREAT | O_EXCL;
        shm_fd = open(shp->name, shMemFlags, shMemMode);
        if (shm_fd == -1) {
          lsts = 2;
          errh_Error("sect_Alloc: open O_CREATE failed errno: %d", errno);
          break;
        }
        *created = 1;
      } else if (shm_fd == -1) {
        if (errno == ENOENT) { /* It didn't exist */
          if (!(flags & sect_mFlags_Create)) {
            lsts = 2;
            errh_Error("sect_Alloc: Couldn't attach shm section size");
            break;
          }
          shMemFlags |= O_CREAT | O_EXCL;
          shm_fd = open(shp->name, shMemFlags, shMemMode);
          if (shm_fd == -1) {
            lsts = 2;
            errh_Error(
                "sect_Alloc: open O_CREATE | O_EXCL failed errno: %d", errno);
            break;
          } else {
            *created = 1;
          }
        } else {
          lsts = 2;
          errh_Error("sect_Alloc: open failed errno: %d", errno);
          break;
        }
      }

      /* Get shm key */
      shm_key = ftok(shp->name, 'P');
      close(shm_fd);

      /* Create shm section */
      shm_id = shmget(shm_key, size, IPC_CREAT | 0660);
      if (shm_id == -1) {
        lsts = 2;
        errh_Error("sect_Alloc: Couldn't attach/create shm section size: %d. "
                   "Check shmmax.",
            size);
        break;
      }

      shp->base = shmat(shm_id, (void*)NULL, 0);
      if (shp->base == (void*)-1) {
        if (*created)
          unlink(shp->name);
        lsts = 2;
        errh_Error("sect_Alloc: shmat failed");
        break;
      }

      shp->size = size;
      shp->flags.b.mapped = 1;
      lsts = 1;
    }

    if (*created)
      errh_Info(
          "Mapped %s, base: %x, size: %d", shp->name, shp->base, shp->size);

    pwr_Return(shp, sts, lsts);
  } while (0);

  /* Something went wrong, clean up!  */

  if (lshp != NULL)
    free(lshp);
  pwr_Return(NULL, sts, lsts);
}

/* Unmap a shared memory section.  */

pwr_tBoolean sect_Free(pwr_tStatus* sts, sect_sHead* shp)
{
  pwr_tStatus lsts;

  if (!shp->flags.b.mapped)
    pwr_Return(FALSE, sts, 4 /*SECT__NOTMAPPED*/);

  lsts = 1; /* TODO ? */

  if (ODD(lsts))
    shp->flags.b.mapped = 0;

  pwr_Return(ODD(lsts), sts, lsts);
}

/* Initialize a shared memory lock.  */

pwr_tBoolean sect_InitLock(pwr_tStatus* sts, sect_sHead* shp, sect_sMutex* mp)
{
  pwr_tStatus lsts = 1;

  if (posix_sem_init_shared(mp, ftok(shp->name, 'P'), 1) != 0) {
    errh_Error("sect_InitLock: sem_init(%s), errno: %d", shp->name, errno);
    lsts = 2;
  }

  errh_ReturnOrBugcheck(ODD(lsts), sts, lsts, "");
}

/* Lock a shared memory section.  */

pwr_tBoolean sect_Lock(pwr_tStatus* sts, sect_sHead* shp, sect_sMutex* mp)
{
  pwr_tStatus lsts = 1;

  while (posix_sem_wait(mp) != 0) {
    if (errno != EINTR) {
      if (errno == EINVAL) {
        _exit(-1);
      }
      perror("sect_Lock: sem_wait ");
      lsts = 2;
      break;
    }
  }

  errh_ReturnOrBugcheck(ODD(lsts), sts, lsts, "");
}

/* Unlock a shared memory section.  */

pwr_tBoolean sect_Unlock(pwr_tStatus* sts, sect_sHead* shp, sect_sMutex* mp)
{
  pwr_tStatus lsts = 1;

  if (posix_sem_post(mp) != 0) {
    perror("sect_Unlock: sem_signal ");
    lsts = 2;
  }

  errh_ReturnOrBugcheck(ODD(lsts), sts, lsts, "");
}
