/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_plc_dirlink.c
   This module contains all routines to handle direct linking
   for the PLC-program.  */

#include "co_cdh.h"
#include "co_string.h"

#include "rt_gdh_msg.h"
#include "rt_hash_msg.h"
#include "rt_ini_msg.h"
#include "rt_plc_msg.h"
#include "rt_plc.h"
#include "rt_plc_ioarea.h"

#define GUARD_DL(_PTR, _SIZE) /* Do nothing */

/* Setup Direct links or subscriptions

      local_object I	TRUE if object is local
             class I	Class of object to directlink
             objid I	Object to directlink
                la I	Direct link array from the plc-code
           aname I	Attribute name string

*/

static pwr_tStatus plc_RefObjidAttr(pwr_tBoolean local_object,
    pwr_tClassId class, pwr_sAttrRef ar, plc_t_rtdbref* la, char* aname)
{
  pwr_tStatus sts;
  pwr_tDlid dlid;
  pwr_tSubid subid;
  pwr_sAttrRef car;

  if (!streq(aname, "")) {
    sts = gdh_ClassAttrToAttrref(class, aname, &car);
    if (EVEN(sts))
      return sts;

    ar.Offset += car.Offset;
    ar.Size = car.Size;
    ar.Flags.m = car.Flags.m;
  }
  if (ar.Size < la->Size)
    ar.Size = la->Size;

  if (local_object) {
    sts = gdh_DLRefObjectInfoAttrref(&ar, la->Pointer, &dlid);
    if (EVEN(sts))
      return sts;
  } else {
    sts = gdh_SubRefObjectInfoAttrref(&ar, &subid);
    if (EVEN(sts))
      return sts;

    sts = gdh_SubAssociateBuffer(subid, la->Pointer, ar.Size);
    if (EVEN(sts))
      return sts;
  }

  return PLC__SUCCESS;
}

/* Get the value of an attribute in an object
   The objid must be a local object

    If 'class' is zero use objid */

static pwr_tStatus plc_GetObjectAttrValue(pwr_tClassId class,
    pwr_sAttrRef attrref, char* aname, void* buffer, pwr_tInt32 size)
{
  pwr_tStatus sts;
  pwr_sAttrRef ar;
  char* p;

  if (class == 0) {
    sts = gdh_GetObjectClass(attrref.Objid, &class);
    if (EVEN(sts))
      return sts;
  }

  sts = gdh_ClassAttrToAttrref(class, aname, &ar);
  if (EVEN(sts))
    return sts;

  sts = gdh_ObjidToPointer(attrref.Objid, (pwr_tAddress*)&p);
  if (EVEN(sts))
    return sts;

  memcpy(buffer, p + attrref.Offset + ar.Offset, size);

  return PLC__SUCCESS;
}

/* Return a pointer to an object or parameter in
   rtdb. This pointer is used to help the PLC code speed
   up it's access of objects and parameters in rtdb

   If the object type is a type that stores its actual values
   in an I/O-copy object, then if the name that is passed to
   plc_DirectLink ends with ".ActualValue", then we want to
   return the pointer to an element in an I/O-copy object

   On the other hand, if the name doesn't end with ".ActualValue",
   then we return a pointer to start of the single rtdb object.  */

pwr_tStatus plc_rtdbref(plc_t_rtdbref (*LinkArray)[], plc_sThread* tp)
{
  pwr_tStatus sts;
  pwr_tInt32 Index = 0;
  char aname[255];
  plc_t_rtdbref* la;
  pwr_tClassId class;
  pwr_tBoolean local_object;

  for (la = *LinkArray; la->Pointer != NULL; ++la) {
    /* NULL pointer terminates the list */
    *la->Pointer = NULL;

    sts = gdh_GetObjectLocation(la->AttrRef.Objid, &local_object);
    if (EVEN(sts)) {
      local_object = FALSE;
    }

    if (la->UseCode == UC_NORMAL) {
      /* If we got here, we can link directly to the object without having
         to append an index to the entered name.  */

      sts = plc_RefObjidAttr(local_object, la->ObjType, la->AttrRef, la, "");
      if (EVEN(sts)) {
        errh_Error("plc_RefObjidAttr object %s, %m",
            cdh_ObjidToString(la->AttrRef.Objid, 0), sts);
        GUARD_DL(la->Pointer, la->Size);
        continue;
      }
    } else {
      /* We're direct linking to a parameter in a Area-object.
         These parameters are stored in a std::vector. We have to find
         out the index in the std::vector before we can direct link. The
         index is stored in the object itself.  */

      if (local_object) {
        switch (la->ObjType) {
        case pwr_cClass_Di:
        case pwr_cClass_Ai:
        case pwr_cClass_Ii:
        case pwr_cClass_Do:
        case pwr_cClass_Ao:
        case pwr_cClass_Io:
        case pwr_cClass_Dv:
        case pwr_cClass_Av:
        case pwr_cClass_Iv:
        case pwr_cClass_Co:
        case pwr_cClass_ATv:
        case pwr_cClass_DTv:
        case pwr_cClass_Sv:
          sts = plc_GetObjectAttrValue(la->ObjType, la->AttrRef, ".ValueIndex",
              &Index, sizeof(pwr_tInt32));
          if (EVEN(sts)) {
            errh_Error("plc_GetObjectAttrValue object %s.ValueIndex\n%m",
                cdh_ObjidToString(la->AttrRef.Objid, 0), sts);
            GUARD_DL(la->Pointer, la->Size);
            continue;
          }
          break;
        default: {
          /* Bi or Bo, get value, get valueindex later */
        }
        }
      }

      /* Get the address to the correct element (indicated by Index) in the
        correct object, and store the value in Pointer.  */

      strcpy(aname, ".ActualValue");
      class = la->ObjType;
      switch (la->ObjType) {
      case pwr_cClass_Di:
        if (la->UseCode == UC_READ && local_object)
          *la->Pointer = &tp->copy.di_a.p->Value[Index];
        break;

      case pwr_cClass_Ai:
        if (la->UseCode == UC_READ && local_object)
          *la->Pointer = &tp->copy.ai_a.p->Value[Index];
        break;

      case pwr_cClass_Ii:
        if (la->UseCode == UC_READ && local_object)
          *la->Pointer = &tp->copy.ii_a.p->Value[Index];
        break;

      case pwr_cClass_Do:
        if (la->UseCode == UC_READ && local_object)
          *la->Pointer = &tp->copy.do_a.p->Value[Index];
        break;

      case pwr_cClass_Ao:
        if (la->UseCode == UC_READ && local_object)
          *la->Pointer = &tp->copy.ao_a.p->Value[Index];
        break;

      case pwr_cClass_Io:
        if (la->UseCode == UC_READ && local_object)
          *la->Pointer = &tp->copy.io_a.p->Value[Index];
        break;

      case pwr_cClass_Dv:
        if (la->UseCode == UC_READ && local_object)
          *la->Pointer = &tp->copy.dv_a.p->Value[Index];
        break;

      case pwr_cClass_Av:
        if (la->UseCode == UC_READ && local_object)
          *la->Pointer = &tp->copy.av_a.p->Value[Index];
        break;

      case pwr_cClass_Iv:
        if (la->UseCode == UC_READ && local_object)
          *la->Pointer = &tp->copy.iv_a.p->Value[Index];
        break;

      case pwr_cClass_ATv:
        if (la->UseCode == UC_READ && local_object)
          *la->Pointer = &tp->copy.atv_a.p->Value[Index];
        break;

      case pwr_cClass_DTv:
        if (la->UseCode == UC_READ && local_object)
          *la->Pointer = &tp->copy.dtv_a.p->Value[Index];
        break;

      case pwr_cClass_Sv:
        if (la->UseCode == UC_READ && local_object)
          *la->Pointer = &tp->copy.sv_a.p->Value[Index];
        break;

      /* Special: UC_READ => AbsValue, UC_READ2 => RawValue */
      case pwr_cClass_Co:
        if (local_object) {
          if (la->UseCode == UC_READ) {
            *la->Pointer = &tp->copy.ca_a.p->Value[Index];
          } else if (la->UseCode == UC_READ2) {
            *la->Pointer = &tp->copy.co_a.p->Value[Index];
          } else if (la->UseCode == UC_WRITE) {
            strcpy(aname, ".AbsValue");
          } else {
            strcpy(aname, ".RawValue");
          }
        } else {
          if (la->UseCode == UC_READ)
            strcpy(aname, ".AbsValue");
          else
            strcpy(aname, ".RawValue");
        }
        break;
      default: {
        pwr_tCid scid;
        pwr_tAttrRef oaref;

        /* Get ValueIndex that is sibling attribute to the attrref */
        sts = gdh_AttrArefToObjectAref(&la->AttrRef, &oaref);
        if (ODD(sts))
          sts = plc_GetObjectAttrValue(
              la->ObjType, oaref, ".ValueIndex", &Index, sizeof(pwr_tInt32));
        if (EVEN(sts)) {
          errh_Error("plc_GetObjectAttrValue object %s.ValueIndex\n%m",
              cdh_ObjidToString(la->AttrRef.Objid, 0), sts);
          GUARD_DL(la->Pointer, la->Size);
          continue;
        }

        /* Bi or Bo subclass */
        sts = gdh_GetSuperClass(la->ObjType, &scid, pwr_cNOid);
        if (EVEN(sts))
          break;

        switch (scid) {
        case pwr_cClass_Bi:
          if (la->UseCode == UC_READ && local_object)
            *la->Pointer = (char*)&tp->copy.bi_a.p->Value[Index] + la->Offset;
          break;
        case pwr_cClass_Bo:
          if (la->UseCode == UC_READ && local_object)
            *la->Pointer = (char*)&tp->copy.bo_a.p->Value[Index] + la->Offset;
          break;
        }
        strcpy(aname, "");
      }
      }

      if (*la->Pointer != NULL)
        continue;

      sts = plc_RefObjidAttr(local_object, class, la->AttrRef, la, aname);
      if (EVEN(sts)) {
        pwr_tDisableAttr disabled;
        pwr_tStatus sts1;

        sts1 = gdh_ArefDisabled(&la->AttrRef, &disabled);
        if (EVEN(sts1) || !disabled)
          errh_Error("plc_RefObjidAttr(oid:%s,aname:%s) , %m",
              cdh_AttrRefToString(&la->AttrRef, 0), aname, sts);
        GUARD_DL(la->Pointer, la->Size);
        continue;
      }
    }
  }

  return PLC__SUCCESS;
}

/* Get a pointer to an object in rtdb. I the object doesn't exist,
   then we create the object in order to be able to get the pointer.
   A direct link is made to the object.  */

void plc_GetPointerToObject(pwr_tAddress* Pointer, char* Name,
    pwr_tSubid* Subid, pwr_tObjid* Objid, pwr_tInt32 Type, pwr_tInt32 Size)
{
  pwr_tStatus sts;

  /* Only handle object if BaseValue object > 0 bytes */
  if (Size == 0)
    return;

  sts = gdh_NameToObjid(Name, Objid);
  if (ODD(sts)) {
    sts = gdh_RefObjectInfo(Name, Pointer, Subid, Size);
    if (EVEN(sts))
      errh_Error("gdh_RefObjectInfo(%s), %m", Name, sts);
    return;
  }

  /* The object either doesn't exist, or we have an error.  */
  if (sts != GDH__NOSUCHOBJ && sts != HASH__NOTFOUND) {
    errh_Error("Getting pointer to object (%s), %m", Name, sts);
    return;
  }

  /* Create the object with the same size as the
     basevalue object for this object type. However, if the XXBaseValueSize
     equals 0, then there aren't any objects of this type used on this
     node, and therefore we don't create or link to a copy object. No
     use creating objects if they won't be used.  */

  sts = gdh_CreateObject(Name, Type, Size, Objid, pwr_cNObjid, 0, pwr_cNObjid);
  if (EVEN(sts)) {
    errh_Error("Creating object (%s), %m", Name, sts);
  } else {
    /* Make a direct link to the object */
    sts = gdh_RefObjectInfo(Name, Pointer, Subid, Size);
    if (EVEN(sts))
      errh_Error("Direct link to object (%s), %m", Name, sts);
  }
}
