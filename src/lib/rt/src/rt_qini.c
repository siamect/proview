/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_qini.c -- Queue Communication, initiation  */

#include <stdlib.h>

#include "co_string.h"

#include "rt_errh.h"
#include "rt_qini.h"
#include "rt_net.h"
#include "rt_ini_alias.h"

static qdb_sNode* addNode(qini_sNode* nep)
{
  pwr_tStatus sts;
  qdb_sNode* np;

  np = qdb_AddNode(&sts, nep->nid, 0);
  if (np == NULL)
    return NULL;

  strcpy(np->link[0].name, nep->name);
  strncpy(
      np->nidstr, cdh_NodeIdToString(0, nep->nid, 0, 0), sizeof(np->nidstr));
  np->sa.sin_family = AF_INET;
  np->sa.sin_addr.s_addr = nep->naddr.s_addr;
  if (nep->flags.b.port)
    np->sa.sin_port = htons(nep->port);
  else
    np->sa.sin_port = htons(55000 + qdb->g->bus);

  memcpy(&np->link[0].arp.arp_pa.sa_data, &np->link[0].sa.sin_addr.s_addr,
      sizeof(np->link[0].sa.sin_addr.s_addr));

  np->link[0].sa.sin_family = AF_INET;
  if (nep->port)
    np->link[0].sa.sin_port = nep->port;
  else
    np->link[0].sa.sin_port = htons(55000 + qdb->g->bus);
  np->link[0].sa.sin_addr.s_addr = nep->naddr.s_addr;
  np->link[0].connection = nep->connection;
  np->link[0].min_resend_time = nep->min_resend_time;
  np->link[0].max_resend_time = nep->max_resend_time;
  np->link[0].export_buf_quota = nep->export_buf_quota;
  np->link[0].ack_delay = nep->ack_delay;
  np->link[0].seg_size = nep->seg_size;
  np->link_cnt++;

  np->is_secondary = nep->is_secondary;
  if (!streq(nep->secondary_name, "")) {
    strcpy(np->link[1].name, nep->secondary_name);
    np->link[1].sa.sin_family = AF_INET;
    if (nep->port)
      np->link[1].sa.sin_port = nep->port;
    else
      np->link[1].sa.sin_port = htons(55000 + qdb->g->bus);
    np->link[1].sa.sin_addr.s_addr = nep->secondary_naddr.s_addr;
    np->link_cnt++;
  }

  return np;
}

static qdb_sQue* addQueue(
    qdb_sAppl* ap, qcom_tQix qix, char* name, qdb_eQue type, pwr_tBitMask flags)
{
  pwr_tStatus sts;
  qcom_sQid qid;
  qdb_sQue* qp;

  qid.nid = qdb->g->nid;
  qid.qix = qix;
  qp = qdb_AddQue(&sts, qix);
  if (qp == NULL)
    errh_Bugcheck(sts, "qdb_AddQue(&sts, &qid)");
  qp->type = type;
  qp->flags.m = flags;
  strcpy(qp->name, name);

  if (qp->flags.b.broadcast) {
    qdb_AddBond(&sts, qp, qdb->exportque);
  }

  if (ap != NULL) {
    pool_QinsertPred(&sts, &qdb->pool, &qp->que_ll, &ap->que_lh);
    qp->aid = ap->aid;
  }

  return qp;
}

int qini_ParseFile(
    FILE* f, tree_sTable* ntp, int* warnings, int* errors, int* fatals)
{
  pwr_tStatus sts = 1;
  int n, n2;
  char* s;
  char buffer[256];
  int error = 0;
  char name[80];
  char s_nid[80];
  char s_naddr[80];
  char s_port[80];
  char s_connection[10];
  char s_min_resend_time[20];
  char s_max_resend_time[20];
  char s_export_buf_quota[20];
  char s_ack_delay[20];
  char s_seg_size[20];
  char s_is_secondary[20];
  char secondary_name[80];
  char s_secondary_naddr[80];
  char alias[80];
  char alias_naddr[80];
  pwr_tNodeId nid;
  struct in_addr naddr;
  qini_sNode* nep;
  struct arpreq arpreq;

  while ((s = fgets(buffer, sizeof(buffer) - 1, f)) != NULL) {
    if (*s == '#' || *s == '!') {
      s++;
      continue;
    }

    n = sscanf(s, "%s %s %s %s %s %s %s %s %s %s %s %s %s", name, s_nid,
        s_naddr, s_port, s_connection, s_min_resend_time, s_max_resend_time,
        s_export_buf_quota, s_ack_delay, s_seg_size, s_is_secondary,
        secondary_name, s_secondary_naddr);
    if (n < 3) {
      errh_Error("error in line, <wrong number of arguments>, skip to next "
                 "line.\n>> %s",
          s);
      (*errors)++;
      continue;
    }

    sts = ini_GetAlias(name, alias, alias_naddr);
    if (ODD(sts)) {
      strcpy(name, alias);
      strcpy(s_naddr, alias_naddr);
    }

    sts = cdh_StringToVolumeId(s_nid, (pwr_tVolumeId*)&nid);
    if (EVEN(sts)) {
      errh_Error(
          "error in line, <node identity>, skip to next line.\n>> %s", s);
      (*errors)++;
      continue;
    }

    sts = net_StringToAddr(s_naddr, &naddr);
    if (EVEN(sts)) {
      errh_Error(
          "error in line, <network address>, skip to next line.\n>> %s", s);
      (*errors)++;
      continue;
    }

    nep = tree_Find(&sts, ntp, &nid);
    if (nep != NULL) {
      errh_Warning("node is already defined: %s, skip to next line", s);
      (*warnings)++;
      continue;
    } else {
      nep = tree_Insert(&sts, ntp, &nid);
    }

    strcpy(nep->name, name);
    nep->naddr.s_addr = htonl(naddr.s_addr);
    if (n > 3)
      nep->port = htons(atoi(s_port));
    if (n > 4)
      nep->connection = atoi(s_connection);
    if (n > 5)
      nep->min_resend_time = atoi(s_min_resend_time);
    if (n > 6)
      nep->max_resend_time = atoi(s_max_resend_time);
    if (n > 7)
      nep->export_buf_quota = atoi(s_export_buf_quota);
    else
      nep->export_buf_quota = 600000;
    if (n > 8) {
      n2 = sscanf(s_ack_delay, "%f", &nep->ack_delay);
      if (n2 != 1)
        nep->ack_delay = 0.001;
    } else
      nep->ack_delay = 0.001;
    if (n > 9) {
      nep->seg_size = atoi(s_seg_size);
      if (nep->seg_size == 0)
        nep->seg_size = 8192;
    } else
      nep->seg_size = 8192;

    if (n > 8)
      nep->is_secondary = atoi(s_is_secondary);

    if (n > 9 && !streq(secondary_name, "-"))
      strcpy(nep->secondary_name, secondary_name);

    if (n > 10 && !streq(s_secondary_naddr, "-")) {
      sts = net_StringToAddr(s_secondary_naddr, &naddr);
      nep->secondary_naddr.s_addr = htonl(naddr.s_addr);
      if (EVEN(sts)) {
        errh_Error(
            "error in line, <network address>, skip to next line.\n>> %s", s);
        (*errors)++;
        continue;
      }
    }

    memset(&arpreq, 0, sizeof(arpreq));
    memcpy(&arpreq.arp_pa.sa_data, &naddr, sizeof(naddr));
    inet_GetArpEntry(&sts, 0, &arpreq);
  }

  return error;
}

pwr_tBoolean qini_BuildDb(pwr_tStatus* sts, tree_sTable* nodes, qini_sNode* me,
    void* cp, qcom_tBus bus)
{
  qdb_sInit init;
  qdb_sNode* np;
  qini_sNode* nep;
  void* p;
  qdb_sAppl* ap;

  memset(&init, 0, sizeof(init));

  init.nid = me->nid;
  init.bus = bus;
  init.nodes = nodes->nNode;

  p = qdb_CreateDb(sts, &init);
  if (p == NULL)
    return NO;

  qdb_ScopeLock
  {
    for (nep = tree_Minimum(sts, nodes); nep != NULL;
         nep = tree_Successor(sts, nodes, nep)) {
      np = addNode(nep);
    }

    ap = qdb_AddAppl(NULL, YES);

    qdb->exportque = addQueue(
        NULL, qdb_cIexport, "export", qdb_eQue_private, qdb_mQue_system);
    addQueue(
        ap, qcom_cInetEvent, "netEvent", qdb_eQue_forward, qdb_mQue_system);
    addQueue(
        ap, qcom_cIapplEvent, "applEvent", qdb_eQue_forward, qdb_mQue_system);
    addQueue(ap, qcom_cImhAllHandlers, "allHandlers", qdb_eQue_forward,
        qdb_mQue_broadcast);
    addQueue(ap, qcom_cImhAllOutunits, "allOutunits", qdb_eQue_forward,
        qdb_mQue_broadcast);
    addQueue(
        ap, qcom_cIhdServer, "hdServer", qdb_eQue_forward, qdb_mQue_broadcast);
    addQueue(
        ap, qcom_cIhdClient, "hdClient", qdb_eQue_forward, qdb_mQue_broadcast);
#if !defined OS_CYGWIN
    addQueue(NULL, qcom_cInacp, "nacp", qdb_eQue_private, qdb_mQue_system);
#endif
    addQueue(ap, qcom_cIini, "ini", qdb_eQue_forward,
        qdb_mQue_system | qdb_mQue_event);
  }
  qdb_ScopeUnlock;

  return (YES);
}
