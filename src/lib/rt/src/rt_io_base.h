/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#ifndef rt_io_base_h
#define rt_io_base_h

/* rt_io_base.h -- includefile for io base. */

#ifdef __cplusplus
extern "C" {
#endif

typedef struct io_sCtx* io_tCtx;

#include "rt_io_methods.h"
#include "rt_io_supervise.h"

#ifndef NULL
#define NULL (void*)0
#endif

#define io_cLibDummy -9999
#define IO_CHANLIST_SIZE 250

#define FIXOUT 2
#define IO_REBOOT 1 /* Reboot the machine */

extern pwr_tBoolean io_writeerr;
extern pwr_tBoolean io_readerr;
extern pwr_tBoolean io_fatal_error;

typedef enum {
  io_eType_Node,
  io_eType_Agent,
  io_eType_Rack,
  io_eType_Card
} io_eType;

typedef enum {
  io_mAction_None = 0,
  io_mAction_Read = 1 << 0,
  io_mAction_Write = 1 << 1,
  io_mAction_Swap = 1 << 2
} io_mAction;

typedef enum {
  io_mProcess_None = 0,
  io_mProcess_Plc = 1 << 0,
  io_mProcess_IoComm = 1 << 1,
  io_mProcess_Profibus = 1 << 2,
  io_mProcess_User = 1 << 3,
  io_mProcess_User2 = 1 << 4,
  io_mProcess_User3 = 1 << 5,
  io_mProcess_User4 = 1 << 6,
  io_mProcess_Powerlink = 1 << 7,
  io_mProcess_All = ~0
} io_mProcess;

typedef enum {
  io_eEvent_EmergencyBreak,
  io_eEvent_IoCommEmergencyBreak,
  io_eEvent_IoCommSwapInit,
  io_eEvent_IoCommSwap
} io_eEvent;

typedef struct {
  void* cop; /* Pointer to channel object */
  pwr_tDlid ChanDlid; /* Dlid for pointer to channel */
  pwr_sAttrRef ChanAref; /* AttrRef for channel */
  void* sop; /* Pointer to signal object */
  pwr_tDlid SigDlid; /* Dlid for pointer to signal */
  pwr_sAttrRef SigAref; /* AttrRef for signal */
  void* vbp; /* Pointer to valuebase for signal */
  void* abs_vbp; /* Pointer to absvaluebase (Co only) */
  pwr_tClassId ChanClass; /* Class of channel object */
  pwr_tClassId SigClass; /* Class of signal object */
  pwr_tUInt32 size; /* Size of channel in byte */
  pwr_tUInt32 offset; /* Offset to channel in card */
  pwr_tUInt32 mask; /* Mask for bit oriented channels */
  pwr_eType SigType; /* Type of buffer signal */
  pwr_tUInt32 SigElem; /* Elements of buffer array signal */
  pwr_tUInt32 SigStrSize; /* Size of buffer signal element */
  pwr_tUInt32 udata; /* User defined data */
} io_sChannel;

typedef struct s_Card {
  pwr_tClassId Class; /* Class of card object */
  pwr_tObjid Objid; /* Objid of card object */
  pwr_tOName Name; /* Full name of card object */
  io_mAction Action; /* Type of method defined (Read/Write)*/
  io_mProcess Process; /* Process number */
  pwr_tStatus (*Init)(); /* Init method */
  pwr_tStatus (*Close)(); /* Close method */
  pwr_tStatus (*Read)(); /* Read method */
  pwr_tStatus (*Write)(); /* Write method */
  pwr_tStatus (*Swap)(); /* Swap method */
  pwr_tAddress* op; /* Pointer to card object */
  pwr_tDlid Dlid; /* Dlid for card object pointer */
  pwr_tUInt32 size; /* Size of card data area in byte */
  pwr_tUInt32 offset; /* Offset to card data area in rack */
  int scan_interval; /* Interval between scans */
  int scan_interval_cnt; /* Counter to detect next time to scan */
  int AgentControlled; /* TRUE if kontrolled by agent */
  int ChanListSize; /* Size of chanlist */
  io_sChannel* chanlist; /* Array of channel structures */
  void* Local; /* Pointer to method defined data structure */
  int MethodDisabled; /* Card method disabled */
  struct s_Card* next; /* Next card */
} io_sCard;

typedef struct s_Rack {
  pwr_tClassId Class; /* Class of rack object */
  pwr_tObjid Objid; /* Objid of rack object */
  pwr_tOName Name; /* Full name of rack object */
  io_mAction Action; /* Type of method defined (Read/Write)*/
  io_mProcess Process; /* Process number */
  pwr_tStatus (*Init)(); /* Init method */
  pwr_tStatus (*Close)(); /* Close method */
  pwr_tStatus (*Read)(); /* Read method */
  pwr_tStatus (*Write)(); /* Write method */
  pwr_tStatus (*Swap)(); /* Swap method */
  void* op; /* Pointer to rack object */
  pwr_tDlid Dlid; /* Dlid för rack object pointer */
  pwr_tUInt32 size; /* Size of rack data area in byte */
  pwr_tUInt32 offset; /* Offset to rack data area in agent */
  int scan_interval; /* Interval between scans */
  int scan_interval_cnt; /* Counter to detect next time to scan */
  int AgentControlled; /* TRUE if kontrolled by agent */
  io_sCard* cardlist; /* List of card structures */
  void* Local; /* Pointer to method defined data structure */
  int MethodDisabled; /* Rack method disabled */
  struct s_Rack* next; /* Next rack */
} io_sRack;

typedef struct s_Agent {
  pwr_tClassId Class; /* Class of agent object */
  pwr_tObjid Objid; /* Objid of agent object */
  pwr_tOName Name; /* Full name of agent object */
  io_mAction Action; /* Type of method defined (Read/Write)*/
  io_mProcess Process; /* Process number */
  pwr_tStatus (*Init)(); /* Init method */
  pwr_tStatus (*Close)(); /* Close method */
  pwr_tStatus (*Read)(); /* Read method */
  pwr_tStatus (*Write)(); /* Write method */
  pwr_tStatus (*Swap)(); /* Swap method */
  void* op; /* Pointer to agent object */
  pwr_tDlid Dlid; /* Dlid for agent object pointer */
  int scan_interval; /* Interval between scans */
  int scan_interval_cnt; /* Counter to detect next time to scan */
  io_sRack* racklist; /* List of rack structures */
  void* Local; /* Pointer to method defined data structure */
  struct s_Agent* next; /* Next agent */
} io_sAgent;

struct io_sCtx {
  io_sAgent* agentlist; /* List of agent structures */
  io_mProcess Process; /* Callers process number */
  pwr_tObjid Thread; /* Callers thread objid */
  int RelativVector; /* Used by plc */
  pwr_sNode* Node; /* Pointer to node object */
  pwr_sClass_IOHandler* IOHandler; /* Pointer to IO Handler object */
  float ScanTime; /* Scantime supplied by caller */
  io_tSupCtx SupCtx; /* Context for supervise object lists */
  int read_reset; /* Reset pending read buffers */
};

/*----------------------------------------------------------------------------*\
  Io functions
\*----------------------------------------------------------------------------*/

void io_DiUnpackWord(
    io_sCard* cp, pwr_tUInt16 data, pwr_tUInt16 mask, int index);

void io_DoPackWord(io_sCard* cp, pwr_tUInt16* data, int index);

pwr_tStatus io_init(io_mProcess process, pwr_tObjid thread, io_tCtx* ctx,
    int relativ_vector, float scan_time);

pwr_tStatus io_init_swap(io_mProcess process, pwr_tObjid thread, io_tCtx* ctx,
    int relativ_vector, float scan_time);

pwr_tStatus io_read(io_tCtx ctx);

pwr_tStatus io_write(io_tCtx ctx);

pwr_tStatus io_swap(io_tCtx ctx, io_eEvent event);

pwr_tStatus io_close(io_tCtx ctx);

pwr_tStatus io_AiRangeToCoef(io_sChannel* chanp);

pwr_tStatus io_BiRangeToCoef(io_sChannel* chanp);

pwr_tStatus io_AoRangeToCoef(io_sChannel* chanp);

pwr_tStatus io_BoRangeToCoef(io_sChannel* chanp);

void io_ConvertAi(
    pwr_sClass_ChanAi* cop, pwr_tInt16 rawvalue, pwr_tFloat32* actvalue_p);

void io_ConvertAi32(
    pwr_sClass_ChanAi* cop, pwr_tInt32 rawvalue, pwr_tFloat32* actvalue_p);

void io_ConvertAit(
    pwr_sClass_ChanAit* cop, pwr_tInt16 rawvalue, pwr_tFloat32* actvalue_p);

pwr_tStatus io_init_signals(void);

pwr_tStatus io_get_iohandler_object(
    pwr_sClass_IOHandler** ObjPtr, pwr_tObjid* oid);

pwr_tStatus io_GetIoTypeClasses(
    io_eType type, pwr_tClassId** classes, int* size);

int io_CheckClassIoType(io_eType type, pwr_tCid cid);

void io_methods_print();

#ifdef __cplusplus
}
#endif

#endif
