/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2012 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

#ifndef rt_io_base_h
#define rt_io_base_h

/* rt_io_base.h -- includefile for io base. */

#ifndef pwr_h
#include "pwr.h"
#endif

#ifndef pwr_class_h
#include "pwr_class.h"
#endif

#ifndef PWR_BASECLASSES_H
#include "pwr_baseclasses.h"
#endif

#ifdef __cplusplus
extern "C"
{
#endif

typedef struct io_sCtx *io_tCtx;

#ifndef rt_io_supervise_h
#include "rt_io_supervise.h"
#endif

#ifndef rt_io_methods_h
#include "rt_io_methods.h"
#endif

#ifndef NULL
#define NULL (void *) 0
#endif


#define io_cLibDummy -9999
#define IO_CHANLIST_SIZE 250

#define FIXOUT 2
#define IO_REBOOT       1       /* Reboot the machine */

extern  pwr_tBoolean io_writeerr;
extern  pwr_tBoolean io_readerr;
extern  pwr_tBoolean io_fatal_error;


typedef enum {
  io_eType_Node,
  io_eType_Agent,
  io_eType_Rack,
  io_eType_Card
} io_eType;

typedef enum {
  io_mAction_None      	= 0,
  io_mAction_Read      	= 1 << 0,
  io_mAction_Write	= 1 << 1,
  io_mAction_Swap      	= 1 << 2
} io_mAction;

typedef enum {
  io_mProcess_None	= 0,
  io_mProcess_Plc      	= 1 << 0,
  io_mProcess_IoComm	= 1 << 1,
  io_mProcess_Profibus 	= 1 << 2,
  io_mProcess_User	= 1 << 3,
  io_mProcess_User2	= 1 << 4,
  io_mProcess_User3	= 1 << 5,
  io_mProcess_User4	= 1 << 6,
  io_mProcess_All      	= ~0
} io_mProcess;

typedef enum {
  io_eEvent_EmergencyBreak,
  io_eEvent_IoCommEmergencyBreak,
  io_eEvent_IoCommSwapInit,
  io_eEvent_IoCommSwap
} io_eEvent;

typedef struct {
  void		*cop;		/* Pointer to channel object */
  pwr_tDlid	ChanDlid;	/* Dlid for pointer to channel */
  pwr_sAttrRef	ChanAref;	/* AttrRef for channel */
  void		*sop;		/* Pointer to signal object */
  pwr_tDlid	SigDlid;	/* Dlid for pointer to signal */
  pwr_sAttrRef	SigAref;	/* AttrRef for signal */
  void		*vbp;		/* Pointer to valuebase for signal */
  void		*abs_vbp;	/* Pointer to absvaluebase (Co only) */
  pwr_tClassId	ChanClass;	/* Class of channel object */
  pwr_tClassId	SigClass;	/* Class of signal object */
  pwr_tUInt32	size;		/* Size of channel in byte */
  pwr_tUInt32	offset;		/* Offset to channel in card */
  pwr_tUInt32	mask;		/* Mask for bit oriented channels */
  pwr_eType	SigType;	/* Type of buffer signal */
  pwr_tUInt32	SigElem;	/* Elements of buffer array signal */
  pwr_tUInt32	SigStrSize;	/* Size of buffer signal element */
  pwr_tUInt32   udata;       	/* User defined data */
} io_sChannel;
	

typedef struct s_Card {
  pwr_tClassId	Class;		/* Class of card object */
  pwr_tObjid	Objid;		/* Objid of card object */
  pwr_tOName	Name;		/* Full name of card object */
  io_mAction	Action;		/* Type of method defined (Read/Write)*/
  io_mProcess	Process;	/* Process number */
  pwr_tStatus	(* Init) ();	/* Init method */
  pwr_tStatus	(* Close) ();	/* Close method */
  pwr_tStatus	(* Read) ();	/* Read method */
  pwr_tStatus	(* Write) ();	/* Write method */
  pwr_tStatus	(* Swap) ();	/* Swap method */
  pwr_tAddress	*op;		/* Pointer to card object */
  pwr_tDlid	Dlid;		/* Dlid for card object pointer */
  pwr_tUInt32	size;		/* Size of card data area in byte */
  pwr_tUInt32	offset;		/* Offset to card data area in rack */
  int		scan_interval;	/* Interval between scans */
  int		scan_interval_cnt;/* Counter to detect next time to scan */
  int		AgentControlled;/* TRUE if kontrolled by agent */
  int		ChanListSize;	/* Size of chanlist */
  io_sChannel	*chanlist; 	/* Array of channel structures */
  void		*Local;		/* Pointer to method defined data structure */
  int		MethodDisabled;	/* Card method disabled */
  struct s_Card	*next;		/* Next card */
} io_sCard;

typedef struct s_Rack {
  pwr_tClassId	Class;		/* Class of rack object */
  pwr_tObjid	Objid;		/* Objid of rack object */
  pwr_tOName	Name;		/* Full name of rack object */
  io_mAction	Action;		/* Type of method defined (Read/Write)*/
  io_mProcess	Process;	/* Process number */
  pwr_tStatus	(* Init) ();	/* Init method */
  pwr_tStatus	(* Close) ();	/* Close method */
  pwr_tStatus	(* Read) ();	/* Read method */
  pwr_tStatus	(* Write) ();	/* Write method */
  pwr_tStatus	(* Swap) ();	/* Swap method */
  void		*op;		/* Pointer to rack object */
  pwr_tDlid	Dlid;		/* Dlid för rack object pointer */
  pwr_tUInt32	size;		/* Size of rack data area in byte */
  pwr_tUInt32	offset;		/* Offset to rack data area in agent */
  int		scan_interval;	/* Interval between scans */
  int		scan_interval_cnt;/* Counter to detect next time to scan */
  int		AgentControlled;/* TRUE if kontrolled by agent */
  io_sCard	*cardlist;	/* List of card structures */
  void		*Local;		/* Pointer to method defined data structure */
  int		MethodDisabled; /* Rack method disabled */
  struct s_Rack	*next;		/* Next rack */
} io_sRack;

typedef struct s_Agent {
  pwr_tClassId	Class;		/* Class of agent object */
  pwr_tObjid	Objid;		/* Objid of agent object */
  pwr_tOName	Name;		/* Full name of agent object */ 
  io_mAction	Action;		/* Type of method defined (Read/Write)*/
  io_mProcess	Process;	/* Process number */
  pwr_tStatus	(* Init) ();	/* Init method */
  pwr_tStatus	(* Close) ();	/* Close method */
  pwr_tStatus	(* Read) ();	/* Read method */
  pwr_tStatus	(* Write) ();	/* Write method */
  pwr_tStatus	(* Swap) ();	/* Swap method */
  void		*op;		/* Pointer to agent object */
  pwr_tDlid	Dlid;		/* Dlid for agent object pointer */
  int		scan_interval;	/* Interval between scans */
  int		scan_interval_cnt;/* Counter to detect next time to scan */
  io_sRack	*racklist;	/* List of rack structures */
  void		*Local;		/* Pointer to method defined data structure */
  struct s_Agent *next;		/* Next agent */
} io_sAgent;

struct io_sCtx {
  io_sAgent	*agentlist;	/* List of agent structures */
  io_mProcess	Process;	/* Callers process number */
  pwr_tObjid    Thread;         /* Callers thread objid */
  int		RelativVector;	/* Used by plc */
  pwr_sNode	*Node;		/* Pointer to node object */
  pwr_sClass_IOHandler	*IOHandler;		/* Pointer to IO Handler object */
  float		ScanTime;	/* Scantime supplied by caller */
  io_tSupCtx	SupCtx;		/* Context for supervise object lists */
};

/*----------------------------------------------------------------------------*\
  Io functions
\*----------------------------------------------------------------------------*/

void io_DiUnpackWord( 
  io_sCard	*cp,
  pwr_tUInt16	data,
  pwr_tUInt16	mask,
  int		index
);

void io_DoPackWord( 
  io_sCard	*cp,
  pwr_tUInt16	*data,
  int		index
);

pwr_tStatus io_init( 
  io_mProcess	process,
  pwr_tObjid    thread,
  io_tCtx 	*ctx,
  int		relativ_vector,
  float		scan_time
);

pwr_tStatus io_init_swap( 
  io_mProcess	process,
  pwr_tObjid    thread,
  io_tCtx 	*ctx,
  int		relativ_vector,
  float		scan_time
);

pwr_tStatus io_read(
  io_tCtx 	ctx
);

pwr_tStatus io_write(
  io_tCtx 	ctx
);

pwr_tStatus io_swap(
  io_tCtx 	ctx,
  io_eEvent	event
);

pwr_tStatus io_close(
  io_tCtx 	ctx
);

pwr_tStatus io_AiRangeToCoef( 
  io_sChannel 	*chanp
);

pwr_tStatus io_BiRangeToCoef( 
  io_sChannel 	*chanp
);

pwr_tStatus io_AoRangeToCoef( 
  io_sChannel 	*chanp
);

pwr_tStatus io_BoRangeToCoef( 
  io_sChannel 	*chanp
);

void io_ConvertAi (
  pwr_sClass_ChanAi  *cop,
  pwr_tInt16	      rawvalue,
  pwr_tFloat32	      *actvalue_p
);

void io_ConvertAi32 (
  pwr_sClass_ChanAi  *cop,
  pwr_tInt32	      rawvalue,
  pwr_tFloat32	      *actvalue_p
);

void io_ConvertAit (
  pwr_sClass_ChanAit  *cop,
  pwr_tInt16	      rawvalue,
  pwr_tFloat32	      *actvalue_p
);

pwr_tStatus io_init_signals( 
  void
);

pwr_tStatus io_get_iohandler_object (
  pwr_sClass_IOHandler	**ObjPtr,
  pwr_tObjid *oid
);

pwr_tStatus io_GetIoTypeClasses( 
  io_eType	type,
  pwr_tClassId 	**classes,
  int		*size
);

int io_CheckClassIoType( 
  io_eType	type,
  pwr_tCid 	cid
);

void io_methods_print();

#ifdef __cplusplus
}
#endif

#endif
