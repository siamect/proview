/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <errno.h>
#include <float.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "co_errno.h"
#include "co_time.h"
#include "rt_errh.h"
#include "rt_thread.h"
#include "rt_thread_msg.h"

#ifndef pwr_baseclasses_h
#include "pwr_baseclasses.h"
#endif

#define SCHED_DEADLINE 6

/* XXX use the proper syscall numbers */
#ifdef __x86_64__
#define __NR_sched_setattr 314
#define __NR_sched_getattr 315
#endif
#ifdef __i386__
#define __NR_sched_setattr 351
#define __NR_sched_getattr 352
#endif
#ifdef __arm__
#define __NR_sched_setattr 380
#define __NR_sched_getattr 381
#endif

struct sched_attr {
  uint32_t size;

  uint32_t sched_policy;
  uint64_t sched_flags;

  /* SCHED_NORMAL, SCHED_BATCH */
  int32_t sched_nice;

  /* SCHED_FIFO, SCHED_RR */
  uint32_t sched_priority;

  /* SCHED_DEADLINE (nsec) */
  uint64_t sched_runtime;
  uint64_t sched_deadline;
  uint64_t sched_period;
};

int sched_setattr(pid_t pid, const struct sched_attr* attr, unsigned int flags)
{
  return syscall(__NR_sched_setattr, pid, attr, flags);
}

int sched_getattr(
    pid_t pid, struct sched_attr* attr, unsigned int size, unsigned int flags)
{
  return syscall(__NR_sched_getattr, pid, attr, size, flags);
}

pwr_tStatus thread_CondInit(thread_sCond* cp)
{
  pthread_condattr_t attr;
  pthread_condattr_init(&attr);
  pthread_condattr_setclock(&attr, CLOCK_MONOTONIC);
  return errno_Status(pthread_cond_init(&cp->c, &attr));
}

pwr_tStatus thread_MutexInit(thread_sMutex* mp)
{
  return errno_Status(pthread_mutex_init(mp, NULL));
}

pwr_tStatus thread_MutexLock(thread_sMutex* mp)
{
  return errno_Status(pthread_mutex_lock(mp));
}

pwr_tStatus thread_MutexUnlock(thread_sMutex* mp)
{
  return errno_Status(pthread_mutex_unlock(mp));
}

pwr_tStatus thread_Cancel(thread_s* tp)
{
  return errno_Status(pthread_cancel(*tp));
}

pwr_tStatus thread_Create(
    thread_s* tp, char* name, void* (*routine)(), void* arg)
{
  pthread_attr_t attr;

  pthread_attr_init(&attr);
  pthread_attr_setinheritsched(&attr, PTHREAD_INHERIT_SCHED);

  return errno_Status(pthread_create(tp, &attr, routine, arg));
}

pwr_tStatus thread_CondWait(thread_sCond* cp, thread_sMutex* mp)
{
  pwr_tStatus sts = THREAD__SUCCESS;

  cp->f = 0;

  while (!cp->f) {
    sts = errno_Status(pthread_cond_wait(&cp->c, mp));
    if (sts != ERRNO__INTR)
      break;
  }
  return cp->f ? THREAD__SUCCESS : sts;
}

pwr_tStatus thread_CondTimedWait(
    thread_sCond* cp, thread_sMutex* mp, pwr_tDeltaTime* time)
{
  {
    pwr_tTime now;
    pwr_tTime then;
    struct timespec then_ts;

    cp->f = 0;

    if (time == NULL || time->tv_sec > 100000000)
      return thread_CondWait(cp, mp);

    time_GetTimeMonotonic(&now);
    time_Aadd(&then, &now, time);
    then_ts.tv_sec = then.tv_sec;
    then_ts.tv_nsec = then.tv_nsec;

    return errno_Status(pthread_cond_timedwait(&cp->c, mp, &then_ts));
  }
}

pwr_tStatus thread_CondSignal(thread_sCond* cp)
{
  cp->f = 1;

  return errno_Status(pthread_cond_signal(&cp->c));
}

pwr_tStatus thread_Wait(pwr_tDeltaTime* tp)
{
  pwr_tStatus sts = THREAD__SUCCESS;
  pwr_tDeltaTime time = { 999999999, 0 };

  if (tp == NULL)
    tp = &time;

  if ((int)tp->tv_sec > 0 || ((int)tp->tv_sec == 0 && tp->tv_nsec > 0)) {
    struct timespec rmt;
    struct timespec ttime = { 9999999, 0 };
    struct timespec ts;

    if (tp == &time) {
      int i;
      for (i = 0; i < 100; i++)
        sts = errno_Pstatus(nanosleep(&ttime, &rmt));
    } else {
      ts.tv_sec = tp->tv_sec;
      ts.tv_nsec = tp->tv_nsec;
      sts = errno_Pstatus(nanosleep(&ts, &rmt));
    }
  }

  return sts;
}

pwr_tStatus thread_SetPrio(thread_s* tp, int prio)
{
  {
    pthread_t tid;
    struct sched_param par;

    /* Set priority and scheduling mechanism for thread. */
    tid = pthread_self();
    prio = MIN(sched_get_priority_max(SCHED_FIFO),
        sched_get_priority_min(SCHED_FIFO) + prio);
    par.sched_priority = prio;
    return errno_Status(pthread_setschedparam(tid, SCHED_FIFO, &par));
  }
}

uint64_t toNs(float f)
{
  return ((uint64_t)f * 1000 * 1000 * 1000);
}

pwr_tStatus thread_SetDeadline(pwr_sClass_PlcThread* o)
{
  {
    pthread_t tid;
    struct sched_attr attr;

    /* Set priority and scheduling mechanism for thread. */
    tid = pthread_self();
    attr.size = sizeof(attr);
    attr.sched_flags = 0;
    attr.sched_nice = 0;
    attr.sched_priority = 0;

    attr.sched_policy = SCHED_DEADLINE;
    attr.sched_runtime
        = (o->Max > o->ScanTimeMax) ? toNs(o->Max) : toNs(o->ScanTimeMax);
    attr.sched_period = toNs(o->ScanTime);
    if (attr.sched_runtime > attr.sched_period) {
      fprintf(stderr, "Warning! PLC thread %s has a period %" PRIu64
                      " ms shorter than its WCET %" PRIu64 " ms\n",
          o->Description, attr.sched_period / (1000 * 1000),
          attr.sched_runtime / (1000 * 1000));
    }
    if (o->Deadline > FLT_EPSILON) {
      attr.sched_deadline = toNs(o->Deadline);
    } else {
      attr.sched_deadline = toNs(o->ScanTime);
    }

    int ret = sched_setattr(tid, &attr, 0);
    if (ret != 0) {
      fprintf(stderr, "sched_setattr returned %d\n", ret);
    }
    return errno_Status(ret);
  }
}
