/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_mh_outunit.c -- Out unit */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "co_cdh.h"
#include "co_string.h"
#include "co_time.h"

#include "rt_mh_log.h"
#include "rt_mh_util.h"
#include "rt_qcom_msg.h"

typedef struct s_Ack sAck;
typedef struct s_Block sBlock;
typedef struct s_Handler sHandler;

struct s_Ack {
  struct LstHead ack_l;
  mh_sOutunitAck ack;
};

struct s_Block {
  struct LstHead block_l;
  mh_sOutunitBlock block;
};

struct s_Handler {
  struct LstHead handler_l;
  struct LstHead sync_l;
  pwr_tTime birthTime; /* Time when handler started */
  qcom_sQid qid; /* Qcom queue of handler */
  qcom_sAid aid; /* Qcom application id */
  co_sPlatform platform; /* Platform identity */
  pwr_tNodeIndex nix; /* Node index of handler */
  struct LstHead ack_l; /* Head to ack list */
  pwr_tUInt32 ackGen; /* Ack generation */
  struct LstHead block_l; /* Head to block list */
  pwr_tUInt32 blockGen; /* Block generation */
  pwr_tBoolean isDummy;
  pwr_tBoolean linkUp;
  pwr_tUInt32 selGen;
  pwr_tUInt32 eventGen;
  pwr_tUInt32 eventIdx; /* Index of last received event from handler */
};

typedef struct {
  mh_sHead head;
  mh_eOutunitType type; /* Type of outunit */
  pwr_tBoolean isConnected;
  mh_mOutunitFlags flags;
  int timeout;
  int tempTimeout;
  pwr_tStatus (*cbAck)(mh_sAck*);
  pwr_tStatus (*cbAlarm)(mh_sMessage*);
  pwr_tStatus (*cbBlock)(mh_sBlock*);
  pwr_tStatus (*cbCancel)(mh_sReturn*);
  pwr_tStatus (*cbClearAlarmList)(pwr_tNodeIndex);
  pwr_tStatus (*cbClearBlockList)(pwr_tNodeIndex);
  pwr_tStatus (*cbInfo)(mh_sMessage*);
  pwr_tStatus (*cbReturn)(mh_sReturn*);
  pwr_tStatus (*cbAlarmStatus)(mh_sAlarmStatus*);
  struct LstHead handler_l;
  struct LstHead sync_l;
  pwr_tUInt32 selGen;
  pwr_tUInt32 selSize;
  pwr_tString80 (*pSelL)[];
  pwr_mEventTypeMask* pSelEventType;
  mh_sSelL selL[mh_cSelLSize];
  pwr_mEventTypeMask selEventType;
  pwr_tBoolean* SelectListIsUpdated;
} sContext;

/* Local variables */

static sContext l;

/* Local function prototypes */

static void msgFromV3(mh_sHead* hp);
static void ackListDelete(sHandler*, sAck*);
static void ackListDestroy(sHandler*);
static void ackListInsert(sHandler*, pwr_tUInt32);
static void blockListDelete(sHandler*, sBlock*);
static void blockListDestroy(sHandler*);
static void blockListInsert(sHandler*, pwr_tObjid*, pwr_tUInt32);
static void checkSync();
static void checkSyncListDelete(sHandler*);
static void checkSyncReply(sHandler*);
static pwr_tStatus enableQcomAllOutunits();
static pwr_tStatus enableQcomEvents();
static void fromHandler(mh_sHead*, int, qcom_sAid*);
static void fromQcom(qcom_sGet*);
static void getSelectList();
static void handlerEvent(sHandler*, mh_sHead*);
static void handlerLog(sHandler*, char*);
static void handlerSync(sHandler*, mh_sHead*);
static void handlerAlarmStatus(sHandler*, mh_sHead*);
static pwr_tBoolean isValidHandler(mh_sHead*, qcom_sAid*, sHandler**);
static void linkDown(qcom_sNode*);
static void linkUp(qcom_sNode*);
static void procDown(qcom_sAid*);
static void sendInfo(sHandler*);
static pwr_tStatus sendToHandler(sHandler*, mh_eMsg, unsigned int, void*);

/**
 *@brief Informs all Handlers known to this Outunit that the
 * message with identity TargetId is acknowleged.
 */

pwr_tStatus mh_OutunitAck(mh_sEventId* targetId /**< The identity of an alarm.*/
    )
{
  pwr_tStatus sts = MH__SUCCESS;
  sHandler* hp;
  struct LstHead * hl;

  /* Find originating handler */

  LstForEach(hl, &l.handler_l)
    if (LstEntry(hl, sHandler, handler_l)->nix == targetId->Nix)
      break;

  if (hl == &l.handler_l) {
    return MH__HANDLERDOWN;
  } else {
    hp = LstEntry(hl, sHandler, handler_l);
  }

  ackListInsert(hp, targetId->Idx);

  return sts;
}

/**
 * @brief Send a block request. Prio == 0 -> unblock.
 */

pwr_tStatus mh_OutunitBlock(
    pwr_tObjid object, /**< The identity of an object to be blocked. */
    mh_eEventPrio prio /**< The priority to block. */
    )
{
  pwr_tStatus sts;
  sHandler* hp;
  struct LstHead * hl;
  pwr_tNodeIndex nix;
  pwr_tBoolean is_mount_clean;

  /* Find corresponding handler */

  sts = gdh_GetObjectNodeIndex(object, &nix);
  if (EVEN(sts))
    return sts;

  LstForEach(hl, &l.handler_l) {
    if (!hl)
      return MH__HANDLERDOWN;

    if (LstEntry(hl, sHandler, handler_l)->nix == nix)
      break;
  }

  if (hl == &l.handler_l) {
    return MH__HANDLERDOWN;
  } else {
    hp = LstEntry(hl, sHandler, handler_l);
  }

  blockListInsert(hp, &object, prio);

  sts = gdh_IsMountClean(object, &is_mount_clean);
  if (ODD(sts) && !is_mount_clean)
    return MH__NOTMNTCLEAN;

  return MH__SUCCESS;
}

/**
 *@brief Connects this Outunit to the local Handler.
 *@return pwr_tStatus
 */

pwr_tStatus mh_OutunitConnect(
    pwr_tObjid outunit, /**< Object identity of an outunit object.*/
    mh_eOutunitType type, /**< Type of outunit. */
    mh_mOutunitFlags flags, /**< ZZZ */
    mh_cbOutunitAck
        cbAck, /**< Address of a function to receive aknowledge messages.*/
    mh_cbOutunitAlarm cbAlarm, /**< Address of a function to receive alarm
                                  messages messages.*/
    mh_cbOutunitBlock
        cbBlock, /**< Address of a function to receive blocking messages.*/
    mh_cbOutunitCancel
        cbCancel, /**< Address of a function to receive cancel messages.*/
    mh_cbOutunitClearAlarmList cbClearAlarmList, /**< Address of a function to
                                                    clear alarm list from alarms
                                                      generated by the node. */
    mh_cbOutunitClearBlockList cbClearBlockList, /**< Address of a function to
                                                    clear block list from blocks
                                                      generated by the node.*/
    mh_cbOutunitInfo
        cbInfo, /**< Address of a function to receive info messages. */
    mh_cbOutunitReturn cbReturn, /**< Address of a function to receive alarm
                                    return messages. */
    mh_cbOutunitAlarmStatus
        cbAlarmStatus /**< Address of a function to receive alarm status
                         messages. */
    )
{
  pwr_tStatus sts;
  pwr_tObjid* p;
  pwr_tClassId cid;
  qcom_sNode myNode;
  qcom_sQattr qAttr;
  int i;
  sHandler* hp;
  char name[80];

  sprintf(name, "Outunit_%X", outunit.oix);

  mh_UtilWaitForMh();

  if (l.isConnected)
    return MH__ALLRCON;

  /* Check Outunit object */

  memset(&l, 0, sizeof(l));

  if (type == mh_eOutunitType_Logger) {
    l.SelectListIsUpdated = NULL;
  } else {
    sts = gdh_GetObjectClass(outunit, &cid);
    if (EVEN(sts))
      return sts;
    sts = gdh_ObjidToPointer(outunit, (pwr_tAddress*)&p);
    if (EVEN(sts))
      return sts;

    switch (cid) {
    case pwr_cClass_User:
      type = mh_eOutunitType_Operator;
      l.pSelL = (void*)&((pwr_sClass_User*)p)->SelectList[0];
      l.SelectListIsUpdated
          = (pwr_tBoolean*)&((pwr_sClass_User*)p)->SelectListIsUpdated;
      break;
    case pwr_cClass_OpPlace:
      type = mh_eOutunitType_Operator;
      l.pSelL = (void*)&((pwr_sClass_OpPlace*)p)->EventSelectList[0];
      l.pSelEventType = &((pwr_sClass_OpPlace*)p)->EventSelectType;
      l.SelectListIsUpdated
          = (pwr_tBoolean*)&((pwr_sClass_OpPlace*)p)->SelectListIsUpdated;
      break;
    case pwr_cClass_WebHandler:
      type = mh_eOutunitType_Operator;
      l.pSelL = (void*)&((pwr_sClass_WebHandler*)p)->EventSelectList[0];
      l.pSelEventType = &((pwr_sClass_WebHandler*)p)->EventSelectType;
      l.SelectListIsUpdated = NULL;
      break;
    case pwr_cClass_WebSocketServer:
      type = mh_eOutunitType_Operator;
      l.pSelL = (void*)&((pwr_sClass_WebSocketServer*)p)->EventSelectList[0];
      l.pSelEventType = &((pwr_sClass_WebSocketServer*)p)->EventSelectType;
      l.SelectListIsUpdated = NULL;
      break;
    case pwr_cClass_RttConfig:
      type = mh_eOutunitType_Operator;
      l.pSelL = (void*)&((pwr_sClass_RttConfig*)p)->EventSelectList[0];
      l.SelectListIsUpdated = NULL;
      break;
    case pwr_cClass_EventPrinter:
      type = mh_eOutunitType_Printer;
      l.pSelL = (void*)&((pwr_sClass_EventPrinter*)p)->SelectList[0];
      l.SelectListIsUpdated = NULL;
      break;
    case pwr_cClass_PostConfig:
      type = mh_eOutunitType_Post;
      l.pSelL = (void*)&((pwr_sClass_PostConfig*)p)->EventSelectList[0];
      l.SelectListIsUpdated = NULL;
      break;
    case pwr_cClass_SevHistEvents:
      type = mh_eOutunitType_SevHistEvents;
      l.pSelL = (void*)&((pwr_sClass_SevHistEvents*)p)->EventSelectList[0];
      l.pSelEventType = &((pwr_sClass_SevHistEvents*)p)->EventSelectType;
      l.SelectListIsUpdated = NULL;
      break;
    default:
      return MH__NOOUTUNIT;
    }
  }

  l.head.ver = mh_cVersion;

  l.head.qid = qcom_cNQid;

  qAttr.type = qcom_eQtype_private;
  qAttr.quota = 100;
  if (!qcom_CreateQ(&sts, &l.head.qid, &qAttr, name)) {
    errh_Error("mh_OutunitConnect: Failed to create QCOM que\n%m", sts);
    return MH__QCOMCREQ;
  }

  qcom_MyNode(&sts, &myNode);
  l.head.platform.os = myNode.os;
  l.head.platform.hw = myNode.hw;

  l.head.source = mh_eSource_Outunit;
  net_GetTime(&l.head.birthTime);
  l.head.outunit = outunit;
  sts = gdh_GetNodeIndex(&l.head.nix);
  if (EVEN(sts))
    return sts;
  l.type = type;
  l.flags = flags;
  l.timeout = flags == mh_mOutunitFlags_ReadWait ? -1 : 0;
  l.tempTimeout = l.timeout;
  l.cbAck = cbAck;
  l.cbAlarm = cbAlarm;
  l.cbBlock = cbBlock;
  l.cbCancel = cbCancel;
  l.cbClearAlarmList = cbClearAlarmList;
  l.cbClearBlockList = cbClearBlockList;
  l.cbInfo = cbInfo;
  l.cbReturn = cbReturn;
  l.cbAlarmStatus = cbAlarmStatus;

  LstInit(&l.handler_l);
  LstInit(&l.sync_l);

  for (i = 0; i < 5; i++) {
    hp = (sHandler*)calloc(1, sizeof(*hp));
    hp->isDummy = TRUE;
    LstInsert(&l.sync_l, &hp->sync_l);
  }

  getSelectList();

  sts = enableQcomEvents();
  if (EVEN(sts))
    return sts;
  sts = enableQcomAllOutunits();
  if (EVEN(sts))
    return sts;

  sts = sendToHandler(NULL, mh_eMsg_OutunitHello, 0, NULL);
  if (EVEN(sts))
    return sts;
  l.isConnected = TRUE;

  return MH__SUCCESS;
}

/**
 *@brief Inform all Handlers known to this Outunit, to remove
 * this Outunit from their list of known out units.
 *
 * The Outunit context block local to the mh_Outunit
 * interface will be cleared.
 *@return pwr_tStatus
 */

pwr_tStatus mh_OutunitDisconnect()
{
  sHandler* hp;
  struct LstHead * hl;

  /* Disconnect all handlers and free memory */

  for (hl = l.handler_l.next; hl != &l.handler_l; hl = l.handler_l.next) {
    hp = LstEntry(hl, sHandler, handler_l);
    sendToHandler(hp, mh_eMsg_OutunitDisconnect, 0, NULL);
    ackListDestroy(hp);
    blockListDestroy(hp);
    LstRemove(hl);
    LstNull(hl);
    free(hp);
  }

  l.isConnected = FALSE;
  return MH__SUCCESS;
}

/**
 *@brief Receive next messages in Queue.
 *@return pwr_tStatus
 */

pwr_tStatus mh_OutunitReceive()
{
  pwr_tStatus sts;
  static char mp[8000];
  mh_sHead* hp;
  qcom_sGet msg;
  XDR xdrs;

  /* If SelectListIsUpdated is set, the outunit will be updated */
  if (l.type == mh_eOutunitType_Operator && l.SelectListIsUpdated
      && *l.SelectListIsUpdated) {
    *l.SelectListIsUpdated = 0;
    mh_OutunitUpdate();
  }

  msg.data = mp;
  msg.maxSize = sizeof(mp);
  qcom_Get(&sts, &l.head.qid, &msg, l.tempTimeout);
  l.tempTimeout = l.timeout;
  if (sts == QCOM__QEMPTY) {
    checkSync();
    return MH__NOMESSAVAIL;
  } else if (sts == QCOM__TMO) {
    checkSync();
    return MH__TMO;
  } else if (EVEN(sts)) {
    return MH__QCOMGETMSG;
  }

  switch ((int)msg.type.b) {
  case qcom_eBtype_qcom:
    fromQcom(&msg);
    break;

  case mh_cMsgClass:
    hp = (mh_sHead*)mp;
    if (hp->xdr) {
      xdrmem_create(&xdrs, (char*)hp, msg.size, XDR_DECODE);
      sts = mh_NetXdrMessage(&xdrs, msg.type.s, hp);
      if (EVEN(sts))
        return sts;
    }
    fromHandler(hp, msg.size, &msg.sender);
    break;
  default:
    break;
  }

  return MH__SUCCESS;
}

/**
 *@brief Sets the timeout time in ms for mh_OutunitReceive.
 *
 * This routine must be called before mh_OutunitReceive.
 * An negative number means wait forever
 *@return pwr_tStatus
 */
pwr_tStatus mh_OutunitSetTimeout(int timeout /**< The timeout in ms. */
    )
{
  l.timeout = timeout;
  return MH__SUCCESS;
}

/**
 *@brief Inform all event monitors known to this outunit,
 * that the select list is changed.
 *@return pwr_tStatus
 */

pwr_tStatus mh_OutunitUpdate()
{
  struct LstHead * hl;

  getSelectList();

  LstForEach(hl, &l.handler_l)
    sendInfo(LstEntry(hl, sHandler, handler_l));

  return MH__SUCCESS;
}

/**
 *@brief Request info about missing alarms.
 *@return pwr_tStatus
 */

pwr_tStatus mh_OutunitAlarmRequest(mh_sOutunitAlarmReq* msg)
{
  sHandler* hp;
  struct LstHead * hl;

  /* Find originating handler */

  LstForEach(hl, &l.handler_l)
    if (LstEntry(hl, sHandler, handler_l)->nix == msg->Nix)
      break;

  if (hl == &l.handler_l) {
    return MH__HANDLERDOWN;
  } else {
    hp = LstEntry(hl, sHandler, handler_l);
  }

  sendToHandler(hp, mh_eMsg_OutunitAlarmReq, sizeof(*msg), (void*)msg);

  return MH__SUCCESS;
}

static void ackListDelete(sHandler* hp, sAck* ap)
{
  LstRemove(&ap->ack_l);
  LstNull(&ap->ack_l);
  free(ap);

  checkSyncListDelete(hp);
}

static void ackListDestroy(sHandler* hp)
{
  sAck* ap;
  struct LstHead * al;

  for (al = hp->ack_l.next; al != &(hp->ack_l); al = hp->ack_l.next) {
    ap = LstEntry(al, sAck, ack_l);
    LstRemove(al);
    LstNull(al);
    free(ap);
  }

  hp->ackGen = 0;
  checkSyncListDelete(hp);
}

static void ackListInsert(sHandler* hp, pwr_tUInt32 targetIdx)
{
  sAck* ap;
  struct LstHead * al;

  /* Don't insert if already present */
  LstForEach(al, &hp->ack_l)
    if (LstEntry(al, sAck, ack_l)->ack.targetIdx == targetIdx)
      return;

  ap = (sAck*)calloc(1, sizeof(*ap));
  ap->ack.ackGen = ++hp->ackGen;
  ap->ack.targetIdx = targetIdx;
  al = &hp->ack_l;
  LstInsert(al, &ap->ack_l);

  if (LstIsNull(&hp->sync_l)) {
    LstInsert(&l.sync_l, &hp->sync_l);
  }

  if (ap == LstEntry(hp->ack_l.next, sAck, ack_l)) {
    sendToHandler(hp, mh_eMsg_OutunitAck, sizeof(ap->ack), (void*)&ap->ack);
  }
}

static void blockListDelete(sHandler* hp, sBlock* bp)
{
  LstRemove(&bp->block_l);
  LstNull(&bp->block_l);
  free(bp);

  checkSyncListDelete(hp);
}

static void blockListDestroy(sHandler* hp)
{
  sBlock* bp;
  struct LstHead * bl;

  LstForEach(bl, &hp->block_l) {
    bp = LstEntry(bl, sBlock, block_l);
    LstRemove(bl);
    LstNull(bl);
    free(bp);
  }

  hp->blockGen = 0;
  checkSyncListDelete(hp);
}

static void blockListInsert(sHandler* hp, pwr_tObjid* op, pwr_tUInt32 prio)
{
  sBlock* bp;
  struct LstHead * bl;

  bp = (sBlock*)calloc(1, sizeof(*bp));
  bp->block.blockGen = ++hp->blockGen;
  bp->block.object = *op;
  bp->block.outunit = l.head.outunit;
  bp->block.prio = prio;
  bl = &hp->block_l;
  LstInsert(bl, &bp->block_l);

  if (LstIsNull(&hp->sync_l)) {
    LstInsert(&l.sync_l, &hp->sync_l);
  }

  if (bp == LstEntry(hp->block_l.next, sBlock, block_l)) {
    sendToHandler(
        hp, mh_eMsg_OutunitBlock, sizeof(bp->block), (void*)&bp->block);
  }
}

static void checkSync()
{
  struct LstHead * sl;
  sHandler* hp;

  LstForEach(sl, &l.sync_l) {
    hp = LstEntry(sl, sHandler, sync_l);
    LstRemove(sl);
    LstInsert(&l.sync_l, &hp->sync_l);
    if (hp->isDummy)
      return;
    if (!hp->linkUp)
      return;
    // handlerLog(hp, "Sending sync");
    sendToHandler(hp, mh_eMsg_OutunitSync, 0, NULL);
  }
}

static void checkSyncListDelete(sHandler* hp)
{
  if (LstIsNull(&hp->sync_l))
    return;
  if (!LstEmpty(&hp->ack_l))
    return;
  if (!LstEmpty(&hp->block_l))
    return;
  if (hp->selGen != l.selGen)
    return;

  LstRemove(&hp->sync_l);
  LstNull(&hp->sync_l);
}

static void checkSyncReply(sHandler* hp)
{
  if (hp->selGen != l.selGen) {
    sendInfo(hp);
  } else if (!LstEmpty(&hp->block_l)) {
    sBlock* bp;

    bp = LstEntry(hp->block_l.next, sBlock, block_l);
    sendToHandler(
        hp, mh_eMsg_OutunitBlock, sizeof(bp->block), (void*)&bp->block);
  } else if (!LstEmpty(&hp->ack_l)) {
    sAck* ap;

    ap = LstEntry(hp->ack_l.next, sAck, ack_l);
    sendToHandler(hp, mh_eMsg_OutunitAck, sizeof(ap->ack), (void*)&ap->ack);
  }

  if (!LstIsNull(&hp->sync_l)) {
    LstRemove(&hp->sync_l);
    LstInsert(&l.sync_l, &hp->sync_l);
  }
}

static pwr_tStatus enableQcomAllOutunits()
{
  pwr_tStatus sts;
  qcom_sQid allOuQid = mh_cProcAllOutunits;

  if (!qcom_Bind(&sts, &l.head.qid, &allOuQid)) {
    errh_Error("EnableQcomAllOutunits: qcom_Bind failed, reason:\n%m", sts);
    return MH__QCOMBINDQ;
  }

  return MH__SUCCESS;
}

static pwr_tStatus enableQcomEvents()
{
  pwr_tStatus sts;
  qcom_sQid otherQue;

  otherQue = qcom_cQnetEvent;
  if (!qcom_Bind(&sts, &l.head.qid, &otherQue)) {
    errh_Error("EnableQcomEvents: Binding link que failed, reason:\n%m", sts);
    return MH__QCOMBINDQ;
  }

  otherQue = qcom_cQapplEvent;
  if (!qcom_Bind(&sts, &l.head.qid, &otherQue)) {
    errh_Error(
        "EnableQcomEvents: Binding process notify que failed, reason:\n%m",
        sts);
    return MH__QCOMBINDQ;
  }

  return MH__SUCCESS;
}

static void fromHandler(mh_sHead* p, int size, qcom_sAid* aid)
{
  sHandler* hp;

  if (!isValidHandler(p, aid, &hp))
    return;

  if (p->ver == 3)
    msgFromV3(p);

  switch (p->type) {
  case mh_eMsg_Event:
    handlerEvent(hp, p);
    handlerSync(hp, p);
    break;
  case mh_eMsg_HandlerSync:
    handlerSync(hp, p);
    sendToHandler(hp, mh_eMsg_Sync, 0, NULL);
    break;
  case mh_eMsg_Sync:
    handlerSync(hp, p);
    checkSyncReply(hp);
    break;
  case mh_eMsg_HandlerHello:
    if (hp->selGen != l.selGen)
      sendInfo(hp);
    break;
  case mh_eMsg_OutunitClear:
    if (l.cbClearAlarmList != NULL)
      l.cbClearAlarmList(hp->nix);
    break;
  case mh_eMsg_HandlerAlarmStatus:
    handlerAlarmStatus(hp, p);
    handlerSync(hp, p);
    break;
  default:
    errh_Warning("Received unhandled messagetype: %d", p->type);
    break;
  }
}

static void fromQcom(qcom_sGet* mp)
{
  switch (mp->type.s) {
  case qcom_eStype_applDisconnect:
    procDown(&((qcom_sAppl*)mp->data)->aid);
    break;
  case qcom_eStype_linkDisconnect:
    linkDown((qcom_sNode*)mp->data);
    break;
  case qcom_eStype_linkConnect:
    linkUp((qcom_sNode*)mp->data);
    break;
  default:
    break;
  }
}

static void getSelectList()
{
  int i;
  int j;
  int len;
  char* s;

  if (l.type == mh_eOutunitType_Logger) {
    l.selSize = 0;
    l.selGen = 1;
    return;
  }

  memset(&l.selL, 0, sizeof(l.selL));

  for (i = 0, j = 0; i < mh_cSelLSize; i++) {
    for (s = (*l.pSelL)[i], len = 0; !(*s == 0 || *s == 32 || *s == 9); s++)
      len++;
    len = MIN(len, sizeof(pwr_tString80));
    if (len == 0)
      continue;
    l.selL[j].len = len;
    strncpy(l.selL[j].objName, (*l.pSelL)[i], len);
    l.selL[j].objName[sizeof(pwr_tString80) - 1] = '\0';
    str_ToUpper(l.selL[j].objName, l.selL[j].objName);
    j++;
  }
  l.selSize = j;
  l.selGen++;

  if (l.pSelEventType)
    l.selEventType = *l.pSelEventType;
}

static void handlerEvent(sHandler* hp, mh_sHead* p)
{
  pwr_tStatus sts;
  mh_sMsgInfo* mp = (mh_sMsgInfo*)(p + 1);
  struct LstHead * al;
  mh_sAck* ap;
  mh_sReturn* cp;

  /* Skip events sent from an old select list. */
  if (p->selGen != l.selGen)
    return;

  if (hp->eventGen != p->eventGen) {
    /* This is the first event with a new select list. */
    if (l.cbClearAlarmList != NULL)
      l.cbClearAlarmList(hp->nix);
    if (l.cbClearBlockList != NULL)
      l.cbClearBlockList(hp->nix);
    hp->eventGen = p->eventGen;
  }

  hp->eventIdx = mp->Id.Idx;
  sendToHandler(hp, mh_eMsg_Sync, 0, NULL);

  if (l.tempTimeout == 0)
    l.tempTimeout = 100;

  switch (mp->EventType) {
  case mh_eEvent_Ack:
    /* Delete alarm from local ack list, if present */

    ap = (mh_sAck*)mp;

    LstForEach(al, &hp->ack_l)
      if (LstEntry(al, sAck, ack_l)->ack.targetIdx == ap->TargetId.Idx) {
        ackListDelete(hp, LstEntry(al, sAck, ack_l));
        break;
      }

    if (l.cbAck != NULL)
      l.cbAck(ap);
    break;
  case mh_eEvent_Alarm:
  case mh_eEvent_MaintenanceAlarm:
  case mh_eEvent_SystemAlarm:
  case mh_eEvent_UserAlarm1:
  case mh_eEvent_UserAlarm2:
  case mh_eEvent_UserAlarm3:
  case mh_eEvent_UserAlarm4:
    if (l.cbAlarm != NULL)
      sts = l.cbAlarm((mh_sMessage*)mp);
    break;
  case mh_eEvent_Block:
  case mh_eEvent_Unblock:
  case mh_eEvent_Reblock:
  case mh_eEvent_CancelBlock:
    if (l.cbBlock != NULL)
      sts = l.cbBlock((mh_sBlock*)mp);
    break;
  case mh_eEvent_Cancel:
    /* Delete alarm from local ack list, if present */

    cp = (mh_sReturn*)mp;

    LstForEach(al, &hp->ack_l)
      if (LstEntry(al, sAck, ack_l)->ack.targetIdx == cp->TargetId.Idx) {
        ackListDelete(hp, LstEntry(al, sAck, ack_l));
        break;
      }

    if (l.cbCancel != NULL)
      sts = l.cbCancel(cp);
    break;
  case mh_eEvent_Info:
  case mh_eEvent_InfoSuccess:
    if (l.cbInfo != NULL)
      sts = l.cbInfo((mh_sMessage*)mp);
    break;
  case mh_eEvent_Return:
    if (l.cbReturn != NULL)
      sts = l.cbReturn((mh_sReturn*)mp);
    break;
  default:
    errh_Warning("Received unknown event type", mp->EventType);
    break;
  }
}

static void handlerLog(sHandler* hp, char* s)
{
  errh_Info("%s, %s (%s)", s, qcom_NodeName(hp->qid.nid),
      qcom_QidToString(NULL, &hp->qid, 1));
}

static void handlerSync(sHandler* hp, mh_sHead* p)
{
  if (!LstEmpty(&hp->ack_l)) {
    sAck* ap;

    ap = LstEntry(hp->ack_l.next, sAck, ack_l);
    if (ap->ack.ackGen == p->ackGen)
      ackListDelete(hp, ap);
  }

  if (!LstEmpty(&hp->block_l)) {
    sBlock* bp;

    bp = LstEntry(hp->block_l.next, sBlock, block_l);
    if (bp->block.blockGen == p->blockGen)
      blockListDelete(hp, bp);
  }

  if (hp->selGen != l.selGen && p->selGen == l.selGen) {
    hp->selGen = l.selGen;
    checkSyncListDelete(hp);
  }
}

static void handlerAlarmStatus(sHandler* hp, mh_sHead* p)
{
  pwr_tStatus sts;
  mh_sAlarmStatus* mp = (mh_sAlarmStatus*)(p + 1);

  /* Skip events sent from an old select list. */
  if (p->selGen != l.selGen)
    return;

  if (l.cbAlarmStatus != NULL)
    sts = l.cbAlarmStatus(mp);
}

static pwr_tBoolean isValidHandler(mh_sHead* p, qcom_sAid* aid, sHandler** h)
{
  sHandler* hp;
  struct LstHead * hl;

  if (!(p->ver == mh_cVersion
          || (mh_cVersion == 5
                 && (p->ver == 3
                        || p->ver
                            == 4)))) { /* V5 is compatible with V3 and V4 */
    /* Different versions, not yet implemented */
    errh_Warning("Received a Message with different version: %d != %d", p->ver,
        mh_cVersion);
    *h = NULL;
    return FALSE;
  }

  /* Find handler in handler list */

  LstForEach(hl, &l.handler_l)
    if (LstEntry(hl, sHandler, handler_l)->qid.qix == p->qid.qix && LstEntry(hl, sHandler, handler_l)->qid.nid == p->qid.nid)
      break;

  if (hl == &l.handler_l) {
    /* Handler not known, make it known */
    hp = (sHandler*)calloc(1, sizeof(*hp));
    hp->birthTime = net_NetTimeToTime(&p->birthTime);
    hp->qid = p->qid;
    hp->aid = *aid;
    hp->platform = p->platform;
    hp->nix = p->nix;
    hp->linkUp = TRUE;
    LstInsert(&l.handler_l, &hp->handler_l);
    LstInit(&hp->ack_l);
    LstInit(&hp->block_l);
    handlerLog(hp, "New handler");
  } else {
    hp = LstEntry(hl, sHandler, handler_l);

    if (hp->birthTime.tv_sec != p->birthTime.tv_sec) {
      /* Different times, i.e. the handler is restarted */
      hp->birthTime = net_NetTimeToTime(&p->birthTime);
      hp->qid = p->qid;
      hp->aid = *aid;
      ackListDestroy(hp);
      blockListDestroy(hp);
      hp->linkUp = TRUE;
      hp->eventGen = 0;
      hp->eventIdx = 0;
      hp->selGen = 0;
      handlerLog(hp, "Restarted handler");
    }
  }

  *h = hp;
  return TRUE;
}

static void linkDown(qcom_sNode* nodep)
{
  struct LstHead * hl;
  sHandler* hp;

  LstForEach(hl, &l.handler_l)
    if (LstEntry(hl, sHandler, handler_l)->qid.nid == nodep->nid) {
      hp = LstEntry(hl, sHandler, handler_l);
      hp->linkUp = FALSE;
      handlerLog(hp, "Link down");
      return;
    }
}

static void linkUp(qcom_sNode* nodep)
{
  struct LstHead * hl;
  sHandler* hp;

  LstForEach(hl, &l.handler_l)
    if (LstEntry(hl, sHandler, handler_l)->qid.nid == nodep->nid) {
      hp = LstEntry(hl, sHandler, handler_l);
      hp->linkUp = TRUE;
      handlerLog(hp, "Link up");
      return;
    }
}

static void procDown(qcom_sAid* aid)
{
  sHandler* hp;
  struct LstHead * hl;

  LstForEach(hl, &l.handler_l) {
    hp = LstEntry(hl, sHandler, handler_l);
    if (hp->aid.aix == aid->aix && hp->aid.nid == aid->nid) {
      /* Delete this handler from handler list */
      handlerLog(hp, "Handler aborted");
      ackListDestroy(hp);
      blockListDestroy(hp);
      LstRemove(hl);
      LstNull(hl);
      free(hp);
      return;
    }
  }
}

static void sendInfo(sHandler* hp)
{
  pwr_tStatus sts;
  mh_sOutunitInfo* ip;
  char* mp;
  unsigned int size;

  size = sizeof(mh_sOutunitInfo) + l.selSize * sizeof(mh_sSelL);

  mp = calloc(1, size);
  if (mp == NULL)
    return;

  ip = (mh_sOutunitInfo*)mp;
  ip->type = (pwr_tUInt16)l.type;
  ip->selEventType = (pwr_tUInt16)l.selEventType;
  ip->selGen = l.selGen;
  ip->selSize = l.selSize;

  if (ip->selSize > 0)
    memcpy(ip + 1, &l.selL[0], ip->selSize * sizeof(mh_sSelL));

  sts = sendToHandler(hp, mh_eMsg_OutunitInfo, size, mp);

  free(mp);

  if (LstIsNull(&hp->sync_l)) {
    LstInsert(&l.sync_l, &hp->sync_l);
  }
}

static pwr_tStatus sendToHandler(
    sHandler* hp, mh_eMsg type, unsigned int size, void* bp)
{
  pwr_tStatus sts;
  char* mp;
  unsigned int msize = sizeof(l.head) + size;
  co_sPlatform* pfp;
  qcom_sQid qid;
  mh_sHead* p;

  mp = calloc(1, msize);

  memcpy(mp, &l.head, sizeof(l.head));
  p = (mh_sHead*)mp;
  p->type = type;

  if (size > 0)
    memcpy(mp + sizeof(l.head), bp, size);

  if (hp == NULL) {
    /* Send to all handlers */

    qid = mh_cProcAllHandlers;
    pfp = NULL;
  } else {
    p->eventGen = hp->eventGen;
    p->eventIdx = hp->eventIdx;
    qid = hp->qid;
    pfp = &hp->platform;
  }

  sts = mh_NetSendMessage(&qid, pfp, 0, 0, 0, (mh_sHead*)mp, msize);

  free(mp);
  if (ODD(sts))
    return sts;

  errh_Error("sendToHandler failed\n%m", sts);

  return sts;
}

static void msgFromV3(mh_sHead* hp)
{
  switch (hp->type) {
  case mh_eMsg_Event: {
    mh_sMsgInfo* ip = (mh_sMsgInfo*)(hp + 1);

    switch (ip->EventType) {
    case mh_eEvent_Ack: {
      mh_sAck* mp = (mh_sAck*)ip;

      mp->Object = cdh_ObjidToAref(ip->Object_V3);
      mp->SupObject = cdh_ObjidToAref(ip->SupObject_V3);
      strncpy(mp->EventName, ip->EventName_V3, sizeof(mp->EventName));
      break;
    }
    case mh_eEvent_Info:
    case mh_eEvent_Alarm:
    case mh_eEvent_MaintenanceAlarm:
    case mh_eEvent_SystemAlarm:
    case mh_eEvent_UserAlarm1:
    case mh_eEvent_UserAlarm2:
    case mh_eEvent_UserAlarm3:
    case mh_eEvent_UserAlarm4: {
      mh_sMessage* mp = (mh_sMessage*)ip;

      mp->Object = cdh_ObjidToAref(ip->Object_V3);
      mp->SupObject = cdh_ObjidToAref(ip->SupObject_V3);
      strncpy(mp->EventName, ip->EventName_V3, sizeof(mp->EventName));
      break;
    }
    case mh_eEvent_Block:
    case mh_eEvent_Unblock:
    case mh_eEvent_Reblock:
    case mh_eEvent_CancelBlock: {
      mh_sBlock* mp = (mh_sBlock*)ip;

      mp->Object = cdh_ObjidToAref(ip->Object_V3);
      mp->SupObject = cdh_ObjidToAref(ip->SupObject_V3);
      strncpy(mp->EventName, ip->EventName_V3, sizeof(mp->EventName));
      break;
    }
    case mh_eEvent_Return:
    case mh_eEvent_Cancel: {
      mh_sReturn* mp = (mh_sReturn*)ip;

      mp->Object = cdh_ObjidToAref(ip->Object_V3);
      mp->SupObject = cdh_ObjidToAref(ip->SupObject_V3);
      strncpy(mp->EventName, ip->EventName_V3, sizeof(mp->EventName));
      break;
    }
    default:;
    }
    break;
  }
  default:;
  }
}
