/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_bck_load.c
   This module contains the code for reading and
   restoring the information in the backup data file.  */

#include <stdlib.h>

#include <string.h>
#include <errno.h>

#include "pwr_baseclasses.h"
#include "rt_gdh.h"
#include "rt_gdh_msg.h"
#include "rt_bckdef.h"
#include "rt_bck_load.h"
#include "co_dcli.h"
#include "co_cdh.h"

#define SET_ERRNO_STS                                                          \
  perror("rt_bck_load");                                                       \
  sts = 2
#define A_MODE
#define FGETNAME backup_confp->BackupFile

/* Open the backup datafile, read the information and load it into rtdb.
   This should be done before bck_Init is invoked.  */

pwr_tStatus bck_LoadBackup()
{
  pwr_tStatus sts;
  pwr_tInt32 csts;
  pwr_tObjid objid;
  pwr_sClass_Backup_Conf* backup_confp = NULL; /* Backup_Conf object pointer */
  FILE* f;
  BCK_FILEHEAD_STRUCT fh; /* File header */
  BCK_CYCLEHEAD_STRUCT ch_old;
  bck_t_cycleheader ch;
  BCK_DATAHEAD_STRUCT dh_old;
  bck_t_writeheader dh;
  pwr_tUInt32 c;
  pwr_tUInt32 d;
  char* strp;
  char* datap = NULL;
  char* namep = NULL;
  char fname[200];
  pwr_tAName objectname;

  /* Find the local Backup_Conf object.  */

  sts = gdh_GetClassList(pwr_cClass_Backup_Conf, &objid);
  while (ODD(sts)) {
    sts = gdh_ObjidToPointer(objid, (pwr_tAddress*)&backup_confp);
    if (ODD(sts))
      break;
    sts = gdh_GetNextObject(objid, &objid);
  }
  if (EVEN(sts))
    return sts;

  /* Open the backup file.  */
  dcli_translate_filename(fname, backup_confp->BackupFile);

  f = fopen(fname, "r+" A_MODE);

  if (f == NULL) {
    SET_ERRNO_STS;
    errh_Error("Load Backup: Failed to open %s, errno = %d",
        backup_confp->BackupFile, sts);
    return sts;
  }

  errh_Info("BACKUP loading information from %s", FGETNAME);

  sts = 1; /* Guess all ok */

  /* Read the header.  */

  csts = fread(&fh, sizeof fh, 1, f);
  if (csts == 0) {
    SET_ERRNO_STS;
  } else {
    if (fh.version < BCK_FILE_VERSION - 1) {
      errh_Info("BACKUP Loading old file version : %d", fh.version);
      /* Read the cycle data.  */

      BCK_FILEHEAD_STRUCT_V6* fhp_v6 = (BCK_FILEHEAD_STRUCT_V6*)&fh;

      for (c = 0; c < 2; c++) {
        fseek(f, fhp_v6->curdata[c], 0);
        fread(&ch_old, sizeof ch_old, 1, f);

        /* Work thru the data segments */

        for (d = 0; d < ch_old.segments; d++) {
          csts = fread(&dh_old, sizeof dh_old, 1, f);
          if (csts != 0) {
            datap = malloc(dh_old.attrref.Size);
            csts = fread(datap, dh_old.attrref.Size, 1, f);
          }
          if (csts == 0) {
            SET_ERRNO_STS;
            break;
          }

          if (dh_old.valid) {
            /* Find object */

            if (dh_old.dynamic) {
              strp
                  = strchr(dh_old.dataname, '.'); /* always is a full object! */
              if (strp != NULL)
                *strp = '\0'; /* Just make sure... */

              sts = gdh_CreateObject(dh_old.dataname, dh_old.cid,
                  dh_old.attrref.Size, &objid, dh_old.attrref.Objid, 0,
                  pwr_cNObjid);

              if (strp != NULL)
                *strp = '.';

              if (ODD(sts))
                sts = gdh_SetObjectInfo(
                    dh_old.dataname, datap, dh_old.attrref.Size);
            } /* Dynamic object */
            else {
              sts = gdh_SetObjectInfoAttrref(
                  &dh_old.attrref, datap, dh_old.attrref.Size);
            }
          } /* valid segment */

          free(datap);

          if (EVEN(sts)) {
            errh_Error(
                "BACKUP error reloading %s, reason:\n%m", dh_old.dataname, sts);
            sts = 1;
          }

        } /* For all data segments */
        if (EVEN(sts))
          break; /* Fatal! Get out! */
      } /* For each cycle */
    } else if (fh.version == BCK_FILE_VERSION - 1) {
      /* Read the cycle data.  */
      BCK_FILEHEAD_STRUCT_V6* fhp_v6 = (BCK_FILEHEAD_STRUCT_V6*)&fh;
      BCK_CYCLEHEAD_STRUCT_V6 ch_v6;

      for (c = 0; c < 2; c++) {
        fseek(f, fhp_v6->curdata[c], 0);
        fread(&ch_v6, sizeof ch_v6, 1, f);

        /* Work thru the data segments */

        for (d = 0; d < ch_v6.segments; d++) {
          csts = fread(&dh, sizeof dh, 1, f);
          if (csts != 0) {
            if (dh.namesize > 0) {
              namep = malloc(dh.namesize + 1);
              csts = fread(namep, dh.namesize + 1, 1, f);
            } else
              namep = NULL;
            datap = malloc(dh.size);
            csts = fread(datap, dh.size, 1, f);
          }
          if (csts == 0) {
            SET_ERRNO_STS;
            break;
          }

          if (dh.valid) {
            /* Find object */

            if (dh.dynamic) {
              strp = strchr(namep, '.'); /* always is a full object! */
              if (strp != NULL)
                *strp = '\0'; /* Just make sure... */

              sts = gdh_CreateObject(
                  namep, dh.cid, dh.size, &objid, dh.objid, 0, pwr_cNObjid);

              if (strp != NULL)
                *strp = '.';

              if (ODD(sts))
                sts = gdh_SetObjectInfo(namep, datap, dh.size);

              strncpy(objectname, namep, pwr_cSizAName);
            } /* Dynamic object */
            else {
              sts = gdh_ObjidToName(
                  dh.objid, objectname, sizeof(objectname), cdh_mNName);
              if (ODD(sts)) {
                strcat(objectname, namep);
                sts = gdh_SetObjectInfo(objectname, datap, dh.size);
              }
            }
          } /* valid segment */

          if (EVEN(sts)) {
            errh_Error(
                "BACKUP error reloading %s, reason:\n%m", objectname, sts);
            sts = 1;
          }

          free(datap);
          free(namep);

        } /* For all data segments */
        if (EVEN(sts))
          break; /* Fatal! Get out! */
      } /* For each cycle */
    } else if (fh.version == BCK_FILE_VERSION) {
      /* Read the cycle data.  */

      for (c = 0; c < 2; c++) {
        fseek(f, fh.curdata[c], 0);
        fread(&ch, sizeof ch, 1, f);

        /* Work thru the data segments */

        for (d = 0; d < ch.segments; d++) {
          csts = fread(&dh, sizeof dh, 1, f);
          if (csts != 0) {
            if (dh.namesize > 0) {
              namep = malloc(dh.namesize + 1);
              csts = fread(namep, dh.namesize + 1, 1, f);
            } else
              namep = NULL;
            datap = malloc(dh.size);
            csts = fread(datap, dh.size, 1, f);
          }
          if (csts == 0) {
            SET_ERRNO_STS;
            break;
          }

          if (dh.valid) {
            /* Find object */
            strcpy(objectname, "");

            if (dh.dynamic) {
              strp = strchr(namep, '.'); /* always is a full object! */
              if (strp != NULL)
                *strp = '\0'; /* Just make sure... */

              sts = gdh_CreateObject(
                  namep, dh.cid, dh.size, &objid, dh.objid, 0, pwr_cNObjid);

              if (strp != NULL)
                *strp = '.';

              if (ODD(sts))
                sts = gdh_SetObjectInfo(namep, datap, dh.size);

              strncpy(objectname, namep, pwr_cSizAName);
            } /* Dynamic object */
            else {
              sts = gdh_ObjidToName(
                  dh.objid, objectname, sizeof(objectname), cdh_mNName);
              if (ODD(sts)) {
                strcat(objectname, namep);
                sts = gdh_SetObjectInfo(objectname, datap, dh.size);
              } else
                cdh_OidToString(objectname, sizeof(objectname), dh.objid, 1);
            }
          } /* valid segment */

          if (EVEN(sts)) {
            errh_Error(
                "BACKUP error reloading %s, reason:\n%m", objectname, sts);
            sts = 1;
          }

          free(datap);
          free(namep);

        } /* For all data segments */
        if (EVEN(sts))
          break; /* Fatal! Get out! */
      } /* For each cycle */
    } /* File version format ok */
    else {
      errh_Error("BACKUP Cannot load backup file with version %d", fh.version);
    }
  } /* Successful header read */

  fclose(f);

  return sts;
}
