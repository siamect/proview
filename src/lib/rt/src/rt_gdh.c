/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_gdh.c
   This module contains the access routines to the Global Data
   Handler. Those routines are callable from application level.  */

#include <stdlib.h>

#include "co_array.h"
#include "co_dcli.h"
#include "co_string.h"
#include "co_time.h"

#include "rt_gdh_msg.h"
#include "rt_hash_msg.h"
#include "rt_pwr_msg.h"
#include "rt_gdh.h"
#include "rt_dvol.h"
#include "rt_cmvolc.h"
#include "rt_cvolc.h"
#include "rt_ndc.h"
#include "rt_subc.h"
#include "rt_sanc.h"
#include "rt_dl.h"
#include "rt_lck.h"
#include "pwr_baseclasses.h"

#if defined(OS_LINUX) || defined OS_MACOS
#define gdh_Lock                                                               \
  pthread_mutex_lock(&gdbroot->thread_lock);                                   \
  gdb_Lock
#define gdh_Unlock                                                             \
  gdb_Unlock;                                                                  \
  pthread_mutex_unlock(&gdbroot->thread_lock)

#else
#define gdh_Lock gdb_Lock
#define gdh_Unlock gdb_Unlock
#endif

#define gdh_ScopeLock                                                          \
  gdh_Lock;                                                                    \
  do
#define gdh_ScopeUnlock                                                        \
  while (0)                                                                    \
    ;                                                                          \
  gdh_Unlock

#define touchObject(op)                                                        \
  if (op != NULL && op->l.flags.b.isCached)                                    \
  cvolc_TouchObject(op)

#define STS_M_SEVERITY 0x7
//#define STS_K_WARNING 0 /**< WARNING                          */
//#define STS_K_SUCCESS 1 /**< SUCCESSFUL COMPLETION            */
#define STS_K_ERROR 2 /**< ERROR                            */
#define STS_K_INFO 3 /**< INFORMATION                      */

static void (*gdh_log_cb)(char*, void*, unsigned int) = 0;

/**
 * @brief This routine fetches the minimum, not visible alarmlevel for a
 * certain object.
 *
 * It inspects all its parents and
 * maximizes the blocking levels.
 */
static void getAlarmVisibility(pwr_tStatus* status, /**< Status */
    gdb_sObject* op, /**< Object */
    pwr_tUInt32* avis /**< The alarm block level */
    )
{
  gdb_sObject* pop;
  pwr_dStatus(sts, status, GDH__SUCCESS);

  *avis = op->l.al.b;
  pop = op;
  while (pop->l.por != pool_cNRef) {
    pop = pool_Address(sts, gdbroot->pool, pop->l.por);
    if (EVEN(*sts))
      return;

    *avis = MAX(*avis, pop->l.al.b);
  }
}
/**
 * @brief Translate an attribute referece to a name.
 * @return pwr_tStatus
 */
pwr_tStatus gdh_AttrrefToName(
    pwr_sAttrRef* arp, /**< Pointer to the attribute reference. */
    char* name, /**< Name buffer supplied by the user, where name is written. */
    unsigned int size, /**< Size of the name buffer */
    pwr_tBitMask nametype /**< Mask of type cdh_mName.  */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  mvol_sAttribute Attribute;
  mvol_sAttribute* ap;
  unsigned int lsize;
  char string[512];
  char* s = NULL;
  cdh_mName lnametype;

  if (arp == NULL)
    return GDH__BADARG;
  if (name == NULL)
    return GDH__BADARG;

  if (arp->Flags.b.Object)
    return gdh_ObjidToName(arp->Objid, name, size, nametype);

  memset(&Attribute, 0, sizeof(Attribute));

  if (nametype == cdh_mNName)
    lnametype.m = cdh_mName_pathStrict;
  else
    lnametype.m = nametype;

  gdh_ScopeLock
  {
    ap = vol_ArefToAttribute(
        &sts, &Attribute, arp, gdb_mLo_global, vol_mTrans_all);
    if (ap == NULL)
      break;

    touchObject(ap->op);
    s = vol_AttributeToName(&sts, ap, lnametype.m, string);
  }
  gdh_ScopeUnlock;

  if (ap == NULL && lnametype.b.fallback != cdh_mName_eFallback_strict) {
    sts = GDH__SUCCESS;
    cdh_ArefToString(string, sizeof(string), arp, 1);
    s = string;
  }

  if (s != NULL) {
    lsize = strlen(s);
    if (lsize >= size)
      sts = GDH__NAMEBUF;
    strncpy(name, s, lsize + 1);
  }

  return sts;
}

/**
 * @brief Get the attribute reference for an attribute in an object attribute
 * reference, where the attribute is specified by an string.
 *
 * @return pwr_tStatus
 */
pwr_tStatus gdh_ArefANameToAref(
    pwr_sAttrRef* arp, /**< Pointer to object attribute reference */
    const char* aname, /**< Attribute name string */
    pwr_sAttrRef* oarp /**< Receives the  attribute reference. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  mvol_sAttribute Attribute;
  mvol_sAttribute* ap;
  char string[512];
  char* s = NULL;
  cdh_sParseName parseName;
  cdh_sParseName* pn = NULL;
  gdb_sObject* op;

  gdh_ScopeLock
  {
    memset(&Attribute, 0, sizeof(Attribute));

    if (arp->Flags.b.Object) {
      op = vol_OidToObject(
          &sts, arp->Objid, gdb_mLo_global, vol_mTrans_none, cvol_eHint_none);
      if (op == NULL)
        break;

      touchObject(op);
      s = vol_ObjectToName(&sts, op, cdh_mName_volumeStrict, string);
    } else {
      ap = vol_ArefToAttribute(
          &sts, &Attribute, arp, gdb_mLo_global, vol_mTrans_all);
      if (ap == NULL)
        break;

      touchObject(ap->op);
      s = vol_AttributeToName(&sts, ap, cdh_mName_volumeStrict, string);
    }
    strcat(string, ".");
    strcat(string, aname);

    pn = cdh_ParseName(&sts, &parseName, pwr_cNOid, string, 0);
    if (pn == NULL)
      break;

    memset(&Attribute, 0, sizeof(Attribute));

    ap = vol_NameToAttribute(
        &sts, &Attribute, pn, gdb_mLo_global, vol_mTrans_all);
    if (ap == NULL)
      break;

    mvol_AttributeToAref(&sts, ap, oarp);
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get the attribute reference to an object or attribute object, from the
 * attribute reference to an attribute in the object.
 *
 * This functions cuts the last attribute segment.
 *
 * @return pwr_tStatus
 */
pwr_tStatus gdh_AttrArefToObjectAref(
    pwr_sAttrRef* arp, /**< Attribute reference to the attribute. */
    pwr_sAttrRef* oarp /**< Returned attribute reference to the object or
                          attribute object.*/
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  mvol_sAttribute Attribute;
  mvol_sAttribute* ap;
  char string[512];
  char* s = NULL;
  char* t;
  cdh_sParseName parseName;
  cdh_sParseName* pn = NULL;

  if (arp->Flags.b.Object)
    return GDH__NOATTR;

  gdh_ScopeLock
  {
    memset(&Attribute, 0, sizeof(Attribute));

    ap = vol_ArefToAttribute(
        &sts, &Attribute, arp, gdb_mLo_global, vol_mTrans_all);
    if (ap == NULL)
      break;

    touchObject(ap->op);
    s = vol_AttributeToName(&sts, ap, cdh_mName_volumeStrict, string);

    t = strrchr(string, '.');
    if (!t) {
      sts = GDH__NOATTR;
      break;
    }
    *t = 0;

    pn = cdh_ParseName(&sts, &parseName, pwr_cNOid, string, 0);
    if (pn == NULL)
      break;

    memset(&Attribute, 0, sizeof(Attribute));

    ap = vol_NameToAttribute(
        &sts, &Attribute, pn, gdb_mLo_global, vol_mTrans_all);
    if (ap == NULL)
      break;

    mvol_AttributeToAref(&sts, ap, oarp);
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Converts a class and attribute string to attrref format.
 *
 * The Objid of the attrref is left untouched.
 * @return pwr_tStatus
 */

pwr_tStatus gdh_ClassAttrToAttrref(
    pwr_tClassId
        cid, /**< The class identity whose attribute we want to examin */
    const char* name, /**< The name of the attribute we want */
    pwr_sAttrRef* arp /**< Receives the attribute description. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  mvol_sAttribute Attribute;
  mvol_sAttribute* ap;
  cdh_sParseName ParseName;
  cdh_sParseName* pn = NULL;
  char buff[512] = ".";

  if (arp == NULL)
    return GDH__BADARG;

  /* If no attribute name is given, Assume whole body.  */

  if (name != NULL && *name != '\0') {
    pn = cdh_ParseName(&sts, &ParseName, pwr_cNObjid, name, 0);
    if (pn == NULL || pn->nAttribute == 0) {
      strcat(buff, name);
      pn = cdh_ParseName(&sts, &ParseName, pwr_cNObjid, buff, 0);
    }
    if (pn == NULL)
      return GDH__BADNAME;
  }

  memset(&Attribute, 0, sizeof(Attribute));

  gdh_ScopeLock
  {
    ap = mvol_AnameToAttribute(&sts, &Attribute, cid, pn, NULL);
    if (ap == NULL)
      break;
    mvol_AttributeToAref(&sts, ap, arp);
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get the attribute name from a class and attrref.
 *
 * The objid of the attrref is not used.
 * @return Status of the operation.
 */

pwr_tStatus gdh_ClassAttrrefToAttr(
    pwr_tClassId
        cid, /**< The class identity whose attribute we want to examin */
    pwr_sAttrRef* arp, /**< Attribute description. */
    char* name, /**< The returned name of the attribute */
    int size /**< Max size of the returned name */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  mvol_sAttribute Attribute;
  mvol_sAttribute* ap;

  if (arp == NULL)
    return GDH__BADARG;
  if (name == NULL)
    return GDH__BADARG;

  memset(&Attribute, 0, sizeof(Attribute));

  gdh_ScopeLock
  {
    ap = mvol_ArefToAttribute(&sts, &Attribute, arp, cid);
  }
  gdh_ScopeUnlock;

  if (ap != NULL) {
    if (ap->adef && ap->adef->Info.Elements > 1
        && ap->size < ap->adef->Info.Size) {
      char aname[256];

      sprintf(aname, "%s[%d]", ap->name, ap->idx);
      strncpy(name, aname, size);
    } else
      strncpy(name, ap->name, size);
  }

  return sts;
}

/**
 * @brief Get the class identity corresponding to a class
 * specified by name.
 * @return pwr_tStatus
 */
pwr_tStatus gdh_ClassNameToId(const char* name, /**< Class name string. */
    pwr_tClassId* cid /**< Returned class identity. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sClass* cp;

  if (name == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    cp = mvol_NameToClass(&sts, name);
    if (cp != NULL && cid != NULL)
      *cid = cp->cid;
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Create an object in a dynamic volume.
 *
 * Objects can only be created in local dynamic volumes, or in the local
 * system volume. <br>
 * Space is allocated for the object which must not exist.
 * This call is possible only if the object is created
 * in a local volume, i.e a volume owned by the local node.
 *
 * All reachable nodes, who have mounted the volume in question,
 * are notified about this new object.
 * It is possible to require a certain objid, but the the objid must not
 * exist in the requested volume.
 *
 * If the volume identity part of the required objid (objid.vid) is zero
 * the the volume id indicated by the given name is used.
 * If the objid.vid != zero, then it must match the volume id indicated by
 * the name.
 * @return pwr_tStatus
*/

pwr_tStatus gdh_CreateObject(
    char* name, /**< Object name string with path.*/
    pwr_tClassId cid, /**< Class id for object. */
    unsigned int size, /**< Size of object body. Only needed for objects
                               with dynamic size, else 0. */
    pwr_tObjid* oid, /**< Returned objid.  */
    pwr_tObjid req_oid, /**< Requested objid. Only if any special objid is
                                prefered, else pwr_cNOid. */
    pwr_tBitMask flags, /**< Alias client or mount client.  */
    pwr_tObjid
        soid /**< Server objid. Used for ExternVolumes. Normally pwr_cNOid */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;
  cdh_sParseName ParseName;
  cdh_sParseName* pn;

  if (name == NULL)
    return GDH__BADARG;
  if (oid == NULL)
    return GDH__BADARG;

  pn = cdh_ParseName(&sts, &ParseName, pwr_cNObjid, name, 0);
  if (pn == NULL)
    return sts;
  if (pn->flags.b.idString)
    return GDH__NOSUCHOBJ;

  gdh_ScopeLock
  {
    op = dvol_CreateObject(&sts, pn, cid, size, req_oid);
  }
  gdh_ScopeUnlock;

  if (op != NULL)
    *oid = op->g.oid;

  return sts;
}

/**
 * @brief Remove a local object.
 *
 * Object header and the associated body are removed.
 * This call is possible only if the object is
 * in a local volume, i.e a volume owned by the local node.
 * The volume must be of class $DynamicVolume or $SystemVolume.
 * The object must not be parent to any other object.
 *
 * All reachable nodes, who have mounted the volume in question,
 * are notified about the removal of this object.
 *
 * The object is not completly removed until all directlink and
 * subscriptions to the object are removed.
 * @return pwr_tStatus
 */

pwr_tStatus gdh_DeleteObject(
    pwr_tObjid oid /**< The identity of the object to delete. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;

  if (cdh_ObjidIsNull(oid))
    return GDH__NOSUCHOBJ;

  gdh_ScopeLock
  {
    dvol_DeleteObject(&sts, oid);
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Remove a local object tree.
 *
 * Object header and the associated body are removed.
 * This call is possible only if the object is
 * in a local volume, i.e a volume owned by the local node.
 * The volume must be of class $DynamicVolume or $SystemVolume.
 * The object must not be parent to any other object.
 *
 * All reachable nodes, who have mounted the volume in question,
 * are notified about the removal of this object.
 *
 * The objects is not completly removed until all directlink and
 * subscriptions to the object are removed.
 * @return pwr_tStatus
 */

pwr_tStatus gdh_DeleteObjectTree(
    pwr_tObjid oid /**< The identity of the root object of the tree. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;

  if (cdh_ObjidIsNull(oid))
    return GDH__NOSUCHOBJ;

  gdh_ScopeLock
  {
    dvol_DeleteObjectTree(&sts, oid);
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Request a direct link to the data denoted by an attribute reference.
 *
 * The object owning the data must be owned by the local node.
 * The caller receives a pointer to data in the object body in the realtime
 * database.
 * The data can be changed by the user without restriction.
 *
 * The data should be unlinked with a gdh_DLUnrefObjectInfo() call.
 *
 * @return pwr_tStatus
 */
pwr_tStatus gdh_DLRefObjectInfoAttrref(
    pwr_sAttrRef* arp, /**< Pointer to attribute reference for object or
                          attribute to link to.*/
    void** infop, /**< Returnd pointer to the data. */
    pwr_tDlid* dlid /**< Id for the direct link. Used to unlink the data.*/
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  dl_sLink* dp;
  mvol_sAttribute Attribute;
  mvol_sAttribute* ap;
  void* p;

  if (arp == NULL)
    return GDH__BADARG;

  memset(&Attribute, 0, sizeof(Attribute));

  gdh_ScopeLock
  {
    ap = vol_ArefToAttribute(
        &sts, &Attribute, arp, gdb_mLo_native, vol_mTrans_all);
    if (ap == NULL)
      break;

    if (ap->op->u.n.lflags.b.readOnly) {
      sts = GDH__READONLY;
      break;
    }

    p = vol_AttributeToAddress(&sts, ap);
    if (p == NULL)
      break;

    dp = dl_Create(&sts, ap, arp);
    if (dp == NULL)
      break;

    if (infop != NULL)
      *infop = p;
    if (dlid != NULL)
      *dlid = dp->dlid;
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Terminate direct linking of an object or an object attribute.
 *
 * The pointer returned by DLRefObjectInfo can become invalid
 * after this call.
 *
 * @see gdh_DLRefObjectInfo
 * @see gdh_DLRefObjectInfoAttrref
 * @return pwr_tStatus
 */

pwr_tStatus gdh_DLUnrefObjectInfo(
    pwr_tDlid dlid /** <The id of the direct link we want to remove */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;

  gdh_ScopeLock
  {
    dl_Cancel(&sts, dlid);
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Removes all direct links set up by this process.
 */

void gdh_DLUnrefObjectInfoAll(void)
{
  gdh_ScopeLock
  {
    dl_CancelUser(gdbroot->my_pid);
  }
  gdh_ScopeUnlock;
}

/**
 * @brief Get the alarm status for a certain object.
 * @return pwr_tStatus
 */

pwr_tStatus gdh_GetAlarmInfo(pwr_tObjid oid, /**< Object identity */
    pwr_tUInt32* a, /**< Receives the alarm status. Can be NULL */
    pwr_tUInt32*
        maxa, /**< Receives the highest alarm level of the object. Can be NULL
                 */
    pwr_tUInt32*
        b, /**< Receives the blocking level of the object. CAn be NULL */
    pwr_tUInt32*
        maxb, /**< Receives the highest existing blocking level of the object.
                 Can be NULL */
    pwr_tUInt32* alarmvisibility /**< Receives the alarm block level. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_global, vol_mTrans_none, cvol_eHint_none);
    if (op == NULL)
      break;

    touchObject(op);

    if (!op->l.flags.b.isNative)
      sanc_Subscribe(NULL, op);

    if (a != NULL)
      *a = op->l.al.a;

    if (maxa != NULL) {
      *maxa = op->l.al.maxa;
      if (op->l.flags.b.isNative)
        *maxa = MAX(*maxa, op->u.n.ral.maxa);
    }

    if (b != NULL)
      *b = op->l.al.b;

    if (maxb != NULL) {
      *maxb = op->l.al.maxb;
      if (op->l.flags.b.isNative)
        *maxb = MAX(*maxb, op->u.n.ral.maxb);
    }

    if (alarmvisibility != NULL) {
      getAlarmVisibility(&sts, op, alarmvisibility);
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get the node identity of the local node.
 * @return pwr_tStatus
 */
pwr_tStatus gdh_GetNodeIndex(
    pwr_tNodeId* nid /**< Receives node index of the local node */
    )
{
  if (nid == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    *nid = gdbroot->my_node->nid;
  }
  gdh_ScopeUnlock;

  return GDH__SUCCESS;
}

/**
 * @brief Get the node identity of the owner node of an object.
 * @return pwr_tStatus
 */

pwr_tStatus gdh_GetObjectNodeIndex(pwr_tObjid oid, /**< Object identity. */
    pwr_tNodeId* nid /**< Receives the node index. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;
  gdb_sVolume* vp;

  if (nid == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_global, vol_mTrans_all, cvol_eHint_none);
    if (op == NULL)
      break;

    touchObject(op);

    vp = pool_Address(NULL, gdbroot->pool, op->l.vr);
    *nid = vp->g.nid;
  }
  gdh_ScopeUnlock;

  return sts;
  ;
}

/**
 * @brief Fetch data from an object or an attribute.
 *
 * The caller gets blocked until the information is available.
 * The caller is responsible for allocating a buffer
 * where the information can be stored. If that buffer
 * is to small, the information will be truncated.
 * @return pwr_tStatus
 */

pwr_tStatus gdh_GetObjectInfo(
    const char* name, /**<  Name of object or object.parameter.	 */
    pwr_tAddress bufp, /**<  Pointer to a buffer of 'bufsize' bytes
                             to be filled with requested information.  */
    pwr_tUInt32 bufsize /**<  Size of the 'bufp' buffer.	*/
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  cdh_sParseName parseName;
  cdh_sParseName* pn;
  gdb_sVolume* vp;
  gdb_sNode* np = NULL;
  mvol_sAttribute attribute;
  mvol_sAttribute* ap;
  void* p;
  pwr_sAttrRef aref;
  pwr_sAttrRef* arp = NULL;
  pwr_sAttrRef raref;
  pwr_sAttrRef* rarp = NULL;
  gdb_sCclass* ccp = NULL;
  gdb_sCclass* ccpLocked = NULL;
  pwr_tBoolean equal = 0;
  pwr_tBoolean fetched;
  pwr_tUInt32 ridx = UINT_MAX;

  if (name == NULL)
    return GDH__BADARG;

  pn = cdh_ParseName(&sts, &parseName, pwr_cNObjid, name, 0);
  if (pn == NULL)
    return sts;

  memset(&attribute, 0, sizeof(attribute));

  gdh_Lock;

  do {
    ap = vol_NameToAttribute(
        &sts, &attribute, pn, gdb_mLo_global, vol_mTrans_all);
    if (ap == NULL)
      break;
    if (ap->op == NULL)
      break;

    touchObject(ap->op);

    p = vol_AttributeToAddress(&sts, ap);
    if (p != NULL) {
      memcpy(bufp, p, MIN(ap->size, bufsize));
      break;
    } else if (ap->op->l.flags.m & gdb_mLo_native) {
      break;
    }

    /* Try remote.  */

    arp = mvol_AttributeToAref(&sts, ap, &aref);
    if (arp == NULL)
      break;

    vp = pool_Address(NULL, gdbroot->pool, ap->op->l.vr);
    np = hash_Search(&sts, gdbroot->nid_ht, &vp->g.nid);
    if (np == NULL)
      break;

    ccp = NULL;
    /* Get cached class if needed */
    if (!ap->op->u.c.flags.b.classChecked || !ap->op->u.c.flags.b.classEqual) {
      ccp = cmvolc_GetCachedClass(&sts, np, vp, ap, &equal, &fetched, NULL);
      if (EVEN(sts)) {
        np = NULL;
        break;
      }
      if (equal)
        ccp = NULL;

      if (ccpLocked == NULL && ccp != NULL && !equal) {
        cmvolc_LockClass(NULL, ccp);
        ccpLocked = ccp;
      }

      /* If gdb has been unlocked, refresh pointers */
      /** @todo Check if we can do it more efficient, eg. vol_ArefToAttribute */
      if (fetched) {
        memset(&attribute, 0, sizeof(attribute));
        np = NULL;
        continue;
      }

      if (equal)
        break;

      rarp = ndc_NarefToRaref(
          &sts, ap, arp, ccp, &ridx, &raref, &equal, pn, ccpLocked, vp, np);
    }
    break;
  } while (1);

  gdh_Unlock;

  if (np != NULL && ODD(sts)) {
    if (equal)
      cvolc_GetObjectInfo(
          &sts, np, arp, NULL, NULL, UINT_MAX, ap, bufp, bufsize);
    else
      cvolc_GetObjectInfo(&sts, np, arp, ccp, rarp, ridx, ap, bufp, bufsize);
  }

  if (ccpLocked) {
    gdb_Lock;
    cmvolc_UnlockClass(NULL, ccpLocked);
    gdb_Unlock;
  }

  return sts;
}

/**
 * @brief Fetch the data of an attribute or a whole object body.
 *
 * The function blocks until the information is available.
 * The caller is responsible for allocating a buffer where
 * the information can be stored. If that buffer is to small
 * the information is truncated.
 * @return pwr_tStatus
*/

pwr_tStatus gdh_GetObjectInfoAttrref(
    pwr_sAttrRef* arp, /**< Attribute reference descriptor that defines an
                          object or an object reference */
    void* bufp, /**< Receives the requested information */
    unsigned int bufsize /**< The size in bytes of the data buffer */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sVolume* vp;
  gdb_sNode* np = NULL;
  mvol_sAttribute attribute;
  mvol_sAttribute* ap;
  void* p;
  gdb_sCclass* ccp = NULL;
  gdb_sCclass* ccpLocked = NULL;
  pwr_sAttrRef raref;
  pwr_sAttrRef* rarp = NULL;
  pwr_tBoolean equal = 0;
  pwr_tBoolean fetched;
  pwr_tUInt32 ridx = UINT_MAX;

  memset(&attribute, 0, sizeof(attribute));

  gdh_Lock;

  do {
    ap = vol_ArefToAttribute(
        &sts, &attribute, arp, gdb_mLo_global, vol_mTrans_all);
    if (ap == NULL || ap->op == NULL)
      break;

    touchObject(ap->op);

    p = vol_AttributeToAddress(&sts, ap);
    if (p != NULL) {
      memcpy(bufp, p, MIN(ap->size, bufsize));
      break;
    } else if ((ap->op->l.flags.m & gdb_mLo_native) != 0) {
      break;
    }

    /* Try remote.  */

    vp = pool_Address(NULL, gdbroot->pool, ap->op->l.vr);
    np = hash_Search(&sts, gdbroot->nid_ht, &vp->g.nid);

    if (np == NULL)
      break;

    ccp = NULL;
    /* Get cached class if needed */
    if (!ap->op->u.c.flags.b.classChecked || !ap->op->u.c.flags.b.classEqual) {
      ccp = cmvolc_GetCachedClass(&sts, np, vp, ap, &equal, &fetched, NULL);
      if (EVEN(sts)) {
        np = NULL;
        break;
      }
      if (equal)
        ccp = NULL;

      if (ccpLocked == NULL && ccp != NULL && !equal) {
        cmvolc_LockClass(NULL, ccp);
        ccpLocked = ccp;
      }

      /* If gdb has been unlocked, refresh pointers */
      if (fetched) {
        memset(&attribute, 0, sizeof(attribute));
        np = NULL;
        continue;
      }

      if (equal)
        break;

      rarp = ndc_NarefToRaref(
          &sts, ap, arp, ccp, &ridx, &raref, &equal, NULL, ccpLocked, vp, np);
    }

    break;
  } while (1);

  gdh_Unlock;

  if (np != NULL && ODD(sts)) {
    if (equal)
      cvolc_GetObjectInfo(
          &sts, np, arp, NULL, NULL, UINT_MAX, ap, bufp, bufsize);
    else
      cvolc_GetObjectInfo(&sts, np, arp, ccp, rarp, ridx, ap, bufp, bufsize);
  }

  if (ccpLocked) {
    gdb_Lock;
    cmvolc_UnlockClass(NULL, ccpLocked);
    gdb_Unlock;
  }

  return sts;
}

/**
 * @brief Get the size of the body of an object.
 *
 * This information
 * can be retrieved both for local and remote objects.
 * @return pwr_tStatus
 */

pwr_tStatus gdh_GetObjectSize(pwr_tObjid oid, /**< The object identity. */
    pwr_tUInt32* size /**< Receives the size in bytes of the object. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;

  if (size == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_global, vol_mTrans_none, cvol_eHint_none);
    if (op != NULL) {
      touchObject(op);
      *size = op->g.size;
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get the size of a dynamic attribute.
 *
 * @return pwr_tStatus
 */

pwr_tStatus gdh_GetDynamicAttrSize(pwr_tObjid oid, /**< The object identity. */
    char* name, /**< Attribute name with leading point, eg ".Length". */
    pwr_tUInt32* size /**< Receives the size in bytes of the object. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;
  mvol_sAttribute Attribute;
  mvol_sAttribute* ap;
  cdh_sParseName ParseName;
  cdh_sParseName* pn = NULL;

  if (size == NULL)
    return GDH__BADARG;

  if (name != NULL && *name != '\0') {
    pn = cdh_ParseName(&sts, &ParseName, pwr_cNObjid, name, 0);
    if (pn == NULL)
      return GDH__BADNAME;
  } else
    return GDH__BADNAME;

  memset(&Attribute, 0, sizeof(Attribute));

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_global, vol_mTrans_none, cvol_eHint_none);
    if (op != NULL) {
      touchObject(op);
      *size = op->g.size;
    }

    ap = mvol_AnameToAttribute(&sts, &Attribute, op->g.cid, pn, NULL);
    if (ap == NULL)
      break;
  }
  gdh_ScopeUnlock;
  if (ap == 0)
    sts = GDH__ATTRIBUTE;

  *size -= ap->offs;
  return sts;
}

/**
 * @brief Get the class identifier of an object.
 *
 * This information
 * can be retrieved both for local and remote objects.
 * @return pwr_tStatus
 */
pwr_tStatus gdh_GetObjectClass(
    pwr_tObjid oid, /**< The identity of the object. */
    pwr_tClassId* cid /**< Receives the object class identity. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;
  gdb_sClass* cp;
  pwr_tStatus lsts;

  if (cid == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_global, vol_mTrans_all, cvol_eHint_none);
    if (op != NULL) {
      touchObject(op);
      *cid = op->g.cid;

      if (op->l.flags.b.isCached) {
        cp = hash_Search(&lsts, gdbroot->cid_ht, cid);
        if (cp == NULL) {
          cmvolc_GetNonExistingClass(&lsts, op, *cid);
        }
      }
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get the type or class identifier of an attribute reference.
 * @return pwr_tStatus
 */
pwr_tStatus gdh_GetAttrRefTid(
    pwr_sAttrRef* arp, /**< The attribute reference. */
    pwr_tTid* tid /**< Receives the aref type or class identity. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  mvol_sAttribute* ap;
  mvol_sAttribute attribute;
  gdb_sClass* cp;

  if (arp->Flags.b.Object && arp->Body) {
    *tid = arp->Body & ~7;
    return GDH__SUCCESS;
  }
  if ((arp->Body == 0 && arp->Offset == 0)
      || (arp->Offset == 0 && arp->Size == 0))
    return gdh_GetObjectClass(arp->Objid, tid);

  gdh_ScopeLock
  {
    memset(&attribute, 0, sizeof(attribute));

    ap = vol_ArefToAttribute(
        &sts, &attribute, arp, gdb_mLo_global, vol_mTrans_all);
    if (ap != NULL)
      touchObject(ap->op);
  }
  gdh_ScopeUnlock;

  if (ap != 0 && ap->adef != 0) {
    if (ap->adef->Info.Flags & PWR_MASK_CASTATTR) {
      pwr_tCastId castid;
      pwr_sAttrRef cast_aref = cdh_ArefToCastAref(arp);

      sts = gdh_GetObjectInfoAttrref(&cast_aref, &castid, sizeof(castid));
      if (ODD(sts) && castid != pwr_cNCastId) {
        *tid = castid;
      } else {
        *tid = ap->adef->TypeRef;
      }
    } else {
      *tid = ap->adef->TypeRef;
    }

    if (cdh_tidIsCid(*tid) && !(ap->op->l.flags.m & gdb_mLo_native)) {
      gdh_ScopeLock
      {
        cp = hash_Search(&sts, gdbroot->cid_ht, tid);
        if (cp == NULL) {
          cmvolc_GetNonExistingClass(&sts, ap->op, *tid);
          cp = hash_Search(&sts, gdbroot->cid_ht, tid);
          if (cp == NULL) {
            sts = GDH__NOSUCHCLASS;
          }
        }
      }
      gdh_ScopeUnlock;
    }
  } else if (ap != 0 && ap->adef == 0 && ODD(sts)) {
    *tid = ap->cp->cid;
  }
  return sts;
}

/**
 * @brief Return the location of an object.
 *
 * The argument 'location' will get the
 * value TRUE if the object is local,
 * i.e. the object is in a volume owned by the local node,
 * else the value FALSE.
 * @return pwr_tStatus
 */

pwr_tStatus gdh_GetObjectLocation(
    pwr_tObjid oid, /**< The identity of the object.*/
    pwr_tBoolean* location /**< Receives the location.
                                TRUE means local and FALSE remote.*/
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;

  if (location == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_global, vol_mTrans_all, cvol_eHint_none);
    if (op != NULL) {
      touchObject(op);
      *location = (op->l.flags.m & gdb_mLo_native) != 0;
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Gets the direct link count of an object.
 *
 * This information is can be fetched only for local objects.
 * @return pwr_tStatus
 */
pwr_tStatus gdh_GetObjectDLCount(pwr_tObjid oid, /**< The object identity. */
    pwr_tUInt32* count /**< Receives the value of the direct access counter of
                          the object.*/
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;

  if (count == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_native, vol_mTrans_all, cvol_eHint_none);
    if (op != NULL) {
      *count = op->u.n.dlcount;
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get the object identity of the parent of an object.
 * @see gdh_GetLocalParent
 * @return pwr_tStatus
 */

pwr_tStatus gdh_GetParent(pwr_tObjid oid, /**< The identity of the object. */
    pwr_tObjid* new_oid /**< Receives the object identity of the parent. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;

  if (new_oid == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_global, vol_mTrans_all, cvol_eHint_none);
    if (op != NULL) {
      touchObject(op);
      if (op->g.f.poid.oix == pwr_cNObjectIx) {
        *new_oid = pwr_cNObjid;
        sts = GDH__NO_PARENT;
      } else {
        *new_oid = op->g.f.poid;
      }
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get the object identity of the local parent of an object.
 *
 * If the parent is a MountObject, the objid for the MountObject will be
 * returned,
 * not the mounted object, as in gdh_GetParent:
 * @see gdh_GetParent
 * @return pwr_tStatus
 */

pwr_tStatus gdh_GetLocalParent(
    pwr_tObjid oid, /**< The identity of the object. */
    pwr_tObjid* new_oid /**< Receives the object identity of local parent. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;

  if (new_oid == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_global, vol_mTrans_none, cvol_eHint_none);
    if (op != NULL) {
      touchObject(op);
      if (op->g.f.poid.oix == pwr_cNObjectIx) {
        *new_oid = pwr_cNObjid;
        sts = GDH__NO_PARENT;
      } else {
        *new_oid = op->g.f.poid;
      }
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Checks the oldness of a certain subscription.
 *
 * Data gets `old' after a certain timeout-time,
 * when no updates are refreshing the data.
 *
 * @return pwr_tStatus
 */
pwr_tStatus gdh_GetSubscriptionOldness(
    pwr_tSubid sid, /**<  Subscription to examine.  */
    pwr_tBoolean* old, /**<  Pointer to where the oldness
                             flag is stored or NULL.  */
    pwr_tTime* lastupdate, /**<  Pointer to where the 64-bit
                                 time value of last update is
                                 stored or NULL.  */
    pwr_tStatus* status /**<  Status of last data transfer.  */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  sub_sClient* cp;
  cdh_uRefId rid;
  void* p;

  rid.pwr = sid;

  gdh_ScopeLock
  {
    p = hash_Search(&sts, gdbroot->subc_ht, &sid);
    if (p == NULL)
      break;

    if (rid.r.vid_3 == cdh_eVid3_subid) {
      cp = (sub_sClient*)p;

      if (old != NULL)
        *old = cp->old;
      if (lastupdate != NULL)
        memcpy(lastupdate, &cp->lastupdate, sizeof(cp->lastupdate));
      if (status != NULL)
        *status = cp->sts;
    } else if (rid.r.vid_3 == cdh_eVid3_dlid) {
      if (old != NULL)
        *old = FALSE;
      if (lastupdate != NULL)
        time_GetTime(lastupdate);
      if (status != NULL)
        *status = GDH__SUCCESS;
    } else {
      sts = GDH__WEIRD;
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get the object identity of the first child of an object.
 *
 * Other children are fetched with gdh_GetNextSibling.
 * @see gdh_GetNextSibling
 *
 * Example
 * @code
 * pwr_tStatus sts;
 * pwr_tOid coid;
 * pwr_tOName name;
 *
 * // Get all children to oid
 * for ( sts = gdh_GetChild( oid, &coid); ODD(sts); sts = gdh_GetNextSibling(
 * coid, &coid)) {
 *   sts = gdh_ObjidToName( coid, name, sizeof(name), cdh_mName_volumeStrict);
 *   if ( EVEN(sts)) throw co_error(sts);
 *
 *   std::cout << "Child: " << name << '\n';
 * }
 * @endcode
 * @return pwr_tStatus
 */

pwr_tStatus gdh_GetChild(pwr_tObjid oid, /**< The object identity. */
    pwr_tObjid* new_oid /**< Recevies the object identity of the first child. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;

  if (new_oid == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_global, vol_mTrans_all, cvol_eHint_child);
    if (op != NULL) {
      touchObject(op);
      if (op->g.flags.b.isParent) {
        *new_oid = op->g.soid;
      } else {
        sts = GDH__NO_CHILD;
      }
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get the object identity of the next sibling (i.e.
 * the next object with the same parent).
 * @see Example in gdh_GetChild
 * @see gdh_GetPreviousSibling
 * @return pwr_tStatus
 */
pwr_tStatus gdh_GetNextSibling(pwr_tObjid oid, /**< The object identity. */
    pwr_tObjid* new_oid /** Receives the object identity of the next sibling.*/
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;
  gdb_sObject* pop = NULL;
  pwr_tObjid noid;

  if (new_oid == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_global, vol_mTrans_none, cvol_eHint_next);
    if (op != NULL) {
      touchObject(op);
      noid.vid = op->g.oid.vid;
      noid.oix = op->g.sib.flink;
      pop = pool_Address(NULL, gdbroot->pool, op->l.por);
    }
  }
  gdh_ScopeUnlock;

  if (op == NULL)
    return sts;

  if (pop == NULL || noid.oix == pop->g.soid.oix) {
    sts = GDH__NO_SIBLING;
  } else {
    *new_oid = noid;
  }

  return sts;
}

/**
 * @brief Get the object identity of the previous sibling (i.e.
 * the previous object with the same parent).
 * @see gdh_GetNextSibling
 * @return pwr_tStatus
*/

pwr_tStatus gdh_GetPreviousSibling(pwr_tObjid oid, /**< The object identity. */
    pwr_tObjid*
        new_oid /**< Receievs the object identity for the previous sibling. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;
  gdb_sObject* pop = NULL;
  pwr_tObjid noid = {0, 0};

  if (new_oid == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_global, vol_mTrans_none, cvol_eHint_prev);
    if (op != NULL) {
      touchObject(op);
      noid.vid = op->g.oid.vid;
      noid.oix = op->g.sib.blink;
      pop = pool_Address(NULL, gdbroot->pool, op->l.por);
    }
  }
  gdh_ScopeUnlock;

  if (op == NULL)
    return sts;

  if (pop == NULL || oid.oix == pop->g.soid.oix) {
    sts = GDH__NO_SIBLING;
  } else {
    *new_oid = noid;
  }

  return sts;
}

/**
 * @brief Get the first root object in the object tree.
 *
 * Returns the object identity for the first root object.<br>
 * Other root objects are fetched with gdh_GetNextSibling.
 *
 * Example
 * @code
 * pwr_tStatus sts;
 * pwr_tOName name;
 * pwr_tOid oid;
 *
 * // Get all top objects on this node
 * for ( sts = gdh_GetRootList( &oid); ODD(sts); sts = gdh_GetNextSibling( oid,
 * &oid)) {
 *   sts = gdh_ObjidToName( oid, name, sizeof(name), cdh_mName_volumeStrict);
 *   if ( EVEN(sts)) throw co_error(sts);
 *
 *   std::cout << "Top object: " << name << '\n';
 * }
 * @endcode
 * @see gdh_GetNextSibling
 * @return pwr_tStatus
 */
pwr_tStatus gdh_GetRootList(pwr_tObjid*
        oid /**< Receives the object identity of the first root object. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;

  /*  Check arguments.  */
  if (oid == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    /*  Get the first child of the rootvolume.  */

    op = hash_Search(&sts, gdbroot->oid_ht, &gdbroot->my_volume->g.oid);
    if (op != NULL) {
      if (op->g.flags.b.isParent) {
        *oid = op->g.soid;
      } else {
        sts = GDH__NOSUCHOBJ;
      }
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get the object identity of the first object
 * in the list of objects of a specified class.
 *
 * The call shows only private volumes
 * (of class $RootVolume, $SubVolume,
 * $DynamicVolume, $ClassVolume and $SystemVolume),
 * and shared volumes.
 *
 * Example
 * @code
 * pwr_tStatus sts;
 * pwr_tOName name;
 * pwr_tOid oid;
 *
 * // Get all objects of class cid
 * for ( sts = gdh_GetClassList( cid); ODD(sts); sts = gdh_GetNextObject( oid,
 * &oid)) {
 *   sts = gdh_ObjidToName( oid, name, sizeof(name), cdh_mName_volumeStrict);
 *   if ( EVEN(sts)) throw co_error(sts);
 *
 *   std::cout << "Object: " << name << '\n';
 * }
 * @endcode
 * @return pwr_tStatus
*/

pwr_tStatus gdh_GetClassList(pwr_tClassId cid, /**< The class identity. */
    pwr_tObjid* oid /**< Receives the object identity. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op = NULL;

  gdh_ScopeLock
  {
    op = mvol_ClassList(&sts, cid, pwr_cNObjid, mvol_eList_first);
    if (op != NULL) {
      *oid = op->g.oid;
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get the object identity of the next object
 * in the list of objects of a certain class.
 *
 * The visibility of objects in the class list are
 * restricted to objects in private volumes,
 * (of class $RootVolume, $SubVolume,
 * $DynamicVolume, $ClassVolume and $SystemVolume),
 * and in shared volumes.
 * @see Example in gdh_GetClassList
 * @return pwr_tStatus
 */

pwr_tStatus gdh_GetNextObject(pwr_tObjid oid, /**< The object identity. */
    pwr_tObjid* new_oid /**< Receives the object identity */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;

  /* Check arguments. */
  if (new_oid == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    op = mvol_ClassList(&sts, pwr_cNClassId, oid, mvol_eList_next);
    if (op != NULL) {
      *new_oid = op->g.oid;
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get the attribute reference of the first object
 * in the list of objects of a specified class.
 * The object can be a solitary object or an attribute object.
 *
 * The call shows only private volumes
 * (of class $RootVolume, $SubVolume,
 * $DynamicVolume, $ClassVolume and $SystemVolume),
 * and shared volumes.
 *
 * Example
 * @code
 * pwr_tStatus sts;
 * pwr_tAttrRef aref;
 * pwr_tAName name;
 *
 * // Get all objects and attribute objects for class cid
 * for ( sts = gdh_GetClassListAttrRef( cid, &aref); ODD(sts); sts =
 * gdh_GetNextAttrRef( cid, &aref, &aref)) {
 *   sts = gdh_AttrrefToName( &aref, name, sizeof(name),
 * cdh_mName_volumeStrict);
 *   if ( EVEN(sts)) throw co_error(sts);
 *
 *   std::cout << "Object: " << name << '\n';
 * }
 * @endcode
 * @see gdh_GetNextAttrRef
 * @return pwr_tStatus
*/

pwr_tStatus gdh_GetClassListAttrRef(
    pwr_tClassId cid, /**< The class identity. */
    pwr_sAttrRef* arp /**< Receives the attribute reference. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;

  gdh_ScopeLock
  {
    mvol_ClassListAttrRef(&sts, cid, NULL, arp, mvol_eList_first);
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get the attrref of the next object
 * in the list of objects of a certain class.
 * The object can be a solitary object or an attribute object.
 *
 * The visibility of objects in the class list are
 * restricted to objects in private volumes,
 * (of class $RootVolume, $SubVolume,
 * $DynamicVolume, $ClassVolume and $SystemVolume),
 * and in shared volumes.
 * @see Example in gdh_GetClassListAttrRef
 * @return pwr_tStatus
 */

pwr_tStatus gdh_GetNextAttrRef(pwr_tClassId cid, /**< The class identity. */
    pwr_sAttrRef* arp, /**< The attribute reference. */
    pwr_sAttrRef* new_arp /**< Receives the attribute reference */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;

  /* Check arguments. */
  if (new_arp == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    mvol_ClassListAttrRef(&sts, cid, arp, new_arp, mvol_eList_next);
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get the attribute reference of the first attribute object
 * of a specified class in the specified object.
 * @return pwr_tStatus
*/

pwr_tStatus gdh_GetObjectClassList(pwr_tCid cid, /**< The class identity. */
    pwr_tOid oid, /**< Host object. */
    pwr_sAttrRef* arp /**< Receives the attribute reference. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  pwr_sAttrRef ar;

  gdh_ScopeLock
  {
    ar.Objid = oid;
    mvol_ClassListAttrRef(&sts, cid, &ar, arp, mvol_eList_objectfirst);
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get the attrref of the next attribute object
 * of a specified class in a specified object.
 * @return pwr_tStatus
 */

pwr_tStatus gdh_GetNextObjectAttrRef(
    pwr_tClassId cid, /**< The class identity. */
    pwr_sAttrRef* arp, /**< The attribute reference. */
    pwr_sAttrRef* new_arp /**< Receives the attribute reference */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;

  /* Check arguments. */
  if (new_arp == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    mvol_ClassListAttrRef(&sts, cid, arp, new_arp, mvol_eList_objectnext);
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Return the objid of the node object for a node identified by a
 * node identifier (of type pwr_tNodeId).
 *
 * If the node identity is specified as zero,
 * the node object for the local node is returned.
 * @return pwr_tStatus
 */

pwr_tStatus gdh_GetNodeObject(pwr_tNodeId nid, /**< The node index. */
    pwr_tObjid* oid /**< Receive the object identity. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sNode* np;

  if (oid == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    if (nid == pwr_cNNodeId) {
      *oid = gdbroot->db->nod_oid;
    } else {
      np = hash_Search(&sts, gdbroot->nid_ht, &nid);
      if (np != NULL) {
        *oid = np->nod_oid;
      }
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Return info for a node identified by a
 * node identifier (of type pwr_tNodeId).
 *
 * @return pwr_tStatus
 */
pwr_tStatus gdh_GetNodeInfo(pwr_tNodeId nid, /**< The node index. */
    gdh_sNodeInfo* ip /**< Receive the node info. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sNode* np;

  if (ip == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    np = hash_Search(&sts, gdbroot->nid_ht, &nid);
    if (np != NULL) {
      ip->nodidx = np->nid;
      ip->nix = np->vol_oid.vid;
      strcpy(ip->nodename, np->name); 
      ip->objid = np->nod_oid;
      ip->linkstate = 0;
      ip->upcnt = np->upcnt;
      ip->timeup = np->timeup;
      ip->timedown = np->timedown;
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get the characteristics of an attribute, given
 * its name and the class it belongs to.
 *
 * The output arguments
 * can have an actual value of NULL if they are not wanted.
 * @return pwr_tStatus
 */

pwr_tStatus gdh_GetAttributeCharacteristics(
    char* name, /**< String containing attribute name;
                     object.attribute or
                     object.attribute[index].  */
    pwr_tTypeId* tid, /**< Address to an integer where
                           the type is stored.  */
    pwr_tUInt32* size, /**< Address to an integer where
                            the size is stored.  */
    pwr_tUInt32* offs, /**< Address to an integer where
                           the offset is stored.  */
    pwr_tUInt32* elem /**< Address to an integer where
                          the # of elements is stored.  */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  cdh_sParseName parseName;
  cdh_sParseName* pn;
  mvol_sAttribute attribute;
  mvol_sAttribute* ap;

  pn = cdh_ParseName(&sts, &parseName, pwr_cNObjid, name, 0);
  if (pn == NULL)
    return sts;

  memset(&attribute, 0, sizeof(attribute));

  gdh_ScopeLock
  {
    ap = vol_NameToAttribute(
        &sts, &attribute, pn, gdb_mLo_global, vol_mTrans_all);
    if (ap != NULL)
      touchObject(ap->op);
  }
  gdh_ScopeUnlock;

  if (ap != NULL) {
    if (size != NULL)
      *size = ap->size;
    if (offs != NULL)
      *offs = ap->offs;
    if (tid != NULL)
      *tid = ap->tid;
    if (elem != NULL)
      *elem = ap->elem;
  }

  return sts;
}

/**
 * @brief Get the characteristics of an attribute.
 *
 * The output arguments
 * can be NULL if they are not wanted.
 * @return pwr_tStatus
 */

pwr_tStatus gdh_GetAttributeCharAttrref(
    pwr_sAttrRef*
        arp, /**< The attribute of which to fetch the charactertistics. */
    pwr_tTypeId* tid, /**< Receives the attribute type. */
    unsigned int* size, /**< Receives the size in bytes */
    unsigned int* offs, /**< Receives the offset of the attribute from the
                             beginning of the object .*/
    unsigned int* elem /**< Receives the number of elements. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  mvol_sAttribute attribute;
  mvol_sAttribute* ap;

  memset(&attribute, 0, sizeof(attribute));

  gdh_ScopeLock
  {
    ap = vol_ArefToAttribute(
        &sts, &attribute, arp, gdb_mLo_global, vol_mTrans_all);
    if (ap != NULL)
      touchObject(ap->op);
  }
  gdh_ScopeUnlock;

  if (ap != NULL) {
    if (size != NULL)
      *size = ap->size;
    if (offs != NULL)
      *offs = ap->offs;
    if (tid != NULL)
      *tid = ap->tid;
    if (elem != NULL)
      *elem = ap->elem;
  }

  return sts;
}

/**
 * @brief Get the flags of an attribute.
 *
 * @return pwr_tStatus
 */

pwr_tStatus gdh_GetAttributeFlags(
    pwr_sAttrRef* arp, /**< The attribute of which to fetch flags. */
    unsigned int* flags /**< Receives the attribute flags. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  mvol_sAttribute attribute;
  mvol_sAttribute* ap;

  memset(&attribute, 0, sizeof(attribute));

  gdh_ScopeLock
  {
    ap = vol_ArefToAttribute(
        &sts, &attribute, arp, gdb_mLo_global, vol_mTrans_all);
    if (ap != NULL)
      touchObject(ap->op);
  }
  gdh_ScopeUnlock;

  if (ap != NULL)
    *flags = ap->adef->Info.Flags;

  return sts;
}

/**
 * @brief Get the object identity of the previous object
 * in the list of objects of a certain class.
 *
 * The visibility of objects in the class list are
 * restricted to objects in private volumes,
 * (of class $RootVolume, $SubVolume,
 * $DynamicVolume, $ClassVolume and $SystemVolume),
 * and in shared volumes.
 * @return pwr_tStatus
 */
pwr_tStatus gdh_GetPreviousObject(pwr_tObjid oid, /**< The object identity.*/
    pwr_tObjid* new_oid /**< Receives the identity of the previos object.*/
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;

  if (new_oid == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    op = mvol_ClassList(&sts, pwr_cNClassId, oid, mvol_eList_prev);
    if (op != NULL) {
      *new_oid = op->g.oid;
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Initialize the process to the Proview runtime environment.
 *
 * Example
 * @code
 * pwr_tStatus sts;
 *
 * sts = gdh_Init( "my_appl");
 * if ( EVEN(sts)) throw co_error(sts);
 * @endcode
 */

pwr_tStatus gdh_Init(const char* name /**< Process name */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;

  /* Map the database.  */

  gdbroot = gdb_MapDb(&sts, NULL, name);

  return sts;
}

/*
 * Fetch the meta data of an attribute, given its attrref or its name.
 *
 * If meta data is wanted for a class use the class parameter.
 * The output arguments can be NULL if they are not wanted.
 */
pwr_tStatus gdh_MDAttribute(
    pwr_tClassId cid, /* Class. Use pwr_cNClassId if meta
                          data for an object and not for
                          a class is wanted.  */
    pwr_sAttrRef* arp, /* Use NULL if attrname should be used
                           instead of the attribute reference.  */
    char* aname, /* String containing
                     object.attribute or
                     object.attribute[index]
                     If class data then name of attribute
                     must start with a dot.  */
    pwr_tTypeId* tid, /* Address of an type id where the
                          attribute type will be stored
                          or NULL if not wanted  */
    unsigned int* size, /* Address of an integer where the
                            attribute size will be stored
                            or NULL if not wanted.  */
    unsigned int* offs, /* Address of an integer where the
                            attribute offset will be stored
                            or NULL if not wanted.  */
    unsigned int* elem /* Address of an integer where the
                           number of elements will be stored
                           or NULL if not wanted.  */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  cdh_sParseName parseName;
  cdh_sParseName* pn = NULL;
  mvol_sAttribute attribute;
  mvol_sAttribute* ap = NULL;

  if (arp == NULL) {
    pn = cdh_ParseName(&sts, &parseName, pwr_cNObjid, aname, 0);
    if (pn == NULL)
      return sts;
  }

  memset(&attribute, 0, sizeof(attribute));

  gdh_ScopeLock
  {
    if (arp != NULL) {
      ap = vol_ArefToAttribute(
          &sts, &attribute, arp, gdb_mLo_global, vol_mTrans_all);
    } else if (cid != pwr_cNClassId) {
      ap = mvol_AnameToAttribute(&sts, ap, cid, pn, NULL);
    } else {
      ap = vol_NameToAttribute(&sts, ap, pn, gdb_mLo_global, vol_mTrans_all);
    }

    if (ap != NULL)
      touchObject(ap->op);
  }
  gdh_ScopeUnlock;

  if (ap != NULL) {
    if (size != NULL)
      *size = ap->size;
    if (offs != NULL)
      *offs = ap->offs;
    if (tid != NULL)
      *tid = ap->tid;
    if (elem != NULL)
      *elem = ap->elem;
  }

  return sts;
}

/**
 * @brief  Move a local object.
 *
 * This call is possible only if the object is
 * in a local volume, i.e a volume owned by the local node.
 * The volume must be of class $DynamicVolume or $SystemVolume.
 * All reachable nodes, who have mounted the volume in question,
 * are notified about the move of this object.
 * @return pwr_tStatus
 */
pwr_tStatus gdh_MoveObject(
    pwr_tObjid oid, /**< The object that should be moved. */
    pwr_tObjid poid /**< The object that should become the new parent. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;

  if (cdh_ObjidIsNull(oid))
    return GDH__NOSUCHOBJ;
  if (oid.oix == pwr_cNObjectIx)
    return GDH__NOTMOVABLE;
  if (poid.vid == pwr_cNVolumeId)
    poid.vid = oid.vid;
  if (oid.vid != poid.vid)
    return GDH__SAMEVOLUME;
  if (oid.oix == poid.oix)
    return GDH__CHILDSELF;

  gdh_ScopeLock
  {
    dvol_MoveObject(&sts, oid, poid);
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get the object identity of an object with name 'name'.
 *
 * Example
 * @code
 *   pwr_tOid oid;
 *   pwr_tOName name = "H1-H2-Valve";
 *
 *   sts = gdh_NameToObjid( name, &oid);
 *   if ( EVEN(sts)) throw co_error(sts);
 * @endcode
 * @return pwr_tStatus
 */
pwr_tStatus gdh_NameToObjid(const char* name, /**< The object name. */
    pwr_tObjid* oid /**< receives the identity of the object. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  cdh_sParseName parseName;
  cdh_sParseName* pn;
  gdb_sObject* op = NULL;

  if (name == NULL)
    return GDH__BADARG;
  if (oid == NULL)
    return GDH__BADARG;

  pn = cdh_ParseName(&sts, &parseName, pwr_cNObjid, name, 0);
  if (pn == NULL)
    return sts;

  gdh_ScopeLock
  {
    op = vol_NameToObject(&sts, pn, gdb_mLo_global, vol_mTrans_all);
    if (op != NULL) {
      touchObject(op);
      *oid = op->g.oid;
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get the address of the data of an object,
 * given its name.
 *
 * Only local objects are handled.
 * @return pwr_tStatus
 */
pwr_tStatus gdh_NameToPointer(const char* name, /**< The name of the object. */
    void** p /**< Receives a pointer to the object. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  cdh_sParseName parseName;
  cdh_sParseName* pn;
  gdb_sObject* op = NULL;

  if (name == NULL)
    return GDH__BADARG;
  if (p == NULL)
    return GDH__BADARG;

  pn = cdh_ParseName(&sts, &parseName, pwr_cNObjid, name, 0);
  if (pn == NULL)
    return sts;

  gdh_ScopeLock
  {
    op = vol_NameToObject(&sts, pn, gdb_mLo_global, vol_mTrans_all);
    if (op != NULL)
      *p = vol_ObjectToAddress(&sts, op);
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 *@brief Check if the Nethandler has started.
 *
 * Returns GDH__SUCCESS if the nethandler is running,
 * else GDH__NONETHANDLER.
 *
 * Example
 * @code
 *   // Wait for nethandler to start
 *   while ( EVEN( gdh_NethandlerRunning()))
 *     sleep(5);
 * @endcode
 *@return pwr_tStatus
 */

pwr_tStatus gdh_NethandlerRunning(void)
{
  pwr_tStatus sts = GDH__SUCCESS;

  gdh_ScopeLock
  {
    if (gdbroot->db->nethandler.qix != 0)
      sts = GDH__SUCCESS;
    else
      sts = GDH__NONETHANDLER;
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Converts from name string to attribute reference.
 *
 * Example
 * @code
 * pwr_tStatus sts;
 * pwr_tAttrRef aref;
 * pwr_tAName name = "H1-H2-Temperature.ActualValue";
 *
 * sts = gdh_NameToAttrref( pwr_cNOid, name, &aref);
 * if ( EVEN(sts)) throw co_error(sts);
 * @endcode
 * @return pwr_tStatus
 */
pwr_tStatus gdh_NameToAttrref(
    pwr_tObjid
        poid, /**< This object is added to the Name argument to
                   form the complete name of the object/attribute.
                   It should be specified as pwr_cNobjid if it is not used.*/
    const char*
        name, /**< The argument is added to the parent to form the
                   complete item name. If the parent argument is supplied as
                   pwr_cNobjid, this argument is considered to describe the
                   full name. */
    pwr_sAttrRef* arp /**< The resulting attribute reference descriptor. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  cdh_sParseName parseName;
  cdh_sParseName* pn;
  mvol_sAttribute attribute;
  mvol_sAttribute* ap;

  if (arp == NULL)
    return GDH__BADARG;

  pn = cdh_ParseName(&sts, &parseName, poid, name, 0);
  if (pn == NULL)
    return sts;

  memset(&attribute, 0, sizeof(attribute));

  gdh_ScopeLock
  {
    ap = vol_NameToAttribute(
        &sts, &attribute, pn, gdb_mLo_global, vol_mTrans_all);
    if (ap == NULL)
      break;

    touchObject(ap->op);
    mvol_AttributeToAref(&sts, ap, arp);
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get the name of an object identified by its object identity.
 *
 * Example
 * @code
 * pwr_tStatus sts;
 * pwr_tOName name;
 *
 * sts = gdh_ObjidToName( oid, name, sizeof(name), cdh_mName_volumeStrict);
 * if ( EVEN(sts)) throw co_error(sts);
 * @endcode
 * The caller is responsible for supplying a sufficient buffer.
 * @return pwr_tStatus
 */
pwr_tStatus gdh_ObjidToName(pwr_tObjid oid, /**<  Object id of an object.  */
    char* namebuf, /**<  A buffer where the name can be put.  */
    pwr_tUInt32 size, /**<  Size of namebuf.  */
    pwr_tBitMask nametype /**<  Mask of type cdh_mName.  */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  char name[512];
  char* s = NULL;
  pwr_tInt32 len;
  cdh_mName lnametype;
  gdb_sObject* op;

  if (namebuf == NULL)
    return GDH__BADARG;

  if (nametype == cdh_mNName)
    lnametype.m = cdh_mName_pathStrict;
  else
    lnametype.m = nametype;

  if (cdh_ObjidIsNull(oid))
    return GDH__NOSUCHOBJ;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_global, vol_mTrans_none, cvol_eHint_none);
    if (op == NULL)
      break;

    touchObject(op);
    s = vol_ObjectToName(&sts, op, lnametype.m, name);
  }
  gdh_ScopeUnlock;

  if (op == NULL && lnametype.b.fallback != cdh_mName_eFallback_strict) {
    sts = GDH__SUCCESS;
    cdh_OidToString(name, sizeof(name), oid, 1);
    s = name;
  }

  if (s != NULL) {
    len = strlen(s);
    if (len >= size)
      sts = GDH__NAMEBUF;
    strncpy(namebuf, s, len + 1);
  }

  return sts;
}

/**
 * @brief Gets the address of the data of an object, given its
 * object identity.
 *
 * Nota bene ! Only local objects can be referenced.
 *
 * @return pwr_tStatus
 */
pwr_tStatus gdh_ObjidToPointer(pwr_tObjid oid, /**< The object identity. */
    void** p /**< Reveives a pointer to the object. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;

  if (p == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_native, vol_mTrans_all, cvol_eHint_none);
    if (op == NULL)
      break;

    if (op->u.n.lflags.b.readOnly) {
      sts = GDH__READONLY;
      break;
    }

    *p = vol_ObjectToAddress(&sts, op);
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get a pointer to a mount object.
 * @return pwr_tStatus
 */
pwr_tStatus gdh_MountObjidToPointer(pwr_tObjid oid, /**< The object identity. */
    void** p /**< Reveives a pointer to the object. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;

  if (p == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_native, vol_mTrans_none, cvol_eHint_none);
    if (op != NULL)
      *p = vol_ObjectToAddress(&sts, op);
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Gets the address of the data of an attribute reference.
 *
 * Nota bene ! Only local objects can be referenced.
 *
 * @return pwr_tStatus
 */
pwr_tStatus gdh_AttrRefToPointer(pwr_sAttrRef* arp, /**< Attribute reference. */
    void** p /**< Reveives a pointer to the object. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;

  if (p == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, arp->Objid, gdb_mLo_native, vol_mTrans_all, cvol_eHint_none);
    if (op == NULL)
      break;

    if (op->u.n.lflags.b.readOnly) {
      sts = GDH__READONLY;
      break;
    }

    *p = vol_ObjectToAddress(&sts, op);
    *p = (char*)*p + arp->Offset;
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Rename a local object.
 *
 * This call is possible only if the object is
 * in a local volume, i.e a volume owned by the local node.
 * The volume must be of class $DynamicVolume or $SystemVolume.
 *  All reachable nodes, who have mounted the volume in question,
 * are notified about the renaming of this object.
 * @return pwr_tStatus
 */

pwr_tStatus gdh_RenameObject(
    pwr_tObjid oid, /**< The object identity that should be renamed.*/
    char* name /**< The new name. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  cdh_sParseName parseName;
  cdh_sParseName* pn;

  if (name == NULL)
    return GDH__BADARG;

  pn = cdh_ParseName(&sts, &parseName, pwr_cNObjid, name, 0);
  if (pn == NULL || pn->nObject != 1 || pn->flags.b.idString)
    return GDH__BADNAME;

  gdh_ScopeLock
  {
    dvol_RenameObject(&sts, oid, pn);
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Change the value of an attribute or the whole body of an object.
 *
 * The routine stalls until the operation is performed.
 * The caller is responsible for the information in the buffer.
 * If the buffer is shorter then what is required,
 * then a partial update takes place.
 *
 * Example
 * @code
 * pwr_tStatus sts;
 * pwr_tOName name = "H1-H2-Temperature.ActualValue";
 * pwr_tFloat32 value = 1.23;
 *
 * sts = gdh_SetObjectInfo( name, &value, sizeof(value));
 * if ( EVEN(sts)) throw co_error(sts);
 * @endcode
 * @return pwr_tStatus
 */

pwr_tStatus gdh_SetObjectInfo(
    const char* name, /**< The name of the object or object attribute.*/
    void* bufp, /**< Pointer to the data. */
    unsigned int bufsize /**< The size in bytes of the data buffer. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  cdh_sParseName parseName;
  cdh_sParseName* pn;
  mvol_sAttribute attribute;
  mvol_sAttribute* ap;
  gdb_sVolume* vp;
  gdb_sNode* np = NULL;
  pwr_sAttrRef aref;
  pwr_sAttrRef* arp = NULL;
  void* p;
  pwr_sAttrRef raref;
  pwr_sAttrRef* rarp = NULL;
  gdb_sCclass* ccp = NULL;
  gdb_sCclass* ccpLocked = NULL;
  pwr_tBoolean equal = 0;
  pwr_tBoolean fetched;
  pwr_tUInt32 ridx = UINT_MAX;

  if (name == NULL)
    return GDH__BADARG;
  if (bufp == NULL)
    return GDH__BADARG;

  pn = cdh_ParseName(&sts, &parseName, pwr_cNObjid, name, 0);
  if (pn == NULL)
    return sts;

  memset(&attribute, 0, sizeof(attribute));

  gdh_Lock;

  do {
    ap = vol_NameToAttribute(
        &sts, &attribute, pn, gdb_mLo_global, vol_mTrans_all);
    if (ap == NULL || ap->op == NULL)
      break;

    if (ap->op->u.n.lflags.b.readOnly
        || (ap->adef && ap->adef->Info.Flags & PWR_MASK_CONST)) {
      sts = GDH__READONLY;
      break;
    }

    touchObject(ap->op);
    p = vol_AttributeToAddress(&sts, ap);
    if (p != NULL) {
      memcpy(p, bufp, MIN(ap->size, bufsize));
      break;
    } else if ((ap->op->l.flags.m & gdb_mLo_native) != 0) {
      break;
    }

    /* Try remote.  */

    memset(&aref, 0, sizeof(aref));
    arp = mvol_AttributeToAref(&sts, ap, &aref);
    if (arp == NULL)
      break;

    vp = pool_Address(NULL, gdbroot->pool, ap->op->l.vr);
    np = pool_Address(NULL, gdbroot->pool, vp->l.nr);
    if (np == NULL)
      break;

    ccp = NULL;
    /* Get cached class if needed */
    if (!ap->op->u.c.flags.b.classChecked || !ap->op->u.c.flags.b.classEqual) {
      ccp = cmvolc_GetCachedClass(&sts, np, vp, ap, &equal, &fetched, NULL);
      if (EVEN(sts)) {
        np = NULL;
        break;
      }
      if (equal)
        ccp = NULL;

      if (ccpLocked == NULL && ccp != NULL && !equal) {
        cmvolc_LockClass(NULL, ccp);
        ccpLocked = ccp;
      }

      /* If gdb has been unlocked, refresh pointers */
      /** @todo Check if we can do it more efficient, eg. vol_ArefToAttribute */
      if (fetched) {
        memset(&attribute, 0, sizeof(attribute));
        np = NULL;
        continue;
      }

      if (equal)
        break;

      rarp = ndc_NarefToRaref(
          &sts, ap, arp, ccp, &ridx, &raref, &equal, pn, ccpLocked, vp, np);
    }
    break;
  } while (1);

  gdh_Unlock;

  if (np != NULL && ODD(sts)) {
    if (equal)
      cvolc_SetObjectInfo(
          &sts, np, arp, NULL, NULL, UINT_MAX, ap, bufp, bufsize);
    else
      cvolc_SetObjectInfo(&sts, np, arp, ccp, rarp, ridx, ap, bufp, bufsize);
  }

  if (gdh_log_cb && ODD(sts))
    gdh_log_cb((char *)name, bufp, bufsize);

  if (ccpLocked) {
    gdb_Lock;
    cmvolc_UnlockClass(NULL, ccpLocked);
    gdb_Unlock;
  }

  return sts;
}

/**
 * @brief Change the data of an object or an attribute.
 *
 * The routine stalls until the operation is performed. The caller
 * is responsible for the information in the buffer. If the buffer
 * is shorter then what is required, then a partial update takes place.
 *
 * Example
 * @code
 * pwr_tStatus sts;
 * pwr_tFloat32 value = 1.23;
 *
 * sts = gdh_SetObjectInfoAttrref( &aref, &value, sizeof(value));
 * if ( EVEN(sts)) throw co_error(sts);
 * @endcode
 * @return pwr_tStatus
 */

pwr_tStatus gdh_SetObjectInfoAttrref(
    pwr_sAttrRef*
        arp, /**< Supplies the attribute reference decriptor that defines
                  an object or an object and attribute. */
    void* bufp, /**< Pointer to the data. */
    unsigned int bufsize /**< The size in bytes of the data buffer. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  mvol_sAttribute attribute;
  mvol_sAttribute* ap;
  gdb_sVolume* vp;
  gdb_sNode* np = NULL;
  void* p;
  gdb_sCclass* ccp = NULL;
  gdb_sCclass* ccpLocked = NULL;
  pwr_sAttrRef raref;
  pwr_sAttrRef* rarp = NULL;
  pwr_tBoolean equal = 0;
  pwr_tBoolean fetched;
  pwr_tUInt32 ridx = UINT_MAX;

  if (arp == NULL)
    return GDH__BADARG;
  if (bufp == NULL)
    return GDH__BADARG;

  memset(&attribute, 0, sizeof(attribute));

  gdh_Lock;
  do {
    ap = vol_ArefToAttribute(
        &sts, &attribute, arp, gdb_mLo_global, vol_mTrans_all);
    if (ap == NULL || ap->op == NULL)
      break;

    if (ap->op->u.n.lflags.b.readOnly
        || (ap->adef && ap->adef->Info.Flags & PWR_MASK_CONST)) {
      sts = GDH__READONLY;
      break;
    }

    touchObject(ap->op);
    p = vol_AttributeToAddress(&sts, ap);
    if (p != NULL) {
      memcpy(p, bufp, MIN(ap->size, bufsize));
      break;
    } else if ((ap->op->l.flags.m & gdb_mLo_native) != 0) {
      break;
    }

    /* Try remote.  */
    sts = GDH__SUCCESS;

    vp = pool_Address(NULL, gdbroot->pool, ap->op->l.vr);
    np = pool_Address(NULL, gdbroot->pool, vp->l.nr);

    if (np == NULL)
      break;

    ccp = NULL;
    /* Get cached class if needed */
    if (!ap->op->u.c.flags.b.classChecked || !ap->op->u.c.flags.b.classEqual) {
      ccp = cmvolc_GetCachedClass(&sts, np, vp, ap, &equal, &fetched, NULL);
      if (EVEN(sts)) {
        np = NULL;
        break;
      }
      if (equal)
        ccp = NULL;

      if (ccpLocked == NULL && ccp != NULL && !equal) {
        cmvolc_LockClass(NULL, ccp);
        ccpLocked = ccp;
      }

      /* If gdb has been unlocked, refresh pointers */
      if (fetched) {
        memset(&attribute, 0, sizeof(attribute));
        np = NULL;
        continue;
      }

      if (equal)
        break;

      rarp = ndc_NarefToRaref(
          &sts, ap, arp, ccp, &ridx, &raref, &equal, NULL, ccpLocked, vp, np);
    } else
      equal = ap->op->u.c.flags.b.classEqual;

    break;

  } while (1);

  gdh_Unlock;

  if (np != NULL && ODD(sts)) {
    if (equal)
      cvolc_SetObjectInfo(
          &sts, np, arp, NULL, NULL, UINT_MAX, ap, bufp, bufsize);
    else
      cvolc_SetObjectInfo(&sts, np, arp, ccp, rarp, ridx, ap, bufp, bufsize);
  }

  if (ccpLocked) {
    gdb_Lock;
    cmvolc_UnlockClass(NULL, ccpLocked);
    gdb_Unlock;
  }

  return sts;
}

/**
 * @brief Sets up a list of subscriptions to an object/attribute.
 *
 * Much more efficient way to establish a number of subscriptions than
 * calling gdh_SubRefObjectInfoAttrref or gdh_SubRefObjectInfoName
 * @return pwr_tStatus
 */

pwr_tStatus gdh_SubRefObjectInfoList(
    unsigned int nentries, /**< Number of entries in the object[],
                               attrref[] and subid[] arrays.  */

    void* object[], /**< The address of an array with
                        either the address of a name string
                        or the address of an pwr_sAttrRef
                        identifying the objects or parameters
                        to establish subscriptions for.  */

    pwr_tBoolean is_aref[], /**< True if the corresponding object[]
                                entry is an attrref. Otherwise it
                                is regarded as a name string.  */

    pwr_tSubid subid[] /**< Returned handles with index matching
                           the object argument. The array must be
                           declared by the caller.  */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  sub_sClient* cp;
  pool_sQlink* lh;
  pwr_tUInt32 i;
  char* s;
  pwr_sAttrRef* arp;

  gdh_ScopeLock
  {
    /* Allocate a temporary list header */

    lh = pool_Qalloc(NULL, gdbroot->pool);

    for (i = 0; i < nentries; i++) {
      /* Build subcli structure */

      if (is_aref[i]) {
        s = NULL;
        arp = object[i];
      } else {
        s = object[i];
        arp = NULL;
      }

      cp = subc_Create(s, arp, lh);

      if (subid)
        subid[i] = cp->sid;
    }

    /* Try to get it running */

    subc_ActivateList(lh, pwr_cNObjid);

    /* Get rid of temporary root */

    pool_Free(NULL, gdbroot->pool, lh);
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief This routine returns a subid to the information that is
 * denoted by 'aref'. The name can be either an object or an
 * object attribute.
 *
 * Since this routine operates on a single data item, it is
 * pretty slow. For faster setup of many subscriptions in one
 * call, use gdh_SubRefObjectInfoList.
 * @return pwr_tStatus
 */

pwr_tStatus gdh_SubRefObjectInfoAttrref(
    pwr_sAttrRef* aref, /**< Reference to an object.attribute.  */
    pwr_tSubid* sid /**< Returned handle.  */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  pwr_tBoolean true_flag = TRUE;

  if (aref == NULL)
    return GDH__BADARG;
  if (sid == NULL)
    return GDH__BADARG;

  sts = gdh_SubRefObjectInfoList(1, (void*)&aref, &true_flag, sid);

  return sts;
}

/**
 * @brief Get the address of the data that is denoted by 'name'.
 *
 * The name can be either a whole object or an object attribute.
 *
 * Since this routine operates on a single data item, it is
 * pretty slow. For faster setup of many subscriptions in one
 * call, use gdh_SubRefObjectInfoList.
*/
pwr_tStatus gdh_SubRefObjectInfoName(
    char* name, /**< Name of an object or object.attribute. */
    pwr_tSubid* sid /**< Returned handle. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  pwr_tBoolean false_flag = FALSE;

  if (name == NULL)
    return GDH__BADARG;
  if (sid == NULL)
    return GDH__BADARG;

  sts = gdh_SubRefObjectInfoList(1, (void*)&name, &false_flag, sid);

  return sts;
}

/**
 * @brief Terminates a list of subscriptions.
 *
 * All invalid pwr_tSubids remain in the list. The valid pwr_tSubids are zeroed
 * out!
 *
 * @return pwr_tStatus
 */
pwr_tStatus gdh_SubUnrefObjectInfoList(
    unsigned int nentries, /**< # of pwr_tSubids in the array.  */
    pwr_tSubid* sid /**< Array of subscriptions to terminate.  */
    )
{
  pwr_tStatus retsts = GDH__SUCCESS;
  pwr_tStatus sts = GDH__SUCCESS;
  sub_sClient* cp = NULL;
  pool_sQlink* lh;
  pwr_tUInt32 i;
  cdh_uRefId rid;

  if (sid == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    /* Allocate a temporary root */

    lh = pool_Qalloc(NULL, gdbroot->pool);

    for (i = 0; i < nentries; i++) {
      rid.pwr = sid[i];

      if (rid.r.vid_3 != cdh_eVid3_subid) /* Verify Subid.  */
        sts = GDH__NOSUBCLI;
      else
        cp = hash_Search(&sts, gdbroot->subc_ht, &sid[i]);

      if (EVEN(sts)) {
        retsts = (sts & ~STS_M_SEVERITY) | STS_K_INFO;
      } else {
        /* Move the subscription client to the temporary list.  */

        pool_Qremove(NULL, gdbroot->pool, &cp->subc_ll);
        pool_QinsertPred(NULL, gdbroot->pool, &cp->subc_ll, lh);

        /* Tell the caller this was a valid subid by zeroing it
           leaving the invalid ones in the list...  */

        sid[i] = pwr_cNSubid;
      }
    }

    /* Cancel all clients in the temporary list.  */

    subc_CancelList(lh);

    /* Get rid of temporary root.  */

    pool_Free(NULL, gdbroot->pool, lh);
  }
  gdh_ScopeUnlock;

  return retsts;
}

/**
 *@brief Terminates subscription of an object or an attribute.
 *
 *@return pwr_tStatus
 */

pwr_tStatus gdh_SubUnrefObjectInfo(
    pwr_tSubid sid /**< Subscription to terminate.  */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  pwr_tSubid sidlst = sid;

  sts = gdh_SubUnrefObjectInfoList(1, &sidlst);
  if (cdh_SubidIsNotNull(sidlst))
    sts = (sts & ~STS_M_SEVERITY) | STS_K_ERROR;

  return sts;
}

/**
 * @brief Terminates all subscriptions set up by this user (job/process).
 *
 */

void gdh_SubUnrefObjectInfoAll(void)
{
  gdh_ScopeLock
  {
    subc_CancelUser(gdbroot->my_pid);
  }
  gdh_ScopeUnlock;
}

/**
 * @brief Fetch the data associated with a subscription.
 */
pwr_tStatus gdh_SubData(
    pwr_tSubid sid, /**<  Subscription to fetch data from.  */
    void* bp, /**<  User supplied buffer where data is put.  */
    unsigned int bsize /**<  Size in bytes of user buffer.  */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  sub_sClient* cp;
  const void* p = NULL;
  net_sSubData* dp;
  mvol_sAttribute attribute;
  mvol_sAttribute* ap;

  if (bp == NULL)
    return GDH__BADARG;
  memset(&attribute, 0, sizeof(attribute));

  gdh_ScopeLock
  {
    cp = hash_Search(&sts, gdbroot->subc_ht, &sid);
    if (cp == NULL)
      break;

    if (EVEN(cp->sts)) {
      sts = cp->sts;
      break;
    }

    if ((cp->nid == gdbroot->db->nid) && (cp->userdata == pool_cNRef)) {
      /*  Handle local object references without user buffers.  */

      ap = vol_ArefToAttribute(
          &sts, &attribute, &cp->aref, gdb_mLo_global, vol_mTrans_all);
      if (ap == NULL)
        break;

      p = vol_AttributeToAddress(&sts, ap);
    } else {
      /*  Handle all other object references.  */

      if (cp->old) {
        sts = GDH__SUBOLD;
      } else {
        dp = pool_Address(NULL, gdbroot->pool, cp->subdata);
        if (dp == NULL)
          errh_Bugcheck(GDH__WEIRD, "gdh_SubData");
        p = &dp->data[0];
      }
    }

    /*  If all is fine, copy data to user buffer.  */

    if (ODD(sts)) {
      if (cp->cclass != pool_cNRef) {
        gdb_sCclass* ccp;
        ndc_sRemoteToNative* tbl;
        pwr_tUInt32 size;
        pwr_tBoolean first = 1;

        ccp = pool_Address(NULL, gdbroot->pool, cp->cclass);
        if (ccp == NULL)
          errh_Bugcheck(GDH__WEIRD, "gdh_SubData, get cached class address");

        if (!ccp->flags.b.rnConv)
          errh_Bugcheck(GDH__WEIRD, "gdh_SubData, no conversion table");

        tbl = pool_Address(NULL, gdbroot->pool, ccp->rnConv);
        if (tbl == NULL)
          errh_Bugcheck(GDH__WEIRD, "gdh_SubData, get cached class address");

        size = MIN(bsize, cp->aref.Size);
        ndc_ConvertRemoteToNativeTable(&sts, ccp, tbl, &cp->raref, &cp->aref,
            bp, p, &size, cp->aref.Offset, 0, 0, &first, cp->nid);

      } else
        memcpy(bp, p, MIN(bsize, cp->aref.Size));
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Fetch the data size associated with a subscription.
 */
pwr_tStatus gdh_SubSize(pwr_tSubid sid, /**<  Subscription referenced.  */
    unsigned int* size /**<  Subscription size in bytes.  */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  sub_sClient* cp;

  if (size == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    cp = hash_Search(&sts, gdbroot->subc_ht, &sid);
    if (cp == NULL)
      break;

    if (EVEN(cp->sts)) {
      sts = cp->sts;
    } else {
      *size = cp->aref.Size;
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 *@brief Associate a buffer with the subscription.
 *
 * If a buffer already is associated, that buffer
 * will be returned, if compatible in size.
 * Otherwise an error will be returned.
 * @return pwr_tStatus
 */

pwr_tStatus gdh_SubAssociateBuffer(
    pwr_tSubid sid, /**< Subscription referenced.  */
    void** buffer, /**< Address of buffer that gets allocated
                        for the caller.  */
    unsigned int buffersize /**< Requested size in bytes of user buffer.  */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  sub_sClient* cp;

  if (buffer == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    cp = hash_Search(&sts, gdbroot->subc_ht, &sid);
    if (cp == NULL)
      break;

    if (cp->userdata == pool_cNRef) {
      cp->userdata = pool_RefAlloc(NULL, gdbroot->rtdb, buffersize);
      cp->usersize = buffersize;
      *buffer = pool_Address(NULL, gdbroot->rtdb, cp->userdata);
    } else {
      if (cp->usersize >= buffersize) { /** todo !!! Try to understand this
                                           code!, LW?
                                           I think it shall be usersize instead
                                           of userdata, ML.
                                           Please verify.*/
        *buffer = pool_Address(NULL, gdbroot->rtdb, cp->userdata);
      } else {
        sts = GDH__SUBALRBUF;
      }
    } /* Previous buffer */
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Sets default subscription timers for future subscription
 * requests.
 *
 * Supply negative values for no change.
 * A value of zero resets the default values.
 */

pwr_tStatus gdh_SetSubscriptionDefaults(
    pwr_tInt32 dt, /**<  Default update time for subscription
                       requests to come, in ms.  */
    pwr_tInt32 tmo /**<  Default timeout (i.e. time until
                       data gets flagged as old), in ms.  */
    )
{
  subc_SetDefaults(dt, tmo);
  return GDH__SUCCESS;
}

/**
 * @brief  This routine returns addresses to the information that is
 * denoted by "objref[].fullname".
 *
 * The name can be either an
 * object or an object parameter. Optionally, the subid array
 * can be supplied. If there is such an argument, it is assumed
 * to have n elements. This can be used to retrieve further info
 * about a particular subscription.
 * If a NULL address is received in an objref[].adrs,
 * that particular subscription never was requested due
 * to some error.
 *
 * This routine remains only because of compatibility with
 * applications that uses the GDH V1 interface. The logic is
 * emulated using the new, GDH V2 interface. The only internal
 * knowledge is about Subids, if the high byte is 0 then it
 * is a Dlid, otherwise a Subid!
 */

pwr_tStatus gdh_RefObjectInfoList(
    unsigned int n, /**<  # of entries in objref and subid.  */
    gdh_sObjRef* objref, /**<  Input:
                               Name list: objects or object.attributes
                               Output:
                               Address list.  */
    pwr_tSubid* sid /**<  Subids corresponding to objrefs.
                          If supplied as NULL, it is ignored.  */
    )
{
  pwr_tStatus sts, rsts = GDH__SUCCESS;
  pwr_tUInt32 i;
  OBJREF_STRUCT* objrefp;
  pwr_tSubid* subidarr;
  pwr_tUInt32* xrefarr;
  pwr_sAttrRef aref;
  char** object;
  char** objp;
  pwr_tUInt32 nsub;
  pwr_tBoolean dl;
  pwr_tDlid dlid;
  pwr_tBoolean* isattrref;

  /* Allocate space for the object array and the subid array
     needed by SubRefObjectInfoList. If we assume that
     all entries in objref will be subscriptions the logic becomes simple!  */

  object = calloc(n, sizeof(*object));
  xrefarr = calloc(n, sizeof(pwr_tUInt32));
  subidarr = calloc(n, sizeof(pwr_tSubid));
  isattrref = calloc(n, sizeof(pwr_tBoolean));

  /* Go through the objrefs. Set up direct links if local reference,
     accumulate in object[] array for a later call to set up subscriptions
     if this is a remote object.  */

  nsub = 0; /* Keep track of subscription count */

  objrefp = &objref[0];
  objp = &object[0];
  for (i = 0; i < n; i++, objrefp++) {
    sts = gdh_NameToAttrref(pwr_cNObjid, objrefp->fullname, &aref);
    if (EVEN(sts)) {
      pwr_tAName an;
      pwr_tOid oid;
      char* s;
      pwr_tStatus lsts;

      if ( sts == GDH__NODYNLOCOBJ) {
	rsts = sts;
	continue;
      }
	
      dl = 0;

      /* Check if this is an erroneous local attribute */
      strcpy(an, objrefp->fullname);
      if ((s = strchr(an, '.'))) {
        *s = 0;
        lsts = gdh_NameToObjid(an, &oid);
        if (ODD(lsts)) {
          gdh_GetObjectLocation(oid, &dl);
          if (dl) {
            rsts = sts;
            continue;
          }
        }
      }
    } else {
      gdh_GetObjectLocation(aref.Objid, &dl);
    }

    /*  If dl == TRUE, then direct link, else subscribe!  */

    if (dl) {
      dlid = pwr_cNDlid;
      objrefp->adrs = NULL;
      gdh_DLRefObjectInfoAttrref(&aref, &objrefp->adrs, &dlid);
      if (sid != NULL)
        sid[i] = dlid;
    } else {
      *objp = (char*)&objrefp->fullname;
      isattrref[nsub] = FALSE;
      xrefarr[nsub++] = i;
      objp++;
    }
  } /* For all objref struct entries */

  /* Establish subscriptions.  */

  if (nsub > 0) {
    gdh_SubRefObjectInfoList(nsub, (void*)object, isattrref, subidarr);

    /* Associate buffers and return pwr_tSubid if requested.  */

    for (i = 0; i < nsub; i++) {
      objrefp = &objref[xrefarr[i]];
      if (objrefp->bufsize == 0) {
        free(subidarr);
        free(xrefarr);
        free(isattrref);
        free(object);
        return GDH__BADARG;
      }
      gdh_SubAssociateBuffer(subidarr[i], &objrefp->adrs, objrefp->bufsize);
      if (sid != NULL)
        sid[xrefarr[i]] = subidarr[i];
    }
  }

  /* Free all resources.   */

  free(subidarr);
  free(xrefarr);
  free(isattrref);
  free(object);

  return rsts;
}

/**
 * @brief The routine returns an address to the data that is denoted by Name.
 * The name can be either an object or an object attribute.
 *
 * If the object is known and is local, this call will result in a
 * gdh_DLRefObjectInfo,
 * otherwise it will result in a gdh_SubRefObjectInfo.
 *
 * Some important considerations:<BR>
 * This call is preferable to gdh_NameToPointer or gdh_ObjidToPointer since it
 * prevents
 * the data from being removed until you dereference it.
 * If you need data repeatedly use the gdh_RefObject routines, for a single
 * request use
 * gdh_GetObjectInfo.
 * You may read and write data on the local node. But if the data exists on
 * another
 * node writing will have no effect, since the data will be overwritten by the
 * next
 * subscription update. If you need to write data on another node use
 * gdh_SetObjectInfo.
 * If you want to issue several requests at the same time use
 * gdh_RefObjectInfoList,
 * this is much more efficient than repeated calls to gdh_RefObjectInfo.
 * @see gdh_UnrefObjectinfo
 *
 * Example
 * @code
 * pwr_tStatus sts;
 * pwr_tOName name = "H1-H2-Temperature.ActualValue";
 * pwr_tSubid subid;
 * pwr_tFloat32 *valuep;
 *
 * sts = gdh_RefObjectInfo( name, &valuep, &subid, sizeof(*valuep));
 * if ( EVEN(sts)) throw co_error(sts);
 * ...
 * sts = gdh_UnrefObjectInfo( subid);
 * @endcode
 * @see gdh_UnrefObjectInfo();
 * @return pwr_tStatus
 */
pwr_tStatus gdh_RefObjectInfo(
    char* name, /**<Supplies the name of an object or object and attribute.*/
    void** infop, /**<Receives a pointer to the requested information.  */
    pwr_tSubid* sid, /**<Receives the subscription identity. */
    unsigned int size /**<Size of the subscribed data. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdh_sObjRef objref;

  if (infop == NULL)
    return GDH__BADARG;
  if (name == NULL)
    return GDH__BADARG;
  if (strlen(name) >= sizeof(objref.fullname))
    return GDH__NAMELEN;

  objref.bufsize = size;

  strncpy((char*)&objref.fullname, name, sizeof(objref.fullname));

  sts = gdh_RefObjectInfoList(1, &objref, sid);
  if (ODD(sts) && objref.adrs == NULL)
    return GDH__RTDBNULL;
  if (ODD(sts))
    *infop = objref.adrs;

  return sts;
}

/**
 *@brief Terminates the subscription defined by the
 * subscription identity.
 *
 * The pointer returned by for example gdh_RefObjectInfo
 * is invalid after this call.
 *
 * N.B.! The user is responsible for removing all subscriptions
 * before terminating a process, the system will not do it for you.
 * This call will result in either a gdh_DLUnrefObjectInfo or a
 * gdh_SubUnrefObjectInfo.
 * @see gdh_RefObjectInfo, gdh_DLUnrefObjectInfo, gdh_SubUnrefObjectInfo
 * @return pwr_tStatus
 */
pwr_tStatus gdh_UnrefObjectInfo(
    pwr_tSubid sid /**<The subscription to terminate. */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  cdh_uRefId refid;

  refid.pwr = sid;

  if (refid.r.vid_3 == cdh_eVid3_dlid) {
    sts = gdh_DLUnrefObjectInfo(sid);
  } else if (refid.r.vid_3 == cdh_eVid3_subid) {
    sts = gdh_SubUnrefObjectInfo(sid);
  } else {
    sts = GDH__NOSUBCLI;
  }

  return sts;
}

/**
 *@brief Terminates all subscriptions set up by this process.
 *
 * This call will result in either a gdh_DLUnrefObjectInfoAll or a
 * gdh_SubUnrefObjectInfoAll.
 * @see gdh_DLUnrefObjectInfoAll, gdhSubUnrefObjectInfoAll
 * @return pwr_tStatus
 */
pwr_tStatus gdh_UnrefObjectInfoAll(void)
{
  gdh_DLUnrefObjectInfoAll();
  gdh_SubUnrefObjectInfoAll();

  return GDH__SUCCESS;
}

/**
 * @brief This routine sets the alarm level for a certain object.
 *
 * The alarm level is propagated upwards to its parents as
 * long as the new alarm level is higher than the old.
 * @return pwr_tStatus
 */

pwr_tStatus gdh_SetAlarmLevel(
    pwr_tObjid oid, /**< Object identity for the object */
    pwr_tUInt32 alarmlevel /**< New alarm level */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_owned, vol_mTrans_none, cvol_eHint_none);
    if (op == NULL)
      break;

    touchObject(op);

    vol_SetAlarmLevel(&sts, op, alarmlevel);
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 *@brief  Sets the alarm block level for a certain object.
 *
 * The block level is propagated upwards to its parents as
 * long as the new alarm level is higher than the old.
 * @return pwr_tStatus
 */
pwr_tStatus gdh_SetAlarmBlockLevel(
    pwr_tObjid oid, /**< Object identity for the object */
    pwr_tUInt32 blocklevel /**< New block level */
    )
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_owned, vol_mTrans_none, cvol_eHint_none);
    if (op == NULL)
      break;

    touchObject(op);

    vol_SetBlockLevel(&sts, op, blocklevel);
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief  Convert pointer to rtdb relative pointer.
 */
void gdh_StoreRtdbPointer(unsigned long* rp, void* p)
{
  pool_tRef r;

  if (rp == NULL)
    return;

  if (p == NULL) {
    r = pool_cNRef;
  } else {
    r = pool_Reference(NULL, gdbroot->rtdb, p);
    if (r == pool_cNRef)
      errh_Bugcheck(GDH__RTDBNULL, "gdh_StoreRtdbPointer");
  }
  *rp = r;
}

/**
 * @brief  Convert rtdb relative pointer to absolute pointer.
 * @return pwr_tStatus
 */
void* gdh_TranslateRtdbPointer(unsigned long r)
{
  return pool_Address(NULL, gdbroot->rtdb, r);
}

pwr_tStatus gdh_IsAlias(pwr_tObjid oid, pwr_tBoolean* is_alias)
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;

  if (is_alias == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_global, vol_mTrans_none, cvol_eHint_none);
    if (op != NULL) {
      touchObject(op);
      *is_alias = (pwr_tBoolean)op->g.flags.b.isAliasClient;
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

pwr_tStatus gdh_IsMountClean(pwr_tObjid oid, pwr_tBoolean* is_mount_clean)
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;

  if (is_mount_clean == NULL)
    return GDH__BADARG;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_global, vol_mTrans_none, cvol_eHint_none);
    if (op != NULL) {
      touchObject(op);
      if (!op->l.flags.b.isOwned) {
        *is_mount_clean = 1;
        sts = GDH__REMOTE;
        break;
      }
      *is_mount_clean = (pwr_tBoolean)op->u.n.flags.b.isMountClean;
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

pwr_tStatus gdh_SetCache(
    pwr_tUInt32 activation_level, /*  Level when trimming starts.  */
    pwr_tUInt32 trimmed_level /*  Trimmed cache level.  */
    )
{
  return GDH__OBSOLETE;
}

/**
 * @brief Get the first volume.
 *
 * Other volumes can be fetched with gdh_GetNextVolume.
 *
 * Example
 * @code
 * pwr_tStatus sts;
 * pwr_tVid vid;
 * pwr_tObjName vname;
 *
 * // Get all volumes
 * for ( sts = gdh_GetVolumeList( &vid); ODD(sts); sts = gdh_GetNextVolume( vid,
 * &vid)) {
 *   sts = gdh_VolumeIdToName( vid, vname, sizeof(vname));
 *   if (EVEN(sts)) throw co_error(sts);
 *
 *   std::cout << "Volume: " << vname << '\n';
 * }
 * @endcode
 * @see gdh_GetNextVolume
 * @return pwr_tStatus
 */
pwr_tStatus gdh_GetVolumeList(
    pwr_tVid* vid /**< Recieves the volume identity for the first volume. */
    )
{
  pool_sQlink* vl;
  gdb_sVolume* vp;

  gdh_ScopeLock
  {
    vl = pool_Qsucc(NULL, gdbroot->pool, &gdbroot->db->vol_lh);
    if (vl == NULL || vl == &gdbroot->db->vol_lh)
      return GDH__NOSUCHVOL;

    vp = pool_Qitem(vl, gdb_sVolume, l.vol_ll);

    *vid = vp->g.vid;
  }
  gdh_ScopeUnlock;
  return GDH__SUCCESS;
}

/**
 * @brief Get the next volume in the volume list.
 *
 * The first volume can be fetched with gdh_GetVolumeList.
 * @see Example in gdh_GetVolumeList
 * @return pwr_tStatus
 */
pwr_tStatus gdh_GetNextVolume(pwr_tVid pvid, pwr_tVid* vid)
{
  pool_sQlink* vl;
  gdb_sVolume* vp;
  pwr_tStatus sts;
  pwr_tStatus rsts = GDH__NOSUCHVOL;

  gdh_ScopeLock
  {
    for (vl = pool_Qsucc(NULL, gdbroot->pool, &gdbroot->db->vol_lh);
         vl != &gdbroot->db->vol_lh; vl = pool_Qsucc(&sts, gdbroot->pool, vl)) {
      vp = pool_Qitem(vl, gdb_sVolume, l.vol_ll);
      if (vp->g.vid == pvid) {
        for (vl = pool_Qsucc(&sts, gdbroot->pool, vl);
             vl != &gdbroot->db->vol_lh;
             vl = pool_Qsucc(&sts, gdbroot->pool, vl)) {
          vp = pool_Qitem(vl, gdb_sVolume, l.vol_ll);
          if (vp->l.flags.b.isLoaded || vp->l.flags.b.isCached) {
            *vid = vp->g.vid;
            rsts = GDH__SUCCESS;
            break;
          }
        }
        if (rsts == GDH__SUCCESS || vl == &gdbroot->db->vol_lh)
          break;
      }
    }
  }
  gdh_ScopeUnlock;

  return rsts;
}

/**
 * @brief Get the name for a volume denoted by volume identity.
 * @see Example in gdh_GetVolumeList
 * @return pwr_tStatus
 */
pwr_tStatus gdh_VolumeIdToName(pwr_tVid vid, /**< Volume identity */
    char* name, /**< Name buffer, allocated by the user */
    int size /**< Size of name buffer */
    )
{
  gdb_sVolume* vp;
  pwr_tStatus sts;
  pwr_tStatus rsts = GDH__SUCCESS;

  gdh_ScopeLock
  {
    vp = hash_Search(&sts, gdbroot->vid_ht, &vid);
    if (vp != NULL) {
      if (strlen(vp->g.name.orig) >= size)
        rsts = GDH__NAMEBUF;
      strncpy(name, vp->g.name.orig, size);
    } else
      rsts = GDH__NOSUCHVOL;
  }
  gdh_ScopeUnlock;

  return rsts;
}

/**
 * @brief Get info for a volume.
 */
pwr_tStatus gdh_GetVolumeInfo(pwr_tVid vid, /**< Volume identity */
    gdh_sVolumeInfo* info /**< Pointer to info area, supplied by the user */
    )
{
  gdb_sVolume* vp;
  pwr_tStatus sts;
  pwr_tStatus rsts = GDH__SUCCESS;

  gdh_ScopeLock
  {
    vp = hash_Search(&sts, gdbroot->vid_ht, &vid);
    if (vp != NULL) {
      info->isCached = vp->l.flags.b.isCached ? 1 : 0;
      info->isLoaded = vp->l.flags.b.isLoaded ? 1 : 0;
      info->isMounted = vp->l.flags.b.isMounted ? 1 : 0;
      info->time = net_NetTimeToTime(&vp->g.time);
      info->cid = vp->g.cid;
      info->nid = vp->g.nid;
      strcpy(info->name, vp->g.name.orig);
    } else
      rsts = GDH__NOSUCHVOL;
  }
  gdh_ScopeUnlock;

  return rsts;
}

/**
 * @brief Get info for a volume.
 */
pwr_tStatus gdh_GetRootVolume(pwr_tVid* vid /**< Volume identity */
    )
{
  *vid = gdbroot->my_volume->g.vid;
  return GDH__SUCCESS;
}

pwr_tStatus gdh_GetObjectBodyDef(
    pwr_tCid cid, gdh_sAttrDef** bodydef, int* rows, pwr_tOid oid)
{
  gdb_sClass* cp;
  gdb_sObject* bop;
  gdb_sObject* aop;
  gdb_sObject* op;
  pwr_sParam* adef;
  pwr_sObjBodyDef* bdef;
  int acnt = 0;
  gdh_sAttrDef* bd;
  pwr_tStatus sts;
  pwr_tStatus rsts = GDH__SUCCESS;
  pwr_tOid noid;
  gdb_sObject* a_super[20];
  int scnt = 0;
  int i, j;

  gdh_ScopeLock
  {
    cp = hash_Search(&sts, gdbroot->cid_ht, &cid);
    if (cp == 0) {
      rsts = GDH__NOSUCHCLASS;
      goto error_sts;
    }

    bop = pool_Address(&sts, gdbroot->pool, cp->bor);
    if (bop == NULL) {
      rsts = GDH__ATTRIBUTE;
      goto error_sts;
    }

    bdef = pool_Address(NULL, gdbroot->rtdb, bop->u.n.body);
    acnt += bdef->NumOfParams;

    /* Count attributes */
    a_super[scnt++] = vol_OidToObject(
        &sts, bop->g.soid, gdb_mLo_local, vol_mTrans_none, cvol_eHint_none);
    while (a_super[scnt - 1]) {
      adef = pool_Address(NULL, gdbroot->rtdb, a_super[scnt - 1]->u.n.body);

      if (streq(a_super[scnt - 1]->g.f.name.orig, "Super")
          && cdh_tidIsCid(adef->TypeRef)) {
        cp = hash_Search(&sts, gdbroot->cid_ht, &adef->TypeRef);

        if (cp == 0) {
          if (!cdh_ObjidIsNull(oid)) {
            op = vol_OidToObject(
                &sts, oid, gdb_mLo_global, vol_mTrans_all, cvol_eHint_none);

            if (!(op->l.flags.m & gdb_mLo_native)) {
              cmvolc_GetNonExistingClass(&sts, op, adef->TypeRef);
              cp = hash_Search(&sts, gdbroot->cid_ht, &adef->TypeRef);
              if (cp == NULL) {
                rsts = GDH__NOSUCHCLASS;
                goto error_sts;
              }
            } else {
              rsts = GDH__NOSUCHCLASS;
              goto error_sts;
            }
          } else {
            rsts = GDH__NOSUCHCLASS;
            goto error_sts;
          }
        }

        bop = pool_Address(&sts, gdbroot->pool, cp->bor);
        if (bop == NULL) {
          rsts = GDH__ATTRIBUTE;
          goto error_sts;
        }

        bdef = pool_Address(NULL, gdbroot->rtdb, bop->u.n.body);
        acnt += bdef->NumOfParams - 1;

        a_super[scnt++] = vol_OidToObject(
            &sts, bop->g.soid, gdb_mLo_local, vol_mTrans_none, cvol_eHint_none);
      } else
        break;
    }

    /* Allocate buffer */
    bd = (gdh_sAttrDef*)calloc(acnt, sizeof(gdh_sAttrDef));

    acnt = 0;
    for (i = scnt - 1; i >= 0; i--) {
      aop = a_super[i];
      while (aop) {
        adef = pool_Address(NULL, gdbroot->rtdb, aop->u.n.body);
        if (!(aop == a_super[i] && streq(aop->g.f.name.orig, "Super"))) {
          for (j = 0; j < i; j++)
            strcat(bd[acnt].attrName, "Super.");
          strcat(bd[acnt].attrName, aop->g.f.name.orig);
          bd[acnt].attrClass = aop->g.cid;
          bd[acnt].attr = (pwr_uParDef*)adef;
          if (i > 0)
            bd[acnt].flags = gdh_mAttrDef_Super;
          acnt++;
        }
        noid.vid = aop->g.oid.vid;
        noid.oix = aop->g.sib.flink;
        aop = vol_OidToObject(
            &sts, noid, gdb_mLo_local, vol_mTrans_none, cvol_eHint_next);
        if (aop && aop == a_super[i])
          break;
      }
    }

    if (scnt > 1) {
      /* Detect shadowed attributes */
      for (j = 0; j < acnt - 1; j++) {
        char* s1 = strrchr(bd[j].attrName, '.');
        if (!s1)
          s1 = bd[j].attrName;
        else
          s1++;
        for (i = j + 1; i < acnt; i++) {
          char* s2 = strrchr(bd[i].attrName, '.');
          if (!s2)
            s2 = bd[i].attrName;
          else
            s2++;
          if (str_NoCaseStrcmp(s1, s2) == 0) {
            bd[j].flags |= gdh_mAttrDef_Shadowed;
            break;
          }
        }
      }
    }
    *bodydef = bd;
    *rows = acnt;

  error_sts : {
  }
  }
  gdh_ScopeUnlock;
  return rsts;
}

pwr_tStatus gdh_GetTrueObjectBodyDef(
    pwr_tCid cid, gdh_sAttrDef** bodydef, int* rows)
{
  gdb_sClass* cp;
  gdb_sObject* bop;
  gdb_sObject* aop;
  pwr_sParam* adef;
  pwr_sObjBodyDef* bdef;
  int acnt = 0;
  gdh_sAttrDef* bd;
  pwr_tStatus sts;
  pwr_tStatus rsts = GDH__SUCCESS;
  pwr_tOid noid;

  gdh_ScopeLock
  {
    cp = hash_Search(&sts, gdbroot->cid_ht, &cid);
    if (cp == 0) {
      rsts = GDH__NOSUCHCLASS;
      goto error_sts;
    }

    bop = pool_Address(&sts, gdbroot->pool, cp->bor);
    if (bop == NULL) {
      rsts = GDH__ATTRIBUTE;
      goto error_sts;
    }

    bdef = pool_Address(NULL, gdbroot->rtdb, bop->u.n.body);
    acnt = bdef->NumOfParams;

    /* Allocate buffer */
    bd = (gdh_sAttrDef*)calloc(acnt, sizeof(gdh_sAttrDef));

    acnt = 0;
    aop = vol_OidToObject(
        &sts, bop->g.soid, gdb_mLo_local, vol_mTrans_none, cvol_eHint_none);
    while (aop) {
      adef = pool_Address(NULL, gdbroot->rtdb, aop->u.n.body);
      strcpy(bd[acnt].attrName, aop->g.f.name.orig);
      bd[acnt].attrClass = aop->g.cid;
      bd[acnt].attr = (pwr_uParDef*)adef;
      acnt++;

      noid.vid = aop->g.oid.vid;
      noid.oix = aop->g.sib.flink;
      aop = vol_OidToObject(
          &sts, noid, gdb_mLo_local, vol_mTrans_none, cvol_eHint_next);
      if (aop->g.oid.oix == bop->g.soid.oix)
        break;
    }
    *bodydef = bd;
    *rows = acnt;

  error_sts : {
  }
  }
  gdh_ScopeUnlock;
  return rsts;
}

pwr_tStatus gdh_GetAttrRefAdef(pwr_sAttrRef* arp, gdh_sAttrDef* attrdef)
{
  pwr_sParam* adef;
  mvol_sAttribute Attribute;
  mvol_sAttribute* ap;
  pwr_tStatus sts;
  pwr_tStatus rsts = GDH__SUCCESS;

  gdh_ScopeLock
  {
    ap = vol_ArefToAttribute(
        &sts, &Attribute, arp, gdb_mLo_global, vol_mTrans_all);
    if (ap == NULL)
      rsts = GDH__ATTRIBUTE;
    else {
      touchObject(ap->op);

      adef = pool_Address(NULL, gdbroot->rtdb, ap->aop->u.n.body);
      strcpy(attrdef->attrName, ap->aop->g.f.name.orig);
      attrdef->attrClass = ap->aop->g.cid;
      attrdef->attr = (pwr_uParDef*)adef;
    }
  }
  gdh_ScopeUnlock;
  return rsts;
}

/**
 * @brief Get the superclass for a class.
 *
 * If the class for a remote object is examined, the class might not be loded on
 * the local,
 * and in this case the object itself has to supplied in the oid argument. For
 * local classes,
 * this argument can be set to pwr_cNOid.
 *
 * Example
 * @code
 * pwr_tStatus sts;
 * pwr_tCid supercid;
 *
 * sts = gdh_GetSuperClass( cid, &supercid, pwr_cNOid);
 * @endcode
 * @return pwr_tStatus
 */
pwr_tStatus gdh_GetSuperClass(pwr_tCid cid, /**< Class identity. */
    pwr_tCid* supercid, /**< Received class identity for the super class. */
    pwr_tObjid oid /**< Object id for remote object, normally pwr_cNOid */
    )
{
  gdb_sClass* cp;
  gdb_sObject* op;
  pwr_tCid sid;
  pwr_tStatus sts = GDH__SUCCESS;

  gdh_ScopeLock
  {
    cp = hash_Search(&sts, gdbroot->cid_ht, &cid);
    if (cp) {
      if (!(cp->attr[0].flags.m & PWR_MASK_SUPERCLASS))
        sts = GDH__NOSUCHCLASS;
      else {
        sid = *supercid = cp->attr[0].tid;
        if (!cdh_ObjidIsNull(oid)) {
          op = vol_OidToObject(
              &sts, oid, gdb_mLo_global, vol_mTrans_all, cvol_eHint_none);
          if (!(op->l.flags.m & gdb_mLo_native)) {
            cp = hash_Search(&sts, gdbroot->cid_ht, &sid);
            if (cp == NULL) {
              cmvolc_GetNonExistingClass(&sts, op, sid);
              cp = hash_Search(&sts, gdbroot->cid_ht, &sid);
              if (cp == NULL) {
                sts = GDH__NOSUCHCLASS;
              }
            }
          }
        }
      }
    } else if (!cdh_ObjidIsNull(oid)) {
      op = vol_OidToObject(
          &sts, oid, gdb_mLo_global, vol_mTrans_all, cvol_eHint_none);
      cmvolc_GetNonExistingClass(&sts, op, cid);
      cp = hash_Search(&sts, gdbroot->cid_ht, &cid);
      if (cp) {
        if (!(cp->attr[0].flags.m & PWR_MASK_SUPERCLASS))
          sts = GDH__NOSUCHCLASS;
        else
          *supercid = cp->attr[0].tid;
      } else {
        sts = GDH__NOSUCHCLASS;
      }
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get definition information for an enumeration type.
 *
 * Returns a data stucture with the defined enumeration values and
 * corresponding texts for an enumeration type. The datastructure is
 * of type gdh_sValueDef, with an array of pointers to the values
 * definition objects of the enumeration values.
 *
 * The data structure should be freed with a free() call.
 */
pwr_tStatus gdh_GetEnumValueDef(pwr_tTid tid, /**< Enumeration type id */
    gdh_sValueDef** vd, /**< Recieves a pointer to the data structure. */
    int* rows /**< Number defined enum values */
    )
{
  gdb_sObject* top;
  gdb_sObject* vop;
  pwr_tOid valoid;
  int vcnt;
  pwr_tStatus sts = GDH__SUCCESS;
  pwr_sValue* valp;

  gdh_ScopeLock
  {
    top = vol_OidToObject(&sts, cdh_TypeIdToObjid(tid), gdb_mLo_local,
        vol_mTrans_none, cvol_eHint_none);
    if (top == NULL)
      goto error_sts;
    if (!top->g.flags.b.isParent) {
      sts = GDH__NOSUCHOBJ;
      goto error_sts;
    }

    vcnt = 0;
    valoid = top->g.soid;
    while (1) {
      vop = vol_OidToObject(
          &sts, valoid, gdb_mLo_local, vol_mTrans_none, cvol_eHint_none);
      if (vop == NULL)
        goto error_sts;

      if (vop->g.cid == pwr_eClass_Value)
        vcnt++;

      valoid.oix = vop->g.sib.flink;

      if (valoid.oix == top->g.soid.oix)
        break;
    }

    /* Allocate buffer */
    *vd = (gdh_sValueDef*)calloc(vcnt, sizeof(gdh_sValueDef));
    *rows = vcnt;

    vcnt = 0;
    valoid = top->g.soid;

    while (1) {
      vop = vol_OidToObject(
          &sts, valoid, gdb_mLo_local, vol_mTrans_none, cvol_eHint_none);
      if (vop == NULL)
        goto error_sts;

      if (vop->g.cid == pwr_eClass_Value) {
        valp = (pwr_sValue*)vol_ObjectToAddress(&sts, vop);
        if (valp == NULL)
          goto error_sts;

        strcpy((*vd)[vcnt].Name, vop->g.f.name.orig);
        (*vd)[vcnt].Value = valp;
        vcnt++;
      }

      valoid.oix = vop->g.sib.flink;

      if (valoid.oix == top->g.soid.oix)
        break;
    }
  error_sts : {
  }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get definition information for a mask type.
 *
 * Returns a data stucture with the defined bit values and
 * corresponding texts for a mask type. The datastructure is
 * of type gdh_sBitDef, which contains an array with
 * ponters to the but definition objects for the bits.
 *
 * The data structure should be freed with a free() call.
 */
pwr_tStatus gdh_GetMaskBitDef(pwr_tTid tid, /**< Type identity for mask. */
    gdh_sBitDef** bd, /**< Receives a pointer to the data structure. */
    int* rows /**< Number of defined bit values. */
    )
{
  gdb_sObject* top;
  gdb_sObject* bop;
  pwr_tOid boid;
  int bcnt;
  pwr_tStatus sts = GDH__SUCCESS;
  pwr_sBit* bp;

  gdh_ScopeLock
  {
    top = vol_OidToObject(&sts, cdh_TypeIdToObjid(tid), gdb_mLo_local,
        vol_mTrans_none, cvol_eHint_none);
    if (top == NULL)
      goto error_sts;
    if (!top->g.flags.b.isParent) {
      sts = GDH__NOSUCHOBJ;
      goto error_sts;
    }

    bcnt = 0;
    boid = top->g.soid;

    while (1) {
      bop = vol_OidToObject(
          &sts, boid, gdb_mLo_local, vol_mTrans_none, cvol_eHint_none);
      if (bop == NULL)
        goto error_sts;

      if (bop->g.cid == pwr_eClass_Bit)
        bcnt++;

      boid.oix = bop->g.sib.flink;

      if (boid.oix == top->g.soid.oix)
        break;
    }

    /* Allocate buffer */
    *bd = (gdh_sBitDef*)calloc(bcnt, sizeof(gdh_sBitDef));
    *rows = bcnt;

    bcnt = 0;
    boid = top->g.soid;
    while (1) {
      bop = vol_OidToObject(
          &sts, boid, gdb_mLo_local, vol_mTrans_none, cvol_eHint_none);
      if (bop == NULL)
        goto error_sts;

      if (bop->g.cid == pwr_eClass_Bit) {
        bp = (pwr_sBit*)vol_ObjectToAddress(&sts, bop);
        if (bp == NULL)
          goto error_sts;

        strcpy((*bd)[bcnt].Name, bop->g.f.name.orig);
        (*bd)[bcnt].Bit = bp;
        bcnt++;
      }

      boid.oix = bop->g.sib.flink;

      if (boid.oix == top->g.soid.oix)
        break;
    }
  error_sts : {
  }
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Check if an attribute is disabled.
 * @return pwr_tStatus
 */
pwr_tStatus gdh_ArefDisabled(pwr_sAttrRef* arp, /**< Attribute reference */
    pwr_tDisableAttr* disabled /**< Recives 1 if disabled else 0 */
    )
{
  pwr_tStatus sts;
  pwr_sAttrRef daref;
  mvol_sAttribute* ap;
  mvol_sAttribute attribute;

  gdh_ScopeLock
  {
    memset(&attribute, 0, sizeof(attribute));

    ap = vol_ArefToAttribute(
        &sts, &attribute, arp, gdb_mLo_global, vol_mTrans_all);
    if (ap != NULL)
      touchObject(ap->op);
  }
  gdh_ScopeUnlock;

  if (ap != 0 && ap->adef != 0 && ap->adef->Info.Flags & PWR_MASK_DISABLEATTR) {
    daref = cdh_ArefToDisableAref(arp);
    sts = gdh_GetObjectInfoAttrref(&daref, disabled, sizeof(*disabled));
    return sts;
  } else
    return GDH__NOATTR;
}

pwr_tStatus gdh_FWriteObjectR(
    FILE* fp, char* ap, char* aname, pwr_tAttrRef* arp, pwr_tCid cid)
{
  pwr_tOName name;
  char value_str[512];
  gdh_sAttrDef* bd;
  int i, j, rows, elements;
  char idx[20];
  pwr_tStatus sts;
  pwr_tAttrRef aref;
  int len;
  char attrName[40];

  sts = gdh_GetObjectBodyDef(cid, &bd, &rows, arp->Objid);
  if (EVEN(sts))
    return sts;

  for (i = 0; i < rows; i++) {
    if (bd[i].attr->Param.Info.Flags & PWR_MASK_RTVIRTUAL
        || (bd[i].attr->Param.Info.Flags & PWR_MASK_PRIVATE
               && bd[i].attr->Param.Info.Flags & PWR_MASK_POINTER))
      continue;

    strcpy(name, aname);
    strcat(name, ".");
    strcat(name, bd[i].attrName);
    strcpy(attrName, bd[i].attrName);

    if (bd[i].attr->Param.Info.Flags & PWR_MASK_ARRAY)
      elements = bd[i].attr->Param.Info.Elements;
    else
      elements = 1;

    for (j = 0; j < elements; j++) {
      if (bd[i].attr->Param.Info.Flags & PWR_MASK_ARRAY) {
        sprintf(idx, "[%d]", j);
        strcpy(name, aname);
        strcat(name, ".");
        strcat(name, bd[i].attrName);
        strcat(name, idx);
        strcpy(attrName, bd[i].attrName);
        strcat(attrName, idx);
      }

      sts = gdh_ArefANameToAref(arp, attrName, &aref);
      if (EVEN(sts))
        return sts;

      if (bd[i].attr->Param.Info.Flags & PWR_MASK_CLASS) {
        sts = gdh_FWriteObjectR(fp, ap + bd[i].attr->Param.Info.Offset
                + j * bd[i].attr->Param.Info.Size / elements,
            name, &aref, bd[i].attr->Param.Info.Type);
      } else {
        sts = gdh_AttrValueToString(bd[i].attr->Param.Info.Type,
            bd[i].attr->Param.TypeRef, ap + bd[i].attr->Param.Info.Offset
                + j * bd[i].attr->Param.Info.Size / elements,
            value_str, sizeof(value_str), &len, 0);
        if (ODD(sts)) {
          switch (bd[i].attr->Param.Info.Type) {
          case pwr_eType_String:
          case pwr_eType_Text:
          case pwr_eType_Objid:
          case pwr_eType_AttrRef:
          case pwr_eType_ClassId:
          case pwr_eType_TypeId:
          case pwr_eType_CastId:
	  case pwr_eType_Time:
            fprintf(fp, "%s \"%s\"\n", &name[1], value_str);
            break;
          default:
            fprintf(fp, "%s %s\n", &name[1], value_str);
            break;
          }
        } else {
          fprintf(fp, "# %s Value could not be converted\n", &name[1]);
        }
      }
    }
  }
  free(bd);

  return GDH__SUCCESS;
}

/**
 * @brief Write the content of an object to textfile.
 *
 * The file can later be read and the attribute values inserted in the
 * object or in another object of the same class with the function
 * gdh_FReadObject.
 * @see gdh_FReadObject
 * @return pwr_tStatus
 */
pwr_tStatus gdh_FWriteObject(char* filename, /**< File specification */
    pwr_tAttrRef* arp /**< Attribute reference to object */
    )
{
  pwr_tFileName fname;
  FILE* fp;
  char* ap;
  pwr_tStatus sts;
  pwr_tTid tid;

  sts = gdh_GetAttrRefTid(arp, &tid);
  if (EVEN(sts))
    return sts;

  if (!cdh_tidIsCid(tid))
    return GDH__NOOBJECT;

  if (arp->Flags.b.Object && arp->Size == 0) {
    sts = gdh_GetObjectSize(arp->Objid, &arp->Size);
    if (EVEN(sts))
      return sts;
  } else if (arp->Size == 0)
    return GDH__BADARG;

  ap = calloc(1, arp->Size);
  if (!ap)
    return GDH__INSVIRMEM;

  sts = gdh_GetObjectInfoAttrref(arp, ap, arp->Size);
  if (EVEN(sts))
    return sts;

  dcli_translate_filename(fname, filename);
  fp = fopen(fname, "w");
  if (!fp)
    return GDH__FILE;

  sts = gdh_FWriteObjectR(fp, ap, "", arp, tid);

  fclose(fp);
  free(ap);
  return sts;
}

/**
 * @brief Read a textfile into an object.
 *
 * Reads a textfile, created by gdh_FWriteObject, and inserts the values
 * into the specified object.
 *
 * The file has to be generated from the same object or from an object of the
 * same class.
 * @see gdh_FWriteObject
 * @return pwr_tStatus
 */
pwr_tStatus gdh_FReadObject(char* filename, /**< File specification */
    pwr_tAttrRef* arp /**< Attribute reference for object */
    )
{
  pwr_tFileName fname;
  FILE* fp;
  char* ap;
  pwr_tStatus sts;
  pwr_tTid tid;
  char line[512];
  char line_elem[2][512];
  int nr;
  pwr_tTypeId a_tid;
  unsigned int a_size;
  unsigned int a_offs;
  unsigned int a_elem;
  char buffer[512];
  pwr_tAttrRef aref;

  sts = gdh_GetAttrRefTid(arp, &tid);
  if (EVEN(sts))
    return sts;

  if (!cdh_tidIsCid(tid))
    return GDH__NOOBJECT;

  sts = gdh_AttrRefToPointer(arp, (void**)&ap);
  if (EVEN(sts))
    return sts;

  dcli_translate_filename(fname, filename);
  fp = fopen(fname, "r");
  if (!fp)
    return GDH__FILE;

  while (dcli_read_line(line, sizeof(line), fp)) {
    str_trim(line, line);
    if (line[0] == '#')
      continue;
    if (streq(line, ""))
      continue;

    nr = dcli_parse(line, " 	", "", (char*)line_elem,
        sizeof(line_elem) / sizeof(line_elem[0]), sizeof(line_elem[0]), 1);
    if (nr != 2)
      continue;

    sts = gdh_ArefANameToAref(arp, line_elem[0], &aref);
    if (EVEN(sts))
      continue;

    sts = gdh_GetAttributeCharAttrref(&aref, &a_tid, &a_size, &a_offs, &a_elem);
    if (EVEN(sts))
      continue;

    switch (a_tid) {
    case pwr_eType_String:
    case pwr_eType_Text:
    case pwr_eType_Objid:
    case pwr_eType_AttrRef:
    case pwr_eType_ClassId:
    case pwr_eType_TypeId:
    case pwr_eType_CastId:
    case pwr_eType_Time:
      if (line_elem[1][0] == '"'
          && line_elem[1][strlen(line_elem[1]) - 1] == '"') {
        line_elem[1][strlen(line_elem[1]) - 1] = 0;
        sts = gdh_AttrStringToValue(
            a_tid, &line_elem[1][1], buffer, sizeof(buffer), a_size);
      } else
        sts = gdh_AttrStringToValue(
            a_tid, line_elem[1], buffer, sizeof(buffer), a_size);
      break;
    default:
      sts = gdh_AttrStringToValue(
          a_tid, line_elem[1], buffer, sizeof(buffer), a_size);
    }
    if (EVEN(sts))
      continue;

    sts = gdh_SetObjectInfoAttrref(&aref, buffer, a_size);
  }

  fclose(fp);
  return sts;
}

/**
 * @brief Convert a string to attribute value.
 */
pwr_tStatus gdh_AttrValueToString(pwr_eType type_id, /**< Attribute type */
    pwr_tTid tid, /**< Attribute type identity */
    void* value_ptr, /**< Pointer to attribute value */
    char* str, /**< String buffer */
    int size, /**< Size of string buffer */
    int* len, /**< Receives the string length */
    char* format /**< Format for conversion in printf syntax */
    )
{
  int sts;

  switch (type_id) {
  case pwr_eType_Boolean: {
    if (!format)
      *len = sprintf(str, "%d", *(pwr_tBoolean*)value_ptr);
    else
      *len = sprintf(str, format, *(pwr_tBoolean*)value_ptr);
    break;
  }
  case pwr_eType_Float32: {
    if ( *(float *)value_ptr == FLT_MIN) {
      strcpy( str, "FltMin");
      *len = strlen(str);
    }
    else if ( *(float *)value_ptr == -FLT_MIN) {
      strcpy( str, "FltNMin");
      *len = strlen(str);
    }
    else if ( *(float *)value_ptr == FLT_MAX) {
      strcpy( str, "FltMax");
      *len = strlen(str);
    }
    else if ( *(float *)value_ptr == -FLT_MAX) {
      strcpy( str, "FltNMax");
      *len = strlen(str);
    } else {
      if (!format)
        *len = sprintf(str, "%g", *(float*)value_ptr);
      else
        *len = sprintf(str, format, *(float*)value_ptr);
    }
    break;
  }
  case pwr_eType_Float64: {
    if (!format)
      *len = sprintf(str, "%g", *(double*)value_ptr);
    else
      *len = sprintf(str, format, *(double*)value_ptr);
    break;
  }
  case pwr_eType_Char: {
    if (!format)
      *len = sprintf(str, "%c", *(char*)value_ptr);
    else
      *len = sprintf(str, format, *(char*)value_ptr);
    break;
  }
  case pwr_eType_Int8: {
    if (!format)
      *len = sprintf(str, "%d", *(char*)value_ptr);
    else
      *len = sprintf(str, format, *(char*)value_ptr);
    break;
  }
  case pwr_eType_Int16: {
    if (!format)
      *len = sprintf(str, "%hd", *(short*)value_ptr);
    else
      *len = sprintf(str, format, *(short*)value_ptr);
    break;
  }
  case pwr_eType_Int32: {
    if (*(int*)value_ptr == INT_MIN) {
      strcpy(str, "IntMin");
      *len = strlen(str);
    } else if (*(int*)value_ptr == INT_MAX) {
      strcpy(str, "IntMax");
      *len = strlen(str);
    } else {
      if (!format)
        *len = sprintf(str, "%d", *(int*)value_ptr);
      else
        *len = sprintf(str, format, *(int*)value_ptr);
    }
    break;
  }
  case pwr_eType_Int64: {
    if (!format)
      *len = sprintf(str, pwr_dFormatInt64, *(pwr_tInt64*)value_ptr);
    else
      *len = sprintf(str, format, *(pwr_tInt64*)value_ptr);
    break;
  }
  case pwr_eType_UInt8: {
    if (!format)
      *len = sprintf(str, "%u", *(unsigned char*)value_ptr);
    else
      *len = sprintf(str, format, *(unsigned char*)value_ptr);
    break;
  }
  case pwr_eType_UInt16: {
    if (!format)
      *len = sprintf(str, "%hu", *(unsigned short*)value_ptr);
    else
      *len = sprintf(str, format, *(unsigned short*)value_ptr);
    break;
  }
  case pwr_eType_UInt32:
  case pwr_eType_Mask:
  case pwr_eType_DisableAttr: {
    if (!format)
      *len = sprintf(str, "%u", *(unsigned int*)value_ptr);
    else
      *len = sprintf(str, format, *(unsigned int*)value_ptr);
    break;
  }
  case pwr_eType_UInt64: {
    if (!format)
      *len = sprintf(str, pwr_dFormatUInt64, *(pwr_tUInt64*)value_ptr);
    else
      *len = sprintf(str, format, *(pwr_tUInt64*)value_ptr);
    break;
  }
  case pwr_eType_Enum: {
    if (!format)
      *len = sprintf(str, "%u", *(unsigned int*)value_ptr);
    else
      *len = sprintf(str, format, *(unsigned int*)value_ptr);
    break;
  }
  case pwr_eType_String: {
    strncpy(str, (char*)value_ptr, size);
    str[size - 1] = 0;
    *len = strlen(str);
    break;
  }
  case pwr_eType_Text: {
    char *s, *t;

    for (s = (char*)value_ptr, t = str; *s != 10 && *s != 0; s++, t++) {
      if (t - str >= size - 1)
        break;
      *t = *s;
    }
    *t = 0;
    *len = strlen(str);
    break;
  }
  case pwr_eType_Objid: {
    pwr_tOName hiername;
    pwr_tObjid objid;

    objid = *(pwr_tObjid*)value_ptr;
    if (!objid.oix)
      sts = gdh_ObjidToName(
          objid, hiername, sizeof(hiername), cdh_mName_volumeStrict);
    else
      sts = gdh_ObjidToName(objid, hiername, sizeof(hiername), cdh_mNName);
    if (EVEN(sts)) {
      strcpy(str, "");
      *len = 0;
      break;
    }
    *len = sprintf(str, "%s", hiername);
    break;
  }
  case pwr_eType_AttrRef: {
    pwr_tAName hiername;
    pwr_sAttrRef* attrref;

    attrref = (pwr_sAttrRef*)value_ptr;
    sts = gdh_AttrrefToName(attrref, hiername, sizeof(hiername), cdh_mNName);
    if (EVEN(sts)) {
      strcpy(str, "");
      *len = 0;
      break;
    }
    *len = sprintf(str, "%s", hiername);
    break;
  }
  case pwr_eType_DataRef: {
    pwr_tAName hiername;
    pwr_tDataRef* dataref;

    dataref = (pwr_tDataRef*)value_ptr;
    sts = gdh_AttrrefToName(
        &dataref->Aref, hiername, sizeof(hiername), cdh_mNName);
    if (EVEN(sts)) {
      strcpy(str, "");
      *len = 0;
      break;
    }
    *len = sprintf(str, "%s", hiername);
    break;
  }
  case pwr_eType_Time: {
    char timstr[64];

    if (memcmp(value_ptr, &pwr_cAtMin, sizeof(pwr_tTime)) == 0) {
      strcpy(timstr, "AtZero");
      sts = GDH__SUCCESS;
    } else if (memcmp(value_ptr, &pwr_cAtMax, sizeof(pwr_tTime)) == 0) {
      strcpy(timstr, "AtMax");
      sts = GDH__SUCCESS;
    } else if (format && format[0] == '%' && format[2] == 't') {
      switch (format[1]) {
      case '1':
        // Format %1t, only time, no hundredth
        sts = time_AtoAscii(
            (pwr_tTime*)value_ptr, time_eFormat_Time, timstr, sizeof(timstr));
        timstr[8] = 0;
        break;
      case '2':
        // Format %2t, only time, with hundredth
        sts = time_AtoAscii(
            (pwr_tTime*)value_ptr, time_eFormat_Time, timstr, sizeof(timstr));
        break;
      case '3':
        // Format %3t, compressed date and time, no hundredth
        sts = time_AtoAscii((pwr_tTime*)value_ptr,
            time_eFormat_ComprDateAndTime, timstr, sizeof(timstr));
        timstr[17] = 0;
        break;
      case '4':
        // Format %4t, date only
        sts = time_AtoAscii((pwr_tTime*)value_ptr, time_eFormat_DateAndTime,
            timstr, sizeof(timstr));
        timstr[11] = 0;
        break;
      case '5':
        // Format %5t, compressed date only
        sts = time_AtoAscii((pwr_tTime*)value_ptr,
            time_eFormat_ComprDateAndTime, timstr, sizeof(timstr));
        timstr[8] = 0;
        break;
      case '6':
        // Format %6t, time before to date
        sts = time_AtoAscii((pwr_tTime*)value_ptr, time_eFormat_TimeAndDate,
            timstr, sizeof(timstr));
        timstr[17] = 0;
        break;
      default:
        sts = time_AtoAscii((pwr_tTime*)value_ptr, time_eFormat_DateAndTime,
            timstr, sizeof(timstr));
      }
    } else
      sts = time_AtoAscii((pwr_tTime*)value_ptr, time_eFormat_DateAndTime,
          timstr, sizeof(timstr));
    if (EVEN(sts))
      strcpy(timstr, "-");
    *len = sprintf(str, "%s", timstr);
    break;
  }
  case pwr_eType_DeltaTime: {
    char timstr[64];

    if (memcmp(value_ptr, &pwr_cDtMin, sizeof(pwr_tDeltaTime)) == 0)
      strcpy(timstr, "DtMin");
    else if (memcmp(value_ptr, &pwr_cDtMax, sizeof(pwr_tDeltaTime)) == 0)
      strcpy(timstr, "DtMax");
    else {
      sts = time_DtoAscii(
          (pwr_tDeltaTime*)value_ptr, 1, timstr, sizeof(timstr));
      if (EVEN(sts))
        strcpy(timstr, "Undefined time");
    }
    *len = sprintf(str, "%s", timstr);
    break;
  }
  case pwr_eType_ObjectIx: {
    cdh_ObjectIxToString(str, size, *(pwr_tObjectIx*)value_ptr, 1);
    *len = strlen(str);
    break;
  }
  case pwr_eType_ClassId: {
    pwr_tOName hiername;
    pwr_tObjid objid;

    objid = cdh_ClassIdToObjid(*(pwr_tClassId*)value_ptr);
    sts = gdh_ObjidToName(objid, hiername, sizeof(hiername), cdh_mNName);
    if (EVEN(sts)) {
      strcpy(str, "");
      *len = 0;
      break;
    }
    *len = sprintf(str, "%s", hiername);
    break;
  }
  case pwr_eType_TypeId:
  case pwr_eType_CastId: {
    pwr_tOName hiername;
    pwr_tObjid objid;

    objid = cdh_TypeIdToObjid(*(pwr_tTypeId*)value_ptr);
    sts = gdh_ObjidToName(objid, hiername, sizeof(hiername), cdh_mNName);
    if (EVEN(sts)) {
      strcpy(str, "");
      *len = 0;
      break;
    }
    *len = sprintf(str, "%s", hiername);
    break;
  }
  case pwr_eType_VolumeId: {
    cdh_VolumeIdToString(str, size, *(pwr_tVolumeId*)value_ptr, 1, 0);
    *len = strlen(str);
    break;
  }
  case pwr_eType_RefId: {
    cdh_SubidToString(str, size, *(pwr_tSubid*)value_ptr, 1);
    *len = strlen(str);
    break;
  }
  case pwr_eType_NetStatus:
  case pwr_eType_Status: {
    if (!format)
      *len = sprintf(str, "%u", *(unsigned int*)value_ptr);
    else
      *len = sprintf(str, format, *(unsigned int*)value_ptr);
    break;
  }
  default:
    return GDH__CONVERT;
  }
  return GDH__SUCCESS;
}

/**
 * @brief Convert an attribute string to value
 */
pwr_tStatus gdh_AttrStringToValue(int type_id, /**< Attribute type */
    char* value_str, /**< String value */
    void* buffer_ptr, /**< Value buffer */
    int buff_size, /**< Size of value buffer */
    int attr_size /**< Attribute size, used for String and Text attributes */
    )
{
  int sts;

  switch (type_id) {
  case pwr_eType_Boolean: {
    if (sscanf(value_str, "%d", (pwr_tBoolean*)buffer_ptr) != 1)
      return GDH__CONVERT;
    if (*(pwr_tBoolean*)buffer_ptr > 1)
      return GDH__CONVERT;
    break;
  }
  case pwr_eType_Float32: {
    if (streq(value_str, "FltMin"))
      *(float*)buffer_ptr = FLT_MIN;
    else if (streq(value_str, "FltNMin"))
      *(float*)buffer_ptr = -FLT_MIN;
    else if (streq(value_str, "FltMax"))
      *(float*)buffer_ptr = FLT_MAX;
    else if (streq(value_str, "FltNMax"))
      *(float*)buffer_ptr = -FLT_MAX;
    else if (sscanf(value_str, "%f", (float*)buffer_ptr) != 1)
      return GDH__CONVERT;
    break;
  }
  case pwr_eType_Float64: {
    pwr_tFloat32 f;
    pwr_tFloat64 d;
    if (sscanf(value_str, "%f", &f) != 1)
      return GDH__CONVERT;
    d = f;
    memcpy(buffer_ptr, (char*)&d, sizeof(d));

    break;
  }
  case pwr_eType_Char: {
    if (sscanf(value_str, "%c", (char*)buffer_ptr) != 1)
      return GDH__CONVERT;
    break;
  }
  case pwr_eType_Int8: {
    pwr_tInt8 i8;
    pwr_tInt16 i16;
    if (sscanf(value_str, "%hd", &i16) != 1)
      return GDH__CONVERT;
    i8 = i16;
    memcpy(buffer_ptr, (char*)&i8, sizeof(i8));
    break;
  }
  case pwr_eType_Int16: {
    if (sscanf(value_str, "%hd", (short*)buffer_ptr) != 1)
      return GDH__CONVERT;
    break;
  }
  case pwr_eType_Int32:
  case pwr_eType_Status:
  case pwr_eType_NetStatus: {
    if (streq(value_str, "IntMin"))
      *(int*)buffer_ptr = INT_MIN;
    else if (streq(value_str, "IntMax"))
      *(int*)buffer_ptr = INT_MAX;
    else if (sscanf(value_str, "%d", (int*)buffer_ptr) != 1)
      return GDH__CONVERT;
    break;
  }
  case pwr_eType_Int64: {
    if (sscanf(value_str, pwr_dFormatInt64, (pwr_tInt64*)buffer_ptr) != 1)
      return GDH__CONVERT;
    break;
  }
  case pwr_eType_UInt8: {
    pwr_tUInt8 i8;
    pwr_tUInt16 i16;
    if (sscanf(value_str, "%hu", &i16) != 1)
      return GDH__CONVERT;
    i8 = i16;
    memcpy(buffer_ptr, (char*)&i8, sizeof(i8));
    break;
  }
  case pwr_eType_UInt16: {
    if (sscanf(value_str, "%hu", (unsigned short*)buffer_ptr) != 1)
      return GDH__CONVERT;
    break;
  }
  case pwr_eType_UInt32:
  case pwr_eType_Mask:
  case pwr_eType_DisableAttr: {
    if (sscanf(value_str, "%lu", (unsigned long*)buffer_ptr) != 1)
      return GDH__CONVERT;
    break;
  }
  case pwr_eType_UInt64: {
    if (sscanf(value_str, pwr_dFormatUInt64, (pwr_tUInt64*)buffer_ptr) != 1)
      return GDH__CONVERT;
    break;
  }
  case pwr_eType_String:
  case pwr_eType_Text: {
    if ((int)strlen(value_str) >= attr_size)
      return GDH__CONVERT;
    strncpy((char*)buffer_ptr, value_str,
        attr_size < buff_size ? attr_size : buff_size);
    break;
  }
  case pwr_eType_Objid: {
    pwr_tObjid objid;

    if (streq(value_str, "0"))
      objid = pwr_cNObjid;
    else {
      sts = gdh_NameToObjid(value_str, &objid);
      if (EVEN(sts))
        return sts;
    }
    memcpy(buffer_ptr, &objid, sizeof(objid));
    break;
  }
  case pwr_eType_ClassId: {
    pwr_tClassId classid;
    pwr_tObjid objid;

    sts = gdh_NameToObjid(value_str, &objid);
    if (EVEN(sts))
      return sts;
    classid = cdh_ClassObjidToId(objid);
    memcpy(buffer_ptr, (char*)&classid, sizeof(classid));
    break;
  }
  case pwr_eType_TypeId:
  case pwr_eType_CastId: {
    pwr_tTypeId val_typeid;
    pwr_tObjid objid;

    sts = gdh_NameToObjid(value_str, &objid);
    if (EVEN(sts))
      return sts;
    val_typeid = cdh_TypeObjidToId(objid);
    memcpy(buffer_ptr, (char*)&val_typeid, sizeof(val_typeid));
    break;
  }
  case pwr_eType_ObjectIx: {
    pwr_tObjectIx objectix;

    sts = cdh_StringToObjectIx(value_str, &objectix);
    if (EVEN(sts))
      return sts;
    memcpy(buffer_ptr, (char*)&objectix, sizeof(objectix));
    break;
  }
  case pwr_eType_VolumeId: {
    pwr_tVolumeId volumeid;

    sts = cdh_StringToVolumeId(value_str, &volumeid);
    if (EVEN(sts))
      return sts;
    memcpy(buffer_ptr, (char*)&volumeid, sizeof(volumeid));
    break;
  }
  case pwr_eType_RefId: {
    pwr_tRefId subid;

    sts = cdh_StringToSubid(value_str, &subid);
    if (EVEN(sts))
      return sts;
    memcpy(buffer_ptr, (char*)&subid, sizeof(subid));
    break;
  }
  case pwr_eType_AttrRef: {
    pwr_sAttrRef attrref;

    if (streq(value_str, "0"))
      attrref = pwr_cNAttrRef;
    else {
      sts = gdh_NameToAttrref(pwr_cNObjid, value_str, &attrref);
      if (EVEN(sts))
        return sts;
    }
    memcpy(buffer_ptr, &attrref, sizeof(attrref));
    break;
  }
  case pwr_eType_DataRef: {
    pwr_tDataRef dataref;

    sts = gdh_NameToAttrref(pwr_cNObjid, value_str, &dataref.Aref);
    if (EVEN(sts))
      return sts;
    dataref.Ptr = 0;
    memcpy(buffer_ptr, &dataref, sizeof(dataref));
    break;
  }
  case pwr_eType_Time: {
    pwr_tTime time;

    if (streq(value_str, "AtZero"))
      memcpy(buffer_ptr, &pwr_cAtMin, sizeof(pwr_tTime));
    else if (streq(value_str, "AtMax"))
      memcpy(buffer_ptr, &pwr_cAtMax, sizeof(pwr_tTime));
    else {
      sts = time_AsciiToA(value_str, &time);
      if (EVEN(sts))
        return GDH__CONVERT;
      memcpy(buffer_ptr, (char*)&time, sizeof(time));
    }
    break;
  }
  case pwr_eType_DeltaTime: {
    pwr_tDeltaTime deltatime;

    if (streq(value_str, "DtMin"))
      memcpy(buffer_ptr, &pwr_cDtMin, sizeof(pwr_tDeltaTime));
    else if (streq(value_str, "DtMax"))
      memcpy(buffer_ptr, &pwr_cDtMax, sizeof(pwr_tDeltaTime));
    else {
      sts = time_AsciiToD(value_str, &deltatime);
      if (EVEN(sts))
        return GDH__CONVERT;
      memcpy(buffer_ptr, (char*)&deltatime, sizeof(deltatime));
    }
    break;
  }
  case pwr_eType_Enum: {
    if (sscanf(value_str, "%lu", (unsigned long*)buffer_ptr) != 1)
      return GDH__CONVERT;
    break;
  }
  }
  return GDH__SUCCESS;
}

pwr_tStatus gdh_SearchFile(pwr_tOid oid, char* dir, char* pattern,
    pwr_tString40* filelist[], int* filecnt)
{
  pwr_tStatus sts;
  gdb_sObject* op;
  int is_cached = 0;

  if (oid.vid == 0) {
    sts = dcli_get_files(dir, pattern, filelist, filecnt);
    return sts;
  }

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_global, vol_mTrans_all, cvol_eHint_none);

    if (op->l.flags.b.isCached) {
      is_cached = 1;
      cvolc_FileList(&sts, op, dir, pattern, filelist, filecnt);
    }
  }
  gdh_ScopeUnlock;

  if (!is_cached)
    sts = dcli_get_files(dir, pattern, filelist, filecnt);
  return sts;
}

pwr_tStatus gdh_SetObjectReadOnly(pwr_tOid oid)
{
  pwr_tStatus sts = GDH__SUCCESS;
  gdb_sObject* op;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_native, vol_mTrans_all, cvol_eHint_none);
    if (op == NULL)
      break;

    op->u.n.lflags.b.readOnly = 1;
  }
  gdh_ScopeUnlock;

  return sts;
}

/**
 * @brief Get security information
 *
 * Returns the content of the $Securiy object of the current node.
 * @return pwr_tStatus
 */
pwr_tStatus gdh_GetSecurityInfo(
    pwr_sSecurity* security /**< Pointer to buffer supplied by the user */
    )
{
  pwr_tStatus sts;
  pwr_tAttrRef aref;
  pwr_tOid oid;
  pwr_tCid cid;
  pwr_tOName name;

  sts = gdh_ObjidToName(
      gdbroot->db->nod_oid, name, sizeof(name), cdh_mName_volumeStrict);
  if (EVEN(sts))
    return sts;
  strcat(name, "-Security");

  sts = gdh_NameToObjid(name, &oid);
  if (EVEN(sts))
    return sts;

  sts = gdh_GetObjectClass(oid, &cid);
  if (EVEN(sts))
    return sts;

  if (cid != pwr_eClass_Security)
    return GDH__NOSUCHOBJ;

  aref = cdh_ObjidToAref(oid);
  return gdh_GetObjectInfoAttrref(&aref, security, sizeof(*security));
}

void gdh_RegisterLogFunction(void (*func)(char*, void*, unsigned int))
{
  gdh_log_cb = func;
}

pwr_tStatus gdh_GetSubClassList(pwr_tCid cid, pwr_tCid* subcid)
{
  return gdh_GetNextSubClass(cid, 0, subcid);
}

pwr_tStatus gdh_GetNextSubClass(
    pwr_tCid cid, pwr_tCid psubcid, pwr_tCid* subcid)
{
  pwr_tStatus sts;
  pwr_tOid oid;
  pwr_tCid cd_cid;
  pwr_tCid super_cid;

  if (psubcid == 0)
    sts = gdh_GetClassList(pwr_eClass_ClassDef, &oid);
  else {
    oid = cdh_ClassIdToObjid(psubcid);
    sts = gdh_GetNextObject(oid, &oid);
  }
  for (; ODD(sts); sts = gdh_GetNextObject(oid, &oid)) {
    cd_cid = cdh_ClassObjidToId(oid);

    sts = gdh_GetSuperClass(cd_cid, &super_cid, pwr_cNOid);
    if (EVEN(sts))
      continue;

    if (super_cid == cid) {
      *subcid = cd_cid;
      return GDH__SUCCESS;
    }
  }
  return GDH__NOSUCHCLASS;
}

pwr_tStatus gdh_GetGlobalClassList(int cidcnt, pwr_tCid* cid, int attrobjects,
    pwr_tAttrRef* classlist[], int* listcnt)
{
  pwr_tStatus sts;
  qcom_sNode mynode, node;
  pwr_tNid nid;
  pwr_tAttrRef* clist;
  int ccnt;
  int i;
  pwr_tObjid oid;
  pwr_tAttrRef aref;

  array_tCtx arr = array_New(sizeof(pwr_tAttrRef), 20);

  /* Add local objects */
  if (attrobjects) {
    for (i = 0; i < cidcnt; i++) {
      for (sts = gdh_GetClassListAttrRef(cid[i], &aref); ODD(sts);
           sts = gdh_GetNextAttrRef(cid[i], &aref, &aref)) {
        array_Push(arr, &aref);
      }
    }
  } else {
    for (i = 0; i < cidcnt; i++) {
      for (sts = gdh_GetClassList(cid[i], &oid); ODD(sts);
           sts = gdh_GetNextObject(oid, &oid)) {
        aref = cdh_ObjidToAref(oid);
        array_Push(arr, &aref);
      }
    }
  }

  qcom_MyNode(&sts, &mynode);
  for (nid = qcom_cNNid; qcom_NextNode(&sts, &node, nid); nid = node.nid) {
    if (node.nid == mynode.nid)
      continue;

    cvolc_ClassList(&sts, node.nid, cidcnt, cid, attrobjects, &clist, &ccnt);
    if (EVEN(sts))
      continue;

    array_Concat(arr, clist, ccnt);
  }

  if (arr->size)
    *classlist = array_Copy(arr);
  else {
    *classlist = 0;
    sts = GDH__NOSUCHOBJ;
  }
  *listcnt = arr->size;

  array_Delete(arr);
  return GDH__SUCCESS;
}

pwr_tStatus gdh_GetLocalClassList(int cidcnt, pwr_tCid* cid, int attrobjects,
    pwr_tAttrRef* classlist[], int* listcnt)
{
  pwr_tStatus sts;
  int i;
  pwr_tObjid oid;
  pwr_tAttrRef aref;

  array_tCtx arr = array_New(sizeof(pwr_tAttrRef), 20);

  /* Add local objects */
  if (attrobjects) {
    for (i = 0; i < cidcnt; i++) {
      for (sts = gdh_GetClassListAttrRef(cid[i], &aref); ODD(sts);
           sts = gdh_GetNextAttrRef(cid[i], &aref, &aref)) {
        array_Push(arr, &aref);
      }
    }
  } else {
    for (i = 0; i < cidcnt; i++) {
      for (sts = gdh_GetClassList(cid[i], &oid); ODD(sts);
           sts = gdh_GetNextObject(oid, &oid)) {
        aref = cdh_ObjidToAref(oid);
        array_Push(arr, &aref);
      }
    }
  }

  if (arr->size)
    *classlist = array_Copy(arr);
  else {
    *classlist = 0;
    sts = GDH__NOSUCHOBJ;
  }
  *listcnt = arr->size;

  array_Delete(arr);
  return GDH__SUCCESS;
}

pwr_tStatus gdh_CheckLocalObject(pwr_tOid oid)
{
  pwr_tStatus sts;
  gdb_sObject *op;

  gdh_ScopeLock {
    op = vol_OidToObject(&sts, oid, gdb_mLo_local, vol_mTrans_none, cvol_eHint_none);
  } gdh_ScopeUnlock;

  if (op == NULL)
    return sts;
  return GDH__SUCCESS;
}

pwr_tStatus gdh_TidToType(pwr_tTid tid, pwr_eType *type)
{
  pwr_tOid oid = cdh_TypeIdToObjid(tid);
  pwr_eType *p;
  gdb_sObject *op;
  pwr_tStatus sts = GDH__SUCCESS;

  gdh_ScopeLock
  {
    op = vol_OidToObject(
        &sts, oid, gdb_mLo_native, vol_mTrans_all, cvol_eHint_none);
    if (op != NULL) {
      p = (pwr_eType *)vol_ObjectToAddress(&sts, op);
      if ( p != NULL)
	*type = *p;
    }
  }
  gdh_ScopeUnlock;

  return sts;
}

pwr_tStatus gdh_MountDynClients(void)
{
  gdb_sObject *op;
  pwr_tOid oid;
  pwr_tStatus sts = GDH__SUCCESS;

  for (sts = gdh_GetClassList(pwr_eClass_MountDynObject, &oid); 
       ODD(sts);
       sts = gdh_GetNextObject(oid, &oid)) {

    gdh_ScopeLock
    {
      op = vol_OidToObject(&sts, oid, gdb_mLo_native, vol_mTrans_none, 
			   cvol_eHint_none);
      if (cdh_ObjidIsNull(op->g.soid))
	vol_MountDynObject(&sts, op);
    }
    gdh_ScopeUnlock;
  }
  return sts;
}


/**
 * @brief Thread save function to fetch a direct linked absolute time value.
 * Sets the time lock to ensure that the time is not modified during
 * the operation.
 * The application first has to attach the time lock with a call to
 * lck_Create(&sts, lck_eLock_Time).
 */
void gdh_GetTimeDL(pwr_tTime* atp, /**< Direct link to time attribute */
    pwr_tTime* time /**< Receives the requested time */
    )
{
  lck_Lock(lck_eLock_Time);
  *time = *atp;
  lck_Unlock(lck_eLock_Time);
}

/**
 * @brief Thread save function to store a direct linked absolute time value.
 * Sets the time lock to ensure that the time is not modified during
 * the operation.
 * The application first has to attach the time lock with a call to
 * lck_Create(&sts, lck_eLock_Time).
 */
void gdh_SetTimeDL(pwr_tTime* atp, /**< Direct link to time attribute */
    pwr_tTime* time /**< Time value to set */
    )
{
  if (time) {
    lck_Lock(lck_eLock_Time);
    *atp = *time;
    lck_Unlock(lck_eLock_Time);
  } else {
    /* Set current time */
    lck_Lock(lck_eLock_Time);
    time_GetTime(atp);
    lck_Unlock(lck_eLock_Time);
  }
}

/**
 * @brief Thread save function to fetch a direct linked delta time value.
 * Sets the time lock to ensure that the time is not modified during
 * the operation.
 * The application first has to attach the time lock with a call to
 * lck_Create(&sts, lck_eLock_Time).
 */
void gdh_GetDeltaTimeDL(
    pwr_tDeltaTime* dtp, /**< Direct link to time attribute */
    pwr_tDeltaTime* time /**< Receives the requested time */
    )
{
  lck_Lock(lck_eLock_Time);
  *time = *dtp;
  lck_Unlock(lck_eLock_Time);
}

/**
 * @brief Thread save function to store a direct linked delta time value.
 * Sets the time lock to ensure that the time is not modified during
 * the operation.
 * The application first has to attach the time lock with a call to
 * lck_Create(&sts, lck_eLock_Time).
 */
void gdh_SetDeltaTimeDL(
    pwr_tDeltaTime* dtp, /**< Direct link to time attribute */
    pwr_tDeltaTime* time /**< Time value to set */
    )
{
  lck_Lock(lck_eLock_Time);
  *dtp = *time;
  lck_Unlock(lck_eLock_Time);
}

/**
 * @brief Thread save function to fetch a direct linked string value.
 * Sets the string lock to ensure that the string is not modified during
 * the operation.
 * The application first has to attach the string lock with a call to
 * lck_Create(&sts, lck_eLock_Str).
 */
void gdh_GetStrDL(char* sp, /**< Direct link to string attribute */
    char* str, /**< Receives the requested string */
    int size /**< Size of string */
    )
{
  lck_Lock(lck_eLock_Str);
  strncpy(str, sp, size);
  lck_Unlock(lck_eLock_Str);
}

/**
 * @brief Thread save function to store a direct linked string value.
 * Sets the string lock to ensure that the string is not modified during
 * the operation.
 * The application first has to attach the string lock with a call to
 * lck_Create(&sts, lck_eLock_Str).
 */
void gdh_SetStrDL(char* sp, /**< Direct link to string attribute */
    const char* str, /**< String value to set */
    int size /**< Size of string */
    )
{
  lck_Lock(lck_eLock_Str);
  strncpy(sp, str, size);
  lck_Unlock(lck_eLock_Str);
}

/**
 * @brief Fetch an absolute time value from an attribute.
 * Sets the time lock to ensure that the time is not modified during
 * the operation.
 * The application first has to attach the time lock with a call to
 * lck_Create(&sts, lck_eLock_Time).
 *
 * @return pwr_tStatus
 */
pwr_tStatus gdh_GetObjectInfoTime(const char* name, /**< Attribute name */
    pwr_tTime* time /**< Receives the requested time */
    )
{
  pwr_tStatus sts;

  lck_Lock(lck_eLock_Time);
  sts = gdh_GetObjectInfo(name, (pwr_tAddress)time, sizeof(pwr_tTime));
  lck_Unlock(lck_eLock_Time);
  return sts;
}

/**
 * @brief Store an absolute time value in an attribute.
 * Sets the time lock to ensure that the time is not modified during
 * the operation.
 * The application first has to attach the time lock with a call to
 * lck_Create(&sts, lck_eLock_Time).
 *
 * @return pwr_tStatus
 */
pwr_tStatus gdh_SetObjectInfoTime(const char* name, /**< Attribute name */
    pwr_tTime* time /**< Time to set */
    )
{
  pwr_tStatus sts;

  lck_Lock(lck_eLock_Time);
  sts = gdh_SetObjectInfo(name, (void*)time, sizeof(pwr_tTime));
  lck_Unlock(lck_eLock_Time);
  return sts;
}

/**
 * @brief Fetch an delta time value from an attribute.
 * Sets the time lock to ensure that the time is not modified during
 * the operation.
 * The application first has to attach the time lock with a call to
 * lck_Create(&sts, lck_eLock_Time).
 *
 * @return pwr_tStatus
 */
pwr_tStatus gdh_GetObjectInfoDeltaTime(const char* name, /**< Attribute name */
    pwr_tDeltaTime* time /**< Receives the requested time */
    )
{
  pwr_tStatus sts;

  lck_Lock(lck_eLock_Time);
  sts = gdh_GetObjectInfo(name, (void*)time, sizeof(pwr_tDeltaTime));
  lck_Unlock(lck_eLock_Time);
  return sts;
}

/**
 * @brief Store a delta time value in an attribute.
 * Sets the time lock to ensure that the time is not modified during
 * the operation.
 * The application first has to attach the time lock with a call to
 * lck_Create(&sts, lck_eLock_Time).
 *
 * @return pwr_tStatus
 */
pwr_tStatus gdh_SetObjectInfoDeltaTime(const char* name, /**< Attribute name */
    pwr_tDeltaTime* time /**< Time to set */
    )
{
  pwr_tStatus sts;

  lck_Lock(lck_eLock_Time);
  sts = gdh_SetObjectInfo(name, (void*)time, sizeof(pwr_tDeltaTime));
  lck_Unlock(lck_eLock_Time);
  return sts;
}

/**
 * @brief Fetch a string value from an attribute.
 * Sets the string lock to ensure that the string is not modified during
 * the operation.
 * The application first has to attach the string lock with a call to
 * lck_Create(&sts, lck_eLock_Str).
 *
 * @return pwr_tStatus
 */
pwr_tStatus gdh_GetObjectInfoStr(const char* name, /**< Attribute name */
    char* str, /**< Receives the requested string */
    int size /**< String size */
    )
{
  pwr_tStatus sts;

  lck_Lock(lck_eLock_Str);
  sts = gdh_GetObjectInfo(name, (void*)str, size);
  lck_Unlock(lck_eLock_Str);
  return sts;
}

/**
 * @brief Store a string value in an attribute.
 * Sets the string lock to ensure that the string is not modified during
 * the operation.
 * The application first has to attach the string lock with a call to
 * lck_Create(&sts, lck_eLock_Str).
 *
 * @return pwr_tStatus
 */
pwr_tStatus gdh_SetObjectInfoStr(const char* name, /**< Attribute name */
    const char* str, /**< String to set */
    int size /**< String size */
    )
{
  pwr_tStatus sts;

  lck_Lock(lck_eLock_Str);
  sts = gdh_SetObjectInfo(name, (void*)str, size);
  lck_Unlock(lck_eLock_Str);
  return sts;
}
