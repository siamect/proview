/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* plc_thread.c -- Run a PLC thread
   Run a PLC thread.  */

#include <errno.h>
#include <float.h>
#include <pwd.h>
#include <string.h>
#include <unistd.h>

#if defined OS_LINUX
#include <linux/capability.h>
#endif

#include "co_time.h"
#include "co_time_msg.h"
#include "co_cdh.h"
#include "rt_plc_msg.h"
#include "rt_plc_rt.h"
#include "rt_thread_msg.h"
#include "rt_sim_msg.h"
#include "rt_qcom_msg.h"
#include "rt_csup.h"
#include "rt_c_plcthread.h"
#include "rt_c_node.h"
#include "rt_lck.h"

#define MIN_SCANTIME 1e-9

/* When you use pthread_cond_timedwait is the shortest timeout always > 1
 * CLK_TCK
 * So if you want to run a PLC-program with the same frequency as the scheduler
 * you need to use a rt-timer. In this version there is no slip detection if
 * you use a rt-timer. You need to set USE_RT_TIMER to 1 in rt_plc_thread.c
 * and rt_plc_process.c
 */
#define USE_RT_TIMER 0

static void scan(plc_sThread*);
static pwr_tStatus plc_redu_send_table(plc_sThread* tp);

static pwr_tStatus plc_redu_init(plc_sThread* tp)
{
  pwr_tStatus sts;
  pwr_tOid child;
  void* p;
  pwr_tCid cid;

  for (sts = gdh_GetChild(tp->aref.Objid, &child); ODD(sts);
       sts = gdh_GetNextSibling(child, &child)) {
    sts = gdh_GetObjectClass(child, &cid);
    if (EVEN(sts))
      continue;
    if (cid == pwr_cClass_RedcomPacket) {
      sts = gdh_ObjidToPointer(child, &p);
      if (EVEN(sts))
        return sts;

      sts = redu_init(&tp->redu, tp->pp->Node, p);
      if (EVEN(sts))
        return sts;

      return PLC__SUCCESS;
    }
  }
  return PLC__REDUCONFIG;
}

static pwr_tStatus plc_redu_receive(plc_sThread* tp, unsigned int timeout)
{
  pwr_tStatus sts;
  void* msg;
  int size;

  sts = redu_receive(tp->redu, timeout, &size, &msg);
  if (sts == QCOM__TMO)
    return sts;
  else if (EVEN(sts))
    return sts;

  switch (((redu_sHeader*)msg)->type) {
  case redu_eMsgType_Table:
    if (tp->redu->t)
      redu_free_table(tp->redu);

    sts = redu_receive_table(tp->redu, msg);
    if (tp->redu->packetp) {
      tp->redu->packetp->TableStatus = sts;
      tp->redu->packetp->TableVersion = tp->redu->table_version;
    }
    if (EVEN(sts)) {
      qcom_Free(&sts, msg);
      return sts;
    }
    tp->redu->table_sent = 1;
    break;
  case redu_eMsgType_Cyclic:
    if (tp->redu->packetp)
      tp->redu->packetp->PacketSize = size;
    sts = redu_unpack_message(tp->redu, msg);
    if (EVEN(sts)) {
      qcom_Free(&sts, msg);
      return sts;
    }
    break;
  case redu_eMsgType_TableRequest: {
    sts = plc_redu_send_table(tp);
    if (ODD(sts))
      tp->redu->table_sent = 1;
    break;
  }
  case redu_eMsgType_TableVersionRequest: {
    sts = redu_send_table_version(tp->redu);
    break;
  }
  case redu_eMsgType_TableVersion: {
    int tsts;
    pwr_tTime table_version;

    tp->redu_table_version_req_sent = 0;
    if (tp->redu->table_version.tv_sec == 0)
      table_version = tp->redu->nodep->CurrentVersion;
    else
      table_version = tp->redu->table_version;

    tsts = time_Acomp_NE(
        &table_version, &((redu_sMsgTableVersion*)msg)->version);
    if (tsts == 0)
      sts = redu_send_table_request(tp->redu);
    else {
      sts = plc_redu_send_table(tp);
      if (EVEN(sts)) {
        qcom_Free(&sts, msg);
        return sts;
      }
      tp->redu->table_sent = 1;
    }
    break;
  }
  default:
    printf("Redu: Unknown message type %d\n", ((redu_sHeader*)msg)->type);
  }
  qcom_Free(&sts, msg);
  return PLC__SUCCESS;
}

static pwr_tStatus plc_redu_receive_active(plc_sThread* tp)
{
  pwr_tStatus sts;
  void* msg;
  int size;

  sts = redu_receive(tp->redu, qcom_cTmoNone, &size, &msg);
  if (EVEN(sts))
    return sts;

  switch (((redu_sHeader*)msg)->type) {
  case redu_eMsgType_Table:
    if (tp->redu->t)
      redu_free_table(tp->redu);

    sts = redu_receive_table(tp->redu, msg);
    if (tp->redu->packetp) {
      tp->redu->packetp->TableStatus = sts;
      tp->redu->packetp->TableVersion = tp->redu->table_version;
    }
    if (EVEN(sts)) {
      qcom_Free(&sts, msg);
      return sts;
    }
    tp->redu->table_sent = 1;
    break;
  case redu_eMsgType_Cyclic:
    break;
  case redu_eMsgType_TableRequest: {
    sts = plc_redu_send_table(tp);
    if (EVEN(sts))
      return sts;
    tp->redu->table_sent = 1;
    break;
  }
  case redu_eMsgType_TableVersionRequest: {
    sts = redu_send_table_version(tp->redu);
    break;
  }
  case redu_eMsgType_TableVersion: {
    int tsts;
    pwr_tTime table_version;

    if (tp->redu->table_version.tv_sec == 0)
      table_version = tp->redu->nodep->CurrentVersion;
    else
      table_version = tp->redu->table_version;

    tsts = time_Acomp_NE(
        &table_version, &((redu_sMsgTableVersion*)msg)->version);
    if (tsts == 0)
      sts = redu_send_table_request(tp->redu);
    else {
      sts = plc_redu_send_table(tp);
      if (ODD(sts))
        tp->redu->table_sent = 1;
    }
    break;
  }
  default:
    printf("Redu: Unknown message type\n");
  }
  qcom_Free(&sts, msg);
  return PLC__SUCCESS;
}

static pwr_tStatus plc_redu_send_table(plc_sThread* tp)
{
  void* table_msg;
  pwr_tStatus sts;

  if (!tp->redu->table_created) {
    sts = redu_create_table(tp->redu);
    if (tp->redu->packetp) {
      tp->redu->packetp->TableStatus = sts;
      tp->redu->packetp->TableVersion = tp->redu->table_version;
    }
    if (EVEN(sts))
      return sts;
    tp->redu->table_created = 1;
  }

  sts = redu_send_table(tp->redu, &table_msg);
  if (tp->redu->packetp)
    tp->redu->packetp->TableStatus = sts;
  if (EVEN(sts))
    return sts;

  sts = redu_send(tp->redu, table_msg,
      ((redu_sTableMsgHeader*)table_msg)->size + sizeof(redu_sTableMsgHeader),
      tp->redu->msgid_table);
  free(table_msg);
  return sts;
}

static pwr_tStatus plc_redu_send(plc_sThread* tp)
{
  pwr_tStatus sts;
  void* msg;

  if (!tp->redu->table_sent) {
    sts = plc_redu_send_table(tp);
    if (EVEN(sts))
      return sts;
    tp->redu->table_sent = 1;
  }

  sts = redu_create_message(tp->redu, &msg);
  if (EVEN(sts))
    return sts;

  tp->redu->packetp->PacketSize
      = ((redu_sMsgHeader*)msg)->size + sizeof(redu_sMsgHeader);

  sts = redu_send(tp->redu, msg,
      ((redu_sMsgHeader*)msg)->size + sizeof(redu_sMsgHeader),
      tp->redu->msgid_cyclic);

  free(msg);

  return sts;
}

void plc_thread(plc_sThread* tp)
{
  pwr_tStatus sts = 0;
  int rel_vec;
  long int phase;
  uid_t ruid;
  plc_sProcess* pp = tp->pp;

  /* Phase 1.  */

  tp->init(1, tp);

  if (tp->PlcThread->Deadline > FLT_EPSILON) {
    sts = thread_SetDeadline(tp->PlcThread);
  } else {
    sts = thread_SetPrio(&tp->tid, tp->prio);
  }
  if (EVEN(sts)) {
    errh_Error("Failed to set priority, plc thread %d ms, prio %d",
        (int)(tp->PlcThread->ScanTime * 1000), tp->prio);
  } else {
    errh_Info("Priority set, plc thread %d ms, prio %d",
        (int)(tp->PlcThread->ScanTime * 1000), tp->prio);
  }

  que_Put(&sts, &tp->q_out, &tp->event, (void*)1);
  phase = (long int)que_Get(&sts, &tp->q_in, NULL, NULL);
  pwr_Assert(phase == 2);

  /* Phase 2.  */

  tp->init(2, tp);

  que_Put(&sts, &tp->q_out, &tp->event, (void*)2);
  phase = (long int)que_Get(&sts, &tp->q_in, NULL, NULL);
  pwr_Assert(phase == 3);

  /* Phase 3.  */

  rel_vec = ((tp->pp->PlcProcess->ChgCount - 1) % 2) + 1;
  sts = io_init(tp->PlcThread->IoProcess, tp->aref.Objid, &tp->plc_io_ctx,
      rel_vec, tp->f_scan_time);
  if (EVEN(sts)) {
    pp->IOHandler->IOReadWriteFlag = FALSE;
    errh_Error("Failed to inititalize io, %m", sts);
    errh_SetStatus(PLC__ERRINITIO);
  }

/* Once thread's has set it's priority don't run as root */

  struct passwd* pwd;

  ruid = getuid();

  if (ruid == 0) {
    pwd = getpwnam("pwrp");
    if (pwd != NULL) {
      setreuid(pwd->pw_uid, pwd->pw_uid);
    }
  } else
    setreuid(ruid, ruid);

  tp->init(0, tp);

  if (tp->pp->IOHandler->IOReadWriteFlag) {
    sts = io_read(tp->plc_io_ctx);
    if (EVEN(sts)) {
      tp->pp->IOHandler->IOReadWriteFlag = FALSE;
      errh_Error("IO read, %m", sts);
      errh_SetStatus(PLC__IOREAD);
    }
  }

  if (tp->pp->Node->RedundancyState != pwr_eRedundancyState_Off) {
    sts = plc_redu_init(tp);
    if (EVEN(sts)) {
      errh_Error("Redundance init, %m", sts);
      tp->redu = 0;
    }
  }

  thread_MutexLock(&tp->pp->io_copy_mutex);
  memcpy(tp->copy.ai_a.p, tp->pp->base.ai_a.p, tp->copy.ai_a.size);
  memcpy(tp->copy.ao_a.p, tp->pp->base.ao_a.p, tp->copy.ao_a.size);
  memcpy(tp->copy.av_a.p, tp->pp->base.av_a.p, tp->copy.av_a.size);
  memcpy(tp->copy.ca_a.p, tp->pp->base.ca_a.p, tp->copy.ca_a.size);
  memcpy(tp->copy.co_a.p, tp->pp->base.co_a.p, tp->copy.co_a.size);
  memcpy(tp->copy.di_a.p, tp->pp->base.di_a.p, tp->copy.di_a.size);
  memcpy(tp->copy.do_a.p, tp->pp->base.do_a.p, tp->copy.do_a.size);
  memcpy(tp->copy.dv_a.p, tp->pp->base.dv_a.p, tp->copy.dv_a.size);
  memcpy(tp->copy.ii_a.p, tp->pp->base.ii_a.p, tp->copy.ii_a.size);
  memcpy(tp->copy.io_a.p, tp->pp->base.io_a.p, tp->copy.io_a.size);
  memcpy(tp->copy.iv_a.p, tp->pp->base.iv_a.p, tp->copy.iv_a.size);
  memcpy(tp->copy.bi_a.p, tp->pp->base.bi_a.p, tp->copy.bi_a.size);
  memcpy(tp->copy.bo_a.p, tp->pp->base.bo_a.p, tp->copy.bo_a.size);
  thread_MutexUnlock(&tp->pp->io_copy_mutex);

  if (tp->tim_copy_lock) {
    lck_LockTime;
    memcpy(tp->copy.atv_a.p, tp->pp->base.atv_a.p, tp->copy.atv_a.size);
    memcpy(tp->copy.dtv_a.p, tp->pp->base.dtv_a.p, tp->copy.dtv_a.size);
    lck_UnlockTime;
  }
  if (tp->str_copy_lock) {
    lck_LockStr;
    memcpy(tp->copy.sv_a.p, tp->pp->base.sv_a.p, tp->copy.sv_a.size);
    lck_UnlockStr;
  }

  que_Put(&sts, &tp->q_out, &tp->event, (void*)3);
  phase = (long int)que_Get(&sts, &tp->q_in, NULL, NULL);
  pwr_Assert(phase == 4);

  /* Phase 4.  */

  que_Put(&sts, &tp->q_out, &tp->event, (void*)4);

  pwrb_PlcThread_Zero(tp);

  time_GetTimeMonotonic(&tp->sync_time);

  tp->ActualScanTime = tp->f_scan_time;

  while (!tp->exit) {
    scan(tp);
  }

  //  sts = io_close(tp->plc_io_ctx);

  /* Tell main we are done.  */
  que_Put(&sts, &tp->q_out, &tp->event, (void*)5);
}

static int sim_scan(plc_sThread* tp)
{
  pwr_sClass_SimulateConfig* sp = tp->pp->SimConfig;
  unsigned int i;
  int select_thread_cnt;

  if (!tp->sim_initdone_old && sp->InitDone) {
    /* Identify index in simulate configuration */
    for (i = 0; i < sizeof(sp->PlcThreads) / sizeof(sp->PlcThreads[0]); i++) {
      if (cdh_ObjidIsEqual(tp->aref.Objid, sp->PlcThreads[i])) {
        tp->sim_idx = i;
        sp->ThreadStatus[i]
            = tp->sim_halted ? SIM__THREAD_HALT : SIM__THREAD_RUNNING;
        break;
      }
    }
    tp->sim_disable_old = sp->Disable;
  }
  tp->sim_initdone_old = sp->InitDone;

  if (!tp->sim_disable_old && sp->Disable) {
    pwr_tTime current;

    /* Use nominal scantime as time since last scan */
    time_GetTimeMonotonic(&current);
    time_Asub(&tp->one_before_scan, &current, &tp->scan_time);
    time_GetTime(&current);
    time_Asub(&tp->one_before_scan_abs, &current, &tp->scan_time);

    tp->sim_disable_old = sp->Disable;
    return 0;
  }
  tp->sim_disable_old = sp->Disable;

  if (sp->PlcHaltOrder && sp->ThreadSelected[tp->sim_idx]) {
    if (!tp->sim_halted) {
      tp->sim_halted = 1;
      sp->ThreadStatus[tp->sim_idx] = SIM__THREAD_HALT;
      sp->PlcHaltOrder--;
    }
  }
  if (sp->PlcContinueOrder && sp->ThreadSelected[tp->sim_idx]) {
    if (tp->sim_halted) {
      pwr_tTime current;

      tp->sim_halted = 0;
      sp->ThreadStatus[tp->sim_idx] = SIM__THREAD_RUNNING;
      sp->PlcContinueOrder--;

      /* Use nominal scantime as time since last scan */
      time_GetTimeMonotonic(&current);
      time_Asub(&tp->one_before_scan, &current, &tp->scan_time);
      time_GetTime(&current);
      time_Asub(&tp->one_before_scan_abs, &current, &tp->scan_time);
    }
  }

  select_thread_cnt = 0;
  for (i = 0; i < sizeof(sp->ThreadSelected) / sizeof(sp->ThreadSelected[0]);
       i++) {
    if (sp->ThreadSelected[i] && sp->ThreadStatus[i] == SIM__THREAD_HALT)
      select_thread_cnt++;
  }

  if (tp->sim_singlestep && (sp->PlcStepOrder <= select_thread_cnt)) {
    tp->sim_singlestep = 0;
    sp->PlcStepOrder--;
  }

  if (sp->PlcStepOrder > select_thread_cnt && sp->ThreadSelected[tp->sim_idx]
      && !tp->sim_singlestep) {
    if (tp->sim_halted) {
      pwr_tTime current;

      sp->PlcStepOrder--;
      if (sp->PlcStepOrder <= select_thread_cnt)
        sp->PlcStepOrder--;
      else
        tp->sim_singlestep = 1;

      /* Use nominal scantime as time since last scan */
      time_GetTimeMonotonic(&current);
      time_Asub(&tp->one_before_scan, &current, &tp->scan_time);
      time_GetTime(&current);
      time_Asub(&tp->one_before_scan_abs, &current, &tp->scan_time);
      return 0;
    }
  }
  if (sp->PlcLoadOrder && tp->sim_halted) {
    sp->PlcLoadOrder--;
  }
  return tp->sim_halted;
}

static void scan(plc_sThread* tp)
{
  pwr_tStatus sts;
  plc_sProcess* pp = tp->pp;
  int delay_action = 0;

  if ( tp->ext_retry_connect_cnt > (int)(5.0/tp->f_scan_time)) {
    tp->ext_retry_connect = 1;
    tp->ext_retry_connect_cnt = 0;
  }
  else {
    tp->ext_retry_connect = 0;
    tp->ext_retry_connect_cnt++;
  }

  //  time_Uptime(&sts, &tp->before_scan, NULL);
  time_GetTimeMonotonic(&tp->before_scan);
  time_GetTime(&tp->before_scan_abs);
  pp->Node->SystemTime = tp->before_scan_abs;

  if (pp->IOHandler->IOSimulFlag && pp->SimConfig) {
    if (!pp->SimConfig->Disable || !tp->sim_disable_old) {
      if (sim_scan(tp)) {
        pwr_tDeltaTime delta;

        time_GetTimeMonotonic(&tp->after_scan);
        time_Aadd(NULL, &tp->sync_time, &tp->scan_time);
        time_Adiff(&delta, &tp->sync_time, &tp->after_scan);
        if (time_Dcomp(&delta, NULL) > 0) {
#if defined OS_MACOS || defined OS_FREEBSD || OS_OPENBSD || OS_CYGWIN
          struct timespec ts;
          ts.tv_sec = delta.tv_sec;
          ts.tv_nsec = delta.tv_nsec;
          nanosleep(&ts, NULL);
#else
          struct timespec ts;

          ts.tv_sec = tp->sync_time.tv_sec;
          ts.tv_nsec = tp->sync_time.tv_nsec;
          sts = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &ts, NULL);
          while (sts == EINTR)
            /* The wait was interruped, continue to sleep */
            sts = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &ts, NULL);
#endif
        }
        return;
      }
    } else
      tp->sim_halted = 0;
  }

  if (tp->loops > 0) {
    /*    if (sts == TIME__CLKCHANGE) {
          time_Dadd(&tp->before_scan, &tp->one_before_scan, &tp->scan_time);
        } */
    time_Adiff(&tp->delta_scan, &tp->before_scan, &tp->one_before_scan);
    time_DToFloat(&tp->ActualScanTime, &tp->delta_scan);
    if (tp->ActualScanTime < MIN_SCANTIME)
      tp->ActualScanTime = MIN_SCANTIME;
  }

  if (tp->redu
      && tp->pp->Node->RedundancyState == pwr_eRedundancyState_Passive) {
    if (tp->redu_state_old == pwr_eRedundancyState_Off
        || tp->redu_state_old == pwr_eRedundancyState_Init) {
      /* Send table version request to see if table should be requested or sent
       */
      if (!tp->redu_table_version_req_sent) {
        sts = redu_send_table_version_request(tp->redu);
        if (ODD(sts))
          tp->redu_table_version_req_sent = 1;
      }
    }
    time_GetTimeMonotonic(&tp->before_scan);
    time_GetTime(&tp->before_scan_abs);

    sts = plc_redu_receive(tp, tp->i_scan_time);
    if (EVEN(sts))
      return;

    time_Aadd(NULL, &tp->sync_time, &tp->scan_time);
    time_GetTimeMonotonic(&tp->after_scan);
    time_GetTime(&tp->after_scan_abs);
    if (tp->log)
      pwrb_PlcThread_Exec(tp);

    if (tp->csup_lh != NULL) {
      pwr_tTime now;
      time_GetTime(&now);
      csup_Exec(&sts, tp->csup_lh, (pwr_tDeltaTime*)&tp->sync_time,
          (pwr_tDeltaTime*)&tp->after_scan, &now);
    }
    tp->one_before_scan = tp->before_scan;
    tp->ActualScanTime = tp->f_scan_time;

    tp->redu_state_old = tp->pp->Node->RedundancyState;

    tp->one_before_scan = tp->before_scan;
    tp->one_before_scan_abs = tp->before_scan_abs;

    if (++tp->loops == 2)
      tp->log = TRUE;

    return;
  }

  if (!tp->redu
      || (tp->pp->Node->RedundancyState != pwr_eRedundancyState_Passive)) {
    if (tp->redu_state_old == pwr_eRedundancyState_Passive && tp->redu)
      sts = plc_redu_receive(tp, 0);

    if (pp->IOHandler->IOReadWriteFlag) {
      if (tp->redu_state_old == pwr_eRedundancyState_Passive)
        tp->plc_io_ctx->read_reset = 1;

      sts = io_read(tp->plc_io_ctx);

      if (tp->redu_state_old == pwr_eRedundancyState_Passive)
        tp->plc_io_ctx->read_reset = 0;
      if (EVEN(sts)) {
        pp->IOHandler->IOReadWriteFlag = FALSE;
        errh_Error("IO read, %m", sts);
        errh_SetStatus(PLC__IOREAD);
      }
    }
    tp->redu_state_old = tp->pp->Node->RedundancyState;

    if (pp->Node->EmergBreakTrue && !tp->emergency_break_old)
      io_swap(tp->plc_io_ctx, io_eEvent_EmergencyBreak);
    tp->emergency_break_old = pp->Node->EmergBreakTrue;

    thread_MutexLock(&pp->io_copy_mutex);
    memcpy(tp->copy.ai_a.p, pp->base.ai_a.p, tp->copy.ai_a.size);
    memcpy(tp->copy.ao_a.p, pp->base.ao_a.p, tp->copy.ao_a.size);
    memcpy(tp->copy.av_a.p, pp->base.av_a.p, tp->copy.av_a.size);
    memcpy(tp->copy.ca_a.p, pp->base.ca_a.p, tp->copy.ca_a.size);
    memcpy(tp->copy.co_a.p, pp->base.co_a.p, tp->copy.co_a.size);
    memcpy(tp->copy.di_a.p, pp->base.di_a.p, tp->copy.di_a.size);
    memcpy(tp->copy.do_a.p, pp->base.do_a.p, tp->copy.do_a.size);
    memcpy(tp->copy.dv_a.p, pp->base.dv_a.p, tp->copy.dv_a.size);
    memcpy(tp->copy.ii_a.p, pp->base.ii_a.p, tp->copy.ii_a.size);
    memcpy(tp->copy.io_a.p, pp->base.io_a.p, tp->copy.io_a.size);
    memcpy(tp->copy.iv_a.p, pp->base.iv_a.p, tp->copy.iv_a.size);
    memcpy(tp->copy.bi_a.p, pp->base.bi_a.p, tp->copy.bi_a.size);
    memcpy(tp->copy.bo_a.p, pp->base.bo_a.p, tp->copy.bo_a.size);
    thread_MutexUnlock(&pp->io_copy_mutex);

    if (tp->tim_copy_lock) {
      lck_LockTime;
      *pp->system_time = tp->before_scan_abs;
      memcpy(tp->copy.atv_a.p, pp->base.atv_a.p, tp->copy.atv_a.size);
      memcpy(tp->copy.dtv_a.p, pp->base.dtv_a.p, tp->copy.dtv_a.size);
      lck_UnlockTime;
    }
    if (tp->str_copy_lock) {
      lck_LockStr;
      memcpy(tp->copy.sv_a.p, pp->base.sv_a.p, tp->copy.sv_a.size);
      lck_UnlockStr;
    }

    /* Execute all the PLC code */
    tp->exec(0, tp);

    if (pp->IOHandler->IOReadWriteFlag) {
      sts = io_write(tp->plc_io_ctx);
      if (EVEN(sts)) {
        pp->IOHandler->IOReadWriteFlag = FALSE;
        errh_Error("IO write, %m", sts);
        errh_SetStatus(PLC__IOWRITE);
      }
    }
    if (tp->redu
        && tp->pp->Node->RedundancyState == pwr_eRedundancyState_Active) {
      sts = plc_redu_receive_active(tp);
      sts = plc_redu_send(tp);
    }
  }

  if (tp->first_scan)
    tp->first_scan = 0;

  time_GetTimeMonotonic(&tp->after_scan);
  /*  if (sts == TIME__CLKCHANGE) {
      tp->after_scan = tp->before_scan;
    }*/
  time_GetTime(&tp->after_scan_abs);
  if (tp->log)
    pwrb_PlcThread_Exec(tp);

  do {
    pwr_tDeltaTime delta;

    plc_timerhandler(tp);
    time_Aadd(NULL, &tp->sync_time, &tp->scan_time);
    time_Adiff(&delta, &tp->sync_time, &tp->after_scan);
    if (time_Dcomp(&delta, NULL) > 0) {
      pwr_tStatus sts;
      int phase = 0;
      tp->skip_count = 0;

      if (tp->csup_lh != NULL) {
        pwr_tTime now;
        time_GetTime(&now);
        delay_action =
            csup_Exec(&sts, tp->csup_lh, (pwr_tDeltaTime*)&tp->sync_time,
                      (pwr_tDeltaTime*)&tp->after_scan, &now);
        if (delay_action == pwr_eSupDelayActionEnum_EmergencyBreak)
        {
          int prev_rwflag = pp->IOHandler->IOReadWriteFlag;
          pp->IOHandler->IOReadWriteFlag = FALSE;
          pp->Node->EmergBreakTrue = TRUE;
          errh_SetStatus(PLC__IOSTALLED);
          if (prev_rwflag)
            errh_Fatal("Delay detected in a CycleSup with action Emergency Break!");
        }
      }

#if defined OS_MACOS || defined OS_FREEBSD || OS_OPENBSD || OS_CYGWIN
      struct timespec ts;
      ts.tv_sec = delta.tv_sec;
      ts.tv_nsec = delta.tv_nsec;
      nanosleep(&ts, NULL);
#else
      /* REMARK
       * que_Get makes use of pthread_cond_timedwait.
       * At this point it is not possible to set the clock-attribute of a
       * condition variable.
       * It should be set with pthread_condattr_setclock() to CLOCK_MONOTONIC,
       * default
       * is always CLOCK_REALTIME which might change. Instead we use
       * clock_nanosleep()
       * and don't have a controlled stop, in most cases we are sleeping anyway.
       * The controlled stop is only needed for warm restart.
       * END REMARK
       */
      //      phase = (int)que_Get(&sts, &tp->q_in, &delta, NULL);
      struct timespec ts;
      ts.tv_sec = tp->sync_time.tv_sec;
      ts.tv_nsec = tp->sync_time.tv_nsec;
      sts = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &ts, NULL);
      while (sts == EINTR)
        /* The wait was interruped, continue to sleep */
        sts = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &ts, NULL);

#endif
      if (phase > 0) {
        tp->exit = TRUE;
      }
      break;

    } else {
      tp->sliped++;
      if (tp->PlcThread->Options & pwr_mThreadOptionsMask_OverExecScanSingle
          && tp->skip_count < 10) {
        tp->skip_count++;
        break;
      } else if (tp->PlcThread->Options
          & pwr_mThreadOptionsMask_OverExecScanAlways)
        break;
    }

  } while (!tp->exit);

  tp->one_before_scan = tp->before_scan;
  tp->one_before_scan_abs = tp->before_scan_abs;

  if (++tp->loops == 2)
    tp->log = TRUE;

  if (tp->loops % MAX(1, (int)(1.0 / tp->PlcThread->ScanTime)) == 0)
    pwrs_Node_SupEmon();
}
