/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_cvolc.c -- Cached volumes, client user API. */

#include <string.h>

#include "rt_gdh_msg.h"
#include "rt_vol.h"
#include "rt_ndc.h"
#include "rt_cvolc.h"
#include "rt_cmvolc.h"

static gdb_sObject* fetch(pwr_tStatus* sts, gdb_sVolume* vp, qcom_sPut* put);

/* General cache fetch routine.  */

static gdb_sObject* fetch(pwr_tStatus* sts, gdb_sVolume* vp, qcom_sPut* put)
{
  pwr_tStatus lsts;
  qcom_sQid tgt;
  qcom_sGet get;
  net_sObjectR* rsp;
  net_sGobject go;
  int i;
  gdb_sNode* np;
  gdb_sObject* op;
  gdb_sObject* rop = NULL;

  gdb_AssumeLocked;

  np = hash_Search(sts, gdbroot->nid_ht, &vp->g.nid);
  if (np == NULL)
    return NULL;

  tgt = np->handler;

  gdb_Unlock;

  rsp = net_Request(&lsts, &tgt, put, &get, net_eMsg_objectR, 0, 0);

  gdb_Lock;

  if (EVEN(lsts))
    pwr_Return(NULL, sts, lsts);
  if (EVEN(lsts = rsp->sts)) {
    net_Free(NULL, rsp);
    pwr_Return(NULL, sts, lsts);
  }
  if (!vp->l.flags.b.isConnected)
    pwr_Return(NULL, sts, GDH__CONNLOST);

  for (i = 0; i < rsp->count; i++) {
    go = rsp->g[i];
    if (vp->g.vid != go.oid.vid) {
      net_Free(NULL, rsp);
      pwr_Return(NULL, sts, GDH__REMOTEMOUNT);
    }

    op = cvol_LoadObject(&lsts, np, vp, &go);
    if (cdh_ObjidIsEqual(go.oid, rsp->oid)) {
      /* This is the referenced object.  */
      rop = op;
      if (sts != NULL)
        *sts = lsts; /* return this status code */
    }
  }

  pwr_Assert(rop != NULL);

  net_Free(NULL, rsp);

  return rop;
}

void* cvolc_GetObjectInfo(pwr_tStatus* sts, const gdb_sNode* np,
    const pwr_sAttrRef* arp, gdb_sCclass* ccp, const pwr_sAttrRef* rarp,
    pwr_tUInt32 ridx, mvol_sAttribute* ap, void* p, int size)
{
  qcom_sQid tgt;
  qcom_sPut put;
  net_sGetObjectInfo* smp; /* Send message.  */
  net_sGetObjectInfoR* rmp; /* Receive message.  */
  pwr_tBoolean equal;
  ndc_sRemoteToNative* tbl = NULL;
  pwr_tBoolean first = 1;
  int rsize;
  cdh_uTypeId cid;

  gdb_AssumeUnlocked;
  pwr_Assert(sts != NULL);

  if (ccp == NULL) {
    equal = 1;
    rarp = arp;
  } else {
    equal = 0;
    cmvolc_AssumeLocked(ccp);
  }

  smp = net_Alloc(sts, &put, sizeof(*smp), net_eMsg_getObjectInfo);
  if (smp == NULL)
    return sts;

  tgt = np->handler;
  smp->aref = *rarp;

  rmp = net_Request(sts, &tgt, &put, NULL, net_eMsg_getObjectInfoR, 0, 0);

  if (rmp == NULL) {
    return NULL;
  } else {
    if (ODD(rmp->sts)) {
      size = MIN(arp->Size, size);
      if (ccp == NULL || equal) {
        gdb_sClass* cp;
        cid.pwr = arp->Body;
        cid.c.bix = 0; /* To get the class id.  */
        cp = hash_Search(sts, gdbroot->cid_ht, &cid.pwr);
        if (cp != NULL) {
          ndc_ConvertData(sts, np, cp, arp, p, rmp->info, (pwr_tUInt32*)&size,
              ndc_eOp_decode, arp->Offset, 0);
        }
      } else {
        if (!ccp->flags.b.rnConv && ap->aop == NULL) { /* whole object */

          gdb_ScopeLock
          {
            if (!ccp->flags.b.rnConv) {
              if (ap->cp == NULL)
                errh_Bugcheck(GDH__WEIRD, "can't get class");

              tbl = pool_Alloc(
                  sts, gdbroot->pool, sizeof(*tbl) * ap->cp->acount);
              if (tbl == NULL)
                break;

              ndc_UpdateRemoteToNativeTable(
                  sts, tbl, ap->cp->acount, ap->cp, ccp, np->nid);
              if (ODD(*sts)) {
                ccp->rnConv = pool_Reference(NULL, gdbroot->pool, tbl);
                ccp->flags.b.rnConv = 1;
              } else {
                pool_Free(NULL, gdbroot->pool, tbl);
                tbl = NULL;
              }
            }
          }
          gdb_ScopeUnlock;
        }

        rsize = rarp->Size;
        ndc_ConvertRemoteData(sts, np, ccp, rarp, rmp->info, rmp->info,
            (pwr_tUInt32*)&rsize, ndc_eOp_decode, rarp->Offset, 0);
        if (ODD(*sts)) {
          if (ccp->flags.b.rnConv) {
            if (tbl == NULL) {
              tbl = pool_Address(sts, gdbroot->pool, ccp->rnConv);
              if (tbl == NULL)
                errh_Bugcheck(
                    *sts, "failed getting address for conversion table");
            }
            gdb_ScopeLock
            {
              ndc_ConvertRemoteToNativeTable(sts, ccp, tbl, rarp, arp, p,
                  rmp->info, (pwr_tUInt32*)&size, arp->Offset, 0, 0, &first,
                  np->nid);
            }
            gdb_ScopeUnlock;

          } else {
            /* The object pointer may be invalid after gdb has been open, reset
             * it */
            ap->op = NULL;
            ndc_ConvertRemoteToNativeData(sts, ccp, ridx, ap, rarp, arp, p,
                rmp->info, (pwr_tUInt32*)&size, arp->Offset, 0, 0, np->nid);
          }
        }
      }
    } else if (sts != NULL)
      *sts = rmp->sts;
    net_Free(NULL, rmp);
    return p;
  }
}

/* Lock a cached object, i.e. exclude it
   from cache trim.  */

void cvolc_LockObject(pwr_tStatus* sts, gdb_sObject* op)
{
  gdb_sVolume* vp;

  gdb_AssumeLocked;
  pwr_Assert(op != NULL);

  if (!op->l.flags.b.isCached || op->u.c.flags.b.cacheLock)
    return;

  vp = pool_Address(NULL, gdbroot->pool, op->l.vr);
  pwr_Assert(vp != NULL);

  cvol_QmoveSucc(op, cvol_Qget(op), &vp->u.c.cacheLock);
}

/* Fetch an object identified by its name.  */

gdb_sObject* cvolc_NameToObject(pwr_tStatus* sts, gdb_sObject* p_op,
    cdh_sParseName* pn, int index, pwr_tBitMask trans)
{
  net_sNameToObject* mp;
  qcom_sPut put;
  pwr_tUInt32 len;
  char* s;
  int i;
  gdb_sVolume* vp;

  gdb_AssumeLocked;

  if (!p_op->l.flags.b.isCached)
    pwr_Return(NULL, sts, GDH__NOSUCHOBJ);

  vp = pool_Address(NULL, gdbroot->pool, p_op->l.vr);
  if (vp == NULL)
    pwr_Return(NULL, sts, GDH__NOSUCHOBJ);

  for (len = 0, i = index; i < pn->nObject; i++)
    len += 1 + pn->object[i].name.pack.c.len;

  len = (len + 3) & ~3; /* Size up to nearest multipel of 4.  */

  mp = net_Alloc(sts, &put, len + sizeof(*mp), net_eMsg_nameToObject);
  if (mp == NULL)
    return NULL;

  mp->poid = pn->object[index].poid;
  mp->trans = trans;
  mp->len = len;
  mp->rcount = mp->lcount = net_cObjectMaxCount / 2;

  for (i = index, s = mp->name; i < pn->nObject; i++) {
    memcpy(s, pn->object[i].name.norm, pn->object[i].name.pack.c.len);
    s += pn->object[i].name.pack.c.len;
    *s++ = '-';
  }
  *--s = '\0';

  return fetch(sts, vp, &put);
}

/* Fetch an object identified by its object identifier.  */

gdb_sObject* cvolc_OidToObject(pwr_tStatus* sts, gdb_sVolume* vp,
    pwr_tObjid oid, pwr_tBitMask trans, cvol_eHint hint)
{
  net_sOidToObject* mp;
  qcom_sPut put;

  gdb_AssumeLocked;

  mp = net_Alloc(sts, &put, sizeof(*mp), net_eMsg_oidToObject);
  if (mp == NULL)
    return NULL;

  mp->oid = oid;
  mp->trans = trans;

  switch (hint) {
  case cvol_eHint_prev:
    mp->lcount = net_cObjectMaxCount;
    mp->rcount = 0;
    break;

  case cvol_eHint_next:
    mp->lcount = 0;
    mp->rcount = net_cObjectMaxCount;
    break;

  default:
    mp->lcount = 0;
    mp->rcount = 0;
    break;
  }

  return fetch(sts, vp, &put);
}

/* Update the object body of an object residing on
   a remote node.  */

pwr_tBoolean cvolc_SetObjectInfo(pwr_tStatus* sts, const gdb_sNode* np,
    const pwr_sAttrRef* arp, const gdb_sCclass* ccp, const pwr_sAttrRef* rarp,
    pwr_tUInt32 ridx, mvol_sAttribute* ap, const void* p, int size)
{
  qcom_sQid tgt;
  qcom_sPut put;
  net_sSetObjectInfo* smp;
  int msize;
  net_sSetObjectInfoR* rmp;
  pwr_tBoolean equal;
  int rsize;
  cdh_uTypeId cid;

  gdb_AssumeUnlocked;

  if (ccp == NULL) {
    equal = 1;
    rarp = arp;
  } else {
    equal = 0;
    cmvolc_AssumeLocked(ccp);
  }

  tgt = np->handler;

  size = MIN(arp->Size, size);

  msize = sizeof(net_sSetObjectInfo) - sizeof(smp->info) + rarp->Size;
  msize = (msize + 3) & ~3; /* Size up to nearest multiple of 4.  */

  smp = net_Alloc(sts, &put, msize, net_eMsg_setObjectInfo);
  if (smp == NULL)
    return NO;

  smp->size = rarp->Size;
  smp->aref = *rarp;

  if (equal) {
    gdb_sClass* cp;
    cid.pwr = arp->Body;
    cid.c.bix = 0; /* To get the class id.  */
    cp = hash_Search(sts, gdbroot->cid_ht, &cid.pwr);
    if (cp != NULL) {
      ndc_ConvertData(sts, np, cp, arp, smp->info, p, (pwr_tUInt32*)&size,
          ndc_eOp_encode, arp->Offset, 0);
    }
  } else {
    /* The object pointer may be invalid after gdb has been open, reset it */
    ap->op = NULL;
    rsize = rarp->Size;
    ndc_ConvertNativeToRemoteData(sts, ccp, ridx, ap, rarp, arp, smp->info, p,
        (pwr_tUInt32*)&rsize, rarp->Offset, 0, 0, np->nid);
    if (ODD(*sts)) {
      rsize = rarp->Size;
      ndc_ConvertRemoteData(sts, np, ccp, rarp, smp->info, smp->info,
          (pwr_tUInt32*)&rsize, ndc_eOp_encode, rarp->Offset, 0);
    }
    if (EVEN(*sts)) {
      net_Free(NULL, smp);
      return NO;
    }
  }

  rmp = net_Request(sts, &tgt, &put, NULL, net_eMsg_setObjectInfoR, 0, 0);

  if (rmp == NULL) {
    return NO;
  } else {
    if (sts != NULL)
      *sts = rmp->sts;
    net_Free(NULL, rmp);
    return YES;
  }
}

/* Move an object to the head of its volume touched list. */
void cvolc_TouchObject(gdb_sObject* op)
{
  gdb_sVolume* vp;
  gdb_sTouchQ* fqp;
  gdb_sTouchQ* vqp;

  gdb_AssumeLocked;
  pwr_Assert(op != NULL);

  if (!op->l.flags.b.isCached || op->u.c.flags.b.cacheLock)
    return;

  vp = pool_Address(NULL, gdbroot->pool, op->l.vr);
  pwr_Assert(vp != NULL);
  vqp = &vp->u.c.cacheVol;
  fqp = cvol_Qget(op);

  cvol_QmoveSucc(op, fqp, vqp);
  if (fqp != vqp)
    cvol_Qtrim(vqp);
}

/* Unlock a cached object, i.e. include it
   in cache trim.  */

void cvolc_UnlockObject(pwr_tStatus* sts, gdb_sObject* op)
{
  gdb_sVolume* vp;
  gdb_sTouchQ* fqp;
  gdb_sTouchQ* vqp;

  gdb_AssumeLocked;
  pwr_Assert(op != NULL);

  if (!op->l.flags.b.isCached || !op->u.c.flags.b.cacheLock)
    return;

  vp = pool_Address(NULL, gdbroot->pool, op->l.vr);
  pwr_Assert(vp != NULL);
  vqp = &vp->u.c.cacheVol;
  fqp = cvol_Qget(op);
  pwr_Assert(fqp == &vp->u.c.cacheLock);
  cvol_QmoveSucc(op, fqp, vqp);
  cvol_Qtrim(vqp);
}

void cvolc_FileList(pwr_tStatus* sts, gdb_sObject* p_op, char* dir,
    char* pattern, pwr_tString40* filelist[], int* filecnt)
{
  net_sFileList* mp;
  qcom_sPut put;
  gdb_sVolume* vp;
  pwr_tStatus lsts;
  qcom_sQid tgt;
  qcom_sGet get;
  net_sFileListR* rsp;
  gdb_sNode* np;

  gdb_AssumeLocked;

  if (!p_op->l.flags.b.isCached) {
    *sts = GDH__NOSUCHOBJ;
    return;
  }
  vp = pool_Address(NULL, gdbroot->pool, p_op->l.vr);
  if (vp == NULL) {
    *sts = GDH__NOSUCHOBJ;
    return;
  }

  mp = net_Alloc(sts, &put, sizeof(*mp), net_eMsg_fileList);
  if (mp == NULL)
    return;

  strncpy(mp->pattern, pattern, sizeof(mp->pattern));
  strncpy(mp->dir, dir, sizeof(mp->dir));

  np = hash_Search(sts, gdbroot->nid_ht, &vp->g.nid);
  if (np == NULL)
    return;

  tgt = np->handler;

  gdb_Unlock;

  rsp = net_Request(&lsts, &tgt, &put, &get, net_eMsg_fileListR, 0, 0);

  gdb_Lock;

  if (EVEN(lsts)) {
    *sts = lsts;
    return;
  }
  if (EVEN(rsp->sts)) {
    *sts = rsp->sts;
    net_Free(NULL, rsp);
    return;
  }

  *filecnt = rsp->filecnt;
  *filelist = calloc(rsp->filecnt, sizeof(pwr_tString40));
  memcpy((*filelist)[0], rsp->files, rsp->filecnt * sizeof(pwr_tString40));

  net_Free(NULL, rsp);
}

void cvolc_ClassList(pwr_tStatus* sts, pwr_tNid nid, int cidcnt, pwr_tCid* cid,
    int attrobjects, pwr_tAttrRef* classlist[], int* listcnt)
{
  gdb_sNode* np = NULL;
  net_sClassList* mp;
  net_sClassListR* rsp;
  qcom_sQid tgt;
  qcom_sPut put;
  qcom_sGet get;
  gdb_sVolume* vp = NULL;

  np = hash_Search(sts, gdbroot->nid_ht, &nid);
  if (np == NULL)
    pwr_ReturnVoid(sts, GDH__NOSUCHNODE);

  vp = hash_Search(sts, gdbroot->vid_ht, &np->nid);
  if (vp == NULL)
    pwr_ReturnVoid(sts, GDH__NOSUCHVOL);

  if (!vp->l.flags.b.isMounted)
    pwr_ReturnVoid(sts, GDH__NOTMOUNTED);
  if (!(vp->l.flags.m & gdb_mLo_global))
    pwr_ReturnVoid(sts, GDH__NOTMOUNTED);

  tgt = np->handler;

  mp = net_Alloc(sts, &put, sizeof(*mp) + (cidcnt - 1) * sizeof(pwr_tCid),
      net_eMsg_classList);
  if (mp == NULL)
    return;

  memcpy(mp->cid, cid, cidcnt * sizeof(pwr_tCid));
  mp->cidcnt = cidcnt;
  mp->attrobjects = attrobjects;

  rsp = net_Request(sts, &tgt, &put, &get, net_eMsg_classListR, 0, 0);

  if (EVEN(*sts))
    return;
  if (EVEN(rsp->sts)) {
    *sts = rsp->sts;
    net_Free(NULL, rsp);
    return;
  }

  *listcnt = rsp->listcnt;
  *classlist = calloc(rsp->listcnt, sizeof(pwr_tAttrRef));
  memcpy(*classlist, rsp->classlist, rsp->listcnt * sizeof(pwr_tAttrRef));

  net_Free(NULL, rsp);
}
