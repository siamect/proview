/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_mh_blockdb.c -- Runtime environment - MH Block database */

#include <stdio.h>
#include <stdlib.h>

#include <errno.h>
#include <string.h>

#include "co_time.h"
#include "rt_mh_msg.h"
#include "rt_errh.h"
#include "rt_mh_blockdb.h"

/* Local macros */

#define mh_cBlockFileVersion 1
#define mh_cPageAlign 511L
#define mh_cPageSize 512L

mh_sBlockDb* mh_BlockDbOpen(char* FileName, pwr_tUInt32* size)
{
  register mh_sBlockDb* dp;
  register mh_sBlockDbHead* hp;
  char page[mh_cPageSize];
  char msg[512];

  dp = (mh_sBlockDb*)calloc(1, sizeof(mh_sBlockDb));
  if (dp == NULL)
    return (dp);
  hp = &dp->Head;

  /* try to open old blocking file */
  dp->File = fopen(FileName, "r+");

  if (dp->File != NULL) {
    sprintf(msg, "BlockDbOpen: old file: %s", FileName);
    errh_Info(msg);
    if (fread(hp, sizeof(*hp), 1, dp->File) != 1) {
      sprintf(msg, "BlockDbOpen: read header, %s", strerror(errno));
      errh_Info(msg);
    } else {
      time_GetTime(&hp->OpenTime);
      if (size != NULL)
        *size = hp->SegSize;
      if (hp->Version == mh_cBlockFileVersion)
        return (dp);
      errh_Info("BlockDbOpen: file version mismatch");
    }
    fclose(dp->File);
  }

  /* try to create new blocking file */
  dp->File = fopen(FileName, "w+");

  if (dp->File == NULL) {
    sprintf(msg, "BlockDbOpen: %s", strerror(errno));
    errh_Info(msg);
  } else {
    sprintf(msg, "BlockDbOpen: new file, %s", FileName);
    errh_Info(msg);

    memset(hp, 0, sizeof(*hp));
    time_GetTime(&hp->CreationTime);
    time_GetTime(&hp->OpenTime);
    hp->Version = mh_cBlockFileVersion;

    /* Write a file header */

    hp->SectPos = sizeof(page);
    if (fseek(dp->File, 0, SEEK_SET) == 0) {
      memset(page, 0, sizeof(page));
      memcpy(page, hp, sizeof(*hp));
      if (size != NULL)
        *size = hp->SegSize;
      if (fwrite(page, sizeof(page), 1, dp->File) == 1)
        return (dp);
    }

    sprintf(msg, "BlockDbOpen: write header, %s", strerror(errno));
    errh_Info(msg);
    fclose(dp->File);
  }
  free(dp);
  return (NULL);
}

mh_sBlockDb* mh_BlockDbClose(mh_sBlockDb* dp)
{
  if (dp != NULL) {
    if (dp->File != NULL)
      fclose(dp->File);
    free(dp);
  }
  return NULL;
}

mh_sBlockDb* mh_BlockDbGet(mh_sBlockDb* dp, pwr_tUInt32* size, char* buffer)
{
  register mh_sBlockDbHead* hp = &dp->Head;
  char msg[512];

  time_GetTime(&hp->GetTime);
  hp->GetCount++;

  if (fseek(dp->File, hp->SectPos, SEEK_SET) != 0)
    goto error;
  if (fread(buffer, hp->SegSize, 1, dp->File) != 1)
    goto error;

  *size = hp->SegSize;
  return (dp);

error:
  sprintf(msg, "BlockDbGet: %s", strerror(errno));
  errh_Info(msg);
  return mh_BlockDbClose(dp);
}

mh_sBlockDb* mh_BlockDbPut(mh_sBlockDb* dp, pwr_tUInt32 size, char* buffer)
{
  register mh_sBlockDbHead* hp = &dp->Head;
  char msg[512];
  char* errc;
  mh_sBlockDbHead Head = dp->Head;
  char page[mh_cPageSize];
  long FileSize;
  long DiffSize;

  memset(page, 0, sizeof(page));

  if (hp->FreeSize < size) {
    Head.SectPos = hp->SectPos + hp->SectSize;
    Head.FreeSize = Head.SectPos - sizeof(page);
  } else {
    Head.SectPos = sizeof(page);
    Head.FreeSize = 0;
  }

  Head.SegSize = size;
  Head.SectSize
      = (size + mh_cPageAlign) & ~mh_cPageAlign; /* align with page size */
  Head.SectSize = MAX(Head.SectSize, mh_cPageSize); /* Minimum one page */
  DiffSize = Head.SectSize - Head.SegSize;

  /* statistics */
  time_GetTime(&Head.PutTime);
  Head.PutCount++;
  if (Head.FreeSize > Head.MaxFreeSize)
    Head.MaxFreeSize = Head.FreeSize;
  if (Head.SegSize > Head.MaxSegSize)
    Head.MaxSegSize = Head.SegSize;
  if (Head.SectSize > Head.MaxSectSize)
    Head.MaxSectSize = Head.SectSize;
  FileSize = Head.FreeSize + Head.SectSize + sizeof(page);
  if (FileSize > Head.FileSize)
    Head.FileSize = FileSize;

  if (fseek(dp->File, Head.SectPos, SEEK_SET) != 0)
    goto error;
  if (size > 0)
    if (fwrite(buffer, size, 1, dp->File) != 1)
      goto error;
  if (DiffSize > 0) {
    if (fwrite(page, DiffSize, 1, dp->File) != 1)
      goto error;
  }
  if (fflush(dp->File) != 0)
    goto error;
  if (fseek(dp->File, 0, SEEK_SET) != 0)
    goto error;
  memcpy(page, &Head, sizeof(Head));
  if (fwrite(page, sizeof(page), 1, dp->File) != 1)
    goto error;
  if (fflush(dp->File) != 0)
    goto error;

  *hp = Head;
  return (dp);

error:
  errc = strerror(errno);
  sprintf(msg, "BlockDbPut: %s", errc);
  errh_Info(msg);
  return mh_BlockDbClose(dp);
}
