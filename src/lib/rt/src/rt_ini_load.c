/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <stdio.h>

#include <sys/wait.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "pwr_remoteclasses.h"
#include "pwr_nmpsclasses.h"
#include "pwr_basecomponentclasses.h"
#include "pwr_otherioclasses.h"
#include "pwr_opcclasses.h"

#include "co_dcli.h"
#include "co_string.h"
#include "co_syi.h"

#include "rt_io_base.h"
#include "rt_ini_load.h"
#include "rt_ini_event.h"
#include "rt_ini_alias.h"
#include "rt_ini_msg.h"

static pwr_tBoolean checkSect(pwr_tStatus*, ini_sContext*, int, int);
static gdb_sObject* oidToObject(pwr_tObjid);
static pwr_tBoolean loadSectObject(pwr_tStatus*, ini_sContext*, ivol_sVolume*);
static pwr_tBoolean loadSectRbody(pwr_tStatus*, ini_sContext*, ivol_sVolume*);
static pwr_tBoolean loadSectScObject(
    pwr_tStatus*, ini_sContext*, ivol_sVolume*);
static pwr_tBoolean loadSectVolume(pwr_tStatus*, ini_sContext*, ivol_sVolume*);
static pwr_tBoolean readSectFile(pwr_tStatus*, ini_sContext*, ivol_sVolume*);
static pwr_tBoolean readSectVolRef(pwr_tStatus*, ini_sContext*, ivol_sVolume*);
static pwr_tBoolean readSectVolume(pwr_tStatus*, ini_sContext*, ivol_sVolume*);
static gdb_sObject* reloadObject(
    pwr_tStatus*, ini_sContext*, ivol_sVolume*, dbs_sObject*);
static pwr_tBoolean reloadSectObject(
    pwr_tStatus*, ini_sContext*, ivol_sVolume*);
static pwr_tBoolean reloadSectRbody(pwr_tStatus*, ini_sContext*, ivol_sVolume*);
static pwr_tBoolean reloadSectVolume(
    pwr_tStatus*, ini_sContext*, ivol_sVolume*);
static char* strsav(char*);
static void create_active_io();
static void delete_old_io();
static void rename_active_io(ini_sContext*);

static char* strsav(char* s)
{
  int len;
  char* t = NULL;

  if (s == NULL)
    return NULL;

  len = strlen(s);
  if (len > 0) {
    t = malloc(len + 1);
    strcpy(t, s);
  }

  return t;
}

static pwr_tBoolean checkSect(
    pwr_tStatus* status, ini_sContext* cp, int sects, int version)
{
  pwr_dStatus(sts, status, INI__SUCCESS);

  if (cp->sect.version != version) {
    *sts = INI__SECTVERSION;
    errh_LogError(&cp->log, "Section header Versions differ: %d != %d",
        cp->sect.version, version);
    cp->errors++;
  } else if (((1 << cp->sect.type) & sects) != 0) {
    *sts = INI__MULTSECT;
    errh_LogError(
        &cp->log, "Section type allready read, %d", 1 << cp->sect.type);
    cp->errors++;
  }

  return ODD(*sts);
}

static gdb_sObject* reloadObject(
    pwr_tStatus* status, ini_sContext* cp, ivol_sVolume* vp, dbs_sObject* oh)
{
  gdb_sObject* op;
  ivol_sObject* iop;
  gdb_mChange flags;

  pwr_dStatus(sts, status, INI__SUCCESS);

  flags.m = gdb_mChange__;

  gdb_ScopeLock
  {
    op = oidToObject(oh->oid);
    if (op != NULL) {
      op->u.n.flags.b.swapDelete = 0;

      if (op->g.oid.oix != 0) {
        flags.b.father = op->g.f.poid.oix != oh->poid.oix;
        flags.b.name = !streq(op->g.f.name.orig, oh->name);
        flags.b.server = op->g.flags.m & net_mGo_isClient
            && cdh_ObjidIsNotEqual(op->g.soid, oh->soid);
        flags.b.classid = op->g.cid != oh->cid;
        flags.b.size
            = !op->g.flags.b.isAliasClient && op->g.size != oh->rbody.size;
        flags.b.flags = op->u.n.lflags.m != oh->flags.m;
        // flags.b.body   = time_Acomp(&op->u.n.time, &oh->rbody.time) != 0;
        flags.b.body = time_Acomp(&op->u.n.time, &oh->time) != 0;
      }
    } else {
      flags.b.created = 1;
      op = ivol_LoadObject(sts, vp, oh, vol_mLink_swapLoad);
      flags.b.body = op->g.size > 0;
    }
  }
  gdb_ScopeUnlock;

  if (!flags.m)
    return op;

  iop = tree_Insert(sts, vp->oid_t, &oh->oid.oix);
  if (iop == NULL)
    return NULL;

  iop->flags.m = flags.m;
  iop->oh = *oh;
  iop->op = op;
  iop->cp = hash_Search(sts, gdbroot->cid_ht, &op->g.cid);
  if (iop->cp == NULL)
    errh_Bugcheck(2, "class definition missing");

  if (flags.b.created) {
    lst_InsertPred(NULL, &vp->cre_lh, &iop->obj_ll, iop);
  } else {
    if (oh->flags.b.io)
      lst_InsertPred(NULL, &vp->upd_io_lh, &iop->obj_ll, iop);
    else
      lst_InsertPred(NULL, &vp->upd_lh, &iop->obj_ll, iop);

    iop->unlink.b.goAdopt = iop->flags.b.father;
    iop->unlink.b.loFamilyTab = iop->flags.b.father | iop->flags.b.name;
    iop->unlink.b.loParentRef = iop->flags.b.father;
    iop->unlink.b.noSibList = iop->flags.b.father;
    iop->unlink.b.noCidList = iop->flags.b.classid;
    iop->link.m = iop->unlink.m;
    if (iop->upd_body != NULL) {
      printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!error");
    }
    if (flags.b.body && op->g.size > 0) {
      iop->upd_body = calloc(1, op->g.size);
    }
  }

  return op;
}

static gdb_sObject* oidToObject(pwr_tObjid oid)
{
  gdb_sObject* op;

  gdb_AssumeLocked;

  op = hash_Search(NULL, gdbroot->oid_ht, &oid);

  return op;
}

static pwr_tBoolean readSectFile(
    pwr_tStatus* status, ini_sContext* cp, ivol_sVolume* vp)
{
  char timbuf[32];

  pwr_dStatus(sts, status, INI__SUCCESS);

  if (cp->dbs.file.version != dbs_cVersionFile) {
    *sts = INI__SECTVERSION;
    errh_LogError(&cp->log, "dbs_cVersionFile differ: %d != %d",
        cp->dbs.file.version, dbs_cVersionFile);
    cp->errors++;
  }

  time_AtoAscii(
      &cp->dbs.file.time, time_eFormat_DateAndTime, timbuf, sizeof(timbuf));

  errh_LogInfo(&cp->log, "Created %s", timbuf);
  if (!cp->node.rtVersion.tv_sec)
    cp->node.rtVersion = cp->dbs.file.time;

  if (vp->time.tv_sec != 0) {
    // Time inserted from volref
    if (time_Acomp(&vp->time, &cp->dbs.file.time) != 0) {
      char timbuf1[32];
      char timbuf2[32];

      time_AtoAscii(
          &vp->time, time_eFormat_DateAndTime, timbuf1, sizeof(timbuf1));
      time_AtoAscii(&cp->dbs.file.time, time_eFormat_DateAndTime, timbuf2,
          sizeof(timbuf2));

      errh_LogWarning(&cp->log, "Version mismatch for volume: %s, %s != %s",
          vp->name, timbuf1, timbuf2);
      cp->warnings++;
    }
  }
  vp->time = cp->dbs.file.time;

  return ODD(*sts);
}

static pwr_tBoolean readSectVolRef(
    pwr_tStatus* status, ini_sContext* cp, ivol_sVolume* dvp)
{
  dbs_sVolRef volRef;
  ivol_sVolume* vp;
  int i;
  PDR pdrs;

  pwr_dStatus(sts, status, INI__SUCCESS);

  if (fseek(cp->dbs.f, cp->sect.offset, SEEK_SET) != 0)
    pwr_Return(NO, sts, errno_GetStatus());

  /* Read the section */

  for (i = 0; i < cp->sect.size; i += dbs_dAlign(sizeof(volRef))) {
    if (!dbs_AlignedRead(sts, &volRef, sizeof(volRef), &cp->dbs))
      return NO;

    if (cp->dbs.file.format.m != cp->format.m) {
      pdrmem_create(&pdrs, &volRef, sizeof(volRef), PDR_DECODE,
          cp->dbs.file.format, cp->format);

      if (!pdr_dbs_sVolRef(&pdrs, &volRef))
        pwr_Return(NO, sts, INI__XDR);
    }

    /* Try to find the volume in the volume list.  */

    vp = tree_Find(sts, cp->vid_t, &volRef.vid);
    if (vp == NULL) {
      /* This volume is not in the volume list.  */

      vp = tree_Insert(sts, cp->vid_t, &volRef.vid);
      lst_InsertPred(NULL, &cp->vol_lh, &vp->ll, vp);
      vp->time = volRef.time;
      strcpy(vp->name, volRef.name);
      if (!cdh_isClassVolumeClass(volRef.cid))
        vp->isVolRef = 1;
      vp->volRef = volRef;
      vp->oid_t = tree_CreateTable(sts, sizeof(pwr_tObjectIx),
          offsetof(ivol_sObject, oix), sizeof(ivol_sObject), 10, tree_Comp_oix);
      lst_Init(NULL, &vp->upd_lh, NULL);
      lst_Init(NULL, &vp->upd_io_lh, NULL);
      lst_Init(NULL, &vp->cre_lh, NULL);
    } else if (vp->time.tv_sec != 0) {
      /* Do some checks.  */
      if (dvp->volume.cid == pwr_eClass_DetachedClassVolume) {
        /* Check dvVersion */
        if (vp->volume.dvVersion != volRef.time.tv_sec) {
          errh_LogWarning(&cp->log,
              "Version mismatch for volume %s: %s, %u (present), %d (detached)",
              dvp->name, vp->name, vp->volume.dvVersion, volRef.time.tv_sec);
          cp->warnings++;
        } else
          errh_LogInfo(&cp->log,
              "Detached volref for %s: %s, %u (present), %d (detached)",
              dvp->name, vp->name, vp->volume.dvVersion, volRef.time.tv_sec);
      } else {
        if (time_Acomp(&vp->time, &volRef.time) != 0) {
          char timbuf1[32];
          char timbuf2[32];

          time_AtoAscii(
              &vp->time, time_eFormat_DateAndTime, timbuf1, sizeof(timbuf1));
          time_AtoAscii(
              &volRef.time, time_eFormat_DateAndTime, timbuf2, sizeof(timbuf2));

          errh_LogWarning(&cp->log, "Version mismatch for volume: %s, %s != %s",
              vp->name, timbuf1, timbuf2);
          cp->warnings++;
        }
      }
    }
  }
  return ODD(*sts);
}

static pwr_tBoolean readSectVolume(
    pwr_tStatus* status, ini_sContext* cp, ivol_sVolume* vp)
{
  PDR pdrs;

  pwr_dStatus(sts, status, INI__SUCCESS);

  if (fseek(cp->dbs.f, cp->sect.offset, SEEK_SET) != 0)
    pwr_Return(NO, sts, errno_GetStatus());

  if (!dbs_AlignedRead(sts, &vp->volume, cp->sect.size, &cp->dbs))
    return NO;

  if (cp->dbs.file.format.m != cp->format.m) {
    pdrmem_create(&pdrs, &vp->volume, sizeof(vp->volume), PDR_DECODE,
        cp->dbs.file.format, cp->format);
    if (!pdr_dbs_sVolume(&pdrs, &vp->volume))
      pwr_Return(NO, sts, INI__XDR);
  }

  cp->node.cardinality += vp->volume.cardinality;
  cp->node.bodySize += vp->volume.rbodySize;

  return ODD(*sts);
}

static pwr_tBoolean loadSectRbody(
    pwr_tStatus* sts, ini_sContext* cp, ivol_sVolume* vp)
{
  pwr_tInt32 i;
  dbs_sBody ob;
  pwr_tAddress body;
  pwr_tUInt32 nextpos;
  ivol_sBody* bp = NULL;
  PDR pdrs;

  /* Read the objdata entries one by one */

  i = cp->sect.size; /* Remaining # of bytes in section */
  nextpos = cp->sect.offset;
  while (i > 0) {
    fseek(cp->dbs.f, nextpos, SEEK_SET);
    if (!dbs_AlignedRead(sts, &ob, sizeof(ob), &cp->dbs)) {
      errh_LogFatal(&cp->log, "loadSectRbody, fread, %m", *sts);
      return NO;
    }

    if (cp->dbs.file.format.m != cp->format.m) {
      pdrmem_create(
          &pdrs, &ob, sizeof(ob), PDR_DECODE, cp->dbs.file.format, cp->format);
      if (!pdr_dbs_sBody(&pdrs, &ob))
        pwr_Return(NO, sts, INI__XDR);
    }

    i -= dbs_dAlign(sizeof(ob)) + dbs_dAlign(ob.size);
    nextpos = ftell(cp->dbs.f) + dbs_dAlign(ob.size);

    bp = ivol_GetBody(sts, ob.oid, NULL);
    if (bp == NULL) {
      *sts = INI__SUCCESS;
      // errh_LogError(&cp->log, "Cannot find body of object %s\n%m",
      // cdh_ObjidToString(ob.oid,0), *sts);
    } else {
      if (dbs_dAlign(bp->size) < ob.size) {
        errh_LogError(&cp->log, "Data beyond size of body, Objid %s",
            cdh_ObjidToString(ob.oid, 0));
      } else if (bp->size > ob.size) {
        errh_LogError(&cp->log, "Data is smaller than size of body, Objid %s",
            cdh_ObjidToString(ob.oid, 0));
      } else {
        body = bp->body;
        if (fread(body, bp->size, 1, cp->dbs.f) == 0)
          pwr_Return(NO, sts, errno_GetStatus());
      }
    }
  }

  return INI__SUCCESS;
}

static pwr_tBoolean reloadSectRbody(
    pwr_tStatus* sts, ini_sContext* cp, ivol_sVolume* vp)
{
  pwr_tInt32 i;
  dbs_sBody ob;
  void* body;
  pwr_tUInt32 nextpos;
  PDR pdrs;
  ivol_sObject* iop;

  /* Read the objdata entries one by one */

  i = cp->sect.size; /* Remaining # of bytes in section */
  nextpos = cp->sect.offset;

  while (i > 0) {
    if (fseek(cp->dbs.f, nextpos, SEEK_SET) != 0) {
      *sts = errno_GetStatus();
      errh_LogFatal(&cp->log, "reloadSectRbody, fseek, %m", *sts);
      break;
    }
    if (!dbs_AlignedRead(sts, &ob, sizeof(ob), &cp->dbs)) {
      errh_LogFatal(&cp->log, "reloadSectRbody, fread, %m", *sts);
      break;
    }

    if (cp->dbs.file.format.m != cp->format.m) {
      pdrmem_create(
          &pdrs, &ob, sizeof(ob), PDR_DECODE, cp->dbs.file.format, cp->format);
      if (!pdr_dbs_sBody(&pdrs, &ob))
        pwr_Return(NO, sts, INI__XDR);
    }

    i -= dbs_dAlign(sizeof(ob)) + dbs_dAlign(ob.size);
    nextpos = ftell(cp->dbs.f) + dbs_dAlign(ob.size);

    iop = tree_Find(sts, vp->oid_t, &ob.oid.oix);
    if (iop == NULL)
      continue;

    if (iop->body == NULL) {
      iop->size = iop->op->g.size;
      iop->body = pool_Address(NULL, gdbroot->rtdb, iop->op->u.n.body);
    }

    if (iop->flags.b.created && iop->flags.b.body) {
      body = iop->body;
    } else if (iop->flags.b.body) {
      if (iop->upd_body == NULL) {
        printf("iop->upd_body == NULL\n");
      }
      body = iop->upd_body;
    } else {
      continue;
    }

    if (iop->body == NULL) {
      // errh_LogError(&cp->log, "Cannot find body of object %s\n%m",
      // cdh_ObjidToString(ob.oid,0), sts);
    } else {
      if (dbs_dAlign(iop->op->g.size) < ob.size) {
        errh_LogError(&cp->log, "Data beyond size of body, Objid %s",
            cdh_ObjidToString(ob.oid, 0));
      } else if (iop->op->g.size > ob.size) {
        errh_LogError(&cp->log, "Data is smaller than size of body, Objid %s",
            cdh_ObjidToString(ob.oid, 0));
      } else {
        if (fread(body, iop->op->g.size, 1, cp->dbs.f) == 0)
          pwr_Return(NO, sts, errno_GetStatus());
      }
    }
  }

  return ODD(*sts);
}

static pwr_tBoolean loadSectObject(
    pwr_tStatus* status, ini_sContext* cp, ivol_sVolume* vp)
{
  pwr_tUInt32 i;
  dbs_sObject oh;
  gdb_sObject* op;
  PDR pdrs;

  pwr_dStatus(sts, status, INI__SUCCESS);

  /* Read the section header by header */

  if (fseek(cp->dbs.f, cp->sect.offset, SEEK_SET) != 0)
    pwr_Return(NO, sts, errno_GetStatus());

  for (i = 0; i < cp->sect.size; i += dbs_dAlign(sizeof(oh))) {
    if (!dbs_AlignedRead(sts, &oh, sizeof(oh), &cp->dbs)) {
      errh_LogFatal(&cp->log, "loadSectObject, fread, %m", *sts);
      break;
    }

    if (cp->dbs.file.format.m != cp->format.m) {
      pdrmem_create(
          &pdrs, &oh, sizeof(oh), PDR_DECODE, cp->dbs.file.format, cp->format);
      if (!pdr_dbs_sObject(&pdrs, &oh))
        pwr_Return(NO, sts, INI__XDR);
    }
    if (cdh_ObjidIsNull(oh.oid))
      printf("Load file is corrupt: %s\n", vp->filename);

    if (oh.cid == pwr_eClass_Node && oh.oid.vid == cp->node.nid)
      cp->node.nod_oid = oh.oid; /* This is the node object.  */

    if (oh.flags.b.devOnly) {
      continue;
    }

    op = ivol_LoadObject(sts, vp, &oh, vol_mLink_load);
    if (op == NULL) {
      errh_LogError(&cp->log, "Loading object %s, %s, parent %s\n%m",
          cdh_ObjidToString(oh.oid, 0), oh.name, cdh_ObjidToString(oh.poid, 0),
          *sts);
      return NO;
    }
  }

  return YES;
}

static pwr_tBoolean reloadSectObject(
    pwr_tStatus* status, ini_sContext* cp, ivol_sVolume* vp)
{
  pwr_tUInt32 i;
  dbs_sObject oh;
  gdb_sObject* op;
  PDR pdrs;

  pwr_dStatus(sts, status, INI__SUCCESS);

  ivol_InitiateVolumeUpdate(sts, vp);

  /* Read the section header by header */

  if (fseek(cp->dbs.f, cp->sect.offset, SEEK_SET) != 0)
    pwr_Return(NO, sts, errno_GetStatus());

  for (i = 0; i < cp->sect.size; i += dbs_dAlign(sizeof(oh))) {
    if (!dbs_AlignedRead(sts, &oh, sizeof(oh), &cp->dbs)) {
      errh_LogFatal(&cp->log, "reloadSectObject, fread, %m", *sts);
      return NO;
    }

    if (cp->dbs.file.format.m != cp->format.m) {
      pdrmem_create(
          &pdrs, &oh, sizeof(oh), PDR_DECODE, cp->dbs.file.format, cp->format);
      if (!pdr_dbs_sObject(&pdrs, &oh))
        pwr_Return(NO, sts, INI__XDR);
    }

    if (oh.cid == pwr_eClass_Node && oh.oid.vid == cp->node.nid)
      cp->node.nod_oid = oh.oid; /* This is the node object.  */

    if (oh.flags.b.devOnly)
      continue;

    op = reloadObject(sts, cp, vp, &oh);
    if (op == NULL) {
      errh_LogError(&cp->log, "Loading object %s, %s, parent %s\n%m",
          cdh_ObjidToString(oh.oid, 0), oh.name, cdh_ObjidToString(oh.poid, 0),
          sts);
      return NO;
    }
  }

  return ODD(*sts);
}

static pwr_tBoolean loadSectScObject(
    pwr_tStatus* status, ini_sContext* cp, ivol_sVolume* vp)
{
  pwr_tUInt32 i;
  dbs_sScObject sc;
  gdb_sScObject* scp;
  PDR pdrs;

  pwr_dStatus(sts, status, INI__SUCCESS);

  /* Read the section header by header */

  if (fseek(cp->dbs.f, cp->sect.offset, SEEK_SET) != 0)
    pwr_Return(NO, sts, errno_GetStatus());

  for (i = 0; i < cp->sect.size; i += dbs_dAlign(sizeof(sc))) {
    if (!dbs_AlignedRead(sts, &sc, sizeof(sc), &cp->dbs)) {
      errh_LogFatal(&cp->log, "loadSectScObject, fread, %m", *sts);
      break;
    }

    if (cp->dbs.file.format.m != cp->format.m) {
      pdrmem_create(
          &pdrs, &sc, sizeof(sc), PDR_DECODE, cp->dbs.file.format, cp->format);
      if (!pdr_dbs_sScObject(&pdrs, &sc))
        pwr_Return(NO, sts, INI__XDR);
    }

    scp = ivol_LoadScObject(sts, vp, &sc, vol_mLinkSc_load);
    if (scp == NULL) {
      errh_LogError(&cp->log, "Loading object %s, parent %s\n%m",
          cdh_ObjidToString(sc.oid, 0), cdh_ObjidToString(sc.poid, 0), *sts);
      return NO;
    }
  }

  return YES;
}

static pwr_tBoolean loadSectVolume(
    pwr_tStatus* status, ini_sContext* cp, ivol_sVolume* vp)
{
  PDR pdrs;

  pwr_dStatus(sts, status, INI__SUCCESS);

  /* Read the section */

  if (fseek(cp->dbs.f, cp->sect.offset, SEEK_SET) != 0)
    pwr_Return(NO, sts, errno_GetStatus());

  if (!dbs_AlignedRead(sts, &vp->volume, cp->sect.size, &cp->dbs)) {
    errh_LogFatal(&cp->log, "loadSectVolume, fread, %m", *sts);
    return NO;
  }

  if (cp->dbs.file.format.m != cp->format.m) {
    pdrmem_create(&pdrs, &vp->volume, sizeof(vp->volume), PDR_DECODE,
        cp->dbs.file.format, cp->format);
    if (!pdr_dbs_sVolume(&pdrs, &vp->volume))
      pwr_Return(NO, sts, INI__XDR);
  }

  errh_LogInfo(&cp->log, "Loading volume %s (%s)...", vp->volume.name,
      vp->volume.className);

  vp->vp = ivol_LoadVolume(sts, &vp->volume, &cp->dbs.file.format);

  return ODD(*sts);
}

static pwr_tBoolean reloadSectVolume(
    pwr_tStatus* status, ini_sContext* cp, ivol_sVolume* vp)
{
  PDR pdrs;

  pwr_dStatus(sts, status, INI__SUCCESS);

  /* Read the section */

  if (fseek(cp->dbs.f, cp->sect.offset, SEEK_SET) != 0)
    pwr_Return(NO, sts, errno_GetStatus());

  if (!dbs_AlignedRead(sts, &vp->volume, cp->sect.size, &cp->dbs)) {
    errh_LogFatal(&cp->log, "reloadSectVolume, fread, %m", *sts);
    return NO;
  }

  if (cp->dbs.file.format.m != cp->format.m) {
    pdrmem_create(&pdrs, &vp->volume, sizeof(vp->volume), PDR_DECODE,
        cp->dbs.file.format, cp->format);
    if (!pdr_dbs_sVolume(&pdrs, &vp->volume))
      pwr_Return(NO, sts, INI__XDR);
  }

  errh_LogInfo(&cp->log, "Loading volume %s (%s)...", vp->volume.name,
      vp->volume.className);

  gdb_Lock;

  vp->vp = hash_Search(sts, gdbroot->vid_ht, &vp->vid);

  gdb_Unlock;

  return ODD(*sts);
}

ini_sContext* ini_CheckContext(pwr_tStatus* status, ini_sContext* cp)
{
  pwr_dStatus(sts, status, INI__SUCCESS);

  ini_LoadDirectory(sts, cp);

  cp->nodefile.errcount = NULL;
  cp->nodefile.logOpenFail = errh_LogInfo;

  if (!cp->flags.b.applfile)
    sprintf(cp->applfile.name, dbs_cNameAppl, cp->dir, cdh_Low(cp->origname),
        cp->busid);
  // str_ToLower(cp->applfile.name, cp->applfile.name);
  cp->applfile.errcount = NULL;
  cp->applfile.logOpenFail = errh_LogInfo;

  if (!cp->flags.b.bootfile)
    sprintf(cp->bootfile.name, dbs_cNameBoot, cp->dir, cdh_Low(cp->origname),
        cp->busid);
  // str_ToLower(cp->bootfile.name, cp->bootfile.name);
  cp->bootfile.errcount = &cp->fatals;
  cp->bootfile.logOpenFail = errh_LogFatal;

  if (!cp->flags.b.nodefile)
    sprintf(cp->nodefile.name, dbs_cNameNode, cp->dir, cdh_Low(cp->origname),
        cp->busid);
  // str_ToLower(cp->nodefile.name, cp->nodefile.name);
  cp->nodefile.errcount = &cp->fatals;
  cp->nodefile.logOpenFail = errh_LogFatal;

  // str_ToLower(cp->plcfile.name, cp->plcfile.name);
  // cp->plcfile.errcount = NULL;
  // cp->plcfile.logOpenFail = errh_LogInfo;

  return cp;
}

ini_sContext* ini_CreateContext(pwr_tStatus* status)
{
  ini_sContext* cp;

  pwr_dStatus(sts, status, INI__SUCCESS);

  cp = calloc(1, sizeof(*cp));
  if (cp == NULL)
    return NULL;

  cp->nid_t = tree_CreateTable(sts, sizeof(pwr_tNodeId),
      offsetof(qini_sNode, nid), sizeof(qini_sNode), 10, tree_Comp_nid);

  cp->vid_t = tree_CreateTable(sts, sizeof(pwr_tVolumeId),
      offsetof(ivol_sVolume, vid), sizeof(ivol_sVolume), 10, tree_Comp_vid);

  cp->proc_t = tree_CreateTable(sts, sizeof(((ini_sProc*)0)->id),
      offsetof(ini_sProc, id), sizeof(ini_sProc), 10, tree_Comp_strncmp);

  lst_Init(NULL, &cp->vol_lh, NULL);
  lst_Init(NULL, &cp->proc_lh, NULL);

  co_GetOwnFormat(&cp->format);

  if (cp->vid_t == NULL) {
    free(cp);
    return NULL;
  }

  return cp;
}

FILE* ini_OpenFile(pwr_tStatus* status, ini_sContext* cp, ini_sFile* fp)
{
  FILE* f;

  pwr_dStatus(sts, status, INI__SUCCESS);

  f = fopen(fp->name, "r");
  if (f == NULL) {
    if (fp->errcount)
      (*fp->errcount)++;
    if (fp->logOpenFail)
      fp->logOpenFail(&cp->log, "Could not open file %s", fp->name);
    return NULL;
  }

  if (cp->flags.b.verbose)
    errh_LogInfo(&cp->log, "Opened file %s", fp->name);

  return f;
}

char* ini_LoadDirectory(pwr_tStatus* status, ini_sContext* cp)
{
  pwr_dStatus(sts, status, INI__SUCCESS);

  if (!cp->flags.b.nodename)
    syi_NodeName(sts, cp->nodename, sizeof(cp->nodename));
  if (!cp->flags.b.hostname)
    syi_HostName(sts, cp->hostname, sizeof(cp->hostname));

  strcpy(cp->origname, cp->nodename);

  syi_NodeSpec(sts, cp->nodespec, sizeof(cp->nodespec));
  syi_HostSpec(sts, cp->hostspec, sizeof(cp->hostspec));
  syi_BootDisk(sts, cp->bootdisk, sizeof(cp->bootdisk));

  {
    char* s;

    if ((s = getenv(dbs_cNameBaseDirectory)) != NULL)
      sprintf(cp->bdir, "%s/", s);
    else
      errh_LogError(&cp->log, "Environment variable '%s' is not defined",
          dbs_cNameBaseDirectory);

    if ((s = getenv(dbs_cNameDirectory)) != NULL)
      sprintf(cp->dir, "%s/", s);
    else
      errh_LogError(&cp->log, "Environment variable '%s' is not defined",
          dbs_cNameDirectory);

    if (!cp->flags.b.busid) {
      s = getenv(pwr_dEnvBusId);
      if (s != NULL)

        cp->busid = atoi(s);
    }
  }
  if (!cp->flags.b.aliasfile)
    sprintf(cp->aliasfile.name, dbs_cNameAlias, cp->dir);

  *sts = ini_LoadAlias(cp->aliasfile.name);
  if (ODD(*sts))
    *sts = ini_GetAlias(cp->nodename, cp->alias, 0);
  if (ODD(*sts)) {
    errh_LogInfo(&cp->log, "Alias defined to %s for this node %s", cp->alias,
        cp->nodename);
    strcpy(cp->nodename, cp->alias);
  }

  return cp->dir;
}

void ini_SetSystemStatus(ini_sContext* cp, pwr_tStatus sts)
{
  if (!cp->np)
    return;

  if (ODD(sts) && ODD(cp->np->SystemStatus))
    cp->np->SystemStatus = sts;
  else if ((sts & 7) >= (cp->np->SystemStatus & 7))
    cp->np->SystemStatus = sts;
}

void ini_UpdateSystemInfo(ini_sContext* cp, int boot)
{
  if (boot) {
    cp->np->BootVersion = cp->node.rtVersion;
    cp->np->BootPlcVersion = cp->node.plcVersion;
    time_GetTime(&cp->np->BootTime);
  }
  cp->np->CurrentVersion = cp->node.rtVersion;
  cp->np->CurrentPlcVersion = cp->node.plcVersion;

  if (!boot) {
    cp->np->Restarts++;
    time_GetTime(&cp->np->RestartTime);
  }
}

void ini_ReadBootFile(pwr_tStatus* status, ini_sContext* cp)
{
  char day[80];
  char time[80];
  char buffer[1000];
  char* s;
  int i;
  int n;
  int nvol;

  char vname[80];
  char vids[80];
  pwr_tVolumeId vid;

  /*  pwr_tProjVersion	ver;*/
  FILE* f;
  ivol_sVolume* vp;

  pwr_dStatus(sts, status, INI__SUCCESS);

  f = ini_OpenFile(sts, cp, &cp->bootfile);

  if (f == NULL)
    return;

  errh_LogInfo(&cp->log, "Reading Boot file %s", cp->bootfile.name);

  for (i = 0, nvol = 0, s = fgets(buffer, sizeof(buffer) - 1, f); s != NULL;
       s = fgets(buffer, sizeof(buffer) - 1, f)) {
    if (*s == '!') {
      s++;
      continue;
    }

    switch (i) {
    case 0: /* Creation Date.  */
      i++;
      time[0] = day[0] = '\0';
      n = sscanf(s, "%s %s", day, time);
      break;
    case 1:
      i++;
      cp->proj[0] = '\0';
      n = sscanf(s, "%s", cp->proj);
      errh_LogInfo(
          &cp->log, "Created at %s %s for project: %s", day, time, cp->proj);
      break;
    case 2:
      i++;
      cp->group[0] = '\0';
      n = sscanf(s, "%s", cp->group);
      break;
    case 3: { /* Find PLC programs.  */
      char prog_array[50][80];
      int progs;
      int j;

      i++;

      if (!cp->flags.b.plcfile) {
        if (*s == '-') {
          /* No plc programs */
          cp->plcfile = 0;
          continue;
        }

        if (s[strlen(s) - 1] == '\n')
          s[strlen(s) - 1] = 0;

        progs = dcli_parse(s, ",", "", (char*)prog_array,
            sizeof(prog_array) / sizeof(prog_array[0]), sizeof(prog_array[0]),
            0);

        if (progs < 1) {
          errh_LogError(&cp->log, "Bootfile corrupt, error in plc data");
          cp->errors++;
          cp->plcfile = 0;
          continue;
        }

        cp->plcfile = (ini_sFile*)calloc(progs, sizeof(ini_sFile));

        cp->plcfile_cnt = progs;

        for (j = 0; j < progs; j++) {
          snprintf(cp->plcfile[j].name, sizeof(cp->plcfile[0].name), "%s",
              prog_array[j]);
          errh_LogInfo(
              &cp->log, "This node vill run PLC file: %s", cp->plcfile[j].name);
          cp->plcfile[j].logOpenFail = errh_LogInfo;
        }
      }

      break;
    }
    case 4: /* Find root volume.  */
      i++;
      n = sscanf(s, "%s %s", vname, vids);
      if (n < 2) {
        errh_LogError(&cp->log, "Found no root volume");
        cp->errors++;
        continue;
      } else {
        *sts = cdh_StringToVolumeId(vids, &vid);
        if (EVEN(*sts)) {
          errh_LogError(&cp->log, "Found no root volume");
          cp->errors++;
          continue;
        }
        errh_LogInfo(&cp->log, "This node has node identity %s (%d)",
            cdh_NodeIdToString(NULL, vid, 0, 0), vid);
        cp->node.nid = vid;
      }
      vp = tree_Insert(sts, cp->vid_t, &vid);
      strcpy(vp->name, vname);
      lst_InsertPred(NULL, &cp->vol_lh, &vp->ll, vp);
      vp->isVolRef = 0;
      vp->oid_t = tree_CreateTable(sts, sizeof(pwr_tObjectIx),
          offsetof(ivol_sObject, oix), sizeof(ivol_sObject), 10, tree_Comp_oix);
      lst_Init(NULL, &vp->upd_lh, NULL);
      lst_Init(NULL, &vp->upd_io_lh, NULL);
      lst_Init(NULL, &vp->cre_lh, NULL);
      cp->flags.b.rootvolume = 1;
      break;
    case 5: /* Find other volume.  */
      n = sscanf(s, "%s %s", vname, vids);
      if (n < 2) {
        errh_LogError(&cp->log, "Error in line, skip to next line\n%s", s);
        cp->errors++;
        continue;
      } else {
        *sts = cdh_StringToVolumeId(vids, &vid);
        if (EVEN(*sts)) {
          errh_LogError(
              &cp->log, "Error in line, skip to next line\n%s\n%m", s, *sts);
          cp->errors++;
          continue;
        }
      }
      /* Do we have this volume?  */
      vp = tree_Find(sts, cp->vid_t, &vid);
      if (vp != NULL) {
        errh_LogInfo(&cp->log, "Volume already defined: %s", s);
        vp->isVolRef = 0;
        /* todo !!! check versions */
      } else {
        vp = tree_Insert(sts, cp->vid_t, &vid);
        strcpy(vp->name, vname);
        lst_InsertPred(NULL, &cp->vol_lh, &vp->ll, vp);
        vp->oid_t = tree_CreateTable(sts, sizeof(pwr_tObjectIx),
            offsetof(ivol_sObject, oix), sizeof(ivol_sObject), 10,
            tree_Comp_oix);
        lst_Init(NULL, &vp->upd_lh, NULL);
        lst_Init(NULL, &vp->upd_io_lh, NULL);
        lst_Init(NULL, &vp->cre_lh, NULL);
      }
      break;
    }
  }

  fclose(f);

  /* Insert global shared volume rt */
  vid = cdh_cRtVolume;
  vp = tree_Insert(sts, cp->vid_t, &vid);
  strcpy(vp->name, "rt");
  lst_InsertPred(NULL, &cp->vol_lh, &vp->ll, vp);
  vp->oid_t = tree_CreateTable(sts, sizeof(pwr_tObjectIx),
      offsetof(ivol_sObject, oix), sizeof(ivol_sObject), 10, tree_Comp_oix);
  lst_Init(NULL, &vp->upd_lh, NULL);
  lst_Init(NULL, &vp->upd_io_lh, NULL);
  lst_Init(NULL, &vp->cre_lh, NULL);
}

pwr_tBoolean ini_IterVolumes(pwr_tStatus* sts, ini_sContext* cp,
    pwr_tBoolean (*func)(pwr_tStatus*, ini_sContext*, ivol_sVolume*))
{
  ivol_sVolume* vp;
  lst_sEntry* vl;

  for (vp = lst_Succ(NULL, &cp->vol_lh, &vl); vp != NULL;
       vp = lst_Succ(NULL, vl, &vl)) {
    sprintf(vp->filename, dbs_cNameVolume, cp->bdir, cdh_Low(vp->name));
    // str_ToLower(vp->filename, vp->filename);

    dbs_Open(sts, &cp->dbs, vp->filename);
    if (*sts == ERRNO__NOENT) { /* Give pwrp a chance */
      sprintf(vp->filename, dbs_cNameVolume, cp->dir, cdh_Low(vp->name));
      //  str_ToLower(vp->filename, vp->filename);
      dbs_Open(sts, &cp->dbs, vp->filename);
    }

    if (EVEN(*sts)) {
      errh_LogError(&cp->log, "Open file %s, %m", vp->filename, *sts);
      cp->errors++;
      continue;
    }

    errh_LogInfo(&cp->log, "Reading volume file %s", vp->filename);

    func(sts, cp, vp);

    dbs_Close(sts, &cp->dbs);

    if (EVEN(*sts)) {
      errh_LogError(&cp->log, "Error while reading volume file %s, %m",
          vp->filename, *sts);
      cp->errors++;
      break;
    }
  }
  return ODD(*sts);
}

/* read all load file headers to get sizes */
pwr_tBoolean ini_CheckVolumeFile(
    pwr_tStatus* status, ini_sContext* cp, ivol_sVolume* vp)
{
  int reqmask = 0;
  int sects = 0;
  unsigned int nextpos;
  PDR pdrs;

  pwr_dStatus(sts, status, INI__SUCCESS);

  nextpos = dbs_dAlign(sizeof(dbs_sFile));
  do {
    if (fseek(cp->dbs.f, nextpos, SEEK_SET) != 0) {
      *sts = errno_GetStatus();
      errh_LogFatal(&cp->log, "ini_CheckVolumeFile, fseek, %m", *sts);
      return NO;
    }
    if (!dbs_AlignedRead(sts, &cp->sect, sizeof(cp->sect), &cp->dbs)) {
      errh_LogFatal(&cp->log, "ini_CheckVolumeFile, fread, %m", *sts);
      return NO;
    }

    if (cp->dbs.file.format.m != cp->format.m) {
      pdrmem_create(&pdrs, &cp->sect, sizeof(cp->sect), PDR_DECODE,
          cp->dbs.file.format, cp->format);
      if (!pdr_dbs_sSect(&pdrs, &cp->sect)) {
        *sts = INI__XDR;
        errh_LogFatal(&cp->log, "ini_CheckVolumeFile, pdr, %m", *sts);
        return NO;
      }
    }

    nextpos = ftell(cp->dbs.f);

    switch (cp->sect.type) {
    case dbs_eSect_dir:
      if (checkSect(sts, cp, sects, dbs_cVersionDirectory))
        readSectFile(sts, cp, vp);
      break;
    case dbs_eSect_volume:
      if (checkSect(sts, cp, sects, dbs_cVersionVolume))
        readSectVolume(sts, cp, vp);
      break;
    case dbs_eSect_volref:
      if (checkSect(sts, cp, sects, dbs_cVersionVolRef))
        readSectVolRef(sts, cp, vp);
      break;
    case dbs_eSect_oid:
      checkSect(sts, cp, sects, dbs_cVersionOid);
      break;
    case dbs_eSect_object:
      checkSect(sts, cp, sects, dbs_cVersionObject);
      break;
    case dbs_eSect_rbody:
      checkSect(sts, cp, sects, dbs_cVersionRbody);
      break;
    default:
      *sts = INI__BADSECT; /* Successful return status; means that */
      break; /* we can continue after unknown sections */
    }
    if (EVEN(*sts))
      break; /* Panic exit */

    sects |= 1 << cp->sect.type;

  } while (cp->sect.type != dbs_eSect_rbody);

  reqmask = (1 << dbs_eSect_dir) | (1 << dbs_eSect_volume)
      | (1 << dbs_eSect_volref) | (1 << dbs_eSect_oid) | (1 << dbs_eSect_object)
      | (1 << dbs_eSect_rbody);
  if ((sects & reqmask) != reqmask) {
    *sts = INI__SECTORDER;
    errh_LogError(&cp->log, "Section order");
    cp->errors++;
  }

  return ODD(*sts);
}

pwr_tBoolean ini_LoadVolume(
    pwr_tStatus* status, ini_sContext* cp, ivol_sVolume* vp)
{
  pwr_tUInt32 reqmask = 0;
  pwr_tUInt32 sects = 0;
  pwr_tUInt32 nextpos;
  PDR pdrs;

  pwr_dStatus(sts, status, INI__SUCCESS);

  nextpos = dbs_dAlign(sizeof(dbs_sFile));
  do {
    if (fseek(cp->dbs.f, nextpos, SEEK_SET) != 0) {
      *sts = errno_GetStatus();
      errh_LogFatal(&cp->log, "ini_LoadVolumeFile, fseek, %m", *sts);
      return NO;
    }
    if (!dbs_AlignedRead(sts, &cp->sect, sizeof(cp->sect), &cp->dbs)) {
      errh_LogFatal(&cp->log, "ini_LoadVolumeFile, fread, %m", *sts);
      return NO;
    }

    if (cp->dbs.file.format.m != cp->format.m) {
      pdrmem_create(&pdrs, &cp->sect, sizeof(cp->sect), PDR_DECODE,
          cp->dbs.file.format, cp->format);
      if (!pdr_dbs_sSect(&pdrs, &cp->sect)) {
        *sts = INI__XDR;
        errh_LogFatal(&cp->log, "ini_LoadVolumeFile, pdr, %m", *sts);
        return NO;
      }
    }

    if (cp->sect.version != dbs_cVersionDirectory) {
      *sts = INI__HEADVERSION;
      break;
    }

    nextpos = ftell(cp->dbs.f);

    switch (cp->sect.type) {
    case dbs_eSect_dir:
      checkSect(sts, cp, sects, dbs_cVersionDirectory);
      break;
    case dbs_eSect_volume:
      if (checkSect(sts, cp, sects, dbs_cVersionVolume))
        loadSectVolume(sts, cp, vp);
      break;
    case dbs_eSect_volref:
      checkSect(sts, cp, sects, dbs_cVersionVolRef);
      break;
    case dbs_eSect_oid:
      checkSect(sts, cp, sects, dbs_cVersionOid);
      break;
    case dbs_eSect_object:
      if (checkSect(sts, cp, sects, dbs_cVersionObject))
        loadSectObject(sts, cp, vp);
      break;
    case dbs_eSect_rbody:
      if (checkSect(sts, cp, sects, dbs_cVersionRbody))
        loadSectRbody(sts, cp, vp);
      break;
    default:
    case dbs_eSect_scobject:
      if (checkSect(sts, cp, sects, dbs_cVersionScObject))
        loadSectScObject(sts, cp, vp);
      break;
      *sts = INI__BADSECT; /* Successful return status; means that */
      break; /* we can continue after unknown sections */
    }
    if (EVEN(*sts))
      break; /* Panic exit */

    sects |= 1 << cp->sect.type;

  } while (cp->sect.type != dbs_eSect_rbody);

  /** @todo add dbs_eSect_scobject to reqmask */
  reqmask = (1 << dbs_eSect_dir) | (1 << dbs_eSect_volume)
      | (1 << dbs_eSect_volref) | (1 << dbs_eSect_oid) | (1 << dbs_eSect_object)
      | (1 << dbs_eSect_rbody);

  if ((sects & reqmask) != reqmask) {
    *sts = INI__SECTORDER;
    errh_LogError(&cp->log, "Section order");
    cp->errors++;
  }

  return ODD(*sts);
}

pwr_tBoolean ini_ReloadVolume(
    pwr_tStatus* status, ini_sContext* cp, ivol_sVolume* vp)
{
  pwr_tUInt32 reqmask = 0;
  pwr_tUInt32 sects = 0;
  pwr_tUInt32 nextpos;
  PDR pdrs;

  pwr_dStatus(sts, status, INI__SUCCESS);

  nextpos = dbs_dAlign(sizeof(dbs_sFile));
  do {
    if (fseek(cp->dbs.f, nextpos, SEEK_SET) != 0) {
      *sts = errno_GetStatus();
      errh_LogFatal(&cp->log, "ini_ReloadVolumeFile, fseek, %m", *sts);
      return NO;
    }
    if (!dbs_AlignedRead(sts, &cp->sect, sizeof(cp->sect), &cp->dbs)) {
      errh_LogFatal(&cp->log, "ini_ReloadVolumeFile, fread, %m", *sts);
      return NO;
    }

    if (cp->dbs.file.format.m != cp->format.m) {
      pdrmem_create(&pdrs, &cp->sect, sizeof(cp->sect), PDR_DECODE,
          cp->dbs.file.format, cp->format);
      if (!pdr_dbs_sSect(&pdrs, &cp->sect)) {
        *sts = INI__XDR;
        errh_LogFatal(&cp->log, "ini_ReloadVolumeFile, pdr, %m", *sts);
        return NO;
      }
    }

    if (cp->sect.version != dbs_cVersionDirectory) {
      *sts = INI__HEADVERSION;
      break;
    }

    nextpos = ftell(cp->dbs.f);

    switch (cp->sect.type) {
    case dbs_eSect_dir:
      checkSect(sts, cp, sects, dbs_cVersionDirectory);
      break;
    case dbs_eSect_volume:
      if (checkSect(sts, cp, sects, dbs_cVersionVolume))
        reloadSectVolume(sts, cp, vp);
      break;
    case dbs_eSect_volref:
      checkSect(sts, cp, sects, dbs_cVersionVolRef);
      break;
    case dbs_eSect_oid:
      checkSect(sts, cp, sects, dbs_cVersionOid);
      break;
    case dbs_eSect_object:
      if (checkSect(sts, cp, sects, dbs_cVersionObject))
        reloadSectObject(sts, cp, vp);
      break;
    case dbs_eSect_rbody:
      if (checkSect(sts, cp, sects, dbs_cVersionRbody))
        reloadSectRbody(sts, cp, vp);
      break;
    default:
      *sts = INI__BADSECT; /* Successful return status; means that */
      break; /* we can continue after unknown sections */
    }
    if (EVEN(*sts))
      break; /* Panic exit */

    sects |= 1 << cp->sect.type;

  } while (cp->sect.type != dbs_eSect_rbody);

  reqmask = (1 << dbs_eSect_dir) | (1 << dbs_eSect_volume)
      | (1 << dbs_eSect_volref) | (1 << dbs_eSect_oid) | (1 << dbs_eSect_object)
      | (1 << dbs_eSect_rbody);

  if ((sects & reqmask) != reqmask) {
    *sts = INI__SECTORDER;
    errh_LogError(&cp->log, "Section order");
    cp->errors++;
  }

  return ODD(*sts);
}

pwr_tBoolean ini_CheckNode(pwr_tStatus* status, ini_sContext* cp)
{
  pwr_dStatus(sts, status, INI__SUCCESS);
  cp->node.rtVersion.tv_sec = 0;

  return ini_IterVolumes(sts, cp, ini_CheckVolumeFile);
}

pwr_tBoolean ini_LoadNode(pwr_tStatus* status, ini_sContext* cp)
{
  pwr_tBoolean result;
  pwr_dStatus(sts, status, INI__SUCCESS);

  gdb_ScopeLock
  {
    result = ini_IterVolumes(sts, cp, ini_LoadVolume);
  }
  gdb_ScopeUnlock;

  return result;
}

pwr_tBoolean ini_ReloadNode(pwr_tStatus* status, ini_sContext* cp)
{
  pwr_dStatus(sts, status, INI__SUCCESS);

  return ini_IterVolumes(sts, cp, ini_ReloadVolume);
}

pwr_tBoolean ini_UpdateBodies(
    pwr_tStatus* status, ini_sContext* cp, pwr_tBoolean io)
{
  ivol_sVolume* vp;
  lst_sEntry* vl;
  ivol_sObject* iop;
  lst_sEntry* iol;
  lst_sEntry* bl;

  pwr_dStatus(sts, status, INI__SUCCESS);

  for (vp = lst_Succ(NULL, &cp->vol_lh, &vl); vp != NULL;
       vp = lst_Succ(NULL, vl, &vl)) {
    if (io)
      bl = &vp->upd_io_lh;
    else
      bl = &vp->upd_lh;

    for (iop = lst_Succ(NULL, bl, &iol); iop != NULL;
         iop = lst_Succ(NULL, iol, &iol)) {
      if (iop->body == NULL || iop->upd_body == NULL)
        continue;
      ivol_CopyBody(sts, iop->upd_body, iop->body, iop->cp);
    }
  }

  return TRUE;
}

pwr_tBoolean ini_FreeBodies(
    pwr_tStatus* status, ini_sContext* cp, pwr_tBoolean io)
{
  ivol_sVolume* vp;
  lst_sEntry* vl;
  ivol_sObject* iop;
  lst_sEntry* iol;
  lst_sEntry* bl;

  pwr_dStatus(sts, status, INI__SUCCESS);

  for (vp = lst_Succ(NULL, &cp->vol_lh, &vl); vp != NULL;
       vp = lst_Succ(NULL, vl, &vl)) {
    if (io)
      bl = &vp->upd_io_lh;
    else
      bl = &vp->upd_lh;

    for (iop = lst_Succ(NULL, bl, &iol); iop != NULL;
         iop = lst_Succ(NULL, iol, &iol)) {
      if (iop->upd_body == NULL)
        continue;
      free(iop->upd_body);
      iop->upd_body = NULL;
    }
  }

  return YES;
}

pwr_tBoolean ini_DecodeBodies(
    pwr_tStatus* status, ini_sContext* cp, pwr_tBoolean io)
{
  ivol_sVolume* vp;
  lst_sEntry* vl;
  ivol_sObject* iop;
  lst_sEntry* iol;
  lst_sEntry* bl;

  pwr_dStatus(sts, status, INI__SUCCESS);

  for (vp = lst_Succ(NULL, &cp->vol_lh, &vl); vp != NULL;
       vp = lst_Succ(NULL, vl, &vl)) {
    if (io)
      bl = &vp->upd_io_lh;
    else
      bl = &vp->upd_lh;

    for (iop = lst_Succ(NULL, bl, &iol); iop != NULL;
         iop = lst_Succ(NULL, iol, &iol)) {
      if (iop->body == NULL || iop->upd_body == NULL)
        continue;
      if (!ivol_DecodeBody(sts, iop->upd_body, iop->cp))
        return FALSE;
    }
  }

  return TRUE;
}

pwr_tBoolean ini_UpdateDatabase(pwr_tStatus* status, ini_sContext* cp)
{
  ivol_sVolume* vp;
  lst_sEntry* vl;

  pwr_dStatus(sts, status, INI__SUCCESS);

  for (vp = lst_Succ(NULL, &cp->vol_lh, &vl); vp != NULL;
       vp = lst_Succ(NULL, vl, &vl)) {
  }

  return YES;
}

pwr_tBoolean ini_BuildNode(pwr_tStatus* status, ini_sContext* cp)
{
  ivol_sBody* node_bp = NULL;
  pwr_tStatus tsts;
  pwr_tObjid oid = pwr_cNObjid;
  pwr_sSystem System;
  int size = MIN(sizeof(System.SystemName) - 1, strlen(cp->proj));
  int gsize = MIN(sizeof(System.SystemGroup) - 1, strlen(cp->group));

  pwr_dStatus(sts, status, INI__SUCCESS);

  gdb_ScopeLock
  {
    ivol_BuildNode(sts, &cp->node, &cp->dbs.file.format);
    if (EVEN(*sts)) {
      errh_LogFatal(&cp->log, "Building runtime database, %m", *sts);
      break;
    }

    node_bp = ivol_GetBody(sts, cp->node.nod_oid, NULL);
    if (node_bp == NULL) {
      errh_LogFatal(&cp->log, "Can not find a node object!");
      break;
    }

    cp->np = (pwr_sNode*)node_bp->body;
    ini_UpdateSystemInfo(cp, 1);
  }
  gdb_ScopeUnlock;

  if (EVEN(*sts)) {
    if (cp->flags.b.ignoreFatal)
      return NO;
    exit(INI__ERROR);
  }

  /* Create a $System object and set SystemName to project name given in boot
   * file.  */

  tsts = gdh_CreateObject("pwrNode-System", pwr_eClass_System,
      sizeof(pwr_sSystem), &oid, pwr_cNObjid, 0, pwr_cNObjid);
  if (ODD(tsts)) {
    gdh_SetObjectInfo("pwrNode-System.SystemName", cp->proj, size);
    gdh_SetObjectInfo("pwrNode-System.SystemGroup", cp->group, gsize);
    gdh_SetObjectReadOnly(oid);
  }

  create_active_io();

  strncpy(cp->np->OrigName, cp->origname, sizeof(cp->np->OrigName));
  return ODD(*sts);
}

pwr_tBoolean ini_RebuildNode(pwr_tStatus* status, ini_sContext* cp)
{
  ivol_sVolume* vp;
  lst_sEntry* vl;
  ivol_sBody* node_bp = NULL;

  pwr_dStatus(sts, status, INI__SUCCESS);

  if (cp->flags.b.verbose)
    errh_LogInfo(&cp->log, "Rebuild database...");

  gdb_ScopeExcl
  {
    for (vp = lst_Succ(NULL, &cp->vol_lh, &vl); vp != NULL;
         vp = lst_Succ(NULL, vl, &vl)) {
      if (cp->flags.b.verbose)
        errh_LogInfo(&cp->log, "Rebuild volume: %s", vp->volume.name);
      ivol_RebuildVolume(sts, vp, &cp->dbs.file.format);
    }
  }
  gdb_ScopeUnexcl;

  if (cp->flags.b.verbose)
    errh_LogInfo(&cp->log, "Database rebuilt");

  if (cp->flags.b.verbose)
    errh_LogInfo(&cp->log, "Create io areas...");
  rename_active_io(cp);
  create_active_io();
  if (cp->flags.b.verbose)
    errh_LogInfo(&cp->log, "Io areas created");

  node_bp = ivol_GetBody(sts, cp->node.nod_oid, NULL);
  if (node_bp == NULL) {
    errh_LogFatal(&cp->log, "Can not find a node object!");
  }
  cp->np = (pwr_sNode*)node_bp->body;

  ini_UpdateSystemInfo(cp, 0);

  return YES;
}

pwr_tBoolean ini_CreateDb(pwr_tStatus* status, ini_sContext* cp)
{
  gdb_sLocal* lgdb = NULL;

  pwr_dStatus(sts, status, INI__SUCCESS);

  memset(&cp->gdbInit, 0, sizeof(cp->gdbInit));

  cp->gdbInit.nid = cp->node.nid;
  cp->gdbInit.objects = cp->node.cardinality;
  cp->gdbInit.rtdb_isize = cp->node.bodySize;

  cp->gdbInit.cvol_max = MAX(10000, cp->node.cvolMaxCount);
  cp->gdbInit.cvol_min = MAX(900, cp->node.cvolMinCount);

  lgdb = gdb_CreateDb(sts, &cp->gdbInit);

  return lgdb != NULL;
}

pwr_tBoolean ini_ReadNodeFile(pwr_tStatus* status, ini_sContext* cp)
{
  FILE* f;

  pwr_dStatus(sts, status, INI__SUCCESS);

  f = ini_OpenFile(sts, cp, &cp->nodefile);

  if (f == NULL)
    return NO;

  errh_LogInfo(&cp->log, "Reading Node file %s", cp->nodefile.name);

  qini_ParseFile(f, cp->nid_t, &cp->warnings, &cp->errors, &cp->fatals);
  fclose(f);

  return YES;
}

ini_sProc* ini_ProcInsert(pwr_tStatus* status, ini_sContext* cp, char* id,
    char* name, int load, int run, char* file, int prio, int debug,
    pwr_tCid confcid, char* arg, void* objectp)
{
  ini_sProc* pp;
  char buf[255];
  char* s;
  int ret;
  struct stat f_stat;
  pwr_tOid oid;

  pwr_dStatus(sts, status, INI__SUCCESS);

  pp = tree_Insert(sts, cp->proc_t, id);
  if (pp == NULL)
    return NULL;

  if (name != NULL && name[0] != '\0' && strcmp(name, "\"\"")) {
    if (pp->proc.name != NULL)
      free(pp->proc.name);
    sprintf(buf, name, cp->busid);
    pp->proc.name = strsav(buf);
  }
  if (load != -1)
    pp->proc.flags.b.load = load != 0;
  if (run != -1)
    pp->flags.b.run = run != 0;
  if (file != NULL && file[0] != '\0' && strcmp(file, "\"\"")) {
    if (pp->proc.file != NULL)
      free(pp->proc.file);
    pp->proc.file = strsav(file);
    s = getenv("pwr_exe");
    sprintf(buf, "%s/%s", s, file);
    ret = stat(buf, &f_stat);
    if (ret == -1) {
      s = getenv("pwrp_exe");
      sprintf(buf, "%s/%s", s, file);
      ret = stat(buf, &f_stat);
      if (ret == -1) {
        pp->flags.b.run = 0;
        pp->proc.flags.b.load = 0;
      }
    }
  }
  if (confcid && EVEN(gdh_GetClassList(confcid, &oid)))
    pp->flags.b.run = 0;
  if (arg != NULL && arg[0] != '\0' && strcmp(arg, "\"\"")) {
    if (pp->proc.arg != NULL)
      free(pp->proc.arg);
    pp->proc.arg = strsav(arg);
  }
  if (prio != -1)
    pp->proc.p_prio = prio;
  if (debug != -1)
    pp->proc.flags.b.debug = debug != 0;
  pp->objectp = objectp;
  if (!lst_IsLinked(NULL, &pp->proc_ll)) {
    lst_InsertPred(NULL, &cp->proc_lh, &pp->proc_ll, pp);
  }

  return pp;
}

void ini_ProcLoad(pwr_tStatus* status, ini_sContext* cp, ini_sProc* pp)
{
  pwr_dStatus(sts, status, INI__SUCCESS);

  return;
}

void ini_ProcStart(pwr_tStatus* status, ini_sContext* cp, ini_sProc* pp)
{
  pwr_dStatus(sts, status, INI__SUCCESS);

  if (pp->flags.b.running)
    return;

  if (pp->flags.b.run) {
    errh_LogInfo(&cp->log, "Starting %s, file: %s, prio: %d", pp->id,
        pp->proc.file, pp->proc.p_prio);
  } else {
    errh_LogInfo(&cp->log, "Not starting %s, file: %s", pp->id, pp->proc.file);
    return;
  }

  *sts = proc_Start(&pp->proc);
  if (EVEN(*sts))
    errh_LogError(&cp->log, "Error starting %s, %m", pp->id, *sts);
}

void ini_ProcPrio(pwr_tStatus* status, ini_sContext* cp, ini_sProc* pp)
{
  pwr_dStatus(sts, status, INI__SUCCESS);

  if (pp->flags.b.running)
    return;

  if (pp->flags.b.run) {
#if defined(OS_LINUX)
    if (!(pp->flags.b.plc)) {
      struct sched_param sp;
      sp.sched_priority = pp->proc.p_prio;
      if (sched_setscheduler(pp->proc.pid, SCHED_RR, &sp) == -1) {
        perror("sched_setscheduler");
        fprintf(stderr, "failed to set pid %d's policy\n", pp->proc.pid);
        return;
      }
    }
#endif
  }
}

void ini_ProcIter(pwr_tStatus* status, ini_sContext* cp, int mask, int pmask,
    void (*func)(pwr_tStatus*, ini_sContext*, ini_sProc*))
{
  lst_sEntry* pl;
  ini_sProc* pp;

  pwr_dStatus(sts, status, INI__SUCCESS);

  for (pp = lst_Succ(NULL, &cp->proc_lh, &pl); pp != NULL;
       pp = lst_Succ(NULL, pl, &pl)) {
    if (pp->proc.flags.m & mask) {
      if (!pmask || (pp->flags.m & pmask))
        func(sts, cp, pp);
    }
  }
}

void ini_ProcWait(pwr_tStatus* status, ini_sContext* cp)
{
  lst_sEntry* pl;
  ini_sProc* pp;
  pid_t pid;
  pid_t last_pid = 1;
  qcom_sGet get;
  int tmo = 1000;

  pwr_dStatus(sts, status, INI__SUCCESS);

  for (;;) {
    int status;

    get.data = NULL;
    qcom_Get(sts, &cp->eventQ, &get, tmo);
    if (*sts == QCOM__TMO || *sts == QCOM__QEMPTY) {
      errh_Info("Timeout");
    } else if (get.data == NULL) {
      errh_Info("Nulldata");
    } else {
      errh_Info("%d %s", get.size, get.data);
      qcom_Free(NULL, get.data);
    }
    if (lst_Succ(NULL, &cp->proc_lh, &pl) == NULL)
      break;
    pid = waitpid(-1, &status, WNOHANG | WUNTRACED);
    if (pid == 0)
      continue;
    if (pid == last_pid)
      break;

    for (pp = lst_Succ(NULL, &cp->proc_lh, &pl); pp != NULL;
         pp = lst_Succ(NULL, pl, &pl)) {
      if (pp->proc.pid == pid) {
        errh_Info("Process %s exited with status %d", pp->proc.name, status);
        break;
      }
    }
  }
  errh_Info("Ich sterbe!!");
}

static void create_active_io()
{
  pwr_tStatus sts;
  pwr_tObjid oid;
  pwr_tAttrRef aref;
  int ai_cnt, ao_cnt, av_cnt, di_cnt, do_cnt, dv_cnt, ii_cnt, io_cnt, iv_cnt;
  int atv_cnt, dtv_cnt, sv_cnt, co_cnt, bi_cnt, bo_cnt;
  int bi_size, bo_size;
  pwr_tCid subcid;
  pwr_tAttrRef actval_aref;

  // Count number of signals
  ai_cnt = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Ai, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Ai, &aref, &aref))
    ai_cnt++;

  ao_cnt = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Ao, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Ao, &aref, &aref))
    ao_cnt++;

  av_cnt = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Av, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Av, &aref, &aref))
    av_cnt++;

  di_cnt = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Di, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Di, &aref, &aref))
    di_cnt++;

  do_cnt = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Do, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Do, &aref, &aref))
    do_cnt++;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Po, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Po, &aref, &aref))
    do_cnt++;

  dv_cnt = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Dv, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Dv, &aref, &aref))
    dv_cnt++;

  ii_cnt = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Ii, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Ii, &aref, &aref))
    ii_cnt++;

  io_cnt = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Io, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Io, &aref, &aref))
    io_cnt++;

  iv_cnt = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Iv, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Iv, &aref, &aref))
    iv_cnt++;

  atv_cnt = 1;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_ATv, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_ATv, &aref, &aref))
    atv_cnt++;

  dtv_cnt = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_DTv, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_DTv, &aref, &aref))
    dtv_cnt++;

  sv_cnt = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Sv, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Sv, &aref, &aref))
    sv_cnt++;

  co_cnt = 0;
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_Co, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_Co, &aref, &aref))
    co_cnt++;

  bi_cnt = 0;
  bi_size = 0;
  for (sts = gdh_GetSubClassList(pwr_cClass_Bi, &subcid); ODD(sts);
       sts = gdh_GetNextSubClass(pwr_cClass_Bi, subcid, &subcid)) {
    pwr_tTypeId a_type;
    unsigned int a_size, a_offs, a_dim;

    for (sts = gdh_GetClassListAttrRef(subcid, &aref); ODD(sts);
         sts = gdh_GetNextAttrRef(subcid, &aref, &aref)) {
      sts = gdh_ArefANameToAref(&aref, "ActualValue", &actval_aref);
      if (EVEN(sts))
        continue;

      sts = gdh_GetAttributeCharAttrref(
          &actval_aref, &a_type, &a_size, &a_offs, &a_dim);
      if (EVEN(sts))
        continue;

      bi_cnt += a_dim;
      bi_size = pwr_AlignLW(bi_size);
      bi_size += a_size;
    }
  }

  bo_cnt = 0;
  bo_size = 0;
  for (sts = gdh_GetSubClassList(pwr_cClass_Bo, &subcid); ODD(sts);
       sts = gdh_GetNextSubClass(pwr_cClass_Bo, subcid, &subcid)) {
    pwr_tTypeId a_type;
    unsigned int a_size, a_offs, a_dim;

    for (sts = gdh_GetClassListAttrRef(subcid, &aref); ODD(sts);
         sts = gdh_GetNextAttrRef(subcid, &aref, &aref)) {
      sts = gdh_ArefANameToAref(&aref, "ActualValue", &actval_aref);
      if (EVEN(sts))
        continue;

      sts = gdh_GetAttributeCharAttrref(
          &actval_aref, &a_type, &a_size, &a_offs, &a_dim);
      if (EVEN(sts))
        continue;

      bo_cnt += a_dim;
      bo_size = pwr_AlignLW(bo_size);
      bo_size += a_size;
    }
  }
  sts = gdh_CreateObject("pwrNode-active", pwr_eClass_NodeHier, 0, &oid,
      pwr_cNObjid, 0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io", pwr_eClass_NodeHier, 0, &oid,
      pwr_cNObjid, 0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-ai", pwr_cClass_AiArea,
      ai_cnt * sizeof(((pwr_sClass_AiArea*)0)->Value[0]), &oid, pwr_cNObjid, 0,
      pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-ao", pwr_cClass_AoArea,
      ao_cnt * sizeof(((pwr_sClass_AoArea*)0)->Value[0]), &oid, pwr_cNObjid, 0,
      pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-av", pwr_cClass_AvArea,
      av_cnt * sizeof(((pwr_sClass_AvArea*)0)->Value[0]), &oid, pwr_cNObjid, 0,
      pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-ca", pwr_cClass_CaArea,
      co_cnt * sizeof(((pwr_sClass_CaArea*)0)->Value[0]), &oid, pwr_cNObjid, 0,
      pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-co", pwr_cClass_CoArea,
      co_cnt * sizeof(((pwr_sClass_CoArea*)0)->Value[0]), &oid, pwr_cNObjid, 0,
      pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-di", pwr_cClass_DiArea,
      di_cnt * sizeof(((pwr_sClass_DiArea*)0)->Value[0]), &oid, pwr_cNObjid, 0,
      pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-do", pwr_cClass_DoArea,
      do_cnt * sizeof(((pwr_sClass_DoArea*)0)->Value[0]), &oid, pwr_cNObjid, 0,
      pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-dv", pwr_cClass_DvArea,
      dv_cnt * sizeof(((pwr_sClass_DvArea*)0)->Value[0]), &oid, pwr_cNObjid, 0,
      pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-ii", pwr_cClass_IiArea,
      ii_cnt * sizeof(((pwr_sClass_IiArea*)0)->Value[0]), &oid, pwr_cNObjid, 0,
      pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-io", pwr_cClass_IoArea,
      io_cnt * sizeof(((pwr_sClass_IoArea*)0)->Value[0]), &oid, pwr_cNObjid, 0,
      pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-iv", pwr_cClass_IvArea,
      iv_cnt * sizeof(((pwr_sClass_IvArea*)0)->Value[0]), &oid, pwr_cNObjid, 0,
      pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-atv", pwr_cClass_ATvArea,
      atv_cnt * sizeof(((pwr_sClass_ATvArea*)0)->Value[0]), &oid, pwr_cNObjid,
      0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-dtv", pwr_cClass_DTvArea,
      dtv_cnt * sizeof(((pwr_sClass_DTvArea*)0)->Value[0]), &oid, pwr_cNObjid,
      0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-sv", pwr_cClass_SvArea,
      sv_cnt * sizeof(((pwr_sClass_SvArea*)0)->Value[0]), &oid, pwr_cNObjid, 0,
      pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-bi", pwr_cClass_BiArea, bi_size,
      &oid, pwr_cNObjid, 0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-bo", pwr_cClass_BoArea, bo_size,
      &oid, pwr_cNObjid, 0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-dv_init", pwr_cClass_InitArea,
      dv_cnt * sizeof(((pwr_sClass_InitArea*)0)->Value[0]), &oid, pwr_cNObjid,
      0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-av_init", pwr_cClass_InitArea,
      av_cnt * sizeof(((pwr_sClass_InitArea*)0)->Value[0]), &oid, pwr_cNObjid,
      0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-iv_init", pwr_cClass_InitArea,
      iv_cnt * sizeof(((pwr_sClass_InitArea*)0)->Value[0]), &oid, pwr_cNObjid,
      0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-ai_init", pwr_cClass_InitArea,
      ai_cnt * sizeof(((pwr_sClass_InitArea*)0)->Value[0]), &oid, pwr_cNObjid,
      0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-ao_init", pwr_cClass_InitArea,
      ao_cnt * sizeof(((pwr_sClass_InitArea*)0)->Value[0]), &oid, pwr_cNObjid,
      0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-di_init", pwr_cClass_InitArea,
      di_cnt * sizeof(((pwr_sClass_InitArea*)0)->Value[0]), &oid, pwr_cNObjid,
      0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-do_init", pwr_cClass_InitArea,
      do_cnt * sizeof(((pwr_sClass_InitArea*)0)->Value[0]), &oid, pwr_cNObjid,
      0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-ii_init", pwr_cClass_InitArea,
      ii_cnt * sizeof(((pwr_sClass_InitArea*)0)->Value[0]), &oid, pwr_cNObjid,
      0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-io_init", pwr_cClass_InitArea,
      io_cnt * sizeof(((pwr_sClass_InitArea*)0)->Value[0]), &oid, pwr_cNObjid,
      0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-atv_init", pwr_cClass_InitArea,
      atv_cnt * sizeof(((pwr_sClass_InitArea*)0)->Value[0]), &oid, pwr_cNObjid,
      0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-dtv_init", pwr_cClass_InitArea,
      dtv_cnt * sizeof(((pwr_sClass_InitArea*)0)->Value[0]), &oid, pwr_cNObjid,
      0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-sv_init", pwr_cClass_InitArea,
      sv_cnt * sizeof(((pwr_sClass_InitArea*)0)->Value[0]), &oid, pwr_cNObjid,
      0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-bi_init", pwr_cClass_InitArea,
      bi_cnt * sizeof(((pwr_sClass_InitArea*)0)->Value[0]), &oid, pwr_cNObjid,
      0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-bi_initsize", pwr_cClass_InitArea,
      bi_cnt * sizeof(((pwr_sClass_InitArea*)0)->Value[0]), &oid, pwr_cNObjid,
      0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-bo_init", pwr_cClass_InitArea,
      bo_cnt * sizeof(((pwr_sClass_InitArea*)0)->Value[0]), &oid, pwr_cNObjid,
      0, pwr_cNObjid);
  sts = gdh_CreateObject("pwrNode-active-io-bo_initsize", pwr_cClass_InitArea,
      bo_cnt * sizeof(((pwr_sClass_InitArea*)0)->Value[0]), &oid, pwr_cNObjid,
      0, pwr_cNObjid);
}

static void rename_active_io(ini_sContext* cp)
{
  pwr_tStatus sts;
  pwr_tObjid oid;

  sts = gdh_NameToObjid("pwrNode-old", &oid);
  if (ODD(sts))
    delete_old_io();

  sts = gdh_NameToObjid("pwrNode-active", &oid);
  if (EVEN(sts)) {
    errh_LogError(&cp->log, "gdh_NameToObjid(pwrNode-active, &oid), %m", sts);
    return;
  }
  sts = gdh_RenameObject(oid, "old");
  if (EVEN(sts)) {
    errh_LogError(&cp->log, "gdh_RenameObject(oid, pwrNode-old), %m", sts);
    return;
  }
}

static void delete_old_io()
{
  pwr_tStatus sts;
  pwr_tObjid oid;

  sts = gdh_NameToObjid("pwrNode-old-io-ai", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-ao", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-av", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-ca", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-co", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-di", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-do", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-dv", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-ii", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-io", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-iv", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-atv", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-dtv", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-sv", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-bi", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-bo", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-dv_init", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-av_init", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-iv_init", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-ai_init", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-ao_init", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-di_init", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-do_init", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-ii_init", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-io_init", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-atv_init", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-dtv_init", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-sv_init", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-bi_init", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-bi_initsize", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-bo_init", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io-bo_initsize", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old-io", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
  sts = gdh_NameToObjid("pwrNode-old", &oid);
  if (ODD(sts))
    gdh_DeleteObject(oid);
}
