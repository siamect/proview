/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_subcm.c -- Object data subscription, client monitor functions.

   This module contains routines to handle subscription.
   Those routines can NOT be called in a job context other than
   that of the nethandler.  */

#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#include "co_time.h"
#include "rt_gdh_msg.h"
#include "rt_ndc.h"
#include "rt_vol.h"
#include "rt_subc.h"
#include "rt_subcm.h"

/* Check if any client timeouts have occurred.
   The database should be locked on entry.  */

void subcm_CheckTimeout()
{
  pool_sQlink* cl;
  sub_sClient* cp;
  pwr_tTime curtim;
  pwr_tTime restim;
  pwr_tDeltaTime tmotim;
  pwr_tInt32 n;
  pwr_tInt32 i;

  gdb_AssumeLocked;

  gdbroot->db->tmocnt++; /* Statistics */

  time_GetTime(&curtim);

  /* Calculate # of remote object clients to process this time */

  n = gdbroot->db->subt_lc;
  if (n == 0)
    n = MIN(1, gdbroot->db->subt_lc);

  for (i = 0; i < n; i++) {
    /* Temporarily remove the first entry from the queue for processing.  */

    cl = pool_QremoveSucc(NULL, gdbroot->pool, &gdbroot->db->subt_lh);
    cp = pool_Qitem(cl, sub_sClient, subt_ll);

    /* Find out if the client has timed out */

    if (!cp->old) {
      /* cp->tmo in 10ths of seconds */
      tmotim.tv_sec = cp->tmo / 10;
      tmotim.tv_nsec = (cp->tmo - tmotim.tv_sec * 10) * 100000000;
      time_Aadd(&restim, &cp->lastupdate, &tmotim);

      /* curtim >= tmotim + lastupdate */
      if (time_Acomp(&curtim, &restim) >= 0)
        subc_SetOld(cp);
    } /* If it was old already */

    /* Reinsert the entry last in the queue.  */

    pool_QinsertPred(NULL, gdbroot->pool, cl, &gdbroot->db->subt_lh);
  }
}

/* Handles the reception of a subdata message.
   Database must NOT be locked.  */

void subcm_Data(qcom_sGet* get)
{
  pwr_tStatus sts;
  pwr_tTime curtim;
  pool_tRef mr;
  sub_sMessage* mp;
  pwr_tUInt32 refcount = 0;
  pwr_tInt32 i;
  sub_sClient* cp;
  pool_tRef dr;
  net_sSubData* dp;
  void* adrs;
  gdb_sNode* np = NULL;
  net_sSubRemove* rp = NULL;
  qcom_sQid tgt;
  gdb_sCclass* ccp = NULL;
  ndc_sRemoteToNative* tbl = NULL;
  int rsize;

  time_GetTime(&curtim);

  gdb_AssumeUnlocked;

  tgt.qix = net_cProcHandler;

  gdb_ScopeLock
  {
    /* Allocate space for, and store the message in the pool.  */

    mp = pool_Alloc(
        &sts, gdbroot->pool, sizeof(*mp) - sizeof(mp->msg) + get->size);
    if (mp == NULL)
      break;
    mr = pool_ItemReference(NULL, gdbroot->pool, mp);

    memcpy(&mp->msg, get->data, get->size);
    pool_Qinit(NULL, gdbroot->pool, &mp->subm_ll);
    pool_QinsertPred(NULL, gdbroot->pool, &mp->subm_ll, &gdbroot->db->subm_lh);
    gdbroot->db->subm_lc++;
    np = hash_Search(&sts, gdbroot->nid_ht, &mp->msg.hdr.nid);

    /* Check if message is corrupt */
    dp = (net_sSubData*)&mp->msg.subdata;
    for (i = 0; i < mp->msg.count; i++) {
      if ((char*)dp > (char*)&mp->msg + get->size
          || (char*)dp < (char*)&mp->msg) {
        errh_Error("Subscription client message corrupt");
        gdb_Unlock;
        return;
      }
      dp = (net_sSubData*)((unsigned long)&dp->data + dp->size);
    }

    /* Walk through every entry in the message buffer.  */
    for (i = 0, dp = (net_sSubData*)&mp->msg.subdata,
        dr = mr + offsetof(sub_sMessage, msg.subdata);

         i < mp->msg.count;

         i++, dr += offsetof(net_sSubData, data) + (unsigned long)dp->size,
        dp = (net_sSubData*)((unsigned long)&dp->data + dp->size)) {
      cp = hash_Search(&sts, gdbroot->subc_ht, &dp->sid);
      if (cp == NULL) {
        if (rp == NULL) {
          rp = pool_Alloc(&sts, gdbroot->pool,
              sizeof(*rp) + ((mp->msg.count - 1) * sizeof(rp->sid[0])));
          if (rp == NULL)
            continue;
          tgt.nid = mp->msg.hdr.nid;
        }
        rp->sid[rp->count++] = dp->sid;
        continue;
      }

      /* If the client has an earlier reference to a message, then
         remove that reference.
         This can cause the old message to get disposed of.  */

      subc_RemoveFromMessage(cp);

      /* Now start filling in the client according to the new
         information we just received...  */

      memcpy(&cp->lastupdate, &curtim, sizeof(curtim));
      cp->sts = dp->sts;
      cp->count++;

      if (ODD(dp->sts)) {
        cp->old = FALSE; /* There is new, fresh, real data!  */
        cp->submsg = mr;
        cp->subdata = dr;
        refcount++;

        if (cp->cclass == pool_cNRef) {
          gdb_sClass* classp;
          cdh_uTypeId cid;

          cid.pwr = cp->aref.Body;
          cid.c.bix = 0; /* To get the class id.  */
          classp = hash_Search(&sts, gdbroot->cid_ht, &cid.pwr);
          rsize = dp->size;

          if (classp != NULL)
            ndc_ConvertData(&sts, np, classp, &cp->aref, dp->data, dp->data,
                (pwr_tUInt32*)&rsize, ndc_eOp_decode, cp->aref.Offset, 0);
        } else {
          cp->old = TRUE;
          ccp = pool_Address(&cp->sts, gdbroot->pool, cp->cclass);
          if (ccp != NULL) {
            tbl = pool_Address(&cp->sts, gdbroot->pool, ccp->rnConv);
            if (tbl != NULL) {
              rsize = dp->size;
              ndc_ConvertRemoteData(&cp->sts, np, ccp, &cp->raref, dp->data,
                  dp->data, (pwr_tUInt32*)&rsize, ndc_eOp_decode,
                  cp->raref.Offset, 0);
              if (ODD(cp->sts))
                cp->old = FALSE;
            }
          }
        }

        /* !!! Todo !!! Error handling. */

        /* If the userdata field contains a valid pool_tRef, then
           copy the data. This poolref is resolved in RTDB!  */

        if (cp->userdata != pool_cNRef) {
          adrs = pool_Address(NULL, gdbroot->rtdb, cp->userdata);
          if (adrs != NULL) {
            if (cp->cclass == pool_cNRef)
              memcpy(adrs, dp->data, MIN(dp->size, cp->usersize));
            else if (!cp->old) {
              pwr_tUInt32 size = cp->usersize;
              pwr_tBoolean first = 1;
              ndc_ConvertRemoteToNativeTable(&cp->sts, ccp, tbl, &cp->raref,
                  &cp->aref, adrs, dp->data, &size, cp->aref.Offset, 0, 0,
                  &first, np->nid);
              if (EVEN(cp->sts))
                cp->old = TRUE;
            }
          }
        }
      }
    }

    /* Fill in count as the # of references in the 'message' header. This
       is the # of references that have to be removed before the 'message'
       can be returned to pool. If there are no references to the 'message'
       just dispose it!  */

    if (refcount != 0) {
      mp->msg.count = refcount;
    } else {
      pool_Qremove(NULL, gdbroot->pool, &mp->subm_ll);
      gdbroot->db->subm_lc--;
      pool_Free(NULL, gdbroot->pool, mp);
    }
  }
  gdb_ScopeUnlock;

  if (rp != NULL) {
    tgt = np->handler;
    net_Put(NULL, &tgt, rp, net_eMsg_subRemove, 0,
        pwr_Offset(rp, sid[rp->count]), 0);
    pool_Free(NULL, gdbroot->pool, rp);
  }
}

/* Move all clients from the indicated node to the unknown node.  */

void subcm_FlushNode(pwr_tStatus* sts, gdb_sNode* np)
{
  subc_ActivateList(&np->subc_lh, pwr_cNObjid);
}
