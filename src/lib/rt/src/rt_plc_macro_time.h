/* 
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2018 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

/*		 Preprocessor routines for time operations	    */

#define GetDTv_init(tp) \
  tp->tim_copy_lock = 1;

#define GetATv_init(tp) \
  tp->tim_copy_lock = 1;

/*_*
  STOATV
  store absolute time value			
  @aref stoatv StoATv
*/
#define StoATv_exec(obj,in) \
  lck_LockTime; \
  obj->ActualValue = in; \
  lck_UnlockTime;

/*_*
  STODTV
  store delta time value			
  @aref stodtv StoDTv
*/
#define StoDTv_exec(obj,in) \
  lck_LockTime; \
  obj->ActualValue = in; \
  lck_UnlockTime;

/*_*
  CSTOATV								
  store conditionally into absolute time value		
  @aref cstoatv CStoATv
*/
#define CStoATv_exec(obj,in,cond) \
  if ( cond ) { \
    lck_LockTime; \
    obj->ActualValue = in; \
    lck_UnlockTime; \
  }

/*_*
  CSTODTV								
  store conditionally into delta time value		
  @aref cstodtv CStoDTv
*/
#define CStoDTv_exec(obj,in,cond) \
  if ( cond ) { \
    lck_LockTime; \
    obj->ActualValue = in; \
    lck_UnlockTime; \
  }

/*_*
  STOATP								
  Store into absolute time attribute			
  @aref stoatp StoATp
*/
#define StoATp_exec(ut,in) \
  lck_LockTime; \
  ut = in; \
  lck_UnlockTime;

/*_*
  STODTP								
  Store into delta time attribute			
  @aref stodtp StoDTp
*/
#define StoDTp_exec(ut,in) \
  lck_LockTime; \
  ut = in; \
  lck_UnlockTime;

/*_*
  CSTOATP
  Store conditionally into absolute time attribute	
  @aref cstoatp CStoATp
*/
#define CStoATp_exec(ut,in,cond) \
  if ( cond) { \
    lck_LockTime; \
    ut = in; \
    lck_UnlockTime; \
  }

/*_*
  CSTODTP
  Store conditionally into delta time attribute	
  @aref cstodtp CStoDTp
*/
#define CStoDTp_exec(ut,in,cond) \
  if ( cond) { \
    lck_LockTime; \
    ut = in; \
    lck_UnlockTime; \
  }

/*_*
  GetATp
  Get absolute time attribute
  @aref getatp GetATp
*/
#define GetATp_exec(object,in) \
  lck_LockTime;		       \
  object->ActVal = in; \
  lck_UnlockTime;

/*_*
  GetDTp
  Get delta time attribute
  @aref getatp GetDTp
*/
#define GetDTp_exec(object,in) \
  lck_LockTime;		       \
  object->ActVal = in; \
  lck_UnlockTime;

/*_*
  ATADD
  @aref atadd AtAdd
*/
#define AtAdd_exec(obj,t1,t2) \
  time_Aadd_NE( &obj->ActVal, &t1, &t2);

/*_*
  DTADD
  @aref dtadd DtAdd
*/
#define DtAdd_exec(obj,t1,t2) \
  time_Dadd_NE( &obj->ActVal, &t1, &t2);

/*_*
  ATSUB
  @aref atsub AtSub
*/
#define AtSub_exec(obj,t1,t2) \
  time_Adiff_NE( &obj->ActVal, &t1, &t2);

/*_*
  ATDTSUB
  @aref atdtsub AtDtSub
*/
#define AtDtSub_exec(obj,t1,t2) \
  time_Asub_NE( &obj->ActVal, &t1, &t2);

/*_*
  DTSUB
  @aref dtsub DtSub
*/
#define DtSub_exec(obj,t1,t2) \
  time_Dsub_NE( &obj->ActVal, &t1, &t2);

/*_*
  DTTOA
  @aref dttoa DtToA
*/
#define DtToA_exec(obj,t) \
  time_DToFloat( &obj->ActVal, &t);

/*_*
  ATODT
  @aref atodt AToDt
*/
#define AToDt_exec(obj, val) \
  time_FloatToD( &obj->DTime, val);

/*_*
  CURRENTTIME
  @aref currentime CurrentTime
*/
#define CurrentTime_init(tp) \
  tp->tim_copy_lock = 1;

#define CurrentTime_exec(obj) \
  obj->Time = *tp->pp->system_time;

/*_*
  ATGREATERTHAN
  @aref atgreaterthan AtGreaterThan
*/
#define AtGreaterThan_exec(obj,t1,t2) \
  obj->Status = (time_Acomp_NE( &t1, &t2) == 1);

/*_*
  ATLESSTHAN
  @aref atlessthan AtLessThan
*/
#define AtLessThan_exec(obj,t1,t2) \
  obj->Status = (time_Acomp_NE( &t1, &t2) == -1);

/*_*
  ATEQUAL
  @aref atequal AtEqual
*/
#define AtEqual_exec(obj,t1,t2) \
  obj->Status = (time_Acomp_NE( &t1, &t2) == 0);

/*_*
  DTGREATERTHAN
  @aref dtgreaterthan DtGreaterThan
*/
#define DtGreaterThan_exec(obj,t1,t2) \
  obj->Status = (time_Dcomp_NE( &t1, &t2) == 1);

/*_*
  DTLESSTHAN
  @aref dtlessthan DtLessThan
*/
#define DtLessThan_exec(obj,t1,t2) \
  obj->Status = (time_Dcomp_NE( &t1, &t2) == -1);

/*_*
  DTEQUAL
  @aref dtequalthan DtEqual
*/
#define DtEqual_exec(obj,t1,t2) \
  obj->Status = (time_Dcomp_NE( &t1, &t2) == 0);

/*_*
  LOCALTIME
  @aref localtime LocalTime
*/
#define LocalTime_exec(obj,t) \
{\
  struct tm tm; \
  time_t time = t.tv_sec; \
\
  localtime_r( &time, &tm); \
  obj->Second = tm.tm_sec; \
  obj->Minute = tm.tm_min; \
  obj->Hour = tm.tm_hour; \
  obj->MDay = tm.tm_mday; \
  obj->Month = tm.tm_mon; \
  obj->Year = tm.tm_year; \
  obj->WDay = tm.tm_wday; \
  obj->YDay = tm.tm_yday; \
}
