/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_rtt_os.c
   This module contains routines for os dependent functions in rtt. */

/*_Include files_________________________________________________________*/

#include <stdlib.h>
#include <sys/utsname.h>

#include "co_math.h"
#include "co_string.h"

#include "rt_rtt_global.h"
#include "rt_rtt_msg.h"

/*************************************************************************
*
* Name:		rtt_get_nodename()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Get nodename for the current system.
*
**************************************************************************/
int rtt_get_nodename(char* nodename, int size)
{
  struct utsname buf;

  if (uname(&buf) == -1)
    return 0;
  strncpy(nodename, buf.nodename, size);
  return 1;
}

/*************************************************************************
*
* Name:		rtt_fgetname()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Get filename for a filedescriptor.
*	This function is not implementet on all os, therefor a defaultname
*	should be supplied which is returned for this os.
*
**************************************************************************/
char* rtt_fgetname(FILE* fp, char* name, char* def_name)
{
  strcpy(name, def_name);
  return name;
}

/*************************************************************************
*
* Name:		rtt_set_prio()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Set process priority.
*
**************************************************************************/
int rtt_set_prio(int prio)
{
  /* TODO.... */
  return 1;
}

/*************************************************************************
*
* Name:		rtt_set_prio()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Set process priority to default value for rtt.
*
**************************************************************************/
int rtt_set_default_prio()
{
  /* TODO.... */
  return 1;
}

/*************************************************************************
*
* Name:		rtt_get_platform()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Get platform for the current system.
*
**************************************************************************/
int rtt_get_platform(char* platform)
{
  struct utsname buf;

  if (uname(&buf) == -1)
    return 0;
  if (strstr(buf.machine, "86") != 0)
    strcpy(platform, "X86_LNX");
  return 1;
}

/*************************************************************************
*
* Name:		rtt_get_hw()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Get hardware for the current system.
*
**************************************************************************/
int rtt_get_hw(char* hw)
{
#if defined(OS_LINUX)
  struct utsname buf;

  if (uname(&buf) == -1)
    return 0;
  if (strstr(buf.machine, "86_64") != 0)
    strcpy(hw, "x86_64");
  else if (strstr(buf.machine, "86") != 0)
    strcpy(hw, "x86");
  else if (strstr(buf.machine, "arm") != 0)
    strcpy(hw, "arm");
  return 1;
#elif defined OS_MACOS || defined OS_FREEBSD || OS_OPENBSD
  strcpy(hw, "x86_64");
  return 1;
#elif defined OS_CYGWIN
  struct utsname buf;

  if (uname(&buf) == -1)
    return 0;
  if (strstr(buf.machine, "86_64") != 0)
    strcpy(hw, "x86_64");
  else if (strstr(buf.machine, "86") != 0)
    strcpy(hw, "x86");
  return 1;
#endif
}

/*************************************************************************
*
* Name:		rtt_replace_env()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Replace env variables in UNIX filenames.
*	A string that starts with $ and ends with . or / will replaced
*	if then string is found by getenv. Only lower case variables
*	will be detected.
*
**************************************************************************/
int rtt_replace_env(char* str, char* newstr)
{
  char* s;
  char* t;
  char* u = NULL;
  int symbolmode;
  long int size;
  char* value;
  char symbol[80];
  char lower_symbol[80];
  char news[160];

  symbolmode = 0;
  s = str;
  t = news;

  while (*s != 0) {
    if (*s == '$') {
      symbolmode = 1;
      u = s + 1;
      *t = *s;
      t++;
    } else if (symbolmode && (*s == '/' || *s == '.')) {
      /* End of potential symbol */
      size = (long int)s - (long int)u;
      strncpy(symbol, u, size);
      symbol[size] = 0;
      str_ToLower(lower_symbol, symbol);
      if ((value = getenv(lower_symbol)) == NULL) {
        /* It was no symbol */
        *t = *s;
        t++;
      } else {
        /* Symbol found */
        t -= strlen(symbol) + 1;
        strcpy(t, value);
        t += strlen(value);
        *t = *s;
        t++;
      }
      symbolmode = 0;
    } else {
      *t = *s;
      t++;
    }
    s++;
  }

  if (symbolmode) {
    strcpy(t, u);
  } else
    *t = 0;

  strcpy(newstr, news);
  return 1;
}
