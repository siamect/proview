/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

/* rt_rtt_qiomod.c 
   This module contains routines for terminal read and write */

/*_Include files_________________________________________________________*/

#if defined(OS_VMS)
# include <stdio.h>
# include <chfdef.h>
# include <string.h>
# include <starlet.h>
# include <iodef.h>   
# include <descrip.h>
# include <latdef.h>   
# include <ssdef.h>
#elif defined OS_POSIX
# include <stdio.h>
# include <string.h>
# include <termios.h>
# include <sys/types.h>
# include <sys/file.h>
# include <unistd.h>
# include <fcntl.h>
#endif

#define RTT_QIO_RETRY 10


#include "pwr.h"
#include "pwr_class.h"
#include "pwr_baseclasses.h"
#include "rt_gdh.h"
#include "rt_rtt.h"
#include "rt_rtt_global.h"
#include "rt_rtt_msg.h"
#include "rt_rtt_functions.h"

/***********************  D E F I N E ' S *******************************/
#define ODD(a)	(((int)(a) & 1) != 0)
#define EVEN(a)	(((int)(a) & 1) == 0)
/***********************  T Y P E D E F ' S *****************************/
/***********************  G L O B A L   V A R I A B L E S ***************/
/***********************  L O C A L   V A R I A B L E S *****************/

/*__Local function prototypes_________________________________________*/

#if defined(OS_VMS)
static int qio_ltconnect( int *chn);
static int qio_ltdisconnect( int *chn);
#endif

/************************************************************************
*
* Name:	qio_assign(char *s, int *chn)
*
* Type:	int
*
* TYPE		PARAMETER	IOGF	DESCRIPTION
* char		*s		     I	    String
* int		*chn		 O	    Kanal
*
* Description:	Gör en assign av s till kanalnummer chn
*************************************************************************/
int qio_assign( char *s, int *chn)
#ifdef OS_VMS
{
	/* Deklarationer som behövs i VMS */
	static $DESCRIPTOR(device,"");
	static char *stin = "SYS$OUTPUT:";
	char   *devn;

	/* Om input ska vara stdin, sätt stdinput */
	if ( strcmp(s,"stdin") == 0) 
		devn = stin; 
	else
		devn = s;

	device.dsc$a_pointer = devn;
	device.dsc$w_length  = strlen(devn);

	return sys$assign(&device, chn,0,0);
}
#elif defined OS_POSIX
{
	int chan = -1;
  	int sts;

	if ( strcmp( s,"stdin") == 0)
	  chan = STDIN_FILENO; 
	else
	{
	  chan = open( s, O_RDWR | O_NOCTTY);
  	  if ( chan == -1)
	  {
            printf( "No such device\n");
            return 0;
          }
	}
        sts = qio_set_attr( &chan);
	*chn = chan;
	return 1;
}
#endif




/************************************************************************
*
* Name:	qio_set_attr(int *chn)
*
* Type:	int
*
* TYPE		PARAMETER	IOGF	DESCRIPTION
* char		*s		     I	    String
* int		*chn		 O	    Kanal
*
* Description:	Set rtt attributes to a tty
*************************************************************************/
int qio_set_attr( int *chn)
#if defined(OS_VMS)
{
	return RTT__SUCCESS;
}
#elif defined OS_POSIX
{
	int chan;
  	int sts;
  	struct termios t;

	chan = *chn; 

  	sts = tcgetattr( chan, &t);
	if ( sts != 0) return 0;

	t.c_cc[VMIN] = 0;
	t.c_cc[VTIME] = 10;
	t.c_lflag &= ~ICANON;
	t.c_lflag &= ~ECHO;
	/* t.c_iflag ...*/
 	sts = tcflush( chan, TCIFLUSH);
	sts = tcsetattr( chan, TCSAFLUSH, &t);  

	return 1;
}
#endif

/************************************************************************
*
* Name:	qio_reset(char *s, int *chn)
*
* Type:	int
*
* TYPE		PARAMETER	IOGF	DESCRIPTION
* char		*s		     I	    String
* int		*chn		 O	    Kanal
*
* Description:	Reset the channel before exit
*************************************************************************/
int qio_reset( int *chn)
#if defined(OS_VMS)
{
	return RTT__SUCCESS;
}
#elif defined OS_POSIX
{
	int chan;
  	int sts;
  	struct termios t;

	chan = *chn; 

  	sts = tcgetattr( chan, &t);
	if ( sts != 0) return 0;

	t.c_cc[VMIN] = 0;
	t.c_cc[VTIME] = 0;
	t.c_lflag |= ICANON;
	t.c_lflag |= ECHO;
	/* t.c_iflag ...*/
 	sts = tcflush( chan, TCIFLUSH);
	sts = tcsetattr( chan, TCSAFLUSH, &t);  

	return 1;
}
#endif

/************************************************************************
*
* Name:	qio_readw(int chn, char *buf, int len)
*
* Type:	int
*
* TYPE		PARAMETER	IOGF	DESCRIPTION
* int		chn         I       Kanal
* char		*buf         O      Läst buffer
* int		len         I       Antal tecken som får läsas
*
* Description:	Läser med qiow från chn till buf
*************************************************************************/
int qio_readw( int *chn, char *buf, int len)
#ifdef OS_VMS
{
	struct statusblk {
		short condval;
		short transcount;
		int   devstat;
		} stsblk;
	static unsigned int code;
	int	i;
	int 	sts;

	code  = IO$_READLBLK | IO$M_NOECHO | IO$M_NOFILTR;
	for ( i = 0; i < RTT_QIO_RETRY; i++)
	{
	  sts = sys$qiow( 1, *chn, code, &stsblk,0,0,buf,len,0,0,0,0);
	  if ( ODD(sts)) return sts;
	}
	rtt_exit_now(1, sts);
	return 1;
}
#elif defined OS_POSIX
{
	int n = 0;

	while( n == 0)
    	  n = read( *chn, buf, len);
	return 1;
}
#endif

/************************************************************************
*
* Name:	qio_read(int chn, int tmo, char *buf, int len)
*
* Type:	int
*
* TYPE		PARAMETER	IOGF	DESCRIPTION
* int		chn         I       Kanal
* int		tmo         I       Timout-tid
* char		*buf         O      Läst buffer
* int		len         I       Antal tecken som får läsas
*
* Description:	Läser med qio från chn till buf med timout-tid tmo (ms)
*************************************************************************/
int qio_read( int *chn, int tmo, char *buf, int len)
#ifdef OS_VMS
{
	struct statusblk {
		short condval;
		short transcount;
		int   devstat;
		} stsblk;
	static unsigned int code;
	static unsigned int sts;
	int	i;

	if ( tmo < 1000)
	  tmo = 1000;

	code  = IO$_READLBLK | IO$M_NOECHO | IO$M_NOFILTR | IO$M_TIMED;
	for ( i = 0; i < RTT_QIO_RETRY; i++)
	{
	  sts   = sys$qiow( 1, *chn, code, &stsblk,0,0,buf,len,tmo/1000,0,0,0);
          if ( stsblk.condval == SS$_TIMEOUT) return 0;
	  if (ODD(sts)) return 1;
	}
	rtt_exit_now(1, sts);
	return 1;

}
#elif defined OS_POSIX
{
	int n;

    	n = read( *chn, buf, len);
	if ( n == 0)
	  /* Timeout */
	  return 0;
	return 1;
}
#endif

/************************************************************************
*
* Name:	qio_ltconnect(int chn)
*
* Type:	int
*
* TYPE		PARAMETER	IOGF	DESCRIPTION
* int		chn         I       Kanal
*
* Description:	Väntar med qio på en LAT-service
*************************************************************************/
#ifdef OS_VMS
static int qio_ltconnect( int *chn)
{
struct statusblk {
	short condval;
	short transcount;
	int   devstat;
	} stsblk;
static unsigned int code;
static unsigned int sts;

	code = IO$_TTY_PORT | IO$M_LT_CONNECT; /* Vänta på LAT */
	sts   = sys$qiow( 0, *chn, code, &stsblk,0,0,0,0,0,0,0,0);
	return sts;
}
#endif

/************************************************************************
*
* Name:	qio_ltdisconnect(int chn)
*
* Type:	int
*
* TYPE		PARAMETER	IOGF	DESCRIPTION
* int		chn         I       Kanal
*
* Description:	Kopplar ned en LAT LAT-service
*************************************************************************/
#ifdef OS_VMS
static int qio_ltdisconnect( int *chn)
{
struct statusblk {
	short condval;
	short transcount;
	int   devstat;
	} stsblk;
static unsigned int code;
static unsigned int sts;

	code = IO$_TTY_PORT | IO$M_LT_DISCON; /* Koppla ned LAT */
	sts   = sys$qiow( 0, *chn, code, &stsblk,0,0,0,0,0,0,0,0);
	return sts;
}
#endif

/************************************************************************
*
* Name:	qio_writew(int chn, char *buf, int len)
*
* Type:	int
*
* TYPE		PARAMETER	IOGF	DESCRIPTION
* int		chn         I       Kanal
* char		*buf        I       Buffer
* int		len         I       Antal tecken som ska skrivas
*
* Description:	Skriver med qiow från buf till chn
*************************************************************************/
int qio_writew( int *chn, char *buf, int len)
#ifdef OS_VMS
{
	struct statusblk {
		short condval;
		short transcount;
		int   devstat;
		} stsblk;
    static unsigned int code;

	code  = IO$_WRITELBLK | IO$M_NOECHO | IO$M_NOFILTR;
	return sys$qiow( 0, *chn, code, &stsblk,0,0,buf,len,0,0,0,0);

}
#elif defined OS_POSIX
{
	if ( *chn == STDIN_FILENO)
	  write( STDOUT_FILENO, buf, len);
	else
	  write( *chn, buf, len);
	return 1;
}
#endif

/************************************************************************
*
* Name:	qio_write(int chn, int tmo, char *buf, int len)
*
* Type:	int
*
* TYPE		PARAMETER	IOGF	DESCRIPTION
* int		chn         I       Kanal
* int		tmo         I       Timout-tid
* char		*buf         O      Läst buffer
* int		len         I       Antal tecken som får läsas
*
* Description:	Skriver med qio från buf till chn med timout-tid tmo (ms)
*************************************************************************/
int qio_write( int *chn, int tmo, char *buf, int len)
#ifdef OS_VMS
{
	struct statusblk {
		short condval;
		short transcount;
		int   devstat;
		} stsblk;
    static unsigned int code;
    static unsigned int sts;

	if ( tmo < 1000)
	  tmo = 1000;

	code  = IO$_WRITELBLK | IO$M_NOECHO | IO$M_NOFILTR | IO$M_TIMED;
	sts   = sys$qiow( 0, chn, code, &stsblk,0,0,buf,len,tmo/1000,0,0,0);
        return stsblk.condval == SS$_TIMEOUT ? 0 : 1;        

}
#elif defined OS_POSIX
{
	if ( *chn == STDIN_FILENO)
	  write( STDOUT_FILENO, buf, len);
	else
	  write( *chn, buf, len);
	return 1;
}
#endif
