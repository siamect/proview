/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include "co_time.h"
#include "co_dcli.h"
#include "rt_gdh_msg.h"
#include "rt_hash_msg.h"
#include "rt_pwr_msg.h"
#include "rt_vol.h"
#include "rt_cvolc.h"
#include "rt_gdh.h"
#include "rt_cbuf.h"
#include "pwr_baseclasses.h"

/* rt_cbuf.c
   This module handles circular buffer objects.  */

#if defined OS_LINUX || defined OS_MACOS
#define gdh_Lock                                                               \
  pthread_mutex_lock(&gdbroot->thread_lock);                                   \
  gdb_Lock
#define gdh_Unlock                                                             \
  gdb_Unlock;                                                                  \
  pthread_mutex_unlock(&gdbroot->thread_lock)
#else
#define gdh_Lock gdb_Lock
#define gdh_Unlock gdb_Unlock
#endif

#define touchObject(op)                                                        \
  if (op != NULL && op->l.flags.b.isCached)                                    \
  cvolc_TouchObject(op)

void cbuf_InitBuffer(void* o, pwr_tUInt32 size, pwr_tUInt32 element_size)
{
  pwr_sClass_CircBuffHeader* hp = (pwr_sClass_CircBuffHeader*)o;

  hp->Size = size;
  hp->ElementSize = element_size;
}

void cbuf_AddSample(void* o, void* value)
{
  pwr_sClass_CircBuffHeader* hp = (pwr_sClass_CircBuffHeader*)o;
  int last_idx, first_idx;
  ;

  if (hp->LastIndex == 0 && hp->FirstIndex == 0) {
    memcpy((char*)hp + pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader)), value,
        hp->ElementSize);
  }
  last_idx = hp->LastIndex + 1;
  first_idx = hp->FirstIndex;
  if (last_idx >= hp->Size)
    last_idx = 0;
  if (first_idx == last_idx) {
    first_idx++;
    if (first_idx >= hp->Size)
      first_idx = 0;
  }
  hp->FirstIndex = first_idx;
  memcpy((char*)hp + pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader))
          + last_idx * hp->ElementSize,
      value, hp->ElementSize);
  hp->LastIndex = last_idx;
}

void cbuf_AddTimeSample(void* o, pwr_tTime* t)
{
  pwr_sClass_CircBuffHeader* hp = (pwr_sClass_CircBuffHeader*)o;
  int last_idx, first_idx;
  ;
  char* buffp;

  if (hp->LastIndex == 0 && hp->FirstIndex == 0) {
    buffp = (char*)hp + pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader));
    if (hp->ElementSize == 8) {
      unsigned int tv_sec = (unsigned int)t->tv_sec;
      unsigned int tv_nsec = (unsigned int)t->tv_nsec;
      memcpy(buffp, &tv_sec, 4);
      memcpy(buffp + 4, &tv_nsec, 4);
    } else {
      unsigned int tv_sec = (unsigned int)t->tv_sec;
      memcpy(buffp, &tv_sec, 4);
    }
  }
  last_idx = hp->LastIndex + 1;
  first_idx = hp->FirstIndex;
  if (last_idx >= hp->Size)
    last_idx = 0;
  if (first_idx == last_idx) {
    first_idx++;
    if (first_idx >= hp->Size)
      first_idx = 0;
  }
  hp->FirstIndex = first_idx;
  buffp = (char*)hp + pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader))
      + last_idx * hp->ElementSize;
  if (hp->ElementSize == 8) {
    unsigned int tv_sec = (unsigned int)t->tv_sec;
    unsigned int tv_nsec = (unsigned int)t->tv_nsec;
    memcpy(buffp, &tv_sec, 4);
    memcpy(buffp + 4, &tv_nsec, 4);
  } else {
    unsigned int tv_sec = (unsigned int)t->tv_sec;
    memcpy(buffp, &tv_sec, 4);
  }
  hp->LastIndex = last_idx;
}

pwr_tStatus cbuf_GetCircBuffInfo(cbuf_sCircBuffInfo* info, int infosize)
{
  pwr_tStatus sts = GDH__SUCCESS;
  mvol_sAttribute attribute;
  mvol_sAttribute* ap;
  pwr_sClass_CircBuffHeader* hp;
  char* datap;
  int split = 0;
  int start_idx;
  int first_index, last_index;
  int samples;
  int j;

  memset(&attribute, 0, sizeof(attribute));

  gdh_Lock;

  for (j = 0; j < infosize; j++) {
    while (1) {
      ap = vol_ArefToAttribute(
          &sts, &attribute, &info[j].circ_aref, gdb_mLo_global, vol_mTrans_all);
      if (ap == NULL || ap->op == NULL)
        break;

      if (ap->op->l.flags.b.isCached) {
        net_sGetCircBuffer* mp;
        qcom_sPut put;
        gdb_sVolume* vp;
        qcom_sQid tgt;
        qcom_sGet get;
        net_sGetCircBufferR* rsp;
        gdb_sNode* np;

        vp = pool_Address(NULL, gdbroot->pool, ap->op->l.vr);
        if (vp == NULL) {
          sts = GDH__NOSUCHOBJ;
          break;
        }

        mp = net_Alloc(&sts, &put, sizeof(*mp), net_eMsg_getCircBuffer);
        if (mp == NULL)
          break;

        mp->circ_aref = info->circ_aref;
        mp->resolution = info->resolution;
        mp->samples = info->samples;
        mp->bufsize = info->bufsize;

        np = hash_Search(&sts, gdbroot->nid_ht, &vp->g.nid);
        if (np == NULL)
          break;

        tgt = np->handler;

        gdb_Unlock;

        rsp = net_Request(
            &sts, &tgt, &put, &get, net_eMsg_getCircBufferR, 0, 0);

        gdb_Lock;

        if (EVEN(sts))
          break;

        if (EVEN(rsp->sts)) {
          sts = rsp->sts;
          net_Free(NULL, rsp);
          break;
        }

        if (cdh_ObjidIsNotEqual(rsp->circ_aref.Objid, info->circ_aref.Objid)) {
          sts = 0;
          break;
        }

        info->size = rsp->size;
        info->bufsize = rsp->bufsize;
        info->first_idx = rsp->first_idx;
        info->last_idx = rsp->last_idx;
        info->offset = rsp->offset;
        info->bufp = calloc(1, info->bufsize);
        memcpy(info->bufp, rsp->buf, info->bufsize);

        net_Free(NULL, rsp);
        break;
      }

      touchObject(ap->op);

      samples = info[j].samples;

      hp = vol_AttributeToAddress(&sts, ap);
      if (hp != NULL) {
        if (hp->FirstIndex == hp->LastIndex) {
          sts = 0;
          break;
        }
        if (info[j].resolution <= 1) {
          if (samples > hp->Size)
            samples = hp->Size;

          datap = (char*)hp + pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader));
          first_index = hp->FirstIndex;
          last_index = hp->LastIndex;
          start_idx = last_index - samples;
          if (first_index < last_index) {
            if (first_index > start_idx)
              start_idx = first_index;
          } else {
            if (start_idx < 0) {
              split = 1;
              start_idx = hp->Size + start_idx;
              if (start_idx < first_index)
                start_idx = first_index;
            }
          }
          if (split) {
            memcpy(info[j].bufp, datap + start_idx * hp->ElementSize,
                (hp->Size - start_idx) * hp->ElementSize);
            memcpy(info[j].bufp + (hp->Size - start_idx) * hp->ElementSize,
                datap, last_index * hp->ElementSize);
            info[j].size = hp->Size - start_idx + last_index;
          } else {
            memcpy(info[j].bufp, datap + start_idx * hp->ElementSize,
                (last_index - start_idx) * hp->ElementSize);
            info[j].size = last_index - start_idx;
          }
          info[j].last_idx = last_index;
          info[j].first_idx = first_index;
          info[j].offset = 0;
        } else {
          /* Resolution > 0 */
          int elements;
          char *dp, *bp;
          int i;
          int idx, tst_first_idx;

          if (samples > hp->Size / info[j].resolution)
            samples = hp->Size / info[j].resolution;

          datap = (char*)hp + pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader));
          first_index = hp->FirstIndex;
          last_index = hp->LastIndex;
          start_idx = last_index - (samples - 1) * info[j].resolution;

          tst_first_idx = first_index;
          if (first_index > last_index)
            tst_first_idx -= hp->Size;

          if (start_idx < tst_first_idx)
            start_idx += (tst_first_idx - start_idx) / info[j].resolution
                * info[j].resolution;

          elements = (last_index - start_idx) / info[j].resolution + 1;
          info[j].size = elements;
          info[j].offset = info[j].resolution;
          if (start_idx < 0)
            start_idx += hp->Size;

          bp = info[j].bufp;
          idx = start_idx;
          for (i = 0; i < elements; i++) {
            dp = datap + idx * hp->ElementSize;
            memcpy(bp, dp, hp->ElementSize);
            // printf( "sp1: %d\n", idx);
            bp += hp->ElementSize;
            idx += info[j].resolution;
            if (idx >= hp->Size)
              idx -= hp->Size;
          }
          info[j].last_idx = last_index;
          info[j].first_idx = first_index;
        }
        sts = GDH__SUCCESS;
      } else
        sts = 0;
      break;
    }
    gdh_Unlock;
  }
  return sts;
}

pwr_tStatus cbuf_UpdateCircBuffInfo(cbuf_sCircBuffInfo* info, int infosize)
{
  pwr_tStatus sts = GDH__SUCCESS;
  mvol_sAttribute attribute;
  mvol_sAttribute* ap;
  pwr_sClass_CircBuffHeader* hp;
  char* datap;
  int split;
  int start_idx;
  int first_index, last_index;
  int finish = 0;
  int j;

  memset(&attribute, 0, sizeof(attribute));

  for (j = 0; j < infosize; j++) {
    split = 0;
    gdh_Lock;

    while (1) {
      ap = vol_ArefToAttribute(
          &sts, &attribute, &info[j].circ_aref, gdb_mLo_global, vol_mTrans_all);
      if (ap == NULL || ap->op == NULL)
        break;

      if (ap->op->l.flags.b.isCached) {
        net_sUpdateCircBuffer* mp;
        qcom_sPut put;
        gdb_sVolume* vp;
        qcom_sQid tgt;
        qcom_sGet get;
        net_sUpdateCircBufferR* rsp;
        gdb_sNode* np;
        int i;
        int offs;

        vp = pool_Address(NULL, gdbroot->pool, ap->op->l.vr);
        if (vp == NULL) {
          sts = GDH__NOSUCHOBJ;
          break;
        }

        mp = net_Alloc(&sts, &put, sizeof(*mp), net_eMsg_updateCircBuffer);
        if (mp == NULL)
          break;

        mp->info_size = infosize;
        if (mp->info_size > 10)
          mp->info_size = 10;

        for (i = 0; i < infosize; i++) {
          mp->circ_aref[i] = info[i].circ_aref;
          mp->resolution[i] = info[i].resolution;
          mp->samples[i] = info[i].samples;
          mp->bufsize[i] = info[i].bufsize;
          mp->last_idx[i] = info[i].last_idx;
          mp->offset[i] = info[i].offset;
        }

        np = hash_Search(&sts, gdbroot->nid_ht, &vp->g.nid);
        if (np == NULL)
          break;

        tgt = np->handler;

        gdb_Unlock;

        rsp = net_Request(
            &sts, &tgt, &put, &get, net_eMsg_updateCircBufferR, 0, 0);

        gdb_Lock;

        if (EVEN(sts))
          break;

        if (EVEN(rsp->sts)) {
          sts = rsp->sts;
          net_Free(NULL, rsp);
          break;
        }

        offs = 0;
        for (i = 0; i < rsp->info_size; i++) {
          if (cdh_ObjidIsNotEqual(
                  rsp->circ_aref[i].Objid, info[i].circ_aref.Objid)) {
            sts = 0;
            break;
          }

          info[i].size = rsp->size[i];
          info[i].bufsize = rsp->bufsize[i];
          info[i].first_idx = rsp->first_idx[i];
          info[i].last_idx = rsp->last_idx[i];
          info[i].offset = rsp->offset[i];
          info[i].bufp = calloc(1, info[i].bufsize);
          memcpy(info[i].bufp, rsp->buf + offs, info[i].bufsize);
          offs += info[i].bufsize;
        }
        net_Free(NULL, rsp);
        finish = 1;
        break;
      }

      touchObject(ap->op);

      hp = vol_AttributeToAddress(&sts, ap);
      if (hp != NULL) {
        if (hp->FirstIndex == hp->LastIndex) {
          info[j].size = 0;
          break;
        }
        if (info[j].resolution <= 1) {
          datap = (char*)hp + pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader));
          first_index = info[j].last_idx;
          last_index = hp->LastIndex;
          start_idx = last_index - info[j].samples;
	  if (first_index == last_index) {
	    info[j].last_idx = last_index;
	    info[j].first_idx = first_index;
	    info[j].offset = 0;
	    info[j].size = 0;
	    break;
	  }
          else if (first_index < last_index) {
            if (first_index > start_idx)
              start_idx = first_index;
          } else {
            if (start_idx < 0) {
              split = 1;
              start_idx = hp->Size + start_idx;
              if (start_idx < first_index)
                start_idx = first_index;
            }
          }
          if (split) {
            memcpy(info[j].bufp, datap + start_idx * hp->ElementSize,
                (hp->Size - start_idx) * hp->ElementSize);
            memcpy(info[j].bufp + (hp->Size - start_idx) * hp->ElementSize,
                datap, last_index * hp->ElementSize);
            info[j].size = hp->Size - start_idx + last_index;
          } else {
            memcpy(info[j].bufp, datap + start_idx * hp->ElementSize,
                (last_index - start_idx) * hp->ElementSize);
            info[j].size = last_index - start_idx;
          }
          info[j].last_idx = last_index;
          info[j].first_idx = first_index;
          info[j].offset = 0;
        } else {
          /* Resolution > 1 */
          int elements;
          char* dp;
          int i;
          int tst_idx;

          datap = (char*)hp + pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader));

          first_index = hp->FirstIndex;
          last_index = hp->LastIndex;

          tst_idx = last_index;
          if (tst_idx < info[j].last_idx)
            tst_idx += hp->Size;

          start_idx = info[j].last_idx + info[j].offset;
          if (start_idx > tst_idx) {
            info[j].size = 0;
            break;
          }
          elements = (tst_idx - start_idx) / info[j].resolution + 1;
          info[j].offset = info[j].resolution
              - (tst_idx - start_idx - (elements - 1) * info[j].resolution);
          if (start_idx >= hp->Size)
            start_idx -= hp->Size;

          if (elements > info[j].samples)
            elements = info[j].samples;

          info[j].size = elements;
          for (i = 0; i < elements; i++) {
            dp = datap + start_idx * hp->ElementSize;
            memcpy(info[j].bufp + i * hp->ElementSize, dp, hp->ElementSize);
            // printf( "%d idx: %d   %5.2f   el:%d  off:%d  lidx: prev %d curr
            // %d\n", i, start_idx, *(float *)dp, elements, info[j].offset,
            // info[j].last_idx, last_index);
            start_idx += info[j].resolution;
            if (start_idx >= hp->Size)
              start_idx -= hp->Size;
          }

          info[j].last_idx = last_index;
          info[j].first_idx = first_index;
        }
        sts = GDH__SUCCESS;
      } else
        sts = 0;
      break;
    }
    gdh_Unlock;

    if (finish)
      break;
  }
  return sts;
}

void cbuf_GetCircBufferMsg(qcom_sGet* get)
{
  net_sGetCircBuffer* mp = get->data;
  net_sGetCircBufferR* rmp;
  gdb_sNode* np;
  pwr_tStatus sts;
  pwr_tUInt32 size;
  qcom_sPut put;
  cbuf_sCircBuffInfo info;

  gdb_ScopeLock
  {
    np = hash_Search(&sts, gdbroot->nid_ht, &mp->hdr.nid);
  }
  gdb_ScopeUnlock;

  if (gdbroot->db->log.b.id) {
    errh_Info("Sending 'getCircBuffer' to %s (%s)", np->name,
        cdh_NodeIdToString(NULL, np->nid, 0, 0));
  }

  info.circ_aref = mp->circ_aref;
  info.resolution = mp->resolution;
  info.samples = mp->samples;
  info.bufsize = mp->bufsize;
  info.bufp = calloc(1, info.bufsize);

  sts = cbuf_GetCircBuffInfo(&info, 1);
  if (EVEN(sts))
    size = sizeof(*rmp);
  else
    size = sizeof(*rmp) + info.bufsize;
  size = (size + 3) & ~3; /* Size up to nearest multiple of 4.  */

  rmp = net_Alloc(&sts, &put, size, net_eMsg_getCircBufferR);
  if (rmp == NULL) {
    errh_Error("Failed to allocate 'getCircBufferR' to %s (%s)", np->name,
        cdh_NodeIdToString(NULL, np->nid, 0, 0));
    return;
  }

  rmp->sts = sts;
  if (EVEN(sts)) {
    rmp->sts = sts;
    rmp->size = 0;
  } else {
    rmp->sts = sts;
    rmp->circ_aref = info.circ_aref;
    rmp->size = info.size;
    rmp->bufsize = info.bufsize;
    rmp->first_idx = info.first_idx;
    rmp->last_idx = info.last_idx;
    rmp->offset = info.offset;
    memcpy(rmp->buf, info.bufp, info.bufsize);
    free(info.bufp);
  }

  net_Reply(&sts, get, &put, 0);
}

void cbuf_UpdateCircBufferMsg(qcom_sGet* get)
{
  net_sUpdateCircBuffer* mp = get->data;
  net_sUpdateCircBufferR* rmp;
  gdb_sNode* np;
  pwr_tStatus sts;
  pwr_tUInt32 size;
  pwr_tUInt32 total_size = 0;
  qcom_sPut put;
  cbuf_sCircBuffInfo info[10];
  int i, offs;

  gdb_ScopeLock
  {
    np = hash_Search(&sts, gdbroot->nid_ht, &mp->hdr.nid);
  }
  gdb_ScopeUnlock;

  if (gdbroot->db->log.b.id) {
    errh_Info("Sending 'updateCircBuffer' to %s (%s)", np->name,
        cdh_NodeIdToString(NULL, np->nid, 0, 0));
  }

  if (mp->info_size >= 10) {
    errh_Error("Parameter size error 'updateCircBufferR' to %s (%s)", np->name,
        cdh_NodeIdToString(NULL, np->nid, 0, 0));
    return;
  }
  for (i = 0; i < mp->info_size; i++) {
    info[i].circ_aref = mp->circ_aref[i];
    info[i].resolution = mp->resolution[i];
    info[i].samples = mp->samples[i];
    info[i].last_idx = mp->last_idx[i];
    info[i].offset = mp->offset[i];
    info[i].bufsize = mp->bufsize[i];
    info[i].bufp = calloc(1, info[i].bufsize);
  }
  sts = cbuf_UpdateCircBuffInfo(info, mp->info_size);
  if (EVEN(sts))
    size = sizeof(*rmp);
  else {
    total_size = 0;
    for (i = 0; i < mp->info_size; i++)
      total_size += info[i].bufsize;
    size = sizeof(*rmp) + total_size;
  }
  size = (size + 3) & ~3; /* Size up to nearest multiple of 4.  */

  rmp = net_Alloc(&sts, &put, size, net_eMsg_updateCircBufferR);
  if (rmp == NULL) {
    errh_Error("Failed to allocate 'updateCircBufferR' to %s (%s)", np->name,
        cdh_NodeIdToString(NULL, np->nid, 0, 0));
    return;
  }

  rmp->sts = sts;
  if (EVEN(sts)) {
    rmp->sts = sts;
    rmp->bsize = 0;
  } else {
    rmp->sts = sts;
    rmp->info_size = mp->info_size;
    rmp->bsize = total_size;
    offs = 0;
    for (i = 0; i < mp->info_size; i++) {
      rmp->circ_aref[i] = info[i].circ_aref;
      rmp->size[i] = info[i].size;
      rmp->bufsize[i] = info[i].bufsize;
      rmp->first_idx[i] = info[i].first_idx;
      rmp->last_idx[i] = info[i].last_idx;
      rmp->offset[i] = info[i].offset;
      memcpy(rmp->buf + offs, info[i].bufp, info[i].bufsize);
      offs += info[i].bufsize;
      free(info[i].bufp);
    }
  }

  net_Reply(&sts, get, &put, 0);
}
