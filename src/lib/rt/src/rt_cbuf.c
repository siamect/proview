/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2013 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

#include "pwr.h"              
#include "co_cdh.h"
#include "co_time.h"
#include "co_dcli.h"
#include "rt_gdh_msg.h"
#include "rt_hash_msg.h"
#include "rt_pwr_msg.h"
#include "pwr_class.h"
#include "rt_errh.h"
#include "rt_gdb.h"
#include "rt_net.h"
#include "rt_vol.h"
#include "rt_cvolc.h"
#include "rt_mvol.h"
#include "rt_gdh.h"
#include "rt_qcom.h"
#include "rt_cbuf.h"
#include "pwr_baseclasses.h"

/* rt_cbuf.c 
   This module handles circular buffer objects.  */

#if defined OS_LYNX || defined OS_LINUX || defined OS_MACOS
# define gdh_Lock	pthread_mutex_lock(&gdbroot->thread_lock); gdb_Lock
# define gdh_Unlock	gdb_Unlock; pthread_mutex_unlock(&gdbroot->thread_lock)
#else
# define gdh_Lock	gdb_Lock
# define gdh_Unlock	gdb_Unlock
#endif

#define touchObject(op)  if (op != NULL && op->l.flags.b.isCached) cvolc_TouchObject(op)

void cbuf_InitBuffer( void *o, pwr_tUInt32 size, pwr_tUInt32 element_size)
{
  pwr_sClass_CircBuffHeader *hp = (pwr_sClass_CircBuffHeader *)o;

  hp->Size = size;
  hp->ElementSize = element_size;
}

void cbuf_AddSample( void *o, void *value)
{
  pwr_sClass_CircBuffHeader *hp = (pwr_sClass_CircBuffHeader *)o;
  int last_idx, first_idx;;

  if ( hp->LastIndex == 0 && hp->FirstIndex == 0) {
    memcpy( (char *)hp + pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader)), 
	    value, hp->ElementSize);
  }
  last_idx = hp->LastIndex + 1;
  first_idx = hp->FirstIndex;
  if ( last_idx >= hp->Size)
    last_idx = 0;
  if ( first_idx == last_idx) {
    first_idx++;
    if ( first_idx >= hp->Size)
      first_idx = 0;
  }
  hp->FirstIndex = first_idx;
  memcpy( (char *)hp + pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader)) + last_idx * hp->ElementSize, 
	  value, hp->ElementSize);
  hp->LastIndex = last_idx;
}

void cbuf_AddTimeSample( void *o, pwr_tTime *t)
{
  pwr_sClass_CircBuffHeader *hp = (pwr_sClass_CircBuffHeader *)o;
  int last_idx, first_idx;;
  char *buffp;

  if ( hp->LastIndex == 0 && hp->FirstIndex == 0) {
    buffp = (char *)hp + pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader));
    if ( hp->ElementSize == 8) {
      unsigned int tv_sec = (unsigned int)t->tv_sec;
      unsigned int tv_nsec = (unsigned int)t->tv_nsec;
      memcpy( buffp, &tv_sec, 4);
      memcpy( buffp+4, &tv_nsec, 4);
    }
    else {
      unsigned int tv_sec = (unsigned int)t->tv_sec;
      memcpy( buffp, &tv_sec, 4);
    }
  }
  last_idx = hp->LastIndex + 1;
  first_idx = hp->FirstIndex;
  if ( last_idx >= hp->Size)
    last_idx = 0;
  if ( first_idx == last_idx) {
    first_idx++;
    if ( first_idx >= hp->Size)
      first_idx = 0;
  }
  hp->FirstIndex = first_idx;
  buffp = (char *)hp + pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader)) + last_idx * hp->ElementSize;
  if ( hp->ElementSize == 8) {
    unsigned int tv_sec = (unsigned int)t->tv_sec;
    unsigned int tv_nsec = (unsigned int)t->tv_nsec;
    memcpy( buffp, &tv_sec, 4);
    memcpy( buffp+4, &tv_nsec, 4);
  }
  else {
    unsigned int tv_sec = (unsigned int)t->tv_sec;
    memcpy( buffp, &tv_sec, 4);
  }
  hp->LastIndex = last_idx;
}

pwr_tStatus cbuf_GetCircBuffInfo( cbuf_sCircBuffInfo *info,
				  int infosize)
{
  pwr_tStatus		sts = GDH__SUCCESS;
  mvol_sAttribute	attribute;
  mvol_sAttribute	*ap;
  pwr_sClass_CircBuffHeader  	*hp;
  char			*datap;
  int			split = 0;
  int			start_idx;
  int			first_index, last_index;
  int			samples;
  int			j;

  memset(&attribute, 0, sizeof(attribute));

  gdh_Lock;
  
  for ( j = 0; j < infosize; j++) {
    while ( 1) {
      ap = vol_ArefToAttribute(&sts, &attribute, &info[j].circ_aref, gdb_mLo_global, vol_mTrans_all);
      if (ap == NULL || ap->op == NULL) break;

      if ( ap->op->l.flags.b.isCached) {
	net_sGetCircBuffer		*mp;
	qcom_sPut		put;
	gdb_sVolume		*vp;
	qcom_sQid	tgt;
	qcom_sGet	get;
	net_sGetCircBufferR *rsp;
	gdb_sNode	*np;
  
	vp = pool_Address(NULL, gdbroot->pool, ap->op->l.vr);
	if (vp == NULL) {
	  sts = GDH__NOSUCHOBJ;
	  break;
	}

	mp = net_Alloc(&sts, &put, sizeof(*mp), net_eMsg_getCircBuffer);
	if (mp == NULL) break;

	mp->circ_aref = info->circ_aref;
	mp->resolution = info->resolution;
	mp->samples = info->samples;
	mp->bufsize = info->bufsize;

	np = hash_Search(&sts, gdbroot->nid_ht, &vp->g.nid);
	if (np == NULL) break;

	tgt = np->handler;

	gdb_Unlock;

	rsp = net_Request(&sts, &tgt, &put, &get, net_eMsg_getCircBufferR, 0, 0);

	gdb_Lock;

	if (EVEN(sts))
	  break;

	if (EVEN(rsp->sts)) {
	  sts = rsp->sts;
	  net_Free(NULL, rsp);
	  break;
	}

	if ( cdh_ObjidIsNotEqual(rsp->circ_aref.Objid, info->circ_aref.Objid)) {
	  sts = 0;
	  break;
	}
     
	info->size = rsp->size;
	info->bufsize = rsp->bufsize;
	info->first_idx = rsp->first_idx;
	info->last_idx = rsp->last_idx;
	info->offset = rsp->offset;
	info->bufp = calloc( 1, info->bufsize);
	memcpy( info->bufp, rsp->buf, info->bufsize);
	
	net_Free(NULL, rsp);
	break;
      }

      touchObject(ap->op);

      samples = info[j].samples;
    
      hp = vol_AttributeToAddress(&sts, ap);
      if (hp != NULL) {
	if ( hp->FirstIndex == hp->LastIndex)
	  return 0;
	if ( info[j].resolution <= 1) {
	  if ( samples > hp->Size)
	    samples = hp->Size;

	  datap = (char *)hp + pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader));
	  first_index = hp->FirstIndex;
	  last_index = hp->LastIndex;
	  start_idx = last_index - samples;
	  if ( first_index < last_index) {
	    if ( first_index > start_idx)
	      start_idx = first_index;
	  }
	  else {
	    if ( start_idx < 0) {
	      split = 1;
	      start_idx = hp->Size + start_idx;
	      if ( start_idx < first_index)
		start_idx = first_index;	    
	    }
	  }
	  if ( split) {
	    memcpy( info[j].bufp, datap + start_idx * hp->ElementSize, (hp->Size - start_idx) * hp->ElementSize);
	    memcpy( info[j].bufp + (hp->Size - start_idx) * hp->ElementSize, datap, last_index * hp->ElementSize);
	    info[j].size = hp->Size - start_idx + last_index;
	  }
	  else {
	    memcpy( info[j].bufp, datap + start_idx * hp->ElementSize, (last_index - start_idx) * hp->ElementSize);
	    info[j].size = last_index - start_idx;
	  }
	  info[j].last_idx = last_index;
	  info[j].first_idx = first_index;
	  info[j].offset = 0;
	}
	else {
	  /* Resolution > 0 */
	  int elements;
	  char *dp, *bp;
	  int i;
	  int idx, tst_first_idx;
	  
	  if ( samples > hp->Size / info[j].resolution)
	    samples = hp->Size / info[j].resolution;

	  datap = (char *)hp + pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader));
	  first_index = hp->FirstIndex;
	  last_index = hp->LastIndex;
	  start_idx = last_index - (samples - 1)* info[j].resolution;
	  
	  tst_first_idx = first_index;
	  if ( first_index > last_index)
	    tst_first_idx -= hp->Size;
	  
	  if ( start_idx < tst_first_idx)
	    start_idx += (tst_first_idx - start_idx)/ info[j].resolution * info[j].resolution;
	  
	  elements = (last_index - start_idx) / info[j].resolution + 1;
	  info[j].size = elements;
	  info[j].offset = info[j].resolution;
	  if ( start_idx < 0)
	    start_idx += hp->Size;
	  
	  bp = info[j].bufp;
	  idx = start_idx;
	  for ( i = 0; i < elements; i++) {
	    dp = datap + idx * hp->ElementSize;
	    memcpy( bp, dp, hp->ElementSize);
	    // printf( "sp1: %d\n", idx);
	    bp += hp->ElementSize;
	    idx += info[j].resolution;
	    if ( idx >= hp->Size)
	      idx -= hp->Size;
	  }
	  info[j].last_idx = last_index;
	  info[j].first_idx = first_index;
	}
	sts = GDH__SUCCESS;
      }
      else
	sts = 0;
      break;
    }
    gdh_Unlock;
  }
  return sts;
}

pwr_tStatus cbuf_UpdateCircBuffInfo( cbuf_sCircBuffInfo *info,
				     int infosize)
{
  pwr_tStatus		sts = GDH__SUCCESS;
  mvol_sAttribute	attribute;
  mvol_sAttribute	*ap;
  pwr_sClass_CircBuffHeader  	*hp;
  char			*datap;
  int			split = 0;
  int			start_idx;
  int			first_index, last_index;
  int			finish = 0;
  int j;

  memset(&attribute, 0, sizeof(attribute));


  for ( j = 0; j < infosize; j++) {
    gdh_Lock;
  
    while ( 1) {
      ap = vol_ArefToAttribute(&sts, &attribute, &info[j].circ_aref, gdb_mLo_global, vol_mTrans_all);
      if (ap == NULL || ap->op == NULL) break;

      if ( ap->op->l.flags.b.isCached) {
	net_sUpdateCircBuffer		*mp;
	qcom_sPut		put;
	gdb_sVolume		*vp;
	qcom_sQid	tgt;
	qcom_sGet	get;
	net_sUpdateCircBufferR *rsp;
	gdb_sNode	*np;
	int i;
	int offs;
  
	vp = pool_Address(NULL, gdbroot->pool, ap->op->l.vr);
	if (vp == NULL) {
	  sts = GDH__NOSUCHOBJ;
	  break;
	}

	mp = net_Alloc(&sts, &put, sizeof(*mp), net_eMsg_updateCircBuffer);
	if (mp == NULL) break;

	mp->info_size = infosize;
	if ( mp->info_size > 10)
	  mp->info_size = 10;

	for ( i = 0; i < infosize; i++) {
	  mp->circ_aref[i] = info[i].circ_aref;
	  mp->resolution[i] = info[i].resolution;
	  mp->samples[i] = info[i].samples;
	  mp->bufsize[i] = info[i].bufsize;
	  mp->last_idx[i] = info[i].last_idx;
	  mp->offset[i] = info[i].offset;
	}

	np = hash_Search(&sts, gdbroot->nid_ht, &vp->g.nid);
	if (np == NULL) break;

	tgt = np->handler;

	gdb_Unlock;

	rsp = net_Request(&sts, &tgt, &put, &get, net_eMsg_updateCircBufferR, 0, 0);

	gdb_Lock;

	if (EVEN(sts))
	  break;

	if (EVEN(rsp->sts)) {
	  sts = rsp->sts;
	  net_Free(NULL, rsp);
	  break;
	}

	offs = 0;
	for ( i = 0; i < rsp->info_size; i++) {
	  if ( cdh_ObjidIsNotEqual(rsp->circ_aref[i].Objid, info[i].circ_aref.Objid)) {
	    sts = 0;
	    break;
	  }
	  
	  info[i].size = rsp->size[i];
	  info[i].bufsize = rsp->bufsize[i];
	  info[i].first_idx = rsp->first_idx[i];
	  info[i].last_idx = rsp->last_idx[i];
	  info[i].offset = rsp->offset[i];
	  info[i].bufp = calloc( 1, info[i].bufsize);
	  memcpy( info[i].bufp, rsp->buf + offs, info[i].bufsize);
	  offs += info[i].bufsize;
	}
	net_Free(NULL, rsp);
	finish = 1;
	break;
      }

      touchObject(ap->op);
    
      hp = vol_AttributeToAddress(&sts, ap);
      if (hp != NULL) {
	if ( hp->FirstIndex == hp->LastIndex) {
	  info[j].size = 0;
	  break;
	}
	if ( info[j].resolution <= 1) {
	  datap = (char *)hp + pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader));
	  first_index = info[j].last_idx;
	  last_index = hp->LastIndex;
	  start_idx = last_index - info[j].samples;
	  if ( first_index < last_index) {
	    if ( first_index > start_idx)
	      start_idx = first_index;
	  }
	  else {
	    if ( start_idx < 0) {
	      split = 1;
	      start_idx = hp->Size + start_idx;
	      if ( start_idx < first_index)
		start_idx = first_index;	    
	    }
	  }
	  if ( split) {
	    memcpy( info[j].bufp, datap + start_idx * hp->ElementSize, (hp->Size - start_idx) * hp->ElementSize);
	    memcpy( info[j].bufp + (hp->Size - start_idx) * hp->ElementSize, datap, last_index * hp->ElementSize);
	    info[j].size = hp->Size - start_idx + last_index;
	  }
	  else {
	    memcpy( info[j].bufp, datap + start_idx * hp->ElementSize, (last_index - start_idx) * hp->ElementSize);
	    info[j].size = last_index - start_idx;
	  }
	  info[j].last_idx = last_index;
	  info[j].first_idx = first_index;
	  info[j].offset = 0;
	}
	else {
	  /* Resolution > 1 */
	  int elements;
	  char *dp;
	  int i;
	  int tst_idx;
	  
	  datap = (char *)hp + pwr_AlignLW(sizeof(pwr_sClass_CircBuffHeader));
	  
	  first_index = hp->FirstIndex;
	  last_index = hp->LastIndex;

	  tst_idx = last_index;
	  if ( tst_idx < info[j].last_idx)
	    tst_idx += hp->Size;

	  start_idx = info[j].last_idx + info[j].offset;
	  if ( start_idx > tst_idx) {
	    info[j].size = 0;
	    break;
	  }
	  elements = (tst_idx - start_idx) / info[j].resolution + 1;
	  info[j].offset = info[j].resolution - (tst_idx - start_idx - (elements - 1) * info[j].resolution);
	  if ( start_idx >= hp->Size)
	    start_idx -= hp->Size;

	  if ( elements > info[j].samples)
	    elements = info[j].samples;
	  
	  info[j].size = elements;
	  for ( i = 0; i < elements; i++) {
	    dp = datap + start_idx * hp->ElementSize;
	    memcpy( info[j].bufp + i * hp->ElementSize, dp, hp->ElementSize);
	    // printf( "%d idx: %d   %5.2f   el:%d  off:%d  lidx: prev %d curr %d\n", i, start_idx, *(float *)dp, elements, info[j].offset, info[j].last_idx, last_index);
	    start_idx += info[j].resolution;
	    if ( start_idx >= hp->Size)
	      start_idx -= hp->Size;
	  }

	  info[j].last_idx = last_index;
	  info[j].first_idx = first_index;
	}
	sts = GDH__SUCCESS;
      }
      else
	sts = 0;
      break;
    }
    gdh_Unlock;

    if ( finish)
      break;
  }
  return sts;
}


void cbuf_GetCircBufferMsg( qcom_sGet *get)
{
  net_sGetCircBuffer *mp = get->data;
  net_sGetCircBufferR *rmp;
  gdb_sNode	*np;
  pwr_tStatus 	sts;
  pwr_tUInt32		size;
  qcom_sPut		put;
  cbuf_sCircBuffInfo info;

  gdb_ScopeLock {
    np = hash_Search(&sts, gdbroot->nid_ht, &mp->hdr.nid);
  } gdb_ScopeUnlock;


  if (gdbroot->db->log.b.id) {
    errh_Info("Sending 'getCircBuffer' to %s (%s)",
      np->name, cdh_NodeIdToString(NULL, np->nid, 0, 0));
  }

  info.circ_aref = mp->circ_aref;
  info.resolution = mp->resolution;
  info.samples = mp->samples;
  info.bufsize = mp->bufsize;
  info.bufp = calloc( 1, info.bufsize);

  sts = cbuf_GetCircBuffInfo( &info, 1);
  if ( EVEN(sts))
    size = sizeof(*rmp);
  else
    size = sizeof(*rmp) + info.bufsize;
  size = (size + 3) & ~3;   /* Size up to nearest multiple of 4.  */
  
  rmp = net_Alloc(&sts, &put, size, net_eMsg_getCircBufferR);
  if (rmp == NULL) {
    errh_Error("Failed to allocate 'getCircBufferR' to %s (%s)",
      np->name, cdh_NodeIdToString(NULL, np->nid, 0, 0));
    return;
  }

  rmp->sts = sts;
  if ( EVEN(sts)) {
    rmp->sts = sts;
    rmp->size = 0;
  }
  else {
    rmp->sts = sts;
    rmp->circ_aref = info.circ_aref;
    rmp->size = info.size;
    rmp->bufsize = info.bufsize;
    rmp->first_idx = info.first_idx;
    rmp->last_idx = info.last_idx;
    rmp->offset = info.offset;
    memcpy( rmp->buf, info.bufp, info.bufsize);
    free( info.bufp);
  }

  net_Reply(&sts, get, &put, 0);
}

void cbuf_UpdateCircBufferMsg( qcom_sGet *get)
{
  net_sUpdateCircBuffer *mp = get->data;
  net_sUpdateCircBufferR *rmp;
  gdb_sNode	*np;
  pwr_tStatus 	sts;
  pwr_tUInt32  	size;
  pwr_tUInt32  	total_size;
  qcom_sPut    	put;
  cbuf_sCircBuffInfo info[10];
  int		i, offs;

  gdb_ScopeLock {
    np = hash_Search(&sts, gdbroot->nid_ht, &mp->hdr.nid);
  } gdb_ScopeUnlock;


  if (gdbroot->db->log.b.id) {
    errh_Info("Sending 'updateCircBuffer' to %s (%s)",
      np->name, cdh_NodeIdToString(NULL, np->nid, 0, 0));
  }

  if ( mp->info_size >= 10) {
    errh_Error("Parameter size error 'updateCircBufferR' to %s (%s)",
      np->name, cdh_NodeIdToString(NULL, np->nid, 0, 0));
    return;
  }
  for ( i = 0; i < mp->info_size; i++) {

    info[i].circ_aref = mp->circ_aref[i];
    info[i].resolution = mp->resolution[i];
    info[i].samples = mp->samples[i];
    info[i].last_idx = mp->last_idx[i];
    info[i].offset = mp->offset[i];
    info[i].bufsize = mp->bufsize[i];
    info[i].bufp = calloc( 1, info[i].bufsize);
  }
  sts = cbuf_UpdateCircBuffInfo( info, mp->info_size);
  if ( EVEN(sts))
    size = sizeof(*rmp);
  else {
    total_size = 0;
    for ( i = 0; i < mp->info_size; i++)
      total_size += info[i].bufsize;
    size = sizeof(*rmp) + total_size;
  }
  size = (size + 3) & ~3;   /* Size up to nearest multiple of 4.  */
  
  rmp = net_Alloc(&sts, &put, size, net_eMsg_updateCircBufferR);
  if (rmp == NULL) {
    errh_Error("Failed to allocate 'updateCircBufferR' to %s (%s)",
      np->name, cdh_NodeIdToString(NULL, np->nid, 0, 0));
    return;
  }

  rmp->sts = sts;
  if ( EVEN(sts)) {
    rmp->sts = sts;
    rmp->bsize = 0;
  }
  else {
    rmp->sts = sts;
    rmp->info_size = mp->info_size;
    rmp->bsize = total_size;
    offs = 0;
    for ( i = 0; i < mp->info_size; i++) {
      rmp->circ_aref[i] = info[i].circ_aref;
      rmp->size[i] = info[i].size;
      rmp->bufsize[i] = info[i].bufsize;
      rmp->first_idx[i] = info[i].first_idx;
      rmp->last_idx[i] = info[i].last_idx;
      rmp->offset[i] = info[i].offset;
      memcpy( rmp->buf + offs, info[i].bufp, info[i].bufsize);
      offs += info[i].bufsize;
      free( info[i].bufp);
    }
  }

  net_Reply(&sts, get, &put, 0);
}
