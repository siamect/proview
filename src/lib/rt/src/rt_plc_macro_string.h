/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/*		 Preprocessor routines for string operations	    */

/*_*
  GETSV
  get string value
  @aref getsv GetSv
*/
#define GetSv_init(tp) tp->str_copy_lock = 1;

/*_*
  STOSV
  store string value
  @aref stosv StoSv
*/
#define stosv_exec(obj, in)                                                    \
  lck_LockStr;                                                                 \
  strncpy(obj->ActualValue, in, sizeof(obj->ActualValue));                     \
  obj->ActualValue[sizeof(obj->ActualValue) - 1] = 0;                          \
  lck_UnlockStr;

/*_*
  CSTOSV
  store conditionally into string value
  @aref cstosv CStoSv
*/
#define cstosv_exec(obj, in, cond)                                             \
  if (cond) {                                                                  \
    lck_LockStr;                                                               \
    strncpy(obj->ActualValue, in, sizeof(obj->ActualValue));                   \
    obj->ActualValue[sizeof(obj->ActualValue) - 1] = 0;                        \
    lck_UnlockStr;                                                             \
  }

/*_*
  STRCAT
  @aref strcat Strcat
*/
#define Strcat_exec(obj, str1, str2)                                           \
  strncpy(obj->ActVal, str1, sizeof(obj->ActVal));                             \
  if (strlen(str1) < sizeof(obj->ActVal))                                      \
    strncat(obj->ActVal, str2, sizeof(obj->ActVal) - strlen(str1));            \
  obj->ActVal[sizeof(obj->ActVal) - 1] = 0;

/*_*
  ATOSTR
  @aref atostr AtoStr
*/
#define AtoStr_exec(obj, in) sprintf(obj->ActVal, obj->Format, in);

/*_*
  DTOSTR
  @aref dtostr DtoStr
*/
#define DtoStr_exec(obj, in) sprintf(obj->ActVal, obj->Format, in);

/*_*
  ITOSTR
  @aref itostr ItoStr
*/
#define ItoStr_exec(obj, in) sprintf(obj->ActVal, obj->Format, in);

/*_*
  STOSP
  Store into string attribute
  @aref stosp StoSp
*/
#define stosp_exec(ut, in, size)                                               \
  lck_LockStr;                                                                 \
  strncpy(ut, in, size);                                                       \
  ut[size - 1] = 0;                                                            \
  lck_UnlockStr;

/*_*
  CSTOSP
  Store conditionally into string attribute
  @aref cstosp CStoSp
*/
#define cstosp_exec(ut, in, cond, size)                                        \
  if (cond) {                                                                  \
    lck_LockStr;                                                               \
    strncpy(ut, in, size);                                                     \
    ut[size - 1] = 0;                                                          \
    lck_UnlockStr;                                                             \
  }

/*_*
  STONUMSP
  Store a number of characters into string attribute
  @aref stonumsp StoNumSp
*/
#define stonumsp_exec(ut, in, size, num)                                       \
  lck_LockStr;                                                                 \
  strncpy(ut, in, num < size ? num : size);                                    \
  ut[size - 1] = 0;                                                            \
  lck_UnlockStr;

/*_*
  CSTONUMSP
  Store conditionally a number of characters into string attribute
  @aref cstonumsp CStoNumSp
*/
#define cstonumsp_exec(ut, in, cond, size, num)                                \
  if (cond) {                                                                  \
    lck_LockStr;                                                               \
    strncpy(ut, in, num < size ? num : size);                                  \
    ut[size - 1] = 0;                                                          \
    lck_UnlockStr;                                                             \
  }

/*_*
  GetSp
  Get string attribute
  @aref getsp GetSp
*/
#define GetSp_exec(object, in)                                                 \
  lck_LockStr;                                                                 \
  strncpy(object->ActVal, in, sizeof(object->ActVal));                         \
  lck_UnlockStr;

/*_*
  SUBSTR
  @aref substr SubStr
*/
#define SubStr_exec(obj, in)                                                   \
  if (obj->Start < strlen(in)) {                                               \
    strncpy(                                                                   \
        obj->ActVal, &in[obj->Start], MIN(obj->Length, sizeof(obj->ActVal)));  \
    obj->ActVal[MIN(obj->Length, sizeof(obj->ActVal) - 1)] = 0;                \
  } else                                                                       \
    strcpy(obj->ActVal, "");

/*_*
  GetRefS
  Get string value by reference
  @aref getrefs GetRefS
*/
#define GetRefS_exec(obj, value)                                               \
  strncpy(obj->ActVal, value, sizeof(obj->ActVal));

/*_*
  StoRefS
  Store string value by reference
  @aref storefs StoRefS
*/
#define StoRefS_exec(out, in, size) strncpy(out, in, size);

/*_*
  CStoRefS
  Conditionally store analog value by reference
  @aref cstorefs CStoRefS
*/
#define CStoRefS_exec(out, in, cond, size)                                     \
  if (cond)                                                                    \
    strncpy(out, in, size);
