
<topic> __DocumentTitlePage

<image> pwr_logga.gif






<h1> Ge
<h1> Designer's Guide





















<hr>
2011-11-17
Version 4.8.3	
<hr>
</topic>

<topic> __DocumentInfoPage


Copyright 2006-2011 SSAB Oxelösund AB

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts.




</topic>

<chapter>
<option> printdisable
<topic>index
Ge Designer's Guide

Introduction <link>geref_intro
Glossary <link>geref_term
Working with the editor <link>geref_work
Windows <link>geref_windows
Objects <link>geref_objects
SubGraphs <link>geref_subgraph
Dynamics <link>geref_dynamic
Actions <link>geref_action
Create a SubGraph <link>geref_create_subgraph
Groups <link>geref_groups
GIF and JPEG images <link>geref_images
Connections <link>geref_connections
Edit <link>geref_edit
Test <link>geref_testing
Development environment <link>geref_development
Commands <link>geref_command
Script <link>geref_script
Web graphs <link>geref_web
Runtime <link>geref_runtime
Script and commands <link>gecmd
</topic>
<option> printenable

<topic>geref_intro
Introduction

Ge is an editor to build operator graphics in Proview. The editor is integrated in the 
Proview development environment and started from the Configurator. The graphs are built of
base objects in shapes of rectangles, circles, lines and texts, and of subgraphs, i.e. a
kind of composed object. Ge contains a collection of subgraphs for some common components: 
valves, motors, pumps etc. Other components, the constructor can easily draw himself. The 
shapes are stored as vectors, which makes it possible to scale and rotate the objects. In 
runtime, there is a number of possibilities to use the graphs. They can be displayed in the 
operator environment, or exported as Java frames or applets, and displayed on the web. You 
can also export a subgraph as a javabean, and use it in a java-IDE.
</topic>
</chapter>

<chapter>
<topic>geref_term
Glossary
<h2>Graph
A picture consists of a graph.
<h2>Subgraf
A collection of base objects can be stored as a subgraph. A subgraph works as a kind of class
or pattern, and in a graph you can create instances of the subgraph, that is subgraph objects.
Stored subgraphs are displayed in the subgraph palette.
<h2>Base objects
Base object are objects of type rectangles, ellipses, lines, polylines, texts, connection
points and annotations.
<h2>Complex objects.
More complex objects, e.g. bar, trend, axis.
<h2>Annotation
Text in a subgraph that can be unique for each instance.
<h2>Connection
A line that connects two subgraphs. The line can be straight or contain breakpoints that divide
it in vertical and horizontal parts.
<h2>Connection point
A point in a subgraph to which a connection can be connected.
<h2>Signal
Signal is used as a common name for an attribute of an object in the Proview realtime database.
Often its the value for a Di, Do, Dv, Ai, Ao or Av, but it can be an attribute in an arbitrary
object.
<h2>MB1
The left mouse button.
<h2>MB2
The middle mouse button or the scroll wheel. 
<h2>MB3
The right mouse button.
<h2>Rtdb
The Proview realtime database.
</topic>
</chapter>

<chapter>
<topic>geref_work
Work with the editor

<option> printdisable
Baseobjects <link>geg_baseobjects
Editing <link>geg_editing
Subgraphs <link>geg_subgraphs
Special objects <link>geg_specialobjects
Dynamic and action <link>geg_dynamics
Images <link>geg_images
Create a subgraph <link>geg_createsubgraph
Configure <link>geg_configure
Guidelines <link>geg_guidelines
</topic>
<option> printenable

<headerlevel>
<topic>geg_baseobjects
Base objects
We will start with looking at simple objects as lines, rectangles, circles and polylines. 
These objects are called base objects. The base objects is found to the left in the bottom
row of the tool panel.

<image>geg_fig1.png
<b>Fig Buttons to create base objects

<option> printdisable
Rectangle <link>geg_baseobject_rectangle
Line <link>geg_baseobject_line
Circle <link>geg_baseobject_arc
Polyline <link>geg_baseobject_polyline
Text <link>geg_baseobject_text
<option> printenable
</topic>

<headerlevel>

<topic>geg_baseobject_rectangle
Rectangle
You draw a rectangle by activating the rectangle button in the tool panel, push the right
mouse button where a corner of the rectangle should be, drag with the mouse button pressed
to the opposite corner and release the mouse button. With the default settings, a rectangle
with black border is now created.

<image> geg_fig3.png
<b>Fig Rectangle

We shall now have a look at how the appearance of the rectangle can be changed. In the tool
panel there are buttons for border, fill and 3D. They work in the way that if an object is
selected, the property of the selected object is changed. At the same time the current
setting is the default value for new objects that are created.

<h1>Object editor
By doubleclicking on the rectangle, a window is opened where you can set various attributes
of the rectangle. An attribute is changed by selecting the attributes, pressing key arrow
right (or Ctrl+Q) and inserting the new value.

<image> geg_fig2.png
<b>Fig Object editor

<h1>Fill color
We can fill the rectangle with color by clicking on the Fill button in the tool panel.
<image> geg_fig4.png
The color is changed by first selecting the rectangle by clicking on it, and the click on
the desired color in the color palette.
<image> geg_fig5.png
<b>Fig Rectangle with fill color

<h1>Border
The border of the rectangle can be removed with the Border button in the tool panel. To 
remove the border the rectangle has to be either filled or have a 3D frame. If the border
is removed, it can be added with the border button.

<image> geg_fig6.png
<b>Fig Rectangle without border

<h1>Border width
The width of the border can be changed with the LineWidth menu in the tool panel. Select
the rectangle and set desired line width. The line width in pixels, and a width between 1
and 8 pixel can be selected.

<image> geg_fig7.png
<b>Fig Rectangle with broader border

<h1>Border color
Also the color of the border can be modified. Select the rectangle, activate 'Border' in the 
color palette and click on the wanted color.

<image> geg_fig8.png
<b>Fig Modified border color

<h1>3D
With the 3D button in the tool panel, a frame with relief effect is draw on the rectangle.
<image> geg_fig9.png
<b>Fig Rectangle with 3D

The width of the relief can be changed with the attribute shadow_width. Open the object 
editor by doubleclicking on the rectangle, and insert a new value in shadow_width. The unit
of shadow_width is in percentage of the width or height (the smallest).

<image> geg_fig10.png
<b>Fig Width 3 % to the left and 15 % to the right

You can also change the contrast of the relief frame with shadow_contrast. By increasing the
value to 3 the shade will be darker and the light border will be lighter. Valid values are
1 - 3.

Whether the relief is outwards or inwards depends on the attribute relief. With Up the 
relief is outwards, ie the upper border is light and the lower dark. With Down the upper is
dark and the lower is light, which gives the effect of an inward relief. You will get the
greatest relief effect if the relief is drawn with the same color as the background.

<image> geg_fig11.png
<b>Fig Relief Up to the left and Down to the right

<h1>Gradient
With the three gradient buttons you can set a color gradient on the rectangle from lighter
to darker color tone.

<image> geg_fig12.png
<b>Fig Rectangles with various gradients

In the gradient menu there are 17 additional variations of gradients to select. Below 
Horizontal Tube2 is shown that is suitable for cylindric items.

<image> geg_fig13.png
<b>Fig Rectangle with gradient Horizontal Tube2

The contrast of the gradient can be affected by the gradient_contrast attribute in the 
object editor. The contrast can have a value between 0 and 10.

<h1>Draw a square
To draw a square you press Ctrl+E (Scale equal) before you draw the rectangle. Reset Equal
scale by right clicking in the work area.

<h1>Draw several rectangles
If you are going to draw several rectangles you can press the Shift key when clicking on the 
rectangle button in the tool panel. Now you can draw several rectangles without clicking on
the rectangle button for each new rectangle. The function is reset by right clicking in the
work area.
 
</topic>
<topic>geg_baseobject_line
Line
You draw a line by activating the line button in the tool panel, press the right mouse
button where the line is to start, drag with the mouse button pressed to the end position
and there release the mouse button.

<image> geg_fig14.png
<b>Fig Line

<h1>Line width
The line width is changed by selecting the line and choose a width in the Linewidth menu.
<image> geg_fig15.png
<b>Fig Linewidth set to 8

<h1>Färg
The color is changed by selecting the line, clicking on Border in the color palette, and 
clicking on the desired color.
<image> geg_fig16.png
<b>Fig Colored line

<h1>Line type
There is a number of different line types to choose between. Select the line and activate
the desired type in the Linetype menu.

<image> geg_fig17.png
<b>Fig Various line types

<h1>Horizontal and vertical lines
To draw a horizontal line you press Ctrl+H (MoveRestrictions Horizontal) before you draw the
line. A vertical line is drawn by first pressing Ctrl+G (MoveRestrictions Vertical). 
MoveRestrictions is reset by right clicking in the work area.

<h1>Draw several lines
If you will draw several lines you can press the Shift key when clicking on the line button 
in the tool panel. Now you can draw several lines without clicking on the line button for 
each new line. The function is reset by right clicking in the work area.

</topic>

<topic> geg_baseobject_arc
Ellipse and circle
Draw an ellipse by selecting the ellipse button in the tool panel, and press the left mouse
button, drag with the button pressed, and finally release the button.

<image> geg_fig20.png
<b>Fig Ellipse

As for the rectangle, you can set properties for border, fill, border color, fill color,
3D and gradient. Some examples are displayed below.
<image> geg_fig18.png
<b>Fig Circle with various combinations of border, fill, 3D and gradient

<h1>Arc
You can also draw an arc by specifying angle1 and angle2 in the object editor. angle1 is 
the angle from the horizontal axis to the beginning of the arc, and angle2 is the angle for
the extension of the arc.

<h1>Draw several ellipses
By pressing the Shift key when you click on the arc button in the tool panel, you can draw
several arcs ellipses without clicking on the arc button for every new ellipse. The function
is reset by right clickning in the work area.

<image> geg_fig19.png
<b>Fig Arc with angle1=30 and angle2=270

</topic>

<topic> geg_baseobject_polyline
Polylinje and polygon
A polyline is drawn by clicking on the polyline button in the tool panel, press left mouse 
button at the starting point, keep the mouse button pressed and drag to the next breakpoint
and release the mouse button, press again and drag to the next breakpoint etc. When the last
line is drawn, right click in the work area to finish the polyline. 

<image> geg_fig21.png
<b>Fig Polyline

Various combinations of border, fill, 3D, gradient, linewitdh and color can be used for
polylines.
<image> geg_fig22.png
<b>Fig Some combinations of fill, 3D and gradient

<h1>3D
When applying the 3D effect on polylines, the polyline should be closed, ie the start point
should be the same as the endpoint. To draw a closed polyline, activate the Snap to grid in
the tool panel before drawing the polyline.

<h1>Modify a polyline
To move a breakpoint in a polyline, select the polyline and activate Edit/Edit Polyline in
the menu. The breakpoints and endpoints are now sensitive and can be moved by dragging with
the left mouse button.

<h1>Vertical and horizontal lines
Often you only want the polyline to consist of vertical and horizontal lines. By pressing
Ctrl+H (MoveRestrictions horizontal) the first line will be horizontal, the second vertical
etc. If you press Ctrl+G (MoveRestrictions vertical) the first line will be vertical and the
second horizontal etc. Reset MoveRestrictions by right clicking in the work area.
</topic>

<topic> geg_baseobject_text
Text
Texts are drawn by activating the text button in the tool panel. Click in the work area and
insert the text into the input field at the bottom line in the editor.

<image> geg_fig23.png
<b>Fig Text

<h1>Object attributes
By doubleclicking on the text the object editor is opened, displaying the object attributes.
The attribute Adjustment is set for left, center or right adjustment of the text.

<image> geg_fig24.png
<b>Fig The object editor with adjustment attribute

<h1>Text size
You change the text size from the Textsize menu in the tool panel. Select the text and set
desired size in the menu. You can also use the scale function to change the size.

<h1>Font
The font is selected with the font menu in the tool panel, You can choose between the fonts
Helvetica, Times, New Century Schoolbook, Courier and Lucida Sans. Select the text and 
specify the wanted font in the menu.

<h1>Color
Text color is selected by activating the Text button in the color palette, and the clicking
on a clolor.
<image> geg_fig25.png
<b>Fig Colored text

<h1>Text rotation
A text can be rotated in steps of 90 degrees by using the rotation button in the tool panel.
Only text with center adjustment can be rotated, ie the attribute Adjustment has to be set to
Center in the object editor.
<image> geg_fig26.png
<b>Fig Rotated text

<h1>Change a text
To change a text you select the text and press Ctrl+T (Change Text). An input field is opened
in the bottom line of the editor where you can insert the new text.

<h1>Bitmap fonts
The normal fonts are scalable and antialiased. In some cases you might prefer bitmap fonts.
They only exist in certain sizes between 8 and 24 pixel, but requires considerably less 
CPU capacity to handle. Bitmap fonts are selected by setting BitmapFonts in Graph Attributes
to 1.

<h1>Window manager font settings
Some window managers have settings that affects the fonts. In Gnome you find the setting in 
System menu where you can choose between various rendering.

</topic>
</headerlevel>

<topic> geg_editing
Editing
In this section we will have a closer look at various editing functions, for example how to
move, scale and color objects.

<h1>Create an object
How to create a base object is described in the Base object section above. Normally you 
create and object by clicking on the symbol in the tool panel, and then click or drag with
the left mouse button in the work area. Subgraphs are created by selecting a subgraph in the
subgraph palette and click with MB2 in the work area.

<h1>Select an object
You select an object with Click MB1. A selected object is marked with red color. If you want
to select several object click on them with Shift/Click MB1.

To select objects in the certain area you can also drag with MB1 in the work area The 
objects inside the selection rectangle will be selected. As objects are also moved by
drag MB1 you should avoid to hit an object when starting the drag. If this is hard to
avoid you can use Shift/Drag MB1 that adds objects to the select list.

Note that when you change the color of a selected object the red marking is removed, as
you then want to se the new color instead. The object is though still selected.

By right clicking in the work area the select list is emptied.

<h1>Delete an object
To delete an object you select the object and press the Delete key. You can also delete an
object by doubleclicking with MB2 on the object. With doubleclick MB2 in some empty space in 
the work area you delete all selected objects.

<h1>Move an object
An object is moved with drag MB1. If several object should be moved concurrently, you 
select them and drag one of the objects. All selected object will then follow. If the 
movement should be vertical or horizontal, you can use Functions/MoveRestrictions/Vertical
(Ctrl+G) or Functions/MoveRestrictions/Horizontal (Ctrl+H). These functions are active 
until you reset with right click.

If Snap to grid is activated in the tool panel, the position of an object is adjusted to
nearest grid point when the object is moved.

You can also move an object with the move command. This will give a more precise movement
than if you move with the mouse. You can move by supplying relative or absolute coordinates.
The command to move the selected object to the point (1,1) is

<c>ge> move selected /absx=1 /absy=1


<h1>Object with fix position
Large objects in the background are easy to move by mistake when you edit. For some objects
as rectangles, ellipses and polylines you can set the attribute 'fixposition' that locks
the object at a certain position.

<h1>Copy an object
You copy objects by selecting them and activating Edit/Copy (Ctrl+C) and Edit/Paste (Ctrl+V)
in the menu. After paste the objects are following the cursor, and by clicking with MB1 you
position them in the work area. When pasting you can select vertical (Ctrl+G) or
horizontal (Ctrl+H) movement.

<h1>Scale an object
An object is scaled by selecting the object, activating Scale in the tool panel, and then
stretch the rectangle that surrounds the objects. Terminate with click MB3. If you want
the proportions between width and hight to be preserved, press first Ctrl+E (Scale Equal).

There is also a button in the tool panel to double the size of an object, and one button 
to half the size.

<h1>Rotate an object
An object can be rotated with the rotation button in the tool panel. It rotates the 
selected objects in steps of 90 degrees.

I you want another rotation angle you activate Edit/Rotate in in the menu. Note that
rectangles and ellipses only can be rotated in steps of 90 degrees, and to rotate texts
the Adjustment attribute for the text has to be set to Center.

<h1>Mirror
There are two buttons in the tool panel to mirror, one for horizontal mirroring an one for
vertical mirroring. The mirroring it executed on the select objects.

<image> geg_fig27.png
<b>Fig Horizontal mirroring

<image> geg_fig28.png
<b>Fig Vertical mirroring

<h1>Change object color
There are three different types of colors that can be selected in the color palette, fill
color, border color and text color. In the palette you find the buttons Fill, Border and
Text where you mark which color type should be selected. When you then select a color in 
the palette the color of the selected objects are changed. The selected color combination
is also applied to new objects that are created.

<b>Fill color
To set the fill color of an object, you select the object, check that Fill is active in the
color palette, or else you click on Fill. Then you select the color you want to set on the
object. In the example below the fill color is changed from blue to green.

<image> geg_fig30.png
<b>Fig Fill is marked and a green tone is selected.

<image> geg_fig29.png
<b>Fig Fill color is change from blue to green

<b>Border color
The border color is changed in a similar way. Now you mark Border in the color palette, and
then select the border color that should be set to the selected objects.

<image> geg_fig32.png
<b>Fig Border is marked and a bluegreen tone is selected for border color

<image> geg_fig31.png
<b>Fig Border color changed from black to bluegreen

<b>Text color
To change the text color, you activate Text in the color palette, and then choose the text
color that should be set to the selected objects.

<image> geg_fig34.png
<b>Fig Text is marked and a green tone is selected

<image> geg_fig33.png
<b>Fig The text color is changed from black to green

<h1>Background color
You set the background color the the graph by selecting a fill color in the color palette
and activate Functions/Set Background Color in the menu.

<h1>Grid
The two buttons Show grid and Snap to grid, together with the Gridsize menu handles the 
grid function. Show grid shows all grid points, and with the Gridsize menu you can set the
distance between the grid points. When Snap to grid is activated, the coordinates for objects
that are created or moved will be adjusted to nearest grid point.

The gridsize can be set to 1.0, 0.5, 0.25 or 0.10 in the Gridsize menu. With the 
'set gridsize' command it is also possible to set other values on the grid size. To set the
grid size to 0.20 enter the command

<c>ge> set gridsize 0.20

<h1>Order objects
There are a number of buttons in the tool panel to adjust the position of number of objects
to place them on the same horizontal or vertical level.

You can also adjust the position so objects will be placed on equal distance from each other.

<h1>Groups
You create a group of a number of objects by selecting the objects and pressing the Group
button in the tool panel. The group is then handled as if it where an individual object, 
for example when you select, move or scale it. If you want to make a change in a member
object, the group has to be dissolved by the Ungroup button, then you can make the change
and group again.

Groups have the properties dynamic and action, ie you can connect them to signals in the 
database and for example change color of the group dependent on the status of a signal.
You can also make them sensitive for click, and set signal values when they are clicked on.
These are properties they share with subgraphs, that the base objects lacks. If you want to
set dynamic on a base object, eg a rectangle, you have to create a group with only the
rectangle, and then you will get the possibility to set dynamic and action on the rectangle.
In this way you can create an indicator, pushbutton or a bar from the rectangle.

<image> geg_fig35.png
<b>Fig The object editor for a group with attributes for dynamic and action

</topic>


<topic> geg_subgraphs
Subgraphs
A subgraph is a graphic component built by base objects. It often symbolizes a certain 
element in the plant, eg a valve or a pump, but it can also be a pushbutton or an input
field.

<h1>Create a subgraph
To the right in the editor, the subgraph palette is found, and you create a subgraph by
selecting a subgraph in the palette and click with MB2 in the work area. In the figure
below a Valve under the Process map is selected.

<image> geg_fig36.png
<b>Fig A valve subgraph

On most subgraphs you can apply 3D and different kinds of gradients. There are though some
subgraphs that are not adapter for this.

<image> geg_fig38.png
<b>Fig Valve with 3D to the left, and 3D + gradient to the right


<h1>Change color
The valve in the figure is a monochrome subgraph, and you can change the color by selecting
a fill color in the color palette in the same way as for base objects. You can also modify
the border color and border width.

<image> geg_fig37.png
<b>Fig Blue colored valve

<h1>Polychrome subgraphs
On subgraphs that contain different color, you change the color with the functions for color
shift or with the color tone palette. Let us create a burner (Process/Burner) that contains
the colors yellow and orange.

<image> geg_fig40.png
<b>Fig Polychrome subgraph

If we set a fill color we will lose the color drawing and the burner will be monochrome.
Instead we use the buttons for color shift in the tool panel (the right buttons in the 
figure below). Select the subgraph and click on the arrows to shift the color.

<image> geg_fig44.png
<b>Fig Buttons to shift color

Now the colors are rotated on the color wheel so that the subgraphs is still drawn with two
colors, and the color contrast is kept. You can also use the buttons for changing intensity
and lightness, positioned the right of the color shift buttons, to adjust the subgraph color.

<image> geg_fig41.png
<b>Fig Example of burners with shifted colors

Another way of changing the color of a polychrome subgraph is to use the color tone palette 
(the lower part of the color palette in the figure below). Select the subgraph and click on a 
color tone in the palette.

<image> geg_fig43.png
<b>Fig Färgtons-paletten

The result is that the different parts have the same color tone, but the lightness contrast
between the different parts is kept.

<image> geg_fig42.png
<b>Fig Burners with various color tones applied

<h1>Connection points
Some subgraphs contains connection points that makes it possible to draw connections between
the subgraphs. You create a connection by dragging MB2 from a connection point in a subgraph,
and release MB2 at a connection point in another subgraph. For the connections, line width, 
color and 3D can be set. If you release a connection in the work area, a junction is created, 
from which connections in different directions can be drawn.

<image> geg_fig39.png
<b>Fig Subgraphs with connections

<h1>Dynamic and action
Subgraphs have, like groups, the properties dynamic and action, which makes is possible
to connect them to signals in the database and change color and shape dependent on the 
status of a signal. It is also possible to make them sensitive for mouse clicks and set
signals when they are clicked on. Furthermore, subgraphs have often a preprogrammed
dynamic or action. An indicator has for example the dynamic to change color as default, so
you only have to connect it to a signal to make it work.

Let us create an indicator and look at how to change the color. We mark an indicator
Indicator/IndRoundMetalFrame in the subgraph palette and click with MB2 in the work area to
create the indicator. To connect it to a signal in the database we click on the navigator
button in the tool panel. Now the plant hierarchy is displayed to the left. We want the
indicator to show status of the Dv H1-Dv3, and find the Dv in the plant hierarchy. By 
selecting H1-Dv3 and click with Ctrl+Doubleclick MB1 on the indicator the connection is made.

<image> geg_fig45.png
<b>Fig A signal is connected to the indicator with Ctrl+Dubbleclick MB1

By opening the object editor for the indicator we can check that the connections is done.

<image> geg_fig47.png
<b>Fig The indicator object editor

We can see that the indicator has the default dynamic DigLowColor, that shifts between
two colors, and DigLowColor.Attribute is set to H1-Dv3.ActualValue.

When we open the graph in rt_xtt we can se how the indicator shifts between green and 
dark gray when Dv3 shifts between 1 and 0.

<image> geg_fig46.png
<b>Fig The indicator when the Dv is 1 to the left and 0 to the right

If we take a look at the valve above, it has a slightly more advanced dynamic. It can shift
between three different colors, and thus has to be connected to two signals. One signal
colors the valve red to indicate a fault, and the other colors the valve white to indicate
closed valve.

If we open the object editor for the valve we can see that DigError.Attribute should be 
connected to a signal indicating fault, and DigLowColor.Attribute to a signal indicating
that the valve is open.
<image> geg_fig48.png
<b>Fig Valve connected to two signals

In this case we will make the connection in the object editor, and select H1-Dv4 in the
plant hierarchy. By clicking with Ctrl+Doubleclick MB1 on the attribute DigError.Attribute,
H1-Dv4 in inserted. In the same way, H1-Dv5 is inserted into DigLowColor.Attribute. We 
can see the result in the figure below. When Dv4 is 0, ie the valve is closed, it is colored
white. When Dv4 is high, ie the valve is opened, it is colored green. If we set the fault
signal Dv4 it is colored red independent of the value of Dv5. This is due to the fact that
DigError has higher priority than DigLowColor. In the object editor, the dynamics are 
ordered by priority, with the highest priority on top and the lowest priority at the 
bottom.

<image> geg_fig49.png
<b>Fig Closed valve to the left, open valve in the middle and fault signal to the right

If we want to mark closed valve with dark gray instead of white, we change the color in
DigLowColor.LowColor. The default value is Inherit, ie a white preprogrammed color will be
chosen. By choosing GrayHigh9 instead, the color when the signal is low will be dark gray.
If you have difficulties with identifying the colors, you can select desired color as fill
color in the color palette, and click with Ctrl+Doublelclick MB1 on DigLowColor.LowColor to
insert the color.

<image> geg_fig51.png
<b>Fig LowColor is changed from Inherit to dark gray

<image> geg_fig50.png
<b>Fig Closed valve to the left, open valve in the middle and fault signal to the right

</topic>

<topic> geg_specialobjects
Special objects
Besides base objects and subgraphs there are a collection of more complex objects. These
objects are found in the subgraph palette. The objects are

Window <link>geg_specialobjects_window
TabbedWindow <link>geg_specialobjects_tabbedwindow
Slider <link>geg_specialobjects_slider
Trend <link>geg_specialobjects_trend
Bar <link>geg_specialobjects_bar
XYCurve <link>geg_specialobjects_xycurve
FastCurve <link>geg_specialobjects_fastcurve
Axis <link>geg_specialobjects_axis
Table <link>geg_specialobjects_table
PulldownMenu <link>geg_specialobjects_pulldownmenu
OptionMenu <link>geg_specialobjects_optionmenu
</topic>

<headerlevel>
<topic> geg_specialobjects_window
Window
The window object is a frame that displays a graph in a specified area in another graph.
The graph is displayed with or without scrollbars. If is also possible to shift the graph
displayed in the window by executing a command from a push button. You can also display
object graphs for various objects in the database.

Here are some fields of application for the window object

- you have a table like part of the graph the takes to much space. This can be put in
  a window object and by utilizing the scrollbar of the window object you will gain space.
- you want to show information about a database object that already has an object graph.
- it is possible to build a graph with a window object that displays different graph 
  dependent on a set of pushbuttons or menu alternatives. See also TabbedWindow.

<h1> Display a graph in a window object
The window object is found under the Other map in the subgraph palette. Create the object by
middle click in the work area and scale the object to desired size.

<image> geg_fig52.png
<b>Fig Window object

Open the object editor and supply the name of the graph that is to be displayed in 
Window.Filename. Note that the graph is read from $pwrp_exe, and as graphs in window objects
often doesn't have an XttGraph object, they will not be copied automatically from $pwrp_pop
to $pwrp_exe. The copying then has to be done by hand or by a make file.

<image> geg_fig54.png
<b>Fig The object editor for a window object with supplied filename

When the filename is inserted and the file exist on $pwrp_exe the graph will be displayed
in the window object.

<image> geg_fig53.png
<b>Fig Window object with inserted filename

<h1>Display an object graph in a window object
Several database objects have an object graph that is opened from 'Object Graph' in the 
popup menu for the object. Also object graphs can be viewed in window objects by
specifying the name of the graph file. Also the database object that the graph should be
connected to has to be specified in Window.Object.

If the object class is a part of the Proview release, the filename for the object graph is
$pwr_exe/pwr_c_'classname'.pwg. For an Av object this will be $pwr_exe/pwr_c_av.pwg. You 
have to specify the path in the filename as the file is located in the default directory
$pwrp_exe.

If the class reside in a class volume in the project, the filename is 
$pwrp_exe/'classname'.pwg. In this case there is no need to specify the path.

In the example below the object graph for the Av object H1-Av1 is displayed. The graph is
scaled to 3/4 of the original size by setting Window.Scale to 0.75.

<image> geg_fig55.png
<b>Fig Attributes for a window object displaying an object graph

<image> geg_fig56.png
<b>Fig  Object graph for an Av displayed in the window object

<h1>Shift between two different graphs
There is an xtt command that displays a specific graph in a window object. By setting this 
command in a number of pushbuttons you can shift between different graphs in one window
object. The function is similar to a TabbedWindow. The difference is that you have a more
free layout of the push buttons, and that there is no limitation in the number of graphs
that can be displayed.

The command is

<c>set subwindow 'graphname' /name= /source= [/object=]

where grapname is the name of the graph that contains the window object. In /name the name
of the window object is specified, and in /source the filename of the graph that is to be
displayed. /object is used when an object graph is displayed, and specifies the database
object the graph should be connected to.

In the following example, the object graphs for a number of Dv are displayed in a window 
object. You can insert a start graph in Window.FileName, but you can also let the window
object be empty until one of the buttons are activated. In this case you should insert
"_no_" in Window.FileName to avoid and error output.

The graph containing the window object is saved with the name 'dvdisplay'. It also contains
6 pushbuttons of type CommandButtonCenter. The window object is named 'DvWindow' by
activating Edit/Change Name in the menu. In the figure below the object editor for a 
pushbutton is viewed with the command inserted. Note that the filename has to be surrounded
by quotation marks as it contains a slash.

<image> geg_fig58.png
<b>Fig Command 'set subwind' in a pushbutton

The final graph will look like this with Dv4 selected.

<image> geg_fig57.png
<b>Fig The object graph for Dv4 is displayed after a click on the Dv4 button
</topic>

<topic> geg_specialobjects_tabbedwindow
TabbedWindow
TabbedWindow is a Window object that allows multiple graphs to be viewed in one window,
using tabs to switch between graphs. For each tab a specific graph is stated, and when
the graph is activated the stated graph is displayed in the window.

You can display object graphs or other graphs in a tabbed window. We will have a look at 
how to display a set of object graphs, as in the window example above.

<image> geg_fig64.png
<b>Fig A tabbed window object

We will have 6 tabs and each tab will display the object graph of a Dv object. When the 
TabbedWindow is created, we open the object editor and set Folder.NumberOfFolder to 6.
We also increase the tab size by changing Folder.HeaderHeight to 1. Then we insert FileName,
Text and Object for the 6 first tabs. Filename is the filename of Dv object graph, ie
$pwr_exe/pwr_c_dv. In Text we set Dv1, Dv2 etc and Object contains the object name of the 
different Dv objects, H1-Dv1, H2-Dv2 etc. We also increase the text size of the tabs by
selecting the window object and set TextSize to 14 in the tool panel. 

<image> geg_fig65.png
<b>Fig The object editor of the tabbed window


</topic>

<topic> geg_specialobjects_slider
Slider
A slider is a movable object connected to an analog signal in the database. The position
of the slider states the value of the signal. The slider can be moved either horizontal
or vertical between two endpoints. The position of the endpoints can be specified by two
different methods. Either by placing a special background object of type SliderBackground,
or by specifying the coordinates for the endpoints in the object editor.

<h1>Slider with background object
Under the Slider map in the subgraph palette you will find slider and slider background
objects. We select a SliderBackground1 and place a Slider1 on top of it. To get a 
horizontal slider we rotate both object 270 degrees.

<image> geg_fig59.png
<b>Fig Slider with background object

The next step is to connect the slider to an analog signal in the database. We select the
Av object H1-Av in the plant hierarchy and click with Ctrl+Doubleclick MB1 on the slider
object. We also have to state the range in signal units that the slider movement corresponds
to. The signal range is 0 - 1000 and we set Slider.MaxValue to 1000 in the object editor.
Note that we don't have to set the min and max position as they are fetched from the slider
background object.

<image> geg_fig60.png
<b>Fig The range for the signal is stated in Slider.MinValue and Slider.MaxValue

<h1>Slider without background object
For a slider without background object you have to state the direction of the slider movement
and the min and max position of the movement.

<image> geg_fig61.png
<b>Fig Slider without background object

We create a slider of type Arrow2 that is to be moved along an axis with a scale of range
0 - 100. 100 is positioned on the y-coordinate 0, and 0 is positioned on the y-coordinate 30.
The slider should be placed on the position with the lowest y-coordinate, which is at the
value 100 on the scale. Then we should state the movement range of the slider and measure 
the coordinate at the top of the slider object. This gives the y coordinates -1 in the upper
position of the slider, and 29 in the lower position. We insert these coordinates in 
Slider.MinPosition (-1) and Slider.MaxPosition (29). We also set Slider.Direction to Up as
a motion upwards in the graph will give increasing signal value.

<image> geg_fig62.png
<b>Fig The object editor of the slider

A horizontal slider is placed on the lowest x-coordinate, that is in the rightmost position
in the graph. In the example below Slider.Direction is set to Left.

<image> geg_fig63.png
<b>Fig Horizontal slider

</topic>

<topic> geg_specialobjects_bar
Bar
A bar displays the value of an analog signal. The bar is found under the Analog map in the 
subgraph palette.

<image> geg_fig68.png
<b>Fig Bar

The bar is configured by connecting it to an analog signal, and insert the range for the
bar in Bar.MinValuie and Bar.MaxValue. The axis object in the figure is not a part of the
bar object.

<image> geg_fig67.png
<b>Fig Bar object attributes

If the bar is a part of an object graph, the range can differ between different instances
of the database object that the graph shows. It is then possible to connect 
Bar.MinValueAttr and Bar.MaxValueAttr to the attributes in the database that contains the
min and max value for the range of the signal.

Note that a bar also can be accomplished by a rectangle that is grouped and provided with
FillLevel dynamics. The difference is that the bar object has a border line with separate
color between the bar and the background.
</topic>

<topic> geg_specialobjects_trend
Trend
A trend displays a curve of the value of one or two signals. The signals can be analog,
digital or integer. Trend is found under the Analog map in the subgraph palette.

<image> geg_fig66.png
<b>Fig Trend curve

The trend object above is configured with an analog signal. The number of vertical and
horizontal lines has been increased by setting Trend.HorizontalLines and Trend.VerticalLines
to 9. The axes are not included in the trend object, but has to be created with axis objects.
The vertical axis has the range 0-100 as Trend.MinValue1 is 0 and Trend.MaxValue1 is 100.
The time axis range is 50 s as Trend.ScanTime is 0.5 and the number of stored points, 
Trend.NoOfPoints is 100.

<image> geg_fig67.png
<b>Fig Attributes for a trend object

If the trend is a part of an object graph, the range can differ between different instances
of the database object that the graph shows. It is then possible to connect 
Trend.MinValueAttr and Trend.MaxValueAttr to the attributes in the database that contains the
min and max value for the range of the signal.
</topic>

<topic> geg_specialobjects_axis
Axis and AxisArc
An axis object draws a scale with a specified range. Axis objects don't have any dynamics
and the scale is fix. There are two variants, a straight axis and a circular or elliptic axis.

<h1>Straight axis
A straight axis is an Axis object fetched from the Analog map and scaled to desired size.
The size of the digits are adjusted from the TextSize menu in the tool panel. The range of
the axis is determined by MinValue and MaxValue that in the example below are set to 0 and 50.
If the scale should be in the opposite direction you shift the values in MinValue and 
MaxValue. It is not required that MaxValue should be greater than MinValue.

<image> geg_fig70.png
<b>Fig Straight axis

The number of perpendicular lines are stated in the Lines attribute, that is set to 101. As
every tenth line should be a little longer, LongQuotient is set to 10. Every twentieth line 
should be marked with a value, thus ValueQuotient is set to 20.

<image> geg_fig72.png
<b>Fig Attributes of an axis object

It is also possible to affect the format of the values with the Format attribute, and if no
values should be drawn, Format can be cleared. The format should be of type %5.1f where
5 is the total number of characters, decimal point included, and 1 number of decimals.

<h1>Elliptic axis
An AxisArc object is a circular or elliptic axis. The object is scaled to suitable size, 
and the text size is adjusted with TextSize in the tool panel.

The axis consists of an arc, and from the object editor Angle1 and Angle2 can be specified
to control the size and position of the arc. Angle1 is the angle from the horizontal axis
to the start of the arc, and Angle2 is the angle for the extention of the arc.

You can also affect the length of the lines in LineLength. The length is specified in 
relation to the radius, so a LineLength of 0.1 will give a length on the longest lines of
10 % of the radius.

<image> geg_fig71.png
<b>Fig Elliptic axis

<image> geg_fig73.png
<b>Fig Attribute of an axisarc object
</topic>

<topic> geg_specialobjects_table
Table
Table is a lucid disposition of data, organized in rows and columns, often providede with 
headers. Table is found under the Other map in the subgraph palette.

<image> geg_fig76.png
<b>Fig Table without header

The data for one column is usually gathered in an array attribute in the database. There
are a number of classes with arrays of different type, eg AArray100 and AArray500 the 
contains arrays with 100 and 500 elements respectively of type Float32. Corresponding
objects also exist for boolean, integer and strings, DArray, IArray and SArray. In the 
example below data is gathered in 3 AArray100 objects and one SArray100.

<image> geg_fig75.png
<b>Fig Array objects contains table data

If we look at the simple table in Fig Table without header above, two columns are displayed.
The number of columns are stated in Table.Columns. Column1.Attribute and Column2.Attribute
are connected to two array attributes containing that data that is to be displayed in the 
columns, H3-A1.Value and H3-A2.Value. The syntax is H1-A1.Value##Float32#100 which means
that the attribute is an array of type Float32 with 100 elements. You also has to specify
the output format for the values in the columns, by inserting Column1.Format and 
Column2.Format. '%6.1f' means a float value with 6 characters and 1 decimal.

Some other details are modified in table object,
- The font is set to Lucida Sans, by selecting the table, and set Lucida Sans in the tool bar.
- The text size is increased to 12 from Textsize in the tool panel.
- The row height is adapted to the larger text size by setting Table.RowHeight to 0.8.

<image> geg_fig74.png
<b>Fig Table object attributes

The figure below shows a table with a header. Here the Table.HeaderRow is set to 1. The text
size for the header, Table.HederTextSize set set to 12 and Table.HeaderTextBold is set to 0
for normal text.

<image> geg_fig77.png
<b>Fig Table with header

In the table below a vertical scrollbar is added by setting Table.VerticalScrollbar to 1.
Note that the header row is not scrolled but always visible.

The table object displays 3 columns, the first is connected to a string array of type
SArray100.Value, and the format Column1.Format is set to %s. The first column is also marked 
as a header column, by setting Table.HeaderColumn to 1. It implies that the border line
between the first and second column is a little thicker. It also affects the horizontal
scrolling which we will see in the next example.

<image> geg_fig78.png
<b>Fig Table with vertical scrollbar and header column

The figure below shows how a header column works with a horizontal scrollbar. The horizontal
scrollbar is viewed when Table.HorizontalScrollbar is set to 1. Note that the scrollbar
does not cover the first column. The first column is always visible.

<image> geg_fig79.png
<b>Fig Table with horizontal scrollbar and header column

<h1>Table displaying objects of the same type
Now we will look at an example where the data is not organized in arrays, but in a number
of objects of the same class. Under H3-Data in the plant hierarchy there is a number of
objects of class Thing. Thing has the attributes Length, Height and Width. We want to show
the content of all the Thing objects in a table, with one object on each row. To do this
we have to create an array of type Objid that contains the identity of each object that is
to be displayed. Thus we create an object of type OidArray and insert the identities of all
Thing objects.

<image> geg_fig82.png
<b>Fig The objects that will be displayed to the left, an array of the objid to the right

We create a table with four columns. The first column will show the name of the object, The
second the Length attribute, the third Width and the fourth Height. The table is configured
by connecting the array with the object identities to Column1.Attribute. In Column2.Attribute
'$header.Length##Float32' is stated. $header points at the object displayed in the same row
in the header column, and the Lengh attribute of this object will be displayed in this column.
In the same way we state '$header.Width##Float32' in Column3.Attribute and 
'$header.Height##Float32' in Column4.Attribute.

<image> geg_fig80.png
<b>Fig The attributes of the table columns

The result is shown in the figure below. In the first column the name of the objects is 
displayed, and in the same row the content of the object.

<image> geg_fig81.png
<b>Fig Table showing the object name and the content of the objects

<h1>Table with selection function
Sometimes you want to be able to select a cell in a table, and execute something in the plc
program with the selected data or object. You do this by connecting a boolean array to the
attribute SelectAttribute for a column. In the example below the array H3-Select1.Value is
connected to Column1.SelectAttribute.

<image> geg_fig83.png
<b>Fig A selection array is supplied for the first column

The first column will now be click sensitive, and the selected cell will be marked with a
distinctive color stated in Table.SelectColor.

<image> geg_fig84.png
<b>Fig The fourth row in the first column is selected

The element in the array that corresponds to the selected object will be set to 1. In the 
figure above, the forth row is selected, which implies that the fourth element in the select
array will be set, ie H3-Select1.Value[3].

<image> geg_fig85.png
<b>Fig The corresponding array element of the selected row is set
</topic>
</headerlevel>

<topic> geg_dynamics
Dynamic and action
A process graph has basically two tasks, to show the status of the process to the operator,
and to make it possible for the operator to affect the process.

To show the status of the process you insert dynamics in the graphs. The dynamic can be to

- change the color of an object <link>geg_dynamic_color
- make objects invisible or insensitive <link>geg_dynamic_invisible
- draw texts <link>geg_dynamic_text
- change the shape of an object <link>geg_dynamic_shape
- show analog value <link>geg_dynamic_analog
- move, scale or rotate objects <link>geg_dynamic_move
- Sound and commands <link>geg_dynamic_misc

To make it possible for the operator to affect the process, you insert actions to objects
in the process graph. By adding action to an object it can also be possible for the operator
to gain more information about the object, from a popup menu or by opening additional graphs
or curves. An action can be

- set values from pushbuttons <link>geg_action_button
- popup menu <link>geg_action_popupmenu
- open graphs <link>geg_action_opengraph
- execute commands <link>geg_action_command
- tooltip <link>geg_action_tooltip
- help texts <link>geg_action_help
- input focus <link>geg_action_inputfocus

</topic>

<headerlevel>
<topic> geg_dynamic_color
Change the color of an object
<h1>Shift between two colors
We will look at how to change the color of an object dependent on a digital signal in the
database. There are a number of different dynamics available, DigLowColor, DigColor,
DigError and DigWarning. We will start with a DigLowColor example.

DigLowColor shifts bewteen two colors, the first is the one you apply to the object in the
editor, and this will be the color when the signal is high. The second color is specified in
DigLowColor.LowColor. We will draw an orange indicator, that should be orange when the 
signal is high, and dark gray when the signal is low. Thus we draw the indicator with orange
color in the editor, and set DigLowColor.Color to dark gray.

We begin by drawing a circle, and fill it with orange color. We also set the gradient to
GradientGlobe.

<image> geg_fig86.png
<b>Fig Orange indicator

We create an additional frame with a metallic look to the indicator by drawing a somewhat 
larger circle with gray fill color. On the frame, fixcolor in the object editor is set to 1, 
as the frame should not change color with the indicator lamp. We also set 3D and select the 
gradient DiagonalDownTube.

<image> geg_fig89.png
<b>Fig Indicator frame

From the object editor gradient_contrast is increased to 8 and shadow_width to 9.

<image> geg_fig88.png
<b>Fig Fixcolor is set on the frame

To be able to set dynamics we group the two circles. When we open the object editor for the
group the attribute DynType is available and we select DigLowColor. We set DigLowColor.Color
to a dark gray tone and connect DigLowColor.Attribute to a Dv, H1-Dv1.

<image> geg_fig87.png
<b>Fig Dynamic DigLowColor

The result is shown in the figure below. When the signal is high, the indicator is orange,
and when the signal is low, the indicator is dark gray.

<image> geg_fig158.png
<b>Fig Indicator with low signal to the left and high to the right

The dynamic type DigColor is similar to DigLowColor, and it could also be used in this
example. The difference is that the function of the signal is inverted. In DigLowColor you
specify the color the object will get when the signal is low, while in DigColor you specify
the color the object will get when the signal is high.

<h1>Shift between several colors
We will now see how you can shift between several colors. We start with the indicator in the
example above and add the dynamic DigColor to DynType. In the object editor we now have the 
attributes DigColor.Attribute and DigColor.Color. DigColor.Attribute is connected to a signal 
in the database, H1-Dv2, and in DigColor.Color the color for high signal is stated. We insert
a blue color.

<image> geg_fig90.png
<b>Fig A third color added with DigColor

The indicator will now shift between three different colors. DigLowColor shifts as before
between dark gray and orange dependent on H1-Dv1, and DigColor sets blue color when H1-Dv2
is hign. Note that DigColor has higher priority than DigLowColor. You can see this in the 
object editor where the dynamics are ordered in priority order with highest priority at the
top and lowest priority at the bottom. The higher priority for DigColor implies that when
H1-Dv2 is high, the indicator is blue regardless of the value of H1-Dv1.

<image> geg_fig91.png
<b>Fig The indicator is orange when H1-Dv1 is high and blue when H1-Dv2 is high

We will now add yet another color and study the Instance function. Some dynamic and action
types can occur in several copies, or several instances on the same object. For DigColor
this means that when we add yet another instance, you can set yet another color on the 
object. As there are 32 instances available you can set 32 different colors, where each
color is connected to a signal in the database. 

You add a DigColor instance by opening DigColor.Instance and mark instance 2. Now the
attributes for this instance are displayed, DigColor2.Attribute and DigColor2.Color. We
Connect DigColor2.Attribute to the signal H1-Dv3 and state a green color in DigColor2.Color.
Note that instances with higher instance number has higher prioriy, ie H1-Dv3 will color
the indicator green regardless of the value of H1-Dv1 and H1-Dv2.

<image> geg_fig92.png
<b>Fig A fourth color is added by DigColor instance 2

The result is displayed in the figure below. You can now shift between four different colors.
Beyond the three previous, dark gray, orange and blue, the indicator is now colored green when
H1-Dv3 is high.

<image> geg_fig93.png
<b>Fig The indicator with four different colors

<h1>Colors for warning and error
In Proview the colors yellow and red are consistently used for warning and error respectively.
There are two types of dynamic, DigWarning and DigError, that sets yellow and red color.
The advantage compared to DigLowColor or DigColor is that you don't have to specify the color.
You just have to connect the dynamic to a digital signal in the database.

We use the indicator in the example above, and color it dark gray. This will be the color
when neither of the signals for DigWarning or DigError is high. We connect 
DigWarning.Attribute to H1-Dv4 and DigError.Attribute to H1-Dv5.

<image> geg_fig94.png
<b>Fig Dynamic DigWarning and DigError

When no signal is set the indicator has the original color dark gray. When H1-Dv4 is set
it is colored yellow, and when H1-Dv5 is set it is colored red. DigError has higher 
priority than DigWarning, thus it is red when H1-Dv5 is set, regardless of the value of
H1-Dv4.

<image> geg_fig95.png
<b>Fig Yellow color for warning and red for error

<h1>Flashing dynamic
To get maximum attention to an object you can set DigFlash dynamic on it. DigFlash means
that the object will flash between two colors, when a signal is high. The flash rate equals 
the scan time for the object. If Cycle is Slow, the flashing will be done with ScanTime for 
the graph, and if Cycle is Fast with FastScanTime.
 
We set DigFlash dynamic to the indicator and can now state two colors that the object will
flash with, DigFlash.Color and DigFlash.Color2. We set DigFlash.Color to red and 
DigFlash.Color2 to black, and connect DigFlash.Attribute to the signal H1-Dv6.

<image> geg_fig96.png
<b>Fig DigFlash dynamic

When the signal H1-Dv6 is low the indicator has the original color dark gray. When H1-Dv6
is high it starts to flash with the colors red and black.

<image> geg_fig97.png
<b>Fig The indicator flashes with red and black when the signal is high

<h1>Change the color of an analog signal
Now we will look at  how to change the color of an object dependent on the value of an
analog signal. There are to different types of dynamic, FillColor and AnalogColor, that
are connected to analog signals. FillColor will color a portion of an object and to what
extent depends on the signal value. Analog color shifts the color of an object when the
signal value goes below or beyond a limit value.

<h1>Color up to a certain level
The dynamic FillColor colors an object up to a certain border line dependent on an analog
signal. It is similar to the bar object, with the difference that it can be applied to an
object of arbitrary shape. We will apply FillColor to a tank object fetched from 
Hydraulics/Tank2 in the subgraph menu.

<image> geg_fig102.png
<b>Fig A tank

The tank doesn't have any default dynamic. We mark FillColor in DynType and connect it to
the Av object H4-Av1. We also set a dark gray color in FillLevel.BackgroundColor.
FillLevel.MinValue and FillLevel.MaxValue specifies the range of the signal. The default
range is 0 - 100, implying that when the signal value is zero, the tank will be colored
with the background color, and when the value is 100, is is colored with the original blue 
color we have set in the editor.

<image> geg_fig98.png
<b>Fig Tank with FillColor dynamic

In the figure below H4-Av1 has the value 70 and the tank is filled to this level.

<image> geg_fig99.png
<b>Fig The tank filled to a certain level

The tank can be filled in other directions by modifying FillColor.Direction. If the FillColor
dynamic is used in an object graph, also the range can be connected to attributes for min
and max values in the database.

<h1>Shift color beyond or below a certain limit
Often you want to display that an analog signal has gone beyond or below a certain value.
Suppose that in the tank example above, the level normally should be below 80, and if it 
goes beyond 90 the situation is critical. We will use the dynamic AnalogColor to change the 
color of the tank when the value passes the two limit values.

First we want to color the tank yellow when the signal H4-Av1 goes beyond 80. We add
AnalogColor to DynType and now we can set AnalogColor.Limit to 80. The type of limit value,
AnalogColor.LimitType is already GreaterThan, so we don't need to change it. We must though
specify the yellow color that will be set when the signal is greater than 80, and insert a
yellow tone in AnalogColor.Color.

To be able to add yet another limit value at 90, we add instance 2 in AnalogColor.Instances.
Now the attributes for AnalogColor2 appears and we set AnalogColor2.Limit to 90 and 
AnalogColor2.Color to a red color. Note that you don't connect a new signal to instance 2,
but all instances uses the same signal.

<image> geg_fig100.png
<b>Fig AnalogColor dynamic

The result is viewed in the figure below. As long as the value of H4-Dv1 is less than 80 the
tank is blue. When the value is over 80, it's yellow, and when 90 is passed it's red.

<image> geg_fig101.png
<b>Fig At 80 the color is shifted to yellow, and at 90 to red

By setting LimitType to LessThan you can also add limit value for minimum levels, for example
color the tank yellow if the value is less than 20, and red if the value is less than 10. 

</topic>

<topic> geg_dynamic_invisible
Making objects invisible or insensitive
To make objects invisible or dimmed you use the dynamic Invisible. To demonstrate this we
create a pushbutton from Button/Button2MetalFrame in the subgraph menu.

<image> geg_fig103.png
<b>Fig A pushbutton

<h1>Invisible
The pushbutton has as default the attributes for DigToggle, and by adding Invisible to 
DynType we also see the attributes for Invisible. By connecting a digital signal to 
Invisible.Attribute the pushbutton will be invisible when the signal is high.

<image> geg_fig104.png
<b>Fig Invisible attributes

We connect Invisible.Attribute to H1-Dv2, and the result is that when H1-Dv2 is high the 
pushbutton is invisible.

<h1>Dimmed
If you only want the pushbutton to be insensitive for click and dimmed, you set 
Invisible.Dimmed to 1.

<image> geg_fig105.png
<b>Fig Invisible.Dimmed is set for dimmed dynamic

When H1-Dv2 goes high the pushbutton is no longer sensitive for mouse clicks. This is marked
by the drawing the button dimmed.

<image> geg_fig106.png
<b>Fig The pushbutton in dimmed state to the left
</topic>

<topic> geg_dynamic_text
Draw texts
To draw a dynamic text, you have to use a subgraph that contains an Annotation. For example
almost all pushbuttons contains an Annotation to be able to print a text on the button. Also
Value and InputValue subgraphs contains an annotation.

An annotation is a place in the subgraph where a text can be printed. The text either be
specified in the editor, or be supplied by some different types of dynamics that is connected
to signal in the database and will modify the text in runtime.

The different types of text dynamics are
- DigText, where you shift between two different texts dependent on a digital signal.
- AnalogText, where you shift between several different texts dependent on an analog signal.
- Value. When connected to a string attribute in the database, the string value will be 
  displayed.

<h1>Shift between two texts on a digital signal
The dynamic DigLowText shifts between two texts dependent on a digital signal.
We create a pushbutton of type ButtonRoundMetalFram and opens the object editor.

<image> geg_fig107.png
<b>Fig Pushbutton with an annotation

In Text you can specify a text that is diplayed on the pushbutton, and we insert the text
'Off'. By adding the dynamic DigText, the text specified in Text will be replaced by the
text in DigText.LowText when the signal we connect to DigText.Attribute is low. We insert
the text 'On' in DigText.LowText and connect DigText.Attribute to the Dv H1-Dv1. We also 
connect the same signal to ToggleDig.Attribute to easy be able to change the value by clicking 
on the pushbutton.

<image> geg_fig108.png
<b>Fig Dynamik DigLowText

The dynamic will now work in this way. When H1-Dv1 is low the text 'On' is displayed on the 
button, this is the text in DigText.LowText, and when the signal is high the text 'Off' is
displayed, this is the text we inserted in the Text attribute.

<image> geg_fig109.png
<b>Fig Low signal to the left and high signal to the right

DigText has sevral instances and for each instance a text can be specified and it will be
connected to a digital signal. Note that the function is somewhat different for the other
instances. For the first instance you specify a LowText, ie a text displayed when the value is
low. For the other instances you specify a HighText, ie a text that is displayed when the 
signal is high.

<h1>Shift between several texts dependent on an analog signal
For the dynamic AnalogColor you can specify up to 32 different texts, and which of the texts
that is printed depends on the value of analog signal that is connected to the dynamic.

We use a ValueLargeCenter to demonstrate the dynamic.

<image> geg_fig110.png
<b>Fig A ValueLargeCenter subgraph

ValueLargeCenter has Value dynamic as default, and we remove this by removing Inherit in
DynType, and mark AnalogText instead.

In AnalogText.TextMask you mark the texts that is to be used. We will shift between four
different texts and mark 2, 3 and 4. The texts 'Low level, 'Normal level', 'High level' 
and 'Very high level' is filled in in the text attributes. We keep the enumeration values,
which implies that AnalogText.Text1 will be displayed when the signal is 0, AnalogText2
when the signal is 1 etc. Actually the text will shift at the value 0.5, 1.5, and 2.5. If the
signal value is larger than 3.5 the annotation will be emptied.

We also connect the Av H4-Av1 to AnalogText.Attribute.

<image> geg_fig111.png
<b>Fig The Value dynamic replaced by AnalogText

In the figure below the value object is displayed when H4-Av1 has the values 0, 1, 2 and 3
with the 0 value at the bottom.

<image> geg_fig112.png
<b>Fig Text at different values of H4-Av1

<h1>Display the text of a string attribute
To display the content of a string attribute in the database you use the Value dynamic. As
in the previous example we create a ValueLargeCenter object.

<image> geg_fig110.png
<b>Fig A ValueLargeCenter subgraph

The subgraph has Value as default dynamic, and we only have to connect Value.Attribute to
a string attribute, and insert the string format '%s' in Value.Format. We connect 
Value.Attribute to the Sv object H1-Sv.

<image> geg_fig113.png
<b>Fig Value dynamic

To show the result we insert the text 'Starting up' in H1-Sv1 in Xtt.

<image> geg_fig114.png
<b>Fig Set a text in the Sv attribute

The text will be displayed in the Value object.

<image> geg_fig115.png
<b>Fig The text displayed in the value object
</topic>

<topic> geg_dynamic_shape
Modify the shape
In many cases the best way to show the state of the process is to change the shape of an 
object. It can be a gate that is viewed open or closed, or a padlock that is locked or
unlocked. This can be achieved by using subgraphs with two pages or more.

One example of an subgraph with several pages is Smiley.

Subgraphs with several pages are handled by the dynamic types DigShift, AnalogShift and
Animation.

<image> geg_fig116.png
<b>Fig Example of an subgraph with several pages

- DigShift shifts between two different pages dependent on a digital signal.
- AnalogShift shifts between several different pages dependent on an analog signal.
- Animation plays a number of pages with a certain speed so you get the impression of
  motion.

<h1>Shift between two pages
The dynamic DigShift can be used for a subgraph with several pages. It is connected to a
digital signal and shifts between the first and the last page dependent on if the signal
is high or low.

We use the Smiley subgraph to demonstrate DigShift. Smiley has the dynamic AnalogShift as
default, and we first have to remove this by resetting Inherit in DynType. Instead we 
set DigShift in DynType, and connect the signal H1-Dv1 to DigShift.Attribute.

<image> geg_fig117.png
<b>Fig Dynamic DigShift selected

The result is displayed in the figure below. When the signal is low the first page of the 
subgraph is viewed, and when the signal is high the last page is viewed.

<image> geg_fig118.png
<b>Fig Low signal to the left and high signal to the right

<h1>Shift between several pages
AnalogShift is connected to an analog signal, and can shift between several pages. The value
of the analog signal will specify the index for the displayed page. When signal value is 0
the first page is displayed, when the value is 1 the second page is displayed etc.

The subgraph Smiley has AnalogShift as default. All we have to do is to connect it to an
analog signal. We connect it to H4-Av1.

<image> geg_fig119.png
<b>Fig Dynamic AnalogShift

Smiley contains 6 different pages. When the signal is 0 or less than 0, the first page is
displayed, and when the signal is 1 the second page is diplayed etc. When the signal is 5 or
greater than 5, the last page is displayed.

<image> geg_fig120.png
<b>Fig The value of the signal is 0 to the left and is incremented by 1 for each picture

<h1>Animation
TODO...

<image> geg_fig121.png
<b>Fig Animation to open/close a padlock
</topic>

<topic> geg_dynamic_analog
Display analog values

<h1>Display analog value as figures
To display analog values as figures you use the dynamic Value. Value is connected to an
analog signal and the value is converted to suitable format by the format specification.

The value dynamic can be used on subgraphs that contains an annotation, ie a place where
a text can be printed. One example of such a subgraph is ValueLargeCenter.

<image> geg_fig122.png
<b>Fig ValueLargeCenter

We create a ValueLargeCenter and connect it to the analog signal H4-Av1. We also have to 
specify the format in Value.Format. '%f' is the format for a float, and you can also specify
the number of characters and decimals in the figure. The format '%7.2f' states that the format
is 7 characters with the decimal point, and two of these are decimals.

<image> geg_fig123.png
<b>Fig Value dynamic with format specifier

The result is shown in the figure below, The analog value is written with two decimals.

<image> geg_fig124.png
<b>Fig Value dynamic


Note that the Value dynamic also can be used to show the content of other types of signals,
eg integer, string, time etc.

By creating several instances of Value dynamic for one object, it is possible to show 
serveral analog value is the same object. This requires that the subgraph contain several
annotations.

Analog values can also be displayed in the shape of curves and bars. This is described in the
chapter 'Special objects'.

<option> printdisable
Trend <link> geg_specialobjects_trend
Bar <link> geg_specialobjects_bar
<option> printenable

</topic>

<topic> geg_dynamic_move
Move, scale and rotate objects

<h1>Move an object
To move and scale an object you use the dynamic Move. To begin with we will look at how to 
move an object. An object can be moved in x and y direction, and for each direction an analog
signal is connected to the object, specifying the movement relative to the original position.
The signal value can be transformed to a movement in Ge coordinates by one factor in each
direction (Move.XFactor and Move.YFactor) and one offset in each direction (Move.XOffset and
Move.YOffset).

In this example we will move a rectangle in the x direction. We draw the rectangle and create 
a group with only the rectangle.

<image> geg_fig125.png
<b>Fig A rectangle

When the rectangle is grouped, we can set Move in DynType and the attributes for Move is
displayed in the object editor. As we are going to move in x direction, we connect
Move.XAttribute to the signal H4-Av1 in the database. We measure the range where the rectangle
is to be moved, and concludes that when the signal varies between 0-100 the rectangle should
be move 20 Ge units in the graph. By placing the rectangle on the zero point, we don't have
to specify any offset, but we have to scale down the signal value by 20/100 = 0.2 and this
value is insert into Move.XFactor. In the example we have also drawn an x axis to show the 
magnitude of the movement.

<image> geg_fig126.png
<b>Fig Move dynamic on the rectangle

The result is that when the signal is 0, the rectangle is still positioned in the original
position. At the value 60 the rectangle is moved 12 units, se the figure below, and when
the value is 100 the rectangle is moved 20 units.

<image> geg_fig127.png
<b>Fig The rectangle moved 12 Ge units in x direction

<h1>Scale an object
The move dynamic can also be used to scale an object. The scale can be performed in x and
y direction, and for each direction you connect an analog signal specifying the magnitude 
of the scaling.

We use the rectangle in the example above, and add scale attributes to the Move dynamic.
Move.ScaleXAttribute is connected to the signal H4-Av2. We also have to calculate a scale
factor. The rectangle has the width 2 units and with a scale factor of 0.1 a signal value
of 100 will result in a width of 20 units ( 0.1 * 100 * 2 units).

<image> geg_fig128.png
<b>Fig Signal and scale factor stated

The result is that when the signal value is 0, the rectangle has no width at all, and is
drawn as a line. At the signal value 25 is looks as in the figure below, the rectangle is
scaled 2.5 times, and when the signal value is 100 the rectangle is scaled 10 times and
covers the whole x axis.

<image> geg_fig129.png
<b>Fig The signal value 25 results in 2.5 times scaling

<h1>Rotate an object
To rotate an object you use the dynamic Rotate. Rotate is connected to an analog signal that
contains the rotation in degrees.

Rotate has certain limitations as rectangles and ellipses only can be rotated in steps of
90 degrees. For that reason you preferably use polylines, lines an circles with Rotate.

We draw a simpel needle with an arc and a polyline. We group the objects and set Rotate in
DynType. We also draw a circular axis with an AxisArc object.

<image> geg_fig130.png
<b>Fig Needle with rotation dynamic

The needle is connected to the anlog signal H4-Av1. We also have to specify the point on 
which the object will turn. In this case it is the center of the arc that has the x
coordinate 9 and y coordinate 1. The turning point is inserted into Rotate.x0 and Rotate.y0.

The axis we have drawn has the range -100 - 100, which is the range of the signal H4-Av1. This
has to be converted to degrees and the corresponding rotation is -90 - 90 degrees, ie the 
scale factor is 0.9. We insert 0.9 into Rotate.Factor.

<image> geg_fig131.png
<b>Fig The needle is connected to an analog signal and the scale factor is set to 0.9

The result is displayed in the figure below.

<image> geg_fig132.png
<b>Fig The value 40 will cause a rotation of 36 degrees
</topic>

<topic> geg_dynamic_misc
Sounds and commands

TODO...
</topic>

<topic> geg_action_button
Set value with push buttons

<h1>Set a digital value
The Action SetDig sets the value of a digital signal to 1 when you click on an object.

To demonstrate this we create a button from a rectangle. By setting 3D and increase 
shadow_width to 15 the rectangle will get a characteristic button look. Furthermore we add
the gradient DiagonalLowerRight with gradient_contrast 1 to increase the 3D effect. Finally
se create a group of the rectangle and are now able to specify an Action.

<image> geg_fig133.png
<b>Fig A rectangle shaped as pushbutton

To set set a digital signal to 1 when pressing the button, we set SetDig in Action.
This means that is the signal value is 0, the value will be set to 1. If the value already
is 1 there will be no change.

We connect SetDig.Attribute to the signal H1-Dv1.

<image> geg_fig134.png
<b>Fig Action SetDig on the button

The result is that when we click the button H1-Dv1 is set to 1.

It is possible to add several instances of SetDig and for each new instance you connect
a new signal that is set to 1 when the button is clicked on. In this way several signals can
be set with one mouseclick.

<h1>Reset a digital value
ResetDig works as SetDig with the difference that the signal value is set to 0.

We set Action ResetDig and connect to the signal H1-Dv1.

<image> geg_fig135.png
<b>Fig Action ResetDig on the button

The result is that when we click the button H1-Dv1 is set to 0.

<h1>Toggle a digital value
With Action ToggleDig you change the value of a digital signal when clicking on the object.
If the value of the signal is 1, it is set to 0, and if the value is 0, it is set to 1.

We connect ToggleDig.Attribute to the signal H1-Dv1.

<image> geg_fig136.png
<b>Fig Action ToggleDig on the button

The result is the the value of H1-Dv1 is inverted when the button is clicked on.

<h1>Set a digital value as long as the buttons in pressed
With Action StoDig you set the value of a digital signal to 1 when the button is pressed, and
reset to 0 when the button is released.

We set Action StoDig on the button an connect to H1-Dv1.

<image> geg_fig137.png
<b>Fig Action StoDig

The result is that when we press the button, H1-Dv1 is set to 1, and when we release the
button H1-Dv1 is set to 0.

<h1>Pushbutton with confirmation
If you add Action Confirm to a pushbutton, a confirmation from the user is required before
the action is executed. When you click the button a popup dialog is displayed where you
either can confirm or cancel. The text in the window is stated in Confirm.Text.

<h1>Set an analog value
To set a value to an analog signal the Action SetValue is used. SetValue is connected to an
analog signal, and when clicking on the object a specified value is set to the signal.

We set Action SetValue on the button, and connect to the Av object H4-Av1. We want to set
the value 4.5 and insert 4.5 into SetValue.Value.

<image> geg_fig138.png
<b>Fig SetValue

The result is that when we click the button the value 4.5 is set in H4-Av1.

Several instances of SetValue are implemented, and for each instance you specify a value and
connect the instance to an analog signal. It is then possible to set different values into a 
number of analog signals with one mouse click.

<h1>Increase/Decrease buttons
With action IncrAnalog you can increase or decrease the value of an analog signal with mouse
clicks. IncrAnalog is connected to an analog signal, and in IncrAnalog.Increment is stated
the amount of the increment or decrement for each click. You can also state minimum and
maximum values for the signal.

We create a ButtonUp and a ButtonDown object from the Pushbutton map in the subgraph palette.

<image> geg_fig148.png
<b>Fig ButtonUp and ButtonDown

Both have SetDig as default. We remove SetDig by unmarking Inherit in Action, and mark
IncrAnalog instead. We connect both buttons to the signal H4-Av1. The ButtonUp button should
increase the value with 1 for each click, and we set IncrAnalog.Increment to 1. ButtonDown
should decrease the value with 1, and we set IncrAnalog.Increment to -1. We also set min and
max values and set IncrAnalog.MaxValue to 10.

<image> geg_fig149.png
<b>Fig ButtonUp to the left and ButtonDown to the right

The result is that when we click on ButtonUp the value of H4-Av1 is increased with 1 for 
each click until the max value 10 is reached. When we click on ButtonDown, the value is
decreased with 1 until the min value 0 is reached.

<h1>Radio buttons
Radio buttons are used when you want to select one alternative from a number of alternatives.
For each alternative you create a radio button and connect it to a digital signal. Then
you group the radio buttons. The action RadioButton work in the way that the signal for a 
radio button that is clicked on will be set, while other radio buttons in the group will be 
reset. This means that at most one alternative is selected, and only one of the signals are 1.

We create four radio buttons of type RadioButtonRelief.

<image> geg_fig150.png
<b>Fig Four radio buttons

They already have the action RadioButton as default. We connect the every radio button to one
digital signal each, H1-Dv1, H1-Dv2, H1-Dv3 and H1-Dv4. Then we group the four radio buttons
and add some suitable texts to describe the alternatives.

<image> geg_fig151.png
<b>Fig The first radiobutton is connected to H1-Dv1

When we open the graph with the radio buttons in the operator environment, we can select
one of the alternatives. The selected one is marked with a black dot, while the other are 
reseted. In the figure below the second alternative is marked, ie H1-Dv1 is 1 while Dv1,
Dv3 and Dv4 is 0.

<image> geg_fig152.png
<b>Fig A radio button is marked

<h1>Checkboxes
Checkboxes are used to mark a number of alternatives in a list. Contrary to radio buttons
several alternatives can be selected concurrently. A checkbox has the action ToggleDig
combined with the dynamic DigShift.

We create for checkboxes of type Checkbox2, and insert descriptive text close by.

<image> geg_fig153.png
<b>Fig Checkboxes

The checkboxes are connected to the signals H1-Dv1, H1-Dv2, H1-Dv3 and H1-Dv4. Note that
both DigShift.Attribute and ToggleDig.Attribute are connected to the same signal.

<image> geg_fig154.png
<b>Fig Object editor for the first checkbox

In the figure below the first and third checkbox are marked, ie H1-Dv1 and H1-Dv3 are set to 
1.

<image> geg_fig155.png
<b>Fig Checkboxes marked

</topic>

<topic> geg_action_popupmenu
Popup menu
With the action PopupMenu you can by right clicking on an object, open a popup menu. The popup
menu is connected to an object in the database, and displays the methods for this object.
The methods viewed depends on how the object is configured in the database, and on which 
methods are configured for this object type.

Let us begin with a simple example where we show the value of an Av object in a Value field.
We create a ValueLargeCenter, and connect it to H4-Av1 and insert the format %7.2f into
Value.Format.

<image> geg_fig122.png
<b>Fig ValueLargeCenter

Now we also add PopupMenu in Action, and insert the Av object into PopupMenu.ReferenceObject.
Note that the references is to the whole object and not to a specific attribute.

We also have to open File/Graph Attributes in the Ge menu and set MB3Action to PopupMenu, as 
the default MB3 action is to close the graph.

<image> geg_fig139.png
<b>Fig Action PopupMenu added

When we now open the graph in the operator environment and right click on the Value field the
popup menu is opened.

<image> geg_fig140.png
<b>Fig The popupmenu

Which methods are present in the popup menu depends on which class the referred object belongs
to and how the object is configured. In the figure below the configuration of the Av object is
displayed, and we can see the attributes DefGraph, DefTrend, HelpTopic, DataSheet,
CircuitDiagram, Photo and Note that all are associated with different methods.

<image> geg_fig141.png
<b>Fig The configuration of H4-Av1

We will now go over some of the alternatives in the popup menu and see how they are configured
or what they depend on.

<b>Graph
For Graph you specify a graph that shows information about the object or about the plant part
where the object is found. The configuration is made by inserting an XttGraph object in the
DefGraph attributes. For H4-Av1 DefGraph is not filled in, and then the graph if fetched from 
the closest ancestor with DefGraph specified. In this case it is the hierarchy object H4 
that has a default graph stated.

<b>Object Graph
Object Graph opens the object graph for the object. The object graph is a graph that displays
information about an object of a specific class. If there is an object graph availabel for 
the present class this alternative is viewed in the popup menu.

<b>Trend
Shows a trend for the object. This requires that a trend is configured with a DsTrend object,
and the trend object is inserted in the DefTrend attribute. DefTrend can also refere to a 
DsFastCurve or PlotGroup object.

<b>History
Opens a curve with process history for the object. This requires that storage of data is 
configured by a SevHist object positioned below the current object in the object tree.

<b>Hist Event
Hist Event displays the alarm and event history for the current object.

<b>Block Events
Block Event opens a dialog where it is possible to block alarms of different priority.

<b>Help
Help displays a help text for the object. Help text are written in a help text file,
$pwrp_cnf/xtt_help.dat, where each text embraces a topic. By inserting a topic into the
attribute HelpTopic, the text for this topic will be displayed when the Help entry in the popup
menu is activated.

<b>Note
With Note you can write a text that is stored in the Note attribute of the object. The Note
text is shown in the object graph of the object.

<b>Open Object
Open Object displays the object attributes and the object content.

<b>RtNavigator
RtNavigator searches the object in the runtime navigator.

<b>Crossreferences
Shows a list with references to the object in plc code and graphs.

<b>Help Class
Help Class opens a help text for the object class.

<b>Photo
Photo displays a photo of the object in the plant. It is configured by inserting an URL to the
photo into the attribute Photo.

<b>DataSheet
If a data sheet for the object is available, you can insert an URL to the data sheet in the
attribute DataSheet.

<b>CircuitDiagram
A URL to a circuit diagram can be inserted into the CircuitDiagram attribut.
</topic>

<topic> geg_action_opengraph
Open a graph
To open a graph by clicking on an object, you normally use the action OpenGraph. You can also
use the Command action with the command 'open graph'.

<h1>Open a graph with a mouse click

We create a pushbutton to open a graph, with a rectangle and a text that is grouped.

<image> geg_fig142.png
<b>Fig Pushbutton to open a graph

<h2>Action OpenGraph
In the first example we set action to OpenGraph. OpenGraph requires that you have configured
an XttGraph object in the database. The XttGraph object is inserted into 
OpenGraph.GraphObject.

<image> geg_fig143.png
<b>Fig Action OpenGraph

If the graph should be able to be opened on different nodes, and you prefer to use local
XttGraph object, you can replace the name of the node object by '$node'.

<c>$node-op-h4_Overview

$node will be replaced by the name of the node object for the current node. You also have to
see to that XttGraph object with the corresponding name exist on all the nodes in question.

<h2>Action Command
It is also possible to open a graph with the action Command and the command

<c>open graph 'graphname' [/width=] [/height=]

The command to open an object graph is

<c>open graph /class /instance=

In this example we have set Command in Action and inserted a command to open the object
graph for the Av object H4-Av1.

<image> geg_fig144.png
<b>Fig Open an object graph

If the action PopupMenu is present and you in addition want to open the object graph when
you click on the object, it is sufficient to add OpenGraph to action. You don't have to
fill in an object, as this will be fetched from PopupMenu.ReferenceObject by default.

<image> geg_fig145.png
<b>Fig Open the object graph when PopupMenu is configured

If you you want to set input focus to a specific input field in the graph when the graph is
opened, you use the command 'open graph /focus'. You also have to specify the name of the
input object that should receive input focus. The name can be set from Edit/Change name in the 
menu.

<c>open graph /object=*-Graphs-SomeXttGraph /focus="TempSetValue"

<h1>Close a graph
To close a graph the action CloseGraph is used.

<image> geg_fig146.png
<b>Fig Pushbutton to close a graph

We create a pushbutton with the text 'Close' and set Action to CloseGraph.

<image> geg_fig147.png
<b>Fig Action CloseGraph

</topic>

<topic> geg_action_command
Execute commands
With action Command you can specify an xtt command that is executed when an object is
clicked on. There are a number of xtt commands to open graph, show curves, call methods etc.
The xtt commands are described in the Operator's Guide. You can also execute scripts with
Command.

In this example we will open a trend curve from a push button.
We create a rectangle, add a suitable text and make a group fo the recangle and the text.

<image> geg_fig156.png
<b>Fig Command pushbutton

In Action we mark Command and in Command.Command we insert the xtt command. We want to open
a trend curve configured with the DsTrend object H4-Av1-Trend, and the command to open the
curve is

<c>open trend H4-Av1-Trend

<image> geg_fig157.png
<b>Fig Command to open a trend

<h1>Execute a script
With a script you can execute several commands at the same time, but you can also read
attributes in the database, test on different conditions and set attributes.

A script is executed with an xtt command consisting of a '@' sign followed by the filename
of the script, for example

<c>@$pwrp_exe/my_script

This will execute the script my_script.rtt_com on the directory $pwrp_exe.

Below is an example of a script that opens the graph g1 if H1-Dv1 is set, else the graph g2 
is opened.

<c>main()
<c>  int sts;
<c>
<c>  if ( GetAttribute( "H1-Dv1.ActualValue", sts))
<c>    open graph g1
<c>  else
<c>    open graph g2
<c>  endif
<c>endmain

</topic>

<topic> geg_action_help
Help and info
It is of course important that an operator quickly and easily can get help on how to handle 
graphs and processes. One way to solve this is to create help and info buttons in the graph.
You can, for example, use the subgraphs ButtonHelp or ButtonInfo. The action type for those are
Help, and you supply a topic in Help.Topic, and any bookmark in Help.Bookmark. The help 
function fetches help text written in the file $pwrp_cnf/xtt_help.dat, and a bookmark makes 
it possible to position in a specific row of the text.
</topic>

<topic> geg_action_inputfocus
Navigate from the keyboard
To enter data and activate objects without using the mouse, you use the action type InputFocus.
If an object has input focus, key events are sent to that object. For a ValueInput object, this
means that you can enter a value, for a pushbutton it means that you can activate it by 
pressing Return.

Focus input is traversed between the objects with the Tab and arrow keys. How the input focus
is traversed, is configured with the attributes NextHorizontal, NextVertical and NextTab.
Here you state the object name of the object that input focus is traversed to by arrow right, 
arrow down and Tab keys.

An object that has input focus is usually marked with a relief that surrounds the object.
</topic>

</headerlevel>
</headerlevel>

<topic> geg_images
Gif and JPEG-images
You insert a gif or JPEG image in the following way. Copy the image file to $pwrp_pop. It is
now displayed under the folder Local/Images in the subgraph palette. Select the picture and
click with MB2 in the working area.

<h2>Change color
The functions to change colors for subgraphs, i.e. color tone, lightness, intensity and color
shift, also applies to image objects.

<h2>Dynamics
You can not set any dynamic on the image object directory. You can though let them be a member
of a group or subgraph, and state dynamics for the group or subgraph. If you dynamically want
to change the color of an image object, you should use a dynamic type that changes the color
tone, e.g. DigTone.
DigTone.
</topic>

<topic> geg_createsubgraph
Draw a subgraph
A subgraph is constructed by drawing base objects in the working area and then save these as a
subgraph. You can also draw other subgraphs in the working area, but these can't have any
dynamics of its own, but will follow the dynamic of the main subgraph. There are two special
objects that are used in subgraphs: connection points and annotations.

Connection points makes it possible to draw connections between objects. They are created
by activating connection point in the tool panel and clicking MB1 in the working area. In the
object editor for the connection point you can state the direction (Direction) of the point,
i.e. the direction a connection out from the point will get. Connectionpoints on the left side
of an object should have Direction Left, on the upper side Up, on the right side Right and on
the lower side Down.

Annotation is a place for a text, that can vary for different instance of the subgraph. They
are created by selecting An in the tool panel and click with MB1 in the working area. When you
create instances of the subgraph, the annotations are displayed as attributes in the object
editor for the subgraphs object as A1, A2 etc., and you kan in this way put texts in the
annotations.

When the subgraph is ready you open 'File/GraphAttributes' and enter 1 in Subgraph. You can
also enter default values for dynamic type or action, e.g. DigLowColor. Then you save it with
a suitable name.

You create instances of the subgraphs by selecting it under the folder Local/Subgraphs in the
subgraph palette, and click with MB2 in the working area.

<h2>A subgraph with several pages
Some types of dynamic, e.g. animations, presume that you hava a subgraph with several pages.
When building an animation you create several pages that slightly differs from each other, 
and the pages are run through, it gives an illusion of movement. The dynamic types DigShift
and AnalogShift also uses different pages, and shifts between pages depending on the value of
a digital or analog signal.

When to draw a subgraph with several pages, you draw the first page in the usual way. When
you have saved it as a subgraph, you activate 'File/Page/Create next page' (Shift+Ctrl/N).
Now the second page is created, which is marked in the title of the window. When the changes
on page 2 is drawn, this is saved and you again activate 'Create next page' to create the
third page etc.

You can shift between pages with 'File/Page/Next page' (Ctrl/N) and 'File/Page/Previous page'
(Ctrl+J). When drawing animations, this is a valuable way to see differences between pages and
evaluate how the animation works.

<h2>Slider
A slider is constructed with two separate subgraphs, one background, and one mobile part. The
slider should always be drawn vertically, i.e. with vertical movement direction.

For the background subgraph you measure the y coordinate for the endpoints of the slider 
movement, and enter the values in the attributes y0 and y1 in 'Graph attributes'. As DynamicType
you state SliderBackground.

For the mobile subgraph you measure the y coordinate for the point that is to be adjusted against
the signal value, and put this in y0. The attribute Slider should be set to 1.

<h2>FillLevel
For a subgraph with dynamic FillLevel, e.g. a thermometer, you often want to set a minimum
and maximum limit for the level. By measuring the coordinates for the maximum and minium level
and put these in y0 and y1 in 'Graph attributes' you achieve this function. The subgraph should
always be drawn in an upright position, so that the level is changed up or down.

<h2>Animation
For subgraphs with dynamic Animation, you select a suitable AnimationSequence in 'Graph
Attributes'. AnimationSequence can be Cyclic, Dig or ForwBack.
</topic>
</chapter>

<chapter>
<topic>geref_windows
Windows

<image> geref_fig18.png

In ge, there are a number of palettes and other windows to choose objects, subgraphs, colors etc.

<h1>Working area
In the working area the graph is edited by clicking and dragging the mouse.

<b>Mouse click     <t><t>Function
Click MB1       <t><t>Select an object, or create a base object.
Shift/Click MB1 <t><t>Add an object to the select list.
Press MB1       <t><t>Select objects in an area, or move objects.
Chift/Press MB1 <t><t>Add objects in an area to the select list.
DoubleClick MB1 <t><t>Open the object editor for the object.
Ctrl/DoubleClick MB1 <t><t>Connect the first attribute in a subgraph object to a rtdb-object.
Shift/Ctrl/DoubleClick MB1 <t><t>Connect the second attribute in a subgraph object to a
                 <t><t>database object.
Shift/DoubleClick MB1 <t><t>Set selected fill color in LowColor in a subgraph object.
Click MB2        <t><t>Create a subgraph object.
Press MB2        <t><t>Create a connection.

<h1>Navigation window

Down to the left there is a navigation window that contains a copy of the working area in
reduced scale. From the navigation window you can scroll (MB1) or zoom (MB2) the graph in the
working area.

<h1>The subgraph palette

The subgraph palette consists of a number of folders with subgraphs. Under the Local/Subgraphs
folder there are subgraphs that is created within the project. Other folder contain subgraphs 
that comes with Proview.

<h1>The color palette

In the color palette there are 300 colors. Here you choose fill color, border color and text
color. The fill color is selected with MB1 and displayed in the left field of the top row of
the palette, bordercolor is selected with MB2 and displayed in the middle field, and text color
is selected with Shift MB1 and displayed in the right field.

The palette is parted in rows with 30 colors in each row. In the first row there are back, white
and intense signal colors, and a collection of gray tones. Then follows a row with the gray 
scale and after that 8 rows with different color tones: yellowgreen, yellow, orange, violet,
blue, seablue and green. Within each color group the 10 first has low saturation, the 10
middle colors a little higher saturation and the 10 last high saturation.

Beneath the color palette there is also a color tone palette in which you can select a color
ton for subgraph objects.

Here is also a reset button to return to the original color of an object.

<h1>Tool panel

The tool panel consists of a number of pushbuttons to create rectangles, circles, lines etc.
There are also functions to rotate and scale, to set line width, font size, to modify color of
subgraphs etc.

<h1>The object and attribute editor
<image> geref_fig19.png

The object and attribute editor makes it possible to enter properties to objects, graphs and
subgraphs.

For an object, this is opend by doubleclicking on the object, for graph or subgraphs, it is 
opened from the menu 'File/Graph attributes'.

Values in the object editor are changed by selecting the attribute and press ArrowRight, or from
the menu with 'Functions/Change value'.

Bitmasks, enum attributes and arrays are opened with ArrowRight or DoubleClick MB1. Checkboxes
are changed with ArrowRight or by clicking in the checkbox.

The fastest way is to select an attributes with ArrowUp and ArrowDown, and use ArrowRight to
open and change the attribute, and ArrowLeft to close the attribute.

<h1>Plant hierarchy
<image> geref_fig20.png

If Ge is started from the navigator, the plant hierarchy is displayed in a window below the
color palette. It is used to connect dynamic objects to signals in the database. You connect a 
subgraph object to a signal by selecting the object (or an attribute in the object) in the plant
hierarchy, and then click with Ctrl/Doubleclick MB1 on the subgraph object (or on an attribute
in the object editor). If there is a second attribute that is to be connected to a signal, you
can connect this in the same way with Shift/Ctrl/Doubleclick MB1.
</topic>
</chapter>

<chapter>
<topic>geref_objects
Objects

An object is created by selecting the object in the tool panel, and draw it in the working area
with MB1. The object is drawn with the current values of fill, fillcolor, border, bordercolor 
and linewidth. If the properties of an existing object is to be changed, you select it and
activate the color, linewidth etc. that should be applied to the object. The object editor for
an object is opened by double clicking on the object. Below is described, under the title
'Properties', the properties that can be changed from the tool panel or color palette, and under
the title 'Attributes' the attributes found in the object editor.

<h1>Baseobjects

Rectangle 	<link> geref_rectangle
Rounded rectangle <link> geref_roundedrect
Circle 		<link>geref_circle
Line 		<link>geref_line
Polyline 	<link>geref_polyline
Text 		<link>geref_text
Annotation 	<link>geref_annotation
Connection point <link>geref_conpoint

<h1>Complex objects
Bar 		<link>geref_bar
Trend	 	<link>geref_trend
Axis 		<link>geref_axis
Window		<link>geref_windowobject
TabbedWindow	<link>geref_tabbedwind
Table		<link>geref_table

</topic>
<topic>geref_rectangle <style>function
Rectangle
<image> geref_fig6.png

A rectangle is created by selecting rectangle in the tool panel and drag with MB1 in the
working area. If you first activate Functions/ScaleEqual a square is drawn.

<h2>Properties
- Fill
- Fillcolor
- Border
- Bordercolor
- Linewidth
- 3D
- Gradient

<h2>Attributes
<b>Attribute      <t>Description
shadow_width   <t>The with of the 3D-shadow in % of width or length (the smallest).
shadow_contrast <t>Contrast of the 3D-shadow. A value in the range 1 - 3.
gradient_contrast <t>Contrast of the gradient. A value in the range 0 - 10.
gradient      <t>Type of gradient.
invisible     <t>The object is invisible but sensitive for mouseclicks. This is used in a
              <t>subgraph to increase the area of sensitivity for the subgraph.
fixcolor      <t>The color is fix. This is used when the object is a part of a subgraph and
              <t>should not be affected by color setting of the subgraph.
relief        <t>Up gives a shadow on the lower side, and Down gives a shadow on the upper side.
disable_shadow <t>Disables the 3D function. This is used when the object is a part of a subgraph
              <t>and the object should not be drawn with 3D although 3D is specified for the 
              <t>subgraph.
disable_gradient <t>Disables the gradient function. This is used when the object is a part of a
              <t>subgraph and the object should not be drawn with gradient although gradient is
              <t>specified for the subgraph.
fixposition   <t>The object can not be moved.
Dynamic       <t>Not implemented.
</topic>

<topic>geref_roundedrect <style>function
Rounded rectangle
<image> geref_fig7.png

A rectangle with rounded corners are created by selecting rounded rectangle in the tool panel
and drag with MB1 in the working area. If you first activate Functions/ScaleEqual a square is
drawn.

<h2>Properties
- Fill
- Fillcolor
- Border
- Bordercolor
- Linewidth
- 3D
- Gradient

<h2>Attributes
<b>Attribute      <t>Description
round_amount   <t>The amount of the rounded corners in % of length or width (the smallest).
shadow_width   <t>The with of the 3D-shadow in % of width or length (the smallest).
shadow_contrast <t>Contrast of the 3D-shadow.
relief        <t>Up gives a shadow on the lower side, and Down gives a shadow on the upper side.
gradient_contrast <t>Contrast of the gradient. A value in the range 0 - 10.
gradient      <t>Type of gradient.
disable_shadow <t>Disables the 3D-function. Is used when the object is a part of a subgraph
              <t>an not should be drawn with 3D when 3D is chosen for the instance of the 
              <t>subgraph.
disable_gradient <t>Disables the gradient function. This is used when the object is a part of a
              <t>subgraph and the object should not be drawn with gradient although gradient is
              <t>specified for the subgraph.
fixposition   <t>The object can not be moved.
Dynamic       <t>Not implemented.
</topic>

<topic>geref_circle <style>function
Ellipse
<image> geref_fig8.png

An ellipse is created by selecting circle in the tool panel and drag with MB1 in the working
area. With angle1 and angle2 a segment of the circle is drawn. If you first activate
Functions/ScaleEqual a circle is drawn.

<h2>Properties
- Fill
- Fillcolor
- Border
- Bordercolor
- Linewidth
- 3D
- Gradient

<h2>Attributes
<b>Attribute      <t>Description
angle1       <t>Angle from the x-axis in degrees to the start of the segment.
angle2       <t>Angle in degrees that states the size of the segment.
shadow_width   <t>The with of the 3D-shadow in % of width or length (the smallest).
shadow_contrast <t>Contrast of the 3D-shadow.
gradient_contrast <t>Contrast of the gradient. A value in the range 0 - 10.
gradient      <t>Type of gradient.
relief        <t>Up gives a shadow on the lower side, and Down gives a shadow on the upper side.
fixcolor      <t>The color is fix. This is used when the object is a part of a subgraph and
              <t>should not be affected by color setting of the subgraph.
disable_shadow <t>Disables the 3D-function. Is used when the object is a part of a subgraph
              <t>an not should be drawn with 3D when 3D is chosen for the instance of the 
              <t>subgraph.
disable_gradient <t>Disables the gradient function. This is used when the object is a part of a
              <t>subgraph and the object should not be drawn with gradient although gradient is
              <t>specified for the subgraph.
fixposition   <t>The object can not be moved.
Dynamic       <t>Not implemented.
</topic>

<topic>geref_line <style>function
Line
<image> geref_fig10.png

A line is created by selecting line in the tool panel and drag with MB1 in the working area.
By activating Functions/MoveRestrictions/Horizontal or Vertical you draw horizontal or
vertical lines.

<h2>Properties
- Border
- Bordercolor
- Linewidth
- Linetype

<h2>Attributes
<b>Attribute     <t>Description
Dynamic      <t>Not implemented.
</topic>

<topic>geref_polyline <style>function
Polyline
<image> geref_fig9.png

A polyline is created by selecting polyline in the tool panel and drag MB1 in the working area.
When MB1 is released, the first line segment is created. By dragging MB1 additional line
segments are created. When all the line segments are drawn, the drawing sequence is terminated
with MB3.

If you want to move a single breakpoint in a polyline, you select the polyline and activate
'Edit/Edit polyline' in the menu. The editing is terminated with MB3.

By activating 'Functions/MoveRestrictions/Horizontal' or 'Vertical' you draw horizontal and
vertical lines. Horizontal or Vertical states the direction of the first line segment. The 
following segments are drawn perpendicular to the previous segment. MoveRestrictions can be
disabled when drawing a polyline with 'Functions/MoveRestrictions/No'.

<h2>Properties
- Fill
- Fillcolor
- Border
- Bordercolor
- Linewidth
- 3D
- Gradient

<h2>Attributes
<b>Attribute      <t>Description
shadow_width   <t>The with of the 3D-shadow in % of width or length (the smallest).
shadow_contrast <t>Contrast of the 3D-shadow.
gradient_contrast <t>Contrast of the gradient. A value in the range 0 - 10.
relief        <t>Up gives a shadow on the lower side, and Down gives a shadow on the upper side.
gradient      <t>Type of gradient.
disable_shadow <t>Disables the 3D-function. Is used when the object is a part of a subgraph
              <t>an not should be drawn with 3D when 3D is chosen for the instance of the 
              <t>subgraph.
fill_eq_border <t>Indicates that the fill color is drawn with the specified border color instead
              <t>of the current fill color. This is used for subgraphs where certain elements,
              <t>e.g. arrows, have more in common with the border color than the fill color.
fill_eq_light <t>If the object is a part of a subgraph, it will have the light 3D-color,
              <t>when 3D is chosen for the subgraph.
fill_eq_shadow <t>If the object is a part of a subgraph, it will have the same color as a 3D 
              <t>shadow, when 3D is chosen for the subgraph.
fixcolor      <t>The color is fix. This is used when the object is a part of a subgraph and
              <t>should not be affected by color setting of the subgraph.
fixposition   <t>The object can not be moved.
Dynamic       <t>Not implemented.
</topic>

<topic>geref_text <style>function
Text
<image> geref_fig11.png

A text is created by selecting text in the tool panel and clicking MB1 in the working area.
An input field is opened, where the text is entered. The text is modified from 
'Edit/Change text' in the menu or from the object editor.

The currently available font is Helvetica, normal or bold. The maximum number of character
in the text string is 79.

<h2>Properties
- Font size
- Normal or bold text
- Text color

<h2>Attributes
<b>Attribute  <t>Description
Text         <t>Actual text, maximum 79 characters.
Adjustment   <t>Text adjustment, left, right or center.
Dynamic      <t>Not implemented.
</topic>

<topic>geref_annotation <style>function
Annotation

An annotation is a text in a subgraph, that is unique for each instance of the subgraph.
Examples of annotations are the text of a pushbutton, or the analog value of an update field.
When editing the subgraph, the position for the text is stated. The actual text is stated in 
the object editor for the instance of the subgraph (or handled by certain dynamic functions).

An annotation is created by selecting annotation (An) in the tool panel and clicking MB1 in
the working area.

Annotations can only be created in a subgraph. There can be 10 annotations in one subgraph.
Each annotation is given a number that is unique within the subgraph.

Note that some types of dynamics (Value, SetDig etc) requires specific numbers of annotations.

<h2>Properties
- Normal or bold text
- Text color

<h2>Attributes
<b>Attribute     <t>Description
TextSize     <t>Text size 0-7
Number       <t>Numbering of annotations within the subgraph.
Adjustment   <t>Text adjustment, left, right or center.
Dynamic      <t>Not implemented.
</topic>

<topic>geref_conpoint <style>function
Connection point

A connection point in a subgraph makes it possible to draw connections between instances of
the subgraph. In the subgraph, the position of the connection point is stated, as well as
the direction in which a connection of the connection point is to be drawn.

A connection point is created by selecting connection point in the tool panel and clicking
MB1 in the working area.

Connection points can only be created in subgraphs.

A connection point is marked with a circle when editing the subgraph. In an instance of the
subgraph, the connection point is not visible.

If the connection is to be connected to connections of type grafcet or routed, the direction
has to be given. It is stated from the object editor.

Each connection point has a number that is unique within a subgraph.

<h2>Properties
- Direction

<h2>Attributes
<b>Attribute      <t>Description
Number        <t>Numbering or connection points within a subgraph.
Direction     <t>Direction: up, down, right or left.
Dynamic       <t>Not implemented.
</topic>

<topic>geref_complexobj
Complex objects
</topic>

<topic>geref_bar <style>function
Bar
<image> geref_fig13.png

Bar is one way to display the value of an analog signal.
The properties fill, fillcolor, bordercolor etc. states properties for the background rectangle.
The properties for the bar itself, are stated in the object editor.
A bar is created by selecting bar in the subgraph palette, 'Analog/Bar', and clicking MB2 in
the working area.

<h2>Properties
- Fill (for the background rectangle)
- Fillcolor (for the background rectangle)
- Border (for the background rectangle)
- Bordercolor (for the background rectangle)
- Linewidth (for the background rectangle)

<h2>Attributes
Attribute      <t>Description
Bar.Attribute <t>The name of a signal in the database.
Bar.MaxValue  <t>Signal value that corresponds to full length of the bar.
Bar.MinValue  <t>Signal value that corresponds to zero length of the bar.
Bar.Value     <t>Can be used as a test value in the editor.
Bar.BarColor  <t>Fillcolor for the bar (the value Inherit implies that the border color
              <t>of the background rectangle is chosen).
Bar.BorderColor <t>Border color for the upper border line of the bar (the value Inherit
              <t>implies that that the bordercolor from the background rectangle is chosen).
Bar.BorderWidth <t>Line width of the borderline (1-8)
Dynamic       <t>Not implemented
</topic>

<topic>geref_trend <style>function
Trend
<image> geref_fig14.png

Trend displays the value of one or two analog values as curves.

The cuves can be drawn with or without fill, where fill means that that area between the curve
and the time axis is filled. The curves are drawn with the second curve on top.

A number of horizontal and vertical lines can be drawn with the border color in the trend 
object. The number of lines are configured from the object editor.

The properties fill, fillcolor, bordercolor etc., states the properties for the background
rectangle of the curve. The properties of the curve itself are stated from the object editor.

A trend is created by selecting trend in the subgraph palette, 'Analog-Trend', and clicking
MB2 in the working area.

<h2>Properties
- Fill (for the background rectangle)
- Fillcolor (for the background rectangle)
- Border (for the background rectangle)
- Bordercolor (for the background rectangle)
- Linewidth (for the background rectangle)

<h2>Attributes
<b>Attribute     <t><t>Description
Trend.Attribute1  <t><t>Signal for curve number 1.
Trend.Attribute2  <t><t>Signal for curve number 2.
Trend.NoOfPoints  <t><t>Number of points in the curve.
Trend.ScanTime    <t><t>Time interval between two points.
Trend.CurveLineWidth <t><t>Linewidth for the curve (1-8)
Trend.FillCurve   <t><t>States that the area between the curve and the time axis
                  <t><t>is to be filled.
Trend.HorizontalLines <t><t>Number of horizontal lines
Trend.VerticalLines <t><t>Number or vertical lines
Trend.MaxValue1   <t><t>Maximum value of Attribute1
Trend.MinValue1   <t><t>Minimum value of Attribute1
Trend.CurveColor1 <t><t>Border color for the curve of Attribute1
Trend.CurveFillColor1 <t><t>Fill color for the curve of Attribute1
Trend.MaxValue2   <t><t>Maximum value of Attribute2
Trend.MinValue2   <t><t>Minimum value of Attribute2
Trend.CurveColor2 <t><t>Border color for the curve of Attribute2
Trend.CurveFillColor2 <t><t>Fill color for the curve of Attribute2
Trend.Dynamic     <t><t>Not implemented
</topic>

<topic>geref_axis <style>function
Axis
<image> geref_fig12.png

Axis shows the range for a curve or bar in x or y direction.
There are two variants of Axis, one with static min and max
values, and one with dynamic min and max values, where min and
max are connected to signals in the database. For a dynamic
Axis object, the values of Lines, LongQuotient, ValueQuotient and
Format are calculated automatically in runtime.

<h2>Attributes
<b>Attribute  <t>Description
MaxValue     <t>Maximum value for the range.
MinValue     <t>Minimum value for the range.
Lines        <t>Number of lines perpendicular to the axis.
LongQuotient <t>Specification of lines that is a bit longer. For example 4 implies that
             <t>every fourth line is a bit longer.
ValueQuotient <t>How often a value is to be written. For example 4 impies that a value is
	     <t>written at every fourth line.
Format       <t>Format in c syntax of written values.
Dynamic      <t>Not implemented.

<b>Dynamic Axis
Axis.MinValueAttr <t>Min value signal of type Float32 or Int32.
Axis.MaxValueAttr <t>Max value signal of type Float32 of Int32.
</topic>

<topic>geref_windowobject <style>function
Window
<image> geref_fig15.png

Window displays a separate graph in a specified area in another graph. The graph is displayed
with or without scrollbars.

<h2>Limitations
Connections within the window object are scaled properly.

<h2>Attributes
<b>Attribute    <t><t>Description
Window.FileName <t><t>Name of the graph to be displayed in the window.
Window.Scale    <t><t>Scale of the graph.
Window.VerticalScrollbar  <t><t>A vertical scrollbar is displayed in the window.
Window.HorizontalScrollbar <t><t>A horizontal scrollbar is displayed in the window.
Window.ScrollbarWidth  <t><t>Width of scrollbar.
Window.ScrollbarColor  <t><t>Fill color of the mobile part of the scrollbar.
Window.ScrollbarBgColor <t><t>Fill color of the background part of the scrollbar.
</topic>

<topic>geref_tabbedwind <style>function
TabbedWindow
<image> geref_fig17.png

TabbedWindow is a window object with folders. For each folder a separate graph is stated,
and when that folder is activated, the stated graph is displayed in the window.

<h2>Limitations
Sliders within the window object are disabled.
You can not state an hierarchy or class object.

<h2>Attribut
<b>Attribute    <t><t>Description
Folder.NumberOfFolders  <t><t>Number of folders.
Folder.HeaderHeight     <t><t>Folder height.
Folder.ColorSelected    <t><t>Color of the active folder.
Folder.ColorUnselected  <t><t>Color of inactive folders.
Folder.ScrollbarWidth   <t><t>Width of scrollbar.
Folder.ScrollbarColor   <t><t>Fill color of the mobile part of a scrollbar.
Folder.ScrollbarBgColor <t><t>Fill color of the background part of a scrollbar.
Folder1.FileName        <t><t>Name of the graph that is displayed in the first folder.
Folder1.Text            <t><t>Text of the first folder.
Folder1.Scale           <t><t>Scale of the graph in folder number 1.
Folder1.VerticalScrollbar <t><t>A vertical scrollbar is displayed for folder 1.
Folder1.HorizontalScrollbar <t><t>A horizontal scrollbar is displayed for folder 1.
</topic>

<topic>geref_table <style>function
Table
<image> geref_fig16.png

A table object displays a table with a number of rows and columns. Each column is connected
to an array attribute in the database, and the values of the array elements are displayed
in the column.

A cell in the table is selected by clicking on it, or by the arrow keys (if dynamic type
InputFocus is configured for the table). To each column you can connect a select attribute,
i.e. an array attribute in the database of type Boolean. When a cell is selected, the 
corresponding element in the select attribute is set, and the previous selected is reset.

If the connected array attribute to a column is of type Objid, you can open a popup menu with
the methods of the objects displayed in the column.

The array attributes should be stated with data type and size, for example
VWX-P1-Table.TabVect##Float32#100, where Float32 is the datatype and 100 the number of elements
in the array.

The table object consists of the following components:
- Vertical and horizontal scrollbar.
- A header row with a title for each column. The header row is not comprised by the vertical
  scrollbar.
- A header column. The left most column can be configured as a header column, i.e. it is not
  comprised by the horizontal scrollbar.

<h2>Attributes
<b>Attribute     <t><t>Description
Table.Rows   <t><t>Number of rows in the table (header row excluded).
Table.Columns <t><t>Number of columns in the table (header column included). 
Table.HeaderRow <t><t>A header row with title for each column is drawn.
Table.HeaderColumn <t><t>The leftmost column is not comprised by the horizontal 
               <t><t>scrollbar.
Table.RowHeight  <t><t>Row height.
Table.HeaderTextSize <t><t>Text size of the text in the header row.
Table.HeaderTextBold <t><t>Bold text in the header row.
Table.HeaderTextColor <t><t>Text color in the header row.
Table.Options   <t><t>Bitmask with options
                <t><t>1: If the cell in the leftmost column is empty, all the 
                <t><t>cells on that row is drawn empty.
Table.VerticalScrollbar <t><t>Vertical scrollbar in the table.
Table.HorizontalScrollbar <t><t>Horizontal scrollbar in the table.
Table.ScrollbarWidth <t><t>Scrollbar width.
Table.ScrollbarColor <t><t>Fill color of the mobile part of the scrollbar.
Table.ScrollbarBgColor <t><t>Fill color of the background part of the scrollbar.
Column1.Attribute <t><t>Array attribute. The value of each element is displayed 
                  <t><t>in the corresponding row in the column. The attribute 
                  <t><t>should be stated with data type and size, see above.
Column1.Format    <t><t>Format in c syntax.
Column1.SelectAttribute <t><t>Array attribute of type Boolean, When a cell in the 
                  <t><t>column is selected, the corresponding element in the 
                  <t><t>array is set. The attribute should be stated with data type 
                  <t><t>and size, see above.
Column1Width      <t><t>Width of the column.
Column1.HeaderText <t><t>Column title. The title is written in the header row.
</topic>
</chapter>

<chapter>
<topic>geref_subgraph
Subgraphs

A subgraph is a class or pattern that is built of a number of base objects.

An instance of the subgraph is created by selecting the subgraph in the subgraph palette,
and clicking MB1 in the working area. In the editor, the instances are handled as other objects,
and the fillcolor, bordercolor and linewidth of the instances can be set.

<h1>Color
You can set the fill color and border color of a subgraph object in the same way as the base
objects. It implies that these properties are set to all the base objects of the subgraph. 
If you set the fill color of a subgraph that is drawn with shadows and reflections to give a 3D
effect, this effect will disappear and the objects is totally flattened out. To modify the color
of this kind of subgraph you use the functions for lightness, color intensity and color tone
in the tool panel.

<b>Lightness
The function for lightness is found in the tool panel and marked with sun. Here are increase
and decrease buttons that makes the fill color of the object lighter or darker. The lightness
can be modified in seven steps.

<b>Intensity
The function for color intensity is found in the tool panel and marked with three color points.
The intensity can be modified in three steps: strong intensity, medium and gray.

<b>Shift
Color shift implies that every color in the subgraph object is rotated on the color circle.
An object that contains blue and green colors will, for example, after four shift steps contain
orange and red colors. The colors keeps their original lightness and intensity, and also their
internal color contrast.

The function is found in the tool panel and marked with color points surrounded by an circular
arrow. The colors of the first row of the color palette are not affected by the shift function.

<b>Tone
Toning of an object, implies that all the color of the subgraph object gets the same color tone.
They keep their lightness and intensity. There are nine different color tones: gray, 
yellowgreen, yellow, orange, red, violet, blue, seablue and green.

The function for tone is found in the color palette below the selection of fill, border and
text color. Here is also a button to reset the color of an objects to the original colors.

<h1>Animation and shift
<b>Subgraphs with several pages
Animation and Shift are types of dynamics that don't just change the color of the subgraph,
they also change the shape. This is done by creating a subgraph with several pages.

To create additional pages for a subgraph you activate 'File/Page/Create next page'. This
function will create a new subgraph with the suffix '__px', where x is the page number, and
it will link this to the previous page by putting the name in the attribute NextSubgraph in
the graph attributes. For the last page, NextSubgraph is empty. When a page is created and
saved, you can easily shift to the next or previous page from 'File/Page/NextPage' and
'File/Page/PreviousPage' in the menu.

You should save the different pages with the same zoom factor, otherwise you might get one
pixels displacement of pages in runtime.

<h1>Shift
Shift between different pages in runtime is done with the dynamic types DigShift and AnalogShift.
DigShift shifts between the first and second page depending on a digital value. AnalogShift
is connected to an analog signal, where the value corresponds the the index for the page
to be displayed (the first page has index 0).

<h1>Animation
When an animation is run, the pages are displayed, one after another and gives the impression
of movement.

The interval between each page shift, normally has to be much shorter than the normal update
interval. For a graph, you can state the animation scan time in 'File/Graph attributes' in the 
menu. Note that the time is common for all subgraphs in the graph, and can not be stated for
each subgraph individually. A suitable value for the animation scan time is 0.2 seconds.

If an animation should rest on the same page for several animation cycles, you can enter the
number of cycles in AnimationCount in  Graph attributes for the page.

Animations are handled by the dynamic type Animation. It is connected to a digital signal that
controls start and stop of the animation. It also has the attribute Sequence which tells
in which order, and on what condition, the animation is run. Sequence can have the value Cyclic,
Dig or ForwBack.

If Sequence is Cyclic, the first page is displayed when the value of the signal is 0. When the
value of the signal is 1, the animation is active. It starts at page 2 and continues to the 
last page, after that it jumps to the second page again and continues to the last page etc.
This continues until the value of the signal becomes 0.

The sequence ForwBack is similar, but here, the animation runs continuously forward and back 
between the first and last page, as long as the signal value is 1.

If Sequence is Dig the animation is run only when the signal value is changed. When the value
is changed to 1, the animation is run from the first to the last page, and stays on the last
page, when the value is changed to 0, the animation is run back to the first page, and rests
there.
</topic>

<topic>geref_dynamic
Dynamics

You can apply a number of different types of dynamic for the subgraphs. The dynamic defines
how signals in the database should influence for example the color, or to print out an analog
value.

There are a number of predefined types of dynamics, e.g shift between two colors or between
two texts. When you draw the subgraph you state the type of dynamic that is proper for this
subgraph, but this is only a default value for each instance, and can be replace by another
type.

<b>Dynamic   <t>Signal type <t>Description
Inherit   <t>-          <t>The dynamic for the instance is inherited from the subgraph.
Tone      <t>-          <t>States that dynamics that changes the color of the component
          <t>           <t>should change the color tone instead of the fill color.
DigLowColor <t>Boolean  <t>Set the specified fill color when the signal is low. <link>GeDynDigLowColor
DigColor  <t>Boolean    <t>Set the specified fill color when the signal is high. <link>GeDynDigColor
DigError  <t>Boolean    <t>Set red fill color when the signal is high. <link>GeDynDigError
DigWarning <t>Boolean   <t>Set yellow fill color when the signal is high. <link>GeDynDigWarning
DigFlash  <t>Boolean    <t>Flash with specified color when the signal is high. <link>GeDynDigFlash
AnalogColor <t>Float32 Int32 <t>Set specified fill color when the signal <link>GeDynAnalogColor
          <t>            <t>goes beyond or below the specified limit.
StatusColor <t>Status   <t>Set fill color dependent on a status signal severity. <link>GeDynStatusColor
FillLevel <t>Float32    <t>Changes partly the fill color of the component. The level <link>GeDynFillLevel
          <t>           <t>for the borderline of the colored part is determined by
          <t>           <t>the value of the signal.
Invisible <t>Boolean String <t>Make the component invisible when the signal is high, <link>GeDynInvisible
          <t>           <t>or when the string is empty.
DigBorder <t>Boolean    <t>Set specified border color when the signal is high. <link>GeDynDigBorder
DigText   <t>Boolean    <t>Set specified text when the signal is low. <link>GeDynDigText
AnalogText <t>Float32 Int32 <t>Set up till 32 different texts depending on the value of <link>GeDynAnalogText
          <t>           <t>an analog signal.
Value     <t>Arbitrary  <t>Write the value of an attribute. <link>GeDynValue
Rotate    <t>Float32 Int32 <t>Rotate the component. <link>GeDynRotate
Move      <t>Float32 Int32 <t>Move and scale the component is x and y direction. <link>GeDynMove
DigShift  <t>Boolean    <t>Shift between two pages in the subgraph (first and last page). <link>GeDynDigShift
AnalogShift <t>Float32 Int32 <t>Shift between different pages in the subgraph. The value <link>GeDynAnalogShift
          <t>           <t>of the signal determines the page number.
Animation <t>Boolean    <t>Different types of animation. <link>GeDynAnimation
Video     <t>-          <t>Display a continuously updated image file. <link>GeDynVideo
SliderBackground <t>-   <t>Indicates that the subgraph is background to a slider component. <link>GeDynSliderBackground
DigCommand <t>Boolean   <t>Executes a command when signal gets high. <link>GeDynDigCommand

<h2>Inherit
For an instance of a subgraph, Inherit means, that the dynamic is inherited from the subgraph 
class, that is the default dynamic stated when the subgraph was edited. If also the default
dynamic is inherit, the subgraph lacks dynamics.

The default dynamic for an instance, is displayed by opening the object editor for the instance
and there open the subgraph folder.

<h2>Xtt-commands
There are a number of pushbuttons that executes xtt-commands. The most usual is to open another
graph, but you can also open trace or trends etc. Here follows some usable xtt-commands. 

<c>open graph GraphName [/width=][/height=][/scrollbar][/navigator]

<c>open trace WindowName [/center=]

<h2>Access
All dynamics that makes it possible to influence the value of a signal in the database, has
the attribute Access. Access states the privileges that are required for a user to be allowed
to change a value. There are 15 different privileges that are of interest for graphs, 10
for various operators, and 4 for different professionals. Furthermore there is RtRead, read 
access in runtime, that a user that is not logged in is granted. A user grants one or
several privileges, and if one of his privileges is present in Access, he has the right to
influence the object.

Default access is all privileges except RtRead. Some operations, as opening other graphs, should
also accept RtRead.

<b>Privileges in runtime <t>Description
RtRead    <t>Read access.
System    <t>System manager.
Maintenance <t>Maintenance technicians.
Process   <t>Process technicians.
Instrument <t>Instrument technicians.
Operator1  <t>Different operator or operator places.
Operator2  <t>"
Operator3  <t>"
Operator4  <t>"
Operator5  <t>"
Operator6  <t>"
Operator7  <t>"
Operator8  <t>"
Operator9  <t>"
Operator10 <t>"
</topic>

<headerlevel>
<topic>GeDynDigLowColor <style>function
DigLowColor
Set specified fill color when the signal is low.

The object is connected to a digital signal in the database. If the value is 1, the object
is drawn with the normal fill color, if the value is 0, it is drawn with DigLowColor.Color
which is stated in the object editor.

Compare to DigColor below, that set the specified color when the signal is high instead of low.
If to use DigLowColor or DigColor is a question how the component is to be drawn in the editor:
The way is will appear when the signal is high or low, i.e. if you want to draw the graph
as it will look when the plant is running or stopped.

<b>Attribute <t><t>Description
DigLowColor.Attribute <t><t>Signal in the database of type Boolean that 
                      <t><t>should influence the component.
DigLowColor.Color  <t><t>Fill color of the component when the signal is 0.
</topic>

<topic>GeDynDigColor <style>function
DigColor
Set specified fill color when the signal is high.

The object is connected to a digital signal in the database. If the value is 1 the object is
drawn with DigColor.Color which is stated from the object editor, if the value is 0 it is drawn
with the normal fillcolor.

DigColor can exist in several instances, which makes it possible to change between several 
colors (up to 32 colors). Instances with higher number has higher priority, i.e. if the signal 
for a higher instance is high, it determines the color independent of the values of signals
connected to lower instances.

<b>Attribute <t><t>Description
DigColor.Attribute <t><t>Signal in the database of type boolean that should 
                   <t><t>influence the component.
DigColor.Color <t><t>Fill color of the component when the signal is 1.
DigColor.Instance <t><t>States the number of instances that is created.
DigColor2.Attribute <t><t>Signal for instance number 2.
DigColor2.Color <t><t>Fill color for instance number 2.
DigColor3.Attribute <t><t>Signal for instance number 3.
DigColor3.Color <t><t>Fill color for instance number 3.
</topic>

<topic>GeDynAnalogColor <style>function
AnalogColor

AnalogColor is connected to an analog signal, and sets the specified fill color when the signal
goes below or beyond a limit. The limit is specified in AnalogColor.Limit and 
AnalogColor.LimitType determines if it is an upper or lower limit. If LimitType is GreaterThan,
the fillcolor is set, when the value of the signal exceeds the limit, and when LimitType
is LessThan, the fillcolor is set when the signal value is below the limit. Other limit types
are GreaterEqual, LessEqual and Equal.

AnalogColor can exist in several instances, which makes it possible to set several limit
values and to shift between several colors (up to 32 colors).

Note! If there are several instances with equal LimitType, a higher instance has to have a
higher limit, when LimitType is GreaterThan or GreaterEqual. If LimitType is LessThan or
LessEqual, a higher instance has to have a lower limit.

<b>Attribute <t><t>Description
AnalogColor.Attribute <t><t>Signal in the database of type Float32 or Int32. The 
                      <t><t>value is compared to the limit, and if it is 
                      <t><t>beyond/below the limit the color of the component is 
                      <t><t>changed.
AnalogColor.Color     <t><t>Fill color of the component value when the signal has 
                      <t><t>passed the limit.
AnalogColor.Limit     <t><t>Limit value.
AnalogColor.LimitType <t><t>Type of limit. Can be GreaterThan, GreaterEqual, 
                      <t><t>LessThan, LessEqual or Equal.
AnalogColor.Instances <t><t>States the number of instances that is created.
AnalogColor2.Color    <t><t>Fill color for instance number 2.
AnalogColor2.Limit    <t><t>Limit for instance number 2.
AnalogColor2.LimitType <t><t>Type of limit for instance number 2.
AnalogColor3.Color    <t><t>Fill color for instance number 3.
</topic>

<topic>GeDynStatusColor <style>function
StatusColor

StatusColor is connected to an attribute of type Status. A status is defined by
a text and a severity, where the severity is one of the categories Success, Info
Warning, Error and Fatal. The status value can also be 0, NoStatus. StatusColor
set fill color from the status severity.

Success, Info   <t>Original color.
Warning         <t>Yellow.
Error           <t>Red.
Fatal           <t>Flashing red.

<b>Attribute <t><t>Description
StatusColor.Attribute <t><t>Signal in the database of type Status. The color of the component
                      <t><t>is set from the severity of the status value.
StatusColor.NoStatusColor <t><t>Color when the status value is 0.
</topic>

<topic>GeDynDigWarning <style>function
DigWarning

Set fill color to yellow when the signal is high.

The object is connected to a digital signal in the database. If the value is 1, the object is
drawn with yellow fill color, if the value is 0, it is drawn with the normal fill color.

<b>Attribute <t><t>Description
DigWarning.Attribute <t><t>Signal in the database of type Boolean that should 
                     <t><t>influence the object.
</topic>

<topic>GeDynDigError <style>function
DigError

Set the fill color to red when the signal is high.

The object is connected to a digital signal in the database. If the value is 1, the object is
drawn with red fill color, if the value is 0, it is drawn with the normal fill color.

<b>Attribute <t><t>Description
DigError.Attribute <t><t>Signal in the database of type Boolean that should 
  <t><t>influence the object.
</topic>

<topic>GeDynDigFlash <style>function
DigFlash

Flash with specified fill color when the signal is high.

DigFlash changes the color of the object every cycle. The color is shifted between the 
specified color and original color, or the color the object receives from other color dynamics.

The flash frequency is determined by the cycle time of the cycle of the object.

<b>Attribute <t><t>Description
DigFlash.Attribute <t><t>Signal in the database that should influence the object.
DigFlash.Color     <t><t>Fillcolor.
</topic>

<topic>GeDynFillLevel <style>function
FillLevel

Draw the object with a specified fill color, up to a certain level.

FillLevel draws the original color (or the color determined by other dynamics) up to a certain
border line. On the other side of the borderline the object is drawn with the specified
background color. The position of the borderline is determined from the value of the analog
signal. If the value is less then MinValue, the whole object is drawn with background color.
If the value is greater than MaxValue the object is drawn with the original color.

Direction states the direction of the movement of the borderline. If Direction is Up the border
is move upwards with increasing value, if Down downwards, if Left to the left and if right to
the right.

<b>Attribute <t><t>Description
FillLevel.Attribute <t><t>Signal in the database of type Float32.
FillLevel.BackgroundColor <t><t>Background color.
FillLevel.Direction <t><t>Direction Up, Down, Left or Right.
FillLevel.MinValue <t><t>Min value. When the signal value equals 
                   <t><t>MinValue, the whole object is drawn with 
                   <t><t>background color.
FillLevel.MaxValue <t><t>Max value. When the signal value equals 
                   <t><t>MaxValue, the whole object is drawn with 
                   <t><t>original color.
</topic>

<topic>GeDynInvisible <style>function
Invisible

Makes the object invisible (or dimmed) when the signal is high.
The signal is usually connected to a digital signal, but can also be connected to a string. 
In this case the object is invisible when the string is empty. Invisible can also be used with 
the xtt-command 'check' to, for example, check if a method is defined for an object. In 
Attribute you then write $cmd('command'), for example
<c>   $cmd(check method/method=Note/object=VK-Valve)

<b>Attribute <t><t>Description
Invisible.Attribute <t><t>Signal in the database of type Boolean that should 
                    <t><t>influence the object.
Invisible.Dimmed <t><t>1 dims the object, 0 makes the object invisible.
</topic>

<topic>GeDynDigBorder <style>function
DigBorder

Set specified border color when the signal is low.

The object is connected to a digital signal in the database. If the value is 1, the object is 
drawn with the normal border color, if the value is 0, it is drawn with DigBorder.Color that 
is stated from the object editor.

<b>Attribute <t><t>Description
DigBorder.Attribute <t><t>Signal in the database of type Boolean the should influence 
                    <t><t>the component.
DigBorder.LowColor  <t><t>Border color of the component when the signal is 0.
</topic>

<topic>GeDynDigText <style>function
DigText

Shift between two texts.

The object is connected to a digital signal in the database. If the value is 1, the original 
text is written, if the value is 0, the text in LowText is written. DigText operates on 
annotation 1. 

<b>Attribute <t><t>Description
DigText.Attribute <t><t>Signal in the database of type Boolean the shift the text.
DigText.LowText   <t><t>Text to write when the signal is low.
</topic>

<topic>GeDynAnalogText <style>function
AnalogText

Shift between several texts depening on the value of an analog signal.

The object is connected to a database attribute of type float or int. To each text you specify
an Enum value. The text which Enum value matches the value of the database attribute, is 
displayed in the component.

<b>Attribute <t><t>Description
AnalogText.Attribute <t><t>Database attribute of type Float32, Float64, Int32, 
                     <t><t>UInt32, Int16, UInt16, Int8 or UInt8. The text which
                     <t><t>Enum matches the value of the database attribute is
                     <t><t>displayed.
AnaogText.TextMask   <t><t>Mask that states number of texts.
AnalogText.Text1     <t><t>Text number 1.
AnalogText.Enum1     <t><t>Enumeration value for text number 1.
AnalogText.Text2     <t><t>Text number 2.
AnalogText.Enum2     <t><t>Enumeration value for the second text.
</topic>

<topic>GeDynValue <style>function
Value

Writes the value of a signal. The value is written in a text field.

The object is connected to an attribute in the database of arbitrary type. In format, the 
format of the conversion to text is specified, in c-syntax.

It is possible to create additional instances. This requres that the subgraph has several
annotations to write out values in. The value of an instance are written out in the annotation
with the corresponding number.

<b>Attribute <t><t>Description
Value.Attribute <t><t>Signal in the database or arbitrary type, that is written out in 
                <t><t>the text field.
Value.Format    <t><t>Format in c-printf syntax.
Value.Instances <t><t>States the instances that is created.

<h2>Format
For the following attributes types, some additional format strings are defined.

<b>pwr_tTime
%t<t>Date and time. Ex 24-MAY-2007 11:33:43.91
%1t<t>Only time, no hundredth. Ex 11:33:43
%2t<t>Only time, with hundredth. Ex 11:33:43:91
%3t<t>Compressed date and time. Ex 07-05-24 11:33:43
%4t<t>Date only. Ex 24-MAY-2007
%5t<t>Compressed date. Ex 07-05-24

<b>pwr_tDeltaTime
%t<t>Time with hundredth. Ex 1:23:45.43
%1t<t>Time without hundredth. Ex 1:23:45

<b>pwr_tEnum
%d<t>The enumeration value is displayed as in UInt32.
%s<t>The enumeration value will be converted to the corresponding string.

<b>pwr_tObjid
%o<t>Object name (last segment).
%1o<t>Path and object name.
%2o<t>Volume, path and object name.

<b>pwr_tAttrRef
%o<t>Object name (last segment) and attribute name.
%1o<t>Path, object name and attribute name.
%2o<t>Volume, path, object name and attribute name.

<b>pwr_tStatus and pwr_tNetStatus
%m<t>The status value will be converted to the corresponding string.
  <t> Ex "GDH-E-NOSUCHOBJ, No such object".
%1m<t>Only the text part of the string is displayed. Ex "No such object".

<b>pwr_tMask
%d<t>The mask is displayed as an UInt32.
%b<t>The mask is displayed as a 32-bit binary value.
%16b<t>The mask is displayed as a 16-bit binary value. Ex 001111100011001.


</topic>

<topic>GeDynRotate <style>function
Rotate

Rotate an object.

The rotation is made from the position the object has in the editor. The value of the signal
is multipied by Factor, that gives the rotation in degrees.

x0 and y0 specifies the rotation point. If x0 and y0 is zero, origin in the coordinate system
of the subgraph is used as rotation point. Subgraph that has Rotate as default dynamics, 
usually are drawn in a way that the rotation points doesn't has to be specified.

<b>Attribute <t><t>Description
Rotate.Attribute <t><t>Signal in the database of type Float32. Supplies the rotation 
                 <t><t>of the object.
Rotate.x0        <t><t>x coordinate for the rotation point.
Rotate.y0        <t><t>y coordinate for the rotation point.
Rotate.Factor    <t><t>Factor that, multiplied by the value of the signal, gives 
                 <t><t>the value in degrees. 
</topic>

<topic>GeDynMove <style>function
Move

Moves and scales an object. Can be connected to four analog signals that moves the object in
x and y direction, and scales it in x and y direction.

The movement is done from the position the object is given in the editor. The calculation from
the values of the signals in XAttribute and YAttribute to Ge coordinates, are influenced by
XOffset, YOffset and Factor. XOffset and YOffset are the values that corresponds to the 
starting point in x and y direction. Factor specifies the conversion from XAttribute and
YAttribute values to Ge coordinates, according to the formula:

dx = (XAttribute - XOffset) * Factor

dy = (YAttribute - YOffset) * Factor

The scaling in x and y direction is done from the values of the signals in ScaleXAttribute
and ScaleYAttribute. These are multiplied by ScaleFactor and gives the scale factor, where
1.0 implies no scaling, values greater than 1 gives enlargement, and values less then 1 gives
reduced scale.

<b>Attribute  <t><t>Description
Move.XAttribute <t><t>Signal in the database of type Float32. Gives movement in 
                <t><t>x direction.
Move.YAttribute <t><t>Signal in the database or type Float32. Gives movement in 
                <t><t>y direction.
Move.Factor     <t><t>Conversion factor from entity for XAttribute and 
                <t><t>YAttribute to entity for Ge coordinate.
Move.XOffset    <t><t>Value for XAttribute that corresponds to the start 
                <t><t>position for the object.
Move.YOffset    <t><t>Value for YAttribute that corresponds to the start 
                <t><t>position for the object.
Move.ScaleXAttribute <t><t>Signal in the datbase of type Float32. Gives scaling in 
                <t><t>x direction.
Move.ScaleYAttribute <t><t>Signal in the database of type Float32. Gives scaling in 
                <t><t>y direction.
Move.ScaleFactor <t><t>Conversion factor from entity for ScaleXAttribute
                <t><t>and ScaleYAttribute to scale factor.
</topic>

<topic>GeDynAnalogShift <style>function
AnalogShift

Shift between several pages in the subgraph. The subgraph has to contain at least two pages.

The object is connected to an analog signal in the database. The value of the analog attribute
determines the index for the page to display. Value 0 displays the first page, value 1 the
second etc.

<b>Attribute <t><t>Description
AnalogShift.Attribute <t><t>Signal in the database of type Float32 or Int32 that shifts 
                      <t><t>page of the subgraphs. The value determines which 
                      <t><t>page is to be displayed. Value 0 displays the first 
                      <t><t>page.
</topic>

<topic>GeDynDigShift <style>function
DigShift

Shift between two pages in the subgraph. The subgraph has to contain at least two pages.

The object is connected to a digital signal in the database. If the value is 0, the object is 
drawn with the first page, if the value is 1, it is drawn with the last page.

<b>Attribute <t><t>Description
DigShift.Attribute <t><t>Signal in the database or type Boolean that shifts 
                   <t><t>page. When the value is 0, the first page 
                   <t><t>is displayed, when value is 1 the last page.
</topic>

<topic>GeDynAnimation <style>function
Animation

Dynamic for animation subgraphs, i.e. subgraphs with several pages. The object is connected
to a digital signal that activates the animation.

The animation sequence is determined by Sequence, that can have the value Cyclic, ForwBack
or Dig.

<h2>Cyclic
Alter between resting and cyclic animation. The animation is done from page 2 to the last
page, and continues on page 2 to the last page etc.

If the signal value is 0 the object is drawn with the first page, if the value is 1 the cyclic
animation starts between the second and the last page. At animation the pages from second to
the last page are run through, and after that you jump to the second page again, animating to
the last page etc.

<h2>ForwBack
Shift between resting and cyclic animation. The animation runs forward and back between the 
first and the last page. If the signal value is 0 the object is drawn with th first page, if
the value is 1, the cyclic animation starts forward and back between the first and the last 
page.

<h2>Dig
Shift between two resting positions. When the signal value is changed, an animation between
the resting positions is performed.

If the signal value is 0, the object is drawn with the first page, if the value is 1, it is
draw with the last page. When the values changes from 0 to 1 the animation is run from the
first page to the last page. When the value changes from 1 to 0, the animation is run from
the last page to the first page.

<b>Attribute <t><t>Description
Animation.Attribute <t><t>Signal in the database of type Boolean that activates 
                    <t><t>the animation.
Animation.Sequence  <t><t>Animation sequence. Can be Cyclic, ForwBack 
                    <t><t>or Dig.
</topic>

<topic>GeDynVideo <style>function
Video

Displays a gif-file that is continuously updated by a web camera.
Video has no attribues.
</topic>

<topic>GeDynDigCommand <style>function
DigCommand
Execute specified command when the signal goes from low to high.

The object is connected to a digital signal in the database. When the value changes from 0 to 
1, the command is executed.

DigCommand can exist in several instances, which makes it possible to execute several 
command.

<b>Attribute <t><t>Description
DigCommand.Attribute <t><t>Signal in the database of type boolean that should 
                   <t><t>influence the component.
DigCommand.Command <t><t>Xtt command that is executed when the signal value changes from 0 to 1.
DigCommand.Instance <t><t>States the number of instances that is created.
DigCommand.Attribute <t><t>Signal for instance number 2.
DigCommand.Command <t><t>Command for instance number 2.
</topic>
</headerlevel>
<pagebreak>

<topic> geref_action
Action

Action defines what happens when you activate an object, for example by clicking on it.
You can set or reset signals in the database, open another graph, display a help text or a 
tooltip text etc.

<b>Action <t>Signal type <t>Description
Inherit   <t>-          <t>Action for the instance is inherited from the subgraph.
PopupMenu <t>Object     <t>A popup menu can be opened from the component by <link>GeDynPopupMenu
          <t>           <t>clicking MB3.
SetDig    <t>Boolean    <t>Set the value of a signal to true with Click MB1. <link>GeDynSetDig
ResetDig  <t>Boolean    <t>Set the value of a signal to false with Click MB1. <link>GeDynResetDig
ToggleDig <t>Boolean    <t>Change the value of a signal with Click MB1. <link>GeDynToggleDig
StoDig    <t>Boolean    <t>Set the value of a signal as long as the button is pressed. <link>GeDynStoDig
SetValue  <t>Int, Float, String  <t>Set the value of a signal to a specified value. <link>GeDynSetValue
Command   <t>-          <t>Execute a xtt command with Click MB1. <link>GeDynCommand
CommandDoubleClick <t>- <t>Execute a xtt command with Doubleclick MB1. <link>GeDynCommandDoubleClick
Confirm   <t>-          <t>Confirm before the action is executed. <link>GeDynConfirm
IncrAnalog <t>Float32   <t>Increase or decrease an analog value. <link>GeDynIncrAnalog
RadioButton <t>Boolean  <t>Action for radio buttons. <link>GeDynRadioButton
Slider    <t>Float32 Int32 <t>Reserved for slider subgraphs.
ValueInput <t>Arbitrary <t>Input field. <link>GeDynValueInput
ToolTip   <t>-          <t>Display a tooltip text. <link>GeDynToolTip
Help      <t>-          <t>Display a help text with Click MB1. <link>GeDynHelp
OpenGraph <t>-          <t>Open a graph with Click MB1. <link>GeDynOpenGraph
OpenURL   <t>-          <t>Open an URL in a suitable web browser on Click MB1. <link>GeDynOpenURL
PulldownMenu <t>- 	<t>Action for pulldown menus. <link>GeDynPulldownMenu
OptionMenu <t>-		<t>Action for option menus. <link>GeDynOptionMenu
</topic>

<headerlevel>
<topic>GeDynPopupMenu <style>function
PopupMenu 

An popup menu is opend by clicking MB3. The popup menu contains the methods for the object
specified in RefObject (Se chapter Methods in the Xtt manual).

<b>Attribute <t><t>Description
PopupMenu.RefObject <t><t>Object in the database, which methods are displayed and 
                    <t><t>activated from the popup menu.
</topic>

<topic>GeDynSetDig <style>function
SetDig

Set the value of a digital signal to 1 by clicking MB1 on the object.

SetDig can exist in several instances, and then sets the value of several signals.

<b>Attribute <t><t>Description
SetDig.Attribute <t><t>Signal in the database that is set to 1 with
                 <t><t>Click MB1 on the object.
SetDig.Instances <t><t>States the number of instances that is created.
</topic>

<topic>GeDynResetDig <style>function
ResetDig

Set the value of a digital signal to 0 by clicking MB1 on the object.

ResetDig can exist in several instances, and then sets the value of several signals to 0.

<b>Attribute <t><t>Description
ResetDig.Attribute <t><t>Signal in the database of type Boolean that is set to 0
                   <t><t>with Click MB1 on the object.
ResetDig.Instances <t><t>States the number of instances that is created.
</topic>

<topic>GeDynToggleDig <style>function
ToggleDig

Toggle the value of a digital signal by clicking MB1 on the object.

<b>Attribute <t><t>Description
SetDig.Attribute <t><t>Signal in the database of type Boolean that is toggled with
                 <t><t>Click MB1 on the object.
</topic>

<topic>GeDynStoDig <style>function
StoDig

Set the value of a digital signal to 1 for as long the the button is pressed.

<b>Attribute <t><t>Description
StoDig.Attribute <t><t>Signal in the database of type Boolean that is set
                 <t><t>1 as long as the button is pressed.
</topic>

<topic>GeDynSetValue <style>function
SetValue

Set the value of a signal to specified value.
By using several instances, values can be set into several attributes
with the same button.

<b>Attribute <t><t>Description
SetValue.Attribute <t><t>Signal in the database of type Float32, Int32, 
                   <t><t>UInt32, Int16, UInt16, Int8, UInt8 or String,
                   <t><t>that it set with Click MB1 on the object.
SetValue.Value     <t><t>The value that is set.
</topic>

<topic>GeDynCommand <style>function
Command

Execute a xtt command by clicking MB1 on the object.

<b>Attribute <t><t>Description
Command.Command <t><t>Xtt command that is executed when the 
                <t><t>object is activated.

Additions to the xtt command syntax

<b>$object

$object will be replaced by the current object in an object graph
or by the stated hierarchy in an hierarchy graph.

<b>$hostobject

A special syntax for HostObject dynamics where $hostobject will be
replaced by the current host object.

<b>&(attribute-reference)

The string for an attribute reference of type &(attribute-reference) 
will be replaced by the content of the attribute reference. Suppose 
there is an array, H1-ObjectList.ObjArray, with attriute references 
that points to objects, which object graphs is going to be shown. 
With the command

<c>> open graph /class /instance=&(H1-ObjectList.ObjArray[0])

the object graph is opened for the object in the first element. It is also
possible to state double steps of attribute references with the syntax
'&(&(attribute-reference))'.
</topic>

<topic>GeDynCommandDoubleClick <style>function
CommandDoubleClick

Execute a xtt command by doubleclicking MB1 on the object.

<b>Attribute <t><t>Description
CommandDoubleClick.Command <t><t>Xtt command that is executed when the object
                           <t><t>is activated.
</topic>

<topic>GeDynHelp <style>function
Help

Open the help window with specified topic by clicking MB1 on the object.

<b>Attribute   <t><t>Description
Help.Topic    <t><t>Help text topic that is to be displayed.
Help.Bookmark <t><t>Bookmark in the help text. Optional.
</topic>

<topic>GeDynOpenGraph <style>function
OpenGraph

Open another graph via a XttGraph object by clicking MB1 on the object.

<b>Attribute <t><t>Description
OpenGraph.GraphObject <t><t>Object of class XttGraph.
</topic>

<topic>GeDynOpenURL <style>function
OpenURL

Open an URL in a suitable webbrowser by clicking MB1 on the object.

<b>Attribute <t><t>Description
OpenURL.URL <t><t>An URL
</topic>

<topic>GeDynConfirm <style>function
Confirm

Confirm requires a confirmation from the user before an action is executed. A dialog box with
specified text, Ok and Cancel buttons, is displayed before any other action element is executed.

<b>Attribute  <t><t>Desciption
Confirm.Text <t><t>Text displayed in the confirm window.
</topic>

<topic>GeDynIncrAnalog <style>function
IncrAnalog

Increase or decrease the value of an analog signal.

The object is connected to an analog signal. When clicking MB1 on the object the value is 
incremented by the value specified in Increment. Minimum and maximum values for the signal
value can be specified.

<b>Attribute <t><t>Description
IncrAnalog.Attribute <t><t>Signal in the database of type Float32. When the object is 
                     <t><t>activated, the value of the signal is incremented
                     <t><t>by the value in Increment.
IncrAnalog.Increment <t><t>Value that the signal value is incremented by.
IncrAnalog.MinValue  <t><t>Minimum value for the signal.
IncrAnalog.MaxValue  <t><t>Maximum value for the signal.
</topic>

<topic>GeDynRadioButton <style>function
RadioButton

Sets the value of a digital signal when the button is activated, and resets the value for the
other RadioButton objects in the group.

The object has to be a member of a group with other objects of type RadioButton.

<b>Attribute <t><t>Description
RadioButton.Attribute <t><t>Signal in the database of type Boolean. With Click MB1
                      <t><t>the value of the signal is set, and the other
                      <t><t>RadioButton objects in the same group are reset.
</topic>

<topic>GeDynValueInput <style>function
ValueInput

Input field. Makes it possible to enter the value of a signal, in a component with Value
dynamics specified. The value is changed by clicking MB1 on the object.

The signal is specified in Value.Attribute.

<b>Attribute <t><t>Description
ValueInput.MinValule  <t><t>Minimum input value.
ValueInput.MaxValue   <t><t>Maximum input value.
ValueInput.Clear      <t><t>The field is cleared when opened for input.
ValueInput.Popup      <t><t>Input is done in a popup box.
ValueInput.Unselect   <t><t>The text in the field is not selected when the 
                      <t><t>field is opened for input.
</topic>

<topic>GeDynToolTip <style>function
ToolTip

Views a ToolTip text for a component. ToolTip is a white text box, that is displayed when the
cursor is resting on a component for a certain time. When the cursor leaves the component, the
textbox is removed. In 'Text' the tooltip text is usually specified. If the text is to be
modified, you can connect it to a string attribute by specifying the string attribute in 'Text'
with the prefix '&', for example
<c>  &A1-B1- Sv1.ActualValue##String80

<b>Attribute <t><t>Description
ToolTip.Text <t><t>ToolTip text.
</topic>

<topic>GeDynInputFocus <style>function
InputFocus

Input focus is a function that makes it possible to influence components in the graph from
the keyboard instead using the mouse. Most functions executed with cursor and mouse can also
be performed with the keyboard.

A component is selected with the arrow and Tab keys (or by clicking on it), to receive input
focus.
This means that all input from the keyboard are directed to the component. A pushbutton is, for
example activated by pressing Return, an option menu by selecting the desired alternative with
the arrow keys and pressing Return, a ValueInput by entering desired value and pressing Return.

Only components with the action type InputFocus can receive input focus, the exception is
ValueInput that also can receive input focus by clicking on it.

You shift input focus between components with the arrow keys or the tab key. The order of the
components are configured by linking them in three lists, one horizontal, one vertical and one
Tab list. In the horizontal list you move with the ArrowLeft and ArrowRight keys, in the 
vertical with the ArrowUp and ArrowDown, and in the Tab list with the Tab key. This is 
configured with the attributes InitialFocus, NextHorizontal, NextVertical and NextTab. In
InitialFocus you can state that an object is first or last in a list. You can also state that
a component should receive input focus when the graph is opened. In NextHorizontal, 
NextVertical and NextTab you specify the object name of the next component in the lists.

You use to divide the components in Tab groups. Between the objects within a Tab group you
navigate with the arrow keys, and between Tab groups you navigate with the Tab key. This is
achieved by setting NextTab for all the objects in one Tab group, to the first object in the 
next Tab group.

<b>Attribute <t><t>Description
InputFocus.InitalFocus <t><t>Bitmask with the following bits:
  <t><t>- InitialFocus The component has input focus when 
  <t><t>  the graph is opened.
  <t><t>- FirstHorizontal The object is the first object in 
  <t><t>  the horizontal list.
  <t><t>- FirstVertical The object is the first object in 
  <t><t>  the vertical list.
  <t><t>- FirstTab The object is the first object in the 
  <t><t>  Tab list.
  <t><t>- LastHorizontal The component is the last object 
  <t><t>  in the horizontal list.
  <t><t>- LastVertical The component is the last object in 
  <t><t>  the vertical list.
InputFocus.NextHorizontal <t><t>Object name of the next component in the 
                          <t><t>horizontal list.
InputFocus.NextVertical   <t><t>Object name of the next component in the 
                          <t><t>vertical list.
InputFocus.NextTab        <t><t>Object name of the next component in the 
                          <t><t>Tab list.
</topic>

<topic>GeDynPulldownMenu <style>function
PulldownMenu

Action for a pulldown menu, or for a submenu in a pulldown menu.

A pulldown menu consists of a number of menu alternatives that either are pushbuttons or
submenus.
The number of alternatives in the menu is configured in ItemMask, a menu can contain up to 32
menu alternatives. For each alternative you choose an action type. For pushbuttons you can
choose between SetDig, ResetDig, ToggleDig, Command, Help, OpenGraph, CloseGraph, OpenURL 
and IncrAnalog. Submenus should have action type PulldownMenu, and for this you configure 
the number of menu alternatives and the actiontypes in the same way as for a pulldown menu.
Submenus can be built in an unlimited number of levels.

<b>Attribute <t><t>Description
Text                   <t><t>Pulldown menu text.
PulldownMenu.ItemMask  <t><t>Mask that states the number of menu alternatives.
PulldownMenu.ItemText1 <t><t>Text of the first menu alternative.
PulldownMenu.ItemDyn1  <t><t>Dynamic for the first menu alternative. Contains
                       <t><t>action type, and possible access, for the alternative.
PulldownMenu.ItemText2 <t><t>Text of the second menu alternative.
PulldownMenu.ItemDyn2  <t><t>Dynamic for the second menu alternative.
</topic>

<topic>GeDynOptionMenu <style>function
OptionMenu

Option menu is menu where you select an alternative in a list of alternatives. The chosen
alternative is displayed in the menu component. When you click on the component, the list
of alternatives is displayed. When an alternative is chosen, the list is closed, and the 
selected alternative is displayed in the component.

The option menu is connect to a database attribute of type float or int. Each alternative in 
the list corresponds to an enumeration value, and when an alternative is selected, the value
is inserted into the database attribute. The component is continuously reading the value of the
databas attribute, and displays the corresponding text in the text field.

The option men can be static or dynamic. For a static meny you state the texts and 
enumeration values in different items. For a dynamic meny the meny text are fetched
from a database attribute of type array of String80. The number of texts in the menu is
fetched from an attribute of type Int32, and further more you should state an attribute
that indicates that new texts should be loaded. This attribute should be of type Boolean
and the new texts are loaded when the value is changed from 0 to 1.

<b>Attribute <t><t>Description
OptionMenu.Type	      <t><t>Type of option menu. Static or dynamic.

<b>Static menu

OptionMenu.Attribute  <t><t>Database attribute of type Float32, Float64, Int32,
                      <t><t>UInt32, Int16, UInt16, Int8 or UInt8. The value in
                      <t><t>ItemEnum for a selected alternative inserted into the 
                      <t><t>database attribute.
OptionMenu.ItemMask   <t><t>Mask that states the number of menu alternatives.
OptionMenu.ItemText1  <t><t>Text of the first menu alternative.
OptionMenu.ItemEnum1  <t><t>Enumeration value of the first menu alternative.
OptionMenu.ItemText2  <t><t>Text of the second menu alternative.
OptionMenu.ItemEnum2  <t><t>Enumeration value of the second menu alternative.

<b>Dynamic menu

OptionMenu.Attribute  <t><t>Database attribute of type Float32, Float64, Int32,
                      <t><t>UInt32, Int16, UInt16, Int8 or UInt8. The value in
                      <t><t>ItemEnum for a selected alternative inserted into the 
                      <t><t>database attribute.
OptionMenu.TextAttribute <t><t>Database attribute of type array of String80. The array
		      <t><t>contains the texts that are displayed in the menu.
OptionMenu.SizeAttribute <t><t>Database attribute of type Int32. States the number of
		      <t><t>alternative in the menu.
OptionMenu.UpdateAttribute <t><t>Database attribute of type Boolean. Should be set to 
		      <t><t>1 when new texts are present in the TextAttribute. New 
		      <t><t>texts are loaded when the value is changed from 0 to 1.
</topic>
</headerlevel>
<pagebreak>

<topic>geref_create_subgraph
Create a subgraph

You create a subgraph by drawing base objects in the working area. Here you also have access to
connection points and annotations.

Mark that the graph is a subgraph by opening 'File/Graph attributes' and set 'Subgraph' to 1.

<b>Attribute <t>Description
DynType     <t>Type of dynamic. The instances will inherit this as their default dynamic.
Action      <t>Type of action. The instances will inherit this as their default action.
Color1      <t>The first color that the instances will inherit as default.
Color2      <t>The second color that the instances will inherit as default.
Color3      <t>The third color that the instances will inherit as default.
Color4      <t>The fourth color that the instances will inherit as default.
AnimSequence <t>Type of animation when DynType is Animation.
NoConObstacle <t>Indicates that connections should ignore instances of this subgraph.
              <t>Connections of type 'routed' normally avoids subgraph objects,
              <t>though if NoConObstacle is set, connections can cross the object.
Slider      <t>Indicates that the subgraph is a slider.
Subgraph    <t>Should be 1 for a subgraph.
AnimationCount <t>Used for animations. States the number of cycles the animation 
            <t>stays at this page.
JavaName    <t>When exported as a java bean, the subgraph will be exported as
            <t>java class with this name.
Cycle       <t>Default value for cycle, slow or fast, that instances
            <t>will inherit as default.
x0          <t>In (x0, y0) and (x1, y1) you can state the max size of a subgraph
            <t>in the case where the subgraph has pages with different extension.
y0          <t>See x0. Also used by some subgraphs with DynType Slider,
            <t>Sliderbackground and FillLevel.
x1          <t>See x0.
y1          <t>See x0. Also used by some subgraphs with DynType SliderBackground
            <t>and FillLevel.
Dynamic     <t>Not implemented.

Save the subgraph with 'File/SaveAs...'. Copy the .pwsg file that is created to $pwrp_exe.
The subgraph should now be visible under the Local/Subgraphs folder in the subgraph palette.

Its advisable to draw subgraphs close to origin in the working area, because when creating
a subgraph, the position of the mouse click corresponds to origin. Connection points should be
positioned on grid points, if rectangular connections are used to connect the instances. You
then avoid notches in the connections lines.

<h2>External och internal subgraphs
When you for the first time in a graph create an instance of a certain subgraph, this is loaded
from the .pwsg-file. As default it is internal, which means that the subgraph is saved together
with the graph, and the .pwsg-file is not needed any more, i.e. you don't need to concern
yourself with copying it to operator and process nodes. This will work, until you need to 
change the subgraph. As long as the subgraph is internal, the changes will not come along.
To get in the changes, the subgraph has to be external. When the graph then is saved, the 
subgraph will not be saved together with the graph, and when reading the graph next time, the
subgraph is loaded from the .pwsg-file. When the changed version is loaded, you can again reset
to internal.

To rearrange a subgraph from internal to external and vice versa, you activate 
'Loaded Subgraphs' under 'File' in the menu. Here you get a list of all loaded subgraph and
can set them as external or internal.

<h2>Slider
A slider is a specific type of subgraph. A slider is moved horizontally or vertically between 
two endpoints, and the position is transferred, after conversion, to an analog value in the 
database.

<b>With background
The easiest way to configure a slider, is to put a SliderBackground object behind the slider.
Then, the only thing you have to do, is to connect the slider to an analog signal.

<b>Without background
If you absolutely don't want to have any background to the slider, you have to state the
direction, and minimum and maximum position for the movement. A horizontal slider is configured
in the following way (vertical configuration inside parentesis).

Position the slider on the lowest y (x) coordinate for the slider movement. Remember the origin
is positioned in the upper left corner. 
Measure the minimum and maximum values for the movement of the slider, relative to the upper
(left) side of the slider by placing the cursor there. The position of the cursor is present in
the lower right corner of the window. Enter these values in the attributes MaxPosition and
MinPosition from the object editor for the object. State also the direction, Up indicates a
vertical slider with increasing value upwards, Right a horizontal slider with increasing value
to the right etc.

<b>Attribute <t>Description
Attribute <t>Signal in the database of type Float32 or Int32 that is changed when the slider 
          <t>is dragged.
Access    <t>Privileges required to change the value of the signal.
Direction <t>Only has to be stated if there is no SliderBackground object.
          <t>Direction of the slider. Up implies a vertical slider with increasing
          <t>value upwards, Right a horizontal slider with increasing value to the right.
MaxValue  <t>Value of the signal that corresponds to the max position of the slider.
MinValue  <t>Value of the signal that corresponds to the min position of the slider.
MaxPosition <t>Only has to be stated if there is no SliderBackground object.
          <t>x or y coordinate for the max position of the slider (see above).
MinPosition <t>Only has to be stated if there is no SliderBackground object.
          <t>x or y coordinate for the min position of the slider (see above).
</topic>
</chapter>

<chapter>
<topic>geref_groups
Groups

A group is a number of objects that appear and behave as a single object when moved, scaled,
rotated etc. A group is created by selecting the object that should belong to the group, and
activating 'Functions/Group' in the menu. If you want to resolve a group, you select the group
and activate 'Functions/Ungroup' in the menu.

There are some limitations in objects that can be a part of a group, connections for example
are not allowed in groups, and sliders will loose their sensitivity.

<h2>Dynamics
One property for groups is that you can specify dynamic to them. All types of dynamics and
actions available for subgraphs, are also available for groups.

The types of dynamic that includes a change of color or color tone, will affect all the objects
in the group that has no dynamic of its own. Subgraphs that should follow the color of the 
group, should have No as dynamic type (xtt and java here work a bit different).
Subgraphs and subgroups within the group that has its own dynamic, will role over the color
itself.

When you resolve a group, that has some kind of dynamic type, the data of the dynamic is lost.
To simplify the situations when you temporary resolve a group to do some modifications of a
group member, there is a function that tries to recover the dynamic. When you resolve the group,
the dynamic data is saved in a recall buffer with the group name as key. Furthermore the group
name is also saved in all the members of the group. When you later regroup the objects, you
look for the group that the majority of the objects has been a member of, and try to find the
dynamic for this group in the recall buffer. If it is found, it is inserted as dynamic for the
new group. There are cases when the restoring of dynamic doesn't work, so it is advisable to
check that the dynamic is correctly recovered after having temporary dissolved of the group. If 
something has gone wrong, you can usually find the dynamics in the recall buffer, that is 
handled from the object editor with 'Functions/Recall' and 'Functions/Recall previous'.
</topic>
</chapter>

<chapter>
<topic>geref_images
GIF and JPEG images

GIF and JPEG-images are here called images.

<h2>Create an image
You create an image in the same way as a subgraph. GIF and JPEG images are found under the
'Images' folder, and under the 'Local/Images' folder. If you want to read a specific GIF of
JPEG file you copy it to $pwrp_pop. The file is then found under the 'Local/Images' folder. By
selecting it and clicking MB2 in the work area you create the image object.

An image can be scaled and rotated in steps of 90 degrees. Functions for color tone, lightness,
intensity and color shift also applies to images.

<h2>Dynamik
To put dynamics behind an image, you first have to make a subgraph of the image, or let it be
a member of a group. If you want to change the color dynamically, you should use a dynamic
type that changes the color tone, e.g. DigTone. Change of fill color of an image will have no
effect.

<h2>Transparency
If you have an image of a symbol that is not rectangular, e.g. a round indicator, you want the
area outside the indicator to be transparent.

The GIF-format supports transparency. By choosing the transparency color (R: 255, G: 0, B: 255) 
the transparency will also work in Ge.

Java doesn't support transparency of GIF-files. Though the Ge image class will insert 
transparency in pixel that has (R:255, G:255, B:255) i.e. white. This though can imply that
white areas of the image are viewed as transparent.
</topic>
</chapter>

<chapter>
<topic>geref_connections
Connections

The subgraph objects that contains connection points can be connected with connections.
Connections are drawn by dragging MB2 from one object to the other. The connection point that
is closest to the cursor when you press or release the mouse is selected.

Connections are characterized by type, line width, 3D and color.

<h2>Typ
Type is selected from the menu under 'Connections'.

<b>Straight
A straight line connection between the connection points.

<b>StraightOneArrow
A straight line connection with one arrow.

<b>Routed
Connection with horizontal and vertical lines. The route and breakpoints of the connection
are caculated to avoid collision with other subgraph objects (that don't has the attribute
NoConObstacle set).

<b>Grafcet
There are a number of connections used when drawing grafcet sequences: StepDivergence,
StepConvergence, TransDivergence and TransConvergence. These can be used, together with the
subgraphs under the folder Grafcet in the subgraph palette, if you want to view a grafcet
sequence in a graph.

<h2>Round corners
For connections of type routed, you can choose to have rounded corners, and you can also
specify the radius of the rounding. This is chosen in the menu, 'Connections/Corners' and
'Connections/CornerRoundAmount'.

<h2>Color
The color of the connection is selected as fill color, that is with MB1 in the color palette.

<h2>Border
With 'Border', the connections is draw with black borderlines.

<h2>3D
With '3D', a lighter shadow is drawn on the upper side, and a darker on the lower side. Only
implemented for connections of type Routed and round corners.

<h2>Width
The width is chosen in the tool panel in the same way as for lines.

<h2>Ramification
If a connection is drawn from a component and released in the working area, a component of type
ConGlue is created at the end of the connection. ConGlue has four connection points and works
either as a termination, or as a ramification of the connection, or as a possibility to 
influence the route of the connection. By drawing new connections from ConGlue, new connections
are created, and the ConGlue object adapts its color and shape after its connected connections.

ConGlue is also found in the subgraph palette under 'Other'.
</topic>
</chapter>

<chapter>
<topic>geref_edit
Editing

Ge contains a number of functions to create objects, modify them, order them etc. The functions
are found in the tool panel or in the menu, and som are activated with mouse clicks.

<h1>Create objects
Base objects are created by choosing an object type in the tool panel, and then dragging or
clicking in the working area with MB1. If you press the Shift key while the object type is
chosen, you can create several objects without choosing object type again. A more detailed
description of how to create each object type is found in the chapter Object.

An instance of a subgraph or a complex object, is created by selecting the object in the 
subgraph palette an clicking MB1 in the working area.

<h1>Create connections
Connections are created by dragging MB2 between two subgraph object that contains connection
points.
First you set the proper connection type from 'Connections' in the menu.

<h1>Reset
By clicking with MB3 you reset or terminate most functions: clear the list of selected objects,
end drawing of a polyline, end scaling, end polyline editing.

<h1>Select objects
An object or connection that is selected is marked with red color. This is not valid when you
change the color of the selected objects. Then the object is drawn with the new color so that
the effect of the color change can be examined.

Objects are selected in the following ways

- Click on the object with MB1. Previously selected objects are removed from the select list.
  If the object already is selected, the select list is cleared.
- Click on the object with Shift MB1. The object is added to the select list. If the object
  already is selected it is removed from the select list.
- Drag with MB1. A rectangle is drawn and objects positioned totally inside the rectangle 
  becomes selected. Previously selected objects are remove from the select list. Note that as
  you also move objects with drag MB1, you should not hit any object when starting to drag.
  If there is an object covering the background, you can use Shift MB1 instead (se below).
- Drag with Shift MB1. Object inside the rectangle are added to the list of selected objects.
- 'Select all objects' under 'Edit' in the menu selects all objects.
- 'Select all connections' selects all connections. 

The list of selected objects is cleared by clicking MB1 in an empty space in the working area
or by clicking MB3 in the working area.

<h1>Move objects
An object is moved by MB1. If you want to move several objects simultaneously, you select the
objects. If you now move one of the selected objects the other selected objects will follow.

If you want to move objects vertically or horizontally you first select 'Move Restrictions'
under 'Edit' in the menu. Move Restrictions are reset by MB3.

<h1>Cut, copy and paste
You copy objects by selecting the objects that are to be copied, and copy them to the paste
buffer with Ctrl+C. With Ctrl+V the objects are copied to the working area, and follows the
movement of the cursor until you click MB1 to fasten them. Cut works in the same way with
Ctrl+X.

<h1>Grid
Grid and grid size are chosen from the tool panel.

<h1>Scaling
The scaling function is activated from the tool panel and affects selected objects. The selected
objects are framed by a rectangle. By dragging a corner or side of the rectangle, the selected
objects are scaled. If you drag a side, the scaling is vertical or horizontal, if you drag a 
corner the scaling is unlimited. By activating 'Functions/ScaleEqual' you get a conform scaling
in x and y direction.

<h1>Rotate
Selected objects are rotated 90 degrees clockwise when the rotate function in the tool panel
is activated. The 90 degrees rotation works för all objects except texts. If you want to
totate with another angle, this is done from 'Edit/Rotate' in the menu. Here you can enter an
arbitrary angle. Note that only lines, polylines and circles can handle arbitrary rotations.
If you want subgraphs to be able to handle arbitrary rotation, you have to build them with
lines and polylines.

<h1>Order objects
<h2>Vertically
Objects that are placed vertically can be left aligned, right aligned or centered, by using
'Align/vertical' under 'Functions' in the menu. Select the object that are to be aligned and
activate the menu entry.

<h2>Horizontally
Objects that are placed horizontally can be aligned regarding the upper side, the lower side or
the center, by using 'Align/horizontal' under 'Functions' in the menu. Select the objects that
is to be aligned and activate the menu entry.

<h2>Concentric circles
Concentric circles are achieved by first activating 'Align/vertical/center' and then
'Align/horizontal/center'.

<h2>Equal distance between objects
Objects that are placed vertically or horizontally, often should have the same distance between
them. This is achieved by 'Equidistance' under 'Functions' in the menu. The Equidistance 
function for horizontal objects, keeps the position of the leftmost and rightmost objects, and
adjusts the position of the objects between, to get the same distance between them. The distance
is measured from the left border, right border or the center. In a similar way vertically objects
are ordered with 'Equidistance/Vertical'.

<h1>Over or under
If objects overlap, you can move them over or under with 'Pop' and 'Push' under 'Functions' in 
the menu. Pop puts an object on top of all other objects in the graph, and Push puts the object
beneath all other objects. If you want to put an object between two objects, some thinking is
required to activate the pop and push in the correct order.

<h1>Colors
<h2>Background color
The background color in the graph is set by selecting a suitable fill color in the color 
palette, and then activating 'Set background color' under 'Functions' in the menu.

<h2>Object colors
Object colors are divided in fill color and border color. The filled part of the objects is 
drawn with the fill color and the border is drawn with the border color. Some objects, for 
example lines, are only drawn with border colors. The colors are selected in the color palette,
fill color is selected with MB1 and border color with MB2. The currently selected colors are 
displayed in rectangles topmost in the palette, fill color to the left and border color in the 
middle. When base objects are created, the object are given the currently selected colors in 
the palette. If you want to change the color of an existing object, you select it and select a 
new fill or border color in the palette. Note that the objects after this operation are not 
drawn with red color, though they are selected. For that reason you should always clear the 
select list by clicking MB3 after the operation.

<h2>Subgraph object colors
You can change the color of a subgraph object in the same way as you change the color of a
base object, by selecting them, and state a border or fill color. Object that is drawn with
shadows and 3D effects might loose these effects if you change the fill color. There are special
functions to change the color of subgraph objects, color tone, lightness, intensity and color 
shift. In the chapter Subgraphs this is described in more detail. 

<h1>Connection to the database
When a subgraph object is to influence or be influenced by a signal in the database, you have 
to state this in the attributes of the subgraph. One way is to enter the signal name by hand 
in the  object editor. Another and smoother way is to use the plant hierarchy that is found 
over the navigation window. In the plant hierarch you select the object you want to connect the 
subgraph object to, and then you click on the subgraph object with Ctrl/Doubleclick MB1. 
If there are two database attributes in the subgraph object, the first is connected in this way,
and the second with Ctrl/Shift/Doubleclick MB1. You can also open the object editor and click
on the attribute row with Ctrl/Doubleclick MB1 to insert the signal. If you are connecting a 
signal it is enough to select the object in the plant hierarchy, the attribute ActualValue is 
selected automatically. If it is another type of object, you have to state which attribute to 
connect to the subgraph object. This is done by opening the object with Doubleclick MB1, and 
the select the desired attribute.

You can also select the object in the configurator.

<h2>Suffix
To the signal name, a suffix should be added, that tells the type of the attribute.
For some types of dynamics, where the type is obvious, it might work without suffix.
The following types of suffix can be stated:

##BOOLEAN
##FLOAT32
##FLOAT64
##CHAR
##INT8
##INT16
##INT32
##UINT8
##UINT16
##UINT32
##OBJID
##STRING
##TIME
##DELTATIME
##ATTRREF

If the attribute is a string or an array, the size should also be stated.

<h1>Graph attributes
Under File in the menu you find 'Graph attributes' and here you can enter attributes for the
graph.

Here you state which part of the working area that is to be displayed in runtime. The 
coordinates for the upper left corner and lower right corner are measured with the cursor and
entered in x0, y0 and x1, y1 respectively.

<b>Attribute <t>Description
subgraph    <t>States that the graph is a subgraph. In this case the attributes
            <t>below are not valid.
x0          <t>x-coordinate for the upper left corner of the graph.
y0          <t>y-coordinate for the upper left corner of the graph.
x1          <t>x-coordinate for the lower right corner of the graph.
y1          <t>y-coordinate for the lower right corner of the graph.
Scantime    <t>Cycle time in seconds for update objects that runs with 
            <t>the slow cycle.
FastScantime <t>Cycle time in seconds for update objects that runs with 
            <t>the fast cycle.
AnmationScantime <t>Cycle time in second for animations in the graph.
JavaWidth   <t>Width in pixels that the graph is scaled to when exported to java.
IsJavaApplet <t>The graph is exported as a java applet when exported.
IsJavaFrame <t>The graph is exported as a java frame when exported.
BackgroundImage <t>Name of a gif or jpeg image for the background image.
BackgroundTiled <t>The background image is tiled, not scaled.
DoubleBuffered <t>The graph is double buffered, i.e. it is first drawn
             <t>in a pixmap in memory that is then copied to the sreen.
             <t>Should be used if the graph contains mobile objects or animations.

<h1>Object and hierarchy graphs
This chapter describes how to create Ge graphs that displays the content of an object of a 
certain class, and is able to display all object of that class. It also describes how you can
construct common graphs for similar hierarchies in the Proview database.

<h1>Object graph
For some classes that belongs to Proview baseclasses, there are so called object graphs, i.e.
graphs that can be opened for each instance of the class. Object graphs exist for example for
the classes PID, Mode, Av, Ai, Ao, Di, Do and Dv, and is opened with the command 
'open graph/instance=' where you in /instance supply the name of the object. You can also open
the object graph by selecting the object and activate 'Functions/Open object graph' in the xtt
menu.

If you have created a user class, you can draw an object graph for this class. You edit the graph
as a normal ge graph. The difference is when you are about to connect the dynamic objects to
database objects. Where you normally write an object name, you instead write '$object'. Data for
an indicator connected to the attribute ActualValue might look like this.

<b>Attribute <t><t>Value
SubGraph <t><t>pwr_indsquare
LowColor.Attribute <t><t>$object.ActualValue##Boolean
LowColor.Color  <t><t>Inherit
Cycle   <t><t>Inherit
DynType <t><t>Inherit
Action  <t><t>Inherit

The graph is saved with the same name as the class, but with lower case.

The command to open the object graph for the object H1-H2-MyObject of class MyClass is

<c>open graph /classgraph /instance=H1-H2-MyObject

<h1>Hierarchy graph
Often there are plant parts in a system that are identical and that are configured with nearly
identical hierarchies. You can for example have 30 identical frequency converters, and there
is an possibility to, instead of drawing 30 identical graphs, draw one generic graph that can
display all the frequency converters. The procedure is similar to object graphs above. The
hierarchy that is supplied in /instance in the open graph command when the graph is opened,
will replace all occurrences of $object in dynamic connections in the graph.

Data for an indicator that is connected to the Dv Start can look like this 

<b>Attribute <t><t>Value
SubGraph  <t><t>pwr_indsquare
LowColor.Attribute <t><t>$object-Start.ActualValue##Boolean
LowColor.Color  <t><t>Inherit
Cycle   <t><t>Inherit
DynType <t><t>Inherit
Action  <t><t>Inherit

Then the picture is opened with the command

<c>open graph my_fo_graph /instance=H1-H2-Fo1.53

the indicator is connected to the attribute H1-H2-Fo1-Start.ActualValue.

Also in commands that is executed by pushbuttons in the graph, the string $object will be
replaced by the hierarchy name. This makes it possible to open object graph or trends of objects
within the hierarchy from pushbuttons. The command to open the object graph for a Mode object
could be

<c>open graph /classgraph /instance=$object-Plc-W-Mode0/name=$object

Example of a command to open a trend from a plotgroup in the hierarchy

<c>open trend $object-Plot
</topic>
</chapter>

<chapter>
<topic>geref_testing
Testing

<h1>Preview
There is a function to test the graph immediately in the editor. One requirement is that you
have to start the Proview runtime environment on the development station, to be able to find 
signals that occurs in the graph. From 'View/Preview' in the menu, the editor connects to the
database and starts executing the dynamic of the graph. Preview is closed with 'View/Preview 
close' and then you can continue to edit the graph.

<h1>Xtt
By starting xtt in the development environment or in an operator/process station, you can also
easily test the graph. The only requirement is that the .pwg file for the graph is present on
$pwrp_exe. You open a Ge graph with the command

<c>xtt> open graph 'graphname' [/width=][/height=][/scrollbar][/navigator]

With the command

<c>xtt> show graph

all the available graphs are listed.
</topic>
</chapter>

<chapter>
<topic>geref_development
Development environment

This is a short description of directories and files that are used by Ge, and what files are
generated.

<h1>File types
Ge reads graph files and save graph files in the directory $pwrp_pop.

A graph is saved as a file of type .pwg. A subgraph is also saved as a .pwg-file, that is used
when the subgraph is edited, but it is also saved as a .pwsg-file. It is the .pwsg-file that
is loaded when you create instances of the subgraph.

If you export the graph as a java application (frame) you create a .java-file with the name 
specified as java name.

If you export the graph as a java applet, a java-file is created with the name stated as 
java name with the suffix _A, e.g. Oversikg_A.java. Furthermore a html files is created with
the class name as name.

<h1>Setup-files
Ge uses two setup files, one for the color palette, and one for the subgraphs palette.

<h2>Color palette
If you want to modify the colors in the color palette, this is possible by creating av file
with the name ge_colors.dat. This should contain the rgb-codes for the colors in the palette.
There is a template in ...

<h2>Subgraph palette
The subgraph palette contains a collection of fix menus and subgraphs, and the folder Local
that displayes the subgraphs and images in $pwrp_pop. Most of the fix menus and subgraphs are
configured in the file pwr_ge_setup.dat. This file is common for all projects but can be modified
by the system manager.
</topic>
</chapter>

<chapter>
<topic>geref_command
Commands

Ge contains a command line that is opened from the menu or by Ctrl/b. The command is mainly
considered to be used in ge scrips, but can also be executed from the command line. From the
command line ge script is also executed by writing the name of the file preceded by a '@'.
Note that a change of functions in the editor made via a command is not viewed in the 
optionmenus or check boxes. When a scrip is run the setting can differ from what is viewed.
</topic>
</chapter>

<chapter>
<topic>geref_script
Script

The script handling in Ge is described in the chapter Ge script and commands. Here some examples
are viewed to get an idea of what scripts can do.

<h2>To use a script
A script is executed from the command line in Ge by setting a '@' before the filename, for 
example

<c>ge> @my_script

The command line is opened from Functions/Command (Ctrl+B).

<b>Example 1
The first example is a script that exports some subgraphs to java. Often you have made a lot
of modifications in different graphs, and when you are ready, everything is to be exported to
java. This script reads the different graphs and export them.

<c>!
<c>! Export java
<c>!
<c>function int process( string graph)
<c>  open 'graph'
<c>  printf( "Exporting %s...\n", graph);
<c>  export java
<c>endfunction

<c>main()
<c>  process( "nu4_alla_platar");
<c>  process( "nu4_status_trp");
<c>  process( "nu4_trp_hy1");
<c>  process( "nu4_trp_rb_ut");
<c>  process( "nu4_buffhog");
<c>  process( "nu4_status_ugn");
<c>  process( "nu4_trp_lu1");
<c>  process( "nu4_trp_start");
<c>  process( "nu4_inlagg");
<c>  process( "nu4_trend");
<c>  process( "nu4_trp_rb1");
<c>  process( "nu4_ugn_start");
<c>endmain

<b>Example 2
Next example shows how to change a subgraph in several graphs. A subgraph is normally intern,
and a modification does not take effect until you have performed the procedure to

- set the subgraph extern
- save the graph
- read the graph, now with the modified subgraph
- set the subgraph intern again
- save the graph

If you often modify you subgraphs you can with advantage write a script that replaces a subgraph
in all graphs of the project.

<c>!
<c>! Replace a subgraph
<c>!
<c>function int process( string graph)
<c>  int sts;
<c>  printf( "Processing graph %s\n", graph);
<c>  open 'graph'
<c>  sts = SetExtern("my_subgraph");
<c>  if ( sts)
<c>    printf( "Changing my_subgraph\n");
<c>    save
<c>    open 'graph'
<c>    SetIntern( "my_subgraph");
<c>    save
<c>  endif
<c>endfunction

<c>main()
<c>  process( "nu4_alla_platar");
<c>  process( "nu4_status_trp");
<c>  process( "nu4_trp_hy1");
<c>  process( "nu4_trp_rb_ut");
<c>  process( "nu4_buffhog");
<c>  process( "nu4_status_ugn");
<c>  process( "nu4_trp_lu1");
<c>  process( "nu4_trp_start");
<c>  process( "nu4_inlagg");
<c>  process( "nu4_trend");
<c>  process( "nu4_trp_rb1");
<c>  process( "nu4_ugn_start");
<c>endmain
</topic>
</chapter>

<chapter>
<topic>geref_web
Web graphs

<h1>Export as a java applet
If a graph should be viewed in a web browser, you can export it as a java applet. First you set
the attribute IsJavaApplet in 'File/Graph attributes'. Thereafter you activate 
'File/Export Java', that exports the graph to java applet format and compiles the java file. 
Furthremore a html file is created to open the applet. The html file together with a java 
archive with the applet class are put in the direction $pwrp_web. By copying the files on 
$pwrp_web to a corresponding directory on the web server, you can open them in a web browser.

<b>Limitations
The java version lf a Ge graph differs in appearance and function compared to Ge and Xtt in
some points.
- The format statements to view floating point, integers and string should be of type %n.mf, 
  %-n.mf, %d, %nd, %s where n and m are digits.
- The width of the borderlines in a subgraph is scaled in the subgraph as a whole.
- When a dynamic object is changed the background or possible covering objects are not redrawn,
  i.e. dynamic object should not be covered by other objects, and texts that are changed has
  to have a background in the subgraph.
- Subgraphs can not contain groups. This implies compilation errors.
- Base objects are always drawn under components. If you for example place a text on top of a
  component, the text will be hidden.

<h1>Configure a web site
To be able to open the varoius process graphs in a system it is suitable to have web page
with a menu to the left and actual graph to the right. With some configuration you can generate
such a page from 'Generate web' in the menu.

This is how the configuration is done:
Create a WebHandler object under the node object in the node hierarchy. The WebHandler object
will cause the start of a server process that supplies the graphs with the dynamic information
from the realtime database. In the object you also state if you should be able to log in as a 
Proview user. Under the WebHandler object you create a WebGraph object for each graph that is
to be opened from the menu.
Under the WebHandler object, you can also create WebLink objects. Each WebLink object give rise
to a menu entry that is connected to an URL, e.g. documents for working instructions, function
specifications etc.

All files required for the web site are gathered in the directory $pwrp_web. By copying these
files, together with the files $pwr_lib/pwr_rt_client and $pwr_lib/pwr_jop.jar, to a suitable
directory in the web server, the operator station is available on the net.
</topic>
</chapter>

<chapter>
<topic>geref_runtime
Runtime

When the graph is completed it is to be displayed in an operator station, an process station
or on the intranet.

<h1>Maintenance graphs in xtt
Maintenance graphs can be opened without configuration from the command line in xtt, which
is described in the chapter Test. This works as long as you yourself and other informed persons
should have access to the graphs. If a broader group should have access to them, you can build
a menu tree in xtt. This is done by writing commands in the xtt setup file. The setup file
~/xtt_setup.rtt_com is executed each time xtt is started. Here you can define symbols and add
commands to create menus. Below is an example of a symbol file that creates a simple
maintenance menu.

<c>create item/text="Maintenance"/menu/dest=DataBase/before
<c>create item/text="Overview"/command="open graph overview" /menu 
<c>  <t>/dest=Maintenance /firstchild
<c>create item/text="Blast"/command="open graph blast" /menu 
<c>  <t>/dest=Maintenance /firstchild
<c>create item/text="Roller bed"/command="open graph rollerbed" /menu 
<c>  <t>/dest=Maintenance /firstchild

<h1>Operator graphics in xtt
If the graphs is to be operator graphics you build an operator place with an OpPlace object, 
an User object and XttGraph objects. Xtt is started with the name of the OpPlace object as 
argument.

<h1>Java applications in xtt
A ge graph can be exported as a java frame. This is opened in xtt with the command 
'open jgraph'.

<h1>Web graphs
To view process graphs on the intranet, you have to install a web server in an operator station.
We recommend Apache on Linux.

In Proview you create a WebHandler object in the noder hierarchy, to start a server process
in runtime that supplies the web graphs with database data.

<h1>Distribution
<h2>xtt
To be able to open a graph in xtt, the .pwg-file for the graph has to be copied from $pwrp_pop
in the development environment to $pwrp_exe in the runtime environment. Also local subgraphs
that are defined as extern has to be copied. In this case you copy the .pwsg file.
Local image files also has to be copied.

<h2>Web
Graphs exported as java applets, are compiled and inserted into the java archive
$pwrp_lib/pwrp_'systemname'_web.jar. Also GIF and JPEG images that reside on $pwrp_pop are
inserted into the archive. This archive has to be copied to the application directory of the 
web server together with the .html files that is generated by 'export java'. To the application
directory of the web server should also be copied $pwr_lib/pwr_rt_client.jar and 
$pwr_lib/pwr_jop.jar.

<h2>Java-applications
Graphs exported as java frames, are compiled and inserted in the archive
$pwr_lib/pwrp_'systemname'.jar. Also GIF and JPEG images that reside on $pwrp_pop are inserted
into the archive. The archive should be copied to $pwrp_lib on the target node. Together with
the archives $pwr_lib/pwr_rt.jar and $pwr_lib/pwr_jop.jar they shall be inserted in the
CLASSPATH in the target node.
</topic>
</chapter>

<chapter>
<topic>gecmd
Ge script och commands
<option> printdisable
Introduction to script <link>gecmd_intro
Commands <link>gecmd_command
Script <link>gecmd_script
<option> printenable
</topic>

<topic>gecmd_intro
Introduction to script
In Ge there is a collection of commands to create graphic elements as rectangles, texts, 
polylines and subgraphs. These commands can be executed from the command line in Ge, or 
executed from script files that is executed from the command line.

The script files can furthermore contain a language similar to c, that contains operators för
calculations, if statements and for loops etc. There are also functions to fetch information
from the development database. See the manual for Wtt Script for more information.

Ge script can for example be used to convert graph from other systems to ge graphs, or to
automatically generate forms or graphs from objects in the database.

<h1>Create objects
Base objects as rectangles, lines etc. are created by the create command. Before the object
is created you set the disired properties of the editor (fill, border, fill color, text size 
etc.) and then you create the object.

<h2>Rectangle
An example of a filled rectangle

<c>set fill
<c>set linewidth 1
<c>set bordercolor 0
<c>set fillcolor 19
<c>create rect /x1=10 /y1=1 /width=4  /height=2

<h2>Circle
An example of a half circle

<c>set nofill
<c>set linewidth 2
<c>set bordercolor 0
<c>create arc /x1=1 /y1=1 /x2=3 /y2=2 /angle1=0 /angle2 =180

<h2>Line
Line example

<c>set linewidth 1
<c>set bordercolor 0
<c>create line /x1=0 /y1=0 /x2=10 /y2=0

<h2>Polylinje
To create to polyline, you create the first segment with 'create', and the following segments
with 'add'.

Polyline example

<c>set nofill
<c>set linewidth 1
<c>set bordercolor 0
<c>create polyline /x1=5 /y1=5 /x2=6 /y2=6
<c>add polyline /x1=5 /y1=7
<c>add polyline /x1= 6/y1=8
<c>add polyline /x1=5 /y1=9
<c>add polyline /x1= 6 /y1=10

<h2>Text
Example

<c>set textsize 14
<c>set bold
<c>create text/text="Example" /x1=3 /y1=5

<h2>Subgraph object
Creating subgraphs object is a bit different. Here you create the object first, and the set
the attributes of the object.

Valve example

<c>create object /sub=pwr_valve /x1=1 /y1= 1 /x2=3 /y2=2
<c>set current fillcolor 45
<c>set current attr attribute "Rt-Dv1.ActualValue##Boolean"
<c>set current attr lowcolor 3

Pushbutton example

<c>create object /sub=pwr_buttonset /x1=5 /y1=1
<c>! Change type to SetDigConfirmWithTone
<c>set current attr type 1014
<c>set current attr text "Start"
<c>set current attr ConfirmText "Do you really want to..."
<c>set current attr Attribute "rt-Dv1.ActualValue##Boolean"
<c>set current attr ToneAttr "rt-Dv2.ActualValue##Boolean"
<c>set current attr LowTone 8
<c>set current attr Access 65534

<h2>Graph attributes
Before saving the graph, you should state the borders in x and y direction for the graph, and
some other attributes. This is done with the command 'set graphattributes'.

Example

<c>set graph x0 -3
<c>set graph y0 -3
<c>set graph x1 40
<c>set graph y1 37
<c>set graph AnimationScanTime 0.2
<c>set graph BackgroundImage "corrado.gif"

<h2>Subgraph attributes
If the graph is to be saved as a subgraph, you also use 'set graphattributes'. You first set
the attribute 'subgraph' and thereafter the other attributes that belongs to a subgraph.

Example

<c>set graph subgraph 1
<c>! Type ToggleDigWithTone
<c>set graph TraceAttrType 1012
<c>set graph TraceColor 3
<c>set graph NoConObstacle 1

<h2>Colors
Colors are stated with index in the color palette (0-299). 0 is black, 30-59 gray tones,
60-89 greenyellow, 90-119 yellow, 120-149 orange, 150-179 red, 180-209 violet, 210-239 blue,
240-269 seablue and 270-299 green.

<h2>Color tone
Also the color tone is stated with index. See table below.

For dynamic types that changes the color tone you can often set a fill color instead of color
tone. You then state index for the fill color instead (a value in the interval 83-299).

<b>Index <t>Ton
0 <t>No tone
1 <t>Gray
2 <t>Yellowgreen
3 <t>Yellow
4 <t>Orange
5 <t>Red
6 <t>Violet
7 <t>Blue
8 <t>Seagreen
9 <t>Green
10 <t>Darkgray
</topic>

<topic>gecmd_command
Commands

Below is a description of commands in Ge

add 			<link>gecmd_add
  <t>add polyline 	<link>gecmd_add_polyline
create 			<link>gecmd_create
  <t>create rectangle 	<link>gecmd_create_rect
  <t>create arc 	<link>gecmd_create_arc
  <t>create line 	<link>gecmd_create_line
  <t>create polyline 	<link>gecmd_create_polyline
  <t>create rectangle 	<link>gecmd_create_rect
  <t>create text 	<link>gecmd_create_text
  <t>create subgraph 	<link>gecmd_create_subgraph
group 			<link>gecmd_group
move 			<link>gecmd_move
  <t>move currentobject	<link>gecmd_move_currentobject
  <t>move selectedobject <link>gecmd_move_selectedobject
new 			<link>gecmd_new
select 			<link>gecmd_select
  <t>select currentobject <link>gecmd_select_currentobject
  <t>select clear	<link>gecmd_select_clear
set 			<link>gecmd_set
  <t>set verify		<link>gecmd_set_verify
  <t>set noverify	<link>gecmd_set_noverify
  <t>set fill 		<link>gecmd_set_fill
  <t>set nofill		<link>gecmd_set_nofill
  <t>set border		<link>gecmd_set_border
  <t>set noborder	<link>gecmd_set_noborder
  <t>set grid		<link>gecmd_set_grid
  <t>set nogrid		<link>gecmd_set_nogrid
  <t>set linewidth	<link>gecmd_set_linewidth
  <t>set gridsize	<link>gecmd_set_gridsize
  <t>set textsize	<link>gecmd_set_textsize
  <t>set bold		<link>gecmd_set_bold
  <t>set nobold		<link>gecmd_set_nobold
  <t>set backgroundcolor <link>gecmd_set_backgroundcolor
  <t>set fillcolor	<link>gecmd_set_fillcolor
  <t>set bordercolor	<link>gecmd_set_bordercolor
  <t>set currentobject fillcolor <link>gecmd_set_current_fillcolor
  <t>set currentobject colortone <link>gecmd_set_current_colortone
  <t>set currentobject colorlightness <link>gecmd_set_current_colorlightness
  <t>set currentobject colorintensity <link>gecmd_set_current_colorintensity
  <t>set currentobject colorshift <link>gecmd_set_current_colorshift
  <t>set currentobject attributes <link>gecmd_set_current_attributes
  <t>set currentobject type <link>gecmd_set_current_type
  <t>set currentobject color <link>gecmd_set_current_color_
  <t>set currentobject colortone <link>gecmd_set_current_colortone
  <t>set currentobject access <link>gecmd_set_current_access
  <t>set currentobject attr1 <link>gecmd_set_current_attr1
  <t>set currentobject attr2 <link>gecmd_set_current_attr1
  <t>set currentobject annotation <link>gecmd_set_current_annotation
  <t>set graphattributes <link>gecmd_set_graphattributes
rotate 			<link>gecmd_rotate
  <t>rotate currentobject <link>gecmd_rotate_current
  <t>rotate selectedobject <link>gecmd_rotate_selected
scale 			<link>gecmd_scale
  <t>scale currentobject <link>gecmd_scale_current
  <t>scale selectedobject <link>gecmd_scale_selected
save 			<link>gecmd_save
exit 			<link>gecmd_exit
quit 			<link>gecmd_quit
open 			<link>gecmd_open
show 			<link>gecmd_show
  <t>show version <link>gecmd_show_version
</topic>

<headerlevel>
<topic>gecmd_add <style>function
add
</topic>

<topic>gecmd_add_polyline
add polyline

Add a breakpoint to the latest created polyline.
A polyline is created by 'create polyline' that also creates the first segment. The following
segments are created by 'add polyline'.

<b>Syntax

<c>ge> add polyline /x1= /y1=

/x1 <t>x-coordinate for the added segment.
/y1 <t>y-coordinate for the added segment.
</topic>

<topic>gecmd_create <style>function
create

Create graphic object in the graph.
</topic>

<topic>gecmd_create_rect
create rectangle

Create a rectangle.

<b>Syntax

<c>ge> create rectangle /x1= /y1= /width= /height=

/x1 <t>x-coordinate of upper left corner
/y1 <t>y-coordinate of upper left corner
/widht <t>Width of the rectangle.
/height <t>Height of the rectangle.
</topic>

<topic>gecmd_create_arc
create arc

Create a circle or an ellipse, or a segment of a circle or ellipse.

<b>Syntax

<c>ge> create arc /x1= /y1= /x2= /y2= /angle1= /angle2=

/x1 <t>x-coordinate of upper left corner of a rectangle the surrounds the ellipse.
/y1 <t>y-coordinate of upper left corner of a rectangle the surrounds the ellipse.
/x2 <t>x-coordinate of lower right corner of a rectangle the surrounds the ellipse.
/y2 <t>y-coordinate of lower right corner of a rectangle the surrounds the ellipse.
/angle1 <t>Angle that states the start of a circle segment in degrees.
    <t>Default value 0.
/angle2 <t>Angle that states the size of a circle segment in degrees.
    <t>Default value 360 degrees.
</topic>

<topic>gecmd_create_line
create line

Create a straight line between two points.

<b>Syntax

<c>ge> create line /x1= /y1= /x2= /y2=

/x1 <t>x-coordinate for the first end point.
/y1 <t>y-coordinate for the first and point.
/x2 <t>x-coordinate för the second end point.
/y2 <t>y-coordinate för the second end point.
</topic>

<topic>gecmd_create_polyline
create polyline

Create a polyline, i.e. a line that consists of several straight line segments.
'create polyline' creates the first line segment. The following segments are created by
'add polyline'. The point (x1, y1) is the starting point for the polyline. The next segment
is added to the point (x2, y2).

<b>Syntax

<c>ge> create polyline /x1= /y1= /x2= /y2=
<c>ge> add polyline /x1= /y1=
<c>ge> add polyline /x1= /y1=
<c>ge> ...

/x1 <t>x-coordinate for the starting point.
/y1 <t>y-coordinate for the starting point.
/x2 <t>x-coordinate for the ending point of the first segment.
/y2 <t>y-coordinate for the ending point of the first segment.
</topic>

<topic>gecmd_create_text
create text

Create a text.

<b>Syntax

<c>ge> create text /x1= /y1= /text=

/x1 <t>x-coordinate.
/y1 <t>y-coordinate.
/text <t>Text surrounde by quoutes.
</topic>

<topic>gecmd_create_subgraph
create subgraph
Create a subgraph object.

<b>Syntax

<c>ge> create subgraph /x1= /y1= /subgraph= [/x2= /y2=]

/x1 <t>x-coordinate for the upper left corner.
/y1 <t>y-coordinate for the upper left corner.
/subgraph <t>The name of the subgraph. If the subgraph is a part of the Proview
    <t>base system is always has the prefix 'pwr_' and is written with lower case,
    <t>e.g. 'Valve' has the name pwr_valve.
/x2 <t>If the point (x2, y2) is supplied, the subgraph is scaled to fit inside a
    <t>rectangle with the corner points (x1, y1) and (x2, y2).
/y2
</topic>

<topic>gecmd_group <style>function
group

Create a group of the selected objects.

</topic>

<topic>gecmd_move <style>function
move

</topic>

<topic>gecmd_move_currentobject
move currentobject

Move the current object. The movement can be specified with relative coordinates
(x and y) or absolute coordinates (absx and absy) or combinations.

<b>Syntax

<c>ge> move currentobject /x= /y=
<c>ge> move currentobject /absx= /absy=

/x <t>Relative movement in x direction.
/y <t>Relative movement in y direction.
/absx <t>Movement to absolute coordinate in x direction.
/absy <t>Movement to absolute coordinate in y direction.
</topic>

<topic>gecmd_move_selectedobject
move selectedobject

Move the selected object. The movement can be specified with relative coordinates
(x and y) or absolute coordinates (absx and absy) or combinations.

Only one object can be selected.

<b>Syntax

<c>ge> move selectedobject /x= /y=
<c>ge> move selectedobject /absx= /absy=

/x <t>Relative movement in x direction.
/y <t>Relative movement in y direction.
/absx <t>Movement to absolute coordinate in x direction.
/absy <t>Movement to absolute coordinate in y direction.
</topic>

<topic>gecmd_new <style>function
new

Clear and reset the working area.
</topic>

<topic>gecmd_select <style>function
select
</topic>

<topic>gecmd_select_currentobject
select currentobject

Put the current object in the list of selected objects.
</topic>

<topic>gecmd_select_clear <style>function
select clear
Clear the select list.
</topic>

<topic>gecmd_set <style>function
set
</topic>

<topic>gecmd_set_verify
set verify
Set veriy mode, i.e. all executed rows in a script are printed in the terminal window.
</topic>

<topic>gecmd_set_noverify
set noverify
Reset verify mode.
</topic>

<topic>gecmd_set_fill
set fill
Set 'fill' in the editor. Created objects will in the future be created with the fill property 
set.
</topic>

<topic>gecmd_set_nofill
set nofill
Reset 'fill' in the editor. Created objects will in the future be created with the fill 
property reset.
</topic>

<topic>gecmd_set_border
set border
Set 'border' in the editor. Created objects will in the future be created with the border 
property set.
</topic>

<topic>gecmd_set_noborder
set noborder
Reset 'border' in the editor. Created objects will in the future be created with the border
property reset.
</topic>

<topic>gecmd_set_grid
set grid

Set 'grid' in the editor. Created objects are positioned to closest grid point.
</topic>

<topic>gecmd_set_nogrid
set nogrid

Reset grid in the editor.
</topic>

<topic>gecmd_set_linewidth
set linewidth

Set linewidth in the editor. Created objects will in the future be created with specified line
width. The line width has a value in the interval 1-8.

<b>Syntax

<c>ge> set linewidth 'linewidth'
</topic>

<topic>gecmd_set_gridsize
set gridsize

Set gridsize in the editor.

<b>Syntax

<c>ge> set gridsize 'gridsize'
</topic>

<topic>gecmd_set_textsize
set textsize

Set 'textsize' in the editor. All text objects will in the future be created with this text
size. The text size can be 8, 10, 12, 14, 18 or 24.

<b>Syntax

<c>ge> set textsize 'textsize'
</topic>

<topic>gecmd_set_bold
set bold

Set 'bold' in the editor. Textobject will in the future be created with bold.
</topic>

<topic>gecmd_set_nobold
set nobold

Reset bold.
</topic>

<topic>gecmd_set_backgroundcolor
set backgroundcolor

Set background color. The background color is an index in the color palette (0-299).


<b>Syntax

<c>ge> set backgroundcolor 'color'
</topic>

<topic>gecmd_set_fillcolor
set fillcolor

Set fill color in the color palette. The object will in the future be created with this fill 
color. Fill color is an index in the color palette  (0-299).

<b>Syntax

<c>ge> set fillcolor 'color'
</topic>

<topic>gecmd_set_bordercolor
set bordercolor

Set border color in the color palette. Objects will in the future be created with this border
color. The border color is an index in the color palette (0-299).

<b>Syntax

<c>ge> set bordercolor 'color'
</topic>

<topic>gecmd_set_current_fillcolor
set currentobject fillcolor

Set fill color of the current object. The fill color is an index in the color palette (0-299).

<b>Syntax

<c>ge> set currentobject fillcolor 'color'
</topic>

<topic>gecmd_set_current_colortone
set currentobject colortone

Set color tone of the current object.

<b>Syntax

<c>ge> set currentobject colortone 'index'
</topic>

<topic>gecmd_set_current_colorlightness
set currentobject colorlightness

Set lightness of the current object. The lightness is an integer. Positive value gives lighter
colors, negative darker colors.

<b>Syntax

<c>ge> set currentobject colorlightness 'lightness'
</topic>

<topic>gecmd_set_current_colorintensity
set currentobject colorintensity

Set color intensity of the current object. The intensity is an integer. Positive value gives
more intense colors, negative less intense.

<b>Syntax

<c>ge> set currentobject colorintensity 'intensity'

</topic>

<topic>gecmd_set_current_colorshift
set currentobject colorshift

Shift color of the current object. The color tones of the subgraph are rotated in the color
circle, but the colors keep their internal color contrast. Colorshift is an integer that states
the number of steps to shift the color. Positive value rotates in direction yellowgreen->
yellow->orange->red->violet->blue->seablue->green. Negative in the opposite direction.

<b>Syntax

<c>ge> set currentobject colorshift 'shift'
</topic>

<topic>gecmd_set_current_attributes
set currentobject attributes
Set attributes of the current object.

<b>Syntax

<c>ge> set currentobject attributes 'attrname' 'value'

The name the attributes depends on which type of dynamic is applied on the subgraph. The
dynamic type has to be stated first, and thereafter the attributes for that dynamic type 
is stated.
</topic>

<topic>gecmd_set_current_type
set currentobject type
Type states type of dynamic for the object. It is entered as an integer.

<b>Syntax

<c>ge> set currentobject attributes type 'value'


<b>Type of dynamic <t>Value
No		<t> 0
Inherit		<t> 1 << 0
Tone		<t> 1 << 1
DigLowColor     <t> 1 << 2
DigColor	<t> 1 << 3
DigError	<t> 1 << 4
DigWarning	<t> 1 << 5
DigFlash	<t> 1 << 6
Invisible	<t> 1 << 7
DigBorder	<t> 1 << 8
DigText		<t> 1 << 9
Value		<t> 1 << 10
AnalogColor     <t> 1 << 11
Rotate		<t> 1 << 12
Move	       	<t> 1 << 13
AnalogShift     <t> 1 << 14
DigShift	<t> 1 << 15
Animation	<t> 1 << 16
Bar	       	<t> 1 << 17
Trend		<t> 1 << 18
SliderBackground <t> 1 << 19
Video		<t> 1 << 20
FillLevel	<t> 1 << 21
FastCurve	<t> 1 << 22
AnalogText	<t> 1 << 23
Table		<t> 1 << 24
StatusColor     <t> 1 << 25
HostObject      <t> 1 << 26

<b>Type of action <t>Value
No		<t> 0
Inherit		<t> 1 << 0
PopupMenu      	<t> 1 << 1
SetDig		<t> 1 << 2
ResetDig       	<t> 1 << 3
ToggleDig      	<t> 1 << 4
StoDig		<t> 1 << 5
Command		<t> 1 << 6
CommandDoubleClick <t> 1 << 7
Confirm		<t> 1 << 8
IncrAnalog	<t> 1 << 9
RadioButton	<t> 1 << 10
Slider		<t> 1 << 11
ValueInput	<t> 1 << 12
TipText		<t> 1 << 13
CloseGraph     	<t> 1 << 18
PulldownMenu    <t> 1 << 19
OptionMenu     	<t> 1 << 20
</topic>

<topic>gecmd_set_current_color_
set currentobject color
Colors are usually called 'LowColor' or 'LowColor2'. Color is an index in the color palette.
</topic>

<topic>gecmd_set_curren_colortone
set currentobject colortone

Color tone are usually called 'LowTone'. Colortone is an integer.
</topic>

<topic>gecmd_set_current_access
set currentobject access

Access is a bitmask where each bit represents a user category authority to influence the object.

<b>User category <t>Value
RtRead     <t>1 << 0
RtWrite    <t>1 << 1
System     <t>1 << 2
Maintenance <t>1 << 3
Process    <t>1 << 4
Instrument <t>1 << 5
Operator1  <t>1 << 6
Operator2  <t>1 << 7
Operator3  <t>1 << 8
Operator4  <t>1 << 9
Operator5  <t>1 << 10
Operator6  <t>1 << 11
Operator7  <t>1 << 12
Operator8  <t>1 << 13
Operator9  <t>1 << 14
Operator10 <t>1 << 15

<b>Syntax

<c>ge> set currentobject access 'value'
</topic>

<topic>gecmd_set_current_attr1
set currentobject attr1

Set the attribute, i.e. the connection to the database, for the current object.
Corresponds to the Ctrl+Doubleclick MB1 function.

<b>Syntax

<c>ge> set currentobject attr1 'attribute'

</topic>

<topic>gecmd_set_current_attr2
set currentobject attr2

Set the second attribute, i.e. the connection to the database, for the current object.
Corresponds to the Ctrl+Shift+Doubleclick MB1 function.

<b>Syntax

<c>ge> set currentobject attr2 'attribute'
</topic>

<topic>gecmd_set_current_annotation
set currentobject annotation

Insert a string in the annotation in the current object. The text is put in annotation number 1.

<b>Syntax

<c>ge> set currentobject annotation 'text'
</topic>

<topic>gecmd_set_graphattributes
set graphattributes

Set an attribute for the current graph or subgraph.

<b>Graph attribut

<b>Name  <t>Type
subgraph <t>Boolean
x0  <t>Float
y0  <t>Float
x1  <t>Float
y1  <t>Float
ScanTime <t>Float
AnimationScanTime <t>Float
JavaWidth <t>String
BackgroundImage <t>String

<b>Subgraph attribute

<b>Name <t>Type
TraceAttrType
TraceType
TraceColor <t>ColorIndex or ColorTone
TraceColor2 <t>ColorIndex or ColorTone
NoConObstacle <t>Int
Slider <t>Int
NextSubgraph <t>Int
AnimationCount <t>Int

<b>Syntax

<c>ge> set graphattributes 'name' 'value'
</topic>

<topic>gecmd_rotate
rotate
</topic>

<topic>gecmd_rotate_current
rotate currentobject

Rotates the current object around the center of the object.

<b>Syntax

<c>ge> rotate currentobject /angle=

/angle <t>Angle in degrees that the object is rotated.
</topic>

<topic>gecmd_rotate_selected
rotate selectedobject

Rotates the selected object around the center of the object.

<b>Syntax

<c>ge> rotate selectedobject /angle=

/angle <t>Angle in degrees that the object is rotated.
</topic>

<topic>gecmd_scale
scale
</topic>

<topic>gecmd_scale_current
scale currentobject

Scale the current object.

<b>Syntax

<c>ge> scale currentobject /scalex= /scaley= [/x= /y=]

/scalex <t>Scale factor in x direction.
/scaley <t>Scale factor in y direction.
/x <t>x coordinate for the reference point of the scaling.
/y <t>y coordinate for the reference point of the scaling.
</topic>

<topic>gecmd_scale_selected
scale selectedobject

Scale the selected object.

<b>Syntax

<c>ge> scale selectedobject /scalex= /scaley= [/x= /y=]

/scalex <t>Scalefactor in x direction.
/scaley <t>Scalefactor in y direction.
/x <t>x coordinate for the reference point of the scaling.
/y <t>y coordinate for the reference point of the scaling.
</topic>

<topic>gecmd_save
save

Save a graph.

<b>Syntax

<c>ge> save ['filename']
</topic>

<topic>gecmd_exit
exit

Save the current graph and close Ge.

<b>Syntax

<c>ge> exit ['filename']
</topic>

<topic>gecmd_quit
quit

Close without save.

<b>Syntax

<c>ge> quit
</topic>

<topic>gecmd_open
open

Open a graph.

<b>Syntax

<c>ge> open ['filename']
</topic>

<topic>gecmd_show
show
</topic>

<topic>gecmd_show_version
show version

Show Ge version.
</topic>
</headerlevel>
</chapter>

<chapter>
<topic>gecmd_script
Script

Ge script is a way to program ge commands. In the script function there are also possibilities
to perform calculations, if statements, loop statements, declarations of variables and 
functions.

A script is started with '@' followed by the name of the script file and possible arguments.

A ge-script should have the filetype .ge_com.

<b>Example

<c>ge> @my_script

In Wtt script there is a description of the script language and a description of built in 
functions. Here follows a list of build in functions that also can be used in Ge script.

<h2>Ge functions
<b>Function <t>Description
GetCurrentObject <t>Returns the identity of the last created object.<link>GetCurrentObject()
GetTextExtent <t>Calculate the extent of a text. <link>GetTextExtent()
SelectAdd <t>Add an object to select list. <link>SelectAdd()
SetExtern <t>Set subgraph extern. <link>SetExtern()
SetIntern <t>Set subgraph intern. <link>SetIntern()

<h2>Input and output
<b>Function <t>Description
ask <t>Print a question an read an answere.
say <t>Print a text.
printf <t>Formatted print.
scanf  <t>Formatted read.

<h2>File handling
<b>Function <t>Description
fclose <t>Close a file
felement <t>Extract one element from the last read line.
fgets <t>Read a line from a file.
fopen <t>Open a file.
fprintf <t>Formatted write to file.
fscanf <t>Formatted read from file.

<h2>Handling of strings
<b>Function <t>Description
edit <t>Removes leading and trailing spaces and tabs, and replaces multiple
     <t>tabs and spaces with a single space.
element <t>Extract one element from a string of elements.
extract <t>Extracts the specified characters from a string.
sprintf <t>Formatted print to a string variable.
strchr <t>Find the first occurrence of a character in a string.
strlen <t>The length of a string.
strrchr <t>Find the last occurrence of a character in a string.
strstr <t>Find the first occurrence of a character sequence in a string.
toupper <t>Convert a string to upper case.

<h2>Database functions
<b>Function <t>Description
CutObjectName <t>Extract the last segment of an object name.
GetAttribute <t>Fetch the value of an attribute.
GetChild <t>Get the first child of an object.
GetNextSibling <t>Get next sibling of an object.
GetNextVolume <t>Get next volume.
GetParent <t>Get the parent of an object.
GetObjectClass <t>Get the class of an object.
GetRootList <t>Get first object in the root list.
GetVolumeClass <t>Get the class of a volume.

<h2>System functions
<b>Function <t>Description
exit <t>Terminate the execution of a script.
time <t>Fetch the system time.
system <t>Execute a shell command.
verify <t>Set verify on or off.

</topic>

<topic>GetTextExtent() <style>function
GetTextExtent()
int GetTextExtent( string text, int textsize, int bold, float width [, float height, 
float descent])

<h2>Description

Calculates the extent of a text.
Returns the width of the text in the width argument, and if the arguments height and descent
are supplied, also height and descent in these arguments.

<h2>Argument

string <t>text     <t>Text which size is to be measured.
int    <t>textsize <t>Text size (8, 10, 12, 14, 18 of 24).
int    <t>bold     <t>Bold (1) or normal (0) text.
float  <t>width    <t>The text width is returned in this variable.
float  <t>height   <t>The height is returned in this variable.
float  <t>descent  <t>The descent is returned in this variable.

<b>Example
<c> float width;
 
<c> GetTextExtent("Detta är en text", 12, 1, width);
</topic>

<topic>SelectAdd() <style>function
SelectAdd()
int SelectAdd( int objectid)

<h2>Description

Insert an object in the list of selected objects.

<h2>Argument

int          <t>objectid   <t>Object identity.

<b>Example
<c> int id;
 
<c> id = GetCurrentObject();
<c> SelectAdd( id);
</topic>

<topic>GetCurrentObject() <style>function
GetCurrentObject()
int GetCurrentObject()

<h2>Description

Returns the identity of the last created object.

<b>Example
<c> int id;
 
<c> id = GetCurrentObject();
</topic>

<topic>SetExtern() <style>function
SetExtern()
int SetExtern( string name)

<h2>Description

Set a subgraph extern.

<h2>Argument

string      <t>name       <t>Name of the subgraph.

<b>Example
 
<c> SetExtern("MySubgraph");
</topic>

<topic>SetIntern() <style>function
SetIntern()
int SetIntern( string name)

<h2>Description

Set a subgraph intern.

<h2>Argument

string    <t>name       <t>Name of the subgraph.

<b>Example
 
<c> SetIntern("MySubgraph");
</topic>

<topic>gecmd_examples <style>function
Example

<h1>Example 1
<c>!
<c>! Draw some simple objects
<c>!
<c>main()
<c>  string name;

<c>  verify(1);


<c>  ! Draw a rectangle
<c>  set fill
<c>  set linewidth 1
<c>  set bordercolor 0
<c>  set fillcolor 19
<c>  create rect /x1=10 /y1=1 /width=2 /height=2

<c>  ! Draw a half circle
<c>  set nofill
<c>  set linewidth 2
<c>  create arc /x1=1/y1=1/x2=3/y2=2/angle1=0 /angle2=180
  
<c>  ! Draw a polyline
<c>  set nofill
<c>  set linewidth 1
<c>  create polyline /x1=5 /y1=5 /x2=6 /y2=6
<c>  add polyline /x1=5 /y1=7
<c>  add polyline /x1=6 /y1=8
<c>  add polyline /x1=5 /y1=9
<c>  add polyline /x1=6 /y1=10

<c>  ! Print a text
<c>  set bold
<c>  set textsize 14
<c>  create text/text="Example" /x1=3 /y1=5

<c>  ! Create a subgraph
<c>  create object/sub=pwr_valve/x1=1/y1=1/x2=3/y2=2
<c>  set current fillcolor 45
<c>  set current attr attribute "Rt-Dv1.ActualValue##Boolean"
<c>  set current attr lowcolor 0
  
<c>  ! Create a pushbutton
<c>  create object /sub=pwr_buttonset /x1=5 /y1=1
<c>  set current attr text "Start"
<c>  set current attr attribute "rt-dv1.actualvalue##Boolean"
<c>  set current attributes access 65000

<c>  ! Set graph attributes
<c>  set graph x0 -3
<c>  set graph y0 -3
<c>  set graph x1 40
<c>  set graph y1 25

<c>  save
<c>endmain

<h1>Example 2
<c>!
<c>! This example finds all dv objects in an hierarchy,
<c>! prints the name and displayes the value in an indicator.
<c>! A frame is drawn around the objects.
<c>!
<c>main()

<c>  string name;
<c>  string segname;
<c>  string attr;
<c>  float x;
<c>  float y;
<c>  float x_ind;
<c>  float y_ind;
<c>  float x1;
<c>  float x2;
<c>  float y1;
<c>  float y2;
<c>  float width;
<c>  float t_width;
<c>  string class;
  
<c>  x_ind = 2;
<c>  x = 4;
<c>  y_ind = 1.5;
<c>  y = 2;
<c>  name = GetChild( p1);
  
<c>  if ( p1 == "")
<c>    printf("usage : test3 'parent'\n");
<c>    exit();
<c>  endif
  
<c>  set bold
<c>  set textsize 12
<c>  while ( name != "")
<c>    class = GetObjectClass( name);
<c>    if ( class == "Dv")
<c>      create object/sub=pwr_indsquare/x1='x_ind'/y1='y_ind'
<c>      attr = name + ".ActualValue##Boolean";
<c>      set current attr attribute "'attr'"
<c>      segname = CutObjectName( name, 1);
<c>      create text/text="'segname'"/x1='x'/y1='y'
<c>      GetTextExtent( segname, 12, 1, t_width);
<c>      if ( t_width > width)
<c>        width = t_width;
<c>      endif
<c>      y += 1;
<c>      y_ind += 1;
<c>    endif
<c>    name = GetNextSibling( name);
<c>  endwhile

<c>  x1 = x_ind - 1;
<c>  x2 = x + width + 1;
<c>  y1 = 0;
<c>  y1 = y;
<c>  cre obj/sub=pwr_framethin/x1='x1'/y1='y1'/x2='x2'/y2='y2'

<c>  x1--;
<c>  x2++;
<c>  y1--;
<c>  y2++;
<c>  set background 11
<c>  set graph x0 'x1'
<c>  set graph y0 'y1'
<c>  set graph x1 'x2'
<c>  set graph y1 'x2'
<c>endmain
</topic>
</chapter>










