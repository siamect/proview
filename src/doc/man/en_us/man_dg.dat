
<topic> __DocumentTitlePage

<image> pwr_logga.gif


co



<h1> Designer's Guide
























<hr>
2008-10-21
Version 4.6.0	
<hr>
</topic>

<topic> __DocumentInfoPage


Copyright (C) 2008 SSAB Oxelösund AB

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts.


First Edition Mars 2005




</topic>

<chapter>
<topic> introduction
Introduction

Proview is a modern, powerful and general process control system. It contains all functions
normally required for successful sequential control, adjustment, data acquisition, 
communication, supervision, etc. 

The configuration of a Proview system is done graphically, making the application adaptation
simple, reliable, and flexible. Proview is a distributed system, which means that the system
consists of several computers, connected via a network . Via the network computers exchange 
data with each other. In this way, for instance, the measuring signals will be known on all 
the process - and operator stations of a Proview system. 

A Proview system is defined with objects. Each object represents a physical or abstract 
entity in the system. The objects are structured in hierarchical tree structures, making it 
possible to describe the system in a structured way. The tree structure also imposes a 
hierarchical naming of all objects. By carefully choosing names when configuring a system, 
the full name of an object will identify its function, or role in the system. 

The hierarchies are divided into two groups; one called the Plant Configuration, describing 
the logical view of a system; and one called the Node Configuration , describing the physical
view of the system. The configuration of these two parts can be done independently. Eventually
the two parts are connected to each other. 

To configure a system you use the Proview Workbench. The workbench comprises a permanent 
database and a number of tools to help you configuring the objects needed to define the 
system. From the workbench you create a runnable system as well as documentation about the 
system. 

The purpose of Proview is to help you creating automated systems. Suppose you have a 
process that you wish to control, Proview helps you creating the control system for this 
process. When the system is created, you will find that you have also created the 
documentation for the system. 
</topic>
</chapter>

<option> printdisable
<topic> index
Designer's Guide

<image> pwr_logga.gif

<h1>Designer's Guide
Overview <link> design_overview
Database structure <link> database_structure
A case study <link> case_study
Communication <link> communication
Administration <link> administrator
Navigating the project <link> project_structure
Configure the directoryvolume <link> configure_directoryvolume
Configure the rootvolume <link> configure_rootvolume
Plc programming <link>plc_programming
Components and Aggregates <link>dg_components
Call functions from the plc program <link>dg_plc_functions
Application programming <link>dg_application
Creating Process Graphics  <link> ge_man
Running and Testing a Proview System <link> conf_test

<b>Reference Manuals
The Configurator <link> configurator_refman
The Object Editor<link> objecteditor_refman
The Spreadsheet Editor<link> spreadsheeteditor_refman
The Plc Editor<link> plceditor_refman
The Class Editor<link> classeditor
OPC <link> opc_intro
Commands <link> help command
Script <link> script
</topic>
<option> printenable

<chapter>
<topic> design_overview
Overview

As this is a guide for designers, we to start with a description of what the design of a 
control system imply. The description can also work as an introduction to the different 
concepts that are used in this guide.

A designer's starting point is, of course, the process that is to be controled by the system,
and the first task is to learn about the process, and to figure out the best way to control
it: which control loops is needed, which interlockings, how is the startup and shutdown 
carried out, how is operators and maintainers going to work with the system. This is 
summed up in a Design specification.

At the same time you have to consider what information about the process the control system
need to perform its task, i.e. which sensors should be placed in the plant. The control
system also has to influence the process i varous ways, for example with valves and engines.
This ends in a Signal list, that is alist of all input and output signals of the system.

At this point the question of which control system is to be used is raised, and on alternative
is of course Proview. You also has to decide whick I/O-system to use, and how to devide the
function i different process stations.

<h1>IO-systems
The task of the I/O-system is to bring signals from the process to the control system, and to
put out signals to influence the process. The signals are usually digital or analog, but
there are also other types as integers and counters. You can choose between a rack and card
system connected to the process station, or a distributed I/O, e.g profibus.

<h1>Configure the system
When it's time to start configure the system, you first create a new project in the
Administrator. The Administartor is a tool to create order among all the projects, as there
can be plenty of them in time.

The configuration of a system is mainly done by creating objects in a database, the Workbench. 
There is a large amount of objects to configure everything from IO-channels to PLC programs.
The Proview Object Reference Manual contains over 800 different types of objects. The objects
are placed in a tree structure, and you use a tool called the Configurator to create objects and
to navigate it the object tree.

The object tree is separated in to parts, the plant hierarchy and the node hierarchy.
The Plant hierarchy reflects the different functions in the plant and in the process, while
the Node hierarchy reflects the hardware of the control system, with computors, I/O-racks and
I/O-cards.

When later the control system is started in runtime, a copy of the object tree is created in
a realtime database, rtdb. The transfer from the Workbench to rtdb is done with so called
loadfiles, files that are generated from the Workbench and contains all its objects.

<h1>Control program
Proview offers a graphical programming language in witch logic, Grafcet sequences and control
loops is programmed. It is named the PLC program. Also the PLC program is a part of the object
tree. It is configured by placing specific program objects, PlcPgm, in the Plant hierarchy. 
When opening a PlcPgm you enter the Plc Editor, in which the graphical programming is preformed.
Function blocks is created, and connected in a signal flow of digital and analogous signals,
where the input signals are feched at the left side, transformed in different function blocks,
and finally stored in ouput signals at the right side.

A complement to the PLC program is application programs, which are written in the c, c++ or
java language. Applications are written and started as separate programs and connected to
the realtimedatabase through an API.

<h1>Simulation
The realtime database, the PLC program and possible applications kan easily be started in the
development station. This makes it possible to test the programs in direct connection with
the programming. You kan even write special simulation programas which reads the output signals,
simulates the ouputs influence of the process, calculates values of different sensors and puts
this values in the input signals.

The configuration and programming of the system is then a process, where you altertately
configure/program and test. The result i carefully debugged programs and a fast and efficiant
commissioning of the plant. It also result in better programs, and more thoroughly workt
through functions, beacause the feedback is greater in the create process that the construction
of a process control system implies.

At the simulation and commissioning it is of greate importance to have access to tools that
makes it possible to monitor and examine the system, and quickly locacalize possible 
malfunctions. In Proview this tools is called Xtt. Xtt containts a lot of functions to examine
the content of the realtime database, to flow the signal flow, to log fast or slow sequences,
etc.

<h1>Operator interface
There are a number of different groups of professionals that shall gain access to the system, 
operators running the plant on a daily basis, maintaners occasionally correcting som 
malfuncions, process engineers requesting various process data. All have their demands on the 
system interface. Furthermore the limits between the various groups of professionals might be
fluid, operators that are both operators and maintainers, and perhaps even process engineers.
This makes high demands on the functionality and flexibility of the operator interface. You
can rapidly and easy trough, so called methods that i activated from popupmenues, fetch all the
information of various objects, that i stored in the realtime database, or in different server
systems.

<h1>Process graphics
Process graphics are build in a grapical editor. The grapics are vector based, which makes all
graphs and components unlimitede scalable. Components have a preprogrammed dynamic to change
color and shape, depending of signals in the realtime database, or to respond to mouse clicks
and set values in the database. In each component that is sensible to mouse click or input,
you can state access, and selectively allow or hinder users to influence the system. Process
graphs can also, besides beeing displayed in the ordinary operator environment, be exported to 
java, which makes them viewable on the web with all dynamics.

<h1>Supervision
If any malfunction arise in the system, the operator has to be noticed. This is done with
special supervisory objects, that is configured in the plant hierarchy or in the PLC program,
and which originate alarms and events. The alarms have four priority levels: A, B, C and D,
and is diplayed to the operator in the alarm list, the event list and the historical event list.

The alarmlist contains unacknowledged alarms and alarms in alarm state. An alarm normally has
to be acknowledged before it disapperas from the list. If the alarm state is active, the alarm
remains in the list as long as it is active.

Alarm also are registred in the event list, that displays events in a chronological order.

The historical eventlist is a database, also registrering event. Here you can search for events,
stating criteria as priority and process part. 

If a plant part is shut down, it is possible to block the alarms, to avoid to distract the
operator. Blocked plant parts are displayed in the Block list.

<h1>Data Storage
You often want to follow the change of a signal over time, in the shape of a curve. In Proview
there are there kinds of funktions for this, DsTrend, DsFast and SevHist.

DsTrend is a trend that is stored in the realtime database. The value of a signal is stored
continously with an interval of 1 second and upwards. For each curve there is space for about
500 samples, so if you choose to store a new sample every second, you have a trend of the
signal of about 8 minutes.

SevHist stores signals in a similar way in a database on disk, which makes it possible to store
values a longer period of time then DsTrend.

DsFast stores more rapid sequences, where the storage is started on a trigg condition, and 
continues a specified time. When the sequence is finished, it is displayed as a curve.
</topic>
</chapter>

<chapter>
<topic> database_structure
Database structure

As we have seen earlier, the main part of the configuration of a Proview system is taken place
in a database, the Workbench. In the Workbench you create objects in a tree structure, and
every object arise a certain function i the control system. Proview is what is called object
oriented, so let us look a little closer at what a Proview object really is.

<option> printdisable
Objects <link> object
Volumes <link> volume
Attribute <link> attribute
Class <link> class
Object Tree <link> object_tree
Object Name <link> object_name
Mounting <link> mounting
Object Identity <link> object_identity
<option> printenable

</topic>

<topic> object
Object

An object consists of a quantity of data, that in some way defines the state of the object or 
the properties of the object. The data quantity can be very simple, as for an And-gate, where
it consists of a boolean value that is true or false. However, a PID controler has a more
complex quantity of data. It contains gain, integration time, output, force etc. It consists
of a mix of digital, analogous and integer values. Some values are configured in the development
environment and some are calculated in runtime.

The quantity of data is called the body of the object. The body is divided in attributes, where
every attribute has a name and a type. The body of an And-gate consists of the attribute Status
which is of type Boolean, while the body of a PID controler consists of 47 attributes: ProcVal,
SetVal, Bias, ForceVal etc.

All PID objects has its quantity of data structured in the same way, you say they are a member
of the same class. The PID objects are memebers of the PID class, and the And-gates are members
of the And class. A class is a kind of model of how objects that belongs to the class appear,
for example which the attributes are, and the name and type of the attribues.

Besides a body, an objects also has a header. In the header, the class and identity of the 
objects is found, and also its relation to other objects. The objects are ordered in a tree
structure, and in the header there are link to the parent, and the closest siblings of the
object.
</topic>

<topic>volume
Volumes
When configuring a system, and creating objects, you usually know to which node the objects
will belong in runtime. You could group the objects after which node they will belong to,
but a more flexibel grouping is made, so instead you group the objects in volumes. A volume
is a kind of container for objects. The volume has a name and an identity, and it contains
a number of objects ordered in a tree structure.

There are a number of different types of volumes, and the first you get into contact with is
a root volume. When configuring a node, you usually work in a root volume. Every node is
connected to a root volume, i.e when the node is starting up in runtime, the root volume,
and its objects, is loaded into the node. Below is a description of the different types of
volumes.

<h2>RootVolume
A root volume contains the root of the object tree in a node. At startup, the node is loading
the root volume.

A node is connected to one and only one root volume. Furthermore, a root volume can be loaded
into several nodes. When a process station is running i production, the same volume can
concurrently be loaded into a develoopment station for simulation, and a third node kan run
the volume in educational purposes. Though, you have to consider that the nodes has to run
in different communication busses.

<h2>SubVolume
Some of the objects in a node can be placed in a sub volume. The reason to divide the objects
of a node in a root volume and in one or several sub volumes, could be that a number of persons
has to configure the node simultaneously, or that you plan to move parts of the control of
some plant parts to another node later.

<h2>ClassVolume
The definition of different classes reside in a special type of volume, called ClassVolume.
Here the description of a class i built with objects that define the name of the class
and the attributes of the class.

There are two classvolumes that you always include in a Proview system, pwrs and pwrb. pwrs
contains the system classes, mainly classes used in class definitions. pwrb contains base
classes, i.e standard classes that is neede to build a process or operator station.

<h2>DynamicVolume
A dynamic volume contains dynamic objects, i.e. volatile objects created at runtime. If you
have a material planning module in the system, an objects i created for each material that
is processed in the plant. When the processing is completed, the object is removed.

<h2>SystemVolume
The system volume is a dynamic volume that reside in every node, and that keeps various
system objects.

<h2>DirectoryVolume
The Directoy volume only exists in the development environment. Here the volumes and nodes of
the system are configured.

<h1>Volyme Identity
Each volume has a unic identity, that is written with four numbers, separated with points,
e.g. "_V0.3.4.23". The prefix _V states that it is a volume identity. To verify that the volume
identities are unic, there is a global volumelist that contains all volumes. Before creating
a project, the volumes of the project should be registred in the volume list.
</topic>

<topic> attribute
Attribute
The quantity of data for an object is divided into attributes. Each attribut has a name and a
type. Here follows a description of the most common attribute types.

<h2>Boolean
Digital attributes are of type boolean. The value can be true (1) or false (0).

<h2>Float32
Analogue attributes are of type Float32, i.e. a 32-bit float.

<h2>Int32
Integer attributes are usually of type Int32, i.e. a 32-bit integer. There are also a number
of other integer types, e.g. Int8, Int16, Int64, UInt8, UInt16, UInt32 and UInt64.

<h2>String
In a string attribute a character string is stored. There are different string types with
variuos length, e.g. String8, String16, String40, String80, String256.

<h2>Time
Time contains an absolute time, e.g. 1-MAR-2005 12:35:00.00.

<h2>DeltaTime
DeltaTime contains an delta time, e.g. 1:12:22.13 (1 hour, 12 minutes, 22.13 seconds).

<h2>Enum
Enum is an enumeration type, used to chose one alternative of several alternatives.
It can be assigned one integer value, in a serie of integer values, where each value is 
associated with a name. There are, for example, the enumeration ParityEnum which kan have the
values 0 (None), 1 (Odd) or 2 (Even).
Enum is a basic type and ParityEnum is a derived type.

<h2>Mask
Mask is used when to choose one, or several, of a number of alternatives. The alternatives
are represented by the bits in a 32-bit integer.

An attribute can also consist of a more complex datastructure. It can be an array with a 
specified number of elements, and it may also be another object, a so called attribute object.
</topic>

<topic>class
Class

A Class is a description of how an object that is a member of the class shall look like. An
object that belong to the class is called an intance. The class defines how the data of the
instances are structured in attributes of various type, or the graphic representation of objects
in the PLCeditor or in the operator environment.

Each class has a template object, i.e. an instance of the class that contains default values
for the attributes of the class.

Proview's basesystem contains about 900 classes. See Object Reference Manaual detailed
description. The designer can also create his own classes within a project.
</topic>

<topic>object_tree
Object Tree
The object in a volums are ordered in a tree structure. In the volume there is one, or several
top objects, each top object can have one or several children, which can have children etc.
You usually talk about the relations between objects in the tree in terms as parent, sibling,
child, ancestor and descendants.
</topic>

<topic>object_name
Object Name

Each object has a name that is unic whithin its siblinghood. The object also has a path name
that is unic within the world. The pathname includes, besides the object name, the volume
name and the name of all the ancestors, e.g 

<c>VolTrafficCross1:TrafficCross1-ControlSignals-Reset

If you want to be more specific, and point out an attribute in an object, you add the attribute
name to the object name with a point between, e.g.

<c>VolTrafficCross1:TrafficCross1-ControlSignals-Reset.ActualValue

Also an attribute can have several segments, since an attribute can consist of an object. The
attribute name segments are separated by points, e.g

<c>VolTrafficCross1:Hydr-Valve.OpenSw.ActualValue
</topic>

<topic>mounting
Mounting

An operator station has to display values of signals and attributes that reside in the volumes
of process stations. This is achieved by a mechanism, where an operator station mounts the 
volumes of the process stations, in its own object tree. A mounting means that you hang an
object tree of another volume in the own rootvolume. Where in the tree the volumes is hanged,
is configured wiht a MountObject object. In the MountObject states, which object in the other
volumes that is mounted. The result is, that the MountObject is displayed as the mounted object,
with the objecttree beneath is. It apparently looks as if the objects belong to the own root
volume, while they in reality reside in another node.

If you use subvolumes, they also have to be mounted in a root volume, to make the objects
available.

When you choose mounting points and names of mounting points, it is suitable to do this in a
way, that the objects have the same pathname in both volumes.
</topic>

<topic>object_identity
Objekt Identity
An object has an identity that is unic. It consits of the volume identity, and an object index
that is unic within the volume. An object identity is written for example "_O0.3.4.23:34" where
0.3.4.23 is the volume identity, and 34 the object index. The prefix _O states that it is an
object identity.
</topic>
</chapter>

<chapter>
<topic>development environment
Development environment

The configuration of a Proview system is done in a development station. The Proview development
enviroment is installed in the development station.
</topic>
</chapter>

<chapter>
<topic>case_study
A Case Study

<option> printdisable
Specification of I/O<link>io_specification
Administration <link> administration
Plant Configuration <link> plant_configuration
Node Configuration <link> node_configuration
PLC program <link> plcprogram
Plant Graphics <link> process_graphics

<option> printenable
In this chapter we will give you an idea of how a Proview system is created. The process to 
control in this case study is very simple - an intersection with four traffic lights - but it
will give you an idea of the steps you have to go through when creating a Proview system.

The traffic lights should be able to operate in two different modes:

  - Normal: The traffic lights run normal cycle of red, yellow and green.
  - Flash: The traffic lights are flashing yellow.

<image> dg_fig1.gif
<b>Traffic lights in an Intersecion

The operating mode of the traffic lights is decided by an operator at via operator station, or 
by a maintenance technician, who influences a switch. The maintenance technician can change 
mode, only if the operator have switched the traffic lights to service mode. 

Figure 'Traffic Lights, Control Panels' shows the different switches and indicators needed by 
the operator and maintenance technician respectively, to be able to monitor and control the 
system. These could be realized with plant graphics on the operator station or with hardware. 

<image> dg_fig2.gif
<b>Traffic Lights, Control Panels
</topic>

<topic> io_specification
Specification of I/O
We start with analysing the task to decide what hardware to use. 

<h2>Digital Outputs
We have four traffic lights, but the traffic lights in the same street can be connected in 
parallel, which means that we can treat them as two lights. 

Three outputs per light: 2 × 3 = 6
Indication: Operating mode 1
Indication: Control 1
----------------------------------
Total number of digital outputs: 8 


<h2>Digital Inputs
The only digital input needed is for the maintenance technician's switch. The operator controls
the process from the computer display, and this requires no physical signals. 

Switch: Operating mode 1
---------------------------------
Total number of digital inputs: 1 

Den enda digitala ingång som behövs är för underhållsteknikerns vred. Operatören styr 

<h2>Analog I/O 
No analog in- or outputs are needed for this task. 

<h2>Specification of the Process Station 
When we have decided upon the I/O needed, we can choose the hardware. We choose: 

1 Linux PC with rack.
1 card with 16 digital inputs.
1 card with 16 digital outputs. 

<h2>Specification of the Operator Station 
1 Linux PC.

<h2>Specification of Plant Graphics 
We need a display from which the operator can control and survey the traffic lights. 

</topic>

<topic> administration
Administration

First we have to register a new volume, create a project, and, if necessary, create new users.
For this we need

- A name for the project. We call it trafficcross1.
- Two volumes, one for the process station and one for the operator station.
- We need three users: one developer, one operator and one maintenance technician.

Volumes, projects and users are registred and created in the administrator tool.

<h2>Register volume
For this project, we need two volumes, one for the process station, and one for the operator
station. They are root volumes so we can choose an idle volume identity in the intervall
0.1-254.1-254.1-254. We choose 0.1.1.1 to the operator station and 0.1.1.2 to the process
station, and enter the volume mode in the administator to register these volumes.

<image> dg_fig11.gif
<b>Volume registration

<h2>Create users
Eric is a developer in the traffec department, an Carl is an operator. They are both involved
in all the projects at the traffic department, so we create a common systemgroup for all the
projects and let them share users. We grant Eric developer and system privileges, Carl
operator privileges and Lisa maintenance privileges.

<image> dg_fig4.gif
<b>Created users

<h2>Create Project
We create the project with the hierarchy name 'trafiic-trafficcross1'.

<image> dg_fig10.gif
<b>Created project

<h1>Configure the project
The project has a directory volume in which the nodes and volumes of the project are configured.
In the upper window the volumes are configured with RootVolumeConfig objects. In the lower
window the process and the operator station are configured with NodeConfig objects. The
NodeConfig objects is put beneath a BusConfig object that states in which QCOM bus the nodes are
communicating. 

The NodeConfig objects contains

- Nodename
- ip adress of the node

Below each NodeConfig object there is a RootVolumeLoad object that states the volume to load
at runtime startup.

Note also the system object with the attribute SystemGroup that is assigned the value
'trafficdepartment'. This grants the users eric, carl and lisa access to the project.

<image>dg_fig5.gif
<b>The Directory Volume
</topic>

<topic> plant_configuration
Plant Configuration
Once the configuring of the project is done, next step is to configure the plant. The 
configuration is done in the Configuration Editor. The plant is a logical description of the 
reality, which is to be controlled and supervised. 

The plant is structured hierarchically. Examples of levels in the plant can be plant, process, process part, component, and signal. These are the logical signals represented by signal objects which will be connected to physical channels. 


<h2>The Process Station
Den största delen av konfigureringen görs i processtationens volym, VolTrafficCross1. Det
är ju här som all kort, kanaler, signaler och PLC program ska konfigureras.

The plant is structured hierarchically. Examples of levels in the plant can be plant, process, 
process part, component, and signal. These are the logical signals represented by signal 
objects which will be connected to physical channels. 

Sometimes it can be difficult to configure each signal in an initial stage, but it must at any 
rate be decided how possible signals shall be grouped. 

The figure below illustrates how a plant has been configured. We see how signals have been 
configured on different levels, and even how the PLC programs are configured in the plant. 

<image> dg_fig3.gif
<b>An Example of a Plant Configuration

We choose to call our plant TrafficCross1 and we decide on the following structure: 

- Two traffic lights, each one consisting of a green, a yellow, and a red lamp. Since the 
  streets run north-south and west-east respectively, we call them TrafficLightNS and 
  TrafficLightWE. Each lamp requires a signal. These are digital output signals and are 
  called RedNS, RedWE, etc. 

- A PLC program to control the traffic lights. 

- A number of control signals to select operating mode and function. We choose to put them in 
  one folder, ControlSignals. The table below shows the signals required. 

Figure shows the resulting Plant Configuration. 

We choose to call our plant TrafficCross1 and decide the following structure:

<b>Signal Name <t>Signal Type <t>Function 
 
ServiceSwitch  <t>Di <t>A switch which the maintenance technician can influence to
               <t>   <t>change the operating mode. 
OperatorSwitch <t>Di <t>A value which the operator can influence to change the operating 
               <t>   <t>mode. 
ServiceMode    <t>Di <t>A value which the operator can influence to change the function 
               <t>   <t>to service mode. 
ServiceModeInd <t>Do <t>A signal which shows the maintenance technician that the program 
               <t>   <t>is in service mode.  
Mode           <t>Dv <t>Indicates whether the program is in normal or flashing mode. 
ModeInd        <t>Do <t>Indicates whether the program is in normal or flashing mode. 
Reset          <t>Dv <t>A value which is used to reset the program to initial mode. 

<bookmark> plant_example
<image> dg_fig6.gif
<b>The Plant Configuration of the Intersection

As you can see we have a plant object at the topmost level, TrafficCross1 of the class 
$PlantHier. We use other objects of class $PlantHier to group our objects. We also create an 
object, which defines a PLC program, the ControlPgm object of the class PlcPgm . 

<h2>The Operator Station
The configuration of the operator station is performed in the volume VolOpTrafficCross1. In the
Plant side there is only a mount object, that makes the plant hierarchy of the process node
available in the operator station. We have mounted the topmost $PlantHier object, 
'TrafficCross1' with a MountObject with the same name.

<image> dg_fig14.gif
<b>The Plant Configuration in the operator volume.
</topic>

<topic> node_configuration
Node Configration

When you have configured the plant, continue to configure the nodes.

<h2>Processtation
In this example we choose to start configuring the process station. We name the process station
"cross1". It is advisable to give the process stations descriptive names. In the node 
hierarchy we create a $NodeHier object 'Nodes' and below, a $Node object 'cross1' that 
configures the node.

In the analysis phase we decided that the process station should consist of the following 
hardware: 

- 1 Linux PC
- 1 rack with 16 slots
- 1 card with 16 digital inputs (Di channels).
- 1 card with 16 digital outputs (Do channels).

The rack and the cards are configured in a manner much like what you would do physically. You 
have a node, place the rack in the node, the card in the rack, and the channels on each card. 

<image> dg_fig7.gif
<b>Node Configuration of the Process Station

We also configure the PLC program with a PlcProcess object, and below this, a  PlcThread object
for each time base. We are content with one 100 ms timebase.

<image> dg_fig12.gif
<b>Timebase configuration of the PLC program

Each object has a number of attributes that you may have to change. To give an understanding of
how to change attributes, some of the attributes in the PlcProcess object are edited below.

<image> dg_fig13.gif
<b>Change of Attribute Value

<h2>Operator Station
The node hierarchy of the operator station is configured in the volume VolOpTrafficCross1. 
Below the node object we find an OpPlace object that defines the operator place, and below
this a User object that defines a user. Below the OpPlace object there is also a XttGraph object
for the process graph of the operator station.

<image> dg_fig8.gif
<b>The Node Configuration i the Operator Volume.

<h1> Connecting channels to signals
When you have configured the plant and the nodes, it is time to connect the logical signals to 
the physical channels. Each logical signal in the Plant Configuration must be connected to one 
channel in the Node Configuration; a Di to a ChanDi, a Do to a ChanDo, an Ai to a ChanAi and 
an Ao to a ChanAo , etc. 

You can se the connection as a representation of the copper cable between the components in the 
plant, and the channel in the I/O rack. In the figure below there is a cable between the switch
and channel 0 in the Di-card. As the Di-signal SeviceSwitch is representing the switch and
Di-channel Di4-00 is representing the channel, we have to make a connection between these two
objects.

<image> dg_fig15.gif
<b>Connection between a signal and a channel

<image> dg_fig9.gif
<b>Connect a signal to a channel
</topic>

<topic>plcprogram
PLC program
We use the Graphical PLC Editor to create PLC programs. 

However we must first connect the PlcPgm object to a PlcThread object in the node hierarchy.
This states which timebase the PLC programm is executed on.

<image> dg_fig16.gif
<b>The Graphical PLC Editor

We will use the PLC Editor to create a sequential control program for the traffic lights. There
are two ways to solve the problem concerning the two operating modes for a traffic light, 
normal and flash: 

1. Use one Grafcet sequence with conditional branches, i.e. one branch for the normal operating
   mode sequence and one for the flash operating mode sequence. 
2. Use two separate Grafcet sequences with different start conditions. 

Here we choose to use the second alternative. In chapter 4, Graphical PLC Programming a more 
detailed description of Grafcet and sequential control can be found. 

Grafcet programs are based on activating and deactivating a number of steps in sequence. In 
linear sequences only one step at a time can be active. To each step you tie a number of orders
that are to be executed when the step is active. This can be e.g. to set (with a StoDo object) 
a digital output signal, which turns on a lamp. The PLC programs thus control the logical 
signals. 


<image>dg_fig17.gif
<b>The Flashing Light Sequence 

This is the sequence that will be executed when you want the lights to flash yellow. 

The start condition for this sequence is inverted in relation to the start condition for the 
normal operating mode sequence. This implies that the two sequences cannot execute at the same 
time. 

<image>dg_fig18.gif
<b>The Normal Sequence 

The program for the normal operating mode is based on a traffic light following the sequence: 

<b>   <t>North-South <t>West-East
1     <t>Red         <t>Red
2     <t>Red, Yellow <t>Red
3     <t>Grön        <t>Red
4     <t>Yellow, Green <t>Red
5     <t>Red         <t>Red
6     <t>Red         <t>Red, Yellow
7     <t>Red         <t>Green
8     <t>Red         <t>Yellow, Green
9     <t>Back to step 1

The program starts in the initial step. If the start condition is fulfilled, step S1 will 
become active and the red lamps are turned on. After a certain time, step S1 will become 
inactive and step S2 will become active, and a yellow lamp will also be turned on, and so on. 
When step S8 has been active for a certain time, it will be deactivated, and the initial step 
is once again activated. 

<image> dg_fig19.gif
<b>Trigger Signals

The program above shows the logic that controls different operating modes. 

At the very top to the right you set the Dv signal "Mode". If this is set to a logical 1, the 
sequence for the light's normal operating mode will be run, otherwise the sequence for flashing
lights will be run. 

The Dv signal "Reset" will be set to a logical 1 during one execution cycle when the signal 
Mode changes value. This implies that the two Grafcet sequences will return to the initial 
step. The chosen sequence will be executed again when Reset is set to a logical 0. 

The PLC programs you have created must be compiled before they can be executed on a process 
station. 
</topic>

<topic> process_graphics
Plant Graphics 

Plant graphics are often used as an interface between the operator and the process. Plant 
graphics are created with the Plant Graphics Editor. 

<image> dg_fig20.gif
<b>The Plant Graphics Edtitor

Plant graphics can contain dynamics, which are connected to the logical signals, e.g.: 

- Text that becomes visible when a signal reaches a certain value 
- Graphical objects that change color when a signal reaches a certain value 
- Graphical objects that become invisible when a signal reaches a certain value 
- Graphical objects that move depending on the value of a signal 

You can also place push buttons in the plant graphics, which the operator can use for changing 
values of digital signals. To change analog signals you use an input entry field. 

In our example we choose to make a plant graphics, showing a road crossing, where the traffic 
lights (red, yellow, and green) are dynamic as shown in figure. How to create the plant 
graphics is described in chapter 5 Creating Plant Graphics . 

<image>dg_fig21.gif
<b>The Plant Graphics for the Intersection
</topic>
</chapter>

<chapter>
<topic>communication
Communication

The Remote concept in Proview is a way to standardize the methods of communication with other
systems. It describes a number of transport programs and Proview objects used to implement
a variety of different communication protocols and to handle incoming and outgoing messages.
Remote is designed to use different transport protocols such as TCP/IP or BEA Message Queue,
and different hardware media such as ethernet or serial lines.
The main purpose of Remote is to provide the programmer with an interface to communication.

<option> printdisable
Introduction <link> comm_introduction
Protocols <link> protocols
An example <link> an_example
<option> printenable
</topic>

<headerlevel>
<topic>comm_introduction
Introduction
There are some different classes/components/objects that are used to handle the communication.

<h2>RemoteConfig
Required to have any remote communication at all. Without this no remotehandler is started.
Place one object in the node-hierarchy.

<h2>RemNode
Defines a link of some type to a remote node over a specific protocol. 
Several different protocols are supported and there is one specific class for each protocol.
The supported protocols are:

TCP/IP
UDP/IP
MQ (BEA Message Queue)
ALCM (an old Digital protocol, supported for historical reasons)
Serial
Modbus/RTU Serial
3964R (serial protocol from Siemens)

Configuration of each protocol is described further down.
Place RemNode-objects below the RemoteConfig-object.

<h2>RemTrans
Generic class that defines a specific message to or from a specific remote node on a
specific protocol. Should be placed below the RemNode-object. The size of a message to be sent 
is specified in the RemTrans-object. The data however to be sent resides in a buffer that is
configured as a child to the remtrans-object. When a message is to be sent data of the length
specified in the remtrans-object is fetched from the buffer. Sometimes however a header of some
length is added to the message.

<h2>Buffer
Defining the send- and/or receive data area for each message. Exists in different sizes.
Should be placed below a RemTrans-object. The buffer must be of at least the size of the
message that will be received or sent. If size is not enough message will be cut in the end.

<h2>RemTransSend 
Function object used in a plc-program for sending messages.

<h2>RemTransRcv
Function object used in a plc-program for receiving messages.
</topic>

<topic> protocols
Protocols
Which protocol to use is defined by the type of Remnode-object you configure. For each configured 
Remnode-object a transport job is started. That is, a program to handle the specific protocol is
started as a process. This process will handle all RemTrans-object that is configured as children
to the Remnode-object. 

<option> printdisable
UDP <link> udp_ip
TCP <link> tcp_ip
BEA Message Queue <link> bea_mq
Serial <link> serial
3964-R <link> 3964r
<option> printenable
</topic>

<headerlevel>
<topic> udp_ip
UDP
UDP uses socket communication without connection (datagram), compared to TCP wich is a connected protocol.
In the RemnodeUDP-object you specify the name and ip-address of the node to communicate with
aswell as the port-numbers for both ends. The local port-number need to be unique on your node
not to conflict with other communications.

As default all messages is sent with a special header that is not included in the user data buffer.
This header is added at the beginning of the message. The purpose for the header is to give information
about the message that is sent. This helps identify what type of message is received and to wich buffer
the data will be unpacked. The header looks like:

<c>char       RemId1;  /* STX (Hex 02) */
<c>char       RemId2;  /* ETB (Hex 0F) in data message without acknowledge 
<c>                       ENQ (Hex 05) in data message with acknowledge 
<c>                       ACK (Hex 06) in acknowledge message */
<c>short int  Length;  /* Number of bytes in message including this header */
<c>short int  MessId1; /* Message identity part 1 */
<c>short int  MessId2; /* Message identity part 2 */
 
All of the integers in the header will be sent as big endian values, that is most significant byte first
in the datagram. The user data is the responsibility of the user to switch, if he wants integers to be sent
with big endian. Intel (x86), VAX and Alpha all uses little endian! To send messages without headers the
attribute DisableHeader should be set to TRUE. When communicating between two Proview-systems the header
should be kept on. MessId1 and MessId2 is fetched from attributes RemTrans.Address[0] and RemTrans.Address[1].
Through the header it is also possible to request an acknowledge of a sent message. If there is no
acknowledge the message will be resent with a cyclicity specified by the RetransmitTime-attribute in the
remtrans-object.

Since UDP/IP is a connectionless protocol there is a possibility to watch the connection using
keepalive-messages. This is set through the attribute UseKeepalive.

<h2>Sending messages
The transport will send a message to the remote port, consisting of header + data.
MessId in the header is taken from RemTrans.Address[0,1], byte-switched to send as big endian.
If MaxBuffers in remtrans-object > 0, the message is sent with type "want acknowledge" and is stored
in the retransmit queue for the remnode. When a correspondning acknowledge message is received the 
message is deleted from the retransmit queue. This is done automatically by the transport process.

<h2>Receiving messages
When we receive a buffer, first we check the header to see that this is a correct RemTrans message.
Then we search for RemTrans.Address[0,1] that matches the byte-switched MessId. If the data object for 
this message is big enough to contain the message, the message will be stored, and the 
DataValid flag will be set.
If the Remnode is marked to be used without header (DisableHeader-attribute set) then a RemTrans marked as a
receiving remtrans with a enough large buffer will be searched.

</topic>

<topic> tcp_ip
TCP
RemnodeTCP is configured in much the same way as RemnodeUDP. The big (only) difference is that TCP is
a connected protocol which acts in client/server fashion. Thus you have to either connect to a 
remote socket (act like a client) or await a connection (act like a server). When acting like a server
only one client will be accepted. The ConnectionMode-attribute in the remnode-object defines if you are
a client or a server. Setting it to zero (default) means client and setting it to one means server. 

</topic>

<topic> bea_mq
MQ
RemnodeMQ is a transport for sending messages on BEA Message Queue (BMQ). It requires you to have
BEA Message Queue installed on your node. This message queue is good for safely delivering messages 
to a remote node even if it is not up at the moment you send your message. Vice versa, 
messages will safely be delivered to you.

This documentation expects you to have basic knowledge on BEA Message Queue. In basic the communication 
runs on a specific bus. Each node has group-number and can only communicate to other groups on the same bus.
On each group several queues can be configured.

To be able to start this transport of course the Message Queue sotware need to be runnning. You also need some 
environment variables to be set. These are:

<c>DMQ_BUS_ID
<c>DMQ_GROUP_ID
<c>DMQ_GROUPNAME

In the RemnodeMQ-object you configure on which BMQ-queue to recieve messages in the attribute MyQueue.
You also configure the remote nodes group-number and queue to send to in the attributes TargetGroup and
TargetQueue.

<h2>Sending messages
Similarly to UDP and TCP-transports RemTrans. Address[0,1] are used to identify the message. Address[0]
represent the message-class and Address[1] represent the message-type (according to the BMQ-nomenclature).
Address[2,3] are used to define what type delivery mode (Address[2]) that should be used and what action should be
taken when a message cannot be deilvered (Address[3]).

Possible delivery modes are:

<c>PDEL_MODE_WF_SAF 25
<c>PDEL_MODE_WF_DQF 26
<c>PDEL_MODE_WF_NET 27
<c>PDEL_MODE_WF_RCM 28
<c>PDEL_MODE_WF_MEM 29
<c>PDEL_MODE_AK_SAF 30
<c>PDEL_MODE_AK_DQF 31
<c>PDEL_MODE_AK_NET 32
<c>PDEL_MODE_AK_RCM 33
<c>PDEL_MODE_AK_MEM 34
<c>PDEL_MODE_NN_SAF 35
<c>PDEL_MODE_NN_DQF 36
<c>PDEL_MODE_NN_NET 37
<c>PDEL_MODE_NN_RCM 38
<c>PDEL_MODE_NN_MEM 39
<c>PDEL_MODE_WF_DEQ 40
<c>PDEL_MODE_AK_DEQ 41
<c>PDEL_MODE_WF_CONF 42
<c>PDEL_MODE_AK_CONF 43
<c>PDEL_MODE_WF_ACK 44
<c>PDEL_MODE_AK_ACK 45

and possible actions are:

PDEL_UMA_RTS 1
PDEL_UMA_DLJ 2
PDEL_UMA_DLQ 3
PDEL_UMA_SAF 4
PDEL_UMA_DISC 5
PDEL_UMA_DISCL 6

Not all combinations are possible (see BEA Message Queue documentation for more information).

Recommended combinations are,

for safe delivery of message
Address[2] = 26
Address[3] = 4

and for discarding the message if it cannot be delivered
Address[2] = 39
Address[3] = 5

If Address[2,3] are both set to zero a default setting will be used. The default is to discard the 
message if it cannot be delivered.

<h2>Receiving messages
Address[0,1] are used to identify the message. Address[0] represent the message-class and Address[1]
represent the message-type (according to the BMQ-nomenclature).
</topic>

<topic> serial
Serial
RemoteSerial is an attempt to generalize the using of a simple serial line communication protocols.
Its useful when we have a one-way sending of messages from some equipment to the control system. 
You can specify up to eight termination characters in the attribute TermChar[0-7]. 
These termination characters are used to detect the end of a received message (if a charachter matches
any of the termination characters). 
Specify also the settings for the serial link, that is - DevName , Speed , Parity (0 = none, 1 = odd, 
2 = even), StopBits and DataBits. These could be for example /dev/ttyS0, 9600, 0, 1, 8.
</topic>

<topic> 3964r
3964-R
3964R is a simple serial line communication protocol that is developed by Siemens. 

You specify the settings for the serial link as with RemnodeSerial, except for that there are no stp bits
to specify. You must also specify the character timeout (the maximum time between received characters)
in the attribute CharTimeout. The AckTimeout-attribute specifies the time to wait for an answer.

Messages will be sent straight on without any header. ACK, NAK, DLE and BCC is handled according to 
the 3964R protocol.

<h2>Receiving messages
There can be only one RemTrans object for receive-messages because of the lack of header 
in this protocol. Every received message will be put in the first found RemTrans-object below 
the RemNode-object. If the data object for this message is big enough to contain the message, 
the message will be stored, and the DataValid flag will be set.

<h2>Sending messages
The transport will send a 3964R message to the serial without adding any header.
If we don't have contact with the other node the message will be buffered, 
if there are still free buffers for this message. 
</topic>

<topic> modbus-serial
Modbus Serial
The format of MODBUS that is implemented is RTU. For identification of messages we use the fields 
known as slave address and function code in the MODBUS header. The RemTrans.Address[0] and [1] 
defines these fields in the Proview environment. Se MODBUS specifications documents for more information.

Modbus Serial is not yet implemented as an I/O-system in Proview. You have to configure the messages
yourself by using RemnodeModbus and specifying RemTrans-object for the various operations you
want to perform. Modbus works in a request/reply manner so for each operation you want to perform
you specify one RemTrans-object for sending and one for receiving. Except for the Modbus-header of the
message and the checksum handling you have to specify the content of the message to send in the
send-buffer. In the same way you must decode the content of a received message yourself.

Modbus TCP is implemented as an I/O-system in Proview. See more information about this in the document
"Guide to I/O-systems". With Modbus TCP you don't have to care about the encoding of the messages.

<h2>Receiving messages
When we receive a buffer, we search for RemTrans.Address[0] and [1] that matches the fields 
slave adress and function code in the message header. 
If the data object for this message is big enough to contain the message, the message will be stored, 
and the DataValid flag will be set.

<h2>Sending messages
Messages will be sent using the contents of RemTrans.Address[0] and [1] as the fields 
slave address and function code in the message header.
</topic>
</headerlevel>

<topic> an_example
An example
To show how to work with the classes that are briefly described above we will start with a little
example. The classes are described in more detail below.

In our example we have one Proview-system communicating with an other node via UDP/IP. We will
send a few messages in both directions. My node is named 'dumle' and the remote node is named
'asterix'.

The messages we will send is:

d_a_RequestData <t> 4 Byte
d_a_Report <t> 20 Byte

and the messages we will receive is:

a_d_Data <t> 365 Byte (as an answer to the d_a_RequestData-message)
a_d_Error <t> 10 Byte

The configuration in the node-hierarchy looks like this.

The RemoteConfig-object has to be there. I have added a RemnodeUDP object below this and
configured address and nodename aswell as the port-numbers to communicate on.

<image> dg_fig70.png

Below the RemnodeUDP-object I have added four RemTrans-objects, one for each message. In the
remrans-objects I have configured the direction (send or receive). Numbered the addresses so I can
distinguish between the messages and set the sizes on the sending messages.

<image> dg_fig71.png

Below the remtrans-objects I have put the data-buffers. For the smaller messages I have chosen the
small Buff256-buffer. The Data-message is larger and I have therefor chosen the Buff1440-buffer for
this message.

<image> dg_fig72.png

<h2>The data structures
The data structures for the messages are defined in the file ra_plc_user.h in $pwrp_inc-directory. This
file is automatically included when you compile the plc-code. The structures look like:

<c>typedef struct {
<c>  pwr_tUInt32  Id;
<c>} d_a_RequestData;
<c>
<c>#define pwr_sClass_d_a_RequestData d_a_RequestData
<c>
<c>typedef struct {
<c>  pwr_tUInt32   Id;
<c>  pwr_tFloat32  data_1;
<c>  pwr_tInt32    data_2;
<c>  pwr_tInt32    data_3;
<c>  pwr_tInt32    data_4;
<c>} d_a_Report;
<c>
<c>#define pwr_sClass_d_a_Report d_a_Report
<c>
<c>typedef struct {
<c>  pwr_tUInt32   Id;
<c>  pwr_tFloat32  data_1;
<c>  ...
<c>  ...
<c>  pwr_tInt32    data_xx;
<c>} a_d_Data;
<c>
<c>#define pwr_sClass_a_d_Data a_d_Data
<c>
<c>typedef struct {
<c>  pwr_tUInt32   Id;
<c>  pwr_tInt32    func_no;
<c>  pwr_tInt16    err_code;
<c>} a_d_Data;
<c>
<c>#define pwr_sClass_a_d_Error a_d_Error

<h2>The plc code

I have a plc program named Comm. In this program I have placed one RemTransSend-object and one
RemTransRcv-object. These objects are found below the "Other"-hierarchy in the plc-editor palette.
To the RemTransSend-object I have connected the RemTrans that I want to send. In this case the
d_a_ReuestData-message. The message will be sent when the Dv-signal "RequestData" is set. Similarly 
I have to the RemTransRcv-object connected the a_d_Data-message which will be the answer 
to my request.

<image> dg_fig73.png

Both the RemTransSend and the RemTransRcv-objects have a subwindow. For the RemTransSend this subwindow 
will be executed when there is a flank on the snd-pin. When the subwindow has been executed the
DataValid-attribute of the connected RemTrans-object is set. The transport job for this Remnode 
sends the message and sets the DataValid-flag to zero.

For the RemTransRcv the subwindow will be executed when the DataValid-attribute in the connected 
RemTrans-object is set. When the transport job for this Remnode receives a message it fills the
data buffer with the received data and then sets the DataValid-flag. 
After execution the flag will be reset.

<h2>Send subwindow
In the send subwindow we fill in the data in the send-buffer. The send-buffer for the message to send
is connected to a DataArithm. The special 'classdef'-syntax casts Da1 to be a pointer to a
d_a_RequestData-struct (or actually it will cast this pointer to a pwr_sClass_d_a_RequestData,
therefor the define-statement as described above).

<image> dg_fig74.png

<h2>Receive subwindow
In the receive subwindow unpack the data received in the receive-buffer. The recieve buffer
is connected to a DataArithm. Again we use the classdef-statement to cast the Da1-pointer.
We unpack the data to the output pins of the DataArithm. If one DataArithm is not enough to unpack
the parameters we just add more DataArithm's and continue in the same way. 

<image> dg_fig75.png

</topic>

</chapter>

<chapter>
<topic>administrator
Administration

<option> printdisable
Create users <link> adm_user
Register volumes <link> register_volumes
Create project <link> create_project
<option> printenable
</topic>

<topic> adm_user
Users

To gain access to the Proview development and runtime environment you need to login with 
username and password. Users are kept in the user database and are granted privileges which 
states the users authority to make changes in the system.

Systems that share the same users are grouped into a system group, and the the users for this 
group is defined. You can also build a hierarchy of system groups where child groups inherit 
the users of their parent, and additional users can be defined for each child.

A system is connected to a systemgroup by the SystemGroup attribute in the $System object. 
The notation for a system group in a hierarchy is the names of the group separated by a point, 
for example 'Main.West.F1.

In the example below Eric is responsible for all the systems in the plant, and is defined on 
the highest level in the hierarchy. Nils is working with the west side of the plant and is 
defined on the 'West system group. Finally, Carl working with the systems in the F1 part of 
the plant. All system groups has the attribute UserInherit, that states that a child group
inherits all the users of the parent.
 

<image> dg_fig22.gif

Users and systemgroups are created in the administrator:

- Start the administrator with the command 'pwra'
- Enter the UserDatabase from the menu 'File/Open/UserDatabase'.
- Login by entering the login command. Open the login prompt from the menu 'Functions/Command'
  and enter 'login /adm on the command line. If the systemgroup 'administrator is presen
  you also has to add username and password to a user defined in the administrator systemgroup.
- Enter edit mode from the menu 'Edit/Edit mode'.
  Systemgroups and users are represented by object of the classes SystemGroupReg and
  UserReg, that are displayed in the palette to the left. An object is created by selecting
  a class in the palette. After that, you click with the middle mousebutton on the future 
  sibling or parent to the new object. If you click on the map/leaf in the destination object, 
  the new object is placed as the first child, if you click to the right of the map/leaf, 
  it is placed as a sibling.
- Create a systemgroup by selecting 'SystemGroupReg' in the palette, and click with MB2
  (the middle mousebutton) in the right window. Open the SystemGroupReg object and enter
  name ant attribute for the system group. Enter the complete hierarchy name, e.g. 
  'Main.West'.
- Create a user by selecting 'UserReg' in the palette and click with MB2 on the map/leaf
  of the SystemGroupReg object that the UserReg should be a child of. Open the object and
  enter username, password and privileges for the user.
- Save.
- Logout with the command 'logout'.


The user database reside in the directory $pwra_db.

</topic>

<topic>register_volumes
Register Volumes

All volumes in a network has to have a unique volumname and volume identity. To assure this, 
all volumes is registered in a global volume.

The registration is done by the administrator:

- Start the administrator with the command 'pwra
- Enter volume mode from the menu 'File/Open/GlobalVolumeList'.
- Login as administartor.
- Enter edit mode from the menu 'Edit/Edit mode'.
  Volumes are registred by objects of class VolumeReg, that is dislayed in the palette to
  the left. In the palette, there is also the $Hier class, that can be used to order the
  VolumeReg objects in a tree structure.
- Create a VolumeReg object, open the object and enter volumename (equals objectname),
  volumeidentity and project.  
- Save.
- Logout with the command 'logout'.

<h2>Volume name
The name of the volume, a unic name with max 31 characters.

<h2>Volume Identity
The volume identity is a 32 bit word specified in the form v1.v2.v3.v4 where v1, v2, v3 and v4 
are numbers in the interval 0-255. Dependent on the class of the volume, the numbers can be 
chosen in separate intervals. 

RootVolumes            <t>0. 1-254. 1-254. 1-254
User ClassVolumes      <t>0. 0. 2-254. 1-254

The DirectoryVolume always has the identity 254.254.254.253
</topic>

<topic>create_project
Create project

A project is a number of nodes and volumes that share the same development environment. Usually
it consist of some process stations and a couple of operators stations that control a part of 
the plant, but there are no restrictions in the size of a project. You can choose to have each 
node in its own project or all the nodes in the same project.

- All the nodes in a project (on the same bus) has a nethandler link between each other.
- All the volumes and nodes share the same directory tree.
- All node has to be upgraded to new Proview versions at the same time.

A common size is 1-10 nodes in a project. Too many nodes will increase the communication 
overhead and make it harder to upgrade the project.

Create the project in the administrator:

- Start the administrator with the command 'pwra.
- The projectlist is shown as default when starting the administrator. It can also be opened
  from the menu (File/Open/ProjectList).
- Login as administrator.
- Enter edit mode from the menu 'Edit/Edit mode'.
  Projects are represented by objects of class ProjectReg, that is displayed in the palette
  to the left. $Hier objects can be used to order the ProjectReg objects in a tree structure.
- Create a ProjectReg object and enter project name, base version, path and description.
- The project is created when saving. First you have to confirm the changes.
- Save and logout.

<h2>Project name
A project has a project name that identifies the project in the development environment. It is 
similar the system name that identifies the project in the runtime environment, but it 
doesnt have to be the same. Actually a system can have several projects in the development 
environment. When upgrading or making a major modification of the system, it is advisable to 
take a copy of the project and keep the currently running version of the system available for 
minor corrections. The copy is then created under a new project name, though it has the same 
system name.

<h2>Base
Proview is a multiversion system, i.e. different versions of proview can be installed in 
the same development environment and projects of different proview versions can coexist in 
the same development environment. A project points at a Proview base, e.g. V3.4, V4.0, and 
when creating a project you have to choose which base the project should point at.

<h2>Path
The project consist of a directory tree where databases, source files, archives etc is stored. 
The path is the root directory of this tree.

</topic>
</chapter>

<chapter>
<topic>configure_directoryvolume
Directory Volume Configuration

<h1>Open a project
When the project is created, it is found in the administrator project tree. You open a project 
by activating 'Open Project' in the popupmenu for a ProjectReg object. The workbench is now 
opened for the project, and the Volume selection window is displayed, showing all the volumes 
in the project. So far, only the DirectoryVolume is created, and our first task is to configure 
this volume, with the volumes and nodes of the system.

Select the DirectoryVolume and click on the Ok button to open the configuration editor for the 
volume. 

<image> dg_fig23.gif

You can also create a project with a shell command. You tie to the project with the commmand

> pwrp set project 'projektname'

The Workbench is opened with the command

> wb

wb takes user, password and volume as arguments.

<h2>The Configuration Editor

The configuration editor displays two windows, and for the DirectoryVolume, the upper shows 
the volume configuration, and the lower the node configuration. 

<h2>Configure Volumes
First we configure all the root volumes, sub volumes and class volumes in the project. This
i done in the volume window in the directory volume. We start by creating a RootVolumeConfig
object the configures a root volume.

- Enter the edit mode from the menu 'Edit/Edit mode'. Now the palette is visible to the right 
  in the window, and maps can be opened with a click on the map symbol or a double click on 
  the text. 
- Open the Volume map and select the 'RootVolumeConfig' class.
- Click with MB2 in the volume configuration window, and the object is created.
- Select the object and open the object editor from the menu 'Functions/Open Object'.
- Select ObjectName and activate 'Functions/Change value' in the object editor menu.
- Enter the name of the object. The name should be the same as the name of the volume.
- Close the object editor.

Create the RootVolumeConfig objects for the other rootvolumes of the project. For the following
objects you can control the position of the object. If you click with MB2 on the object name of
an object, the new object will be a sibling to this object. If you click on the leaf or map 
symbol, the object will be a child.

Also subvolumes and classvolumes is configured in a similar way with SubVolumeConfig and
ClassVolumeConfig objects.

It is also possible to display the attributes of an object directly in the configuration editor:

- Press Shift and click MB1 on the object to open the object
- Select an attribute and activate Functions/Change value to modify a value.

<h2>Configure the nodes

In the lower window, the nodes in the project is configured. You group the nodes by which
QCOM bus they communicate on. We create two BusConfig objects, one for the produktion nodes
and one for simutation. In the BusNumber attribute the busnumber is defined.

As children to the BusConfig object, the NodeConfig objects are created, one for each process
and operator station. When the NodeConfig objects are created, some additional objects are
created

- a RootVolumeLoad objects, that states the rootvolume to load when the runtime environment is
  started on this node. The name of the object should be equal to the name of the root volume.
- a Distribute object that configures which files are copied from the development environment
  to the process or operator station.

Open the NodeConfig object an enter nodename, operating system and ip address.

Below the BusConfig object for the simulation bus, it is suitable to place a NodeConfig object
for the development station, and below this, a RootVolumeLoad that states the volume of the
process station you are going to work with first. In this way you can start the volume in 
runtime and test it on the development environment. State the name, operating system and
ip address of the development station in the NodeConfig object.

<b>System object
Create also a $System object in the node configuration window. The system object has the 
attributes SystemName and SystemGroup.

- The system name in this state, often is equal to the project name.
- The system group attribute makes the system a member of a system group in the user database, 
  which defines the users for the system. Once the system object is created you have to state 
  a valid username and password when entering the workbench.

<b>Save
Save the session from the menu 'File/Save'. If the configuration passes the syntax check, you 
will receive a question if you want to create the configured volumes. Answer Ok to these 
questions and create the volumes.

If the volume selection window is opened now, 'File/Open' in the menu, all the configured 
volumes are displayed. The next step is to configure a RootVolume.
</topic>

<topic>configure_rootvolume
Configure a Root Volume
A root volume is opened from the volume selection window. Select the volume and click on the 
Ok button. This will start the configration editor for the root volume. As for the 
DirectoryVolume it is separated in two windows, but this time, the upper window shows the 
plant configuration and the lower the node configuration.

<h1>Plant Configuration
The Plant Configuration describes the different plants which you can find in the Proview 
system. A plant is a logical description of e.g. a production process, functions, equipment, 
that is to be controlled, supervised, etc. 
Se an example of a plant configuration <link>plant_configuration, plant_example

<h2>$PlantHier Object
The top object in the plant hierarchy is the $PlantHier object. This object identifies the 
plant or parts of it. 
 
The $PlantHier object is used to group objects and to structure the plant. This object can, 
for instance, be used to group signal objects. 

<h2>Signal Objects
The signal objects define logical signals, or points, representing a quantity or value 
somewhere in the process; whereas contrast to the channel objects, which define physical 
signals. The signal objects are generic, i.e. they can be used with any I/O-system. 

There are some classes of signals that cannot be connected to hardware signal, i.e. the Dv, 
Iv, Av and Sv objects (DigitalValue, IntegerValue, AnalogValue and StringValue). These objects 
are used to store a logical values, integer value, real numbers and strings respectively. 

The actual value of the signal is defined by the attribute ActualValue. 

At present the following signal objects are available: 

Ai <t>Analog input.
Ao <t>Analog outupt.
Av <t>Analogt value.
Ii <t>Integer input.
Io <t>Integer output.
Iv <t>Integer value.
Di <t>Digital input.
Do <t>Digital output.
Po <t>Pulsed digital output.
Dv <t>Digital value.
Co <t>Counter input.
Sv <t>String value.

Note! The PLC program can read signals placed on remote nodes, but cannot write to them.

<h2>PlcPgm Object
The PlcPgm object defines a PLC program. It is possible to have several PLC programs in a 
plant. The following attribute must be given a value: 

- ThreadObject indicates the plc thread where the program is executed. It references a 
  PlcThread object in the node configuration.
- If the program contains a GRAFCET sequence, the ResetObject must be given. This is a Dv, Di 
  or Do that reset the sequence to its initial state.

<bookmark> backup_object 
<h2>Backup Object
The Backup object is used to point out the object or attribute, for which the backup will be 
made. It is also indicated whether storing will take place with fast or slow cycle time.

<h2>MountObject
The MountObject mounts an object in another volume. The attribute Object specifies the mounted 
object.

<h1>Node Configuration
The Node Configuration defines the nodes of your PROVIEW/R system. The nodes are named and 
their contents specified. 

<b>Node Configuration
<image> dg_fig44.gif

<h2>$NodeHier Object
The node hierarchy object is used to group objects in the Node Configuration. This object is 
of the $NodeHier class. The object can be used to group for instance $Node objects or XttGraph
objects. 
See $NodeHier i Object Reference Manual <link>nodehier,"",$pwr_lang/pwrs_xtthelp.dat

<h2>$Node
To define the nodes of the system, you use node objects. The node object is of the $Node class.
When the node object is created, a number of server and operator objects are created.

See $Node i Object Reference Manual <link>node,"",$pwr_lang/pwrs_xtthelp.dat

<h2>I/O Objects
The configuration of the I/O system is dependent of which type of I/O system you use. Proview
has a modular I/O that can handle different types of I/O systems: rack and card systems,
distributed bussystems, or systems connected with some network.

The modolar I/O is devided in four levels: agent, rack, card and channel.

<b>Rack and Card System
We will take the PSS9000 as an example of an rack and card I/O. The system consists of analog
and digital input and output cards that i mounted i racks. The rack i connected via a bus
cable to a busconvertercard in the computor, that converts the PSS9000 bus to the computors
PCI bus.

In this case, the agent level is not used, so the $Node object works as an agent. The rack
level is configured with SSAB_Rack objects that is placed below the $Node object, one for
each rack in the system. The cards are configured with objects below the rack object, that is 
specific for different kind of IO cards. For PSS9000 there are card objects like Ai_Ai32uP,
Ao_Ao4uP, Di_DIX2 and Do_DVDO32. Below a card object, there are placed channel objects, one for
each channel on the card.

Common for the different I/O systems is the channel objects, that defines the input or output
channels of a card or module. There are som different types of channels.

ChanDi <t>Digital input.
ChanDo <t>Digital output.
ChanAi <t>Analog input.
ChanAit <t>Analog input with conversion of the signalvalue from a table.
ChanAo <t>Analog output.
ChanIi <t>Integer input.
ChanIo <t>Integer output.
ChanCo <t>Counter input.

<b>I/O configuration
<image> dg_fig43.gif

<b>Distributed I/O
As an example of distributed I/O we choose profibus. In this case, all the four levels is used.
In the PCI bus of the computor, there is a mastercard the communicates with a number of slaves
on the profibus circuit. The mastercard is configured with a Pb_Profiboard card on the agent
level. Below this, we find the different slaves configured with Pb_DP_Slave objects. They
represent the rack level. Below the slave objects there are module objects of type Pb_Ai,
Pb_Ao, Pb_Di, Pb_Do etc, that are placed on the card level. Below the module objects finally,
the channels are configured with the channel objects ChanDi, ChanDo etc.

<b>Process and thread for I/O objects
I/O objects of the card level, often contains the attributes Process and ThreadObject. In 
Process which process to handle the card is defined.

The card can be handled by the PLC program, that is, reading and writing is made syncroized
with the execution of the PLC. You can also specify a thread in the PLC that should handle the
card, i.e. which timebase is used to read or write the card (the PlcThread attribute).

The card can also be handled by the rt_io process, that usually has a lower priority then the
PLC, and that is not syncronized with the PLC. Certain types of analog inputcards that takes
some time to read, are with advantage handled by this process.

You can also write an application that handles reading and writing of cards. There are an
API to initiate, read and write the cards. This is useful if the reading and writing of a 
card has to be syncronized with the application.

<h2>MessageHandler Object
The MessageHandler object configures the server process rt_emon, that handles the supervision
objects (DSup, ASup, CycleSup). When an event is detected by the server, a message is sent
to the outunits that has has interesst of this specific event.

In the object indicates, for example the number of events that is stored in the node. The object
is automatically create below a $Node object.
See MessageHandler i Object Reference Manual <link>messagehandler,"",$pwr_lang/pwrb_xtthelp.dat

<h2>IOHandler objekt
IOHandler configures properties for the I/O handling.

- ReadWriteFlag specifies whether to adress physical hardware or not.
- IOSimulFlag indicates wether to use the hardware or not.
- The timebase for the rt_io process, i.e. the process that handles slower types of I/O cards
  that are not suitable to be handled by the PLC.

In the production system for a process station, ReadWriteFlag is set to 1 and IOSimulFlag is
set to 0. If you want to simulate the process station, for example on the development station, 
ReadWriteFlag is set to 0 and IOSimulFlag is set to 1.

The IOHandler object is created automatically, when creating a $Node object.
See IOHandler i Object Reference Manual <link>iohandler,"",$pwr_lang/pwrb_xtthelp.dat

<h2>Backup_Conf Object - Configuration Object for Backup 
Sometimes it may be desirable to have a backup of a number of objects in your system. In that 
case you place a backup configuration object, Backup_Conf, under the node object. The backup 
is carried out with two different cycles, one fast cycle and one slow. 

In order to indicate which objects/attributes that should be backed up you use backup objects.
See description of the Backup object <link> configure_rootvolume, backup_object
See Backup_Conf in Object Reference Manual <link>backup_conf,"",$pwr_lang/pwrb_xtthelp.dat

<h2>Operator Place Object
To define an operator place you place an object of the OpPlace class under the $Node object.
 
The following attributes must be given values: 

- OpNumber indicates the number of the operator place. Every operator place in the node
  should be allocated a unique integer. 

See OpPlace i Object Reference Manual <link>opplace,"",$pwr_lang/pwrb_xtthelp.dat

<h2>User Object
For each operator place you must define an out unit of the user type (operator). To do this 
you use a User object. You can only have one user per operator place. User objects should
also be defined for RttConfig and WebHandler objects.
	
The following attributes must be given values: 
	
- UserName indicates the name of the user. 
- OpNumber must have the same number as the operator place. 
- MaxNoOfEvents indicates the number of events which the operator's event list can hold at 
  the same time.
- SelectList indicates the object hierarchies in the Plant Configuration, from which the
   operator will be receiving events.

If we look at the figure above, which illustrates the plant A, and assume that we want to 
receive events only from the encircled objects, we state 'A-C' as an alternative in the 
select list. This choice means that we will be receiving events from the supervised object C, 
and from all supervised objects, which have C as their parent.

<b>SelectList example 1
<image> dg_fig41.gif

Another example:

We look at the figure below, which illustrates the plant TrafficCross1. If you want to receive 
all events from the plant TrafficCross1, you state TrafficCross1 as an alternative. 
TrafficCross1 handles two traffic lights, TrafficLightNS and TrafficLightWE. Let us say that 
we want events only from TrafficLightNS. In that case we state 'TrafficCross1-TrafficLightNS'
instead of TrafficCross1.

<b>Selectlist example 2
<image> dg_fig42.gif

If you want to receive messages from the CycleSup object the supervises the plc threads, you 
must also state the hierarchy name of the $Node object.

In FastAvail you specify the complete hierarchy name of the XttGraph object, which will be 
possible to start from the graphics buttons of the Operator Window  NoFastAvail specifies 
the number of graphics buttons to be used. You can have 0- 15 push buttons. Buttons which are 
not used become invisible.

See User i Object Reference Manual <link>user,"",$pwr_lang/pwrb_xtthelp.dat

<b>Operator Window
<image> dg_fig45.gif

<h2>The Plant Graphics Object - the XttGraph Object 
In order to be able to show plant graphics which are unique to the project in the operator 
station, you must configure XttGraph objects. These objects define, for instance, what the 
files with the plant graphics are called. The objects are refered to in the User object
FastAvail attribute, and in the DefGraph attribute that is found in $PlantHier and signal
objects.

When the object is refered in a FastAvail you can use the possibility to execute a Xtt command
from the XttGraph object. In this way, you can set a signal from a pushbutton in the opeator
window.

- Action. States a Ge graph to open, or an Xtt command to execute.

See XttGraph in Object Reference Manual <link>xttgraph,"",$pwr_lang/pwrb_xtthelp.dat
</topic>
</chapter>

<chapter>
<topic>project_structure
Navigating the project

This chapter describes the projects structure and explains the purpose of the different
directories. The chapter also describes some important files that you can use to configure
and control different things in your project.

The directory structure is divided into two branches, one which contains all source files that
your project consists of and the other is the build tree where all produced files are placed.
<option> printdisable
Introduction <link> proj_introduction
The source tree <link> source_tree
The build tree <link> build_tree
Special files <link> special_files
<option> printenable
</topic>

<headerlevel>
<topic>proj_introduction
Introduction
The figure below shows a projects structure of the directory tree.

<image> dg_psfig1.png

This directory structure is new to Proview v4.6. The reason for this is to make it more clear
what is the sources and configuration files of the project and what is generated content.
Earlier versions did not make this as clear and the idea is that everything that resides in
the build tree can be regenerated from the source tree.

All directories have an environment variable defined so it will be easy to reach all
directories in the project. These variables are always defined as:
<c> $pwrp_<directory>

For example $pwrp_exe for the directory <project_root>/bld/x86_linux/exe.

</topic>

<topic> source_tree
The source tree
The source tree contains all the files that is the projects sources and configuration files.
Yhe top level only contains subdirectories and no source or configuration files. In the
following the contents and purpose of the subdirectories is described.

<option> printdisable
The login directory
$pwrp_login <link> project_login

The database directory
$pwrp_db <link> project_db

The graphical directory
$pwrp_pop <link> project_pop

The application directory
$pwrp_appl <link> project_appl

The documentation directory
$pwrp_doc <link> project_doc

The configuration directory
$pwrp_cnf <link> project_cnf
<option> printenable
</topic>

<headerlevel>
<topic> project_login
$pwrp_login
This is the directory you will start in when you move to a project with the 'sdf'-command.
Two files here are of interest.

<c>login.sh
<c>sysinfo.txt

login.sh is script that is ran when you go to the project. It can be used to set up
project-specific environment variables and alikes.

sysinfo.txt is a text-file which will be printed in the terminal-window when you come to the
project.
</topic>

<topic> project_db
$pwrp_db
This is the directory where the databases for all your local volumes will reside (including
the directory volume where the project is configured). Each database resides in it's own
sub-directory. This is valid is valid if you choose to create your databases as
BerkleyDB-databases. If you instead choose to have mysql-databases the databases will be
created on your mysql-server.
</topic>

<topic> project_pop
$pwrp_pop
This is the directory where the the pictures developed with the ge-editor will be stored
(fileend *.pwg). Finished files should be copied to the exe-directory in the build-tree
($pwrp_exe). Also xtt-helpfiles should be developed here and copied to the
$pwrp_exe-directory.
Pictures that has a corresponding XttGraph-object in the node-hierarchy of a RootVolume will
automatically be copied to the $pwrp_exe-directory when that volume is built.
</topic>

<topic> project_appl
$pwrp_appl
This is the directory where you should keep source code for your own applications belonging
to the project and also for code that you want to link with the plc-program.

One file of special interest that should be kept here is the 
<c>ra_plc_user.h-file
This file will by default be included when you compile the plc-code. It is however included
from a directory in the build-tree (<project_root>/bld/common/inc).

All header-files located here or in subdirectories and that should be included with the
plc-program must be distributed to the $pwrp_inc-directory (<project_root>/bld/common/inc).

If you have some small functions that you only link with the plc-program and nothing else
then you typically place this code in a file called:
<c>ra_plc_user.c
</topic>

<topic> project_doc
$pwrp_doc
This is the place where you put documentation related to the project. This can be your own 
produced documentation or for example DataSheet's on components existing in your plant
that you might want to distribute to the operator stations. 
</topic>

<topic> project_cnf
$pwrp_cnf
This directory contains all configuration files for your project. Some configuration files
are common for the whole project and they are placed here. Some configuration files are 
specific for each node in your project. Create a subdirectory here for each node that has
specific configuration files. Sometimes a configuration is unique to a specific user. If 
this is the case then create a subdirecty in the node-directory for that user.

Files that you should keep here is:

Configuration of Global function keys.
<c>Rt_xtt

Configuration of menus and quick commands in rt_xtt.
<c>xtt_setup.rtt_com

Startup file for Proview.
<c>ld_appl_<nodename>_<bus_no>.txt

File to decide which libraries to link with the plc-program.
<c>plc_<nodename>_<bus_no>.opt

File to control setting of initial values when starting Proview.
<c>pwrp_alias.dat

All the above files are further described below.
</topic>

</headerlevel>

<topic> build_tree
The build tree
The build tree contains all the files needed when building the plc-program. It contains also
all the files produced when you build. Files needed when building the plc-program should be 
in this tree, but the master for all files should be in the source tree. The idea is that 
the build tree should be possible to remove completely and regenerated from tho source tree.

<option> printdisable
The exe directory
$pwrp_exe <link> project_exe

The object files directory
$pwrp_obj <link> project_obj

The list files directory
$pwrp_lis <link> project_lis

The library directory
$pwrp_lib <link> project_lib

The load files directory
$pwrp_load <link> project_load

The log file directory
$pwrp_log <link> project_log

The temporary files directory
$pwrp_tmp <link> project_tmp

The include files directory
$pwrp_inc <link> project_inc

The web files directory
$pwrp_web <link> project_web
<option> printenable
</topic>

<headerlevel>
<topic> project_exe
$pwrp_exe
This is the directory where the exe-files for plc-programs are created. The plc-program
is named:

<c>plc_<nodename>_<bus_no>_<version_no>

If you have your own applications in the project these exe-files should also be generated here.
</topic>

<topic> project_obj
$pwrp_obj
This is the directory where all object files produced during compilation should be placed.
Object-files for the plc-program are automatically placed here. The object file for a 
a PlcPgm-object placed in the PlantHier is named after object identity of this object.

Object files for all other code should also be placed here.
</topic>

<topic> project_lis
$pwrp_lis
This is the directory where you place list-files produced during compilation.
</topic>

<topic> project_lib
$pwrp_lib
This is the directory where libraries will be created containg object files belonging to 
a certain volume. You should also place your own libraries here.
</topic>

<topic> project_load
$pwrp_load
This is the place where load-files for the projects volumes will be created. The load-files 
are named:

<c><volumename>.dbs 
</topic>

<topic> project_log
$pwrp_log
This directory contains log-files that are produced during simulation of your project.
Proview's main log-file is named

<c>pwr_<nodename>.log

If you restart simulation logging will be appended to this file. Remove it if you want a fresh one.
</topic>

<topic> project_tmp
$pwrp_tmp
This directory contains temporary files. These files will be created at certain operations.
For example if you compile a plc-program with debug-mode the sorce files created for this 
program will be created here.
</topic>

<topic> project_inc
$pwrp_inc
This directory contains include-files that will be included when you build the plc-program.
A file called
<c>ra_plc_user.h
will always be searched in this directory. If you have other header-files to include, then include
them in this one.
The master for all these include files should be kept in the source tree and copied here.
</topic>

<topic> project_web
$pwrp_web
This directory contains all files for the web-interface. For example xtt-helpfiles that you generate
as html-files. Also if you create java-pictures from your ge-graphs they will be created here.
</topic>

</headerlevel>

<topic> project_special_files
Special files
All special files that can be used for different kinds of configuration or is of other interest 
and is located somewhere in the project directory tree is described here. They are all
mentioned above in this chapter.

<option> printdisable
Configuration of Global function keys.
Rt_xtt <link> file_rt_xtt

Configuration of menus and quick commands in rt_xtt.
xtt_setup.rtt_com <link> file_rt_xtt

Startup file for Proview.
ld_appl_<nodename>_<bus_no>.txt <link> file_ld_appl

File to decide which libraries to link with the plc-program.
plc_<nodename>_<bus_no>.opt <link> file_plc_opt

File to control setting of initial values when starting Proview.
pwrp_alias.dat <link> file_pwrp_alias
<option> printenable
</topic>

<headerlevel>
<topic> file_rt_xtt
Rt_xtt
This is file is read by rt_xtt when started and the file is searched from the directory where
you start rt_xtt. The file configures hot-keys to perform different kinds of commands.

Valid commands are:

<c>Command     // This will perform a xtt command
<c>SetDig      // This will set a digital signal to TRUE
<c>ToggleDig   // This will toggle the state of a digital signal
<c>ResetDig    // This will reset a digital signal to FALSE

To bind a hot-key to a command you first define the key and then states the command.
For example to bind the keystroke <ctrl>F5 to a command that acknowledges a type A alarm:

<c>Control <Key>F5: Command(event ack /prio=A)

A typical Rt_xtt-file could look something like this:

<c>#
<c># Function key definition file
<c>#
<c>Control <Key>F5: Command(event ack /prio=A)
<c>Control <Key>F6: Command(event ack /prio=NOA) # ack non A-alarms 
<c>Control <Key>F7: Command(show alarm)          # open alarm list
<c>Control <Key>F8: Command(show event)          # open event list
<c># Below opens a graph defined by a XttGraph-object in the node hierarchy.
<c># The $Node-expression will be replaced by the node-object on this node.
<c># This makes the Rt_xtt-file work on different nodes.
<c>Alt <Key>F12: Command(open graph /object=$Node-Pictures-rkt_overview)
<c># Below opens a graph defined by a XttGraph-object in the node hierarchy.
<c># The /focus-syntax sets focus on a object in the graph named NewPlate
<c>Control <Key>F9: Command(open graph /object=*-Pictures-rkt_platepic/focus="NewPlate")
<c>Control <Key>F10: Command(open graph /object=*-Bilder-rkt_cells/focus="Check_no")
<c># Below closes all open graphs except rkt_overview.
<c>Control <Key>F11: Command(close all/except=rkt_overview)
<c>Shift <Key>F1: SetDig(VWX-RKT-RB-DS-OnOffMan_1_2.ActualValue)
<c>Shift <Key>F6: ResetDig(VWX-RKT-RI-RP-CalcPrePos.ActualValue)
<c>Shift Control <Key>v: ToggleDig(VWX-RKT-COM-VWXSVR-BlockOrder_RKT.ActualValue)

</topic>
<topic> file_xtt_setup
xtt_setup.rtt_com
This is file is read by rt_xtt when started and the file is searched from the directory where
you start rt_xtt. The file configures the appearance of rt_xtt. You can build your own menues
and make entries that perform certain commands.

All commands in the file follow standard xtt command syntax. There is a built in help in
rt_xtt which explain most of the commands. To view this help type <ctrl>-b when in xtt to open the command
line and write help. Navigate through the commands to understand them.

When you start rt_xtt there is by default some menues where the first one is named Database.
If for example you would like to create a menu on top (before) this then use this command:

<c>create item/text="Maintenance"/menu/dest=DataBase/before

To create a sub menu (first child) to this use this command:

<c>create item/text="VVS"/menu/dest=Maintenance/firstchild

To create an entry that performs a command below the VVS menu use this command:

<c>create item/text="Graph P1"/command="open graph/object=$Node-pics-h4_proc1"\
<c>       /pixmap=graph/dest=Maintenance-VVS/lastchild
The pixmap qualifier defines the appearance (icon) of this entry. Without this qualifier the icon will be a leaf.
The command opens a graph defined by a XttGraph-object in the node hierarchy.

The result will look like this:

<image> dg_psfig2.png

In addition to building a menu you can also define symbols (shortcuts) which can be used as commands.
The symbols can be entered on the command line and the command defined by the symbol will 
be executed.
The following defines a symbol 'h4' that will open a graph:

<c>define h4 "open graph /object=*-pics-h4_process1"

In the xtt_setup-file you create one command per line. Comment lines starts with a exclamation mark.
</topic>

<topic> file_ld_appl
ld_appl_<node>_<bus_no>.txt
This file controls which applications should start when you start Proview runtime. You can add your
own applications aswell as turn off one or more of the Proview kernel applications.

A typical ld_appl-file can look like this:

<c># Startup file for PROVIEW/R
<c>#
<c># id,   name,   load/noload run/norun,  file,   prio,   debug/nodebug,  "arg" 
<c>#pwr_neth,      , noload, norun, , 5, debug, ""
<c>#pwr_plc,       , noload, norun, ,  , debug, ""
<c>#pwr_alim,      , noload, norun, , 5, debug, ""
<c>#pwr_emon,      , noload, norun, , 5, nodebug, ""
<c>#pwr_tmon,      , noload, norun, , 5, debug, ""
<c>#pwr_qmon,      , noload, norun, , 19, debug, ""
<c>#pwr_nacp,      , noload, norun, , 5, debug, ""
<c>#pwr_bck,       , noload, norun, , 5, debug, ""
<c>#pwr_io,         , noload, norun, , 5, debug, ""
<c>#pwr_linksup,   , noload, norun, , 5, debug, ""
<c>#pwr_trend,     , noload, norun, , 5, debug, ""
<c>#pwr_fast,       , noload, norun, , 5, debug, ""
<c>#pwr_remh,       , noload, norun, , 5, debug, ""
<c>pwr_remlog,       , noload, norun, , 5, debug, ""
<c>#pwr_sysmon,       , noload, norun, , 5, debug, ""
<c>#pwr_elog,       , noload, norun, , 5, debug, ""
<c>pwr_webmon,       , noload, norun, , 5, debug, ""
<c>pwr_webmonmh,       , noload, norun, , 5, debug, ""
<c>pwr_webmonelog,       , noload, norun, , 5, debug, ""
<c>#pwr_opc_server,       , noload, norun, , 5, debug, ""
<c>#pwr_sevhistmon,       , noload, norun, , 5, debug, ""
<c>#pwr_sev_server,       , noload, norun, , 5, debug, ""
<c>#rs_nmps_bck, rs_nmps_bck, noload, run, rs_nmps_bck, 12, nodebug, ""
<c>ra_utl_track, ra_utl_track, noload, run, ra_utl_track, 12, nodebug, ""

The sharp sign means those lines are commented away. Almost all of the proview kernel applications
are commented away since we want those to start. If I take away the hash sign then this kernel 
application will not be started. For example in this case I have no web-interface so I don't 
want the web-applications to start (pwr_webmon).

If I use Nmps-cells and want the content of the cells to be backed up I take away the sharp sign
on rs_nmps_bck.

On the last line I have added an application produced by myself. I've chosen priority 12. I don't
want this application to interfere with the kernel applications and they run between 17 and 19.
</topic>

<topic> file_plc_opt
plc_<node>_<bus_no>.opt
This file (if it exists) will be used as the link options when I build the plc-program.
Proview by default links against some libraries and object-files. If you have your own
opt-file you need to include these. A default opt-file would look like:

<c>$pwr_obj/rt_io_user.o -lpwr_rt -lpwr_usbio_dummy

If you don't have any io-methods of your own (see "Guide to I/O-systems") then you can
skip the first one (rt_io_user). Add your own libraries at will.

</topic>

<topic> file_pwrp_alias
pwrp_alias.dat
File to control setting of initial values when starting Proview.

There are some different ways of setting values through the pwrp_alias-file.
The same file is used for all nodes in the project. Each row in the file should start
with the following expression:

<c><nodename>_setval

The different ways of setting things is described below:

1. Setting an attribute value

<c><nodename>_setval <attribute_name> = <value>

example:

<c>bslds1_setval bsl-ds1-par-maxtemp.actualvalue = 70.0

Using the above described syntax will set the value before the backup is loaded and before
the plc-program is started. This means that if a value is backed up then the backuped value
will always be valid.

If you instead really want the setting in this file to have effect then use this syntax:

<c><nodename>_setvalp <attribute_name> = <value> 

In this case the setting will take effect after the backup-file is loaded and the plc-program
is started.

2. Setting simulation mode

Setting the simulation mode means that no physical i/o will be handled. You can write simulation
programs to set correct values on the input i/o. Add this line to the file:

<c><nodename>_setval plcsim = yes

3. Set all plc-programs to scan off at startup

To set all plc-programs to scan-off use this line:

<c><nodename>_setval plcscan = off

Turn a plc-program on by finding the corresponding WindowPlc-object (child to PlcPgm-object) and
set the attribute ScanOff to 1. Observe that there might be subwindows in this program
that also need to be turned on.
</topic>


</headerlevel>

</chapter>

<chapter>
<topic>plc_programming
Graphical PLC Programming 
	 
This chapter describes how you create PLC programs. 

<h1>The Editor
You enter the plc editor from a PlcPgm object in the plant configuration. Select the object 
and activate 'Functions/Open Program' in the menu. The first time the program is opened, you 
will find an empty document object. The program consist functions blocks and Grafcet sequences.

Programming with function block is made in a horizontal net of nodes and connections from left 
to right in the document. Signals or attributes are fetched on the left side of the net, and 
the values are transferred via connections from output pins to input pins of functions blocks. 
The function blocks operate on the values, and on the left side of the net, the values are 
stored in signals or attributes.
	
Grafcet sequences consist of a vertical net of nodes and connections. A state is transferred 
between the steps in the sequence via the connections. Grafcet and function block nets can 
interact with each other and be combined to one net.




<h2>Edit function objects

The plc editor consists of 
- a working area.
- a palette with grafcet objects and function blocks, and a palette with connections.
- a navigation window, from which the work area can be scrolled and zoomed.

<b>The Plc editor
<image> dg_fig46.gif

A function object is created by selecting a class in the palette, and pressing MB2 in the 
working area. 

<h2>Modify the object
The objects is modified from the object editor. This is opened by selecting the object and 
activate 'Functions/Open Objects' in the menu. Values of the object attributes is modified 
with 'Functions/Change value' in the object editor menu. If an input or output is not used it 
can be removed with a checkbox. There is also a checkbox which states that the value of a 
digital input should be inverted.

<h2>Connect function objects
A output pin and a input pin is connected by

- Place the cursor on the pin, or in an area in the function object close to the pin, and 
  press MB2.
- Drag the cursor to the other pin, or to an area in the function object close to the pin, and 
  release MB2.

A connection is now created between the function objects.

<h2>Fetch a signal value
The value of a Di signal is fetched with a GetDi object. The GetDi object has to point at a 
Di signal and this is done by selecting the signal in the plant configuration, and then press 
Ctrl and double click on the GetDi object. The name of the signal is now displayed in the 
drawing. Dv signals, Do signals and attributes are fetched in the same way, with GetDv, GetDo 
and  GetDp objects.

<h2>Store a value to a signal
The value of an output from a function object is stored in Do signal with a StoDo objects. 
The StoDo object is connected to a Do signal in the same way as the Get objects. Dv signals 
and attributes are stored with StoDv and StoDp objects.

<h1>Grafcet Basics
This section gives a brief introduction to Grafcet. For a more detailed description, please 
read a reference manual on Grafcet. Grafcet is an international norm or method to use at 
sequential control. 

Grafcet consists of a number of steps, and to each step one or more orders are connected, which
will be executed when the step is active. In order to move from one step to another, a 
transition is used. For each transition you have transition conditions, and the move can only 
take place when the transition conditions have been fulfilled. 

<b>Single Straight Sequence 
We look at the single sequence below and assume that the step is active, which means that the 
order connected with the initial step will be carried out. This order will be carried out, 
until the initial step becomes inactive. Step 1 becomes active, when the transition condition 
for transition 1 has been fulfilled. Then the initial step becomes inactive. 

A Grafcet program is always a closed sequence. 

<b>A Simple Straight Grafcet Sequence
<image> dg_fig47.gif

<h2>Förgrenad sekvens

A straight sequence is the most simple variant of sequences. Sometimes you may require 
alternative branches in your program, for instance when you have a machine, which can 
manufacture three different products. At the points where the production differs, you introduce
alternative branches.

<b>Sequece Selection
<image> dg_fig48.gif

The example in the figure above shows the sequence for a machine which can manufacture the 
three products, Red, Green, and Blue. At the point of divergence, point 1 in the figure, you
choose the disired branch depending on the product to produce. The alternative branches diverge
from a step, that is followed by one transition condition in each branch. It is the
constructors task to see that only one of the transition conditions is fullfilled. If several
are fullfilled, which one that is selected is undefined. At point 2 in the figure, the branches
are converging to a common step.

<h2>Parallel Sequences
Sometimes it may be necessary to start several parallel working procedures at the same time. 
It must be possible for these working procedures to operate independent of each other. In 
order to do this, parallel sequences are used. 

<b>Parallel Sequences
<image> dg_fig49.gif

The example in the figure above illustrates the sequence for two machines, which are drilling 
two holes at the same time and independent of each other. When the transition condition before
the parallel divergence (point 1 in the figure), is fullfilled, the activity is moved to
both branches, and the machines start drilling. The drilling is preformed independent of each
other.

The branches are converging to a transition condition (point 2 in the figure), and when the
drilling is completed in both machines, i.e. both S12 and S13 are active, and the transition
condition T17 is fullfulled, the activity is moved to the init step IS2.

<h2>Step
<image> dg_fig51.gif

A Step is used to describe a state in the process. The following applies to a step: 

- A step can be active or inactive. 
- An attribute, Order , indicates whether the step is active or not. 
- You can connect one or more orders to a step. 
- The step can be allocated a name at your own discretion. 

<h2>InitStep
<image> dg_fig50.gif

In each sequence you must have an initial step (InitStep) which differs from a usual step 
at the following points: 

- You should only have one initial step in a sequence. 
- When the program starts its execution, the initial step is active. 
- You can always make the initial step active by setting the reset signal. 

<h2>Transition - Trans
As mentioned above, the transition (Trans) is used to start a transition between an active 
and an inactive step. A logical condition, for instance a digital signal, is connected to a 
transition, and determines when the transition is taken place.

<b>A Transition Example
<image>dg_fig52.gif

<h2>Order
It is possible to connect one or more orders to each step. 

<b>An Order Example
<image>dg_fig53.gif

Normally the output is active when the input is active, but for each order you have a number 
of attributes, with which you can influence the function of the output: 

- D Delay 
- L Time limit 
- P Pulse 
- C Conditional 
- S Stored 

These functions are described in detail in Proview Objects Reference Manual. The principles are
that you indicate the name of the attribute (capital letters) and possible time by means of the
Object Editor. The figure below illustrates how to delay an order from being active for 10 
seconds. 

<b>DOrder Attributes
<image>dg_fig54.gif

The selected order attributes are written in the order symbol. 

The figure below illustrates how you can use an order object with delay to make a step active
for a certain time. 

<b>A Delayed Transition
<image>dg_fig55.gif

Note! You must use a ConFeedbackDigital connection to connect the delayed order object with 
the transition object, otherwise the order of execution will be ambigous. 
See Feedback Connection <link>plceditor_refman, feedback_connection

<h2>Subsekvens - SubStep

När man skapar komplexa Grafcet program, är det ofta en fördel att använda underfönster,
och i dessa placera subsekvenser. På det här sättet får man en bättre layout på programmet.

<b>Subsequence
<image>dg_fig56.gif

The above figure shows the sub sequence of a SubStep. A sub sequence always starts with an 
SsBegin object, and ends with an SsEnd object. In its turn a subsequence can contain 
subsequences. 

<h1>An Introduction to Function Block Programming 

<h2>Block to fetch and store values
Block to fetch and store are used to read and write values. There are fetch and store blocks
for each type of signal. In the figure below a number of these blocks are displayed. They
are found in the 'Signal' folder in the palette.

<b>Block to fetch and store values
<image>dg_fig57.gif

To read signals you use blocka like GetAi, GetIi, GetDv or GetAo. When you want to give a value
to a signal, you use for instance StoAv, StoDo, SetDv or ResDo. 

Digital values can be written in two ways: 

- 'Sto' stores the input value, i.e. if the input is 1 the signal becomes 1, and if the input is
  zero the signal becomes zero. 
- 'Set' sets the signal to one if the input is true, Res sets the signal to zero if the input 
  is true. For instance, if you set a digital output signal with a SetDo object, this will 
  remain set until you reset it with a ResDo object.

To read, respectively assign attribute values other than the ActualValue attribute, you use the
following: 

- analog attributes, GetAp and StoAp 
- integer attributes, GetIp and StoIp
- digital attributes, GetDp and StoDp, SetDp or ResDp 
- string attributes, GetSp and StoSp
- time attributes, GetAtp, GetDtp, StoAtp and StoDtp

<h2>Logic Blocks 
A number of objects are available for logical programming, for instance And-gate (And), 
Or-gate (Or), inverter or timer. For the logical programming digital signals are used. The 
objects are placed in the folder Logic. 

<b>Logic Blocks 
<image> dg_fig58.gif

The figure below shows an And-gate. For this object the following applies: 

- Inputs to the left 
- Output to the right 
- Class name is written at the top 
- The object name is written at the very bottom (can be changed by the user) 
- You can use a variable number of inputs, default is 2. 
- The inputs can be inverted, indicated by a ring on the symbol's input. 

<b>And-gate
<image> dg_fig59.gif

The attributes of the And-gate are changed with the Object Editor.

<b>Attributes of the And-Gate
<image> dg_fig60.gif

The other objects in the 'Logic' folder have similar parameters, see Proview Objects Reference 
Manual . 

<h2>Calculation Blocks 
The folder 'Analog' contains a number of objects for handling analog signals, for instance 
filters, summation blocks, and integrators. 

<b>Arithmetical Calculation Block
<image> dg_fig61.gif

In this guide we do not describe the function of the objects, but it may be expedient to 
comment on the use of arithmetic blocks. The blocks are used for calculation of user defined 
expressions. These are written in the C language. 

In the figure below the block will calculate the expression (A1 + A2 * A3) and give the output 
this value. A1, A2 and A3 are representing analog values, for instance signals supposed to be 
connected to the inputs of the object. 

The expression can contain advanced C code with arrays and pointers.
When writing these expressions it is important to use space before and after the operators, otherwise the expression may be misinterpreted at the execution. 


Här beskrivs inte funktionen hos objekten, men det kan vara lämpligt att kommentera
användningen av aritmetiska block. Blocken används för beräkning av användardefinierade
uttryck, som skrivs i programmeringsspråket C.

I figuren ovan kommer blocket att beräkna värdet (A1 + A2 * A3) och lägga detta på utgången.
A1, A2 och A3 representerar analoga värden, t ex signaler som antas vara kopplade till
ingångarna på objektet. 

Uttrycken kan innehålla avancerad C kod med arrayer och pekar. When you write these, you 
should ge aware of that indexing outside arrays, or erroneous pointers might cause the
execution of the plcprogram to terminate.

<h1>Alarm Supervision 
In Proview it is possible to supervise analog and digital signals. Supervision of analog
signals is made against a limit value. If  the supervised limit is exceeded, an alarm is sent 
to the Message Handler, who in his turn sends the alarm to the out unit, e.g. an operator 
dialog. 

See Proview Objects Reference Manual regarding the attributes of the objects. 

<h2>Supervision of Digital Signals 
For supervision of a digital signal or attribute, you use the DSup object (Digital 
supervisory), which is in the folder Logic. 

The desired signal or attribute, is fetched with a Get-object that is connected to the DSup 
object. Outputs of logical blocks can be directly connected to the DSup object.

<b>Digital Supervisory Objects
<image> dg_fig62.gif

Figure above illustrates supervision of a Dv signal and a digital attribute.

You also have an attribute in the DSup object, 'CtrlPosition', that indicates whether the 
alarm will be activated when the supervised signal/attribute becomes true or false. 

<h2>Supervision of Analog Signals 
For supervision of an analog signal or attribute, you use the ASup object (Analog supervisory),
which is in the folder 'Analog' in the palette. 

Supervision takes place in the same way as for DSup objects with the exception that you can 
choose whether the alarm will be released when the value is above or below the supervision 
limit.

<h1>Compile the plcpgm
Before starting to compile, you have to state on which platform (or platforms) the volume of
the plc should run. Open the volume attributes editor from the navigator menu: 
'File/Volume Attributes', and enter the OperatingSystem. Note, that more than one operating 
system can be choosen. The volume can at the same time be run in the production system, in a 
simulation system and in a educational system, and the systems can have different platforms.

Now, the plcgpm is compiled, by choosing 'File/Build' in the plc editor. Any waring or error 
messages will be displayed in the message window.
</topic>
</chapter>

<chapter>
<topic>dg_components
Components and Aggregates

This chapter is about how to program with components and aggregates.

A component is one (or a number of) objects that handles a component in the plant. A 
component can be for example a valve, a contactor, a temperaturesensor or a frequency
converter. As these components are very common and exist in many different types of plants,
its a great advantage if we can construct an object that containts all that it needed to
control and supervise the component, and is that general that it can be used in most
applications.

A component in Proview can be divided in a number of objects:
- a main object containing configuration data and data needed to supervise and operate
  the component. Is also contains the signal objects for the component.
- a function object that is placed in the plc program and that contains the code to 
  control the component.
- an I/O object that defines possible communication with for example a profibus module.
- a simulate object, used to test and simulate the system.

Furthermore an object graph, documentation, trends etc are included in the component.

An aggregate is a larger part in the plant than the component, and contains a number of
components. An aggregeate can for example be a pump drive, consisting of the components
pump, motor, contactor and safety switch. In other respects, the aggregate is built as
a component with main object, function object, simulate object, object graph, documentation
etc.

<b>Object orientation
Proview is an object oriented system, and components and aggregates are a field where 
the benefits of object orientation are used. In the components, one can see how an object
is built by other objects, that an attribute, besides from beeing a simple type as a float
or boolean, also can be an object, that in its turn are composed by other objects. An
attribute that is an object is called an attribute object. It is not quite analogous to
a free-standing object, as it lacks object head and an object identity, but apart from that
it contatins all the properties of a free-standing object in terms of methods, object graph 
etc.

One example of an attrbute object can be seen in the component object of a solenoid valve.
Here all the signal objects, two Di objects for limit switches, and a Do object for order,
are placed internally as attribute objects. Thus, we don't have to create these signals
separately. When the valve object is created, also the signals for the valve are created.
Another example of attribute objects are a motor aggregate that contains the component
objects for frequency converer, safetyswitch, motor etc. in the shape of attribute objects. 

Another important property in object orientation is inheritage. With inheritage means that
you can create a subclass derived from an existing class, a superclass. The subclass
inherits all the properties of the superclass, but has also the possibility to extend
or modify some of the properties. One example is a component for a temperature sensor that
is a subclass to a general sensor object for analogous sensors. The only difference 
between the temperature sensor class and its superclass is the object graph, where
the sensor value is presented in the shape of a thermometer instead of a bar. Another
example is a pump aggregate derived from a motor aggregate. The pump aggregate is
extended by a pump attribute object and also has a modified object graph that apart
from the motor control also displays a pump.

<image> orm_basetempsensor_og.gif
<b>Fig Object graph for the class BaseTempSensor

Another property that we have introduced is the posibility to disable attributes. The 
reason for this is that the component objects has to be as general as possible, to 
be able to handle all variants of the plant component. A solenoid valve can, for example,
have a limit switch indicating valve open, but there are also solenoid valves with a
limit switch indicating valve closed, or valves with both switches or without switches.
Of course we could create four different component classes, one for each limit switch
alternative, but problems will arise when you start building aggregate of the components.
The number of variants of an aggregate will soon be unmanageable if you want to cover
all the variants of the components. If we for example want to create an aggregate
containing four solenoid valves, and there are four variants of each valve, there will
be 64 variants of the aggregate. If we want to build an aggregate containing four valve
aggregates there number of variants are 4096. The solution is to build a valve component
that contains both switches, but where you can disable one or both switches to be able
to handle all four limit switch variants. In this case attribute objects of class Di are
disabled, which means that they are not viewed in the navigator, ignored by the
I/O handling. Also the in code for the valve component and in the object graph this is taken 
into consideration. The configuration is made in the configurator from the popup menu
where you under 'ConfigureComponent' can choose a configuration from the alternatives.

<image> dg_fig76.png
<b>Fig The ConfigureComponent method for a BaseMValve. 

<h2>Basecomponents
Proview contains a number of component and aggregate objects for common plant components,
e.g. temperature sensor, pressure sensor, pressure switch, solenoid valve, filter, 
motor and fan drives. The are gathered in the classvolume BaseComponent. A basecomponent
can be used directly, and this is probably the usual way to use them, but the idea is also 
that you from the basecomponents create libraries and classes for the specific components 
you are using in your plant.

For solenoid valves there are the baseclass BaseMValve. If you have a solenoid valve
of type Durholt 100.103 you create a subclass with BaseMValve as superclass, 
Durholt_Valve_100_103 and insert the configuration that is valid for this valve. You
also add a link to a datasheet and fill in the Specification attribute, which makes it
possible to identify and order spareparts to the valve. When using a Durholt_Valve_100_103
object you don't have to to so much configuring and adaptations because this is already
made in the class. In this way, component archives can be built for the types of component
you use in your plant.

A problem arises when you use aggregates. An aggregate contains basecomponents from
the BaseComponent volume, and if there are specific subclasses for a component, you
want to use these. The solution is the Cast function. A basecomponent in an aggregate
can be casted to a subclass, given that the subclass is not extended with new attributes.
The casting means that the component fetches initial values, configurations, methods,
object graph etc. from the subclass, i.e. in all situations it acts as the subclass it is 
casted to. The casting is performed from the popup menu in the configurator, where you
in the 'Cast' alternative get a list of all the available subclasses. By selecting a
subclass, the component is casted to this.

<h1>Pressure switch
Let's have a look at a relatively simpel component, a pressure switch, to examine how
it is built and how to configure it. For pressure switches there is the base component
BasePressureSwitch, that is a subclass to BaseSupSwitch. As temperature, pressure and 
limitswithes are quite alike, they have a common superclass. BaseSupSwitch has also a 
superclass, Component, that is common for all component classes. The class dependency for
the pressure switch class can be written

<c>Component-BaseSubSwitch-BasePressureSwitch

<b>The Component class

Component contains the attributes Desciption, Specification, HelpTopic, DataSheet, 
CircuitDiagram, Note and Photo that thus are present in all components. In Description
there are place for a short description, in Specification you enter the model specification,
the other are used to configure the corresponding methods in the operator environment.

<b>BaseSubSwitch
From the superclass BaseSupSwitch the attributes Switch, AlarmStatus, AlarmText, Delay,
SupDisabled and PlcConnect are inherited.

- Switch is a Di object for the pressure switch. It should be connected to a channel
  object in the node hierarchy.
- AlarmStatus shows the alarm status in runtime.
- AlarmText contains the alarm text for the alarm sent at alarm status. The alarm text
  has the default value "Pressure switch, ", but can be changed to some other text.
  Note that if the default text is kept, this will be translated if another language
  is selected. If it is replace by another text, the translation will fail.
- Delay is the alarm delay in seconds, default 0.
- SupDisabled indicates that the alarm is disabled.
- PlcConnect is a link to the function object in the plc code.

To the main object BaseSupSwitch there is a corresponding function object, BaseSupSwitchFo,
which also is inherited by the subclass BasePressureSwitch.

<b>BasePressureSwitch
BasePressureSwitch doesn't have any attributes beyond those inherited from the superclasses.
The unique properties in BasePressureSwitch in the graphic symbol,
Components/BaseComponent/PressureSwitch, and the object graph where the switch symbol includes
a P for pressure.

<b>Configuration
We open the configurator and creates the main object, BasePressureSwitch, in the plant
hierarchy. In a suitable PlcPgm we insert a function object BaseSupSwitchFo and connects
it to the main object with the connect function. Select the main object and click with
Shift/Doubleclick MB1 on the function object. The function object contains the code for
the component, which for a BaseSubSwitch is an alarm that is sent when the switch signal 
is lost.

<image> dg_fig77.png
<b>Fig Main object with corresponding function object

The pressure switch is to be viewed in a Ge graph. We open the Ge graph and fetches the
subgraph BaseComponent/SupSwitch from the palette. The subgraph is adapted to a
BaseSubSwitch object, and all we have to do is to connect it to the main object. Select
the main object in the plant hierarchy and click with Shift/Doubleclick MB1 on the
subgraph.

<image> dg_fig78.png
<b>Fig Graphic symbol, popup menu with methods and object graph

We have now accomplished a working component. We can of course also continue to configure
the method attributes with helptexts and links to photos, circuit diagrams and datasheet.

<h1>Control Valve
Let's have a closer look at a bit more complicated component, BaseCValve, that manoeuvers a
control valve. In contrast to the pressureswitch above, you also have to use 
ConfigureComponent to configure the object, and there are also a simulate object that is
used to test the component.

Suppose now that we have a control valve, that is controlled by an analog output, and that gives
back the valve position in an analog input. Here we can use a BaseCValve. It has the analog 
output 'Order' and the analog input 'Position', i.e. the signals we request. Apart from these,
there are two digital input signals for switch open and switch closed, but these can be 
disabled by a configuration.

<b>Configuration
We place the main object BaseCValve in the plant hierarchy and the function object BaseCValveFo
in a PlcPgm, and links them together with the Connect function. The functionobject has an
order input pin that we connects to a PID object. We also have to state that our valve does not 
have any switches, and we do this by activating 'ConfigureComponent/PositionNoSwitches' in the 
popupmenu for the main object. When we open the main object, and in this the Actuator object,
we shall find a Position signal, but no input signals for the switches.

<image> dg_fig79.png
<b>Fig Main object with function object

<image> dg_fig81.png
<b>Fig Configuring the main object with ConfigureComponent/PositionNoSwiches

In the HMI we place the subgraph BaseComponent/CValve in a Ge graph and connects it to the main
object.

We also want to be able to simulate the valve, to see that it works the way we want. For
simulation there is the function object BaseCValveSim that we place in a specific PlcPgm
for simulation, as this PlcPgm is not to be executed in the production system. The function
object is connected to the main object with the Connect function.

<image> dg_fig80.png
<b>Fig Simulate object for the control valve

The configuration is finished and after building the simulation node we can test the system
and examine the result.

<h1>Pump drive
The next example is an aggregate, a pump drive with a frequency converter that communicates
via Profibus with the protocol PPO3. We will see how a component object in the aggregate,
in addition to the usual main, function and simulation object, also contains I/O objects to 
fetch and send data via Profibus.

The class we use is BaseFcPPO3PumpAggr, and the class dependency for this class is

<c> Aggregate-BaseFcPPO3MotorAggr-BaseFcPPO3PumpAggr

All aggregates have the superclass Aggregate that corresponds to the Component class for 
components. The next superclass, BaseFcPPO3MotorAggr contains all the functionallity for
the control. The pump class BaseFcPPO3PumpAggr extends the motor aggregate with a pump object
representing the mechanical pump, but this doesn't contain any signal or any additional 
functionallity. The pump aggregate also has its own object graph and graphical symbol.

<b>Configuration
The main object BaseFcPPO3PumpAggr is placed in the plant hierarchy, and the function object,
that is inherited from the motor aggregate, BaseFcPPO3MotorAggrFo, is placed in a PlcPgm, and
they are linked together by the Connect function.
 
The main object has no less than 24 different configuration alternatives to choose between,
dependent of which of the components Fuse, Contactor, SafetySwitch, StartLock and CircuitBreaker
are present in the construction. In our case we only have a contactor and a frequence converter
and we the choose the ConfigureComponent alternative CoFc.

Some components in an aggregate can have its own configurations. In this case the contactor
and the motor can be configured individually. Our contactor has to signals, a Do for order and
a Di for feedback, and this applies to the default configuration, i.e. we don't have to change
this. The motor, however has a temperature switch, and thus we select the motor component
and activates ConfigureComponent/TempSwitch in the popup menu.

The next step is to connect the signal objects to the channel objects. The contactor has a
Do for order and a Di for feedback that is to be connected to suitable channels in the node 
hierarchy. The motor has a temperature switch in the shape of a Di that also shoud be 
connected. The frequence converter contatins four signals, StatusWordSW (Ii), ActSpeed (Ai), 
ControlWordCW (Io) and RefSpeed (Ao). These signals are exchanged with the frequency converter 
via Prifibus with the protocol PPO3. There is a specific Profibus module object for PPO3, 
BaseVcPPO3PbModule, that contains the signals for PPO3 communication. The module is configured 
by the Profibus configuratior (se Guide to I/O System) and is connected to the 
FrequencyConverter component in the pump aggregate. As the komponent object and module object 
are adapted to each other, you don't have to connect each signal, you connect the component to 
the module instead. By selecting the module object and activating ConnectIo in the popupmenu 
for the FrequenceConverter component the connection is made.

We also put the subgraph Component/BaseComponents/FccPPO3PumpAggr in an overview graph and
connects this to the main object. Furthermore we place the simulate object 
BaseFcPPO3MotorAggrSim in specific simulate PlcPgm and connects it to the main object.

<b>Mode

The pump aggregate contains a Mode object in which one configures from where the pump is
controlled. It can have the modes Auto, Manuel or Local which means:

- Auto: the pump is controlled by the plc program.
- Manuel: the pump is controlled by the operator from the object graph.
- Local: the pump is controlled from a pulpet.

In the mode object you can configure the modes that applies to the pump in question.
</topic>
<headerlevel>
<topic> dg_compcasestudy
A Component case study

In this section we are going to use components and aggregates to program the control of 
the level in a watertank, 

<b>Process
The process we will control is shown in figure 'Level control'. The water is pumped from
a reservoir to a tank. Our task is to control the level in the tank. To our disposition we
have a level sensor and a control valve. I the system there are also a return pipe with a
solenoid valve that is always open during the control. 

We note that the tank is 1 meter high, which will be reflected in various min and max values 
in the configuration.

<image> dg_fig82.png
<b>Fig Level control

We can identify the following components and aggregates:
- a contactor operated pump, with circuitbreaker, contactor, overload relay and safetyswitch.
- a control valve with two limit switches for open and closed.
- a level sensor.
- a solenoid valve with two limit switches for open and closed valve. 

The following component object corresponds to the components in the plant:

- Pump <t><t>BasePumpAggr
- Control valve <t><t>BaseCValve
- Level sensor <t><t>BaseLevelSensor
- Solenoid valve <t><t>BaseMValve

<h2>Configuration in the plant hierarchy
The components are created under the hierarchy LevelControl. Under this we place a PlcPgm
'Plc' that will contain the code for the control, and a PlcPgm 'Simulate' that will contain
the code neede for simulation and testing of the program. We also create three Dv objects
to start, stop and reset the control program, Start, Stop and Reset.

<image> dg_fig83.png
<b>Fig Plant configuration

<b>Pump
The pumpdrive consists of
- a circuitbreaker with one Di.
- a contactor with a Do for order, and a Di for feedback.
- a safety switch with one Di.
- a motor without any signals.

For the pump, a BasePumpAggr object is created with the name P1.

The ConfigureComponent alternative that corresponds to the construction is CbCoOrSs
(CircuitBreaker, Contactor, Order, SafetySwitch) and we select P1 and activates this
alternative in ConfigureComponent from the popupmenu.

<image> dg_fig86.png
<b>Fig Pump configuration

The components Contactor and Motor has their own configurations, and for them also we have
to activate ConfigureComponent. We select Contactor and select ConfigureComponent/OrderFeedback
as we one signal for order and one for feedback. For the Motor object we activate 
ConfigureComponent/NoTempSwitchOrSensor, as the motor doesn't have any signals.

All the signals in the pump aggregate has to be connected to channel objects in the node 
hierarchy. We find the following signal objects and connect them to suitable channels:

P1.Contactor.Order 		<t><t>Do contactor order.
P1.Contactor.Feedback 		<t><t>Di contactor feedback.
P1.CircuitBreaker.NotTripped 	<t><t>Di circuitbreaker not tripped.
P1.SafetySwitch.On 		<t><t>Di safety switch on.
P1.OverloadRelay.Overload 	<t><t>Di overload relay tripped.


<b>Control valve
The control valve has as actuator that is controlled by an analog output signal, and limit
switches for open and closed valve.

We create a BaseCValve object with the name CV1. The ConfigureComponent alternative that
corresponds to our construction is TwoSwitches.

The following signals are connected to suitable channels in the node hierarchy:

CV1.Actuator.Order 		<t><t>Ao for order.
CV1.Actuator.SwitchOpen 	<t><t>Di for switch open.
CV1.Actuator.SwitchClosed 	<t><t>Di for switch closed.

<b>Level sensor
For the level sensor we create a BaseLevelSensor object with the name LC1. This doesn't
have any ConfigureComponent method, but there are some other properties to configure.

The sensor object has alarm limits for HighHigh, High, Low and LowLow and these are 
stated in the attributes LC1.LimitHH.Limit, LC1.LimitH.Limit, LC1.LimitL.Limit and 
LC1.LimitLL.Limit. We set the limit values to 0.95, 0.90, 0.10 and 0.05. We also set the 
upper limit for presentation of the value in LC1.Value.PresMaxLimit to 1. This will affect 
the range in bars and trends.

<b>Solenoid valve
The solenoid valve is controled by a digital output and has feedback in the shape of
digital inputs for limitswitch open and limitswitch closed.

For the solenoid valve we create a BaseMValve object with the name MV1.

In ConfigureComponent we activate TwoSwitches that correspones to the current configuration
with both limitswitches present.

The signals that is to be connected to channels in the nodehierarchy are:

MV1.Order 		<t><t>Do for order to open the valve.
MV1.SwitchOpen 		<t><t>Di for limitswitch open.
MV1.SwitchClosed 	<t><t>Di for limitswitch closed.

<h1>Plcprogram
The next step is top write the plc program for the level control, in which the function 
object for the components will be inserted:

- BaseMotorAggrFo for the pump P1.
- BaseCValveFo for the control valve CV1.
- BaseMValveFo for the solenoid valve MV1.
- BaseSensorFo for the level sensor LC1.

We create the function objects and connects them to their main objects, by selecting the
main object and activate Connect in the popupmenu for the function object.

We will also use a PID controller to control the level in the tank. The controller will
have the value from the level sensor as process value, and set out the outvalue to the
control valve. The inflow to the tank will then be adjusted to reach the desired level.
The controller is created with the functionobjects Mode and PID.

The program is built around a Grafcet sequence with four steps. See Fig Plc program

1. The initial step IS0 is the resting position when the pump is turned off and all the
   valves are closed.

2. When the Start Dv is set from a button in the operator graph, step S0 is activated. 
   Here the pump is started as the sorder Ord0 is connected to the start inputpin of the
   functionobject for the pump P1. When the pump is started, the On outputpin of the pump
   object is set, and the activity is moved to the next step S1. Note that the sorder
   Ord0 continues to be active, i.e. the pump is turned on until the reset in step S2.

   The value of the error outputpin Err of the pump object is set into the Reset Dv. Reset 
   is stated as ResetObject in the PlcPgm object, and all the sequences in the PlcPgm will 
   be reseted when Reset is set, i.e. the sequence will return to the initial position
   and the pump and the control will be turned off.

3. S1 is the working step, where the controller is active, controlling the level in the tank.
   As long is S1 is not active, the force input of the mode object is set, and the 
   controller has 0 as outvalue. When the step is active, the controller fetches the
   processvalue from the output of the sensor object LC1, and the setpoint is set into
   the mode object LC1_Mode.SetVal from the operator graph. The outvalue of the
   controller is connected to the order inputpin of the control valve. 
   The order Ord1 is also connected to the order input of the solenoid valve, which
   opens the valve.

4. Step S1 is active until the Stop Dv is set from a button in the operator graph. When
   the step is left, the controller is again forced to zero and the control valve is closed.
   Also the solenoid valve is closed. The step S2 is active for a moment, reseting the
   sorder Ord0, thus stopping the pump. Then the sequence returns to the resting position
   IS0.

The mode object LC1_Mode and the controller LC1_PID requires som additional configuration.
In the mode object
- OpMode = Auto to start the controlerl in auto mode.
- MaxSet = 1, maximum setpoint value is the height of the tank, 1 m.
- SetMaxShow = 1, also the hight of the tank.
- SetEngUnit = m, meter.
- PidObjDid = LevelControl-Plc-W-LC1_PID, the name of the PID object.

In PID object
- PidAlg = PID
- Gain = 100
- IntTime = 10
- MaxGain = 200
- SetMaxShow = 1
- SetEngUnit = m
- ModeObjDid = LevelControl-Plc-W-LC1_Mode, the name of the mode object.

<image> dg_fig84.png
<b>Fig Plc program

<h1>Simulate program
We create the simulate program to be able to test all the functions in the program, alarm
handling and operator graphs before the commissioning. You can also use it for education and
demonstration.

The simulate code is put in a separate program 'Simulate', that should not execute in the
production system. In this program, the simulation objects for the components are created:

- BaseMotorAggrSim for the pump P1.
- BaseCValveSim for the control valve CV1.
- BaseValveSim for the solenoid valve MV1.
- BaseSensorSim for the level sensor LC1.

The function object are connected to their main objects, by selecting the main object and
activate Connect in the popupmenu of the function object.

The simulate objects for the pump, control valve and solenoid valve doesn't have any in or
output pins, they work solely against data in the main object, where they read output signals
and set suitable values into the input signals. The simulate objects also have an object graph,
from which the you can influence the simulation and cause different faults to check that the
errors are handled in a proper way and that the operator is informed via process graphs and
alarms.

The simulate object for the level sensor, however, has an input pin, and for this we have
to calculate a simulated level in the tank. A change of the level is determined by the input 
flow minus the output flow divided by the area of the tank. If we assume that the input flow
is proportional to the order output to the control valve (CV1.Actuator.Order), and subtracts
the out flow throgh the solenoid valve when this is open. The change in flow is accumulated
in the OA1 output of the CArithm, which is sent forward to the simulate object of the level
sensor LC1. In LC1, some noise is added to the signal to get a more realistic appearence. This
is achieved by setting LC1.RandomCurve to 1, and LC1.RandomAmplitude to 0.01.

<image> dg_fig85.png
<b>Fig Simulate program

<h1>Process graph
The process graph for the level control is drawn in Ge. We find the graphic symbols for the 
components in the Ge palette:

- Component/BaseComponent/PumpAggr for the pump.
- Component/BaseComponent/CValve for the control vavle.
- Component/BaseComponent/MValve for the solenoid valve.
- Component/BaseComponent/LevelSensor for the level sensor.

The symbols have the dynamic HostObject, which means that they have a preprogrammed dynamic
that is connected to different attributes in the object. You only need to insert the object
name of the main object in HostObject.Object, or connect them by selecting the main object 
and click with DoubleClick Ctrl/MB1 on the symbol.

The default dynamic doesn't include opening the object graph when clicking on the symbol. 
We add this function by opening the attribute editor for the symbol and adding OpenGraph 
in action (if no OpenGraph.GraphObject is stated, the object graph is opened).

We also assemble a tank, from a rectangle and two halfellipses, that we set fill and gradient
properties and also group. On the group, the dynamic FillLevel is set, and FillLevel.Attribute
is connected to the value of the level sensor, LevelControl-LC1.Value.ActualValue. The 
min and max values for FillLevel are set to 0 and 1.

To the left of the tank, a slider i placed from which the setpoint of the level is be set.
It consists of a Slider/SliderBackground3 and a Slider/Slider3. The slider is connected
to the setpoint in the mode object LC1_Mode, i.e. LevelControl-Plc-W-LC1_Mode.SetVal. The
min and max values for the slider are set to 0 and 1.

For the setpoint, also an input field 'SetValue' is created, which is connected to the same
value as the slider above. The process value of the level is displayed in the 'Level' field,
which is connected to the value of the level sensor.

The controller symbol is fetched from Process/PID_Controller in the palette. Is has no
dynamic as default, but we want the object graph for the mode object to be opened when 
clicking on the object, so we add Command to Action with the command 

<c>open graph /class/instance=LevelControl-Plc-W-LC1_Mode

The pushbuttons for Start and Stop are of type Buttons/SmallButton. SmallButton has ToggleDig
as default action, but we want SetDig instead, as the Start and Stop signals are reseted by
the plc program. We remove Inherit in Actions to avoid ToggleDig and add SetDig instead, and
connects to the Start and Stop Dv.

The trend curve is fetched from Analog/Trend in the palette. The process and set values are
to be displayed here, i.e.
- Trend.Attribute1 is set to LevelControl-LC1.Value.ActualValue (the value of the level sensor).
- Trend.Attribute2 is set to LevelControl-Plc-W-LC1_Mode.SetVal (the set value in the mode 
  object).

Finally we draw som pipes and lines and the graph is finished.

We also enter File/Graph attributes and insert the koordinates for the upper left and lower
right corners in x0,y0 and x1,y1. DoubleBuffered is set to 1 and MB3Action to PopupMenu.

<image> dg_fig87.png
<b>Fig Graphic editor

<h1>Simulation
To look at the result of our programming effort, we start the simulation.

When we open the graph, both valves are colored white, which markes that they are closed.
The pump is not started, which is marked with gray color and the the triangle in the pump
symbol doesn't point in the flow direction. The tank is colored white, i.e. it is empty, and
the levelsensor flashes red as the level is beneath the LowLow level in the level sensor object.

By pressing the start button, we leave the resting step in the Grafcet sequence, and activates
the step that starts the pump (S0). When the pump is started, it is colored blue and the
triangle points in the flow direction. In this step, also the solenoid valve is opened and
colored blue. When the pump has started, the sequence proceeds to the working step S1.

We set a set value with the slider to aproximatley 0.3 and hopefully the controller starts
to work. Eventually, some adjustment of the controller parameters are needed, and the controller
graph is opened by clicking on the controller symbol, which opens the object graph for the
Mode object. In this, we click on the PID button to open the object graph of the PID object.
Here we can adjust the gain (Kp) and integration time (Ti).

<image> dg_fig92.png
<b>Fig Object graph mode and PID object.

Let's have a look at what we can do with the components in the process graph.

<b>Level sensor
If you rightclick on the level sensor, an popup menu is opened with the methods that
are defined for the sensor. With OpenPlc you open plc trace for the function object of
the component. with RtNavigator the object is looked up and viewed in the navigator, with
Trend a trend curve for the level is displayed and with OpenGraph the object graph is
opened. The object graph can also be opened by clicking on the symbol.

The upper part of the object graph for components and aggregates have a similar appearence.
There is a meny where you under 'Methods' can activate the methods of the component. Under
'Signals' you can see the signals in the component and open the object graph for them. For
aggregates you can also see the components and open the object graph for them under 
'Components'. There is also a toolbar with pushbuttons for the methods, and two text fields
that displays Description and Specification for the component. In the lowest row in the graph
the Note message is viewed if such a message is inserted (by the Note method).

Furthermore the level is displayed as a number and with a bar, and the alarm limits are also
viewed. The alarm limits can be adjusted with sliders and enabled or disabled by checkboxes.

In the upper right corner of the graph there is a button marked with a 'S'. It is only visible
in simulation mode (i.e. IOSimulFlag in the IOHandler object is set) and is opens the 
simulate graph. From the simulate graph you kan influence the simulated signal. We have already
configured Random with amplitude 0.01, but you kan also add a sinus curve or a sawtoothed curve
to the signal.

<image> dg_fig88.png
<b>Fig Object graph for the levelsensor and simulate graph

<b>Control valve

The object graph for the control valve has indicators for the limit switches and shows
the order output to the valve as a bar.

You can take over the valve in manuel mode, i.e. the valve position is now adjusted with
the slider 'Manual' instead of beeing feched from the outsignal from the controller.
The control loop is now out of order and the water flow is adjusted from the slider.

From the simulate graph you can for example influence the simulation of the limit switches.
If order is 0 and switch closed are not affected, you receive a limit switch alarm and a
red flashing symbol. At simulation the simulate objects sets the correct values into the
limitswitches, but this can be overriden from the simulate graph. By pushing 'Manual Control'
the switch is controlled from the graph instead, and by zeroing the limit switch you can
check that the limitswitch supervision works.

<image> dg_fig89.png
<b>Fig Object graph for the controlvalve and simulate graph

<b>Solenoid valve

The object graph for the solenoid valve displays limit switches and order signal
with indicators. The valve is switched to manual control by clicking on the Man button,
and can now be manouvred by the Open and Close buttons.

From the simulate graph you can, as for the control valve, influence the simulation of the
limitswitches and trigger a switch error alarm.

<image> dg_fig91.png
<b>Fig Object graph for the solenoidvalve and simulate graph

<b>Pump

The object graph for the pump shows a schematic drawing of the components in the pump, and
also a status indicator for each component. By clicking on a component, you open the object
graph for the component.

With the 'Man' button you can switch the mode to manuel and start and stop the pump from
the Start and Stop buttons in the graph.

From the simulate graph various events can be simulated.
- 'SafetySwich on' simuates that someone activates the safety switch. This causes the pump
  to turn off, and the pump symbol is colored yellow. Also the Err outputpin of the function 
  object is set. As This is connected to the Reset Dv the sequence is reset and the control is 
  turned off.
- 'CircuitBreaker tripped' simulates that the circuitbreaker has tripped. 
- 'Contacor feeback lost' simulates that the contactor feedback is lost.
- 'OverloadRelay tripped' simulates that the overloadrelay has tripped.

<image> dg_fig90.png
<b>Fig Object graph for the pump and simulate graph

</topic>
</headerlevel>
</chapter>

<chapter>
<topic> dg_plc_functions
Call functions from the plc program

The functionobject programming in the plc editor has its limitations, and some tasks can
be done much easier and nicer in c-code. c programming can be achieved in CArithm and
DataArihm where you can put an amount of c-code, but the number of characters are limited
to 1023, and occationally this is not enough. Then you have two possibilities, to write a
detached application, or to call a c-function from a CArithm or DataArithm. The advantage 
with calling a c-function is that all initialization and linking to objects and attributes 
are handled by the plc program. The execution of the function is also syncronous with the 
execution lf the plc thread calling the function.  

<h1>Write the code
The code is put into a c file, created somewhere under $pwrp_src. We create the file
$pwrp_src/ra_myfunction.c and inserts the function MyFunction() that performs some simple
calculation.

<c>#include "pwr.h"
<c>#include "ra_plc_user.h"

<c>void MyFunction( pwr_tBoolean cond, pwr_tFloat32 in1, pwr_tFloat32 in2, 
<c>                 pwr_tFloat32 *out)
<c>{
<c>  if ( cond)
<c>    *out = in1 * in2;
<c>  else
<c>    *out = in1 + in2;
<c>}

<h1>Prototype declaration
In the include file ra_plc_user.h a prototype declaration is inserted.

<c>void MyFunction( pwr_tBoolean cond, pwr_tFloat32 in1, pwr_tFloat32 in2, 
<c>                 pwr_tFloat32 *out);

ra_plc_user.h is included by the plc program, and the function can be called from a CArithm
or DataArithm object. You should also include ra_plc_user.h in the function code to ensure
that the prototype is correct.

ra_plc_user should be placed on $pwrp_src and copied to $pwrp_inc, from where it is included
by the plc program and the function code.

<h1>Compile the code
The c file is compiled, for example with make. Below a makefile is shown, that compiles
ra_myfunction.cpp and puts the result, ra_myfunction.o on $pwrp_obj. Note that there is also 
a dependency on ra_plc_user.h, which causes this file to be copied from $pwrp_src to $pwrp_inc.


<c>ra_myfunction_top : ra_myfunction

<c>include $(pwr_exe)/pwrp_rules.mk

<c>ra_myfunction_modules : \ 
<c>		$(pwrp_inc)/ra_plc_user.h \ 
<c>		$(pwrp_obj)/ra_myfunction.o

<c>ra_myfunction : ra_myfunction_modules
<c>	@ echo "ra_myfunction built"

<c>#
<c># Modules
<c>#

<c>$(pwrp_inc)/ra_plc_user.h : $(pwrp_src)/ra_plc_user.h

<c>$(pwrp_obj)/ra_myfunction.o : $(pwrp_src)/ra_myfunction.c \ 
<c>                              $(pwrp_inc)/ra_plc_user.h


<b>Call in the plc program
The function is called from a CArithm or DataArithm.

<image>dg_fig97.png
<b>Fig Function call from the plc code

<b>Link the plc program
When the source code of the function was compiled, the object module
$pwrp_obj/ra_myfunction.o was created. This has to be added to the link command when the
plc program is built, which is achieved by addning the objectmodule to an option file that
is input to the linker. The optionfile resides on the directory $pwrp_exe and is named
plc_'nodename'_'qbus'.opt, for example

<c>$pwrp_exe/plc_mynode_0999.opt

The following line is inserted into this file

<c>$pwr_obj/rt_io_user.o $pwrp_obj/ra_myfunction.o -lpwr_rt -lpwr_usbio_dummy

We kan now build the node and startup Proview runtime.

<b>Debug
One disadvantage when you leave the graphic programming and call c-functons is that you
can not use trace any more for debugging. If you suspect some error in the  function code, 
you occasionally have to start the plc program in debug, set a breakpoint in the function 
and step forward in the code.

First you have to build the plc program with debug, by opening Options/Setting from the
configurator and activate Build/Debug, and then build the node.

After that you start Proview runtime and attach the debugger, gdb, to the plc process by
starting gdb with the pid for the process. pid is viewed by 'ps x'

<c>> ps x
<c>...
<c>5473 pts/0    Sl     0:18 plc_mynode_0999_00003

where 5473 is pid for the plc process, and we start the debugger, set a breakpoint in the
function and let the program continue to execute

<c>> gdb -p 5473 plc_mynode_0999_00003
<c>(gdb) b MyFunction
<c>(gdb) c

When the program enters the function it stops in the debugger, and we kan step (s) and 
examin the content in variables (x) etc.

If the plc program is terminated immediately after start, you can restart in debug.

<c>> gdb plc_mynode_0999_00003

You can also kill the current plc process and start a new one in debug.

<c>> killall plc_mynode_0999_00003
<c>> gdb plc_mynode_0999_00003

</topic>
</chapter>

<chapter>
<topic> dg_application
Application programming

This chapter is about how to write application programs, i.e. programs in c, c++ or java,
that attaches Proview. It is assumed that the reader has basic knowlage in the c
programming language.

In many Proview applications, coding everything in the plc editor with function object
programming works excellent. There are though applications that with graphic programming
will be unecessary complex, for example advancde models, handling of databases and 
materialplanning. In this case you write an application program in c, c++ or java, that
attaches the realtime database, rtdb. The program reads input data from rtdb, makes its
calculations, and sets outdata to rtdb, where the data is further processed by the plc program,
sent to the I/O system and viewed in operator graphs.

We will concentrate on c/c++, as this is the programming languge that i most common in 
application programming and also has most functionality. The interfaces used are described
in Programmer's Reference Manual (PRM).

<option> printdisable
Attach to the realtime database and handle object and data. <link> dg_appl_gdh
Write on the console log. <link> dg_appl_errh
Start an application. <link> dg_appl_file
Handle system events. <link> dg_appl_inievents
Application baseclass rt_appl. <link> dg_appl_rtappl
Send messages and alarms. <link> dg_appl_mh
Communicate with other processes via Qcom. <link> dg_appl_qcom
Fetch data from storage stations. <link> dg_appl_sev
Read and write to the I/O System. <link> dg_appl_io
Build an application with make. <link> dg_appl_build
Java applications. <link> dg_appl_java
<option> printenable
</topic>

<headerlevel>

<topic> dg_appl_gdh
Attach to the database and handle object and data

We start by writing a simple c++ program that attaches to the realtime database and links
to some objects.

The cpp file should be created on the $pwrp_src directory, or subdirectory to this. We create
the directory $pwrp-src/myappl and edits the file ra_myappl.cpp.

<h1>Datatypes
In the includefile pwr.h the basic datatypes in Proview are defined. The most common is
pwr_tBoolean for digital signals and pwr_tFloat32 for analogous signals, but there are also
c types for all the other Proview types, e.g. pwr_tInt32, pwr_tUInt32, pwr_tString80 etc.

<h1>Gdh initialization
The database is attached with a call to gdh_Init() which takes an idenfifier string for the
application as an argument. First we include pwr.h that contains the baseic types in Proview
and rt_gdh.h that contains the API to the database.

<c>#include "pwr.h"
<c>#include "rt_gdh.h"

<c>int main() {
<c>  pwr_tStatus sts;

<c>  sts = gdh_Init( "ra_myappl");
<c>  if ( EVEN(sts)) {
<c>    cout << "gdh_Init failure " << sts << endl;
<c>    exit(0);
<c>  }
<c>}

The function returns a status variable of type pwr_tStatus. An even status implies that
something is wrong, an odd that the call was a success. The status kan be translated into
a string that gives more information about what is wrong. This is achieved with the
errh interface which is described later.

<h1>Read and write attribute values
If we want to read or write an object attribute you can use the functions
gdh_SetObjectInfo() and gdh_GetObjectInfo().  

A read and write of the Dv H1-H2-Start can look like this. Note that the value of the Dv
is fetched from the attribute ActualValue.

<c>pwr_tBoolean value;

<c>sts = gdh_GetObjectInfo( "H1-H2-Start.ActualValue", &value, sizeof(value));
<c>if (ODD(sts)) {
<c>  value = !value;
<c>  sts = gdh_SetObjectInfo( "H1-H2-Start.ActualValue", &value, sizeof(value));
<c>}

<h1>Direct link to attributes
Application programs are often put into an infinite loop, supervising attributes in the
database and reacting to certain changes. In this case you preferably direct link to the
attribute, i.e. get a pointer. This is done by gdh_RefObjectInfo(). In the exampel below
the program is separated in an init() function direct linking to attributes, a scan()
function containing the supervision and control functions, and a close() function removing
the direct links.

<c>class ra_myappl {
<c>  pwr_tBoolean *start_ptr;
<c>  pwr_tRefId dlid;
<c> public:
<c>  ra_myappl() {}
<c>  void init();
<c>  void scan();
<c>  void close();
<c> };

<c>void ra_myappl::init()
<c>{
<c>  sts = gdh_RefObectInfo( "H1-H2-Start.ActualValue", &start_ptr, &dlid, 
<c>                          sizeof(*start_ptr));
<c>  if ( EVEN(sts)) exit(0);
<c>}

<c>void ra_myappl::scan()
<c>{
<c>  for (;;) {
<c>    if ( *start_ptr) {
<c>      // Do something...
<c>      cout << "Starting" << endl;
	
<c>      *start_ptr = 0;

<c>    }
<c>    sleep(1);
<c>  }
<c>}

<c>void ra_myappl::close()
<c>{
<c>  gdh_UnrefObjectInfo( &dlid);
<c>}

In the init() function the pointer start_ptr is set to point to the value of the Dv 
H1-H2-Start in the database.

<h2>Warning
Note that pointers in c requires caution. If you use pointer arithmetics or array indices 
its easy to point at wrong position in the database, and to write in wrong position.
This can give rise to errors that are very hard to find this cause of.

<h1>Direct link to objects
gdh_RefObjectInfo() can, besides direct link to individual attributes, also direct link to
objects and attribute objects.

Suppose that we will set points in a curve and display the curve in a graph. We direct link
to the object H1-H2-Curve of class XyCurve. The includefile pwr_baseclasses.hpp contains a
c++ class, pwr_Class_XyCurve, for the object.

<c>#include <math.h>
<c>#include "pwr.h"
<c>#include "pwr_baseclasses.hpp"
<c>#include "rt_gdh.h"

<c>class ra_myappl {
<c>  pwr_Class_XyCurve *curve_ptr;
<c>  pwr_tRefId dlid;
<c> public:
<c>  ra_myappl() {}
<c>  void init();
<c>  void scan();
<c>  void close();
<c> };

<c>void ra_myappl::init()
<c>{
<c>  pwr_tStatus sts;
<c>  pwr_tOName name = "H1-H2-Curve";

<c>  // Connect to database
<c>  sts = gdh_Init( "ra_myappl");
<c>  if ( EVEN(sts)) exit(0);

<c>  // Direct link to curve object
<c>  sts = gdh_RefObjectInfo( name, (void **)&curve_ptr, &dlid, sizeof(*curve_ptr));
<c>  if ( EVEN(sts)) exit(0);
<c>}

<c>void ra_myappl::scan()
<c>{
<c>  for ( unsigned int i = 0;;i++) {
<c>    if ( i % 5 == 0) {
<c>      // Calculate x and y coordinates for a sine curve every fifth second
<c>      for ( int j = 0; j < 100; j++) {
<c>        curve_ptr->XValue[j] = j;
<c>        curve_ptr->YValue[j] = 50 + 50 * sin( 2.0 *  M_PI * (j + i) / 100);
<c>      }
<c>      // Indicate new curve to graph
<c>      curve_ptr->Update = 1;
<c>    }
<c>    else if ( i % 5 == 2)
<c>      curve_ptr->Update = 0;
<c>    sleep(1);
<c>    if ( i > 360)
<c>      i = 0;
<c>  }
<c>}

<c>void ra_myappl::close()
<c>{
<c>  gdh_UnrefObjectInfo( dlid);
<c>}


<c>int main()
<c>{
<c>  ra_myappl myappl;

<c>  myappl.init();
<c>  myappl.scan();
<c>  myappl.close();
<c>}

The program is compiled and linked with

<c>> g++ -g -c  ra_myappl.cpp -o $pwrp_obj/ra_myappl.o -I$pwr_inc -DOS_LINUX=1 
<c>      -DOS=linux -DHW_X86=1 -DHW=x86
<c>> g++ -g -o $pwrp_exe/ra_myappl $pwrp_obj/ra_myappl.o $pwr_obj/pwr_msg_rt.o 
<c>      -L$pwr_lib -lpwr_rt -lpwr_co -lpwr_msg_dummy -lrt

Later we will see how to use make for compiling and linking.

When opening the object graph for the H1-H2-Curve object, we can study the result.

<image> dg_fig93.png
<b>Fig Object graph for the curve object.

</topic>

<topic> dg_appl_errh
Console log

<h1>Log on the console log
<h2>Console log
The console log contains log messages from system processes. If there is something wrong
with the system, you should look in the console log to examine if any process logs error
messages. The error log is a text file on $pwrp_log, pwr_'nodename'.log, which can also
be opened in rt_xtt from System/SystemMessages. The loggings have five severity levels, 
fatal, error, warning, info and success. Fatal and error are colored red, warning colored 
yellow info and success colored green.

Also applications can write on the console log. First you attach to the console log with
errh_Init(), then you kan write messages with different severity with errh_Fatal(),
errh_Error(), errh_Warning(), errh_Info() and errh_Success(),

errh_Init() is called before gdh_Init() and has as arguments a name of the application and 
an application index supplied as errh_eAnix_Appl1, errh_eAnix_Appl2 etc. Every application
should have a unique application index within the node.

<c>#include "rt_errh.h"

<c>sts = errh_Init( "ra_myappl", errh_eAnix_Appl1);

To the log functions you send the string that is to be written in the log, e.g.

errh_Error( "Something went wrong");

The string can also work as a format statement contaning %s to format strings, %f for
float and %d for integer, see printf for more info.

<c>errh_Error( "Number is to high: %d", n);

The format %m translates a status code to corresponding text

<c>catch ( co_error e) {
<c>  errh_Error( "Error status: %m", e.sts());
<c>}

<h1>Application status
Every application has a status word in the $Node object. It is found in the attribute 
ProcStatus[] in element applicationindex + 20. The status should reflect the  condition 
of the application and is set by the application itself by the function errh_SetStatus(). 

<c>errh_SetStatus( PWR__ARUN);

PWR__ARUN is defined in rt_pwr_msg.h and linked to the text "Application running".

Other useful status codes are

PWR__APPLSTARTUP "Application starting up"  (info)
PWR__APPLRESTART "Application restaring"  (info)
PWR__APPLTERM    "Application terminated"  (fatal)

In the node object there is also a SystemStatus that is a kind of sum of all the status
of server and application processes. Into the systemstatus the server or application status
that is most severe is placed.

<h1>Watchdog
An application that has called errt_Init() is supervised by the system. It should call
aproc_TimeStamp cyclic, or the application status is set to "Process timeout" (fatal).
The timeout for applications is 5 s.

<h1>Application object
An application object can be created for the applications. It is placed in the node
hierarchy under the $Node object and is of class Application.

The application object is registred by the function aproc_RegisterObject() that has
the object identity for the object as argument.

<c>pwr_tObjid aoid;
<c>pwr_tOName name = "Nodes-MyNode-ra_myappl";

<c>sts = gdh_NameToObjid( name, &aoid);
<c>if (EVEN(sts)) throw co_error(sts);

<c>sts = aproc_RegisterObject( aoid);
<c>if (EVEN(sts)) throw co_error(sts);

<h1>Status graph
The application is viewed in the status graph for the node, if the application has attached
errh and registred the application object. I will be shown under 'Application' on the row
corresponding to the application index. In the graph the status of the application and the
last/most severe log message are displayed.

<image> dg_fig94.png
<b>Fig Detail for the status graph displaying status and logg message for the application.

If the process i halted, status is set to timeout. This vill also affect the system status.

<image> dg_fig95.png
<b>Fig The application is halted.

<b>Example
In the example we have extended the program with the xy-curve above, and inserted
calls to set application status, log on the console log and register the application
object.

<c>#include <math.h>
<c>#include <iostream>
<c>#include "pwr.h"
<c>#include "pwr_baseclasses.hpp"
<c>#include "rt_gdh.h"
<c>#include "rt_errh.h"
<c>#include "rt_aproc.h"
<c>#include "rt_pwr_msg.h"
<c>#include "co_error.h"

<c>class ra_myappl {
<c>  pwr_Class_XyCurve *curve_ptr;
<c>  pwr_tRefId dlid;
<c> public:
<c>  ra_myappl() {}
<c>  void init();
<c>  void scan();
<c>  void close();
<c>};

<c>void ra_myappl::init()
<c>{
<c>  pwr_tStatus sts;
<c>  pwr_tOName name = "H1-H2-Curve";
<c>  pwr_tObjid aoid;

<c>  // Init errh with anix 1
<c>  sts = errh_Init( "ra_myappl", errh_eAnix_appl1);
<c>  if ( EVEN(sts)) throw co_error(sts);

<c>  // Write message to consolelog and set application status
<c>  errh_Info( "I feel fine");
<c>  errh_SetStatus( PWR__APPLSTARTUP);

<c>  // Connect to database
<c>  sts = gdh_Init( "ra_myappl");
<c>  if ( EVEN(sts)) throw co_error(sts);
 
<c>  // Register application object
<c>  sts = gdh_NameToObjid( "Nodes-Saturnus7-ra_myappl", &aoid);
<c>  if ( EVEN(sts)) throw co_error(sts);

<c>  aproc_RegisterObject( aoid);

<c>  // Directlink to curve object
<c>  sts = gdh_RefObjectInfo( name, (void **)&curve_ptr, &dlid, sizeof(*curve_ptr));
<c>  if ( EVEN(sts)) throw co_error(sts);

<c>  errh_SetStatus( PWR__ARUN);
<c>}

<c>void ra_myappl::scan()
<c>{
<c>  for ( unsigned int i = 0;;i++) {
<c>    // Notify that we are still alive
<c>    aproc_TimeStamp();
<c>
<c>    if ( i % 5 == 0) {
<c>      for ( int j = 0; j < 100; j++) {
<c>        curve_ptr->XValue[j] = j;
<c>        curve_ptr->YValue[j] = 50 + 50 * sin( 2.0 *  M_PI * (j + i) / 100);
<c>      }
<c>      curve_ptr->Update = 1;
<c>    }
<c>    else if ( i % 5 == 2)
<c>      curve_ptr->Update = 0;
<c>    sleep(1);
<c>    if ( i > 360)
<c>      i = 0;
<c>  }
<c>}

<c>void ra_myappl::close()
<c>{
<c>  gdh_UnrefObjectInfo( dlid);
<c>}


<c>int main()
<c>{
<c>  ra_myappl myappl;

<c>  try {
<c>    myappl.init();
<c>  }
<c>  catch ( co_error e) {
<c>    errh_Fatal( "ra_myappl terminated, %m", e.sts());
<c>    errh_SetStatus( PWR__APPLTERM);
<c>    exit(0);
<c>  }
<c>  myappl.scan();
<c>  myappl.close();
<c>}

</topic>

<topic> dg_appl_file
Start the application

An application that is to be started at Proview runtime startup is inserted into the
application file. This resides on $pwrp_load and is named ls_app_'nodename'_'qbus'.txt,
e.g.

<c>$pwrp_load/ld_app_mynode_999.txt

In the file you insert one line for each application that is to be started

<c># id       name      [no]load [no]run file       prio  [no]debug  "arg"
<c>ra_myappl, ra_myappl, noload,  run,   ra_myappl, 12,   nodebug,   ""

</topic>

<topic> dg_appl_inievents
Receive system events

Proview transmitts messages at certain events, e.g. when a soft restart proceeds or when
the runtime environment is stopped. An application can listen to these messages, for 
example to terminate when Proview is terminated. The messages are receive from Qcom. You
create a Qcom queue and binds this queue to the queue that submits the messages.

<c>#include "rt_qcom.h"
<c>#include "rt_ini_event.h"
<c>#include "rt_qcom_msg.h"

<c>qcom_sQid qid = qcom_cNQid;
<c>qcom_sQid qini;
<c>qcom_sQattr qAttr;

<c>if ( !qcom_Init(&sts, 0, "ra_myappl")) {
<c>  throw co_error(sts);

<c>// Create a queue to receive stop and restart events
<c>qAttr.type = qcom_eQtype_private;
<c>qAttr.quota = 100;
<c>if ( !qcom_CreateQ(&sts, &qid, &qAttr, "events"))
<c>  throw co_error(sts);

<c>// Bind to init event queue
<c>qini = qcom_cQini;
<c>if ( !qcom_Bind(&sts, qid, &qini))
<c>  throw co_error(sts);

In each scan you read the queue with qcom_Get() to see if any messages has arrived. You
can also use the timeout in qcom_Get() to wait to next scan. In the example below, the
terminate event is handled, but also the oldPlcStop and swapDone events that indicates
the start and end of a soft restart. This you only have to do if you want the application
to discover new objects of new configurations after a soft restart.

<c>int tmo = 1000;
<c>char mp[2000];
<c>qcom_sGet get;
<c>int swap = 0;

<c>for (;;) {
<c>  get.maxSize = sizeof(mp);
<c>  get.data = mp;
<c>  qcom_Get( &sts, &qid, &get, tmo);
<c>  if (sts == QCOM__TMO || sts == QCOM__QEMPTY) {
<c>    if ( !swap)
<c>      // Do the normal thing
<c>      scan();
<c>  } 
<c>  else {
<c>    // Ini event received
<c>    ini_mEvent  new_event;
<c>    qcom_sEvent *ep = (qcom_sEvent*) get.data;

<c>    new_event.m  = ep->mask;
<c>    if (new_event.b.oldPlcStop && !swap) {
<c>      errh_SetStatus( PWR__APPLRESTART);
<c>      swap = 1;
<c>      close();
<c>    } else if (new_event.b.swapDone && swap) {
<c>      swap = 0;
<c>      open();
<c>      errh_SetStatus( PWR__ARUN);
<c>    } else if (new_event.b.terminate) {
<c>      exit(0);
<c>    }
<c>  }
<c>}

If you are only interested in stopping the proccess when Proview is taken down, there is
a more simpel way to kill it. You can put a scripfile, pwrp_stop.sh, on $pwrp_exe where
you kill the process.

<c>killall ra_myappl

</topic>

<topic> dg_appl_rtappl
Baseclass for applications rt_appl

The baseclass rt_appl contains many of the initializations and supervision of events 
described above. By subclassing rt_appl you don't have to supply any code for this, it
is done by rt_appl. rt_appl contains three virtual functions that are to be implemented
by the subclass, open(), close() and scan(). open() is used at initialization to direct
link to attributes anad object, scan() is called cyclic with supplied cycletime, and in
close() you remove the direct links.

rt_appl handles this:

- Initialization of gdh, errh and qcom.
- Setting of application status at startup and restart.
- Handling events for soft restart and termination.
- Timestamps to avoid timeout.

This exampel shows the application ra_appl subclassing rt_appl.

<c>class ra_appl : public rt_appl {
<c>public:
<c> ra_appl() : rt_appl( "ra_appl", errh_eAnix_appl1) {}
<c> void open();
<c> void close();
<c> void scan();
<c>};

<c>void ra_appl::open()
<c>{
<c> // Link to database objects
<c>}

<c>void ra_appl::close()
<c>{
<c> // Unlink to database objects
<c>}

<c>void ra_appl::scan()
<c>{
<c> // Do something
<c>}

<c>int main()
<c>{
<c> ra_appl appl;

<c> appl.init();
<c> appl.register_appl( "Nodes-MyNode-MyAppl");

<c> appl.mainloop();
<c>}


</topic>

<topic> dg_appl_mh
Send alarms and messages

From an application you can send alarm and messages to the alarmlist and eventlist of
the operator. First you have to connect to the event monitor with mh_ApplConnect() which
takes the object identity for the application object as first argument.

<c>#include "rt_mh_appl.h"
<c>
<c>pwr_tUInt32 num;
<c>sts = mh_ApplConnect( aoid, mh_mApplFlags(0), "", mh_eEvent_Info, mh_eEventPrio_A,
<c>			mh_mEventFlags_Bell, "", &num);
<c>  if (EVEN(sts)) throw co_error(sts);

We then can send alarms with mh_ApplMessage().

<c>mh_sApplMessage msg;
<c>pwr_tUInt32 msgid;

<c>memset( &msg, 0, sizeof(msg));
<c>msg.EventFlags = mh_mEventFlags(mh_mEventFlags_Returned | 
<c>				  mh_mEventFlags_NoObject | 
<c>				  mh_mEventFlags_Bell);
<c>clock_gettime( CLOCK_REALTIME, &msg.EventTime);
<c>strcpy( msg.EventName, "Message from ra_myappl");
<c>strcpy( msg.EventText, "I'm up and running now !");
<c>msg.EventType = mh_eEvent_Alarm;
<c>msg.EventPrio = mh_eEventPrio_B;

<c>sts = mh_ApplMessage( &msgid, &msg);
<c>if (EVEN(sts)) throw co_error(sts);    

<image> dg_fig96.png
<b>Fig The alarm in the alarmlist.
</topic>

<topic> dg_appl_qcom
Communicate with other processes

Proview's protocol for communication between processes can be used also by applications.
The communication can be

- between processes in the same node.
- between processes in different nodes that belongs to the same project.
- between processes in nodes that belongs different projects, if the project has the same
  Qcom bus. In this case the nodes have to be configured by FriendNodeConfig objects where
  Connection is set to QcomOnly.

Read more about Qcom in Qcom Refrence Guide.
</topic>

<topic> dg_appl_sev
Fetch data from a storage station

Data stored in a Proview storage station can be fetched by the client interface sevcli.
First you initiate sevcli with sevcli_init() and state which storage station you want to
fetch the data from with sevcli_set_servernode().

<c>sevcli_tCtx sevctx;
<c>char server_node[40] = "MyStorageStation";

<c>if ( !sevcli_init( &sts, &sevctx))
<c>  throw co_error(sts);

<c>if ( !sevcli_set_servernode( &sts, sevctx, server_node))
<c>  throw co_error(sts);

Then you can fetch data with sevcli_get_itemdata(). Data is identified by object identity and
attribute name. You also state the time range for the data that is to be fetched and
maximum number of points.

<c>pwr_tTime *time_buf;
<c>void *value_buf;
<c>pwr_tTime from = pwr_cNTime;
<c>pwr_tTime to = pwr_cNTime;
<c>int rows;
<c>pwr_eType vtype;
<c>unsigned int vsize;
<c>pwr_tOName name = "H1-H2-Temperature";
<c>pwr_tOName aname = "ActualValue";
<c>pwr_tObjid oid;
<c>char timstr[40];

<c>sts = gdh_NameToObjid( name, &oid);
<c>if (EVEN(sts)) throw co_error(sts);

<c>if ( !sevcli_get_itemdata( &sts, sevctx, oid, aname, from, to, 1000, &time_buf, &value_buf,
<c>                           &rows, &vtype, &vsize))
<c>  throw co_error(sts);

<c>for ( int i = 0; i < rows; i++) {
<c>  time_AtoAscii( &time_buf[i], time_eFormat_DateAndTime, timstr, sizeof(timstr));
<c>
<c>  cout << timstr << " " << ((pwr_tFloat32 *)value_buf)[i] << endl;
<c>}

<c>free( time_buf);
<c>free( value_buf);

Finally you call sevcli_close() to disconnect the server node.

<c>sevcli_close( &sts, sevctx);

</topic>

<topic> dg_appl_io
I/O handling

If an application requires fast and syncronized I/O data it can work directly against the
I/O system and call the I/O routines to read and write I/O on its own.

Initialization is done with the function io_init(), to which a process argument is supplied.
Process identifies which I/O uints (agent, rack or card) are handled by a specific process. 
Each I/O object has a Process attribute and if this corresponds to the process sent as 
argument to io_init(), the unit will be handled by the application. If a card is handled 
by an application, also the rack and agent of the card have to be handled by the application.

As the Process attribute is a bitmask, a unit can be handled by several processes by
setting several bits in the mask. If you for example have several cards in a rack, and some 
of the card should be handled by the plc-process and some by an application, the rack unit 
has to be handled by both the plc and the application. How and if it works to handle a 
unit from several processes depends on how the I/O methods for the unit are written.
For example for Profibus, you can not separate the handling of slaves in different
processes.

<c>#include rt_io_base.h

<c>io_tCtx io_ctx;

<c>sts = io_init( io_mProcess_User, pwr_cNOid, &io_ctx, 0, scantime);
<c>if ( EVEN(sts)) {
<c>  errh_Error( "Io init error: %m", sts);
<c>  throw co_error(sts);
<c>}

Reading in executed with io_read() which reads data from the I/O units and places
the data in the signals connected to the unit. The application preferably direct links
to these signals, and also to the signals of the output units. The output units are written 
to with the function io_write().

<c>sts = io_read( io_ctx);

<c>sts = io_write( io_ctx);

</topic>

<topic> dg_appl_build
Build an application

A c++ application has to be compiled and linked, and you can use make to do this. Proview
contains a rule file, $pwr_exe/pwrp_rules.mk, that contains rules for compilation.

A makefile for the application ra_myappl on the directory $pwrp_src/myappl can look 
like this ($pwrp_src/myappl/makefile): 

<c>ra_myappl_top : ra_myappl

<c>include $(pwr_exe)/pwrp_rules.mk

<c>ra_myappl_modules : \ 
		$(pwrp_obj)/ra_myappl.o \ 
		$(pwrp_exe)/ra_myappl

<c>ra_myappl : ra_myappl_modules
	@ echo "ra_myappl built"

<c>#
<c># Modules
<c>#

<c>$(pwrp_obj)/ra_myappl.o : $(pwrp_src)/myappl/ra_myappl.cpp \ 
<c>                          $(pwrp_src)/myappl/ra_myappl.h

<c>$(pwrp_exe)/ra_myappl : $(pwrp_obj)/ra_myappl.o
<c>	@ echo "Link $(tname)"
<c>	@ $(ldxx) $(linkflags) -o $(target) $(source) -lpwr_rt -lpwr_co \ 
<c>		-lpwr_msg_dummy -lrpcsvc -lpthread -lm -lrt

The makefile is executed by positioning on the directory and writing make

<c>make

You can also insert the build command into the Application object for the application 
in the attribute BuildCmd. In this case the build command is

<c>make -f $pwrp_src/myappl/makefile

This command is the executed when the node is built from the configurator. This is a
way to ensure that all applications are updated when the node is built.

</topic>

<topic> dg_appl_java
Java applications

Some API also exist for java in the shape of the classes Gdh, Errh and Qcom. Below is
an example of a java application attaching the realtime database and reading and writing
an attribute.

<c>import jpwr.rt.*;

<c>public class MyJappl {
<c>  public MyJappl() {
<c>    Gdh gdh = new Gdh( null);

<c>    CdhrBoolean rb = gdh.getObjectInfoBoolean( "H1-H2-Start.ActualValue");

<c>    PwrtStatus rsts = gdh.setObjectInfo( "H1-H1-Start.ActualValue", 
<c>					    !rb.value);
<c>  }

<c>  //Main method
<c>  public static void main(String[] args) {
<c>    new MyJappl();
<c>  }
<c>}

To compile and execute you have to put $pwr_lib/pwr_rt.jar and the working directory into
CLASSPATH, and $pwr_exe into LD_LIBRARY_PATH

<c>> export CLASSPATH=$pwr_lib/pwr_rt.jar:$pwrp_src/myjappl
<c>> export LD_LIBRARY_PATH=$pwr_exe

Compile with
<c>> javac MyJappl.java

and execute with
<c>> java MyJappl

For auto start of the application you create a shellscript that exports CLASSPATH and
LD_LIBRARY_PATH, and starts the java application. The script is inserted into the appl-file
in the same way as a c application.

</topic>

</headerlevel>
</headerlevel>
</chapter>

<chapter>
<topic>ge_man
Creating Process Graphics

This chapter describes how you create process graphics.

Process graphics are drawn and configured in the Ge editor.

<h1>The Ge editor

Ge is opened from the menu in the navigator: 'Functions/Open Ge'. It consist of 

- a tool panel
- a work area
- a subgraph palette
- a color palette
- a window displaying the plant hierarchy
- a navigation window

<h2>Background picture
A background image is drawn with base objects such as rectangles, circles, lines, polylines 
and text. These are found in the tool panel. Create a base object by activating the pushbutton 
in the tool panel and dragging or clicking MB1 in the work area. If the base object should be 
filled, select the object and activate fill in the tool panel. Change the fillcolor by 
selecting the object and click on the desired color in the color palette. Change the border 
color by clicking with MB2 in the color palette, and the text color by clicking Shift/Click MB1.

<h2>Subgraphs
A subgraph is a graphic component, e.g. a valve, a motor, a pushbutton. To create a subgraph, 
select a subgraph in the subgraph palette and click MB2 in the work area. 

<h2>Groups
Base objects and subgraphs can be grouped together by selecting them and activating 
'Functions/Group' in the menu.

<h2>Dynamics
Subgraphs and groups has dynamic properties, i.e. they can be connected to signals in the 
runtime database, and change color, position or shape depending on the values of the signals. 
A subgraph often has default dynamic behaviour, for example an indicator shifts between two 
colors. You only have to connect the indicator to a digital signal to make it work. This is 
done by selecting a signal in the plant hierarchy window, and click on the valve with 
Ctrl/DoubleClick MB1. 

A pushbutton has an action property, is sets, resets or toggles a signal in the database. 
A button with a set action is created by selecting a ButtonSet in the subgraph palette and 
click MB2 in the work area. The signal that should be set is connected as above, by selecting 
the signal and click with Ctrl/DoubleClick MB1 on the button. In the object editor, a button 
text can be assigned.

<b>Connect a subgraph to a signal
<image> dg_fig63.gif

Group also has a dynamic property, i.e. they can shift color, move, or perform some action. 
They dont have any default action or default color,as the subgraphs. You have to assign this
for each group.

<h2>The Object editor
Base objects, subgraph objects and groups have properties, that is changed from the object
editor. The object editor is opened by selecting the object, and activating 
'Function/Object attributes' in the mnu. By opening the object editor for the pushbutton
mentioned above, you can for example enter the text, that is displayed in the button, in the
attribute 'Text'.

If a subgraph has more advanced dynamics, for example shift between several colors, you often
has to connect it to several signals. If you open the object editor for a valve, you see that
it can be connected to two attributes, 'DigError.Attribute' and 'DigLowColor.Attribute'.
The DigError attribute indicates that something is wrong, and if this signal is true, the
valve is colored red. The DigLowColor attribute is connected to the open switch of the valve.
If this signal is false, the valve is colored in the color stated in 'DigLowColor.Color'. Is
the signal true, it keeps the color given in the editor. The signals of the two attribute is
inserted by selecting each signal in the plant hierarchy respektively, and clicking with
Ctrl/Doubleclick MB1 on the attribute row of the attribut. The color 'DigLowColor' is stated
by opening the attribute and selecting one of the 300 colors. The colors has the same order
as in the color palette, and with a little practice they can be identified by the name.

<b>The Object Editor for a valve
<image>dg_fig64.gif

<h2>Graph borders
The drawing area in Ge is unlimited in every direction, so before saving the graph, you have 
to state the borders of the graph. Open the graph attributes with 'File/Graph' attributes  in 
the menu. Measure the coordinates of the upper right corner, and insert as x0 and y0, then 
measure the coordinates of the lower left corner and insert as x1 and y1. The measurement is 
done by placing the cursor in position and read the coordinates in the ge message row.

<b>Graph Attributes
<image>dg_fig65.gif

<h1>Configuration in the workbench
<h2>The XttGraph object
To each plant graphics belongs a XttGraph object. This object is usually a child of the 
operator place object (OpPlace) for the node, on which the graphics will be displayed. It is 
necessary to create a XttGraph object for each node, on which the graphics will be displayed. 
However, you only need to have one graph file. The following attributes in the graph object 
must be set to appropriate values:

- Action, the name of the pwg file with file type, e.g 'hydr.pwg.
- Title, the title of the graph window.
- ButtonText, text of the button in the operator window.

The XttGraph object contains other attributes which e.g. helps you to customize the position 
and size of plant graphics. These attributes are described in detail in Proview Objects 
Reference Manual .
See XttGraph in Object Reference Manual <link>xttgraph,"",$pwr_lang/pwrb_xtthelp.dat
</topic>
</chapter>

<chapter>
<topic>conf_test
Running and Testing a Proview System
In preceding chapters we have described how to configure a PROVIEW/R system, how to create 
PLC programs and how to create plant graphics. Now it is time to run and test the system. 

This chapter shows how to: 

- create load files 
- create a boot file 
- distribute

<h2>Syntax control
Before creating load files it is appropriate to make a syntax control. This is done from the 
menu in the navigator, 'File/Syntax'.

<h2>Creating Load Files 
Before starting the runtime environment you have to create a number of load files, one for each
volume in your system. You create the load files from the Navigator of each volume,
'Function/Build Volume'.

<h2>Creating Boot Files
For every node in the project you have to create a boot file. The bootfile contains mainly the 
root volume to load for the node. The bootfile is created from the configurator menu, 
'Functions/Build Node'. This command will also build the plcprogram for the node.

<b>Select node when creating a bootfile
<image> dg_fig66.gif

At this point, everything in the development environment is configured and generated, and its 
time to set up the runtime environment.

<h2>Install the Proview runtime package
...

<h2>Distribute
...
</topic>

<topic>runtime monitor
Runtime Monitor
Often you want to start to runtime environment on the development node, for example
if you have made a change in the system that you want to test, before sending it
down to the production system.

The Runtime Monitor is used to start and stop the runtime environment on the 
development station.

<image>dg_fig67.gif

To start the runtime environment on the development station, the following requirements
has to be fulfilled

- the node should be configured with a NodeConfig object in the project volume.

- the correct comunication buss should be set. To do this you set the bash environment variable
  PWR_BUS_ID to the buss stated in the BusConfig object in the project volume, for example
<c>  export PWR_BUS_ID=999

The runtime monitorn also requires a StatusMontorConfig object to be configured below
the $Node object in the volume to start.

The Runtime Monitor is started from Tools/Runtime Monitor in the menu. There are buttons
to start and stop the runtime environment ('Start Runtime' and 'Stop Runtime'). In the
colored square, the status of the runtime environment is displayed ('Running' or 'Down').
The color indicates the status of the system, red for error status, yellow for warning, 
and green for OK.

The button 'Restart Runtime' performes a soft restart, and can be used if the runtime
is started already. 

</topic>

</chapter>

<chapter>
<topic>configurator_refman
The Configurator

The configurator is used to navigate in and configure the Workbench.
The configurator displayes the object in one volume. The objects are usually separated in two
windows, a left and a right, and how the separation is done depends on what type of volumes
is handled.

- For rootvolumes and subvolumes, the plant hierarchy is displayed in the left window, and
  the node hierarchy in the right.

- For the directory volume, volumes are displayed in the left window and busses and nodes in
  the right.

- For class volumes, classes are displayed in the left window and types in the right.

From 'View/TwoWindow' you kan choose wether to display two windows or only one. I only one
window is displayed, every second time you activate 'TwoWindow' it will be the upper window
that is displayed, else it will be the lower window.

From 'Edit/Edit mode' you enter edit mode, and a palette with varoius classes is displayed to
the left. You can now create new objects, move objects, change values of attributes etc.

<h2>Volume representation

Volumes is stored in various formats, in a database, in a loadfile or in a textfile. The
configurator can display a volume in all these formats, and it has four different 
representations of volumes:

- db, a database. Rootvolumes and subvolumes are created and edited in a database. Before you
  can start the runtime environment, loadfiles are generated from the volumes. The loadfiles
  are read at runtime startup. The db representation i editable.

- wbl, a textfile with extension .wb_load. The classvolujes are stored as wbl, and root and
  sub volumes can be dumped in a wbl-file, for example when upgrading, and later reloaded. The
  wbl representation is node editable. When editing a class volume you import the wbl
  representation to a mem-represention, and the save it as wbl again.

- dbs, a loadfile. From rootvolumes, subvolumes and classvolumes, in db and wbl representation,
  loadfiles are cerated and used in the runtime environment. The configurator also reads the
  dbs-files of the classvolumes to be able to interpret the classes, and the dbs-files of the
  root and subvolumes to be able to translate references to external objects. The dbs
  representation is not editable.

- mem, a volume the configurator keeps internally in memory. Copy/Paste buffers consist of
  mem-volumes. The classeditor imports the classvolume, which originally is a wbl, to a mem
  volume, as the mem representation is editable.

As we see above, the same volume can exist both as a database or as a loadfile. When staring
the configurator, you specify a volume as an argument. For this volume, the database i opened,
i.e. it is represented as a db, for the other volumes in the project, the loadfiles are opened,
i.e. they are represented as dbs. This makes it possible to display the other volumes in the 
project, and to solve references to them, but they are not editable. If the database of the
volume is locked, because someone else has opened it, an error message is displayed and the
loadfile is opened instead of the database.

In the figure below the volume list is displayed, which is opened from 'File/Open' in the menu.
I shows all volumes opened by the configurator. We can see that the database for the root
volume VolTrafficCross1 is opened, while the other root volume, VolOpTrafficCross1 is opened
as a loadfile. Also the class volumes are opened as loadfiles.
<image> dg_fig24.gif

If no volume is given as argument when starting the configurator, the database of the 
directory volume is opened, and the other volumes are opened as dbs-volumes.

<h1>Navigate <bookmark>wnav_navigate
The object of the current volume are displayed in the configurator. The objects are ordered
in a tree structure, and objects with chidren are displayed with a map, and objects without 
children with a leaf. For each object is displayed as default, the object name, class and
possible description (the description is fechted from the Description attribute in the object).

By clicking with MB1 on a map, the map is opened and the children of the object are displayed.
Is the map alread open, it is closed. You can also open a map with a doubleclick anywhere in
the object row.

If you want to see the content of an object, click with Shift/Click MB1 on the map or leaf,
or Shift/Doubleclick MB1 anywhere in the object row. Now the attributes of the object are
displayed, together with the value of each attribute. The attributes are marked with various
icons dependent of type.

<b>Bitmaps for different types of attributes
<image> dg_fig26.gif

- An ordinary attributs is marked with a long narrow rectangle.

- An array is marked with a map and a pile of attributes. The array is opened with Click MB1
  on the map, or Doubleclick anywhere in the attribute row. Now the elements of the array
  are displayed.
<image> dg_fig27.gif

- An attribute refering another attribute or object, i.e. of type Objid or AttrRef, is marked
  with an arrow ponting to a square.

- Enumeration types, Enum, is marked with am map and some long narrow rectangles. By clicking
  MB1 on the map the different alternatives of the enumeration are displayed. The alternatives
  are displayed with checkboxes, and the choosen alternative is marked. You can also 
  Doubleclick MB1 in the attribute row to display the alternatives.
  attributraden för att se alternativen.
<image> dg_fig28.gif

- Mask types, Mask, is marked simular to Enum, an the different bits are displayed with Click
  MB1 on the map, or Doubleclick MB1 in the attribute row.
<image> dg_fig29.gif

- Attrbute objects, i.e. attributes that contains the datastructure of an object, is marked
  with a square with a double line on the upper side. The attribute object is opened with
  Click MB1 on the square, or Doubleclick MB1 in the attribute row.

En object or attribute is selected with Click MB1 in the object/attribute row (not in the map
or leaf). With Shift/MB1 you kan select several objects. With Drag MB1 you can also select
several objects.

From an ergonomic point of view, it is often better to navigat from the keyboard. You mainly
use the arrow keys. First you have to set input focus to the window, by clicking on it. Input
focus between the left and right window is shifted with TAB.

With ArrowUp/ArrowDown you select an object. If the object has children, you open the children
whigh ArrowRight, and close with ArrowLeft. The content of the object, i.e the attributes, are
displayed with Shift/ArrowRight and closed with ArrowLeft.

An attribute that is an array, enum, mask or attribute object, is opened by ArrowRight and
closed by ArrowLeft.

When you feel at home in the object tree, you can set yourself as 'advanced user'. Additional
function is the placed in the arrow keys. ArrowRight on an object, displayes for example the
attributes of the object, if it has no children. If it has children, you have to use 
Shift/ArrowRight as before.

<h1>Editing
When editing a volume, you create new objects, copy objects, remove objects and change values
of attributes.

<h2>Create an object
You create an object by selecting the class of the object in the palette. The palette is
divided in the folders Plant, Node and AllClasses. Under Plant you find the most common classes
in the plant hierarchy, under node the most common in the node hierarchy. If the class is not
found here, all the classes are available under AllClasses. Here, all the class volumes are
listed, and under each volume, the classes of the volume. After that, you click with the 
middle mousebutton on the future sibling or parent to the new object. If you click on the
map/leaf in the destination object, the new object is placed as the first child, if you click
to the right of the map/leaf, it is placed as a sibling.

You can also create an object from the popup menu. Select a class i the palette and open the
popup menu by Click MB3 on the destination object. Activate 'Create Object' and choose where
to put the new object, relatively the destination, before, after or as first or last child.

<b>The Configurator in edit mode
<image> dg_fig25.gif

<h2>Delete an object
An object is deleted from the popup menu. Click MB3 on the object and activate 'Delete Object'.

<h2>Move an object
You can also move an object from the popup menu, but it is often easier to use the middle
mouse button: select the object that is to be moved and click with the middle button on the
destination object. If you click on the map/leaf on the destination object, the object is
placed as first child, else as a sibling.

Node! Avoid using Cut/Paste to move an object. This will create a copy of the object with
a new object identity, and references to the object might be lost. You can use the command
paste/keepoid to keep the identity.

<h2>Copy an object
You kan copy an object with copy/paste or from the popup menu.

- copy/paste. Select the object or objects that are to be copiedm and activate 'Edit/Copy'
  (Ctrl/C) in the menu. The selected object are now copied to a paste buffer. Select a
  destination object, and activate 'Edit/Paste' (Ctrl/V). The objects in the paste buffer are
  now placed as siblings to the destination objects. If you instead activate 'Edit/Paste Into'
  (Shift+Ctrl/V) the new objects are placed as children to the destination object. If the
  copied objects have children, the children are also copied by copy/paste.

- from the popup menu. Select the object or objects that are to be copied, open the popup
  menu from the destination object, and activate 'Copy selected object(s)'. You now have to
  choose where the new objects are to be placed, relative to the destination object, as first
  or last child, or as next or previous sibling. If the copied objects have acsendants, and
  they also are to be copied, you activate 'Copy selected Tree(s)' instead.

<h2>Change object name
The name of an object is changed by selecting the object, and activating 'Edit/Rename' 
(Ctrl/N) in the menu. An input field is opened in the lower region of the configurator, where
the new name is entered. An object name kan have max 31 characters.

You can also change the name by displaying the object attributes. In edit mode, the object
name is displayed above the attributes, and is changed in the same way as an attribute.

<h2>Change an attribute value
Select the attribute to be changed, and activate 'Functions/Change value' (Ctrl/Q) in the menu.
Enter the new value in the input field. If you want to terminate the input, you activate
'Change value' again.

Not all attribute are editable. It depends on the function of the attribuet, if it is to be
assigned a value in the development environment or not. Editable attributes are marked with
an arrow.

You can also change the value of an attribute from the object editor, opened from the popup
menu (Open Object). An attribute of type multiline text, can only be edited from the object
editor.

As 'advanced user' you can open the input field with 'ArrowRight', as a faster alternative to
'Change value'.

<h1>Symbol file

The symbolfile is a command-file that is executed att wtt startup.
It can contain definitions of symbols and other wtt commands.
Here is some examples of useful commands.

Shortcut to somewhere in the database hierarchy:

<c>define rb9 "show children /name=hql-rb9" <LINK> define

</topic>


<topic>objecteditor_refman
Object Editor

The quantity of data for an object is devided in attributes. The Object Editor displayes the
attributes of an object and value of each attribute. If you are in edit mode, you can also
change the values of the attributes.

The attributes are displayed in the same way as in the configurator, the main difference is
that they are displayed in a separate window.

<h2>Navigate
Navigation and assignment of values is also done in the same way as in the configurator.<link> configurator, wnav_navigate

<h2>Start
The Object Editor is opened from the Configurator or the Plc editor. Activate 'OpenObject' in 
the popup menu for an object, or select the object and activate 'Functions/Open Object' in the
menu. From the Plc editor you can also start the object editor by doubleclickning on the 
object. If the Configuration/Plc editor is in edit mode, the Object Editor is also opened in
edit mode.

<h2>Menu

File/Close <t><t>close the object editor.

Functions/Change value  <t><t>open the input field for the selected attribute.
                        <t><t>This is only allowed in edit mode.
Functions/Close change value <t><t>Close the input field.

<b>Object Editor
<image> dg_fig30.gif

The Object Editor has an input field to enter multiline texts. In this case you can not
terminate the input with 'Enter', as for singleline texts. You either click on the 'Ok' button
or activate 'Functions/Close change value' (Ctrl/T) to terminate.

<b>A Multiline text
<image> dg_fig31.gif

The Object Editor for plc objects has functions to state which inputs or outputs are to be
displayed in the function block. You can also choose if digital inputs is to be inverted.
This i choosen with checkboxes for each attribute respectively ('Used' and 'Inverted'). The
checkbox for 'Used' can also be changed from the keyboard with 'Shift/ArrowRight', and the
checkbox for 'Inverted' can be changed with 'Shift/ArrowLeft'.

<b>Plc object with checkboxes
<image> dg_fig32.gif
</topic>

<topic>spreadsheeteditor_refman
The Spreadsheet Editor

The Speadsheet editor is used to view or configure, several objects of the same class
simultaneously. Objects for a certain class, below a specified object in the object tree, are
displayed in a table in the editor. In the table. also the values of an attribute in the
objects are displayed, and you can easily shift between different attributes.

The Spreadsheet Editor is opened from the configurator: 'Functions/Spreadsheet' in the menu.
If the configrator is in edit mode, also the Spreadsheet Editor i opened in edit mode.

When the spreadsheet editor is started, you first have to state which object are to be 
displayed, i.e. which class they belong to and under which hierarchy the are placed. This
is done by activating 'File/Select Class' in the menu. Enter class, hierarchy and state if
attribute objects, i.e. objects that reside as attributes in other objects, is to be displayed.

<b>Choose class and hierarchy
<image>dg_fig33.gif

After that you choose which attribut is to be displayed. Select at attribut in the attribute
list and click on 'Ok', or doubleclick on an attribute.

<b>Choose attribute
<image>dg_fig34.gif

The result is shown in the figure below. Here, the attribute 'Description' was choosen. You
can easily view the other attributes in the object by activating 'File/Next Attribute'
(Ctrl/N) and 'File/Previous Attribute' in the menu.

<b>Spreadsheet Editor
<image>dg_fig35.gif

<h2>Meny
File/Select Class     <t><t>State class and hierarchy for the objects that are to be displayed.
File/Select Attribute <t><t>State which attribute is to be displayed.
File/Next Attribute   <t><t>Display the next attribute for the object in the table.
File/Previous Attribut <t><t>Display the previous attribute for the objects in the table.
File/Print            <t><t>Print the table.
File/Close            <t><t>Close the Spreadsheet Editor.

Functions/Change value <t><t>Open an input field for the sekected object.
Functions/Close change value <t><t>Close the input field.

</topic>
</chapter>

<chapter>
<topic> helpwindow_refman
Help window

The helpwindow is used to view and navigate in help texts. The help texts can be various
manuals and guides that comes with Proview, or helptexts witten by the constructor to
describe the plant and to give assistance to the operators.
</topic>
</chapter>

<chapter>
<topic> messagewindow_refman
Message window

The message window displayes messages from Proview that are transmitted at various
operations. The messaged can have five levels of severity, that are marked with different
colors: 

S <t>Success  <t>green
I <t>Information <t>green
W <t>Warning  <t>yellow
E <t>Error    <t>red
F <t>Fatal    <t>red

If  an arrow is displayed in front of the message, the message contains a link to an object.
By clicking the arrow, the object is displayed.
</topic>
</chapter>

<chapter>
<topic> utilities_refman
Utilities

The utilities window is a graphic interface to different commands in wtt.
For more information about the commands, se chapter Commands.
</topic>
</chapter>

<chapter>
<topic> plceditor_refman
Plc Editor

In The Plc Editor you create plcprograms in a graphical programming language.

Programming with function block is made in a horizontal net of nodes and connections from left 
to right in the document. Signals or attributes are fetched on the left side of the net, and 
the values are transferred via connections from output pins to input pins of functions blocks. 
The function blocks operate on the values, and on the left side of the net, the values are 
stored in signals or attributes.
	
Grafcet sequences consist of a vertical net of nodes and connections. A state is transferred 
between the steps in the sequence via the connections. Grafcet and function block nets can 
interact with each other and be combined to one net.

<h2>Start
The Plc editor is opened from the configurator. Select an object of class PlcPgm and activate
'Functions/Open Program' (Ctrl/L) in the menu, or activate 'Open Program' in the popupmenu
for the PlcPgm object. The configurator shoude not be in edit mode.

<h2>Working mode
The Plc editor can be in four different modes: View, Edit, Trace and Simulate. The mode
is selected  under 'Mode' i the menu.

<b>View
In View you can look at the program, but not create or modify objects. The menu alternatives
for edit functions are dimmed.

<b>Edit
If you have edit privileges you can enter the edit mode. Now it is possible to create and
modify objects.

<b>Trace och Simulate
If you want to trace the program you enter the trace mode. This requires that the Proview
runtime environment is started in the development station. Simulate works as trace, but
you can also set values to signals.

Trace is nowdays easier and faster performed from Xtt. We recommend that you use PlcTrace in
Xtt instead.

<h1>Editering
The Plc editor consist of

- a working area.
- tow palettes, one for function objects and one for connections (only one palette at a time
  is visible).
- a navigation window, from which the working area can be scrolled and zoomed.

<b>The Plc editor
<image>dg_fig40.gif

<h2>The Palettes
<b>The Object Palette
When you start the Plc editor, the funktion object palette is displayed. When creating a
funktion block in the work area, you choose a class in the palette.

<b>The Connection Palette
When you create connectinos between objects, the editor chooses a suitible type of connection.
Though, in some cases the constructor has to influence the choise of connection type. This
is done in the connections palette that is displayed by activating 'View/Palette/Connection'
in the menu. When the palette is closed, by activating 'View/Palette/Object' or 
'View/Palette/Plant', the editorn is again responsible for choise of connection type.

<b>Plant Hierarchy
You can view the plant hierachy by activating 'View/Palette/Plant' in the menu. When
connecting function objects to signals, for example when fetching signal values, it is possible
to indicate which signal is to be fetched. You can also select the signal in the configurator,
which in many cases is a smoother alternative.

<h2>Navigation window
Down to the left there is a view of the program in reduced scale. The part of the working
area that is displayed in the main window, is marked with a rectangle. By moving the rectangle
(Drag MB1) you scroll the main window. You can also zoom with Drag MB2.

<h1>Function objects
<h2>Create object
To create objects the editor has to be in edit mode. Enter edit mode from 'Mode/Edit' in the
menu.

To create an object, you select a class in the palette, and click with MB2 (the middle button)
in the working area.

<h2>Modify an object
An object is created with certain default values. This applies also to which inputs and ouputs
are viewed in the plc editor and can be connected to other objects. If a value is to be changed
the object editor is opened for the object. The object editor is opened in following ways:

- doubleclick on the object
- activate 'Open Object' in the popup menu for the object.
- select the object and activate 'Functions/Open object' in the menu.


From the object editor you can change the values of various attributes. The attribute for a
plc object is separated in input attributes, internal attributes and output attributes.

<b>Inputs
The value of an input attribute is fetched from another function block, via a connection.
The attribute is displayed in the function block as an input pin. In some cases the input is
not used, an and-gate has for example 8 inputs but often only two of the are used. This is
controlled by the 'Used' checkbox in the object editor. If 'Used' is marked, the attributes is
displayed with an input pin, else it is hidden.

Some input attributes, especially of analog type, can be assigned a value in the object editor.
If 'Used' isn't marked for the attribute, the assigned value is used. However, if 'Used' is 
marked the value is fetched from the output the attribute is connected to. This is for 
example the function for the limit values 'Min' and 'Max' in a Limit object. You can choose
whether to fetch the value from another function block, or to assign a value. The assignment
works in runtime as an initial value, that later can be modified in various ways.

Some digital inputs can be inverted. To do this you mark the checkbox 'Inverted' in the object
editor. In the function block this is displayed with a circle on the input pin.

<b>Internal attributes
Internal attributes can contain configuration values that are assigned in the development
environment, or values that are calculated in runtime. The latter type is not changeable, and
maybe not even visible in the development environment.

<b>Outputs
The value of an output attributes is transfered to an input via a connection. As for an input,
you can choose whether to display an output pin or not with the 'Used' checkbox in the
object editor.

<h2>Select an object
Objects are selected in the following ways

- click with MB1 on the object.
- Shift/Click MB1 adds the  object to the list of selected objects, or removes it if the
  object already is selected.
- by Drag MB1 you can select one or several objects. Objects that has some part within the
  marked rectangle are selected.
- by pressing the Shift key and Drag MB1 you add the objects in the marked rectanglel to the
  selectlist.

Selected objects are drawn with red color.

<h2>Move objects
A single object is moved by placing the cursor on it and drat with MB1.
Several objects are moved by selecting them and dragging one ofhte objects with MB1.

<h1>Connections
<h2>Create connections
An output pin and an input pin is connected in the following way

- place the cursor on the pin, or in an area in the function object close to the pin, and
  push MB2 (the middle button).
- drag the cursor to the other pin. or to an area in the function object close to the pin,
  and release MB2.

A connections is now created between the objects.

Two inputs is connected in the same way, but som of the connected inputs has to be connected
to an output, and from this output the value is fetched to all the connected inputs.

<b>Data types
The values that is transfered between different objects via the connections can be digital,
analog, integer or string values. Inputs and outputs that are connected has to be of the same
type. If they are of different type you have to use an object that converts between the types,
e.g AtoI or ItoA. These conversion object are found under 'Signals/Conversion' in the palette.

Analog and integer connections are marked with slightly thicker lines, and digital connections
with thinner lines.

Furthermore there is a connectiontype for transfer of an object reference. These are drawn with
a thick, dashed line.

<b>Reference connections
If the editor has difficulties to find a path for the connection between the input and output
pin, because there are too many objects in the way, or because the reside in separate 
documents, the connections is drawn as a reference connection. Reference connections can also
be drawn by activating 'View/Reference connection' in the menu.

<b>Referens connection
<image> dg_fig39.gif

<bookmark>feedback_connection
<b>Execute order

Besides transfering a signal value, the connections also determine the execute order between
different function blocks. If two objects are connected trough an output and an input, 
normally the output-object is to be executed before the input-object. But sometimes a feedback
is needed in the net, and then you face a execute order loop. To determine the execute order
you have to specify the feedback with a connections of type ConFeedbackDigital or 
ConFeedbackAnalog. These are selected in the connection palette, viewed by activating 
'View/Palette/Connection' in the menu. Under the folder 'ConPlc' you can find the feedback
connections. They are drawn with dashed lines.

<b>Feedback connection
<image> dg_fig37.gif

Here you can also find the connection type 'ConExecuteOrder'. In som cases you want to control
the execute order between to function blocks, though they are not connected to each other.
Then you can draw a ConExecuteOrder between them (between which input or outpu doesn't 
matter). The connections is to be drawn from the object that is to execute first, to the object
that is to execute last. In the figure below, the storage of the attribute 'Temperaturer' is 
done before the storage of the attribute 'Tjocklek'.

<b>Execute order connection
<image> dg_fig38.gif

<h1>Fetch and store signal values
<h2>Fetch signal and attribute values
In the left side of the net of function blocks, values of signals and attributes are fetched.
The fetching is performed by objects as GetDi, GetDo, GetDv, GetIi etc. Fetching of attribute 
values is performed by GetDp, GetIp, GetAp and GetSp. These object you find under the folder
'Signals' in the palette. When an object of this type is created, you has to state which
signal, or which attribut that is to be fetched. The easiest way to do this, is to select the
signal/attribute in the configurator, and click with Ctrl/Doubleclick MB1 on the object.
The signal/attribute is then displayed in the function block, and if the signal is an input
signal, the channel of the signal is also displayed.

There is a faster way to create these objects. If you draw a connection from an input pin in
a function object, and release it in an empty space in the working area, a generic Get object
is created with the datatype of the input, i.e. a GetDgeneric, a GetIgeneric, a GetAgeneric
or a GetSgeneric. When you specify the signal or attribut the Get object is to fetch, the 
generic Get object is converted to a Get object of the the correct type for the signal or
attrbute. If you choose a Dv in the configurator, a GetDgeneric will be converted to a GetDv
when clicking with Ctrl/Doubleclick MB1 on it.

<h2>Store signal and attribute values
In the right side of the net calculated values are stord in signals and attributes. The 
storage is performed by objects as StoDo, StoDv, StoDp, StoIo etc. The method to specify the
signal or attribute to connect is the same as for Get objects, i.e. by selecting the 
signal/attribute in the configurator and click with Ctrl/Doubleclick MB1 on the object.

If you draw a connections from an output pin in a function block, a generic Sto object is 
created, that is converted to a Sto object of suitable type when connected to a signal or
attribute. If you want to store values with Set or Reset (for example SetDo or ResDo), you
can't use this method. You have to create the objects from the palette.

<b>Generic Get and Sto objects
<image> dg_fig36.gif

<h1>Subwindows
Some objects contains subwindow, e.g. CSub, SubStep, Trans, Order. An object with a subwindow
is marked with a thick gray line somewhere in the function block. A subwindow is opened in
different ways:
- by selecting the object and activate 'Function/Subwindow' in the menu.
- by activating 'Subwindow' in the popup menu for the object.
- by clicking on the object with Shift/Doubleclick MB1.

You create a new subwindow in the following way (the fact that only one editing session can
be open at a time, makes it a bit complicated)

- create the object that is going to contain the subwindow.
- save.
- open the subwindow.
- leave edit mode in the main window.
- enter edit mode in the subwindow.

<h1>Control the execute order
You normally don't have to consider the execute order of different function blocks in a
window. As signals are I/O copied, i.e. every timebase in the plc program, makes a copy of
all signal values before the execution that is not changed throughout the execution, the
storing and fetching of signal values will not be affected by the execute order between
individual storing or fetching objects. 

However, if you store and fetch the value of an attribute, that is not I/O copied, the
execute order can be of importance for the function.

The exectute order is determined by the connections between the function blocks. The common
connections are both signal tranferring and executeorder determining. If you make a feedback
you then have to choose a connectiontype that is signal transferring, but not executeorder
determining. The different feedback connections are of this type. Furthermore there is a 
connections that is executeorder determining but node signal transferring, ConExecuteOrder.
With this you can control the execute order between different function blocks without
tranferring any signals values.

The execute order for the function blocks in a plc window is displayed with
'View/Show execute order' in the menu. The number displayed for each function block states
tho order in which they are executed. The objects without a number doesn't have any
executable code.

The execute order between different PlcPgm is controled by the attriute ExecuteOrder in the
PlcPgm object. Exectute order determines the order within a thread. Lower values of 
ExecuteOrder are exectued before higher.

<h1>Compile
Before a plc window can be executed, is has to be compiled. At the same time, a syntax control
of the plc code is performed. If the syntax in not correct, a message is displayed in the
message window. The error message can be of type Error or Warning. Error is a more severe error
that has to be attended to. By clicking on the arrow in front of the message in the message
window, the erroneous object is displayed in the plc editor.

After the syntax check, c-code is generated and sent to the c compiler. If there is an object
with user defined c-code, e.g CArithm or DataArithm, the c compiler can find errors that
is written in the terminal window. Always look in the terminal window to check that the
compilation succeeded.

The compile is executed from 'File/Build' in the menu.

If you want to check the syntax witout generating any code, you activate 'File/Syntax'. The
c compiler is not activated, thus possible c code errors are not detected.

<h1>Cut and Paste
The plc editor contains a paste buffer. The paste buffer is common for all windows, which
makes it possible to copy between separate windows. With the functions 'Edit/Copy' and 
'Edit/Cut' in the menu, the selected objects are copied to the paste buffer (Cut also removes
them from the working area). The function 'Edit/Paste' copies the paste buffer to the working
area. The copied objects are now moved with the cursor, and you place them on the correct
position by clicking MB1 to lock them.

Cut, Copy and Paste can also be activate from the keyboard with Ctrl/X, Ctrl/C and Ctrl/V.

<h1>Special Plc objects
Here a number of objects that has special functions in the plc program are described.

<b>Document
The document object is used to divide the code in pages, when printing the code. When you
open a new window, it contains a document object. From the object editor you can change the
dimension of the document, and enter signature and page number. Other information in the 
document header is filled in automatically. The document object is found under the folder
'Edit' in the object palette.

<b>ShowPlcAttr
ShowPlcAttr can be used as an extension of the document header. In the object is displayed
information about volume, scantime and reset object for Grafcet sequences.

<b>Head, Title, Text och BodyText
These objects are used to write informational text in the document. Head, Title and Text
contains singleline texts of different size with max 79 characters. Bodytext contains a
multiline text with max 1023 characters. The objects is found under 'Edit' in the palette.

<b>Point
The point object is a free connection point that is used to branch a connection or to control
the layout of a connection. Point is found under 'Edit' in the menu.

<b>GRAFCET
Grafcet sequences are built with specific Grafcet objects as InitStep, Step, Trans and Order.
The connections between the objects follow specific rules. The vertical pins in a Step object
is for example connected to Trans objects, and the horizontal pin i connected to an order
object. Here is an example of how to create a Grafcet sequence.

Start by creating an InitStop object. Draw a connection from the lower pin, and release it
in the working area below the InitStep object. Now a Trans object is created, that is 
connected to the InitStep object. Draw a connection from the lower pin of the Trans object
and release it in the working space below the Trans object. A Step object is now created there.
If you draw a connection from the Step objects lower pin, another Trans object is created.
If you want a branch of the sequence, you draw an additional connection from the lower pin of
the Step object. Now a step divergens is created with specific StepDiv connections. If you in
the same manner creates a branch from a Trans object, by drawing to two connections from the
lower pin, a parellell branch, with TransDiv connections marked with double lines is created.
If you draw a connection from the horizontal pin of a Step an Order object is created, and
so on. As you can see this is a fast way to build complex sequences.

<b>ScanTime
ScanTime feches the actual scantime, i.e. the time since the last lap.

<b>FirstScan
FirstScan i true the first lap of the plc execution after Proview startup. It is also true
after a soft restart.

<h1>Menu

File/Save <t><t>Save
File/Print/Documents <t><t>Print all documents.
File/Print/Overview  <t><t>Print an overview.
File/Print/Selected documents <t><t>Print selected documents.
File/Syntax  <t><t>Perform a syntax check of the code.
File/Build <t><t>Compile the program.
File/Plc Attributes <t><t>Open the Object editor for the PlcPgm object.
File/Delete Window  <t><t>Delete the plc window.
File/Save Trace <t><t>Save trace objects.
File/Restore Trace<t><t>Restore previously saved traceobjects.
File/Close <t><t>Close the window.

Edit/Undo Delete <t><t>Undo the last delete action.
Edit/Undo Select <t><t>Reset the select list.
Edit/Cut <t><t>Cut selected objects.
Edit/Copy <t><t>Copy selected object to the paste buffer.
Edit/Paste <t><t>Copy the paste buffer to the work area.
Edit/Connect <t><t>Connect selected object to the selected signal or attribute
             <t><t>in the configurator.
Edit/Delete <t><t>Delete selected objects.
Edit/Change Text <t><t>Change text in the selected text object.
Edit/Expand Object <t><t>Expand the selected object.
Edit/Compress Object <t><t>Compress the selected object.

Search/Object <t><t>Search for an object name.
Search/String <t><t>Search for a string.
Search/Next <t><t>Search further with the same string.

View/Palette/Object <t><t>Display the functions object palette.
View/Palette/Connection <t><t>Display the connection palette.
View/Palette/Plant <t><t>Display the plant hierarchy.
View/Reference connections <t><t>Create connections as reference connections.
View/Grid Size <t><t>Set grid size.
View/Show Grid <t><t>Show the grid.
View/Zoom/In <t><t>Zoom in.
View/Zoom/Out <t><t>Zomm out.
View/Zoom/Reset <t><t>Reset to original zoom factor.
View/Show Execute Order <t><t>Show execute order for the functions objects.
View/Redraw <t><t>Redraw connections and redraw the window.

Functions/Open Object <t><t>Open the object editor for the selected object.
Functions/Subwindow <t><t>Open the subwindow for the selected object.

Mode/View <t><t>View mode.
Mode/Edit <t><t>Edit mode.
Mode/Trace <t><t>Trace mode.
Mode/Simulate <t><t>Simulate mode.

<h1>Mouse functions
<h2>Working area
Click MB1 <t><t>Select an object. Click in an empty space will reset the select list.
Shift/Click MB1 <t><t>Add object to the select list.
DoubleClick MB1 <t><t>Open object editor.
Shift+Ctrl/DoubleClick MB1 <t><t>Copy to paset buffer. Click in an object
                <t><t>copies the object, click in empty space copies selected objects.
Drag MB1 <t><t>On an object: move object or move selected objects.
         <t><t>In empty space: select objects inside the marked rectangle.
Shift/Drag MB1 <t><t>Add objects inside the marked rectangle to the select list.

Click MB2 <t><t>Create object.
DoubleClick MB2 <t><t>Delete. Click in object deletes the object, Click
          <t><t>in empty space deletes all the selected objects.
Shift+Ctrl/Click MB2 <t><t>Paste. Copy the paste buffer to the working area.
Shift+Ctrl/DoubleClick MB2 <t><t>Cut. Click in an object deletes the object, click
          <t><t>in an empty space deletes selected objects. Deletet object are put
          <t><t>in the paste buffer.

Press MB3 <t><t>Popup menu.

<h2>Navigation window
Drag MB1 <t><t>Scroll working area.
Drag MB2 <t><t>Zoom working area.
</topic>
</chapter>

<chapter>
<TOPIC> helpfile
Helpfile

Helptexts are displayed in the help window that can be opened from the configurator and the
operator environment. Helptext are written in a file $pwrp_exe/xtt_help.dat. The help texts
are divided in topics, and each topic has a key, that is specified when the help text for
the topic is to be displayed. Links in the helptext, that points to other topics, makes it 
possible to navigate in the helptexts.

The topic 'index' is the root topic that is displayed from different utilities

- 'Help/Project' in the configurator menu.
- 'Help/Project' in the runtime navigator.
- The 'Help' button in the operator window.

Specific help topics can be opened from Ge graphs by buttons (actiontype Help), or from the 
popup menu for an object in the operator environment (method 'Help').

<option> printdisable
<b>Syntax <link> helpfile syntax
<b>Conversion <link> helpfile conversion
<option> printenable
</topic>

</headerlevel>
<topic> helpfile conversion
Conversion
The helptext can be converted to html, PDF and PostScript format. When converted to html, each
topic is converted to one html page. When converted to PDF and PoscScript, there are a number
of additional tags available, to create a document of the helptext with with chapters and 
headers.

The conversion is done by 'co_convert'.

<h2>Conversion to html
A helpfile is converted to html with the command

<c>co_convert -f [-d outputdirectory] 'helpfile'

<b>Example
<c>co_convert -f -d $pwrp_web $pwrp_exe/xtt_help.dat

<h2>Conversion to postscript
A helpfile is converted to PostScript with the command

<c>co_convert -n [-d outputdirectory] 'helpfile'

<b>Example
<c>co_convert -n -d $pwrp_lis $pwrp_exe/xtt_help.dat

<h2>Conversion to PDF
A helpfile is converted to PDF with the command

<c>co_convert -f [-d outputdirectory] 'helpfile'

<b>Example
<c>co_convert -f -d $pwrp_lis $pwrp_exe/xtt_help.dat
</topic>

<topic> helpfile syntax
Syntax
There are a number of different tags that influence the search
and the conversion of the helpfile.

topic     <t>Defines the helptext for a topic<link> topic
bookmark  <t>Defines a position inside a topic<link> bookmark
link      <t>Link to a topic or an URL<link> link
index     <t>List of topics<link> helpindex
h1        <t>Header 1 <link> header1
h2        <t>Header 2 <link> header2
b         <t>Bold text <link> bold
t         <t>Tab <link> helptab
hr        <t>Horizontal line<link> hr
include   <t>Include other helpfiles<link> include

<h2>PDF and PostScript tags
The following tags are used to format the helptexts when converted to PDF and PostScript

chapter   <t>Divide topics in chapters<link> chapter
headerlevel <t>Increase or decrease header level <link> headerlevel
pagebreak <t>New page<link> pagebreak
option    <t>Options<link> option
style     <t>Specific text style <link> style

<b>Example <link> helpfile example
</topic>

<headerlevel>
<topic> topic
Topic
<ib><topic>
<i><topic> begin a topic and should be placed in the first position
<i>of a line. The topic-tag should be followed by the key that
<i>the help function will search for. All the following lines untill
<i> a </topic> tag will be displayed as text for the topic.

<i><topic> 'key'


<ib></topic>
<i>End a topic. </topic> should be placed in the first position 
<i>of a line.

<b>Example
<i><topic> start engine
The engine will be started by...
<i></topic>

The command

<c>wtt> help start engine

will display the text of this topic.
</topic>

<topic> bookmark
Bookmark
<ib><bookmark>
Bookmark is a line inside a topic which can be found by a link-tag or the /bookmark qualifier
in the help command. The bookmark tag should be placed at the end of the line and should be 
followed by a name.

<i>'some text' <bookmark> 'name'

<b>Example
<i>This is a bookmark. <bookmark> first_engine

The command

<c>wtt> help start engine/bookmark=first_engine

will display the text of the topic and scroll to the bookmark.
</topic>

<topic> link
Link
<ib><link>
<i>The <link> tag is a link to another help topic. The <link> tag should be placed at the 
end of the line. When the line of the link is activated the topic of the link will be 
displayed. The link tag should be followed by the topic, and can also be followed by a 
bookmark and the helpfile where the topic reside, separated with comma. If a line contains 
a link, is will be marked with an arrow.

<i>'some text'   <link> 'topic'[,'bookmark'][,'helpfile']

<b>Example
<i>Link to first engine <link> show engine, first_engine
</topic>

<topic> helpindex
Index
<ib><index>
<i>The <index> tag is a special link that will display an index of
<i>the helpfile, that is a list of all the topics in alpabetical order.

<i>'some text' <index>
</topic>

<topic> header1
Header1
<ib><h1>
<i>The <h1> tag will display a line as a header with larger text size. 
<i>The tag should be placed at the beginning of the line. A header line 
<i>can't contain any links.

<i><h1>'header text'

<b>Example
<i><h1>This is a h1 header
will be displayed as
<h1>This is a h1 header
</topic>

<topic> header2
Header2
<ib><h2>
<i>The <h2> tag will display a line as a header with bold text surrounded
<i>by grey lines. The tag should be placed at the beginning of the line. 
<i>A header line can't contain any links.

<b>Example
<i><h2>This is a h2 header
will be displayed as
<h2>This is a h2 header
</topic>

<topic> bold
Bold
<ib><b>
<i>The <b> tag will display a line with bold text.
<i>The tag should be placed at the beginning of the line. 

<b>Example
<i><b>This is a bold line
will be displayed as
<b>This is a bold line
</topic>

<topic> helptab
Tab
<ib><t>
<i>The <t> tag makes i possible to write columns. Only three columns
<i>(two <t> tags) is allowed.

<b>Example
<i>Col1 <t> Col2 <t> Col3
will be displayed as
Col1 <t> Col2 <t> Col3
</topic>

<topic> hr
Horizontal line
<ib><hr>
<i>The <hr> tag will display a horizontal line.
<i>The tag should be placed at the beginning of the line. 

<b>Example
<i><hr>
will be displayed as
<hr>

</topic>

<topic> include
Include
<ib><include>
<i>Includes another helpfile. The <include> tag should not be placed
<i>inside a topic.

<i><include> 'filname'
</topic>

<topic> chapter
Chapter
<ib><chapter>
<i>This tag divides the topics in chapters. A chapter beginns with <chapter> and ends with
<i></chapter>. The title of the first topic in the chapter will be the header of the chapter.

<ib></chapter>
Ends a chapter.

<b>Example
<i><chapter>
<i><topic>
<i>Introduction
<i>...
<i></topic>
<i></chapter>
</topic>

<topic> headerlevel
Headerlevel
Divides the topics in a chapter in header levels. 

<ib><headerlevel>
Increases the header level

<ib></headerlevel>
Descreases the headerlevel
</topic>

<topic> pagebreak
Pagebreak
<ib><pagebreak>
Forces a pagebreak.
</topic>

<topic> option
Option
<ib><option>
Option can have the values

printdisable <t>Ignore the tags and text untill the next 'printenable' in PDF 
             <t>and PostScript files. Normally used for links that has no effect
             <t>in PDF and PostScript.
printenable  <t>Reset the 'printdisable'.

<b>Example
<i><option> disable
<i>Some text
<i>...
<i><option> enable
</topic>

<topic> style
Style
<ib><style>
Specifies that a topic should be written in e specific style.
<b>Styles
function	<t>Style used for functions and commands. Large title and pagebreak after 
                <t>each topic.

<b>Example
<i><topic> MyFunction <style> function
...
<i></topic>
</topic>

<topic> helpfile example
Helpfile example
<i><topic> helpfile_example
<i>Start and stop of engines.

<i>Engine 1 <link> helpfile_example, bm_engine_1
<i>Engine 2 <link> helpfile_example, bm_engine_2
<i>Characteristics <link> helpfile_example, bm_char

<i><h1>Engine 1 <bookmark> bm_engine_1
<i>Start engine one by pressing the start button.
<i>Stop engine one by pressing the stop button.

<i><h1>Engine 2 <bookmark> bm_engine_2
<i>Start engine two by pressing the start button.
<i>Stop engine two by pressing the stop button.

<i><h2>Characteristics <bookmark> bm_char

<i><b><t>Engine1 <t>Engine2
<i>Max speed <t> 3200 <t> 5400
<i>Max current <t> 130 <t> 120
<i></topic>

This is the outlook of this example <link>helpfile_example
</TOPIC>

<headerlevel>
<topic> helpfile_example
Start and stop of engines.

Engine 1 <link> helpfile_example, bm_engine_1
Engine 2 <link> helpfile_example, bm_engine_2
Characteristics <link> helpfile_example, bm_char

<h1>Engine 1 <bookmark> bm_engine_1
Start engine one by pressing the start button.
Stop engine one by pressing the stop button.

<h1>Engine 2 <bookmark> bm_engine_2
Start engine two by pressing the start button.
Stop engine two by pressing the stop button.

<h2>Characteristics <bookmark> bm_char

<b><t>Engine1 <t>Engine2
Max speed <t> 3200 <t> 5400
Max current <t> 130 <t> 120
</topic>
</headerlevel>
</headerlevel>
</headerlevel>
</chapter>
<chapter>
<topic>users
Users

This chapter describes how to create at user in proview, and how to grant privileges and 
access for the user.

The increasing availability of Proview system for different type of users, for example via the
itranet, has resulted in increasing demands of possibilities to limit the possibility for
various users to influence the system. Proview contains a user database, where you define
the users for different systems, and where you have the possibility to group systems with
common users. The database is designed to face the demands of increasing access control, and
att the same time keep the administration on an low level.

<option> printdisable
User database <link> userdatabase
Example <link> user example
Login <link> user login
pwr_user <link> pwr_user
<option> printenable
</topic>

<headerlevel>
<topic>userdatabase
User database

The user database is populated by system groups and users. When a proview utility is started,
for example the opeator or development environment, there is a check that the user exist in
the database, and the privileges of the user are registred. The privileges determine what
a user is allowed to do in the system.

<h1>Systemgroup
The concept system group is introduced to not have to define every system in the database.
Instead you define system groups, and connect number of systems to each system group. These
system will share users.

The database is built of an hierarchy of system groups. The hierarchy has to functions, to
describe the connection between different system groups, and to introduce heritage between
system groups. The systemgroups lower in the hierarchy, can inherit attributes and users from
systemgroups higher in the hierarchy.

If a systemgroup will inherit users or not, is determined by the attribut UserInherit. If
the attribute is set, the systemgroup will inherit all users from its parent usergroup.
Also the users the parent has inherited from its parent, are inherited. A systemgroup can
override an inherited user by defining the username in its own systemgroup.

A systemgroup is refered to by the 'path'-name in the hierarchy, where the names are separated
by points, e.g. 'ssab.hql.se1', where ssab is the root group, and se1 the lowest level in the
hierarchy.

A Proview system is connected to a system group by stating the systemgroup in the System 
objekt. If the systemgroup is not present in the user database, though a parent or ancestor
is, it is supposed that the systemgroup inherits users from the ancestor.

<h2>Attributes
<b>Attribute <t>Description
UserInherit <t>The system group inherits users fro its parent systemgroup, also users
            <t>that the parent has inherited.

<h1>Users
A user is characterized by a username, a password and a set of privileges. A user is also
connected to a system group.

The privileges defines what a user is allowed to do in proview. Some privileges influences
the access to make changes from proview utilities, e.g. the navigator or plc-editor, some
regards the construction of operators graphics, to control which input fields and pushbuttons
a user can influence.

A username can be connected to several system groups, but from the databse point of view,
they are different users, with unic passwords and privileges. They just happen to have the
same username.

<h2>Privileges
<b>Privilege <t>Description
RtRead    <t>Read access to rtdb. Default privileges for user that is not logged in.
RtWrite   <t>Write access to rtdb. Allows user to modify rtdb from xtt and Simulate mode
          <t>in trace.
System    <t>Privilege for system manager.
Maintenance <t>Privilege for maintenance technician.
Process   <t>Privilege for process technician.
Instrument <t>Privilege for instrument technician.
Operator1 <t>Privilege for operator.
Operator2 <t>Privilege for operator.
Operator3 <t>Privilege for operator.
Operator4 <t>Privilege for operator.
Operator5 <t>Privilege for operator.
Operator6 <t>Privilege for operator.
Operator7 <t>Privilege for operator.
Operator8 <t>Privilege for operator.
Operator9 <t>Privilege for operator.
Operator10 <t>Privilege for operator.
DevRead   <t>Read access to the workbench.
DevPlc    <t>Write access in the plc editor.
DevConfig <t>Write access in the configurator.
DevClass  <t>Write access in class editor (not yet implemented)
</topic>

<topic> user example
Exempel
Proview user database V1.0.0

<c>ssab
<c>. . . . . . sysansv    System DevRead DevPlc DevConfig (14680068)
<c>. . . . . . skiftel    Maintenance DevRead (2097160)
<c>. . . . . . 55         Operator1 (64)
<c>. hql                  UserInherit
<c>. . . . . . anna       RtWrite Operator4 (514)
<c>. . bl2
<c>. . . . . . anna       Operator4 (512)
<c>. . bl1                UserInherit
<c>. . . . . . 55         Operator1 (64)
<c>. . . . . . carlgustav Operator8 (8192)
<c>. hst
<c>. . . . . . magnus     Operator1 (64)
<c>. . rlb                UserInherit     
<c>. . . . . . amanda     Operator4 (512)

Look at the example above. This is a listing of an user database. To the left, you see the
system groups, and the number of ponts marks their level in the hierarchy. In the same row
the attribute of the system group is written. Under each systemgroup, its users with
privileges is found. Thus the systemgroup ssab has the users sysansv, skiftel and 55.

The systemgroup sasb.hql.bl1 has the attribut UserInherit, which results in that it inherits
users from its parent. Also the parent ssab.hql has UserInherit, i.e. ssab.hql.bl1 also
inherits from ssab. The users of ssab.hql.bl1 is then, sysansv, skiftel, anna 55 and 
carlgustav. Here the user 55 of sasb.hql.bl1 overrides the user 55 of ssab.

The systemgroup ssab.hql.bl2 lacks UserInherit and has only the user anna.

The systemgroup ssab.hst.rlb has UserInherit and inherits from its parent ssab.hst. Though,
this has not UserInherit and has not inherited from its parent ssab. The users for 
ssab.hst.rlb is then amanda and magnus.

A system with the systemgroup sandviken.hql will be denied access because the systemgroup and
all its ancestors is missing.

A system with the systemgroup ssab.vwx.n2 will inherit users from the systemgroup ssab,
i.e. sysansv, skifel and 55. All systemgroups don't have to be present in the database, the
existance of an ancestor is enough. The ones that are not found are supposed to have the
attribute UserInherit.
</topic>

<topic> user login
Login

This sections desribes how Login and access control works in different proview environments.

<h1>Development environment
When starting the configurator, a login window is opened where you kan state username and
password. You can also give the username and password as arguments to the workbench if you
want to avoid the login procedure. To open the configurator, you need the privilege DevRead,
and to enter edit mode, you ned DevWrite. To edit in the plc editor, you ned DevPlc.

<h1>Operator environment
When the operator environment is started with an OpPlace as argument, the user is fetched from
the UserName attribute in the corresponding User object. To make modifications in the 
databas from the runtime navigator, the privilege RtWrite is required. In the process graphics
there are pushbuttons, sliders etc. from which you influence the database. These objects have
an access attribute, that determines which privileges are required to activate the object.
These privileges are matched to the users privileges, and if he isn't granted any of them,
he is denied access.

From the runtime navigator, you can with the login/logut command, login as another user and
thereby change your privileges.

<h1>Process graphics on the intranet
For process graphics on the web there is a special login frame that can be added to the
start menu of a system page. The login frame checks the username and password. 
</topic>

<topic> pwr_user
pwr_user

You use pwr_user to create systemgroups and users in the user database.
The configuration is performed with commands.

pwr_user is started from the command prompt.

Below is a description of the different command available to create, modify and list
systemgroups and users.

add group <t>Add a system group <link> pwr_user add group
add user  <t>Add a user <link> pwr_user add user
get       <t>Get a user<link> pwr_user get
list      <t>List systemgroups and users <link> pwr_user list
load      <t>Load the latest saved database <link> pwr_user load
modify group <t>Modify a system group <link> pwr_user modify group
modify user  <t>Modify a user <link> pwr_user modify user
remove group <t>Remove a system group <link> pwr_user remove group
remove user  <t>Remove a user <link> pwr_user remove user
save      <t>Save <link> pwr_user save
su        <t>Login as super user <link> pwr_user su
</topic>

<headerlevel>
<topic>pwr_user add
add

add group <link> pwr_user add group
add user <link> pwr_user add user
</topic>

<headerlevel>
<topic> pwr_user add group
add group

Create a systemgroup

<c>pwr_user> add group 'name' [/nouserinherit]

/nouserinherit <t>The attribute UserInherit is not set for the systemgroup.
        <t>As default UserInherit is set.
</topic>
<topic> pwr_user add user
add user
Create a user.

pwr_user> add user 'name' /group= /password= [/privilege=]
	[/rtread][/rtwrite][/system][/maintenance][/process]
[/instrument][/operator1][/operator2]...[oper10][/devread]
[/devplc][/devconfig][/devclass]

/group <t>Systemgroup of the user.
/password <t>Password of the user.
/privilege <t>Privileges if this is supplied as a mask, i.e an integer value.
/rtread <t>The user is granted RtRead.
/rtwrite <t>The user is granted RtWrite.
/system <t>The user is granted System.
/maintenance <t>The user is granted Maintenance.
/process <t>The user is granted Process.
/operator1 <t>The user is granted Operator1.
...
/operator9 <t>The user is granted Operator9.
/operator10 <t>The user is granted Operator10.
/devread <t>The user is granted DevRead.
/devplc <t>The user is granted DevPlc.
/devconfig <t>The user is granted DevConfig.
/devclass <t>The user is granted DevClass.
</topic>
</headerlevel>

<topic> pwr_user get
get

Fetches a user with an algorithm used in runtime.

pwr_user> get 'username' /group= /password=
</topic>

<topic> pwr_user list
list

List systemgroups and users.

pwr_user> list
</topic>

<topic> pwr_user load
load

Load the latest saved database and revert the current session.
</topic>
<topic> pwr_user modify
modify

modify group <link> pwr_user modify group
modify user <link> pwr_user modify user
</topic>

<headerlevel>
<topic> pwr_user modify group
modify group

Modify a systemgroup.

<c>pwr_user> modify group 'name' /[no]userinherit

/userinherit <t>Sets the attribute UserInherit that states that the systemgroup
             <t>inherits users form its parent in the systemgroup hierarchy.
             <t>Negated with /nouserinherit
</topic>

<topic> pwr_user modify user
modify user

Modify a user.

<c>pwr_user> modify user 'name' /group= [/password=][/privilege=]
<c>	[/rtread][/rtwrite][/system][/maintenance][/process]
<c>     [/instrument][/operator1][/operator2]...[oper10][/devread]
<c>     [/devplc][/devconfig][/devclass]

/group <t>Systemgroup of the user.
/password <t>Password of the user.
/privilege <t>Privileges if this is supplied as a mask, i.e an integer value.
/rtread <t>The user is granted RtRead.
/rtwrite <t>The user is granted RtWrite.
/system <t>The user is granted System.
/maintenance <t>The user is granted Maintenance.
/process <t>The user is granted Process.
/operator1 <t>The user is granted Operator1.
...
/operator9 <t>The user is granted Operator9.
/operator10 <t>The user is granted Operator10.
/devread <t>The user is granted DevRead.
/devplc <t>The user is granted DevPlc.
/devconfig <t>The user is granted DevConfig.
/devclass <t>The user is granted DevClass.
</topic>
</headerlevel>

<topic> pwr_user remove
remove

remove group <link> pwr_user remove group
remove user <link> pwr_user remove user
</topic>

<headerlevel>
<topic> pwr_user remove group
remove group
Remove a system group.

<c>pwr_user> remove group 'name'
</topic>

<topic> pwr_user remove user
remove user

Remove a user.

<c>pwr_user> remove user 'name' /group=
</topic>
</headerlevel>

<topic> pwr_user save
save
Save the current session.

<c>pwr_user> save
</topic>

<topic> pwr_user su
su

Login as super user. As super user you can se password for users when listing the database.
su requires password.

<c>pwr_user> su 'password' 
</topic>
</headerlevel>
</headerlevel>
</chapter>

<chapter>
<topic> classeditor
Class Editor

This section describes how to create new classes in Proview.
There are a number of different cases when you might consider creating a new class.

<h2>Data objects
You want to store data in a data structure, for example to easy gain access to the data from
applications. You can also create data objects that describes material that passes through
a plant, where the data object contains properites for one material, e.g. length, width etc.
The material can be moved between NMps cells to indicate the position of a material in the
plant.

<h2>Plc function object
A function object used in plc programming, constists of a class that defines the input and
output pins of the function object, and possible internal attributes. This type of objects
also consists of code that are executed by the plc program. You can choose to create the code
as plc code or c code.

<h2>Components
A component object reflecs a component in the plant, and is often divided into two or three
different classes, a main object, a function object and a bus object, possibly also a 
simulate object. The main object is placed in the plant hierarchy and contains the signals 
that are connected to the component, in addition to other configuration data. A function 
object, placed in a plc program, is connected to the main object and works partly with data
from its own inputs and outputs, and partly with signals and other parameters in the main
object. If the signal exchange is made via Profibus, you kan also create a special module
object that contains channel objects for the data transported on the Profibus. It is 
sufficient to make one connection between the main and the module object, to connect all
signals and channels in the component. The simulation object is a function object, that is
connected to the main object, and that simulates the component when the system is run i
simulation mode.

<h2>Subclasses of components
Proview contatins a number of basecomponent classes for valves, motors etc. These are designed
in a general fashion to cover a large number of components. Often, you create a subclass that
is adapted to a specific component, and that, for example, contains a link to a data sheet, 
helptext etc. for this component. By creating a subclass of a basecomponent you inherit all
the methods and attributes from this, but you also has the possibility to increase the
functionallity with more attributes and more plc-code.

<h2>Aggregates
An aggregate reflects a plant part the contains a number of components. In this case, you can
create an aggregate class that contains the different components in shape of attribute 
objects. To the aggregate, there is also a function object, that calls the functions objects
for the present components. Aggregates can also contain other aggregates and give rise to
quite extensive object structures. In principle, you could build a plant i one single object,
but in practice it is appropriate to keep the object structure on a fairly low level. It is
mainly when you have several identical aggregates that you benefit by creating an aggregate
object of a plant part.

<option> printdisable
<b>Database structure <link> ced_databasestructure
<b>Class description <link> ced_classdescription
<b>Type description <link> ced_typedescription
<b>Create classes <link> ced_createclasses
<b>Build classvolume <link> ced_build
<b>Documentation of classes<link> class docblock
<option> printenable


</topic>

<headerlevel>
<topic>ced_databasestructure
Database structure
<h1>Object
In the chapter Database structure a descripton of how objects are construced. Now there is
reason to go a little futher in the subject.

An object constist of an object head and an object body. The object head contains information
about the object name, class and relation to other objects. The object body contatins the data
of the object.

<h2>Object header
An object has a name with a maximum size of 31 characters that is stored in the object header.

In the object header there is also a link to the class description of the object. The class
description contains information of how to interpret the data of the object, how it is divided
into different attributes, and the type of the attributes. You also find the methods that work
on the object.

An object is placed in a tree structure and the object head contains pointer to the closest
relatives: father, backward sibling, forward sibling and first child.

The structure of an object head are common for all types of objects.

<h2>Object body
An object can have two bodies, one body that contains the data that is needed in runtime. 
It can also contain one additional body with data that only exist in the development 
environment.

A body is divided into attributes that contains data of a specific type, e.g a Boolean, a
Float32 or an Int32. But an attribute can also have a more complex datatype, as an array or
a class.

<b>RtBody
RtBody is the body that exist in the runtime database. The body is also present in the
development environment, to make it possible to set values to different attributes in the 
body.

<b>DevBody
Some objects also have a DevBody, a body that exist only in the development database, and that
is not loaded into the runtime database. This body is mainly used by plc objects, where 
devbody for example contains graphical data for the plc editor.

</topic>

<topic>ced_classdescription
Class description

The layout of an object body is described in the class description of the object. Here you
also find methods and other properties of the class. The class desciption is built of
specific class definition objects that reside in a class volume. The class volume has a strict
syntax of how to build the class descriptions. A presentation of the the different objects
that is a part of the class description follows here.

<h2>Class volume
Class descriptions reside in a specific type of volume, a class volume. These can contain
two hierarchies, one hierachy with class descriptions, and one with type descriptions.

<h2>$ClassHier
The class descriptions are found under the root object 'Class' of type $ClassHier. Below
the $ClassHier object, $ClassDef objects define the classes in the volume.

<h2>$ClassDef
A $ClassDef object with its descendants, describe a class. The name of the object gives the 
name of the class. Below the $ClassDef, the following objects can be located

- an $ObjBodyDef object, 'RtBody', that describes the runtime body.
- an $ObjBodyDef object, 'DevBody', that describes the body in the development environment.
- a Template object, i.e. an object of the current class that contatains default values for 
  instance objects of the class.
- one or several body objects that contains data for a specific function.
- a PlcTemplate object, that can be opened by the plc editor, and that contains plc code for
  the class.
- menu objects that define the popupmenu in the navigator, configurator and xtt.
- method objects that links to methods that are called for example when objects are created 
  or moved in the development environment.

<h2>$ObjBodyDef
An $ObjBodyDef object can either have the name 'RtBody', and then describe the runtime body,
or the name 'DevBody' and describe thte development body. The attribute 'StructName' contains
the name of the c-struct of the class in the include file that is generated for the volume.
Below the $ObjBodyDef object, one attribute object for each attribute in the object body is
located. $Attribute object are used for data objects, and $Input, $Intern and $Output for plc 
functionobjects.


<h2>$Attribute
An $Attribute object describes an attribute in a body. The attribute can be of the following
type:

- a base type, e.g. Boolean, Float32, Time, Int16.
- a derived type, e.g. String80, Text1024, URL.
- an array of a base type or derived type.
- another class.
- an array of a class.
- an rtdb pointer, i.e. a pointer that can be interpreted by all processes.
- a private pointer, i.e. a pointer that is valid on one single process.

The type is stated in the attribute 'TypeRef'. In the attribute 'Flags' you state if the
object describes an array, pointer, class etc. If the object describes an array, the number
of elements is stated in 'Elements'.

<h2>$Input
$Input describes an input pin in a functions object in the plc program. The input can be of 
type Boolean, Float32, Int32, String80, Time, DeltaTime or of datatype (pointer to Float32).
$Input gives rise to an attribute with two elements, one element of the stated type, and one
element with apointer to the stated type. If the input is connected, the pointer points to the
connected output attribute, if the pointer is not connected it points to its first element,
where you then can specify a value for the input.

The attribute 'PgmName' states the name of the attribute in the c-struct, and 'GraphName' the
textstring that is written in the function object at the input pin.

<h2>$Intern
Defines an intern attribute in a function object, i.e. an attribute that is neither an input
nor an output.

<h2>$Output
$Output describes an output pin in a function object. The same datatypes is valid for an
$Output as for an $Input.

<h2>$Buffer
$Buffer specifies an attribut that contatins data of a certain size that only a single function
is able to interpret. The data is described by a class, but ar not viewable in for example 
xtt. PlcNode, that is found in all plc objects, is an example of a $Buffer. Here you find
graphic information that is only of interest for the plc editor.

<h2>Class body
A class can contain a class body object. The class body object contains data that is common
for all instances of the class. One example of a class body object is $GraphPlcNode that
reside in all plc classes. $GraphPlcNode contains data for code generation and graphic layout
of the function object.

<h1>Menues
Menu object are used to define popupmenues for objects in the development environment and in
the operator environment. $Menu defines a popupmenu in the development environment and 
$RtMenu i the operator environment. Below the menu object, menu alternatives are defined by
$MenuButton objects, and submenues with $MenuCascade objects. The menu objects are placed
below the $ClassDef object.

The menu object calls methods, i.e. c functions that are linked with the development or
operator environment. There is for the moment no possibility to do this from a project. This
has to be done from the Proview source code.

<h2>$Menu
$Menu objects describe popup menues in the development environment. The object name specifies
the function, the first part states the tool (Navigator/Configurator). The five last letters
states during witch conditions the menu is present, dependent on which objects are selected 
or pointed at.

<c>char 1: P stands for pointed, i.e. the object at which the pointer points.
<c>char 2: states what should be pointed at: 'o' an object, 'a' an attibute, 
<c>        'c' a class in the palette.
<c>char 3: 's' stands for selected, i.e. the object that is selected.
<c>char 4: states what the selected object should be: 'o' an object, 
<c>        'a' an attribute, 'c' a class in the palette.
<c>char 5: states if selected and pointed should be the same object: 
<c>        's' same object, 'n' different objects.

Example ConfiguratorPosos: 'Po' the poitner points at an object, 'so' one object is selected,
's' the object the pointer points at and the selected object is the same object.

<h2>$RtMenu
The menu objects that describes popup menues in the operator environment.

<h2>$MenuButton
Deifines a menu alternative in a popup menu.

</topic>

<topic>ced_typedescription
Type description

Type descriptions, as class descriptions, reside in a class volume. They are placed in a
separate hierarchy under a $TypeHier object. Types are devided into two categories, base types
and derived types.

<h2>Base types
Base types are defined in the system volume pwrs. Example of base types are Boolean, Float32,
Int32, String, Enum and Mask.

<h2>Derived types
Derived type can be defined in any classvolume. They consist of 
- arrays of base types, e.g. String80.
- enumeration types, Enum, with defined characterstrings for various values.
- bitmasks, Mask, with defined strings for various bits.

<b>$TypeHier
Type description are placed under the root object 'Type' of class $TypeHier. The $TypeHier
object has $Type and $TypeDef objects as children.

<b>$Type
Description of a base type. This object is reserved for the system volume pwrs.

<b>$TypeDef
Description of a derived type. The attribute 'TypeRef' contaitns the base type. The most
common usage are strings and texts with specific size, and enumeration types and bitmasks.

To define an enumeration type, the basetype should be $Enum. Below the $TypeDef object, texts
for different values are defined with $Value objects. When the value of an attribute of the
type is to be displayed, the text that corresponds to the value is displayed. When the
attribute is given a value, the different texts are viewed with checkboxes and you select
one alternative.

To define bitmasks the basetype $Mask is used. Below the $TypeDef object, texts are defined
for different bits by $Bit objects. When the attribute is given a value, the texts are 
displayed with checkboxes, as for enumeration types. For bitmasks, several alternatives can
be choosen.

<b>$Value
Defines a value in an enumeration type. The value corresponds to a text, that is viewd in
the configuration and in xtt when the attribute is opened. I the includefile for the volume,
an enum declaration is created, that can be used in c-code.

<b>$Bit
Defines a bit in a bitmask. The bit corresponds to a text that is viewed in the configurator
and i xtt when an attribute of the type is opened. In the includefile for the volume, an
enum declaration is created that can be used in c-code.

</topic>

<topic>ced_createclasses
Create classes

<option> printdisable
<b>Create a class volume <link> ced_createclassvolume
<b>Data classes <link> ced_dataclasses
<b>Function objects <link>ced_foclasses
<b>Components <link>ced_components
<option> printenable
</topic>

<headerlevel>
<topic>ced_createclassvolume
Create a class volume

The classdefinition objects reside in a classvolume, and first the classvolume has to be 
registred and created.

The registration is made in the global volume list which is opened from 
File/Open/GlobalVolumeList in the navigator menu. Here you create a VolumeReg object with
suitable volume name and volume identity. The volume identity for user classvolumes should
be in the intervall 0.0.2-249.1-254. Use preferably the prefix CVol in the name to indicate
that it is a class volume. Also state the current project.

<image>ced_fig11.gif
<b>Registration of the class volume in GlobalVolumeList

Next step is to configure the classvolume in the directory volume of the project, with a
ClassVolumeConfig object. Open the Directory volume with 

<c>$ pwrs

and create a ClassVolumeConfig object in the left window. The object should have the same
name as the classvolume. After saving and leaving edit mode, the classvolume can be opened
by rightclicking on the ClassVolumeConfig object and activating 'Open ClassEditor...'.

<image>ced_fig10.gif
<b>Configuration of th classvolume in the Directory volume

Now the Class Editor is opened, where you can create classdefinition objects. By entering
edit mode, a palette is viewed, with the class and type description classes that are used to
define a class or type.

Begin by creating an object of type $ClassHier on the top level. This will automatically get
the name 'Class'. Below the $ClassHier objects, $ClassDef objects are created for each class
that is to be defined.
</topic>

<topic>ced_dataclasses
Data classes

Data classes are the most elementary classes, and usually used to store data. The classes
constists of a RtBody with attributes.

To create a class you put a $ClassDef object below the 'Class' object.
The name of the object states the class name.

Under the $ClassDef object you create a $ObjBodyDef object that automatically gets the name
RtBody. 

Under the RtBody object, an $Attribute object is created, that defines an attribute in the
class. The name of the $Attribute object states the attribute name. In the object you should
state this in the attribute object:

- the attribute type is stated in TypeRef, e.g a 32-bit integer is stated with 
  pwrs:Type-$Int32, a 32-bit float with pwrs:Type-$Float32 and a boolean with 
  pwrs:Type-$Boolean. Actually it is the full name of a type definition object that is
  inserted. See the Object Reference Manual, pwrs/Types, which types are defined.
- if the attribute name contains national characters, in PgmName you have to state a name 
without national characters, that is accepted by the c compiler.

<image> ced_fig1.gif
<b>Definition of an attribute

When you save, an instance object of the current class with the name Template, is created under 
the $ClassDef object. Here you can se the layout of the class, and also set template values for 
attributes. When other instances of the class are created, they are created as a copy of the
Template object.

<image> ced_fig2.gif
<b>Template object with default values

<b>Arrays
An array attribute is defined with an $Attribute object, as other attributes. Here you set
the Array bit in Flags, and state the number of elements in the array in Elements.

<image> ced_fig3.gif
<b>Definition of an array attribute with 50 elements



<b>Attribute objects
The term attribute objects refers to attributes that are described by a data structure. The
reason to do this, can be that you want to gather data under on map, or that the datastructure
is repeated, and in this case you create an attribute object array.

The datas structure of the attribute is defined in a separate class. The class should only
contain a runtime body, and can not have a development body.

The attribute object is defined by an $Attribute object. In TypeRef the class describing the 
datastructure is stated, and in Flags the Class bit is set.

You can also create an array, by setting the Array bit in Flags, and state the number of
elements in Elements.

Attribute objects can also contain attributes that are attribute objects. The number of levels
are limitied to 20, and the total attribute name is limited to 255 characters.

An attribute in an attribute objects is referred to with point as delimiter, i.e. the 
attribute Description in the attribute object Pump in object o, is referred to with the name
'o.Pump.Description'. If Pump also is an array of pumpobjects, the name of the Description
attribute in the first pump object is 'o.Pump[0].Description'.

<image> ced_fig4.gif
<b>Definition of an attribute object of class Table



<b>Subclass

You can also define a class as a subclass to another class. The subclass will inherit
attributes and methods from the other class, which is called the super class.

A subclass is defined by naming the first $Attribute object in the class to 'Super',
and setting the Class and SuperClass bits in Flags. The superclass is stated in TypeRef.

All the attributes that exist in the superclass will also be present in the subclass. The
subclass can also have additional attributes that are defined as usual by $Attribute objects.
 
A superclass can only contain a runtime body, not a development body.

<image> ced_fig5.gif
<b>The Super attributes makes MyDataClass a subclass of MySuperDataClass

</topic>

<topic>ced_foclasses
Function object classes

Function objects are used in the plc editor to program the plc program. A function object is
also described by a class, usually a bit more complex than a data class. It defines, in
addition to the data sturcture, the graphic layout with inputs and outputs, and the code that 
is to be generated for the plc program.

The code can be defined either by c-code, or by graphical programming in the plc editor.

<option> printdisable
<b>Function object with c code <link> ced_ccodefo
<b>Function object with plc code <link> ced_plccodefo
<option> printenable
</topic>

<headerlevel>
<topic>ced_ccodefo
Function object with c code

The function object class is defined by a $ClassDef object under the 'Class' object. Name
the object and activate 'Configure-CCodeFo' from the popupmenu of the object. Now are
created

- a RtBody object.
- a DevBody object with a PlcNode object that defines a buffer for grapic information in
  the instances.
- a GraphPlcNode object that contains information for graphic and code generation for the
  class.

Next step is to define the attributes of the class. The attributes are divided into inputs,
internal attributes and outputs.

<b>Inputs
The input attributes defines the input pins of the function object, i.e. values that are fetched
from output pins of other function objects. The inputs are defined by $Input objects that are
placed below the RtBody object.

In TypeRef the datatype of the input is stated. Valid datatypes for an input is 
pwrs:Type-Float32, pwrs:Type-Int32 and pwrs:Type-String80.

In GraphName the text at the input pin in the function object is stated. Normally you use
2 - 4 characters, block letters for analog signals, lower-case for digital, and first
character upper-case for other signal types.

An input attribute in an instance object, contains both a pointer to the output it is
connected to, and a value that can be stated. You choose whether to use the input pin and 
connect an output, or to set a value, with a checkbox (Used). If you chooses not to mark Used, 
the input pin is not displayed in the function object. In the Template object, you can set 
default values for the input, that will be used when the input is not connected.

<b>Intern attributes
Intern attributes are attributes that are not inputs or outputs. They can be used for
calculated values that need to be stored in the object, or values that are used to configure
the object.

All common datatypes are valid for intern attributes.

<b>Outputs
The output attributes define the output pins of the function object, i.e. values that are stored
in the object, and can be fetched by inputs of other function objects. The outputs are  defined 
by $Output objects that are placed below the RtBody object.

The datatype for the output is stated in TypeRef. As for $Input, Boolean, Float32, Int32 and
String80 can be stated, and in GraphName the text for the output pin in the function object is
stated.

<b>Note !
$Input, $Intern and $Output has to be placed in this order below RtBody: $Input first, then
$Intern and then $Output.

<b>Default values
Defaultvalues of attributes can be set in the Template object.

If you want to state which inputs and outputs should be viewed as default, there is a mask in 
the GraphPlcNode object that controls this, default_mask. Bits in default_mask[0] corresponds 
to input attributes, and bits in default_mask[1] to output attributes. If the bit that 
corresponds to a specific input or output is set, this will be viewed as default.


<image> ced_fig6.gif
<b>Function object with two inputs, one intern attribute, and one output

<image> ced_fig7.gif
<b>The function object for the class

<b>Code
When the classvolume is built, an h-file with a c struct for the class is generated. The name
of the struct is

<c>pwr_sClass_'StructName' 

where StructName is fetched from the StructName attribute in RtBody. As default, it is the 
same as the class name, but, for example if the classname contains national characters, 
another name can be specified.

Below an example of the struct for the class MyFo is viewed. MyFo contains two inputs In1 and
In2, one intern attribute Factor, and an output Out, all of type Float32.

<c>typedef struct {
<c>  pwr_tFloat32           *In1P;
<c>  pwr_tFloat32           In1;
<c>  pwr_tFloat32           *In2P;
<c>  pwr_tFloat32           In2;
<c>  pwr_tFloat32           Factor;
<c>  pwr_tFloat32           Out;
<c>} pwr_sClass_MyFo;

Note that each input consist of two elements, a poniter with the suffix 'P', and en element
that can be given a value if the input is not connected. If the input is connected, the 
pointer element will point to the output it is connected to, otherwise it will point to the
value element. Therefore, in the c-code, you should use the pointer element to fetch the 
value of the input.

The cod for the class is a function with this appearance

<c>void 'StructName'_exec( plc_sThread *tp,
<c>                        pwr_sClass_'StructName' *o) {
<c>}

In the code, data are fetched from the inputs, and calculated values are put on the outputs.
Also intern attributes can be used to store information to the next scan, or to fetch
configuration data.

In the code example below In1 and In2 are inputs, Factor is an intern attribute and Out an
output.

<c>  o->Out = o->Factor * (*o->In1P + *o->In2P);

Note that the pointer element for the inputs In1 and In2 are used in the code.

The module of the c-code is compiled and linked with the plc program. This requires a link
file to be placed on the directory $pwrp_exe. The file is named plc_'nodename'_'busnumber'.opt,
e.g. plc_mynode_0999.opt. The content of the file is input to the linker, ld, and here you
add the modules of the plc-code. In the example below these modules are placed in the archive
$pwrp_lib/libpwrp.a

<c>$pwr_obj/rt_io_user.o -lpwrp



</topic>

<topic>ced_plccodefo
Function object with plc code

A function object, where the code is written in plc-code in the plc editor, is defined in a 
similar way as the function object with c-code above.

The functionobject class is defined by a $ClassDef object below the 'Class' object. Name the
object and activate Configure-Fo in the popupmenu for the object. Now, in addition to the
objects created for the c-code functionobject, also a Code object of class PlcTemplate is
created. This object can be opened with the plc editor, and define the code for the class.

Inputs, intern attributes and outputs i the function object are defined in the same way as for
the c-code function object, by $Input, $Intern and $Output attributes.

<image> ced_fig8.gif
<b>Definition of a function object with plc code.

<b>Code
By activating 'Open Program...' in the popupmenu of the Code object, the plc editor is opened.
Here the code is written with function object programming. The code is created similar to an 
ordinary program, but here you also have to fetch values from the input and intern attribute,
and to set values to the outputs.

Values of inputs, intern attributes, and also outputs, are fetched in the code with GetDp,
GetIp, GetAp or GetSp objects. You connect the  objects to attributes in the class by 
selecting the attribute in the Template object for the class, and activate the 'Connect' 
method for the Get object. A symbolic reference $PlcFo is put into the Get object. This will
later be exechanged to a reference to the current instance, when the code for the instance is
compiled.

Calculated values are stored in outputs or intern attributes with StoDp, StoIp etc. These are
connected to attributes in the same way as the inputs, by selecting the attributes in the
Template object and activating 'Connect'.

<image> ced_fig9.gif
<b>Example of plc code for a function object

The template code in the Code object should not be compiled or built. When an instance object
is compiled for the first time, the template code is copied to the instance.

When the template code is changed, the code of the instances will be updated the next time
they are compiled (the volume containing the instances, has to be updated with UpdateClasses 
first).
</topic>
</headerlevel>

<topic>ced_ioclasses
I/O classes

I/O objects are the objects handled by the I/O-handling in Proview. They are divided in Agent,
Rack, Card and Channel objects. When adapting new I/O systems to Proview, you have to create
new classes of types Agent, Rack and Card. I/O objects are defined by a $ClassDef object 
where the IoAgent, IoRack or IoCard bit is set in Flags.

A more detailed description of how to create I/O objects is found in Guide to I/O System.

</topic>

<topic>ced_components
Components

A component is an object, or a number of objects, that handles a component i the plant. It
could be a valve, a motor, a frequency converter etc. The idea behind the component concept
is that by creating one object (or a number of objects) you get all the functionallity 
required to control the component: an object contaning data and signals, a function object
with code to control the component, an object graph for HMI, a simulation object, I/O objects
to configure bus communication etc.

A component can include the following parts
- a main object.
- a function object.
- a simulation object.
- one or more I/O bus objects.
- object graph for the main object.
- object graph for the simulation object.
- graphic symbol for the main object.

<option> printdisable
<b>Main object <link> ced_compmain
<b>Function object <link> ced_compfo
<b>Simulation object <link> ced_compsim
<b>I/O bus object <link> ced_compio
<b>Object graph <link> ced_compog
<b>Grapic symbol <link> ced_compgs
<option> printenable
</topic>

<headerlevel>
<topic> ced_compmain
Main object

The main object contains all data needed to configure and make calculations. The object is
placed in the plant hierarchy, as an individual object or as a part of an aggregate.

Often the class BaseComponent:Component is used as super class to a component class. It 
contains a number of attributes as Description, Specification, DataSheet etc.

All the input and output signals that is attached to the component should be placed in the
main object. Di, Ii, Ai, Do, Io, Ao or Co object are inserted as attribute objects. When
creating instances of the component, the signals has to be connected to channel objects. For
profibus, for example, you can create a module object, that contains the channels, and 
preconnect the signales in the main object to these channels. For each instance, you then
don't have to connect every channel individually, but can make on single connection between
main object and module object.

<b>Special attributes
<b>PlcConnect
If there are any code that is to be created by the plc program, you create a function object
for the class. This has to be connected to the main object, and this connection is stored in
an attribute with name 'PlcConnect' of type pwrs:Type-$AttrRef.

<b>SimConnect
If there is a simulation object, this is connected to the main object by a 'SimConnect' 
attribute of type pwrs:Type-AttrRef.

<b>IoConnect
If there is a I/O module object, this is connected with an 'IoConnect' attribute of type
pwrs:Type-AttrRef. The attribute is handled by the IoConnect method.

<b>IoStatus
If you want to fetch the status from the I/O-module object, you create the attribute 
'IoStatus' of type pwrs:Type-$Status, and set the Pointer bit in Flags.

The attribute will be assigned a pointer to the Status attribute of the I/O-module in runtime 
when the I/O handling is initialized. The Status attribute is of type Status and can for example
be displayed in an object graph with the dynamic type StatusColor. If you want to use IoStatus
in the plc code for the object, you have to consider that the attribute is a pointer and 
fetch the value with GetIpPtr.

<b>GraphConfiguration
GraphConfiguration is of type Enum and used to decide which object graph is to be opened
for the current instance. It is used by the 'ConfigureComponent' method (see below).

<b>DisableAttr
The DisableAttr function makes it possible to disable an attribute in an instance. If an
attribute is disabled, it will not be viewed in the navigator or object editor. If the 
disabled attribute is a signal, it will be ignored by the I/O handling.

The disable function is used for components that can exist in different configurations.
A solenoid valve for example, can have one switch indicating that the valve is open, and one
indicating that the valve is closed. Totally there are four configurations for the solenoid
valve:

- no switches.
- switch open.
- switch closed.
- both switch open and switch closed.

You could create four different solenoid valve classes, but a problems will come up when 
building aggregates of the valve objects. An aggregate, containing a valve objects also has
to exist in four variations, and if the aggregate contains two valve objects, there has to be
16 variations. By using the DisableAttr function on the switch attributes we can create a 
solenoid valve class that covers all four configurations, and also can be used in aggregate
classes.

DisableAttr for an attribute is configured in the following way.
- the DisableAttr bit in Flags is set for the attribute.
- before the attribute, an attribute of type pwrs:Type-$DisableAttr is placed, with the same
  name as the attribute, but with the prefix 'Disable'. The Invisible bit in Flags should be
  set for the DisableAttr attribute.

<b>Example
In the solenoid valve class above, the switch closed is represented by the attribute
SwitchClosed that is a digital signal of type pwrb:Class-Di. Immediately above the attribute
an attribute with name 'DisableSwitchClosed' of type pwrs:Type-$DisableAttr is placed. For 
this attribute the Invisible bit in Flags is set, and for the SwitchClosed attribute the
DisableAttr bit in Flags is set.

<image> ced_fig12.gif
<b>Attribute with disable function

<b>Cast
Component classes are often built in a relativly flexible way to minimize the number of 
variants. Often you create a baseclass that make use of the DisableAttr function to be able
to cover a number of different configurations. In the example above a solenoid valve class 
can cover four different configurations by setting DisableAttr on the switch signals. You also
create subclasses that are adapted to specific valves. For example, a Durholt 100.103 doesn't
contain any switches, and an subclass is created where both switches are disabled in the
Template object. You also set other adaptions in the Template object as a link to a datasheet.
The result is a subclass that can be used for Durholt valves without any configurations for
each instance.

If we now build a general aggregate, containing a solenoid valve, and want to be able to use
the subclasses that exist for the solenoid valve, we use the Cast function. With the Cast 
function, an attribute object can be casted as a subclass of the original class, given that
the subclass has the same size. When an attribute object is casted, defaultvalues, and thus
configurations, are fetched from the subclass. Also classname and methods are feched from the
subclass.

The cast function for an attribute is entered in the following way:
- The CastAttr bit in Flags is set for the attribute.
- Before the attribute, an attribute of type pwrs:Type-$CastId is placed with the same name
  as the attribute, but with the prefix 'Cast'. The Invisible bit in Flags should be set for 
  the cast attribute.

<image> ced_fig22.gif
<b>Contactor with cast attribute

Casting of an instance is executed by activating the 'Cast' method i the popupmenu for the
attribute. A list with the baseclass and all subclasses are displayed, where a suitable
cast class can be selected.

If an attribute has both cast and disable attributes, the cast attribute should be placed
before the disable attribute.

<image> ced_fig23.gif
<b>Casting of an instance


<b>Methods
<b>Method ConfigureComponent
Often there are several variants of a component. In the example with the solenoid valve above,
four different variants where found dependent on the configuration of switches. To simplify
the users configuration of the component, you can define the method 'ConfigureComponent'. 

The ConfigureComponent method makes it possible to from a menu alternative in the popupmenu,
set Disable to one or a number of attributes, and to select an object graph that is adapted
to the current configuration.

<b>Meny
The menu alternatives for ConfigureComponent are defined by menu objects. Under the $ClassDef
object, a $Menu object with name 'ConfiguratorPosos' is placed, which makes the menu visible
in edit mode when the object is pointed at and selected. Below this, yet another $Menu object
is placed with the name 'Pointed', and below this a $MenuCascade object with the name
'ConfigureComponent'. The attribute ButtonName is set to ConfigureComponent for this object.
Below this, finally one $MenuButton object is placed for each configuration alternative.
The name is preferably set to the name of the configuration alternative, and is also put into
the attribute ButtonName. In the attribute MethodName '$Object-ConfigureComponent' is inserted
and in the attribute FilterName '$Object-ConfigureComponentFilter'. You should also fill in
arguments to the method i MethodArguments. MethodArguments[0] contains a bitmask, that decide
which attributes will be disabled in the current menu alternative. Each attribute, that is
possible to disable is represented by a bit, and bit order corresponds to the attribute order
in the object. MethodArguments[1] contains the graphic represententation, see below.

If we look at the solenoid valve, we have two attributes that can be disabled, SwitchClosed
and SwitchOpen. In the bitmask in MethodArguments[0] SwitchClosed corresponds to the first
bit and SwitchOpen to the second, i.e. if the first bit is set, SwitchClosed will be disabled,
and if the second bit is set, SwitchOpen is disabled. The four configuration alternatives
TwoSwitches, SwitchClosed, SwitchOpen and NoSwitches corresponds to the following masks

<c>TwoSwitches   0   (both SwitchOpen and SwitchClosed are present)
<c>SwitchClosed  2   (SwitchOpen is disabled)
<c>SwitchOpen    1   (SwitchClosed is disabled)
<c>NoSwitches    3   (both SwitchOpen and SwitchClosed are disabled)

<image> ced_fig14.gif

<b>Configuration of component attributes
If you disable an attribute that is a component that contains signals, the signals in the 
component also has to be disabled. The I/O handling only looks at if the individual signal is
disabled, and is not looking upwards on higher levels. To disable a signal in a component
attribute, you add a comma and the name of the component followed by the disable mask that
is valid for the component to MethodArguments[0]. For example in an object where the 
components Contactor and CircuitBreaker are disabled MethodArguments[0] can contain

<c>3, Contactor 1, CircuitBreaker 1

where '3' is the Disable mask of the object (that disables the attributes Contactor and
CircuitBreaker), and 'Contactor 1' results in disabling a signal attribute in Contactor, and
'CircuitBreaker 1' disables a signal in CircuitBreaker.

<b>Component attributes with individual configuration

When the ConfigureComponent method is activated, Disable are removed from all component
attributes, to reset any previous configuration. Sometimes there are component attributes
that are not a part of the object configuration, but has to be configured individually. These
components should not be reset by the ConfigureComponent method, and have to stated in
MethodArguments[2] with comma as delimiter. In the following example, the component attributes
Motor and Contactor should be configured by their own ConfigureComponent methods, and not
affected by the ConfigureComponent method of the object. In MethodArguments[2] is stated

<c>Motor, Contactor


<b>Object graph
When drawing the object graph for the component, you have to consider the different 
configurations. If the differences between the configurations are small, you can use the
Invisible dynamic. If the differences are greater, it might be more convenient to draw
separate graphs for the configurations. Then you insert an attribute in the main object with
the name GraphConfiguration of type Enum. It is common to create a specific enumeration type
with the configuration alternatives. If GraphConfiguration is 0 the standard graph is used,
else the value in GraphConfiguration is set as suffix to the graphname.

In the example with the solenoid valve, MValve, we create an enum type, MValveGCEnum, and
define the values

<c>TwoSwitches  0
<c>SwitchClosed 1
<c>SwitchOpen   2
<c>NoSwitches   3

For the TwoSwitches configuration, with value 0, we draw an object graph with name mvalve.pwg.
For SwitchClosed, with value 1, we name the graph mvalve1.pwg, for SwichOpen mvalve2.pwg and
for NoSwitches mvalve3.pwg.

We also state the enumeration value in MethodArguments[1] in the $MenuButton object for the
current configuration. This will imply that GraphConfiguration will be set to this value
when the current menualternative is activated.

<image> ced_fig13.gif
<b>Enumeration type for GraphConfiguration


</topic>

<topic> ced_compfo
Functionobject

The functionobject is the interface of the component in the plc program. It defines inputs and 
outputs that can be connected to other functionobjects in the plc editor. Unlike an ordinary 
functionobject the code is also working with data in the main object.

The code can be written in plc-code or c-code.


<b>plc-code
If you want to keep the code of the function object visible, and there is need of running
PlcTrace in the code, it is suitable to use a functionobject with plc-code.

Create a $ClassDef object and name the object. Preferably use the same name as for the main
object followed by the suffix 'Fo', e.g. MyComponentFo. Then activate Configure-ConnecteFo in
the popupmenu.

Under RtBody a PlcConnect attribute of type AttrRef is created, that will contain a link to
the main object, when an instance i connected in the plc-editor.

Configure inputs and outputs with $Input and $Output objects below the RtBody object. You
can also create $Intern objects, but this type av data are usually stored in the main object.
Note that the order of attribute objects should be $Input, $Intern, $Output.

The code is created by opening the plc editor for the Code object. In the code, you fetch
values from an input, by selecting the input attribut in the template object for the 
functionobject in the navigator, and activate the connect function. Output are stored in a 
similar way. When data should be fetched or stored in the main object, you select the attribute
in the template object of the main object. References to the function object are viewed in the
plc-code with the symbol $PlcFo, and references to the main object with the symbol $PlcMain.

If the object contains components, the function object of these components are put in the
plc-code.

If you have DisableAttr on signals or other attributes, this has to handled with conditional
execution in the code. A signal that is disabled must not be read or written to in the code.
You use the object Disabled under the map Other, to evaluate if an attribute is disabled or not.
This can then be connected to a CArea object that handles the conditional execution.

<image> ced_fig18.gif
<b> Condition execution with Disabled and CArea

<b>c-code
A function object with c-code is configured with a $ClassDef object. Name the object and then
activate Configure-ConnectedCCodeFo in the popupmenu.

Below RtBody, two attribute are created, PlcConnect of type AttrRef and PlcConnectP that is a
pointer. In PlcConnect, the reference to the main object is stored, when an instance is 
connected in the plc editor. When the plc program is initialized in runtime, you fetch, with
help of the reference, a pointer to the main object. The pointer i stored in PlcConnectP. This
is done in the c code, that is separated in an init function that is executed at initialization
of the plc program, and an exec function that is executed every scan. For the function object
MyComponentFo with the input In1 and In2, and the output Out2, the code is

<c>void MyComponentFo_init( pwr_sClass_MyComponentFo  *o)
<c>{
<c>  pwr_tDlid dlid;
<c>  pwr_tStatus sts;

<c>  sts = gdh_DLRefObjectInfoAttrref( &o->PlcConnect, (void **)&o->PlcConnectP, &dlid);
<c>  if ( EVEN(sts)) 
<c>    o->PlcConnectP = 0;
<c>}

<c>void MyComponentFo_exec( plc_sThread      *tp,
<c>                         pwr_sClass_MyComponentFo *o)
<c>{
<c>  pwr_sClass_MyComponent *co = (pwr_sClass_MyComponent *) o->PlcConnectP;

<c>  if ( !co)
<c>    return;

<c>  o->Out = co->Value = co->Factor * (*o->In1P + *o->In2P);
<c>}

</topic>

<topic> ced_compsim
Simulation object

A simulation object is used to simulate the process, both at normal conditions and when 
different errors occurs. The simulation object reads the output signals (Do, Ao, Io) in the main
object, and set values to the input signals (Di, Ai, Ii, Co). The object is a functionobject
that can contain input and output attributes, but these are usually missing, and the object is
working with data in the main object, and with internal attributes that configures the 
simulation and triggers various error conditions. The simulation object often has an object 
graph that is opened by the Simulate method of the main object.

A simulation object is connected to the main object by a connect method, in the same way as an
ordinary function object. But the simulation class has another connect method than the Fo class.
The main object should contain the attribute 'SimConnect' of type pwrs:Type-$AttrRef, into
which the connection method will store the identity for the simulation object when a main
instance object and a simulation instance object are connected.

A simulation class is created in the same way as a functionobject class, and can be written in
c of plc-code. The class is preferably named the same name as the main class, followed by the
suffix 'Sim'.

Create a $ClassDef object and name the object. Then activate the Configure-ConnectedFo or
Configure-ConnectedCCodeFo. Add any $Input, $Intern and $Output attributes, and write the code
in plc or c-code. Change the connectmethod in GraphPlcNode to 26.

The object graph for simulation objects are often drawn with darkblue background and white text
to easily be parted from other object graphs. Note that attributes in the main object can be
referenced by the '&' notation, e.g. &($object.PlcConnect).IndError##Boolean.

<image> ced_fig15.gif
<b>Objekt graph for a simulation object

</topic>

<topic> ced_compio
I/O-module object

A main object for a component can contain signal objects of type Ai, Ai, Ii, Ao, Do, Io and
Co. The signals of an instance have to be connected to channel objects in the node hierarchy.
In, for example, Profibus you can create module objects, where the channels are adapted to the
dataarea that is received and sent on the bus. If the signals in a component, is handled by
a module object, you can store symbolic references to the channel objects in the signal
objects. Then you only have to do one IoConnection between the component and the module object, 
you don't have to connect each signal separateley. The symbolic references are stored in the 
template object of the template object of component, by connecting the signals in the template
object to the channels in the template object of the I/O module. The symbolic references are
of type $IoConnect, and are converted to real references at initialization of the I/O handling
in runtime.

<image> ced_fig16.gif
<b> A signal is connected to a channel in an I/O module.

<image> ced_fig17.gif
<b> Symbolic reference to channel object
</topic>

<topic>ced_compog
Object graph

Object graph har the same name as the component, but with lower case. For classes in the Proview
base system you add the prefix 'pwr_c_'. The graphs are edited as normal in Ge. In the dynamic
you exchange the object name with '$object'. Object graph for objects in the base system are
drawn with the following guidelines.

<b> Menu
There should be a menu with the pulldown menues File, Methods, Signals and Help.

File should have the entries

<c>Print   Command     print graph/class/inst=$object
<c>Close   CloseGraph

Methods should have the entries

<c>Help             Invisible   $cmd(check method/method="Help"/object=$object)
<c>                 Command     call method/method="Help"/object=$object
<c>Note             Invisible   $cmd(check method/method="Note"/object=$object)
<c>                 Command     call method/method="Note"/object=$object
<c>Trend            Invisible   $cmd(check method/method="Trend"/object=$object)
<c>                 Command     call method/method="Trend"/object=$object
<c>Fast             Invisible   $cmd(check method/method="Fast"/object=$object)
<c>                 Command     call method/method="Fast"/object=$object
<c>Help             Invisible   $cmd(check method/method="Photo"/object=$object)
<c>                 Command     call method/method="Photo"/object=$object
<c>DataSheet        Invisible   $cmd(check method/method="DataSheet"/object=$object)
<c>                 Command     call method/method="DataSheet"/object=$object
<c>Hist Event...    Invisible   $cmd(check method/method="Hist Event..."/object=$object)
<c>                 Command     call method/method="Hist Event..."/object=$object
<c>Block Events...  Invisible   $cmd(check method/method="Block Events..."/object=$object)
<c>                 Command     call method/method="Block Events..."/object=$object
<c>RtNavigator      Invisible   $cmd(check method/method="RtNavigator"/object=$object)
<c>                 Command     call method/method="RtNavigator"/object=$object
<c>Open Object      Invisible   $cmd(check method/method="Open Object"/object=$object)
<c>                 Command     call method/method="Open Object"/object=$object
<c>Open Plc         Invisible   $cmd(check method/method="Open Plc"/object=$object)
<c>                 Command     call method/method="Open Plc"/object=$object
<c>Circuit Diagram  Invisible   $cmd(check method/method="Circuit Diagram"/object=$object)
<c>                 Command     call method/method="Circuit Diagram"/object=$object
<c>HelpClass        Invisible   $cmd(check method/method="HelpClass"/object=$object)
<c>                 Command     call method/method="HelpClass"/object=$object

Signals should contain all signals in the component and open the object graph for each signal.

Example

<c>SwitchOpen Di    Command     open graph/class /inst=$object.SwitchOpen
<c>SwitchClosed Di  Command     open graph/class /inst=$object.SwitchClosed
<c>Order Do         Command     open graph/class /inst=$object.Order

The Help menu should contain Help and HelpClass

<c>Help             Command     call method/method="Help"/object=$object
<c>HelpClass        Command     call method/method="HelpClass"/object=$object

<b> Toolbar
The toolbar contains buttons for the methods. The dynamics are the same as in the methods menu
above. To the right, there is also a button for the object graph of the simulate object. This 
has the dynamic

<c>Invisible   $cmd(check method/method="Simulate"/object=$object)
<c>Command     call method/method="Simulate"/object=$object

Below the methodbuttons there are two textfields that displays the Desciption and Specification 
attributes in the component with the dynamic

<c>Description     Value.Attribute $object.Description##String80
<c>                Value.Format    %s
<c>Specification   Value.Attribute $object.Specification##String80
<c>                Value.Format    %s

On the lowest row in the graph, any Notes message are viewed, with a button to change or remove
the message.

<c>Notes button    Invisible       $object.Note##String80
<c>                Command         call method/method="Note"/object=$object
<c>Notes text      Value.Attribute $object.Note##String80
<c>                Value.Format    %s

<image> ced_fig21.gif
<b>Object graph

</topic>

<topic>ced_compgs
Graphic symbol

The graphic symbol is drawn in Ge and given the default dynamic HostObject. In the host object
dynamic, differenty types of dynamic are connected to attributes in the object. The objectname
is exchanged to '$hostobject' in the dynamics. Often you create the attributes IndWarning and
IndError in the main object, and color the symbol yellow or red, or flashing red, when these
are set.

<image> ced_fig20.gif
<b>The grahic symbol is drawn in Ge witch HostObject default dynamic.




</topic>

</headerlevel>
</headerlevel>

<topic> ced_build
Build the classvolume

When building the classvolume, a loadfile and two structfiles are created.

<b>Loadfile
The loadfile is stored in $pwrp_load and has the same name as the volume, with lower case.
The filetype is .dbs, e.g the loadfile for the volume CVolMerk1 is $pwrp_load/cvolmerk1.dbs.

The time when the loadfile is created is stored in the file. Furthermore the version of other
classvolumes that the loadfile is dependent on are stored. At runtime startup, there is a check
that the current versions in the system coincide with the versions registred in the loadfile.
If any version doesn't coincide, you get the message 'Version mismatch' and the startup is
aborted.

You can display the version of a loadfile, and the versions of the dependent volumes with
wb_ldlist.

<c>$ wb_ldlist $pwrp_load/cvolmerk1.dbs
<c>Volume     CVolMerk1       21-DEC-2007 13:52:05.22 (1198241525,227130443) 25364
<c>VolRef     CVolMerk1       21-DEC-2007 13:52:05.22 (1198241525,227130443) 25364
<c>VolRef     pwrs            12-DEC-2007 08:35:06.98 (1197444906,983976467) 1
<c>VolRef     pwrb            12-DEC-2007 08:35:09.93 (1197444909,930182284) 2
<c>VolRef     BaseComponent   12-DEC-2007 08:35:26.92 (1197444926,926679004) 10

<b>Structfiles
When building a classvolume, two includefiles are generated, a .h-file and a .hpp-file.

If the classvolume contains functions objects, or classes that are used in CArithm or
DataArithm objects, you have to include the .h file in $pwrp_inc/ra_plc_user.h.

<b>Update Classes
When the classvolume is built, you have to update the classes in the root or sub volumes in 
the project. The update is activated in the configurator for the root or sub volume, from the
menu with 'Function/Update Classes'. If a class is changed, instance objects  of the class are 
adapted to the changed class. All references to instances of the class will also be updated.

</topic>

<topic>class docblock
Documentation of classes

For $ClassDef and $Attribute objects, there is a documentation block, that is filled in from
the object editor. The documentations block, together with the class description, is used
when classdocumentation is generatated to xtthelp or html format.

The documentation block for the $ClassDef object should contain a description of the class, 
and the documentation block for the $Attribute object a description of the attribute.

<option> printdisable
Genererate Xtt helpfiles <link> class generate xtthelp
Genererate html documentation <link> class generate html
ClassDef <link> docblock classdef
Attribute <link> docblock attribute
c- and h-files <link> docblock ccode
<option> printenable
</topic>

<headerlevel>

<topic> class generate xtthelp
Generate Xtt helpfiles

Helpfiles for xtt is generated with the command

<c>co_convert -xv -d $pwrp_exe/ $pwrp_db/userclasses.wb_load

The command generates a helpfile $pwrp_exe/'volumename'_xtthelp.dat, and it is proper to put
a link to the file in the xtt helpfile for the project $pwrp_exe/xtt_help.dat:

Example for the classvolume cvolvhxn2r

<i><topic> index

<i>...

<i>User classes<link>cvolssabtest,"",$pwrp_exe/cvolvhxn2r_xtthelp.dat

<i></topic>

...

<i><include> $pwrp_exe/cvolssabtest_xtthelp.dat
</topic>

<topic> class generate html
Generate html documentation

html files are generated by the command

<c>co_convert -wv -d $pwrp_web/ $pwrp_db/userclasses.wb_load

The command genenrates, among others, the file $pwrp_web/'volumename'_index.html that contains
the start page for the class documentation. This, together with the other files
($pwrp_web/'volumename'_*.html) should be copied to a proper directory of the web server.

A link to the documentation is made with a WebLink object pointing at the URL
'volumename'_index.html.

If you wantn to be able to show the c struct for the classes, you convert the h-file with
co_convert

<c>co_convert -cv $pwrp_web/ $pwrp_inc/'volymsnamn'classes.h

If you also want to be able to display the code of plc-objects, you have to add aref tags
in the c or h file of the code, and convert it with

<c>co_convert -sv -d $pwrp_web/ 'filnamn'
</topic>

<topic> docblock classdef
ClassDef

<h2>Example

<c>@Author Homer Simpson
<c>@Version 1.0
<c>@Code ra_plc_user.c
<c>@Summary Brief description of this class
<c>Description of
<c>this class.
<c>
<c>See also 
<c>@link Example plat.html
<c>@classlink AnotherPlate cvolvhxn2r_anotherplate.html

<h2>Tags
Author  <t>Author or the class description <link> docblock author
Version <t>Version of the class <link> docblock version
Code    <t>File that contains the code for the class <link> docblock code
Summary <t>Summary <link> docblock summary
Link    <t>Arbitrary link <link> docblock link
Classlink <t>Link to another class <link> docblock classlink
wb_load syntax <link> docblock wb_load classdef
</topic>

<headerlevel>
<topic> docblock author
@Author

Author. Optional.

<b>Syntax
<c>@Author 'name of author'
</topic>

<topic> docblock version
@Version

Version. Optional.

<b>Syntax
<c>@Version 'version number'
</topic>

<topic> docblock code
@Code

For classes with plc-code you can state the name of the c-file. Optional.
Also the c-file has to be converted by the command: co_convert -c -d $pwrp_web/'filename'

<b>Syntax
<c>@Code 'filename'
</topic>

<topic> docblock summary
@Summary

Short description in one line. Optional.
This is shown in the indexfile in the xtt helpfile. Not used in html.

<b>Syntax
<c>@Summary 'text'
</topic>

<topic> docblock link
@Link

A link to an arbitrary URL. Is only displayed in the html documentation, not in Xtt.
The link should lay after the description of the class.

<b>Syntax
<c>@Link 'URL'
</topic>

<topic> docblock classlink
@Classlink

A link to another class. This link work in both html and xtt.
The link should lay after the description of the class.

<b>Syntax
<c>@Classlink 'html-filename'
</topic>

<topic> docblock wb_load classdef
wb_load syntax

The documentation of a class i written above the $ClassDef row.

<c>!
<c>!/**
<c>!  @Author Homer Simpson
<c>!  @Version 1.0
<c>!  @Code ra_plc_user.c
<c>!  @Summary Brief description of this class
<c>!  Description of
<c>!  this class.
<c>!
<c>!  See also 
<c>!  @link Example plat.html
<c>!  @classlink AnotherPlate cvolvhxn2r_anotherplate.html
<c>!*/
<c>!
<c>Object        Plat    $ClassDef 1

<h2>!/**
Start of a documentation block.
All the text between !/** and !*/ will be written as a description of the class.

<h2>!*/
End of a documentation block.
</topic>
</headerlevel>

<topic> docblock attribute
Attribute

<h2>Example
<c>@Summary Plåtens längd
<c>En grundligare beskrivning
<c>av attributet Langd...


<h2>@Summary
Short description in one line. If there is a @Summary, this text is put into the table of
attributes in the html file. If there is no summary, the whole description is written instead.
Not used in xtt.

wb_load syntax <link>docblock wb_load attribute
</topic>

<headerlevel>
<topic> docblock wb_load attribute
wb_load syntax

Documenation of an attribute in written above the $Attribute, $Input, $Output or $Intern line.

<c>      !/**
<c>      !  @Summary Plåtens längd
<c>      !  En grundligare beskrivning
<c>      !  av attributet Langd...
<c>      !*/
<c>      Object    Langd $Attribute 3
<c>        Body             SysBody
<c>          Attr           TypeRef = "pwrs:Type-$Float32"
<c>        EndBody
<c>      EndObject

<h2>!/**
Start of a documentation block.
All the text between !/** and !*/ will be written as a description of the attribute.

<h2>!*/
End of a documentation block.
</topic>
</headerlevel>

<topic> docblock ccode
Syntax for c- and h-files
If you want to use the links to c- and h-files, these also have to be converted to html.
There is also a function to add bookmarks.

The structfile for the classes are automatically generated with bookmarks.

<c>/**
<c>   MyPlcClass
<c>
<c>   Description for the class that is not displayed anywhere but in the code.
<c>
<c>   @aref MyPlcClass MyPlcClass
<c>*/
<c>void MyPlcClass_exec(...)

<h2>@aref
@aref has to lay insice a /*_* ... */ block. Inside the block, there can also be comments
that are not handled by the converter.

<b>Syntax
<c>@aref 'bookmark' 'text' 
</topic>

</chapter>

<chapter>
<topic>opc_intro
OPC
Proview has implemented the OPC XML/DA protocol for data exchange with other automation
software. For more information about OPC see www.opcfoundation.org.

<option> printdisable
OPC Server <link> opc_server
OPC Client <link> opc_client
<option> printenable
</topic>

<headerlevel>
<topic>opc_server
OPC XML/DA Server

An OPC XML/DA Server is a web service from which an OPC XML/DA Client can get information of a 
Proview system. A opc client can, for example, browse the object hierachy, read and write 
attribute value, and subscribe to attributes. 

The opc server implements the http protocol as well and is not  connected to a web server. The 
port number of the opc_server is set to 80, the URI for the web service is on node 'mynode' is

<c>http://mynode

If a web server is present, this normally has allocated the port 80, and another port has to be
choosen for the opc_sever. If port 8080 is choosen, the URI will be

<c>http://mynode:8080

<h1>Browsing
The OPC XML/DA browsing supports branches and items. The item contains a value, while the 
branch is an hierarchical component without a value. There is no support for objects, so an 
object has to be implemented as a branch, while an attribute is implemented as an item. Also 
arrays are implemented as branches, while array elements (that is not a class) is implemented 
as an item.

<h1>Threads
If the opc client uses the HoldTime and WaitTime attributes in the SubscriptionPolledRefresh 
request, the opc server has to be multi threaded, that is, for every request, an new thread is 
created. If the HoldTime and WaitTime is not used (as in the proview opc client), all requests 
can be handled in a single thread, which is less time consuming. Multithreads or not is 
configured in the configuration object for the opc server. The default value is 'IfNeeded' 
which turns on the multithreading for a client if HoldTime or WaitTime are detected.

<h1>Client access
To gain access to a proview opc server, the ip address of the client has to be configured in 
the configuration object for the opc server. Here you can also choose if the client has 
ReadWrite or ReadOnly access, where ReadOnly, allows the client to read and subscribe to 
attribute values, while ReadWrite also is allowed to write attribute values.

<h1>Buffering of subscriptions
The server does not support buffering of subscriptions.

<h1>Configuration
The opc server is configured with a Opc_ServerConfig object that is placed in the Node
hierarchy. The configuration object will cause a server process (opc_server) to start at 
proview startup.
</topic>
</headerlevel>

<headerlevel>
<topic> opc_client
OPC XML/DA Client

The proview opc client is implemented as an extern volume, which is mounted somewhere in the 
object tree of the root volume. Under the mount object, the branches and items of the server 
are displayed with special opc objects. An Opc_Hier object represents a branch and Opc_Int an 
item with an integer value, Opc_Boolean an item with a boolean value etc. If an item object is 
opened the item value are displayed in a Value attribute, and some other properties as 
description, lowEU, highEU, engineeringUnit, lowIR and highIR are displayed. When the object is
opened a subscription is started, and the value is continuously updated. For integer and float 
items there is also an object graph that displays a trend of the value.

With the opc client you can

- browse the branches and items in Xtt, and also display item values and set item values.
- subscribe item values and display them in a Ge graph.
- fetch item values into the plc logic and also write values to items.

The opc client requires that name browsing is implemented in the opc server.

<h1>Ge
An item value can be displayed in a Ge graph by using the name in the extern volume. For 
example, if the mount object for the extern volume is 'Ext-P1', and the local name of the item 
is

<c> /P1/Signals/Ai22

the signal name in Ge will probably be (this is dependent of the browsing function of the 
server)

<c> Ext-P1-P1-Signals-Ai22.Value##Float32

presuming that it is a float datatype.

<h1>Plc
Item values can also be handled in the plc program, using the GetExt... and CStoExt... objects.
The normally used objects for getting and storing attributes GetDp, GetAp, StoDp, StoAp etc. 
can not be used, as they require that the referenced name is known in the development 
environment, which is not the case for most extern volumes. In the Ext objects, the reference 
is made with a name string, making it possible to enter the item name. To get the value of the 
item in the previous example, you should use a GetExtFloat32 object, and the object name should
be

<c>Ext-P1-P1-Signals-Ai22.Value

To store a value in an item, lets say /P1/Signals/Ao5, you use a CStoExtFoat32. This objects 
makes a conditional storage, and only on a positive edge of the condition. Compare with the 
CStoAp, where the value is stored, as long as the condition is true. The reference name in the 
CStoExtFloat32 object in this case should be

<c>Ext-P1-P1-Signals-Ao5.Value

<h1>Client process
For each opc client-server connection a client process has to be started. The executable for 
this process is opc_provider that has the arguments

 1. Opc server URL.
 2. Extern volume id.
 3. Extern volume name.
 4. Server identity (optional, default 200).

<h1>Configuration
<h2>Register ExternVolume
Register the externvolume in the GlobalVolumeList with a volume name and identity.

<h2>Application file
Add a line in the application file to start the opc_provider. Here is an example for a opc 
client connecting to the opc server 'http://servernode:8080'. The registered externvolume has 
the name MyOpcVolume with volume id 0.1.99.55

<c>opc_provider, opc_provider, noload, run, opc_provider, 9, nodebug, 
<c>   http://servernode:8080 0.1.99.55 MyOpcVolume

If item values are fetched into the plc, the priority should be set to 4 (sixth argument).

<h2>Mount object
Create a mount object in the plant hierarchy of the rootvolume, and insert the objid of the 
volumeobject in the externvolume into the Object attribute. In the example above this objid is 
_O0.1.99.55:0.

<h2>Hint
The application file reside on $pwrp_load and has the name 

<c>$pwrp_load/ld_appl_'nodename'_'busnumber'.txt 

where nodename is the name of the node, and busnumber the qcom bus number. If the node is 
'mynode' and the busnumber is 507, the filename will be

<c> $pwrp_load/ls_appl_mynode_507.txt
</topic>
</headerlevel>
</chapter>

<chapter>
<TOPIC> help command
Wtt commands

<b>build      <t>Build node, volume or object	<LINK> build
<b>check classes <t>Check if any classes needs update <LINK> check classes
<b>close graph <t>Close a Ge graph		<LINK> close graph
<b>compile    <t>Compile plcpgm			<LINK> compile
<b>configure card<t>Configure a card object	<LINK> configure card
<b>connect    <t>Connect signal and channel	<LINK> connect
<b>copy       <t>Copy selected object trees 	<LINK> copy
<b>copy object<t>Copy an object			<LINK> copy object
<b>create bootfiles <t>Create bootfiles		<LINK> create bootfiles
<b>create crossreferencefiles <t>Create crossreferencefiles <LINK> create crossreferencefiles
<b>create flowfiles <t>Create flow files for plc trace	<LINK> create flowfiles
<b>create loadfiles <t>Create loadfiles		<LINK> create loadfiles
<b>create object <t>Create an object		<LINK> create object
<b>create structfiles <t>Create structfiles	<LINK> create structfiles
<b>create volume <t>Create a volume		<LINK> create volume
<b>cut		<t>Cut objects			<LINK> cut
<b>define      	<t>Define a symbol		<LINK> define
<b>delete object <t>Delete an object		<LINK> delete object
<b>delete tree	<t>Delete an object tree	<LINK> delete tree
<b>delete volume<t>Delete a volume		<LINK> delete volume
<b>disconnect 	<t>Disconnect signal and channel <LINK> disconnect
<b>display     <t>Display a window		<LINK> display
<b>edit        <t>set edit mode			<LINK> edit
<b>exit        <t>close wtt			<LINK> exit
<b>help        <t>Display help			<LINK> help help
<b>generate web <t>Generate webpages		<LINK> generate web
<b>list channels<t>List channels		<LINK> list channels
<b>list descriptor<t>List from listdescriptor	<LINK> list descriptor
<b>list hierarchy<t>List hierarchy		<LINK> list hierarchy
<b>list plcpgm <t>List plcprogram		<LINK> list plcpgm
<b>list signals<t>List signals			<LINK> list signals
<b>login       <t>User login			<LINK> login
<b>logout      <t>User logout			<LINK> logout
<b>move object <t>Move an object		<LINK> move object
<b>new buffer  <t>Create a new buffer		<LINK> new buffer
<b>one         <t>One window			<LINK> one
<b>open buffer <t>Open buffer selection window	<LINK> open buffer
<b>open graph  <t>Open a Ge graph		<LINK> open graph
<b>paste       <t>Paste buffer			<LINK> paste
<b>print      <t>Print plcpgm			<LINK> print
<b>redraw     <t>Redraw plcpgm			<LINK> redraw
<b>release subwindow <t>Continue execution with graph in window object. <LINK>release subwindow
<b>revert      <t>Revert session		<LINK> revert
<b>save        <t>Save session			<LINK> save
<b>search      <t>Search 			<LINK> search
<b>set advanceduser<t>Set advanced user	<LINK> set advanceduser
<b>set alltoplevel<t>Display all toplevel objects <LINK> set alltoplevel
<b>set attribute<t>Set object attributes 	<LINK> set attribute
<b>set db      <t>Set database 			<LINK> set db
<b>set inputfocus<t>Set input focus to window 	<LINK> set inputfocus
<b>set showalias<t>Display alias name 		<LINK> set showalias
<b>set showattrref<t>Display attribute references <LINK> set showattrref
<b>set showattrxref<t>Display attribute x-references <LINK> set showattrxref
<b>set showclass<t>Display object class 	<LINK> set showclass
<b>set showdescription<t>Display description 	<LINK> set showdescription
<b>set showobjref<t>Display object references 	<LINK> set showobjref
<b>set showobjxref<t>Display object x-references <LINK> set showobjxref
<b>set subwindow <t>Open a graph in a window object <LINK>set subwindow
<b>set template<t>Set template values for objects <LINK> set template
<b>set verify  <t>Script verification	 	<LINK> set verify
<b>set window  <t>Set window width and height 	<LINK> set window
<b>setup       <t>Wtt setup			<LINK> setup
<b>show children<t>Show the children of an object <LINK> show children
<b>show license <t>Show license terms		<LINK> show license
<b>show object  <t>Show an object		<LINK> show object
<b>show objid  <t>Show object identity		<LINK> show objid
<b>show script <t>Show scriptfiles		<LINK> show script
<b>show symbol <t>Show a symbol			<LINK> show symbol
<b>show user   <t>Show current user		<LINK> show user
<b>show version<t>Show wtt version		<LINK> show version
<b>show volumes<t>Show all volumes in the database <LINK> show volumes
<b>sort       <t>Sort the children of an object <LINK> sort
<b>two         <t>Two windows			<LINK> two
<b>update classes <t>Update classes		<LINK> update classes
<b>wb dump    <t>Dump objects to textfile	<LINK> wb dump
<b>wb load    <t>Load objects from textfile	<LINK> wb load

<b>Symbols <link> symbol

<H2>related subjects
script <LINK> script
</TOPIC>	

<TOPIC> build <style> function
Command   build

Call the build method for a node, a volume or an object.

<B>wtt> build node /name= [/force][/debug][/manual][/crossreference]
<B>wtt> build volume /name= [/force][/debug][/manual][/crossreference]
<B>wtt> build object /name= [/force][/debug][/manual][/crossreference]

/name	<t>Node name, volume name or object name.
/force  <t>Don't check any dependencies, build everything.
/debug  <t>Build with debug, i.e. compile and link with debug.
/manual <t>Just build the specified item.
/crossreferences <t>Create crossreferencefiles. Valid for building volumes.

</TOPIC>

<TOPIC> check classes <style> function
Command   check classes

Check if any classes needs update.

<B>wtt> check classes

</TOPIC>

<TOPIC> close graph <style> function
Command   close graph

Close a Ge graph.

<B>wtt> close graph /file=

/file	<t>Name of the Ge graph.
</TOPIC>

<TOPIC> compile <style> function
Command   compile

Compile plcprograms.

If no hierarchy, plcpgm or window is specified, the selected plcpgm
will be compiled.


<B>wtt> compile [/debug]
<B>wtt> compile /plcpgm= [/debug]
<B>wtt> compile /window= [/debug]
<B>wtt> compile /hierarchy= [/debug][/modified][/from_plcpgm=]
<B>wtt> compile /volume= [/debug][/modified][/from_plcpgm=]
<B>wtt> compile /allvolumes [/debug][/modified][/from_plcpgm=]

/plcpgm		<t>Name of plcpgm object that will be compiled.
/window		<t>Name of plcwindow object that will be compiled.
/hierarchy	<t>All plcpgm's in the hierarchy will be compiled.
/volume		<t>Volume name. All plcpgm's in the volume will be compiled.
/allvolumes	<t>All plcpgm's in all volumes in the database will be compiled.
/debug		<t>Compile with debug.
/modified	<t>Only modified plcwindows will be compiled.
</TOPIC>

<TOPIC> configure card <style> function
Command   configure card

Create a card with channels.

<B>wtt> configure card /rack= /cardname= /channelname= /chanidentity=
<B>		<t>/chandescription= /table=

/rack		<t>Name of rack object that the card will belong to.

/cardname	<t>Name of card. Last segment of name.

/channelname	<t>Name of channel. Last segment of name.
		<t>A '#' will be replaced with the channel number.
		<t>For example /chan=di33## will give the channelnames
		<t>di3301, di3302... If there is more than one channel
		<t>channelname has to contain a '#' sign.

/chanidentity	<t>Identiy of the channel. Will be inserted into the Identity-
		<t>attribute of the channel.

/chandescripton	<t>Channel description. Will be inserted into the Description-
		<t>attribute of the channel.
</TOPIC>

<TOPIC> connect <style> function
Command   connect

Connect a signal and a channel.

<B>wtt> connect /source= /destination= [/reconnect]

/source		<t>A signal or channel object.
/destination	<t>A signal or channel object.
/reconnect	<t>If the source or destination already is connected
		<t>it will first be disconnected.
</TOPIC>

<TOPIC> copy <style> function
Command   copy

Copy selected object trees to paste buffer.

<B>wtt> copy [/keepreferences] [/ignore_errors]

/keepreferences	<t>Keep references to objects outside the copied trees. By default
                <t>these references will be zeroed.
/ignore_errors  <t>Try to complete the copy despite detected errors.
</TOPIC>

<TOPIC> copy object <style> function
Command   copy object

Copy an object or an object tree.

<B>wtt> copy object /source= /destination= /name= [/hierarchy]
<B>		<t>[/first] [/last] [/after] [/before]

/source		<t>The object that will be copied.
/destination	<t>The parent or sibling to the created object.
/name		<t>The name of the created object. Last segment.
/hierarchy	<t>If the source-object has children, the child tree
		<t>will also be copied.
/first		<t>The object will be inserted as first child to
		<t>the destination object.
/last		<t>The object will be inserted as last child to
		<t>the destination object.
/after		<t>The object will be inserted as sibling after
		<t>the destination object.
/before		<t>The object will be inserted as sibling before
		<t>the destination object.
</TOPIC>

<TOPIC> create bootfiles <style> function
Command   create bootfiles

Create new bootfiles.

<B>wtt> create bootfiles /nodeconfig= [/debug]
<B>wtt> create bootfiles /allnodes [/debug]

/nodeconfig	<t>The name of the NodeConfig-object of the
		<t>node for which nodefile will be created.

/all		<t>Create bootfiles for all nodes in the project.

/debug		<t>Link plcprogram with debug.
</TOPIC>

<TOPIC> create crossreferencefiles <style> function
Command   create crossreferencefiles

Create files for displaying crossreferences in xtt and rtt for
the current volume.

<B>wtt> create crossreferencefiles
</TOPIC>

<TOPIC> create flowfiles <style> function
Command   create flowfiles

Create flowfiles for plc trace.
The layout of the plc windows are stored in flow files and used
in plc trace.

<B>wtt> create flowfiles /plcpgm=
<B>wtt> create flowfiles /hier=
<B>wtt> create flowfiles /all

Command to create flowfiles from template plcpgm's in a class volume
<B>wtt> create flowfiles /template/plcpgm=
<B>wtt> create flowfiles /template/hier=Class

/all		<t>Create flowfiles for all plc programs in the volume
                <t>(can not be used in class volumes, use /hier=Class instead).
/plcpgm		<t>Create flowfiles for the specified PlcPgm object.
/hierarchy      <t>Create flowfiles for all PlcPgm object under the 
                <t>specified hierarchy.
/template	<t>Create flowfiles for PlcTemplate programs in a class volume.
</TOPIC>

<TOPIC> create loadfiles <style> function
Command   create loadfiles

Create loadfiles for a volume.

<B>wtt> create loadfile /volume=
<B>wtt> create loadfile [/class] [/all]

/volume		<t>Create loadfiles for a specific volume.

/all		<t>Create loadfiles for all root volumes
		<t>in the database.

/class		<t>Create loadfiles for all classvolumes in the database.
</TOPIC>

<TOPIC> create object <style> function
Command   create object

Create an object.

<B>wtt> create object /destination= /name= /class= 
<B>		<t>[/first] [/last] [/after] [/before]

/destination	<t>The destination of the new object. The position
		<t>of the new object will be child or sibling relative
		<t>to the destination object.

/name		<t>Name of the new object. Last segment.

/class		<t>Class of new object.

/first		<t>The object will be inserted as first child to
		<t>the destination object.

/last		<t>The object will be inserted as last child to
		<t>the destination object.

/after		<t>The object will be inserted as sibling after
		<t>the destination object.

/before		<t>The object will be inserted as sibling before
		<t>the destination object.

</TOPIC>

<TOPIC> create structfiles <style> function
Command   create structfiles

Create c include-files for classes in a classvolume.

<B>wtt> create structfiles [/files=]

/files		<t>Name of wb_load-file.
		<t>Default name $pwrp_db/userclasses.wb_load
</TOPIC>

<TOPIC> cut <style> function
Command   cut

Copy selected object trees to paste buffer, and remove the objects
in the current volume.

<B>wtt> cut [/keepreferences]

/keepreferences	<t>Keep references to objects outside the copied trees. By default
                <t>these references will be zeroed.
</TOPIC>

<TOPIC> define <style> function
Command define

Define a symbol.

<B>wtt> define 'symbolname' 'text'

<h2>related subjects
symbol <LINK> symbol
show symbol <LINK> show symbol
symbolfile <LINK> symbolfile
</TOPIC>	

<TOPIC> delete object <style> function
Command   delete object

Delete an object.

<B>wtt> delete object /name= [/noconfirm] [/nolog]

/name		<t>Name of object.
/noconfirm	<t>Delete without confirm.
/nolog		<t>The operation will not be logged on the output device.
</TOPIC>

<TOPIC> delete tree <style> function
Command   delete tree

Delete an object tree.

<B>wtt> delete tree /name= [/noconfirm] [/nolog]

/name		<t>The root object of the tree.
/noconfirm	<t>Delete without confirm.
/nolog		<t>The operation will not be logged on the output device.
</TOPIC>

<TOPIC> disconnect <style> function
Command   disconnect

Disconnect a signal or a channel.

<B>wtt> disconnect /source=

/source		<t>A signal or channel object.
</TOPIC>

<TOPIC> display <style> function
Command   display

Display plant or node hierarchy window (w1 or w2).

<B>wtt> display w1
<B>wtt> display w2
</TOPIC>

<TOPIC> edit <style> function
Command   edit

Enter or leave edit mode.

<B>wtt> edit
<B>wtt> noedit
</TOPIC>

<TOPIC> exit <style> function
Command   exit

Close wtt.

<B>wtt> exit
</TOPIC>

<TOPIC> help help <style> function
Command   help

Display help information for a subject.
The help information will be searched for in a help file. The file can be the base helpfile, 
the project helpfile or another help file.

If no helpfile is supplied the subject will be searched for in the base and project helpfiles.

<B>wtt> help 'subject'
<B>wtt> help 'subject' /helpfile=

/helpfile<t>A help file that contains information of the help subject.

<H2>related subjects
helpfile <LINK> helpfile
</TOPIC>

<TOPIC> generate web <style> function
Command   generate web

Generate html-files for webpages configured by Web-objects in the
node hierarchy of the current volume.

<B>wtt> generate web
</TOPIC>

<TOPIC> list <style> function
Command   list

Print a list of objects and attributes.

The lists will be sent to a printer queue specified by the
symbol PWR_FOE_PRINT.

<B>wtt> list descriptor /descriptor=		<link> list descriptor
<B>wtt> list channels [/node=]			<link> list channels
<B>wtt> list signals [/hierarchy=]		<link> list signals
<B>wtt> list plcpgm [/plcpgm=] [/hierarchy=]	<link> list plcpgm
<B>wtt> list hierarchy [/hierarchy=]		<link> list hierarchy
</TOPIC>

<TOPIC> list channels <style> function
Command   list channels

List cards and channels.

<B>wtt> list channels [/node=] [/volume=] [/allvolumes] [output=]

/node		<t>$Node object.
/volume		<t>List objects in this volume.
/allvolume	<t>List objects in all volumes.
/output		<t>Output file. If output file is supplied, the list
		<t>will not be sent to the printer.
</TOPIC>

<TOPIC> list descriptor <style> function
Command   list descriptor

Print a list described by a ListDescriptor object.

<B>wtt> list descriptor /descriptor=		<link> list descriptor

/descriptor	<t>ListDescriptor object.
</TOPIC>

<TOPIC> list hierarchy <style> function
Command   list hierarchy

List of PlantHier and NodeHier objects.

<B>wtt> list hierarchy [/hierarchy=] [/volume=] [/allvolumes] [output=]

/hierarchy	<t>Hierarchy object.
/volume		<t>List objects in this volume.
/allvolume	<t>List objects in all volumes.
/output		<t>Output file. If output file is supplied, the list
		<t>will not be sent to the printer.
</TOPIC>

<TOPIC> list plcpgm <style> function
Command   list plcpgm

List of PlcPgm objects.

<B>wtt> list plcpgm [/hierarchy=] [plcpgm=] [/volume=] [/allvolumes] [output=]

/plcpgm		<t>Plcpgm object.
/hierarchy	<t>Hierarchy object.
/volume		<t>List objects in this volume.
/allvolume	<t>List objects in all volumes.
/output		<t>Output file. If output file is supplied, the list
		<t>will not be sent to the printer.
</TOPIC>

<TOPIC> list signals <style> function
Command   list signals

List of signals and crossreferences to the signals.

<B>wtt> list signals [/hierarchy=] [/volume=] [/allvolumes] [output=]

/hierarchy	<t>Hierarchy object.
/volume		<t>List objects in this volume.
/allvolume	<t>List objects in all volumes.
/output		<t>Output file. If output file is supplied, the list
		<t>will not be sent to the printer.
</TOPIC>

<TOPIC> login <style> function
Command   login

Login with username an password. The privileges of the user will be
fetched from the user database, and affect the access to the system.

<B>wtt> login 'username' 'password'

If you want to create or modify a project, user or register a volume,
you login as administrator with the qualifier /administrator. You must
specify a user in the systemgroup 'administrator'. If this systemgroup
doesn't exist, usename and password is not required.

<B>wtt> login /administrator 'username' 'password'

<H2>related subjects
logout <LINK> logout
show user <LINK> show user
</TOPIC>

<TOPIC> logout <style> function
Command   logout

Logout a user, and return to the original user.

<B>wtt> logout

<H2>related subjects
login <LINK> login
</TOPIC>

<TOPIC> move object <style> function
Command   move object

Move an object.

<B>wtt> move object /source= /destination= [/rename=] [/first] [/last] [/after] [/before]
<B>wtt> move object /source= /rename=

/source		<t>Name of object to move.
/destination	<t>The parent or sibling to the object after the move.
/rename		<t>New object name, if the object name should be changed.
		<t>Last segment. If no destination is supplied, the object
		<t>will only be renamed, not moved.
/first		<t>The object will be inserted as first child to
		<t>the destination object.
/last		<t>The object will be inserted as last child to
		<t>the destination object.
/after		<t>The object will be inserted as sibling after
		<t>the destination object.
/before		<t>The object will be inserted as sibling before
		<t>the destination object.
</TOPIC>

<TOPIC> new buffer <style> function
Command   new buffer

Create a new empty buffer.

<B>wtt> new buffer /name=

/name		<t>Name of the buffer
</TOPIC>

<TOPIC> one <style> function
Command   one

Display one window. The window which currently owns the input
focus is kept.

<B>wtt> one
</TOPIC>

<TOPIC> open buffer <style> function
Command   open buffer

Open the buffer selection window.

<B>wtt> open buffer
</TOPIC>

<TOPIC> open graph <style> function
Command   open graph

Open a Ge graph.
If modal is selected, the execution av the script is continued
when the graph is closed.

<B>wtt> open graph /file= /modal

/file	<t>Name of the Ge graph.
/modal  <t>Modal.
</TOPIC>

<TOPIC> paste <style> function
Command   paste

Paste object from the last copy or cut operation into the current volume.
With the buffer option, an older paste buffer can be pasted.

<B>wtt> paste [/keepoid] [/buffer=]

/keepoid	<t>Keep the object identities if possible.
/buffer		<t>Name of the buffer that should be pasted. By default
		<t>the last buffer is used.
/into		<t>Copy the root objects of the paste buffer as child to
                <t>the selected object.
/toplevel       <t>Copy the root objects of the paste buffer to the toplevel.
                <t>Has to be used when copying to an empty volume.
</TOPIC>

<TOPIC> print <style> function
Command   print

Print plc documents.

<B>wtt> print /plcpgm= [/nodocument] [/nooverview]
<B>wtt> print /hierarchy= [/nodocument] [/nooverview]

/plcpgm		<t>Print documents in a plcpgm.
/hierarchy	<t>Hierarchy object. All plc in the hierarchy will
		<t>be printed.
/nodocument	<t>The plc-documents will not be printed.
/nooverview	<t>The overview of the plc-window will not be printed.
</TOPIC>

<TOPIC> release subwindow <style> function
Command   release subwindow

Continue the execution of a script that has opened a graph
in a window object by the command 'set subwindow' or the 
function 'SetSubwindow' with modal selected.
The release command should be executed from a pushbutton
in the graph with actiontype command.

<B>wtt> release subwindow 'graph'

graph	<t>Name of the main graph.
</TOPIC>

<TOPIC> revert <style> function
Command   revert

Revert session.

<B>wtt> revert
</TOPIC>

<TOPIC> save <style> function
Command   save

Save session.

<B>wtt> save
</TOPIC>


<TOPIC> search <style> function
Command   search

Search for an objectname or a string.

<B>wtt> search 'object'
<B>wtt> search /regularexpression 'expression'
<B>wtt> search /next
</TOPIC>

<TOPIC> set advanceduser <style> function
Command   set advanceduser

Set or reset advanced user.

<B>wtt> set advanceduser
<B>wtt> set noadvanceduser

<H2>related subjects
advanced user <LINK> advanced user
</TOPIC>

<TOPIC> set alltoplevel <style> function
Command   set alltoplevel

Show all the root objects in the database, not only the
root objects defined for the plant hierarchy or the
node hierarchy.

<B>wtt> set alltoplevel
<B>wtt> set noalltoplevel

</TOPIC>

<TOPIC> set attribute <style> function
Command   set attribute

Set a value to an attribute.
Objects are selected by the name, class and hierarchy qualifiers.

<B>wtt> set attribute /attribute= [/value=] [/name=] [/class=] [/hierarchy=]
<B>		<t>[/noconfirm] [/nolog] [/output] [/noterminal]

/attribute	<t>Name of attribute.
/value		<t>Value to insert in the attribute. If no value is given
		<t>a question will be asked for each object.
/class		<t>Select object of this class.
/hierarchy	<t>Only successors to this object will be selected.
/noconfirm	<t>No confirm request is issued.
/nolog		<t>Operation is not logged to output device.
/output		<t>Output file.
/noterminal	<t>Operations will not be logged in terminal.
</TOPIC>

<TOPIC> set db <style> function
Command   set db

Connect to the database with the supplied id.
This has no affect if a database already is open.

<B>wtt> set db /dbid=

/dbid	<t>Database identity.
</TOPIC>

<TOPIC> set inputfocus <style> function
Command   set inputfocus

Set input focus to the plant or the node hierarchy window (w1 or w2).

<B>wtt> set inputfocus w1
<B>wtt> set inputfocus w2
</TOPIC>

<TOPIC> set showalias <style> function
Command   set showalias

Display the aliasname of the objects in the plant and node hierarchy.

<B>wtt> set showalias
<B>wtt> set noshowalias
</TOPIC>

<TOPIC> set showattrref <style> function
Command   set showattrref

Display the number of connected attribute references
of the objects in the plant and node hierarchy.

<B>wtt> set showattrref
<B>wtt> set noshowattrref
</TOPIC>

<TOPIC> set showattrxref <style> function
Command   set showattrxref

Display the number of connected attribute x-references of 
the objects in the plant and node hierarchy.

<B>wtt> set showattrxref
<B>wtt> set noshowattrxref
</TOPIC>

<TOPIC> set showclass <style> function
Command   set showclass

Display the class of the object in the plant and node hierarchy.

<B>wtt> set showclass
<B>wtt> set noshowclass
</TOPIC>

<TOPIC> set showdescription <style> function
Command   set showdescription

Display the description of the objects in the plant and node hierarchy.

<B>wtt> set showdescription
<B>wtt> set noshowdescription
</TOPIC>

<TOPIC> set showobjref <style> function
Command   set showobjref

Display the number of connected object references of the objects in the 
plant and node hierarchy.

<B>wtt> set showobjref
<B>wtt> set noshowobjref
</TOPIC>

<TOPIC> set showobjxref <style> function
Command   set showobjxref

Display the number of connected object x-references of the objects in the 
plant and node hierarchy.

<B>wtt> set showobjxref
<B>wtt> set noshowobjxref
</TOPIC>

<TOPIC> set subwindow <style> function
Command   set subwindow

Open a graph in a window object in a previously opened graph.

<B>wtt> set subwindow 'graph' /name= /source=

/name	<t>Name of the window object.
/source	<t>Name of graph that is to be opened in the window object.
</TOPIC>

<TOPIC> set template <style> function
Command   set template

Set template values for some attributes that affect the layout
in the plceditor.

<B>wtt> set template [/signalobjectseg=] [/sigchanconseg=] [/shosigchancon=]
		<t>[/shodetecttext=]

/signalobjectseg	<t>Number of segments of the signal name that will
			<t>be displayed in 'Get' and 'Set' objects in 
			<t>the plc-editor.
/sigchanconseg		<t>Number of segments of the channel name that will
			<t>be displayed in 'Get' and 'Set' objects in 
			<t>the plc-editor.
/shosigchancon		<t>Display the channel name in 'Get' and 'Set' 
			<t>objects in the plc-editor.
/shodetecttext		<t>Display the detect text in ASup and DSup 
			<t>objects in the plc-editor.
</TOPIC>

<TOPIC> set verify <style> function
Command   set verify

Display all executed lines when running a script.

<B>wtt> set verify
<B>wtt> set noverify
</TOPIC>

<TOPIC> set window <style> function
Command   set window

Set window width and height.

<B>wtt> set window /width= /height=

/width	<t>width in pixels.
/height <t>height in pixels.
</TOPIC>

<TOPIC> set volume <style> function
Command   set volume

set volume is obsolete.
</TOPIC>

<TOPIC> setup <style> function
Wtt setup
Setup of wtt properies

DefaultDirectory<t><t>Default directory for commandfiles.
SymbolFilename	<t><t>Symbolfile.		<LINK> symbolfile
Verify		<t><t>Verify commandfile execution.
AdvancedUser	<t><t>User is advanced. <LINK> advanced user
AllToplevel	<t><t>Display all toplevel objects.
Bypass		<t><t>Bypass some edit restrictions.
</TOPIC>

<TOPIC> show children <style> function
Command   show children

Display en object and it's children

<B>wtt> show children /name=

/name	<t>Name of the parent object.
</TOPIC>

<TOPIC> show license <style> function
Command   show license

Show license terms.

<B>wtt> show license
</TOPIC>

<TOPIC> show object <style> function
Command   show object

List objects.

<B>wtt> show object [/name=] [/hierarchy=] [/class=] [/volume=] [/allvolumes]
<B>		<t>[/parameter=] [/full] [/output=] [/noterminal]
<B>wtt> show object /objid=

/name		<t>Object name. Wildcard is supported.
/hierarchy	<t>Hierarchy object. Only object in the hierarchy will be
		<t>selected.
/class		<t>Only objects of this class will be selected.
/volume		<t>Name of volume.
/allvolumes	<t>Search of objects will be performed in all volumes.
/parameter	<t>List the value of an attribut for the selected objects.
/full		<t>Display the content of the objects. Attributes that
		<t>differ from template value will be displayed.
/output		<t>Output file.
/noterminal	<t>Output will not be written to terminal.
/objid		<t>Display object for a specified objid.
</TOPIC>

<TOPIC> show objid <style> function
Command   show objid

Show the objid of an object.
If name is ommitted, the objid of the current selected
object is shown.

<B>wtt> show objid [/name=]

/name	<t>Object name.
</TOPIC>

<TOPIC> show script <style> function
Command   show script

Provides a list of scriptfiles.
Wildcard with asterisk (*) can be used to look up files. 

<B>wtt> show script ['scriptspec']

</TOPIC>

<TOPIC> show symbol <style> function
Command   show symbol

Show one symbol, or all symbols

<B>wtt> show symbol 'symbol'<t>Show symbol 'symbol'
<B>wtt> show symbol<t>              Show all symbols

<h2>related subjects
define <LINK> define
symbol <LINK> symbol
</TOPIC>

<TOPIC> show version <style> function
Command   show version

Show the wtt version

<B>wtt> show version
</TOPIC>

<TOPIC> show volumes <style> function
Command   show volumes

Show all volumes in the database.

<B>wtt> show volumes
</TOPIC>

<TOPIC> sort <style> function
Command   sort

Sort the children of an object in alpabetical order, or in class order.
If no parent is given, the children of the selected objects will be sorted.

<B>wtt> sort /parent= [/class] [/signals]

/parent		<t>Parent to the objects that will be sorted.
/class		<t>Sort in class order.
/signals	<t>Sort signal and plcpgm objects in class order,
		<t>and other objects in alpabetical order.
</TOPIC>

<TOPIC> two <style> function
Command   two

Display two windows. Both the plant and the node hierarchy window are
displayed.

<B>wtt> two
</TOPIC>

<TOPIC> update classes <style> function
Command   update classes

Update classes in the attached volume.

<B>wtt> update classes

</TOPIC>

<TOPIC> wb dump <style> function
Command   wb dump

Dump the volume or a part of the volume to text file.

<B>wtt> wb dump /output= [/hierarchy=]

/hierarchy	<t>Hierarchy object. The object and its child tree will
		<t>be written to text file.
/output		<t>Output file.
/nofocode       <t>Don't write plc code for functionobjects with template
                <t>code. This will reduce the size of the dumpfile. New
                <t>code will be copied when the plc is compiled.
/keepname       <t>Write extern references by name instead of indentity string.
/noindex        <t>Don't write object index in the dumpfile.
</TOPIC>

<TOPIC> wb load <style> function
Command   wb load

Load the database or from wb_load-file or dbs-file.

<B>wtt> wb load /loadfile=

/loadfile	<t>Name of file. Can be of type .wb_load, .wb_dmp or .dbs.

</TOPIC>

<TOPIC> symbol
Symbol

A wtt symbol can be used as a short command or as string replacement
in a command. If the symbol is used as string replacement the symbol-
name should be surrounded by quotes.

Symbols are created with the define command. <LINK> define
The define-commands can be executed by the symbolfile. <LINK> symbolfile

Example of symbol used as a short command.

<c>wtt> define p1 "show child/name=hql-hvk-pumpar-pump1"
<c>wtt> p1

Example of symbol used as string replacement

<c>wtt> define p1 hql-hvk-pumpar-StartPump1
<c>wtt> open trace 'p1'

<H2>related subjects
define <LINK> define
show symbol <LINK> show symbol
symbolfile <LINK> symbolfile
</TOPIC>

</chapter>
//
// Script
//

<chapter>
<TOPIC> script
Wtt script

execute script		<LINK> execute script
datatypes		<LINK> datatypes
datatype conversions	<LINK> datatype conversions
variable declarations	<LINK> variable declarations
operators		<LINK> operators
main-endmain		<LINK> main-endmain
function-endfunction	<LINK> function-endfunction
if-else-endif		<LINK> if-else-endif
while-endwhile		<LINK> while-endwhile
for-endfor		<LINK> for-endfor
break			<LINK> break
continue		<LINK> continue
goto			<LINK> goto
include			<LINK> include
printf()		<LINK> printf()
scanf()			<LINK> scanf()
fprintf()		<LINK> fprintf()
fgets()			<LINK> fgets()
fopen()			<LINK> fopen()
fclose()		<LINK> fclose()
exit()			<LINK> exit()
verify()		<LINK> verify()
time()			<LINK> time()
edit()			<LINK> edit()
extract()		<LINK> extract()
element()		<LINK> element()
toupper()		<LINK> toupper()
tolower()		<LINK> tolower()
translate_filename()	<LINK> translate_filename()
wtt-commands		<LINK> wtt-commands
GetAttribute()		<LINK> getattribute()
GetChild()		<LINK> getchild()
GetParent()		<LINK> getparent()
GetNextSibling()	<LINK> getnextsibling()
GetNextVolume()		<LINK> getnextvolume()
GetClassList()		<LINK> getclasslist()
GetNextObject()		<LINK> getnextobject()
GetObjectClass()	<LINK> getobjectclass()
GetNodeObject()		<LINK> getnodeobject()
GetRootList()		<LINK> getrootlist()
GetVolumeClass()	<LINK> getvolumeclass()
GetVolumeList()		<LINK> getvolumelist()
SetAttribute()		<LINK> setattribute()
GetProjectName()	<LINK> getprojectname()  
CheckSystemGroup()	<LINK> checksystemgroup()
CutObjectName()		<LINK> cutobjectname()
MessageError()		<LINK> messageerror()
MessageInfo()		<LINK> messageinfo()
GetCurrentText()	<LINK> getcurrenttext()
GetCurrentObject()	<LINK> getcurrentobject()
GetCurrentVolume()	<LINK> getcurrentvolume()
IsW1()			<LINK> isw1()
IsW2()			<LINK> isw2()
EditMode()		<LINK> editmode()
MessageDialog()		<LINK> messagedialog()
ConfirmDialog()		<LINK> confirmdialog()
ContinueDialog()	<LINK> continuedialog()
PromptDialog()		<LINK> promptdialog()
OpenGraph()		<LINK> opengraph()
CloseGraph()		<LINK> closegraph()
SetSubwindow()		<LINK> setsubwindow()
</TOPIC>

<TOPIC> execute script
Execute a script

A script-file will be executed from the command-line with the command

wtt> @'filename'

</TOPIC>

<TOPIC> datatypes
Datatypes

The datatypes are float, int and string.

int	<t>integer value.
float	<t>32-bit float value.
string	<t>80 character string (null terminated).

There are three different tables in which a variable can be declared: local, 
global and extern. A local variable is known inside a function, a global is 
known in all functions in a file (with include-files), an external is known 
for all files executed in a session.

</TOPIC>

<TOPIC> datatype conversions
Datatype conversions

If an expression consists of variables and functions of different datatypes
the variables will be converted with the precedence string, float, int. If
two operands in an expression is of type int and float, the result will be float
If two operands is of type float and string, or int and string, the result will
be string. In an assignment the value of an expression will be converted to the
type of the assignment variable, even if the result is a string and the
variable is of type float or int.

<b>Example

<c>string str;
<c>int    i = 35;
<c>str = "Luthor" + i;
The value in str will be "Luthor35".

<c>float   f;
<c>string  str = "3.14";
<c>int     i = 159;
<c>f = str + i;
The value in f will be 3.14159.
</TOPIC>

<TOPIC> variable declarations
Variable declarations

A variable must be declared before it is used.
A declaration consists of
- the table (global or extern, if local the table is suppressed)
- the datatype (int, float or string)
- the variable name (case sensitive)
- if array, number of elements
- equal mark followed by an init value, if omitted the init value is zero or
  null-string
- semicolon

An extern variable should be deleted (by the delete statement).

<b>Example

<c>int             i;
<c>float           flow = 33.4;
<c>string          str = "Hello";
<c>extern int      jakob[20];
<c>global float    ferdinand = 1234;
<c>...
<c>delete jakob[20];
</TOPIC>

<TOPIC> operators
Operators

The operators have the same function as i c, with some limitations. All
operators are not implemented. Some operators (+,=,==) can also operate on
string variables. Precedence of operators is similar to c.

Operator	<t>Description		<t>Datatypes
+		<t>plus			<t>int, float, string
-		<t>minus			<t>int, float
*		<t>times			<t>int, float
/		<t>divide			<t>int, float
++	 	<t>increment, postfix only.	<t>int, float
--	 	<t>decrement, postfix only	<t>int, float
>>	 	<t>bits right-shifted		<t>int
<<	 	<t>bits left-shifted		<t>int
<		<t>less than			<t>int, float
>		<t>greater than		<t>int, float
<=	 	<t>less equal			<t>int, float
>=	 	<t>greater equal		<t>int, float
==	 	<t>equal			<t>int, float, string
!=	 	<t>not equal			<t>int, float, string
&		<t>bitwise and		<t>int
|		<t>bitwise or			<t>int
&&	 	<t>logical and		<t>int
||	 	<t>logical or			<t>int
!		<t>logical not		<t>int
=		<t>assign			<t>int, float, string
+=	 	<t>add and assign		<t>int, float
-=	 	<t>minus and assign		<t>int, float
&=	 	<t>logical and and assign	<t>int
|=	 	<t>logical or and assign	<t>int
</TOPIC>

<TOPIC> main-endmain <style> function
main-endmain

The main and endmain statements controls where the execution starts and stops
If no main and endmain statements will be found, the execution will start
att the beginning of the file and stop at the end.

<b>Example

<c>main()
<c>  int a;

<c>  a = p1 + 5;
<c>  printf( "a = %d", a);
<c>endmain
</TOPIC>

<TOPIC> function-endfunction <style> function
function-endfunction

A function declaration consists of
- the datatype of the return value for the function
- the name of the function
- an argumentlist delimited by comma and surrounded by parenthesis. The
  argumentlist must include a typedeclaration and a name for each argument.

The arguments supplied by the caller will be converted to the type of the
to the type declared in the argument list. If an argument is changed inside
the function, the new value will be transferred to the caller. In this way
it is possible to return other values then the return value of the function.
A function can contain one or several return statements. The return will hand
over the execution to the caller and return the supplied value.

<b>Example

<c>function float calculate_flow(float a, float b)
<c>  float c;
<c>  c = a + b;
<c>  return c;
<c>endfunction

<c>...
<c>flow = korr * calculate_flow( v, 35.2);
</TOPIC>

<TOPIC> if-else-endif <style> function
if-else-endif

The lines between a if-endif statment will be executed if the expression
in the if-statment is true. The expression should be surrounded by parentheses.
If an else statement is found between the if and endif the lines between else
and endif will be executed if the if-exepression is false.

<b>Example

<c>if ( i < 10 && i > 5)
<c>  a = b + c;
<c>endif

<c>if ( i < 10)
<c>  a = b + c;
<c>else
<c>  a = b - c;
<c>endif
</TOPIC>

<TOPIC> while-endwhile <style> function
while-endwhile

The lines between a while-endwhile statment will be executed as long as the
expression in the while-statment is true. The expression should be surrounded
by parentheses.

<b>Example

<c>while ( i < 10)
<c>  i++;
<c>endwhile
</TOPIC>

<TOPIC> for-endfor <style> function
for-endfor

The lines between a for-endfor statment will be executed as long as the
middle expression in the for-statment is true. The for expression consists
of three expression, delimited by semicolon and surrounded by parentheses.
The first expression will be executed the before the first loop, the third
will be executed after every loop, the middle is executed before every loop
and if it is true, another loop is done, if false the loop is leaved.

<b>Example

<c>for ( i = 0; i < 10; i++)
<c>  a += b;
<c>endfor
</TOPIC>

<TOPIC> break <style> function
break

A break statement will search for the next endwhile or endfor statement
continue the execution at the line after.

<b>Example

<c>for ( i = 0; i < 10; i++)
<c>  a += b;
<c>  if ( a > 100)
<c>    break;
<c>endfor
</TOPIC>

<TOPIC> continue <style> function
continue

A continue statement will search for the previous while or for statement
continue the loop execution.

<b>Example

<c>for ( i = 0; i < 10; i++)
<c>  b = my_function(i);
<c>  if ( b > 100)
<c>    continue;
<c>  a += b;
<c>endfor
</TOPIC>

<TOPIC> goto <style> function
goto

A goto will cause the execution to jump to a row defined by label.
The label line is terminated with colon.

<b>Example

<c>  b = attribute("MOTOR-ON.ActualValue", sts);
<c>  if (!sts)
<c>    goto some_error; 
<c>  ...
<c>some_error:
<c>  say("Something went wrong!");
</TOPIC>

<TOPIC> include <style> function
include

An script include-file containing functions can be included with the
#include statement. The default file extention is '.pwr_com'

<b>Example

<c>#include <my_functions>
</TOPIC>

<TOPIC> printf() <style> function
printf()

int printf( string format [, (arbitrary type) arg1, (arbitrary type) arg2])

<b>Description

Formatted print. C-syntax. Format argument and non, one or two value arguments.
Returns number of printed characters.

<b>Arguments

string 			<t>format	<t>Format.
arbitrary type		<t>arg1		<t>Value argument. Optional. Can be int,
			<t>		<t>float or string.
arbitrary type		<t>arg2		<t>Value argument. Optional. Can be int,
			<t>		<t>float or string.

<b>Example

<c>  printf( "Watch out!");
<c>  printf( "a = %d", a);
<c>  printf( "a = %d och str = %s", a, str);
</TOPIC>

<TOPIC> scanf() <style> function
scanf()

int scanf( string format , (arbitrary type) arg1)

<b>Description

Formatted input. C-syntax
Returns number of read characters.

<b>Arguments

string 			<t>format	<t>Format.
arbitrary type		<t>arg1		<t>Value argument. Returned. Can be int,
			<t>		<t>float or string.

<b>Example

<c>  scanf( "%d", i);
</TOPIC>

<TOPIC> fprintf() <style> function
fprintf()

int fprintf( int file, string format [, (arbitrary type) arg1,
	(arbitrary type) arg2])

<b>Description

Formatted print on file. C-syntax. Format argument and non, one or two value
arguments.
Returns number of printed characters.

<b>Arguments

int 			<t>file		<t>File id retured by fopen.
string 			<t>format	<t>Format.
arbitrary type		<t>arg1		<t>Value argument. Optional. Can be int,
			<t>		<t>float or string.
arbitrary type		<t>arg2		<t>Value argument. Optional. Can be int,
			<t>		<t>float or string.

<b>Example

<c>  int outfile;
<c>  outfile = fopen( "my_file.txt", "w");
<c>  if (!outfile)
<c>    exit();
<c>  fprintf( outfile, "Some text");
<c>  fprintf( outfile, "a = %d", a);
<c>  fclose( outfile);
</TOPIC>

<TOPIC> fgets() <style> function
fgets()

int fgets( string str, int file)

<b>Description

Reads a line from a specified file.
Returns zero if end of file.

<b>Arguments

string 		<t>str		<t>Read line. Returned. 
int		<t>file		<t>file returned by fopen.

<b>Example

<c>  file = fopen("some_file.txt","r");
<c>  while( fgets( str, file))
<c>    say( str);
<c>  endwhile
<c>  fclose( file);
</TOPIC>

<TOPIC> fopen() <style> function
fopen()

int fopen( string filespec, string mode)

<b>Description

Opens a file for read or write.
Returns a file identifier. If the file could not be opened, zero is returned.

<b>Arguments

string 		<t>filespec	<t>Name of file. 
string		<t>mode		<t>Access mode

<b>Example

<c>  int infile;
<c>  int outfile;

<c>  infile = fopen("some_file.txt","r");
<c>  outfile = fopen("another_file.txt","w");
<c>  ...
<c>  fclose( infile);
<c>  fclose( outfile);
</TOPIC>

<TOPIC> fclose() <style> function
fclose()

int fclose( int file)

<b>Description

Closes an opened file.

<b>Arguments

int		<t>file		<t>file-id returned by fopen.

<b>Example

<c>  int infile;
<c>  infile = fopen("some_file.txt","r");
<c>  ...
<c>  fclose( infile);
</TOPIC>

<TOPIC> exit() <style> function
exit()

int exit()

<b>Description

Terminates executions of the file.

<b>Example

<c>  exit();
</TOPIC>

<TOPIC> verify() <style> function
verify()

int verify( [int mode])

<b>Description

Sets or shows verification mode. If verification is on all executed lines will
be displayed on the screen.
Returns the current verification mode.

<b>Arguments

int		<t>mode		<t>verification on (1) or off (0). Optional.

<b>Example

<c>  verify(1);
</TOPIC>

<TOPIC> time() <style> function
time()

string time()

<b>Description

Returns the current time in string format.

<b>Example

<c>  string t;
<c>  t = time();
</TOPIC>

<TOPIC> edit() <style> function
edit()

string edit( string str)

<b>Description

Removes leading and trailing spaces and tabs, and replaces multiple tabs and
spaces with a single space.
Returns the edited string.

<b>Arguments

string		<t>str		<t>string to be edited.

<b>Example

<c>  collapsed_str = edit(str);
</TOPIC>

<TOPIC> extract() <style> function
extract()

string extract( int start, int length, string str)

<b>Description

Extracts the specified characters from the specified string.
Returns the extracted characters as a string.

<b>Arguments

int		<t>start	<t>start position of the first character.
				<t><t>First character has position 1.
int		<t>length	<t>number of characters to be extracted.
string		<t>str		<t>string from which characters should be extracted.

<b>Example

<c>  extracted_str = extract( 5, 7, str);
</TOPIC>

<TOPIC> element() <style> function
element()

string element( int number, string delimiter, string str)

<b>Description

Extracts one element from a string of elements.
Returns the extracted element.

<b>Arguments

int		<t>number	<t>the number of the element.
string		<t>delimiter	<t>delimiter character.
string		<t>str		<t>string of elements.

<b>Example

<c>  string str = "mary, lisa, anna, john";
<c>  string elem1;
<c>  elem1 = elment( 1, ",", str);
</TOPIC>

<TOPIC> toupper() <style> function
toupper()

string toupper( string str)

<b>Description

Convert string to upper case.

<b>Arguments

string		<t>str		<t>string to convert.

<b>Returns
string				<t><t>string in upper case.

<b>Example

<c>  string str1 = "Buster Wilson";
<c>  string str2;
<c>  str2 = toupper( str);
</TOPIC>

<TOPIC> tolower() <style> function
toupper()

string tolower( string str)

<b>Description

Convert string to lower case.

<b>Arguments

string		<t>str		<t>string to convert.

<b>Returns
string				<t><t>string in lower case.

<b>Example

<c>  string str1 = "Buster Wilson";
<c>  string str2;
<c>  str2 = tolower( str);
</TOPIC>

<TOPIC> translate_filename() <style> function
translate_filename()

string translate_filename( string fname)

<b>Description

Replace environment variables in filename.

<b>Arguments

string		<t>fname	<t>A filename.

<b>Returns
string				<t><t>String with expanded env variables.

<b>Example

<c>  string fname1 = "$pwrp_db/a.wb_load";
<c>  string fname2;
<c>  fname2 = translate_filename( fname1);
</TOPIC>

<TOPIC> wtt-commands <style> function
Wtt commands

All the wtt-commands is available in the script code. An wtt-command line
should NOT be ended with a semicolon. Variables can be substituted in the
command line by surrounding them with apostrophes.

<b>Example
 
<c>  string name = "PUMP-VALVE-Open";
<c>  string value = "The valve is open";
<c>  set attribute/name='name'/attr="Description"/value='value'

<b>Example

<c>  string name;
<c>  string parname;
<c>  int j;
<c>  int i;
<c>  for ( i = 0; i < 3; i++)
<c>    parname = "vkv-test-obj" + (i+1);
<c>    create obj/name='parname'
<c>    for ( j = 0; j < 3; j++)
<c>      name = parname + "-obj" + (j+1);
<c>      create obj/name='name'
<c>    endfor
<c>  endfor
</TOPIC>

<TOPIC> getattribute() <style> function
GetAttribute()

(variable type) GetAttribute( string name [, int status])

<b>Description

Get the value of the specified attribute. The returned type is dependent
of the attribute type. The attribute will be converted to int, float or string.

<b>Arguments

string		<t>name		<t>name of the attribute to be fetched.
int		<t>status	<t>status of operation. Returned. If zero, the
		<t>		<t>attribute could not be fetched. Optional.

<b>Example

<c>  int alarm;
<c>  int sts;

<c>  alarm = GetAttribute("Roller-Motor-Alarm.ActualValue");
<c>  on = GetAttribute("Roller-Motor-On.ActualValue", sts);
<c>  if ( !sts)
<c>    say("Could not find motor on attribute!");
</TOPIC>

<TOPIC> getchild() <style> function
GetChild()

string GetChild( string name)

<b>Description

Get the first child of an object. The next children can be fetched with
GetNextSibling().
Returns the name of the child. If no child exists a null-string is returned

<b>Arguments

string		<t>name		<t>name of object.

<b>Example

<c>  string child;

<c>  child = GetChild("Roller-Motor");
</TOPIC>

<TOPIC> getparent() <style> function
GetParent()

string GetParent( string name)

<b>Description

Get the parent of an object.
Returns the name of the parent. If no parent exists a null-string is returned.

<b>Arguments

string		<t>name		<t>name of object.

<b>Example

<c>  string parent;

<c>  parent = GetChild("Roller-Motor");
</TOPIC>

<TOPIC> getnextsibling() <style> function
GetNextSibling()

string GetNextSibling( string name)

<b>Description

Get the next sibling of an object.
Returns the name of the sibling. If no next sibling exists a null-string is
returned.

<b>Arguments

string		<t>name		<t>name of object.

<b>Example

<c> string name;
<c> int not_first;

<c> name = GetChild("Rt");
<c> not_first = 0;
<c> while ( name != "")
<c>   if ( !not_first)
<c>     create menu/title="The Rt objects"/text="'name'"/object="'name'"
<c>   else
<c>     add menu/text="'name'"/object="'name'"
<c>   endif
<c>   not_first = 1;
<c>   name = GetNextSibling(nname);
<c> endwhile
<c> if ( !not_first )
<c>   MessageError("No objects found");
</TOPIC>

<TOPIC> getclasslist() <style> function
GetClassList()

string GetClassList( string class)

<b>Description

Get the first object of a specified class. The next object of the class
can be fetched whith GetNextObject().
Returns the name of the first object. If no instances of the class exists a
null-string is returned.

<b>Arguments

string		<t>name		<t>name of class.

<b>Example

<c>  string name;

<c>  name = GetClassList("Dv");
</TOPIC>

<TOPIC> getnextobject() <style> function
GetNextObject()

string GetNextObject( string name)

<b>Description

Get the next object in a classlist.
Returns the name of the object. If no next object exist a null-string is
returned.

<b>Arguments

string		<t>name		<t>name of object.

<b>Example

<c>  string name;

<c>  name = GetClassList("Di");
<c>  while ( name != "")
<c>    printf("Di object found: %s", name);
<c>    name = GetNextObject(name);
<c>  endwhile
</TOPIC>

<TOPIC> getobjectclass() <style> function
GetObjectClass()

string GetObjectClass( string name)

<b>Description

Get the class of an object.
Returns the name of the class.

<b>Arguments

string		<t>name		<t>name of object.

<b>Example

<c>  string class;

<c>  class = GetObjectClass("Motor-Enable");
</TOPIC>

<TOPIC> getnodeobject() <style> function
GetNodeObject()

string GetNodeObject()

<b>Description

Get the node object.
Returns the name of the node object.

<b>Example

<c>  string node;
<c>  node = GetNodeObject();
</TOPIC>

<TOPIC> getrootlist() <style> function
GetRootList()

string GetRootList()

<b>Description

Get the first object in the root list.
Returns the name of the root object. The next object in the root list can be
fetched with GetNextSibling().

<b>Example

<c>  string name;

<c>  name = GetRootList();
<c>  while( name != "")
<c>    printf( "Root object found: %s", name);
<c>    name = GetNextSibling(name);
<c>  endwhile
</TOPIC>

<TOPIC> getnextvolume() <style> function
GetNextVolume()

string GetNextVolume( string name)

<b>Description

Get the next volume. The first volume is fetched widh GetVolumeList().
Returns the name of the volume. If there is no next volume, a null-string
is returned.

Argument

string          name            name of volume.
</TOPIC>

<TOPIC> getvolumeclass() <style> function
GetVolumeClass()

string GetVolumeClass( string name)

<b>Description

Get the class of a volume.
Returns the classname.

<b>Argument

string          name            volume name.

<b>Example

<c>  string class;

<c>  class = GetVolumeClass("CVolVKVDKR");
</TOPIC>

<TOPIC> getvolumelist() <style> function
GetVolumeList()

string GetVolumeList()

<b>Description

Get the first volume in the volumelist.
Returns the name of the volume. The next volume will be fetched with
GetNextVolume().

<b>Example

<c>  string name;

<c>  name = GetVolumeList();
<c>  while( name != "")
<c>    printf( "Volume found: %s", name);
<c>    name = GetNextVolume(name);
<c>  endwhile
</TOPIC>

<TOPIC> setattribute() <style> function
SetAttribute()

int SetAttribute( string name, (arbitrary type) value)

<b>Description

Set the value of an attribute.
The attribute is specified with full object and
attribute name.
Returns the status of the operation.

<b>Argument

string          name            attribute name.
arbitrary type  value		attribute value.

<b>Example

<c>  SetAttribute( "Pump-V1-Switch.Description", "Valve switch open");
</TOPIC>

<TOPIC> getprojectname() <style> function
GetProjectName()

string GetProjectName()

<b>Description

Get the project name.
Returns the name of the project.

<b>Example

<c>  string name;

<c>  name = GetProjectName();
</TOPIC>

<TOPIC> checksystemgroup() <style> function
CheckSystemGroup()

int CheckSystemGroup()

<b>Description

Check if a system group exists.
Returns 1 if the system group exist, else 0.

<b>Example

<c>  if ( !CheckSystemGroup( "MyGroup"))
<c>    return;
<c>  endif
</TOPIC>

<TOPIC> cutobjectname() <style> function
CutObjectName()

string CutObjectName( string name, int segments)

<b>Description

Cut the first segments of an object name.
Returns the last segments of an object name. The number of segments left is
specified by the second argument

<b>Arguments

string		<t>name		<t>Path name of object.
int		<t>segments	<t>Number of segments that should be left.

<b>Example

<c>  string path_name;
<c>  string object_name;

<c>  path_name = GetChild("Rt-Motor");
<c>  object_name = CutObjectName( path_name, 1);
</TOPIC>

<TOPIC> messageerror() <style> function
MessageError()

string MessageError( string message)

<b>Description

Print an error message on the screen.

<b>Example

<c>  MessageError("Something went wrong");
</TOPIC>

<TOPIC> messageinfo() <style> function
MessageInfo()

string MessageInfo( string message)

<b>Description

Print an rtt info message on the screen.

<b>Example

<c>  MessageInfo("Everything is all right so far");
</TOPIC>

<TOPIC> getcurrenttext() <style> function
GetCurrentText()

string GetCurrentText()

<b>Description

Get the text of the current menu item or update field.

<b>Example

<c>  string text;

<c>  text = GetCurrentText();
</TOPIC>

<TOPIC> getcurrentobject() <style> function
GetCurrentObject()

string GetCurrentObject()

<b>Description

Get the object associated with the current menu item.
If no object is associated, a null-string i returned.

<b>Example

<c>  string object;

<c>  object = GetCurrentObject();
</TOPIC>

<TOPIC> getcurrentvolume() <style> function
GetCurrentVolume()

string GetCurrentVolume()

<b>Description

Get the attached volume.
If no volume is attached, a null-string i returned.

<b>Example

<c>  string current_volume;

<c>  current_volume = GetCurrentVolume();
<c>  set volume/volume=SomeOtherVolume
<c>  ...
<c>  set volume/volume='current_volume'

</TOPIC>

<TOPIC> isw1() <style> function
IsW1()

int IsW1()

<b>Description

Returns 1 if the current focused window in wtt is the Plant hierarchy window.
Otherwise returns 0.
</TOPIC>

<TOPIC> isw2() <style> function
IsW2()

int IsW2()

<b>Description

Returns 1 if the current focused window in wtt is the Node hierarchy window. 
Otherwise returns 0. 
</TOPIC>

<TOPIC> editmode() <style> function
EditMode()

int EditMode()

<b>Description

Returns 1 if wtt is int edit mode.
Otherwise returns 0. 
</TOPIC>

<TOPIC> messagedialog() <style> function
MessageDialog()

MessageDialog( string title, string text)

<b>Description

Display a message dialog box.

<b>Arguments

string		<t>title	<t>Title.
string		<t>text		<t>Message text.

<b>Example

<c>  MessageDialog( "Message", "This is a message");
</TOPIC>

<TOPIC> confirmdialog() <style> function
ConfirmDialog()

int ConfirmDialog( string title, string text [, int cancel])

<b>Description

Display a confirm dialog box.
Returns 1 if the yes-button is pressed, 0 if the no-button i pressed. 
If the third argument (cancel) is added, a cancel-button is displayed.
If the cancel-button i pressed or if the dialogbox is closed, 
the cancel argument is set to 1.

<b>Arguments

string		<t>title	<t>Title.
string		<t>text		<t>Confirm text.
int		<t>cancel	<t>Optional. A cancel button is displayed.
		<t>		<t>Cancel is set to 1 if the cancel-button is 
		<t>		<t>pressed, or if the dialog-box is closed.

<b>Example 1

<c>  if ( ! ConfirmDialog( "Confirm", "Do you really want to..."))
<c>    printf( "Yes is pressed\n");
<c>  else
<c>    printf( "No is pressed\n");
<c>  endif

<b>Example 2

<c>  int cancel;
<c>  int sts;

<c>  sts =  ConfirmDialog( "Confirm", "Do you really want to...", cancel);
<c>  if ( cancel)
<c>    printf("Cancel is pressed\n);
<c>    exit();
<c>  endif

<c>  if ( sts)
<c>    printf( "Yes is pressed\n");
<c>  else
<c>    printf( "No is pressed\n");
<c>  endif
</TOPIC>

<TOPIC> continuedialog() <style> function
ContinueDialog()

ContinueDialog( string title, string text)

<b>Description

Display a message dialog box with the buttons 'Continue' and 'Quit'.
Returns 1 if continue is pressed, 0 if quit is pressed.

<b>Arguments

string		<t>title	<t>Title.
string		<t>text		<t>Message text.

<b>Example

<c>  if ( ! ContinueDialog( "Message", "This script will...");
<c>    exit();
<c>  endif
</TOPIC>

<TOPIC> promptdialog() <style> function
PromptDialog()

int PromptDialog( string title, string text, string value)

<b>Description

Display a prompt dialog box which promps for a input value.
Returns 1 if the yes-button is pressed, 0 if the cancel-button i pressed,
or if the dialogbox is closed.


<b>Arguments

string		<t>title	<t>Title.
string		<t>text		<t>Value text.
string		<t>value	<t>Contains the entered value.

<b>Example

<c>  string name;

<c>  if ( PromptDialog( "Name", "Enter name", name))
<c>    printf( "Name : '%s'\n", name);
<c>  else
<c>    printf( "Cancel...\n");
<c>  endif

</TOPIC>
<TOPIC> opengraph() <style> function
OpenGraph()

int OpenGraph( string name, int modal)

<b>Description

Open a Ge graph.
If modal is selected, the execution of the script is continued when
the graph is closed.

<b>Arguments

string		<t>name		<t>Graph name.
int		<t>modal	<t>Modal.

<b>Example

<c>  OpenGraph( "pwr_wizard_frame", 0);

</TOPIC>

<TOPIC> closegraph() <style> function
CloseGraph()

int CloseGraph( string name)

<b>Description

Close a Ge graph.

<b>Arguments

string		<t>name		<t>Graph name.

<b>Example

<c>  CloseGraph( "pwr_wizard_frame");

</TOPIC>

<TOPIC> setsubwindow() <style> function
SetSubwindow()

int SetSubwindow( string name, string windowname, string source, int modal)

<b>Description

Open a Ge graph in a window object in a previously opened graph.
If modal is selected, the execution of the script is continued when
the command 'release subwindow' is executed by a pushbutton in the graph.

<b>Argument

string		<t>name		<t>Name of the main graph.
string		<t>windowname	<t>Name of the window object in which
		<t>		<t>the source graph is to be opened.
string		<t>source	<t>Name of the graph that is to be opened
                <t>             <t>in the window object.
int		<t>modal	<t>Modal.
<b>Exempel

<c>  SetSubwindow( "pwr_wizard_frame", "Window1", "MyGraph", 1);

</TOPIC>
</chapter>





