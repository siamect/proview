
<topic> __DocumentTitlePage

<image> pwr_logga.gif






<h1> Handbok för
<h1> konstruktörer




















<hr>
2010-07-16
Version 4.7.0	
<hr>
</topic>

<topic> __DocumentInfoPage


Copyright 2010 SSAB Oxelösund AB

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts.




</topic>


<chapter>
<topic> introduction
Inledning

Proview är ett modernt, kraftfullt och generellt process styr system. Det innehåller alla
funktioner som normalt krävs för effektiv sekvensstyrning, reglering, datainsamling,
kommunikation, övervakning mm.

Konfigureringen av ett Proview system görs grafisk, vilket gör att anpassningen till en
tillämning blir enkel, pålitlig och flexibel. Proview är ett distribuerat system, vilket
innebär att systemet består av flera datorer sammankopplade i ett nätverk. Via nätverket
utbyter datorerna ata med varandra. På det här sättet blir, t ex uppmätta signalvärden,
åtkomliga på alla process- och operatörsstationer i ett Proview system. 

Ett Proview system är definierat med objekt. Varje objekt representerar en fysisk eller
abstrakt enhet i systemet. Objekten ordnas i en hierarktisk trädstruktur, vilket gör
det möjligt att ge en strukturerar beskrivning av systemet. Trädstrukturen influerar också
en hierarktisk namngivning av alla objekt. Genom att noggrant välja namn vid konfigureringen
av ett system, kommer det fullständiga objektsnamnet att identifiera dess funtion, eller roll
i systemet.

Hierarkierna är uppdelade i två grupper, en kallas anläggningshierarkin, och beskriver 
systemet ur ett logiskt perpektiv. Den andra kallas nodhierarkin, och beskriver systemet ur
ett fysiskt perspektiv. Konfigureringen av dessa olika delar kan göras oberoende av varandra.
Slutligen kopplas de två delaran ihop.

För att konfigurera ett system använder man Proview's arbetsbänk. Arbetsbänken omfattar en
permanent databas och ett antal verktyg för att konfigurera de objekt som behövs för att
konfigurera ett system. Utifrån arbetsbänken skapar man ett körbart system, liksom 
dokumentation om systemet.

Avsikten med Proview är att hjälpa dig att skapa automatierarde system. Antag att du har en
process som du vill styra, Proview hjälper dig att skapa styrsystemet för processen, och
när systemet är skapat, finner du att du även har gjort dokumentationen för systemet.
</topic>
</chapter>

<option> printdisable
<topic> index
Konstruktörs handbok

<image> pwr_logga.gif

<h1>Konstruktörshandbok

Översikt <link> design_overview
Databas struktur <link> database_structure
En fallstudie <link> case_study
Administration <link> administrator
Konfigurera direktoryvolymen <link> configure_directoryvolume
Konfigurera rotvolymen <link> configure_rootvolume
Plc programmering <link>plc_programming
Skapa processbilder <link> ge_man
Java operatörsmiljö <link> dg_web_iterface
Starta och testa systemet <link> conf_test

<b>Referens manualer
Konfiguratören <link> configurator_refman
Objektseditorn Referensmanual<link> objecteditor_refman
Spreadsheeteditorn Referensmanual<link> spreadsheeteditor_refman
Plceditorn Referensmanual <link> plceditor_refman
Klasseditorn Referensmanual <link> classeditor
OPC <link> opc_intro
Commands <link> help command
Script <link> script
</topic>
<option> printenable

<chapter>
<topic> design_overview
Översikt

Eftersom det här är en handledning för konstruktörer kan det vara lämpligt att inleda med en 
beskrivning av vad designen av ett styrsystem innebär. Beskrivningen kan även fungera som en 
introduktion till de olika begrepp som kommer att användas i den här handledningen.

En konstruktör utgår naturligtvis från den process som styrsystemet ska styra, och den första 
uppgiften är att lära sig processen och fundera över bästa sättet att styra den: vilka 
reglerloopar som behövs, vilka förreglingar som ska finnas, hur anläggningen startas upp och 
stoppas, hur operatörer och underhållare ska arbeta mot systemet. Detta sammanfattar man i 
en Funktions specification.

Samtidigt måste man fundera på vilken information om processen som  styrsystemet behöver för 
att kunna utföra sin uppgift, dvs vilka givare som ska placeras i anläggningen. Styrsystemet 
måste även kunna påverka processen genom på olika sätt, t ex mha ventiler och motorer. Detta 
resulterar i en Signal lista, som är lista på alla in och utgående signaler till systemet.

I det här läget dyker även frågan upp om vilket styrsystem man ska använda sig av, och ett
alternativ är naturligtvis Proview. Man måste även bestämma sig för vilket I/O-system man ska 
använda, och hur man ska dela upp funktionen i olika processstationer.

<h1>I/O-system
I/O-systemet uppgift är att ta in signaler från processen till styrsystemet, och att ställa 
ut  signaler för att påverka processen. Signalerna är vanligtvis digitala eller analoga, men
det finns även andra typer som heltalsvärden och pulsgivare. Man kan välja mellan rack
och kort system i anslutning till datorn, eller distributerat I/O som t ex profibus.

<h1>Konfigurering
När det är dags att börja konfigurera system, skapar man först ett nytt Projekt i 
Administratören. Administratören ett verktyg för skapa ordning och reda bland alla projekt, 
eftersom dessa kan bli ganska många med tiden.

Konfigureringen av ett system sker till stor del genom att skapa objekt i en databas,
arbetsbänken. Det finns en stor mängd olika objekt för att konfigurera allt från IO-kanaler 
till processbilder. Proview's objektshandbok innehåller över 800 typer av objekt. Objekten 
läggs upp  i en trädstruktur och  man använder ett verktyg som kallas för Konfiguratören
för att skapa objekt och för att navigera i objektsträdet.

Objektsträdet delas in i två delar, anläggningshierakin och nodhierakin. 
Anläggningshierakin speglar olika funktioner i anläggningen och processen, medan 
nodhierakin speglar styrsystemets uppbyggnad ur hårdvaru synpunkt med datorer, I/O-rack och 
I/O-kort.

När man senare startar upp styrsystemet i runtime, skapas en kopia av objektträdet som 
läggs in i en realtidsdatabas, rtdb. Överföringen från arbetsbänken till rtdb sker med s k 
laddatafiler, filer som genereras från arbetsbänken och som innehåller alla objekt som finns 
i denna.


<h1>Styrprogram
Proview innehåller ett grafisk programmeringsspråk med vilket man programmerar logik, 
grafcet-sekvenser och reglerkretsar. Det går under benämningen PLC program. Även PLC 
programmet ingår som en del av objektträdet. Det konfigureras genom att man placerar ut 
speciella program objekt, PlcPgm, i anläggninghierarkin. När man öppnar ett PlcPgm kommer 
man in PlcEditorn, i vilken man gör den grafiska programmeringen. Här skapas funktionsobjekt
som binds samman i ett signalflöde av digitala och analoga signaler, där ingångssignaler
hämtas upp på vänstersidan, tranformeras i olika funktionsblock för att slutligen ställas ut 
till utsignaler på högersidan.

Ett komplement till PLC programmet är applikations-program, som skrivs i c, c++ eller java. 
Applikationer skrivs och startas som fristående program och knyter upp sig mot 
realtidsdatabasen mha ett API.

<h1>Simulering
Realtidsdatabasen, PLC-programmet och eventuella applikationer kan enkelt startas upp på 
utvecklingsstationen. Det här gör att man kan testa sina progam i direkt anslutning till 
programmerandet. Man kan även skriva speciella simulerings-program som läser 
utgångssignaler, simulerar den påverkan utgångarna har på processen, beräknar värden på 
olika givare och sätter dessa värden i ingångssignaler.

Konfigureringen och programmeringen av systemet blir då en process, där man växelvis 
konfigurerar/programmerar och testar. Resultatet blir väl avlusade program och en snabb och 
effektiv igångkörning av anläggningen. Det leder även till bättre program och mer 
genomarbetade funktioner, eftersom återkopplingen blir större i den kreativa process som 
konstruktionen av ett styrsystem innebär.

Vid simuleringen och igångkörning är det av yttersta vikt att ha tillgång till verktyg gör att
man kan övervaka och undersöka systemet, och snabbt lokalisera eventuella fel. I Proview kallas
det här verktyget Xtt. Xtt innehåller en mängd funktioner för undersöka innehållet i 
realtidsdatabasen, för att följa signalflöden, logga snabba eller långsamma förlopp, etc. 

<h1>Operatörs gränssnitt
Det finns en rad olika yrkesgrupper som ska kunna komma åt systemet, operatörer som sköter den 
dagliga driften, underhållare som dyker upp när något har gått fel, process ingenjörer som vill
ha ut process data av olika slag. Alla har olika krav på gränssnitt mot systemet. Dessutom kan 
gränserna mellan olika yrkesgrupper vara flytande, operatörer som är både operatörer och 
underhållare, och kanske även processtekniker. Detta ställer stora krav på funktionalitet och
flexibilitet i operatörsgränssnitten.

Proview innehåller en operatörsmiljö där processbilder, felsökningsverktyg, presentation av 
trendkurvor, datablad, hjälptexter, larmlistor mm är väl integrerade och länkade så att den 
rätt konfigurerad, blir ett oerhört effektivt hjälpmedel för alla användare. Man kan snabbt 
och enkelt genom s k metoder, som aktiveras från popupmenyer, hämta upp all information som 
finns om olika objekt, i realtidsdatabasen eller på olika serversystem, i form av PLC kod, 
trendkurvor, datablad mm.

<h1>Processbilder
Processbilder byggs i en grafisk editor (Ge). Grafiken är vektorbaserad, vilket gör att alla
bilder och komponenter kan skalas obegränsat. Komponenter har en förprogrammerad dynamik för
att ändra färg och form beroende på signaler i realtidsdatasen, eller reagera på musklick och
sätta värden i databasen. På varje komponent som är känslig för musklick eller inmatning kan
man ange behörighet, och selektivt tillåta, eller hindra, användare att påverka systemet.
Processbilderna kan, förutom att användas i den ordinare operatörsmiljön, exporteras som i
java-kod för att visas på webben med full dynamik.

<h1>Övervakning
Om något fel uppstår i processen, måste operatören uppmärksammas på detta. Det sker med 
speciella övervaknings-objekt, som konfigureras i anläggningshierakin eller i PLC-programmet, 
och som ger upphov till larm eller meddelanden. Larmen har fyra prioritets nivåer: A, B, C 
eller D, och presenteras för operatören i larmlistan, händelselistan och den historisk 
händelselistan.

Larmlistan inhåller okvitterade och rådande larm. Ett larm måste normalt kvitteras av 
operatören innan de försvinner från listan. Om larmtillståndet fortfarande är rådande, ligger 
larmet kvar i listan så länge det är rådande.

Larm registreras även i händelselistan, som presenterar händelser som inträffat i kronologisk 
ordning.

Historiska händelselistan är en databas som även den registrerar händelser. Här kan man söka 
efter larm med olika kriterier som prioritet och anläggningsdel.

Om en anläggningsdel ställs av kan man blockera larmen från den, så att operatören inte 
distraheras av larm utan betydelse. Blockerade anläggningsdelar visas in en Blockerings lista.

<h1>Datalagring
Ofta vill man kunna se hur en signal förändras över tiden, i form av en kurva. I Proview finns
tre olika funktioner för detta, DsTrend, DsFast och SevHist.

DsTrend är en trendkurva som lagras i realtidsdatabasen. Mätvärdet för en signal lagras
kontinuerligt med ett intervall på 1 sekund och uppåt. För varje kurva finns det plats för ca
500 mätvärden, så väljer man att lagra ett nytt värde varje sekund får man en kurva på hur
signalen har förändrats under ca 8 min.

SevHist lagrar signaler på liknande sätt i en databas på disk, vilket gör att man kan lagra
värden under längre perioder än DsTrend.

DsFast lagrar ofta snabbare förlopp, där lagringen startas på ett triggvillkor, och forsätter
under en specificerad tid, för att sedan presenteras i kurvform.
</topic>
</chapter>

<chapter>
<topic> database_structure
Databas struktur

Som vi har sett tidigare så sker största delen av konfigureringen av ett Proview system i en 
databas, Arbetsbänken. I Arbetsbänkan skapar man objekt i en träd-struktur, och varje objekt 
ger upphov till en viss funktion i styrsystemet. Proview är vad man brukar kalla objekts 
orienterat, och låt oss titta lite närmare på vad ett Proview-objekt egentligen är.

<option> printdisable
Objekt <link> object
Volymer <link> volume
Attribut <link> attribute
Klass <link> class
Objektsträd <link> object_tree
Objektsnamn <link> object_name
Montering <link> mounting
Objekts identitet <link> object_identity
<option> printenable

</topic>

<topic> object
Objekt
Ett objekt består av en datamängd, som på något sätt definierar objektets tillstånd eller
egenskaper. Datamängden kan vara mycket enkel, som t ex hos en Och-grind, där den består ett
boolskt värde som kan vara sant eller falskt. En PID regulator däremot, har en mera komplex 
datamängd. I denna finns förstärkning, integrationstid, utsignal, tvångsstyrning mm. Den 
består av en blandning av digitala, analoga och heltalsvärden. Vissa värden konfigureras i 
utvecklingsmiljön, medan andra beräknas i runtime.

Datamängden kallas objektets kropp. Kroppen är indelad i attribut, och varje attribut har ett
namn och en typ. Kroppen för en Och-grind består av attributet Status som är av typen
Boolean, medan kroppen för en PID regulator består av 47 st attribut: ProcVal, SetVal, Bias, 
ForceVal etc.

Alla PID objekt har sin datamänd strukturerad på samma sätt, och man säger att de tillhör
samma klass. PID objekten tillhör klassen PID och Och-grindarna tillhör klassen And. En klass
är en slags mall för hur objekt som tillhör klassen ska se ut, t ex vilka attribut som ingår,
och attributens namn och typ.

Förutom en kropp, har ett objekt även ett huvud. I huvudet ligger objektets klass, identitet,
namn och relation till andra objekt. Objekten är inordnade i en trädstruktur, och i huvudet 
finns länkar till objektets förälder och närmaste syskon.
</topic>

<topic>volume
Volymer
När man konfigurerar ett system och skapar objekt, vet man vanligtvis vilken nod objektet ska
tillhöra i runtime. Man skulle kunna dela in objekt efter vilka noder de kommer att tillhöra,
men man har valt en lite mer flexibel indelning, så istället delar man in objekten i volymer.
En volym är en slags behållare för objekt. Volymen har ett namn och en identitet, och den 
innehåller ett antal objekt ordnade i en trädstruktur.

Det finns ett antal olika typer av volymer, och den första man kommer i kontakt med är en
rotvolym. När man konfigurerar en nod, jobbar man vanligtvis i en rotvolym. Varje nod är 
kopplad till en rotvolym, vilket innebär att när noden startas i runtime, kommer rotvolymen,
och de objekt som finns in den, att laddas in i noden. Nedan följer en beskrivning på de olika
typer av volymer som finns.

<h2>RootVolume
En rotvolym innehåller roten till objektsträdet på en nod. När en nod startar, laddar den
in rotvolymen.

En nod är kopplad till en och endast en rotvolym. Däremot kan en rotvolym laddas in i flera
olika noder. Samtidigt som man kör processtationen i produktion, kan man ladda in samma
rotvolym i sin utvecklingsstation för simulering, och i en tredje nod för utbildning.
Man måste dock se till att de olika noderna går på olika kommunikations bussar.

<h2>SubVolume
En del av objekten på en nod kan man lägga i en subvolym. Anledningen till att dela upp
objekten i en nod i en rotvolym och en eller flera subvolymer, kan vara att flera personer
måste konfigurera noden samtidigt, eller att man planerar att flytta styrningen av vissa
anläggningsdelar till en annan nod så småningom.

<h2>ClassVolume
Definitionen av olika klasser ligger speciella volymer som kallas klassvolymer. Här byggs
beskrivningen av en klass upp med objekt som definierar klassens namn och vilka attribut
som ingår i klassen.

Det finns två stycken klassvolymer som man alltid måste ha med i ett Proview system, pwrs och
pwrb. pwrs innehåller systemklasser, framför allt klasser som används i 
klassdefinitionerna. pwrb innehåller basklasser, dvs standard klasser som behövs för att
bygga en process- eller operatörsstation.

<h2>DynamicVolume
En dynamisk volym innehåller dynamiska objekt, dvs objekt som skapas temporärt i runtime.
Om man har en materialföljnings modul i systemet, kan man skapa ett objekt för varje material
som behandlas i anläggningen, och ta bort det när materialet är färdigbehandlat.

<h2>SystemVolume
Systemvolymen är en dynamisk volym som finns i varje nod, och som innehåller diverse 
systemobjekt.

<h2>DirectoryVolume
Directory volymen är en volym som enbart finns i utvecklingsmiljön. I denna konfigurerar
man vilka volymer och noder som finns i systemet.

<h1>Volymsidentitet
Varje volym har en unik identitet, som skrivs med fyra tal, separerade med punkter, t ex
"_V0.3.4.23". Prefixet _V markerar att det är frågan om en volymsidentitet. För att
verifiera att volymsidentiteter är unika finns det en global volymslista som innehåller
alla volymer. Innan man skapar ett projekt, ska volymerna i projektet registreras i 
volymslistan.
</topic>

<topic> attribute
Attribut
Datamängden i ett objekt är indelat i attribut. Varje attribut har ett namn och en typ.
Här följer en beskrivning på de vanligaste attribut typerna.

<h2>Boolean
Digitala attribut är av typen boolean, som kan ha värdet sant (1) eller falskt (0).

<h2>Float32
Analoga attribut är av typen Float32, dvs ett 32-bitars flyttal.

<h2>Int32
Heltals attribut är vanligen av typen Int32, dvs ett 32-bitars heltal. Men det finns även
ett antal andra typer av heltal: Int8, Int16, Int64, UInt8, UInt16, UInt32 och UInt64.

<h2>String
I ett string-attribut kan man lagra en sträng av ascii-tecken. Det finns olika sträng typer
för olika längd på strängen, t ex String8, String16, String40, String80 och String256.

<h2>Time
Time innehåller en absoluttid, t ex 1-MAR-2005 12:35:00.00.

<h2>DeltaTime
DeltaTime innehåller en tidsskillnad, t ex 1:12:22.13 (1 timme, 12 minuter, 22.13 sekunder).

<h2>Enum
Enum är en uppräkningstyp, som används när man ska välja ett av ett antal alternativ. 
Den kan anta ett antal heltalsvärden, där varje värde är kopplat till ett namn. Det finns t ex 
en ParityEnum som kan ha värdet 0 (None), 1 (Odd) eller 2 (Even).
Enum är här en bastyp och ParityEnum en härledd typ.

<h2>Mask
Mask används när ska välja ett, eller flera av ett antal alternativ. Alternativen
representeras av bitarna i ett 32-bitars heltal. 

Ett attribut kan även bestå av en mer komplex datastruktur. Det kan vara en vektor med ett
visst antal element, och det kan faktisk också vara ett annat objekt, ett s k attributobjekt.
</topic>

<topic>class
Klass
En klass är en beskrivning på hur ett objekt som tillhör klassen ska se ut. Ett objekt som 
tillhör klassen kallas för en instans. I klassen definieras hur instansernas datamängd är
strukturerad i attribut av olika typ, eller hur objektet grafiskt ska representeras i 
PLCeditorn eller i operatörsmiljön.

Varje klass har ett template objekt, en instans av klassen som innehåller defaultvärden
för olika attribut i klassen.

Proview's bassystem innehåller ca 900 klasser. Se Objektshandboken för närmare beskrivning.
Konstruktören kan även skapa egna klasser inom ett projekt.
</topic>

<topic>object_tree
Objektsträd
Objekten i en volym är ordnade en trädstruktur. I volymen finns ett eller flera topp objekt,
varje topp objekt kan ett eller flera barn, vilka i sin tur kan ha barn, osv. Man brukar
tala om relationerna mellan objekt i trädet i termer av förälder, syskon, barn, förfader och 
ättlingar.
</topic>

<topic>object_name
Objektsnamn
Varje objekt har ett namn som är unikt inom sin syskonskara. Objektet har även ett
fullständigt namn som är unikt i världen. I det fullständiga namnet ingår, förutom 
objektsnamnet, även namnet på volymen och på samtliga förfäder, t ex 

<c>VolTrafficCross1:TrafficCross1-ControlSignals-Reset

Vill man vara ännu mer specifik, och peka ut ett attribut i ett objekt, hakar man på
attributnamnet på objektsnamnet med en punkt emellan, t ex

<c>VolTrafficCross1:TrafficCross1-ControlSignals-Reset.ActualValue

Även ett attribut kan ha flera namnled, eftersom ett attribut kan bestå av ett objekt.
Attribut namnleden separeras då av punkter, t ex

<c>VolTrafficCross1:Hydr-Valve.OpenSw.ActualValue
</topic>

<topic>mounting
Montering

En operatörstation ska kunna presentera värden på signaler och attribut som ligger i 
processtationernas volymer. Detta åstadkommer man genom att operatörsstationen monterar 
processnodernas volymer i det egna objektsträdet. En montering innebär att man hänger in ett 
objektträd från en annan volym i den egna rotvolymen. Var i trädet volymen ska hängas in 
konfigureras med ett MountObject objekt. I MountObject objektet anges vilket objekt i den andra 
volymen ska monteras. Resultatet blir att MountObject objektet presenteras som det monterade 
objektet, inklusive det objektträd som ligger under. Skenbart ser det ut som om objektet 
tillhör den egna rotvolymen, medan de i själva verket ligger på en annan nod.

Om man använder sig av subvolymer måste även dessa monteras i en rotvolym för att objekten
ska bli tillgängliga.

När man väljer monteringspunkter och namn på monteringsobjekt, är det lämpligt att göra detta
så att objektet får samma hierakinamn i båda volymerna.
</topic>

<topic>object_identity
Objektsidentitet
Ett objekt har en identitet som är unik. Den består av volymsidentiteten och ett 
objektindex som är unikt inom volymen. En objektsidentitet skrivs t ex "_O0.3.4.23:34" där
0.3.4.23 är volymsidentiteten och 34 objektindex. Prefixet _O markerar att det är en 
objektsidentitet.
</topic>
</chapter>

<chapter>
<topic>case_study
En fallstudie

<option> printdisable
Specification av I/O <link>io_specification
Administration <link> administration
Konfigurering av anläggningshierakin <link> plant_configuration
Konfigurering av nodhierakin <link> node_configuration
PLC program <link> plcprogram
Processbilder <link> process_graphics

<option> printenable
I det här kapitlet ska vi ge en idé om hur ett Proview system skapas. Processen som ska
styras i det här fallet är mycket enkel, en korsning mellan fyra trafikljus, men kommer att
ge ett begrepp om de olika steg man ska genomgå för att skapa ett Proview system.

Trafikljuset ska kunna arbeta i två olika moder:

  - Normal: trafikljusen går i den normala cykeln röd, gul och grön.
  - Blinkande: trafikljusen blinkar gult.

<image> dg_fig1.gif
<b>Trafikljusen i en korsning

Arbetsmoden för trafikljuset bestäms av en operatör via en operatörsstation, eller av en
underhållstekniker som påverkar ett vred. Underhållsteknikern kan ändra mod endast om 
operatören har ställt trafikljusen i service mod.

Figuren 'Trafikljus, kontrollpanel' visar de olika vred och indikatorer som krävs av
operatören resp underhållsteknikern, för att kunna övervaka och styra systemet. Dessa kan
implementeras som processbilder på operatörsstationen eller med hårdvara.

<image> dg_fig2.gif
<b>Trafikljus, kontrollpanel
</topic>

<topic> io_specification
Specifikation av I/O
Vi börjar med att analysera processen för att bestämma vilken hårdvara vi ska använda.

<h2>Digitala utgångar
Vi har fyra trafikljus, men trafikljusen på samma gata kan parallellkopplas, vilket betyder 
att vi kan behandla dem som två ljus.

Tre utgångar per ljus: 2 * 3 = 6
Indikator: Operating mode 1
Indikator: Control 1
------------------------------
Total antal digitala utgångar: 8

<h2>Digitala ingångar
Den enda digitala ingång som behövs är för underhållsteknikerns vred. Operatören styr 
processen från sin operatörsstation och kräver inga fysiska signaler.

Omkopplare: Operating mode 1
------------------------------
Totalt antal digitala ingångar: 1

<h2>Analogt I/O
Analoga in- eller utgångar behövs inte i det här fallet.

<h2>Specifikation av processtationen
När vi har bestämt det I/O som krävs, kan vi välja hårdvara för processtationen. Vi väljer:

1 Linux PC med rack.
1 kort med 16 digitala ingångar.
1 kort med 16 digitala utgångar.

<h2>Specifikation av operatörsstationen

1 Linux PC.

<h2>Specifikation av process grafik.
Vi behöver en skärm från vilken operatören kan styra och övervaka trafikljusen.
</topic>

<topic> administration
Administration

Först måste vi registrera en ny volym, skapa ett projekt, och eventuellt skapa nya användare.
För detta krävs:

- Ett namn för projektet. Vi kallar det trafficcross1.
- Två volymer, en för processtationen och en för operatörsstationen.
- Vi behöver tre användare: en utvecklare, en operatör och en underhållstekniker.

Volymer, projekt och användare skapas och registreras med 'administratören'.

<h2>Registrera volymer
För det här projektet behövs två volymer, en för processtationen, och en för 
operatörsstationen. De är rotvolymer så vi kan välja lediga volymsidentiteter i intervallet
0.1-254.1-254.1-254. Vi väljer 0.1.1.1 till processtationen och 0.1.1.2 till 
operatörsstationen, och går in i volymsmod i administratören för att registrera volymerna.

<image> dg_fig11.gif
<b>Registrering av volymer

<h2>Användare
Eric är utvecklare vid trafikavdelningen, Carl är operatör och Lisa är underhållstekniker.
De är alla inblandade i samtliga projekt på trafikavdelningen, så vi skapar en gemensam
systemgrupp för all projekt, och låter dem dela användare. Vi tilldelar Eric utvecklings-
privilegier, Carl operatörspriviligier och Lisa underhållspriviligier.

<image> dg_fig4.gif
<b>Skapade användare

<h2>Skapa projekt
Vi skapar projektet med hierarkinamnet traffic-trafficcross1

<image> dg_fig10.gif
<b>Skapat projekt

<h1>Konfigurera projektet
Projektet har en direktoryvolym där noder och volymer i projektet ska konfigureras. I det
övre fönstret konfigureras volymerna med RootVolumeConfig objekt. I det under fönstret
konfigureras process- och operatörsstationerna med NodeConfig objekt. NodeConfig objektet
läggs under ett BusConfig objekt som anger vilken QCOM bus noderna ska kommunicera på.

NodeConfig objekten innehåller

- nodenamn
- ip adress för noden

Under varje NodeConfig objekt finns ett RootVolumeLoad objekt som anger vilken volym som
ska laddas in när runtimemiljön startas.

Notera också systemobjektet med attributet SystemGroup som tilldelas värdet 
"trafficdepartment". Detta ger användarna eric, carl och lisa tillgång till projektet. 

<image>dg_fig5.gif
<b>Directory volymen
</topic>

<topic> plant_configuration
Konfigurering av anläggninghierarkin
När konfigureringen av projektet är klar, kan vi börja ägna oss åt själva anläggningen.
Konfigureringen av anläggningen görs i Konfiguratören. Anläggningshierarkin är en logisk
beskrivning av verkligheten som ska styras och övervakas.

<h2>Processtationen
Den största delen av konfigureringen görs i processtationens volym, VolTrafficCross1. Det
är ju här som all kort, kanaler, signaler och PLC program ska konfigureras.

Anläggningshierarkin har en trädstruktur. Exempel på nivåer i hierarkin kan vara anlägging,
process, processdel, komponent och signal. Signaler är de logiska signaler som representeras
av signalobjekt, vilka kopplas till fysiska kanaler.

Ibland kan det vara svårt att konfigurera varje signal i ett inledande skede, men men måste
ändå bestämma hur tänkbara signaler ska grupperas.

Figuren nedan visar hur en anläggninghierarki har konfigurerats. Vi ser hur signaler ligger
på olika nivåer, och också hur Plc program är konfigurerade i anläggningshierarkin.

<image> dg_fig3.gif
<b>Exempel på anläggningshierarki

Vi väljer att kalla vår anläggning TrafficCross1 och bestämmer följande struktur:

- Två trafikljus, var och en bestående av en grön, en gul och en röd lampa. Eftersom gatorna
  ligger i Nord-Sydlig resp Väst-Östlig riktning, kallar vi dem TrafficLightNS and
  TrafficLightWE (West-East). Varje lampa behöver en signal, av typen digital utgång som vi
  kallar RedNSm, RedWE etc.

- Ett PLC program som styr trafikljuset.

- Ett antal styrsignaler för att välja arbetsmod och funktion. Vi väljer att lägga dem under
  en map, ControlSignals. Tabellen nedan visar de signaler som krävs.

<b>Signalnamn  <t>Signaltyp  <t>Funktion
ServiceSwitch  <t>Di <t>En omkopplare som underhållsteknikern kan påverka för att
               <t>   <t>ändra arbetsmod.
OperatorSwitch <t>Dv <t>Ett värde som operatören kak påverka för att ändra
               <t>   <t>arbetsmod.
ServiceMode    <t>Dv <t>Ett värde som underhållsteknikern kan påverka för att
               <t>   <t>servicemod.
ServiceModeInd <t>Di <t>En signal som visar underhållsteknikern att att 
               <t>   <t>programmet är i servicemod.
Mode           <t>Dv <t>Indikerar om programmet är i normal eller blinkande mod.
ModeInd        <t>Do <t>Indikerar om programmet är i normal eller blinkande mod.
Reset          <t>Dv <t>Ett värde för att återställa programmet i utgångsläge.


<bookmark> plant_example
<image> dg_fig6.gif
<b>Anläggningshierarkin för korsningen

På översta nivån finns ett anläggningsobjekt, TrafficCross1 av klassen $PlantHier. Vi 
använder andra objekt av klassen $PlantHier för att gruppera objekten. Vi skapar också ett
objekt som definierar ett PLC program, ControlPgm objektet av klass PlcPgm.

<h2>Operatörsstationen
Operatörstationens konfigurering görs i volymen VolOpTrafficCross1. På anläggningssidan
finns här endast ett monteringsobjekt, som gör att anläggningshierarkin i processnoden
blir tillgänglig på operatörsstationen. Vi har monterat det översta $PlantHier objektet,
'TrafficCross1' med ett MountObject med samma namn.

<image> dg_fig14.gif
<b>Anläggningshierarkin i operatörsvolymen
</topic>

<topic> node_configuration
Nod konfiguration

Efter anläggninghierarkin, ska nodhierakin konfigureras.

<h2>Processtation
I det här exemplet väljer vi att starta konfigureringen med processtationen. Vi benämner
den "cross1". Vi rekommenderar att men ger noderna beskrivande namn. I nodehierakin skapar
vi ett $NodeHier objekt 'Nodes' och under det ett $Node objekt 'cross1' som konfigurerar 
noden.

I anlysfasen beslutade vi att processtationen skulle bestå av följande hårdvara:

- 1 Linux PC
- 1 rack med 16 kortplatser
- 1 kort med 16 digitala ingångar (Di kanaler).
- 1 kort med 16 digitala utgångar (Do kanaler).

Rack och kort konfigureras på ett sätt som speglar den fysiska konfigureringen. Du placerar
ett rack i nod objektet, korten under rack objektet, och kanalerna under respektive kort 
objekt.

<image> dg_fig7.gif
<b>Nodehierarkin i processtationen

Vi konfigurerar även PLC programmet med ett PlcProcess objekt, och under detta ett
PlcThread objekt för varje tidbas. Vi nöjer oss med en tidbas på 100 ms. 

<image> dg_fig12.gif
<b>Konfigurering av tidbaser i PLC programmet

Varje objekt har att antal attribut som måste datasätta. För att ge en inblick i hur detta
går till visar vi några attribut i PlcProcess objektet.

<image> dg_fig13.gif
<b>Ändring av värden på attribut

<h2>Operatörsstation
Operatörsstationens nodhierarki konfigureras i volymen för denna VolOpTrafficCross1. Under
nod objektet finner vi ett OpPlace objekt som definierar operatörsplatsen, och under detta
ett User objekt som definierar en användare. Under OpPlace objektet finns även ett XttGraph
objekt för operatörsplatsens processbild.

<image> dg_fig8.gif
<b>Nodhierarkin i operatörsvolymen

<h1> Koppla kanaler till signaler
När både anläggnings- och nodehierarkin är konfigurerad, är det dags att koppla ihop logiska
signaler med fysiska kanaler. Varje logisk signal ska kopplas till en fysisk kanal, en Di
till en ChanDi, en Do till en ChanDo, en Ai till en ChanAi, en Ao till en ChanAo, etc.

Man kan se kopplingen som en representation av kopparkabeln mellan komponenten ute i
anläggningen och kanalen i I/O racken. I figuren nedan finns ju en kabel mellan omkopplaren
och kanal 0 på Di-kortet. Eftersom Di-signalen ServiceSwitch representerar omkopplaren, och
Di-kanalen Di4-00 representerar kanalen, måste vi göra en koppling även mellan dessa objekt.

<image> dg_fig15.gif
<b>Koppling mellan signal och kanal

<image> dg_fig9.gif
<b>Att koppla en signal till en kanal
</topic>

<topic>plcprogram
PLC program
Vi använder den grafiska PLC editorn för att skapa PLC program.

Innan vi börjar editera kopplar vi PlcPgm objektet till ett PlcThread objekt i nodhierarkin.
Detta avgör vilken tidbas som PLC programmet kommer att exekvera med.

<image> dg_fig16.gif
<b>Den grafiska PLC editorn

Vi kommer att använde GRAFCET för att skapa programmet för trafikljusen. Det finns två sätt
att lösa problemet med de två arbets moderna normal och blinkande:

1. Använda en GRAFCET sekvens med villkorlig förgrening, en gren för den normal mod och en
   och en för blinkande mod.
2. Använda två separata GRAFCET sekvenser med olika startvillkor.

Här väljer vi alternativ två. En mer detaljerad beskrivning av GRAFCET och 
sekvensprogrammering finns i kapitel Grafisk PLC programmering.

GRAFCET program bygger på att ett aktivt tillstånd förflyttas mellan olika steg en sekvens. 
I linjära sekvenser kan endast ett steg vara aktivt i taget. Till vare steg knyter man ett
antal order som ska exekveras när steget är aktivt. Detta kan vara att t ex sätta en digital
utgångssignal, som tänder en lampa. På så sätt styr PLC programmet de logiska signaler som
är kopplade till de fysiska kanalerna.

<image>dg_fig17.gif
<b>Sekvens för blinkande ljus

Figuren ovan visar sekvensen som exekveras när ljusen ska blinka gult.

Startvillkoret för sekvensen är inverterat jämfört med startvillkoret för sekvensen för 
normal arbetsmod. Det medför att de två sekvenserna inte kommera att exekvera samtidigt.

<image>dg_fig18.gif
<b>Normal sekvens

Programmet för den normala arbetsmoden bygger på att trafikljusen följer sekvensen:

<b>   <t>Nord-Syd   <t>Väst-Öst
1     <t>Röd        <t>Röd
2     <t>Röd, Gul   <t>Röd
3     <t>Grön       <t>Röd
4     <t>Gul, Grön  <t>Röd
5     <t>Röd        <t>Röd
6     <t>Röd        <t>Röd, Gul
7     <t>Röd        <t>Grön
8     <t>Röd        <t>Gul, Grön
9     <t>Tillbaka till steg 1

Programmet startar i initsteget. Om startvillkoret är uppfyllt, blir steg 1 aktivt och de
röda lamporna tänds. Efter en viss tid blir steg 1 inaktivt, och steg 2 aktivt, och en gul
lampa tänds, osv. När steg 8 har varit aktivt en viss tid, flyttas aktiviteten till 
initsteget igen och sekvensen börjar om, så längs startvillkoret är uppfyllt.

<image> dg_fig19.gif
<b>Trigg signaler

Programmet ovan visar logiken för att styra olika arbetsmoder.

Längst uppe till höger sätter man Dv signalen "Mode". Om den sätt till 1 kommer sekvensen
för normal arbetsmod att köras, annars körs sekvensen för blinkande ljus.

Dv signalen "Reset" kommer att vara att till 1 under ett exekverings varv när signalen
"Mode" ändrar värde. Detta medför att de två GRAFCET sekvenserna återgår till 
initialtillståndet med initstegen aktiva. Den valda sekvensen kommer sedan att startas igen
när Reset återställs till 0.

PLC programmet måste kompileras innan det kan köras på en processtation.
</topic>

<topic> process_graphics
Processbilder

Processbilder används ofta som gränssnitt mellan operatören och processen. Processbilder
skapas i den grafiska editorn.

<image> dg_fig20.gif
<b>Grafisk editor

Processbilder kan innehålla dynamik, som kopplas till de logiska signalerna, t ex

- Text som blir synlig när en signal har ett visst värde.
- Grafiska objekt som ändrar färg eller form när en signal för ett visst värde.
- Grafiska objekt som rör sig beroende på värdet av en signal.

Man kan även placera tryckknappar i en processbild, som operatören kan använda för att ändra
värden på digitala signaler. För att ändra analoga signaler använder man inmatingsfält.

I vårt exempel väljer vi att rita en processbild som visar vägkorsningen, där trafikljusen
(röda, gula och gröna) är dynamiska. Hur man skapar processbilder är beskrivet i kapitlet
Skapa processbilder.

<image>dg_fig21.gif
<b>Processbild för korsningen
</topic>
</chapter>

<chapter>
<topic>dg_create_project
Skapa ett project

<h1>Installation av utvecklingsmiljön

Innan man kan börja arbeta med Proview måste Proview's utvecklingsmiljö installeras. Det 
finns ett antal olika paket för olika Linux distributioner, och finns det inte något paket
för den önskade distributionen kan man även ladda hem Proview källkod och bygga från denna.

Installationspaketet för utvecklingsmiljön har namngivits med versionsnummer i namnet, 
t ex pwr47. Detta gör det möjligt att ha flera versioner installerade parallellt, vilket 
är en fördel när man har många projekt i produktion som går på olika versioner.

Mer information om installation finns på Download sidan på www.proview.se.

<h1>setup script
Installationen skapar Linux-användaren 'pwrp' med password 'pwrp'. Genom att logga in som 
pwrp kan man starta Proview genom att klicka på Proview ikonen på skärmen. 

Vill man köra Proview som en annan användare måste man initiera Proview vid inloggningen.
Lägg in följande rad i filen .bashrc på hemma katalogen

<c>source /src/pwrp/adm/db/pwr_setup.sh

Har man flera användare med gemensamma Proview projekt måste man se till att de har
skrivrättigheter på filer i projekten. Ett sätt att uppnå det är att sätta umask till 002,
dvs skrivrättighet för grupp, och ange en gemensam grupp på alla användare, t ex pwrp. 


<h1>Användare
I fallstudien ovan såg vi hur man kan skapa användare som tillhör olika systemgrupper.
Detta finns beskrivet i Administration kapitlet. Vid installationen av utvecklingspaketet
följer det med en användardatabas med en systemgrupp, common, och fem användare, pwrp, op1,
op2, op3 och op4. pwrp är utvecklings användare och har system-privilegier in runtime. op
användarna är operatörer och har operatörspriviliger i runtime. De här användarna fungerar
för många applikationer, och vi nöjer oss tills vidare med dessa. 

<image> dg_fig23.gif
<b>Användare som följer med vid installationen

Notera att om man bygger Proview från källkoden, måste man skapa användare innan man kan 
gå vidare och skapa ett projekt.

<h1>Registrera volymer
Som vi också såg i fallstudien kan man registrera volymer i GlobalVolumeList. Man kan även 
välja att vänta med detta och låta konfigurerings guiden för projeket registrera volymer 
och hämta ut nästa lediga volymsidentitet. För att inte fördjupa oss i detaljer låter vi 
tills vidare konfigurerings guiden registrera volymerna. Om man har flera oberoende 
utvecklingsstationer bör man registrera volymerna manuellt så att volymsidentitetera inte 
kolliderar. Har man större anläggningar med många volymer rekommenderar vi också att man 
tilldelar volymsidentiteter manuellt och grupperar på lämpligt sätt.

<h1>Skapa ett projekt
För att skapa ett project går man in i administratörens projektlista, antingen genom klicka
på Proview ikonen, eller med kommandot

<c>> pwra

pwra är definerad som 'wb -p pwrp pwrp' dvs loggar in som användare pwrp. Har man definerat
andra användare för utveckling måste man definiera om 'pwra' eller använda 'wb -p' kommandot
direkt. wb har användare och password som argument.

I projektlistan går man in i editerings mod och skapar ett ProjectReg objekt, på topp-nivå
eller under ett hierarki objekt. I ProjectReg objektet anger man projektnamn, 
Proview-version och katalog för projektet. När man sparar, skapas projekt-katalogerna för 
projektet.

Hur man skapar ett projekt finns närmare beskrivet i Getting Started Guide. Vi 
rekommenderar att går igenom avsnitten för att skapa projektet och konfigurere directory
volymen innan man fortsätter.

</topic>
</chapter>

<chapter>
<topic>configure_directoryvolume
Konfigurera Directory volymen

<h1>Öppna ett projekt
När projektet har skapas kan man hitta det i administratörens projektträd. Man öppnar ett
projekt genom att aktivera 'Open Project' i popupmenyn för ett ProjectReg objekt.

Man kan också använda 'sdf' kommandot för knyta upp sig mot ett project. Projektnamnet 
skickas med som argument till sdf.

<c>> sdf trafficcross1

Directory volymen kan sedan startas med

<c>> pwrs

pwrs är definerad som 'wb pwrp pwrp' dvs loggar in som användare pwrp. Har man definerat
andra användare för utveckling måste man definiera om 'pwrs' eller använda 'wb' kommandot
direkt. wb har användare och password som argument (och även volym som tredje argument).

<h1>Konfiguratören
Vi öppnar nu konfiguratören för directoryvolymen. I konfiguratören finns två fönster, i det
vänstra visas volymer i projektet, och i det högra noder.

Om volymen är tom, startas en guide som hjälper till med konfigureringen. För att skapa
ett enkelt projekt med en nod och en volym behöver man i princip bara klicka på 'Next' 
knappen. 

Guiden letar efter registrerade volymer för projektet. Om det inte finns några, ger
förslag på lämpliga volymsnamn och lediga volymsidentiteter, och registrerar volymerna om
förslagen godkänns. Guiden skapar också alla konfigurations-objekt i directory volymen och
sätter lämpliga data. 

Vill man senare utöka systemet med fler noder och volymer krävs att man har lite större 
insikt, vi gör därför en genomgång hur man konfigurerar för hand.

<h2>Konfigurera volymer
Först ska alla rotvolymer, subvolymer och klassvolymer i projekt konfigureras. Det gör man
i volymsfönstret i directoryvolymen. Vi börjar med att skapa ett RootVolumeConfig objekt
som konfigurerar en rotvolym.

- gå in i editeringsmod med 'Edit/Edit mode' i menyn. Nu blir paletten synlig till vänster
  i fönstret, och mappar kan öppna genom att klicka på mappen eller dubbelklicka på texten.
- Öppna volymsmappen och välj 'RootVolumeConfig' klassen.
- Klicka med MB2 (mittenknappen) i volymsfönstret, dvs det övre fönstret, och objektet
  skapas.
- Välj ut objektet och öppna objektseditorn från menyn 'Functions/Open Object'.
- Välj ut ObjectName och aktivera 'Functions/Change value' i objektseditorns meny.
- Skriv in objektets namn. Namnet ska vara detsamma som volymsnamnet.
- Stäng objektseditorn.

På samma sätt skapar man RootVolumeConfig objekt för alla rotvolymer i projektet. För nästa
objekt kan man påverka positionen på objektet. Om man klickar men MB2 på objektsnamnet på
ett objekt, kommer det nya objektet att bli syskon till detta objektet. Om man klickar på
löv eller map-symbolen, kommer objektet att bli barn.

Även subvolumer och klassvolymer konfigureras på motsvarande sätt med SubVolumeConfig och
ClassVolumeConfig objekt.

Man kan även visa attributen för ett objekt direkt i konfiguratören:

- Tryck på Shift tangenten och klicka med MB1 på objektet för att öppna objektet.
- Välj ett attribut och aktivera 'Functions/Change value' i menyn för att ändra ett värde.

<h2>Konfigurera noder
I det vänstra fönstret ska noderna i projektet konfigureras. Man delar in noderna efter 
vilken QCOM bus de kommunicerar på. Skapa därför två BusConfig objekt, ett för produktions 
noderna och ett för simulering. Öppna objekten och lägg in BusNumber.

Som barn till BusConfig objekten läggs nu ett NodeConfig objekt för varje process- och
operatörsstation. När NodeConfig objektet skapas, skapas ytterligar ett par objekt

- ett RootVolumeLoad objekt som anger vilken rotvolym som ska laddas in i den här noden vid 
  uppstart i runtime. Sätt namnet på objektet till detsamma som namnet på rotvolymen.
- ett Distribute objekt som konfigurerar som anger vilka filer som ska kopieras från
  utvecklingsmiljön till process- eller operatörsstationen.

Öppna NodeConfig objektet och lägg in nodnamn, operativsystem och ipaddress.

Under BusConfig objektet för simulering lägger man lämpligtvis in utvecklingsstationen, och
anger som RootVolumeLoad, den processtationsvolym som man först ska börja arbeta med. Det här
gör att man kan starta volymen i runtime och testa den på utvecklingsstationen. Ange
utvecklingsstationens nodnamn, operativsystem och ipaddress i NodeConfig objektet.

<b>System objekt
Skapa även ett $System objket in nodkonfigurations fönstret. Systemobjektet har attributen
SystemName och SystemGroup.

- Systemnamnet är än så länge ofta identiskt med projektnamnet.
- Systemgrupps attributet gör systemet medlem av en systemgrupp i användardatabasen. vilken
  definierar användare för systemet. När väl systemobjektet är skapat, måste man logga in
  med giltigt användarnamn och passerord i arbetsbänken.

<b>Spara
Spara sessionen med 'File/Save'. Om konfigurationen passerar syntax-kontrollen, får man
frågan om man vill skapa de konfigurerade volymerna. Svara Ok på dessa frågor och skapa
volymerna.

Om volymsväljaren öppnas nu, 'File/Open' i menyn, visas alla konfigurerade volymer. Nästa
steg är att konfigurera en rotvolym.
</topic>
</chapter>

<chapter>
<topic>configure_rootvolume
Konfigurera en rotvolym

En rootvolym öppnas från directory volymen genom att man högerklickar på ett VolumeConfig
objekt och aktiverar 'Open Project' i popupmenyn. 

Om man har gjort 'sdf' till projektet kan man även öppna med 'pwrs' kommandot genom att
skicka med volymsnamnet som argument.

<c>> pwrs voltrafficcross1

Detta startar konfiguratören för rotvolymen. Liksom för directoryvolymen är den separerad 
i två fönster, men nu visar det övre fönstret anläggingshierarkin och det undre 
nodehierarkin.

Om man öppnar en tom volym, startas en guide för att konfigurera volymen. Guiden 
konfiguerar nod hierarkin genom att skapa diverse objekt för server processer mm, men
man kan även skapa dessa för hand, se nedan.

<h1>Konfigurering av anläggningshierarkin
I anläggningshierarkin beskrivs de olika anläggningarna som finns med i Proview systemet.
En anläggning är en logisk beskrivning av t ex en produktions process, funkioner, utrustning
som ska styras och övervakas. 
Se exempel på anläggningshierarki <link>plant_configuration, plant_example

<h2>$PlantHier objekt
Top objekten i anläggnings hierarkin är $PlantHier objekt. Detta objekt identifierar
anläggningen, eller delar av den.

$PlantHier objektet används för att gruppera objekt, och strukturera anläggningen. Objektet
kan t ex användas för att gruppera signalobjekt.

<h2>Signal objekt
Signalobjekten definerar en logisk signal, eller punkt, och representerar en enhet eller
ett värde någonstans i processen, till skillnad från kanalobjekten som definierar fysiska
signaler. Signalobjekten är generiska, dvs de kan användas med vilket I/O-system som helst.

Det finns några klasser av signaler som inte kan kopplas till kanaler, Dv, Iv, Av och Sv
(DigitalValue, IntegerValue, AnalogValue and StringValue). Dessa objekt används för att
lagra digitala värden, heltalsvärden, analoga värden resp teckensträngar.

Signalens värde definieras av attributet ActualValue.

Följande signalobjekt finns tillgängliga för närvarande:

Ai <t>Analog ingång.
Ao <t>Analog utgång.
Av <t>Analogt värde.
Ii <t>Heltalsingång.
Io <t>Heltalsutgång.
Iv <t>Heltalsvärde.
Di <t>Digital ingång.
Do <t>Digital utgång.
Po <t>Pulsad digital utgång.
Dv <t>Digitalt värde.
Co <t>Pulsgivar ingång.
Sv <t>Sträng värde.

Obs! PLC programmet kan läsa signaler placerade på andra noder, men kan inte skriva i dem.

<h2>PlcPgm objekt
PlcPgm objektet definierar ett PLC program. Det är möjligt att ha flera PLC program i en
anläggning. Följande attribut måste datasättas:

- ThreadObject identifierar den plctråd som programmet ska exekvera i. Den refererar ett
  PlcThread objekt i nodkonfigurationen.
- Om programmet innehåller en GRAFCET sekvens, måste ett återställningsobjekt anges i 
  ResetObject. Detta är en Dv, Di eller Do återställer sekvensen till utgångsläget. 

<bookmark> backup_object 
<h2>Backup objekt
Backup objektet används för att peka ut ett objekt eller attribut, som ska backas upp. Det
anger även om lagringen ska utföras med den snabba eller långsamma cykeln.

<h2>MountObject
MountObject objektet monterar ett objekt i en annan volym. I attributet Object specificerar
man det objekt som ska monteras.

<h1>Konfigurering av nodhierarkin
I nodhierarkin definieras noderna i Proview systemet.

<b>Nodhierakin
<image> dg_fig44.gif

<h2>$NodeHier objekt
$NodeHier objektet används för att gruppera objekt i nodhierarkin. Objektet kan användas för
att gruppera t exe $Node objekt eller XttGraph objekt.
Se $NodeHier i Objektshandboken <classlink>nodehier,"",$pwr_lang/pwrs_xtthelp.dat

<h2>$Node
För att definiera en nod i systemet används $Node objekt. När $Node objektet skapas, skapas
dessutom ett antal server- och operatörs-objekt.
Se $Node i Objektshandboken <classlink>node,"",$pwr_lang/pwrs_xtthelp.dat

<h2>I/O objekt
Konfigureringen av I/O systemet är beroende på vilken typ av I/O man använder. Proview har
ett modulariserat I/O för att kunna hantera många olika typer av I/O system: rack och kort
system, distribuerade bussystem, eller system som är kopplade via olika typer av nätverk.

Det modulariserade I/O system är uppdelat på fyra nivåer: agent, rack, kort och kanal.

<b>Rack och kort system
Vi tar I/O systemet PSS9000 som exempel på ett system med rack och kort. Systemet består
av analoga och digital in- och utgångs-kort som monteras i rackar. Rackarna kopplas via en
buss kabel till ett busskonverteringskort i datorn som konverterar PSS9000 bussen till
datorns PCI buss.

I det här fallet används inte agent-nivån, utan $Node objektet fungerar som agent. Rack
nivån konfigurerar man genom att lägga objekt av typen SSAB_Rack under $Node objektet, ett
för varje rack i systemet. Korten konfigureras genom att lägga objekt specifika för olika
typer av IO-kort under rack-objekten. I PSS9000 finns kortobjekt som Ai_Ai32uP, Ao_Ao4uP,
Di_DIX2 och Do_HVDO32. Under kortobjekten läggs kanalobjekt, ett för varje kanal på kortet.

Gemensamt för olika I/O system är egentligen bara kanal-objekten, som definerar ut- eller
ingångs-kanaler på ett kort eller en modul. Det finns några olika typer av kanaler.

ChanDi <t>Digital ingång.
ChanDo <t>Digital utgång.
ChanAi <t>Analog ingång.
ChanAit <t>Analog ingång med konvertering av signalvärde via tabell.
ChanAo <t>Analog utgång.
ChanIi <t>Heltals ingång.
ChanIo <t>Heltals utgång.
ChanCo <t>Pulsgivaringång.

<b>I/O konfigurering
<image> dg_fig43.gif

<b>Distribuerat I/O
Som exempel på distribuerat I/O tar vi profibus. Här utnyttjas alla fyra nivåerna. På datorns
PCI buss sitter ett masterkort som kommunicerar med ett antal slavar på profibusslingan.
Masterkortet konfigureras med ett Pb_Profiboard objekt som ligger på agent-nivå. Under detta
konfigureras de olika slavarna med Pb_DP_Slave objekt. Dessa ligger på rack-nivå. Under
slav-objekten finns modul objekt av typen Pb_Ai, Pb_Ao, Pb_Di, Pb_Do etc, som ligger på
kort-nivå. Under modul-objekten slutligen, konfigureras kanalerna med kanalobjekten ChanDi,
ChanDo etc.

<b>Process och tråd för I/O objekt
I/O objekt på kort-nivå innehåller ofta attributen Process och ThreadObject. I Process
specificeras vilken process som ska hantera kortet. 

Kortet kan hanteras av PLC programmet, vilket innebär att läsning och skrivning gör synkront 
med exekveringen av PLC't. Här kan man även ange vilken tråd i PLC't som ska hantera korten, 
dvs med vilken tidbas de ska läsas och skrivas (PlcThread attributet). 

Kortet kan även hanteras av rt_io processen, som normalt går på en lägre prioritet än 
PLC't som ej hanterar korten synkron med PLC't. Vissa typer av analoga ingångskort som tar 
relativt lång tid att läsa av, hanteras med fördel av denna process.

Man kan också skriva en egen applikation som hanterar läsning och skrivning av kort. Det 
finns ett API för att initiera, läsa och skriva på korten. Detta kan vara av intresse om det
är av vikt att läsning och skrivning av ett kort gör synkront med applikationen.

<h2>MessageHandler objekt
MessageHandler objektet konfigurerar server processen rt_emon, som hanterar 
övervakningsobjekten (DSup, ASup, CycleSup). När en händelse har detekterats av servern,
skickas ett meddelande till de olika utenheter som är intresserade av just det här larmet.

I objektet anges t ex hur många händelser som ska lagras i noden. Objektet skapas automatisk
under ett $Node objekt.
Se MessageHandler i Objektshandboken <classlink>messagehandler,"",$pwr_lang/pwrb_xtthelp.dat

<h2>IOHandler objekt
IOHandler konfigurerar vissa data för I/O hanteringen.

- ReadWriteFlag specificerar om man ska addressera den fysiska hårdvaran eller inte.
- IOSimulFlag anger att man simulerar den fysiska hårdvaran.
- Tidbasen för rt_io processen, dvs den process som hanterar lite långsammare typer av I/O 
  kort som inte är lämpliga att hantera i PLC programmet.

I produktionssystem för en processtation sätts ReadWriteFlag till 1 och IOSimulFlag till 0.
Om man vill simulera processtationen, t ex på utvecklingsnoden, ska ReadWriteFlag sättas 
till 0 och IOSimulFlag till 1.

IOHandler objektet skapas automatiskt samtidigt som ett $Node objekt.
Se IOHandler i Objektshandboken <classlink>iohandler,"",$pwr_lang/pwrb_xtthelp.dat

<h2>Backup_Conf objekt
Ibland är det önskvärt att ha backup på ett antal objekt in systemet. Då placeras ett
konfigurerings objekt för backupen, Backup_Conf, under nodobjektet. Backupen utförs med två
olika cykler, en snabb och en långsam.

För att ange vilka objekt eller attribut som ska backas upp, använder man Backup objekt.
Se beskrivning av Backup objekt <link> configure_rootvolume, backup_object
Se Backup_Conf i Objektshandboken <classlink>backup_conf,"",$pwr_lang/pwrb_xtthelp.dat

<h2>Operatörsplats objekt
För att definiera en operatörsplats skapas ett objekt av klassen OpPlace under $Node 
objektet.

Föjande attribut måste ges ett värde:

- UserName talar om vilken Proview användare som ska loggas in. När operatörsmiljön startas
  hämtas information om användaren från Proview's användardatabas, bl a vilka rättigheter
  operatören har att påverka systemet från processbilder.
- MaxNumberOfEvents anger antalet händelser som operatörens händelselista kan innehålla
  samtidigt.
- SelectList anger vilka hierakier i anläggninghierakin, som operatören vill ta emot larm
  och händelser ifrån.

Om vi betraktar figuren nedan, som illustrerar anläggningen A, och antar att vi ta emot
händelser från de inringade objekten anger vi 'A-C' som ett alternativ i SelectList. Det
innebär att kommer att ta emot händelser från det övervakade objektet C, och från alla
övervakade objekt under C.

<b>SelectList example 1
<image> dg_fig41.gif

Ett annat exempel:
Vi betraktar figuren nedan, som visar anläggningen TrafficCross1. Om vi vill ta emot alla
händelser från TrafficCross1, lägger vi in 'TrafficCross1' i SelectList. TrafficCross1
hanterar två trafikljus, TrafficLightNS och TrafficLightWE. Låt oss säga att vi enbart vill
ha händelser från TrafficLightNS. I det fallet anger vi 'TrafficCross1-TrafficLightNS' 
istället för TrafficCross1.

<b>Selectlist example 2
<image> dg_fig42.gif

Om man vill ta emot händelser från CycleSup objekt som övervakar plctrådarna, måste man även
ange namnet på $Node-objektet.

I FastAvail specificerar man XttGraph objekt som ska kunna startas från tryckknappar i 
'Operator window'. NoFastAvail specificerar antalet tryckknappar som används. Man kan ha 
upp till 15 tryckknappar. Oanvända tryckknappar visas ej i Operator Window.

Se OpPlace i Objektshandboken <classlink>opplace,"",$pwr_lang/pwrb_xtthelp.dat

<b>Operator Window
<image> dg_fig45.gif

<h2>XttGraph objekt
XttGraph objekt används främst för att visa processbilder. I objektet pekar man ut den graf
som ska visas. Objekten refereras i OpPlace objektets FastAvail attribut, och i attributet
DefGraph som bl a finns i $PlantHier och signal objekt.

När objektet refereras i FastAvail kan man även utnyttja möjligheten att exekvera 
xtt-kommandon mha XttGraph objektet. Man kan t ex via ett kommando sätta en viss signal
från en tryckknapp i operatörsfönstret.

I XttGraph objektet ska följande attribut fyllas i:

- Action. Här anges en Ge graph, eller ett Xtt kommando.

Se XttGraph i Objektshandboken <classlink>xttgraph,"",$pwr_lang/pwrb_xtthelp.dat
</topic>
</chapter>

<chapter>
<topic>project_structure
Navigera i projektet

Det här kapitlet beskriver projektstrukturen och förklarar avsikten med olika filkataloger.
Kapitlet beskriver även en del filer som kan användas för att konfigurera olika funktioner
i projektet.

Filkatalogstrukturen är uppdelad i två grenar, en som innehåller alla källkodsfiler som
projektet består av, och en som är byggträdet där alla filer läggs när projektet byggs.
<option> printdisable
Introduktion<link> proj_introduction
Källkodsträdet <link> source_tree
Byggträdet <link> build_tree
Speciella filer <link> proj_special_files
<option> printenable
</topic>

<headerlevel>
<topic>proj_introduction
Introduktion
Figuren nedan visar filkatalogstrukturen för ett projekt.

<image> dg_psfig1.png

Katalogstrukturen är ny i Proview V4.7. Orsaken till detta är att mer särskilja källkods/
konfigureringsfiler och gerenerade filer i projektet. Idén är att att allt som finns i
byggträdet ska kunna återskapas från källkodsträdet.

Alla filkataloger har en omgivningsvariabel definerad för att men enkelt ska kunna nå
kataloger inom projektet. Variablerna är definierade med

<c> $pwrp_<directory>

Till exempel $pwrp_exe för katalogen <project_root>/bld/x86_linux/exe.
</topic>

<topic> source_tree
Källkodsträdet
Källkodsträdet innehåller alla filer som utgör projektets källkod och konfigureringsfiler.
Topnivån innehåller enbart två underkataloger och inga källkods eller konfigureringsfiler. 
Nedan beskrivs innehållet och funktionen för underkatalogerna.

<option> printdisable
Login-katalogen
$pwrp_login <link> project_login

Databas-katalogen
$pwrp_db <link> project_db

Grafik-katalogen
$pwrp_pop <link> project_pop

Applikations-katalogen
The application directory
$pwrp_appl <link> project_appl

Dokumentations-katalogen
$pwrp_doc <link> project_doc

Konfigurations-katalogen
$pwrp_cnf <link> project_cnf
<option> printenable
</topic>

<headerlevel>
<topic> project_login
$pwrp_login
Den här katalogen är startpunkten när man förflyttar sig till ett projekt med 'sdf'-
kommandot. Här finns två filer av intresse.

<c>login.sh
<c>sysinfo.txt

login.sh är ett script som körs när man går till projektet. Det kan användas för att
sätta upp projekt-specifika omgivningsvariabler och liknande.

sysinfo.txt är en text-fil som kommer att skrivas ut i terminal-fönstret när man kommer
till projektet. Här kan man upplysa om vad som pågår eller är gjort i projektet.
</topic>

<topic> project_db
$pwrp_db
Det här är katalogen där databasen med alla lokala volymer ligger (inklusive direktory-
volymen där projektet är konfigurerat). Varje databas ligger i egen underkatalog. Det här
gäller om man väljer att skapa databaserna som BerkeleyDB databaser. Om man istället
väljer att använda mysql-databaser, skapas databaserna på mysql servern. 

I den här katalogen ligger också filerna för användar-definierade klasser. De är textfiler
av typen .wb_load. En användarklassvolym har vanligen ett namn liknande den rotvolym som
använder klasserna. Om rotvolymer heter VolMyProject kallas klassvolymen CVolMyProject
(notera att detta är konvention och inte bindande). Namnet på filen blir:

<c>cvolmyproject.wb_load
</topic>

<topic> project_pop
$pwrp_pop
Det här är katalogen där processbilderna skapade med ge-editorn sparas (filtyp .pwg). 
Färdiga filer kopieras till exe-katalogen i byggträdet ($pwrp_exe). Även xtt-hälpfiler
utvecklas här och kopieras till $pwrp_exe katalogen.

Bilder som har ett motsvarande XttGraph objekt i nodhierarkin i rotvolymen, kommer
automatiskt att bli kopierade till $pwrp_exe katalogen när volymen byggs.
</topic>

<topic> project_appl
$pwrp_appl
I den här katalogen lägger man källkod for projektets applikationer, och även kod som 
ska länkas med plc-programmet.

En fil av speciellt intressen som ska finnas här är

<c>ra_plc_user.h-file

Den här filen kommer att inkluderas när plc-koden kompileras. Den är dock inkluderad från
en katalog i byggträdet (<project_root>/bld/common/inc).

Alla header filer som ligger här eller på underkataloger, och som ska inkluderas av
plc-programmet måste distributeras till $pwrp_inc katalogen (<project_root>/bld/common/inc).

Om man har någon mindre funktion som man enbart länkar med plc-programmet och inte används
någon annanstans, placerar men koden i filen

<c>ra_plc_user.c
</topic>

<topic> project_doc
$pwrp_doc
Det här är platsen att lägga dokumentation som hör till projektet. Det kan vara egenhändigt
producerad dokumentation eller till exempel datablad för komponenter i anläggningen som 
kanske ska distribueras till operatörsstationerna.

</topic>

<topic> project_cnf
$pwrp_cnf
Katalogen innehåller alla konfigurationsfiler i projektet. Vissa konfigureringsfiler är
gemensamma för hela projektet, och de är placerade här. Vissa är specifika för varje nod
i projektet. Man skapar då en underkatalog för varje nod som har specifika konfigurations-
filer. Ibland är en fil unik för en speciell användare. I detta fall kan man även skapa
en underkatalog i nod-katalogen för den användaren.

Filer som läggs här är:

Konfigurering av globala funktionstangenter.
<c>Rt_xtt

Konfigurering av menuer och kortkommandon i rt_xtt.
<c>xtt_setup.rtt_com

Startupfil för Proview.
<c>ld_appl_<nodename>_<bus_no>.txt

Fil för att ange bibliotek som länkas med plc-programmet.
<c>plc_<nodename>_<bus_no>.opt

Fil för att sätta initialvärden vid Proview uppstart.
<c>pwrp_alias.dat

Alla ovanstående filer beskrivs närmare längre fram.
</topic>

</headerlevel>

<topic> build_tree
Byggträdet
Byggträdet innehåller alla filer som produceras när man bygger volymer och noder. Källkoden
ligger däremot i källkodsträdet. Idén är att byggträdet i princip ska kunna tas bort och
återskapas från källkodsträdet.

<option> printdisable
Exe katalogen
$pwrp_exe <link> project_exe

Katalog för objektsfiler
$pwrp_obj <link> project_obj

Katalog för list-filer
$pwrp_lis <link> project_lis

Biblioteks katalog
$pwrp_lib <link> project_lib

Laddfils katalog
$pwrp_load <link> project_load

Loggfils katalog
$pwrp_log <link> project_log

Katalog för temporära filer
$pwrp_tmp <link> project_tmp

Katalog för include-filer
$pwrp_inc <link> project_inc

Katalog för web-filer
$pwrp_web <link> project_web
<option> printenable
</topic>

<headerlevel>
<topic> project_exe
$pwrp_exe
Detta är katalogen där exe-filer för plc program skapas. Plc-program namnges:

<c>plc_<nodename>_<bus_no>_<version_no>

Om man har applikationsprogram i projektet ska även exe-filerna för dem ligga här.
</topic>

<topic> project_obj
$pwrp_obj
På den här katalogen läggs alla objektsfiler som skapas vid kompilering. Objektsfiler 
för plc-programmen läggs här automatiskt. En objektsfil för ett PlcPgm objekt i 
anläggningshierarkin namnges efter objektets identitet.

Objektsfiler för all annan kod ska också placeras här.
</topic>

<topic> project_lis
$pwrp_lis
Här placeras list-filer som produceras vid kompilering.
</topic>

<topic> project_lib
$pwrp_lib
På den här katalogen skapas bibliotek som innehåller objektsfiler för en viss volym. Man
ska även placera andra bibliotek här.
</topic>

<topic> project_load
$pwrp_load
Det här är katalogen där laddata-filer för projektets volymer skapas. Laddata-filen namnges:

<c><volumename>.dbs 
</topic>

Här läggs även filer som skaöas när man editerar plc-programmet. De innehåller all information
som behövs för att visa plc-programmet grafiskt och för att köra plc trace. De här filerna
är av filtyp .flw och kallas flow-filer.

Filer för korsreferens-funktionen läggs också här. De börjar med bokstäverna "rtt".
Korsreferens-filerna skapas manuellt från "Utilities"-funktionen i Navigatorn, eller genom att
sätta CrossReferences i Options/Settings/Build.

<topic> project_log
$pwrp_log
Den här katalogen innehåller log-filer som skapas vid simulering av projektet. Proview's
systemlogg-fil heter

<c>pwr_<nodename>.log

Om man startar om simuleringen, kommer loggningen att adderas till filen. Ta bort filen om 
gammal loggningen ska rensas bort.
</topic>

<topic> project_tmp
$pwrp_tmp
Katalog för temporär-filer. De här filerna skapas vid vissa operatoner, till exempel när
ett plc-program kompileras i debug-mod. Då lagras källkods-filerna här för att sedan kunna 
användas av debuggern.
</topic>

<topic> project_inc
$pwrp_inc
Det här katalogen innehåller include-filer som inkluderas vid bygge av plc-program.
En fil kallad
<c>ra_plc_user.h
letas alltid efter i denna katalog. Om man har andra header-filer som inkluderas, ska de
inkluderas i ra_plc_user.h. Källkoden till include-filerna ska ligga i källkodsträden och
kopieras därifrån till $pwrp_inc.

Header-filer för användarklasser skapas här när man bygger en klassvolym. Om man dokumenterar
klasserna, kommera även en hjälp-fil att skapas. Filerna namnges:

<c>pwr_<classvoumename>classes.h
<c>pwr_<classvoumename>classes.hpp
<c><classvoumename>_xtthelp.dat
<c><classvolumename>.html

</topic>

<topic> project_web
$pwrp_web
Katalogen innehåller alla filer för web-gränssnittet. Till exempel xtt-hjälpfiler konverterade
till html-filer. Också när man skapar en java-bild från en ge-graf läggs java-klassen här.
</topic>

</headerlevel>

<topic> project_special_files
Speciella filer
Här beskrivs speciella filer som används för olika typer av konfigurering, eller som är av 
annat intresse, och är förlagda någonstans i projekt-trädet. De är alla nämnda tidigare i det 
här kapitlet.

<option> printdisable
Konfigurering av Globala funktionstangenter.
Rt_xtt <link> file_rt_xtt

Konfigurering av menyer och snabbkommandon i rt_xtt.
xtt_setup.rtt_com <link> file_rt_xtt

Startupfil för Proview.
ld_appl_<nodename>_<bus_no>.txt <link> file_ld_appl

Fil för att ange vilka bibliotek som ska länkas med plc-programmet.
plc_<nodename>_<bus_no>.opt <link> file_plc_opt

Fil för att ange initialvärden vid Proview startup.
pwrp_alias.dat <link> file_pwrp_alias
<option> printenable
</topic>

<headerlevel>
<topic> file_rt_xtt
Rt_xtt
Den här filen läses in vid start av rt_xtt, och hämtas från katalogen varifrån rt_xtt startas.
Filen konfigurerar tangenter för att utföra olika typer av kommandon.

Giltiga kommandon är:

<c>Command     // Exekverar ett xtt kommando.
<c>SetDig      // Sätter en digital signal till TRUE.
<c>ToggleDig   // Toggla värdet på en digital signal.
<c>ResetDig    // Återställer en digital signal till FALSE.

För att koppla en tangent till ett kommando måste man först definera tangenten och sedan
kommandot. Ett exempel för att koppla tangenttryckningen <Ctrl>F5 till ett kommando som
kvitterar A-larm:

<c>Control <Key>F5: Command(event ack /prio=A)

En typisk Rt_xtt fil kan se ut så här:

<c>#
<c># Function key definition file
<c>#
<c>Control <Key>F5: Command(event ack /prio=A)
<c>Control <Key>F6: Command(event ack /prio=NOA) # ack non A-alarms 
<c>Control <Key>F7: Command(show alarm)          # open alarm list
<c>Control <Key>F8: Command(show event)          # open event list
<c># Below opens a graph defined by a XttGraph-object in the node hierarchy.
<c># The $Node-expression will be replaced by the node-object on this node.
<c># This makes the Rt_xtt-file work on different nodes.
<c>Alt <Key>F12: Command(open graph /object=$Node-Pictures-rkt_overview)
<c># Below opens a graph defined by a XttGraph-object in the node hierarchy.
<c># The /focus-syntax sets focus on a object in the graph named NewPlate
<c>Control <Key>F9: Command(open graph /object=*-Pictures-rkt_platepic/focus="NewPlate")
<c>Control <Key>F10: Command(open graph /object=*-Bilder-rkt_cells/focus="Check_no")
<c># Below closes all open graphs except rkt_overview.
<c>Control <Key>F11: Command(close all/except=rkt_overview)
<c>Shift <Key>F1: SetDig(VWX-RKT-RB-DS-OnOffMan_1_2.ActualValue)
<c>Shift <Key>F6: ResetDig(VWX-RKT-RI-RP-CalcPrePos.ActualValue)
<c>Shift Control <Key>v: ToggleDig(VWX-RKT-COM-VWXSVR-BlockOrder_RKT.ActualValue)

</topic>
<topic> file_xtt_setup
xtt_setup.rtt_com
Den här filen läses in vid start av rt_xtt. Filen läses från den katalog man startar rt_xtt från,
Med hjälp av den kan man konfigurera egna menyer och koppla menyalternativ till att utföra
speciella kommandon.

Alla kommandon i filen följer syntaxen för xtt script och kommandon. Se Operatörshandboken för mer
info om script och kommandon.

När man startar rt_xtt finns som default en meny med alternativet Databas överst. Om man, till
exempel, vill skapa en meny ovanför denna är kommandot:

<c>create item/text="Maintenance"/menu/dest=DataBase/before

För att skapa en undermeny (första barnet) till denna används kommandot:

<c>create item/text="VVS"/menu/dest=Maintenance/firstchild

För att skapa ett menyalternativ som utför ett kommando under VVS menyn används kommandot:

<c>create item/text="Graph P1"/command="open graph/object=$Node-pics-h4_proc1"\ 
<c>       /pixmap=graph/dest=Maintenance-VVS/lastchild

Pixmap kvalifieraren anger att en speciell ikon används för menyalternativet. Utan denna blir ikonen
en löv. Kommandot öppnar en graf definierad med ett XttGraph objekt i nodhierarkin.

Resultatet ser ut så här:

<image> dg_psfig2.png

Förutom att bygga menyer, kan man även definera symboler (genvägar) som kan användas som kommandon.
Symbolen matas in på kommando-raden och kommandot definierat av symbolen exekveras.
Nedan defineras symbolen 'h4' som öppnar en graf:

<c>define h4 "open graph /object=*-pics-h4_process1"

I xtt_setup-filen lägger man in ett kommando per rad. Kommentars-rader inleds med ett utropstecken.
</topic>

<topic> file_ld_appl
ld_appl_<node>_<bus_no>.txt

I den här filen anges de applikationer som ska startas vid start av Proview runtime. Man kan addera
egna appikationer, men även stänga av en eller flera av Proview's system-processer.

En typisk ld_appl-fil kan se ut så här:

<c># Startup file for PROVIEW/R
<c>#
<c># id,   name,   load/noload run/norun,  file,   prio,   debug/nodebug,  "arg" 
<c>#pwr_neth,      , noload, norun, , 5, debug, ""
<c>#pwr_plc,       , noload, norun, ,  , debug, ""
<c>#pwr_alim,      , noload, norun, , 5, debug, ""
<c>#pwr_emon,      , noload, norun, , 5, nodebug, ""
<c>#pwr_tmon,      , noload, norun, , 5, debug, ""
<c>#pwr_qmon,      , noload, norun, , 19, debug, ""
<c>#pwr_nacp,      , noload, norun, , 5, debug, ""
<c>#pwr_bck,       , noload, norun, , 5, debug, ""
<c>#pwr_io,         , noload, norun, , 5, debug, ""
<c>#pwr_linksup,   , noload, norun, , 5, debug, ""
<c>#pwr_trend,     , noload, norun, , 5, debug, ""
<c>#pwr_fast,       , noload, norun, , 5, debug, ""
<c>#pwr_remh,       , noload, norun, , 5, debug, ""
<c>pwr_remlog,       , noload, norun, , 5, debug, ""
<c>#pwr_sysmon,       , noload, norun, , 5, debug, ""
<c>#pwr_elog,       , noload, norun, , 5, debug, ""
<c>pwr_webmon,       , noload, norun, , 5, debug, ""
<c>pwr_webmonmh,       , noload, norun, , 5, debug, ""
<c>pwr_webmonelog,       , noload, norun, , 5, debug, ""
<c>#pwr_opc_server,       , noload, norun, , 5, debug, ""
<c>#pwr_sevhistmon,       , noload, norun, , 5, debug, ""
<c>#pwr_sev_server,       , noload, norun, , 5, debug, ""
<c>#rs_nmps_bck, rs_nmps_bck, noload, run, rs_nmps_bck, 12, nodebug, ""
<c>ra_utl_track, ra_utl_track, noload, run, ra_utl_track, 12, nodebug, ""

'#' teckenet innebär att raden är bortkommenterad. Nästan alla Proview's systemprocesser är
bortkommenterade eftersom vi vill att de ska starta (de är markerade med 'norun'). Om vi tar 
bort #-tecknet kommer denna systemprocess ej att startas. I ovanstående exempel har 
vi inte något web-gränssnitt och startar därför inte de processer som hanterar detta 
(pwr_webmon, pwr_webmonmh och pwr_webmonelog).

På den sista raden finns en applikation som tillhör projektet och ska startas vid Proview start.
Prioriteten är satt till 12 som är något under prioriteten för Proview's systemprocesser som
har mellan 17 och 19.
</topic>

<topic> file_plc_opt
plc_<node>_<bus_no>.opt
Den är filen (om den existerar) används för att addera bibliotek och objektsmoduler vid
länkningen av plc-programmet. Några bibliotek och objektsmoduler måste finnas med, och
en default option-fil ska se ut så här:

<c>$pwr_obj/rt_io_user.o -lpwr_rt -lpwr_usbio_dummy -lpwr_usb_dummy -lpwr_pnak_dummy

Till detta adderas de bibliotek och moduler som behövs. Syntaxen är den som gäller för ld 
(The GNU linker). Proview genererar en template option-fil .opt_template som kan användas som
mall.

</topic>

<topic> file_pwrp_alias
pwrp_alias.dat
Fil för att sätta initialvärden vid Proview start.

Det finns några olika sätt att sätta värden med pwrp_alias-filen.
Samma fil används för alla noder i projktet. Varje rad ska inledas med följande uttryck:

<c><nodename>_setval

De olika sätten att sätta värden beskrivs nedan:

1. Sätta värde på ett attribut

<c><nodename>_setval <attribute_name> = <value>

Exempel

<c>bslds1_setval bsl-ds1-par-maxtemp.actualvalue = 70.0

Med denna syntax kommer värdet att sättas före backup'en har laddads, och före plc-programmet
har startat. Det betyder att om värdet backas upp är det backupvärdet som gäller.

Om man vill vara säker på att datasättningen kommer att ha effekt används denna syntax:

<c><nodename>_setvalp <attribute_name> = <value> 

I det har fallet utförs datasättningen efter backup-filens laddning och plcprogrammets start.

2. Sätta simulerings-mod

Att sätta simulerings-mod innebär att I/O inte hanteras. Man kan skriva simulerings-program
för att sätta lämpliga värdet på ingångs I/O. Addera den här raden till filen:

<c><nodename>_setval plcsim = yes

3. Stäng av exekveringen av alla plc-program vid startup

För att sätta scan-off på alla plc-program används den här raden:

<c><nodename>_setval plcscan = off

Exekveringen på ett PlcPgm kan sedan sättas på genom att sätta ScanOff attributet i WindowPlc 
objektet (ligger som barn till PlcPgm-objektet) till 0. Observera att eventuella underfönster
också kan behöva startas.
</topic>


</headerlevel>

</chapter>

<chapter>
<topic>plc_programming
Grafisk PLC programmering

Det här avsnittet beskriver hur man skapar PLC program.

<h1>Editorn
Man startar editorn från ett PlcPgm objekt i anläggningshierarkin. Välj ut objektet och
aktivera 'Functions/Open Program' i menyn. Den första gången programmet öppnas, finns där
ett tomt dokument objekt. Programmet består av funktionsobjekt och GRAFCET sekvenser.

Programmering med funktionsblock görs i ett horisontellt nät av noder och förbindningar, från
vänster till höger i dokumentet. Värden på signaler och attribut hämtas upp på den vänstra
sidan av nätet, och värden överförs med förbindningar från utgångs pinnar till ingångs
pinnar på funktionsblocken. Funktionsblocken opererar på signalvärdena och i den högra
sidan av nätet lagras värdena i signaler eller attribut.

GRAFCET sekvenser består av ett vertikalt nät av noder och förbindningar. Ett tillstånd
överförs mellan stegen i sekvensen via förbindningarna. Nät av GRAFCET och funktionsblock
kan samverka med varandra och kombineras till ett nät.



<h2>Editera funktionsobjekt

PLCeditorn består av
- en arbetsarea.
- en palett med GRAFCET objekt och funktionsblock, och en palette med förbindningar.
- ett navigationsfönster, från vilket arbetsarean kan skrollas och zoomas.


<b>Plc editorn
<image> dg_fig46.gif

Ett funktionsobjekt skapas genom att man väljer en klass i paletten, och klickar med MB2
(mittenknappen) i arbetsarean.

<h2>Modifiera ett objekt
Ett objekt kan modifieras från objektseditorn. Denna öppnas genom att välja ut objektet
och aktivera 'Functions/Open Object' i menyn. Värden på objektets attribut kan ändras med
'Functions/Change value' i objekteditorns meny. Om en in- eller ut-gångspinne inte används
kan den tas bort med en checkbox. Det finns också en checkbox som avgör om en digital ingång
ska vara inverterad.

<h2>Koppla ihop funktionsobjekt
En utgångspinne och en ingångspinne kopplas ihop genom att

- placera markören på pinnen, eller på ett område i funktionsobjektet nära pinnen, och 
  tryck ned MB2.
- drag markören till den andra pinnen, eller till ett område i funktionsobjektet nära pinnen,
  och släpp MB2.

En förbindning skapas nu mellan funktionsobjekten.

<h2>Hämta värdet på en signal
Värdet på en Di signal hämtas med ett GetDi objekt. GetDi objektet måste peka på Di objektet
och detta görs genom att välja ut signalen i konfiguratören, och sedan trycka ned Ctrl
tangenten och dubbelklicka med MB1 på GetDi objektet. Signalnamnet visas nu i objektet. Dv
signaler, Do signaler och attribut hämtas på samma sätt med GetDv, GetDo resp GetDp objekt.

<h2>Lagra ett värde i en signal
Värdet från en utgång på ett funktionsobjekt lagras i en Do signal med ett StoDo objekt.
StoDo objektet kopplas till Do signalen på samma sätt som Get objekt. Dv signaler och 
attribut lagras med StoDv resp StoDp objekt.

<h1>Grafcet
Den här sektionen ger en första introduktion till Grafcet. För en mer detaljerad beskrivning,
läs referensmanualen för Grafcet. Grafcet är en internationell standard för 
sekvensstyrningar.

Grafcet består av ett antal steg, och till varje steg är ett eller flera order kopplade, 
som kommer att exekveras när steget är aktivt. Från början är initsteget aktivt, och
aktiviteten flyttas till nästa steg med ett övergångsvillkor. En förflyttning görs när 
villkoret för ett övergångsvillkoret är uppfyllt.

<h2>Enkel rak sekvens
Vi tittar på den enkla sekvensen nedan och antar att initsteget (Start) är aktivt, vilket 
betyder att ordern som är kopplad till initsteget (Order1) kommer att utföras. Ordern kommer
att utföras ända tills initsteget blir inaktivt. Steg 1 (Step1) blir aktivt, när 
övergångsvillkoret T1 är uppfyllt. Initsteget blir då inaktivt.

En Grafcet sekvens är alltid en sluten sekvens.

<b>En enkel rak Grafcet sekvens
<image> dg_fig47.gif

<h2>Förgrenad sekvens

En rak sekvens är den enklaste varianten av sekvenser. Ibland behöver man alternativa grenar
i programmet, till exempel om man har en maskin som kan tillverka tre olika produkter. På de
ställen som produktionen skiljer sig åt, lägger man in alternativa grenar.

<b>Aternativ förgrening
<image> dg_fig48.gif

Exemplet ovan visar sekvensen för en maskin som kan producera tre produkter, röd, grön och 
blå. Vid förgreningen, punkt 1 i figuren, väljer man önskad gren beroende på den produkt
som ska tillverkas. Alternativa grenar utgår från ett steg, som följs av ett 
övergångsvillkor i varje gren. Det är konstruktörens uppgift att se till att endast ett
av övergångsvillkoren är uppfyllt. Om flera skulle vara uppfyllda avgör slumpen vilken gren
som väljs. Vid punkt 2 i figuren går grenarna ihop till ett gemensamt steg.

<h2>Parallella sekvenser
Ibland behöver man starta flera parallella arbetsmoment samtidigt. Det ska vara möjlig för de
olika momenten att kunna arbeta oberoende av varandra. För att åstadkomma detta, använder man
parallella sekvenser.

<b>Parallell sekvens
<image> dg_fig49.gif

Exemplet i figuren ovan visar sekvensen för två maskiner som borrar två hål samtidigt, 
oberoende av varandra. När övergångsvillkoret före parallellförgreningen (punkt 1 i figuren),
är uppfyllt, flyttas aktiviteten över till båda grenarna, och de två maskinerna börjar
borra. Borrningen sker oberoende av varandra. 

Grenarna sammanförs till ett övergångsvillkor (punkt 2 i figuren), och när borrningen är 
klar i båda maskinerna, dvs både S12 och S13 är aktiva, och övergångsvillkoret T17 är 
uppfyllt, flyttas aktiviteten vidare till initsteget IS2.

<h2>Steg - Step
<image> dg_fig51.gif

Ett Step objekt (steg) används för att beskriva ett tillstånd i processen. Följande gäller 
för ett steg:

- Ett steg kan vara aktivt eller inaktivt. Attributet Order[0] innehåller aktiviteten.
- Man kan koppla en eller flera order till ett steg.
- Steget kan ges ett godtyckligt namn.
- Steget blir inaktivt om resetsignalen sätts.

<h2>Initsteg - InitStep
<image> dg_fig50.gif

I varje sekvens måste det finnas ett initsteg (InitStep) som skiljer sig från vanliga steg
på följande punkter

- Man bör endast ha ett initsteg i en sekvens.
- När programmet startar, är initsteget aktivt.
- Initsteget blir aktivt om resetsignalen sätts.

<h2>Övergångsvillkor - Trans
Ett övergångsvillkor används för att överföra aktiviteten mellan två steg. Aktiviteten 
överförs från det övre till det undre steget (se figur nedan). Ett logiskt villkor, t ex 
en digital signal, som kopplas till Trans objektet, avgör när överföringen sker.

<b>Exempel på övergångsvillkor
<image>dg_fig52.gif

<h2>Order
Det är möjlig att koppla en eller flera order till varje steg.

<b>Exempel på order
<image>dg_fig53.gif

Normalt är orderns utgång aktiv när ingången är aktiv, men för varje order finns ett antal
attribut, som påverkar utgångens funktion:

- D Fördröjning (delay) 
- L Tidsbegränsning (limit)
- P Puls (pulse)
- C Villkorlig (conditional)
- S Lagrad (stored)

Dessa funktioner beskrivs i detalj i Proview Objekt handbok. Principen är att man anger
namnet på attributet (stor bokstav) och eventuell tid i objektseditorn. I figuren nedan
visas hur man fördröjer orderns aktivitet i 10 sekunder.

<b>Attribut för DOrder
<image>dg_fig54.gif

De valda attributen skriv ut i ordersymbolen.

Figuren nedan visar hur man kan använda en order med fördröjning för att göra ett steg
aktivt en viss tid.

<b>En fördröjd övergång
<image>dg_fig55.gif

Notera att man måste använda en feedback förbindning för att ansluta den fördröjda ordern
till övergångsvillkoret. Annars blir exekveringsordningen tvetydig.
Se feedback koppling <link>plceditor_refman, feedback_connection

<h2>Subsekvens - SubStep

När man skapar komplexa Grafcet program, är det ofta en fördel att använda underfönster,
och i dessa placera subsekvenser. På det här sättet får man en bättre layout på programmet.

<b>Subsekvens
<image>dg_fig56.gif

I figuren ovan visas subsekvensen för ett SubStep. En subsekvens startar alltid med ett
SsBegin objekt och slutar med ett SsEnd objekt. En subsekvens kan i sin tur innehålla
subsekvenser.

<h1>Introduktion till funktionsblocks programmering

<h2>Block för att hämta och lagra värden
Hämtnings- och lagringsblock används för att läsa och skriva värden. Det finns hämtnings-
och lagringsblock för varje typ av signal. I figuren nedan visas ett antal av dessa block.
De återfinns under 'Signal' mappen i paletten.

<b>Block för att hämta och lagra värden
<image>dg_fig57.gif

För att läsa signalvärden används block som GetAi, GetIi, GetDi eller GetAo. När man vill
sätta ett värde i en signal, används block som StoAv, StoDo, SetDv eller ResDo.

Digitala värden kan skrivas på två sätt:

- 'Sto' lagrar ingångsvärdet, dvs om ingången är 1 blir signalen 1, och om ingången är 0 blir
  signalen 0.
- 'Set' sätter signalen till 1 om ingången är sann, 'Res' sätter ingången till 0 om ingången
  är sann. Om man, t ex, sätter en digital utgång med ett SetDo objekt, förblir den satt
  tills man återställer den med ett ResDo objekt.

För att läsa resp. tilldela värden på attribut (andra än ActualValue) använder man följande:

- GetAp och StoAp för analoga attribut.
- GetIp och StoIp för heltals attribut.
- GetDp och StoDp, SetDp eller ResDp för digitala attribut.
- GetSp för strängattribut.
- GetAtp och GetDtp for tidsattribut.

<h2>Logiska block
Det finns ett antal block tillgängliga för logisk programmering. t ex och-grind (And), 
eller-grind (Or), inverterare och timer. För logisk programmering används digitala signaler.
Objekten är placerade under mappen 'Logic' i paletten.

<b>Logiska block
<image> dg_fig58.gif

I figuren ovan ses en och-grind (And1). För objektet gäller följande:

- Ingångar till vänster
- Utgångar till höger
- Klassnamnet utskrivet överst.
- Objektsnamnet utskrivet underst (kan ändras av konstuktören).
- Man kan använda ett variabelt antal ingångar, default är 2 st.
- Ingångarna kan inverteras, vilket markeras med en cirkel på ingången.

<b>Och-grind
<image> dg_fig59.gif

Och-grindens attribut ändras från objektseditorn.

<b>Och-grindens attribut
<image> dg_fig60.gif

De andra objekten under 'Logic' mappen har liknande attribut, se Proview Objekt handbok.

<h2>Beräkningsblock

Mappen 'Analog' i paletten innehåller ett antal objekt för att hantera analoga signaler,
t ex filter, additionsblock och integratorer.

<b>Aritmetiskt beräkningsblock
<image> dg_fig61.gif

Här beskrivs inte funktionen hos objekten, men det kan vara lämpligt att kommentera
användningen av aritmetiska block. Blocken används för beräkning av användardefinierade
uttryck, som skrivs i programmeringsspråket C.

I figuren ovan kommer blocket att beräkna värdet (A1 + A2 * A3) och lägga detta på utgången.
A1, A2 och A3 representerar analoga värden, t ex signaler som antas vara kopplade till
ingångarna på objektet. 

Uttrycken kan innehålla avancerad C kod med arrayer och pekare. När man skriver dessa bör
man medveten om att indexering utanför arrayer, eller felaktiga pekare kan gör att 
exekveringen av plcprogrammet stoppas.

<h1>Larmövervakning

I Proview är det möjligt att övervaka analoga och digitala signaler. Övervakningen av analoga
signaler sker mot ett gränsvärde. Om gränsvärdet överskrids, skickas ett larm till 'event
monitorn' som i sin tur skickar det vidare till en utenhet, t ex ett larmfönster.

Se Proview Objekt handbok beträffande objektens attribut.

<h2>Övervakning av digitala signaler
För att övervaka digitala signaler eller attribut, använder man DSup objekt (Digital 
Supervisory), som finns under mappen 'Logic' i paletten.

Signal eller ett attributet som ska övervakas, hämtas med ett Get-objekt som förbinds med
DSup objektet. Utgångar på logiska block kan kopplas direkt till DSup objektet.

<b>Digital övervakning
<image> dg_fig62.gif

Figuren ovan visar övervakningen av en Dv signal.

Attributet 'CtrlPosition' i DSup objektet indikerar om larmet ska aktiveras när den 
övervakade signalen blir sann eller falsk.

<h2>Övervakning av analoga signaler

För att övervaka analog signaler eller attribut, använder man ASup objekt (Analog 
Supervisory), som finns under mappen 'Analog' i paletten.

Övervakningen sker på liknande sätt som för en DSup, med undantaget att man kan välja om 
larmet ska utlösas om gränsvärdet underskrids eller överskrids.

<h1>Kompilera plcprogrammet
Innan man börjar kompilera, måste man ange vilken platform (eller vilka plattformar) som
plcprogrammets volym ska exekvera på. Öppna volymsattribut-editorn från konfiguratören, 
'File/Volume Attributes' i menyn, och ange operativsystem. Notera att mer än ett
operativsystem kan väljas. Volymen kan samtidigt köras i produktions-systemet, på ett
simulerings-system och i ett utbildnings-system, och alla kan ha olika plattform.

Nu kompileras plcprogrammet genom att välja 'File/Build' i plceditorns meny. Eventuella
fel och varningar visas i meddelandefönstret.
</topic>
</chapter>

<chapter>
<topic> dg_plc_functions
Anropa funktioner från plc programmet

Den funktions-blocks programmering som plc-programmet utgörs av har sina begränsningar, och
vissa saker kan göras mycket enklare och snyggare med c-kod. För detta finns funktionsblocken
CArithm och DataArithm där man kan lägga in en viss mängd c-kod, men antal tecken är 1023, och 
ibland räcker det inte till. Då har man två möjligheter, att skriva en fristående applikation, 
vilket finns beskrivet i kapitlet Applikationsprogrammering, eller att anropa en c-funktion 
från en CArithm eller DataArithm. Fördelen med att anropa en funktion är att all initiering och 
knytning till objekt sköts av plc-programmet. Dessutom  sker anropen synkront med exekveringen 
av den plc-tråd som anropar funktionen.

<h1>Skriva koden
Koden läggs i en c-fil, som läggs någonstans under $pwrp_src. Vi skapar filen 
$pwrp_src/ra_myfunction.c och lägger in funktionen MyFunction() som utför en enkel beräkning.

<c>#include "pwr.h"
<c>#include "ra_plc_user.h"

<c>void MyFunction( pwr_tBoolean cond, pwr_tFloat32 in1, pwr_tFloat32 in2, 
<c>                 pwr_tFloat32 *out)
<c>{
<c>  if ( cond)
<c>    *out = in1 * in2;
<c>  else
<c>    *out = in1 + in2;
<c>}

<h1>Prototypdeklaration
I includefilen ra_plc_user.h läggs en prototypdeklaration av funktionen. 

<c>void MyFunction( pwr_tBoolean cond, pwr_tFloat32 in1, pwr_tFloat32 in2, 
<c>                 pwr_tFloat32 *out);

ra_plc_user.h includeras av plc-programmet, och funktionen kan därmed anropas från CArithm 
eller DataArithm objekt. Man bör även includera ra_plc_user.h i funktions-koden för att få en 
kontroll på att anropet stämmer.

ra_plc_user bör ligga på $pwrp_src och kopieras till $pwrp_inc varifrån den inkluderas av plc't
och funktions-kod.

<h1>Kompilera koden
c-filen kompileras, till exempel med hjälp av make. Nedan visas en makefile som kompilerar
ra_myfunction.cpp och lägger resultatet, objektsmodulen ra_myfunction.o på $pwrp_obj.
Notera att även ett beroende på ra_plc_user.h har lagts in så att denna kommer att kopiera 
från $pwrp_src till $pwrp_inc.


<c>ra_myfunction_top : ra_myfunction

<c>include $(pwr_exe)/pwrp_rules.mk

<c>ra_myfunction_modules : \ 
<c>		$(pwrp_inc)/ra_plc_user.h \ 
<c>		$(pwrp_obj)/ra_myfunction.o

<c>ra_myfunction : ra_myfunction_modules
<c>	@ echo "ra_myfunction built"

<c>#
<c># Modules
<c>#

<c>$(pwrp_inc)/ra_plc_user.h : $(pwrp_src)/ra_plc_user.h

<c>$(pwrp_obj)/ra_myfunction.o : $(pwrp_src)/ra_myfunction.c \ 
<c>                              $(pwrp_inc)/ra_plc_user.h


<h1>Anrop från plc-programmet
Anropet av funktionen sker från ett CArithm, DataArithm, AArithm eller DArithm objekt. 

<image>dg_fig97.png
<b>Fig Anrop av funktion från plc-koden

<b>Länka plc-programmet
Vid kompileringen skapades objektsmodulen $pwrp_obj/ra_myfunction.o. Denna måste länkas med
när plcprogrammet byggs, och det sker genom att objektsmodulen läggs in i en option fil som
skickas med som indata till länkaren. Optionfilen ligger på $pwrp_exe och har namnet
plc_'nodename'_'qbus'.opt, t ex

<c>$pwrp_exe/plc_mynode_0999.opt

I denna läggs följande rad in

<c>$pwr_obj/rt_io_user.o $pwrp_obj/ra_myfunction.o -lpwr_rt -lpwr_usbio_dummy -lpwr_usb_dummy \
<c> -lpwr_pnak_dummy

Vi kan nu bygga noden och starta Proview runtime.

<h1>Debug
En nackdel när man lämnar den grafiska programmeringen och anropar c-funktioner är att man 
inte längre kan följa förloppet i trace. Om man misstänker att det är något fel i koden är 
ofta bästa sättet att starta plc-programmet i debug, sätta en brytpunkt i funktionen, och
stega sig fram i koden.

Först bygger man plc-programmet med debug genom att från konfiguratören öppna Options/Setting 
i menyn och aktivera Build/Debug, och sedan bygga noden.

Därefter man startar Proview runtime och knyter upp debuggern, gdb, mot plcprocessen genom 
att skicka med pid för processen till gdb med -p. pid kan man se med 'ps x'

<c>> ps x
<c>...
<c>5473 pts/0    Sl     0:18 plc_mynode_0999_00003

5473 är pid för plcprogrammet och vi startar debuggern, sätter en brytpunkt i funktionen
och låter programmet exekvera vidare

<c>> gdb -p 5473 plc_mynode_0999_00003
<c>(gdb) b MyFunction
<c>(gdb) c

När programmet går in i funktionen fastnar det i debuggern och vi kan stega (s) och titta på
innehållet i variabler (x) mm.

Om plcprogrammet terminerar direkt efter start, kan man starta om det i debug.

<c>> gdb plc_mynode_0999_00003

Det går också bra att döda den gående plc-processen och starta en ny i debug

<c>> killall plc_mynode_0999_00003
<c>> gdb plc_mynode_0999_00003

</topic>
</chapter>

<chapter>
<topic>dg_components
Komponenter och Aggregat

Det här kapitlet handlar om hur man programmerar med hjälp av komponenter och aggregat.


En komponent är ett (eller att antal objekt) som hanterar en komponent i anläggningen. En
komponent kan var t ex en ventil, en kontaktor, en temperaturgivare eller en frekvensomformare.
Eftersom det här är komponenter som förekommer i många olika typer av anläggningar är det idé
att försöka göra ett objekt som innehåller allt som behövs för att styra och kontrollera 
komponenten, och som är så generellt att det kan användas i de flesta anläggningar.

En komponent i Proview kan vara uppdelat på ett antal objekt: 
- ett huvudobjekt som innehåller konfigureringsdata och data som behövs vid övervakning och 
  drift av komponenten. Det innehåller även signal-objekten för komponenten.
- ett funktionsobjekt som läggs in i plcprogrammet och som innehåller koden för att styra 
  komponenten.
- ett I/O objekt som definierar eventuell kommunikation med t ex en profibus modul.
- ett simuleringsobjekt för att enkelt kunna testa och simulera systemet.

Dessutom ingår en objektbild, dokumentation, ev trendkurvor mm.

Aggregat är en större del i anläggningen än en komponent, och innehåller ett antal komponenter.
Ett aggregat kan t ex vara en pumpstyrning, som består av komponenterna pump, motor, kontaktor
och säkerhetsbrytare. I övrigt är aggregatet uppbyggt som en komponent med huvudobjekt,
funktionsobjekt, simuleringsobjekt, objektsbild, dokumentation mm.

<b>Objektsorientering
Proview är ett objektsorienterat system, och komponenter och aggregat är ett område där man
utnyttjar objektsorienteringens egenskaper fullt ut. I komponenter kan man 
se hur man bygger upp objekt av andra objekt, att ett attribut förutom att vara en enkel typ 
som  en float eller en integer, även kan vara ett objekt som i sin tur består av andra objekt.
Ett  attribut som är ett objekt kallas för ett attributobjekt. Det är inte riktigt analog med 
ett fristående objekt eftersom det inte har något objektshuvud och inte någon egen 
objektsidentitet, men i övrigt innehåller det alla egenskaper som ett fristående objekt har
i form av metoder, objektbilder mm. 

Ett exempel på attributobjekt kan vi se i komponentobjektet för en magnetventil. Här ligger 
signalobjekten, två Di objekt för gränslägen och ett Do objekt för styrsignal för att 
öppna ventilen, intern i objektet som  attributobjekt. Vi behöver alltså inte skapa signalerna
separat, utan i och med att ventilobjektet är skapat, har vi även skapat signalerna för detta
objekt. Ett annat exempel på attributobjekt är ett motoraggregat som innehåller komponentobjekt 
för frekvensomformare, säkerhetbrytare, motor mm i form av attributobjekt.


En annan viktig egenskap inom objektsorienteringen är arv. Med arv menas att man kan skapa 
en subklass utgående från en existerande klass, en superklass. Subklassen som ärver alla
egenskaper från superklassen, men man har möjlighet att lägga till eller förändra en del 
egenskaper. Ett exempel på detta är en komponent för en temperaturgivare som är en subklass
till ett generellt givarobjekt för analoga givare. Den ända skilladen mellan temperatur-
givarklassen och dess superklass är objektsbilden, där givarvärdet presenteras i form av en
termometer i stället för en stapel. Ett annat exempel är ett pumpaggregat som subklassar ett
motoraggregat. Pumpaggregatet har utökats med ett pump objekt och har även modifierade 
objektsbilder som förutom motorstyrningen även visar en pump.

<image> dg_fig98.gif
<b>Fig Objektsbild för subklassen BaseTempSensor med superklassen BaseSensor

En annan egenskap som vi har infört är möjligheten att sätta attribut ur funktion. Orsaken till
detta är att komponentobjekten måste göras så generella att de täcker in alla varianter av
den komponent i anläggningen de ska styra. En magnetventil kan t ex ha ett gränsläge som 
markerar att ventilen är öppen, men det finns även ventiler med gränslägen som markerar stängd 
ventil, eller ventiler med båda gränslägena eller ventiler helt utan gränslägen. Man skulle
naturligvis ha kunna göra fyra olika komponentklasser, en för varje gränslägesvariant, men 
problemen uppstår när man vill bygga aggregat av komponenterna. Antalet varianter av ett
aggregat blir snart ohanterbart om man ska täcka in alla olika varianter av delkomponenterna.
Om vi t ex ska göra ett aggregat som innehåller fyra magnetventiler och varje ventil kan 
finnas i fyra varianter, blir det 64 varianter av aggregatet. Vill vi dessutom bygga ett 
aggregat som innehåller fyra ventilaggregat är vi uppe i 4096 olika klasser. Lösningen är att 
bygga en ventilkomponent med båda gränslägena, där man sedan genom en konfigurering kan sätta 
attributen för ett eller för båda gränslägena ur funktion, så den kan hantera alla fyra 
gränslägesvarianterna. I det här fallet är det attributobjekt av klassen Di som sätts ur 
funktion, vilket innebär att de inte visas i navigatören och ignoreras av I/O hanteringen. 
Dessutom tas det hänsyn till detta i koden för ventilkomponenten och i objektsbilder. 
Konfigureringen gör i konfiguratören från popupmenyn där man under 'ConfigureComponent' kan 
välja en konfigurerring av de olika alternativ som finns.

<image> dg_fig76.png
<b>Fig ConfigureComponent metoden för en BaseMValve. 

<h2>Baskomponenter
Proview innehåller ett antal komponent och aggregat objekt för vanliga element i en anläggning,
t ex temperaturgivare, tryckgivare, tryckvakt, magnetventil, filter, motorstyrningar och
fläktstyrningar. De finns samlade i klassvolymen BaseComponent. En baskomponent kan användas
rakt av, och det är nog det vanligaste sättet att använda dem, men tanken är också att man 
utgående från basklasserna skapar klasser och bygger upp bibliotek med för de specifika
komponenter man använder i sina anläggningar.

För magnetventiler finns basklassen BaseMValve. Har man en magnetventil av typen 
Durholt 100.103 skapar man en subklass med BaseMValve som superklass, Durholt_Valve_100_103, 
och lägger in den konfigurering som gäller för just den här ventilen, dessutom lägger man in 
en länk till datablad och fyller i Specification attributet så att man kan identifiera och 
beställa reservdelar till ventilen. När man använder ett Durholt_Valve_100_103 objekt behöver 
man sedan inte göra så mycket konfigureringar och anpassningar eftersom detta är gjort redan 
i klassen. På det här sättet kan man bygga upp komponentbibliotek för de olika typer av 
komponenter som man använder i sina anläggningar. 

Ett problem uppstår när man använder aggregat. Aggregaten innehåller baskomponenter från 
BaseComponent och finns det specifica subklasser för komponenterna, vill man kunna använda 
dessa även i aggregaten. Lösningen på problemet är Cast (forma) funktionen. En baskomponent 
i ett aggregat kan castas till en subklass, under förutsättning att subklassen har samma 
storlek, dvs att subklassen inte har utökats med nya attribut. Castningen innebär att 
komponenten hämtar initialvärden, konfigureringar, metoder, objektbilder mm från subklassen, 
dvs i alla lägen uppträder som den subklass den är castade till. Castningen utförs från 
popupmenyn i konfiguratören, där man i 'Cast' alternativet får upp en lista på de subklasser 
som finns att välja på. Genom att välja en subclass castar man komponenten till denna.

<h1>Tryckvakt
Låt oss titta på en relativt enkel komponent, en tryckvakt, för att se hur den är uppbyggd och 
hur man konfigurerar den. För tryckvakter finns baskomponenten BasePressureSwitch, som är en 
subklass till BaseSupSwitch. Eftersom temperatur-, tryck-, och nivåvakter är väldigt lika ur 
övervakningssynpunkt har de en gemensam superklass. BaseSupSwitch har i sin tur en superklass, 
Component, som är gemensam för all komponentklasser. Klassberoende för tryckvaktsklassen blir 
med andra ord

<c>Component-BaseSubSwitch-BasePressureSwitch

<b>Component klassen
Component innehåller attributen Description, Specification, HelpTopic, DataSheet, CircuitDiagram, 
Note och Photo som alltså finns i alla komponenter. I Description finns plats för en kort 
beskrivning, i Specification lägger man in modelltypen för den komponent det är frågan om, de 
övriga används för att konfigurera motsvarande metoder i operatörsmiljön.

<b>BaseSubSwitch
Från superklassen BaseSupSwitch ärvs attributen Switch, AlarmStatus, AlarmText, Delay,
SupDisabled och PlcConnect.

- Switch är Di objektet för tryckgivaren. Detta måste kopplas till
  ett kanalobjekt i nodehierarkin.
- AlarmStatus visar larmstatus i runtime.
- AlarmText innehåller larmtexten för det larm som skickas vi larmstatus. Larmtexten har 
  defaultvärdet "Pressure switch, ", men kan naturnligvis bytas ut mot någonting annat.
  Observera att om defaulttexten behålls, kommer denna att översättas om man väljer att 
  annat språk. Lägger man in en annan text, sker ingen översättning.
- Delay anger larmets fördröjning i sekunder, (default 0 sekunder).
- SupDisabled indikerar att larmet är undertryckt.
- PlcConnect är koppling till funktionsobjekt i plc-koden.

Till huvudobjektet BaseSupSwitch, finns det ett funktionsobjekt BaseSupSwitchFo, och
även detta ärvs av tryckvakskomponenten.

<b>BasePressureSwitch
BasePressureSwitch har inte några attribut utöver de som har ärvts från superklasserna. Det
som är unikt för BasePressureSwitch är den grafiska symbolen, 
Components/BaseComponent/PressureSwitch, och objeksbilden, där switch-symbolen innehåller 
ett P som markerar tryck.


<b>Konfigurering
Vi öppnar konfiguratören och lägger in huvudobjektet, BasePressureSwitch, i anläggning-
hierarkin. I ett lämpligt PlcPgm lägger vi in funktionsobjektet BaseSupSwitchFo och
kopplar detta till huvudobjektet med connect-funktionen. Välj ut huvudobjektet och klicka med
Shift/Dubbelklick MB1 på funktionsobjektet. Funktionsobjektet innehåller koden för komponenten,
som för en BaseSupSwitch är ett larm skickas vid larmtillstånd.

<image> dg_fig77.png
<b>Fig Huvudobjekt med tillhörande funktionsobjekt

Tryckvakten ska visas för operatören i en Ge bild. Vi öppnar Ge-bilden och hämtar subgrafen 
BaseComponent/SupSwitch från paletten. Subgrafen är anpassad till till en BaseSupSwitch, så
det ända vi behöver göra är att koppla den till huvudobjektet. Välj ut huvudobjektet i 
planthierarkin och klicka med Shift/Dubbelklick MB1 på subgrafen.

<image> dg_fig78.png
<b>Fig Grafisk symbol, popupmeny med metoder och objeksbild

Det här räcker för att göra komponenten funktionsduglig. Sedan kan man naturligvis forsätta
att konfigura metodattributen med hjälptexter och länkar till fotografier, elschemor och 
datablad.

<h1>Reglerventil
Nu ska vi titta närmare på en lite mer omfattande komponent, BaseCValve, som styr en 
reglerventil. Till skillnad från tryckvakten ovan, måste man använda ConfigureComponent för
att konfigurerar objektet, dessutom finns det ett simuleringsobjekt som används för att
testa systemet.

Antag att vi har en reglerventil, som styrs med en analog utsignal, och som ger positionen 
tillbaka i en analog ingång. Här kan vi använda en BaseCValve. Den har den analoga utsignalen 
'Order' och den analoga insignalen 'Position', dvs de signaler som vi efterfrågar. Dessutom 
finns två digitala insignaler för gränsläge öppen och gränsläge stängd, men dessa kan 
elimineras med hjälp av  konfigurering.

<b>Konfigurering
Vi lägger in huvudobjektet BaseCValve i planthierarkin och funktionsobjektet BaseCValveFo i
ett PlcPgm, och kopplar ihop dem med Connect funktionen. Funktionsobjektet har en orderingång
som vi kopplar till ett PID objekt. Vi måste även ange att vår ventil inte har några gränslägen,
och det gör vi genom att välja 'ConfigureComponent/PositionNoSwitches' i popupmenyn för
huvudobjektet. När vi nu öppnar huvudobjektet, och i detta Actuator objektet, ska vi hitta
en Position signal, men inga gränslägessignaler.

<image> dg_fig79.png
<b>Fig Huvudobjekt med funktionsobjekt

<image> dg_fig81.png
<b>Fig ConfigureComponent alternativet PositionNoSwiches

Vi lägger även in subgrafen BaseComponent/CValve i en Ge-bild och kopplar denna till 
huvudobjektet.

Nu vill vi även kunna simulera ventilen, för att se att den fungerar som vi har tänkt. För 
simulering finns funktionsobjektet BaseCValveSim som vi lägger i ett speciellt PlcPgm för
simulering, eftersom det inte ska exekvera i driftsystemet. Funktionsobjektet kopplas till
huvudobjektet med Connect-funktionen.

<image> dg_fig80.png
<b>Fig Simuleringsobjekt för reglerventilen

Konfigureringen är klar och efter att ha byggt simuleringsnoden kan vi testköra och titta på
resultatet.

<h1>Pumpstyrning
Nästa exempel är ett aggregat, en pumpstyrning med en frekvensomformare som kommunicerar via
Profibus med protokollet PPO3. Vi kommer att se hur ett komponentobjekt i aggregatet, förutom 
huvudobjekt, funktionsobjekt och simuleringobjekt, även omfattar I/O objekt för att hämta och 
skicka data via profibus.

Klassen vi använder är BaseFcPPO3PumpAggr, och om vi tittar på klassberoendet är det

<c> Aggregate-BaseFcPPO3MotorAggr-BaseFcPPO3PumpAggr

Alla aggregat har superklassen Aggregate som motsvarar Component classen för komponenter. Nästa
superklass, BaseFcPPO3MotorAggr innehåller all funktionalititet för styrningen. Själva pump
klassen BaseFcPPO3PumpAggr utökar motoraggregatet med ett pumpobjekt som representerar den
mekaniska pumpen, men som inte innehåller några signaler eller någon ytterligare funktionalitet.
Dessutom har pumpaggregats klassen en egen objektbild och en egen grafisk symbol.

<b>Konfigurering
Huvudobjektet BaseFcPPO3PumpAggr läggs i anläggningshierarkin och funktionsobjektet (som ärvts
från motoraggregatet) BaseFcPPO3MotorAggrFo läggs i ett PlcPgm, och de båda kopplas ihop med
Connect funktionen. 

Huvudobjektet har inte mindre än 24 olika konfigureringar att välja mellan, beroende på 
vilka av komponenterna Fuse, Contactor, SafetySwich, StartLock och CircuitBreaker som finns med
i konstruktionen. I vårt fall har vi bara en kontaktor och en frekvensomformare och väljer
alternativet ConfigureComponent/CoFc.

En del komponenter i ett aggregat kan ha egna konfigureringar. I det har fallet kan kontaktorn
och motorn konfigureras individuellt. Vår kontaktor har två signaler, en Do för order och en Di
för feedback, och det stämmer med default konfigurationen, så denna behöver vi inte ändra på.
Motorn däremot har ett motorskydd i form av en temperaturvakt, därför väljer vi ut motor
komponenten och aktiverar ConfigureComponent/TempSwitch i popupmenyn. 

Nästa steg är att koppla ihop signalobjekt med kanalobjekt. Kontaktorn innehåller en Do och en 
Di för order resp feedback som kopplas till lämpliga kanalobjekt i nodehierarkin. Motorn,
har en temperaturvakt i form av en Di som också ska kopplas. Frekvensomformaren innehåller 
fyra signaler, StatusWordSW (Ii), ActSpeed (Ai), ControlWordCW (Io) och RefSpeed (Ao). Dessa
signaler utbyts med frekvensomformaren via Profibus med protokollet PPO3. Det finns ett 
speciellt Profibus modulobjekt för PPO3, BaseFcPPO3PbModule, innehåller kanaler för PPO3
kommunikation. Modulen konfigureras mha Profibus konfiguratorn (see Guide to I/O System),
och kopplas ihop med FreqencyConverter komponenten i pumpaggregatet. Eftersom komponentobjektet 
och modulobjektet är anpassade till varandra, behöver man inte koppla signal för signal, utan
man kopplar component med modul istället. Genom att välja ut modulobjektet och aktivera 
ConnectIo i popupmenyn for FrequencyConverter komponenten är kopplingen gjord.

Vi lägger även in subgrafen Components/BaseComponents/FcPPO3PumpAggr i en översiktsbild
och kopplar denna till huvudobjektet. Vidare lägger vi in ett simuleringsobjekt 
BaseFcPPO3MotorAggrSim i ett speciellt simulerings PlcPgm, och kopplar detta till huvudobjektet.

<b>Mode
PumpAggregatet innehåller ett Mode objekt där man konfigurerar varifrån pumpen styrs. Det
innehåller moderna Auto, Manuel och Local med följande betydelse:

- Auto: pumpen styrs av plc-programmet.
- Manuell: pumpen styrs av operatören från objektsbilden.
- Lokal: pumpen styrs från en pulpet.

I Mode objektet kan man konfigurera vilka moder som är aktuella för den här pumpen.
</topic>

<headerlevel>
<topic> dg_compcasestudy
En Component fallstudie 

I det här avsnittet ska vi programmera en reglering av nivån i en vattentank, mha komponenter
och aggregat.

<b>Process
Processen vi ska styra ser vi i figur 'Nivåreglering'. Vattnet pumpas från en reservoar till
en tank. Vår uppgift är att reglera nivån i tanken. Till hjälp har vi en nivå-givare och en
reglerventil. I systemet finns även en returledning med en magnetventil som alltid är öppen
under regleringen. Vi noterar att tanken är 1 meter hög, vilket kommer att återspeglas i 
diverse olika min och max värden vid konfigureringen.

<image> dg_fig82.png
<b>Fig Nivågreglering

Vi kan identifiera följande komponenter: 
- en kontaktorstyrd pump, med effektbrytare, kontaktor, motorskydd och säkerhetsbrytare.
- en reglerventil med två gränslägen för öppen och stängd.
- en nivågivare.
- en magnetventil med två gränslägen för öppen och stängd ventil.

Följande komponentobjekt motsvarar komponenterna i anläggningen:

- Pump <t><t>BasePumpAggr
- Reglerventil <t><t>BaseCValve
- Nivågivare <t><t>BaseLevelSensor
- Magnetventil <t><t>BaseMValve

<h2>Konfigurering i planthierarkin
Komponenterna läggs under hierakin LevelControl. Under detta lägger vi ett PlcPgm 'Plc' som 
ska innehålla koden för styrningen, ett PlcPgm 'Simulate' som ska innehålla den kod som 
behövs för att vi ska kunna simulera och testa programmet. Vi skapar även tre Dv objekt
för starta, stoppa och återställa reglerprogrammet (Start, Stop och Reset).

<image> dg_fig83.png
<b>Fig Plant configuration

<b>Pump
Pumpstyrningen består av
- en effektbrytare med en Di.
- en kontaktor med en Do för order, och en Di för kontaktorsvar.
- ett motorskydd med en Di.
- en säkerhetsbrytare med en Di.
- en motor utan några signaler.

För pumpen skapas ett BasePumpAggr objekt men namet P1. 

Det ConfigureComponent alternativ som motsvara konstruktionen är CbCoOrSs (CircuitBreaker, 
Contactor, Order, SafetySwitch) och vi väljer ut P1 och aktiverar detta alternativ i
ConfigureComponent från popupmenyn.

<image> dg_fig86.png
<b>Fig Pump configuration

Komponenterna Contactor och Motor har egna konfigurationer så även för dessa måste vi aktivera
ConfigureComponent. Vi väljer ut Contactor och väljer ConfigureComponent/OrderFeedback eftersom
vi både har en signal for order och en för kontaktorsvar. För Motor objektet väljer vi
ConfigureComponent/NoTempSwichOrSensor eftersom motorn saknar signaler.

Alla signaler som finns i pumpaggregatet ska kopplas till kanalobjekt i nodhierarkin. Vi letar
upp följande signalobjekt och kopplar dem lämpliga kanaler:

P1.Contactor.Order 		<t><t>Do order till kontaktorn.
P1.Contactor.Feedback 		<t><t>Di kontaktorsvar.
P1.CircuitBreaker.NotTripped 	<t><t>Di effektbrytare ej utlöst.
P1.SafetySwitch.On 		<t><t>Di säkerhetsbrytare till.
P1.OverloadRelay.Overload 	<t><t>Di överlastningsrelä utlöst.


<b>Reglerventil
Reglerventilen har ett ställdon som styrs med en analog utsignal, och gränslägesgivare för
öppen och stängd ventil.

Vi skapar ett BaseCValve objekt med namnet CV1. ConfigureComponent alternativet som passar
in på vår konstruktion är TwoSwitches. 

Följande signaler kopplar vi till lämpliga kanaler i nodhierarkin:

CV1.Actuator.Order 		<t><t>Ao för styrsignal.
CV1.Actuator.SwitchOpen 	<t><t>Di för gränsläge öppen.
CV1.Actuator.SwitchClosed 	<t><t>Di för gränsläge stängd.

<b>Nivågivare
För nivågivaren skapar vi ett BaseLevelSensor objekt men namnet LC1. Denna har inte någon
ConfigureComponent metod, men det finns en del annat att konfigurera.

Givarobjektet har larmgränser för HögHög, Hög, Låg och LågLåg och dessa sätts i attributen
LC1.LimitHH.Limit, LC1.LimitH.Limit, LC1.LimitL.Limit och LC1.LimitLL.Limit. Vi sätter även
övre gränsen för visning av värdet i LC1.Value.PresMaxLimit till 1. Detta påverkar området 
för stapeldiagram och trendkurvor.

<b>Magnetventil
Magnetventilen styrs av en digital utsignal och har feeback i form av digitala insignaler
för gränsläge stängd och gränsläge öppen.

För magnetventilen skapar vi ett BaseMValve objekt med nament MV1. 

I ConfigureComponent väljer vi TwoSwitches som motsvarar den aktuella konfigurationen med
de båda gränslägena.

Signaler som ska kopplas till kanaler i noderhierarkin är:

MV1.Order 		<t><t>Do för order att öppna ventilen.
MV1.SwitchOpen 		<t><t>Di för gränsläge öppen.
MV1.SwitchClosed 	<t><t>Di för gränsläge stängd.

<h1>Plcprogram
Nästa steg är att skriva plcprogrammet för nivåstyrningen. Här ska funktionsobjekten för
komponenterna ingå:

- BaseMotorAggrFo för pumpen P1.
- BaseCValveFo för reglerventilen CV1.
- BaseMValveFo för magnetventilen MV1.
- BaseSensorFo för nivågivaren LC1.

Vi lägger ut funktionsobjekten och kopplar dem till respektive huvudobjekt, genom att välja
ut huvudobjektet och aktivera Connect i popupmenyn för funktionsobjektet.

Vi kommer även att använda en PID regulator för att styra nivån i tanken. Regulatorn har
värdet från nivågivaren som ärvärde, och lägger ut utsignalen till reglerventilen, som då
kommer att anpassa inflödet i tanket så att rätt nivå uppnås. Regulatorn skapas med 
funktionsobjekten Mode och PID. 

Programmet byggs upp kring en Grafcet sekvens med fyra steg. Se Fig Plc program

1. Initialsteget IS0 är viloläget när pumpen är avstängd och alla ventiler stängda.

2. När Start Dv'n sätts från en knapp i operatörsbilden, aktiveras steg S0. Här 
   startas pumpen genom att sordern Ord0 kopplas till startingången på funktionsobjektet
   för pumpen P1. När pumpen har startat sätts On utgången på pumpobjektet, och 
   aktiviteten flyttas till nästa steg S1. Observera att sordern Ord0 fortsätter att
   vara aktiv, dvs pumpen är igång, tills man gör reset i steg S2.

   Från fel-utgången Err på pumpobjektet sätter vi Reset Dv'n. Reset är inlagd som 
   ResetObject i PlcPgm objektet, vilket gör att alla sekvenser i PlcPgm'et kommer
   att återställas när Reset sätts, vilket medför att pumpen och regleringen stängs av 
   och sekvensen återgår till vilotillståndet i IS0.

3. S1 är driftsteget, där regulatorn är till, och reglerar nivån i tanken.
   Så länge S1 är inaktivt, sätts force-ingången på mode objektet och regulatorn har
   0 som utsignal. När steget blir aktivt, hämtar regulatorn ärvärdet från utgången från
   givarobjektet LC1, börvärdet sätt i modeobjektet LC1_Mode.SetVal från operatörsbilden,
   och utsignalen är kopplad till reglerventilens order-ingång.
   Ordern Ord1 är även kopplade till magnetventilens order-ingång och öppnar denna.

4. Steg S1 är aktivt tills Stop Dv'n sätt från en knapp i operatörsbilden. När steget
   lämnas tvångstyrs regulatorn igen och reglerventilen stänger. Även magnetventilen stängs.
   Steget S2 passeras som hastigast och gör reset på sordern Ord0, dvs stoppar pumpen. 
   Därefter återgår sevensen till viloläget IS0.

Mode objektet LC1_Mode och regulatorn LC1_PID kräver lite ytterligare konfigurering. 
I modeobjektet sätts 
- OpMode = Auto så att regulatorn startar i auto-mod.
- MaxSet = 1, max börvärde är höjden på tanken, 1m.
- SetMaxShow = 1, också höjden på tanken.
- SetEngUnit = m, meter.
- PidObjDid = LevelControl-Plc-W-LC1_PID, namnet på PID objektet.

I PID objektet sätts
- PidAlg = PID
- Gain = 100
- IntTime = 10
- MaxGain = 200
- SetMaxShow = 1
- SetEngUnit = m
- ModeObjDid = LevelControl-Plc-W-LC1_Mode, namet på mode objektet.

<image> dg_fig84.png
<b>Fig Plc program

<h1>Simulerings program
Simuleringsprogrammet är till för att kunna testa alla funktioner i programmet, larmhantering 
och operatörbilderna före idrifttagningen. Man kan även använda det för utbildning och
demonstration.

Simulerings-koden läggs i ett separat program 'Simulate' , som inte ska exekvera i 
driftsystemet. I detta läggs simuleringsobjekt för komponenterna:

- BaseMotorAggrSim för pumpen P1.
- BaseCValveSim för reglerventilen CV1.
- BaseValveSim för magnetventilen MV1.
- BaseSensorSim för nivågivaren LC1.

Funktionsobjekten kopplas till huvudobjekten, genom att välja ut huvudobjektet och aktivera
Connect i popmenyn för funktionsobjeket. 

Simuleringsobjekten för pumpen, reglerventilen och magnetventilen har inte några in eller 
utgångar utan arbetar uteslutande mot data i huvudobjektet, där de läser utgångssignaler och
sätter lämpliga värden på ingångssignaler. Simuleringsobjekten har även en objektsbild, där
man kan påverka simuleringen och framkalla olika felfall för att se att felen hanteras på 
ett kontrollerat sätt och att operatören informeras via processbilder och larmhantering.

Simuleringsobjektet för nivågivaren har däremot en ingång, och här måste vi beräkna en
simulerad nivå i tanken. En ändring i nivån bestäms av infödet - utflödet dividerat med
tankens area. Vi antar att inflödet är proportionellt mot order utgången till
reglerventilen (CV1.Actuator.Order), och drar ifrån utflöde genom magnetventilen när denna
är öppen. Inflödet accumuleras i CArithm'ens OA1 utgång, som skickas vidare till simulerings
objektet för nivågivaren LC1. I LC1 adderas även lite brus till signalen för att få ett mer
realistiskt utseende, genom att LC1.RandomCurve sätts till 1, och LC1.RandomAmplitude till 0.1.

<image> dg_fig85.png
<b>Fig Simuleringsprogram

<h1>Processbild
Operatörsbilden för nivåstyrningen ritas i Ge, och här används de grafiska symbolerna för
komponenterna som finns i Ge paletten:

- Component/BaseComponent/PumpAggr för pumpen.
- Component/BaseComponent/CValve för reglerventilen.
- Component/BaseComponent/MValve för magnetventilen.
- Component/BaseComponent/LevelSensor för nivågivaren.

Symbolerna har en dynamiken HostObject, som innebär att de har en förprogrammerad dynamik 
som är kopplad till olika attribut i objektet. Man behöver endast lägga in objektsnamnet 
på huvudobjektet HostObject.Object, eller koppla dem genom välja ut huvudobjektet och klicka 
med Dubbelklick Ctrl/MB1 på symbolen. 

I default dynamiken ingår inte att objektsbilden öppnas när att klicka på symbolen, vi 
adderar denna funktion genom att öppna objektattribut editorn för symbolen och lägga till 
OpenGraph i action (om man inte anger något OpenGraph.GraphObject objekt öppnas objektbilden).

Vi konstruerar också en tank, mha en fyrkant och två halva ellipser, som vi sätter fill 
och gradient på och även grupperar. På gruppen sätts dynamik FillLevel och 
FillLevel.Attribute kopplas till värdet för nivågivaren, dvs 
LevelControl-LC1.Value.ActualValue. Min och max värdet för FillLevel anges till 0 och 1.

Till vänster om tanken läggs en slider för att enkelt kunna ställa in börvärdet för nivån.
Den består av en Slider/SliderBackground3 och en Slider/Slider3. Slidern kopplas till
börvärdet i mode objektet LC1_Mode, dvs LevelControl-Plc-W-LC1_Mode.SetVal. Min och maxvärde 
för slidern sätts till 0 och 1.

För börvärdet skapas också ett inmatningsfält 'SetValue' som kopplas till samma värde som 
slidern ovan. Ärvärdet för nivån visas i value fältet 'Level' och kopplas till värdet för 
nivågivaren.

Regulatorsymbolen hämtas från Process/PID_Controller i paletten. Den har ingen dynamik som
default, men vi vill att objektsbilden för mode objektet ska öppnas när man klickar på den,
så vi lägger in Action Command med kommandot 

<c>open graph /class/instance=LevelControl-Plc-W-LC1_Mode

Tryckknapparna för Start och Stop är av typen Buttons/SmallButton. SmallButton har ToggleDig
som default action, men vi vill ha SetDig istället eftersom Start resp Stop signalerna 
återställs av plcprogrammet. Vi tar bort Inherit i Actions för att undvika ToggleDig och 
lägger dit SetDig i stället, och kopplar till Start resp Stop Dv'n.

Trendkurvan hämtas från Analog/Trend i paletten. I denna ska ärvärdet och börvärdet visas, dvs
- Trend.Attribute1 sätts till LevelControl-LC1.Value.ActualValue (värdet för nivågivaren).
- Trend.Attribute2 sätts till LevelControl-Plc-W-LC1_Mode.SetVal (börvärdet i mode objektet).

Slutligen ritas lite rör och linjer och bilden är klar.
Vi går även in i File/Graph attributes och lägger in koordinaterna för övre vänstra och 
under högra hörnen i x0,y0 och x1,y1. DoubleBuffered sätt till ett och MB3Action till 
PopupMenu.

<image> dg_fig87.png
<b>Fig Graphic editor

<h1>Simulering
För att se resultatet av vår programmering startar vi upp simuleringen.

När vi öppnar bilden är de båda ventilerna färgade vita, vilket markerar att de är stängda.
Pumpen är inte startad, vilket markeras med grå färg och att trekanten i pumpsymbolen inte
pekar i strömningsriktningen. Tanken är vitfärgad, dvs tom, och nivågivaren blinkar ilsket
rött eftersom nivån ligger under LowLow nivån i nivågivarobjektet.

Genom att trycka på startknappen lämnar vi vilosteget i Grafcet sekvensen, och aktiverar
steget som startar pumpen (S0). När pumpen har startats färgas den blå och trekanten pekar 
i strömningens riktning. I det här steget öppnas även magnetventilen som färgas blå. Så snart 
pumpen har startat övergår sekvensen till driftsteget S1.

Vi lägger in ett börvärde med slidern på ca 0.3 och förhoppningsvis börjar regulatorn att
arbeta. Det är möjligt att det behövs lite intrimning av regulatorn, och regulatorbilden
får vi upp genom att klicka på regulator symbolen, som öppnar objektsbilden för Mode
objektet. I denna klickar vi på PID knappen som öppnar objektbilden för PID objektet. Här
kan vi trimma på förstärkning (Kp) och integrationstid (Ti).

<image> dg_fig92.png
<b>Fig Object graph mode and PID object.

Låt oss titta lite på vad vi kan göra med komponenterna i bilden.

<b>Nivågivare
Om vi högerklickar på nivågivaren får vi upp en popupmeny med de metoder som är 
definierade för givaren. Med OpenPlc öppnar vi plc trace för komponentens funktionsobjekt,
med RtNavigator letas objektet upp i navigatören, med Trend visas en trendkurva för
nivån, med OpenGraph öppnas objektsbilden. Objektsbilden kan även öppnas genom att
klicka på symbolen.

Den övre delen av objektsbilden för komponenter och aggregat har ett likartat utseende.
Där finns en meny där man under 'Methods' kan aktivera metoderna för komponenten. Under
'Signals' kan man se vilka signaler som finns i komponenten och öppna objektbilden för dem.
För aggregat kan man även se ingående komponenter och öppna objektsbilden för dessa under
'Components'. Det finns också en vertygspanel med knappar för metoderna, och två textfält
som visar Description och Specification för komponenten. På den nedersta raden i bilden 
visas ett Note meddelande om något sådant är inlagt (detta läggs in med Note metoden).

I övrigt visas i nivågivarbilden nivån, i sifferform och i stapelform, och de larmnivåer
som finns konfigurerade. Larmnivåerna kan ställas in med sliders och kan även aktiveras
eller inaktiveras med checkboxar.

Längst upp till höger i bilden finns en knapp markerad med 'S'. Den är bara synlig om man kör 
simulerat (IOSimulFlag i IOHandler objektet är satt) och med den öppnar man simuleringsbilden.
Från simuleringsbilden kan man påverka den simulerade signalen. Vi har redan konfigurerat
Random med amplituden 0.01, man kan även superponera en sinuskurva eller sågtandskurva på
signalen.

<image> dg_fig88.png
<b>Fig Object graph for the levelsensor and simulate graph

<b>Reglerventil

Objektsbilden för reglerventilen har indikatorer för gränslägena och visar ordern som 
läggs ut till ventilen i stapelform. 

Vi kan ta över ventilen i manuell mod, dvs istället för att regulatorns utsignal läggs 
ut till ventilen, ställs ventilläget in med slidern 'Manual'. Regleringen är nu satt
ur spel och vattenflödet styrs mha slidern.

Från simuleringsbilden kan man t ex påverka simuleringen av gränslägena. Om Order är 0
och inte gränsläge stängd är påverkad får man ett gränslägesfel med larm och rödblinkande
symbol. Vid simulering ser simuleringsobjektet till att ställa in gränslägena rätt, men
detta kan överridas från simuleringsbilden. Genom att trycka på 'Manual Control' styrs
gränsläget från bilden istället, och genom att ta ner gränslägessignalen kan man testa
att gränslägesövervakningen fungerar.

<image> dg_fig89.png
<b>Fig Object graph for the controlvalve and simulate graph

<b>Magnetventil

Objektbilden för magnetventilen visar gränslägen och order signal med indikatorer.
Ventilen tas över i manuel mode genom att klicka på Man knappen, och kan nu manövreras
med Open och Close knapparna.

I simuleringsbilden kan man liksom för reglerventilen påverka simuleringen av gränslägena
och framkalla larm för gränslägesfel.

<image> dg_fig91.png
<b>Fig Object graph for the solenoidvalve and simulate graph

<b>Pump

Objektsbilden för pumpen visar en schematisk skiss över de ingående komponenterna, och
även en status indikator för varje komponent. Genom att klicka på en komponent öppnar man
objektsbilden för denna.

Med 'Man' knappen kan man ta över pumpen i manuell mod och starta och stoppa pumpen från 
Start och Stop knapparna i bilden.

I simuleringsbilden kan olika händelser man simuleras. 
- 'SafetySwich on' simulerar att någon sätter på säkerhetsbrytaren. Det medför att pumpen 
  stängs av, pumpsymbolen färgas gul, och att Err utgången på funktionsobjektet sätts. Denna 
  har vi kopplat till Reset Dv'n som återställer sekvensen och stänger av regleringen.
- 'CircuitBreaker tripped' simulerar att effektbrytaren löser ut.
- 'Contacor feeback lost' simulerar att kontaktorsvaret tappas.
- 'OverloadRelay tripped' simulerar att överlastningsrelät löser.

<image> dg_fig90.png
<b>Fig Object graph for the pump and simulate graph

</topic>
</headerlevel>
</chapter>

<chapter>
<topic>communication
Kommunikation

Remote-konceptet i Proview är ett sätt att standardisera kommuniktionen med andra system.
Det utgörs av ett antal transport program och Proview objekt som används för att 
implementera ett antal olika kommunikations-protokoll och hantera inkommande och utgående
meddedanden. Remote är designat för att använda olika transport protokoll som TCP/IP eller
BEA Message Queue, och olika hårdvara som t ex ethernet eller seriella linjer.
Det grundläggande syftet med Remote är att förse programmeraren med ett gränsnitt för
kommunikation.

<option> printdisable
Introduktion <link> comm_introduction
Protokoll <link> protocols
Ett exempel <link> an_example
<option> printenable
</topic>

<headerlevel>
<topic>comm_introduction
Introduktion
Ett antal olika klasser och objekt används för att hantera kommunikation.

<h2>RemoteConfig
Krävs för att någon remote kommunikation ska vara möjlig. Utan detta objekt startas inte
remotehandlern. Ett RemoteConfig objekt placeras i nod-hierarkin.

<h2>RemNode
Definierar en länk till en remote nod av någon typ med ett specifikt protokoll.
Flera olika protokoll supportas and det finns en specifik klass för varje protokoll.
Det supportade protokollen är:

TCP/IP
UDP/IP
MQ (BEA Message Queue)
ALCM (ett Digital protokoll, modell äldre, supportas av historiska skäl)
Serial
Modbus/RTU Serial
3964R (seriellt protokoll från Siemens)

Konfigurationen av varje protokoll beskrivs längre ner.
RemNode-objekt placeras under RemoteConfig-objektet.

<h2>RemTrans
Generell klass som denfinierar ett specifikt meddelande till en från en viss nod på
ett visst protokoll. Ska placeras under ett RemNode-objekt. Storleken på det meddelande
som ska skickas anges i RemTrans-objektet. Det data som ska sändas läggs i ett 
buffer-objekt som läggs som barn till RemTrans-objektet. När ett meddelande ska skickas 
hämtas data med den specifierade längden från buffer-objektet. I vissa fall adderas också 
en header till meddelandet.

<h2>Buffer
Definierar dataarean för sändning resp mottagning för ett meddelande. Buffer-objekt finns i
olika storlekar, och ska placeras under RemTrans-objektet. Buffer-objektet måste var av
minst den storlek som det meddelandet som ska skickas eller tas emot har. Om storleken
inte räcker till kommer meddelandet att huggas av.

<h2>RemTransSend 
Funktions-objekt som används i plc-program för att skicka meddelanden.

<h2>RemTransRcv
Funktions-objekt som används i plc-program för att ta emot meddelanden.
</topic>

<topic> protocols
Protokoll
Protokollet specifieras med den typ av RemNode-objekt som används vid konfigureringen. För
varje RemNode objekt som är konfigurerat, startas en transport process, dvs ett program som
hanterar det valda protokollet. Processen kommer att hantera alla de RemTrans objekt som 
ligger som barn till RemNode-objektet.

<option> printdisable
UDP <link> udp_ip
TCP <link> tcp_ip
BEA Message Queue <link> bea_mq
Serial <link> serial
3964-R <link> 3964r
Modbus Serial <link> modbus_serial
<option> printenable
</topic>

<headerlevel>
<topic> udp_ip
UDP
UDP använder socket kommunikation utan länk (datagram), till skillnad från TCP som ett länkat
protokoll. I RemNodeUDP-objektet anges ip-adressen till den nod man ska kommunicera med och 
port-nummer in båda ändarna. Det lokala port-numret måste vara unikt på noden.

Meddelanden sänds med en speciell header som adderas till data bufferten. Headern läggs i början
på meddelandet. Headern innehåller information om det sända meddelandet, och används för att
adressera meddelandet till rätt buffer-objekt. Headern ser ut så här:

<c>char       RemId1;  /* STX (Hex 02) */
<c>char       RemId2;  /* ETB (Hex 0F) in data message without acknowledge 
<c>                       ENQ (Hex 05) in data message with acknowledge 
<c>                       ACK (Hex 06) in acknowledge message */
<c>short int  Length;  /* Number of bytes in message including this header */
<c>short int  MessId1; /* Message identity part 1 */
<c>short int  MessId2; /* Message identity part 2 */
 
Alla heltal i headern kommer skickas som big endian, dvs den mest signifikanta byten först. I
användardelen av meddelandet är det konstruktörens ansvar att konverterar mellan big och 
little endian när detta behövs. Det går även att sända meddelanden utan header genom att sätta
attributet DisableHeader till TRUE. Vid kommunikation mellan två Proview system ska headern 
finnas med. MessId1 och MessId2 hämtas från attributen RemTrans.Address[0] och 
RemTrans.Address[1]. Mha headern kan man även ange att kvittens ska skickas på meddelandet. Om
kvittensen uteblir, upprepas sändningen av meddelandet cykliskt med det tid som ligger i
RemTrans-objekts RetransmitTime attribut.

Eftersom UDP/IP är ett länk-fritt protokoll finns funktionen att övervaka kopplingen med
keepalive-meddelanden. Detta anges med attributet UseKeepAlive.

<h2>Skicka meddelanden
Transporten kommer att skicka meddelanden till remote-porten, som består av header + data.
MessId i headern hämtas från RemTrans.Address[0,1], byte-switchade och sända som big endian.
Om MaxBuffer i remtrans-objektet > 0, sänds meddelandet med kvittens och lagras i 
återsändnings-kön för remnoden. När kvittensen tas emot, tas meddelandet bort ur 
återsändnings-kön. Detta utförs automatiskt av transport processen.

<h2>Ta emot meddelanden
När ett meddelande tas emot, kontrolleras först headern för att se att det är ett korrekt
RemTrans meddelande. Sedan letar man upp det RemTrans-objekt med Address[0,1] som matchar det
byte-switchade MessId-värdet. Om buffer-objektet är tillräckligt stort för meddelandet, lagras
meddelandet där, och DataValid flaggan sätts. Om RemNode objekete har markerats för att 
användas utan header (DisableHeader-attributet är satt), letas efter en RemTrans, angiven som 
mottagare, med tillräckligt stort buffer-objekt.

</topic>

<topic> tcp_ip
TCP
RemnodeTCP konfigureras i stort sett som RemnodeUDP. Den stora (enda) skillnaden är att TCP
är ett länk protokoll som agerar enligt klient/server modell. Alltså måste man antingen koppla
upp mot en remote socket som klient, eller vänta på en uppkoppling som server. När man 
agerar som server, kommer enbart en klient att accepteras. ConnectionMode attributet i 
RemNode-objektet avgör om man är klient eller server. 0 (default värdet) anger klient och
1 anger server.

</topic>

<topic> bea_mq
MQ
RemnodeMQ är en transport för att skicka meddelanden med BEA Message Queue (BMQ). Det krävs att
BEA Message Queue är installerad på noden. BMQ är ett säkert sätt att skicka meddelanden till
andra noder även om noden momentant inte är uppe, och även för att säkerställa att meddelanden 
levereras säkert till noden själv.

Det här avsnittet kräver grundläggande kunskap om BEA Message Queue. Kortfattat kan man säga att
kommunikationen går på en speciell bus, där varje nod har ett grupp-nummer och kan enbart
kommunicera med andra grupper på samma bus. På varje grupp kan flera köer konfigureras.

För att kunna starta transporten måste naturligvis Message Queue vara startad. 
Man måste även sätta några omgivningsvariabler. Dessa är:

<c>DMQ_BUS_ID
<c>DMQ_GROUP_ID
<c>DMQ_GROUPNAME

I RemnodeMQ-objektet konfigurerar man vilken BMQ-kö som tar emot meddelanden i attributet MyQueue.
Man konfigurerar även remote-nodens grupp-nummer och kö i attributen TargetGroup och TargetQueue.

<h2>Skicka meddelanden
I likhet med UDP och TCP-transporterna används RemTrans.Address[0,1] till att identifiera meddelanden.
Address[0] representerar meddelande klass och Address[1] meddelandetyp (enligt BMQ nomenklatur).
Address[2,3] används för att definiera vilken typ av leverans-mod (Address[2]) som ska användas och
vad som ska göras om meddelandet inte kan levereras (Address[3]).

Möjliga leverans-moder är:

<c>PDEL_MODE_WF_SAF 25
<c>PDEL_MODE_WF_DQF 26
<c>PDEL_MODE_WF_NET 27
<c>PDEL_MODE_WF_RCM 28
<c>PDEL_MODE_WF_MEM 29
<c>PDEL_MODE_AK_SAF 30
<c>PDEL_MODE_AK_DQF 31
<c>PDEL_MODE_AK_NET 32
<c>PDEL_MODE_AK_RCM 33
<c>PDEL_MODE_AK_MEM 34
<c>PDEL_MODE_NN_SAF 35
<c>PDEL_MODE_NN_DQF 36
<c>PDEL_MODE_NN_NET 37
<c>PDEL_MODE_NN_RCM 38
<c>PDEL_MODE_NN_MEM 39
<c>PDEL_MODE_WF_DEQ 40
<c>PDEL_MODE_AK_DEQ 41
<c>PDEL_MODE_WF_CONF 42
<c>PDEL_MODE_AK_CONF 43
<c>PDEL_MODE_WF_ACK 44
<c>PDEL_MODE_AK_ACK 45

och möjliga alternativ om meddelandet inte kan levereras:

PDEL_UMA_RTS 1
PDEL_UMA_DLJ 2
PDEL_UMA_DLQ 3
PDEL_UMA_SAF 4
PDEL_UMA_DISC 5
PDEL_UMA_DISCL 6

Alla kombinationer är inte tillåtna (se BEA Message Queue dokumentationen för mer info).


Följande kombinationer rekommenderas,

för säker leverans av meddelanden
Address[2] = 26
Address[3] = 4

och för att kasta meddelanden som inte kan levereras
Address[2] = 39
Address[3] = 5

Om Address[2,3] båda har satts till 0 kommer en default uppsättning att användas, som kastar
meddelanden som inte kan levereras.

<h2>Ta emot meddelanden
Address[0,1] används för att idenfiera meddelandet. Address[0] representerar meddelande-klassen 
och Address[1] meddelande-typen (enligt BMQ-nomenkatur).
</topic>

<topic> serial
Seriell
RemoteSerial är ett försök för generall användning av enkla seriella kommunikations-protokoll.
Det är användbart när man har en envägs sändning av meddelanden från någon typ av utrustning
till styrsystemet. Man kan specifiera upp till åtta terminierings tecken i attributet
TermChar[0-7]. Terminerings-tecknen används för att detektera slutet på ett mottaget
meddelande (dvs ett tecken matchar något av terminieringstecken). Specificera också inställningen
för den seriella porten, dvs DevName, Speed, Parity (0 = ingen, 1 = udda, 2 = jämn), StopBits
och DataBits. De kan t ex vara /dev/ttyS0, 9600, 0, 1, 8.
</topic>

<topic> 3964r
3964-R
3964R är ett enkelt seriellt kommunikations-protokoll utvecklat av Siemens.

Man specificerar inställningen för den serialla porten med RemnodeSerial, med undantag för stop
bitar. Man måste även ange tecken timeout (maximal tid mellan ankomna tecken) i attributet
CharTimeout. I AckTimeout attributet anges tiden man väntar för ett svar. 

Meddelandne skickas rak på utan header. ACK, NAK, DLE och BCC hanteras enligt 3965R protokollet.

<h2>Ta emot meddelanden
Det kan endast finnas ett RemTrans objekt för mottagning pga att det saknas header i 
protokollet. Varje mottaget meddelande läggs i första bästa RemTrans objekt under RemNode
objektet. Om buffer objektet är tillräckligt stort för meddelandet lagras meddelandet i 
buffer-objektet och DataValid flaggan sätts.

<h2>Skicka meddelanden
Transporten sänder 3964R meddelanden utan att addera någon header.
Om man inte har kontakt med den andra noden kommer meddelandet att buffras, förutsatt att det
finns fria buffrar för meddelandet.
</topic>

<topic> modbus-serial
Modbus Serial
MODBUS formatet som är implementerat är RTU. För att identifiera meddelanden används fälten för
slav-adress och funktions-kod i MODBUS headern. I RemTrans[0] och [1] anges dessa värden i 
Proview världen. Se MODBUS specifikationen för mer info.

Modbus Serial är ännu inte implementerat som ett I/O system i Proview. Man måste konfigurera
meddelandena genom att använda RemnodeModbus och specifiera RemTrans-objekt för de olika
operationerna man vill utföra. Modbus arbetar i en fråga/svara mod så att för varje operation
som ska utföras, specifieras ett RemTrans-objekt för sändning och ett för mottagning.
Modbus-headern i meddelandet och checksummehanteringen görs automatisk, men man måste specifiera 
innehållet i meddelandet för inläggning till sänd-bufferten. På samma sätt måste man avkoda
innehållet i mottagna meddelanden.

Modbus TCP är implementerat som ett I/O system i Proview, Se mer information om detta i
dokumentet "Guide to I/O Systems". Med Modbus TCP behöver man inte hantera avkodning av 
meddeladen.

<h2>Ta emot meddelanden
När ett meddelande tas emot, letas efter den RemTrans med Address[0] och [1] som matchar fälten
för slav-adress och funktions-kod i meddelandets header. Om buffer-objektet är tillräckligt
stort, lagra meddelandet och DataValid flaggan sätts.

<h2>Skicka meddelanden
Meddelanden som sänds använder innehållet i RemTrans.Address[0] och [1} för fälten för
slav-adress och funktions-kod i meddelandets header.
</topic>
</headerlevel>

<topic> an_example
Ett exempel
För att visa hur man arbetar med de klasser som översikligt beskrivits ovan, startar vi med 
ett litet exempel. Klasserna beskrivs med detaljerat nedan.

I vårt exempel har vi ett Proview system som kommunicerar med en annan nod via UDP/IP. Vi vill
skicka ett antal meddelanden i båda riktningarna. Min nod heter 'dumle' och remote noden heter
'asterix'.

Meddelanden vi ska sända är:

d_a_RequestData <t> 4 Byte
d_a_Report <t> 20 Byte

och meddelanden som vi ska ta emot:

a_d_Data <t> 365 Byte (as an answer to the d_a_RequestData-message)
a_d_Error <t> 10 Byte

Konfigurationen i nod-hierakin ser ut så här.

Under RemoteConfig-objektet ligger ett RemnodeUPD objekt, där IP-address, nodnamn och
port-nummer är konfigurerade.

<image> dg_fig70.png

Under RemnodeUPD-objeketet ligger fyra RemTrans objekt, ett för varje meddelande. I remtrans-
objekten har riktningen (send eller receive) konfigurerats. Adresserna är numrerade för att
kunna särskilja meddelandena, och meddelandenas storlek är angiven.

<image> dg_fig71.png

Under remtrans-objektet ligger buffer-objektet. För de mindre meddelandena används Buff256 objekt.
Data meddelandet är större och använder ett Buff1440 objekt.

<image> dg_fig72.png

<h2>Data-strukturen
Data-strukturen för meddelandena är definierad i filen ra_plc_user.n i $pwrp_inc katalogen. Den
här filen inkluderas automatiskt vid kompilering av plc-koden. Data-strukturen ser ut så här:

<c>typedef struct {
<c>  pwr_tUInt32  Id;
<c>} d_a_RequestData;
<c>
<c>#define pwr_sClass_d_a_RequestData d_a_RequestData
<c>
<c>typedef struct {
<c>  pwr_tUInt32   Id;
<c>  pwr_tFloat32  data_1;
<c>  pwr_tInt32    data_2;
<c>  pwr_tInt32    data_3;
<c>  pwr_tInt32    data_4;
<c>} d_a_Report;
<c>
<c>#define pwr_sClass_d_a_Report d_a_Report
<c>
<c>typedef struct {
<c>  pwr_tUInt32   Id;
<c>  pwr_tFloat32  data_1;
<c>  ...
<c>  ...
<c>  pwr_tInt32    data_xx;
<c>} a_d_Data;
<c>
<c>#define pwr_sClass_a_d_Data a_d_Data
<c>
<c>typedef struct {
<c>  pwr_tUInt32   Id;
<c>  pwr_tInt32    func_no;
<c>  pwr_tInt16    err_code;
<c>} a_d_Data;
<c>
<c>#define pwr_sClass_a_d_Error a_d_Error

<h2>Plc-koden

Koden ligger i ett PlcPgm med namnet Comm. I programmet finns ett RemTransSend-objekt och
ett RemTransRcv objekt. Dess objekt återfinns under mappen 'Other' i paletten i plc-editorn.
Till RemTransSend-objektet kopplas den RemTrans som ska sändas. I det här fallet
d_a_RequestData meddelandet. Meddelandet sänds när Dv-signalen "RequestData" sätts. På samma
sätt är a_d_Data meddelandet kopplat till RemTransRcv-objektet som tar emot svarsmeddelandet
på request meddelandet.

<image> dg_fig73.png

Både RemTransSend och RemTransRcv-objekten har underfönster. För RemTransSend, kommer 
underfönstret att exekveras vid en positiv flank på snd-ingången. När underfönstret har
exekverats, sätts DataValid attributet i det kopplade RemTrans-objektet, och transport-processen
för den aktuella Remnoden skickar iväg meddelandet och sätter DataValid till 0.

För RemTransRcv exekveras underfönstret när DataValid attributet i det kopplade RemTrans-objektet
sätts. När transport-processen för den aktuella Remnoden tar emot ett meddelande, fyller den i
buffer-objektet med meddelandet och sätter DataValid flaggan. När underfönstret har exekverat
återställs DataValid flaggan.

<h2>Underfönstret för sändning
I send underfönstret fyller man i data för sänd-bufferten. Buffer-objektet för meddelandet kopplas
till en DataArithm. Den speciella 'classdef'-syntaxen castar Da1 till en pekare till en
d_a_RequestData struct (eller närmare bestämt till en pekare till pwr_sClass_d_a_RequestData,
därför finns define-satsen för denna i inkludefilen ovan).

<image> dg_fig74.png

<h2>Underfönstret för mottagning
I mottagnings-underfönstret packas det mottagna meddelandet upp. Buffer-objektet för mottagningen
kopplas till en DataArithm. Återigen använder vi classdef-satsen för att casta Da1 pekaren.
Data packas upp och läggs på DataArithm-objektets utgångar. Om inte utgångarna för en DataArithm
räcker till adderar man flera DataArithm-objekt och fortsätter på samma sätt.

<image> dg_fig75.png

</topic>
</chapter>

<chapter>
<topic> dg_application
Applikationsprogrammering

Det här kapitlet handlar om hur man skriver applikations program, dvs program i c, c++ eller
java som knyter upp sig mot Proview. Det förutsätts all läsaren har grundkunskaper i dessa
språk.

För många tillämningar går det utmärkt att koda all styrning grafisk med hjälp av plceditorn.
Men det finns även tillämpningar som med grafisk programmering blir onödigt komplexa som t ex
avancerade modeller, databashantering och materialstyning. Man skriver då ett applikationsprogram
i c, c++ eller java som knyter upp sig mot realtids databasen rtdb. Programmet läser indata från
rtdb, gör sina beräkningar och sätter utdata i rtdb där det t ex vidareprocessas av 
plc-programmet, skickas ut till I/O systemet och visas upp i operatörsbilder.

c++ är det programmeringsspråk som är vanligast vid applikations programmering och även mest
utbyggt, vi kommer därför att koncentrera oss på detta. De funktioner som används finns närmare 
beskrivna i Programmer's Reference Manual (PRM).

<option> printdisable
Knyta upp sig mot realtidsdatabasen och hantera objekt och data. <link> dg_appl_gdh
Skriva på konsolloggen. <link> dg_appl_errh
Start av applikation. <link> dg_appl_file
Hantera systemhändelser. <link> dg_appl_inievents
Basklass för applikationer rt_appl. <link> dg_appl_rtappl
Skicka meddelanden och larm. <link> dg_appl_mh
Kommunicera med andra processer via Qcom. <link> dg_appl_qcom
Hämta data from lagrings stationer. <link> dg_appl_sev
Läsning och skrivning mot I/O systemet. <link> dg_appl_io
Bygga en applikation med make. <link> dg_appl_build
Java applikationer. <link> dg_appl_java
<option> printenable
</topic>

<headerlevel>

<topic> dg_appl_gdh
Knyta upp sig mot databasen och hantera objekt och data

Vi börjar med att skriva ett enkelt c++ program som knyter upp sig mot realtidsdatabasen och
länkar sig mot några objekt.

cpp-filen bör ligga på $pwrp_src katalogen, eller på på någon underkatalog till denna. Vi skapar
katalogen $pwrp_src/myappl och editerar filen ra_myappl.cpp.

<h1>Datatyper
I include-filen pwr.h finns de grundläggande datatyperna i Proview definierade. De vanligaste
är pwr_tBoolean som används för digitala signaler och pwr_tFloat32 för analoga signaler, men 
där finns även c-typer för alla andra Proview-typer, t ex pwr_tInt32, pwr_tUInt32, pwr_tString80 
etc.

<h1>Initiering av gdh
Uppknytningen mot databasen görs med anropet gdh_Init() där man skickar med en sträng som 
identifierar applikationen. Först inkluderar vi pwr.h som innehåller grundtyperna i Proview
och rt_gdh.h som innehåller grånssnittet mot realtidsdatabasen.

<c>#include "pwr.h"
<c>#include "rt_gdh.h"

<c>int main() {
<c>  pwr_tStatus sts;

<c>  sts = gdh_Init( "ra_myappl");
<c>  if ( EVEN(sts)) {
<c>    cout << "gdh_Init failure " << sts << endl;
<c>    exit(0);
<c>  }
<c>}

Funktionen returnerar en status variabel av typen pwr_tStatus. En jämn status innebär att 
något är fel, udda att anropet gick bra. Status kan även översättas till en sträng som ger 
mer information om vad som är fel, vilket beskrivs närmare längre fram.

<h1>Läsa och skriva värden
Om vi vill skriva och läsa ett attribut i ett object kan man använda funktionerna 
gdh_SetObjectInfo() och gdh_GetObjectInfo().  

En läsning resp skrivning av Dv'n H1-H2-Start kan se ut så här. Notera att värdet av Dv'n 
ligger i attributet ActualValue

<c>pwr_tBoolean value;

<c>sts = gdh_GetObjectInfo( "H1-H2-Start.ActualValue", &value, sizeof(value));
<c>if (ODD(sts)) {
<c>  value = !value;
<c>  sts = gdh_SetObjectInfo( "H1-H2-Start.ActualValue", &value, sizeof(value));
<c>}

<h1>Direktlänka mot attribut
Ofta är ligger applikationsprogram i en oändlig loop och övervakar attribut i databasen
och reagerar på vissa förändringar. Då är det bättre att direktlänka sig mot attributet,
dvs skaffa en pekare. Det gör man med gdh_RefObjectInfo(). Ofta delar man upp programmet 
i en init() funktion som direktlänkar till attribut, en scan() funktion som som
innehåller övervakning och styrfunktioner, och en close() funktion tar ner direktlänkningarna.

<c>class ra_myappl {
<c>  pwr_tBoolean *start_ptr;
<c>  pwr_tRefId dlid;
<c> public:
<c>  ra_myappl() {}
<c>  void init();
<c>  void scan();
<c>  void close();
<c> };

<c>void ra_myappl::init()
<c>{
<c>  sts = gdh_RefObectInfo( "H1-H2-Start.ActualValue", &start_ptr, &dlid, 
<c>                          sizeof(*start_ptr));
<c>  if ( EVEN(sts)) exit(0);
<c>}

<c>void ra_myappl::scan()
<c>{
<c>  for (;;) {
<c>    if ( *start_ptr) {
<c>      // Do something...
<c>      cout << "Starting" << endl;
	
<c>      *start_ptr = 0;

<c>    }
<c>    sleep(1);
<c>  }
<c>}

<c>void ra_myappl::close()
<c>{
<c>  gdh_UnrefObjectInfo( &dlid);
<c>}

I init() funktionen fylls pekaren start_ptr i så att den pekar på värdet för Dv'n H1-H2-Start
i databasen. 

<h2>Varning !
Notera att pekare i c kräver varsam hantering. Om man använder pekar-aritmetik eller indexerar 
i vektorer är det lätt hänt att man pekar fel och skriver på fel ställe i databasen. Detta kan 
ge upphov till fel som är svåra att hitta orsaken till.

<h1>Direktlänka mot objekt
gdh_RefObjectInfo() kan förutom att direktlänka mot enskilda attribut, också direklänka mot 
objekt och attributobjekt.

Antag att vi vill fylla i punkter i en kurva och visa upp i en bild. Vi vill direktlänka till
objektet H1-H2-Curve som är av klassen XyCurve. Includefilen pwr_baseclasses.hpp innehåller
en c++ klass, pwr_Class_XyCurve, för objektet.

<c>#include <math.h>
<c>#include "pwr.h"
<c>#include "pwr_baseclasses.hpp"
<c>#include "rt_gdh.h"

<c>class ra_myappl {
<c>  pwr_Class_XyCurve *curve_ptr;
<c>  pwr_tRefId dlid;
<c> public:
<c>  ra_myappl() {}
<c>  void init();
<c>  void scan();
<c>  void close();
<c> };

<c>void ra_myappl::init()
<c>{
<c>  pwr_tStatus sts;
<c>  pwr_tOName name = "H1-H2-Curve";

<c>  // Connect to database
<c>  sts = gdh_Init( "ra_myappl");
<c>  if ( EVEN(sts)) exit(0);

<c>  // Direct link to curve object
<c>  sts = gdh_RefObjectInfo( name, (void **)&curve_ptr, &dlid, sizeof(*curve_ptr));
<c>  if ( EVEN(sts)) exit(0);
<c>}

<c>void ra_myappl::scan()
<c>{
<c>  for ( unsigned int i = 0;;i++) {
<c>    if ( i % 5 == 0) {
<c>      // Calculate x and y coordinates for a sine curve every fifth second
<c>      for ( int j = 0; j < 100; j++) {
<c>        curve_ptr->XValue[j] = j;
<c>        curve_ptr->YValue[j] = 50 + 50 * sin( 2.0 *  M_PI * (j + i) / 100);
<c>      }
<c>      // Indicate new curve to graph
<c>      curve_ptr->Update = 1;
<c>    }
<c>    else if ( i % 5 == 2)
<c>      curve_ptr->Update = 0;
<c>    sleep(1);
<c>    if ( i > 360)
<c>      i = 0;
<c>  }
<c>}

<c>void ra_myappl::close()
<c>{
<c>  gdh_UnrefObjectInfo( dlid);
<c>}


<c>int main()
<c>{
<c>  ra_myappl myappl;

<c>  myappl.init();
<c>  myappl.scan();
<c>  myappl.close();
<c>}

Programmet kompileras och länkas med

<c>> g++ -g -c  ra_myappl.cpp -o $pwrp_obj/ra_myappl.o -I$pwr_inc -DOS_LINUX=1 
<c>      -DOS=linux -DHW_X86=1 -DHW=x86
<c>> g++ -g -o $pwrp_exe/ra_myappl $pwrp_obj/ra_myappl.o $pwr_obj/pwr_msg_rt.o 
<c>      -L$pwr_lib -lpwr_rt -lpwr_co -lpwr_msg_dummy -lrt

Senare ska vi se hur man använder make för att kompilera och länka.

Om vi öppnar objektsbilden för H1-H2-Curve objektet kan vi studera resultatet.

<image> dg_fig93.png
<b>Fig Objektbild for kurvobjektet

</topic>

<topic> dg_appl_errh
Konsollogg

<h1>Logga på konsolloggen
<h2>Konsollog
Konsolloggen innehåller diverse loggning från systemprocesser. Om systemet går orent bör man 
titta på för att se om någon process loggar felmeddelanden. Den ligger som en textfil på
$pwrp_log, pwr_'nodename'.log, men kan även öppnas från med rt_xtt från  System/SystemMessages. 
Loggningarna har fem allvarlighetsnivåer fatalt, fel, varning, info och succé. Fatal och fel är 
rödfärgade, varning gulfärgad och info och succé grönfärgade.

Även applikationer kan skriva på konsollogen. Först initierar man konsollogen med errh_Init(),
sedan kan man skriva meddelanden av olika allvarlighetsgrad med errh_Fatal(), errh_Error(),
errh_Warning(), errh_Info() och errh_Success().

errh_Init() anropas före gdh_Init() och har som argument ett namn på applikationen samt ett
applikationsindex som anges med errh_eAnix_Appl1, errh_eAnix_Appl2 etc. Varje applikation ska 
ha ett unikt applikationsindex inom noden.

<c>#include "rt_errh.h"

<c>sts = errh_Init( "ra_myappl", errh_eAnix_Appl1);

Till logg funktionerna skickar man den sträng som ska skriva ut i loggen, t ex

errh_Error( "Something went wrong");

Strängen kan även fungera som formatsats som kan innehålla %s för att formatera strängar, %f
för flyttal och %d för heltal, se printf för mer info.

<c>errh_Error( "Number is to high: %d", n);

Formatet %m översätter en statuskod till motsvarande text

<c>catch ( co_error e) {
<c>  errh_Error( "Error status: %m", e.sts());
<c>}

<h1>Applikations status
Varje applikation har ett statusord i $Node objektet. Det ligger i attributet ProcStatus[]
i elementet applikationsindex + 20. Detta ska återspegla applikationens tillstånd och 
sätts av applikationen själv med med funktionen errh_SetStatus().

<c>errh_SetStatus( PWR__ARUN);

PWR__ARUN är definierad i rt_pwr_msg.h och länkad till texten "Application running".

Andra användbara status är

PWR__APPLSTARTUP "Application starting up"  (info)
PWR__APPLRESTART "Application restaring"  (info)
PWR__APPLTERM    "Application terminated"  (fatal)

I nodobjektet finns en systemstatus som är en slags summa av status för alla serverprocesser
och applikationsprocesser. I systemstatus läggs den server- eller applikation-status som har
den högsta allvarlighetsgraden.

<h1>Övervakning
En applikation som har anropat errh_Init övervakas av systemet. Den ska anropa funktionen
aproc_TimeStamp() cykliskt, annars sätts applikationsstatus till "Process timeout" (fatal).
Timeouttiden för applikaioner är 5 s. 

<h1>Applikationobjekt
Man kan även skapa ett applikationsobjekt för applikationen. Detta läggs under i nodhierkin
under $Node objektet och är av klassen Application.

Applikationsobjektet registreras med funktionen aproc_RegisterObject() som har 
objektsidentiteten för objektet som argument.

<c>pwr_tObjid aoid;
<c>pwr_tOName name = "Nodes-MyNode-ra_myappl";

<c>sts = gdh_NameToObjid( name, &aoid);
<c>if (EVEN(sts)) throw co_error(sts);

<c>sts = aproc_RegisterObject( aoid);
<c>if (EVEN(sts)) throw co_error(sts);

<h1>Statusbilden
Applikationen visas i statusbilden för noden, om applikationen har initierat errh och 
registrerat applikationsobjektet. Den kommer att visas under 'Application' på den rad som 
motsvara applikationsindex. I bilden visas status för applikationen och senaste/allvarligaste
loggmeddelande.

<image> dg_fig94.png
<b>Fig Detalj ur nodbilden visar status och loggmeddelande för applikationen.

Om processen haltas sätts status till timeout, detta påverkar även systemstatus.

<image> dg_fig95.png
<b>Fig Applikationen har haltats.

<b>Exempel
I det här exemplet har vi jobbat vidare med programmet för xy-kurvan ovan, och fört in
anrop för att sätta applikationsstatus, logga på konsolloggen och registrera 
applikationsobjektet.

<c>#include <math.h>
<c>#include <iostream>
<c>#include "pwr.h"
<c>#include "pwr_baseclasses.hpp"
<c>#include "rt_gdh.h"
<c>#include "rt_errh.h"
<c>#include "rt_aproc.h"
<c>#include "rt_pwr_msg.h"
<c>#include "co_error.h"

<c>class ra_myappl {
<c>  pwr_Class_XyCurve *curve_ptr;
<c>  pwr_tRefId dlid;
<c> public:
<c>  ra_myappl() {}
<c>  void init();
<c>  void scan();
<c>  void close();
<c>};

<c>void ra_myappl::init()
<c>{
<c>  pwr_tStatus sts;
<c>  pwr_tOName name = "H1-H2-Curve";
<c>  pwr_tObjid aoid;

<c>  // Init errh with anix 1
<c>  sts = errh_Init( "ra_myappl", errh_eAnix_appl1);
<c>  if ( EVEN(sts)) throw co_error(sts);

<c>  // Write message to consolelog and set application status
<c>  errh_Info( "I feel fine");
<c>  errh_SetStatus( PWR__APPLSTARTUP);

<c>  // Connect to database
<c>  sts = gdh_Init( "ra_myappl");
<c>  if ( EVEN(sts)) throw co_error(sts);
 
<c>  // Register application object
<c>  sts = gdh_NameToObjid( "Nodes-Saturnus7-ra_myappl", &aoid);
<c>  if ( EVEN(sts)) throw co_error(sts);

<c>  aproc_RegisterObject( aoid);

<c>  // Directlink to curve object
<c>  sts = gdh_RefObjectInfo( name, (void **)&curve_ptr, &dlid, sizeof(*curve_ptr));
<c>  if ( EVEN(sts)) throw co_error(sts);

<c>  errh_SetStatus( PWR__ARUN);
<c>}

<c>void ra_myappl::scan()
<c>{
<c>  for ( unsigned int i = 0;;i++) {
<c>    // Notify that we are still alive
<c>    aproc_TimeStamp();
<c>
<c>    if ( i % 5 == 0) {
<c>      for ( int j = 0; j < 100; j++) {
<c>        curve_ptr->XValue[j] = j;
<c>        curve_ptr->YValue[j] = 50 + 50 * sin( 2.0 *  M_PI * (j + i) / 100);
<c>      }
<c>      curve_ptr->Update = 1;
<c>    }
<c>    else if ( i % 5 == 2)
<c>      curve_ptr->Update = 0;
<c>    sleep(1);
<c>    if ( i > 360)
<c>      i = 0;
<c>  }
<c>}

<c>void ra_myappl::close()
<c>{
<c>  gdh_UnrefObjectInfo( dlid);
<c>}


<c>int main()
<c>{
<c>  ra_myappl myappl;

<c>  try {
<c>    myappl.init();
<c>  }
<c>  catch ( co_error e) {
<c>    errh_Fatal( "ra_myappl terminated, %m", e.sts());
<c>    errh_SetStatus( PWR__APPLTERM);
<c>    exit(0);
<c>  }
<c>  myappl.scan();
<c>  myappl.close();
<c>}

</topic>

<topic> dg_appl_file
Start av applikation

En applikation som ska startas vid uppstart av Proview runtime läggs in i applikationsfilen.
Det ligger på $pwrp_load och har namnet ld_appl_'nodename'_'qbus'.txt, t ex

<c>$pwrp_load/ld_appl_mynode_999.txt

I filen lägger man en rad för varje applikation som ska startas

<c># id       name      [no]load [no]run file       prio  [no]debug  "arg"
<c>ra_myappl, ra_myappl, noload,  run,   ra_myappl, 12,   nodebug,   ""

</topic>

<topic> dg_appl_inievents
Ta emot systemhändelser

Proview skickar ut medelanden vi olika händelser, t ex, när en mjuk omstart pågår eller
om runtimmiljön stoppas. En applikation kan avlyssna dessa händelser, för att t ex terminera
när Proview stoppas. Avlyssningen sker via Qcom. Man skapar en Qcom kö, och knyter denna
kö till den kö som meddelandena sänds ut på.

<c>#include "rt_qcom.h"
<c>#include "rt_ini_event.h"
<c>#include "rt_qcom_msg.h"

<c>qcom_sQid qid = qcom_cNQid;
<c>qcom_sQid qini;
<c>qcom_sQattr qAttr;

<c>if ( !qcom_Init(&sts, 0, "ra_myappl")) {
<c>  throw co_error(sts);

<c>// Create a queue to receive stop and restart events
<c>qAttr.type = qcom_eQtype_private;
<c>qAttr.quota = 100;
<c>if ( !qcom_CreateQ(&sts, &qid, &qAttr, "events"))
<c>  throw co_error(sts);

<c>// Bind to init event queue
<c>qini = qcom_cQini;
<c>if ( !qcom_Bind(&sts, qid, &qini))
<c>  throw co_error(sts);

I varje scan läser man av kön med qcom_Get() för att se om något meddelande har kommit. Man 
kan även passa på att använda timeouten i qcom_Get() för att vänta till nästa scan.
I exemplet nedan hanterar man dels terminate meddelandet, men även oldPlcStop och swapDone
som markerar början och slutet på en mjuk omstart. Det behöver man enbart göra om man vill att 
applikationen ska kunna upptäcka nya objekt eller konfigureringar vid en mjuk omstart.

<c>int tmo = 1000;
<c>char mp[2000];
<c>qcom_sGet get;
<c>int swap = 0;

<c>for (;;) {
<c>  get.maxSize = sizeof(mp);
<c>  get.data = mp;
<c>  qcom_Get( &sts, &qid, &get, tmo);
<c>  if (sts == QCOM__TMO || sts == QCOM__QEMPTY) {
<c>    if ( !swap)
<c>      // Do the normal thing
<c>      scan();
<c>  } 
<c>  else {
<c>    // Ini event received
<c>    ini_mEvent  new_event;
<c>    qcom_sEvent *ep = (qcom_sEvent*) get.data;

<c>    new_event.m  = ep->mask;
<c>    if (new_event.b.oldPlcStop && !swap) {
<c>      errh_SetStatus( PWR__APPLRESTART);
<c>      swap = 1;
<c>      close();
<c>    } else if (new_event.b.swapDone && swap) {
<c>      swap = 0;
<c>      open();
<c>      errh_SetStatus( PWR__ARUN);
<c>    } else if (new_event.b.terminate) {
<c>      exit(0);
<c>    }
<c>  }
<c>}

Om man endast är intresserad av att stoppa processen när Proview tas ner, finns det ett
enklare sätt att ta död på den. Man kan lägga en scriptfile pwrp_stop.sh på $pwrp_exe där 
man gör kill på processen. 

<c>killall ra_myappl

</topic>

<topic> dg_appl_rtappl
Basklass för applikationer rt_appl

Basklassen rt_appl innehåller mycket av de initieringar och övervakning av händelser som
är beskrivet ovan. Genom att subklassa rt_appl behöver man inte lägga in någon kod för detta
utan det utförs av rt_appl. rt_appl innehåller tre virtuella funktioner som ska implementeras
av subklassen, open(), close() och scan(). open() används vid initieringen för att direktlänka 
mot attribut och objekt, scan() blir anropad cykliskt med angiven scantid, och i close() tar 
man ner direktlänkningarna.

rt_appl gör följande:

- Initiera gdh, errh och qcom.
- Sätter applikationsstatus vid uppstart och omstart.
- Hanterar händelser för mjuk omstart och terminiering.
- Tidstämplar för undvika timeout.

I exemplet nedan kan vi se applikationen ra_appl som subklassar rt_appl.

<c>class ra_appl : public rt_appl {
<c>public:
<c> ra_appl() : rt_appl( "ra_appl", errh_eAnix_appl1) {}
<c> void open();
<c> void close();
<c> void scan();
<c>};

<c>void ra_appl::open()
<c>{
<c> // Link to database objects
<c>}

<c>void ra_appl::close()
<c>{
<c> // Unlink to database objects
<c>}

<c>void ra_appl::scan()
<c>{
<c> // Do something
<c>}

<c>int main()
<c>{
<c> ra_appl appl;

<c> appl.init();
<c> appl.register_appl( "Nodes-MyNode-MyAppl");

<c> appl.mainloop();
<c>}


</topic>

<topic> dg_appl_mh
Skicka larm och meddelanden

Från en applikation kan man även skicka larm och meddelanden till operatörens larm och 
händelselista. Först måste man knyta upp sig mot eventmonitorn med mh_ApplConnect(). Vi
skickar med objektidentiteten för applikationsobjektet som första argument.

<c>#include "rt_mh_appl.h"
<c>
<c>pwr_tUInt32 num;
<c>sts = mh_ApplConnect( aoid, mh_mApplFlags(0), "", mh_eEvent_Info, mh_eEventPrio_A,
<c>			mh_mEventFlags_Bell, "", &num);
<c>  if (EVEN(sts)) throw co_error(sts);

Därefter kan vi skicka larm med mh_ApplMessage().

<c>mh_sApplMessage msg;
<c>pwr_tUInt32 msgid;

<c>memset( &msg, 0, sizeof(msg));
<c>msg.EventFlags = mh_mEventFlags(mh_mEventFlags_Returned | 
<c>				  mh_mEventFlags_NoObject | 
<c>				  mh_mEventFlags_Bell);
<c>clock_gettime( CLOCK_REALTIME, &msg.EventTime);
<c>strcpy( msg.EventName, "Message from ra_myappl");
<c>strcpy( msg.EventText, "I'm up and running now !");
<c>msg.EventType = mh_eEvent_Alarm;
<c>msg.EventPrio = mh_eEventPrio_B;

<c>sts = mh_ApplMessage( &msgid, &msg);
<c>if (EVEN(sts)) throw co_error(sts);    

<image> dg_fig96.png
<b>Fig Larmet i larmlistan
</topic>

<topic> dg_appl_qcom
Kommunicera med andra processer

Proview's protokoll för kommunikation mellan processer kan med fördel användas även av
applikationer. Kommunikation kan ske 

- mellan processer inom samma nod.
- mellan processer på olika noder som tillhör samma projekt.
- mellan processer på noder som tillhör olika projekt, om projekten tillhör samma Qcom bus. I
  det här fallet måste noderna konfigureras med FriendNodeConfig objekt där Connection sätt 
  till QcomOnly.

Läs mer om Qcom i Qcom Reference Guide.
</topic>

<topic> dg_appl_sev
Hämta data från lagringsstation

Data som finns lagrat på en Proview lagringsstation kan hämtas med klient gränssnittet sevcli.
Först initierar man sevcli med sevcli_init() och anger vilken lagringsstation man ska hämta
data ifrån med sevcli_set_servernode().

<c>sevcli_tCtx sevctx;
<c>char server_node[40] = "MyStorageStation";

<c>if ( !sevcli_init( &sts, &sevctx))
<c>  throw co_error(sts);

<c>if ( !sevcli_set_servernode( &sts, sevctx, server_node))
<c>  throw co_error(sts);

Därefter kan man hämta data med sevcli_get_itemdata(). Data identifieras med objektsidentitet
och attribut, dessutom anger man tidsintervall för det data som ska hämtas, och max antal
punkter.

<c>pwr_tTime *time_buf;
<c>void *value_buf;
<c>pwr_tTime from = pwr_cNTime;
<c>pwr_tTime to = pwr_cNTime;
<c>int rows;
<c>pwr_eType vtype;
<c>unsigned int vsize;
<c>pwr_tOName name = "H1-H2-Temperature";
<c>pwr_tOName aname = "ActualValue";
<c>pwr_tObjid oid;
<c>char timstr[40];

<c>sts = gdh_NameToObjid( name, &oid);
<c>if (EVEN(sts)) throw co_error(sts);

<c>if ( !sevcli_get_itemdata( &sts, sevctx, oid, aname, from, to, 1000, &time_buf, &value_buf,
<c>                           &rows, &vtype, &vsize))
<c>  throw co_error(sts);

<c>for ( int i = 0; i < rows; i++) {
<c>  time_AtoAscii( &time_buf[i], time_eFormat_DateAndTime, timstr, sizeof(timstr));
<c>
<c>  cout << timstr << " " << ((pwr_tFloat32 *)value_buf)[i] << endl;
<c>}

<c>free( time_buf);
<c>free( value_buf);

Slutligen anropar man sevcli_close() för att koppla ner anslutningen mot servernoden.

<c>sevcli_close( &sts, sevctx);

</topic>

<topic> dg_appl_io
I/O hantering

Har man stora krav på snabbhet och synkronisering kan en applikation arbeta direkt mot 
I/O systemet och själv läsa in och ställa ut data.

Initieringen sker med funktionen io_init() till vilken man bl a skickar argumentet process.
Process identifierar vilka io-enheter (agent, rack eller kort) som ska hanteras av en 
viss process. Varje io-objekt har ett Process attribut som är en bitmask, och om detta
överensstämmer med det som skickas som argument till io_init, kommer enheten att hanteras
av applikationen.  Om ett kort hanteras av en applikation måste även det rack och den agent 
som kortet tillhör, hanteras av applikationen. 

Eftersom Process-attributet är en bitmask kan en enhet hanteras av flera processer, genom att 
flera bitar sätts. Om man t ex har flera kort i ett rack, och vissa kort hanteras av
plc-processen och vissa av en applikation, måste rack-enheten hanteras av både plc't och 
applikationen. Hur och om det fungerar att låta en enhet hanteras av flera processer beror 
på hur io-metoderna är skrivna. För Profibus t ex, kan man inte dela upp hanteringen av slavar
på olika processer.

<c>#include rt_io_base.h

<c>io_tCtx io_ctx;

<c>sts = io_init( io_mProcess_User, pwr_cNOid, &io_ctx, 0, scantime);
<c>if ( EVEN(sts)) {
<c>  errh_Error( "Io init error: %m", sts);
<c>  throw co_error(sts);
<c>}

Läsning sker med io_read() som läser data från io-enheterna och lägger ut i värdena i de
signaler som hör till enheten. Lämpligtvis direktlänkar sig applikationen mot dessa signaler
och även mot signalerna för utenheterna som skrivs med funktionen  io_write(). 

<c>sts = io_read( io_ctx);

<c>sts = io_write( io_ctx);

</topic>

<topic> dg_appl_build
Bygga en applikation

En c++ applikation måste kompileras och länkas, och man kan använda make för detta. Proview
har en regelfil $pwr_exe/pwrp_rules.mk som bl a innehåller regler för kompilering.

En make fil för applikationen ra_myappl på katalogen $pwrp_src/myappl kan se ut på så här
($pwrp_src/myappl/makefile): 

<c>ra_myappl_top : ra_myappl

<c>include $(pwr_exe)/pwrp_rules.mk

<c>ra_myappl_modules : \ 
<c>		$(pwrp_obj)/ra_myappl.o \ 
<c>		$(pwrp_exe)/ra_myappl

<c>ra_myappl : ra_myappl_modules
<c>	@ echo "ra_myappl built"

<c>#
<c># Modules
<c>#

<c>$(pwrp_obj)/ra_myappl.o : $(pwrp_src)/myappl/ra_myappl.cpp \ 
<c>                          $(pwrp_src)/myappl/ra_myappl.h

<c>$(pwrp_exe)/ra_myappl : $(pwrp_obj)/ra_myappl.o
<c>	@ echo "Link $(tname)"
<c>	@ $(ldxx) $(linkflags) -o $(target) $(source) -lpwr_rt -lpwr_co \ 
<c>		-lpwr_msg_dummy -lrpcsvc -lpthread -lm -lrt

Makefilen kan exekveras genom att man ställer sig på den aktuella katalogen och skriver make

<c>make

Man kan även lägga in byggkommandot i Application objektet för applikationen i attributet
BuildCmd. I det här fallet blir byggkommandot

<c>make -f $pwrp_src/myappl/makefile

Det här kommandot exekveras då i samband med att nod byggs från konfiguratören. På det här 
sättet kan man försäkra sig om att alla applikationer uppdateras när nod byggs om.

</topic>

<topic> dg_appl_java
Java applikationer

En del API finns även för java i form av klasserna Gdh, Errh och Qcom. Här följer en exempel
på en java applikation som knyter upp sig mot realtidsdatabasen och läser resp skriver ett
värde i den.

<c>import jpwr.rt.*;

<c>public class MyJappl {
<c>  public MyJappl() {
<c>    Gdh gdh = new Gdh( null);

<c>    CdhrBoolean rb = gdh.getObjectInfoBoolean( "H1-H2-Start.ActualValue");

<c>    PwrtStatus rsts = gdh.setObjectInfo( "H1-H1-Start.ActualValue", 
<c>					    !rb.value);
<c>  }

<c>  //Main method
<c>  public static void main(String[] args) {
<c>    new MyJappl();
<c>  }
<c>}

För att kompilera och exekvera måste man lägga in $pwr_lib/pwr_rt.jar och arbetskatalogen i 
CLASSPATH, samt $pwr_exe i LD_LIBRARY_PATH

<c>> export CLASSPATH=$pwr_lib/pwr_rt.jar:$pwrp_src/myjappl
<c>> export LD_LIBRARY_PATH=$pwr_exe

Kompilera med 
<c>> javac MyJappl.java

och kör med
<c>> java MyJappl

För auto-start skapar man ett script som exporterar CLASSPATH och LD_LIBRARY_PATH, och starar
java-applikationen. Scriptet läggs in i appl-filen på samma sätt som en c-applikation.

</topic>

</headerlevel>
</headerlevel>
</chapter>

<chapter>
<topic>ge_man
Skapa processbilder

Det här kapitlet beskriver hur man skapar processbilder.

Processbilder ritas och konfigureras i Ge editorn.

<h1>Ge editorn
Ge öppnas från menyn i konfiguratören, 'Functions/Open Ge'. Den består av

- en verktygspanel.
- en arbetsarea.
- en subgraf palett.
- en färg palett.
- ett fönster som visa anläggningshierakin.
- ett navigationsfönster.

<h2>Bakgrundsbild

En bakgrundsbild ritas med basobjekt som rektanglar, cirklar, linjer, polylinjer och texter.
Dessa hittar man i verktygspanelen. Skapa att basobjekt genom att aktivera tryckknappen i
verktygspanelen, och dra eller klicka med MB1 i arbetsarean. Om basobjektet ska vara fyllt,
väljer man objektet och aktiverar 'Fill' i vertygspanelen. Man ändar fyllnadsfärg genom att 
välja ut objektet och klicka på den önskade färgen i färgpaletten. Kantfärg ändras genom att 
man klickar med MB2 i färgpaletten, och textfärg med Shift/Klick MB1.

<h2>Subgrafer
En subgraf är en komponent, t ex en ventil, en motor eller en tryckknapp. För att skapa en
subgraf väljer man ut subgrafen i subgraf paletten, och klickar med MB2 i arbetsarean.

<h2>Grupper
Basobjekt och subgrafsobjekt kan grupperas genom att välja ut dem, och aktivera
'Functions/Group' i menyn.


<h2>Dynamik
Subgrafer och grupper har dynamiska egenskaper, dvs de kan kopplas till en signal i runtime
databasen, och ändra färg, position eller form beroende på signalernas värde. En subgraf
har ofta en default dynamik, t ex en indikator kan skifta mellan två färger. Man behöver 
endast koppla ventilen till en digital signal för att den ska fungera. Det här görs genom att 
välja ut signalen i anläggningshierakin, och klicka på ventilen med Ctrl/dubbelklick MB1.

En tryckknapp har aktions egenskaper, den sätter, återställer eller togglar en 
signal i databasen. En knapp med sätt-aktion skapas genom att välja en ButtonSet i subgraf
paletten under mappen Pushbuttons, och klicka med MB2 i arbetsaran. Den signal som ska sättas
kopplas som tidigare genom att välja ut signalen och klicka med Ctrl/dubbelklick MB1 på
tryckknappen.

<b>Koppla en subgraf till en signal
<image> dg_fig63.gif

Även grupper har dynamik, dvs de kan skifta färg, ändra position, eller utföra någon aktion.
De har inte någon default dynamik eller defaultfärg som subgraferna, utan detta måste anges
för varje grupp

<h2>Attribut editor
Basobjekt, subgrafsobjekt och grupper har olika attribut, som man påverkar från 
objekteditorn. Objekteditorn öppnas genom att man väljer ut objektet, och aktivera 
'Function/Object attributes' i menyn. Genom att ta upp attributseditorn för tryckknappen 
ovan, kan man t ex mata in en text som visas på tryckknappen i attributet 'Text'.

Om en subgraf har med avancerad dynamik, t ex växla mellan flera färger, så måste man ofta
koppla den till flera signaler. Om man t ex, öppnar men attributeditorn för en ventil, ser 
man att den kan kopplas till två attribut, 'DigError.Attribute' och 'DigLowColor.Attribute'.
DigError attributet markera att någonting är fel, och om denna signal är sann, färgas
ventilen röd. DigLowColor attributet kopplas till ventilens gränsläge. Om denna signal är
falsk, färgas ventilen i den färg som anges i 'DigLowColor.Color'. Är signalen sann, behåller
ventilen den färg som den ges i editorn. Signalerna för de två attributen läggs in genom att
man väljer ut respektive attribut i anläggningshierakin, och klickar med Ctrl/Dubbelklick MB1
på attributraden i attributeditorn. Färgen 'DigLowColor' anges genom att öppna attributet
och välja ut en av de 300 färgerna. Färgerna ligger i samma ordning som i färgpaletten och
med lite övning identifieras med hjälp av namnet.

<b>Attributeditorn för en ventil
<image>dg_fig64.gif

<h2>Bildområde
Ritarean i Ge är obegränsad i alla riktningar, så innan man sparar bilden, ska man ange
gränserna för bilden i x och y-led. Öppna graf attributen med 'File/Graph attributes' i 
menyn. Mät upp koordinaterna för övre vänstra hörnet, och mata in dem i x0 och y0, mät sedan
upp koordinaterna för nedre högra hörnet och mata in dem i x1 och y1. Mätningen görs genom
att placera makören på positionen och läsa av koordinaterna på informations raden.

<b>Graf attribut
<image>dg_fig65.gif

<h1>Konfigurering i arbetsbänken
<h2>XttGraph objektet
Till varje processbild hör ett XttGraph objekt. Det här objektet är vanligtvis ett barn till
operatörsplats objektet (OpPlace) för noden, på vilken bilden ska visas. Man behöver ett
XttGraph objekt på varje node, som bilden ska visas på. Däremot behöver man enbart en graf 
fil. Följande attribut i XttGraph objektet ska ges lämpliga värden:

- Action, namnet på pwg filen, inklusive filtyp, t ex 'hydr.pwg'.
- Title, titel på bildfönstret.
- ButtonText, text på tryckknappen i grafikfönstret.

XttGraph objektet innehåller andra attribut som t ex bestämmer bildfönstrets storlek och läge
på skärmen. Dessa attribut beskrivs i detalj i objektshanboken.
Se XttGraph i Objektshandboken <classlink>xttgraph,"",$pwr_lang/pwrb_xtthelp.dat
</topic>
</chapter>


<chapter>
<topic> dg_web_interface
Java operatörsmiljö

Proview innehåller förutom den ordinarie operatörsmiljön i X windows, även en operatörsmiljö 
skriven i java. Fördelen med java är att det går att köra i en web-läsare och på många olika 
plattformar. Nackdelen är att det är långsammare och har en begränsad funktionalitet.

<h1>Installation av java
<h2>Utvecklingsstation
För att exportera grafer till java måste Java Development Kit, jdk, vara installerat.
Ladda hem lämplig jdk från java.sun.com. Definera omgivningsvariabeln jdk till katalogen där 
paketet är uppackat, t ex /usr/local och lägg in $jdk/bin i PATH. Definera även jdk_home till
$jdk/bin

<c>export jdk=/usr/local/jdk1.6.0_10
<c>export PATH=$PATH:$jdk/bin
<c>export jdk_home=$jdk/bin

<h2>Process och operatörsstation
På process och operatörsstationerna måste Java Runtime Environment, jre, vara installerat.
Ladda hem från java.sun.com och packa upp under /usr/local. Även här måste jdk och jdk_home 
definieras (detta görs av /etc/pwrp_profile)

<c>export jdk=/usr/local/jre1.6.0_10
<c>export PATH=$PATH:$jdk/bin
<c>export jdk_home=$jdk/bin

<h1>Översikt
<h2>Webläsare (remote)
Java miljön kan startas i en webläsare, genom att man surfar in på projektets 
hemsida. Information om objekt, larm mm, hämtas från tre serverprocesser som
måste vara startade på den nod man läser in hemsidan ifrån, rt_webmon, rt_webmonmh och
rt_webmonelog. För att server-processerna ska starta krävs att ett WebHandler objekt
är konfigurerat i nodhierakin.

<image> dg_fig100.png
<b>Fig Hemsida för ett projekt

<h2>Lokalt
Java miljön kan även köras lokalt på en nod där Proview's runtime har startats.
Server-processerna för web-gränssnittet behöver inte startas, informationen hämtas
direkt ur realtidsdatabasen. 

Den lokala java miljön innehåller en meny, men inte någon höger ram, som websidan. Den
kan endast visa Ge grafer som java frame, inte som applets. Funktionerna larm fönster och 
händelselogg är inte implementerade för lokal körning.

För att köra lokalt krävs att man installerar lämplig jre från java.sun.com och definierar
omgivningsvariabeln jdk till att peka på jre installationen, t ex

<c>> export jdk=/usr/local/jre1.6.0.19

Operatörsmiljön startas sedan med kommandot

<c>> jpwr_opwind.sh

<image> dg_fig103.png
<b>Operatörsmeny vid lokal start

<h1>Konfigurering

<h2>Konfigurering av server processer
Om det finns ett WebHandler objekt startas server-processerna för webgränssnittet.

<h2>Konfigurering av menyn
Konfigureringen av menyn i operatörsfönstret gör i nodhierakin med attribut i WebHandler 
objektet, och ett antal WebGraph och WebLink objekt som läggs under detta objekt.

<b>WebHandler

I WebHandler objektet konfigureras vilka standardfunktioner som ska finnas med
i operatörsfönstrets meny.

<b>EnableLanguage
Visar en knapp för språk-val i menyn. Språkvalet måster göras innan man öppnar olika
fönster, eftersom språket inte ändras på de fönster som redan är skapade.

<b>EnableLogin
Visar kappar för inlogging och utloggning i menyn. Inlogging innebär att man loggar in
som en Proview användare med specificerade privileger som avgör vilken access man har till
systemet.

<b>EnableAlarmList
Visar en knapp i menyn för att öppna fönster med larm och händelselista.

<b>EnableEventLog
Visar en knapp i menyn för att söka efter händelser i eventloggen.

<b>EnableNavigator
Visar en knapp i menyn för att öppna navigatorn.

<b>WebGraph
WebGraph objekt konfigurererar knappar i menyn för att visa process grafik. WebGraph
objekt läggs under WebHandler objektet.

WebGraph objektet gör att grafen öppnas som en Java Frame, dvs i ett eget fönster. I Ge
editorn måste man ange att grafen ska exporteras som en Java Frame genom att markera
IsJavaFrame i Graph Attributes. Vill man öppna grafen som applet används WebLink objektet, 
se nedan.

I Name attributet fylls namnet in på den java-klass som genereras när grafen exporteras
som java. Normalt är detta namn detsamma som grafens namn, men med stor bokstav på första
bokstaven. Man kan dock välja att spara en graph under ett annat namn, genom att välja
export as, t ex om namnet innehåller lokala tecken, eller börjar på en siffra, eller andra
namn som inte bildar tillåtna java-klass namn.

I Text attributet anges knapp-texten.

<b>WebLink
Ett WebLink objekt konfigurerar en knapp i menyn för att öppna en godtycklig URL. I 
WebTarget kan man ange var den nya sidan ska läggas, i ett separat fönster, i den
högra ramen, eller i både meny och högra ramen (parent).

<b>Öppna en Ge graf som en applet
Ett WebLink objekt kan även användas för att öppna en Ge graph som en applet, t ex för
att lägga den i den högra ramen. I Ge editorn anger man att grafen ska exporteras som
en Java Applet genom att markera IsJavaApplet i GraphAttributes. Det gör att det skapas
en html fil på $pwrp_web med samma namn som grafen, t ex mygraph.html. Genom att ange
detta namn i WebLink objektets URL-attribut och sätta WebTarget till RightFrame, visas
grafen i högra ramen när man klickar på knappen. Observera att en graf som öppnas som en
applet får sin behörighet från Security-objektets DefaultWebPriv, och inte påverkas av 
eventuell inlogging.

<h2>Konfigurering av högra ramen
Hemsidan för ett projekt består av en meny och en höger ram. I höger ramen visas som 
default innehållet i xtt-hjälptexten för projektet. Denna konverteras till html när 
noden byggs. Om man vill ha en annan startsida i högra ramen kan man lägga in en URL
till denna i WebHandler objektets attribute StartURL. Om man t ex vill visa en Ge graf,
exporterar man grafen som en Java Applet och lägger man in html-filen för grafen på samma 
sätt som i WebLink objektet ovan.

<h2>LoadArchives
Om man vill kunna visa Ge grafer från flera olika projekt, måste java arkiven för dessa
projekt vara tillgängliga för web-läsaren. Java klasserna som genereras när graferna 
exporteras i Ge editorn, läggas i ett arkiv men namnet pwrp_'systemname'_web.jar. 
Arkivet för det egna projektet laddas alltid, men om även andra arkiv ska laddas, ska de
läggas in i WebHandler objektets LoadArchive attribut, och kopieras till $pwrp_web.

<h2>Behörighet
<b>Default behörighet
Default behörighet är den behörighet som en användare får som inte loggar in. Den anges
i Security objektets DefaultWebPriv attribut. 0 innebär att man inte har access till
något annat än att logga in. Normal sätter man RtRead vilket gör att ej inloggade användare
kan titta, men inte ändra värden.

<b>Inloggning
För att kunna logga in måste inloggingfunktionen vara aktiverad i WebHandler objektet.
Genom att klicka på Login knappen in operatörsfönstret, kan användaren logga in med
användarnamn och passerord. Användarnamnet måste vara registrerat i den systemgrupp
som har angivits i Security objektets WebSystemGroup. Vid registreringen tilldelas 
användaren priviligier som avgör behörigheten.

Lösenordet krypteras av klienten, dvs okrypterade lösenord skickas inte över nätverket.

<h1>Server processer
Tre server processer startas start av Proview runtime, rt_webmon, rt_webmonmh och
rt_webmonelog.

<b>rt_webmon
rt_webmon öppnar en port från vilken web-klienter kan hämta information om objekt
i databasen och lägga upp prenumerationer.

<b>rt_webmonmh
rt_webmonmh förser web-klienter med larm och händelser. Webgränssnittet innehåller ett
fönster med larm och händelselista som hämtar information här ifrån. Urvalet av larm 
händelser bestäms av attributet EventSelectList i WebHandler objektet.

<b>rt_webmonelog
rt_webmonelog gör sökningar av händelser i eventlog databasen.


<h1>Funktioner
I det här avsnittet beskrivs med ingående olika funktioner i web och java miljön och 
hur de genereras och konfigureras.

<h2>Hemsida
Hemsidan konfigureras med WebHandler objektet, och genereras av WebHander objektets 
bygg-metod. Den består av ett antal html-filer och jar-filer som läggs på katalogen
$pwrp_web.

Startsidan, index.html, består av två ramar. Den vänstra ramen öppnar html-filen för menyn, 
index_opwin_menu.html, som i sin tur öppnar en applet som knyter upp sig mot Proview 
servern och bygger upp menyn. Den högra ramen visar den URL som angivits i WebHandler 
objektets StartURL attribut, eller om detta attribut är tomt, startsidan för xtt-hälpen.

<h2>Ge grafer
Ge grafer som visas måste vara exporterade som java frames eller java applets. Normalt
använder man idag java frames. 

En java frame innebär att grafen visas i ett eget fönster. Den är skalbar, och anpassar
sig efter fönstrets storlek. Möjligheterna att påverka inmatningsfält, knappar mm i bilden
bestäms av privilegierna för den användare man är inloggad som. För att kunna exportera en
graf som java frame måste IsJavaFrame markeras Ge editorns GraphAttributes.

<image> dg_fig101.png
<b>Fig Graf öppnad som en Frame

En java applet öppnas från en html-fil. Den är inte skalbar, och behörigheten hämtas
från Security objektets DefaultWebPriv attribut, och påverkas inte av vem som är inloggad.
Java applets kan inte visas i den lokala java miljön. För att kunna exportera en graf som
java applet måste IsJavaApplet markeras i Ge editorns GraphAttributes.

<image> dg_fig102.png
<b>Fig Graf öppnad som en Applet

Man bör även ange en storlek på den genererade java grafen genom att sätta bredden i pixel
i JavaWidth i GraphAttributes.

Exportering sker genom att aktivera File/Export/Java i Ge editorns meny. Även byggmetoden
för WebGraph objekt exporterar en graf, om denna har sparats sedan senaste exporteringen.
Vid exporteringen skapas en java fil på $pwrp_pop, som kompileras och läggs i två arkiv,
$pwrp_web/pwrp_'systemname'_web.jar, och $pwrp_lib/pwrp_'systemname'.jar. Arkivet på 
$pwrp_web används av web-gränssnittet, och arkivet på $pwrp_load av den lokala java miljön.
För en java frame exporteras grafen som en java klass med samma namn som graf-namnet, men 
med stor bokstav på första bokstaven. my_graph exporteras t ex som My_graph. Notera att 
lokala bokstäver inte får ingå i ett java klassnamn, och det får inte heller börja på en 
siffra. I de har fallen kan man exportera med Export/Java As och ange ett tillåtet 
javaklassnamn. Genom att spara ge grafen efter exporteringen sparas java namnet, annars måste 
namnet anges vid varje exportering.

För java applets läggs suffixet _A på java klassnamnet, t ex My_graph_A. Dessutom genereras
en html fil, $pwrp_web/my_graph.html, som används för att starta appleten. Appleten kan 
naturligvis även startas från andra html-filer och kombineras med andra applet'ar och 
grafiska element.

Exporteringen till java innehåller vissa begränsningar. Text objekt kan i Ge läggas ovanpå
subgrafer, men kommer i java att hamna under subgrafen. Vissa xtt-kommandon som kan användas
i command knappar finns inte tillgängliga i web-miljön. Det finns även en begränsing för hur
många tecken en java funktion för innehålla. I stora, innehållsrika grafer kan man stöta på
den här begränsningen.

<h2>Larm och händelselista
För larm och händelselistan måste EventSelectList i WebHandler objektet fyllas i med 
hierarkier från vilka larm och händelser ska visas.

<h2>Hjälptexter
Hjälptexterna för projektet, filen xtt_help.dat, exporteras till html-filer på $pwrp_web
av WebHandler objektets byggmetod. Startsidan för hjälptexterna är 
$pwrp_web/xtt_help_index.html. Denna vissas som default i hemsidans högra ram, om ingen
annan URL är angiven i WebHandler objektets StartURL attribut.

Om hjälptexten innehåller image taggar måste dessa png eller gif filer kopieras till
$pwrp_web.

<h2>Plc 
För att kunna öppna plc program i web miljön måste .flw filer på $pwrp_load kopieras till
$pwrp_web.

<h2>Språk
Default är språket engelska. Andra språk kan anges i WebHandler objektets Language attribut
eller väljas i språkvalsfönstret om detta är konfigurerat. Om ett annat språk än 
engelska ska kunna väljas, måste språkfiler för detta språk, och för engelska, kopieras
från $pwr_exe till $pwrp_web. För t ex svenska skapas katalogerna $pwrp_web/en_us och
$pwrp_web/sv_se och filerna $pwr_exe/en_us/xtt_lng.dat kopieras till $pwrp_web/en_us/ och
$pwr_exe/sv_se/xtt_lng.dat kopieras till $pwrp_web/sv_se/.

<h2>Arkiv
Följande arkiv ska vara tillgängliga på $pwrp_web: pwr_rt_client.jar, pwr_jop.jar,
pwr_jopc.jar, pwr_bcomp.jar, pwr_bcompfc.jar och pwr_abb.jar. I utvecklingsmiljön måste man
kopiera dessa från $pwr_lib, i runtime-miljön görs detta vid installationen av pwrrt paketet.

<h1>Webserver
För att kunna öppna projektets hemsida i en webläsare måste en webserver vara startad på
noden, t ex apache.

Webservern tillåter endast att vissa utvalda kataloger öppnas, t ex /var/www. Antingen kan man
flytta innehållet i $pwrp_web till en öppen katalog, eller så kan man öppna $pwrp_web. I 
apache görs detta i filen /etc/apache2/apache2.conf genom att lägga till

<c>Alias /pwrp_web/ /usr/pwrp/myproj/bld/common/web/

<c><Directory /usr/pwrp/myproj/bld/common/web>
<c>    Options Indexes MultiViews
<c>    AllowOverride None
<c>    Order allow,deny
<c>    Allow from all
<c></Directory>

Här öppnas ett project, myproj, med rot-katalogen /usr/pwrp/myproj, med alias namnet pwrp_web.
Om noden är mynode, blir URL'en för att öppna web-miljön

<c>http://mynode/pwrp_web/index.html

På en process eller operatörsstation blir motsvarande tillägg i apache2.conf vilket
läggs in vid installationen av pwrrt paketet

<c>Alias /pwrp_web/ /pwrp/common/web/

<c><Directory /pwrp/common/web>
<c>    Options Indexes MultiViews
<c>    AllowOverride None
<c>    Order allow,deny
<c>    Allow from all
<c></Directory>

</topic>
</chapter>


<chapter>
<topic>conf_test
Starta och testa ett Proview system
I föregående kapitel har vi beskrivit hur man konfigurerar ett Proview system, hur man
skapar PLC program och processbilder. Nu är det dags att köra och testa systemet.

I avsnitten visas hur man

- bygger systemet. <link> dg_build
- startar simulerings miljö <link> dg_simulate
  och runtime monitorn. <link> runtime_monitor
- distribuerar. <link> dg_distribute
- startar runtime miljö.

<h1>Syntax kontroll
Vissa klasser har en syntax metod som kontrollerar att objektet är rätt konfigurerat. 
Metoden för signaler kontrollerar t ex att de är kopplade till en kanal, metoden för
ett PlcPgm att den är kopplade till ett trådobjekt etc. 
Syntax metoderna fångar upp en del fel, men är inte någon garanti för allt fungerar
felfritt.

Syntax-metoderna körs när 'Functions/Syntax Check' aktiveras i Configuratorn.

</topic>

<topic> dg_build
Bygga 
Innan man har en körbart system för en nod måste man bygga noden. Det innebär att man 
genererar alla de filer som behövs i runtime-miljön, t ex en boot-fil som talar om
vilka volymer som ska laddas, laddatafiler för volymerna som innehåller info om objekt i 
volymen, en exe-fil för plc-programmet etc.

Man bygger genom att aktivera 'Functions/Build Node' i konfiguratorns meny, eller motsvarande
knapp i verktygspanelen. Om man har flera noder definierade i projektet måste man även välja
nod i den lista som visas. 

<image> dg_fig66.gif
<b>Fig Val av nod

Också bygget är uppdelat i metoder för olika klasser. Byggmetoden för ett PlcPgm är att 
generera kod för de fönster som är ändrade och kompilera dessa. Byggmetoden för en volym är 
att anropa byggmetoderna för alla objekt i volymen, samt att skapa en laddatafil för volymen. 
Byggmetoden för en nod är att anropa byggmetoden för volymen, samt skapa en boot-fil och 
länka plc-programmet. Byggmetoden för ett objekt kan anropas genom att välja ut objektet och
aktivera 'Functions/Build Object' i menyn, och byggmetoden för aktuell volym genom att aktivera
'Functions/Build Volume'.

Här följer en beskrivning på några byggmetoder.

XttGraph <t>Kopierar .pwg filen för grafen från $pwrp_pop till $pwrp_exe.
WebGraph <t>Exporterar grafen till java, kompilerar och lägger in i arkiv.
WebHandler <t>Genererar html-filer för nodens hemsida och konverterar xtt-hjälp filen till
           <t>web format (html).
PlcPgm   <t>Genererar c-kod som kompileras av c-kompilatorn.
RootVolume <t>Anropar byggmetoden för all objekt i volymen, samt skapar en laddatafil med
          <t>info om volymens objekt. Skapar även korsreferens filer
         <t>om detta är specificerat i Options.
ClassVolume <t>Genererar include-filer med c-struct'ar för volymens klasser, samt skapar
          <t>en laddatafil med typ och klassbeskrivningarna.
Node     <t>Anropar byggmetoden för rotvolymen om volymen är tillgänglig. Skapar en bootfil
         <t>med info om vilka volymer som ska laddas in och länkar plc-programmet för noden.

Normalt kontrollera byggmetoderna först om något är ändrat, och utför endast bygget om den
hittar någon förändring. I vissa fall vill man tvinga ett bygge, och sätter då 'Force' i
Build kolumnen i options som öppnas från 'Options/Settings' i menyn. Här kan man även markera 
om man vill skapa korsreferens-filer vid bygge av en volym, eller om man vill kompilera och
länka plc-programmet med debug.

Om man har använder subvolymer eller delade volymer måste dessa byggas med 'Build Volume' 
innan noden byggs.
</topic>

<topic> dg_simulate
Simulering
Simulering innebär att man startar upp systemet för en process eller operatörs station på
utvecklingsstationen. På detta sätt kan man snabbt testa program och bilder under utvecklings-
fasen. Även när ett system har tagits i drift kan man testa ändringar i systemet innan man
laddar ner till produktions systemet.

Vid simulering måste indata från processen simuleras, och det gör man genom skapa ett PlcPgm
som läser data som ställs ut till processen, dvs Do och Ao, och utifrån dessa sätter värden på
Ai och Di objekt. Det finns speciella StoDi och StoAi objekt för detta som endast används vid
simulering. Man måste se till att simulerings-programmet enbart exekverar vid simulering,
t ex genom att sätta ScanOff attributet i PlcWindow objektet om IOSimulFlag i IOHandler
objektet inte är 1.

För att kunna starta en simulering på utvecklingsstationen den konfigureras i directory 
volymen. Simuleringen sker på en separat QCom bus vilket konfiguras med ett BusConfig som
läggs på topnivån i directoryvolymens högra fönster. I detta anges även en busidentitet, t ex
999. Under BusConfig objektet lägger man ett NodeConfig objekt för utvecklingsstationen, och
fyller i nodnamen och ip-adress. Man kan använda loopback adressen 127.0.0.1 om man inte avser
att kommunicera med andra noder. Vidare måsta man ange vilken volym man vill simulera
genom att sätta volymen som namn på RootVolumeLoad objektet under NodeConfig objektet.

Notera att konfigurerings guiden för directoryvolymen normalt skapar en simuleringsbus och 
en simuleringsnod.

<image>dg_fig104.png
<b>Fig Directoryvolymen med konfigurering för utvecklingsstation newton

När utvecklingsstationen är konfigurerad, bygger man genom att öppna konfiguratören för den
volym som ska simuleras, aktivera 'Build Node' och välja utvecklingsstationen in i listan
av noder som visas.

Innan man startar måste man definera omgivningsvariablen PWR_BUS_ID till identiteten för
simuleringsbussen. Defaultvärdet för PWR_BUS_ID anges i filen /etc/proview.cnf, parameter
QcomBusId. Med kommandot

<c>> echo $PWR_BUS_ID

kontrollerar man bussidentiteten, och med kommandot

<c>> export PWR_BUS_ID=999

sätter man ett annat värdet. Det här kommandot kan t ex läggas in i $pwrp_login/login.sh.

Nu kan man starta Proview runtime med

<c>> rt_ini &

och stoppa med 

<c>> . pwr_stop.sh

Om Proview inte startar kan man addera -i till start-kommandot för att se eventuella 
felutskrifter

<c>> rt_ini -i

Observera att man alltid måste nollställa genom att köra '. pwr_stop.sh' kommandot före ett 
nytt startförsök.

När runtime-mijön är startad kan man utforska systemet genom att starta runtime navigatören.

<c>> rt_xtt

Man kan även använda runtime-monitorn för att starta runtime-miljön. Se nedan.
</topic>

<topic>runtime monitor
Runtime Monitorn
Ofta vill man starta runtime-miljön på utvecklings-noden, t ex om man har gjort en 
ändring i systemet som man vill testa innan man skickar ner den till produktions-
systemet.

Runtime Monitorn används för att starta och stoppa runtime-miljön på utvecklingsnoden,
ofta i samband med simulering och testning, men även vid små system där utvecklingsnod
och process- eller operatörs nod är en och samma dator.

<image>dg_fig67.gif

Förutsättningen för att man ska kunna starta runtime-miljön är att utvecklingsnoden är

- noden är konfigurerad med ett NodeConfig objekt i projektvolymen.

- att rätt kommunikationsbuss är uppsatt. Det gör man genom att sätta omgivningsvariabeln
  PWR_BUS_ID till den buss man har angivit i BusConfig objektet i projektvolymen. t ex

<c>  export PWR_BUS_ID=999

För att runtime monitorn ska fungera krävs dessutom att det finns ett StatusMontitorConfig
objekt under $Node objektet i den volym som startas.

Runtime Monitorn startas från Tools/Runtime Monitor i menyn. Här finns knappar för att
starta och stoppa runtime-miljön ('Start Runtime' resp 'Stop Runtime'). I färgade rutan
till höger visas om runtime är startat eller inte ('Running' resp 'Down'). Färgen indikerar
status för systemet, rött för felstatus, gult för varning, och grönt för OK.

Knappen 'Restart Runtime' gör en mjuk omstart, och kan användas om runtime redan är startad.
Observera att vissa ändringar inte följer med vid en mjuk omstart, t ex ändrade värden på
attribut i objekt som redan finns sedan tidigare.

</topic>

<topic> dg_process_station
Process och operatörsstationer

I det här avsnittet går vi igenom det punkter som måste genomföras för att Proview ska kunna
startas på en process eller operatörsstation. 

- konfigurering av noden i directoryvolymen.
- noden ska byggas.
- installation av runtime paketet.
- distribuering till noden. <link> dg_distribute
- ange bus id för noden. <link> db_busid
- uppstart av runtime-miljön på noden. <link> dg_rtstart

<h1>Konfigurering in directory volymen
Noden måste vara konfigurerad i directory volymen med ett NodeConfig objekt. Detta läggs
under ett BusConfig objekt som innehåller bus identiteten för produktionsbussen. I NodeConfig
objektet konfigurerar man nodnamn och IP-adress, och under NodeConfig objektet ligger ett
RootVolumeLoad objekt som anger den rotvolym som ska startas i noden.

Noden byggs från rotvolymens konfiguratör genom att aktivera 'Functions/Build Node' och välja
ut noden i listan på noder (om det endast finns en nod konfigurerad visas inte listan).

<h1>Installation av runtimepaketet
Runtime-miljön installeras på process/operatörs-noden genom att installera pwrrt-paketet för 
aktuell Linux distribution. Läs installationsguiden på Download-sidan på www.proview.se för
mer information.
</topic>

<headerlevel>
<topic> dg_distribute
Distribuera
Att distribuera innebär att man samlar ihop de filer som skapas vid bygget av en nod, och som 
behövas för att kunna köra runtime-miljön, till ett paket. Paketet kopieras till process
eller operatörsstationen och packas upp där.

Vilka filer som ingår i paketet konfigueras i directoryvolymen med ett Distribute objekt som
läggs under NodeConfig objektet för noden. Distribute-objektet innehåller attributet Components
i där man anger vilken typ av komponenter eller filer som ska ingå. Om komponenter är
angivna som inte finns genererade resulterar det i varningsutskrifter vid distributionen.

<image> dg_fig106.png
<b>Fig Distribute objektet

Om man t ex har andra filer, t ex applikations-program, som ska ingå i paketet, lägger man ett
objekt av typen ApplDistribute under Distribute objektet. I ApplDistribute objektet kan man
ange den eller de filer (specification med wildcard är tillåten) som ska adderas, samt till
vilken katalog de ska kopieras.

Alla filer som behövs i runtime bör ingå i paketet. Dels är det viktigt att ett paket 
representerar en fullständig version av systemet, så att runtimemiljön kan återskapas, t ex
om man vill backa tillbaka till en tidigare version. Råkar man ut för en disk-krash är det
också viktigt att allt finns i paketet, och att det inte behövs diverse handpåläggning för att
systemet ska starta med en ny disk.

Distributionen utförs från Distributören som öppnas från 'Functions/Distribute' i 
konfiguratorns meny. Välj ut den nod som ska distribueras till och aktivera 
'Functions/Distribute' distributörens menyn.

<image> dg_fig105.png
<b>Fig Distributören

Distributören samlar nu ihop angivna filer, skapar ett paket och kopierar till användaren
'pwrp' på processnoden. ssh kräver att man anger passerord, detta anges två gånger i det
terminalfönster från vilken konfiguratören är startad. Vid installationen har användaren
'pwrp' passerordet 'pwrp' men detta kan ha ändrats av säkerhetsskäl.

Om man inte har nätverkskontakt med processnoden, kan man skapa ett paket och flytta det t ex
med en USB sticka. Välj ut noden i distributören, och aktivera 'Functions/Create Package'.
Paketet lagras på $pwrp_load med namnet pwrp_pkg_'nodename'_'version'.tgz, t ex 
pwrp_pkg_cross1_0002.tgz. På processtationen packar man upp med skriptet pwr_pkg.sh -i och 
anger namnet på paketet.

<c>> pwr_pkg.sh -i pwrp_pkg_cross1_0002.tgz 

<h1>Backa till tidigare version
Ibland fungerar inte en ändring som planerat och man vill backa tillbaka till föregående
version. Detta gör man enkelt med pwr_pkg.sh. Paketen lagras på användaren pwrp hemma-katalog
/home/pwrp. Genom att leta upp det paket som tidigare var installerat och starta pwr_pkg.sh -i
med detta återställer man till denna version.

<c>> pwr_pkg.sh -i pwrp_pkg_cross1_0001.tgz
</topic>

<topic> db_busid
Bus identitet

QCom bus identitet för noden är angiven i filen /etc/proview.cnf.

<c># Default QCOM Bus Id
<c>qcomBusId 517 

Det här värdet ska överensstämma med den konfigurerade busidentiteten i directory volymen.
Den aktuella busidentiteten är lagrad i omgivningsvariabeln $PWR_BUS_ID.

</topic>

<topic> dg_rtstart
Starta runtime-miljön
Runtime-mijön startas med kommandot

<c>> pwr start

och stoppas med 

<c>> pwr stop

eller
 
<c>> pwr kill

Kommandot 'pwr stop' kräver att alla processer lever, medan 'pwr kill' är lite tuffare och 
rensar i alla lägen.

Om Proview runtime inte startar, kan man starta med kommandot

<c>> rt_ini -i

för att visa konsol-loggning i terminalfönstret. 
Återställ alltid med 'pwr kill' före ett nytt startförsök.

</topic>
</headerlevel>
</chapter>

<chapter>
<topic>configurator_refman
Konfiguratören

Konfiguratören används för att navigera och konfigurera i arbetsbänken.
Konfiguratören visar objekten i en volym. Objekten delas vanligen upp i två fönster, ett
till vänster och ett till höger, och hur uppdelningen görs beror på vilken typ av volym som 
hanteras.

- För rotvolymer och subvolymer visas anläggningshierakin i det vänstra fönstret och
  nodhierkin i det högra. Närmare bestämt visas toppobjekt av klassen $PlantHier i det vänstra
  och toppobjekt av klassen $NodeHier i det högra.

- För directory volymen visas volymer i det vänstra fönstret och bussar och noder i det högra.
  Även systemobjektet visas i det undre fönstret.

- För klassvolymer visas klasser i det vänstra fönstret och typer i det högra.

Med 'View/TwoWindow' kan man välja om man vill visa två fönster eller bara ett. Om endast ett
fönster visas kommer det varannan gång man aktiverar 'TwoWindows' att vara det vänstra fönstret
som visas och varannan gång det högra.

Med 'Edit/Edit mode' går man in i editerings mode, och palett med olika klasser dyker upp 
till vänster. Man kan nu skapa nya objekt, flytta objekt, ändra värden på attribut mm.

<h2>Representation av volymer

Volymer kan lagras i olika format, i databas, i laddatafil eller i en textfil. Konfiguratören
kan visa en volym i alla dessa format och kan ha fyra olika representationer av volymer:

- db, en databas. Rotvolymer och subvolymer skapas och editeras i en databas. Innan man
  kan starta runtimemiljön genererar man laddatafiler för volymerna. Laddatafilerne läses
  in vid uppstart av runtimemiljön. db-representationen är editeringsbar.

- wbl, en textfil med filtyp .wb_load. Klassvolymer lagras som wbl, och rot- och subvolymer
  kan dumpas på wbl-fil t ex vid uppgradering, för att sedan återladdas. wbl-representationen
  är inte editeringsbar. Vid editering av klassvolymer överför man wbl-representationen till
  en mem-representation, se nedan, för att därefter spara den som wbl igen.

- dbs, en laddatafil. Från rotvolymer, subvolymer och klassvolymer i db resp. wbl 
  representation skapas laddatafiler som används av runtimemiljön. Konfiguratören läser in
  klassvolymernas dbs-filer för att tolka klasser, och rot och subvolymers dbs-filer för
  att visa monterade volymer och kunna översätta referenser till externa objekt. dbs-
  representationen är inte editeringsbar.

- mem, en volym som konfiguratören håller internt i minnet. Copy/Paste buffrar består t ex
  av mem-volymer. Klasseditorn importerar klassvolymen, som ursprungligen finns som wbl, till
  en mem-volym, eftersom mem-representatinen är editeringsbar.

Som vi ser ovan kan samma volym finnas både som databas och som laddatafil. När man startar
konfiguratören anger man en volym som argument. För denna volymen öppnas databasen, den
alltså representerad som en db, för övriga volymer i projektet öppnas laddatafilerna, dessa
finns representerade som dbs. Det här gör att man kan titta på övriga volymer i projektet,
och man kan lösa upp referenser till dem, men det är inte editeringsbara. Är databasen för 
volymen låst, pga att någon annan har öppnat den, ges ett felmeddelande och laddatafilerna 
öppnas istället för databasen.

I figuren nedan visas volymslistan, som öppnas från 'File/Open' i menyn. Det visar alla
volymer som är öppnade i konfiguratören. Vi kan se att databasen för rotvolymen 
VolTrafficCross1 är öppnad, medan den andra rotvolymen, VolOpTrafficCross1 är öppnad som 
laddadafil. Även klassvolymerna är öppnade som laddatafiler.
<image> dg_fig24.gif

Om ingen volym anges som argument när man startar konfiguratören, öppnas direktory volymens 
databas, och övriga volymer som dbs-volymer.

<bookmark>wnav_navigate
<h1>Navigera 
I konfiguratören visas objekten i den aktuella volymen. Objekten ligger i en trädstruktur,
och objekt som har barn visas med en mapp, objekt utan barn med ett löv. För varje objekt
visas som default, dessutom objektets namn, klass och eventuell beskrivning (beskrivningen
hämtas från ett Description attribut i objektet).

Genom att klicka MB1 på en mapp, öppnas mappen och objektets barn visas. Är mappen redan
öppen stängs den. Man kan även öppna en map genom att dubbelklicka var som helst på raden
för objektet.

Vill man se innehållet i ett objekt klicka man med Shift/Klick MB1 på mappen eller lövet, 
eller Shift/Dubbelklick MB1 var som helst på objektsraden. Nu visas objektets attribut,
och värdet på respektive attribut. Attributen markeras med olika figurer beroende på typ.

<b>Bitmappar för olika typer av attribut
<image> dg_fig26.gif

- Ett vanligt attribut markeras med en långsmal rektangel.

- En vektor markeras med en map och en stapel av attribut markeringar. Vektorn kan öppnas
  genom att man klickar med MB1 på mappen eller dubbelklickar någonstans på attributraden.
  Nu visas de olika elementen i vektorn.
<image> dg_fig27.gif

- Ett attribut som refererar till ett annat attribut eller objekt, dvs av typen Objid eller
  AttrRef, markeras med en pil som pekar på en fyrkant.

- Uppräkningstyper, Enum, markeras med en map med div långsmala rektanglar i. Genom att
  klicka MB1 på mappen visas de lika alternativen i uppräkningstypen. Alternativen visas med
  checkboxar med det valda alternativet markerat. Man kan även dubbelklicka med MB1 på 
  attributraden för att se alternativen.
<image> dg_fig28.gif

- Masktyper, Mask, markeras på liknande sätt som Enum, och de olika bitarna visas med klick
  MB1 på mappen, eller dubbelklick MB1 på attributraden.
<image> dg_fig29.gif

- Attributobjekt, dvs attribut som innehåller datastrukturen för ett objekt, markeras
  med en fyrkant med dubbellinje på ovansidan. Attributobjektet öppnas med klick MB1 på 
  fyrkanten, eller dubbelklick MB1 på attribut raden.

Ett objekt eller attribut väljs ut genom att man klickar med MB1 på det (dock inte på 
mappen/lövet). Med Shift MB1 kan man välja ut fler objekt. Genom att dra med MB1 kan man 
också välja ut flera objekt.


Ur ergonomisk synvinkel är det ofta bättre att navigera från tangenbordet. Man använder då
främst piltangenterna. Först måste man se till att fönstret har inmatings fokus genom att 
klicka på det. Inmatnings fokus mellan vänster och höger fönster skiftas med TAB.

Men PilUpp/PilNer väljer man ut ett objekt. Har objektet barn öppnar man barnaskaran med
PilHöger, och stänger med PilVänster. Innehållet i objektet, dvs objektets attribut, visas
med Shift/PilHöger och stängs med PilVänster.

Attribut som är vektorer, enum, mask eller attributobjekt, öppnas med PilHöger och stängs
med PilVänster.

När man känner sig hemma i objektsträdet kan man sätta upp sig som 'advanced user'. 
Ytterligare funktioner läggs då på piltangenterna. PilHöger på ett objekt visar t ex 
attributen i objektet om det inte har några barn. Har det barn får man använda 
Shift/PilHöger som förut.

<h1>Editera
Editering innebär att man skapar nya objekt, kopierar objekt, tar bort objekt eller ändrar
värde på attribut.

<h2>Skapa objekt
Man skapar ett objekt genom att välja ut objekts klass i paletten. Paletten är uppdelad i
mapparna Plant, Node och AllClasses. Under Plant finns de vanligaste klasserna i anläggnings
hierakin, och under Node finns de vanligaste i nodhierakin. Om klassen inte finns med här,
finns samtliga klasser åtkomliga under AllClasses. Här listas alla klassvolymer, och under
respektive volym, klasserna i volymen. Därefter klickar man med mittenknappen på blivande
syskon eller förälder till det nya objektet. Om man klickar på mappen/lövet på destinations-
objektet läggs det nya objeket som första barn, om kan klicka till höger om mappen/lövet 
läggs det som syskon.

Man kan även skapa objekt från popupmenyn. Välj ut en klass i paletten och öppna popupmenyn
genom att högerklicka på destinationsobjektet. Aktivera 'Create Object' och välj hur 
det nya objektet ska läggas i relation till destinationsobjektet, före eller efter, eller
som första eller sista barn.

<b>Konfiguratören i editeringsläge
<image> dg_fig25.gif

<h2>Ta bort objekt
Objekt tas bort mha popmenyn. Klicka med högerknappen på objektet och aktivera 
'Delete Object'.

<h2>Flytta objekt
Man kan även flytta objekt mha popupmenyn, men det är ofta enklare att använda musens 
mittenknappen: välj ut det objekt som ska flyttas och klicka med mittenknappen på 
destinationsobjektet. Om man klickar på mappen/lövet på destinationsobjektet läggs objektet 
som första barn, annars som syskon.

Obs! Undvik att använda Cut/Paste för att flytta ett objekt, eftersom detta skapar en
kopia av objektet med ny objektsidentitet, och referenser till objektet kan förloras.
Man kan använda kommandot paste/keepoid för att behålla identiteten.

<h2>Kopiera objekt
Kopiering kan ske med copy/paste eller mha popupmenu.

- copy/paste. Välj ut det eller de objekt som ska kopieras och aktivera 'Edit/Copy' (ctrl/C)
  i menyn. De utvalda objekten kopieras nu till en paste-buffert. Välj ut ett destinations 
  objekt, och aktivera 'Edit/Paste' (ctrl/V). Objekten i paste-bufferten läggs nu som syskon
  till destinationsobjektet. Om man istället aktiverar 'Edit/Paste Into' (shift+ctrl/V)
  läggs de nya objekten som barn till destinationsobjeketet. Om det kopierade objektet har 
  barn, kopieras även barnen av copy/paste. 

- från popupmenyn. Välj ut det eller de objekt som ska kopieras, ta upp popmenyn från 
  destinationsobjektet, och aktivera 'Copy selected object(s)'. Man har här möjlighet att
  välja hur de nya objekten ska läggas relativt destinationsobjektet, som första eller sista
  barn, eller som nästa eller föregående syskon. Om de koperade objekten har ättlingar, och
  även de ska kopiera aktiverar man 'Copy selected Tree(s)' istället.

<h2>Ändra namn på ett objekt
Namnet ändras genom att objektet väljs ut och 'Edit/Rename' (ctrl/N) aktiveras i menyn. Ett
inmatningsfält öppnas längs ner i konfiguratören där det nya namnet matas in. Ett objektsnamn
kan ha max 31 tecken.

Man kan även ändra namn genom att visa objektets attribut. När man är i editeringsläge visas
nu objektsnamnet främst bland attributen, och kan ändras pss som ett attribut.

<h2>Ändra värde på ett attribut
Välj ut det attribut som ska ändras, och aktivera 'Functions/Change value' (ctrl/Q) i menyn.
Ange de nya värdet i inmatningsfältet. Vill man avbryta inmatningen aktiverar man 'Change
value' igen.

Alla attribut är inte ändringsbara. Det beror på attributets funktion, om det ska datasättas
i utvecklingsmiljön, eller inte. De som är ändringsbara markeras med en pil.

Man kan även ändra värde på attribut från objektseditorn som öppnas från popupmenyn (Open
Object). Attribut som är av typen flerradig text, kan endast ändras från objekteditorn.

Som 'advanced user' kan man öppna inmatningsfältet med PilHöger, som ett snabbare alternativ 
till 'Change value'.

<bookmark>symbol_file
<h1>Symbol fil 

Symbol filen är en kommando fil som exekveras vid wtt startup. Det kan innehålla definitioner
av symboler och andra wtt kommandon. Här följer några exempel på användbara kommandon.

Genväg till objekt i objektsträdet:

<c>define rb9 "show children /name=hql-rb9" <LINK> define
</topic>

<topic>objecteditor_refman
Objektseditorn

Datamängden för ett objekt består av attribut. Objektseditorn visar attributen i ett objekt 
och värdet på varje attribut. Om man är i editeringsmod kan man även sätta värden på 
attributen.

Attributen visas på samma sätt som i konfiguratören, skillnaden är att de visas i ett eget
fönster. 

<h2>Navigera
Navigering och datasättning sker också pss som i konfiguratören. <link> configurator_refman, wnav_navigate

<h2>Start
Objektseditorn startas från konfiguratören eller plceditorn. Aktivera OpenObject i 
popupmenyn för ett objekt, eller välj ut objektet och aktivera 'Functions/Open Object' i 
menyn. I Plceditorn kan man även starta objektseditorn genom att dubbelklicka på objektet.
Om konfiguratören/plceditorn är i editeringsmod öppnas även objektseditorn i editeringsmod.

<h2>Meny

File/Close <t><t>stäng objektseditorn.

Functions/Change value  <t><t>öppna inmatningsfältet för det utvalda attributet. 
                        <t><t>Detta kan endast göras i edit mode.
Functions/Close change value <t><t>stäng inmatningsfältet.

<b>Objektseditorn
<image> dg_fig30.gif

Objektseditorn har inmatingsfält för att mata in flerradiga texter. I det här fallet kan man
inte avsluta inmatingen med 'Enter' som med enradiga texter. Antingen klickar man på 'Ok' 
knappen, eller också aktiverar man 'Functions/Close change value' (Ctrl/T) för att avsluta.

<b>Flerradiga texter
<image> dg_fig31.gif

Objektseditorn för plc-objekt har funktioner för att ange vilka in resp utgångar som ska
visas i funktionsobjektet. Man kan även välja om digitala ingångar ska vara inverterade.
Detta väljs med checkboxar för respektive attribut ('Used' resp 'Inverted'). Checkboxen
för 'Used' kan även ändras från tangentbordet med 'Shift/PilHöger' och checkboxen för
'Inverted' kan ändras med 'Shift/PilVänster'.

<b>Plc objekt med checkboxar
<image> dg_fig32.gif
</topic>

<topic>spreadsheeteditor_refman
Spreadsheet editorn

Spreadsheet editorn används för att titta på, eller konfigurera, flera objekt av samma klass
samtidigt. Objekt av en viss klass, under en specifierat objekt i objektsträdet, visas i en
tabell i editorn. I tabellen visas även värdet på ett attribut i objekten, och man kan enkelt
skifta mellan olika attribut.

Spreadsheet editorn startas från konfiguratören: 'Functions/Spreadsheet' i menyn.
Om konfiguratören är i editeringsmod, startas även spreadsheet editorn in editeringsmod.

När spreadsheet editorn är startad, måste man först ange vilka objekt som ska visas: vilken 
klass de tillhör och under vilken hierarki de ska ligga. Det här görs genom att aktivera
'File/Select Class' i menyn. Mata in klass, hieraki, samt ange om attributobjekt, dvs objekt
som ligger som attribut i andra objekt, ska vara med.

<b>Välja klass och hierarki
<image>dg_fig33.gif

Därefter väljer man vilket attribut som ska visas. Välj ut ett attribut i attributlistan
och klicka på 'Ok', eller dubbelklicka på ett attribut.

<b>Välja attribut
<image>dg_fig34.gif

Resultatet visas i figuren nedan. Här valdes attributet 'Description'. Man kan enkelt se
övriga attribut i objekten genom att aktivera 'File/Next Attribute' (Ctrl/N) och 
'File/Previous Attribute' i menyn.

<b>Spreadsheet editorn
<image>dg_fig35.gif

<h2>Meny
File/Select Class     <t><t>ange klass och hierarki för de objekt som ska visas.
File/Select Attribute <t><t>ange vilket attribut som ska visas.
File/Next Attribute   <t><t>visar nästa attribut för objekt i tabellen.
File/Previous Attribut <t><t>visar föregående attribut för objekt i tabellen.
File/Print            <t><t>skriver ut tabellen.
File/Close            <t><t>stänger spreadsheet editorn.

Functions/Change value <t><t>öppna inmatningsfält för utvalt objekt.
Functions/Close change value <t><t>stäng inmatningsfältet.

</topic>
</chapter>

<chapter>
<topic> helpwindow_refman
Hjälp fönster

Hjälpfönstret används för att visa och navigera i hjälptexter. Hjälptexterna kan vara olika
typer av manualer och handböcker som följer med Proview, eller hjälptexter som skrivs av
konstruktören för att beskriva anläggningen och ge operatörerna assistans.
</topic>
</chapter>

<chapter>
<topic> messagewindow_refman
Meddelande fönster

Meddelandefönstret visar meddelanden från Proview som ges vid olika operationer. 
Meddelandena kan ha fem olika nivåer av allvarlighet, som markeras med olika färger: 

S <t>Framgång (Success) <t>grön
I <t>Information        <t>grön
W <t>Varning (Warning)  <t>gul 
E <t>Fel (Error)        <t>röd 
F <t>Fatalt fel (Fatal) <t>röd

Om en pil visas före meddelandet innehåller meddelandet en länk till ett objekt. Genom att 
klicka på pilen letas det aktuella objektet upp.
</topic>
</chapter>

<chapter>
<topic> utilities_refman
Utilities fönstret

Utilities fönstret är ett grafiskt gränssnitt till olika kommandon i wtt.
För en närmare beskrivning av respektive kommando, se avsnittet Kommandon.
</topic>
</chapter>

<chapter>
<topic> plceditor_refman
Plceditorn

Plceditorn används för att skapa plcprogram mha ett grafiskt programmeringsspråk.

Programmeringen sker med funktionsblock som läggs i ett horisontellt nät av noder och 
förbindningar från vänster till höger. Signaler eller attribut hämtas upp på den vänstra
sidan av nätet, och värdena skickas vidare med förbindningar från utgångs-pinnar till
ingångs-pinnar på funktionsblocken. Funktionsblocken opererar på värdena och på nätets
högra sida, lagras värdena i signaler eller attribut.

GRAFCET sekvenser består av ett vertikalt nät av noder och förbindningar. Ett tillstånd
förflyttas mellan olika steg i sekvensen via förbindningarna. GRAFCET och funktionsblock
kan samverka med varandra och kombineras till ett enda nät.

<h2>Start
Plceditorn startas från konfiguratören. Välj ut ett objekt av klassen PlcPgm och aktivera
'Functions/Open Program' (Ctrl/L) i menyn, eller aktivera 'Open Program' i popupmenyn för
PlcPgm objektet. Konfiguratören ska inte vara i editeringsmod.

<h2>Arbetsmod
Plceditorn kan vara i fyra olika moder: View, Edit, Trace och Simulate. Moden väljs under
'Mode' i menyn.

<b>View
View innebär att plceditorn är i visningsmod. Man kan inte skapa eller modifiera objekt.
Många av menyalternativen som har med editering att göra är dimmade.

<b>Edit
Om man har editeringsprivileger kan man gå över i editeringsmod. Här kan man skapa och 
modifiera objekt.

<b>Trace och Simulate
Om man vill felsöka programmet går man in i tracemode. Detta kräver att proview's runtime
miljö är startad på utvecklingsstationen. Simulate fungerar som Trace, man man kan dessutom 
sätta värden på signaler.

Felsökning görs numera snabbare och enklare från Xtt. PlcTrace funktionen i Xtt är att
föredra framför Trace-funktionen i plceditorn.

<h1>Editering
Plc editorn består av

- en arbetsarea.
- två stycken paletter, en för funktions objekt och en för förbindningar (endast en palett
  i taget är synlig).
- ett navigationsfönster, från vilket arbetsarean kan skrollas och zoomas.

<b>Plc editorn
<image>dg_fig40.gif

<h2>Paletter
<b>Objektspaletten
När man startar plceditorn, visas paletten för funktionsobjekt. När man skapar ett
funktionsobjekt i arbetsarean väljer man ut en klass i paletten.

<b>Förbindningspaletten
När man skapar förbindningar mellan objekt, väljer editorn en lämplig typ av förbindning. Men
i vissa fall krävs att konstruktören påverkar valet av förbindningstyp. Detta görs i
förbindningspaletten som visas genom att 'View/Palette/Connection' aktiveras i menyn. Så 
länge menyn är öppen, skapas alla nya kopplingar med den typ som är vald i paletten. När
paletten stängs genom att 'View/Palette/Object' eller 'View/Palette/Plant' aktiveras, väljer
editorn förbindningtypen igen.

<b>Anläggningshierakin
Man kan visa anläggningshierakin genom att akivera 'View/Palette/Plant' i menyn. När man 
kopplar funktionsobjekt t ex för att hämta signalvärden, till signaler, kan man här markera
den signal som ska hämtas. Man kan även välja ut signalen i konfiguratören, vilket i många
fall är ett smidigare alternativ.

<h2>Navigationsfönster
Längs ner till vänster finns en förminskad bild av plcprogrammet. Den del av arbetsarean
som visas i huvudfönstret är markerad med en rektangel. Genom att flytta på rektangeln (dra
med MB1) skrollar man i huvudfönstret. Man kan även zooma genom att dra med MB2.

<h1>Funktionsobjekt
<h2>Skapa objekt
För att kunna skapa objekt måste editorn vara i editeringsmod, genom att 'Mode/Edit' 
aktiveras i menyn.

Ett objekt i skapas genom att man väljer ut en klass i paletten, och klickar med MB2 
(mittenknappen) i arbetsarean.

<h2>Modifiera ett objekt
Ett objekt skapas med vissa defaultvärden. Det gäller även vilka in och utgångar som visas
i plceditorn, och som kan förbindas med andra objekt. Vill man ändra på något värde öppnas
objektseditorn för objektet. Objektseditorn öppnas genom att

- dubbelklicka på objektet.
- aktivera 'Open Object' från popupmenyn för objektet.
- välj ut objektet och aktivera 'Functions/Open Object' i menyn.

Från objektseditorn kan man mata in värden på olika attribut. Attributen för ett plc-objekt
är uppdelade i ingångs-attribut, interna attribut och utgångs-attribut. 

<b>Ingångar
Ingångs-attributens värden kan hämtas från ett annat funktionsobjekt via en förbindning.
Attributet visas i funktionsobjektet som en ingångspinne. I vissa fall används inte en 
ingång, ett and-objekt har t ex 8 stycken ingångar men ofta används inte mer än två av dessa.
Detta åstadkommer man genom med hjälp av 'Used' checkboxen i objektseditorn. Om 'Used' är
ifylld, visas attributet som en ingångspinne, annars inte. 

En del ingångsattribut, oftast av analog typ, kan datasättas i objektseditorn. Om 'Used' inte
är markerat för attributet används det datasatta värdet, om 'Used' däremot är markerat, 
hämtas värdet från den utgång som attributet är förbundet med. Så här fungerar t ex 
gränsvärdena 'Min' och 'Max' i ett Limit objekt. Man kan välja om värdet ska hämtas från ett
annat funktionsobjekt, eller om det ska datasättas. Datasättningen i objekteditorn fungerar
i runtime som ett intialvärde, som sedan kan modifieras på olika sätt.

En del digitala ingångar kan inverteras. Detta görs genom att checkboxen för 'Inverted'
markeras i objektseditorn. I funktionsobjektet visas detta med en rund ring på ingångspinnen.

<b>Interna attribut
Interna attribut kan innehålla konfigureringsvärden som datasätts i utvecklingsmiljön, eller
värden som beräknas i runtime. Den senare typen är ofta inte ändringsbar, och kanske inte
ens synlig i utvecklingsmiljön.

<b>Utgångar
Värdet på ett utgångs-attribut skickas vidare till en ingång med en förbindning. Liksom
för ingångar, kan man välja om en utgångpinne ska visas eller ej, med 'Used' checkboxen
i objektseditorn.

<h2>Välja ut objekt
Objekt väljs ut på föjande sätt

- klicka med MB1 på objektet.
- Shift/Click MB1 adderar objektet till listan av utvalda objekt, eller raderar om objektet
  redan är utvalt.
- genom att dra med MB1 kan man välja ut ett eller flera objekt. Objekt som har någon del
  inom den markerade rektangeln, väljs ut.
- genom att trycka på Shift och dra med MB1 adderar man objekt som ligger inom den markerade
  rektangeln till urvalslistan.

Utvalda objekt ritas med röd färg.

<h2>Flytta objekt
Enstaka objekt flyttas genom att man placerar markören på dem och drar med MB1.
Flera objekt flyttas genom att man markerar dem drar på ett av objekten med MB1.

<h1>Förbindningar
<h2>Skapa förbindningar
En utgångpinne och en ingångpinne kopplas på följande sätt

- placera markören på pinnen, eller på ett område i funktionsobjektet nära pinnen, och
  tryck på MB2 (mittenknappen).
- Dra markören till den andra pinnen, eller till ett område i funktionsobjektet nära pinnen,
  och släpp MB2.

En förbindning skapas nu mellan objekten.

Två ingångar kan kopplas ihop på samma sätt, men någon av de sammankopplade ingångarna, 
måste vara kopplad till en utgång, och från denna utgång hämtas värdet till samtliga 
sammankopplade ingångar.

<b>Datatyper
De värden som förflyttas mellan olika objekt via förbindningarna kan vara digitala, analog,
heltals och sträng värden. In och utgångar som kopplas ihop måste vara av samma typ. Om de 
är av olika typ måste någon form av objekt som konverterar mellan olika typer användas, t ex
AtoI eller ItoA. Dessa ligger under 'Signals/Conversion' i paletten.

Analoga- och heltalskopplingar markeras med lite tjockare linjer, digitala kopplingar med 
lite tunnare.

Dessutom finns det en kopplingstyp för överföring av en objektreferens. Dessa ritas med
tjock streckad linje.

<b>Referenskopplingar
Om editorn har svårt att hitta en väg för kopplingen mellan in och utgångspinnen, pga att
det ligger många objekt ivägen, eller för att de ligger på olika dokument, ritas kopplingen
som en referenskoppling. Referenskopplingar kan även ritas genom att aktivera
'View/Reference connections' i menyn.

<b>Referens förbindning
<image> dg_fig39.gif

<bookmark>feedback_connection
<b>Exekveringsordning
Förutom att överföra signalvärden, bestämmer förbindningar även exekveringsordningen mellan
olika funktionsobjekt. Om två objekt är sammankopplade via en utgång och en ingång, ska 
normalt utgångs-objektet exekveras före ingångs-objektet. Men ibland gör man en återkoppling
i nätet och råkar ut för en exekverings loop. För att kunna bestämma exekveringsordingen
måste man då markera återkopplingen med en koppling av typen ConFeedbackDigital eller
ConFeedbackAnalog. Dessa väljs från kopplings-paletten som visas genom att 
'View/Palette/Connection' aktiveras i menyn. Under mappen 'ConPlc' finns bl a feedback
kopplingarna. Dessa ritas med streckade linjer.

<b>Feedback förbindning
<image> dg_fig37.gif

Här hittar man även kopplingstypen 'ConExecuteOrder'. I vissa fall vill man styra
exekveringsordningen mellan två funktionsobjekt, trots att de inte är förbundna med varandra.
Man kan då dra en ConExecuteOrder mellan dem (mellan vilka in eller utgångar är egalt).
Kopplingen ska dras från det objekt som ska exekveras först, till det som ska exekveras sist.
I figuren nedan exekveras lagringen av attributet 'Temperaturer' före lagringen av attributet
'Tjocklek'.

<b>Exekveringsordnings förbindning
<image> dg_fig38.gif

<h1>Hämta och lagra signalvärden
<h2>Hämta signal och attributvärden
I funktionsblocksnätets vänstra del hämtas värden på signaler och attribut upp. Upphämtningen
av signaler sker med med objekten GetDi, GetDo, GetDv, GetIi etc. Upphämtning av
attributvärden sker med GetDp, GetIp, GetAp och GetSp. Dessa objekt återfinns under mappen
'Signals' i paletten. När man har skapat ett objekt av den här typen, måste man ange vilken
signal, eller vilket attribut som ska hämtas upp. Detta görs enklast genom att välja ut
signalen/attributet i konfiguratören, och klicka med Ctrl/dubbelclick MB1 på objektet.
Signalen/attributet visas då i objektet, och är det frågan om en insignal visas även
kanalen som signalen är kopplad till.

Det finns ett snabbare sätt att skapa de här objekten. Drar man ut en koppling från en
ingångspinne på ett funktionsobjekt, och släpper den på ett tomt område i arbetsarean skapas
ett generiskt Get objekt av den datatyp som ingången har, dvs en GetDgeneric, GetIgeneric,
GetAgeneric eller GetSgeneric. När man anger den signal eller attribut som Get objektet
ska hämta, omvandlas det generiska Get objektet till ett Get objekt som hämtar den typ av
signal eller attribut som är angivet. Väljer jag ut en Dv i konfiguratören, kommer ett
GetDgeneric att omvandlas till en GetDv när jag klickar med Ctrl/dubbelklick MB1 på den.

<h2>Lagra signal och attributvärden
I nätets högra del lagras de beräknade värdena i signaler eller attribut. Lagringen sker med
objekt av typen StoDo, StoDv, StoDp, StoIo etc. Metoden för att ange vilken signal eller
vilket attribut som värdet ska lagra i, är detsamma som för Get objekt, dvs genom att välja
ut signalen/attributet i konfiguratören och klicka med Ctrl/dubbelklick MB1 på objektet.

Om man drar ut en koppling från en utgångspinne på ett funktionsobjekt skapas generiska
Sto objekt, som omvandlas till Sto objekt av lämplig typ när de kopplas till en signal eller
ett attribut. Vill man lagra värden med Set eller Reset (t ex SetDo eller ResDo) kan man inte
använda den här metoden utan objektet hämtas från paletten.

<b>Generiska Get och Sto objekt
<image> dg_fig36.gif

<h1>Underfönster
Vissa objekt innehåller underfönster, t ex CSub, SubStep, Trans, Order. Att objeket har ett 
underfönster markeras med att vissa delar av funktionsobjektet ritas med tjock grå linje.
Ett underfönster kan öppnas på olika sätt: 
- genom att välja ut objektet och aktivera 'Functions/Subwindow' i menyn.
- genom att aktivera 'Subwindow' från popupmenyn för objektet.
- genom att klicka på objektet med Shift/dubbelklick MB1.

Man skapar ett nytt underfönster på följande sätt (det faktum att man endast kan ha en 
editeringssession öppen åt gången, gör skapandet en smula omständligt)

- skapa objektet som ska innehålla underfönstret.
- spara.
- öppna underfönstret.
- lämna editeringsmod i huvudfönstret.
- gå in i editeringsmode i underfönstret.

<h1>Kontrollera exekveringsordningen
I vanliga fall ska man inte behöva fundera så mycket på i vilken ordning olika 
funktionsobjekt i ett fönster exekverar. Genom att signaler I/O-kopieras, dvs varje tidbas
i plcprogrammet, tar en kopia av alla signalvärden före exekveringen som inte förändras
under exekveringen, kommer lagring och hämtning av signalvärden inte att påverkas av
exekveringsordningen mellan enskilda hämtnings och lagrings objekt. 

Om man däremot lagrar och hämtar värden från attribut som inte I/O-kopieras kan 
exekveringsordningen vara av betydelse för funktionen.

Exekveringsordningen bestäms av förbindningarna mellan funktionsobjekten. De vanliga
förbindningarna är både signalöverförande och exekveringsordnings-bestämmande. Gör man en 
återkoppling, måste man välja en kopplingstyp som är signalöverförande, men inte
exekveringsordnings-bestämmande. De olika feedback-kopplingarna är av denna typ. Dessutom
finns det en typ av koppling som är exekveringsordnings-bestämmande men inte
signalöverförande, ConExecuteOrder. Med den här kan man styra exekveringsordningen mellan
olika funktionsobjekt utan att överföra några signalvärden.

Exekveringsordningen för funktionsobjekten i ett plcfönster visas med 
'View/Show execute order' i menyn. Den siffra som visas på varje funktionsobjekt anger den
ordning i vilken de exekveras. De objekt som inte har någon siffra, har inte någon 
exekverbar kod.

Exekveringsordningen mellan olika PlcPgm styrs av attributet ExecuteOrder i PlcPgm objektet.
ExecuteOrder avgör hur exekveringen inom en plc tråd ordnas. Lägre värden på ExecuteOrder 
exekverar före högre värden.

<h1>Kompilering
Innan ett plc-fönster kan exekveras måste det kompileras. Samtidigt utförs en syntax kontroll
av plc-koden. Om syntaxen inte är korrekt, skrivs felmeddelanden i meddelandefönstret.
Felmeddelandet kan vara av typen Error eller Warning. Error är ett allvarligare fel som måste
åtgärdas. Genom att klicka på pilen framför felmeddelandet i meddelandefönstret, letas det
felaktiga objektet upp i plceditorn.

Efter syntaxkontrollen genereras c-kod som skickas till c-kompilatorn. Om det 
finns objekt med egendefinierad c-kod, t ex CArithm eller DataArithm, kan c-kompilatorn
hitta fel som skrivs ut i terminalfönstret. Kontrollera alltid i terminalfönstret att 
kompileringen gick bra.

Kompileringen utförs genom att 'File/Build' aktiveras i menyn.

Om man vill kontrollera syntaxen utan att generera kod, aktiverar man 'File/Syntax'. Här
körs inte c-kompilatorn, så eventuella c-kods fel upptäcks inte.

<h1>Klipp och klistra
Plc editorn innehåller en pastebuffer. Pastebufferten är gemensam för alla fönster, vilket
gör att man kan kopiera mellan olika fönster. Med funktionerna 'Edit/Copy' och 'Edit/Cut'
i menyn kopieras utvalda objekt till paste bufferten (vid Cut tas de även bort ur 
arbetsarean). Funktionen 'Edit/Paste' kopierar pastebufferten till arbetsarean. De kopierade
objekten flyttas nu med markören, och man placerar dem på rätt plats och klickar på MB1 för
att låsa fast dem.

Cut, Copy och Paste kan även aktiveras från tangentbordet med Ctrl/X, Ctrl/C och Ctrl/V.

<h1>Speciella plcobjekt
Här beskrivs ett antal objekt som har speciella funktioner i plcprogrammet.

<b>Document
Dokumentobjekt används för att dela in koden i sidor vid utskrift. När man öppnar ett nytt
fönster innehåller det ett dokumentobjekt. Via objektseditorn kan man ändra dimension på
documentet, och ange signatur och sidnummer. Övriga uppgifter i dokumenthuvudet fylls i
automatiskt. Dokument objekt finns under mappen 'Edit' i objektspaletten.

<b>ShowPlcAttr
ShowPlcAttr kan användas som som en utökning av dokumenthuvudet. I detta objekt skriv info
om volym, scantid och resetobjekt för GRAFCET ut.

<b>Head, Title, Text och BodyText
Dessa objekt används för att skriva förklarande texter i dokumenten. Head, Title och Text
innehåller enradiga texter av olika storlek på max 79 tecken. BodyText innehåller en 
flerradig text på max 1023 tecken. Objekten återfinns under'Edit' i objektspaletten.

<b>Point
Point objektet är en fri kopplingspunkt som kan användas som förgrening av förbindningar
eller för att styra layouten på förbindningar. Point finns under 'Edit' i objektspaletten.

<b>GRAFCET
GRAFCET sekvenser är uppbyggda med speciella GRAFCET objekt som InitStep, Step, Trans och 
Order. Kopplingarna mellan objektet följer bestämda regler. De vertikala pinnarna på ett
Step objekt ska t ex kopplas till Trans objekt, och den horisontella pinnen ska kopplas
till ett Order objekt. Här följer ett exempel på hur men enkelt skapar en GRAFCET sekvens.

Börja med att skapa ett InitStep objekt. Dra ut en förbindning från den undre pinnen och
släpp den i arbetsarean under InitStep objektet. Nu skapas ett Trans objekt som är
förbundet med InitStep objektet. Dra en koppling från Trans objektets undre koppling och
släpp den i arbetsarean under Trans objektet. Här skapas nu ett Step objekt. Drar man ut
en koppling från Step objektets under pinne skapas ett Trans objekt till. Vill man ha en 
förgrening drar man ut ytterligare en koppling från Step objektets nedre pinne. Nu skapas
en förgrening med speciella StepDiv förbindningar. Om man pss skapar en förgrening
från ett Trans objekt genom att dra ut två stycken kopplingar från den undre pinnen, bildas
en parallellförgrening med TransDiv förbindningar som markeras med dubbla linjer.
Drar man ut en koppling från den horisontella pinnen på ett Step objekt skapas ett Order
objekt osv. Som synes kan man mycket snabbt bygga upp avancerade sekvenser på det här sättet.

<b>ScanTime
ScanTime hämtar upp den verkliga scantiden, dvs tiden sedan senaste scan.

<b>FirstScan
FirstScan är sann första varvet plc't exekverar efter uppstart av Proview. Den är även sann
först varvet efter en mjuk omstart.

<h1>Meny

File/Save <t><t>Spara
File/Print/Documents <t><t>Skriv ut alla dokument.
File/Print/Overview  <t><t>Skriv ut en översikt på ett blad.
File/Print/Selected documents <t><t>Skriv ut utvalda dokument.
File/Syntax  <t><t>Gör en syntaxkontrol av koden.
File/Compile <t><t>Kompilera programmet.
File/Plc Attributes <t><t>Öppna objektseditorn för PlcPgm objektet.
File/Delete Window  <t><t>Ta bort plcfönstret.
File/Save Trace <t><t>Spara traceobjekt.
File/Restore Trace<t><t>Återskapa sparade traceobjekt.
File/Close <t><t>Stäng fönstret.

Edit/Undo Delete <t><t>Ångra borttagning av objekt.
Edit/Undo Select <t><t>Nollställ utvalslistan.
Edit/Cut <t><t>Klipp ut utvalda objekt.
Edit/Copy <t><t>Kopiera utvalda objekt till paste bufferten.
Edit/Paste <t><t>Kopiera pastebufferten till arbetsarean.
Edit/Connect <t><t>Koppla utvalt objekt till utvald signal eller attribut
             <t><t>i konfiguratören.
Edit/Delete <t><t>Ta bort utvalda objekt.
Edit/Change Text <t><t>Ändra text i utvalt textobjekt.
Edit/Expand Object <t><t>Expandera utvalt objekt.
Edit/Compress Object <t><t>Komprimera utvalt objekt.

Search/Object <t><t>Sök på objektsnamn.
Search/String <t><t>Sök efter textsträng.
Search/Next <t><t>Sök vidare med samma textsträng.

View/Palette/Object <t><t>Visa funktionsobjekts paletten.
View/Palette/Connection <t><t>Visas förbindnings paletten.
View/Palette/Plant <t><t>Visa anläggningshierarkin.
View/Reference connections <t><t>Skapa förbindningar som referenskopplingar.
View/Grid Size <t><t>Sätt gridstorlek.
View/Show Grid <t><t>Visa griden.
View/Zoom/In <t><t>Zooma in.
View/Zoom/Out <t><t>Zomma ut.
View/Zoom/Reset <t><t>Återställ till ursprunglig zoomningsgrad.
View/Show Execute Order <t><t>Visa exekveringsordning för funktionsobjekten.
View/Redraw <t><t>Dra om förbindningar och rita om fönstret.

Functions/Open Object <t><t>Öppna objektseditorn för utvalt objekt.
Functions/Subwindow <t><t>Öppna underfönster för utvalt objekt.

Mode/View <t><t>Visningsmod.
Mode/Edit <t><t>Editeringsmod.
Mode/Trace <t><t>Felsökningsmod.
Mode/Simulate <t><t>Simuleringsmod.

<h1>Musfunktioner
<h2>Arbetsarean
Klick MB1 <t><t>Välj ut objekt. Klick i tomt område nollställer utvalslistan.
Shift/Klick MB1 <t><t>Addera objekt till utvalslistan.
Dubbelklick MB1 <t><t>Öppna objektseditorn.
Shift+Ctrl/Dubbelklick MB1 <t><t>Kopiera till pastebuffer. Klick på ett objekt 
               <t><t>kopierar objektet, klick i tomt område kopierar utvalda objekt.
Drag MB1 <t><t>På objekt: flytta objekt eller flytta utvalda objekt.
         <t><t>I tomt område: välj ut objekt inom markerad rektangel.
Shift/Drag MB1 <t><t>Addera objekt inom markerad rektangel till utvalslistan.

Klick MB2 <t><t>Skapa objekt.
Dubbelklick MB2 <t><t>Ta bort. Klick på ett objekt tar bort objektet, klick
                <t><t>på tomt område i arbetsarean tar bort utvalda objekt.
Shift+Ctrl/Klick MB2 <t><t>Paste. Kopiera pastebufferten till arbetsarean.
Shift+Ctrl/Dubbelklick MB2 <t><t>Klipp ut. Klick i objekt tar bort objektet, klick
                <t><t>på tomt område tar bort utvalda objekt. Borttagna objekt läggs
                <t><t>i pastebufferten.

Press MB3 <t><t>Popupmeny.

<h2>Navigationsfönster
Drag MB1 <t><t>Skrolla arbetsarean.
Drag MB2 <t><t>Zooma arbetsarean.
</topic>
</chapter>


<chapter>
<TOPIC> helpfile
Hjälpfil

Hjälptexter visas i hjälp fönstret, som öppnas från konfiguratören eller från 
operatörsmiljön. Hjälptexter skrivs i filen $pwrp_exe/xtt_help.dat. Hjälptexterna delas upp
i ämnen (topics), och varje ämne har en nyckel, som specificerar när hjälptexten för ämnet
ska visas. Länkar i hjälptexterna, som pekar på andra ämnen, gör det möjligt att navigera
i hjälptexterna.

Ämnet 'index' är rot ämnet som visas från olika verktyg

- 'Help/Project' i konfiguratorns meny.
- 'Help/Project' i runtime navigatorns mey .
- 'Help' knappen i operatörsfönstret.

Specificerade hjälpämnen kan öppnas från Ge grafer genom tryckknappar (aktionstyp Help), eller
från popup-menyn för ett objekt i operatörsmiljön (metod 'Help').

<option> printdisable
<b>Syntax <link> helpfile syntax
<b>Konvertering <link> helpfile conversion
<option> printenable
</topic>

</headerlevel>
<topic> helpfile conversion
Konvertering
Hjälptexterna kan konverteras till html, PDF och PostScript format. Vid konvertering till
html, konverteras varje ämne till en html sida. Vid konvertering till PDF och PostScript,
finns ett antal ytterligare taggar, för att skapa dokument av hjälptexterna med kapitel och
rubriker.

Konverteringen görs med 'co_convert'.

<h2>Konvertering till html
En hjälpfil konverteras till html med kommandot

<c>co_convert -f [-d outputdirectory] 'helpfile'

<b>Exempel
<c>co_convert -f -d $pwrp_web $pwrp_exe/xtt_help.dat

<h2>Konvertering till PostScript
En hjälpfil konverteras till postscript med kommandot

<c>co_convert -n [-d outputdirectory] 'helpfile'

<b>Exampel
<c>co_convert -n -d $pwrp_lis $pwrp_exe/xtt_help.dat

<h2>Konvertering till PDF
En hjälpfil konverteras til PDF med kommandot

<c>co_convert -f [-d outputdirectory] 'helpfile'

<b>Exampel
<c>co_convert -f -d $pwrp_lis $pwrp_exe/xtt_help.dat
</topic>

<topic> helpfile syntax
Syntax
Det finns ett antal olika taggar som påverkar sökningen och konverteringen av hjälpfiler.

topic     <t>Definierar hjälptexten för ett ämne<link> topic
bookmark  <t>Defininerar en position inne i ett ämne<link> bookmark
link      <t>Länk till ett ämne elller en URL<link> link
index     <t>Lista över ämnen<link> helpindex
h1        <t>Rubrik 1 <link> header1
h2        <t>Rubrik 2 <link> header2
b         <t>Fet text <link> bold
t         <t>Tab <link> helptab
hr        <t>Horisontell linje<link> hr
include   <t>Inkludera andra hjälpfiler<link> include

<h2>PDF och PostScript taggar
Följande taggar används för att formatera hjälptexter vid konvertering till PDF och 
PostScript.

chapter   <t>Dela upp ämnen i kapitel<link> chapter
headerlevel <t>Öka eller minska rubrik nivån <link> headerlevel
pagebreak <t>Ny sida<link> pagebreak
option    <t>Optioner<link> option
style     <t>Specifik text stil <link> style

<b>Exampel <link> helpfile example
</topic>

<headerlevel>
<topic> topic
Topic
<ib><topic>
<i><topic> börjar ett ämne och ska placeras på radens första position. Topic taggen följs
<i>av en nyckel som är sökbegrepp i hjälpfunktionen. Alla följande textrader till en </topic>
<i>tag kommer att visas som text för ämnet.

<i><topic> 'key'


<ib></topic>
<i>Avslutar ett ämne. </topic> ska placeras på radens första position.
End a topic. </topic> should bo placed in the first position 
<i>of a line.

<b>Example
<i><topic> start engine
The engine will be started by...
<i></topic>

Kommandot

<c>wtt> help start engine

kommer att visa texten för detta ämne.
</topic>

<topic> bookmark
Bookmark
<ib><bookmark>
Bookmark är en rad inuti ett ämne som kan letas efter med link-taggen eller /bookmark
kvalifieraren i 'help' kommandot. Bookmark ska placeras vid slutet på en rad och följas
av ett namn.

<i>'some text' <bookmark> 'name'

<b>Exempel
<i>This is a bookmark. <bookmark> first_engine

Kommandot 

<c>wtt> help start engine/bookmark=first_engine

kommer att visa texten för ämnet och scrolla till bokmärket.
</topic>

<topic> link
Link
<ib><link>
<i><link> taggen är en länk till ett annat hjålp ämne. <link> taggen ska placeras vid slutet
på raden. När raden för länken aktiveras kommer ämnet för länken att visas. Link taggen ska
följas av ämnet, och kan även följas av ett bokmärke, och hjälfilen som hjältexten finns i,
åtskilda med kommatecken. Om en rad innehåller en länk, markeras den med en pil.

<i>'some text'   <link> 'topic'[,'bookmark'][,'helpfile']

<b>Exempel
<i>Link to first engine <link> show engine, first_engine
</topic>

<topic> helpindex
Index
<ib><index>
<i><index> taggen är en speciell länk som visar innehållet i en hjälpfil, dvs en lista på
alla ämnen i bokstavsordning.

<i>'some text' <index>
</topic>

<topic> header1
Header1
<ib><h1>
<i><h1> taggen kommer att visa en rad som en rubrik med större textstorlek. Taggen ska 
placeras i början på raden. En rubrik rad kan inte innehålla någon länk.

<i><h1>'header text'

<b>Exempel
<i><h1>This is a h1 header
kommer att visas som
<h1>This is a h1 header
</topic>

<topic> header2
Header2
<ib><h2>
<i><h2> taggen visar en rad som en rubrik med större textstorlek. Taggen ska placeras i 
början på raden. En rubrik rad kan inte innehålla någon länk.

<b>Exempel
<i><h2>This is a h2 header
kommer att visas som
<h2>This is a h2 header
</topic>

<topic> bold
Bold
<ib><b>
<i><b> taggen visar en rad med fet text. Taggen ska placeras i början på raden.

<b>Exempel
<i><b>This is a bold line
kommer att visas som
<b>This is a bold line
</topic>

<topic> helptab
Tab
<ib><t>
<i><t> taggen gör det möjligt att skriva kolumner. Endast tre kolumner (två <t> taggar) är
tillåtet.

<b>Exempel
<i>Col1 <t> Col2 <t> Col3
kommer att visas som
Col1 <t> Col2 <t> Col3
</topic>

<topic> hr
Horisonell linje
<ib><hr>
<i><hr> taggen visar en horisonetell linje. Taggen ska placeras i början på raden.

<b>Exempel
<i><hr>
kommer att visas som
<hr>

</topic>

<topic> include
Include
<ib><include>
<i>Inkluderar en annan hjälpfil. <include> taggen ska inte placeras inuti ett ämne.

<i><include> 'filname'
</topic>

<topic> chapter
Chapter
<ib><chapter>
<i>Den här taggen delar in ämnen i kapitel. Ett kapitel inleds med <chapter> avslutas med
<i></chapter>. Titeln för första ämnet i ett kapitel blir rubriken på kapitlet.

<ib></chapter>
Avslutar ett kapitel.

<b>Exempel
<i><chapter>
<i><topic>
<i>Introduction
<i>...
<i></topic>
<i></chapter>
</topic>

<topic> headerlevel
Headerlevel
Delar in ämnen i ett kapitel i rubrik nivåer.

<ib><headerlevel>
Ökar rubriknivån.

<ib></headerlevel>
Minskar rubriknivån
</topic>

<topic> pagebreak
Pagebreak
<ib><pagebreak>
Markerar sidbrytning.
</topic>

<topic> option
Option
<ib><option>
Option kan ha följande värden

printdisable <t>Ignorera alla taggar och all text till nästa 'printenable' vid konvertering
             <t>till PDF och PostScript. Används bl a för länkar som inte fungerar i PDF
             <t>och PostScript.
printenable  <t>Återställ 'printdisable'.

<b>Example
<i><option> disable
<i>Some text
<i>...
<i><option> enable
</topic>

<topic> style
Style
<ib><style>
Anger att ett ämne ska skrivas med en speciell stilmall.
<b>Stilmallar
function	<t>Stilmall använd för funktioner och kommandon. Större rubrik och 
                <t>efter varje ämne.

<b>Exempel
<i><topic> MyFunction <style> function
...
<i></topic>
</topic>

<topic> helpfile example
Exempel på hälpfil
<i><topic> helpfile_example
<i>Start and stop of engines.

<i>Engine 1 <link> helpfile_example, bm_engine_1
<i>Engine 2 <link> helpfile_example, bm_engine_2
<i>Characteristics <link> helpfile_example, bm_char

<i><h1>Engine 1 <bookmark> bm_engine_1
<i>Start engine one by pressing the start button.
<i>Stop engine one by pressing the stop button.

<i><h1>Engine 2 <bookmark> bm_engine_2
<i>Start engine two by pressing the start button.
<i>Stop engine two by pressing the stop button.

<i><h2>Characteristics <bookmark> bm_char

<i><b><t>Engine1 <t>Engine2
<i>Max speed <t> 3200 <t> 5400
<i>Max current <t> 130 <t> 120
<i></topic>

Så här ser ovanstående exempel ut <link>helpfile_example
</TOPIC>

<headerlevel>
<topic> helpfile_example
Start and stop of engines.

Engine 1 <link> helpfile_example, bm_engine_1
Engine 2 <link> helpfile_example, bm_engine_2
Characteristics <link> helpfile_example, bm_char

<h1>Engine 1 <bookmark> bm_engine_1
Start engine one by pressing the start button.
Stop engine one by pressing the stop button.

<h1>Engine 2 <bookmark> bm_engine_2
Start engine two by pressing the start button.
Stop engine two by pressing the stop button.

<h2>Characteristics <bookmark> bm_char

<b><t>Engine1 <t>Engine2
Max speed <t> 3200 <t> 5400
Max current <t> 130 <t> 120
</topic>
</headerlevel>
</headerlevel>
</headerlevel>
</chapter>

<chapter>
<topic>users
Användare

Det här kapitlet beskriver hur man skapar användare i proview, och ger privilegier och 
behörighet för användaren. 

Den ökade tillgängligheten på proview-system för olika typer av användare, bl a via 
intranätet, har gjort att kraven på att kunna begränsa olika användares möjligheter att 
påverka systemet ökat. Proview innehåller en användardatabas, där man definierar användare
för olika system, och har möjlighet att gruppera system som delar användare. Databasen har 
designats för att möta kraven på ökad behörighets-kontroll, samtidigt som administrationen 
hålls på en rimlig nivå.

Användardatabasen hanteras av 'pwr_user' (se nedan) eller från administratören.

<option> printdisable
Användar databas <link> userdatabase
Exempel <link> user example
Inloggning <link> user login
pwr_user <link> pwr_user
<option> printenable
</topic>

<headerlevel>
<topic>userdatabase
Användardatabas

Användardatabasen  populeras av systemgrupper och användare. När en proview-funktion 
startas, t ex operatörs- eller utvecklings-miljön, kontrolleras att användaren finns i 
databasen och användarens privilegier registreras. Privilegerna avgör vad en användare 
tillåts att göra i systemet.

<h1>Systemgrupp
Begreppet systemgrupp har införts för att man inte ska behöva definiera varje system i 
databasen. Istället definerar man systemgrupper och knyter ett antal system till varje 
systemgrupp. Dessa system kommer att ha gemensamma användare.

I databasen byggs upp en hierarki av systemgrupper. Hierarkin fyller två funktioner, dels att
beskriva sambandet mellan olika systemgrupper, och dels att kunna införa arv mellan 
systemgrupperna. Systemgrupper längre ner i hierarkin kan ärva egenskaper och användare av 
systemgrupper längre upp i hierarkin.

Om en systemgrupp ska ärva användare eller inte avgörs av attributet UserInherit. Om 
attributet är satt kommer systemgruppen att ärva samtliga användare från närmast ovanliggande
systemgrupp. Även de användare som ovanliggande systemgrupp har ärvt, ärvs vidare. En 
systemgrupp kan överrida en ärvd användare genom att definiera användarnamnet till sin egen 
systemgrupp.

En systemgrupp refereras med 'path'-namnet i hierarkin där namnet är åtskilda med punkt, t ex
'ssab.hql.se1', där ssab är rot-gruppen och se1 understa nivån i hierarkin.

Ett proview-system knyts till en systemgrupp genom att systemgruppen anges i System-objektet.
Om systemgruppen inte finns i användardatabasen, men någon förälder, eller förfader 
återfinns, antas att systemgruppen ärver användare från förfadern.

<h2>Attribut
<b>Attribut <t>Beskrivning
UserInherit <t>Systemgruppen ärver användare av närmast ovanliggande systemgrupp 
            <t>i hierarkin (även system som den systemgruppen har ärvt).

<h1>Användare
En användare karakteriseras av ett användarnamn, ett passerord och en uppsättning 
privileger. Dessutom knyter man en användare till en systemgrupp.

Privilegierna definierar vad en användare har rätt att göra i proview. En del privilegier 
styr möjligheterna att kunna ändra i proview's bas-program t ex xtt eller plc-editorn, en del 
är avsedda att användas vid konstruktion av operatörsbilder så att man kan styra vilka 
inmatningsfält och vilka knappar olika operatörer ska kunna påverka.

Ett användarnamn kan vara knutet till flera systemgrupper, men ur databasen synvinkel är det 
olika användare, med unika passerord och privilegier. De råkar bara ha samma användarnamn.

<h2>Privilegier
<b>Privilegier <t>Beskrivning
RtRead    <t>Får läsa i rtdb. Default-privilegium utan inloggning.
RtWrite   <t>Får skriva i rtdb. Tillåter ändring i rtdb från xtt och Simulate-mod i trace.
System    <t>Privilegium för systemkonstruktör.
Maintenance <t>Privilegium för underhållstekniker.
Process   <t>Privilegium för processtekniker.
Instrument <t>Privilegium för instrumenttekniker.
Operator1 <t>Privilegium för operatör.
Operator2 <t>Privilegium för operatör.
Operator3 <t>Privilegium för operatör.
Operator4 <t>Privilegium för operatör.
Operator5 <t>Privilegium för operatör.
Operator6 <t>Privilegium för operatör.
Operator7 <t>Privilegium för operatör.
Operator8 <t>Privilegium för operatör.
Operator9 <t>Privilegium för operatör.
Operator10 <t>Privilegium för operatör.
DevRead   <t>Får läsa i arbetsbänken.
DevPlc    <t>Får editera plc-program.
DevConfig <t>Får konfigurera arbetsbänken.
DevClass  <t>För skapa klasser (not yet implemented)
</topic>

<topic> user example
Exempel
Proview user database V1.0.0

<c>ssab
<c>. . . . . . sysansv    System DevRead DevPlc DevConfig (14680068)
<c>. . . . . . skiftel    Maintenance DevRead (2097160)
<c>. . . . . . 55         Operator1 (64)
<c>. hql                  UserInherit
<c>. . . . . . anna       RtWrite Operator4 (514)
<c>. . bl2
<c>. . . . . . anna       Operator4 (512)
<c>. . bl1                UserInherit
<c>. . . . . . 55         Operator1 (64)
<c>. . . . . . carlgustav Operator8 (8192)
<c>. hst
<c>. . . . . . magnus     Operator1 (64)
<c>. . rlb                UserInherit     
<c>. . . . . . amanda     Operator4 (512)

Studera exemplet ovan. Det här är en listning av en användardatabas. Till vänster ser man 
systemgrupperna, och antalet punkter markerar deras hieraki-nivå. På samma rad står 
systemgruppen attribut. Under varje systemgrupp står dess användare med privilegier. 
Systemgruppen ssab har alltså användarna sysansv, skiftel och 55.

Systemgruppen ssab.hql.bl1 har attributet UserInherit vilket gör att den ärver användare från
sin förälder. Även föräldern ssab.hql har UserInherit så ssab.hql.bl1 ärver även från ssab. 
Användarna för ssab.hql.bl1 blir då sysansv, skiftel, anna, 55 och carlgustav. Användaren 55 
hos ssab.hql.bl1 överrider här användaren 55 hos ssab.

Systemgruppen ssab.hql.bl2 saknar UserInherit och har enbart användaren anna.

Systemgruppen ssab.hst.rlb har UserInherit och ärver från sin förälder ssab.hst. Denna har 
dock inte UserInherit och har inte ärvt något från sin förälder ssab. Användarna fär 
ssab.hst.rlb blir amanda och magnus.

Ett system med systemgruppen sandviken.hql kommer att nekas access eftersom systemgruppen och 
alla dess förfäder saknas. 

Ett system med systemgruppen ssab.vwx.n2 kommer att ärva användare från systemgruppen ssab, 
dvs sysansv, skiftel och 55. Alla systemgrupper måste inte finnas i databasen, det räcker att 
någon förfader finns. Det som inte finns antas ha attributet UserInherit.
</topic>

<topic> user login
Inloggning

Inloggning och behörighets-kontroll fungerar olika i olika delar av proview.

<h1>Utvecklingsmiljön
När man startar navigatören öppnas ett inloggnings-fönster där man kan mata in användarnamn 
och passerord. Man kan även skicka med användarnamn och passerord som argument om man vill 
undvika inloggnings-fönstret. För att öppna konfiguratören krävs privilegiet DevRead, och för
att gå in i editerings mod krävs DevRead. För att editera i plc-editorn krävs DevPlc.

<h1>Xtt-operatörsbilder
När xtt startas med ett OpPlace-objekt som argument, hämtas användaren från 
UserName-attributet i motsvarande User-objekt. För att få ändra i databasen från xtt krävs 
RtWrite. I operatörsbilderna finns olika tryck-knappar, dragreglar mm från vilka man kan 
påverka databasen. Dessa objekt har ett access-attribut som talar om vilka priviliger som 
krävs för att kunna aktivera objektet. Dessa privilegier matchas mot användarens privilegier,
och om han inte har något av dem, nekas han access.

Från xtt kan man med login/logout kommandot logga in som en annan användare och därmed ändra 
sina privilegier.

<h1>Operatörsbilder på intranätet
För operatörbilder på webben finns en speciellt inloggningsfönster som kan öppnas om detta
är konfigurerat i WebHandler objektet. Man kan ange default privileger och även en speciell 
systemgrupp fpr 
</topic>

<topic> pwr_user
pwr_user

pwr_user används för att skapa systemgrupper och användare i användar-databasen. 
Konfigureringen sker mha kommandon. 

pwr_user startas från kommando-prompten.

Här beskrivs de olika kommandon som finns för att skapa, modifiera och lista systemgrupper 
och användare.

add group <t>Addera en systemgrupp <link> pwr_user add group
add user  <t>Addera en användare <link> pwr_user add user
get       <t>Hämta en användare <link> pwr_user get
list      <t>Lista systemgrupper och användare <link> pwr_user list
load      <t>Ladda in senaste sparade databas <link> pwr_user load
modify group <t>Ändra en systemgrupp <link> pwr_user modify group
modify user  <t>Ändra en användare <link> pwr_user modify user
remove group <t>Ta bort en systemgrupp <link> pwr_user remove group
remove user  <t>Ta bort en användare <link> pwr_user remove user
save      <t>Spara <link> pwr_user save
su        <t>Logga in som super user <link> pwr_user su
</topic>

<headerlevel>
<topic>pwr_user add
add

add group <link> pwr_user add group
add user <link> pwr_user add user
</topic>

<headerlevel>
<topic> pwr_user add group
add group

Skapa en systemgrupp

<c>pwr_user> add group 'name' [/nouserinherit]

/nouserinherit <t>Attributet UserInherit ska inte vara satt för systemgruppen. 
        <t>UserInherit är default.
</topic>
<topic> pwr_user add user
add user
Skapa en användare.

pwr_user> add user 'name' /group= /password= [/privilege=]
	[/rtread][/rtwrite][/system][/maintenance][/process]
[/instrument][/operator1][/operator2]...[oper10][/devread]
[/devplc][/devconfig][/devclass]

/group <t>Systemgrupp som användaren ska tillhöra.
/password <t>Användarens passerord.
/privilege <t>Privilegier om denna anges anges som en mask, dvs ett heltalsvärde.
/rtread <t>Användaren tilldelas RtRead.
/rtwrite <t>Användaren tilldelas RtWrite.
/system <t>Användaren tilldelas System.
/maintenance <t>Användaren tilldelas Maintenance.
/process <t>Användaren tilldelas Process.
/operator1 <t>Användaren tilldelas Operator1.
...
/operator9 <t>Användaren tilldelas Operator9.
/operator10 <t>Användaren tilldelas Operator10.
/devread <t>Användaren tilldelas DevRead.
/devplc <t>Användaren tilldelas DevPlc.
/devconfig <t>Användaren tilldelas DevConfig.
/devclass <t>Användaren tilldelas DevClass.
</topic>
</headerlevel>

<topic> pwr_user get
get

Hämtar en användare med en algorithm som används i runtime.

pwr_user> get 'username' /group= /password=
</topic>

<topic> pwr_user list
list

Lista systemgrupper och användare.

pwr_user> list
</topic>

<topic> pwr_user load
load

Laddar in den senaste sparade databasen och raderar eventuella ändringar sen senaste save.
</topic>
<topic> pwr_user modify
modify

modify group <link> pwr_user modify group
modify user <link> pwr_user modify user
</topic>

<headerlevel>
<topic> pwr_user modify group
modify group

Ändra data för en systemgrupp. 

<c>pwr_user> modify group 'name' /[no]userinherit

/userinherit <t>Sätter attributet UserInherit som anger att systemgruppen ska 
             <t>ärva användare från från sin förälder i systemgrupps-hierakin. 
             <t>Negeras med /nouserinherit
</topic>

<topic> pwr_user modify user
modify user

Ändra data för en användare.

<c>pwr_user> modify user 'name' /group= [/password=][/privilege=]
<c>	[/rtread][/rtwrite][/system][/maintenance][/process]
<c>     [/instrument][/operator1][/operator2]...[oper10][/devread]
<c>     [/devplc][/devconfig][/devclass]

/group <t>Systemgrupp som användaren tillhör.
/password <t>Användarens passerord.
/privilege <t>Privilegie om denna anges anges som en mask, dvs ett heltalsvärde.
/rtread <t>Användaren tilldelas RtRead.
/rtwrite <t>Användaren tilldelas RtWrite.
/system <t>Användaren tilldelas System.
/maintenance <t>Användaren tilldelas Maintenance.
/process <t>Användaren tilldelas Process.
/operator1 <t>Användaren tilldelas Operator1.
...
/operator9 <t>Användaren tilldelas Operator9.
/oper10 <t>Användaren tilldelas Operator10.
/devread <t>Användaren tilldelas DevRead.
/devplc <t>Användaren tilldelas DevPlc.
/devconfig <t>Användaren tilldelas DevConfig.
/devclass <t>Användaren tilldelas DevClass.
</topic>
</headerlevel>

<topic> pwr_user remove
remove

remove group <link> pwr_user remove group
remove user <link> pwr_user remove user
</topic>

<headerlevel>
<topic> pwr_user remove group
remove group
Ta bort en systemgrupp.

<c>pwr_user> remove group 'name'
</topic>

<topic> pwr_user remove user
remove user

Ta bort en användare.

<c>pwr_user> remove user 'name' /group=
</topic>
</headerlevel>

<topic> pwr_user save
save
Spara.

<c>pwr_user> save
</topic>

<topic> pwr_user su
su

Logga in som super-user. Som super-user kan man se se password för användare vid listning.
su kräver password.

<c>pwr_user> su 'password' 
</topic>
</headerlevel>
</headerlevel>
</chapter>

<chapter>
<topic> classeditor
Klasseditor

Det här avsnittet beskriver hur man skapar nya klasser i Proview. 
Det finns ett antal olika fall när det kan vara idé att skapa en ny klass.

<h2>Data objekt
Man vill lagra en mängd data i en datastruktur, t ex för att smidigare kunna få tillgång till
datamängden från applikationer. Man kan även skapa dataobjekt som beskriver material som
passerar genom en anläggning, där ett dataobjekt innehåller egenskaper för ett material, t ex
längd, bredd, vikt etc. Material objekt kan flyttas runt i NMps celler för att beskriva läget
av ett material i anläggningen, och låta detta styra processen.

<h2>Plc funktionsobjekt
Funktionsobjekt som används i plc programmeringen består av en klass som definierar in- och
utgångs pinnar på funktionsobjektet samt eventuella interna attribut. Det här typen av objekt
består även av kod, som exekveras av plcprogrammet. Man kan välja att skapa koden i
form av plc-kod eller c-kod.

<h2>Komponenter
Ett komponent-objekt speglar en komponent i anläggningen och är ofta uppdelad i två eller tre
olika klasser, ett huvudobjekt, ett funktionsobjekt och ett bussobjekt, ibland även ett 
simuleringsobjekt. Huvudobjektet läggs i anläggningshierarkin och innehåller de signaler som
är kopplade till komponenten, jämte andra konfigureringsdata. I ett plcprogram läggs ett 
funktionsobjekt som kopplas till huvudobjektet och som arbetar dels med data från sina egna 
ingångar, och dels med signaler och andra parametrar som finns i huvudobjektet. Om 
signalutbytet med komponenten sker via Profibus, kan man även skapa ett speciellt Profibus
modulobjekt som innehåller kanalobjekt för de data som transporteras på Profbus. Här räcker
det med att göra en koppling mellan huvudobjekt och modulobjekt, för att koppla ihop alla
kanaler och signaler. Simuleringsobjektet är ett funktionsobjekt som kopplas till 
huvudobjektet och som simulerar komponenten när systemet körs i simuleringsmod.

<h2>Subklasser av komponenter
Proview innehåller ett antal baskomponent-klasser för ventiler, motorer mm. Dessa är byggda
mycket generalla för att täcka in ett stort antal komponenter. Ofta gör man en subklass som
är anpassad till en specifik komponent, och som t ex innehåller länk till datablad, 
hjälptext mm. för just denna komponent. Genom att göra en subklass av en baskomponent ärver
man alla metoder och attribut från denna, men har även möjligheten att utöka funktionaliteten
med fler attribut och mer plc-kod.

<h2>Aggregat
Ett aggregat speglar ett anläggningsdel som består av ett antal komponenter. Här kan man göra
en aggregats-klass som innehåller de olika komponenterna i form av attributobjekt. 
Till aggregatet finns även ett funktionsobjekt som anropar funktionsobjekten för ingående 
komponenter. Aggregat kan även inehålla andra aggregat och ge upphov till ganska omfattande
objektsstrukturer. I princip skulle man kunna bygga en anläggning i form att ett enda
aggregatsobjekt, men praktiken är det lämpligt att hålla objektsstrukturen på en ganska låg
nivå. Det är framför allt när man har flera identiska aggregat som man har nytta av att göra
ett aggregatsobjekt av anläggningsdelen.

<option> printdisable
<b>Databasstruktur <link> ced_databasestructure
<b>Klassbeskrivning <link> ced_classdescription
<b>Typbeskrivning <link> ced_typedescription
<b>Skapa klasser <link> ced_createclasses
<b>Bygga klassvolym <link> ced_build
<b>Dokumentation av klasser <link> class docblock
<option> printenable


</topic>

<headerlevel>
<topic>ced_databasestructure
Databasstruktur
<h1>Objekt
I avsnittet Databas struktur ges en beskrivning av hur objekt är uppbyggda. Här finns 
anledning att gå lite djupare i det ämnet.

Ett objekt består av ett objektshuvud och en objektskropp. Objekshuvudet innehåller 
information om objektets namn, klass och relation till andra objekt. Objektskroppen innehåller
objektets datamängd.

<h2>Objektshuvud
Ett objekt har ett namn på maximalt 31 tecken som finns lagrat i objekthuvudet. 

I objektshuvudet finns även en länk till objekts klassbeskrivning. I klassbeskrivningen finns 
information som gör att man kan tolka objektets datamängd, hur den är uppdela i olika 
attribut och vilken typ de olika attributen har. Vidare finns här även de olika metoder som
kan verka på objektet.

Ett objekt ligger i en trädstruktur och i objektshuvudet finns pekare till närmsta anhöriga:
förälder, föregående syskon, nästa syskon och första barn.

Strukturen på ett objekthuvud är gemensamt för alla olika typer av objekt.

<h2>Objektskropp
Ett objekt kan ha två olika kroppar, en kropp som innehåller den datamänd som behövs i 
runtime, dessutom kan ett objekt ha ytterligare en kropp med en datamängd som enbart finns
i utvecklingsmiljön.

En kropp är uppdelad i attribut som innehåller data av en viss typ, det kan t ex vara en 
Boolean, Float32 eller Int32. Men ett attribut kan även vara en mer komplex datatyp, som en
vektor eller en klass.

<b>RtBody
RtBody är den kropp som finns i runtimedatabasen. Kroppen finns även i utvecklingsmiljön så
att man där kan datasätta olika attribut i kroppen.

<b>DevBody
Vissa objekt har även en DevBody, en kropp som enbart finns i utvecklingsdatabas, och som 
inte laddas in i runtimedatabasen. Detta används främst av plcobjekt, där devbody t ex 
innehåller grafisk data för plceditorn.

</topic>

<topic>ced_classdescription
Klassbeskrivning

Hur ett objekts kropp ser ut finns beskrivet i objektets klassbeskrivning. Här finns även
de metoder som kan verka på ett objekt beskrivna och alla övriga egenskaper hos instanser
av klassen. Klassbeskrivningen byggs upp av speciella klassdefinitionsobjekt som ligger i
en klassvolym. Klassvolymen har en strikt syntax över hur klassbeskrivningarna ska var 
uppbyggda. Här följer en presentation av de olika objekt som ingår in en klassbeskrivning.

<h2>Klassvolym
Klassbeskrivningar ligger i en speciell typ av volym, ClassVolume. Dessa kan innehålla två
olika hierarkier, en hieraki med klassbeskrivningar och en med typbeskrivningar.

<h2>$ClassHier
Klassbeskrivningar ligger under rotobjektet 'Class' av  klassen $ClassHier. Under $ClassHier
objektet ligger objekt som beskriver olika klasser i form av $ClassDef objekt.

<h2>$ClassDef
Ett $ClassDef objekt med underliggande objekt beskriver en klass. Namnet på objeketet ger
namnet på klassen. Under $ClassDef objektet kan det finnas

- ett $ObjBodyDef objekt, 'RtBody', som beskriver runtimekroppen.
- ett $ObjBodyDef objekt, 'DevBody', som beskriver kroppen i utvecklingsmiljön.
- ett Template objekt, dvs ett objekt av den aktuella klassen som innehåller defaultvärden
  för instanser av klassen.
- ett eller flera body objekt som innehåller data för specifika funktioner.
- ett PlcTemplate objekt, som kan öppnas av plceditorn, och som innehåller plc-kod för 
  klassen.
- menyobjekt som beskriver popupmenyn i navigatören, konfiguratören och xtt.
- metodobjekt som knyter till metoder som anropas t ex när objekt skapas eller flyttas i
  utvecklingsmiljön.

<h2>$ObjBodyDef
Ett $ObjBodyDef kan ha antingen namnet 'RtBody' och beskriver då runtimekroppen, eller 
namnet 'DevBody' som bekriver utvecklingsmiljö kroppen. I attributet 'StructName' ligger
namnet på c-structen för klassen i den include-fil som genereras för volymen. Under 
$ObjBodyDef objektet ligger ett objekt för varje attribut som finns i objektskroppen. För 
dataobjekt använder man $Attribute objekt, för funktionsobjekt $Input, $Output och $Intern.

<h2>$Attribute
Ett $Attribute objekt beskriver ett attribut i en kropp. Attributet kan vara av följande
typ:
- en bastyp, t ex Boolean, Float32, Time, Int16.
- en härledd typ, t ex String80, Text1024, URL.
- en vektor av bastyp eller härledd typ.
- en annan klass.
- en vektor av en klass.
- en rtdb pekare, dvs en pekare som kan tolkas av alla processer.
- en privat pekare, dvs en pekare som endast kan tolkas av en process.

Typen anges i attributet 'TypeRef'. I attributet 'Flags' anges om objektet beskriver en
vektor, pekare, klass mm. Om objektet beskriver en vektor anges antalet element i 'Elements'.

<h2>$Input
$Input beskriver en ingång till ett funktionsobjekt i plcprogrammet. Ingången kan vara av
typen Boolean, Float32, Int32, String80, Time, DeltaTime eller av datatyp (pekare till 
Float32). $Input ger upphov till ett attribut med två element, ett element av den angivna
typen, och ett element med en pekare till den angivna typen. Om ingången är kopplad pekar
pekaren på det kopplade utgångsattributet, om ingången ej är kopplad pekare den på sitt
första element, där man kan då kan datasätta ett värde på ingången.

Attributet 'PgmName' anger namnet i c-structen för attributet, och 'GraphName' den textsträng
som skrivs i funktionsobjektet vi ingången.

<h2>$Intern
Ger uphov till ett internt attribut i ett funktionsobjekt, dvs ett attribut som varken är en
ingång eller utgång.

<h2>$Output
$Output beskriver en utgång i ett funktionsobjekt. Samma datatyper gäller för $Output som för
$Input.

<h2>$Buffer
$Buffer skapar ett attribut som innehåller en datamängd av en viss storlek som endast någon 
enstaka funktion behöver kunna tolka. Datamängden beskrivs av en klass, men går ej att
öppna i t ex xtt. PlcNode som återfinns i alla plc objekt är ett exempel på $Buffer. Där
återfinns grafiska information som enbart är av intresse för plc-editorn.

<h2>Klass kropp
Ett klass kan innehålla ett klass kropp objekt. Klass kroppobjektet innehåller data som är
gemensam för alla instanser av klassen. Exempel på klass kropp objekt är $GraphPlcNode som
återfinns i all plc-klasser. $GraphPlcNode innehåller data för kodgenerering och grafisk 
layout av funktionsobjektet.

<h1>Menyer
Menyobjekt används för att definiera popup-menyer för objekt i utvecklingsmiljön och i 
operatörsmiljön. $Menu definierar en popupmeny i utvecklingsmiljön, och $RtMenu in 
operatörsmiljön. Under menuobjektet definieras menyalternativ med $MenuButton objekt, och
undermenyer med $MenuCascade objekt. Meny-objekten läggs under $ClassDef objektet.

Menyobjekten anropar metoder, dvs c-funktioner som byggs med utvecklingsmiljön resp
operatörsmiljön. Det finns fn inte någon möjliget att göra detta från ett projekt, utan
bygget måste ske från källkodsträdet.

<h2>$Menu
$Menu objekt beskriver popupmenyer i utvecklingsmiljön. Objektsnamnet specificerar funktionen,
första delen anger verktyget (Navigator/Configurator). De fem sista bokstäverna bestämmer
under vilka vilkor menyn är närvarande, beroende på vilka objekt som är utvale eller utpekade.

1. P står för pointed, dvs det objekt som markören pekar på.
2. anger vad pointed är: 'o' ett objekt, 'a' ett attribut, 'c' en klass i paletten.
3. s står för selected, dvs det objekt som är utvalt.
4. anger vad selected är: 'o' ett objekt, 'a' ett attribute, 'c' en klass i paletten,
   'm' flera objekt utvalda, 'n' inget objekt utvalt.
5. anger om selected och pointed är samma objekt: 's' samma objekt, 'n' olika objekt.

Exempel ConfiguratorPosos: 'Po' markören pekar på ett objekt, 'so' ett objekt är utvalt,
's' det objekt markören pekar på och det utvalda är samma objekt.

<h2>$RtMenu
Menyobjekt som beskriver popupmenyer i operatörsmiljön.

<h2>$MenuButton
Definerar ett menyalternativ i en popupmeny.
</topic>

<topic>ced_typedescription
Typbeskrivning

Typbeskrivningar ligger liksom klassbeskrivningar i en klassvolym. De är placerade i en egen
hierarki under ett $TypeHier objekt. Typer är uppdelade i två kategorier, bastyper och
härledda typer.

<h2>Bastyper
Bastyperna ligger definierade i systemvolymen pwrs. Exempel på bastyper är Boolean, Float32
Int32, String, Enum och Mask.

<h2>Härledda typer
Härledda typer kan definieras i vilken klassvolym som helst. De utgörs av 
- vektorer av bastyper, t ex String80.
- uppräkningstyper, Enum, med definerade texter för olika värden.
- bitmasker, Mask, med definerade texter för olika bitar.

<b>$TypeHier
Typbeskrivningar ligger under rotobjektet 'Type' av klassen $TypeHier. $TypeHier objektet har
$Type och $TypeDef objekt som barn.

<b>$Type
Beskrivning av en bastyp. Detta objekt är reserverat för systemvolymen pwrs.

<b>$TypeDef
Beskrivning av en härledd typ. Attributet 'TypeRef' innehåller bastypen. Den vanligaste 
användningen är strängar och texter med specifika längder, och uppräkningstyper och bitmaskar.

För en uppräkningstyp ska bastypen vara $Enum. Under $TypeDef objektet definerar man texter
för olika värden med $Value objekt. När ett värdet av attribut av typen ska visas, visas den 
text som motsvara aktuellt värde. När attributet ska datasättas visas de olika de olika 
texterna med checkboxar och man väljer ut ett alternativ.

För bitmaskar används bastypen $Mask. Under $TypeDef objektet defineras texter för olika
bitar med $Bit objekt. Vid datasättning väljer man liksom för uppräkningstyper, alternativ 
med checkboxar. För bitmaskar kan man välja flera alternativ.

<b>$Value
Används för att definiera ett värde i en uppräkningstyp. Värdet kopplas till ett text som 
visas i konfiguratören och xtt när ett attribut av typen öppnas. I include-filen för volymen
skapas en enum deklaration som kan användas i eventuell c-kod.

<b>$Bit
Används för att definiera en bit i en bitmask. Biten kopplas till ett text som visas i 
konfiguratören och xtt när ett attribut av typen öppnas. I include-filen för volymen skapas 
en enum deklaration som kan användas i eventuell c-kod.
</topic>

<topic>ced_createclasses
Skapa klasser

<option> printdisable
<b>Skapa en klassvolym <link> ced_createclassvolume
<b>Dataklasser <link> ced_dataclasses
<b>Funktionsobjekt <link>ced_foclasses
<b>Komponenter <link>ced_components
<option> printenable
</topic>

<headerlevel>
<topic>ced_createclassvolume
Skapa en klassvolym

Klassdefinition objekten ligger i en klassvolym, och först måste klassvolymen registreras
och skapas.

Registreringen sker i globala volymslistan som öppnas från File/Open/GlobalVolumeList i 
navigatorns meny. Här skapar man ett VolumeReg objekt med lämpligt volymsnamn och 
volymsidentitet. Volymsidentiteten för användar-klassvolymer ska ligga i intervallet
0.0.2-249.1-254. Använd gärna prefixet CVol i namnet för att makera att det är en klassvolym.
Ange även aktuellt projekt.

<image>ced_fig11.gif
<b>Registrering av klassvolymen i GlobalVolumeList

Därefter ska klassvolymen konfigureras i projektets directory volym med ett ClassVolumeConfig
objekt. Öppna Directory volymen med

<c>$ pwrs

och lägg ett ClassVolumeConfig objekt i det högra fönstret. Objektet ska ha samma namn
som klassvolymen. När man har sparat och lämnat edit mod, kan man öppna klassvolymen
genom att högerklicka på ClassVolumeConfig objektet och aktivera 'Open ClassEditor...'.

<image>ced_fig10.gif
<b>Konfiguration av klassvolymen i Directory volymen

Nu öppnas klasseditorn, där man kan skapa klassdefinitions objekt. Genom att gå in i 
editerings mod visas en palett, med de klass och typ definitions klasser som används för att
bygga en klass eller typ.

Börja med att skapa ett objekt av typen $ClassHier på rotnivå. Det får automatiska namnet
'Class'. Under $ClassHier objektet lägger man sedan ett $ClassDef objekt för varje klass som 
ska defineras.
</topic>

<topic>ced_dataclasses
Data klasser

Data klasser är den enklaste typen av klasser, och används normalt för att lagra data i.
Klasserna består av en RtBody med attribut.

För att skapa en klass lägger man ett $ClassDef objekt under 'Class' objektet.
Namnet på $ClassDef objektet kommer att bli klassens namn.

Under $ClassDef objektet skapar man ett $ObjBodyDef objekt som automatiskt får namnet RtBody.

Under RtBody objektet skapas ett $Attribute objekt som definierar ett attribut i klassen.
Namnet på $Attribut-objektet ger attribut-namnet. I objektet måste anges följande:

- attributets typ anges i TypeRef. Ett 32-bitars heltal anges t ex med pwrs:Type-$Int32,
     ett 32-bitars flyttal med pwrs:Type-$Float32 och en boolean med pwrs:Type-$Boolean.
     Det som läggs in är egentligen namnet på ett typdefinitions-objekt. Se i objekts
     handboken pwrs/Types, vilka typer som finns definierade. 
- om attributnamnet innehåller nationella tecken måste man ange ett namn utan nationella
     tecken som godkänns av c-kompilatorn. Detta anges i PgmName.

<image> ced_fig1.gif
<b>Definition av ett attribut

När man sparar, skapas en instans av den aktuella klassen med namnet Template under 
$ClassDef objektet. Här kan man se hur ett objekt av klassen ser ut. I Template objektet kan
man också lägga in default-värden på attributen. När instanser av klassen skapas, tas en 
kopia av Template objektet.

<image> ced_fig2.gif
<b>Template objekt med defaultvärden

<b>Vektorer
Ett vektor-attribut definieras med ett $Attribute objekt på samma som övriga attribut. Här 
sätter man Flags biten Array, och anger antalet element i vektorn i Elements.

<image> ced_fig3.gif
<b>Definition av vektor attribut med 50 element


<b>Attributobjekt
Med attributobjekt avses attribut som beskrivs av en datastruktur. Orsaken kan vara att man 
vill samla ett antal data i objektet under en mapp, eller att datastrukturen upprepas, i det 
här fallet gör man ett attribut objekt i form av en vektor.

Datastrukturen för attributet måste defineras av en egen klass. Klassen ska enbart innehålla
en runtime body, och får inte ha en development body. 

Attributobjektet definieras med ett $Attribute objekt. Som TypeRef anges den klass som 
beskriver datastrukturen, och i Flags sätts biten Class.

Man kan även göra en array av attributet genom att sätta Array biten i Flags, och ange
antalet element i Elements.

Attributobjekt kan i sin tur ha attribut som är attribut objekt. Antalet nivåer är dock 
begränsat till 20, och längden på det sammanlagda attribut-namnet får maximalt vara 255 tecken.

Ett attribut i ett attributobjekt refereras med punkt som avgränsare, dvs attributet
Description i attributobjektet Pump i objektet o, refereras med namnet 'o.Pump.Description'.
Om pump dessutom är en vektor av pumpobjekt blir namet på Description attributet i det
första pumpobjektet 'o.Pump[0].Description'.

<image> ced_fig4.gif
<b>Definition av ett attributobjekt av klassen Table.


<b>Subklass
Man kan även definiera en klass som en subklass till en annan klass. Subklassen kommer att
ärva attribut och metoder av den andra klassen, som kallas för superklass.

En subklass definieras genom att det första $Attribute objektet i klassen har namnet 'Super',
och bitarna Class och SuperClass satta i Flags ordet. Superklassen anges i TypeRef.

Alla attribut som finns i superklassen kommer även att finnas i subklassen. Subklassen kan
byggas ut med fler attribut som defineras på normalt sätt med $Attribute objekt.

En superklass får enbart innehålla en runtime body, ej någon dev body.

<image> ced_fig5.gif
<b>Super attributet gör MyDataClass till en subklass till MySuperDataClass

</topic>

<topic>ced_foclasses
Funktionsobjekts klasser

Funktionsobjekt används i plc editorn för att programmera plc-program. Även ett 
funktionsobjekt beskrivs av en klass, vanligvis lite med komplex än en data-klass, eftersom 
den, förutom en datastruktur, även ska definera ett grafiskt utseende med in och utgångar, 
och den kod som ska exekveras av plc-programmet.

Koden kan defineras antingen med c-kod, eller med grafiskt programmering i plc-editorn.

<option> printdisable
<b>Funktions-objekt med c-kod <link> ced_ccodefo
<b>Funktions-objekt med plc-kod <link> ced_plccodefo
<option> printenable
</topic>

<headerlevel>
<topic>ced_ccodefo
Funktionsobjekt med c-kod

Funktionsobjekts-klassen defineras med ett $ClassDef objekt under 'Class' objektet. Namnge
objektet och aktivera 'Configure-CCodeFo' från popup-menyn för objektet. Nu skapas 

- ett RtBody objekt. 
- ett DevBody objekt med ett PlcNode objekt som definierar en buffer för grafisk information 
  i instanserna.
- ett GraphPlcNode objekt som innehåller diverse information om grafik och kodgenerering 
  för klassen.

Nästa steg är att definiera attribut för klassen. Attributen indelas i ingångar, interna 
attribut och utgångar.

<b>Ingångar
Ingångsattributen definierar ingångarna på funktions-objektet, dvs värden som hämtas från 
utgångar på andra funktionsobjekt. Ingångarna definieras med $Input objekt som läggs under
RtBody objektet. 

I TypeRef anges datatypen för ingången, de datatyper man kan välja är pwrs:Type-$Boolean, 
pwrs:Type-$Float32, pwrs:Type-Int32 eller pwrs:Type-String80.

I GraphName anges texten på ingången i funktionsobjektet, normalt brukar man använda 2 - 4
bokstäver. Man brukar använda stora bokstäver för analoga signaler, små för digitala och
stor första bokstav för övriga signaltyper.

Ett ingångsattribut i en instans innehåller både en pekare till den utgång den är kopplad
till, och ett värde som kan datasättas. Det gör att man kan välja om en ingång ska kopplas, 
eller datasättas. Det här valet görs med en checkbox (Used), och om man väljer att inte
markera Used, visas inte ingångs pinnen på funktionsobjektet. I Template objektet kan man
sätta defaultvärde på ingången, i det fall ingången inte kopplas.

<b>Interna attribut
Interna attribut är attribut som ej är ut eller ingångar. Det kan vara beräknade värden som
behöver lagras i objektet, eller värden som används för att konfigurera objektet.

Alla vanliga datatyper är tillgängliga för interna attribut.

<b>Utgångar
Utgångsattributen definierar utgångarna på funktions-objektet, dvs värden som lagras i
objeketet, och som därifrån kan hämtas till ingångar på andra funktionsobjekt. Utgångarna
definieras med $Output objekt som läggs under RtBody objektet.

I TypeRef anges datatypen för utgången, liksom för $Input objekt kan Boolean, Float32, Int32
och String80 anges, och i GraphName anges texten vid utgångspinnen i funktionsobjektet.

<b>OBS !
$Input, $Intern och $Output måste ligga i följande ordning under RtBody: $Input först, sedan 
$Intern och därefter $Output.

<b>Default värden
Defaultvärden på attribut kan anges i Template objektet.

Om man vill ange vilka in och utgångar som ska visas som default, finns det en mask i
GraphPlcNode objektet, default_mask. default_mask[0] anger ingångar och default_mask[1]
utgångar. Om biten som motsvarar en in eller utgång sätts visas denna som default.

<image> ced_fig6.gif
<b>Funktionsobjekt med två ingångar, ett internt attribut, och en utgång

<image> ced_fig7.gif
<b>Funktionsobjektet för klassen

<b>Kod
När klassvolymen byggs genereras en h-fil med en c-struct för klassen. Namnet på structen 
blir 

<c>pwr_sClass_'StructName' 

där StructName hämtas från StructName attributet i RtBody. Default är det samma som 
klassnamnet, men t ex om klassnamnet innehåller nationella tecken, kan ett annat namn anges.

Här visas ett exempel på structen för klassen MyFo som innehåller två ingångar In1 och In2,
ett internt attribut Factor, och en utgång Out, alla av typen Float32.

<c>typedef struct {
<c>  pwr_tFloat32           *In1P;
<c>  pwr_tFloat32           In1;
<c>  pwr_tFloat32           *In2P;
<c>  pwr_tFloat32           In2;
<c>  pwr_tFloat32           Factor;
<c>  pwr_tFloat32           Out;
<c>} pwr_sClass_MyFo;

Notera att varje ingång består av två element, en pekare med suffixet 'P', och ett element 
som kan datasättas om ingången inte kopplas. Om ingången är kopplad kommer pekar-elementet 
att peka på den utgång den är kopplad till, annars pekar den på datasättnings-elementet. I 
koden ska man därför använda pekar-elementet för att hämta upp värde på ingången.

Koden för klassen ska vara en funktion med följande utseende

<c>void 'StructName'_exec( plc_sThread *tp,
<c>                        pwr_sClass_'StructName' *o) {
<c>}

I koden hämtas data från ingångarna, och beräknade värden läggs ut på utgångarna. Även 
interna attribut kan användas för att lagra information till nästa scan, eller för att hämta 
upp konfigureringsdata.

I kod exemplet nedan är In1 och In2 ingångar, Factor ett internt attribut och Out en utgång.

<c>  o->Out = o->Factor * (*o->In1P + *o->In2P);

Observera att pekar-elementet för ingångarna In1 och In2 används i koden.

Modulen för c-koden kompileras och länkas ihop med plc-programmet genom att en länk-fil 
skapas på katalogen $pwrp_exe. Filen ska namnges plc_'nodenamn'_'busnr'.opt, t ex 
plc_mynode_0999.opt. Innehållet i filen skickas med som indata till länkaren, ld, och man 
lägger även in modulerna för plc-koden. I exemplet nedan antas att dessa moduler ligger i 
arkivet $pwrp_lib/libpwrp.a.

<c>$pwr_obj/rt_io_user.o -lpwrp -lpwr_rt -lpwr_usbio_dummy -lpwr_usb_dummy -lpwr_pnak_dummy

</topic>

<topic>ced_plccodefo
Funktions-objekt med plc-kod

Ett funktions-objekt där koden skrivs in form av plc-kod i plc-editor, definieras på liknande
sätt som funktions-objeketet med c-kod ovan.

Funktionsobjekt klassen defineras med ett $ClassDef objekt under 'Class' objektet. Namnge
objektet och aktivera Configure-Fo från popup-menyn för objektet. Nu skapas, förutom de 
objekt som även skapas för c-kods funktionsobjektet, ett Code objekt av klassen PlcTemplate.
Det här objektet kan öppnas med plc-editorn, och här defineras koden för klassen.

Ingångar, interna attribute och utgångar i funktionsobjektet definieras, på samma sätt som
för funktionsobjektet med c-kod, med $Input, $Intern och $Output attribut.

<image> ced_fig8.gif
<b>Definition av funktionsobjekt med plc-kod.

<b>Kod
Genom att aktivera 'Open Program...' i popupmeny för Code objektet öppas plc-editorn. Här kan
man nu skriva koden med funktions-objekts programmering. Koden skapas på samma sätt som ett 
vanligt program. Det som tillkommer är att hämta upp värden från ingångar och interna 
attribut, och att tilldela värden på utgångar.

Värden på ingångar, interna attribut, och även utgångar, hämtas upp i koden med GetDp, GetIp,
GetAp eller GetSp objekt. Objekten knyts till attribut i objektet genom att attributet väljs 
ut i Template objektet för klassen, och 'Connect' aktiveras för  Get-objektet. En symbolisk 
referens $PlcFo läggs nu in i Get objektet. Den kommer sedan att bytas ut mot en referens 
till respektive instans, när koden för instansen kompileras.

Beräknade värden lagras i utgångar eller interna attribut med StoDp, StoIp etc. Dessa
kopplas till attribut på samma sätt ingångarna, genom att välja ut attributen i 
Template objektet och aktivera 'Connect'.

<image> ced_fig9.gif
<b>Exempel på plc-kod för ett funktionsobjekt

Template koden i Code objektet behöver inte kompileras eller byggas. När en instans
kompileras första gången, kopieras koden från template programmet till instansen.

Om template-koden ändras kommer instansernas kod att uppdateras nästa gång de kompileras
(volymen med instanserna måste uppdateras med UpdateClasses först).
</topic>
</headerlevel>

<topic>ced_ioclasses
I/O klasser

I/O objekt är de objekt som hanteras av I/O hanteringen i Proview. De kan indelas i Agent, 
Rack, Card och Channel objekt. Vid knytning av nya I/O system till Proview måste man oftast 
skapa  ny klasser av typerna Agent, Rack och Card. I/O objekt skapas med ett $ClassDef objekt
där man i Flags sätter biten IoAgent, IoRack eller IoCard.

En närmare beskrivning av hur man skapar I/O objekt finns i Guide to I/O System.
</topic>

<topic>ced_components
Komponenter

En komponent är ett objekt, eller ett antal objekt som hanterar en komponent i anläggningen,
det kan vara en ventil, en motor, en frekvensomformare etc. Tanken bakom komponent-begreppet
är att man genom att skapa ett objekt (eller ett antal objekt) får med allt som behövs för
att styra komponenten: ett objekt som innehåller data och signaler, ett funktionsobjekt med 
kod för att styra komponenten, objektsbild för HMI, simulerings objekt, I/O objekt för att 
knyta mot bus-kommunikation mm.

En komponent kan bestå av följande delar
- ett huvudobjekt.
- ett funktionsobjekt.
- ett simuleringsobjekt.
- ett eller flera I/O bus objekt.
- objektsbild för huvudobjektet.
- objektsbild för simulerings objektet.
- grafisk symbol för huvudobjektet.

<option> printdisable
<b>Huvudobjekt <link> ced_compmain
<b>Funktionsobjekt <link> ced_compfo
<b>Simuleringsobjekt <link> ced_compsim
<b>I/O bus objekt <link> ced_compio
<b>Objektsbild <link> ced_compog
<b>Grafisk symbol <link> ced_compgs
<option> printenable
</topic>

<headerlevel>
<topic> ced_compmain
Huvudobjekt

Huvudobjektet innehåller alla data som behövs för att konfigurera och göra beräkningar.
Objektet läggs i planthierarkin, som ett individuellt objekt eller som en del av ett 
aggregat.

Ofta använder man BaseComponent:Component som superklass till komponentobjekt och för då med 
ett antal attribut, som Description, Specification, DataSheet etc.

Alla in- och utgångsignaler som finns på komponenten ska finnas i huvudobjektet. Di, Ii, Ai, 
Do, Io, Ao eller Co objekt läggs som attributobjekt. När man skapar instanser av komponenten
måste signalerna kopplas till kanalobjekt. För t ex Profibus, kan man skapa ett modulobjekt 
som innehåller kanalerna, och, i klasseditorn, förkoppla signalerna i huvudobjektet till dessa
kanaler. För varje instans behöver man då inte koppla varje signal för sig, utan kan göra en 
koppling mellan huvudobjekt och modulobjekt.

<h2>Speciella attribut
<b>PlcConnect
Om det finns någon kod för objektet som ska exekveras av plc-programmet, skapar man ett 
funktionsobjekt för klassen. Detta måste kopplas till huvudobjektet, och denna koppling ska 
ligga i ett attribut med namnet 'PlcConnect' av typen pwrs:Type-$AttrRef. 

<b>SimConnect
Om det finns ett simulerings objekt så kopplas det till huvudobjektet med 'SimConnect' 
attribute av typen pwrs:Type-AttrRef.

<b>IoConnect
Om det finns ett I/O-modul objekt kopplas detta med ett attribut, 'IoConnect' av typen
pwrs:Type-AttrRef. Attributet hanteras av IoConnect metoden.

<b>IoStatus
Om man vill hämta upp status från I/O-modul objektet skapar man attributet 'IoStatus' av 
typen pwrs:Type-$Status, och sätter Pointer biten i Flags.

Attributet kommer att tilldelas en pekare till I/O modulens Status attribut i runtime vid
initieringen av I/O hanteringen. Status-attributet är av typen Status och kan t ex visas i en
objektsbild med dynamiktypen StatusColor. Om man vill använda IoStatus i plc-koden för 
objektet, måste man tänka på att attributet är en pekare och hämta upp värdet upp med 
GetIpPtr.

<b>GraphConfiguration
GraphConfiguration är av typ Enum och används för att bestämma vilken objektsbild som ska
öppnas för den aktuella instansen. Används av 'ConfigureComponent' metoden (se nedan).

<h2>DisableAttr
DisableAttr funktionen gör att möjligt att göra Disable på ett attribut i en instans. Om man
har gjort Disable på ett attribut, visas attributet inte i navigatorn eller objekts editorn.
Är attributet en signal, kommer den att ignoreras av I/O-hanteringen.

Funktionen används för komponenter som kan förekomma i olika varianter och konfigurationer.
En magnetventil, till exempel, kan ha ett gränsläge som indikerar att ventilen är öppen, och 
ett som indikerar att ventilen är stängd. Totalt blir det fyra varianter av magnetventilen:

- inga gränslägen.
- gränsläge öppen.
- gränsläge stängd.
- både gränsläge öppen och gränsläge stängd.

Man skulle kunna göra fyra olika magnetventilsklasser, man problemen uppstår när man bygger
aggregat av ventil objekten. Ett aggregat som innehåller ett ventilobjekt måste även det 
finnas i fyra olika varianter, och skulle aggregatet innehålla två ventilobjekt måste det
finnas i 16 varianter. Genom att använda DisableAttr funktionen på gränslägesattributen kan
man göra en magnetventilklass som täcker in alla fyra varianterna, och som även kan användas
i aggregat-klasser.

DisableAttr för ett attribut läggs in på följande sätt.
- DisableAttr biten i Flags sätts för attributet.
- före attributet läggs ett attribut av typen pwrs:Type-$DisableAttr, med samma namn som 
  attributet men med prefixet 'Disable'. Invisible biten i Flags ska sättas för DisableAttr
  attributet.

<b>Exempel
I Magnetventilsklassen ovan representeras gränsläge stängd av attributet SwitchClosed som är
en digital signal av type pwrb:Class-Di. Omedelbart före attributet läggs ett attribut med 
namnet 'DisableSwitchClosed' av typen pwrs:Type-$DisableAttr. För detta attribut sätts 
Invisible biten i Flags, och för SwitchClosed attributet sätts DisableAttr biten i Flags.

<image> ced_fig12.gif
<b>Attribut med disable funktion

<h2>Cast
Komponent-klasser byggs ofta relativt flexibla för att minimera antalet varianter. Ofta gör
man en basklass som använder sig av DisableAttr funktionen för att kunna användas i ett
antal olika konfigurationer. I exemplet ovan kan en klass för en magnetventil täcka in fyra
olika konfigurationer av gränslägen genom att sätta DisableAttr på gränslägessignalerna. Man
skapar även subklasser som är anpassade till en speciell ventil. En Durholt 100.103 till 
exempel har inga gränslägen, och man skapar då en subklass till magnetventilklassen, sätter
Disable på båda gränslägena i template-objektet för subklassen, och lägger även in en länk 
till datablad och gör en del andra anpassingar. Resultatet blir en subklass som man kan 
använda för Durholt 100.103 ventiler utan att behöva konfigurera varje enskild instans.

Om vi nu bygger ett generellt aggregat som innehåller  en magnetventil, och vill kunna 
utnyttja de subklasser som finns för magnetventilen, använder man Cast funktionen. 
Cast-funktionen innebär att ett attributobjekt kan castas som en subklass av dess ursprungliga
klass, om subklassen har samma storlek. När ett attributobjekt castas hämtas defaultvärden, 
och därmed konfigureringar från subklassen. Även klassnamn och metoder hämtas från subklassen.

Cast funktionen för ett attribut läggs in på följande sätt:
- CastAttr biten sätt i Flags för attributet.
- Före attributet läggs ett attribut av typen pwrs:Type-$CastId med samma namn som attributet
  men med prefixet 'Cast'. Invisible biten i Flags ska sättas för cast attributet.

<image> ced_fig22.gif
<b>Kontaktor med cast attribut

Castningen av en instans utförs genom att aktivera 'Cast' metoden i popupmenyn för attributet. 
En lista med basklassen och samtliga subklasser visas, där man kan välja den klass 
attributobjektet ska castas som.

Om ett attribut har både cast och disable attribut ska castattributet placeras före disable
attributet.

<image> ced_fig23.gif
<b>Castning av en instans




<h2>Metoder
<h2>Metoden ConfigureComponent
Ofta finns det många varianter på en komponent. I exemplet med magnetventilen ovan, hittade
vi fyra olika varianter beroende på konfigurationen av gränslägen. För att förenkla 
konfigureringen av komponenten för användaren, kan man definiera metoden 'ConfigureComponent'.

ConfigureComponent metoden gör det möjligt att utifrån ett menyalternativ i popupmenyn sätta
Disable på ett eller ett antal attribut, samt att välja en objektbild som är anpassad för den
aktuella konfigurationen.

<b>Meny
Menyalternativen för ConfigureComponent defineras med meny-objekt. Under $ClassDef objektet
läggs ett $Menu objekt med namnet 'ConfiguratorPosos', vilket medför att menyn är synlig i
editeringsmod när objektet är utpekat och utvalt. Under detta läggs ytterligare ett $Menu 
objekt med namnet 'Pointed', och under detta ett $MenuCascade objekt med namnet 
'ConfigureComponent'. Attributet ButtonName sätts till 'ConfigureComponent' för detta objekt.
Under detta läggs slutligen ett $MenuButton objekt för varje konfigureringsalternativ.
Namnet sätt lämpligen till namnet på konfigureringsalternativet, och läggs också in i
attributet ButtonName. I attributet MethodName anges '$Object-ConfigureComponent' och i
attributet FilterName '$Object-ConfigureComponentFilter'. Man ska även fylla i argument till
metoden i MethodArguments. MethodArguments[0] innehåller en bitmask som avgör vilka attribut
som ska göras Disable på i det aktuella menualternativet. Varje attribut som det är möjligt
att göra Disable på representeras av en bit, och bitordningen motsvarar attributens ordning i
objektet. MethodArguments[1] innehåller den grafiska representationen, se nedan.

Om vi tittar på magnetventilen, har den två attribut som kan göras Disable på, SwitchClosed
och SwitchOpen. I bitmasken i MethodArguments[0] motsvarar SwitchClosed första biten, och
SwichOpen andra biten, dvs om första biten är satt, görs Disable på SwitchClosed, och om 
andra biten är satt görs Disable på SwitchOpen. De fyra konfigureringsalternativen TwoSwitches,
SwitchClosed, SwichOpen och NoSwitches motsvaras av följande masker

<c>TwoSwitches   0   (både SwitchOpen och SwitchClosed är närvarande)
<c>SwitchClosed  2   (Disable på SwitchOpen)
<c>SwitchOpen    1   (Disable på SwitchClosed)
<c>NoSwitches    3   (Disable på både SwitchOpen och SwitchClosed)

<image> ced_fig14.gif

<b>Konfigurering av komponent-attribut
Om man gör disable på ett attribut som är en komponent som i sin tur innehåller signaler, måste
man göra disable även på signalerna i komponenten. I/O hanteringen tittar enbart på om den
individuella signalen är satt Disable, och letar inte uppåt i attribut-nivåerna. För att göra
Disable på en signal i ett komponent-attribut adderar man ett kommatecken samt namnet på 
komponenten följt av den Disable mask som gäller för komponenten i MethodArguments[0]. I ett
objekt där man till exempel har gjort Disable på komponenterna Contactor och CircuitBreaker kan
MethodArguments[0] se ut på följande sätt

<c>3, Contactor 1, CircuitBreaker 1

där '3' är objektets Disable mask (som gör Disable på attributen Contactor och CircuitBreaker),
och 'Contactor 1' medför att Disable sätts på ett signalattribut i Contactor, och
'CircuitBreaker 1' gör Disable på en signal i CircuitBreaker.

Det finns även en annan syntax med parenteser som tillåter mer än två nivåer. I det här 
exemplet är objektet ovan, Motor, del av ett större aggregat.

<c>(5 (Motor 3 (Contactor 1, CircuitBreaker 1), Temp 1))

<b>Komponent-attribut med individuell konfigurering
När ConfigureComponent metoden aktiveras tas Disable bort i alla komponentattribut för att
återställa den tidigare konfigureringen. Ibland har man komponenter-attribut som inte ingår
i objektets konfigurering, utan som ska konfigureras individuellt. Dessa komponenter ska inte
återställas av ConfigureComponent metoden, och måste anges i MethodArguments[2], separerade
med komma-tecken. I följande exempel ska komponent-attributen Motor och Contactor konfigureras
med sina egna ConfigureComponent metoder och inte påverkas av objektets ConfigureComponent
metod. I MethodArguments[2] skrivs

<c>Motor, Contactor


<h2>Objektbild
När man ritar objektsbilden för komponenten måste man ta hänsyn till vilken konfigurering som
gäller. Om skillnaderna är små kan man använda Invisible dynamiken. Om skillnaden är större
kan det vara smidigare att rita separata bilder för olika konfigurationer. Man lägger då in
ett attribut i objektet med namnet GraphConfiguration av typen Enum. Lämpligen skapar man en 
speciell enum-typ med aktuella alternativ. Om GraphConfiguration är 0 används standard grafen,
annars sätts de numeriska värdet i GraphConfiguration som suffix på graf-namnet.

För exemplet med magnetventilen, MValve, gör vi en enum-typ, MValveGCEnum, och definerar
värdena

<c>TwoSwitches  0
<c>SwitchClosed 1
<c>SwitchOpen   2
<c>NoSwitches   3

För konfigurationen TwoSwitches, med värdet 0, ritar vi en objektsgraf med namnet mvalve.pwg.
För SwitchClosed, med värdet 1, namnger vi grafen mvalve1.pwg, för SwitchOpen mvalve2.pwg och
för NoSwitches mvalve3.pwg.

Vi lägger även in enum-värdet i MethodArguments[1] i $MenuButton objektet för den aktuella 
konfigurationen. Det kommer att medföra att GraphConfiguration sätts till detta värde när detta
menyalternativ aktiveras.

<image> ced_fig13.gif
<b>Enumeration typ för GraphConfiguration
</topic>

<topic> ced_compfo
Funktionsobjekt

Funktionsobjektet är gränssnittet i plc-programmet. Det definierar in och utgångar som kan 
kopplas till andra funktionsobjekt i plc-editorn. Till skillnad från ett vanligt 
funktionsobjekt jobbar koden i funktionsobjektet för en komponent även mot data i 
huvudobjektet.

Man kan skriva koden i plc-kod eller i c-kod.

<h2>plc-kod
Om man vill att koden i funktionsobjektet ska vara synlig, och det finns behov av att kunna gå
in och köra PlcTrace i koden, är det lämpligt att använda ett funktionsobjekt med plc-kod.

Skapa ett $ClassDef objekt och sätt namn på objektet. Lämpligen tar man samma namn som 
huvudklassen föjt av suffixet 'Fo', t ex MyComponentFo. Aktivera därefter Configure-ConnectedFo
i popupmenyn.

Under RtBody har det skapats ett PlcConnect attribut av typen AttrRef, som kommer att innehålla
länken till huvudobjektet när man har gjort connect i plc-editorn.

Konfigurera in och utgångar med $Input och $Output objekt under RtBody objektet. Man kan även
lägga in $Intern objekt, men vanligtvis lagrar man denna typ av data i huvudobjektet. Observera
att ordningen bland attributobjekten ska var $Input, $Intern, $Output.

Koden skapas genom att öppna plceditorn för Code objektet. I koden hämtar man upp värden från
ingångar genom att välja ut ingångsattributen i template objekete för funktionsobjektet i 
navigatören  och aktivera connect funktionen. Utgångar sätts på motsvarande sätt. När data ska 
hämtas eller sättas i huvud-objektet, väljar man ut attribut i huvudobjektets template-objekt. 
Referenser till funktionsobjektet visas i plc-koden med symbolen $PlcFo och referenser till 
huvudobjektet med symbolen $PlcMain.

Om objektet innehåller komponenter läggs funktionsobjekten för dessa komponenter in i 
plc-koden.

Har man DisableAttr på signaler eller andra attribut måste man hantera detta med villkorlig
exekvering i koden. En signal som är satt Disable för inte sättas eller läsas i koden. Man
använder objektet Disabled under mappen Other, för att hämta upp om ett attribut är satt Disable
eller inte. Detta kan sedan kopplas till ett CArea som står för den villkorliga exekveringen.

<image> ced_fig18.gif
<b> Villkorlig exekvering med Disabled och CArea

<h2>c-kod
Ett funktionsobjekt med c-kod konfigureras med ett $ClassDef objekt. Sätt namn på objektet
och aktivera därefter Configure-ConnectedCCodeFo i popupmenyn.

Under RtBody har det skapats två attribut, PlcConnect av typen AttrRef och PlcConnectP som
är en pekare. I PlcConnect läggs referensen till huvudobjektet in, när man gör connect på en 
instans i plc-editorn. Vid initieringen av plc-programmet i runtime hämtar man, med hjälp av
referensen, en pekare till huvudobjektet. Pekaren läggs i PlcConnectP. Detta görs i c-koden
som är uppdelad i en init funktion som exekveras vid initieringen av plc-programmet, och en
exec function som exekveras varje scan. För funktionsobjektet MyComponentFo med ingångarna
In1 och In2 och utgången Out2 kan koden se ut på följande sätt.

<c>void MyComponentFo_init( pwr_sClass_MyComponentFo  *o)
<c>{
<c>  pwr_tDlid dlid;
<c>  pwr_tStatus sts;

<c>  sts = gdh_DLRefObjectInfoAttrref( &o->PlcConnect, (void **)&o->PlcConnectP, &dlid);
<c>  if ( EVEN(sts)) 
<c>    o->PlcConnectP = 0;
<c>}

<c>void MyComponentFo_exec( plc_sThread      *tp,
<c>                         pwr_sClass_MyComponentFo *o)
<c>{
<c>  pwr_sClass_MyComponent *co = (pwr_sClass_MyComponent *) o->PlcConnectP;

<c>  if ( !co)
<c>    return;

<c>  o->Out = co->Value = co->Factor * (*o->In1P + *o->In2P);
<c>}

</topic>

<topic> ced_compsim
Simuleringsobjekt

Ett simulerings objekt används för att simulera processen, både vid normala förhållanden  och 
när olika felfall uppträder. Simuleringsobjektet läser av utgångs-signaler (Do, Ao, Io) i 
huvudobjektet och sätter värden på ingångs-signaler (Di, Ai, Ii, Co). Objektet är ett 
funktionsobjekt som kan innehålla  in och utgångs attribut, men det vanliga är att dessa saknas 
och att objektet jobbar mot data i huvudobjektet och mot interna attribut som konfigurerar 
simuleringen och utlöser olika felfall. Simuleringsobjektet har ofta en objektsgraf som i 
runtime kan öppnas med huvudobjektets Simulate metod.

Ett simuleringsobjekt kopplas till huvudobjektet med en connectmetod på samma sätt som ett
vanligt funktionsobjekt. Men simuleringsklassen har en annan connect-metod än Fo klassen. 
Huvudobjektet ska innehålla ett attribut 'SimConnect' av typen pwrs:Type-$AttrRef, i vilket 
connectmetoden lägger in objektsidentiteten för simuleringsobjektet när huvudobjekt och 
simulerings kopplas ihop.

En simulerings klass skapas på samma sätt som en funktionsobjekts klass, och kan skrivas
antingen i c- eller plc-kod. Klassen brukar namnges med samma namn som huvudklassen, följt av
suffixet 'Sim'.

Skapa ett $ClassDef objekt och sätt namn på objektet. Aktivera Configure-ConnectedFo eller
Configure-ConnectedCCodeFo. Lägg in eventuella $Input, $Intern och $Output attribut, och skriv
koden som plc eller c-kod. Ändra connectmethod i GraphPlcNode till 26.

Objektsbilden för simulerings objekt ritas ofta med mörkblå bakgrundsfärg och vit text för att
enkelt kunna skiljas från andra objektsbilder. Notera att attribut i huvudobjektet kan
refereras från bilden med referensnotationen '&', t ex &($object.PlcConnect).IndError##Boolean.

<image> ced_fig15.gif
<b>Objektsbild för ett simuleringsobjekt

</topic>

<topic> ced_compio
I/O-modul objekt

Ett huvudobjekt för en komponent kan innehålla signalobjekt av typen Ai, Di, Ii, Ao, Do, Io och
Co. Signalerna i en instans måste kopplas till kanalobjekt i nodehierarkin. I t ex profibus
kan man skapa modulobjekt, där kanalerna är anpassade till den dataarea som tas emot resp
skickas på bussen. I det fall signalerna i en komponent, omfattas av ett modulobjekt, kan man
lägga in symboliska referenser till kanalobjekten i signalobjekten, vilket medför att man
endast behöver koppla komponenten med modulobjektet, inte varje enskild signal för sig. De 
symboliska referenserna läggs in i komponentens template-objekt genom att man gör connect 
mellan signalerna i template-objektet och kanalerna i I/O modulklassens template objekt. De 
symboliska referenserna är av typen $IoConnect konverteras till verkliga referenser vid
initieringen av I/O hanteringen i runtime.

<image> ced_fig16.gif
<b> Signal kopplas med kanal i I/O modul

<image> ced_fig17.gif
<b> Symbolisk referens till kanalobjekt
</topic>

<topic>ced_compog
Objektsbild

Objektsbilder har samma namn som komponenten, men med små bokstäver. För klasser som tillhör
Proviews bassystemet adderar man prefixed 'pwr_c_'. Bilderna editeras på vanligt sätt i Ge. I 
dynamiken ersätts objektsnamnet med '$object'. Objektsbilder för bassystemet ritas med följande 
riktlinjer.

<b> Meny
Det ska finnas en meny med pulldown menyerna File, Methods, Signals och Help.

File ska ha meny följande entryn

<c>Print   Command     print graph/class/inst=$object
<c>Close   CloseGraph

Methods ska ha följande entryn

<c>Help             Invisible   $cmd(check method/method="Help"/object=$object)
<c>                 Command     call method/method="Help"/object=$object
<c>Note             Invisible   $cmd(check method/method="Note"/object=$object)
<c>                 Command     call method/method="Note"/object=$object
<c>Trend            Invisible   $cmd(check method/method="Trend"/object=$object)
<c>                 Command     call method/method="Trend"/object=$object
<c>Fast             Invisible   $cmd(check method/method="Fast"/object=$object)
<c>                 Command     call method/method="Fast"/object=$object
<c>Help             Invisible   $cmd(check method/method="Photo"/object=$object)
<c>                 Command     call method/method="Photo"/object=$object
<c>DataSheet        Invisible   $cmd(check method/method="DataSheet"/object=$object)
<c>                 Command     call method/method="DataSheet"/object=$object
<c>Hist Event...    Invisible   $cmd(check method/method="Hist Event..."/object=$object)
<c>                 Command     call method/method="Hist Event..."/object=$object
<c>Block Events...  Invisible   $cmd(check method/method="Block Events..."/object=$object)
<c>                 Command     call method/method="Block Events..."/object=$object
<c>RtNavigator      Invisible   $cmd(check method/method="RtNavigator"/object=$object)
<c>                 Command     call method/method="RtNavigator"/object=$object
<c>Open Object      Invisible   $cmd(check method/method="Open Object"/object=$object)
<c>                 Command     call method/method="Open Object"/object=$object
<c>Open Plc         Invisible   $cmd(check method/method="Open Plc"/object=$object)
<c>                 Command     call method/method="Open Plc"/object=$object
<c>Circuit Diagram  Invisible   $cmd(check method/method="Circuit Diagram"/object=$object)
<c>                 Command     call method/method="Circuit Diagram"/object=$object
<c>HelpClass        Invisible   $cmd(check method/method="HelpClass"/object=$object)
<c>                 Command     call method/method="HelpClass"/object=$object

Signals ska innehålla alla signaler i komponenten och öppna objektsbilden för respektive signal.
Exempel

<c>SwitchOpen Di    Command     open graph/class /inst=$object.SwitchOpen
<c>SwitchClosed Di  Command     open graph/class /inst=$object.SwitchClosed
<c>Order Do         Command     open graph/class /inst=$object.Order

Help menyn ska innehålla Help och HelpClass

<c>Help             Command     call method/method="Help"/object=$object
<c>HelpClass        Command     call method/method="HelpClass"/object=$object

<b> Verkygspanel
Vertygspanelen innehåller knappar för olika metoder. Dynamiken är densamma som i Method menyn 
ovan. Längst till höger finns även en knapp för simuleringsobjektets objektsbild. Denna har
dynamiken

<c>Invisible   $cmd(check method/method="Simulate"/object=$object)
<c>Command     call method/method="Simulate"/object=$object

Under metodknapparena ligger två textfält som visar Descripton och Specification attributen i
komponenten med följande dynamik

<c>Description     Value.Attribute $object.Description##String80
<c>                Value.Format    %s
<c>Specification   Value.Attribute $object.Specification##String80
<c>                Value.Format    %s

Längst ner i bilden visas eventuellt Notes meddelande med en knapp för att ändra eller ta bort
meddelandet.

<c>Notes knapp     Invisible       $object.Note##String80
<c>                Command         call method/method="Note"/object=$object
<c>Notes text      Value.Attribute $object.Note##String80
<c>                Value.Format    %s

<image> ced_fig21.gif
<b>Objektbild

</topic>

<topic>ced_compgs
Grafisk symbol

Den grafiska symbolen ritas i Ge och ges dynamiken HostObject. För dynamiken i host objekt 
kopplas olika typer av dynamik till attribute i objektet. Objektsnamnet ersätts med
'$hostobject' i dynamiken. Ofta skapar man attributen IndWarning och IndError i huvudobjektet
och färgar symbolen gul resp röd, eller blinkande röd, om dessa är satta. 

<image> ced_fig20.gif
<b>Grafisk symbolen ritas i Ge med HostObject dynamik



</topic>

</headerlevel>
</headerlevel>

<topic> ced_build
Bygga klassvolym

När man bygger klassvolymen skapas en laddatafil och två struct-filer.

<b>Laddatafil
Laddatafilen läggs på $pwrp_load och har samma namn som volymen, men med små bokstäver. 
Filtypen är .dbs, dvs laddatafilen för volymen CVolMerk1 blir $pwrp_load/cvolmerk1.dbs.

Tiden när man skapar laddatafilen lagras i filen. Dessutom lagras versionen av andra 
klassvolymer som laddatafilen är beroende av. Vid uppstart av runtime, kontrolleras att 
de versioner som finns i systemet överensstämmer med de versioner som finns registrerade i 
laddatafilen. Om någon version inte stämmer, får man 'Version mismatch' och uppstarten avbryts.

Man kan se versionen av en laddatafil och versionen av andra volymer den är beroende av med
wb_ldlist. 

<c>$ wb_ldlist $pwrp_load/cvolmerk1.dbs
<c>Volume     CVolMerk1       21-DEC-2007 13:52:05.22 (1198241525,227130443) 25364
<c>VolRef     CVolMerk1       21-DEC-2007 13:52:05.22 (1198241525,227130443) 25364
<c>VolRef     pwrs            12-DEC-2007 08:35:06.98 (1197444906,983976467) 1
<c>VolRef     pwrb            12-DEC-2007 08:35:09.93 (1197444909,930182284) 2
<c>VolRef     BaseComponent   12-DEC-2007 08:35:26.92 (1197444926,926679004) 10

<b>Structfiler
Vid byggandet av en klassvolym skapas två include-filer, en .h, och en .hpp.

Om klassvolymen innehåller funktionsobjekt, eller klasser som används i CArithm eller
DataArithm objekt, måste man inkludera .h filen i $pwrp_inc/ra_plc_user.h.

<b>Uppdatera klasser
När man byggt klassvolymen, måste man uppdatera klasserna i rot- eller subvolymer i projektet.
Uppdateringen aktiveras i konfiguratören för respektive rot eller subvolym, från menyn med
'Functions/Update Classes'. Om en klass är ändrad, kommer instanser av klassen att anpassas 
till den förändrade klassen. Vidare kommer alla referenser till instanser av klassen att 
uppdateras.

</topic>


</headerlevel>


<topic>class docblock
Dokumentation av klasser

För $ClassDef och $Attribute objekt finns ett dokumentationsblock, som fylls i från 
objektseditorn. Från dokumentationsblocken och klassbeskrivningen genereras dokumentation
för klasserna på xtthjälp och html format.

Dokumentationsblocket för $ClassDef objektet bör innehålla en beskrivning
av klassens funktion och användningsområde, documentationsblocket för $Attribut en beskrivning
av det aktuella attributets funktion.

<option> printdisable
Genererering av Xtt hjälpfiler <link> class generate xtthelp
Generering av html dokumentation <link> class generate html
ClassDef <link> docblock classdef
Attribute <link> docblock attribute
c- och h-filer <link> docblock ccode
<option> printenable
</topic>

<headerlevel>

<topic> class generate xtthelp
Generering av Xtt hjälpfiler

Hjälpfiler för xtt genereras med kommandot

<c>co_convert -xv -d $pwrp_exe/ $pwrp_db/userclasses.wb_load

Kommandot genererar en hjälpfil $pwrp_exe/'volymsnamn'_xtthelp.dat som man lämpligt-vis 
lägger en länk till i projektets xtt-hjälpfil $pwrp_exe/xtt_help.dat:

Exempel för klassvolymen cvolvhxn2r:

<i><topic> index

<i>...

<i>Användar klasser<link>cvolssabtest,"",$pwrp_exe/cvolvhxn2r_xtthelp.dat

<i></topic>

...

<i><include> $pwrp_exe/cvolssabtest_xtthelp.dat
</topic>

<topic> class generate html
Generering av html dokumentation

html-filer genereras med kommandot

<c>co_convert -wv -d $pwrp_web/ $pwrp_db/userclasses.wb_load

Kommandot genererar bl a filen $pwrp_web/'volymsnamn'_index.html som innehåller startsidan 
för klass-dokumentationen. Denna tillsammans med övriga filer ($pwrp_web/'volymsnamn'_*.html) 
kopieras till lämplig filkatalog på web-servern.

En länk till dokumentationen skapar man lämpligen med ett WebLink-objekt med URL'en 
'volymsnamn'_index.html

Vill man kunna visa c-structarna för klasserna, konverterar man h-filen med co_convert

<c>co_convert -cv $pwrp_web/ $pwrp_inc/'volymsnamn'classes.h

Vill man dessutom visa koden för plc-objekt ska man lägga in aref-taggar i c eller h-filen 
för koden och konvertera den med

<c>co_convert -sv -d $pwrp_web/ 'filnamn'
</topic>

<topic> docblock classdef
ClassDef

<h2>Exempel

<c>@Author Homer Simpson
<c>@Version 1.0
<c>@Code ra_plc_user.c
<c>@Summary Brief description of this class
<c>Description of
<c>this class.
<c>
<c>See also 
<c>@link Example plat.html
<c>@classlink AnotherPlate cvolvhxn2r_anotherplate.html

<h2>Taggar
Author  <t>Redaktör <link> docblock author
Version <t>Version av klassen <link> docblock version
Code    <t>Fil som innehåller kod för klassen <link> docblock code
Summary <t>Sammanfattning <link> docblock summary
Link    <t>Godtycklig länk <link> docblock link
Classlink <t>Länk till annan klass <link> docblock classlink
wb_load syntax <link> docblock wb_load classdef
</topic>

<headerlevel>
<topic> docblock author
@Author

Författare. Kan utelämnas.

<b>Syntax
<c>@Author 'name of author'
</topic>

<topic> docblock version
@Version

Version. Kan utelämnas.

<b>Syntax
<c>@Version 'version number'
</topic>

<topic> docblock code
@Code

För klasser med plc-kod kan man ange namnet på c-filen. Kan utelämnas.
Även c-filen måste konverteras med: co_convert -c -d $pwrp_web/ 'filnamn'

<b>Syntax
<c>@Code 'filename'
</topic>

<topic> docblock summary
@Summary

Kort beskrivning på en rad. 
Denna visas i indexfilen i xtt-hjälpfilen. Används ej i html.
Kan utelämnas.

<b>Syntax
<c>@Summary 'text'
</topic>

<topic> docblock link
@Link

Här kan läggas in en länk till godtycklig URL. Kommer enbart att visas i 
html-dokumentationen, ej i xtt. Länken måste ligga efter beskrivningen av klassen.

<b>Syntax
<c>@Link 'URL'
</topic>

<topic> docblock classlink
@Classlink

Här kan läggas in en länk till en annan klass. Denna länk fungerar både i html och xtt.
Länken måste ligga efter beskrivningen av klassen.

<b>Syntax
<c>@Classlink 'html-filename'
</topic>

<topic> docblock wb_load classdef
wb_load syntax

Info om en klass skrivs före $ClassDef raden.

<c>!
<c>!/**
<c>!  @Author Homer Simpson
<c>!  @Version 1.0
<c>!  @Code ra_plc_user.c
<c>!  @Summary Brief description of this class
<c>!  Description of
<c>!  this class.
<c>!
<c>!  See also 
<c>!  @link Example plat.html
<c>!  @classlink AnotherPlate cvolvhxn2r_anotherplate.html
<c>!*/
<c>!
<c>Object        Plat    $ClassDef 1

<h2>!/**
Start av ett dokumentations block.
All text mellan !/** och !*/ kommer att skrivas ut i oförvanskad form som beskrivning för 
klassen.

<h2>!*/
Avslutning av ett dokumentations block
</topic>
</headerlevel>

<topic> docblock attribute
Attribute

<h2>Exempel
<c>@Summary Plåtens längd
<c>En grundligare beskrivning
<c>av attributet Langd...


<h2>@Summary
Kort beskrivning på en rad. Om det finns en @Summary läggs denna text in i html-filens tabell
över attribut. Om den inte finns läggs beskrivningen hela beskrivningen in.
Används ej i xtt.

wb_load syntax <link>docblock wb_load attribute
</topic>

<headerlevel>
<topic> docblock wb_load attribute
wb_load syntax

Info om ett attribute skrivs före $Attribute, $Input, $Output eller $Inter raden.

<c>      !/**
<c>      !  @Summary Plåtens längd
<c>      !  En grundligare beskrivning
<c>      !  av attributet Langd...
<c>      !*/
<c>      Object    Langd $Attribute 3
<c>        Body             SysBody
<c>          Attr           TypeRef = "pwrs:Type-$Float32"
<c>        EndBody
<c>      EndObject

<h2>!/**
Start av ett dokumentations block.
All text mellan !/** och !*/ kommer att skrivas ut i oförvanskad form som beskrivning för 
attributet, förutom nedanstående taggar.

<h2>!*/
Avslutning av ett dokumentations block
</topic>
</headerlevel>

<topic> docblock ccode
Syntax för c- och h-filer
Om man vill lägga in länkar till c- och h-filer måste även dessa konverteras till html. Det 
finns även en funktion att lägga in bokmärken. ¨

Struct-filen för klasserna genereras automatiskt med bokmärken.

<c>/**
<c>   MyPlcClass
<c>
<c>   Description for the class that is not displayed anywhere but in the code.
<c>
<c>   @aref MyPlcClass MyPlcClass
<c>*/
<c>void MyPlcClass_exec(...)

<h2>@aref
@aref måste ligga inom ett /*_* ... */ block. Inom blocket kan även finnas kommentarer som 
inte hanteras vid konverteringen.

<b>Syntax
<c>@aref 'bookmark' 'text' 
</topic>

</chapter>

<topic>administrator
Administration

<option> printdisable
Skapa användare <link> adm_user
Registrera volymer <link> register_volumes
Skapa projekt <link> create_project
<option> printenable
</topic>

<topic> adm_user
Användare
För att få tillgång till Proview's utvecklings och runtime miljöer måste man logga in med
användarnamn och passerord. Användare konfigureras i en användardatabas och tilldelas
privilegier som bestämmer användarens behörighet att göra ändringar i systemet.

System som delar samma användare är grupperade i en systemgrupp, och utgående från
systemgruppen definieras användarna. Man kan bygga en hierarki av systemgrupper där 
barngrupper ärver användare av sin förälder, och ytterligare användare kan definieras för
varje barn.

Ett system kopplas till en systemgrupp med attributet SystemGroup i $System objektet.
Notationen för en systemgrupp i en hierarki namnet av gruppen med förfäder åtskilda av en
punkt, t ex 'Main.West.F1'.

I exemplet nedan är Eric ansvarig för alla system i anläggningen, och definierad på den
översta nivån i hierakin. Nils arbetar med den västra delen av anläggningen definieras i 
systemgruppen 'West'. Carl, slutligen, arbetar med system i F1 delen av anläggningen. Alla
systemgrupperna har attributet UserInherit, vilket gör att de ärver användare av sin 
förälder.

<image> dg_fig22.gif

Användare och systemgrupper skapas i administratören.

- Starta administratören med kommandot 'pwra'.
- Gå in i Användardatabasen från menyn, 'File/Open/UserDatabase'.
- Logga in med login kommandot. Öppna kommando-prompten från menyn, 'Functions/Command' och
  skriv 'login /adm' på kommandoraden. Om systemgruppen 'administrator' finns definierad måste man
  dessutom addera användarnamn och passerord för en användare definierad i administrator-
  systemgruppen.
- Gå in i edit mod från menyn, 'Edit/Edit mode'.
  Systemgrupper och användare representeras av objekt av klasserna SystemGroupReg resp UserReg
  som visas i paletten till vänster. Objekt skapas genom att man väljer en klass i paletten,
  och därefter klickar med MB2 (mittenknappen) i det högra fönstret. Objekten läggs i en 
  trädstruktur och klickar man på mappen/lövet på ett existerande objekt läggs det nya objeket 
  som första barn, om kan klicka till höger om mappen/lövet läggs det som syskon.
- Skapa en systemgrupp genom att markera 'SystemGroupReg' i paletten till vänster, och klicka
  med MB2 (mittenknappen) i det högra fönstret. Öppna SystemGroupReg objektet och ange namn och
  attribut för systemgruppen. Ange fullständigt hierarkinamn, t ex 'Main.West'.
- Skapa en användare genom att markera 'UserReg' i paletten och klicka med MB2 på mappen/lövet
  till det SystemGroupReg objekt som UserReg objektet ska ligga under. Öppna UserReg objektet
  och ange anvädarnamn, passerord och privilegier för användaren.
- Spara.
- Logga ut med kommandot 'logout'.

Användardatabasen ligger på katalogen $pwra_db.

</topic>

<topic>register_volumes
Registrera volymer

Alla volymer i ett nätvärk måste ha ett unikt volymsnamn och volymsidentitet. För att
säkerställa detta registreras alla volymer i en global volymslista.

Registreringen görs från administratören:

- Starta administratören med kommandot 'pwra'.
- Gå in i Globala Volymslistan från menyn, 'File/Open/GlobalVolumeList'.
- Logga in som administratör.
- Gå in i editerings läge, 'Edit/Edit mode' i menyn.
  Volymer registreras mha objekt av klassen VolumeReg som visas i paletten till vänster.
  I paletten finns även $Hier klassen, med vilken man kan ordna VolumeReg objekten 
  hierarktiskt.
- Skapa ett VolumeReg objekt, öppna objektet och ange volymsnamn (= objektsnamn), 
  volymsidentitet och projekt.
- Spara.
- Logga ut med 'logout'-kommandot.

<h2>Volymsnamn
Namn på volymen, ska vara unikt och får ha max 31 tecken.

<h2>Volymsidentitet
Volymsidentiteten är ett 32-bitar ord specificerat på formen v1.v2.v3.v4, där v1, v2, v3
och v4 är nummer i intervallet 0-255. Beroende på volymens klass, kan numren väljas i olika
intervall.

Rotvolymer           <t>0.1-254.1-254-1.254
Användarklassvolymer <t>0.0.2-254.1-254

Directory volymen har alltid identiteten 254.254.254.253.

</topic>

<topic>create_project
Skapa projekt

Ett projekt är ett antal noder och volymer som delar samma utvecklingsmiljö. Vanligtvis
består den av några process- och operatörsstationer som styr en del av anläggningen, men
det finns inga begränsningar för storleken av ett projekt. Man kan välja att ha varje nod
i var sitt projekt, eller samtliga noder i ett projekt.

- Alla noder i ett projekt (på samma kommunikationsbuss) har länk öppen mellan varandra
  genom näthanteraren.
- Alla volymer och noder delar samma filkatalogsträd.
- Alla noder måste uppgraderas till ny Proview version samtidigt.

En vanlig storlek är 1-10 noder i ett projekt. För många noder ökar nätverksbelastninge och
försvårar uppgradering av projektet.

Skapa ett projekt i administratören:

- Starta administratören med kommandot 'pwra'.
- Projektlistan visas när man startar administratören. Den kan även öppnas från menyn 
  (File/Open/ProjectList).
- Logga in som administratör.
- Gå in i edit mode från meny, 'Edit/Edit mode'.
  Projekt representeras av objekt av klassen ProjectReg, som visas i paletten till vänster.
  ProjectReg objekten kan ordnas i hierakier mha $Hier objekt.
- Skapa ett ProjectReg objekt och ange projektnamn, basversion, filkatalog och beskrivning.
- Projektet skapas när man sparar, efter att en verifiering har gjorts. Spara och logga ut.

<h2>Projektnamn
Ett projekt har ett projektnamn som identifierar projektet i utvecklingsmiljön. Jämför 
systemnamnet som definierar projektet i runtimemiljön. Projektnamn och systemnamn är ofta
lika, men behöver inte vara det. Ett system kan faktiska ha många projekt i 
utvecklingsmiljön. När man uppgraderar, eller gör större förändringar i systemet, tar man
lämpligen en kopia av projektet och sparar den gående versionen av systemet för att kunna
göra mindra ändringar. Kopian skapas under ett nytt projektnamn men den har samma 
systemnamn.

<h2>Base
Proview ett är flerversions system, dvs olika versioner av Proview kan installeras i samma
utvecklingsmiljö, och projekt med olika version kan existera i samma utvecklingsmiljö.
Ett projekt pekar på en bas, t ex V3.4 eller V4.0, när ett projekt skapas väljer man
vilket bas projektet ska peka på.

<h2>Path
Projektet består av ett filkatalogsträd där databaser, källkodsfiler, arkiv mm lagras.
Path är rot katalogen till det här trädet.

</topic>
</chapter>

<chapter>
<topic>opc_intro
OPC
Proview har implementerat OPC XML/DA protokollet för datautbyte med andra typer av 
automationenheter. För mer information om OPC, se www.opcfoundation.org.

<option> printdisable
OPC Server <link> opc_server
OPC Client <link> opc_client
<option> printenable
</topic>

<headerlevel>
<topic>opc_server
OPC XML/DA Server

En OPC XML/DA Server är en web service från vilken an OPC XML/DA Client kan hämta information
om ett Proview-system. En opc klient kan t ex visa objektshierarkin, läsa och skriva 
attributvärden, och lägga upp prenumerationer på attribut.

Opc servern implementerar även http protokollet och är inte kopplad till en webserver.
Portnummret till opc_server är satt till 80, och URI'n för webservicen på noden 'mynode' blir

<c>http://mynode

Om en webserver är installerad, använder den vanligtvis port 80, och en annan port måste
väljas för opc_server. Om man stället väljer 8080, blir URI'n

<c>http://mynode:8080

<h1>Browsing
Browsing funktionen i OPC XML/DA stödjer grenar (branches) och punkter (item). En punkt 
innehåller ett värde, medan en gren är en hierarkikomponent utan värde. Det finns inte något
stöd för objekt, så ett Proview objekt är implementerat som en gren, och varje attribut är
en punkt under grenen. Även arrayer är implementerade som grenar, med varje element som en 
punkt. Om ett element är ett attributobjekt är även detta en gren.

<h1>Trådar
Om opc klienten använder HoldTime och WaitTime attributen i SubscriptionPollledRefresh 
förfrågan, måste opcservern vara multitrådad, dvs skapa en ny tråd för varje förfrågan. Om 
HoldTime och Waittime inte används (som i Proview's opc klient), kan alla förfrågningar 
hanteras i en enda tråd, vilket sparar cpu-tid. Multitrådning eller inte, konfigureras i
konfigurationsobjektet för opc servern. Defaultvärdet är 'IfNeeded' som slår på multitrådning
för en klient om HoldTime eller WaitTime upptäcks.

<h1>Kient åtkomst
För att få åtkomst till en Proview opc server, måste ip-adressen för klienten konfigureras i
konfigurationsobjektet för opc servern. Här kan man också välja om klienten ska a läs- eller
skriv-rättigheter (ReadOnly resp ReadWrite). ReadOnly tillåter klienten att läsa och 
prenumerera på värden, medan ReadWrite även tillåter skrivning av attributvärden. 

<h1>Buffring av prenumerationer
Servern stödjer inte buffring av prenumerationer.

<h1>Konfigurering
Opc servern konfigureras med ett Opc_ServerConfig objekt, som placeras i nodhierarkin. 
Konfigurationsobjektet medför att en serverprocess (opc_server) startas vid Proview startup.

</topic>
</headerlevel>

<headerlevel>
<topic> opc_client
OPC XML/DA Client

Proveiw's opc klient är implementerad som en extern volym, som monteras i rotvolymens 
objektsträd. Under monteringsobjektet visas de grenar och punkter som opc servern innehåller
med speciella opc objekt. Ett Opc_Hier objekt representerar en gren, ett Opc_Int objekt en
punkt med ett heltalsvärde, ett Opc_Boolean objekt en punkt med ett boolskt värde etc.
Om ett punktobjekt öppnas, visas punkvärdet i Value attributet, och en del andra egenskaper
som beskrivning, lowEU, highEU, ingenjörsenhet, lowIR och highIR visas också. När objektet
öppnas startas en prenumeration, och värdet uppdateras kontinuerligt. För heltal- och
flyttalsvärden finns även en objektsbild som visar en kurva på värdet.

Med en opc klient kan man

- visa grenar och punkter i Xtt, och även visa punkvärden och sätta punktvärden.
- prenumerera på värden och visa dem i en Ge bild.
- hämta upp punktvärden i ett plcprogram, och även skriva punktvärden.

Opc klienten kräver att namn browsing är implementerat i opc servern.

<h1>Ge
Ett punkvärde kan visas i en Ge bild genom att använda namnet på punkten i den externa volymen.
Till exempel, om monteringsobjektet för den externa volyment är 'Ext-P1', och det lokala
namnet för punkten är

<c> /P1/Signals/Ai22

kommer sinalnamnet i Ge antagligen att bli (detta är beroende av browsing funktionen i 
servern)

<c> Ext-P1-P1-Signals-Ai22.Value##Float32

om det är en flyttalspunkt.

<h1>Plc
Punktvärden kan även hanteras i plc programm, genom att använda GeExt... och CStoExt... objekt.
De objekt som normalt används för att hämta och lagra attributvärden, GetDp, GetAp, StoDp,
StoAp etc, kan inte användas efter som det refererade objektets identitet  måste vara känt i 
utvecklingsmiljön, vilket inte är fallet med externa volymer. I Ext objekten, utgörs
referenserna av strängar, vilket gör det möjligt att lägga in punktnamnet. För att hämta värdet
av punken i föregående exempel, ska man använda ett GetExtFloat32 objekt, och punktnamnet ska
vara

<c>Ext-P1-P1-Signals-Ai22.Value

För att lagra ett värde i en punkt, t ex /P1/Signals/Ao5, använder man en CStoExtFloat32.
Det här objektet gör en villkorlig lagring, och enbart på positiv flank på villkoret. Jämför
med CStoAp där värdet är lagrat så länge villkoret är sant. Referensnamnet i CStoExtFloat32
objetet blir i det här fallet

<c>Ext-P1-P1-Signals-Ao5.Value

<h1>Klient process
För varje Opc klient/server förbindelse måste en klientprocess startas. Programmet för denna
process är opc_provider, som tar argumenten

 1. Opc server URL.
 2. Extern volume id.
 3. Extern volume name.
 4. Server identity (optional, default 200).

<h1>Konfigurering
<h2>Registrering av ExternVolym
Registrera externvolymen i den globala volymslistan (GlobalVolumeList) med volymsnamn och 
identitet.

<h2>Applikationsfil
Addera en rad i applikationsfilen för att starta opc_provider. Här är ett exempel för en
opc klient som kopplas upp sig mot opc servern 'http://servernode::8080. Den registrerade
externvolymen har namnet MyOpcVolume med volymsidentiteten 0.1.99.55.

<c>opc_provider, opc_provider, noload, run, opc_provider, 9, nodebug, 
<c>   http://servernode:8080 0.1.99.55 MyOpcVolume

Om punkvärden hämtas i plc programmet, ska prioriteten sättas till 4 (sjätte argumentet).

<h2>Monteringsobjekt
Skapa ett monteringsobjekt i anläggningshierarkin i rotvolymen, och lägg in objektsidentiten
för volymsobjektet i externvolymen i Objekt attributet. I exemplet ovan är denna objid
_O0.1.99.55:0.

<h2>Tips
Applikationsfilen ligger på $pwrp_load och har nament

<c>$pwrp_load/ld_appl_'nodename'_'busnumber'.txt 

där nodename är nodens namn och busnumber Qcombusnumret. Om noden är 'mynode' och busnumret
är 507, blir filnamnet

<c> $pwrp_load/ld_appl_mynode_507.txt
</topic>
</headerlevel>
</chapter>

<chapter>
<TOPIC> help command
Wtt kommandon

<b>build      <t>Bygg nod, volym eller objekt	<LINK> build
<b>check classes <t>Kontrollera om några klasser behöver updateras <LINK> check classes
<b>close graph <t>Stäng en Ge graf		<LINK> close graph
<b>compile    <t>Kompilera plcpgm		<LINK> compile
<b>configure card<t>Konfigurera ett kort objekt	<LINK> configure card
<b>connect    <t>Koppla ihop signal med kanal	<LINK> connect
<b>copy       <t>Kopiera utvalt objektsträd 	<LINK> copy
<b>copy object<t>Kopiera ett objekt		<LINK> copy object
<b>create bootfiles <t>Skapa bootfiler		<LINK> create bootfiles
<b>create crossreferencefiles <t>Skapa korsreferens filer		<LINK> create crossreferencefiles
<b>create flowfiles <t>Skapa flowfiler for plc trace	<LINK> create flowfiles
<b>create loadfiles <t>Skapa laddatafier	<LINK> create loadfiles
<b>create object <t>Skapa ett objekt		<LINK> create object
<b>create structfiles <t>Skapa structfiler	<LINK> create structfiles
<b>create volume <t>Skapa en volym		<LINK> create volume
<b>cut		<t>Klipp ut objekt		<LINK> cut
<b>define      	<t>Definiera en symbol		<LINK> define
<b>delete object <t>Ta bort ett objekt		<LINK> delete object
<b>delete tree	<t>Ta bort ett objektsträd	<LINK> delete tree
<b>delete volume<t>Ta bort en volym		<LINK> delete volume
<b>disconnect 	<t>Koppla ifrån signal och kanal <LINK> disconnect
<b>display     <t>Visa ett fönster		<LINK> display
<b>edit        <t>Sätt edit mod			<LINK> edit
<b>exit        <t>Stäng wtt			<LINK> exit
<b>help        <t>Visa hjälp			<LINK> help help
<b>generate web <t>Generera websidor		<LINK> generate web
<b>list channels<t>Lista kanaler		<LINK> list channels
<b>list descriptor<t>Lista från listdescriptor	<LINK> list descriptor
<b>list hierarchy<t>Lista hieraki		<LINK> list hierarchy
<b>list plcpgm <t>Lista plcpgm			<LINK> list plcpgm
<b>list signals<t>Lista signaler		<LINK> list signals
<b>login       <t>Logga in användare		<LINK> login
<b>logout      <t>Logga ut användare		<LINK> logout
<b>move object <t>Flytta ett objekt		<LINK> move object
<b>new buffer  <t>Skapa en ny buffer		<LINK> new buffer
<b>one         <t>Ett fönster			<LINK> one
<b>open buffer <t>Öppna buffer väljar fönstret	<LINK> open buffer
<b>open graph  <t>Öppna en Ge graf		<LINK> open graph
<b>paste       <t>Klistra buffer		<LINK> paste
<b>print      <t>Skriv ut plcpgm		<LINK> print
<b>redraw     <t>Rita om plcpgm			<LINK> redraw
<b>release subwindow <t>Forsätt exekveringen med graf i window objekt <LINK>release subwindow
<b>revert      <t>Backa sessionen		<LINK> revert
<b>save        <t>Spara sessionen		<LINK> save
<b>search      <t>Sök	 			<LINK> search
<b>set advanceduser<t>Sätt avancerad användare	<LINK> set advanceduser
<b>set alltoplevel<t>Visa alla topnivå objekt   <LINK> set alltoplevel
<b>set attribute<t>Sätt objekt attribut 	<LINK> set attribute
<b>set db      <t>Sätt databas 			<LINK> set db
<b>set inputfocus<t>Sätt inmatings fokus till fönster 	<LINK> set inputfocus
<b>set showalias<t>Visa alias namn 		<LINK> set showalias
<b>set showattrref<t>Visa attribut refrenser <LINK> set showattrref
<b>set showattrxref<t>Visa attribut x-referenser <LINK> set showattrxref
<b>set showclass<t>Visa objektsklassen 	<LINK> set showclass
<b>set showdescription<t>Visa beskrivning	<LINK> set showdescription
<b>set showobjref<t>Visa objekt referenser 	<LINK> set showobjref
<b>set showobjxref<t>Visa objekt x-referenser <LINK> set showobjxref
<b>set subwindow <t>Öppna en graph i ett window objekt <LINK>set subwindow
<b>set template<t>Sätt templatevärden på objekt <LINK> set template
<b>set verify  <t>Verifiera script	 	<LINK> set verify
<b>set window  <t>Sätt fönsterstorlek	 	<LINK> set window
<b>setup       <t>Wtt setup			<LINK> setup
<b>show children<t>Visa ett objekts barn	<LINK> show children
<b>show license  <t>Visa licensvillkor		<LINK> show license
<b>show object  <t>Visa ett objekt		<LINK> show object
<b>show objid  <t>Visa objektidentiteten	<LINK> show objid
<b>show script <t>Visa script filer		<LINK> show script
<b>show symbol <t>Visa en symbol		<LINK> show symbol
<b>show user   <t>Visa nuvarande användare	<LINK> show user
<b>show version<t>Visa wtt version		<LINK> show version
<b>show volumes<t>Visa alla volymer i arbetsbänken <LINK> show volumes
<b>sort       <t>Sortera barnen till ett objekt <LINK> sort
<b>two         <t>Två fönster			<LINK> two
<b>update classes <t>Uppdatera klasser		<LINK> update classes
<b>wb dump    <t>Dumpa objekt i en textfil	<LINK> wb dump
<b>wb load    <t>Ladda objekt från textfil	<LINK> wb load

<b>Symboler <link> symbol

<H2>Närliggande ämnen
script <LINK> script
</TOPIC>	

<TOPIC> build <style> function
Kommando   build

Anropa byggmetoden för en node, en volym eller ett objekt.

<B>wtt> build node /name= [/force][/debug][/manual][/crossreference]
<B>wtt> build volume /name= [/force][/debug][/manual][/crossreference]
<B>wtt> build object /name= [/force][/debug][/manual][/crossreference]

/name	<t>Nodnamn, volymsnamn eller objektsnamn.
/force  <t>Kontrollera inga beroenden, bygg allt.
/debug  <t>Bygg med debug, dvs kompilera och länka med debug.
/manual <t>Bygg endast specificerad enhet.
/crossreferences <t>Skapa korsreferensfiler. Giltig för byggande av volymer.

</TOPIC>

<TOPIC> check classes <style> function
Kommando   check classes

Kontrollera om några klasser behöver updateras.

<B>wtt> check classes

</TOPIC>

<TOPIC> close graph <style> function
Kommando   close graph

Stäng en Ge graf.

<B>wtt> close graph /file=

/file	<t>Namn på Ge grafen.
</TOPIC>

<TOPIC> compile <style> function
Kommando   compile

Kompilera plcprogram.

Om ingen hierarki, plcpgm eller window anges, kompileras det utvalda
plcpgm'et.

<B>wtt> compile [/debug]
<B>wtt> compile /plcpgm= [/debug]
<B>wtt> compile /window= [/debug]
<B>wtt> compile /hierarchy= [/debug][/modified][/from_plcpgm=]
<B>wtt> compile /volume= [/debug][/modified][/from_plcpgm=]
<B>wtt> compile /allvolumes [/debug][/modified][/from_plcpgm=]

/plcpgm		<t>Namn på ett plcpgm objekt som ska kompileras.
/window		<t>Namn på ett plcfönster som ska kompileras.
/hierarchy	<t>Alla plcpgm in den här hierakin kommer att kompileras.
/volume		<t>Volymsnamn. Alla plcpgm i volymen kommer att kompileras.
/allvolumes	<t>Alla plcpgm i alla volymer i arbetsbänken kommer att kompileras.
/debug		<t>Kompilera med debug.
/modified	<t>Kompilera enbart modifierade plcfönster.
</TOPIC>

<TOPIC> configure card <style> function
Kommando   configure card

Skapa ett kort med kanaler.

<B>wtt> configure card /rack= /cardname= /channelname= /chanidentity=
<B>		<t>/chandescription= /table=

/rack		<t>Namn på det rackobjekt som kortet ska tillhöra.

/cardname	<t>Namn på kortet. Sista namnledet.

/channelname	<t>Namn på en kanal. Sista namnledet.
		<t>Ett '#' kommer att bytas ut mot kanalnumret.
		<t>T ex /chan=di33## kommer att ge kanalnamnen
		<t>di3301, di3302... Om det är fler än en kanal.
		<t>channelname måste innehålla ett '#' tecken.

/chanidentity	<t>Kanalens identitet. Läggs in i Identity attributet
		<t>för kanalen.

/chandescripton	<t>Kanal beskrivning. Läggs in i Descripton attributet
		<t>för kanalen.
</TOPIC>

<TOPIC> connect <style> function
Kommando   connect

Kopplar ihop en signal med en kanal.

<B>wtt> connect /source= /destination= [/reconnect]

/source		<t>Ett signal eller kanalobjekt.
/destination	<t>Ett signal eller kanalobjekt.
/reconnect	<t>Om source eller destination redan är kopplade
		<t>kommer de först att ta ner kopplingen.
</TOPIC>

<TOPIC> copy <style> function
Kommando   copy

Kopiera utvalda objektträd till en paste buffer.

<B>wtt> copy [/keepreferences]

/keepreferences	<t>Behåll objektsreferenser till objekt utanför det
                <t>kopierade trädet. Som default kommer dessa att nollställas.
/ignore_errors  <t>Slutför kopieringen trots upptäckta fel.
</TOPIC>

<TOPIC> copy object <style> function
Kommando   copy object

Kopiera ett objekt eller ett objeksträd.

<B>wtt> copy object /source= /destination= /name= [/hierarchy]
<B>		<t>[/first] [/last] [/after] [/before]

/source		<t>Objektet som ska kopieras.
/destination	<t>Förälder eller syskon till det skapade objektet.
/name		<t>Namn på det skapade objektet. Sista namnledet.
/hierarchy	<t>Om käll-objektet har barn, kommer även barnträdet
		<t>att kopieras.
/first		<t>Objektet kommer att läggas in som första barn till
		<t>destinations objektet.
/last		<t>Objektet kommer att läggas in som sista barn till
		<t>destinations objektet.
/after		<t>Objektet kommer att läggas in som syskon efter
		<t>destinations objektet.
/before		<t>Objektet kommer att läggas in som syskon före
		<t>destinations objektet.
</TOPIC>

<TOPIC> create bootfiles <style> function
Kommando   create bootfiles

Skapa en ny bootfil.

<B>wtt> create bootfiles /nodeconfig= [/debug]
<B>wtt> create bootfiles /allnodes [/debug]

/nodeconfig	<t>Namn på NodeConfig-objektet för de nod
		<t>som en bootfil ska skapas för.

/all		<t>Skapa bootfiler för alla noder i projektet.

/debug		<t>Länka plcprogram med debug.
</TOPIC>

<TOPIC> create crossreferencefiles <style> function
Kommando   create crossreferencefiles

Skapa filer för att visa korsreferenser i xtt och rtt för aktuell volym.

<B>wtt> create crossreferencefiles
</TOPIC>

<TOPIC> create flowfiles <style> function
Kommando   create flowfiles

Skapa flowfiler för plc trace.
Plc programmens layout lagras i flowfiler och används i plc trace.

<B>wtt> create flowfiles /plcpgm=
<B>wtt> create flowfiles /hier=
<B>wtt> create flowfiles /all

Kommando för att skapa flowfiler från template plcpgm i en klassvolym
<B>wtt> create flowfiles /template/plcpgm=
<B>wtt> create flowfiles /template/hier=Class

/all		<t>Skapa flowfiler för all plcprogram i volymen.
                <t>(kan inte användas i en klassvolym, använd /hier=Class istället).
/plcpgm		<t>Skapa flowfiler för specificerat PlcPgm objekt.
/hierarchy      <t>Skapa flowfiler för alla PlcPgm under specificerad hieraki.
/template	<t>Skapa flowfiler för PlcTemplate program i en klassvolym.
</TOPIC>

<TOPIC> create loadfiles <style> function
Kommando   create loadfiles

Skapa laddatafiler för en volym.

<B>wtt> create loadfile /volume=
<B>wtt> create loadfile [/class] [/all]

/volume		<t>Skapa laddatafil för angiven volym.

/all		<t>Skapa laddatafiler för alla rot- och sub-volymer
		<t>i arbetsbänken.

/class		<t>Skapa laddatafiler för alla classvolymer i arbetsbänken.
</TOPIC>

<TOPIC> create object <style> function
Kommando   create object

Skapa ett objekt.

<B>wtt> create object /destination= /name= /class= 
<B>		<t>[/first] [/last] [/after] [/before]

/destination	<t>Destinationen för det nya objektet. Det nya objektet
		<t>kommer att bli barn eller syskon till destinations objektet.

/name		<t>Namn på det nya objektet. Sista namnledet.

/class		<t>Klass på det nya objektet.

/first		<t>Objektet kommer att läggas in som första barn till
		<t>destinations objektet.

/last		<t>Objektet kommer att läggas in som sista barn till
		<t>destinations objektet.

/after		<t>Objektet kommer att läggas in som syskon efter
		<t>destinations objektet.

/before		<t>Objektet kommer att läggas in som syskon före
		<t>destinations objektet.

</TOPIC>

<TOPIC> create structfiles <style> function
Kommando   create structfiles

Skapa c include filer för klasser i en klassvolym.

<B>wtt> create structfiles [/files=]

/files		<t>Namn på wb_load filen.
</TOPIC>

<TOPIC> cut <style> function
Kommando   cut

Kopiera utvalda objektträd till en paste buffer, och ta bort objekten
ur aktuell volym.

<B>wtt> cut [/keepreferences]

/keepreferences	<t>Behåll objektsreferenser till objekt utanför det
                <t>kopierade trädet. Som default kommer dessa att nollställas.
</TOPIC>

<TOPIC> define <style> function
Kommando define

Definiera en symbol.

<B>wtt> define 'symbolname' 'text'

<h2>närliggand ämnen
symbol <LINK> symbol
show symbol <LINK> show symbol
symbolfile <LINK> configurator_refman,symbol_file
</TOPIC>	

<TOPIC> delete object <style> function
Kommando   delete object

Ta bort ett objekt.

<B>wtt> delete object /name= [/noconfirm] [/nolog]

/name		<t>Namn på objektet.
/noconfirm	<t>Ta bort utan verifikation.
/nolog		<t>Operationen kommer inte att loggas.
</TOPIC>

<TOPIC> delete tree <style> function
Kommando   delete tree

Ta bort ett objektsträd.

<B>wtt> delete tree /name= [/noconfirm] [/nolog]

/name		<t>Rot objektet för trädet.
/noconfirm	<t>Ta bort utan verifikation.
/nolog		<t>Operationen kommer inte att loggas.
</TOPIC>

<TOPIC> disconnect <style> function
Kommando   disconnect

Ta ner kopplingen för en signal eller kanal.

<B>wtt> disconnect /source=

/source		<t>Ett singal eller kanal objekt.
</TOPIC>

<TOPIC> display <style> function
Kommando   display

Visa anläggnings eller nod hierarkin i fönster (w1 eller w2).

<B>wtt> display w1
<B>wtt> display w2
</TOPIC>

<TOPIC> edit <style> function
Kommando   edit

Starta eller lämna editerings mod.

<B>wtt> edit
<B>wtt> noedit
</TOPIC>

<TOPIC> exit <style> function
Kommando   exit

Close wtt.

<B>wtt> exit
</TOPIC>

<TOPIC> help help <style> function
Kommando   help

Visa hjälp information för ämnet.
Hjälp informationen söks efter i en hjälpfil. Filen kan vara
bas-hjälpfilen, projekt-hjälpfilen eller en annan hjälpfil.

Om ingen hjälpfil anges kommer ämnet att eftersökas i
bas och projekt hjälpfilerna.

<B>wtt> help 'subject'
<B>wtt> help 'subject' /helpfile=

/helpfile<t>En hjälpfil som innehåller information om ämnet.

<H2>närliggande ämnen
helpfile <LINK> helpfile
</TOPIC>

<TOPIC> generate web <style> function
Kommando   generate web

Generera html-filer för websidor konfiguerarde med Web-objekt i
nodhierarkin för aktuell volym.

<B>wtt> generate web
</TOPIC>

<TOPIC> list <style> function
Kommando   list

Skriv ut en lista på objekt och attribut.

Listan kommer att skickas till en skrivarkö specificerad av
symbolen PWR_FOE_PRINT.

<B>wtt> list descriptor /descriptor=		<link> list descriptor
<B>wtt> list channels [/node=]			<link> list channels
<B>wtt> list signals [/hierarchy=]		<link> list signals
<B>wtt> list plcpgm [/plcpgm=] [/hierarchy=]	<link> list plcpgm
<B>wtt> list hierarchy [/hierarchy=]		<link> list hierarchy
</TOPIC>

<TOPIC> list channels <style> function
Kommando   list channels

Lista kort och kanaler.

<B>wtt> list channels [/node=] [/volume=] [/allvolumes] [output=]

/node		<t>$Node objekt.
/volume		<t>Lista objekt i angiven volym.
/allvolume	<t>List objekt i alla volymer.
/output		<t>Filnamn för utskrift på fil. Om ett filnamn anges kommer listan 
		<t>inte att skickas till en printer.
</TOPIC>

<TOPIC> list descriptor <style> function
Kommando   list descriptor

Skriver ut en lista beskriven av ett ListDescriptor objekt.

<B>wtt> list descriptor /descriptor=		<link> list descriptor

/descriptor	<t>ListDescriptor object.
</TOPIC>

<TOPIC> list hierarchy <style> function
Kommando   list hierarchy

Lista PlantHier och NodeHier objekt.

<B>wtt> list hierarchy [/hierarchy=] [/volume=] [/allvolumes] [output=]

/hierarchy	<t>Hierarki objekt.
/volume		<t>Lista objekt i angiven volym.
/allvolume	<t>List objekt i alla volymer.
/output		<t>Filnamn för utskrift på fil. Om ett filnamn anges kommer listan 
		<t>inte att skickas till en printer.
</TOPIC>

<TOPIC> list plcpgm <style> function
Kommando   list plcpgm

Lista PlcPgm objekt.

<B>wtt> list plcpgm [/hierarchy=] [plcpgm=] [/volume=] [/allvolumes] [output=]

/plcpgm		<t>Plcpgm objekt.
/hierarchy	<t>Hierarki objekt.
/volume		<t>Lista objekt i angiven volym.
/allvolume	<t>List objekt i alla volymer.
/output		<t>Filnamn för utskrift på fil. Om ett filnamn anges kommer listan 
		<t>inte att skickas till en printer.
</TOPIC>

<TOPIC> list signals <style> function
Kommando   list signals

Lista signaler och korsreferenser för signalerna.

<B>wtt> list signals [/hierarchy=] [/volume=] [/allvolumes] [output=]

/hierarchy	<t>Hierarki objekt.
/volume		<t>Lista objekt i angiven volym.
/allvolume	<t>List objekt i alla volymer.
/output		<t>Filnamn för utskrift på fil. Om ett filnamn anges kommer listan 
		<t>inte att skickas till en printer.
</TOPIC>

<TOPIC> login <style> function
Kommando   login

Logga in med användarnamn och passerord. Användarens privilegier kommer
att hämtas ur användardatabasen, och påverka tillgången till systemet.

<B>wtt> login 'username' 'password'

Om man vill skapa eller modifiera projekt, användare eller registrera
volymer loggar man in som administratör med kvalifieraren /administrator.
Här måste man ange en användare i systemgruppen 'administrator'. Om denna
systemgrupp ej finns, kan användarnamn och passerord utelämnas.

<B>wtt> login /administrator 'username' 'password'


<H2>närliggande ämnen
logout <LINK> logout
show user <LINK> show user
</TOPIC>

<TOPIC> logout <style> function
Kommando   logout

Logga ut en användare, och återgå till den ursprungliga användaren.

<B>wtt> logout

<H2>närliggande ämnen
login <LINK> login
</TOPIC>

<TOPIC> move object <style> function
Kommando   move object

Flytta eller byt namn på ett objekt.

<B>wtt> move object /source= /destination= [/rename=] [/first] [/last] [/after] [/before]
<B>wtt> move object /source= /rename=

/source		<t>Namn på objektet som ska flyttas.
/destination	<t>Förälder eller syskon objekt efter förflyttningen.
/rename		<t>Nytt objektnamn, om namnet ska ändras.
		<t>Sista namnledet. Om ingen destination anget kommer enbart
		<t>namnet att ändras, objektet flyttas inte.
/first		<t>Objektet kommer att läggas in som första barn till
		<t>destinations objektet.
/last		<t>Objektet kommer att läggas in som sista barn till
		<t>destinations objektet.
/after		<t>Objektet kommer att läggas in som syskon efter
		<t>destinations objektet.
/before		<t>Objektet kommer att läggas in som syskon före
		<t>destinations objektet.
</TOPIC>

<TOPIC> new buffer <style> function
Kommando   new buffer

Skapa en ny tom buffer.

<B>wtt> new buffer /name=

/name		<t>Namn på bufferten.
</TOPIC>

<TOPIC> one <style> function
Kommando   one

Visa ett fönster. Fönstret som för närvarande har inmatnings 
fokus behålls.

<B>wtt> one
</TOPIC>

<TOPIC> open buffer <style> function
Kommando   open buffer

Öppna fönstret för att välja buffer.

<B>wtt> open buffer
</TOPIC>

<TOPIC> open graph <style> function
Kommando   open graph

Öppna en Ge graf.
I modal mod, fortsätter inte exekveringen av skriptet förrän
grafen stängs.

<B>wtt> open graph /file= /modal

/file	<t>Namn Ge grafen.
/modal  <t>Modal mod.
</TOPIC>

<TOPIC> paste <style> function
Kommando   paste

Klistra in objekt från den senaste copy or cut operationen, i den
nuvarande volymen. Med buffer möjligheten kan en äldre buffer klistras
in.

<B>wtt> paste [/keepoid] [/buffer=]

/keepoid	<t>Behåll objektsidentiteter om det är möjligt.
/buffer		<t>Namn på den buffer som ska klistras in. Som default
		<t>används den senaste bufferten.
/into		<t>Lägg rotobjekten i pastebufferten som barn till
                <t>utvalt objekt.
/toplevel       <t>Lägg rotobjekten i pastebufferten på topnivån. Måste
                <t>användas för att kopiera till en tom volym.
</TOPIC>

<TOPIC> print <style> function
Kommando   print

Skriv ut plc dokument.

<B>wtt> print /plcpgm= [/nodocument] [/nooverview]
<B>wtt> print /hierarchy= [/nodocument] [/nooverview]

/plcpgm		<t>Skriv ut dokument i ett plcpgm.
/hierarchy	<t>Ett hierarki objekt. Alla plc i hierarkin kommer
		<t>att skrivas ut.
/nodocument	<t>Plc dokumentet skrivs ej ut.
/nooverview	<t>Översikten över plc-fönstret skrivs ej ut.
</TOPIC>

<TOPIC> release subwindow <style> function
Kommando   release subwindow

Släpp loss exekveringen av ett skript som öppnat en graf
i ett window objekt med kommandot 'set subwindow' eller
funktionen 'SetSubwindow' i modal mod.
Release kommandot exekveras från en trycknapp i bilden med
actiontyp command.

<B>wtt> release subwindow 'graph'

graph	<t>Namnet på huvud grafen.
</TOPIC>

<TOPIC> revert <style> function
Kommando   revert

Revertera sessionen.

<B>wtt> revert
</TOPIC>

<TOPIC> save <style> function
Kommando   save

Spara sessionen.

<B>wtt> save
</TOPIC>

<TOPIC> search <style> function
Kommando   search

Leta efter ett objektsnamn eller en sträng.

<B>wtt> search 'object'
<B>wtt> search /regularexpression 'expression'
<B>wtt> search /next
</TOPIC>

<TOPIC> set advanceduser <style> function
Kommando   set advanceduser

Sätta eller återställa 'advanced user'.

<B>wtt> set advanceduser
<B>wtt> set noadvanceduser

<H2>närliggande ämnen
advanced user <LINK> advanced user
</TOPIC>

<TOPIC> set alltoplevel <style> function
Kommando   set alltoplevel

Visa alla rotobjekt i databasen, inte enbart de som är
definierade för anläggnings resp node hierarkin.

<B>wtt> set alltoplevel
<B>wtt> set noalltoplevel

</TOPIC>

<TOPIC> set attribute <style> function
Kommando   set attribute

Sätt ett värde på ett attribut.
Objekt väljs med name, class och hierarchy kvalifierarna.

<B>wtt> set attribute /attribute= [/value=] [/name=] [/class=] [/hierarchy=]
<B>		<t>[/noconfirm] [/nolog] [/output] [/noterminal]

/attribute	<t>Namn på attributet.
/value		<t>Värde som ska läggas in i attributet. Om inget värde
		<t>är angivet kommer en fråga för varje attribut.
/class		<t>Välj objekt av den här klassen.
/hierarchy	<t>Endast avkomlingar till det här objektet kommer att väljas.
/noconfirm	<t>Ställ ingen verifikations fråga.
/nolog		<t>Operationen loggas inte.
/output		<t>Ut fil.
/noterminal	<t>Operationen loggas inte i terminal fönster.
</TOPIC>

<TOPIC> set db <style> function
Kommando   set db

Koppla upp till databasen med angivet id.
Detta har ingen effekt om man redan har öppnat en databas.

<B>wtt> set db /dbid=

/dbid	<t>Databas identitet.
</TOPIC>

<TOPIC> set inputfocus <style> function
Kommando   set inputfocus

Sätt inmatnings fokus till anläggnings eller nod hierarki fönstret 
(w1 eller w2).

<B>wtt> set inputfocus w1
<B>wtt> set inputfocus w2
</TOPIC>

<TOPIC> set showalias <style> function
Kommando   set showalias

Visa aliasnamnet för objekt i anläggnings och nod hierakin.

<B>wtt> set showalias
<B>wtt> set noshowalias
</TOPIC>

<TOPIC> set showattrref <style> function
Kommando   set showattrref

Visa antal kopplade attribut referenser för objekt
i anläggnings och nod hierarkin.

<B>wtt> set showattrref
<B>wtt> set noshowattrref
</TOPIC>

<TOPIC> set showattrxref <style> function
Kommando   set showattrxref

Vissa antalet kopplade attribut x-referenser för objekt
in anläggnings och nod hierarkin.

<B>wtt> set showattrxref
<B>wtt> set noshowattrxref
</TOPIC>

<TOPIC> set showclass <style> function
Kommando   set showclass

Visa klasstillhörighet för objekt i anläggnings och nod hierarkin.

<B>wtt> set showclass
<B>wtt> set noshowclass
</TOPIC>

<TOPIC> set showdescription <style> function
Kommando   set showdescription

Visa beskrivning för objekt i anläggnings och nod hierarkin.

<B>wtt> set showdescription
<B>wtt> set noshowdescription
</TOPIC>

<TOPIC> set showobjref <style> function
Kommando   set showobjref

Visa antalet kopplade objektreferenser för objekt i anläggnings och
nod hierarkin.

<B>wtt> set showobjref
<B>wtt> set noshowobjref
</TOPIC>

<TOPIC> set showobjxref <style> function
Kommando   set showobjxref

Visa antalet kopplade objekt x-referenser för objekt i anläggnings och
nod hierarkin.

<B>wtt> set showobjxref
<B>wtt> set noshowobjxref
</TOPIC>

<TOPIC> set subwindow <style> function
Kommando   set subwindow

Öppna en graf i ett window objekt i en tidigare öppnad graf.

<B>wtt> set subwindow 'graph' /name= /source=

/name	<t>Namn på window objektet.
/source	<t>Namn på grafen som ska öppnas i window objektet.
</TOPIC>

<TOPIC> set template <style> function
Kommando   set template

Föråldrad sen V4.0.
</TOPIC>

<TOPIC> set verify <style> function
Kommando   set verify

Visa alla exekverade rader när ett script körs.

<B>wtt> set verify
<B>wtt> set noverify
</TOPIC>

<TOPIC> set window <style> function
Kommando   set window

Set fönsterbredd och höjd.

<B>wtt> set window /width= /height=

/width	<t>bredd i pixel.
/height <t>höjd i pixel.
</TOPIC>

<TOPIC> set volume <style> function
Kommando   set volume

set volume är obsolet.
</TOPIC>

<TOPIC> setup <style> function
Wtt setup
Setup av wtt egenskaper

DefaultDirectory<t><t>Default filkatalog för script filer.
SymbolFilename	<t><t>Symbolfil.		<LINK> configurator_refman,symbol_file
Verify		<t><t>Verifiera exekvering av script.
AdvancedUser	<t><t>Användaren är avancerad. <LINK> advanced user
AllToplevel	<t><t>Visa samtliga topnivå objekt.
Bypass		<t><t>Förbigå vissa editerings restriktioner.
</TOPIC>

<TOPIC> show children <style> function
Kommando   show children

Visa ett objekt och dess barn.

<B>wtt> show children /name=

/name	<t>Förälder objektets namn.
</TOPIC>

<TOPIC> show license <style> function
Kommando   show license

Visa licensvillkor.

<B>wtt> show license
</TOPIC>

<TOPIC> show object <style> function
Kommando   show object

Lista objekt.

<B>wtt> show object [/name=] [/hierarchy=] [/class=] [/volume=] [/allvolumes]
<B>		<t>[/parameter=] [/full] [/output=] [/noterminal]
<B>wtt> show object /objid=

/name		<t>Objektsnamn. Wildcard kan användas.
/hierarchy	<t>Hierarki objekt. Endast objekt i hierarkin kommer att
		<t>väljas.
/class		<t>Endast objekt av angiven klass kommer att väljas.
/volume		<t>Namn på volymen.
/allvolumes	<t>Sökning av objekt kommer att ske i alla volymer.
/parameter	<t>Lista värdet på ett attribut för valda objekt.
/full		<t>Visa innehållet för objekten. Attribut som skiljer sig
		<t>från template värdet kommer att listas.
/output		<t>Ut fil.
/noterminal	<t>Resultatet kommer inte att skrivas i terminalfönstret.
/objid		<t>Visa objekt med specificerad objektsidentitet.
</TOPIC>

<TOPIC> show objid <style> function
Kommando   show objid

Visa objektsidentitet för ett objekt.
Om /name utelämnas, visas identiteten för det utvalda objektet.

<B>wtt> show objid [/name=]

/name	<t>Objektsnamn.
</TOPIC>

<TOPIC> show script <style> function
Kommando   show script

Visar en lista på script-filer.
Wildcard med asterisk (*) kan användas för att ange filer.

<B>wtt> show script ['scriptspec']

</TOPIC>

<TOPIC> show symbol <style> function
Kommando   show symbol

Visa en symbol, eller alla symboler.

<B>wtt> show symbol 'symbol'<t>Visa symbol 'symbol'
<B>wtt> show symbol         <t>Visa alla symboler

<h2>närliggande ämnen
define <LINK> define
symbol <LINK> symbol
</TOPIC>

<TOPIC> show version <style> function
Kommando   show version

Visa wtt version.

<B>wtt> show version
</TOPIC>

<TOPIC> show volumes <style> function
Kommando   show volumes

Visa alla volymer i arbetsbänken.

<B>wtt> show volumes
</TOPIC>

<TOPIC> sort <style> function
Kommando   sort

Sortera barnen til ett objekt i alfabetisk ordning, eller i klassordning.
Om ingen 'parent' anges kommer barnen till utvalt objekt att sorteras.

<B>wtt> sort /parent= [/class] [/signals]

/parent		<t>Förälder till de objekt som ska sorteras.
/class		<t>Sortera i klass ordning.
/signals	<t>Sortera signaler och plcpgm i klassordning, och
		<t>andra objekt i alfabetisk ordning.
</TOPIC>

<TOPIC> two <style> function
Kommando   two

Visa två fönster. Både anläggnings och nod hierarki fönsterna visas.

<B>wtt> two
</TOPIC>

<TOPIC> update classes <style> function
Kommando   update classes

Updatera klasserna i aktuell volym.

<B>wtt> update classes

</TOPIC>

<TOPIC> wb dump <style> function
Kommando   wb dump

Dumpa volymen, eller en del av volymen på textfil.

<B>wtt> wb dump /output= [/hierarchy=]

/hierarchy	<t>Hierarki objekt. Objektet och dess barnträd kommer
		<t>att dumpas på textfil.
/output		<t>Utfil.
/nofocode       <t>Skriv inte plc kod för funktionsobjekt med template
                <t>kod. Reducerar storleken på dumpfilen. Ny kod kommer
                <t>att kopieras när plc't kompileras.
/keepname       <t>Skriv externa referenser med namn istället för identitet.
/noindex        <t>Skriv inte objektindex i dumpfilen.
</TOPIC>

<TOPIC> wb load <style> function
Kommando   wb load

Ladda databasen från wb_load-fil eller dbs-fil.

<B>wtt> wb load /loadfile=

/loadfile	<t>Filnamn. Kan vara av typ .wb_load, .wb_dmp eller .dbs.
/noindex        <t>Ignorera object index i dumfilen och skapa nya objektsidentiteter.

</TOPIC>

<TOPIC> symbol
Symbol

En wtt symbol kan avändas som ett kort kommando eller som strängsubstitution i ett kommando.
Då symbolen används som strängsubstitution ska symbolnamnet omges av enkelfnuttar.

Symboler skapas med 'define' kommandot. <link> define
Define kommandon kan exekveras av konfiguratörens startupfil. <link> configurator_refman,symbol_file

Exempel på symbol som används som kort kommando.

<c>wtt> define p1 "show child/name=hql-hvk-pumpar-pump1"
<c>wtt> p1

Exempel på symbol som används som sträng substitution

<c>wtt> define p1 hql-hvk-pumpar-StartPump1
<c>wtt> open trace 'p1'

<H2>Närliggande ämnen
define <LINK> define
show symbol <LINK> show symbol
symbolfile <LINK> configurator_refman,symbol_file
</TOPIC>

</chapter>
//
// Script
//

<chapter>
<TOPIC> script
Wtt script

execute script		<LINK> execute script
datatypes		<LINK> datatypes
datatype conversions	<LINK> datatype conversions
variable declarations	<LINK> variable declarations
operators		<LINK> operators
main-endmain		<LINK> main-endmain
function-endfunction	<LINK> function-endfunction
if-else-endif		<LINK> if-else-endif
while-endwhile		<LINK> while-endwhile
for-endfor		<LINK> for-endfor
break			<LINK> break
continue		<LINK> continue
goto			<LINK> goto
include			<LINK> include
printf()		<LINK> printf()
scanf()			<LINK> scanf()
fprintf()		<LINK> fprintf()
fgets()			<LINK> fgets()
fopen()			<LINK> fopen()
fclose()		<LINK> fclose()
exit()			<LINK> exit()
verify()		<LINK> verify()
time()			<LINK> time()
edit()			<LINK> edit()
extract()		<LINK> extract()
element()		<LINK> element()
toupper()		<LINK> toupper()
tolower()		<LINK> tolower()
translate_filename()	<LINK> translate_filename()
wtt-commands		<LINK> wtt-commands
GetAttribute()		<LINK> getattribute()
GetChild()		<LINK> getchild()
GetParent()		<LINK> getparent()
GetNextSibling()	<LINK> getnextsibling()
GetNextVolume()		<LINK> getnextvolume()
GetClassList()		<LINK> getclasslist()
GetNextObject()		<LINK> getnextobject()
GetClassListAttrRef()	<LINK> getclasslistattrref()
GetNextAttrRef()	<LINK> getnextattrref()
GetObjectClass()	<LINK> getobjectclass()
GetNodeObject()		<LINK> getnodeobject()
GetRootList()		<LINK> getrootlist()
GetVolumeClass()	<LINK> getvolumeclass()
GetVolumeList()		<LINK> getvolumelist()
SetAttribute()		<LINK> setattribute()
GetProjectName()	<LINK> getprojectname()  
CheckSystemGroup()	<LINK> checksystemgroup()
CutObjectName()		<LINK> cutobjectname()
MessageError()		<LINK> messageerror()
MessageInfo()		<LINK> messageinfo()
GetCurrentText()	<LINK> getcurrenttext()
GetCurrentObject()	<LINK> getcurrentobject()
GetCurrentVolume()	<LINK> getcurrentvolume()
IsW1()			<LINK> isw1()
IsW2()			<LINK> isw2()
EditMode()		<LINK> editmode()
MessageDialog()		<LINK> messagedialog()
ConfirmDialog()		<LINK> confirmdialog()
ContinueDialog()	<LINK> continuedialog()
PromptDialog()		<LINK> promptdialog()
OpenGraph()		<LINK> opengraph()
CloseGraph()		<LINK> closegraph()
SetSubwindow()		<LINK> setsubwindow()

</TOPIC>

<TOPIC> execute script
Exekvera ett script

En script-fil exekveras från kommando-raden med kommandot

wtt> @'filnamn'

</TOPIC>

<TOPIC> datatypes
Datatyper

Datatyperna är float, int och string.

int	<t>heltals värde.
float	<t>32-bitars flyttals värde.
string	<t>textsträng, 80 tecken lång (null terminerad).

Det finns tre olika tabeller som en variabel kan deklareras i: local, global
och extern. En lokal variabel är känd inom en funktion, en global är känd
i alla funktioner inom en fil, en extern är känd i alla filer som exekveras
i en session.

</TOPIC>

<TOPIC> datatype conversions
Datatyps konvertering

Om ett uttryck består av variabler och funktioner med olika datatyper kommer
variablerna att konverteras med företräde string, float, int. Om två operander
har typerna float och string, eller int och string, kommer resultatet att bli
string. Vid en tilldelning, kommer värdet av ett uttryck att konverteras till
typen för den tilldelade variabeln. Detta gäller även om resultatet är en sträng
och variablerna är av type float och int.

<b>Exempel

<c>string str;
<c>int    i = 35;
<c>str = "Luthor" + i;
The value in str will be "Luthor35".

<c>float   f;
<c>string  str = "3.14";
<c>int     i = 159;
<c>f = str + i;
The value in f will be 3.14159.
</TOPIC>

<TOPIC> variable declarations
Variabel deklarationer

En variabel måste deklareras innan den avänds.
En deklaration består av
- tabellen (global eller extern, om local ska inte tabellen anges)
- datatypen (int, float eller string)
- variabelnamn (känsligt för stora och små bokstäver)
- antal element, om variabeln är en vektor
- likameds tecken följt av initierings värde, om det utelämnas är 
  intitialvärdet 0 eller en null-sträng
- semikolon.

En extern variabel bör tas bort (med delete) när den inte längre används.
<b>Exempel

<c>int             i;
<c>float           flow = 33.4;
<c>string          str = "Hello";
<c>extern int      jakob[20];
<c>global float    ferdinand = 1234;
<c>...
<c>delete jakob[20];
</TOPIC>

<TOPIC> operators
Operatorer

Operatorerna har samma funktion som i c, med vissa begränsningar. Alla
operatorer är inte implementerade. Vissa operatorer (+,=,==) kan även
operera på string variabler. Prioriteten för operatorer är densamma som i c.

Operator	<t>Beskrivning		<t>Datatyper
+		<t>plus			<t>int, float, string
-		<t>minus			<t>int, float
*		<t>multiplikation		<t>int, float
/		<t>division			<t>int, float
++	 	<t>inkrement, postfix only.	<t>int, float
--	 	<t>dekrement, postfix only	<t>int, float
>>	 	<t>bitar höger-skift		<t>int
<<	 	<t>bitar vänster-skift		<t>int
<		<t>mindre än			<t>int, float
>		<t>större än			<t>int, float
<=	 	<t>mindre eller lika med	<t>int, float
>=	 	<t>större eller lika med	<t>int, float
==	 	<t>lika med			<t>int, float, string
!=	 	<t>ej lika med			<t>int, float, string
&		<t>bitvis och			<t>int
|		<t>bitvis eller			<t>int
&&	 	<t>logisk och			<t>int
||	 	<t>logisk eller			<t>int
!		<t>logisk not			<t>int
=		<t>tilldelning			<t>int, float, string
+=	 	<t>addera och tilldela		<t>int, float
-=	 	<t>minus och tilldela		<t>int, float
&=	 	<t>logisk och och tilldelning	<t>int
|=	 	<t>logisk eller och tilldelning	<t>int
</TOPIC>

<TOPIC> main-endmain <style> function
main-endmain

main och endmain satserna kontrollerar var exekveringen börjar och slutar.
Om det inte finns några main och endmain satser, startar exekveringen i
början på filen, och slutar i slutet på filen.

<b>Exempel

<c>main()
<c>  int a;

<c>  a = p1 + 5;
<c>  printf( "a = %d", a);
<c>endmain
</TOPIC>

<TOPIC> function-endfunction <style> function
function-endfunction

En funktions deklaration består av
- datatypen för funktionens retur värde
- namnet på funktionen
- en argumentlista separerade med kommatecken och omgiven av parenteser.
  Argumentlistan innehåller typdeklaration och namn på varje argument.

Argumenten som skickas med vid anropet kommer att konverteras till den typ
som är deklarerad i argumentlistan. Om ett argument ändrar värde inne i 
funktionen, kommer det nya värdet att överföras till anroparen. På detta
sätt blir de möjlig att returnera andra värden än retur värdet för funktionen.
En funktion kan innehålla en eller flera return statser. Return satsen kommer
att flytta över exekveringen till anroparen och returnera det angivna värdet.

<b>Exempel

<c>function float calculate_flow(float a, float b)
<c>  float c;
<c>  c = a + b;
<c>  return c;
<c>endfunction

<c>...
<c>flow = korr * calculate_flow( v, 35.2);
</TOPIC>

<TOPIC> if-else-endif <style> function
if-else-endif

Raderna mellan en if-endif stats exekveras om uttrycket i if-statsen är sant.
Uttrycket ska omges av parenteser. Om en else sats hittas mellan if och endif,
kommer raderna mellan else och endif att exekveras när uttrycket är falskt.

<b>Exempel

<c>if ( i < 10 && i > 5)
<c>  a = b + c;
<c>endif

<c>if ( i < 10)
<c>  a = b + c;
<c>else
<c>  a = b - c;
<c>endif
</TOPIC>

<TOPIC> while-endwhile <style> function
while-endwhile

Raderna mellan en while-endwhile sats exekveras så länge uttrycket i
while-satsen är sant. Uttrycket ska omges av parentser.

<b>Exempel

<c>while ( i < 10)
<c>  i++;
<c>endwhile
</TOPIC>

<TOPIC> for-endfor <style> function
for-endfor

Raderna mellan en for-endfor sats exekveras så länge mitten-uttrycket i 
for-satsen är sant. for-satsen består av tre uttryck, avgränsade med semicolon
och omgivna av parenteser. Det första uttrycket exekveras före den första
loopen, det tredje exekveras efter varje loop, och det i mittne exekveras
före varje loop, och om det är sant, gör ytterligare ett varv, annars lämnas
loopen.

<b>Exempel

<c>for ( i = 0; i < 10; i++)
<c>  a += b;
<c>endfor
</TOPIC>

<TOPIC> break <style> function
break

En break sats kommer att söka efter nästa endwhile eller endfor sats
och försätta exekveringen på raden efter denna.

<b>Exempel

<c>for ( i = 0; i < 10; i++)
<c>  a += b;
<c>  if ( a > 100)
<c>    break;
<c>endfor
</TOPIC>

<TOPIC> continue <style> function
continue

En continue sats kommera att söka efter närmast föregående while eller
for sats och forsätta att utföra loopen.

<b>Exempel

<c>for ( i = 0; i < 10; i++)
<c>  b = my_function(i);
<c>  if ( b > 100)
<c>    continue;
<c>  a += b;
<c>endfor
</TOPIC>

<TOPIC> goto <style> function
goto

En goto sats orsakar ett hopp i exekveringen till en rad som är
definierad med en label. Label raden avslutas med ett kolon.

<b>Exempel

<c>  b = attribute("MOTOR-ON.ActualValue", sts);
<c>  if (!sts)
<c>    goto some_error; 
<c>  ...
<c>some_error:
<c>  say("Something went wrong!");
</TOPIC>

<TOPIC> include <style> function
include

En script include-fil xom innehåller funktioner kan inkluderas med
#include satsen. Default filtyp för filen är '.pwr_com'.

<b>Exempel

<c>#include <my_functions>
</TOPIC>

<TOPIC> printf() <style> function
printf()

int printf( string format [, (arbitrary type) arg1, (arbitrary type) arg2])

<b>Beskrivning

Formaterad utskrift. C-syntax. Format argument och inget, ett eller två
värde argument. 
Returnerar antal utskrivna tecken.

<b>Argument

string 			<t>format	<t>Format.
godtycklig typ		<t>arg1		<t>Värde argument. Valfritt, Kan vara int,
			<t>		<t>float eller string.
godtycklig typ		<t>arg2		<t>Värde argument. Valfritt. Kan vara int,
			<t>		<t>float eller string.

<b>Exempel

<c>  printf( "Watch out!");
<c>  printf( "a = %d", a);
<c>  printf( "a = %d och str = %s", a, str);
</TOPIC>

<TOPIC> scanf() <style> function
scanf()

int scanf( string format , (godtycklig typ) arg1)

<b>Beskrivning

Formaterad inmatning. C-syntax.
Returnerar antal inlästa tecken.

<b>Argument

string 			<t>format	<t>Format.
godtycklig typ		<t>arg1		<t>Värde argument. Returnerat. Kan vara int,
			<t>		<t>float eller string.

<b>Exempel

<c>  scanf( "%d", i);
</TOPIC>

<TOPIC> fprintf() <style> function
fprintf()

int fprintf( int file, string format [, (godtycklig typ) arg1,
	(godtycklig typ) arg2])

<b>Beskrivning

Formaterad utskrift på fil. C-syntax. Format argument och inget, ett eller två
värde argument.
Returnerarn antal utskrivna tecken.

<b>Argument

int 			<t>file		<t>Fil id returnerat av fopen.
string 			<t>format	<t>Format.
godtycklig typ		<t>arg1		<t>Värde argument. Valfritt. Kan vara int,
			<t>		<t>float eller string.
godtycklig typ		<t>arg2		<t>Värde argument. Valfritt. Kan vara int,
			<t>		<t>float eller string.

<b>Exempel

<c>  int outfile;
<c>  outfile = fopen( "my_file.txt", "w");
<c>  if (!outfile)
<c>    exit();
<c>  fprintf( outfile, "Some text");
<c>  fprintf( outfile, "a = %d", a);
<c>  fclose( outfile);
</TOPIC>

<TOPIC> fgets() <style> function
fgets()

int fgets( string str, int file)

<b>Beskrivning

Läser en rad från en angiven fil.
Returnerar noll vid filslut.

<b>Argument

string 		<t>str		<t>Läst rad. Returnerad. 
int		<t>file		<t>Fil id returnerad av fopen.

<b>Exempel

<c>  file = fopen("some_file.txt","r");
<c>  while( fgets( str, file))
<c>    say( str);
<c>  endwhile
<c>  fclose( file);
</TOPIC>

<TOPIC> fopen() <style> function
fopen()

int fopen( string filespec, string mode)

<b>Beskrivning

Öppnar en fil för att läsa eller skriva.
Returnerar en fil identitet, Om filen inte kunde öppnas, returneras noll.

<b>Argument

string 		<t>filespec	<t>Namn på filen. 
string		<t>mode		<t>Access mod

<b>Exempel

<c>  int infile;
<c>  int outfile;

<c>  infile = fopen("some_file.txt","r");
<c>  outfile = fopen("another_file.txt","w");
<c>  ...
<c>  fclose( infile);
<c>  fclose( outfile);
</TOPIC>

<TOPIC> fclose() <style> function
fclose()

int fclose( int file)

<b>Beskrivning

Stänger en öppnad fil.

<b>Argument

int		<t>file		<t>fil-id returnerad av fopen.

<b>Exempel

<c>  int infile;
<c>  infile = fopen("some_file.txt","r");
<c>  ...
<c>  fclose( infile);
</TOPIC>

<TOPIC> exit() <style> function
exit()

int exit()

<b>Beskrivning

Avslutar exekveringen av en fil.

<b>Exempel

<c>  exit();
</TOPIC>

<TOPIC> verify() <style> function
verify()

int verify( [int mode])

<b>Beskrivning

Sätter eller visar verifikatione mod. Om verifiering är till, visas alla 
exekverade rader på skärmen.
Returnerar nuvarande verifikations mod.

<b>Argument

int		<t>mode		<t>verifikaion till (1) eller från (0). Valfri.

<b>Exempel

<c>  verify(1);
</TOPIC>

<TOPIC> time() <style> function
time()

string time()

<b>Beskrivning

Returnerar nuvarande tid i strängformat.

<b>Exempel

<c>  string t;
<c>  t = time();
</TOPIC>

<TOPIC> edit() <style> function
edit()

string edit( string str)

<b>Beskrivning

Tar bort inledande och avslutande blanktecken och tabbar, och ersätter flera
tabbar och blanktecken med ett blanktecken.
Returnerar den editerade stängen.

<b>Argument

string		<t>str		<t>sträng som ska editeras.

<b>Exempel

<c>  collapsed_str = edit(str);
</TOPIC>

<TOPIC> extract() <style> function
extract()

string extract( int start, int length, string str)

<b>Beskrivning

Extraherar de angivna tecknen från angiven sträng.
Returnerar de extraherade tecknen som en sträng.

<b>Argument

int		<t>start	<t>start positionen för första tecknet.
				<t><t>Första tecknet har position 1.
int		<t>length	<t>antalet tecken som ska extraheras.
string		<t>str		<t>sträng som tecknen ska extraheras från.

<b>Exempel

<c>  extracted_str = extract( 5, 7, str);
</TOPIC>

<TOPIC> element() <style> function
element()

string element( int number, string delimiter, string str)

<b>Beskrivning

Extraherar ett element från et sträng av element.
Returnerar det extraherade elementet.

<b>Argument

int		<t>number	<t>elementets nummer.
string		<t>delimiter	<t>avgränsnings tecken.
string		<t>str		<t>sträng med element.

<b>Exempel

<c>  string str = "mary, lisa, anna, john";
<c>  string elem1;
<c>  elem1 = elment( 1, ",", str);
</TOPIC>

<TOPIC> toupper() <style> function
toupper()

string toupper( string str)

<b>Beskrivning

Konverterar en sträng till stora bokstäver.

<b>Argument

string		<t>str		<t>sträng som ska konverteras.

<b>Returns
string				<t><t>sträng med stora bokstäver.

<b>Exempel

<c>  string str1 = "Buster Wilson";
<c>  string str2;
<c>  str2 = toupper( str);
</TOPIC>

<TOPIC> tolower() <style> function
toupper()

string tolower( string str)

<b>Beskrivning

Konverterar en sträng till små bokstäver.

<b>Argument

string		<t>str		<t>sträng som ska konverteras.

<b>Returns
string				<t><t>sträng med små bokstäver.

<b>Exempel

<c>  string str1 = "Buster Wilson";
<c>  string str2;
<c>  str2 = tolower( str);
</TOPIC>

<TOPIC> translate_filename() <style> function
translate_filename()

string translate_filename( string fname)

<b>Beskrivning

Byter ut omgivnings variabler i ett filnamn.

<b>Argument

string		<t>fname	<t>A filnamn.

<b>Returns
string				<t><t>Sträng med utbytta omgivningsvariabler.

<b>Exempel

<c>  string fname1 = "$pwrp_db/a.wb_load";
<c>  string fname2;
<c>  fname2 = translate_filename( fname1);
</TOPIC>

<TOPIC> wtt-commands <style> function
Wtt kommandon

Alla wtt kommandon finns tillgängliga i script koden. En wtt-kommando rad
ska INTE avslutas med semikolon. Variabler kan substitueras i kommandot
genom add omges av apostrofer.

<b>Exempel
 
<c>  string name = "PUMP-VALVE-Open";
<c>  string value = "The valve is open";
<c>  set attribute/name='name'/attr="Description"/value='value'

<b>Exempel

<c>  string name;
<c>  string parname;
<c>  int j;
<c>  int i;
<c>  for ( i = 0; i < 3; i++)
<c>    parname = "vkv-test-obj" + (i+1);
<c>    create obj/name='parname'
<c>    for ( j = 0; j < 3; j++)
<c>      name = parname + "-obj" + (j+1);
<c>      create obj/name='name'
<c>    endfor
<c>  endfor
</TOPIC>

<TOPIC> getattribute() <style> function
GetAttribute()

(variabel typ) GetAttribute( string name [, int status])

<b>Beskrivning

Hämta värdet för angivet attribut. Typen av det returnerade värdet beror
på typen av attributet. Attributet kommer att konverteras till int, float
eller string.

<b>Argument

string		<t>name		<t>namn på attributet som ska hämtas.
int		<t>status	<t>status för operationen. Returnerad. Om noll
		<t>		<t>kunde inte attributet hämtas. Valfritt.

<b>Exempel

<c>  int alarm;
<c>  int sts;

<c>  alarm = GetAttribute("Roller-Motor-Alarm.ActualValue");
<c>  on = GetAttribute("Roller-Motor-On.ActualValue", sts);
<c>  if ( !sts)
<c>    say("Could not find motor on attribute!");
</TOPIC>

<TOPIC> getchild() <style> function
GetChild()

string GetChild( string name)

<b>Beskrivning

Hämta första barnet till ett objekt. Nästföljande barn kan hämtas med
GetNextSibling().
Returnerar namnet på barnet. Om det inte finns något barn, returneras en
null-sträng.

<b>Argument

string		<t>name		<t>objektets namn.

<b>Exempel

<c>  string child;

<c>  child = GetChild("Roller-Motor");
</TOPIC>

<TOPIC> getparent() <style> function
GetParent()

string GetParent( string name)

<b>Beskrivning

Hämta föräldern till ett objekt.
Returnerar förälderns namn. Om det inte finns någon förälder returneras
en null-sträng.

<b>Argument

string		<t>name		<t>objektets namn.

<b>Exempel

<c>  string parent;

<c>  parent = GetChild("Roller-Motor");
</TOPIC>

<TOPIC> getnextsibling() <style> function
GetNextSibling()

string GetNextSibling( string name)

<b>Beskrivning

Hämtar nästa syskon till ett objekt.
Returnerar namnet på syskonet. Om det inte finns något nästa systkon
returneras en null-sträng.

<b>Argument

string		<t>name		<t>objektets namn.

<b>Exempel

<c> string name;
<c> int not_first;

<c> name = GetChild("Rt");
<c> not_first = 0;
<c> while ( name != "")
<c>   if ( !not_first)
<c>     create menu/title="The Rt objects"/text="'name'"/object="'name'"
<c>   else
<c>     add menu/text="'name'"/object="'name'"
<c>   endif
<c>   not_first = 1;
<c>   name = GetNextSibling(nname);
<c> endwhile
<c> if ( !not_first )
<c>   MessageError("No objects found");
</TOPIC>

<TOPIC> getclasslist() <style> function
GetClassList()

string GetClassList( string class)

<b>Beskrivning

Hämta första objektet av angiven klass. Nästa objekt av klassen kan
hämtas med GetNextObject().
Returnerar namnet på första objektet. Om det inte finns några instanser
av klassen returneras en null-sträng.

<b>Argument

string		<t>name		<t>namn på klassen.

<b>Exempel

<c>  string name;

<c>  name = GetClassList("Dv");
</TOPIC>

<TOPIC> getnextobject() <style> function
GetNextObject()

string GetNextObject( string name)

<b>Beskrivning

Hämta nästa objekt i klasslistan.
Returnerar namnet på objektet. Om det inte finns något nästa objekt
returneras en null-sträng.

<b>Argument

string		<t>name		<t>objektets namn.

<b>Exempel

<c>  string name;

<c>  name = GetClassList("Di");
<c>  while ( name != "")
<c>    printf("Di object found: %s", name);
<c>    name = GetNextObject(name);
<c>  endwhile
</TOPIC>

<TOPIC> getclasslistattrref() <style> function
GetClassListAttrRef()

string GetClassListAttrRef( string class)

<b>Beskrivning

Hämta första objekt eller attributeobjekt av angiven klass. Nästa objekt 
eller attributobjekt av klassen kan hämtas med GetNextAttrRef().
Returnerar namnet på första objektet. Om det inte finns några instanser
eller attributobjekt av klassen returneras en null-sträng.

<b>Argument

string		<t>name		<t>namn på klassen.

<b>Exempel

<c>  string name;

<c>  name = GetClassListAttrRef("Dv");
</TOPIC>

<TOPIC> getnextattrref() <style> function
GetNextAttrRef()

string GetNextAttrRef( string class, string name)

<b>Beskrivning

Hämta nästa objekt i klasslistan.
Returnerar namnet på objektet eller attributobjektet. Om det inte finns 
något nästa objekt returneras en null-sträng.

<b>Argument

string		<t>class	<t>namn på klassen.
string		<t>name		<t>namn på objektet eller attributobjektet.

<b>Exempel

<c>  string name;

<c>  name = GetClassListAttrRef("Di");
<c>  while ( name != "")
<c>    printf("Di object found: %s", name);
<c>    name = GetNextAttrRef(name);
<c>  endwhile
</TOPIC>

<TOPIC> getobjectclass() <style> function
GetObjectClass()

string GetObjectClass( string name)

<b>Beskrivning

Hämta klassen för ett objekt.
Returnerar klassens namn.

<b>Argument

string		<t>name		<t>objektets namn.

<b>Exempel

<c>  string class;

<c>  class = GetObjectClass("Motor-Enable");
</TOPIC>

<TOPIC> getnodeobject() <style> function
GetNodeObject()

string GetNodeObject()

<b>Beskrivning

Hämta nod objektet.
Returnerar namnet på nod objektet.

<b>Exempel

<c>  string node;
<c>  node = GetNodeObject();
</TOPIC>

<TOPIC> getrootlist() <style> function
GetRootList()

string GetRootList()

<b>Beskrivning

Hämta första objektet i rot listan.
Returnerar namnet på rotobjektet. Nästa objekt i rotlistan kan hämtas med
GetNextSibling().

<b>Exempel

<c>  string name;

<c>  name = GetRootList();
<c>  while( name != "")
<c>    printf( "Root object found: %s", name);
<c>    name = GetNextSibling(name);
<c>  endwhile
</TOPIC>

<TOPIC> getnextvolume() <style> function
GetNextVolume()

string GetNextVolume( string name)

<b>Beskrivning

Hämta nästa volym. Den första volymen hämtas med GetVolumeList().
Returnerar namnet på volymen. Om det inte finns någon nästa volym,
returneras en null-sträng.

Argument

string          name            volymens hamn.
</TOPIC>

<TOPIC> getvolumeclass() <style> function
GetVolumeClass()

string GetVolumeClass( string name)

<b>Beskrivning

Hämta klassen för en volym.
Returnerar klassnamnet.

<b>Argument

string          name            volymens namn.

<b>Exempel

<c>  string class;

<c>  class = GetVolumeClass("CVolVKVDKR");
</TOPIC>

<TOPIC> getvolumelist() <style> function
GetVolumeList()

string GetVolumeList()

<b>Beskrivning

Hämta första volymen i volymslistan.
Returnerar namnet på volymen. Nästa volym kan hämtas med 
GetNextVolume().

<b>Exempel

<c>  string name;

<c>  name = GetVolumeList();
<c>  while( name != "")
<c>    printf( "Volume found: %s", name);
<c>    name = GetNextVolume(name);
<c>  endwhile
</TOPIC>

<TOPIC> setattribute() <style> function
SetAttribute()

int SetAttribute( string name, (godtycklig typ) value)

<b>Description

Sätt värde på ett attribut.
Attributet specificeras med fullt objekts och attributnamn.
Returnerar operationens status.

<b>Argument

string          name            attributets name.
godtycklig typ  value		attributets värde.

<b>Exempel

<c>  SetAttribute( "Pump-V1-Switch.Description", "Valve switch open");
</TOPIC>

<TOPIC> getprojectname() <style> function
GetProjectName()

string GetProjectName()

<b>Beskrivning

Hämta projektnamnet.
Returnerar projektets namn.

<b>Exempel

<c>  string name;

<c>  name = GetProjectName();
</TOPIC>

<TOPIC> checksystemgroup() <style> function
CheckSystemGroup()

int CheckSystemGroup()

<b>Beskrivning

Kontrollera om en system grupp existerar.
Returnerar 1 om systemgruppen existerar, annars 0.

<b>Exempel

<c>  if ( !CheckSystemGroup( "MyGroup"))
<c>    return;
<c>  endif
</TOPIC>

<TOPIC> cutobjectname() <style> function
CutObjectName()

string CutObjectName( string name, int segments)

<b>Beskrivning

Klipp av det första leden i ett objektsnamn.
Returnerar de sista segementen av ett objektnamn. Antalet segment som
ska återstå anges med 'segments' argumentet.

<b>Argument

string		<t>name		<t>Objektets hierarkinamn.
int		<t>segments	<t>Antal namnled som ska återstå.

<b>Exempel

<c>  string path_name;
<c>  string object_name;

<c>  path_name = GetChild("Rt-Motor");
<c>  object_name = CutObjectName( path_name, 1);
</TOPIC>

<TOPIC> messageerror() <style> function
MessageError()

string MessageError( string message)

<b>Beskrivning

Skriv ett felmeddelande på skärmen.

<b>Exempel

<c>  MessageError("Something went wrong");
</TOPIC>

<TOPIC> messageinfo() <style> function
MessageInfo()

string MessageInfo( string message)

<b>Beskrivning

Skriv ett informations meddelande på skärmen.

<b>Exempel

<c>  MessageInfo("Everything is all right so far");
</TOPIC>

<TOPIC> getcurrenttext() <style> function
GetCurrentText()

string GetCurrentText()

<b>Beskrivning

Hämta texen på utvalt menyalternativ.

<b>Exempel

<c>  string text;

<c>  text = GetCurrentText();
</TOPIC>

<TOPIC> getcurrentobject() <style> function
GetCurrentObject()

string GetCurrentObject()

<b>Beskrivning

Hämta objekt som är associerat med utvalt meny alternativ.
Om inte något objekt är associerat returneras en null-sträng.

<b>Exempel

<c>  string object;

<c>  object = GetCurrentObject();
</TOPIC>

<TOPIC> getcurrentvolume() <style> function
GetCurrentVolume()

string GetCurrentVolume()

<b>Beskrivning

Hämta volymen för aktuell session.
Om ingen aktuell session finns, returneras in null-sträng.

<b>Exempel

<c>  string current_volume;

<c>  current_volume = GetCurrentVolume();
<c>  set volume/volume=SomeOtherVolume
<c>  ...
<c>  set volume/volume='current_volume'

</TOPIC>

<TOPIC> isw1() <style> function
IsW1()

int IsW1()

<b>Beskrivning

Returnerar 1 om nuvarande fönster med imatnings fokus är anläggningshierarki
fönstret. Annars returneras 0.
</TOPIC>

<TOPIC> isw2() <style> function
IsW2()

int IsW2()

<b>Beskrivning

Returnerar 1 om nuvarande fönster med imatnings fokus är nodhierarki
fönstret. Annars returneras 0.
</TOPIC>

<TOPIC> editmode() <style> function
EditMode()

int EditMode()

<b>Beskrivning

Returnerar 1 om wtt är i editerings mod.
Annars returneras 0.
</TOPIC>

<TOPIC> messagedialog() <style> function
MessageDialog()

MessageDialog( string title, string text)

<b>Beskrivning

Visar en dialogruta för meddelanden.

<b>Argument

string		<t>title	<t>Titel.
string		<t>text		<t>Meddelande text.

<b>Exempel

<c>  MessageDialog( "Message", "This is a message");
</TOPIC>

<TOPIC> confirmdialog() <style> function
ConfirmDialog()

int ConfirmDialog( string title, string text [, int cancel])

<b>Beskrivning

Visar en dialog ruta med konfirmering.
Returnerar 1 om yes-knappen har tryckts, 0 om no-knappen har trycks.
Om det tredje argumentet (cancel) har adderats, visas en cancel knapp
i dialogrutan. Om cancel-knappen har trycks, eller om dialogrutan 
har stängs, sätts cancel argumentet till 1.

<b>Argument

string		<t>title	<t>Titel.
string		<t>text		<t>Konfirmerings text.
int		<t>cancel	<t>Valfritt. En cancel knapp visas.
		<t>		<t>Cancel sätts till 1 om cancel-knappen har 
		<t>		<t>trycks, eller om dialogrutan har stängts.

<b>Exempel 1

<c>  if ( ! ConfirmDialog( "Confirm", "Do you really want to..."))
<c>    printf( "Yes is pressed\n");
<c>  else
<c>    printf( "No is pressed\n");
<c>  endif

<b>Exempel 2

<c>  int cancel;
<c>  int sts;

<c>  sts =  ConfirmDialog( "Confirm", "Do you really want to...", cancel);
<c>  if ( cancel)
<c>    printf("Cancel is pressed\n);
<c>    exit();
<c>  endif

<c>  if ( sts)
<c>    printf( "Yes is pressed\n");
<c>  else
<c>    printf( "No is pressed\n");
<c>  endif
</TOPIC>

<TOPIC> continuedialog() <style> function
ContinueDialog()

ContinueDialog( string title, string text)

<b>Beskrivning

Visar en dialogruta med knapparna 'Continue' och 'Quit'.
Returnerar 1 om continue har trycks, 0 om quit har trycks.

<b>Argument

string		<t>title	<t>Titel.
string		<t>text		<t>Meddelande text.

<b>Exempel

<c>  if ( ! ContinueDialog( "Message", "This script will...");
<c>    exit();
<c>  endif
</TOPIC>

<TOPIC> promptdialog() <style> function
PromptDialog()

int PromptDialog( string title, string text, string value)

<b>Beskrivning

Visar en dialogruta med en prompt som promptar för en inmagning.
Returnerar 1 om yes-knappen är tryckt, 0 om cancel-knappen har trycks,
eller om dialogrutan har stängs.


<b>Argument

string		<t>title	<t>Titel.
string		<t>text		<t>Text.
string		<t>value	<t>Innehåller inmatat värde.

<b>Exempel

<c>  string name;

<c>  if ( PromptDialog( "Name", "Enter name", name))
<c>    printf( "Name : '%s'\n", name);
<c>  else
<c>    printf( "Cancel...\n");
<c>  endif

</TOPIC>

<TOPIC> opengraph() <style> function
OpenGraph()

int OpenGraph( string name, int modal)

<b>Beskrivning

Öppnar en Ge graf.
Grafen kan öppnas som modal eller ej modal. Modal innebär att
exekveringen av scriptet inte fortsätter förrän grafen har stängts.

<b>Argument

string		<t>name		<t>Namn på grafen.
int		<t>modal	<t>Modal mod.

<b>Exempel

<c>  OpenGraph( "pwr_wizard_frame", 0);

</TOPIC>

<TOPIC> closegraph() <style> function
CloseGraph()

int CloseGraph( string name)

<b>Beskrivning

Stänger en Ge graf.

<b>Argument

string		<t>name		<t>Namn på grafen.

<b>Exempel

<c>  CloseGraph( "pwr_wizard_frame");

</TOPIC>

<TOPIC> setsubwindow() <style> function
SetSubwindow()

int SetSubwindow( string name, string windowname, string source, int modal)

<b>Beskrivning

Öppnar en Ge graf i ett window objekt i en tidigare öppnad graf.
I modal mod, forsätter inte exekveringen förrän kommandot 'release subwindow'
exekveras av någon trycknapp i bilden.

<b>Argument

string		<t>name		<t>Namn på huvud grafen.
string		<t>windowname	<t>Namn på window objektet i vilken den
		<t>		<t>specificerad grafen ska visas.
string		<t>source	<t>Namn på grafen som ska visas i window objektet.
int		<t>modal	<t>Modal mod.
<b>Exempel

<c>  SetSubwindow( "pwr_wizard_frame", "Window1", "MyGraph", 1);

</TOPIC>
</chapter>









