/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2013 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

#ifndef ra_nmps_appl_h
#define ra_nmps_appl_h

/* ra_nmps_appl.h -- <short description>
   NMps API.  */

/*! \file nmps_appl.h
    \brief Type definitions for NMps.
   This include file contains the Proview NMps type definitions.
*/

/** @addtogroup NMpsAppl */
/*@{*/

#if defined __cplusplus
extern "C" {
#endif


#define NMPSAPPL_CELLIST_MAX		32	/* Max number of cells in a
						   appl_init call */
#define NMPSAPPL_APPLSESS_MAX		32	/* Max number of application
						   sessions */

#define nmpsappl_mOption_Remove		(1 << 0)
#define nmpsappl_mOption_NamePath	(1 << 1)
#define nmpsappl_mOption_ReverseOrder	(1 << 2)


/** @defgroup NMPS_DS NMpsAppl Data Structures
 *  @ingroup NMps
 *  @{
 */


typedef struct nmpsappl_s_cellist {
	pwr_tString80		name;
	pwr_tObjid		objid;
	pwr_tAddress		object_ptr;
	gdh_tDlid		subid;
	pwr_tClassId		classid;
	unsigned long		index_mask[NMPSAPPL_APPLSESS_MAX];
	int			tmp_size;
	void			*tmp_cell;
	struct nmpsappl_s_cellist *next;
	} nmpsappl_t_cellist;

typedef struct {
	pwr_tObjid		objid; /**< Dataobject objid */
	pwr_tString80		name; /**< Dataobject name (last segment) */
	pwr_tAddress		object_ptr;  /**< Pointer to data object */ 
	pwr_tBoolean		select; /**< The select attribute for the dataobject in the
					   cell object. If the dataobject is present in several
					   cells, select is set if the dataobject is selected
					   in at least one of the cells. */
	pwr_tBoolean		front; /**< The Front attribute for the dataobject in the cell
					  object. If the dataobject is present in several 
					  cells, front is set if the Front flag is set in one
					  of the cells. */
	pwr_tBoolean		back; /**< The Back attribute for the dataobject in the cell
					  object. If the dataobject is present in several 
					  cells, back is set if the Back flag is set in one
					  of the cells. */
	pwr_tBoolean		newdata; /**< Marks that a data object is new since the last
					    mirror. */
	pwr_tBoolean		removed;  /**< Marks that the dataobject has disappeard since
					     the last mirror. Requires the the option
					     nmpsappl_mOption_Remove is selected. */
	unsigned long		cell_mask; /**< Mask that specifies in which cell or which
					      cells the dataobject resides. The first bit
					      corresponds to the first cell, i.e. the first
					      cell in cell list supplied to nmpsappl_MirrorInit,
					      etc. */
	} nmpsappl_t_datainfo;

typedef struct nmpsappl_s_ctx {
	nmpsappl_t_cellist	*cellist[NMPSAPPL_CELLIST_MAX];
	unsigned long		options;
	int			index;
	unsigned long		index_mask;
	int			cellist_count;
	int			total_cellsize;
	int			data_count;
	nmpsappl_t_datainfo	*datainfo;
	struct nmpsappl_s_ctx	*next;
	} *nmpsappl_t_ctx;

/** @} */
/** 
 * @defgroup NMPS_FC NMpsAppl Functions
 * @ingroup NMps
 * @{
 */

pwr_tStatus nmpsappl_MirrorInit(	pwr_tString80	*cell_array,
					unsigned long	options,
					nmpsappl_t_ctx	*ctx);

pwr_tStatus nmpsappl_Mirror( 	nmpsappl_t_ctx		applctx,
				int			*data_count,
				nmpsappl_t_datainfo	**datainfo);
pwr_tStatus nmpsappl_RemoveData(
			nmpsappl_t_ctx		applctx,
			pwr_tObjid		objid);
pwr_tStatus nmpsappl_RemoveAndDeleteData(
			nmpsappl_t_ctx		applctx,
			pwr_tObjid 		objid);
pwr_tStatus nmpsappl_SelectData(
			nmpsappl_t_ctx		applctx,
			pwr_tObjid 		objid);
pwr_tStatus	nmpsappl_TransportData(
			nmpsappl_t_ctx		applctx,
			pwr_tObjid 		objid,
			unsigned int		from_cell_mask,
			unsigned int		to_cell_mask);
pwr_tStatus	nmpsappl_InsertData(
			nmpsappl_t_ctx		applctx,
			pwr_tObjid 		objid,
			unsigned int		cell_mask);
pwr_tStatus	nmpsappl_RemoveAndKeepData(
			nmpsappl_t_ctx		applctx,
			pwr_tObjid 		objid,
			unsigned int		cell_mask);


#if defined __cplusplus
}
#endif
#endif

/** @} */
/** @} */
