/* opc_soap_C.cpp
   Generated by gSOAP 2.7.9d from opc_msg.h
   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "opc_soap_H.h"

SOAP_SOURCE_STAMP("@(#) opc_soap_C.cpp ver 2.7.9d 2007-03-15 12:24:24 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_in_short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_float:
		return soap_in_float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedShort:
		return soap_in_unsignedShort(soap, NULL, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLONG64:
		return soap_in_unsignedLONG64(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_s0__browseFilter:
		return soap_in_s0__browseFilter(soap, NULL, NULL, "s0:browseFilter");
	case SOAP_TYPE_s0__limitBits:
		return soap_in_s0__limitBits(soap, NULL, NULL, "s0:limitBits");
	case SOAP_TYPE_s0__qualityBits:
		return soap_in_s0__qualityBits(soap, NULL, NULL, "s0:qualityBits");
	case SOAP_TYPE_s0__interfaceVersion:
		return soap_in_s0__interfaceVersion(soap, NULL, NULL, "s0:interfaceVersion");
	case SOAP_TYPE_s0__serverState:
		return soap_in_s0__serverState(soap, NULL, NULL, "s0:serverState");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_s0__browseFilter_:
		return soap_in_s0__browseFilter_(soap, NULL, NULL, "s0:browseFilter");
	case SOAP_TYPE_s0__limitBits_:
		return soap_in_s0__limitBits_(soap, NULL, NULL, "s0:limitBits");
	case SOAP_TYPE_s0__qualityBits_:
		return soap_in_s0__qualityBits_(soap, NULL, NULL, "s0:qualityBits");
	case SOAP_TYPE_s0__interfaceVersion_:
		return soap_in_s0__interfaceVersion_(soap, NULL, NULL, "s0:interfaceVersion");
	case SOAP_TYPE_s0__serverState_:
		return soap_in_s0__serverState_(soap, NULL, NULL, "s0:serverState");
	case SOAP_TYPE_s0__PropertyReplyList:
		return soap_in_s0__PropertyReplyList(soap, NULL, NULL, "s0:PropertyReplyList");
	case SOAP_TYPE_s0__ItemIdentifier:
		return soap_in_s0__ItemIdentifier(soap, NULL, NULL, "s0:ItemIdentifier");
	case SOAP_TYPE_s0__ItemProperty:
		return soap_in_s0__ItemProperty(soap, NULL, NULL, "s0:ItemProperty");
	case SOAP_TYPE_s0__BrowseElement:
		return soap_in_s0__BrowseElement(soap, NULL, NULL, "s0:BrowseElement");
	case SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList:
		return soap_in_s0__SubscribePolledRefreshReplyItemList(soap, NULL, NULL, "s0:SubscribePolledRefreshReplyItemList");
	case SOAP_TYPE_s0__SubscribeItemValue:
		return soap_in_s0__SubscribeItemValue(soap, NULL, NULL, "s0:SubscribeItemValue");
	case SOAP_TYPE_s0__SubscribeReplyItemList:
		return soap_in_s0__SubscribeReplyItemList(soap, NULL, NULL, "s0:SubscribeReplyItemList");
	case SOAP_TYPE_s0__SubscribeRequestItem:
		return soap_in_s0__SubscribeRequestItem(soap, NULL, NULL, "s0:SubscribeRequestItem");
	case SOAP_TYPE_s0__SubscribeRequestItemList:
		return soap_in_s0__SubscribeRequestItemList(soap, NULL, NULL, "s0:SubscribeRequestItemList");
	case SOAP_TYPE_s0__WriteRequestItemList:
		return soap_in_s0__WriteRequestItemList(soap, NULL, NULL, "s0:WriteRequestItemList");
	case SOAP_TYPE_s0__ArrayOfShort:
		return soap_in_s0__ArrayOfShort(soap, NULL, NULL, "s0:ArrayOfShort");
	case SOAP_TYPE_s0__ArrayOfByte:
		return soap_in_s0__ArrayOfByte(soap, NULL, NULL, "s0:ArrayOfByte");
	case SOAP_TYPE_s0__ArrayOfDecimal:
		return soap_in_s0__ArrayOfDecimal(soap, NULL, NULL, "s0:ArrayOfDecimal");
	case SOAP_TYPE_s0__ArrayOfAnyType:
		return soap_in_s0__ArrayOfAnyType(soap, NULL, NULL, "s0:ArrayOfAnyType");
	case SOAP_TYPE_s0__ArrayOfDateTime:
		return soap_in_s0__ArrayOfDateTime(soap, NULL, NULL, "s0:ArrayOfDateTime");
	case SOAP_TYPE_s0__ArrayOfString:
		return soap_in_s0__ArrayOfString(soap, NULL, NULL, "s0:ArrayOfString");
	case SOAP_TYPE_s0__ArrayOfBoolean:
		return soap_in_s0__ArrayOfBoolean(soap, NULL, NULL, "s0:ArrayOfBoolean");
	case SOAP_TYPE_s0__ArrayOfUnsignedShort:
		return soap_in_s0__ArrayOfUnsignedShort(soap, NULL, NULL, "s0:ArrayOfUnsignedShort");
	case SOAP_TYPE_s0__ArrayOfDouble:
		return soap_in_s0__ArrayOfDouble(soap, NULL, NULL, "s0:ArrayOfDouble");
	case SOAP_TYPE_s0__ArrayOfUnsignedLong:
		return soap_in_s0__ArrayOfUnsignedLong(soap, NULL, NULL, "s0:ArrayOfUnsignedLong");
	case SOAP_TYPE_s0__ArrayOfLong:
		return soap_in_s0__ArrayOfLong(soap, NULL, NULL, "s0:ArrayOfLong");
	case SOAP_TYPE_s0__ArrayOfUnsignedInt:
		return soap_in_s0__ArrayOfUnsignedInt(soap, NULL, NULL, "s0:ArrayOfUnsignedInt");
	case SOAP_TYPE_s0__ArrayOfInt:
		return soap_in_s0__ArrayOfInt(soap, NULL, NULL, "s0:ArrayOfInt");
	case SOAP_TYPE_s0__ArrayOfFloat:
		return soap_in_s0__ArrayOfFloat(soap, NULL, NULL, "s0:ArrayOfFloat");
	case SOAP_TYPE_s0__OPCError:
		return soap_in_s0__OPCError(soap, NULL, NULL, "s0:OPCError");
	case SOAP_TYPE_s0__OPCQuality:
		return soap_in_s0__OPCQuality(soap, NULL, NULL, "s0:OPCQuality");
	case SOAP_TYPE_s0__Value:
		return soap_in_s0__Value(soap, NULL, NULL, "s0:Value");
	case SOAP_TYPE_s0__ItemValue:
		return soap_in_s0__ItemValue(soap, NULL, NULL, "s0:ItemValue");
	case SOAP_TYPE_s0__ReplyItemList:
		return soap_in_s0__ReplyItemList(soap, NULL, NULL, "s0:ReplyItemList");
	case SOAP_TYPE_s0__ReadRequestItem:
		return soap_in_s0__ReadRequestItem(soap, NULL, NULL, "s0:ReadRequestItem");
	case SOAP_TYPE_s0__ReadRequestItemList:
		return soap_in_s0__ReadRequestItemList(soap, NULL, NULL, "s0:ReadRequestItemList");
	case SOAP_TYPE_s0__RequestOptions:
		return soap_in_s0__RequestOptions(soap, NULL, NULL, "s0:RequestOptions");
	case SOAP_TYPE_s0__ServerStatus:
		return soap_in_s0__ServerStatus(soap, NULL, NULL, "s0:ServerStatus");
	case SOAP_TYPE_s0__ReplyBase:
		return soap_in_s0__ReplyBase(soap, NULL, NULL, "s0:ReplyBase");
	case SOAP_TYPE_xsd__unsignedShort:
		return soap_in_xsd__unsignedShort(soap, NULL, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_xsd__unsignedLong:
		return soap_in_xsd__unsignedLong(soap, NULL, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__unsignedInt:
		return soap_in_xsd__unsignedInt(soap, NULL, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedByte:
		return soap_in_xsd__unsignedByte(soap, NULL, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__string:
		return soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__short:
		return soap_in_xsd__short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_xsd__long:
		return soap_in_xsd__long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_xsd__int:
		return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__float:
		return soap_in_xsd__float(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_xsd__double:
		return soap_in_xsd__double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_xsd__decimal_:
		return soap_in_xsd__decimal_(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_xsd__decimal:
		return soap_in_xsd__decimal(soap, NULL, NULL, "xsd:decimal");
	case SOAP_TYPE_xsd__dateTime:
		return soap_in_xsd__dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__byte:
		return soap_in_xsd__byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_xsd__QName_:
		return soap_in_xsd__QName_(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_xsd__QName:
		return soap_in_xsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerTo_s0__GetPropertiesResponse:
		return soap_in_PointerTo_s0__GetPropertiesResponse(soap, NULL, NULL, "s0:GetPropertiesResponse");
	case SOAP_TYPE_PointerTo_s0__GetProperties:
		return soap_in_PointerTo_s0__GetProperties(soap, NULL, NULL, "s0:GetProperties");
	case SOAP_TYPE_PointerTo_s0__BrowseResponse:
		return soap_in_PointerTo_s0__BrowseResponse(soap, NULL, NULL, "s0:BrowseResponse");
	case SOAP_TYPE_PointerTo_s0__Browse:
		return soap_in_PointerTo_s0__Browse(soap, NULL, NULL, "s0:Browse");
	case SOAP_TYPE_PointerTo_s0__SubscriptionCancelResponse:
		return soap_in_PointerTo_s0__SubscriptionCancelResponse(soap, NULL, NULL, "s0:SubscriptionCancelResponse");
	case SOAP_TYPE_PointerTo_s0__SubscriptionCancel:
		return soap_in_PointerTo_s0__SubscriptionCancel(soap, NULL, NULL, "s0:SubscriptionCancel");
	case SOAP_TYPE_PointerTo_s0__SubscriptionPolledRefreshResponse:
		return soap_in_PointerTo_s0__SubscriptionPolledRefreshResponse(soap, NULL, NULL, "s0:SubscriptionPolledRefreshResponse");
	case SOAP_TYPE_PointerTo_s0__SubscriptionPolledRefresh:
		return soap_in_PointerTo_s0__SubscriptionPolledRefresh(soap, NULL, NULL, "s0:SubscriptionPolledRefresh");
	case SOAP_TYPE_PointerTo_s0__SubscribeResponse:
		return soap_in_PointerTo_s0__SubscribeResponse(soap, NULL, NULL, "s0:SubscribeResponse");
	case SOAP_TYPE_PointerTo_s0__Subscribe:
		return soap_in_PointerTo_s0__Subscribe(soap, NULL, NULL, "s0:Subscribe");
	case SOAP_TYPE_PointerTo_s0__WriteResponse:
		return soap_in_PointerTo_s0__WriteResponse(soap, NULL, NULL, "s0:WriteResponse");
	case SOAP_TYPE_PointerTo_s0__Write:
		return soap_in_PointerTo_s0__Write(soap, NULL, NULL, "s0:Write");
	case SOAP_TYPE_PointerTo_s0__ReadResponse:
		return soap_in_PointerTo_s0__ReadResponse(soap, NULL, NULL, "s0:ReadResponse");
	case SOAP_TYPE_PointerTo_s0__Read:
		return soap_in_PointerTo_s0__Read(soap, NULL, NULL, "s0:Read");
	case SOAP_TYPE_PointerTo_s0__GetStatusResponse:
		return soap_in_PointerTo_s0__GetStatusResponse(soap, NULL, NULL, "s0:GetStatusResponse");
	case SOAP_TYPE_PointerTo_s0__GetStatus:
		return soap_in_PointerTo_s0__GetStatus(soap, NULL, NULL, "s0:GetStatus");
	case SOAP_TYPE_PointerTos0__PropertyReplyList:
		return soap_in_PointerTos0__PropertyReplyList(soap, NULL, NULL, "s0:PropertyReplyList");
	case SOAP_TYPE_PointerTos0__ItemIdentifier:
		return soap_in_PointerTos0__ItemIdentifier(soap, NULL, NULL, "s0:ItemIdentifier");
	case SOAP_TYPE_PointerTos0__BrowseElement:
		return soap_in_PointerTos0__BrowseElement(soap, NULL, NULL, "s0:BrowseElement");
	case SOAP_TYPE_PointerTos0__browseFilter:
		return soap_in_PointerTos0__browseFilter(soap, NULL, NULL, "s0:browseFilter");
	case SOAP_TYPE_PointerTos0__SubscribePolledRefreshReplyItemList:
		return soap_in_PointerTos0__SubscribePolledRefreshReplyItemList(soap, NULL, NULL, "s0:SubscribePolledRefreshReplyItemList");
	case SOAP_TYPE_PointerTos0__SubscribeReplyItemList:
		return soap_in_PointerTos0__SubscribeReplyItemList(soap, NULL, NULL, "s0:SubscribeReplyItemList");
	case SOAP_TYPE_PointerTos0__SubscribeRequestItemList:
		return soap_in_PointerTos0__SubscribeRequestItemList(soap, NULL, NULL, "s0:SubscribeRequestItemList");
	case SOAP_TYPE_PointerTos0__WriteRequestItemList:
		return soap_in_PointerTos0__WriteRequestItemList(soap, NULL, NULL, "s0:WriteRequestItemList");
	case SOAP_TYPE_PointerTos0__OPCError:
		return soap_in_PointerTos0__OPCError(soap, NULL, NULL, "s0:OPCError");
	case SOAP_TYPE_PointerTos0__ReplyItemList:
		return soap_in_PointerTos0__ReplyItemList(soap, NULL, NULL, "s0:ReplyItemList");
	case SOAP_TYPE_PointerTos0__ReadRequestItemList:
		return soap_in_PointerTos0__ReadRequestItemList(soap, NULL, NULL, "s0:ReadRequestItemList");
	case SOAP_TYPE_PointerTos0__RequestOptions:
		return soap_in_PointerTos0__RequestOptions(soap, NULL, NULL, "s0:RequestOptions");
	case SOAP_TYPE_PointerTos0__ServerStatus:
		return soap_in_PointerTos0__ServerStatus(soap, NULL, NULL, "s0:ServerStatus");
	case SOAP_TYPE_PointerTos0__ReplyBase:
		return soap_in_PointerTos0__ReplyBase(soap, NULL, NULL, "s0:ReplyBase");
	case SOAP_TYPE_PointerTos0__ItemProperty:
		return soap_in_PointerTos0__ItemProperty(soap, NULL, NULL, "s0:ItemProperty");
	case SOAP_TYPE_PointerTos0__SubscribeItemValue:
		return soap_in_PointerTos0__SubscribeItemValue(soap, NULL, NULL, "s0:SubscribeItemValue");
	case SOAP_TYPE_PointerTofloat:
		return soap_in_PointerTofloat(soap, NULL, NULL, "xsd:float");
	case SOAP_TYPE_PointerTos0__SubscribeRequestItem:
		return soap_in_PointerTos0__SubscribeRequestItem(soap, NULL, NULL, "s0:SubscribeRequestItem");
	case SOAP_TYPE_PointerTounsignedShort:
		return soap_in_PointerTounsignedShort(soap, NULL, NULL, "xsd:unsignedShort");
	case SOAP_TYPE_PointerTos0__limitBits:
		return soap_in_PointerTos0__limitBits(soap, NULL, NULL, "s0:limitBits");
	case SOAP_TYPE_PointerTos0__qualityBits:
		return soap_in_PointerTos0__qualityBits(soap, NULL, NULL, "s0:qualityBits");
	case SOAP_TYPE_PointerTos0__OPCQuality:
		return soap_in_PointerTos0__OPCQuality(soap, NULL, NULL, "s0:OPCQuality");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_in_PointerToxsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerTos0__ItemValue:
		return soap_in_PointerTos0__ItemValue(soap, NULL, NULL, "s0:ItemValue");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_PointerToxsd__QName:
		return soap_in_PointerToxsd__QName(soap, NULL, NULL, "xsd:QName");
	case SOAP_TYPE_PointerTos0__ReadRequestItem:
		return soap_in_PointerTos0__ReadRequestItem(soap, NULL, NULL, "s0:ReadRequestItem");
	case SOAP_TYPE_PointerToxsd__dateTime:
		return soap_in_PointerToxsd__dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_short;
			return soap_in_short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedShort"))
		{	*type = SOAP_TYPE_unsignedShort;
			return soap_in_unsignedShort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_unsignedLONG64;
			return soap_in_unsignedLONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:browseFilter"))
		{	*type = SOAP_TYPE_s0__browseFilter;
			return soap_in_s0__browseFilter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:limitBits"))
		{	*type = SOAP_TYPE_s0__limitBits;
			return soap_in_s0__limitBits(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:qualityBits"))
		{	*type = SOAP_TYPE_s0__qualityBits;
			return soap_in_s0__qualityBits(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:interfaceVersion"))
		{	*type = SOAP_TYPE_s0__interfaceVersion;
			return soap_in_s0__interfaceVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:serverState"))
		{	*type = SOAP_TYPE_s0__serverState;
			return soap_in_s0__serverState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:browseFilter"))
		{	*type = SOAP_TYPE_s0__browseFilter_;
			return soap_in_s0__browseFilter_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:limitBits"))
		{	*type = SOAP_TYPE_s0__limitBits_;
			return soap_in_s0__limitBits_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:qualityBits"))
		{	*type = SOAP_TYPE_s0__qualityBits_;
			return soap_in_s0__qualityBits_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:interfaceVersion"))
		{	*type = SOAP_TYPE_s0__interfaceVersion_;
			return soap_in_s0__interfaceVersion_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:serverState"))
		{	*type = SOAP_TYPE_s0__serverState_;
			return soap_in_s0__serverState_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:PropertyReplyList"))
		{	*type = SOAP_TYPE_s0__PropertyReplyList;
			return soap_in_s0__PropertyReplyList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ItemIdentifier"))
		{	*type = SOAP_TYPE_s0__ItemIdentifier;
			return soap_in_s0__ItemIdentifier(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ItemProperty"))
		{	*type = SOAP_TYPE_s0__ItemProperty;
			return soap_in_s0__ItemProperty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:BrowseElement"))
		{	*type = SOAP_TYPE_s0__BrowseElement;
			return soap_in_s0__BrowseElement(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:SubscribePolledRefreshReplyItemList"))
		{	*type = SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList;
			return soap_in_s0__SubscribePolledRefreshReplyItemList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:SubscribeItemValue"))
		{	*type = SOAP_TYPE_s0__SubscribeItemValue;
			return soap_in_s0__SubscribeItemValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:SubscribeReplyItemList"))
		{	*type = SOAP_TYPE_s0__SubscribeReplyItemList;
			return soap_in_s0__SubscribeReplyItemList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:SubscribeRequestItem"))
		{	*type = SOAP_TYPE_s0__SubscribeRequestItem;
			return soap_in_s0__SubscribeRequestItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:SubscribeRequestItemList"))
		{	*type = SOAP_TYPE_s0__SubscribeRequestItemList;
			return soap_in_s0__SubscribeRequestItemList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:WriteRequestItemList"))
		{	*type = SOAP_TYPE_s0__WriteRequestItemList;
			return soap_in_s0__WriteRequestItemList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ArrayOfShort"))
		{	*type = SOAP_TYPE_s0__ArrayOfShort;
			return soap_in_s0__ArrayOfShort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ArrayOfByte"))
		{	*type = SOAP_TYPE_s0__ArrayOfByte;
			return soap_in_s0__ArrayOfByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ArrayOfDecimal"))
		{	*type = SOAP_TYPE_s0__ArrayOfDecimal;
			return soap_in_s0__ArrayOfDecimal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ArrayOfAnyType"))
		{	*type = SOAP_TYPE_s0__ArrayOfAnyType;
			return soap_in_s0__ArrayOfAnyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ArrayOfDateTime"))
		{	*type = SOAP_TYPE_s0__ArrayOfDateTime;
			return soap_in_s0__ArrayOfDateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ArrayOfString"))
		{	*type = SOAP_TYPE_s0__ArrayOfString;
			return soap_in_s0__ArrayOfString(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ArrayOfBoolean"))
		{	*type = SOAP_TYPE_s0__ArrayOfBoolean;
			return soap_in_s0__ArrayOfBoolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ArrayOfUnsignedShort"))
		{	*type = SOAP_TYPE_s0__ArrayOfUnsignedShort;
			return soap_in_s0__ArrayOfUnsignedShort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ArrayOfDouble"))
		{	*type = SOAP_TYPE_s0__ArrayOfDouble;
			return soap_in_s0__ArrayOfDouble(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ArrayOfUnsignedLong"))
		{	*type = SOAP_TYPE_s0__ArrayOfUnsignedLong;
			return soap_in_s0__ArrayOfUnsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ArrayOfLong"))
		{	*type = SOAP_TYPE_s0__ArrayOfLong;
			return soap_in_s0__ArrayOfLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ArrayOfUnsignedInt"))
		{	*type = SOAP_TYPE_s0__ArrayOfUnsignedInt;
			return soap_in_s0__ArrayOfUnsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ArrayOfInt"))
		{	*type = SOAP_TYPE_s0__ArrayOfInt;
			return soap_in_s0__ArrayOfInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ArrayOfFloat"))
		{	*type = SOAP_TYPE_s0__ArrayOfFloat;
			return soap_in_s0__ArrayOfFloat(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:OPCError"))
		{	*type = SOAP_TYPE_s0__OPCError;
			return soap_in_s0__OPCError(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:OPCQuality"))
		{	*type = SOAP_TYPE_s0__OPCQuality;
			return soap_in_s0__OPCQuality(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:Value"))
		{	*type = SOAP_TYPE_s0__Value;
			return soap_in_s0__Value(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ItemValue"))
		{	*type = SOAP_TYPE_s0__ItemValue;
			return soap_in_s0__ItemValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ReplyItemList"))
		{	*type = SOAP_TYPE_s0__ReplyItemList;
			return soap_in_s0__ReplyItemList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ReadRequestItem"))
		{	*type = SOAP_TYPE_s0__ReadRequestItem;
			return soap_in_s0__ReadRequestItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ReadRequestItemList"))
		{	*type = SOAP_TYPE_s0__ReadRequestItemList;
			return soap_in_s0__ReadRequestItemList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:RequestOptions"))
		{	*type = SOAP_TYPE_s0__RequestOptions;
			return soap_in_s0__RequestOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ServerStatus"))
		{	*type = SOAP_TYPE_s0__ServerStatus;
			return soap_in_s0__ServerStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ReplyBase"))
		{	*type = SOAP_TYPE_s0__ReplyBase;
			return soap_in_s0__ReplyBase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedShort"))
		{	*type = SOAP_TYPE_xsd__unsignedShort;
			return soap_in_xsd__unsignedShort(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_xsd__unsignedLong;
			return soap_in_xsd__unsignedLong(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_xsd__unsignedInt;
			return soap_in_xsd__unsignedInt(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_xsd__unsignedByte;
			return soap_in_xsd__unsignedByte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_xsd__string;
			return soap_in_xsd__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_xsd__short;
			return soap_in_xsd__short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_xsd__long;
			return soap_in_xsd__long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int;
			return soap_in_xsd__int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_xsd__float;
			return soap_in_xsd__float(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_xsd__double;
			return soap_in_xsd__double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal_;
			return soap_in_xsd__decimal_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:decimal"))
		{	*type = SOAP_TYPE_xsd__decimal;
			return soap_in_xsd__decimal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_xsd__dateTime;
			return soap_in_xsd__dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_xsd__byte;
			return soap_in_xsd__byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName_;
			return soap_in_xsd__QName_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName;
			return soap_in_xsd__QName(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "s0:GetPropertiesResponse"))
		{	*type = SOAP_TYPE__s0__GetPropertiesResponse;
			return soap_in__s0__GetPropertiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:GetProperties"))
		{	*type = SOAP_TYPE__s0__GetProperties;
			return soap_in__s0__GetProperties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:BrowseResponse"))
		{	*type = SOAP_TYPE__s0__BrowseResponse;
			return soap_in__s0__BrowseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:Browse"))
		{	*type = SOAP_TYPE__s0__Browse;
			return soap_in__s0__Browse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:SubscriptionCancelResponse"))
		{	*type = SOAP_TYPE__s0__SubscriptionCancelResponse;
			return soap_in__s0__SubscriptionCancelResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:SubscriptionCancel"))
		{	*type = SOAP_TYPE__s0__SubscriptionCancel;
			return soap_in__s0__SubscriptionCancel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:SubscriptionPolledRefreshResponse"))
		{	*type = SOAP_TYPE__s0__SubscriptionPolledRefreshResponse;
			return soap_in__s0__SubscriptionPolledRefreshResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:SubscriptionPolledRefresh"))
		{	*type = SOAP_TYPE__s0__SubscriptionPolledRefresh;
			return soap_in__s0__SubscriptionPolledRefresh(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:SubscribeResponse"))
		{	*type = SOAP_TYPE__s0__SubscribeResponse;
			return soap_in__s0__SubscribeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:Subscribe"))
		{	*type = SOAP_TYPE__s0__Subscribe;
			return soap_in__s0__Subscribe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:WriteResponse"))
		{	*type = SOAP_TYPE__s0__WriteResponse;
			return soap_in__s0__WriteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:Write"))
		{	*type = SOAP_TYPE__s0__Write;
			return soap_in__s0__Write(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:ReadResponse"))
		{	*type = SOAP_TYPE__s0__ReadResponse;
			return soap_in__s0__ReadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:Read"))
		{	*type = SOAP_TYPE__s0__Read;
			return soap_in__s0__Read(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:GetStatusResponse"))
		{	*type = SOAP_TYPE__s0__GetStatusResponse;
			return soap_in__s0__GetStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "s0:GetStatus"))
		{	*type = SOAP_TYPE__s0__GetStatus;
			return soap_in__s0__GetStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedShort:
		return soap_out_unsignedShort(soap, tag, id, (const unsigned short *)ptr, "xsd:unsignedShort");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE_unsignedLONG64:
		return soap_out_unsignedLONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_s0__browseFilter:
		return soap_out_s0__browseFilter(soap, tag, id, (const enum s0__browseFilter *)ptr, "s0:browseFilter");
	case SOAP_TYPE_s0__limitBits:
		return soap_out_s0__limitBits(soap, tag, id, (const enum s0__limitBits *)ptr, "s0:limitBits");
	case SOAP_TYPE_s0__qualityBits:
		return soap_out_s0__qualityBits(soap, tag, id, (const enum s0__qualityBits *)ptr, "s0:qualityBits");
	case SOAP_TYPE_s0__interfaceVersion:
		return soap_out_s0__interfaceVersion(soap, tag, id, (const enum s0__interfaceVersion *)ptr, "s0:interfaceVersion");
	case SOAP_TYPE_s0__serverState:
		return soap_out_s0__serverState(soap, tag, id, (const enum s0__serverState *)ptr, "s0:serverState");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_s0__browseFilter_:
		return ((s0__browseFilter_ *)ptr)->soap_out(soap, tag, id, "s0:browseFilter");
	case SOAP_TYPE_s0__limitBits_:
		return ((s0__limitBits_ *)ptr)->soap_out(soap, tag, id, "s0:limitBits");
	case SOAP_TYPE_s0__qualityBits_:
		return ((s0__qualityBits_ *)ptr)->soap_out(soap, tag, id, "s0:qualityBits");
	case SOAP_TYPE_s0__interfaceVersion_:
		return ((s0__interfaceVersion_ *)ptr)->soap_out(soap, tag, id, "s0:interfaceVersion");
	case SOAP_TYPE_s0__serverState_:
		return ((s0__serverState_ *)ptr)->soap_out(soap, tag, id, "s0:serverState");
	case SOAP_TYPE__s0__GetPropertiesResponse:
		return ((_s0__GetPropertiesResponse *)ptr)->soap_out(soap, "s0:GetPropertiesResponse", id, NULL);
	case SOAP_TYPE__s0__GetProperties:
		return ((_s0__GetProperties *)ptr)->soap_out(soap, "s0:GetProperties", id, NULL);
	case SOAP_TYPE__s0__BrowseResponse:
		return ((_s0__BrowseResponse *)ptr)->soap_out(soap, "s0:BrowseResponse", id, NULL);
	case SOAP_TYPE__s0__Browse:
		return ((_s0__Browse *)ptr)->soap_out(soap, "s0:Browse", id, NULL);
	case SOAP_TYPE__s0__SubscriptionCancelResponse:
		return ((_s0__SubscriptionCancelResponse *)ptr)->soap_out(soap, "s0:SubscriptionCancelResponse", id, NULL);
	case SOAP_TYPE__s0__SubscriptionCancel:
		return ((_s0__SubscriptionCancel *)ptr)->soap_out(soap, "s0:SubscriptionCancel", id, NULL);
	case SOAP_TYPE__s0__SubscriptionPolledRefreshResponse:
		return ((_s0__SubscriptionPolledRefreshResponse *)ptr)->soap_out(soap, "s0:SubscriptionPolledRefreshResponse", id, NULL);
	case SOAP_TYPE__s0__SubscriptionPolledRefresh:
		return ((_s0__SubscriptionPolledRefresh *)ptr)->soap_out(soap, "s0:SubscriptionPolledRefresh", id, NULL);
	case SOAP_TYPE__s0__SubscribeResponse:
		return ((_s0__SubscribeResponse *)ptr)->soap_out(soap, "s0:SubscribeResponse", id, NULL);
	case SOAP_TYPE__s0__Subscribe:
		return ((_s0__Subscribe *)ptr)->soap_out(soap, "s0:Subscribe", id, NULL);
	case SOAP_TYPE__s0__WriteResponse:
		return ((_s0__WriteResponse *)ptr)->soap_out(soap, "s0:WriteResponse", id, NULL);
	case SOAP_TYPE__s0__Write:
		return ((_s0__Write *)ptr)->soap_out(soap, "s0:Write", id, NULL);
	case SOAP_TYPE__s0__ReadResponse:
		return ((_s0__ReadResponse *)ptr)->soap_out(soap, "s0:ReadResponse", id, NULL);
	case SOAP_TYPE__s0__Read:
		return ((_s0__Read *)ptr)->soap_out(soap, "s0:Read", id, NULL);
	case SOAP_TYPE__s0__GetStatusResponse:
		return ((_s0__GetStatusResponse *)ptr)->soap_out(soap, "s0:GetStatusResponse", id, NULL);
	case SOAP_TYPE__s0__GetStatus:
		return ((_s0__GetStatus *)ptr)->soap_out(soap, "s0:GetStatus", id, NULL);
	case SOAP_TYPE_s0__PropertyReplyList:
		return ((s0__PropertyReplyList *)ptr)->soap_out(soap, tag, id, "s0:PropertyReplyList");
	case SOAP_TYPE_s0__ItemIdentifier:
		return ((s0__ItemIdentifier *)ptr)->soap_out(soap, tag, id, "s0:ItemIdentifier");
	case SOAP_TYPE_s0__ItemProperty:
		return ((s0__ItemProperty *)ptr)->soap_out(soap, tag, id, "s0:ItemProperty");
	case SOAP_TYPE_s0__BrowseElement:
		return ((s0__BrowseElement *)ptr)->soap_out(soap, tag, id, "s0:BrowseElement");
	case SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList:
		return ((s0__SubscribePolledRefreshReplyItemList *)ptr)->soap_out(soap, tag, id, "s0:SubscribePolledRefreshReplyItemList");
	case SOAP_TYPE_s0__SubscribeItemValue:
		return ((s0__SubscribeItemValue *)ptr)->soap_out(soap, tag, id, "s0:SubscribeItemValue");
	case SOAP_TYPE_s0__SubscribeReplyItemList:
		return ((s0__SubscribeReplyItemList *)ptr)->soap_out(soap, tag, id, "s0:SubscribeReplyItemList");
	case SOAP_TYPE_s0__SubscribeRequestItem:
		return ((s0__SubscribeRequestItem *)ptr)->soap_out(soap, tag, id, "s0:SubscribeRequestItem");
	case SOAP_TYPE_s0__SubscribeRequestItemList:
		return ((s0__SubscribeRequestItemList *)ptr)->soap_out(soap, tag, id, "s0:SubscribeRequestItemList");
	case SOAP_TYPE_s0__WriteRequestItemList:
		return ((s0__WriteRequestItemList *)ptr)->soap_out(soap, tag, id, "s0:WriteRequestItemList");
	case SOAP_TYPE_s0__ArrayOfShort:
		return ((s0__ArrayOfShort *)ptr)->soap_out(soap, tag, id, "s0:ArrayOfShort");
	case SOAP_TYPE_s0__ArrayOfByte:
		return ((s0__ArrayOfByte *)ptr)->soap_out(soap, tag, id, "s0:ArrayOfByte");
	case SOAP_TYPE_s0__ArrayOfDecimal:
		return ((s0__ArrayOfDecimal *)ptr)->soap_out(soap, tag, id, "s0:ArrayOfDecimal");
	case SOAP_TYPE_s0__ArrayOfAnyType:
		return ((s0__ArrayOfAnyType *)ptr)->soap_out(soap, tag, id, "s0:ArrayOfAnyType");
	case SOAP_TYPE_s0__ArrayOfDateTime:
		return ((s0__ArrayOfDateTime *)ptr)->soap_out(soap, tag, id, "s0:ArrayOfDateTime");
	case SOAP_TYPE_s0__ArrayOfString:
		return ((s0__ArrayOfString *)ptr)->soap_out(soap, tag, id, "s0:ArrayOfString");
	case SOAP_TYPE_s0__ArrayOfBoolean:
		return ((s0__ArrayOfBoolean *)ptr)->soap_out(soap, tag, id, "s0:ArrayOfBoolean");
	case SOAP_TYPE_s0__ArrayOfUnsignedShort:
		return ((s0__ArrayOfUnsignedShort *)ptr)->soap_out(soap, tag, id, "s0:ArrayOfUnsignedShort");
	case SOAP_TYPE_s0__ArrayOfDouble:
		return ((s0__ArrayOfDouble *)ptr)->soap_out(soap, tag, id, "s0:ArrayOfDouble");
	case SOAP_TYPE_s0__ArrayOfUnsignedLong:
		return ((s0__ArrayOfUnsignedLong *)ptr)->soap_out(soap, tag, id, "s0:ArrayOfUnsignedLong");
	case SOAP_TYPE_s0__ArrayOfLong:
		return ((s0__ArrayOfLong *)ptr)->soap_out(soap, tag, id, "s0:ArrayOfLong");
	case SOAP_TYPE_s0__ArrayOfUnsignedInt:
		return ((s0__ArrayOfUnsignedInt *)ptr)->soap_out(soap, tag, id, "s0:ArrayOfUnsignedInt");
	case SOAP_TYPE_s0__ArrayOfInt:
		return ((s0__ArrayOfInt *)ptr)->soap_out(soap, tag, id, "s0:ArrayOfInt");
	case SOAP_TYPE_s0__ArrayOfFloat:
		return ((s0__ArrayOfFloat *)ptr)->soap_out(soap, tag, id, "s0:ArrayOfFloat");
	case SOAP_TYPE_s0__OPCError:
		return ((s0__OPCError *)ptr)->soap_out(soap, tag, id, "s0:OPCError");
	case SOAP_TYPE_s0__OPCQuality:
		return ((s0__OPCQuality *)ptr)->soap_out(soap, tag, id, "s0:OPCQuality");
	case SOAP_TYPE_s0__Value:
		return ((s0__Value *)ptr)->soap_out(soap, tag, id, "s0:Value");
	case SOAP_TYPE_s0__ItemValue:
		return ((s0__ItemValue *)ptr)->soap_out(soap, tag, id, "s0:ItemValue");
	case SOAP_TYPE_s0__ReplyItemList:
		return ((s0__ReplyItemList *)ptr)->soap_out(soap, tag, id, "s0:ReplyItemList");
	case SOAP_TYPE_s0__ReadRequestItem:
		return ((s0__ReadRequestItem *)ptr)->soap_out(soap, tag, id, "s0:ReadRequestItem");
	case SOAP_TYPE_s0__ReadRequestItemList:
		return ((s0__ReadRequestItemList *)ptr)->soap_out(soap, tag, id, "s0:ReadRequestItemList");
	case SOAP_TYPE_s0__RequestOptions:
		return ((s0__RequestOptions *)ptr)->soap_out(soap, tag, id, "s0:RequestOptions");
	case SOAP_TYPE_s0__ServerStatus:
		return ((s0__ServerStatus *)ptr)->soap_out(soap, tag, id, "s0:ServerStatus");
	case SOAP_TYPE_s0__ReplyBase:
		return ((s0__ReplyBase *)ptr)->soap_out(soap, tag, id, "s0:ReplyBase");
	case SOAP_TYPE_xsd__unsignedShort:
		return ((xsd__unsignedShort *)ptr)->soap_out(soap, tag, id, "xsd:unsignedShort");
	case SOAP_TYPE_xsd__unsignedLong:
		return ((xsd__unsignedLong *)ptr)->soap_out(soap, tag, id, "xsd:unsignedLong");
	case SOAP_TYPE_xsd__unsignedInt:
		return ((xsd__unsignedInt *)ptr)->soap_out(soap, tag, id, "xsd:unsignedInt");
	case SOAP_TYPE_xsd__unsignedByte:
		return ((xsd__unsignedByte *)ptr)->soap_out(soap, tag, id, "xsd:unsignedByte");
	case SOAP_TYPE_xsd__string:
		return ((xsd__string *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_xsd__short:
		return ((xsd__short *)ptr)->soap_out(soap, tag, id, "xsd:short");
	case SOAP_TYPE_xsd__long:
		return ((xsd__long *)ptr)->soap_out(soap, tag, id, "xsd:long");
	case SOAP_TYPE_xsd__int:
		return ((xsd__int *)ptr)->soap_out(soap, tag, id, "xsd:int");
	case SOAP_TYPE_xsd__float:
		return ((xsd__float *)ptr)->soap_out(soap, tag, id, "xsd:float");
	case SOAP_TYPE_xsd__double:
		return ((xsd__double *)ptr)->soap_out(soap, tag, id, "xsd:double");
	case SOAP_TYPE_xsd__decimal_:
		return ((xsd__decimal_ *)ptr)->soap_out(soap, tag, id, "xsd:decimal");
	case SOAP_TYPE_xsd__decimal:
		return soap_out_xsd__decimal(soap, tag, id, (const std::string *)ptr, "xsd:decimal");
	case SOAP_TYPE_xsd__dateTime:
		return ((xsd__dateTime *)ptr)->soap_out(soap, tag, id, "xsd:dateTime");
	case SOAP_TYPE_xsd__byte:
		return ((xsd__byte *)ptr)->soap_out(soap, tag, id, "xsd:byte");
	case SOAP_TYPE_xsd__boolean:
		return ((xsd__boolean *)ptr)->soap_out(soap, tag, id, "xsd:boolean");
	case SOAP_TYPE_xsd__QName_:
		return ((xsd__QName_ *)ptr)->soap_out(soap, tag, id, "xsd:QName");
	case SOAP_TYPE_xsd__QName:
		return soap_out_xsd__QName(soap, tag, id, (const std::string *)ptr, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_xsd__anyType:
		return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
	case SOAP_TYPE_PointerTo_s0__GetPropertiesResponse:
		return soap_out_PointerTo_s0__GetPropertiesResponse(soap, tag, id, (_s0__GetPropertiesResponse *const*)ptr, "s0:GetPropertiesResponse");
	case SOAP_TYPE_PointerTo_s0__GetProperties:
		return soap_out_PointerTo_s0__GetProperties(soap, tag, id, (_s0__GetProperties *const*)ptr, "s0:GetProperties");
	case SOAP_TYPE_PointerTo_s0__BrowseResponse:
		return soap_out_PointerTo_s0__BrowseResponse(soap, tag, id, (_s0__BrowseResponse *const*)ptr, "s0:BrowseResponse");
	case SOAP_TYPE_PointerTo_s0__Browse:
		return soap_out_PointerTo_s0__Browse(soap, tag, id, (_s0__Browse *const*)ptr, "s0:Browse");
	case SOAP_TYPE_PointerTo_s0__SubscriptionCancelResponse:
		return soap_out_PointerTo_s0__SubscriptionCancelResponse(soap, tag, id, (_s0__SubscriptionCancelResponse *const*)ptr, "s0:SubscriptionCancelResponse");
	case SOAP_TYPE_PointerTo_s0__SubscriptionCancel:
		return soap_out_PointerTo_s0__SubscriptionCancel(soap, tag, id, (_s0__SubscriptionCancel *const*)ptr, "s0:SubscriptionCancel");
	case SOAP_TYPE_PointerTo_s0__SubscriptionPolledRefreshResponse:
		return soap_out_PointerTo_s0__SubscriptionPolledRefreshResponse(soap, tag, id, (_s0__SubscriptionPolledRefreshResponse *const*)ptr, "s0:SubscriptionPolledRefreshResponse");
	case SOAP_TYPE_PointerTo_s0__SubscriptionPolledRefresh:
		return soap_out_PointerTo_s0__SubscriptionPolledRefresh(soap, tag, id, (_s0__SubscriptionPolledRefresh *const*)ptr, "s0:SubscriptionPolledRefresh");
	case SOAP_TYPE_PointerTo_s0__SubscribeResponse:
		return soap_out_PointerTo_s0__SubscribeResponse(soap, tag, id, (_s0__SubscribeResponse *const*)ptr, "s0:SubscribeResponse");
	case SOAP_TYPE_PointerTo_s0__Subscribe:
		return soap_out_PointerTo_s0__Subscribe(soap, tag, id, (_s0__Subscribe *const*)ptr, "s0:Subscribe");
	case SOAP_TYPE_PointerTo_s0__WriteResponse:
		return soap_out_PointerTo_s0__WriteResponse(soap, tag, id, (_s0__WriteResponse *const*)ptr, "s0:WriteResponse");
	case SOAP_TYPE_PointerTo_s0__Write:
		return soap_out_PointerTo_s0__Write(soap, tag, id, (_s0__Write *const*)ptr, "s0:Write");
	case SOAP_TYPE_PointerTo_s0__ReadResponse:
		return soap_out_PointerTo_s0__ReadResponse(soap, tag, id, (_s0__ReadResponse *const*)ptr, "s0:ReadResponse");
	case SOAP_TYPE_PointerTo_s0__Read:
		return soap_out_PointerTo_s0__Read(soap, tag, id, (_s0__Read *const*)ptr, "s0:Read");
	case SOAP_TYPE_PointerTo_s0__GetStatusResponse:
		return soap_out_PointerTo_s0__GetStatusResponse(soap, tag, id, (_s0__GetStatusResponse *const*)ptr, "s0:GetStatusResponse");
	case SOAP_TYPE_PointerTo_s0__GetStatus:
		return soap_out_PointerTo_s0__GetStatus(soap, tag, id, (_s0__GetStatus *const*)ptr, "s0:GetStatus");
	case SOAP_TYPE_PointerTos0__PropertyReplyList:
		return soap_out_PointerTos0__PropertyReplyList(soap, tag, id, (s0__PropertyReplyList *const*)ptr, "s0:PropertyReplyList");
	case SOAP_TYPE_PointerTos0__ItemIdentifier:
		return soap_out_PointerTos0__ItemIdentifier(soap, tag, id, (s0__ItemIdentifier *const*)ptr, "s0:ItemIdentifier");
	case SOAP_TYPE_PointerTos0__BrowseElement:
		return soap_out_PointerTos0__BrowseElement(soap, tag, id, (s0__BrowseElement *const*)ptr, "s0:BrowseElement");
	case SOAP_TYPE_PointerTos0__browseFilter:
		return soap_out_PointerTos0__browseFilter(soap, tag, id, (enum s0__browseFilter *const*)ptr, "s0:browseFilter");
	case SOAP_TYPE_PointerTos0__SubscribePolledRefreshReplyItemList:
		return soap_out_PointerTos0__SubscribePolledRefreshReplyItemList(soap, tag, id, (s0__SubscribePolledRefreshReplyItemList *const*)ptr, "s0:SubscribePolledRefreshReplyItemList");
	case SOAP_TYPE_PointerTos0__SubscribeReplyItemList:
		return soap_out_PointerTos0__SubscribeReplyItemList(soap, tag, id, (s0__SubscribeReplyItemList *const*)ptr, "s0:SubscribeReplyItemList");
	case SOAP_TYPE_PointerTos0__SubscribeRequestItemList:
		return soap_out_PointerTos0__SubscribeRequestItemList(soap, tag, id, (s0__SubscribeRequestItemList *const*)ptr, "s0:SubscribeRequestItemList");
	case SOAP_TYPE_PointerTos0__WriteRequestItemList:
		return soap_out_PointerTos0__WriteRequestItemList(soap, tag, id, (s0__WriteRequestItemList *const*)ptr, "s0:WriteRequestItemList");
	case SOAP_TYPE_PointerTos0__OPCError:
		return soap_out_PointerTos0__OPCError(soap, tag, id, (s0__OPCError *const*)ptr, "s0:OPCError");
	case SOAP_TYPE_PointerTos0__ReplyItemList:
		return soap_out_PointerTos0__ReplyItemList(soap, tag, id, (s0__ReplyItemList *const*)ptr, "s0:ReplyItemList");
	case SOAP_TYPE_PointerTos0__ReadRequestItemList:
		return soap_out_PointerTos0__ReadRequestItemList(soap, tag, id, (s0__ReadRequestItemList *const*)ptr, "s0:ReadRequestItemList");
	case SOAP_TYPE_PointerTos0__RequestOptions:
		return soap_out_PointerTos0__RequestOptions(soap, tag, id, (s0__RequestOptions *const*)ptr, "s0:RequestOptions");
	case SOAP_TYPE_PointerTos0__ServerStatus:
		return soap_out_PointerTos0__ServerStatus(soap, tag, id, (s0__ServerStatus *const*)ptr, "s0:ServerStatus");
	case SOAP_TYPE_PointerTos0__ReplyBase:
		return soap_out_PointerTos0__ReplyBase(soap, tag, id, (s0__ReplyBase *const*)ptr, "s0:ReplyBase");
	case SOAP_TYPE_PointerTos0__ItemProperty:
		return soap_out_PointerTos0__ItemProperty(soap, tag, id, (s0__ItemProperty *const*)ptr, "s0:ItemProperty");
	case SOAP_TYPE_PointerTos0__SubscribeItemValue:
		return soap_out_PointerTos0__SubscribeItemValue(soap, tag, id, (s0__SubscribeItemValue *const*)ptr, "s0:SubscribeItemValue");
	case SOAP_TYPE_PointerTofloat:
		return soap_out_PointerTofloat(soap, tag, id, (float *const*)ptr, "xsd:float");
	case SOAP_TYPE_PointerTos0__SubscribeRequestItem:
		return soap_out_PointerTos0__SubscribeRequestItem(soap, tag, id, (s0__SubscribeRequestItem *const*)ptr, "s0:SubscribeRequestItem");
	case SOAP_TYPE_PointerTounsignedShort:
		return soap_out_PointerTounsignedShort(soap, tag, id, (unsigned short *const*)ptr, "xsd:unsignedShort");
	case SOAP_TYPE_PointerTos0__limitBits:
		return soap_out_PointerTos0__limitBits(soap, tag, id, (enum s0__limitBits *const*)ptr, "s0:limitBits");
	case SOAP_TYPE_PointerTos0__qualityBits:
		return soap_out_PointerTos0__qualityBits(soap, tag, id, (enum s0__qualityBits *const*)ptr, "s0:qualityBits");
	case SOAP_TYPE_PointerTos0__OPCQuality:
		return soap_out_PointerTos0__OPCQuality(soap, tag, id, (s0__OPCQuality *const*)ptr, "s0:OPCQuality");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_out_PointerToxsd__anyType(soap, tag, id, (xsd__anyType *const*)ptr, "xsd:anyType");
	case SOAP_TYPE_PointerTos0__ItemValue:
		return soap_out_PointerTos0__ItemValue(soap, tag, id, (s0__ItemValue *const*)ptr, "s0:ItemValue");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerToxsd__QName:
		return soap_out_PointerToxsd__QName(soap, tag, id, (std::string *const*)ptr, "xsd:QName");
	case SOAP_TYPE_PointerTos0__ReadRequestItem:
		return soap_out_PointerTos0__ReadRequestItem(soap, tag, id, (s0__ReadRequestItem *const*)ptr, "s0:ReadRequestItem");
	case SOAP_TYPE_PointerToxsd__dateTime:
		return soap_out_PointerToxsd__dateTime(soap, tag, id, (xsd__dateTime *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_s0__browseFilter_:
		((s0__browseFilter_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__limitBits_:
		((s0__limitBits_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__qualityBits_:
		((s0__qualityBits_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__interfaceVersion_:
		((s0__interfaceVersion_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__serverState_:
		((s0__serverState_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__s0__GetPropertiesResponse:
		((_s0__GetPropertiesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__s0__GetProperties:
		((_s0__GetProperties *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__s0__BrowseResponse:
		((_s0__BrowseResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__s0__Browse:
		((_s0__Browse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__s0__SubscriptionCancelResponse:
		((_s0__SubscriptionCancelResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__s0__SubscriptionCancel:
		((_s0__SubscriptionCancel *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__s0__SubscriptionPolledRefreshResponse:
		((_s0__SubscriptionPolledRefreshResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__s0__SubscriptionPolledRefresh:
		((_s0__SubscriptionPolledRefresh *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__s0__SubscribeResponse:
		((_s0__SubscribeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__s0__Subscribe:
		((_s0__Subscribe *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__s0__WriteResponse:
		((_s0__WriteResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__s0__Write:
		((_s0__Write *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__s0__ReadResponse:
		((_s0__ReadResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__s0__Read:
		((_s0__Read *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__s0__GetStatusResponse:
		((_s0__GetStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__s0__GetStatus:
		((_s0__GetStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__PropertyReplyList:
		((s0__PropertyReplyList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ItemIdentifier:
		((s0__ItemIdentifier *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ItemProperty:
		((s0__ItemProperty *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__BrowseElement:
		((s0__BrowseElement *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList:
		((s0__SubscribePolledRefreshReplyItemList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__SubscribeItemValue:
		((s0__SubscribeItemValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__SubscribeReplyItemList:
		((s0__SubscribeReplyItemList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__SubscribeRequestItem:
		((s0__SubscribeRequestItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__SubscribeRequestItemList:
		((s0__SubscribeRequestItemList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__WriteRequestItemList:
		((s0__WriteRequestItemList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ArrayOfShort:
		((s0__ArrayOfShort *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ArrayOfByte:
		((s0__ArrayOfByte *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ArrayOfDecimal:
		((s0__ArrayOfDecimal *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ArrayOfAnyType:
		((s0__ArrayOfAnyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ArrayOfDateTime:
		((s0__ArrayOfDateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ArrayOfString:
		((s0__ArrayOfString *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ArrayOfBoolean:
		((s0__ArrayOfBoolean *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ArrayOfUnsignedShort:
		((s0__ArrayOfUnsignedShort *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ArrayOfDouble:
		((s0__ArrayOfDouble *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ArrayOfUnsignedLong:
		((s0__ArrayOfUnsignedLong *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ArrayOfLong:
		((s0__ArrayOfLong *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ArrayOfUnsignedInt:
		((s0__ArrayOfUnsignedInt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ArrayOfInt:
		((s0__ArrayOfInt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ArrayOfFloat:
		((s0__ArrayOfFloat *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__OPCError:
		((s0__OPCError *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__OPCQuality:
		((s0__OPCQuality *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__Value:
		((s0__Value *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ItemValue:
		((s0__ItemValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ReplyItemList:
		((s0__ReplyItemList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ReadRequestItem:
		((s0__ReadRequestItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ReadRequestItemList:
		((s0__ReadRequestItemList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__RequestOptions:
		((s0__RequestOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ServerStatus:
		((s0__ServerStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_s0__ReplyBase:
		((s0__ReplyBase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__unsignedShort:
		((xsd__unsignedShort *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__unsignedLong:
		((xsd__unsignedLong *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__unsignedInt:
		((xsd__unsignedInt *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__unsignedByte:
		((xsd__unsignedByte *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__string:
		((xsd__string *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__short:
		((xsd__short *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__long:
		((xsd__long *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__int:
		((xsd__int *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__float:
		((xsd__float *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__double:
		((xsd__double *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__decimal_:
		((xsd__decimal_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__decimal:
		soap_serialize_xsd__decimal(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__dateTime:
		((xsd__dateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__byte:
		((xsd__byte *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__boolean:
		((xsd__boolean *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__QName_:
		((xsd__QName_ *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__QName:
		soap_serialize_xsd__QName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anyType:
		((xsd__anyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___s0__GetProperties:
		soap_serialize___s0__GetProperties(soap, (const struct __s0__GetProperties *)ptr);
		break;
	case SOAP_TYPE___s0__Browse:
		soap_serialize___s0__Browse(soap, (const struct __s0__Browse *)ptr);
		break;
	case SOAP_TYPE___s0__SubscriptionCancel:
		soap_serialize___s0__SubscriptionCancel(soap, (const struct __s0__SubscriptionCancel *)ptr);
		break;
	case SOAP_TYPE___s0__SubscriptionPolledRefresh:
		soap_serialize___s0__SubscriptionPolledRefresh(soap, (const struct __s0__SubscriptionPolledRefresh *)ptr);
		break;
	case SOAP_TYPE___s0__Subscribe:
		soap_serialize___s0__Subscribe(soap, (const struct __s0__Subscribe *)ptr);
		break;
	case SOAP_TYPE___s0__Write:
		soap_serialize___s0__Write(soap, (const struct __s0__Write *)ptr);
		break;
	case SOAP_TYPE___s0__Read:
		soap_serialize___s0__Read(soap, (const struct __s0__Read *)ptr);
		break;
	case SOAP_TYPE___s0__GetStatus:
		soap_serialize___s0__GetStatus(soap, (const struct __s0__GetStatus *)ptr);
		break;
	case SOAP_TYPE_PointerTo_s0__GetPropertiesResponse:
		soap_serialize_PointerTo_s0__GetPropertiesResponse(soap, (_s0__GetPropertiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_s0__GetProperties:
		soap_serialize_PointerTo_s0__GetProperties(soap, (_s0__GetProperties *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_s0__BrowseResponse:
		soap_serialize_PointerTo_s0__BrowseResponse(soap, (_s0__BrowseResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_s0__Browse:
		soap_serialize_PointerTo_s0__Browse(soap, (_s0__Browse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_s0__SubscriptionCancelResponse:
		soap_serialize_PointerTo_s0__SubscriptionCancelResponse(soap, (_s0__SubscriptionCancelResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_s0__SubscriptionCancel:
		soap_serialize_PointerTo_s0__SubscriptionCancel(soap, (_s0__SubscriptionCancel *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_s0__SubscriptionPolledRefreshResponse:
		soap_serialize_PointerTo_s0__SubscriptionPolledRefreshResponse(soap, (_s0__SubscriptionPolledRefreshResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_s0__SubscriptionPolledRefresh:
		soap_serialize_PointerTo_s0__SubscriptionPolledRefresh(soap, (_s0__SubscriptionPolledRefresh *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_s0__SubscribeResponse:
		soap_serialize_PointerTo_s0__SubscribeResponse(soap, (_s0__SubscribeResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_s0__Subscribe:
		soap_serialize_PointerTo_s0__Subscribe(soap, (_s0__Subscribe *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_s0__WriteResponse:
		soap_serialize_PointerTo_s0__WriteResponse(soap, (_s0__WriteResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_s0__Write:
		soap_serialize_PointerTo_s0__Write(soap, (_s0__Write *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_s0__ReadResponse:
		soap_serialize_PointerTo_s0__ReadResponse(soap, (_s0__ReadResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_s0__Read:
		soap_serialize_PointerTo_s0__Read(soap, (_s0__Read *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_s0__GetStatusResponse:
		soap_serialize_PointerTo_s0__GetStatusResponse(soap, (_s0__GetStatusResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_s0__GetStatus:
		soap_serialize_PointerTo_s0__GetStatus(soap, (_s0__GetStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__PropertyReplyList:
		soap_serialize_PointerTos0__PropertyReplyList(soap, (s0__PropertyReplyList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__ItemIdentifier:
		soap_serialize_PointerTos0__ItemIdentifier(soap, (s0__ItemIdentifier *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__BrowseElement:
		soap_serialize_PointerTos0__BrowseElement(soap, (s0__BrowseElement *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__browseFilter:
		soap_serialize_PointerTos0__browseFilter(soap, (enum s0__browseFilter *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__SubscribePolledRefreshReplyItemList:
		soap_serialize_PointerTos0__SubscribePolledRefreshReplyItemList(soap, (s0__SubscribePolledRefreshReplyItemList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__SubscribeReplyItemList:
		soap_serialize_PointerTos0__SubscribeReplyItemList(soap, (s0__SubscribeReplyItemList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__SubscribeRequestItemList:
		soap_serialize_PointerTos0__SubscribeRequestItemList(soap, (s0__SubscribeRequestItemList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__WriteRequestItemList:
		soap_serialize_PointerTos0__WriteRequestItemList(soap, (s0__WriteRequestItemList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__OPCError:
		soap_serialize_PointerTos0__OPCError(soap, (s0__OPCError *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__ReplyItemList:
		soap_serialize_PointerTos0__ReplyItemList(soap, (s0__ReplyItemList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__ReadRequestItemList:
		soap_serialize_PointerTos0__ReadRequestItemList(soap, (s0__ReadRequestItemList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__RequestOptions:
		soap_serialize_PointerTos0__RequestOptions(soap, (s0__RequestOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__ServerStatus:
		soap_serialize_PointerTos0__ServerStatus(soap, (s0__ServerStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__ReplyBase:
		soap_serialize_PointerTos0__ReplyBase(soap, (s0__ReplyBase *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__ItemProperty:
		soap_serialize_PointerTos0__ItemProperty(soap, (s0__ItemProperty *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__SubscribeItemValue:
		soap_serialize_PointerTos0__SubscribeItemValue(soap, (s0__SubscribeItemValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofloat:
		soap_serialize_PointerTofloat(soap, (float *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__SubscribeRequestItem:
		soap_serialize_PointerTos0__SubscribeRequestItem(soap, (s0__SubscribeRequestItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerTounsignedShort:
		soap_serialize_PointerTounsignedShort(soap, (unsigned short *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__limitBits:
		soap_serialize_PointerTos0__limitBits(soap, (enum s0__limitBits *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__qualityBits:
		soap_serialize_PointerTos0__qualityBits(soap, (enum s0__qualityBits *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__OPCQuality:
		soap_serialize_PointerTos0__OPCQuality(soap, (s0__OPCQuality *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyType:
		soap_serialize_PointerToxsd__anyType(soap, (xsd__anyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__ItemValue:
		soap_serialize_PointerTos0__ItemValue(soap, (s0__ItemValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__QName:
		soap_serialize_PointerToxsd__QName(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTos0__ReadRequestItem:
		soap_serialize_PointerTos0__ReadRequestItem(soap, (s0__ReadRequestItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__dateTime:
		soap_serialize_PointerToxsd__dateTime(soap, (xsd__dateTime *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__QName_:
		return (void*)soap_instantiate_xsd__QName_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__boolean:
		return (void*)soap_instantiate_xsd__boolean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__byte:
		return (void*)soap_instantiate_xsd__byte(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__dateTime:
		return (void*)soap_instantiate_xsd__dateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal_:
		return (void*)soap_instantiate_xsd__decimal_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__double:
		return (void*)soap_instantiate_xsd__double(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__float:
		return (void*)soap_instantiate_xsd__float(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__int:
		return (void*)soap_instantiate_xsd__int(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__long:
		return (void*)soap_instantiate_xsd__long(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__short:
		return (void*)soap_instantiate_xsd__short(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__string:
		return (void*)soap_instantiate_xsd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedByte:
		return (void*)soap_instantiate_xsd__unsignedByte(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedInt:
		return (void*)soap_instantiate_xsd__unsignedInt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedLong:
		return (void*)soap_instantiate_xsd__unsignedLong(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__unsignedShort:
		return (void*)soap_instantiate_xsd__unsignedShort(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__serverState_:
		return (void*)soap_instantiate_s0__serverState_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__interfaceVersion_:
		return (void*)soap_instantiate_s0__interfaceVersion_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__qualityBits_:
		return (void*)soap_instantiate_s0__qualityBits_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__limitBits_:
		return (void*)soap_instantiate_s0__limitBits_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__browseFilter_:
		return (void*)soap_instantiate_s0__browseFilter_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ReplyBase:
		return (void*)soap_instantiate_s0__ReplyBase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ServerStatus:
		return (void*)soap_instantiate_s0__ServerStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__RequestOptions:
		return (void*)soap_instantiate_s0__RequestOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ReadRequestItemList:
		return (void*)soap_instantiate_s0__ReadRequestItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ReadRequestItem:
		return (void*)soap_instantiate_s0__ReadRequestItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ReplyItemList:
		return (void*)soap_instantiate_s0__ReplyItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ItemValue:
		return (void*)soap_instantiate_s0__ItemValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__Value:
		return (void*)soap_instantiate_s0__Value(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__OPCQuality:
		return (void*)soap_instantiate_s0__OPCQuality(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__OPCError:
		return (void*)soap_instantiate_s0__OPCError(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ArrayOfFloat:
		return (void*)soap_instantiate_s0__ArrayOfFloat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ArrayOfInt:
		return (void*)soap_instantiate_s0__ArrayOfInt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ArrayOfUnsignedInt:
		return (void*)soap_instantiate_s0__ArrayOfUnsignedInt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ArrayOfLong:
		return (void*)soap_instantiate_s0__ArrayOfLong(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ArrayOfUnsignedLong:
		return (void*)soap_instantiate_s0__ArrayOfUnsignedLong(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ArrayOfDouble:
		return (void*)soap_instantiate_s0__ArrayOfDouble(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ArrayOfUnsignedShort:
		return (void*)soap_instantiate_s0__ArrayOfUnsignedShort(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ArrayOfBoolean:
		return (void*)soap_instantiate_s0__ArrayOfBoolean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ArrayOfString:
		return (void*)soap_instantiate_s0__ArrayOfString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ArrayOfDateTime:
		return (void*)soap_instantiate_s0__ArrayOfDateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ArrayOfAnyType:
		return (void*)soap_instantiate_s0__ArrayOfAnyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ArrayOfDecimal:
		return (void*)soap_instantiate_s0__ArrayOfDecimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ArrayOfByte:
		return (void*)soap_instantiate_s0__ArrayOfByte(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ArrayOfShort:
		return (void*)soap_instantiate_s0__ArrayOfShort(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__WriteRequestItemList:
		return (void*)soap_instantiate_s0__WriteRequestItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__SubscribeRequestItemList:
		return (void*)soap_instantiate_s0__SubscribeRequestItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__SubscribeRequestItem:
		return (void*)soap_instantiate_s0__SubscribeRequestItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__SubscribeReplyItemList:
		return (void*)soap_instantiate_s0__SubscribeReplyItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__SubscribeItemValue:
		return (void*)soap_instantiate_s0__SubscribeItemValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList:
		return (void*)soap_instantiate_s0__SubscribePolledRefreshReplyItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__BrowseElement:
		return (void*)soap_instantiate_s0__BrowseElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ItemProperty:
		return (void*)soap_instantiate_s0__ItemProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__ItemIdentifier:
		return (void*)soap_instantiate_s0__ItemIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_s0__PropertyReplyList:
		return (void*)soap_instantiate_s0__PropertyReplyList(soap, -1, type, arrayType, n);
	case SOAP_TYPE__s0__GetStatus:
		return (void*)soap_instantiate__s0__GetStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE__s0__GetStatusResponse:
		return (void*)soap_instantiate__s0__GetStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__s0__Read:
		return (void*)soap_instantiate__s0__Read(soap, -1, type, arrayType, n);
	case SOAP_TYPE__s0__ReadResponse:
		return (void*)soap_instantiate__s0__ReadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__s0__Write:
		return (void*)soap_instantiate__s0__Write(soap, -1, type, arrayType, n);
	case SOAP_TYPE__s0__WriteResponse:
		return (void*)soap_instantiate__s0__WriteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__s0__Subscribe:
		return (void*)soap_instantiate__s0__Subscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE__s0__SubscribeResponse:
		return (void*)soap_instantiate__s0__SubscribeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__s0__SubscriptionPolledRefresh:
		return (void*)soap_instantiate__s0__SubscriptionPolledRefresh(soap, -1, type, arrayType, n);
	case SOAP_TYPE__s0__SubscriptionPolledRefreshResponse:
		return (void*)soap_instantiate__s0__SubscriptionPolledRefreshResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__s0__SubscriptionCancel:
		return (void*)soap_instantiate__s0__SubscriptionCancel(soap, -1, type, arrayType, n);
	case SOAP_TYPE__s0__SubscriptionCancelResponse:
		return (void*)soap_instantiate__s0__SubscriptionCancelResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__s0__Browse:
		return (void*)soap_instantiate__s0__Browse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__s0__BrowseResponse:
		return (void*)soap_instantiate__s0__BrowseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__s0__GetProperties:
		return (void*)soap_instantiate__s0__GetProperties(soap, -1, type, arrayType, n);
	case SOAP_TYPE__s0__GetPropertiesResponse:
		return (void*)soap_instantiate__s0__GetPropertiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___s0__GetStatus:
		return (void*)soap_instantiate___s0__GetStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___s0__Read:
		return (void*)soap_instantiate___s0__Read(soap, -1, type, arrayType, n);
	case SOAP_TYPE___s0__Write:
		return (void*)soap_instantiate___s0__Write(soap, -1, type, arrayType, n);
	case SOAP_TYPE___s0__Subscribe:
		return (void*)soap_instantiate___s0__Subscribe(soap, -1, type, arrayType, n);
	case SOAP_TYPE___s0__SubscriptionPolledRefresh:
		return (void*)soap_instantiate___s0__SubscriptionPolledRefresh(soap, -1, type, arrayType, n);
	case SOAP_TYPE___s0__SubscriptionCancel:
		return (void*)soap_instantiate___s0__SubscriptionCancel(soap, -1, type, arrayType, n);
	case SOAP_TYPE___s0__Browse:
		return (void*)soap_instantiate___s0__Browse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___s0__GetProperties:
		return (void*)soap_instantiate___s0__GetProperties(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__QName:
		return (void*)soap_instantiate_xsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__decimal:
		return (void*)soap_instantiate_xsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__PropertyReplyList:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTos0__PropertyReplyList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemIdentifier:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTos0__ItemIdentifier(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__BrowseElement:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTos0__BrowseElement(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__OPCError:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTos0__OPCError(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemProperty:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTos0__ItemProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribeItemValue:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribeItemValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribeRequestItem:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfshort:
		return (void*)soap_instantiate_std__vectorTemplateOfshort(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfbyte:
		return (void*)soap_instantiate_std__vectorTemplateOfbyte(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfxsd__decimal:
		return (void*)soap_instantiate_std__vectorTemplateOfxsd__decimal(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		return (void*)soap_instantiate_std__vectorTemplateOf_XML(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfbool:
		return (void*)soap_instantiate_std__vectorTemplateOfbool(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfunsignedShort:
		return (void*)soap_instantiate_std__vectorTemplateOfunsignedShort(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfdouble:
		return (void*)soap_instantiate_std__vectorTemplateOfdouble(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfunsignedLONG64:
		return (void*)soap_instantiate_std__vectorTemplateOfunsignedLONG64(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfLONG64:
		return (void*)soap_instantiate_std__vectorTemplateOfLONG64(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfunsignedInt:
		return (void*)soap_instantiate_std__vectorTemplateOfunsignedInt(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfint:
		return (void*)soap_instantiate_std__vectorTemplateOfint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOffloat:
		return (void*)soap_instantiate_std__vectorTemplateOffloat(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemValue:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTos0__ItemValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ReadRequestItem:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTos0__ReadRequestItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfs0__interfaceVersion:
		return (void*)soap_instantiate_std__vectorTemplateOfs0__interfaceVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			delete (xsd__anyType*)p->ptr;
		else
			delete[] (xsd__anyType*)p->ptr;
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_xsd__QName_:
		if (p->size < 0)
			delete (xsd__QName_*)p->ptr;
		else
			delete[] (xsd__QName_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__boolean:
		if (p->size < 0)
			delete (xsd__boolean*)p->ptr;
		else
			delete[] (xsd__boolean*)p->ptr;
		break;
	case SOAP_TYPE_xsd__byte:
		if (p->size < 0)
			delete (xsd__byte*)p->ptr;
		else
			delete[] (xsd__byte*)p->ptr;
		break;
	case SOAP_TYPE_xsd__dateTime:
		if (p->size < 0)
			delete (xsd__dateTime*)p->ptr;
		else
			delete[] (xsd__dateTime*)p->ptr;
		break;
	case SOAP_TYPE_xsd__decimal_:
		if (p->size < 0)
			delete (xsd__decimal_*)p->ptr;
		else
			delete[] (xsd__decimal_*)p->ptr;
		break;
	case SOAP_TYPE_xsd__double:
		if (p->size < 0)
			delete (xsd__double*)p->ptr;
		else
			delete[] (xsd__double*)p->ptr;
		break;
	case SOAP_TYPE_xsd__float:
		if (p->size < 0)
			delete (xsd__float*)p->ptr;
		else
			delete[] (xsd__float*)p->ptr;
		break;
	case SOAP_TYPE_xsd__int:
		if (p->size < 0)
			delete (xsd__int*)p->ptr;
		else
			delete[] (xsd__int*)p->ptr;
		break;
	case SOAP_TYPE_xsd__long:
		if (p->size < 0)
			delete (xsd__long*)p->ptr;
		else
			delete[] (xsd__long*)p->ptr;
		break;
	case SOAP_TYPE_xsd__short:
		if (p->size < 0)
			delete (xsd__short*)p->ptr;
		else
			delete[] (xsd__short*)p->ptr;
		break;
	case SOAP_TYPE_xsd__string:
		if (p->size < 0)
			delete (xsd__string*)p->ptr;
		else
			delete[] (xsd__string*)p->ptr;
		break;
	case SOAP_TYPE_xsd__unsignedByte:
		if (p->size < 0)
			delete (xsd__unsignedByte*)p->ptr;
		else
			delete[] (xsd__unsignedByte*)p->ptr;
		break;
	case SOAP_TYPE_xsd__unsignedInt:
		if (p->size < 0)
			delete (xsd__unsignedInt*)p->ptr;
		else
			delete[] (xsd__unsignedInt*)p->ptr;
		break;
	case SOAP_TYPE_xsd__unsignedLong:
		if (p->size < 0)
			delete (xsd__unsignedLong*)p->ptr;
		else
			delete[] (xsd__unsignedLong*)p->ptr;
		break;
	case SOAP_TYPE_xsd__unsignedShort:
		if (p->size < 0)
			delete (xsd__unsignedShort*)p->ptr;
		else
			delete[] (xsd__unsignedShort*)p->ptr;
		break;
	case SOAP_TYPE_s0__serverState_:
		if (p->size < 0)
			delete (s0__serverState_*)p->ptr;
		else
			delete[] (s0__serverState_*)p->ptr;
		break;
	case SOAP_TYPE_s0__interfaceVersion_:
		if (p->size < 0)
			delete (s0__interfaceVersion_*)p->ptr;
		else
			delete[] (s0__interfaceVersion_*)p->ptr;
		break;
	case SOAP_TYPE_s0__qualityBits_:
		if (p->size < 0)
			delete (s0__qualityBits_*)p->ptr;
		else
			delete[] (s0__qualityBits_*)p->ptr;
		break;
	case SOAP_TYPE_s0__limitBits_:
		if (p->size < 0)
			delete (s0__limitBits_*)p->ptr;
		else
			delete[] (s0__limitBits_*)p->ptr;
		break;
	case SOAP_TYPE_s0__browseFilter_:
		if (p->size < 0)
			delete (s0__browseFilter_*)p->ptr;
		else
			delete[] (s0__browseFilter_*)p->ptr;
		break;
	case SOAP_TYPE_s0__ReplyBase:
		if (p->size < 0)
			delete (s0__ReplyBase*)p->ptr;
		else
			delete[] (s0__ReplyBase*)p->ptr;
		break;
	case SOAP_TYPE_s0__ServerStatus:
		if (p->size < 0)
			delete (s0__ServerStatus*)p->ptr;
		else
			delete[] (s0__ServerStatus*)p->ptr;
		break;
	case SOAP_TYPE_s0__RequestOptions:
		if (p->size < 0)
			delete (s0__RequestOptions*)p->ptr;
		else
			delete[] (s0__RequestOptions*)p->ptr;
		break;
	case SOAP_TYPE_s0__ReadRequestItemList:
		if (p->size < 0)
			delete (s0__ReadRequestItemList*)p->ptr;
		else
			delete[] (s0__ReadRequestItemList*)p->ptr;
		break;
	case SOAP_TYPE_s0__ReadRequestItem:
		if (p->size < 0)
			delete (s0__ReadRequestItem*)p->ptr;
		else
			delete[] (s0__ReadRequestItem*)p->ptr;
		break;
	case SOAP_TYPE_s0__ReplyItemList:
		if (p->size < 0)
			delete (s0__ReplyItemList*)p->ptr;
		else
			delete[] (s0__ReplyItemList*)p->ptr;
		break;
	case SOAP_TYPE_s0__ItemValue:
		if (p->size < 0)
			delete (s0__ItemValue*)p->ptr;
		else
			delete[] (s0__ItemValue*)p->ptr;
		break;
	case SOAP_TYPE_s0__Value:
		if (p->size < 0)
			delete (s0__Value*)p->ptr;
		else
			delete[] (s0__Value*)p->ptr;
		break;
	case SOAP_TYPE_s0__OPCQuality:
		if (p->size < 0)
			delete (s0__OPCQuality*)p->ptr;
		else
			delete[] (s0__OPCQuality*)p->ptr;
		break;
	case SOAP_TYPE_s0__OPCError:
		if (p->size < 0)
			delete (s0__OPCError*)p->ptr;
		else
			delete[] (s0__OPCError*)p->ptr;
		break;
	case SOAP_TYPE_s0__ArrayOfFloat:
		if (p->size < 0)
			delete (s0__ArrayOfFloat*)p->ptr;
		else
			delete[] (s0__ArrayOfFloat*)p->ptr;
		break;
	case SOAP_TYPE_s0__ArrayOfInt:
		if (p->size < 0)
			delete (s0__ArrayOfInt*)p->ptr;
		else
			delete[] (s0__ArrayOfInt*)p->ptr;
		break;
	case SOAP_TYPE_s0__ArrayOfUnsignedInt:
		if (p->size < 0)
			delete (s0__ArrayOfUnsignedInt*)p->ptr;
		else
			delete[] (s0__ArrayOfUnsignedInt*)p->ptr;
		break;
	case SOAP_TYPE_s0__ArrayOfLong:
		if (p->size < 0)
			delete (s0__ArrayOfLong*)p->ptr;
		else
			delete[] (s0__ArrayOfLong*)p->ptr;
		break;
	case SOAP_TYPE_s0__ArrayOfUnsignedLong:
		if (p->size < 0)
			delete (s0__ArrayOfUnsignedLong*)p->ptr;
		else
			delete[] (s0__ArrayOfUnsignedLong*)p->ptr;
		break;
	case SOAP_TYPE_s0__ArrayOfDouble:
		if (p->size < 0)
			delete (s0__ArrayOfDouble*)p->ptr;
		else
			delete[] (s0__ArrayOfDouble*)p->ptr;
		break;
	case SOAP_TYPE_s0__ArrayOfUnsignedShort:
		if (p->size < 0)
			delete (s0__ArrayOfUnsignedShort*)p->ptr;
		else
			delete[] (s0__ArrayOfUnsignedShort*)p->ptr;
		break;
	case SOAP_TYPE_s0__ArrayOfBoolean:
		if (p->size < 0)
			delete (s0__ArrayOfBoolean*)p->ptr;
		else
			delete[] (s0__ArrayOfBoolean*)p->ptr;
		break;
	case SOAP_TYPE_s0__ArrayOfString:
		if (p->size < 0)
			delete (s0__ArrayOfString*)p->ptr;
		else
			delete[] (s0__ArrayOfString*)p->ptr;
		break;
	case SOAP_TYPE_s0__ArrayOfDateTime:
		if (p->size < 0)
			delete (s0__ArrayOfDateTime*)p->ptr;
		else
			delete[] (s0__ArrayOfDateTime*)p->ptr;
		break;
	case SOAP_TYPE_s0__ArrayOfAnyType:
		if (p->size < 0)
			delete (s0__ArrayOfAnyType*)p->ptr;
		else
			delete[] (s0__ArrayOfAnyType*)p->ptr;
		break;
	case SOAP_TYPE_s0__ArrayOfDecimal:
		if (p->size < 0)
			delete (s0__ArrayOfDecimal*)p->ptr;
		else
			delete[] (s0__ArrayOfDecimal*)p->ptr;
		break;
	case SOAP_TYPE_s0__ArrayOfByte:
		if (p->size < 0)
			delete (s0__ArrayOfByte*)p->ptr;
		else
			delete[] (s0__ArrayOfByte*)p->ptr;
		break;
	case SOAP_TYPE_s0__ArrayOfShort:
		if (p->size < 0)
			delete (s0__ArrayOfShort*)p->ptr;
		else
			delete[] (s0__ArrayOfShort*)p->ptr;
		break;
	case SOAP_TYPE_s0__WriteRequestItemList:
		if (p->size < 0)
			delete (s0__WriteRequestItemList*)p->ptr;
		else
			delete[] (s0__WriteRequestItemList*)p->ptr;
		break;
	case SOAP_TYPE_s0__SubscribeRequestItemList:
		if (p->size < 0)
			delete (s0__SubscribeRequestItemList*)p->ptr;
		else
			delete[] (s0__SubscribeRequestItemList*)p->ptr;
		break;
	case SOAP_TYPE_s0__SubscribeRequestItem:
		if (p->size < 0)
			delete (s0__SubscribeRequestItem*)p->ptr;
		else
			delete[] (s0__SubscribeRequestItem*)p->ptr;
		break;
	case SOAP_TYPE_s0__SubscribeReplyItemList:
		if (p->size < 0)
			delete (s0__SubscribeReplyItemList*)p->ptr;
		else
			delete[] (s0__SubscribeReplyItemList*)p->ptr;
		break;
	case SOAP_TYPE_s0__SubscribeItemValue:
		if (p->size < 0)
			delete (s0__SubscribeItemValue*)p->ptr;
		else
			delete[] (s0__SubscribeItemValue*)p->ptr;
		break;
	case SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList:
		if (p->size < 0)
			delete (s0__SubscribePolledRefreshReplyItemList*)p->ptr;
		else
			delete[] (s0__SubscribePolledRefreshReplyItemList*)p->ptr;
		break;
	case SOAP_TYPE_s0__BrowseElement:
		if (p->size < 0)
			delete (s0__BrowseElement*)p->ptr;
		else
			delete[] (s0__BrowseElement*)p->ptr;
		break;
	case SOAP_TYPE_s0__ItemProperty:
		if (p->size < 0)
			delete (s0__ItemProperty*)p->ptr;
		else
			delete[] (s0__ItemProperty*)p->ptr;
		break;
	case SOAP_TYPE_s0__ItemIdentifier:
		if (p->size < 0)
			delete (s0__ItemIdentifier*)p->ptr;
		else
			delete[] (s0__ItemIdentifier*)p->ptr;
		break;
	case SOAP_TYPE_s0__PropertyReplyList:
		if (p->size < 0)
			delete (s0__PropertyReplyList*)p->ptr;
		else
			delete[] (s0__PropertyReplyList*)p->ptr;
		break;
	case SOAP_TYPE__s0__GetStatus:
		if (p->size < 0)
			delete (_s0__GetStatus*)p->ptr;
		else
			delete[] (_s0__GetStatus*)p->ptr;
		break;
	case SOAP_TYPE__s0__GetStatusResponse:
		if (p->size < 0)
			delete (_s0__GetStatusResponse*)p->ptr;
		else
			delete[] (_s0__GetStatusResponse*)p->ptr;
		break;
	case SOAP_TYPE__s0__Read:
		if (p->size < 0)
			delete (_s0__Read*)p->ptr;
		else
			delete[] (_s0__Read*)p->ptr;
		break;
	case SOAP_TYPE__s0__ReadResponse:
		if (p->size < 0)
			delete (_s0__ReadResponse*)p->ptr;
		else
			delete[] (_s0__ReadResponse*)p->ptr;
		break;
	case SOAP_TYPE__s0__Write:
		if (p->size < 0)
			delete (_s0__Write*)p->ptr;
		else
			delete[] (_s0__Write*)p->ptr;
		break;
	case SOAP_TYPE__s0__WriteResponse:
		if (p->size < 0)
			delete (_s0__WriteResponse*)p->ptr;
		else
			delete[] (_s0__WriteResponse*)p->ptr;
		break;
	case SOAP_TYPE__s0__Subscribe:
		if (p->size < 0)
			delete (_s0__Subscribe*)p->ptr;
		else
			delete[] (_s0__Subscribe*)p->ptr;
		break;
	case SOAP_TYPE__s0__SubscribeResponse:
		if (p->size < 0)
			delete (_s0__SubscribeResponse*)p->ptr;
		else
			delete[] (_s0__SubscribeResponse*)p->ptr;
		break;
	case SOAP_TYPE__s0__SubscriptionPolledRefresh:
		if (p->size < 0)
			delete (_s0__SubscriptionPolledRefresh*)p->ptr;
		else
			delete[] (_s0__SubscriptionPolledRefresh*)p->ptr;
		break;
	case SOAP_TYPE__s0__SubscriptionPolledRefreshResponse:
		if (p->size < 0)
			delete (_s0__SubscriptionPolledRefreshResponse*)p->ptr;
		else
			delete[] (_s0__SubscriptionPolledRefreshResponse*)p->ptr;
		break;
	case SOAP_TYPE__s0__SubscriptionCancel:
		if (p->size < 0)
			delete (_s0__SubscriptionCancel*)p->ptr;
		else
			delete[] (_s0__SubscriptionCancel*)p->ptr;
		break;
	case SOAP_TYPE__s0__SubscriptionCancelResponse:
		if (p->size < 0)
			delete (_s0__SubscriptionCancelResponse*)p->ptr;
		else
			delete[] (_s0__SubscriptionCancelResponse*)p->ptr;
		break;
	case SOAP_TYPE__s0__Browse:
		if (p->size < 0)
			delete (_s0__Browse*)p->ptr;
		else
			delete[] (_s0__Browse*)p->ptr;
		break;
	case SOAP_TYPE__s0__BrowseResponse:
		if (p->size < 0)
			delete (_s0__BrowseResponse*)p->ptr;
		else
			delete[] (_s0__BrowseResponse*)p->ptr;
		break;
	case SOAP_TYPE__s0__GetProperties:
		if (p->size < 0)
			delete (_s0__GetProperties*)p->ptr;
		else
			delete[] (_s0__GetProperties*)p->ptr;
		break;
	case SOAP_TYPE__s0__GetPropertiesResponse:
		if (p->size < 0)
			delete (_s0__GetPropertiesResponse*)p->ptr;
		else
			delete[] (_s0__GetPropertiesResponse*)p->ptr;
		break;
	case SOAP_TYPE___s0__GetStatus:
		if (p->size < 0)
			delete (struct __s0__GetStatus*)p->ptr;
		else
			delete[] (struct __s0__GetStatus*)p->ptr;
		break;
	case SOAP_TYPE___s0__Read:
		if (p->size < 0)
			delete (struct __s0__Read*)p->ptr;
		else
			delete[] (struct __s0__Read*)p->ptr;
		break;
	case SOAP_TYPE___s0__Write:
		if (p->size < 0)
			delete (struct __s0__Write*)p->ptr;
		else
			delete[] (struct __s0__Write*)p->ptr;
		break;
	case SOAP_TYPE___s0__Subscribe:
		if (p->size < 0)
			delete (struct __s0__Subscribe*)p->ptr;
		else
			delete[] (struct __s0__Subscribe*)p->ptr;
		break;
	case SOAP_TYPE___s0__SubscriptionPolledRefresh:
		if (p->size < 0)
			delete (struct __s0__SubscriptionPolledRefresh*)p->ptr;
		else
			delete[] (struct __s0__SubscriptionPolledRefresh*)p->ptr;
		break;
	case SOAP_TYPE___s0__SubscriptionCancel:
		if (p->size < 0)
			delete (struct __s0__SubscriptionCancel*)p->ptr;
		else
			delete[] (struct __s0__SubscriptionCancel*)p->ptr;
		break;
	case SOAP_TYPE___s0__Browse:
		if (p->size < 0)
			delete (struct __s0__Browse*)p->ptr;
		else
			delete[] (struct __s0__Browse*)p->ptr;
		break;
	case SOAP_TYPE___s0__GetProperties:
		if (p->size < 0)
			delete (struct __s0__GetProperties*)p->ptr;
		else
			delete[] (struct __s0__GetProperties*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_xsd__QName:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_xsd__decimal:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__PropertyReplyList:
		if (p->size < 0)
			delete (std::vector<s0__PropertyReplyList * >*)p->ptr;
		else
			delete[] (std::vector<s0__PropertyReplyList * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemIdentifier:
		if (p->size < 0)
			delete (std::vector<s0__ItemIdentifier * >*)p->ptr;
		else
			delete[] (std::vector<s0__ItemIdentifier * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__BrowseElement:
		if (p->size < 0)
			delete (std::vector<s0__BrowseElement * >*)p->ptr;
		else
			delete[] (std::vector<s0__BrowseElement * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList:
		if (p->size < 0)
			delete (std::vector<s0__SubscribePolledRefreshReplyItemList * >*)p->ptr;
		else
			delete[] (std::vector<s0__SubscribePolledRefreshReplyItemList * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__OPCError:
		if (p->size < 0)
			delete (std::vector<s0__OPCError * >*)p->ptr;
		else
			delete[] (std::vector<s0__OPCError * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemProperty:
		if (p->size < 0)
			delete (std::vector<s0__ItemProperty * >*)p->ptr;
		else
			delete[] (std::vector<s0__ItemProperty * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribeItemValue:
		if (p->size < 0)
			delete (std::vector<s0__SubscribeItemValue * >*)p->ptr;
		else
			delete[] (std::vector<s0__SubscribeItemValue * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribeRequestItem:
		if (p->size < 0)
			delete (std::vector<s0__SubscribeRequestItem * >*)p->ptr;
		else
			delete[] (std::vector<s0__SubscribeRequestItem * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfshort:
		if (p->size < 0)
			delete (std::vector<short >*)p->ptr;
		else
			delete[] (std::vector<short >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfbyte:
		if (p->size < 0)
			delete (std::vector<char >*)p->ptr;
		else
			delete[] (std::vector<char >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__decimal:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		if (p->size < 0)
			delete (std::vector<char * >*)p->ptr;
		else
			delete[] (std::vector<char * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfbool:
		if (p->size < 0)
			delete (std::vector<bool >*)p->ptr;
		else
			delete[] (std::vector<bool >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfunsignedShort:
		if (p->size < 0)
			delete (std::vector<unsigned short >*)p->ptr;
		else
			delete[] (std::vector<unsigned short >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfdouble:
		if (p->size < 0)
			delete (std::vector<double >*)p->ptr;
		else
			delete[] (std::vector<double >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfunsignedLONG64:
		if (p->size < 0)
			delete (std::vector<ULONG64 >*)p->ptr;
		else
			delete[] (std::vector<ULONG64 >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfLONG64:
		if (p->size < 0)
			delete (std::vector<LONG64 >*)p->ptr;
		else
			delete[] (std::vector<LONG64 >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfunsignedInt:
		if (p->size < 0)
			delete (std::vector<unsigned int >*)p->ptr;
		else
			delete[] (std::vector<unsigned int >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		if (p->size < 0)
			delete (std::vector<int >*)p->ptr;
		else
			delete[] (std::vector<int >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOffloat:
		if (p->size < 0)
			delete (std::vector<float >*)p->ptr;
		else
			delete[] (std::vector<float >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemValue:
		if (p->size < 0)
			delete (std::vector<s0__ItemValue * >*)p->ptr;
		else
			delete[] (std::vector<s0__ItemValue * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ReadRequestItem:
		if (p->size < 0)
			delete (std::vector<s0__ReadRequestItem * >*)p->ptr;
		else
			delete[] (std::vector<s0__ReadRequestItem * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfs0__interfaceVersion:
		if (p->size < 0)
			delete (std::vector<enum s0__interfaceVersion >*)p->ptr;
		else
			delete[] (std::vector<enum s0__interfaceVersion >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__PropertyReplyList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<s0__PropertyReplyList * >*)p)[len] = *(s0__PropertyReplyList **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemIdentifier:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<s0__ItemIdentifier * >*)p)[len] = *(s0__ItemIdentifier **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__BrowseElement:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<s0__BrowseElement * >*)p)[len] = *(s0__BrowseElement **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__QName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<s0__SubscribePolledRefreshReplyItemList * >*)p)[len] = *(s0__SubscribePolledRefreshReplyItemList **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__OPCError:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<s0__OPCError * >*)p)[len] = *(s0__OPCError **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemProperty:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<s0__ItemProperty * >*)p)[len] = *(s0__ItemProperty **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribeItemValue:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<s0__SubscribeItemValue * >*)p)[len] = *(s0__SubscribeItemValue **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribeRequestItem:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<s0__SubscribeRequestItem * >*)p)[len] = *(s0__SubscribeRequestItem **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfshort:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<short >*)p)[len] = *(short *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfbyte:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<char >*)p)[len] = *(char *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfxsd__decimal:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOf_XML:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<char * >*)p)[len] = *(char **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfbool:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<bool >*)p)[len] = *(bool *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfunsignedShort:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<unsigned short >*)p)[len] = *(unsigned short *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfdouble:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<double >*)p)[len] = *(double *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfunsignedLONG64:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ULONG64 >*)p)[len] = *(ULONG64 *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfLONG64:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<LONG64 >*)p)[len] = *(LONG64 *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfunsignedInt:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<unsigned int >*)p)[len] = *(unsigned int *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<int >*)p)[len] = *(int *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOffloat:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<float >*)p)[len] = *(float *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemValue:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<s0__ItemValue * >*)p)[len] = *(s0__ItemValue **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTos0__ReadRequestItem:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<s0__ReadRequestItem * >*)p)[len] = *(s0__ReadRequestItem **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfs0__interfaceVersion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum s0__interfaceVersion >*)p)[len] = *(enum s0__interfaceVersion *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_short(struct soap *soap, short *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_short
	*a = SOAP_DEFAULT_short;
#else
	*a = (short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_short);
	if (soap_out_short(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{
	return soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	return soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_float(struct soap *soap, float *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_float
	*a = SOAP_DEFAULT_float;
#else
	*a = (float)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_float);
	if (soap_out_float(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{
	return soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedByte(struct soap *soap, unsigned char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedByte
	*a = SOAP_DEFAULT_unsignedByte;
#else
	*a = (unsigned char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedByte);
	if (soap_out_unsignedByte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	return soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedShort(struct soap *soap, unsigned short *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedShort
	*a = SOAP_DEFAULT_unsignedShort;
#else
	*a = (unsigned short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedShort(struct soap *soap, const unsigned short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedShort);
	if (soap_out_unsignedShort(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedShort(struct soap *soap, const char *tag, int id, const unsigned short *a, const char *type)
{
	return soap_outunsignedShort(soap, tag, id, a, type, SOAP_TYPE_unsignedShort);
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_get_unsignedShort(struct soap *soap, unsigned short *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedShort(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned short * SOAP_FMAC4 soap_in_unsignedShort(struct soap *soap, const char *tag, unsigned short *a, const char *type)
{
	return soap_inunsignedShort(soap, tag, a, type, SOAP_TYPE_unsignedShort);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedInt(struct soap *soap, unsigned int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedInt
	*a = SOAP_DEFAULT_unsignedInt;
#else
	*a = (unsigned int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedInt);
	if (soap_out_unsignedInt(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	return soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_unsignedLONG64(struct soap *soap, ULONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_unsignedLONG64
	*a = SOAP_DEFAULT_unsignedLONG64;
#else
	*a = (ULONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedLONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_unsignedLONG64);
	if (soap_out_unsignedLONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedLONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_unsignedLONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedLONG64(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_unsignedLONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	return soap_inULONG64(soap, tag, a, type, SOAP_TYPE_unsignedLONG64);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_s0__browseFilter(struct soap *soap, enum s0__browseFilter *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_s0__browseFilter
	*a = SOAP_DEFAULT_s0__browseFilter;
#else
	*a = (enum s0__browseFilter)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_s0__browseFilter(struct soap *soap, const enum s0__browseFilter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_s0__browseFilter);
	if (soap_out_s0__browseFilter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_s0__browseFilter[] =
{	{ (long)s0__browseFilter__all, "all" },
	{ (long)s0__browseFilter__branch, "branch" },
	{ (long)s0__browseFilter__item, "item" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_s0__browseFilter2s(struct soap *soap, enum s0__browseFilter n)
{	const char *s = soap_code_str(soap_codes_s0__browseFilter, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__browseFilter(struct soap *soap, const char *tag, int id, const enum s0__browseFilter *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__browseFilter), type);
	soap_send(soap, soap_s0__browseFilter2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum s0__browseFilter * SOAP_FMAC4 soap_get_s0__browseFilter(struct soap *soap, enum s0__browseFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__browseFilter(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2s0__browseFilter(struct soap *soap, const char *s, enum s0__browseFilter *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_s0__browseFilter, s);
	if (map)
		*a = (enum s0__browseFilter)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum s0__browseFilter)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum s0__browseFilter * SOAP_FMAC4 soap_in_s0__browseFilter(struct soap *soap, const char *tag, enum s0__browseFilter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum s0__browseFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_s0__browseFilter, sizeof(enum s0__browseFilter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2s0__browseFilter(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum s0__browseFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__browseFilter, 0, sizeof(enum s0__browseFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_s0__limitBits(struct soap *soap, enum s0__limitBits *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_s0__limitBits
	*a = SOAP_DEFAULT_s0__limitBits;
#else
	*a = (enum s0__limitBits)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_s0__limitBits(struct soap *soap, const enum s0__limitBits *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_s0__limitBits);
	if (soap_out_s0__limitBits(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_s0__limitBits[] =
{	{ (long)s0__limitBits__none, "none" },
	{ (long)s0__limitBits__low, "low" },
	{ (long)s0__limitBits__high, "high" },
	{ (long)s0__limitBits__constant, "constant" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_s0__limitBits2s(struct soap *soap, enum s0__limitBits n)
{	const char *s = soap_code_str(soap_codes_s0__limitBits, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__limitBits(struct soap *soap, const char *tag, int id, const enum s0__limitBits *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__limitBits), type);
	soap_send(soap, soap_s0__limitBits2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum s0__limitBits * SOAP_FMAC4 soap_get_s0__limitBits(struct soap *soap, enum s0__limitBits *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__limitBits(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2s0__limitBits(struct soap *soap, const char *s, enum s0__limitBits *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_s0__limitBits, s);
	if (map)
		*a = (enum s0__limitBits)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum s0__limitBits)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum s0__limitBits * SOAP_FMAC4 soap_in_s0__limitBits(struct soap *soap, const char *tag, enum s0__limitBits *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum s0__limitBits *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_s0__limitBits, sizeof(enum s0__limitBits), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2s0__limitBits(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum s0__limitBits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__limitBits, 0, sizeof(enum s0__limitBits), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_s0__qualityBits(struct soap *soap, enum s0__qualityBits *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_s0__qualityBits
	*a = SOAP_DEFAULT_s0__qualityBits;
#else
	*a = (enum s0__qualityBits)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_s0__qualityBits(struct soap *soap, const enum s0__qualityBits *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_s0__qualityBits);
	if (soap_out_s0__qualityBits(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_s0__qualityBits[] =
{	{ (long)s0__qualityBits__bad, "bad" },
	{ (long)s0__qualityBits__badConfigurationError, "badConfigurationError" },
	{ (long)s0__qualityBits__badNotConnected, "badNotConnected" },
	{ (long)s0__qualityBits__badDeviceFailure, "badDeviceFailure" },
	{ (long)s0__qualityBits__badSensorFailure, "badSensorFailure" },
	{ (long)s0__qualityBits__badLastKnownValue, "badLastKnownValue" },
	{ (long)s0__qualityBits__badCommFailure, "badCommFailure" },
	{ (long)s0__qualityBits__badOutOfService, "badOutOfService" },
	{ (long)s0__qualityBits__badWaitingForInitialData, "badWaitingForInitialData" },
	{ (long)s0__qualityBits__uncertain, "uncertain" },
	{ (long)s0__qualityBits__uncertainLastUsableValue, "uncertainLastUsableValue" },
	{ (long)s0__qualityBits__uncertainSensorNotAccurate, "uncertainSensorNotAccurate" },
	{ (long)s0__qualityBits__uncertainEUExceeded, "uncertainEUExceeded" },
	{ (long)s0__qualityBits__uncertainSubNormal, "uncertainSubNormal" },
	{ (long)s0__qualityBits__good, "good" },
	{ (long)s0__qualityBits__goodLocalOverride, "goodLocalOverride" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_s0__qualityBits2s(struct soap *soap, enum s0__qualityBits n)
{	const char *s = soap_code_str(soap_codes_s0__qualityBits, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__qualityBits(struct soap *soap, const char *tag, int id, const enum s0__qualityBits *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__qualityBits), type);
	soap_send(soap, soap_s0__qualityBits2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum s0__qualityBits * SOAP_FMAC4 soap_get_s0__qualityBits(struct soap *soap, enum s0__qualityBits *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__qualityBits(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2s0__qualityBits(struct soap *soap, const char *s, enum s0__qualityBits *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_s0__qualityBits, s);
	if (map)
		*a = (enum s0__qualityBits)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 15)))
			return soap->error = SOAP_TYPE;
		*a = (enum s0__qualityBits)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum s0__qualityBits * SOAP_FMAC4 soap_in_s0__qualityBits(struct soap *soap, const char *tag, enum s0__qualityBits *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum s0__qualityBits *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_s0__qualityBits, sizeof(enum s0__qualityBits), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2s0__qualityBits(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum s0__qualityBits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__qualityBits, 0, sizeof(enum s0__qualityBits), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_s0__interfaceVersion(struct soap *soap, enum s0__interfaceVersion *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_s0__interfaceVersion
	*a = SOAP_DEFAULT_s0__interfaceVersion;
#else
	*a = (enum s0__interfaceVersion)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_s0__interfaceVersion(struct soap *soap, const enum s0__interfaceVersion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_s0__interfaceVersion);
	if (soap_out_s0__interfaceVersion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_s0__interfaceVersion[] =
{	{ (long)s0__interfaceVersion__XML_USCOREDA_USCOREVersion_USCORE1_USCORE0, "XML_DA_Version_1_0" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_s0__interfaceVersion2s(struct soap *soap, enum s0__interfaceVersion n)
{	const char *s = soap_code_str(soap_codes_s0__interfaceVersion, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__interfaceVersion(struct soap *soap, const char *tag, int id, const enum s0__interfaceVersion *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__interfaceVersion), type);
	soap_send(soap, soap_s0__interfaceVersion2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum s0__interfaceVersion * SOAP_FMAC4 soap_get_s0__interfaceVersion(struct soap *soap, enum s0__interfaceVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__interfaceVersion(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2s0__interfaceVersion(struct soap *soap, const char *s, enum s0__interfaceVersion *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_s0__interfaceVersion, s);
	if (map)
		*a = (enum s0__interfaceVersion)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 0)))
			return soap->error = SOAP_TYPE;
		*a = (enum s0__interfaceVersion)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum s0__interfaceVersion * SOAP_FMAC4 soap_in_s0__interfaceVersion(struct soap *soap, const char *tag, enum s0__interfaceVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum s0__interfaceVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_s0__interfaceVersion, sizeof(enum s0__interfaceVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2s0__interfaceVersion(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum s0__interfaceVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__interfaceVersion, 0, sizeof(enum s0__interfaceVersion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_s0__serverState(struct soap *soap, enum s0__serverState *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_s0__serverState
	*a = SOAP_DEFAULT_s0__serverState;
#else
	*a = (enum s0__serverState)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_s0__serverState(struct soap *soap, const enum s0__serverState *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_s0__serverState);
	if (soap_out_s0__serverState(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_s0__serverState[] =
{	{ (long)s0__serverState__running, "running" },
	{ (long)s0__serverState__failed, "failed" },
	{ (long)s0__serverState__noConfig, "noConfig" },
	{ (long)s0__serverState__suspended, "suspended" },
	{ (long)s0__serverState__test, "test" },
	{ (long)s0__serverState__commFault, "commFault" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_s0__serverState2s(struct soap *soap, enum s0__serverState n)
{	const char *s = soap_code_str(soap_codes_s0__serverState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__serverState(struct soap *soap, const char *tag, int id, const enum s0__serverState *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__serverState), type);
	soap_send(soap, soap_s0__serverState2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum s0__serverState * SOAP_FMAC4 soap_get_s0__serverState(struct soap *soap, enum s0__serverState *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__serverState(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2s0__serverState(struct soap *soap, const char *s, enum s0__serverState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_s0__serverState, s);
	if (map)
		*a = (enum s0__serverState)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum s0__serverState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum s0__serverState * SOAP_FMAC4 soap_in_s0__serverState(struct soap *soap, const char *tag, enum s0__serverState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum s0__serverState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_s0__serverState, sizeof(enum s0__serverState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2s0__serverState(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum s0__serverState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__serverState, 0, sizeof(enum s0__serverState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type);
	soap_send(soap, soap_bool2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void s0__browseFilter_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_s0__browseFilter(soap, &((s0__browseFilter_*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__browseFilter_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((s0__browseFilter_*)this)->__item, SOAP_TYPE_s0__browseFilter);
	/* transient soap skipped */
}

int s0__browseFilter_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__browseFilter_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__browseFilter_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__browseFilter_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__browseFilter_(struct soap *soap, const char *tag, int id, const s0__browseFilter_ *a, const char *type)
{
	return soap_out_s0__browseFilter(soap, tag, id, &(((s0__browseFilter_*)a)->__item), "s0:browseFilter");
}

void *s0__browseFilter_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__browseFilter_(soap, this, tag, type);
}

SOAP_FMAC3 s0__browseFilter_ * SOAP_FMAC4 soap_get_s0__browseFilter_(struct soap *soap, s0__browseFilter_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__browseFilter_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__browseFilter_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__browseFilter_(soap, tag, this, type);
}

SOAP_FMAC3 s0__browseFilter_ * SOAP_FMAC4 soap_in_s0__browseFilter_(struct soap *soap, const char *tag, s0__browseFilter_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (s0__browseFilter_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__browseFilter_, sizeof(s0__browseFilter_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__browseFilter_)
			return (s0__browseFilter_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_s0__browseFilter(soap, tag, &(((s0__browseFilter_*)a)->__item), "s0:browseFilter"))
		return NULL;
	return a;
}

SOAP_FMAC5 s0__browseFilter_ * SOAP_FMAC6 soap_new_s0__browseFilter_(struct soap *soap, int n)
{	return soap_instantiate_s0__browseFilter_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__browseFilter_(struct soap *soap, s0__browseFilter_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__browseFilter_ * SOAP_FMAC4 soap_instantiate_s0__browseFilter_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__browseFilter_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__browseFilter_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__browseFilter_;
		if (size)
			*size = sizeof(s0__browseFilter_);
		((s0__browseFilter_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__browseFilter_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__browseFilter_);
		for (int i = 0; i < n; i++)
			((s0__browseFilter_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__browseFilter_*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__browseFilter_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__browseFilter_ %p -> %p\n", q, p));
	*(s0__browseFilter_*)p = *(s0__browseFilter_*)q;
}
#ifdef __cplusplus
}
#endif

void s0__limitBits_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_s0__limitBits(soap, &((s0__limitBits_*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__limitBits_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((s0__limitBits_*)this)->__item, SOAP_TYPE_s0__limitBits);
	/* transient soap skipped */
}

int s0__limitBits_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__limitBits_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__limitBits_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__limitBits_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__limitBits_(struct soap *soap, const char *tag, int id, const s0__limitBits_ *a, const char *type)
{
	return soap_out_s0__limitBits(soap, tag, id, &(((s0__limitBits_*)a)->__item), "s0:limitBits");
}

void *s0__limitBits_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__limitBits_(soap, this, tag, type);
}

SOAP_FMAC3 s0__limitBits_ * SOAP_FMAC4 soap_get_s0__limitBits_(struct soap *soap, s0__limitBits_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__limitBits_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__limitBits_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__limitBits_(soap, tag, this, type);
}

SOAP_FMAC3 s0__limitBits_ * SOAP_FMAC4 soap_in_s0__limitBits_(struct soap *soap, const char *tag, s0__limitBits_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (s0__limitBits_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__limitBits_, sizeof(s0__limitBits_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__limitBits_)
			return (s0__limitBits_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_s0__limitBits(soap, tag, &(((s0__limitBits_*)a)->__item), "s0:limitBits"))
		return NULL;
	return a;
}

SOAP_FMAC5 s0__limitBits_ * SOAP_FMAC6 soap_new_s0__limitBits_(struct soap *soap, int n)
{	return soap_instantiate_s0__limitBits_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__limitBits_(struct soap *soap, s0__limitBits_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__limitBits_ * SOAP_FMAC4 soap_instantiate_s0__limitBits_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__limitBits_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__limitBits_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__limitBits_;
		if (size)
			*size = sizeof(s0__limitBits_);
		((s0__limitBits_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__limitBits_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__limitBits_);
		for (int i = 0; i < n; i++)
			((s0__limitBits_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__limitBits_*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__limitBits_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__limitBits_ %p -> %p\n", q, p));
	*(s0__limitBits_*)p = *(s0__limitBits_*)q;
}
#ifdef __cplusplus
}
#endif

void s0__qualityBits_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_s0__qualityBits(soap, &((s0__qualityBits_*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__qualityBits_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((s0__qualityBits_*)this)->__item, SOAP_TYPE_s0__qualityBits);
	/* transient soap skipped */
}

int s0__qualityBits_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__qualityBits_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__qualityBits_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__qualityBits_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__qualityBits_(struct soap *soap, const char *tag, int id, const s0__qualityBits_ *a, const char *type)
{
	return soap_out_s0__qualityBits(soap, tag, id, &(((s0__qualityBits_*)a)->__item), "s0:qualityBits");
}

void *s0__qualityBits_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__qualityBits_(soap, this, tag, type);
}

SOAP_FMAC3 s0__qualityBits_ * SOAP_FMAC4 soap_get_s0__qualityBits_(struct soap *soap, s0__qualityBits_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__qualityBits_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__qualityBits_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__qualityBits_(soap, tag, this, type);
}

SOAP_FMAC3 s0__qualityBits_ * SOAP_FMAC4 soap_in_s0__qualityBits_(struct soap *soap, const char *tag, s0__qualityBits_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (s0__qualityBits_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__qualityBits_, sizeof(s0__qualityBits_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__qualityBits_)
			return (s0__qualityBits_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_s0__qualityBits(soap, tag, &(((s0__qualityBits_*)a)->__item), "s0:qualityBits"))
		return NULL;
	return a;
}

SOAP_FMAC5 s0__qualityBits_ * SOAP_FMAC6 soap_new_s0__qualityBits_(struct soap *soap, int n)
{	return soap_instantiate_s0__qualityBits_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__qualityBits_(struct soap *soap, s0__qualityBits_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__qualityBits_ * SOAP_FMAC4 soap_instantiate_s0__qualityBits_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__qualityBits_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__qualityBits_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__qualityBits_;
		if (size)
			*size = sizeof(s0__qualityBits_);
		((s0__qualityBits_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__qualityBits_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__qualityBits_);
		for (int i = 0; i < n; i++)
			((s0__qualityBits_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__qualityBits_*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__qualityBits_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__qualityBits_ %p -> %p\n", q, p));
	*(s0__qualityBits_*)p = *(s0__qualityBits_*)q;
}
#ifdef __cplusplus
}
#endif

void s0__interfaceVersion_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_s0__interfaceVersion(soap, &((s0__interfaceVersion_*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__interfaceVersion_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int s0__interfaceVersion_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__interfaceVersion_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__interfaceVersion_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__interfaceVersion_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__interfaceVersion_(struct soap *soap, const char *tag, int id, const s0__interfaceVersion_ *a, const char *type)
{
	return soap_out_s0__interfaceVersion(soap, tag, id, &(((s0__interfaceVersion_*)a)->__item), "s0:interfaceVersion");
}

void *s0__interfaceVersion_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__interfaceVersion_(soap, this, tag, type);
}

SOAP_FMAC3 s0__interfaceVersion_ * SOAP_FMAC4 soap_get_s0__interfaceVersion_(struct soap *soap, s0__interfaceVersion_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__interfaceVersion_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__interfaceVersion_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__interfaceVersion_(soap, tag, this, type);
}

SOAP_FMAC3 s0__interfaceVersion_ * SOAP_FMAC4 soap_in_s0__interfaceVersion_(struct soap *soap, const char *tag, s0__interfaceVersion_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (s0__interfaceVersion_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__interfaceVersion_, sizeof(s0__interfaceVersion_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__interfaceVersion_)
			return (s0__interfaceVersion_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_s0__interfaceVersion(soap, tag, &(((s0__interfaceVersion_*)a)->__item), "s0:interfaceVersion"))
		return NULL;
	return a;
}

SOAP_FMAC5 s0__interfaceVersion_ * SOAP_FMAC6 soap_new_s0__interfaceVersion_(struct soap *soap, int n)
{	return soap_instantiate_s0__interfaceVersion_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__interfaceVersion_(struct soap *soap, s0__interfaceVersion_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__interfaceVersion_ * SOAP_FMAC4 soap_instantiate_s0__interfaceVersion_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__interfaceVersion_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__interfaceVersion_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__interfaceVersion_;
		if (size)
			*size = sizeof(s0__interfaceVersion_);
		((s0__interfaceVersion_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__interfaceVersion_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__interfaceVersion_);
		for (int i = 0; i < n; i++)
			((s0__interfaceVersion_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__interfaceVersion_*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__interfaceVersion_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__interfaceVersion_ %p -> %p\n", q, p));
	*(s0__interfaceVersion_*)p = *(s0__interfaceVersion_*)q;
}
#ifdef __cplusplus
}
#endif

void s0__serverState_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_s0__serverState(soap, &((s0__serverState_*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__serverState_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int s0__serverState_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__serverState_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__serverState_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__serverState_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__serverState_(struct soap *soap, const char *tag, int id, const s0__serverState_ *a, const char *type)
{
	return soap_out_s0__serverState(soap, tag, id, &(((s0__serverState_*)a)->__item), "s0:serverState");
}

void *s0__serverState_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__serverState_(soap, this, tag, type);
}

SOAP_FMAC3 s0__serverState_ * SOAP_FMAC4 soap_get_s0__serverState_(struct soap *soap, s0__serverState_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__serverState_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__serverState_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__serverState_(soap, tag, this, type);
}

SOAP_FMAC3 s0__serverState_ * SOAP_FMAC4 soap_in_s0__serverState_(struct soap *soap, const char *tag, s0__serverState_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (s0__serverState_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__serverState_, sizeof(s0__serverState_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__serverState_)
			return (s0__serverState_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_s0__serverState(soap, tag, &(((s0__serverState_*)a)->__item), "s0:serverState"))
		return NULL;
	return a;
}

SOAP_FMAC5 s0__serverState_ * SOAP_FMAC6 soap_new_s0__serverState_(struct soap *soap, int n)
{	return soap_instantiate_s0__serverState_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__serverState_(struct soap *soap, s0__serverState_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__serverState_ * SOAP_FMAC4 soap_instantiate_s0__serverState_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__serverState_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__serverState_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__serverState_;
		if (size)
			*size = sizeof(s0__serverState_);
		((s0__serverState_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__serverState_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__serverState_);
		for (int i = 0; i < n; i++)
			((s0__serverState_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__serverState_*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__serverState_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__serverState_ %p -> %p\n", q, p));
	*(s0__serverState_*)p = *(s0__serverState_*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__GetPropertiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_s0__GetPropertiesResponse*)this)->GetPropertiesResult = NULL;
	soap_default_std__vectorTemplateOfPointerTos0__PropertyReplyList(soap, &((_s0__GetPropertiesResponse*)this)->PropertyLists);
	soap_default_std__vectorTemplateOfPointerTos0__OPCError(soap, &((_s0__GetPropertiesResponse*)this)->Errors);
	/* transient soap skipped */
}

void _s0__GetPropertiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTos0__ReplyBase(soap, &((_s0__GetPropertiesResponse*)this)->GetPropertiesResult);
	soap_serialize_std__vectorTemplateOfPointerTos0__PropertyReplyList(soap, &((_s0__GetPropertiesResponse*)this)->PropertyLists);
	soap_serialize_std__vectorTemplateOfPointerTos0__OPCError(soap, &((_s0__GetPropertiesResponse*)this)->Errors);
	/* transient soap skipped */
}

int _s0__GetPropertiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__GetPropertiesResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _s0__GetPropertiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__s0__GetPropertiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__GetPropertiesResponse(struct soap *soap, const char *tag, int id, const _s0__GetPropertiesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__GetPropertiesResponse), type);
	if (a->GetPropertiesResult)
		soap_element_result(soap, "s0:GetPropertiesResult");
	soap_out_PointerTos0__ReplyBase(soap, "s0:GetPropertiesResult", -1, &(((_s0__GetPropertiesResponse*)a)->GetPropertiesResult), "");
	soap_out_std__vectorTemplateOfPointerTos0__PropertyReplyList(soap, "s0:PropertyLists", -1, &(((_s0__GetPropertiesResponse*)a)->PropertyLists), "");
	soap_out_std__vectorTemplateOfPointerTos0__OPCError(soap, "s0:Errors", -1, &(((_s0__GetPropertiesResponse*)a)->Errors), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_s0__GetPropertiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__s0__GetPropertiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _s0__GetPropertiesResponse * SOAP_FMAC4 soap_get__s0__GetPropertiesResponse(struct soap *soap, _s0__GetPropertiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__s0__GetPropertiesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_s0__GetPropertiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__s0__GetPropertiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _s0__GetPropertiesResponse * SOAP_FMAC4 soap_in__s0__GetPropertiesResponse(struct soap *soap, const char *tag, _s0__GetPropertiesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_s0__GetPropertiesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__s0__GetPropertiesResponse, sizeof(_s0__GetPropertiesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__s0__GetPropertiesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_s0__GetPropertiesResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_GetPropertiesResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetPropertiesResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTos0__ReplyBase(soap, "s0:GetPropertiesResult", &(((_s0__GetPropertiesResponse*)a)->GetPropertiesResult), "s0:ReplyBase"))
				{	soap_flag_GetPropertiesResult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTos0__PropertyReplyList(soap, "s0:PropertyLists", &(((_s0__GetPropertiesResponse*)a)->PropertyLists), "s0:PropertyReplyList"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTos0__OPCError(soap, "s0:Errors", &(((_s0__GetPropertiesResponse*)a)->Errors), "s0:OPCError"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "s0:GetPropertiesResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_s0__GetPropertiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__s0__GetPropertiesResponse, 0, sizeof(_s0__GetPropertiesResponse), 0, soap_copy__s0__GetPropertiesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _s0__GetPropertiesResponse * SOAP_FMAC6 soap_new__s0__GetPropertiesResponse(struct soap *soap, int n)
{	return soap_instantiate__s0__GetPropertiesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__GetPropertiesResponse(struct soap *soap, _s0__GetPropertiesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _s0__GetPropertiesResponse * SOAP_FMAC4 soap_instantiate__s0__GetPropertiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__s0__GetPropertiesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__s0__GetPropertiesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _s0__GetPropertiesResponse;
		if (size)
			*size = sizeof(_s0__GetPropertiesResponse);
		((_s0__GetPropertiesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _s0__GetPropertiesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_s0__GetPropertiesResponse);
		for (int i = 0; i < n; i++)
			((_s0__GetPropertiesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_s0__GetPropertiesResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__GetPropertiesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__GetPropertiesResponse %p -> %p\n", q, p));
	*(_s0__GetPropertiesResponse*)p = *(_s0__GetPropertiesResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__GetProperties::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTos0__ItemIdentifier(soap, &((_s0__GetProperties*)this)->ItemIDs);
	soap_default_std__vectorTemplateOfxsd__QName(soap, &((_s0__GetProperties*)this)->PropertyNames);
	((_s0__GetProperties*)this)->LocaleID = NULL;
	((_s0__GetProperties*)this)->ClientRequestHandle = NULL;
	((_s0__GetProperties*)this)->ItemPath = NULL;
	((_s0__GetProperties*)this)->ReturnAllProperties = NULL;
	((_s0__GetProperties*)this)->ReturnPropertyValues = NULL;
	((_s0__GetProperties*)this)->ReturnErrorText = NULL;
	/* transient soap skipped */
}

void _s0__GetProperties::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTos0__ItemIdentifier(soap, &((_s0__GetProperties*)this)->ItemIDs);
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &((_s0__GetProperties*)this)->PropertyNames);
	/* transient soap skipped */
}

int _s0__GetProperties::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__GetProperties);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _s0__GetProperties::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__s0__GetProperties(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__GetProperties(struct soap *soap, const char *tag, int id, const _s0__GetProperties *a, const char *type)
{
	if (((_s0__GetProperties *)a)->LocaleID)
		soap_set_attr(soap, "LocaleID", ((_s0__GetProperties *)a)->LocaleID->c_str());
	if (((_s0__GetProperties *)a)->ClientRequestHandle)
		soap_set_attr(soap, "ClientRequestHandle", ((_s0__GetProperties *)a)->ClientRequestHandle->c_str());
	if (((_s0__GetProperties *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((_s0__GetProperties *)a)->ItemPath->c_str());
	if (((_s0__GetProperties *)a)->ReturnAllProperties)
		soap_set_attr(soap, "ReturnAllProperties", soap_bool2s(soap, *((_s0__GetProperties *)a)->ReturnAllProperties));
	if (((_s0__GetProperties *)a)->ReturnPropertyValues)
		soap_set_attr(soap, "ReturnPropertyValues", soap_bool2s(soap, *((_s0__GetProperties *)a)->ReturnPropertyValues));
	if (((_s0__GetProperties *)a)->ReturnErrorText)
		soap_set_attr(soap, "ReturnErrorText", soap_bool2s(soap, *((_s0__GetProperties *)a)->ReturnErrorText));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__GetProperties), type);
	soap_out_std__vectorTemplateOfPointerTos0__ItemIdentifier(soap, "s0:ItemIDs", -1, &(((_s0__GetProperties*)a)->ItemIDs), "");
	soap_out_std__vectorTemplateOfxsd__QName(soap, "s0:PropertyNames", -1, &(((_s0__GetProperties*)a)->PropertyNames), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_s0__GetProperties::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__s0__GetProperties(soap, this, tag, type);
}

SOAP_FMAC3 _s0__GetProperties * SOAP_FMAC4 soap_get__s0__GetProperties(struct soap *soap, _s0__GetProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in__s0__GetProperties(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_s0__GetProperties::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__s0__GetProperties(soap, tag, this, type);
}

SOAP_FMAC3 _s0__GetProperties * SOAP_FMAC4 soap_in__s0__GetProperties(struct soap *soap, const char *tag, _s0__GetProperties *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_s0__GetProperties *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__s0__GetProperties, sizeof(_s0__GetProperties), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__s0__GetProperties)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_s0__GetProperties *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "LocaleID", 0);
		if (t)
		{	if (!(((_s0__GetProperties *)a)->LocaleID = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_s0__GetProperties *)a)->LocaleID = soap_new_std__string(soap, -1);
			((_s0__GetProperties *)a)->LocaleID->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ClientRequestHandle", 0);
		if (t)
		{	if (!(((_s0__GetProperties *)a)->ClientRequestHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_s0__GetProperties *)a)->ClientRequestHandle = soap_new_std__string(soap, -1);
			((_s0__GetProperties *)a)->ClientRequestHandle->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((_s0__GetProperties *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_s0__GetProperties *)a)->ItemPath = soap_new_std__string(soap, -1);
			((_s0__GetProperties *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnAllProperties", 0);
		if (t)
		{	if (!(((_s0__GetProperties *)a)->ReturnAllProperties = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((_s0__GetProperties *)a)->ReturnAllProperties))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnPropertyValues", 0);
		if (t)
		{	if (!(((_s0__GetProperties *)a)->ReturnPropertyValues = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((_s0__GetProperties *)a)->ReturnPropertyValues))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnErrorText", 0);
		if (t)
		{	if (!(((_s0__GetProperties *)a)->ReturnErrorText = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((_s0__GetProperties *)a)->ReturnErrorText))
		return NULL;
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTos0__ItemIdentifier(soap, "s0:ItemIDs", &(((_s0__GetProperties*)a)->ItemIDs), "s0:ItemIdentifier"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__QName(soap, "s0:PropertyNames", &(((_s0__GetProperties*)a)->PropertyNames), "xsd:QName"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_s0__GetProperties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__s0__GetProperties, 0, sizeof(_s0__GetProperties), 0, soap_copy__s0__GetProperties);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _s0__GetProperties * SOAP_FMAC6 soap_new__s0__GetProperties(struct soap *soap, int n)
{	return soap_instantiate__s0__GetProperties(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__GetProperties(struct soap *soap, _s0__GetProperties *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _s0__GetProperties * SOAP_FMAC4 soap_instantiate__s0__GetProperties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__s0__GetProperties(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__s0__GetProperties, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _s0__GetProperties;
		if (size)
			*size = sizeof(_s0__GetProperties);
		((_s0__GetProperties*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _s0__GetProperties[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_s0__GetProperties);
		for (int i = 0; i < n; i++)
			((_s0__GetProperties*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_s0__GetProperties*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__GetProperties(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__GetProperties %p -> %p\n", q, p));
	*(_s0__GetProperties*)p = *(_s0__GetProperties*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__BrowseResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_s0__BrowseResponse*)this)->BrowseResult = NULL;
	soap_default_std__vectorTemplateOfPointerTos0__BrowseElement(soap, &((_s0__BrowseResponse*)this)->Elements);
	soap_default_std__vectorTemplateOfPointerTos0__OPCError(soap, &((_s0__BrowseResponse*)this)->Errors);
	((_s0__BrowseResponse*)this)->ContinuationPoint = NULL;
	((_s0__BrowseResponse*)this)->MoreElements = NULL;
	/* transient soap skipped */
}

void _s0__BrowseResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTos0__ReplyBase(soap, &((_s0__BrowseResponse*)this)->BrowseResult);
	soap_serialize_std__vectorTemplateOfPointerTos0__BrowseElement(soap, &((_s0__BrowseResponse*)this)->Elements);
	soap_serialize_std__vectorTemplateOfPointerTos0__OPCError(soap, &((_s0__BrowseResponse*)this)->Errors);
	/* transient soap skipped */
}

int _s0__BrowseResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__BrowseResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _s0__BrowseResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__s0__BrowseResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__BrowseResponse(struct soap *soap, const char *tag, int id, const _s0__BrowseResponse *a, const char *type)
{
	if (((_s0__BrowseResponse *)a)->ContinuationPoint)
		soap_set_attr(soap, "ContinuationPoint", ((_s0__BrowseResponse *)a)->ContinuationPoint->c_str());
	if (((_s0__BrowseResponse *)a)->MoreElements)
		soap_set_attr(soap, "MoreElements", soap_bool2s(soap, *((_s0__BrowseResponse *)a)->MoreElements));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__BrowseResponse), type);
	if (a->BrowseResult)
		soap_element_result(soap, "s0:BrowseResult");
	soap_out_PointerTos0__ReplyBase(soap, "s0:BrowseResult", -1, &(((_s0__BrowseResponse*)a)->BrowseResult), "");
	soap_out_std__vectorTemplateOfPointerTos0__BrowseElement(soap, "s0:Elements", -1, &(((_s0__BrowseResponse*)a)->Elements), "");
	soap_out_std__vectorTemplateOfPointerTos0__OPCError(soap, "s0:Errors", -1, &(((_s0__BrowseResponse*)a)->Errors), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_s0__BrowseResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__s0__BrowseResponse(soap, this, tag, type);
}

SOAP_FMAC3 _s0__BrowseResponse * SOAP_FMAC4 soap_get__s0__BrowseResponse(struct soap *soap, _s0__BrowseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__s0__BrowseResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_s0__BrowseResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__s0__BrowseResponse(soap, tag, this, type);
}

SOAP_FMAC3 _s0__BrowseResponse * SOAP_FMAC4 soap_in__s0__BrowseResponse(struct soap *soap, const char *tag, _s0__BrowseResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_s0__BrowseResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__s0__BrowseResponse, sizeof(_s0__BrowseResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__s0__BrowseResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_s0__BrowseResponse *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ContinuationPoint", 0);
		if (t)
		{	if (!(((_s0__BrowseResponse *)a)->ContinuationPoint = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_s0__BrowseResponse *)a)->ContinuationPoint = soap_new_std__string(soap, -1);
			((_s0__BrowseResponse *)a)->ContinuationPoint->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "MoreElements", 0);
		if (t)
		{	if (!(((_s0__BrowseResponse *)a)->MoreElements = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((_s0__BrowseResponse *)a)->MoreElements))
		return NULL;
		}
	}
	short soap_flag_BrowseResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BrowseResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTos0__ReplyBase(soap, "s0:BrowseResult", &(((_s0__BrowseResponse*)a)->BrowseResult), "s0:ReplyBase"))
				{	soap_flag_BrowseResult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTos0__BrowseElement(soap, "s0:Elements", &(((_s0__BrowseResponse*)a)->Elements), "s0:BrowseElement"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTos0__OPCError(soap, "s0:Errors", &(((_s0__BrowseResponse*)a)->Errors), "s0:OPCError"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "s0:BrowseResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_s0__BrowseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__s0__BrowseResponse, 0, sizeof(_s0__BrowseResponse), 0, soap_copy__s0__BrowseResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _s0__BrowseResponse * SOAP_FMAC6 soap_new__s0__BrowseResponse(struct soap *soap, int n)
{	return soap_instantiate__s0__BrowseResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__BrowseResponse(struct soap *soap, _s0__BrowseResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _s0__BrowseResponse * SOAP_FMAC4 soap_instantiate__s0__BrowseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__s0__BrowseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__s0__BrowseResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _s0__BrowseResponse;
		if (size)
			*size = sizeof(_s0__BrowseResponse);
		((_s0__BrowseResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _s0__BrowseResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_s0__BrowseResponse);
		for (int i = 0; i < n; i++)
			((_s0__BrowseResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_s0__BrowseResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__BrowseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__BrowseResponse %p -> %p\n", q, p));
	*(_s0__BrowseResponse*)p = *(_s0__BrowseResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__Browse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__QName(soap, &((_s0__Browse*)this)->PropertyNames);
	((_s0__Browse*)this)->LocaleID = NULL;
	((_s0__Browse*)this)->ClientRequestHandle = NULL;
	((_s0__Browse*)this)->ItemPath = NULL;
	((_s0__Browse*)this)->ItemName = NULL;
	((_s0__Browse*)this)->ContinuationPoint = NULL;
	((_s0__Browse*)this)->MaxElementsReturned = NULL;
	((_s0__Browse*)this)->BrowseFilter = NULL;
	((_s0__Browse*)this)->ElementNameFilter = NULL;
	((_s0__Browse*)this)->VendorFilter = NULL;
	((_s0__Browse*)this)->ReturnAllProperties = NULL;
	((_s0__Browse*)this)->ReturnPropertyValues = NULL;
	((_s0__Browse*)this)->ReturnErrorText = NULL;
	/* transient soap skipped */
}

void _s0__Browse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__QName(soap, &((_s0__Browse*)this)->PropertyNames);
	/* transient soap skipped */
}

int _s0__Browse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__Browse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _s0__Browse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__s0__Browse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__Browse(struct soap *soap, const char *tag, int id, const _s0__Browse *a, const char *type)
{
	if (((_s0__Browse *)a)->LocaleID)
		soap_set_attr(soap, "LocaleID", ((_s0__Browse *)a)->LocaleID->c_str());
	if (((_s0__Browse *)a)->ClientRequestHandle)
		soap_set_attr(soap, "ClientRequestHandle", ((_s0__Browse *)a)->ClientRequestHandle->c_str());
	if (((_s0__Browse *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((_s0__Browse *)a)->ItemPath->c_str());
	if (((_s0__Browse *)a)->ItemName)
		soap_set_attr(soap, "ItemName", ((_s0__Browse *)a)->ItemName->c_str());
	if (((_s0__Browse *)a)->ContinuationPoint)
		soap_set_attr(soap, "ContinuationPoint", ((_s0__Browse *)a)->ContinuationPoint->c_str());
	if (((_s0__Browse *)a)->MaxElementsReturned)
		soap_set_attr(soap, "MaxElementsReturned", soap_int2s(soap, *((_s0__Browse *)a)->MaxElementsReturned));
	if (((_s0__Browse *)a)->BrowseFilter)
		soap_set_attr(soap, "BrowseFilter", soap_s0__browseFilter2s(soap, *((_s0__Browse *)a)->BrowseFilter));
	if (((_s0__Browse *)a)->ElementNameFilter)
		soap_set_attr(soap, "ElementNameFilter", ((_s0__Browse *)a)->ElementNameFilter->c_str());
	if (((_s0__Browse *)a)->VendorFilter)
		soap_set_attr(soap, "VendorFilter", ((_s0__Browse *)a)->VendorFilter->c_str());
	if (((_s0__Browse *)a)->ReturnAllProperties)
		soap_set_attr(soap, "ReturnAllProperties", soap_bool2s(soap, *((_s0__Browse *)a)->ReturnAllProperties));
	if (((_s0__Browse *)a)->ReturnPropertyValues)
		soap_set_attr(soap, "ReturnPropertyValues", soap_bool2s(soap, *((_s0__Browse *)a)->ReturnPropertyValues));
	if (((_s0__Browse *)a)->ReturnErrorText)
		soap_set_attr(soap, "ReturnErrorText", soap_bool2s(soap, *((_s0__Browse *)a)->ReturnErrorText));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__Browse), type);
	soap_out_std__vectorTemplateOfxsd__QName(soap, "s0:PropertyNames", -1, &(((_s0__Browse*)a)->PropertyNames), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_s0__Browse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__s0__Browse(soap, this, tag, type);
}

SOAP_FMAC3 _s0__Browse * SOAP_FMAC4 soap_get__s0__Browse(struct soap *soap, _s0__Browse *p, const char *tag, const char *type)
{
	if ((p = soap_in__s0__Browse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_s0__Browse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__s0__Browse(soap, tag, this, type);
}

SOAP_FMAC3 _s0__Browse * SOAP_FMAC4 soap_in__s0__Browse(struct soap *soap, const char *tag, _s0__Browse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_s0__Browse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__s0__Browse, sizeof(_s0__Browse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__s0__Browse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_s0__Browse *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "LocaleID", 0);
		if (t)
		{	if (!(((_s0__Browse *)a)->LocaleID = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_s0__Browse *)a)->LocaleID = soap_new_std__string(soap, -1);
			((_s0__Browse *)a)->LocaleID->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ClientRequestHandle", 0);
		if (t)
		{	if (!(((_s0__Browse *)a)->ClientRequestHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_s0__Browse *)a)->ClientRequestHandle = soap_new_std__string(soap, -1);
			((_s0__Browse *)a)->ClientRequestHandle->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((_s0__Browse *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_s0__Browse *)a)->ItemPath = soap_new_std__string(soap, -1);
			((_s0__Browse *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemName", 0);
		if (t)
		{	if (!(((_s0__Browse *)a)->ItemName = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_s0__Browse *)a)->ItemName = soap_new_std__string(soap, -1);
			((_s0__Browse *)a)->ItemName->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ContinuationPoint", 0);
		if (t)
		{	if (!(((_s0__Browse *)a)->ContinuationPoint = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_s0__Browse *)a)->ContinuationPoint = soap_new_std__string(soap, -1);
			((_s0__Browse *)a)->ContinuationPoint->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "MaxElementsReturned", 0);
		if (t)
		{	if (!(((_s0__Browse *)a)->MaxElementsReturned = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((_s0__Browse *)a)->MaxElementsReturned))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "BrowseFilter", 0);
		if (t)
		{	if (!(((_s0__Browse *)a)->BrowseFilter = (enum s0__browseFilter *)soap_malloc(soap, sizeof(enum s0__browseFilter))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2s0__browseFilter(soap, t, ((_s0__Browse *)a)->BrowseFilter))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ElementNameFilter", 0);
		if (t)
		{	if (!(((_s0__Browse *)a)->ElementNameFilter = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_s0__Browse *)a)->ElementNameFilter = soap_new_std__string(soap, -1);
			((_s0__Browse *)a)->ElementNameFilter->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "VendorFilter", 0);
		if (t)
		{	if (!(((_s0__Browse *)a)->VendorFilter = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_s0__Browse *)a)->VendorFilter = soap_new_std__string(soap, -1);
			((_s0__Browse *)a)->VendorFilter->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnAllProperties", 0);
		if (t)
		{	if (!(((_s0__Browse *)a)->ReturnAllProperties = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((_s0__Browse *)a)->ReturnAllProperties))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnPropertyValues", 0);
		if (t)
		{	if (!(((_s0__Browse *)a)->ReturnPropertyValues = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((_s0__Browse *)a)->ReturnPropertyValues))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnErrorText", 0);
		if (t)
		{	if (!(((_s0__Browse *)a)->ReturnErrorText = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((_s0__Browse *)a)->ReturnErrorText))
		return NULL;
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__QName(soap, "s0:PropertyNames", &(((_s0__Browse*)a)->PropertyNames), "xsd:QName"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_s0__Browse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__s0__Browse, 0, sizeof(_s0__Browse), 0, soap_copy__s0__Browse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _s0__Browse * SOAP_FMAC6 soap_new__s0__Browse(struct soap *soap, int n)
{	return soap_instantiate__s0__Browse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__Browse(struct soap *soap, _s0__Browse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _s0__Browse * SOAP_FMAC4 soap_instantiate__s0__Browse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__s0__Browse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__s0__Browse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _s0__Browse;
		if (size)
			*size = sizeof(_s0__Browse);
		((_s0__Browse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _s0__Browse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_s0__Browse);
		for (int i = 0; i < n; i++)
			((_s0__Browse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_s0__Browse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__Browse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__Browse %p -> %p\n", q, p));
	*(_s0__Browse*)p = *(_s0__Browse*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__SubscriptionCancelResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_s0__SubscriptionCancelResponse*)this)->ClientRequestHandle = NULL;
	/* transient soap skipped */
}

void _s0__SubscriptionCancelResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _s0__SubscriptionCancelResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__SubscriptionCancelResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _s0__SubscriptionCancelResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__s0__SubscriptionCancelResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__SubscriptionCancelResponse(struct soap *soap, const char *tag, int id, const _s0__SubscriptionCancelResponse *a, const char *type)
{
	if (((_s0__SubscriptionCancelResponse *)a)->ClientRequestHandle)
		soap_set_attr(soap, "ClientRequestHandle", ((_s0__SubscriptionCancelResponse *)a)->ClientRequestHandle->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__SubscriptionCancelResponse), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_s0__SubscriptionCancelResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__s0__SubscriptionCancelResponse(soap, this, tag, type);
}

SOAP_FMAC3 _s0__SubscriptionCancelResponse * SOAP_FMAC4 soap_get__s0__SubscriptionCancelResponse(struct soap *soap, _s0__SubscriptionCancelResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__s0__SubscriptionCancelResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_s0__SubscriptionCancelResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__s0__SubscriptionCancelResponse(soap, tag, this, type);
}

SOAP_FMAC3 _s0__SubscriptionCancelResponse * SOAP_FMAC4 soap_in__s0__SubscriptionCancelResponse(struct soap *soap, const char *tag, _s0__SubscriptionCancelResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_s0__SubscriptionCancelResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__s0__SubscriptionCancelResponse, sizeof(_s0__SubscriptionCancelResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__s0__SubscriptionCancelResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_s0__SubscriptionCancelResponse *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ClientRequestHandle", 0);
		if (t)
		{	if (!(((_s0__SubscriptionCancelResponse *)a)->ClientRequestHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_s0__SubscriptionCancelResponse *)a)->ClientRequestHandle = soap_new_std__string(soap, -1);
			((_s0__SubscriptionCancelResponse *)a)->ClientRequestHandle->assign(s);
		}
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_s0__SubscriptionCancelResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__s0__SubscriptionCancelResponse, 0, sizeof(_s0__SubscriptionCancelResponse), 0, soap_copy__s0__SubscriptionCancelResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _s0__SubscriptionCancelResponse * SOAP_FMAC6 soap_new__s0__SubscriptionCancelResponse(struct soap *soap, int n)
{	return soap_instantiate__s0__SubscriptionCancelResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__SubscriptionCancelResponse(struct soap *soap, _s0__SubscriptionCancelResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _s0__SubscriptionCancelResponse * SOAP_FMAC4 soap_instantiate__s0__SubscriptionCancelResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__s0__SubscriptionCancelResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__s0__SubscriptionCancelResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _s0__SubscriptionCancelResponse;
		if (size)
			*size = sizeof(_s0__SubscriptionCancelResponse);
		((_s0__SubscriptionCancelResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _s0__SubscriptionCancelResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_s0__SubscriptionCancelResponse);
		for (int i = 0; i < n; i++)
			((_s0__SubscriptionCancelResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_s0__SubscriptionCancelResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__SubscriptionCancelResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__SubscriptionCancelResponse %p -> %p\n", q, p));
	*(_s0__SubscriptionCancelResponse*)p = *(_s0__SubscriptionCancelResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__SubscriptionCancel::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_s0__SubscriptionCancel*)this)->ServerSubHandle = NULL;
	((_s0__SubscriptionCancel*)this)->ClientRequestHandle = NULL;
	/* transient soap skipped */
}

void _s0__SubscriptionCancel::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _s0__SubscriptionCancel::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__SubscriptionCancel);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _s0__SubscriptionCancel::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__s0__SubscriptionCancel(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__SubscriptionCancel(struct soap *soap, const char *tag, int id, const _s0__SubscriptionCancel *a, const char *type)
{
	if (((_s0__SubscriptionCancel *)a)->ServerSubHandle)
		soap_set_attr(soap, "ServerSubHandle", ((_s0__SubscriptionCancel *)a)->ServerSubHandle->c_str());
	if (((_s0__SubscriptionCancel *)a)->ClientRequestHandle)
		soap_set_attr(soap, "ClientRequestHandle", ((_s0__SubscriptionCancel *)a)->ClientRequestHandle->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__SubscriptionCancel), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_s0__SubscriptionCancel::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__s0__SubscriptionCancel(soap, this, tag, type);
}

SOAP_FMAC3 _s0__SubscriptionCancel * SOAP_FMAC4 soap_get__s0__SubscriptionCancel(struct soap *soap, _s0__SubscriptionCancel *p, const char *tag, const char *type)
{
	if ((p = soap_in__s0__SubscriptionCancel(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_s0__SubscriptionCancel::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__s0__SubscriptionCancel(soap, tag, this, type);
}

SOAP_FMAC3 _s0__SubscriptionCancel * SOAP_FMAC4 soap_in__s0__SubscriptionCancel(struct soap *soap, const char *tag, _s0__SubscriptionCancel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_s0__SubscriptionCancel *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__s0__SubscriptionCancel, sizeof(_s0__SubscriptionCancel), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__s0__SubscriptionCancel)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_s0__SubscriptionCancel *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ServerSubHandle", 0);
		if (t)
		{	if (!(((_s0__SubscriptionCancel *)a)->ServerSubHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_s0__SubscriptionCancel *)a)->ServerSubHandle = soap_new_std__string(soap, -1);
			((_s0__SubscriptionCancel *)a)->ServerSubHandle->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ClientRequestHandle", 0);
		if (t)
		{	if (!(((_s0__SubscriptionCancel *)a)->ClientRequestHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_s0__SubscriptionCancel *)a)->ClientRequestHandle = soap_new_std__string(soap, -1);
			((_s0__SubscriptionCancel *)a)->ClientRequestHandle->assign(s);
		}
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_s0__SubscriptionCancel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__s0__SubscriptionCancel, 0, sizeof(_s0__SubscriptionCancel), 0, soap_copy__s0__SubscriptionCancel);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _s0__SubscriptionCancel * SOAP_FMAC6 soap_new__s0__SubscriptionCancel(struct soap *soap, int n)
{	return soap_instantiate__s0__SubscriptionCancel(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__SubscriptionCancel(struct soap *soap, _s0__SubscriptionCancel *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _s0__SubscriptionCancel * SOAP_FMAC4 soap_instantiate__s0__SubscriptionCancel(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__s0__SubscriptionCancel(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__s0__SubscriptionCancel, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _s0__SubscriptionCancel;
		if (size)
			*size = sizeof(_s0__SubscriptionCancel);
		((_s0__SubscriptionCancel*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _s0__SubscriptionCancel[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_s0__SubscriptionCancel);
		for (int i = 0; i < n; i++)
			((_s0__SubscriptionCancel*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_s0__SubscriptionCancel*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__SubscriptionCancel(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__SubscriptionCancel %p -> %p\n", q, p));
	*(_s0__SubscriptionCancel*)p = *(_s0__SubscriptionCancel*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__SubscriptionPolledRefreshResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_s0__SubscriptionPolledRefreshResponse*)this)->SubscriptionPolledRefreshResult = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &((_s0__SubscriptionPolledRefreshResponse*)this)->InvalidServerSubHandles);
	soap_default_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(soap, &((_s0__SubscriptionPolledRefreshResponse*)this)->RItemList);
	soap_default_std__vectorTemplateOfPointerTos0__OPCError(soap, &((_s0__SubscriptionPolledRefreshResponse*)this)->Errors);
	((_s0__SubscriptionPolledRefreshResponse*)this)->DataBufferOverflow = NULL;
	/* transient soap skipped */
}

void _s0__SubscriptionPolledRefreshResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTos0__ReplyBase(soap, &((_s0__SubscriptionPolledRefreshResponse*)this)->SubscriptionPolledRefreshResult);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((_s0__SubscriptionPolledRefreshResponse*)this)->InvalidServerSubHandles);
	soap_serialize_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(soap, &((_s0__SubscriptionPolledRefreshResponse*)this)->RItemList);
	soap_serialize_std__vectorTemplateOfPointerTos0__OPCError(soap, &((_s0__SubscriptionPolledRefreshResponse*)this)->Errors);
	/* transient soap skipped */
}

int _s0__SubscriptionPolledRefreshResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__SubscriptionPolledRefreshResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _s0__SubscriptionPolledRefreshResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__s0__SubscriptionPolledRefreshResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__SubscriptionPolledRefreshResponse(struct soap *soap, const char *tag, int id, const _s0__SubscriptionPolledRefreshResponse *a, const char *type)
{
	if (((_s0__SubscriptionPolledRefreshResponse *)a)->DataBufferOverflow)
		soap_set_attr(soap, "DataBufferOverflow", soap_bool2s(soap, *((_s0__SubscriptionPolledRefreshResponse *)a)->DataBufferOverflow));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__SubscriptionPolledRefreshResponse), type);
	if (a->SubscriptionPolledRefreshResult)
		soap_element_result(soap, "s0:SubscriptionPolledRefreshResult");
	soap_out_PointerTos0__ReplyBase(soap, "s0:SubscriptionPolledRefreshResult", -1, &(((_s0__SubscriptionPolledRefreshResponse*)a)->SubscriptionPolledRefreshResult), "");
	soap_out_std__vectorTemplateOfstd__string(soap, "s0:InvalidServerSubHandles", -1, &(((_s0__SubscriptionPolledRefreshResponse*)a)->InvalidServerSubHandles), "");
	soap_out_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(soap, "s0:RItemList", -1, &(((_s0__SubscriptionPolledRefreshResponse*)a)->RItemList), "");
	soap_out_std__vectorTemplateOfPointerTos0__OPCError(soap, "s0:Errors", -1, &(((_s0__SubscriptionPolledRefreshResponse*)a)->Errors), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_s0__SubscriptionPolledRefreshResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__s0__SubscriptionPolledRefreshResponse(soap, this, tag, type);
}

SOAP_FMAC3 _s0__SubscriptionPolledRefreshResponse * SOAP_FMAC4 soap_get__s0__SubscriptionPolledRefreshResponse(struct soap *soap, _s0__SubscriptionPolledRefreshResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__s0__SubscriptionPolledRefreshResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_s0__SubscriptionPolledRefreshResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__s0__SubscriptionPolledRefreshResponse(soap, tag, this, type);
}

SOAP_FMAC3 _s0__SubscriptionPolledRefreshResponse * SOAP_FMAC4 soap_in__s0__SubscriptionPolledRefreshResponse(struct soap *soap, const char *tag, _s0__SubscriptionPolledRefreshResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_s0__SubscriptionPolledRefreshResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__s0__SubscriptionPolledRefreshResponse, sizeof(_s0__SubscriptionPolledRefreshResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__s0__SubscriptionPolledRefreshResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_s0__SubscriptionPolledRefreshResponse *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "DataBufferOverflow", 0);
		if (t)
		{	if (!(((_s0__SubscriptionPolledRefreshResponse *)a)->DataBufferOverflow = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((_s0__SubscriptionPolledRefreshResponse *)a)->DataBufferOverflow))
		return NULL;
		}
	}
	short soap_flag_SubscriptionPolledRefreshResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionPolledRefreshResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTos0__ReplyBase(soap, "s0:SubscriptionPolledRefreshResult", &(((_s0__SubscriptionPolledRefreshResponse*)a)->SubscriptionPolledRefreshResult), "s0:ReplyBase"))
				{	soap_flag_SubscriptionPolledRefreshResult1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "s0:InvalidServerSubHandles", &(((_s0__SubscriptionPolledRefreshResponse*)a)->InvalidServerSubHandles), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(soap, "s0:RItemList", &(((_s0__SubscriptionPolledRefreshResponse*)a)->RItemList), "s0:SubscribePolledRefreshReplyItemList"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTos0__OPCError(soap, "s0:Errors", &(((_s0__SubscriptionPolledRefreshResponse*)a)->Errors), "s0:OPCError"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "s0:SubscriptionPolledRefreshResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_s0__SubscriptionPolledRefreshResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__s0__SubscriptionPolledRefreshResponse, 0, sizeof(_s0__SubscriptionPolledRefreshResponse), 0, soap_copy__s0__SubscriptionPolledRefreshResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _s0__SubscriptionPolledRefreshResponse * SOAP_FMAC6 soap_new__s0__SubscriptionPolledRefreshResponse(struct soap *soap, int n)
{	return soap_instantiate__s0__SubscriptionPolledRefreshResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__SubscriptionPolledRefreshResponse(struct soap *soap, _s0__SubscriptionPolledRefreshResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _s0__SubscriptionPolledRefreshResponse * SOAP_FMAC4 soap_instantiate__s0__SubscriptionPolledRefreshResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__s0__SubscriptionPolledRefreshResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__s0__SubscriptionPolledRefreshResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _s0__SubscriptionPolledRefreshResponse;
		if (size)
			*size = sizeof(_s0__SubscriptionPolledRefreshResponse);
		((_s0__SubscriptionPolledRefreshResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _s0__SubscriptionPolledRefreshResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_s0__SubscriptionPolledRefreshResponse);
		for (int i = 0; i < n; i++)
			((_s0__SubscriptionPolledRefreshResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_s0__SubscriptionPolledRefreshResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__SubscriptionPolledRefreshResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__SubscriptionPolledRefreshResponse %p -> %p\n", q, p));
	*(_s0__SubscriptionPolledRefreshResponse*)p = *(_s0__SubscriptionPolledRefreshResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__SubscriptionPolledRefresh::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_s0__SubscriptionPolledRefresh*)this)->Options = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &((_s0__SubscriptionPolledRefresh*)this)->ServerSubHandles);
	((_s0__SubscriptionPolledRefresh*)this)->HoldTime = NULL;
	((_s0__SubscriptionPolledRefresh*)this)->WaitTime = NULL;
	((_s0__SubscriptionPolledRefresh*)this)->ReturnAllItems = NULL;
	/* transient soap skipped */
}

void _s0__SubscriptionPolledRefresh::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTos0__RequestOptions(soap, &((_s0__SubscriptionPolledRefresh*)this)->Options);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((_s0__SubscriptionPolledRefresh*)this)->ServerSubHandles);
	soap_serialize_PointerToxsd__dateTime(soap, &((_s0__SubscriptionPolledRefresh*)this)->HoldTime);
	/* transient soap skipped */
}

int _s0__SubscriptionPolledRefresh::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__SubscriptionPolledRefresh);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _s0__SubscriptionPolledRefresh::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__s0__SubscriptionPolledRefresh(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__SubscriptionPolledRefresh(struct soap *soap, const char *tag, int id, const _s0__SubscriptionPolledRefresh *a, const char *type)
{
	if (((_s0__SubscriptionPolledRefresh *)a)->WaitTime)
		soap_set_attr(soap, "WaitTime", soap_int2s(soap, *((_s0__SubscriptionPolledRefresh *)a)->WaitTime));
	if (((_s0__SubscriptionPolledRefresh *)a)->ReturnAllItems)
		soap_set_attr(soap, "ReturnAllItems", soap_bool2s(soap, *((_s0__SubscriptionPolledRefresh *)a)->ReturnAllItems));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__SubscriptionPolledRefresh), type);
	soap_out_PointerTos0__RequestOptions(soap, "s0:Options", -1, &(((_s0__SubscriptionPolledRefresh*)a)->Options), "");
	soap_out_std__vectorTemplateOfstd__string(soap, "s0:ServerSubHandles", -1, &(((_s0__SubscriptionPolledRefresh*)a)->ServerSubHandles), "");
	soap_out_PointerToxsd__dateTime(soap, "s0:HoldTime", -1, &(((_s0__SubscriptionPolledRefresh*)a)->HoldTime), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_s0__SubscriptionPolledRefresh::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__s0__SubscriptionPolledRefresh(soap, this, tag, type);
}

SOAP_FMAC3 _s0__SubscriptionPolledRefresh * SOAP_FMAC4 soap_get__s0__SubscriptionPolledRefresh(struct soap *soap, _s0__SubscriptionPolledRefresh *p, const char *tag, const char *type)
{
	if ((p = soap_in__s0__SubscriptionPolledRefresh(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_s0__SubscriptionPolledRefresh::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__s0__SubscriptionPolledRefresh(soap, tag, this, type);
}

SOAP_FMAC3 _s0__SubscriptionPolledRefresh * SOAP_FMAC4 soap_in__s0__SubscriptionPolledRefresh(struct soap *soap, const char *tag, _s0__SubscriptionPolledRefresh *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_s0__SubscriptionPolledRefresh *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__s0__SubscriptionPolledRefresh, sizeof(_s0__SubscriptionPolledRefresh), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__s0__SubscriptionPolledRefresh)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_s0__SubscriptionPolledRefresh *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "WaitTime", 0);
		if (t)
		{	if (!(((_s0__SubscriptionPolledRefresh *)a)->WaitTime = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((_s0__SubscriptionPolledRefresh *)a)->WaitTime))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnAllItems", 0);
		if (t)
		{	if (!(((_s0__SubscriptionPolledRefresh *)a)->ReturnAllItems = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((_s0__SubscriptionPolledRefresh *)a)->ReturnAllItems))
		return NULL;
		}
	}
	short soap_flag_Options1 = 1, soap_flag_HoldTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTos0__RequestOptions(soap, "s0:Options", &(((_s0__SubscriptionPolledRefresh*)a)->Options), "s0:RequestOptions"))
				{	soap_flag_Options1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "s0:ServerSubHandles", &(((_s0__SubscriptionPolledRefresh*)a)->ServerSubHandles), "xsd:string"))
					continue;
			if (soap_flag_HoldTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__dateTime(soap, "s0:HoldTime", &(((_s0__SubscriptionPolledRefresh*)a)->HoldTime), "xsd:dateTime"))
				{	soap_flag_HoldTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_s0__SubscriptionPolledRefresh *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__s0__SubscriptionPolledRefresh, 0, sizeof(_s0__SubscriptionPolledRefresh), 0, soap_copy__s0__SubscriptionPolledRefresh);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _s0__SubscriptionPolledRefresh * SOAP_FMAC6 soap_new__s0__SubscriptionPolledRefresh(struct soap *soap, int n)
{	return soap_instantiate__s0__SubscriptionPolledRefresh(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__SubscriptionPolledRefresh(struct soap *soap, _s0__SubscriptionPolledRefresh *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _s0__SubscriptionPolledRefresh * SOAP_FMAC4 soap_instantiate__s0__SubscriptionPolledRefresh(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__s0__SubscriptionPolledRefresh(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__s0__SubscriptionPolledRefresh, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _s0__SubscriptionPolledRefresh;
		if (size)
			*size = sizeof(_s0__SubscriptionPolledRefresh);
		((_s0__SubscriptionPolledRefresh*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _s0__SubscriptionPolledRefresh[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_s0__SubscriptionPolledRefresh);
		for (int i = 0; i < n; i++)
			((_s0__SubscriptionPolledRefresh*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_s0__SubscriptionPolledRefresh*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__SubscriptionPolledRefresh(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__SubscriptionPolledRefresh %p -> %p\n", q, p));
	*(_s0__SubscriptionPolledRefresh*)p = *(_s0__SubscriptionPolledRefresh*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__SubscribeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_s0__SubscribeResponse*)this)->SubscribeResult = NULL;
	((_s0__SubscribeResponse*)this)->RItemList = NULL;
	soap_default_std__vectorTemplateOfPointerTos0__OPCError(soap, &((_s0__SubscribeResponse*)this)->Errors);
	((_s0__SubscribeResponse*)this)->ServerSubHandle = NULL;
	/* transient soap skipped */
}

void _s0__SubscribeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTos0__ReplyBase(soap, &((_s0__SubscribeResponse*)this)->SubscribeResult);
	soap_serialize_PointerTos0__SubscribeReplyItemList(soap, &((_s0__SubscribeResponse*)this)->RItemList);
	soap_serialize_std__vectorTemplateOfPointerTos0__OPCError(soap, &((_s0__SubscribeResponse*)this)->Errors);
	/* transient soap skipped */
}

int _s0__SubscribeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__SubscribeResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _s0__SubscribeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__s0__SubscribeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__SubscribeResponse(struct soap *soap, const char *tag, int id, const _s0__SubscribeResponse *a, const char *type)
{
	if (((_s0__SubscribeResponse *)a)->ServerSubHandle)
		soap_set_attr(soap, "ServerSubHandle", ((_s0__SubscribeResponse *)a)->ServerSubHandle->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__SubscribeResponse), type);
	if (a->SubscribeResult)
		soap_element_result(soap, "s0:SubscribeResult");
	soap_out_PointerTos0__ReplyBase(soap, "s0:SubscribeResult", -1, &(((_s0__SubscribeResponse*)a)->SubscribeResult), "");
	soap_out_PointerTos0__SubscribeReplyItemList(soap, "s0:RItemList", -1, &(((_s0__SubscribeResponse*)a)->RItemList), "");
	soap_out_std__vectorTemplateOfPointerTos0__OPCError(soap, "s0:Errors", -1, &(((_s0__SubscribeResponse*)a)->Errors), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_s0__SubscribeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__s0__SubscribeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _s0__SubscribeResponse * SOAP_FMAC4 soap_get__s0__SubscribeResponse(struct soap *soap, _s0__SubscribeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__s0__SubscribeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_s0__SubscribeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__s0__SubscribeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _s0__SubscribeResponse * SOAP_FMAC4 soap_in__s0__SubscribeResponse(struct soap *soap, const char *tag, _s0__SubscribeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_s0__SubscribeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__s0__SubscribeResponse, sizeof(_s0__SubscribeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__s0__SubscribeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_s0__SubscribeResponse *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ServerSubHandle", 0);
		if (t)
		{	if (!(((_s0__SubscribeResponse *)a)->ServerSubHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_s0__SubscribeResponse *)a)->ServerSubHandle = soap_new_std__string(soap, -1);
			((_s0__SubscribeResponse *)a)->ServerSubHandle->assign(s);
		}
		}
	}
	short soap_flag_SubscribeResult1 = 1, soap_flag_RItemList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscribeResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTos0__ReplyBase(soap, "s0:SubscribeResult", &(((_s0__SubscribeResponse*)a)->SubscribeResult), "s0:ReplyBase"))
				{	soap_flag_SubscribeResult1--;
					continue;
				}
			if (soap_flag_RItemList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTos0__SubscribeReplyItemList(soap, "s0:RItemList", &(((_s0__SubscribeResponse*)a)->RItemList), "s0:SubscribeReplyItemList"))
				{	soap_flag_RItemList1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTos0__OPCError(soap, "s0:Errors", &(((_s0__SubscribeResponse*)a)->Errors), "s0:OPCError"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "s0:SubscribeResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_s0__SubscribeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__s0__SubscribeResponse, 0, sizeof(_s0__SubscribeResponse), 0, soap_copy__s0__SubscribeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _s0__SubscribeResponse * SOAP_FMAC6 soap_new__s0__SubscribeResponse(struct soap *soap, int n)
{	return soap_instantiate__s0__SubscribeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__SubscribeResponse(struct soap *soap, _s0__SubscribeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _s0__SubscribeResponse * SOAP_FMAC4 soap_instantiate__s0__SubscribeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__s0__SubscribeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__s0__SubscribeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _s0__SubscribeResponse;
		if (size)
			*size = sizeof(_s0__SubscribeResponse);
		((_s0__SubscribeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _s0__SubscribeResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_s0__SubscribeResponse);
		for (int i = 0; i < n; i++)
			((_s0__SubscribeResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_s0__SubscribeResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__SubscribeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__SubscribeResponse %p -> %p\n", q, p));
	*(_s0__SubscribeResponse*)p = *(_s0__SubscribeResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__Subscribe::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_s0__Subscribe*)this)->Options = NULL;
	((_s0__Subscribe*)this)->ItemList = NULL;
	soap_default_bool(soap, &((_s0__Subscribe*)this)->ReturnValuesOnReply);
	((_s0__Subscribe*)this)->SubscriptionPingRate = NULL;
	/* transient soap skipped */
}

void _s0__Subscribe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTos0__RequestOptions(soap, &((_s0__Subscribe*)this)->Options);
	soap_serialize_PointerTos0__SubscribeRequestItemList(soap, &((_s0__Subscribe*)this)->ItemList);
	/* transient soap skipped */
}

int _s0__Subscribe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__Subscribe);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _s0__Subscribe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__s0__Subscribe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__Subscribe(struct soap *soap, const char *tag, int id, const _s0__Subscribe *a, const char *type)
{
	soap_set_attr(soap, "ReturnValuesOnReply", soap_bool2s(soap, ((_s0__Subscribe *)a)->ReturnValuesOnReply));
	if (((_s0__Subscribe *)a)->SubscriptionPingRate)
		soap_set_attr(soap, "SubscriptionPingRate", soap_int2s(soap, *((_s0__Subscribe *)a)->SubscriptionPingRate));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__Subscribe), type);
	soap_out_PointerTos0__RequestOptions(soap, "s0:Options", -1, &(((_s0__Subscribe*)a)->Options), "");
	soap_out_PointerTos0__SubscribeRequestItemList(soap, "s0:ItemList", -1, &(((_s0__Subscribe*)a)->ItemList), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_s0__Subscribe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__s0__Subscribe(soap, this, tag, type);
}

SOAP_FMAC3 _s0__Subscribe * SOAP_FMAC4 soap_get__s0__Subscribe(struct soap *soap, _s0__Subscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in__s0__Subscribe(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_s0__Subscribe::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__s0__Subscribe(soap, tag, this, type);
}

SOAP_FMAC3 _s0__Subscribe * SOAP_FMAC4 soap_in__s0__Subscribe(struct soap *soap, const char *tag, _s0__Subscribe *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_s0__Subscribe *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__s0__Subscribe, sizeof(_s0__Subscribe), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__s0__Subscribe)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_s0__Subscribe *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "ReturnValuesOnReply", 1), &((_s0__Subscribe *)a)->ReturnValuesOnReply))
		return NULL;
	{	const char *t = soap_attr_value(soap, "SubscriptionPingRate", 0);
		if (t)
		{	if (!(((_s0__Subscribe *)a)->SubscriptionPingRate = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((_s0__Subscribe *)a)->SubscriptionPingRate))
		return NULL;
		}
	}
	short soap_flag_Options1 = 1, soap_flag_ItemList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTos0__RequestOptions(soap, "s0:Options", &(((_s0__Subscribe*)a)->Options), "s0:RequestOptions"))
				{	soap_flag_Options1--;
					continue;
				}
			if (soap_flag_ItemList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTos0__SubscribeRequestItemList(soap, "s0:ItemList", &(((_s0__Subscribe*)a)->ItemList), "s0:SubscribeRequestItemList"))
				{	soap_flag_ItemList1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_s0__Subscribe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__s0__Subscribe, 0, sizeof(_s0__Subscribe), 0, soap_copy__s0__Subscribe);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _s0__Subscribe * SOAP_FMAC6 soap_new__s0__Subscribe(struct soap *soap, int n)
{	return soap_instantiate__s0__Subscribe(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__Subscribe(struct soap *soap, _s0__Subscribe *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _s0__Subscribe * SOAP_FMAC4 soap_instantiate__s0__Subscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__s0__Subscribe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__s0__Subscribe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _s0__Subscribe;
		if (size)
			*size = sizeof(_s0__Subscribe);
		((_s0__Subscribe*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _s0__Subscribe[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_s0__Subscribe);
		for (int i = 0; i < n; i++)
			((_s0__Subscribe*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_s0__Subscribe*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__Subscribe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__Subscribe %p -> %p\n", q, p));
	*(_s0__Subscribe*)p = *(_s0__Subscribe*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__WriteResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_s0__WriteResponse*)this)->WriteResult = NULL;
	((_s0__WriteResponse*)this)->RItemList = NULL;
	soap_default_std__vectorTemplateOfPointerTos0__OPCError(soap, &((_s0__WriteResponse*)this)->Errors);
	/* transient soap skipped */
}

void _s0__WriteResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTos0__ReplyBase(soap, &((_s0__WriteResponse*)this)->WriteResult);
	soap_serialize_PointerTos0__ReplyItemList(soap, &((_s0__WriteResponse*)this)->RItemList);
	soap_serialize_std__vectorTemplateOfPointerTos0__OPCError(soap, &((_s0__WriteResponse*)this)->Errors);
	/* transient soap skipped */
}

int _s0__WriteResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__WriteResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _s0__WriteResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__s0__WriteResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__WriteResponse(struct soap *soap, const char *tag, int id, const _s0__WriteResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__WriteResponse), type);
	if (a->WriteResult)
		soap_element_result(soap, "s0:WriteResult");
	soap_out_PointerTos0__ReplyBase(soap, "s0:WriteResult", -1, &(((_s0__WriteResponse*)a)->WriteResult), "");
	soap_out_PointerTos0__ReplyItemList(soap, "s0:RItemList", -1, &(((_s0__WriteResponse*)a)->RItemList), "");
	soap_out_std__vectorTemplateOfPointerTos0__OPCError(soap, "s0:Errors", -1, &(((_s0__WriteResponse*)a)->Errors), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_s0__WriteResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__s0__WriteResponse(soap, this, tag, type);
}

SOAP_FMAC3 _s0__WriteResponse * SOAP_FMAC4 soap_get__s0__WriteResponse(struct soap *soap, _s0__WriteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__s0__WriteResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_s0__WriteResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__s0__WriteResponse(soap, tag, this, type);
}

SOAP_FMAC3 _s0__WriteResponse * SOAP_FMAC4 soap_in__s0__WriteResponse(struct soap *soap, const char *tag, _s0__WriteResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_s0__WriteResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__s0__WriteResponse, sizeof(_s0__WriteResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__s0__WriteResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_s0__WriteResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_WriteResult1 = 1, soap_flag_RItemList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WriteResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTos0__ReplyBase(soap, "s0:WriteResult", &(((_s0__WriteResponse*)a)->WriteResult), "s0:ReplyBase"))
				{	soap_flag_WriteResult1--;
					continue;
				}
			if (soap_flag_RItemList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTos0__ReplyItemList(soap, "s0:RItemList", &(((_s0__WriteResponse*)a)->RItemList), "s0:ReplyItemList"))
				{	soap_flag_RItemList1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTos0__OPCError(soap, "s0:Errors", &(((_s0__WriteResponse*)a)->Errors), "s0:OPCError"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "s0:WriteResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_s0__WriteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__s0__WriteResponse, 0, sizeof(_s0__WriteResponse), 0, soap_copy__s0__WriteResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _s0__WriteResponse * SOAP_FMAC6 soap_new__s0__WriteResponse(struct soap *soap, int n)
{	return soap_instantiate__s0__WriteResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__WriteResponse(struct soap *soap, _s0__WriteResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _s0__WriteResponse * SOAP_FMAC4 soap_instantiate__s0__WriteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__s0__WriteResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__s0__WriteResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _s0__WriteResponse;
		if (size)
			*size = sizeof(_s0__WriteResponse);
		((_s0__WriteResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _s0__WriteResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_s0__WriteResponse);
		for (int i = 0; i < n; i++)
			((_s0__WriteResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_s0__WriteResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__WriteResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__WriteResponse %p -> %p\n", q, p));
	*(_s0__WriteResponse*)p = *(_s0__WriteResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__Write::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_s0__Write*)this)->Options = NULL;
	((_s0__Write*)this)->ItemList = NULL;
	soap_default_bool(soap, &((_s0__Write*)this)->ReturnValuesOnReply);
	/* transient soap skipped */
}

void _s0__Write::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTos0__RequestOptions(soap, &((_s0__Write*)this)->Options);
	soap_serialize_PointerTos0__WriteRequestItemList(soap, &((_s0__Write*)this)->ItemList);
	/* transient soap skipped */
}

int _s0__Write::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__Write);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _s0__Write::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__s0__Write(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__Write(struct soap *soap, const char *tag, int id, const _s0__Write *a, const char *type)
{
	soap_set_attr(soap, "ReturnValuesOnReply", soap_bool2s(soap, ((_s0__Write *)a)->ReturnValuesOnReply));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__Write), type);
	soap_out_PointerTos0__RequestOptions(soap, "s0:Options", -1, &(((_s0__Write*)a)->Options), "");
	soap_out_PointerTos0__WriteRequestItemList(soap, "s0:ItemList", -1, &(((_s0__Write*)a)->ItemList), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_s0__Write::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__s0__Write(soap, this, tag, type);
}

SOAP_FMAC3 _s0__Write * SOAP_FMAC4 soap_get__s0__Write(struct soap *soap, _s0__Write *p, const char *tag, const char *type)
{
	if ((p = soap_in__s0__Write(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_s0__Write::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__s0__Write(soap, tag, this, type);
}

SOAP_FMAC3 _s0__Write * SOAP_FMAC4 soap_in__s0__Write(struct soap *soap, const char *tag, _s0__Write *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_s0__Write *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__s0__Write, sizeof(_s0__Write), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__s0__Write)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_s0__Write *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "ReturnValuesOnReply", 1), &((_s0__Write *)a)->ReturnValuesOnReply))
		return NULL;
	short soap_flag_Options1 = 1, soap_flag_ItemList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTos0__RequestOptions(soap, "s0:Options", &(((_s0__Write*)a)->Options), "s0:RequestOptions"))
				{	soap_flag_Options1--;
					continue;
				}
			if (soap_flag_ItemList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTos0__WriteRequestItemList(soap, "s0:ItemList", &(((_s0__Write*)a)->ItemList), "s0:WriteRequestItemList"))
				{	soap_flag_ItemList1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_s0__Write *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__s0__Write, 0, sizeof(_s0__Write), 0, soap_copy__s0__Write);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _s0__Write * SOAP_FMAC6 soap_new__s0__Write(struct soap *soap, int n)
{	return soap_instantiate__s0__Write(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__Write(struct soap *soap, _s0__Write *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _s0__Write * SOAP_FMAC4 soap_instantiate__s0__Write(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__s0__Write(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__s0__Write, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _s0__Write;
		if (size)
			*size = sizeof(_s0__Write);
		((_s0__Write*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _s0__Write[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_s0__Write);
		for (int i = 0; i < n; i++)
			((_s0__Write*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_s0__Write*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__Write(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__Write %p -> %p\n", q, p));
	*(_s0__Write*)p = *(_s0__Write*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__ReadResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_s0__ReadResponse*)this)->ReadResult = NULL;
	((_s0__ReadResponse*)this)->RItemList = NULL;
	soap_default_std__vectorTemplateOfPointerTos0__OPCError(soap, &((_s0__ReadResponse*)this)->Errors);
	/* transient soap skipped */
}

void _s0__ReadResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTos0__ReplyBase(soap, &((_s0__ReadResponse*)this)->ReadResult);
	soap_serialize_PointerTos0__ReplyItemList(soap, &((_s0__ReadResponse*)this)->RItemList);
	soap_serialize_std__vectorTemplateOfPointerTos0__OPCError(soap, &((_s0__ReadResponse*)this)->Errors);
	/* transient soap skipped */
}

int _s0__ReadResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__ReadResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _s0__ReadResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__s0__ReadResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__ReadResponse(struct soap *soap, const char *tag, int id, const _s0__ReadResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__ReadResponse), type);
	if (a->ReadResult)
		soap_element_result(soap, "s0:ReadResult");
	soap_out_PointerTos0__ReplyBase(soap, "s0:ReadResult", -1, &(((_s0__ReadResponse*)a)->ReadResult), "");
	soap_out_PointerTos0__ReplyItemList(soap, "s0:RItemList", -1, &(((_s0__ReadResponse*)a)->RItemList), "");
	soap_out_std__vectorTemplateOfPointerTos0__OPCError(soap, "s0:Errors", -1, &(((_s0__ReadResponse*)a)->Errors), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_s0__ReadResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__s0__ReadResponse(soap, this, tag, type);
}

SOAP_FMAC3 _s0__ReadResponse * SOAP_FMAC4 soap_get__s0__ReadResponse(struct soap *soap, _s0__ReadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__s0__ReadResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_s0__ReadResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__s0__ReadResponse(soap, tag, this, type);
}

SOAP_FMAC3 _s0__ReadResponse * SOAP_FMAC4 soap_in__s0__ReadResponse(struct soap *soap, const char *tag, _s0__ReadResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_s0__ReadResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__s0__ReadResponse, sizeof(_s0__ReadResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__s0__ReadResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_s0__ReadResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_ReadResult1 = 1, soap_flag_RItemList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReadResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTos0__ReplyBase(soap, "s0:ReadResult", &(((_s0__ReadResponse*)a)->ReadResult), "s0:ReplyBase"))
				{	soap_flag_ReadResult1--;
					continue;
				}
			if (soap_flag_RItemList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTos0__ReplyItemList(soap, "s0:RItemList", &(((_s0__ReadResponse*)a)->RItemList), "s0:ReplyItemList"))
				{	soap_flag_RItemList1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTos0__OPCError(soap, "s0:Errors", &(((_s0__ReadResponse*)a)->Errors), "s0:OPCError"))
					continue;
			/* transient soap skipped */
			soap_check_result(soap, "s0:ReadResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_s0__ReadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__s0__ReadResponse, 0, sizeof(_s0__ReadResponse), 0, soap_copy__s0__ReadResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _s0__ReadResponse * SOAP_FMAC6 soap_new__s0__ReadResponse(struct soap *soap, int n)
{	return soap_instantiate__s0__ReadResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__ReadResponse(struct soap *soap, _s0__ReadResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _s0__ReadResponse * SOAP_FMAC4 soap_instantiate__s0__ReadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__s0__ReadResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__s0__ReadResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _s0__ReadResponse;
		if (size)
			*size = sizeof(_s0__ReadResponse);
		((_s0__ReadResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _s0__ReadResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_s0__ReadResponse);
		for (int i = 0; i < n; i++)
			((_s0__ReadResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_s0__ReadResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__ReadResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__ReadResponse %p -> %p\n", q, p));
	*(_s0__ReadResponse*)p = *(_s0__ReadResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__Read::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_s0__Read*)this)->Options = NULL;
	((_s0__Read*)this)->ItemList = NULL;
	/* transient soap skipped */
}

void _s0__Read::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTos0__RequestOptions(soap, &((_s0__Read*)this)->Options);
	soap_serialize_PointerTos0__ReadRequestItemList(soap, &((_s0__Read*)this)->ItemList);
	/* transient soap skipped */
}

int _s0__Read::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__Read);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _s0__Read::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__s0__Read(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__Read(struct soap *soap, const char *tag, int id, const _s0__Read *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__Read), type);
	soap_out_PointerTos0__RequestOptions(soap, "s0:Options", -1, &(((_s0__Read*)a)->Options), "");
	soap_out_PointerTos0__ReadRequestItemList(soap, "s0:ItemList", -1, &(((_s0__Read*)a)->ItemList), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_s0__Read::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__s0__Read(soap, this, tag, type);
}

SOAP_FMAC3 _s0__Read * SOAP_FMAC4 soap_get__s0__Read(struct soap *soap, _s0__Read *p, const char *tag, const char *type)
{
	if ((p = soap_in__s0__Read(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_s0__Read::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__s0__Read(soap, tag, this, type);
}

SOAP_FMAC3 _s0__Read * SOAP_FMAC4 soap_in__s0__Read(struct soap *soap, const char *tag, _s0__Read *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_s0__Read *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__s0__Read, sizeof(_s0__Read), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__s0__Read)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_s0__Read *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_Options1 = 1, soap_flag_ItemList1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTos0__RequestOptions(soap, "s0:Options", &(((_s0__Read*)a)->Options), "s0:RequestOptions"))
				{	soap_flag_Options1--;
					continue;
				}
			if (soap_flag_ItemList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTos0__ReadRequestItemList(soap, "s0:ItemList", &(((_s0__Read*)a)->ItemList), "s0:ReadRequestItemList"))
				{	soap_flag_ItemList1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_s0__Read *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__s0__Read, 0, sizeof(_s0__Read), 0, soap_copy__s0__Read);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _s0__Read * SOAP_FMAC6 soap_new__s0__Read(struct soap *soap, int n)
{	return soap_instantiate__s0__Read(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__Read(struct soap *soap, _s0__Read *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _s0__Read * SOAP_FMAC4 soap_instantiate__s0__Read(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__s0__Read(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__s0__Read, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _s0__Read;
		if (size)
			*size = sizeof(_s0__Read);
		((_s0__Read*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _s0__Read[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_s0__Read);
		for (int i = 0; i < n; i++)
			((_s0__Read*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_s0__Read*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__Read(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__Read %p -> %p\n", q, p));
	*(_s0__Read*)p = *(_s0__Read*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__GetStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_s0__GetStatusResponse*)this)->GetStatusResult = NULL;
	((_s0__GetStatusResponse*)this)->Status = NULL;
	/* transient soap skipped */
}

void _s0__GetStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTos0__ReplyBase(soap, &((_s0__GetStatusResponse*)this)->GetStatusResult);
	soap_serialize_PointerTos0__ServerStatus(soap, &((_s0__GetStatusResponse*)this)->Status);
	/* transient soap skipped */
}

int _s0__GetStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__GetStatusResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _s0__GetStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__s0__GetStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__GetStatusResponse(struct soap *soap, const char *tag, int id, const _s0__GetStatusResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__GetStatusResponse), type);
	if (a->GetStatusResult)
		soap_element_result(soap, "s0:GetStatusResult");
	soap_out_PointerTos0__ReplyBase(soap, "s0:GetStatusResult", -1, &(((_s0__GetStatusResponse*)a)->GetStatusResult), "");
	soap_out_PointerTos0__ServerStatus(soap, "s0:Status", -1, &(((_s0__GetStatusResponse*)a)->Status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_s0__GetStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__s0__GetStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _s0__GetStatusResponse * SOAP_FMAC4 soap_get__s0__GetStatusResponse(struct soap *soap, _s0__GetStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__s0__GetStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_s0__GetStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__s0__GetStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _s0__GetStatusResponse * SOAP_FMAC4 soap_in__s0__GetStatusResponse(struct soap *soap, const char *tag, _s0__GetStatusResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_s0__GetStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__s0__GetStatusResponse, sizeof(_s0__GetStatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__s0__GetStatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_s0__GetStatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_GetStatusResult1 = 1, soap_flag_Status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetStatusResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTos0__ReplyBase(soap, "s0:GetStatusResult", &(((_s0__GetStatusResponse*)a)->GetStatusResult), "s0:ReplyBase"))
				{	soap_flag_GetStatusResult1--;
					continue;
				}
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTos0__ServerStatus(soap, "s0:Status", &(((_s0__GetStatusResponse*)a)->Status), "s0:ServerStatus"))
				{	soap_flag_Status1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "s0:GetStatusResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_s0__GetStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__s0__GetStatusResponse, 0, sizeof(_s0__GetStatusResponse), 0, soap_copy__s0__GetStatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _s0__GetStatusResponse * SOAP_FMAC6 soap_new__s0__GetStatusResponse(struct soap *soap, int n)
{	return soap_instantiate__s0__GetStatusResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__GetStatusResponse(struct soap *soap, _s0__GetStatusResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _s0__GetStatusResponse * SOAP_FMAC4 soap_instantiate__s0__GetStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__s0__GetStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__s0__GetStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _s0__GetStatusResponse;
		if (size)
			*size = sizeof(_s0__GetStatusResponse);
		((_s0__GetStatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _s0__GetStatusResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_s0__GetStatusResponse);
		for (int i = 0; i < n; i++)
			((_s0__GetStatusResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_s0__GetStatusResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__GetStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__GetStatusResponse %p -> %p\n", q, p));
	*(_s0__GetStatusResponse*)p = *(_s0__GetStatusResponse*)q;
}
#ifdef __cplusplus
}
#endif

void _s0__GetStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	((_s0__GetStatus*)this)->LocaleID = NULL;
	((_s0__GetStatus*)this)->ClientRequestHandle = NULL;
	/* transient soap skipped */
}

void _s0__GetStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _s0__GetStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__s0__GetStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _s0__GetStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__s0__GetStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__s0__GetStatus(struct soap *soap, const char *tag, int id, const _s0__GetStatus *a, const char *type)
{
	if (((_s0__GetStatus *)a)->LocaleID)
		soap_set_attr(soap, "LocaleID", ((_s0__GetStatus *)a)->LocaleID->c_str());
	if (((_s0__GetStatus *)a)->ClientRequestHandle)
		soap_set_attr(soap, "ClientRequestHandle", ((_s0__GetStatus *)a)->ClientRequestHandle->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__s0__GetStatus), type);
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *_s0__GetStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__s0__GetStatus(soap, this, tag, type);
}

SOAP_FMAC3 _s0__GetStatus * SOAP_FMAC4 soap_get__s0__GetStatus(struct soap *soap, _s0__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__s0__GetStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *_s0__GetStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__s0__GetStatus(soap, tag, this, type);
}

SOAP_FMAC3 _s0__GetStatus * SOAP_FMAC4 soap_in__s0__GetStatus(struct soap *soap, const char *tag, _s0__GetStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_s0__GetStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__s0__GetStatus, sizeof(_s0__GetStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__s0__GetStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_s0__GetStatus *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "LocaleID", 0);
		if (t)
		{	if (!(((_s0__GetStatus *)a)->LocaleID = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_s0__GetStatus *)a)->LocaleID = soap_new_std__string(soap, -1);
			((_s0__GetStatus *)a)->LocaleID->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ClientRequestHandle", 0);
		if (t)
		{	if (!(((_s0__GetStatus *)a)->ClientRequestHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((_s0__GetStatus *)a)->ClientRequestHandle = soap_new_std__string(soap, -1);
			((_s0__GetStatus *)a)->ClientRequestHandle->assign(s);
		}
		}
	};
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_s0__GetStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__s0__GetStatus, 0, sizeof(_s0__GetStatus), 0, soap_copy__s0__GetStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _s0__GetStatus * SOAP_FMAC6 soap_new__s0__GetStatus(struct soap *soap, int n)
{	return soap_instantiate__s0__GetStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__s0__GetStatus(struct soap *soap, _s0__GetStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _s0__GetStatus * SOAP_FMAC4 soap_instantiate__s0__GetStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__s0__GetStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__s0__GetStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _s0__GetStatus;
		if (size)
			*size = sizeof(_s0__GetStatus);
		((_s0__GetStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _s0__GetStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_s0__GetStatus);
		for (int i = 0; i < n; i++)
			((_s0__GetStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_s0__GetStatus*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__s0__GetStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _s0__GetStatus %p -> %p\n", q, p));
	*(_s0__GetStatus*)p = *(_s0__GetStatus*)q;
}
#ifdef __cplusplus
}
#endif

void s0__PropertyReplyList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTos0__ItemProperty(soap, &((s0__PropertyReplyList*)this)->Properties);
	((s0__PropertyReplyList*)this)->ItemPath = NULL;
	((s0__PropertyReplyList*)this)->ItemName = NULL;
	((s0__PropertyReplyList*)this)->ResultID = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__PropertyReplyList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTos0__ItemProperty(soap, &((s0__PropertyReplyList*)this)->Properties);
	/* transient soap skipped */
}

int s0__PropertyReplyList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__PropertyReplyList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__PropertyReplyList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__PropertyReplyList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__PropertyReplyList(struct soap *soap, const char *tag, int id, const s0__PropertyReplyList *a, const char *type)
{
	if (((s0__PropertyReplyList *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((s0__PropertyReplyList *)a)->ItemPath->c_str());
	if (((s0__PropertyReplyList *)a)->ItemName)
		soap_set_attr(soap, "ItemName", ((s0__PropertyReplyList *)a)->ItemName->c_str());
	if (((s0__PropertyReplyList *)a)->ResultID)
		soap_set_attr(soap, "ResultID", soap_QName2s(soap, ((s0__PropertyReplyList *)a)->ResultID->c_str()));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__PropertyReplyList), "s0:PropertyReplyList");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTos0__ItemProperty(soap, "s0:Properties", -1, &(((s0__PropertyReplyList*)a)->Properties), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__PropertyReplyList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__PropertyReplyList(soap, this, tag, type);
}

SOAP_FMAC3 s0__PropertyReplyList * SOAP_FMAC4 soap_get_s0__PropertyReplyList(struct soap *soap, s0__PropertyReplyList *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__PropertyReplyList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__PropertyReplyList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__PropertyReplyList(soap, tag, this, type);
}

SOAP_FMAC3 s0__PropertyReplyList * SOAP_FMAC4 soap_in_s0__PropertyReplyList(struct soap *soap, const char *tag, s0__PropertyReplyList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__PropertyReplyList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__PropertyReplyList, sizeof(s0__PropertyReplyList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__PropertyReplyList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__PropertyReplyList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((s0__PropertyReplyList *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__PropertyReplyList *)a)->ItemPath = soap_new_std__string(soap, -1);
			((s0__PropertyReplyList *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemName", 0);
		if (t)
		{	if (!(((s0__PropertyReplyList *)a)->ItemName = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__PropertyReplyList *)a)->ItemName = soap_new_std__string(soap, -1);
			((s0__PropertyReplyList *)a)->ItemName->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ResultID", 0);
		if (t)
		{	if (!(((s0__PropertyReplyList *)a)->ResultID = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2QName(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__PropertyReplyList *)a)->ResultID = soap_new_std__string(soap, -1);
			((s0__PropertyReplyList *)a)->ResultID->assign(s);
		}
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTos0__ItemProperty(soap, "s0:Properties", &(((s0__PropertyReplyList*)a)->Properties), "s0:ItemProperty"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__PropertyReplyList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__PropertyReplyList, 0, sizeof(s0__PropertyReplyList), 0, soap_copy_s0__PropertyReplyList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__PropertyReplyList * SOAP_FMAC6 soap_new_s0__PropertyReplyList(struct soap *soap, int n)
{	return soap_instantiate_s0__PropertyReplyList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__PropertyReplyList(struct soap *soap, s0__PropertyReplyList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__PropertyReplyList * SOAP_FMAC4 soap_instantiate_s0__PropertyReplyList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__PropertyReplyList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__PropertyReplyList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__PropertyReplyList;
		if (size)
			*size = sizeof(s0__PropertyReplyList);
		((s0__PropertyReplyList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__PropertyReplyList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__PropertyReplyList);
		for (int i = 0; i < n; i++)
			((s0__PropertyReplyList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__PropertyReplyList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__PropertyReplyList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__PropertyReplyList %p -> %p\n", q, p));
	*(s0__PropertyReplyList*)p = *(s0__PropertyReplyList*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ItemIdentifier::soap_default(struct soap *soap)
{
	this->soap = soap;
	((s0__ItemIdentifier*)this)->ItemPath = NULL;
	((s0__ItemIdentifier*)this)->ItemName = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ItemIdentifier::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int s0__ItemIdentifier::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ItemIdentifier);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ItemIdentifier::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ItemIdentifier(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ItemIdentifier(struct soap *soap, const char *tag, int id, const s0__ItemIdentifier *a, const char *type)
{
	if (((s0__ItemIdentifier *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((s0__ItemIdentifier *)a)->ItemPath->c_str());
	if (((s0__ItemIdentifier *)a)->ItemName)
		soap_set_attr(soap, "ItemName", ((s0__ItemIdentifier *)a)->ItemName->c_str());
	return soap_outliteral(soap, tag, &(((xsd__anyType*)a)->__item), "s0:ItemIdentifier");
}

void *s0__ItemIdentifier::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ItemIdentifier(soap, this, tag, type);
}

SOAP_FMAC3 s0__ItemIdentifier * SOAP_FMAC4 soap_get_s0__ItemIdentifier(struct soap *soap, s0__ItemIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ItemIdentifier(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ItemIdentifier::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ItemIdentifier(soap, tag, this, type);
}

SOAP_FMAC3 s0__ItemIdentifier * SOAP_FMAC4 soap_in_s0__ItemIdentifier(struct soap *soap, const char *tag, s0__ItemIdentifier *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (s0__ItemIdentifier *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ItemIdentifier, sizeof(s0__ItemIdentifier), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ItemIdentifier)
			return (s0__ItemIdentifier *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((s0__ItemIdentifier *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ItemIdentifier *)a)->ItemPath = soap_new_std__string(soap, -1);
			((s0__ItemIdentifier *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemName", 0);
		if (t)
		{	if (!(((s0__ItemIdentifier *)a)->ItemName = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ItemIdentifier *)a)->ItemName = soap_new_std__string(soap, -1);
			((s0__ItemIdentifier *)a)->ItemName->assign(s);
		}
		}
	}
	if (!soap_inliteral(soap, tag, &(((xsd__anyType*)a)->__item)))
		return NULL;
	return a;
}

SOAP_FMAC5 s0__ItemIdentifier * SOAP_FMAC6 soap_new_s0__ItemIdentifier(struct soap *soap, int n)
{	return soap_instantiate_s0__ItemIdentifier(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ItemIdentifier(struct soap *soap, s0__ItemIdentifier *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ItemIdentifier * SOAP_FMAC4 soap_instantiate_s0__ItemIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ItemIdentifier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ItemIdentifier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ItemIdentifier;
		if (size)
			*size = sizeof(s0__ItemIdentifier);
		((s0__ItemIdentifier*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ItemIdentifier[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ItemIdentifier);
		for (int i = 0; i < n; i++)
			((s0__ItemIdentifier*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ItemIdentifier*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ItemIdentifier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ItemIdentifier %p -> %p\n", q, p));
	*(s0__ItemIdentifier*)p = *(s0__ItemIdentifier*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ItemProperty::soap_default(struct soap *soap)
{
	this->soap = soap;
	((s0__ItemProperty*)this)->Value = NULL;
	soap_default_xsd__QName(soap, &((s0__ItemProperty*)this)->Name);
	((s0__ItemProperty*)this)->Description = NULL;
	((s0__ItemProperty*)this)->ItemPath = NULL;
	((s0__ItemProperty*)this)->ItemName = NULL;
	((s0__ItemProperty*)this)->ResultID = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ItemProperty::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &((s0__ItemProperty*)this)->Value);
	/* transient soap skipped */
}

int s0__ItemProperty::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ItemProperty);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ItemProperty::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ItemProperty(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ItemProperty(struct soap *soap, const char *tag, int id, const s0__ItemProperty *a, const char *type)
{
	if (!((s0__ItemProperty *)a)->Name.empty())
		soap_set_attr(soap, "Name", soap_QName2s(soap, ((s0__ItemProperty *)a)->Name.c_str()));
	if (((s0__ItemProperty *)a)->Description)
		soap_set_attr(soap, "Description", ((s0__ItemProperty *)a)->Description->c_str());
	if (((s0__ItemProperty *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((s0__ItemProperty *)a)->ItemPath->c_str());
	if (((s0__ItemProperty *)a)->ItemName)
		soap_set_attr(soap, "ItemName", ((s0__ItemProperty *)a)->ItemName->c_str());
	if (((s0__ItemProperty *)a)->ResultID)
		soap_set_attr(soap, "ResultID", soap_QName2s(soap, ((s0__ItemProperty *)a)->ResultID->c_str()));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ItemProperty), "s0:ItemProperty");
	/* transient soap skipped */
	soap_out_PointerToxsd__anyType(soap, "s0:Value", -1, &(((s0__ItemProperty*)a)->Value), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__ItemProperty::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ItemProperty(soap, this, tag, type);
}

SOAP_FMAC3 s0__ItemProperty * SOAP_FMAC4 soap_get_s0__ItemProperty(struct soap *soap, s0__ItemProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ItemProperty(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ItemProperty::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ItemProperty(soap, tag, this, type);
}

SOAP_FMAC3 s0__ItemProperty * SOAP_FMAC4 soap_in_s0__ItemProperty(struct soap *soap, const char *tag, s0__ItemProperty *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__ItemProperty *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ItemProperty, sizeof(s0__ItemProperty), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ItemProperty)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__ItemProperty *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Name", 1);
		if (t)
		{	char *s;
			if (soap_s2QName(soap, t, &s))
				return NULL;
			((s0__ItemProperty *)a)->Name.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "Description", 0);
		if (t)
		{	if (!(((s0__ItemProperty *)a)->Description = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ItemProperty *)a)->Description = soap_new_std__string(soap, -1);
			((s0__ItemProperty *)a)->Description->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((s0__ItemProperty *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ItemProperty *)a)->ItemPath = soap_new_std__string(soap, -1);
			((s0__ItemProperty *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemName", 0);
		if (t)
		{	if (!(((s0__ItemProperty *)a)->ItemName = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ItemProperty *)a)->ItemName = soap_new_std__string(soap, -1);
			((s0__ItemProperty *)a)->ItemName->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ResultID", 0);
		if (t)
		{	if (!(((s0__ItemProperty *)a)->ResultID = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2QName(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ItemProperty *)a)->ResultID = soap_new_std__string(soap, -1);
			((s0__ItemProperty *)a)->ResultID->assign(s);
		}
		}
	}
	short soap_flag___item2 = 1, soap_flag_Value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "s0:Value", &(((s0__ItemProperty*)a)->Value), "xsd:anyType"))
				{	soap_flag_Value1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__ItemProperty *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__ItemProperty, 0, sizeof(s0__ItemProperty), 0, soap_copy_s0__ItemProperty);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__ItemProperty * SOAP_FMAC6 soap_new_s0__ItemProperty(struct soap *soap, int n)
{	return soap_instantiate_s0__ItemProperty(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ItemProperty(struct soap *soap, s0__ItemProperty *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ItemProperty * SOAP_FMAC4 soap_instantiate_s0__ItemProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ItemProperty(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ItemProperty, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ItemProperty;
		if (size)
			*size = sizeof(s0__ItemProperty);
		((s0__ItemProperty*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ItemProperty[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ItemProperty);
		for (int i = 0; i < n; i++)
			((s0__ItemProperty*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ItemProperty*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ItemProperty(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ItemProperty %p -> %p\n", q, p));
	*(s0__ItemProperty*)p = *(s0__ItemProperty*)q;
}
#ifdef __cplusplus
}
#endif

void s0__BrowseElement::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTos0__ItemProperty(soap, &((s0__BrowseElement*)this)->Properties);
	((s0__BrowseElement*)this)->Name = NULL;
	((s0__BrowseElement*)this)->ItemPath = NULL;
	((s0__BrowseElement*)this)->ItemName = NULL;
	soap_default_bool(soap, &((s0__BrowseElement*)this)->IsItem);
	soap_default_bool(soap, &((s0__BrowseElement*)this)->HasChildren);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__BrowseElement::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTos0__ItemProperty(soap, &((s0__BrowseElement*)this)->Properties);
	/* transient soap skipped */
}

int s0__BrowseElement::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__BrowseElement);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__BrowseElement::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__BrowseElement(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__BrowseElement(struct soap *soap, const char *tag, int id, const s0__BrowseElement *a, const char *type)
{
	if (((s0__BrowseElement *)a)->Name)
		soap_set_attr(soap, "Name", ((s0__BrowseElement *)a)->Name->c_str());
	if (((s0__BrowseElement *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((s0__BrowseElement *)a)->ItemPath->c_str());
	if (((s0__BrowseElement *)a)->ItemName)
		soap_set_attr(soap, "ItemName", ((s0__BrowseElement *)a)->ItemName->c_str());
	soap_set_attr(soap, "IsItem", soap_bool2s(soap, ((s0__BrowseElement *)a)->IsItem));
	soap_set_attr(soap, "HasChildren", soap_bool2s(soap, ((s0__BrowseElement *)a)->HasChildren));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__BrowseElement), "s0:BrowseElement");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTos0__ItemProperty(soap, "s0:Properties", -1, &(((s0__BrowseElement*)a)->Properties), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__BrowseElement::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__BrowseElement(soap, this, tag, type);
}

SOAP_FMAC3 s0__BrowseElement * SOAP_FMAC4 soap_get_s0__BrowseElement(struct soap *soap, s0__BrowseElement *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__BrowseElement(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__BrowseElement::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__BrowseElement(soap, tag, this, type);
}

SOAP_FMAC3 s0__BrowseElement * SOAP_FMAC4 soap_in_s0__BrowseElement(struct soap *soap, const char *tag, s0__BrowseElement *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__BrowseElement *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__BrowseElement, sizeof(s0__BrowseElement), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__BrowseElement)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__BrowseElement *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Name", 0);
		if (t)
		{	if (!(((s0__BrowseElement *)a)->Name = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__BrowseElement *)a)->Name = soap_new_std__string(soap, -1);
			((s0__BrowseElement *)a)->Name->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((s0__BrowseElement *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__BrowseElement *)a)->ItemPath = soap_new_std__string(soap, -1);
			((s0__BrowseElement *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemName", 0);
		if (t)
		{	if (!(((s0__BrowseElement *)a)->ItemName = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__BrowseElement *)a)->ItemName = soap_new_std__string(soap, -1);
			((s0__BrowseElement *)a)->ItemName->assign(s);
		}
		}
	}
	if (soap_s2bool(soap, soap_attr_value(soap, "IsItem", 1), &((s0__BrowseElement *)a)->IsItem))
		return NULL;
	if (soap_s2bool(soap, soap_attr_value(soap, "HasChildren", 1), &((s0__BrowseElement *)a)->HasChildren))
		return NULL;
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTos0__ItemProperty(soap, "s0:Properties", &(((s0__BrowseElement*)a)->Properties), "s0:ItemProperty"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__BrowseElement *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__BrowseElement, 0, sizeof(s0__BrowseElement), 0, soap_copy_s0__BrowseElement);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__BrowseElement * SOAP_FMAC6 soap_new_s0__BrowseElement(struct soap *soap, int n)
{	return soap_instantiate_s0__BrowseElement(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__BrowseElement(struct soap *soap, s0__BrowseElement *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__BrowseElement * SOAP_FMAC4 soap_instantiate_s0__BrowseElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__BrowseElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__BrowseElement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__BrowseElement;
		if (size)
			*size = sizeof(s0__BrowseElement);
		((s0__BrowseElement*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__BrowseElement[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__BrowseElement);
		for (int i = 0; i < n; i++)
			((s0__BrowseElement*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__BrowseElement*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__BrowseElement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__BrowseElement %p -> %p\n", q, p));
	*(s0__BrowseElement*)p = *(s0__BrowseElement*)q;
}
#ifdef __cplusplus
}
#endif

void s0__SubscribePolledRefreshReplyItemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTos0__ItemValue(soap, &((s0__SubscribePolledRefreshReplyItemList*)this)->Items);
	((s0__SubscribePolledRefreshReplyItemList*)this)->SubscriptionHandle = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__SubscribePolledRefreshReplyItemList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTos0__ItemValue(soap, &((s0__SubscribePolledRefreshReplyItemList*)this)->Items);
	/* transient soap skipped */
}

int s0__SubscribePolledRefreshReplyItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__SubscribePolledRefreshReplyItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__SubscribePolledRefreshReplyItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__SubscribePolledRefreshReplyItemList(struct soap *soap, const char *tag, int id, const s0__SubscribePolledRefreshReplyItemList *a, const char *type)
{
	if (((s0__SubscribePolledRefreshReplyItemList *)a)->SubscriptionHandle)
		soap_set_attr(soap, "SubscriptionHandle", ((s0__SubscribePolledRefreshReplyItemList *)a)->SubscriptionHandle->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList), "s0:SubscribePolledRefreshReplyItemList");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTos0__ItemValue(soap, "s0:Items", -1, &(((s0__SubscribePolledRefreshReplyItemList*)a)->Items), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__SubscribePolledRefreshReplyItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__SubscribePolledRefreshReplyItemList(soap, this, tag, type);
}

SOAP_FMAC3 s0__SubscribePolledRefreshReplyItemList * SOAP_FMAC4 soap_get_s0__SubscribePolledRefreshReplyItemList(struct soap *soap, s0__SubscribePolledRefreshReplyItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__SubscribePolledRefreshReplyItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__SubscribePolledRefreshReplyItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__SubscribePolledRefreshReplyItemList(soap, tag, this, type);
}

SOAP_FMAC3 s0__SubscribePolledRefreshReplyItemList * SOAP_FMAC4 soap_in_s0__SubscribePolledRefreshReplyItemList(struct soap *soap, const char *tag, s0__SubscribePolledRefreshReplyItemList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__SubscribePolledRefreshReplyItemList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList, sizeof(s0__SubscribePolledRefreshReplyItemList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__SubscribePolledRefreshReplyItemList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "SubscriptionHandle", 0);
		if (t)
		{	if (!(((s0__SubscribePolledRefreshReplyItemList *)a)->SubscriptionHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__SubscribePolledRefreshReplyItemList *)a)->SubscriptionHandle = soap_new_std__string(soap, -1);
			((s0__SubscribePolledRefreshReplyItemList *)a)->SubscriptionHandle->assign(s);
		}
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTos0__ItemValue(soap, "s0:Items", &(((s0__SubscribePolledRefreshReplyItemList*)a)->Items), "s0:ItemValue"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__SubscribePolledRefreshReplyItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList, 0, sizeof(s0__SubscribePolledRefreshReplyItemList), 0, soap_copy_s0__SubscribePolledRefreshReplyItemList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__SubscribePolledRefreshReplyItemList * SOAP_FMAC6 soap_new_s0__SubscribePolledRefreshReplyItemList(struct soap *soap, int n)
{	return soap_instantiate_s0__SubscribePolledRefreshReplyItemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__SubscribePolledRefreshReplyItemList(struct soap *soap, s0__SubscribePolledRefreshReplyItemList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__SubscribePolledRefreshReplyItemList * SOAP_FMAC4 soap_instantiate_s0__SubscribePolledRefreshReplyItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__SubscribePolledRefreshReplyItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__SubscribePolledRefreshReplyItemList;
		if (size)
			*size = sizeof(s0__SubscribePolledRefreshReplyItemList);
		((s0__SubscribePolledRefreshReplyItemList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__SubscribePolledRefreshReplyItemList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__SubscribePolledRefreshReplyItemList);
		for (int i = 0; i < n; i++)
			((s0__SubscribePolledRefreshReplyItemList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__SubscribePolledRefreshReplyItemList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__SubscribePolledRefreshReplyItemList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__SubscribePolledRefreshReplyItemList %p -> %p\n", q, p));
	*(s0__SubscribePolledRefreshReplyItemList*)p = *(s0__SubscribePolledRefreshReplyItemList*)q;
}
#ifdef __cplusplus
}
#endif

void s0__SubscribeItemValue::soap_default(struct soap *soap)
{
	this->soap = soap;
	((s0__SubscribeItemValue*)this)->ItemValue = NULL;
	((s0__SubscribeItemValue*)this)->RevisedSamplingRate = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__SubscribeItemValue::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTos0__ItemValue(soap, &((s0__SubscribeItemValue*)this)->ItemValue);
	/* transient soap skipped */
}

int s0__SubscribeItemValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__SubscribeItemValue);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__SubscribeItemValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__SubscribeItemValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__SubscribeItemValue(struct soap *soap, const char *tag, int id, const s0__SubscribeItemValue *a, const char *type)
{
	if (((s0__SubscribeItemValue *)a)->RevisedSamplingRate)
		soap_set_attr(soap, "RevisedSamplingRate", soap_int2s(soap, *((s0__SubscribeItemValue *)a)->RevisedSamplingRate));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__SubscribeItemValue), "s0:SubscribeItemValue");
	/* transient soap skipped */
	soap_out_PointerTos0__ItemValue(soap, "s0:ItemValue", -1, &(((s0__SubscribeItemValue*)a)->ItemValue), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__SubscribeItemValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__SubscribeItemValue(soap, this, tag, type);
}

SOAP_FMAC3 s0__SubscribeItemValue * SOAP_FMAC4 soap_get_s0__SubscribeItemValue(struct soap *soap, s0__SubscribeItemValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__SubscribeItemValue(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__SubscribeItemValue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__SubscribeItemValue(soap, tag, this, type);
}

SOAP_FMAC3 s0__SubscribeItemValue * SOAP_FMAC4 soap_in_s0__SubscribeItemValue(struct soap *soap, const char *tag, s0__SubscribeItemValue *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__SubscribeItemValue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__SubscribeItemValue, sizeof(s0__SubscribeItemValue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__SubscribeItemValue)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__SubscribeItemValue *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "RevisedSamplingRate", 0);
		if (t)
		{	if (!(((s0__SubscribeItemValue *)a)->RevisedSamplingRate = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((s0__SubscribeItemValue *)a)->RevisedSamplingRate))
		return NULL;
		}
	}
	short soap_flag___item2 = 1, soap_flag_ItemValue1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_ItemValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTos0__ItemValue(soap, "s0:ItemValue", &(((s0__SubscribeItemValue*)a)->ItemValue), "s0:ItemValue"))
				{	soap_flag_ItemValue1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__SubscribeItemValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__SubscribeItemValue, 0, sizeof(s0__SubscribeItemValue), 0, soap_copy_s0__SubscribeItemValue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__SubscribeItemValue * SOAP_FMAC6 soap_new_s0__SubscribeItemValue(struct soap *soap, int n)
{	return soap_instantiate_s0__SubscribeItemValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__SubscribeItemValue(struct soap *soap, s0__SubscribeItemValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__SubscribeItemValue * SOAP_FMAC4 soap_instantiate_s0__SubscribeItemValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__SubscribeItemValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__SubscribeItemValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__SubscribeItemValue;
		if (size)
			*size = sizeof(s0__SubscribeItemValue);
		((s0__SubscribeItemValue*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__SubscribeItemValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__SubscribeItemValue);
		for (int i = 0; i < n; i++)
			((s0__SubscribeItemValue*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__SubscribeItemValue*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__SubscribeItemValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__SubscribeItemValue %p -> %p\n", q, p));
	*(s0__SubscribeItemValue*)p = *(s0__SubscribeItemValue*)q;
}
#ifdef __cplusplus
}
#endif

void s0__SubscribeReplyItemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTos0__SubscribeItemValue(soap, &((s0__SubscribeReplyItemList*)this)->Items);
	((s0__SubscribeReplyItemList*)this)->RevisedSamplingRate = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__SubscribeReplyItemList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTos0__SubscribeItemValue(soap, &((s0__SubscribeReplyItemList*)this)->Items);
	/* transient soap skipped */
}

int s0__SubscribeReplyItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__SubscribeReplyItemList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__SubscribeReplyItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__SubscribeReplyItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__SubscribeReplyItemList(struct soap *soap, const char *tag, int id, const s0__SubscribeReplyItemList *a, const char *type)
{
	if (((s0__SubscribeReplyItemList *)a)->RevisedSamplingRate)
		soap_set_attr(soap, "RevisedSamplingRate", soap_int2s(soap, *((s0__SubscribeReplyItemList *)a)->RevisedSamplingRate));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__SubscribeReplyItemList), "s0:SubscribeReplyItemList");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTos0__SubscribeItemValue(soap, "s0:Items", -1, &(((s0__SubscribeReplyItemList*)a)->Items), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__SubscribeReplyItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__SubscribeReplyItemList(soap, this, tag, type);
}

SOAP_FMAC3 s0__SubscribeReplyItemList * SOAP_FMAC4 soap_get_s0__SubscribeReplyItemList(struct soap *soap, s0__SubscribeReplyItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__SubscribeReplyItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__SubscribeReplyItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__SubscribeReplyItemList(soap, tag, this, type);
}

SOAP_FMAC3 s0__SubscribeReplyItemList * SOAP_FMAC4 soap_in_s0__SubscribeReplyItemList(struct soap *soap, const char *tag, s0__SubscribeReplyItemList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__SubscribeReplyItemList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__SubscribeReplyItemList, sizeof(s0__SubscribeReplyItemList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__SubscribeReplyItemList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__SubscribeReplyItemList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "RevisedSamplingRate", 0);
		if (t)
		{	if (!(((s0__SubscribeReplyItemList *)a)->RevisedSamplingRate = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((s0__SubscribeReplyItemList *)a)->RevisedSamplingRate))
		return NULL;
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTos0__SubscribeItemValue(soap, "s0:Items", &(((s0__SubscribeReplyItemList*)a)->Items), "s0:SubscribeItemValue"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__SubscribeReplyItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__SubscribeReplyItemList, 0, sizeof(s0__SubscribeReplyItemList), 0, soap_copy_s0__SubscribeReplyItemList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__SubscribeReplyItemList * SOAP_FMAC6 soap_new_s0__SubscribeReplyItemList(struct soap *soap, int n)
{	return soap_instantiate_s0__SubscribeReplyItemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__SubscribeReplyItemList(struct soap *soap, s0__SubscribeReplyItemList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__SubscribeReplyItemList * SOAP_FMAC4 soap_instantiate_s0__SubscribeReplyItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__SubscribeReplyItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__SubscribeReplyItemList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__SubscribeReplyItemList;
		if (size)
			*size = sizeof(s0__SubscribeReplyItemList);
		((s0__SubscribeReplyItemList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__SubscribeReplyItemList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__SubscribeReplyItemList);
		for (int i = 0; i < n; i++)
			((s0__SubscribeReplyItemList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__SubscribeReplyItemList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__SubscribeReplyItemList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__SubscribeReplyItemList %p -> %p\n", q, p));
	*(s0__SubscribeReplyItemList*)p = *(s0__SubscribeReplyItemList*)q;
}
#ifdef __cplusplus
}
#endif

void s0__SubscribeRequestItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	((s0__SubscribeRequestItem*)this)->ItemPath = NULL;
	((s0__SubscribeRequestItem*)this)->ReqType = NULL;
	((s0__SubscribeRequestItem*)this)->ItemName = NULL;
	((s0__SubscribeRequestItem*)this)->ClientItemHandle = NULL;
	((s0__SubscribeRequestItem*)this)->Deadband = NULL;
	((s0__SubscribeRequestItem*)this)->RequestedSamplingRate = NULL;
	((s0__SubscribeRequestItem*)this)->EnableBuffering = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__SubscribeRequestItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int s0__SubscribeRequestItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__SubscribeRequestItem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__SubscribeRequestItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__SubscribeRequestItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__SubscribeRequestItem(struct soap *soap, const char *tag, int id, const s0__SubscribeRequestItem *a, const char *type)
{
	if (((s0__SubscribeRequestItem *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((s0__SubscribeRequestItem *)a)->ItemPath->c_str());
	if (((s0__SubscribeRequestItem *)a)->ReqType)
		soap_set_attr(soap, "ReqType", soap_QName2s(soap, ((s0__SubscribeRequestItem *)a)->ReqType->c_str()));
	if (((s0__SubscribeRequestItem *)a)->ItemName)
		soap_set_attr(soap, "ItemName", ((s0__SubscribeRequestItem *)a)->ItemName->c_str());
	if (((s0__SubscribeRequestItem *)a)->ClientItemHandle)
		soap_set_attr(soap, "ClientItemHandle", ((s0__SubscribeRequestItem *)a)->ClientItemHandle->c_str());
	if (((s0__SubscribeRequestItem *)a)->Deadband)
		soap_set_attr(soap, "Deadband", soap_float2s(soap, *((s0__SubscribeRequestItem *)a)->Deadband));
	if (((s0__SubscribeRequestItem *)a)->RequestedSamplingRate)
		soap_set_attr(soap, "RequestedSamplingRate", soap_int2s(soap, *((s0__SubscribeRequestItem *)a)->RequestedSamplingRate));
	if (((s0__SubscribeRequestItem *)a)->EnableBuffering)
		soap_set_attr(soap, "EnableBuffering", soap_bool2s(soap, *((s0__SubscribeRequestItem *)a)->EnableBuffering));
	return soap_outliteral(soap, tag, &(((xsd__anyType*)a)->__item), "s0:SubscribeRequestItem");
}

void *s0__SubscribeRequestItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__SubscribeRequestItem(soap, this, tag, type);
}

SOAP_FMAC3 s0__SubscribeRequestItem * SOAP_FMAC4 soap_get_s0__SubscribeRequestItem(struct soap *soap, s0__SubscribeRequestItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__SubscribeRequestItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__SubscribeRequestItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__SubscribeRequestItem(soap, tag, this, type);
}

SOAP_FMAC3 s0__SubscribeRequestItem * SOAP_FMAC4 soap_in_s0__SubscribeRequestItem(struct soap *soap, const char *tag, s0__SubscribeRequestItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (s0__SubscribeRequestItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__SubscribeRequestItem, sizeof(s0__SubscribeRequestItem), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__SubscribeRequestItem)
			return (s0__SubscribeRequestItem *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((s0__SubscribeRequestItem *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__SubscribeRequestItem *)a)->ItemPath = soap_new_std__string(soap, -1);
			((s0__SubscribeRequestItem *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ReqType", 0);
		if (t)
		{	if (!(((s0__SubscribeRequestItem *)a)->ReqType = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2QName(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__SubscribeRequestItem *)a)->ReqType = soap_new_std__string(soap, -1);
			((s0__SubscribeRequestItem *)a)->ReqType->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemName", 0);
		if (t)
		{	if (!(((s0__SubscribeRequestItem *)a)->ItemName = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__SubscribeRequestItem *)a)->ItemName = soap_new_std__string(soap, -1);
			((s0__SubscribeRequestItem *)a)->ItemName->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ClientItemHandle", 0);
		if (t)
		{	if (!(((s0__SubscribeRequestItem *)a)->ClientItemHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__SubscribeRequestItem *)a)->ClientItemHandle = soap_new_std__string(soap, -1);
			((s0__SubscribeRequestItem *)a)->ClientItemHandle->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "Deadband", 0);
		if (t)
		{	if (!(((s0__SubscribeRequestItem *)a)->Deadband = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2float(soap, t, ((s0__SubscribeRequestItem *)a)->Deadband))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "RequestedSamplingRate", 0);
		if (t)
		{	if (!(((s0__SubscribeRequestItem *)a)->RequestedSamplingRate = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((s0__SubscribeRequestItem *)a)->RequestedSamplingRate))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "EnableBuffering", 0);
		if (t)
		{	if (!(((s0__SubscribeRequestItem *)a)->EnableBuffering = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((s0__SubscribeRequestItem *)a)->EnableBuffering))
		return NULL;
		}
	}
	if (!soap_inliteral(soap, tag, &(((xsd__anyType*)a)->__item)))
		return NULL;
	return a;
}

SOAP_FMAC5 s0__SubscribeRequestItem * SOAP_FMAC6 soap_new_s0__SubscribeRequestItem(struct soap *soap, int n)
{	return soap_instantiate_s0__SubscribeRequestItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__SubscribeRequestItem(struct soap *soap, s0__SubscribeRequestItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__SubscribeRequestItem * SOAP_FMAC4 soap_instantiate_s0__SubscribeRequestItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__SubscribeRequestItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__SubscribeRequestItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__SubscribeRequestItem;
		if (size)
			*size = sizeof(s0__SubscribeRequestItem);
		((s0__SubscribeRequestItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__SubscribeRequestItem[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__SubscribeRequestItem);
		for (int i = 0; i < n; i++)
			((s0__SubscribeRequestItem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__SubscribeRequestItem*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__SubscribeRequestItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__SubscribeRequestItem %p -> %p\n", q, p));
	*(s0__SubscribeRequestItem*)p = *(s0__SubscribeRequestItem*)q;
}
#ifdef __cplusplus
}
#endif

void s0__SubscribeRequestItemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(soap, &((s0__SubscribeRequestItemList*)this)->Items);
	((s0__SubscribeRequestItemList*)this)->ItemPath = NULL;
	((s0__SubscribeRequestItemList*)this)->ReqType = NULL;
	((s0__SubscribeRequestItemList*)this)->Deadband = NULL;
	((s0__SubscribeRequestItemList*)this)->RequestedSamplingRate = NULL;
	((s0__SubscribeRequestItemList*)this)->EnableBuffering = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__SubscribeRequestItemList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(soap, &((s0__SubscribeRequestItemList*)this)->Items);
	/* transient soap skipped */
}

int s0__SubscribeRequestItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__SubscribeRequestItemList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__SubscribeRequestItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__SubscribeRequestItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__SubscribeRequestItemList(struct soap *soap, const char *tag, int id, const s0__SubscribeRequestItemList *a, const char *type)
{
	if (((s0__SubscribeRequestItemList *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((s0__SubscribeRequestItemList *)a)->ItemPath->c_str());
	if (((s0__SubscribeRequestItemList *)a)->ReqType)
		soap_set_attr(soap, "ReqType", soap_QName2s(soap, ((s0__SubscribeRequestItemList *)a)->ReqType->c_str()));
	if (((s0__SubscribeRequestItemList *)a)->Deadband)
		soap_set_attr(soap, "Deadband", soap_float2s(soap, *((s0__SubscribeRequestItemList *)a)->Deadband));
	if (((s0__SubscribeRequestItemList *)a)->RequestedSamplingRate)
		soap_set_attr(soap, "RequestedSamplingRate", soap_int2s(soap, *((s0__SubscribeRequestItemList *)a)->RequestedSamplingRate));
	if (((s0__SubscribeRequestItemList *)a)->EnableBuffering)
		soap_set_attr(soap, "EnableBuffering", soap_bool2s(soap, *((s0__SubscribeRequestItemList *)a)->EnableBuffering));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__SubscribeRequestItemList), "s0:SubscribeRequestItemList");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(soap, "s0:Items", -1, &(((s0__SubscribeRequestItemList*)a)->Items), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__SubscribeRequestItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__SubscribeRequestItemList(soap, this, tag, type);
}

SOAP_FMAC3 s0__SubscribeRequestItemList * SOAP_FMAC4 soap_get_s0__SubscribeRequestItemList(struct soap *soap, s0__SubscribeRequestItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__SubscribeRequestItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__SubscribeRequestItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__SubscribeRequestItemList(soap, tag, this, type);
}

SOAP_FMAC3 s0__SubscribeRequestItemList * SOAP_FMAC4 soap_in_s0__SubscribeRequestItemList(struct soap *soap, const char *tag, s0__SubscribeRequestItemList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__SubscribeRequestItemList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__SubscribeRequestItemList, sizeof(s0__SubscribeRequestItemList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__SubscribeRequestItemList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__SubscribeRequestItemList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((s0__SubscribeRequestItemList *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__SubscribeRequestItemList *)a)->ItemPath = soap_new_std__string(soap, -1);
			((s0__SubscribeRequestItemList *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ReqType", 0);
		if (t)
		{	if (!(((s0__SubscribeRequestItemList *)a)->ReqType = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2QName(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__SubscribeRequestItemList *)a)->ReqType = soap_new_std__string(soap, -1);
			((s0__SubscribeRequestItemList *)a)->ReqType->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "Deadband", 0);
		if (t)
		{	if (!(((s0__SubscribeRequestItemList *)a)->Deadband = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2float(soap, t, ((s0__SubscribeRequestItemList *)a)->Deadband))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "RequestedSamplingRate", 0);
		if (t)
		{	if (!(((s0__SubscribeRequestItemList *)a)->RequestedSamplingRate = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((s0__SubscribeRequestItemList *)a)->RequestedSamplingRate))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "EnableBuffering", 0);
		if (t)
		{	if (!(((s0__SubscribeRequestItemList *)a)->EnableBuffering = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((s0__SubscribeRequestItemList *)a)->EnableBuffering))
		return NULL;
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(soap, "s0:Items", &(((s0__SubscribeRequestItemList*)a)->Items), "s0:SubscribeRequestItem"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__SubscribeRequestItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__SubscribeRequestItemList, 0, sizeof(s0__SubscribeRequestItemList), 0, soap_copy_s0__SubscribeRequestItemList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__SubscribeRequestItemList * SOAP_FMAC6 soap_new_s0__SubscribeRequestItemList(struct soap *soap, int n)
{	return soap_instantiate_s0__SubscribeRequestItemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__SubscribeRequestItemList(struct soap *soap, s0__SubscribeRequestItemList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__SubscribeRequestItemList * SOAP_FMAC4 soap_instantiate_s0__SubscribeRequestItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__SubscribeRequestItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__SubscribeRequestItemList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__SubscribeRequestItemList;
		if (size)
			*size = sizeof(s0__SubscribeRequestItemList);
		((s0__SubscribeRequestItemList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__SubscribeRequestItemList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__SubscribeRequestItemList);
		for (int i = 0; i < n; i++)
			((s0__SubscribeRequestItemList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__SubscribeRequestItemList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__SubscribeRequestItemList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__SubscribeRequestItemList %p -> %p\n", q, p));
	*(s0__SubscribeRequestItemList*)p = *(s0__SubscribeRequestItemList*)q;
}
#ifdef __cplusplus
}
#endif

void s0__WriteRequestItemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTos0__ItemValue(soap, &((s0__WriteRequestItemList*)this)->Items);
	((s0__WriteRequestItemList*)this)->ItemPath = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__WriteRequestItemList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTos0__ItemValue(soap, &((s0__WriteRequestItemList*)this)->Items);
	/* transient soap skipped */
}

int s0__WriteRequestItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__WriteRequestItemList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__WriteRequestItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__WriteRequestItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__WriteRequestItemList(struct soap *soap, const char *tag, int id, const s0__WriteRequestItemList *a, const char *type)
{
	if (((s0__WriteRequestItemList *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((s0__WriteRequestItemList *)a)->ItemPath->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__WriteRequestItemList), "s0:WriteRequestItemList");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTos0__ItemValue(soap, "s0:Items", -1, &(((s0__WriteRequestItemList*)a)->Items), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__WriteRequestItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__WriteRequestItemList(soap, this, tag, type);
}

SOAP_FMAC3 s0__WriteRequestItemList * SOAP_FMAC4 soap_get_s0__WriteRequestItemList(struct soap *soap, s0__WriteRequestItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__WriteRequestItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__WriteRequestItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__WriteRequestItemList(soap, tag, this, type);
}

SOAP_FMAC3 s0__WriteRequestItemList * SOAP_FMAC4 soap_in_s0__WriteRequestItemList(struct soap *soap, const char *tag, s0__WriteRequestItemList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__WriteRequestItemList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__WriteRequestItemList, sizeof(s0__WriteRequestItemList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__WriteRequestItemList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__WriteRequestItemList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((s0__WriteRequestItemList *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__WriteRequestItemList *)a)->ItemPath = soap_new_std__string(soap, -1);
			((s0__WriteRequestItemList *)a)->ItemPath->assign(s);
		}
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTos0__ItemValue(soap, "s0:Items", &(((s0__WriteRequestItemList*)a)->Items), "s0:ItemValue"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__WriteRequestItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__WriteRequestItemList, 0, sizeof(s0__WriteRequestItemList), 0, soap_copy_s0__WriteRequestItemList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__WriteRequestItemList * SOAP_FMAC6 soap_new_s0__WriteRequestItemList(struct soap *soap, int n)
{	return soap_instantiate_s0__WriteRequestItemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__WriteRequestItemList(struct soap *soap, s0__WriteRequestItemList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__WriteRequestItemList * SOAP_FMAC4 soap_instantiate_s0__WriteRequestItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__WriteRequestItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__WriteRequestItemList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__WriteRequestItemList;
		if (size)
			*size = sizeof(s0__WriteRequestItemList);
		((s0__WriteRequestItemList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__WriteRequestItemList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__WriteRequestItemList);
		for (int i = 0; i < n; i++)
			((s0__WriteRequestItemList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__WriteRequestItemList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__WriteRequestItemList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__WriteRequestItemList %p -> %p\n", q, p));
	*(s0__WriteRequestItemList*)p = *(s0__WriteRequestItemList*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfShort::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfshort(soap, &((s0__ArrayOfShort*)this)->short_);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ArrayOfShort::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfshort(soap, &((s0__ArrayOfShort*)this)->short_);
	/* transient soap skipped */
}

int s0__ArrayOfShort::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfShort);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ArrayOfShort::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ArrayOfShort(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfShort(struct soap *soap, const char *tag, int id, const s0__ArrayOfShort *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfShort), "s0:ArrayOfShort");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfshort(soap, "s0:short", -1, &(((s0__ArrayOfShort*)a)->short_), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__ArrayOfShort::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ArrayOfShort(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfShort * SOAP_FMAC4 soap_get_s0__ArrayOfShort(struct soap *soap, s0__ArrayOfShort *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ArrayOfShort(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ArrayOfShort::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ArrayOfShort(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfShort * SOAP_FMAC4 soap_in_s0__ArrayOfShort(struct soap *soap, const char *tag, s0__ArrayOfShort *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__ArrayOfShort *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ArrayOfShort, sizeof(s0__ArrayOfShort), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ArrayOfShort)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__ArrayOfShort *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfshort(soap, "s0:short", &(((s0__ArrayOfShort*)a)->short_), "xsd:short"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__ArrayOfShort *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__ArrayOfShort, 0, sizeof(s0__ArrayOfShort), 0, soap_copy_s0__ArrayOfShort);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__ArrayOfShort * SOAP_FMAC6 soap_new_s0__ArrayOfShort(struct soap *soap, int n)
{	return soap_instantiate_s0__ArrayOfShort(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfShort(struct soap *soap, s0__ArrayOfShort *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfShort * SOAP_FMAC4 soap_instantiate_s0__ArrayOfShort(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfShort(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfShort, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ArrayOfShort;
		if (size)
			*size = sizeof(s0__ArrayOfShort);
		((s0__ArrayOfShort*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ArrayOfShort[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ArrayOfShort);
		for (int i = 0; i < n; i++)
			((s0__ArrayOfShort*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ArrayOfShort*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfShort(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfShort %p -> %p\n", q, p));
	*(s0__ArrayOfShort*)p = *(s0__ArrayOfShort*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfByte::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfbyte(soap, &((s0__ArrayOfByte*)this)->byte);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ArrayOfByte::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfbyte(soap, &((s0__ArrayOfByte*)this)->byte);
	/* transient soap skipped */
}

int s0__ArrayOfByte::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfByte);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ArrayOfByte::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ArrayOfByte(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfByte(struct soap *soap, const char *tag, int id, const s0__ArrayOfByte *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfByte), "s0:ArrayOfByte");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfbyte(soap, "s0:byte", -1, &(((s0__ArrayOfByte*)a)->byte), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__ArrayOfByte::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ArrayOfByte(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfByte * SOAP_FMAC4 soap_get_s0__ArrayOfByte(struct soap *soap, s0__ArrayOfByte *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ArrayOfByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ArrayOfByte::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ArrayOfByte(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfByte * SOAP_FMAC4 soap_in_s0__ArrayOfByte(struct soap *soap, const char *tag, s0__ArrayOfByte *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__ArrayOfByte *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ArrayOfByte, sizeof(s0__ArrayOfByte), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ArrayOfByte)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__ArrayOfByte *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfbyte(soap, "s0:byte", &(((s0__ArrayOfByte*)a)->byte), "xsd:byte"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__ArrayOfByte *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__ArrayOfByte, 0, sizeof(s0__ArrayOfByte), 0, soap_copy_s0__ArrayOfByte);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__ArrayOfByte * SOAP_FMAC6 soap_new_s0__ArrayOfByte(struct soap *soap, int n)
{	return soap_instantiate_s0__ArrayOfByte(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfByte(struct soap *soap, s0__ArrayOfByte *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfByte * SOAP_FMAC4 soap_instantiate_s0__ArrayOfByte(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfByte(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfByte, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ArrayOfByte;
		if (size)
			*size = sizeof(s0__ArrayOfByte);
		((s0__ArrayOfByte*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ArrayOfByte[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ArrayOfByte);
		for (int i = 0; i < n; i++)
			((s0__ArrayOfByte*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ArrayOfByte*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfByte(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfByte %p -> %p\n", q, p));
	*(s0__ArrayOfByte*)p = *(s0__ArrayOfByte*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfDecimal::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfxsd__decimal(soap, &((s0__ArrayOfDecimal*)this)->decimal);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ArrayOfDecimal::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfxsd__decimal(soap, &((s0__ArrayOfDecimal*)this)->decimal);
	/* transient soap skipped */
}

int s0__ArrayOfDecimal::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfDecimal);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ArrayOfDecimal::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ArrayOfDecimal(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfDecimal(struct soap *soap, const char *tag, int id, const s0__ArrayOfDecimal *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfDecimal), "s0:ArrayOfDecimal");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfxsd__decimal(soap, "s0:decimal", -1, &(((s0__ArrayOfDecimal*)a)->decimal), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__ArrayOfDecimal::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ArrayOfDecimal(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfDecimal * SOAP_FMAC4 soap_get_s0__ArrayOfDecimal(struct soap *soap, s0__ArrayOfDecimal *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ArrayOfDecimal(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ArrayOfDecimal::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ArrayOfDecimal(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfDecimal * SOAP_FMAC4 soap_in_s0__ArrayOfDecimal(struct soap *soap, const char *tag, s0__ArrayOfDecimal *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__ArrayOfDecimal *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ArrayOfDecimal, sizeof(s0__ArrayOfDecimal), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ArrayOfDecimal)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__ArrayOfDecimal *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfxsd__decimal(soap, "s0:decimal", &(((s0__ArrayOfDecimal*)a)->decimal), "xsd:decimal"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__ArrayOfDecimal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__ArrayOfDecimal, 0, sizeof(s0__ArrayOfDecimal), 0, soap_copy_s0__ArrayOfDecimal);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__ArrayOfDecimal * SOAP_FMAC6 soap_new_s0__ArrayOfDecimal(struct soap *soap, int n)
{	return soap_instantiate_s0__ArrayOfDecimal(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfDecimal(struct soap *soap, s0__ArrayOfDecimal *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfDecimal * SOAP_FMAC4 soap_instantiate_s0__ArrayOfDecimal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfDecimal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfDecimal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ArrayOfDecimal;
		if (size)
			*size = sizeof(s0__ArrayOfDecimal);
		((s0__ArrayOfDecimal*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ArrayOfDecimal[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ArrayOfDecimal);
		for (int i = 0; i < n; i++)
			((s0__ArrayOfDecimal*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ArrayOfDecimal*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfDecimal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfDecimal %p -> %p\n", q, p));
	*(s0__ArrayOfDecimal*)p = *(s0__ArrayOfDecimal*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfAnyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOf_XML(soap, &((s0__ArrayOfAnyType*)this)->anyType);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ArrayOfAnyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOf_XML(soap, &((s0__ArrayOfAnyType*)this)->anyType);
	/* transient soap skipped */
}

int s0__ArrayOfAnyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfAnyType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ArrayOfAnyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ArrayOfAnyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfAnyType(struct soap *soap, const char *tag, int id, const s0__ArrayOfAnyType *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfAnyType), "s0:ArrayOfAnyType");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOf_XML(soap, "s0:anyType", -1, &(((s0__ArrayOfAnyType*)a)->anyType), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__ArrayOfAnyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ArrayOfAnyType(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfAnyType * SOAP_FMAC4 soap_get_s0__ArrayOfAnyType(struct soap *soap, s0__ArrayOfAnyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ArrayOfAnyType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ArrayOfAnyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ArrayOfAnyType(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfAnyType * SOAP_FMAC4 soap_in_s0__ArrayOfAnyType(struct soap *soap, const char *tag, s0__ArrayOfAnyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__ArrayOfAnyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ArrayOfAnyType, sizeof(s0__ArrayOfAnyType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ArrayOfAnyType)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__ArrayOfAnyType *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOf_XML(soap, "s0:anyType", &(((s0__ArrayOfAnyType*)a)->anyType), ""))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__ArrayOfAnyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__ArrayOfAnyType, 0, sizeof(s0__ArrayOfAnyType), 0, soap_copy_s0__ArrayOfAnyType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__ArrayOfAnyType * SOAP_FMAC6 soap_new_s0__ArrayOfAnyType(struct soap *soap, int n)
{	return soap_instantiate_s0__ArrayOfAnyType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfAnyType(struct soap *soap, s0__ArrayOfAnyType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfAnyType * SOAP_FMAC4 soap_instantiate_s0__ArrayOfAnyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfAnyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfAnyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ArrayOfAnyType;
		if (size)
			*size = sizeof(s0__ArrayOfAnyType);
		((s0__ArrayOfAnyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ArrayOfAnyType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ArrayOfAnyType);
		for (int i = 0; i < n; i++)
			((s0__ArrayOfAnyType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ArrayOfAnyType*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfAnyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfAnyType %p -> %p\n", q, p));
	*(s0__ArrayOfAnyType*)p = *(s0__ArrayOfAnyType*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfDateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &((s0__ArrayOfDateTime*)this)->dateTime);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ArrayOfDateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((s0__ArrayOfDateTime*)this)->dateTime);
	/* transient soap skipped */
}

int s0__ArrayOfDateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfDateTime);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ArrayOfDateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ArrayOfDateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfDateTime(struct soap *soap, const char *tag, int id, const s0__ArrayOfDateTime *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfDateTime), "s0:ArrayOfDateTime");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfstd__string(soap, "s0:dateTime", -1, &(((s0__ArrayOfDateTime*)a)->dateTime), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__ArrayOfDateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ArrayOfDateTime(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfDateTime * SOAP_FMAC4 soap_get_s0__ArrayOfDateTime(struct soap *soap, s0__ArrayOfDateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ArrayOfDateTime(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ArrayOfDateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ArrayOfDateTime(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfDateTime * SOAP_FMAC4 soap_in_s0__ArrayOfDateTime(struct soap *soap, const char *tag, s0__ArrayOfDateTime *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__ArrayOfDateTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ArrayOfDateTime, sizeof(s0__ArrayOfDateTime), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ArrayOfDateTime)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__ArrayOfDateTime *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "s0:dateTime", &(((s0__ArrayOfDateTime*)a)->dateTime), "xsd:string"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__ArrayOfDateTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__ArrayOfDateTime, 0, sizeof(s0__ArrayOfDateTime), 0, soap_copy_s0__ArrayOfDateTime);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__ArrayOfDateTime * SOAP_FMAC6 soap_new_s0__ArrayOfDateTime(struct soap *soap, int n)
{	return soap_instantiate_s0__ArrayOfDateTime(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfDateTime(struct soap *soap, s0__ArrayOfDateTime *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfDateTime * SOAP_FMAC4 soap_instantiate_s0__ArrayOfDateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfDateTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfDateTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ArrayOfDateTime;
		if (size)
			*size = sizeof(s0__ArrayOfDateTime);
		((s0__ArrayOfDateTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ArrayOfDateTime[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ArrayOfDateTime);
		for (int i = 0; i < n; i++)
			((s0__ArrayOfDateTime*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ArrayOfDateTime*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfDateTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfDateTime %p -> %p\n", q, p));
	*(s0__ArrayOfDateTime*)p = *(s0__ArrayOfDateTime*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfString::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &((s0__ArrayOfString*)this)->string);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ArrayOfString::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((s0__ArrayOfString*)this)->string);
	/* transient soap skipped */
}

int s0__ArrayOfString::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfString);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ArrayOfString::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ArrayOfString(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfString(struct soap *soap, const char *tag, int id, const s0__ArrayOfString *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfString), "s0:ArrayOfString");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfstd__string(soap, "s0:string", -1, &(((s0__ArrayOfString*)a)->string), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__ArrayOfString::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ArrayOfString(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfString * SOAP_FMAC4 soap_get_s0__ArrayOfString(struct soap *soap, s0__ArrayOfString *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ArrayOfString(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ArrayOfString::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ArrayOfString(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfString * SOAP_FMAC4 soap_in_s0__ArrayOfString(struct soap *soap, const char *tag, s0__ArrayOfString *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__ArrayOfString *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ArrayOfString, sizeof(s0__ArrayOfString), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ArrayOfString)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__ArrayOfString *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "s0:string", &(((s0__ArrayOfString*)a)->string), "xsd:string"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__ArrayOfString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__ArrayOfString, 0, sizeof(s0__ArrayOfString), 0, soap_copy_s0__ArrayOfString);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__ArrayOfString * SOAP_FMAC6 soap_new_s0__ArrayOfString(struct soap *soap, int n)
{	return soap_instantiate_s0__ArrayOfString(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfString(struct soap *soap, s0__ArrayOfString *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfString * SOAP_FMAC4 soap_instantiate_s0__ArrayOfString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfString(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfString, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ArrayOfString;
		if (size)
			*size = sizeof(s0__ArrayOfString);
		((s0__ArrayOfString*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ArrayOfString[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ArrayOfString);
		for (int i = 0; i < n; i++)
			((s0__ArrayOfString*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ArrayOfString*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfString(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfString %p -> %p\n", q, p));
	*(s0__ArrayOfString*)p = *(s0__ArrayOfString*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfBoolean::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfbool(soap, &((s0__ArrayOfBoolean*)this)->boolean);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ArrayOfBoolean::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfbool(soap, &((s0__ArrayOfBoolean*)this)->boolean);
	/* transient soap skipped */
}

int s0__ArrayOfBoolean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfBoolean);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ArrayOfBoolean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ArrayOfBoolean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfBoolean(struct soap *soap, const char *tag, int id, const s0__ArrayOfBoolean *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfBoolean), "s0:ArrayOfBoolean");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfbool(soap, "s0:boolean", -1, &(((s0__ArrayOfBoolean*)a)->boolean), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__ArrayOfBoolean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ArrayOfBoolean(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfBoolean * SOAP_FMAC4 soap_get_s0__ArrayOfBoolean(struct soap *soap, s0__ArrayOfBoolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ArrayOfBoolean(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ArrayOfBoolean::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ArrayOfBoolean(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfBoolean * SOAP_FMAC4 soap_in_s0__ArrayOfBoolean(struct soap *soap, const char *tag, s0__ArrayOfBoolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__ArrayOfBoolean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ArrayOfBoolean, sizeof(s0__ArrayOfBoolean), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ArrayOfBoolean)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__ArrayOfBoolean *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfbool(soap, "s0:boolean", &(((s0__ArrayOfBoolean*)a)->boolean), "xsd:boolean"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__ArrayOfBoolean *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__ArrayOfBoolean, 0, sizeof(s0__ArrayOfBoolean), 0, soap_copy_s0__ArrayOfBoolean);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__ArrayOfBoolean * SOAP_FMAC6 soap_new_s0__ArrayOfBoolean(struct soap *soap, int n)
{	return soap_instantiate_s0__ArrayOfBoolean(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfBoolean(struct soap *soap, s0__ArrayOfBoolean *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfBoolean * SOAP_FMAC4 soap_instantiate_s0__ArrayOfBoolean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfBoolean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfBoolean, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ArrayOfBoolean;
		if (size)
			*size = sizeof(s0__ArrayOfBoolean);
		((s0__ArrayOfBoolean*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ArrayOfBoolean[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ArrayOfBoolean);
		for (int i = 0; i < n; i++)
			((s0__ArrayOfBoolean*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ArrayOfBoolean*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfBoolean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfBoolean %p -> %p\n", q, p));
	*(s0__ArrayOfBoolean*)p = *(s0__ArrayOfBoolean*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfUnsignedShort::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfunsignedShort(soap, &((s0__ArrayOfUnsignedShort*)this)->unsignedShort);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ArrayOfUnsignedShort::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfunsignedShort(soap, &((s0__ArrayOfUnsignedShort*)this)->unsignedShort);
	/* transient soap skipped */
}

int s0__ArrayOfUnsignedShort::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfUnsignedShort);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ArrayOfUnsignedShort::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ArrayOfUnsignedShort(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfUnsignedShort(struct soap *soap, const char *tag, int id, const s0__ArrayOfUnsignedShort *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfUnsignedShort), "s0:ArrayOfUnsignedShort");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfunsignedShort(soap, "s0:unsignedShort", -1, &(((s0__ArrayOfUnsignedShort*)a)->unsignedShort), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__ArrayOfUnsignedShort::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ArrayOfUnsignedShort(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfUnsignedShort * SOAP_FMAC4 soap_get_s0__ArrayOfUnsignedShort(struct soap *soap, s0__ArrayOfUnsignedShort *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ArrayOfUnsignedShort(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ArrayOfUnsignedShort::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ArrayOfUnsignedShort(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfUnsignedShort * SOAP_FMAC4 soap_in_s0__ArrayOfUnsignedShort(struct soap *soap, const char *tag, s0__ArrayOfUnsignedShort *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__ArrayOfUnsignedShort *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ArrayOfUnsignedShort, sizeof(s0__ArrayOfUnsignedShort), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ArrayOfUnsignedShort)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__ArrayOfUnsignedShort *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfunsignedShort(soap, "s0:unsignedShort", &(((s0__ArrayOfUnsignedShort*)a)->unsignedShort), "xsd:unsignedShort"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__ArrayOfUnsignedShort *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__ArrayOfUnsignedShort, 0, sizeof(s0__ArrayOfUnsignedShort), 0, soap_copy_s0__ArrayOfUnsignedShort);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__ArrayOfUnsignedShort * SOAP_FMAC6 soap_new_s0__ArrayOfUnsignedShort(struct soap *soap, int n)
{	return soap_instantiate_s0__ArrayOfUnsignedShort(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfUnsignedShort(struct soap *soap, s0__ArrayOfUnsignedShort *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfUnsignedShort * SOAP_FMAC4 soap_instantiate_s0__ArrayOfUnsignedShort(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfUnsignedShort(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfUnsignedShort, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ArrayOfUnsignedShort;
		if (size)
			*size = sizeof(s0__ArrayOfUnsignedShort);
		((s0__ArrayOfUnsignedShort*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ArrayOfUnsignedShort[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ArrayOfUnsignedShort);
		for (int i = 0; i < n; i++)
			((s0__ArrayOfUnsignedShort*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ArrayOfUnsignedShort*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfUnsignedShort(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfUnsignedShort %p -> %p\n", q, p));
	*(s0__ArrayOfUnsignedShort*)p = *(s0__ArrayOfUnsignedShort*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfDouble::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfdouble(soap, &((s0__ArrayOfDouble*)this)->double_);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ArrayOfDouble::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfdouble(soap, &((s0__ArrayOfDouble*)this)->double_);
	/* transient soap skipped */
}

int s0__ArrayOfDouble::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfDouble);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ArrayOfDouble::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ArrayOfDouble(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfDouble(struct soap *soap, const char *tag, int id, const s0__ArrayOfDouble *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfDouble), "s0:ArrayOfDouble");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfdouble(soap, "s0:double", -1, &(((s0__ArrayOfDouble*)a)->double_), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__ArrayOfDouble::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ArrayOfDouble(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfDouble * SOAP_FMAC4 soap_get_s0__ArrayOfDouble(struct soap *soap, s0__ArrayOfDouble *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ArrayOfDouble(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ArrayOfDouble::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ArrayOfDouble(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfDouble * SOAP_FMAC4 soap_in_s0__ArrayOfDouble(struct soap *soap, const char *tag, s0__ArrayOfDouble *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__ArrayOfDouble *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ArrayOfDouble, sizeof(s0__ArrayOfDouble), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ArrayOfDouble)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__ArrayOfDouble *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfdouble(soap, "s0:double", &(((s0__ArrayOfDouble*)a)->double_), "xsd:double"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__ArrayOfDouble *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__ArrayOfDouble, 0, sizeof(s0__ArrayOfDouble), 0, soap_copy_s0__ArrayOfDouble);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__ArrayOfDouble * SOAP_FMAC6 soap_new_s0__ArrayOfDouble(struct soap *soap, int n)
{	return soap_instantiate_s0__ArrayOfDouble(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfDouble(struct soap *soap, s0__ArrayOfDouble *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfDouble * SOAP_FMAC4 soap_instantiate_s0__ArrayOfDouble(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfDouble(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfDouble, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ArrayOfDouble;
		if (size)
			*size = sizeof(s0__ArrayOfDouble);
		((s0__ArrayOfDouble*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ArrayOfDouble[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ArrayOfDouble);
		for (int i = 0; i < n; i++)
			((s0__ArrayOfDouble*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ArrayOfDouble*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfDouble(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfDouble %p -> %p\n", q, p));
	*(s0__ArrayOfDouble*)p = *(s0__ArrayOfDouble*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfUnsignedLong::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfunsignedLONG64(soap, &((s0__ArrayOfUnsignedLong*)this)->unsignedLong);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ArrayOfUnsignedLong::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfunsignedLONG64(soap, &((s0__ArrayOfUnsignedLong*)this)->unsignedLong);
	/* transient soap skipped */
}

int s0__ArrayOfUnsignedLong::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfUnsignedLong);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ArrayOfUnsignedLong::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ArrayOfUnsignedLong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfUnsignedLong(struct soap *soap, const char *tag, int id, const s0__ArrayOfUnsignedLong *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfUnsignedLong), "s0:ArrayOfUnsignedLong");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfunsignedLONG64(soap, "s0:unsignedLong", -1, &(((s0__ArrayOfUnsignedLong*)a)->unsignedLong), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__ArrayOfUnsignedLong::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ArrayOfUnsignedLong(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfUnsignedLong * SOAP_FMAC4 soap_get_s0__ArrayOfUnsignedLong(struct soap *soap, s0__ArrayOfUnsignedLong *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ArrayOfUnsignedLong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ArrayOfUnsignedLong::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ArrayOfUnsignedLong(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfUnsignedLong * SOAP_FMAC4 soap_in_s0__ArrayOfUnsignedLong(struct soap *soap, const char *tag, s0__ArrayOfUnsignedLong *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__ArrayOfUnsignedLong *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ArrayOfUnsignedLong, sizeof(s0__ArrayOfUnsignedLong), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ArrayOfUnsignedLong)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__ArrayOfUnsignedLong *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfunsignedLONG64(soap, "s0:unsignedLong", &(((s0__ArrayOfUnsignedLong*)a)->unsignedLong), "xsd:unsignedLong"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__ArrayOfUnsignedLong *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__ArrayOfUnsignedLong, 0, sizeof(s0__ArrayOfUnsignedLong), 0, soap_copy_s0__ArrayOfUnsignedLong);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__ArrayOfUnsignedLong * SOAP_FMAC6 soap_new_s0__ArrayOfUnsignedLong(struct soap *soap, int n)
{	return soap_instantiate_s0__ArrayOfUnsignedLong(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfUnsignedLong(struct soap *soap, s0__ArrayOfUnsignedLong *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfUnsignedLong * SOAP_FMAC4 soap_instantiate_s0__ArrayOfUnsignedLong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfUnsignedLong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfUnsignedLong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ArrayOfUnsignedLong;
		if (size)
			*size = sizeof(s0__ArrayOfUnsignedLong);
		((s0__ArrayOfUnsignedLong*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ArrayOfUnsignedLong[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ArrayOfUnsignedLong);
		for (int i = 0; i < n; i++)
			((s0__ArrayOfUnsignedLong*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ArrayOfUnsignedLong*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfUnsignedLong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfUnsignedLong %p -> %p\n", q, p));
	*(s0__ArrayOfUnsignedLong*)p = *(s0__ArrayOfUnsignedLong*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfLong::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfLONG64(soap, &((s0__ArrayOfLong*)this)->long_);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ArrayOfLong::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfLONG64(soap, &((s0__ArrayOfLong*)this)->long_);
	/* transient soap skipped */
}

int s0__ArrayOfLong::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfLong);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ArrayOfLong::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ArrayOfLong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfLong(struct soap *soap, const char *tag, int id, const s0__ArrayOfLong *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfLong), "s0:ArrayOfLong");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfLONG64(soap, "s0:long", -1, &(((s0__ArrayOfLong*)a)->long_), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__ArrayOfLong::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ArrayOfLong(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfLong * SOAP_FMAC4 soap_get_s0__ArrayOfLong(struct soap *soap, s0__ArrayOfLong *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ArrayOfLong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ArrayOfLong::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ArrayOfLong(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfLong * SOAP_FMAC4 soap_in_s0__ArrayOfLong(struct soap *soap, const char *tag, s0__ArrayOfLong *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__ArrayOfLong *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ArrayOfLong, sizeof(s0__ArrayOfLong), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ArrayOfLong)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__ArrayOfLong *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfLONG64(soap, "s0:long", &(((s0__ArrayOfLong*)a)->long_), "xsd:long"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__ArrayOfLong *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__ArrayOfLong, 0, sizeof(s0__ArrayOfLong), 0, soap_copy_s0__ArrayOfLong);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__ArrayOfLong * SOAP_FMAC6 soap_new_s0__ArrayOfLong(struct soap *soap, int n)
{	return soap_instantiate_s0__ArrayOfLong(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfLong(struct soap *soap, s0__ArrayOfLong *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfLong * SOAP_FMAC4 soap_instantiate_s0__ArrayOfLong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfLong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfLong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ArrayOfLong;
		if (size)
			*size = sizeof(s0__ArrayOfLong);
		((s0__ArrayOfLong*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ArrayOfLong[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ArrayOfLong);
		for (int i = 0; i < n; i++)
			((s0__ArrayOfLong*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ArrayOfLong*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfLong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfLong %p -> %p\n", q, p));
	*(s0__ArrayOfLong*)p = *(s0__ArrayOfLong*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfUnsignedInt::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfunsignedInt(soap, &((s0__ArrayOfUnsignedInt*)this)->unsignedInt);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ArrayOfUnsignedInt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfunsignedInt(soap, &((s0__ArrayOfUnsignedInt*)this)->unsignedInt);
	/* transient soap skipped */
}

int s0__ArrayOfUnsignedInt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfUnsignedInt);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ArrayOfUnsignedInt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ArrayOfUnsignedInt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfUnsignedInt(struct soap *soap, const char *tag, int id, const s0__ArrayOfUnsignedInt *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfUnsignedInt), "s0:ArrayOfUnsignedInt");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfunsignedInt(soap, "s0:unsignedInt", -1, &(((s0__ArrayOfUnsignedInt*)a)->unsignedInt), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__ArrayOfUnsignedInt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ArrayOfUnsignedInt(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfUnsignedInt * SOAP_FMAC4 soap_get_s0__ArrayOfUnsignedInt(struct soap *soap, s0__ArrayOfUnsignedInt *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ArrayOfUnsignedInt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ArrayOfUnsignedInt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ArrayOfUnsignedInt(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfUnsignedInt * SOAP_FMAC4 soap_in_s0__ArrayOfUnsignedInt(struct soap *soap, const char *tag, s0__ArrayOfUnsignedInt *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__ArrayOfUnsignedInt *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ArrayOfUnsignedInt, sizeof(s0__ArrayOfUnsignedInt), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ArrayOfUnsignedInt)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__ArrayOfUnsignedInt *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfunsignedInt(soap, "s0:unsignedInt", &(((s0__ArrayOfUnsignedInt*)a)->unsignedInt), "xsd:unsignedInt"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__ArrayOfUnsignedInt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__ArrayOfUnsignedInt, 0, sizeof(s0__ArrayOfUnsignedInt), 0, soap_copy_s0__ArrayOfUnsignedInt);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__ArrayOfUnsignedInt * SOAP_FMAC6 soap_new_s0__ArrayOfUnsignedInt(struct soap *soap, int n)
{	return soap_instantiate_s0__ArrayOfUnsignedInt(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfUnsignedInt(struct soap *soap, s0__ArrayOfUnsignedInt *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfUnsignedInt * SOAP_FMAC4 soap_instantiate_s0__ArrayOfUnsignedInt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfUnsignedInt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfUnsignedInt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ArrayOfUnsignedInt;
		if (size)
			*size = sizeof(s0__ArrayOfUnsignedInt);
		((s0__ArrayOfUnsignedInt*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ArrayOfUnsignedInt[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ArrayOfUnsignedInt);
		for (int i = 0; i < n; i++)
			((s0__ArrayOfUnsignedInt*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ArrayOfUnsignedInt*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfUnsignedInt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfUnsignedInt %p -> %p\n", q, p));
	*(s0__ArrayOfUnsignedInt*)p = *(s0__ArrayOfUnsignedInt*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfInt::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfint(soap, &((s0__ArrayOfInt*)this)->int_);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ArrayOfInt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &((s0__ArrayOfInt*)this)->int_);
	/* transient soap skipped */
}

int s0__ArrayOfInt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfInt);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ArrayOfInt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ArrayOfInt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfInt(struct soap *soap, const char *tag, int id, const s0__ArrayOfInt *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfInt), "s0:ArrayOfInt");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfint(soap, "s0:int", -1, &(((s0__ArrayOfInt*)a)->int_), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__ArrayOfInt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ArrayOfInt(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfInt * SOAP_FMAC4 soap_get_s0__ArrayOfInt(struct soap *soap, s0__ArrayOfInt *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ArrayOfInt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ArrayOfInt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ArrayOfInt(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfInt * SOAP_FMAC4 soap_in_s0__ArrayOfInt(struct soap *soap, const char *tag, s0__ArrayOfInt *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__ArrayOfInt *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ArrayOfInt, sizeof(s0__ArrayOfInt), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ArrayOfInt)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__ArrayOfInt *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "s0:int", &(((s0__ArrayOfInt*)a)->int_), "xsd:int"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__ArrayOfInt *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__ArrayOfInt, 0, sizeof(s0__ArrayOfInt), 0, soap_copy_s0__ArrayOfInt);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__ArrayOfInt * SOAP_FMAC6 soap_new_s0__ArrayOfInt(struct soap *soap, int n)
{	return soap_instantiate_s0__ArrayOfInt(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfInt(struct soap *soap, s0__ArrayOfInt *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfInt * SOAP_FMAC4 soap_instantiate_s0__ArrayOfInt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfInt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfInt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ArrayOfInt;
		if (size)
			*size = sizeof(s0__ArrayOfInt);
		((s0__ArrayOfInt*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ArrayOfInt[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ArrayOfInt);
		for (int i = 0; i < n; i++)
			((s0__ArrayOfInt*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ArrayOfInt*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfInt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfInt %p -> %p\n", q, p));
	*(s0__ArrayOfInt*)p = *(s0__ArrayOfInt*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ArrayOfFloat::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOffloat(soap, &((s0__ArrayOfFloat*)this)->float_);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ArrayOfFloat::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOffloat(soap, &((s0__ArrayOfFloat*)this)->float_);
	/* transient soap skipped */
}

int s0__ArrayOfFloat::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ArrayOfFloat);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ArrayOfFloat::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ArrayOfFloat(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ArrayOfFloat(struct soap *soap, const char *tag, int id, const s0__ArrayOfFloat *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ArrayOfFloat), "s0:ArrayOfFloat");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOffloat(soap, "s0:float", -1, &(((s0__ArrayOfFloat*)a)->float_), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__ArrayOfFloat::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ArrayOfFloat(soap, this, tag, type);
}

SOAP_FMAC3 s0__ArrayOfFloat * SOAP_FMAC4 soap_get_s0__ArrayOfFloat(struct soap *soap, s0__ArrayOfFloat *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ArrayOfFloat(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ArrayOfFloat::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ArrayOfFloat(soap, tag, this, type);
}

SOAP_FMAC3 s0__ArrayOfFloat * SOAP_FMAC4 soap_in_s0__ArrayOfFloat(struct soap *soap, const char *tag, s0__ArrayOfFloat *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__ArrayOfFloat *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ArrayOfFloat, sizeof(s0__ArrayOfFloat), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ArrayOfFloat)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__ArrayOfFloat *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOffloat(soap, "s0:float", &(((s0__ArrayOfFloat*)a)->float_), "xsd:float"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__ArrayOfFloat *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__ArrayOfFloat, 0, sizeof(s0__ArrayOfFloat), 0, soap_copy_s0__ArrayOfFloat);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__ArrayOfFloat * SOAP_FMAC6 soap_new_s0__ArrayOfFloat(struct soap *soap, int n)
{	return soap_instantiate_s0__ArrayOfFloat(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ArrayOfFloat(struct soap *soap, s0__ArrayOfFloat *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ArrayOfFloat * SOAP_FMAC4 soap_instantiate_s0__ArrayOfFloat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ArrayOfFloat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ArrayOfFloat, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ArrayOfFloat;
		if (size)
			*size = sizeof(s0__ArrayOfFloat);
		((s0__ArrayOfFloat*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ArrayOfFloat[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ArrayOfFloat);
		for (int i = 0; i < n; i++)
			((s0__ArrayOfFloat*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ArrayOfFloat*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ArrayOfFloat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ArrayOfFloat %p -> %p\n", q, p));
	*(s0__ArrayOfFloat*)p = *(s0__ArrayOfFloat*)q;
}
#ifdef __cplusplus
}
#endif

void s0__OPCError::soap_default(struct soap *soap)
{
	this->soap = soap;
	((s0__OPCError*)this)->Text = NULL;
	soap_default_xsd__QName(soap, &((s0__OPCError*)this)->ID);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__OPCError::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((s0__OPCError*)this)->Text);
	/* transient soap skipped */
}

int s0__OPCError::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__OPCError);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__OPCError::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__OPCError(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__OPCError(struct soap *soap, const char *tag, int id, const s0__OPCError *a, const char *type)
{
	if (!((s0__OPCError *)a)->ID.empty())
		soap_set_attr(soap, "ID", soap_QName2s(soap, ((s0__OPCError *)a)->ID.c_str()));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__OPCError), "s0:OPCError");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "s0:Text", -1, &(((s0__OPCError*)a)->Text), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__OPCError::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__OPCError(soap, this, tag, type);
}

SOAP_FMAC3 s0__OPCError * SOAP_FMAC4 soap_get_s0__OPCError(struct soap *soap, s0__OPCError *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__OPCError(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__OPCError::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__OPCError(soap, tag, this, type);
}

SOAP_FMAC3 s0__OPCError * SOAP_FMAC4 soap_in_s0__OPCError(struct soap *soap, const char *tag, s0__OPCError *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__OPCError *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__OPCError, sizeof(s0__OPCError), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__OPCError)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__OPCError *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ID", 1);
		if (t)
		{	char *s;
			if (soap_s2QName(soap, t, &s))
				return NULL;
			((s0__OPCError *)a)->ID.assign(s);
		}
	}
	short soap_flag___item2 = 1, soap_flag_Text1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "s0:Text", &(((s0__OPCError*)a)->Text), "xsd:string"))
				{	soap_flag_Text1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__OPCError *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__OPCError, 0, sizeof(s0__OPCError), 0, soap_copy_s0__OPCError);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__OPCError * SOAP_FMAC6 soap_new_s0__OPCError(struct soap *soap, int n)
{	return soap_instantiate_s0__OPCError(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__OPCError(struct soap *soap, s0__OPCError *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__OPCError * SOAP_FMAC4 soap_instantiate_s0__OPCError(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__OPCError(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__OPCError, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__OPCError;
		if (size)
			*size = sizeof(s0__OPCError);
		((s0__OPCError*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__OPCError[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__OPCError);
		for (int i = 0; i < n; i++)
			((s0__OPCError*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__OPCError*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__OPCError(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__OPCError %p -> %p\n", q, p));
	*(s0__OPCError*)p = *(s0__OPCError*)q;
}
#ifdef __cplusplus
}
#endif

void s0__OPCQuality::soap_default(struct soap *soap)
{
	this->soap = soap;
	((s0__OPCQuality*)this)->QualityField = NULL;
	((s0__OPCQuality*)this)->LimitField = NULL;
	((s0__OPCQuality*)this)->VendorField = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__OPCQuality::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int s0__OPCQuality::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__OPCQuality);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__OPCQuality::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__OPCQuality(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__OPCQuality(struct soap *soap, const char *tag, int id, const s0__OPCQuality *a, const char *type)
{
	if (((s0__OPCQuality *)a)->QualityField)
		soap_set_attr(soap, "QualityField", soap_s0__qualityBits2s(soap, *((s0__OPCQuality *)a)->QualityField));
	if (((s0__OPCQuality *)a)->LimitField)
		soap_set_attr(soap, "LimitField", soap_s0__limitBits2s(soap, *((s0__OPCQuality *)a)->LimitField));
	if (((s0__OPCQuality *)a)->VendorField)
		soap_set_attr(soap, "VendorField", soap_unsignedShort2s(soap, *((s0__OPCQuality *)a)->VendorField));
	return soap_outliteral(soap, tag, &(((xsd__anyType*)a)->__item), "s0:OPCQuality");
}

void *s0__OPCQuality::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__OPCQuality(soap, this, tag, type);
}

SOAP_FMAC3 s0__OPCQuality * SOAP_FMAC4 soap_get_s0__OPCQuality(struct soap *soap, s0__OPCQuality *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__OPCQuality(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__OPCQuality::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__OPCQuality(soap, tag, this, type);
}

SOAP_FMAC3 s0__OPCQuality * SOAP_FMAC4 soap_in_s0__OPCQuality(struct soap *soap, const char *tag, s0__OPCQuality *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (s0__OPCQuality *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__OPCQuality, sizeof(s0__OPCQuality), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__OPCQuality)
			return (s0__OPCQuality *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "QualityField", 0);
		if (t)
		{	if (!(((s0__OPCQuality *)a)->QualityField = (enum s0__qualityBits *)soap_malloc(soap, sizeof(enum s0__qualityBits))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2s0__qualityBits(soap, t, ((s0__OPCQuality *)a)->QualityField))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "LimitField", 0);
		if (t)
		{	if (!(((s0__OPCQuality *)a)->LimitField = (enum s0__limitBits *)soap_malloc(soap, sizeof(enum s0__limitBits))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2s0__limitBits(soap, t, ((s0__OPCQuality *)a)->LimitField))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "VendorField", 0);
		if (t)
		{	if (!(((s0__OPCQuality *)a)->VendorField = (unsigned short *)soap_malloc(soap, sizeof(unsigned short))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2unsignedShort(soap, t, ((s0__OPCQuality *)a)->VendorField))
		return NULL;
		}
	}
	if (!soap_inliteral(soap, tag, &(((xsd__anyType*)a)->__item)))
		return NULL;
	return a;
}

SOAP_FMAC5 s0__OPCQuality * SOAP_FMAC6 soap_new_s0__OPCQuality(struct soap *soap, int n)
{	return soap_instantiate_s0__OPCQuality(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__OPCQuality(struct soap *soap, s0__OPCQuality *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__OPCQuality * SOAP_FMAC4 soap_instantiate_s0__OPCQuality(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__OPCQuality(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__OPCQuality, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__OPCQuality;
		if (size)
			*size = sizeof(s0__OPCQuality);
		((s0__OPCQuality*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__OPCQuality[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__OPCQuality);
		for (int i = 0; i < n; i++)
			((s0__OPCQuality*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__OPCQuality*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__OPCQuality(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__OPCQuality %p -> %p\n", q, p));
	*(s0__OPCQuality*)p = *(s0__OPCQuality*)q;
}
#ifdef __cplusplus
}
#endif

void s0__Value::soap_default(struct soap *soap)
{
	this->soap = soap;
	((s0__Value*)this)->xsi__type = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__Value::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int s0__Value::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__Value);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__Value::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__Value(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__Value(struct soap *soap, const char *tag, int id, const s0__Value *a, const char *type)
{
	if (((s0__Value *)a)->xsi__type)
		soap_set_attr(soap, "xsi:type", soap_QName2s(soap, ((s0__Value *)a)->xsi__type->c_str()));
	return soap_outliteral(soap, tag, &(((xsd__anyType*)a)->__item), "s0:Value");
}

void *s0__Value::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__Value(soap, this, tag, type);
}

SOAP_FMAC3 s0__Value * SOAP_FMAC4 soap_get_s0__Value(struct soap *soap, s0__Value *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__Value(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__Value::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__Value(soap, tag, this, type);
}

SOAP_FMAC3 s0__Value * SOAP_FMAC4 soap_in_s0__Value(struct soap *soap, const char *tag, s0__Value *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (s0__Value *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__Value, sizeof(s0__Value), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__Value)
			return (s0__Value *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "xsi:type", 0);
		if (t)
		{	if (!(((s0__Value *)a)->xsi__type = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2QName(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__Value *)a)->xsi__type = soap_new_std__string(soap, -1);
			((s0__Value *)a)->xsi__type->assign(s);
		}
		}
	}
	if (!soap_inliteral(soap, tag, &(((xsd__anyType*)a)->__item)))
		return NULL;
	return a;
}

SOAP_FMAC5 s0__Value * SOAP_FMAC6 soap_new_s0__Value(struct soap *soap, int n)
{	return soap_instantiate_s0__Value(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__Value(struct soap *soap, s0__Value *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__Value * SOAP_FMAC4 soap_instantiate_s0__Value(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__Value(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__Value, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__Value;
		if (size)
			*size = sizeof(s0__Value);
		((s0__Value*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__Value[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__Value);
		for (int i = 0; i < n; i++)
			((s0__Value*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__Value*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__Value(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__Value %p -> %p\n", q, p));
	*(s0__Value*)p = *(s0__Value*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ItemValue::soap_default(struct soap *soap)
{
	this->soap = soap;
	((s0__ItemValue*)this)->DiagnosticInfo = NULL;
	((s0__ItemValue*)this)->Value = NULL;
	((s0__ItemValue*)this)->Quality = NULL;
	((s0__ItemValue*)this)->ValueTypeQualifier = NULL;
	((s0__ItemValue*)this)->ItemPath = NULL;
	((s0__ItemValue*)this)->ItemName = NULL;
	((s0__ItemValue*)this)->ClientItemHandle = NULL;
	((s0__ItemValue*)this)->Timestamp = NULL;
	((s0__ItemValue*)this)->ResultID = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ItemValue::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((s0__ItemValue*)this)->DiagnosticInfo);
	soap_serialize_PointerToxsd__anyType(soap, &((s0__ItemValue*)this)->Value);
	soap_serialize_PointerTos0__OPCQuality(soap, &((s0__ItemValue*)this)->Quality);
	soap_serialize_PointerToxsd__dateTime(soap, &((s0__ItemValue*)this)->Timestamp);
	/* transient soap skipped */
}

int s0__ItemValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ItemValue);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ItemValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ItemValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ItemValue(struct soap *soap, const char *tag, int id, const s0__ItemValue *a, const char *type)
{
	if (((s0__ItemValue *)a)->ValueTypeQualifier)
		soap_set_attr(soap, "ValueTypeQualifier", soap_QName2s(soap, ((s0__ItemValue *)a)->ValueTypeQualifier->c_str()));
	if (((s0__ItemValue *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((s0__ItemValue *)a)->ItemPath->c_str());
	if (((s0__ItemValue *)a)->ItemName)
		soap_set_attr(soap, "ItemName", ((s0__ItemValue *)a)->ItemName->c_str());
	if (((s0__ItemValue *)a)->ClientItemHandle)
		soap_set_attr(soap, "ClientItemHandle", ((s0__ItemValue *)a)->ClientItemHandle->c_str());
	if (((s0__ItemValue *)a)->ResultID)
		soap_set_attr(soap, "ResultID", soap_QName2s(soap, ((s0__ItemValue *)a)->ResultID->c_str()));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ItemValue), "s0:ItemValue");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "s0:DiagnosticInfo", -1, &(((s0__ItemValue*)a)->DiagnosticInfo), "");
	soap_out_PointerToxsd__anyType(soap, "s0:Value", -1, &(((s0__ItemValue*)a)->Value), "");
	soap_out_PointerTos0__OPCQuality(soap, "s0:Quality", -1, &(((s0__ItemValue*)a)->Quality), "");
	soap_out_PointerToxsd__dateTime(soap, "s0:Timestamp", -1, &(((s0__ItemValue*)a)->Timestamp), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__ItemValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ItemValue(soap, this, tag, type);
}

SOAP_FMAC3 s0__ItemValue * SOAP_FMAC4 soap_get_s0__ItemValue(struct soap *soap, s0__ItemValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ItemValue(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ItemValue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ItemValue(soap, tag, this, type);
}

SOAP_FMAC3 s0__ItemValue * SOAP_FMAC4 soap_in_s0__ItemValue(struct soap *soap, const char *tag, s0__ItemValue *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__ItemValue *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ItemValue, sizeof(s0__ItemValue), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ItemValue)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__ItemValue *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ValueTypeQualifier", 0);
		if (t)
		{	if (!(((s0__ItemValue *)a)->ValueTypeQualifier = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2QName(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ItemValue *)a)->ValueTypeQualifier = soap_new_std__string(soap, -1);
			((s0__ItemValue *)a)->ValueTypeQualifier->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((s0__ItemValue *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ItemValue *)a)->ItemPath = soap_new_std__string(soap, -1);
			((s0__ItemValue *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemName", 0);
		if (t)
		{	if (!(((s0__ItemValue *)a)->ItemName = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ItemValue *)a)->ItemName = soap_new_std__string(soap, -1);
			((s0__ItemValue *)a)->ItemName->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ClientItemHandle", 0);
		if (t)
		{	if (!(((s0__ItemValue *)a)->ClientItemHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ItemValue *)a)->ClientItemHandle = soap_new_std__string(soap, -1);
			((s0__ItemValue *)a)->ClientItemHandle->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ResultID", 0);
		if (t)
		{	if (!(((s0__ItemValue *)a)->ResultID = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2QName(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ItemValue *)a)->ResultID = soap_new_std__string(soap, -1);
			((s0__ItemValue *)a)->ResultID->assign(s);
		}
		}
	}
	short soap_flag___item2 = 1, soap_flag_DiagnosticInfo1 = 1, soap_flag_Value1 = 1, soap_flag_Quality1 = 1, soap_flag_Timestamp1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_DiagnosticInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "s0:DiagnosticInfo", &(((s0__ItemValue*)a)->DiagnosticInfo), "xsd:string"))
				{	soap_flag_DiagnosticInfo1--;
					continue;
				}
			if (soap_flag_Value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "s0:Value", &(((s0__ItemValue*)a)->Value), "xsd:anyType"))
				{	soap_flag_Value1--;
					continue;
				}
			if (soap_flag_Quality1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTos0__OPCQuality(soap, "s0:Quality", &(((s0__ItemValue*)a)->Quality), "s0:OPCQuality"))
				{	soap_flag_Quality1--;
					continue;
				}
			if (soap_flag_Timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__dateTime(soap, "s0:Timestamp", &(((s0__ItemValue*)a)->Timestamp), "xsd:dateTime"))
				{	soap_flag_Timestamp1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__ItemValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__ItemValue, 0, sizeof(s0__ItemValue), 0, soap_copy_s0__ItemValue);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__ItemValue * SOAP_FMAC6 soap_new_s0__ItemValue(struct soap *soap, int n)
{	return soap_instantiate_s0__ItemValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ItemValue(struct soap *soap, s0__ItemValue *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ItemValue * SOAP_FMAC4 soap_instantiate_s0__ItemValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ItemValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ItemValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ItemValue;
		if (size)
			*size = sizeof(s0__ItemValue);
		((s0__ItemValue*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ItemValue[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ItemValue);
		for (int i = 0; i < n; i++)
			((s0__ItemValue*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ItemValue*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ItemValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ItemValue %p -> %p\n", q, p));
	*(s0__ItemValue*)p = *(s0__ItemValue*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ReplyItemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTos0__ItemValue(soap, &((s0__ReplyItemList*)this)->Items);
	((s0__ReplyItemList*)this)->Reserved = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ReplyItemList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTos0__ItemValue(soap, &((s0__ReplyItemList*)this)->Items);
	/* transient soap skipped */
}

int s0__ReplyItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ReplyItemList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ReplyItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ReplyItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ReplyItemList(struct soap *soap, const char *tag, int id, const s0__ReplyItemList *a, const char *type)
{
	if (((s0__ReplyItemList *)a)->Reserved)
		soap_set_attr(soap, "Reserved", ((s0__ReplyItemList *)a)->Reserved->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ReplyItemList), "s0:ReplyItemList");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTos0__ItemValue(soap, "s0:Items", -1, &(((s0__ReplyItemList*)a)->Items), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__ReplyItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ReplyItemList(soap, this, tag, type);
}

SOAP_FMAC3 s0__ReplyItemList * SOAP_FMAC4 soap_get_s0__ReplyItemList(struct soap *soap, s0__ReplyItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ReplyItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ReplyItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ReplyItemList(soap, tag, this, type);
}

SOAP_FMAC3 s0__ReplyItemList * SOAP_FMAC4 soap_in_s0__ReplyItemList(struct soap *soap, const char *tag, s0__ReplyItemList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__ReplyItemList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ReplyItemList, sizeof(s0__ReplyItemList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ReplyItemList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__ReplyItemList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "Reserved", 0);
		if (t)
		{	if (!(((s0__ReplyItemList *)a)->Reserved = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ReplyItemList *)a)->Reserved = soap_new_std__string(soap, -1);
			((s0__ReplyItemList *)a)->Reserved->assign(s);
		}
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTos0__ItemValue(soap, "s0:Items", &(((s0__ReplyItemList*)a)->Items), "s0:ItemValue"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__ReplyItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__ReplyItemList, 0, sizeof(s0__ReplyItemList), 0, soap_copy_s0__ReplyItemList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__ReplyItemList * SOAP_FMAC6 soap_new_s0__ReplyItemList(struct soap *soap, int n)
{	return soap_instantiate_s0__ReplyItemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ReplyItemList(struct soap *soap, s0__ReplyItemList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ReplyItemList * SOAP_FMAC4 soap_instantiate_s0__ReplyItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ReplyItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ReplyItemList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ReplyItemList;
		if (size)
			*size = sizeof(s0__ReplyItemList);
		((s0__ReplyItemList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ReplyItemList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ReplyItemList);
		for (int i = 0; i < n; i++)
			((s0__ReplyItemList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ReplyItemList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ReplyItemList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ReplyItemList %p -> %p\n", q, p));
	*(s0__ReplyItemList*)p = *(s0__ReplyItemList*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ReadRequestItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	((s0__ReadRequestItem*)this)->ItemPath = NULL;
	((s0__ReadRequestItem*)this)->ReqType = NULL;
	((s0__ReadRequestItem*)this)->ItemName = NULL;
	((s0__ReadRequestItem*)this)->ClientItemHandle = NULL;
	((s0__ReadRequestItem*)this)->MaxAge = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ReadRequestItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int s0__ReadRequestItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ReadRequestItem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ReadRequestItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ReadRequestItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ReadRequestItem(struct soap *soap, const char *tag, int id, const s0__ReadRequestItem *a, const char *type)
{
	if (((s0__ReadRequestItem *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((s0__ReadRequestItem *)a)->ItemPath->c_str());
	if (((s0__ReadRequestItem *)a)->ReqType)
		soap_set_attr(soap, "ReqType", soap_QName2s(soap, ((s0__ReadRequestItem *)a)->ReqType->c_str()));
	if (((s0__ReadRequestItem *)a)->ItemName)
		soap_set_attr(soap, "ItemName", ((s0__ReadRequestItem *)a)->ItemName->c_str());
	if (((s0__ReadRequestItem *)a)->ClientItemHandle)
		soap_set_attr(soap, "ClientItemHandle", ((s0__ReadRequestItem *)a)->ClientItemHandle->c_str());
	if (((s0__ReadRequestItem *)a)->MaxAge)
		soap_set_attr(soap, "MaxAge", soap_int2s(soap, *((s0__ReadRequestItem *)a)->MaxAge));
	return soap_outliteral(soap, tag, &(((xsd__anyType*)a)->__item), "s0:ReadRequestItem");
}

void *s0__ReadRequestItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ReadRequestItem(soap, this, tag, type);
}

SOAP_FMAC3 s0__ReadRequestItem * SOAP_FMAC4 soap_get_s0__ReadRequestItem(struct soap *soap, s0__ReadRequestItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ReadRequestItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ReadRequestItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ReadRequestItem(soap, tag, this, type);
}

SOAP_FMAC3 s0__ReadRequestItem * SOAP_FMAC4 soap_in_s0__ReadRequestItem(struct soap *soap, const char *tag, s0__ReadRequestItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (s0__ReadRequestItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ReadRequestItem, sizeof(s0__ReadRequestItem), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ReadRequestItem)
			return (s0__ReadRequestItem *)a->soap_in(soap, tag, type);
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((s0__ReadRequestItem *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ReadRequestItem *)a)->ItemPath = soap_new_std__string(soap, -1);
			((s0__ReadRequestItem *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ReqType", 0);
		if (t)
		{	if (!(((s0__ReadRequestItem *)a)->ReqType = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2QName(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ReadRequestItem *)a)->ReqType = soap_new_std__string(soap, -1);
			((s0__ReadRequestItem *)a)->ReqType->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemName", 0);
		if (t)
		{	if (!(((s0__ReadRequestItem *)a)->ItemName = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ReadRequestItem *)a)->ItemName = soap_new_std__string(soap, -1);
			((s0__ReadRequestItem *)a)->ItemName->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ClientItemHandle", 0);
		if (t)
		{	if (!(((s0__ReadRequestItem *)a)->ClientItemHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ReadRequestItem *)a)->ClientItemHandle = soap_new_std__string(soap, -1);
			((s0__ReadRequestItem *)a)->ClientItemHandle->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "MaxAge", 0);
		if (t)
		{	if (!(((s0__ReadRequestItem *)a)->MaxAge = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((s0__ReadRequestItem *)a)->MaxAge))
		return NULL;
		}
	}
	if (!soap_inliteral(soap, tag, &(((xsd__anyType*)a)->__item)))
		return NULL;
	return a;
}

SOAP_FMAC5 s0__ReadRequestItem * SOAP_FMAC6 soap_new_s0__ReadRequestItem(struct soap *soap, int n)
{	return soap_instantiate_s0__ReadRequestItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ReadRequestItem(struct soap *soap, s0__ReadRequestItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ReadRequestItem * SOAP_FMAC4 soap_instantiate_s0__ReadRequestItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ReadRequestItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ReadRequestItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ReadRequestItem;
		if (size)
			*size = sizeof(s0__ReadRequestItem);
		((s0__ReadRequestItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ReadRequestItem[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ReadRequestItem);
		for (int i = 0; i < n; i++)
			((s0__ReadRequestItem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ReadRequestItem*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ReadRequestItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ReadRequestItem %p -> %p\n", q, p));
	*(s0__ReadRequestItem*)p = *(s0__ReadRequestItem*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ReadRequestItemList::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTos0__ReadRequestItem(soap, &((s0__ReadRequestItemList*)this)->Items);
	((s0__ReadRequestItemList*)this)->ItemPath = NULL;
	((s0__ReadRequestItemList*)this)->ReqType = NULL;
	((s0__ReadRequestItemList*)this)->MaxAge = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ReadRequestItemList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTos0__ReadRequestItem(soap, &((s0__ReadRequestItemList*)this)->Items);
	/* transient soap skipped */
}

int s0__ReadRequestItemList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ReadRequestItemList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ReadRequestItemList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ReadRequestItemList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ReadRequestItemList(struct soap *soap, const char *tag, int id, const s0__ReadRequestItemList *a, const char *type)
{
	if (((s0__ReadRequestItemList *)a)->ItemPath)
		soap_set_attr(soap, "ItemPath", ((s0__ReadRequestItemList *)a)->ItemPath->c_str());
	if (((s0__ReadRequestItemList *)a)->ReqType)
		soap_set_attr(soap, "ReqType", soap_QName2s(soap, ((s0__ReadRequestItemList *)a)->ReqType->c_str()));
	if (((s0__ReadRequestItemList *)a)->MaxAge)
		soap_set_attr(soap, "MaxAge", soap_int2s(soap, *((s0__ReadRequestItemList *)a)->MaxAge));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ReadRequestItemList), "s0:ReadRequestItemList");
	/* transient soap skipped */
	soap_out_std__vectorTemplateOfPointerTos0__ReadRequestItem(soap, "s0:Items", -1, &(((s0__ReadRequestItemList*)a)->Items), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__ReadRequestItemList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ReadRequestItemList(soap, this, tag, type);
}

SOAP_FMAC3 s0__ReadRequestItemList * SOAP_FMAC4 soap_get_s0__ReadRequestItemList(struct soap *soap, s0__ReadRequestItemList *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ReadRequestItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ReadRequestItemList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ReadRequestItemList(soap, tag, this, type);
}

SOAP_FMAC3 s0__ReadRequestItemList * SOAP_FMAC4 soap_in_s0__ReadRequestItemList(struct soap *soap, const char *tag, s0__ReadRequestItemList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__ReadRequestItemList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ReadRequestItemList, sizeof(s0__ReadRequestItemList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ReadRequestItemList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__ReadRequestItemList *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ItemPath", 0);
		if (t)
		{	if (!(((s0__ReadRequestItemList *)a)->ItemPath = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ReadRequestItemList *)a)->ItemPath = soap_new_std__string(soap, -1);
			((s0__ReadRequestItemList *)a)->ItemPath->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "ReqType", 0);
		if (t)
		{	if (!(((s0__ReadRequestItemList *)a)->ReqType = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2QName(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ReadRequestItemList *)a)->ReqType = soap_new_std__string(soap, -1);
			((s0__ReadRequestItemList *)a)->ReqType->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "MaxAge", 0);
		if (t)
		{	if (!(((s0__ReadRequestItemList *)a)->MaxAge = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2int(soap, t, ((s0__ReadRequestItemList *)a)->MaxAge))
		return NULL;
		}
	}
	short soap_flag___item2 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTos0__ReadRequestItem(soap, "s0:Items", &(((s0__ReadRequestItemList*)a)->Items), "s0:ReadRequestItem"))
					continue;
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__ReadRequestItemList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__ReadRequestItemList, 0, sizeof(s0__ReadRequestItemList), 0, soap_copy_s0__ReadRequestItemList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__ReadRequestItemList * SOAP_FMAC6 soap_new_s0__ReadRequestItemList(struct soap *soap, int n)
{	return soap_instantiate_s0__ReadRequestItemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ReadRequestItemList(struct soap *soap, s0__ReadRequestItemList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ReadRequestItemList * SOAP_FMAC4 soap_instantiate_s0__ReadRequestItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ReadRequestItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ReadRequestItemList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ReadRequestItemList;
		if (size)
			*size = sizeof(s0__ReadRequestItemList);
		((s0__ReadRequestItemList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ReadRequestItemList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ReadRequestItemList);
		for (int i = 0; i < n; i++)
			((s0__ReadRequestItemList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ReadRequestItemList*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ReadRequestItemList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ReadRequestItemList %p -> %p\n", q, p));
	*(s0__ReadRequestItemList*)p = *(s0__ReadRequestItemList*)q;
}
#ifdef __cplusplus
}
#endif

void s0__RequestOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	((s0__RequestOptions*)this)->ReturnErrorText = NULL;
	((s0__RequestOptions*)this)->ReturnDiagnosticInfo = NULL;
	((s0__RequestOptions*)this)->ReturnItemTime = NULL;
	((s0__RequestOptions*)this)->ReturnItemPath = NULL;
	((s0__RequestOptions*)this)->ReturnItemName = NULL;
	((s0__RequestOptions*)this)->RequestDeadline = NULL;
	((s0__RequestOptions*)this)->ClientRequestHandle = NULL;
	((s0__RequestOptions*)this)->LocaleID = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__RequestOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__dateTime(soap, &((s0__RequestOptions*)this)->RequestDeadline);
	/* transient soap skipped */
}

int s0__RequestOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__RequestOptions);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__RequestOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__RequestOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__RequestOptions(struct soap *soap, const char *tag, int id, const s0__RequestOptions *a, const char *type)
{
	if (((s0__RequestOptions *)a)->ReturnErrorText)
		soap_set_attr(soap, "ReturnErrorText", soap_bool2s(soap, *((s0__RequestOptions *)a)->ReturnErrorText));
	if (((s0__RequestOptions *)a)->ReturnDiagnosticInfo)
		soap_set_attr(soap, "ReturnDiagnosticInfo", soap_bool2s(soap, *((s0__RequestOptions *)a)->ReturnDiagnosticInfo));
	if (((s0__RequestOptions *)a)->ReturnItemTime)
		soap_set_attr(soap, "ReturnItemTime", soap_bool2s(soap, *((s0__RequestOptions *)a)->ReturnItemTime));
	if (((s0__RequestOptions *)a)->ReturnItemPath)
		soap_set_attr(soap, "ReturnItemPath", soap_bool2s(soap, *((s0__RequestOptions *)a)->ReturnItemPath));
	if (((s0__RequestOptions *)a)->ReturnItemName)
		soap_set_attr(soap, "ReturnItemName", soap_bool2s(soap, *((s0__RequestOptions *)a)->ReturnItemName));
	if (((s0__RequestOptions *)a)->ClientRequestHandle)
		soap_set_attr(soap, "ClientRequestHandle", ((s0__RequestOptions *)a)->ClientRequestHandle->c_str());
	if (((s0__RequestOptions *)a)->LocaleID)
		soap_set_attr(soap, "LocaleID", ((s0__RequestOptions *)a)->LocaleID->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__RequestOptions), "s0:RequestOptions");
	/* transient soap skipped */
	soap_out_PointerToxsd__dateTime(soap, "s0:RequestDeadline", -1, &(((s0__RequestOptions*)a)->RequestDeadline), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__RequestOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__RequestOptions(soap, this, tag, type);
}

SOAP_FMAC3 s0__RequestOptions * SOAP_FMAC4 soap_get_s0__RequestOptions(struct soap *soap, s0__RequestOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__RequestOptions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__RequestOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__RequestOptions(soap, tag, this, type);
}

SOAP_FMAC3 s0__RequestOptions * SOAP_FMAC4 soap_in_s0__RequestOptions(struct soap *soap, const char *tag, s0__RequestOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__RequestOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__RequestOptions, sizeof(s0__RequestOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__RequestOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__RequestOptions *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnErrorText", 0);
		if (t)
		{	if (!(((s0__RequestOptions *)a)->ReturnErrorText = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((s0__RequestOptions *)a)->ReturnErrorText))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnDiagnosticInfo", 0);
		if (t)
		{	if (!(((s0__RequestOptions *)a)->ReturnDiagnosticInfo = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((s0__RequestOptions *)a)->ReturnDiagnosticInfo))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnItemTime", 0);
		if (t)
		{	if (!(((s0__RequestOptions *)a)->ReturnItemTime = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((s0__RequestOptions *)a)->ReturnItemTime))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnItemPath", 0);
		if (t)
		{	if (!(((s0__RequestOptions *)a)->ReturnItemPath = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((s0__RequestOptions *)a)->ReturnItemPath))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ReturnItemName", 0);
		if (t)
		{	if (!(((s0__RequestOptions *)a)->ReturnItemName = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	if (soap_s2bool(soap, t, ((s0__RequestOptions *)a)->ReturnItemName))
		return NULL;
		}
	}
	{	const char *t = soap_attr_value(soap, "ClientRequestHandle", 0);
		if (t)
		{	if (!(((s0__RequestOptions *)a)->ClientRequestHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__RequestOptions *)a)->ClientRequestHandle = soap_new_std__string(soap, -1);
			((s0__RequestOptions *)a)->ClientRequestHandle->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "LocaleID", 0);
		if (t)
		{	if (!(((s0__RequestOptions *)a)->LocaleID = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__RequestOptions *)a)->LocaleID = soap_new_std__string(soap, -1);
			((s0__RequestOptions *)a)->LocaleID->assign(s);
		}
		}
	}
	short soap_flag___item2 = 1, soap_flag_RequestDeadline1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_RequestDeadline1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__dateTime(soap, "s0:RequestDeadline", &(((s0__RequestOptions*)a)->RequestDeadline), "xsd:dateTime"))
				{	soap_flag_RequestDeadline1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__RequestOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__RequestOptions, 0, sizeof(s0__RequestOptions), 0, soap_copy_s0__RequestOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__RequestOptions * SOAP_FMAC6 soap_new_s0__RequestOptions(struct soap *soap, int n)
{	return soap_instantiate_s0__RequestOptions(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__RequestOptions(struct soap *soap, s0__RequestOptions *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__RequestOptions * SOAP_FMAC4 soap_instantiate_s0__RequestOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__RequestOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__RequestOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__RequestOptions;
		if (size)
			*size = sizeof(s0__RequestOptions);
		((s0__RequestOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__RequestOptions[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__RequestOptions);
		for (int i = 0; i < n; i++)
			((s0__RequestOptions*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__RequestOptions*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__RequestOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__RequestOptions %p -> %p\n", q, p));
	*(s0__RequestOptions*)p = *(s0__RequestOptions*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ServerStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	((s0__ServerStatus*)this)->StatusInfo = NULL;
	((s0__ServerStatus*)this)->VendorInfo = NULL;
	soap_default_std__vectorTemplateOfstd__string(soap, &((s0__ServerStatus*)this)->SupportedLocaleIDs);
	soap_default_std__vectorTemplateOfs0__interfaceVersion(soap, &((s0__ServerStatus*)this)->SupportedInterfaceVersions);
	((s0__ServerStatus*)this)->StartTime.xsd__dateTime::soap_default(soap);
	((s0__ServerStatus*)this)->ProductVersion = NULL;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ServerStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((s0__ServerStatus*)this)->StatusInfo);
	soap_serialize_PointerTostd__string(soap, &((s0__ServerStatus*)this)->VendorInfo);
	soap_serialize_std__vectorTemplateOfstd__string(soap, &((s0__ServerStatus*)this)->SupportedLocaleIDs);
	soap_serialize_std__vectorTemplateOfs0__interfaceVersion(soap, &((s0__ServerStatus*)this)->SupportedInterfaceVersions);
	soap_embedded(soap, &((s0__ServerStatus*)this)->StartTime, SOAP_TYPE_xsd__dateTime);
	((s0__ServerStatus*)this)->StartTime.soap_serialize(soap);
	/* transient soap skipped */
}

int s0__ServerStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ServerStatus);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ServerStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ServerStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ServerStatus(struct soap *soap, const char *tag, int id, const s0__ServerStatus *a, const char *type)
{
	if (((s0__ServerStatus *)a)->ProductVersion)
		soap_set_attr(soap, "ProductVersion", ((s0__ServerStatus *)a)->ProductVersion->c_str());
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ServerStatus), "s0:ServerStatus");
	/* transient soap skipped */
	soap_out_PointerTostd__string(soap, "s0:StatusInfo", -1, &(((s0__ServerStatus*)a)->StatusInfo), "");
	soap_out_PointerTostd__string(soap, "s0:VendorInfo", -1, &(((s0__ServerStatus*)a)->VendorInfo), "");
	soap_out_std__vectorTemplateOfstd__string(soap, "s0:SupportedLocaleIDs", -1, &(((s0__ServerStatus*)a)->SupportedLocaleIDs), "");
	soap_out_std__vectorTemplateOfs0__interfaceVersion(soap, "s0:SupportedInterfaceVersions", -1, &(((s0__ServerStatus*)a)->SupportedInterfaceVersions), "");
	(((s0__ServerStatus*)a)->StartTime).soap_out(soap, "s0:StartTime", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__ServerStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ServerStatus(soap, this, tag, type);
}

SOAP_FMAC3 s0__ServerStatus * SOAP_FMAC4 soap_get_s0__ServerStatus(struct soap *soap, s0__ServerStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ServerStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ServerStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ServerStatus(soap, tag, this, type);
}

SOAP_FMAC3 s0__ServerStatus * SOAP_FMAC4 soap_in_s0__ServerStatus(struct soap *soap, const char *tag, s0__ServerStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__ServerStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ServerStatus, sizeof(s0__ServerStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ServerStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__ServerStatus *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ProductVersion", 0);
		if (t)
		{	if (!(((s0__ServerStatus *)a)->ProductVersion = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ServerStatus *)a)->ProductVersion = soap_new_std__string(soap, -1);
			((s0__ServerStatus *)a)->ProductVersion->assign(s);
		}
		}
	}
	short soap_flag___item2 = 1, soap_flag_StatusInfo1 = 1, soap_flag_VendorInfo1 = 1, soap_flag_StartTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_StatusInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "s0:StatusInfo", &(((s0__ServerStatus*)a)->StatusInfo), "xsd:string"))
				{	soap_flag_StatusInfo1--;
					continue;
				}
			if (soap_flag_VendorInfo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "s0:VendorInfo", &(((s0__ServerStatus*)a)->VendorInfo), "xsd:string"))
				{	soap_flag_VendorInfo1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "s0:SupportedLocaleIDs", &(((s0__ServerStatus*)a)->SupportedLocaleIDs), "xsd:string"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfs0__interfaceVersion(soap, "s0:SupportedInterfaceVersions", &(((s0__ServerStatus*)a)->SupportedInterfaceVersions), "s0:interfaceVersion"))
					continue;
			if (soap_flag_StartTime1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((s0__ServerStatus*)a)->StartTime).soap_in(soap, "s0:StartTime", "xsd:dateTime"))
				{	soap_flag_StartTime1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__ServerStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__ServerStatus, 0, sizeof(s0__ServerStatus), 0, soap_copy_s0__ServerStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__ServerStatus * SOAP_FMAC6 soap_new_s0__ServerStatus(struct soap *soap, int n)
{	return soap_instantiate_s0__ServerStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ServerStatus(struct soap *soap, s0__ServerStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ServerStatus * SOAP_FMAC4 soap_instantiate_s0__ServerStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ServerStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ServerStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ServerStatus;
		if (size)
			*size = sizeof(s0__ServerStatus);
		((s0__ServerStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ServerStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ServerStatus);
		for (int i = 0; i < n; i++)
			((s0__ServerStatus*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ServerStatus*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ServerStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ServerStatus %p -> %p\n", q, p));
	*(s0__ServerStatus*)p = *(s0__ServerStatus*)q;
}
#ifdef __cplusplus
}
#endif

void s0__ReplyBase::soap_default(struct soap *soap)
{
	this->soap = soap;
	((s0__ReplyBase*)this)->RcvTime.xsd__dateTime::soap_default(soap);
	((s0__ReplyBase*)this)->ReplyTime.xsd__dateTime::soap_default(soap);
	((s0__ReplyBase*)this)->ClientRequestHandle = NULL;
	((s0__ReplyBase*)this)->RevisedLocaleID = NULL;
	soap_default_s0__serverState(soap, &((s0__ReplyBase*)this)->ServerState);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void s0__ReplyBase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((s0__ReplyBase*)this)->RcvTime, SOAP_TYPE_xsd__dateTime);
	((s0__ReplyBase*)this)->RcvTime.soap_serialize(soap);
	soap_embedded(soap, &((s0__ReplyBase*)this)->ReplyTime, SOAP_TYPE_xsd__dateTime);
	((s0__ReplyBase*)this)->ReplyTime.soap_serialize(soap);
	/* transient soap skipped */
}

int s0__ReplyBase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_s0__ReplyBase);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int s0__ReplyBase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_s0__ReplyBase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_s0__ReplyBase(struct soap *soap, const char *tag, int id, const s0__ReplyBase *a, const char *type)
{
	if (((s0__ReplyBase *)a)->ClientRequestHandle)
		soap_set_attr(soap, "ClientRequestHandle", ((s0__ReplyBase *)a)->ClientRequestHandle->c_str());
	if (((s0__ReplyBase *)a)->RevisedLocaleID)
		soap_set_attr(soap, "RevisedLocaleID", ((s0__ReplyBase *)a)->RevisedLocaleID->c_str());
	soap_set_attr(soap, "ServerState", soap_s0__serverState2s(soap, ((s0__ReplyBase *)a)->ServerState));
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_s0__ReplyBase), "s0:ReplyBase");
	/* transient soap skipped */
	(((s0__ReplyBase*)a)->RcvTime).soap_out(soap, "s0:RcvTime", -1, "");
	(((s0__ReplyBase*)a)->ReplyTime).soap_out(soap, "s0:ReplyTime", -1, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *s0__ReplyBase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_s0__ReplyBase(soap, this, tag, type);
}

SOAP_FMAC3 s0__ReplyBase * SOAP_FMAC4 soap_get_s0__ReplyBase(struct soap *soap, s0__ReplyBase *p, const char *tag, const char *type)
{
	if ((p = soap_in_s0__ReplyBase(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *s0__ReplyBase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_s0__ReplyBase(soap, tag, this, type);
}

SOAP_FMAC3 s0__ReplyBase * SOAP_FMAC4 soap_in_s0__ReplyBase(struct soap *soap, const char *tag, s0__ReplyBase *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (s0__ReplyBase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_s0__ReplyBase, sizeof(s0__ReplyBase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_s0__ReplyBase)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (s0__ReplyBase *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "ClientRequestHandle", 0);
		if (t)
		{	if (!(((s0__ReplyBase *)a)->ClientRequestHandle = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ReplyBase *)a)->ClientRequestHandle = soap_new_std__string(soap, -1);
			((s0__ReplyBase *)a)->ClientRequestHandle->assign(s);
		}
		}
	}
	{	const char *t = soap_attr_value(soap, "RevisedLocaleID", 0);
		if (t)
		{	if (!(((s0__ReplyBase *)a)->RevisedLocaleID = (std::string *)soap_malloc(soap, sizeof(std::string))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
	char *s;
		if (soap_s2string(soap, t, &s))
			return NULL;
		if (s)
		{	((s0__ReplyBase *)a)->RevisedLocaleID = soap_new_std__string(soap, -1);
			((s0__ReplyBase *)a)->RevisedLocaleID->assign(s);
		}
		}
	}
	if (soap_s2s0__serverState(soap, soap_attr_value(soap, "ServerState", 1), &((s0__ReplyBase *)a)->ServerState))
		return NULL;
	short soap_flag___item2 = 1, soap_flag_RcvTime1 = 1, soap_flag_ReplyTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_RcvTime1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((s0__ReplyBase*)a)->RcvTime).soap_in(soap, "s0:RcvTime", "xsd:dateTime"))
				{	soap_flag_RcvTime1--;
					continue;
				}
			if (soap_flag_ReplyTime1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((s0__ReplyBase*)a)->ReplyTime).soap_in(soap, "s0:ReplyTime", "xsd:dateTime"))
				{	soap_flag_ReplyTime1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(((xsd__anyType*)a)->__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RcvTime1 > 0 || soap_flag_ReplyTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (s0__ReplyBase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_s0__ReplyBase, 0, sizeof(s0__ReplyBase), 0, soap_copy_s0__ReplyBase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 s0__ReplyBase * SOAP_FMAC6 soap_new_s0__ReplyBase(struct soap *soap, int n)
{	return soap_instantiate_s0__ReplyBase(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_s0__ReplyBase(struct soap *soap, s0__ReplyBase *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 s0__ReplyBase * SOAP_FMAC4 soap_instantiate_s0__ReplyBase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_s0__ReplyBase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_s0__ReplyBase, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new s0__ReplyBase;
		if (size)
			*size = sizeof(s0__ReplyBase);
		((s0__ReplyBase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new s0__ReplyBase[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(s0__ReplyBase);
		for (int i = 0; i < n; i++)
			((s0__ReplyBase*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (s0__ReplyBase*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_s0__ReplyBase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying s0__ReplyBase %p -> %p\n", q, p));
	*(s0__ReplyBase*)p = *(s0__ReplyBase*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__unsignedShort::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedShort(soap, &((xsd__unsignedShort*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void xsd__unsignedShort::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((xsd__unsignedShort*)this)->__item, SOAP_TYPE_unsignedShort);
	/* transient soap skipped */
}

int xsd__unsignedShort::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedShort);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__unsignedShort::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedShort(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedShort(struct soap *soap, const char *tag, int id, const xsd__unsignedShort *a, const char *type)
{
	return soap_out_unsignedShort(soap, tag, id, &(((xsd__unsignedShort*)a)->__item), "xsd:unsignedShort");
}

void *xsd__unsignedShort::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedShort(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedShort * SOAP_FMAC4 soap_get_xsd__unsignedShort(struct soap *soap, xsd__unsignedShort *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedShort(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__unsignedShort::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedShort(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedShort * SOAP_FMAC4 soap_in_xsd__unsignedShort(struct soap *soap, const char *tag, xsd__unsignedShort *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__unsignedShort *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedShort, sizeof(xsd__unsignedShort), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__unsignedShort)
			return (xsd__unsignedShort *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_unsignedShort(soap, tag, &(((xsd__unsignedShort*)a)->__item), "xsd:unsignedShort"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__unsignedShort * SOAP_FMAC6 soap_new_xsd__unsignedShort(struct soap *soap, int n)
{	return soap_instantiate_xsd__unsignedShort(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__unsignedShort(struct soap *soap, xsd__unsignedShort *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__unsignedShort * SOAP_FMAC4 soap_instantiate_xsd__unsignedShort(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedShort(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedShort, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__unsignedShort;
		if (size)
			*size = sizeof(xsd__unsignedShort);
		((xsd__unsignedShort*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__unsignedShort[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__unsignedShort);
		for (int i = 0; i < n; i++)
			((xsd__unsignedShort*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__unsignedShort*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__unsignedShort(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedShort %p -> %p\n", q, p));
	*(xsd__unsignedShort*)p = *(xsd__unsignedShort*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__unsignedLong::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedLONG64(soap, &((xsd__unsignedLong*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void xsd__unsignedLong::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__unsignedLong::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedLong);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__unsignedLong::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedLong(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedLong(struct soap *soap, const char *tag, int id, const xsd__unsignedLong *a, const char *type)
{
	return soap_out_unsignedLONG64(soap, tag, id, &(((xsd__unsignedLong*)a)->__item), "xsd:unsignedLong");
}

void *xsd__unsignedLong::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedLong(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedLong * SOAP_FMAC4 soap_get_xsd__unsignedLong(struct soap *soap, xsd__unsignedLong *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedLong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__unsignedLong::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedLong(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedLong * SOAP_FMAC4 soap_in_xsd__unsignedLong(struct soap *soap, const char *tag, xsd__unsignedLong *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__unsignedLong *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedLong, sizeof(xsd__unsignedLong), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__unsignedLong)
			return (xsd__unsignedLong *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_unsignedLONG64(soap, tag, &(((xsd__unsignedLong*)a)->__item), "xsd:unsignedLong"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__unsignedLong * SOAP_FMAC6 soap_new_xsd__unsignedLong(struct soap *soap, int n)
{	return soap_instantiate_xsd__unsignedLong(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__unsignedLong(struct soap *soap, xsd__unsignedLong *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__unsignedLong * SOAP_FMAC4 soap_instantiate_xsd__unsignedLong(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedLong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedLong, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__unsignedLong;
		if (size)
			*size = sizeof(xsd__unsignedLong);
		((xsd__unsignedLong*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__unsignedLong[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__unsignedLong);
		for (int i = 0; i < n; i++)
			((xsd__unsignedLong*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__unsignedLong*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__unsignedLong(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedLong %p -> %p\n", q, p));
	*(xsd__unsignedLong*)p = *(xsd__unsignedLong*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__unsignedInt::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedInt(soap, &((xsd__unsignedInt*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void xsd__unsignedInt::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__unsignedInt::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedInt);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__unsignedInt::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedInt(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedInt(struct soap *soap, const char *tag, int id, const xsd__unsignedInt *a, const char *type)
{
	return soap_out_unsignedInt(soap, tag, id, &(((xsd__unsignedInt*)a)->__item), "xsd:unsignedInt");
}

void *xsd__unsignedInt::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedInt(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedInt * SOAP_FMAC4 soap_get_xsd__unsignedInt(struct soap *soap, xsd__unsignedInt *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedInt(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__unsignedInt::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedInt(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedInt * SOAP_FMAC4 soap_in_xsd__unsignedInt(struct soap *soap, const char *tag, xsd__unsignedInt *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__unsignedInt *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedInt, sizeof(xsd__unsignedInt), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__unsignedInt)
			return (xsd__unsignedInt *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_unsignedInt(soap, tag, &(((xsd__unsignedInt*)a)->__item), "xsd:unsignedInt"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__unsignedInt * SOAP_FMAC6 soap_new_xsd__unsignedInt(struct soap *soap, int n)
{	return soap_instantiate_xsd__unsignedInt(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__unsignedInt(struct soap *soap, xsd__unsignedInt *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__unsignedInt * SOAP_FMAC4 soap_instantiate_xsd__unsignedInt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedInt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedInt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__unsignedInt;
		if (size)
			*size = sizeof(xsd__unsignedInt);
		((xsd__unsignedInt*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__unsignedInt[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__unsignedInt);
		for (int i = 0; i < n; i++)
			((xsd__unsignedInt*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__unsignedInt*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__unsignedInt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedInt %p -> %p\n", q, p));
	*(xsd__unsignedInt*)p = *(xsd__unsignedInt*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__unsignedByte::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_unsignedByte(soap, &((xsd__unsignedByte*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void xsd__unsignedByte::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__unsignedByte::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__unsignedByte);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__unsignedByte::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__unsignedByte(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__unsignedByte(struct soap *soap, const char *tag, int id, const xsd__unsignedByte *a, const char *type)
{
	return soap_out_unsignedByte(soap, tag, id, &(((xsd__unsignedByte*)a)->__item), "xsd:unsignedByte");
}

void *xsd__unsignedByte::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__unsignedByte(soap, this, tag, type);
}

SOAP_FMAC3 xsd__unsignedByte * SOAP_FMAC4 soap_get_xsd__unsignedByte(struct soap *soap, xsd__unsignedByte *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__unsignedByte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__unsignedByte::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__unsignedByte(soap, tag, this, type);
}

SOAP_FMAC3 xsd__unsignedByte * SOAP_FMAC4 soap_in_xsd__unsignedByte(struct soap *soap, const char *tag, xsd__unsignedByte *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__unsignedByte *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__unsignedByte, sizeof(xsd__unsignedByte), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__unsignedByte)
			return (xsd__unsignedByte *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_unsignedByte(soap, tag, &(((xsd__unsignedByte*)a)->__item), "xsd:unsignedByte"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__unsignedByte * SOAP_FMAC6 soap_new_xsd__unsignedByte(struct soap *soap, int n)
{	return soap_instantiate_xsd__unsignedByte(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__unsignedByte(struct soap *soap, xsd__unsignedByte *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__unsignedByte * SOAP_FMAC4 soap_instantiate_xsd__unsignedByte(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__unsignedByte(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__unsignedByte, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__unsignedByte;
		if (size)
			*size = sizeof(xsd__unsignedByte);
		((xsd__unsignedByte*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__unsignedByte[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__unsignedByte);
		for (int i = 0; i < n; i++)
			((xsd__unsignedByte*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__unsignedByte*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__unsignedByte(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__unsignedByte %p -> %p\n", q, p));
	*(xsd__unsignedByte*)p = *(xsd__unsignedByte*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__string::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((xsd__string*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void xsd__string::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((xsd__string*)this)->__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((xsd__string*)this)->__item);
	/* transient soap skipped */
}

int xsd__string::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__string);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__string::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__string(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, const xsd__string *a, const char *type)
{
	return soap_out_std__string(soap, tag, id, &(((xsd__string*)a)->__item), "xsd:string");
}

void *xsd__string::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__string(soap, this, tag, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, xsd__string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__string::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__string(soap, tag, this, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, xsd__string *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__string *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__string, sizeof(xsd__string), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__string)
			return (xsd__string *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_std__string(soap, tag, &(((xsd__string*)a)->__item), "xsd:string"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__string * SOAP_FMAC6 soap_new_xsd__string(struct soap *soap, int n)
{	return soap_instantiate_xsd__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__string(struct soap *soap, xsd__string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_instantiate_xsd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__string;
		if (size)
			*size = sizeof(xsd__string);
		((xsd__string*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__string);
		for (int i = 0; i < n; i++)
			((xsd__string*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__string*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__string %p -> %p\n", q, p));
	*(xsd__string*)p = *(xsd__string*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__short::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &((xsd__short*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void xsd__short::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__short::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__short);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__short::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__short(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__short(struct soap *soap, const char *tag, int id, const xsd__short *a, const char *type)
{
	return soap_out_short(soap, tag, id, &(((xsd__short*)a)->__item), "xsd:short");
}

void *xsd__short::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__short(soap, this, tag, type);
}

SOAP_FMAC3 xsd__short * SOAP_FMAC4 soap_get_xsd__short(struct soap *soap, xsd__short *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__short(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__short::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__short(soap, tag, this, type);
}

SOAP_FMAC3 xsd__short * SOAP_FMAC4 soap_in_xsd__short(struct soap *soap, const char *tag, xsd__short *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__short *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__short, sizeof(xsd__short), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__short)
			return (xsd__short *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_short(soap, tag, &(((xsd__short*)a)->__item), "xsd:short"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__short * SOAP_FMAC6 soap_new_xsd__short(struct soap *soap, int n)
{	return soap_instantiate_xsd__short(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__short(struct soap *soap, xsd__short *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__short * SOAP_FMAC4 soap_instantiate_xsd__short(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__short(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__short, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__short;
		if (size)
			*size = sizeof(xsd__short);
		((xsd__short*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__short[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__short);
		for (int i = 0; i < n; i++)
			((xsd__short*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__short*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__short(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__short %p -> %p\n", q, p));
	*(xsd__short*)p = *(xsd__short*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__long::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &((xsd__long*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void xsd__long::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__long::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__long);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__long::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__long(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__long(struct soap *soap, const char *tag, int id, const xsd__long *a, const char *type)
{
	return soap_out_LONG64(soap, tag, id, &(((xsd__long*)a)->__item), "xsd:long");
}

void *xsd__long::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__long(soap, this, tag, type);
}

SOAP_FMAC3 xsd__long * SOAP_FMAC4 soap_get_xsd__long(struct soap *soap, xsd__long *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__long(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__long::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__long(soap, tag, this, type);
}

SOAP_FMAC3 xsd__long * SOAP_FMAC4 soap_in_xsd__long(struct soap *soap, const char *tag, xsd__long *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__long *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__long, sizeof(xsd__long), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__long)
			return (xsd__long *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_LONG64(soap, tag, &(((xsd__long*)a)->__item), "xsd:long"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__long * SOAP_FMAC6 soap_new_xsd__long(struct soap *soap, int n)
{	return soap_instantiate_xsd__long(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__long(struct soap *soap, xsd__long *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__long * SOAP_FMAC4 soap_instantiate_xsd__long(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__long(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__long, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__long;
		if (size)
			*size = sizeof(xsd__long);
		((xsd__long*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__long[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__long);
		for (int i = 0; i < n; i++)
			((xsd__long*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__long*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__long(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__long %p -> %p\n", q, p));
	*(xsd__long*)p = *(xsd__long*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__int::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &((xsd__int*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void xsd__int::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((xsd__int*)this)->__item, SOAP_TYPE_int);
	/* transient soap skipped */
}

int xsd__int::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__int);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__int::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__int(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const xsd__int *a, const char *type)
{
	return soap_out_int(soap, tag, id, &(((xsd__int*)a)->__item), "xsd:int");
}

void *xsd__int::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__int(soap, this, tag, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_get_xsd__int(struct soap *soap, xsd__int *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__int::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__int(soap, tag, this, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_in_xsd__int(struct soap *soap, const char *tag, xsd__int *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__int *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__int, sizeof(xsd__int), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__int)
			return (xsd__int *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_int(soap, tag, &(((xsd__int*)a)->__item), "xsd:int"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__int * SOAP_FMAC6 soap_new_xsd__int(struct soap *soap, int n)
{	return soap_instantiate_xsd__int(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__int(struct soap *soap, xsd__int *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_instantiate_xsd__int(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__int(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__int, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__int;
		if (size)
			*size = sizeof(xsd__int);
		((xsd__int*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__int[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__int);
		for (int i = 0; i < n; i++)
			((xsd__int*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__int*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__int(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__int %p -> %p\n", q, p));
	*(xsd__int*)p = *(xsd__int*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__float::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_float(soap, &((xsd__float*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void xsd__float::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((xsd__float*)this)->__item, SOAP_TYPE_float);
	/* transient soap skipped */
}

int xsd__float::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__float);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__float::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__float(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__float(struct soap *soap, const char *tag, int id, const xsd__float *a, const char *type)
{
	return soap_out_float(soap, tag, id, &(((xsd__float*)a)->__item), "xsd:float");
}

void *xsd__float::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__float(soap, this, tag, type);
}

SOAP_FMAC3 xsd__float * SOAP_FMAC4 soap_get_xsd__float(struct soap *soap, xsd__float *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__float(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__float::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__float(soap, tag, this, type);
}

SOAP_FMAC3 xsd__float * SOAP_FMAC4 soap_in_xsd__float(struct soap *soap, const char *tag, xsd__float *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__float *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__float, sizeof(xsd__float), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__float)
			return (xsd__float *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_float(soap, tag, &(((xsd__float*)a)->__item), "xsd:float"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__float * SOAP_FMAC6 soap_new_xsd__float(struct soap *soap, int n)
{	return soap_instantiate_xsd__float(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__float(struct soap *soap, xsd__float *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__float * SOAP_FMAC4 soap_instantiate_xsd__float(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__float(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__float, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__float;
		if (size)
			*size = sizeof(xsd__float);
		((xsd__float*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__float[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__float);
		for (int i = 0; i < n; i++)
			((xsd__float*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__float*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__float(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__float %p -> %p\n", q, p));
	*(xsd__float*)p = *(xsd__float*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__double::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &((xsd__double*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void xsd__double::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__double::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__double);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__double::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__double(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double(struct soap *soap, const char *tag, int id, const xsd__double *a, const char *type)
{
	return soap_out_double(soap, tag, id, &(((xsd__double*)a)->__item), "xsd:double");
}

void *xsd__double::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__double(soap, this, tag, type);
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_get_xsd__double(struct soap *soap, xsd__double *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__double(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__double::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__double(soap, tag, this, type);
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_in_xsd__double(struct soap *soap, const char *tag, xsd__double *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__double *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__double, sizeof(xsd__double), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__double)
			return (xsd__double *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_double(soap, tag, &(((xsd__double*)a)->__item), "xsd:double"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__double * SOAP_FMAC6 soap_new_xsd__double(struct soap *soap, int n)
{	return soap_instantiate_xsd__double(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__double(struct soap *soap, xsd__double *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_instantiate_xsd__double(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__double(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__double, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__double;
		if (size)
			*size = sizeof(xsd__double);
		((xsd__double*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__double[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__double);
		for (int i = 0; i < n; i++)
			((xsd__double*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__double*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__double(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__double %p -> %p\n", q, p));
	*(xsd__double*)p = *(xsd__double*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__decimal_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void xsd__decimal_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__decimal(soap, &((xsd__decimal_*)this)->__item);
	/* transient soap skipped */
}

int xsd__decimal_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__decimal_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__decimal_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__decimal_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal_(struct soap *soap, const char *tag, int id, const xsd__decimal_ *a, const char *type)
{
	return soap_out_xsd__decimal(soap, tag, id, &(((xsd__decimal_*)a)->__item), "xsd:decimal");
}

void *xsd__decimal_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__decimal_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__decimal_ * SOAP_FMAC4 soap_get_xsd__decimal_(struct soap *soap, xsd__decimal_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__decimal_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__decimal_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__decimal_ * SOAP_FMAC4 soap_in_xsd__decimal_(struct soap *soap, const char *tag, xsd__decimal_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__decimal_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__decimal_, sizeof(xsd__decimal_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__decimal_)
			return (xsd__decimal_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__decimal(soap, tag, &(((xsd__decimal_*)a)->__item), "xsd:decimal"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__decimal_ * SOAP_FMAC6 soap_new_xsd__decimal_(struct soap *soap, int n)
{	return soap_instantiate_xsd__decimal_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__decimal_(struct soap *soap, xsd__decimal_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__decimal_ * SOAP_FMAC4 soap_instantiate_xsd__decimal_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__decimal_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__decimal_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__decimal_;
		if (size)
			*size = sizeof(xsd__decimal_);
		((xsd__decimal_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__decimal_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__decimal_);
		for (int i = 0; i < n; i++)
			((xsd__decimal_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__decimal_*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__decimal_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__decimal_ %p -> %p\n", q, p));
	*(xsd__decimal_*)p = *(xsd__decimal_*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__decimal(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__decimal);
	if (soap_out_xsd__decimal(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__decimal), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__decimal(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__decimal(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__decimal(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__decimal, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__decimal, 0, sizeof(std::string), 0, soap_copy_xsd__decimal);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__decimal(struct soap *soap, int n)
{	return soap_instantiate_xsd__decimal(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__decimal(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__decimal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__decimal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__decimal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__decimal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__dateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((xsd__dateTime*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void xsd__dateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((xsd__dateTime*)this)->__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((xsd__dateTime*)this)->__item);
	/* transient soap skipped */
}

int xsd__dateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__dateTime);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__dateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__dateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime(struct soap *soap, const char *tag, int id, const xsd__dateTime *a, const char *type)
{
	return soap_out_std__string(soap, tag, id, &(((xsd__dateTime*)a)->__item), "xsd:dateTime");
}

void *xsd__dateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__dateTime(soap, this, tag, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_get_xsd__dateTime(struct soap *soap, xsd__dateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__dateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__dateTime(soap, tag, this, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_in_xsd__dateTime(struct soap *soap, const char *tag, xsd__dateTime *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__dateTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__dateTime, sizeof(xsd__dateTime), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__dateTime)
			return (xsd__dateTime *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_std__string(soap, tag, &(((xsd__dateTime*)a)->__item), "xsd:dateTime"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__dateTime * SOAP_FMAC6 soap_new_xsd__dateTime(struct soap *soap, int n)
{	return soap_instantiate_xsd__dateTime(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__dateTime(struct soap *soap, xsd__dateTime *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_instantiate_xsd__dateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__dateTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__dateTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__dateTime;
		if (size)
			*size = sizeof(xsd__dateTime);
		((xsd__dateTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__dateTime[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__dateTime);
		for (int i = 0; i < n; i++)
			((xsd__dateTime*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__dateTime*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__dateTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__dateTime %p -> %p\n", q, p));
	*(xsd__dateTime*)p = *(xsd__dateTime*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__byte::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_byte(soap, &((xsd__byte*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void xsd__byte::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((xsd__byte*)this)->__item, SOAP_TYPE_byte);
	/* transient soap skipped */
}

int xsd__byte::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__byte);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__byte::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__byte(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__byte(struct soap *soap, const char *tag, int id, const xsd__byte *a, const char *type)
{
	return soap_out_byte(soap, tag, id, &(((xsd__byte*)a)->__item), "xsd:byte");
}

void *xsd__byte::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__byte(soap, this, tag, type);
}

SOAP_FMAC3 xsd__byte * SOAP_FMAC4 soap_get_xsd__byte(struct soap *soap, xsd__byte *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__byte::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__byte(soap, tag, this, type);
}

SOAP_FMAC3 xsd__byte * SOAP_FMAC4 soap_in_xsd__byte(struct soap *soap, const char *tag, xsd__byte *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__byte *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__byte, sizeof(xsd__byte), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__byte)
			return (xsd__byte *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_byte(soap, tag, &(((xsd__byte*)a)->__item), "xsd:byte"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__byte * SOAP_FMAC6 soap_new_xsd__byte(struct soap *soap, int n)
{	return soap_instantiate_xsd__byte(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__byte(struct soap *soap, xsd__byte *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__byte * SOAP_FMAC4 soap_instantiate_xsd__byte(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__byte(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__byte, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__byte;
		if (size)
			*size = sizeof(xsd__byte);
		((xsd__byte*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__byte[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__byte);
		for (int i = 0; i < n; i++)
			((xsd__byte*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__byte*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__byte(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__byte %p -> %p\n", q, p));
	*(xsd__byte*)p = *(xsd__byte*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__boolean::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &((xsd__boolean*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void xsd__boolean::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((xsd__boolean*)this)->__item, SOAP_TYPE_bool);
	/* transient soap skipped */
}

int xsd__boolean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__boolean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__boolean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const xsd__boolean *a, const char *type)
{
	return soap_out_bool(soap, tag, id, &(((xsd__boolean*)a)->__item), "xsd:boolean");
}

void *xsd__boolean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__boolean(soap, this, tag, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__boolean::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__boolean(soap, tag, this, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__boolean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(xsd__boolean), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__boolean)
			return (xsd__boolean *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_bool(soap, tag, &(((xsd__boolean*)a)->__item), "xsd:boolean"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__boolean * SOAP_FMAC6 soap_new_xsd__boolean(struct soap *soap, int n)
{	return soap_instantiate_xsd__boolean(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__boolean(struct soap *soap, xsd__boolean *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_instantiate_xsd__boolean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__boolean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__boolean, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__boolean;
		if (size)
			*size = sizeof(xsd__boolean);
		((xsd__boolean*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__boolean[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__boolean);
		for (int i = 0; i < n; i++)
			((xsd__boolean*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__boolean*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__boolean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__boolean %p -> %p\n", q, p));
	*(xsd__boolean*)p = *(xsd__boolean*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__QName_::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__QName(soap, &((xsd__QName_*)this)->__item);
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void xsd__QName_::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((xsd__QName_*)this)->__item, SOAP_TYPE_xsd__QName);
	soap_serialize_xsd__QName(soap, &((xsd__QName_*)this)->__item);
	/* transient soap skipped */
}

int xsd__QName_::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__QName_);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__QName_::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__QName_(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName_(struct soap *soap, const char *tag, int id, const xsd__QName_ *a, const char *type)
{
	std::string soap_tmp___item(soap_QName2s(soap, a->__item.c_str()));
	return soap_out_xsd__QName(soap, tag, id, &soap_tmp___item, "xsd:QName");
}

void *xsd__QName_::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__QName_(soap, this, tag, type);
}

SOAP_FMAC3 xsd__QName_ * SOAP_FMAC4 soap_get_xsd__QName_(struct soap *soap, xsd__QName_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName_(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__QName_::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__QName_(soap, tag, this, type);
}

SOAP_FMAC3 xsd__QName_ * SOAP_FMAC4 soap_in_xsd__QName_(struct soap *soap, const char *tag, xsd__QName_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__QName_ *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__QName_, sizeof(xsd__QName_), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__QName_)
			return (xsd__QName_ *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_xsd__QName(soap, tag, &(((xsd__QName_*)a)->__item), "xsd:QName"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__QName_ * SOAP_FMAC6 soap_new_xsd__QName_(struct soap *soap, int n)
{	return soap_instantiate_xsd__QName_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__QName_(struct soap *soap, xsd__QName_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__QName_ * SOAP_FMAC4 soap_instantiate_xsd__QName_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__QName_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__QName_;
		if (size)
			*size = sizeof(xsd__QName_);
		((xsd__QName_*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__QName_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__QName_);
		for (int i = 0; i < n; i++)
			((xsd__QName_*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__QName_*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__QName_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__QName_ %p -> %p\n", q, p));
	*(xsd__QName_*)p = *(xsd__QName_*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__QName(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__QName);
	if (soap_out_xsd__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__QName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__QName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 2, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__QName, 0, sizeof(std::string), 0, soap_copy_xsd__QName);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__QName(struct soap *soap, int n)
{	return soap_instantiate_xsd__QName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__QName(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__QName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__QName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}
#ifdef __cplusplus
}
#endif

void xsd__anyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	((xsd__anyType*)this)->__item = NULL;
	/* transient soap skipped */
}

void xsd__anyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anyType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a, const char *type)
{
	return soap_outliteral(soap, tag, &(((xsd__anyType*)a)->__item), NULL);
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__anyType)
			return (xsd__anyType *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(((xsd__anyType*)a)->__item)))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__anyType * SOAP_FMAC6 soap_new_xsd__anyType(struct soap *soap, int n)
{	return soap_instantiate_xsd__anyType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__anyType(struct soap *soap, xsd__anyType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:QName"))
	{	cp->type = SOAP_TYPE_xsd__QName_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__QName_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__QName_);
			((xsd__QName_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__QName_[n];
			if (size)
				*size = n * sizeof(xsd__QName_);
			for (int i = 0; i < n; i++)
				((xsd__QName_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__QName_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:boolean"))
	{	cp->type = SOAP_TYPE_xsd__boolean;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__boolean;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__boolean);
			((xsd__boolean*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__boolean[n];
			if (size)
				*size = n * sizeof(xsd__boolean);
			for (int i = 0; i < n; i++)
				((xsd__boolean*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__boolean*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:byte"))
	{	cp->type = SOAP_TYPE_xsd__byte;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__byte;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__byte);
			((xsd__byte*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__byte[n];
			if (size)
				*size = n * sizeof(xsd__byte);
			for (int i = 0; i < n; i++)
				((xsd__byte*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__byte*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:dateTime"))
	{	cp->type = SOAP_TYPE_xsd__dateTime;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__dateTime;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__dateTime);
			((xsd__dateTime*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__dateTime[n];
			if (size)
				*size = n * sizeof(xsd__dateTime);
			for (int i = 0; i < n; i++)
				((xsd__dateTime*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__dateTime*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:decimal"))
	{	cp->type = SOAP_TYPE_xsd__decimal_;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__decimal_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__decimal_);
			((xsd__decimal_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__decimal_[n];
			if (size)
				*size = n * sizeof(xsd__decimal_);
			for (int i = 0; i < n; i++)
				((xsd__decimal_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__decimal_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:double"))
	{	cp->type = SOAP_TYPE_xsd__double;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__double;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__double);
			((xsd__double*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__double[n];
			if (size)
				*size = n * sizeof(xsd__double);
			for (int i = 0; i < n; i++)
				((xsd__double*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__double*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:float"))
	{	cp->type = SOAP_TYPE_xsd__float;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__float;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__float);
			((xsd__float*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__float[n];
			if (size)
				*size = n * sizeof(xsd__float);
			for (int i = 0; i < n; i++)
				((xsd__float*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__float*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:int"))
	{	cp->type = SOAP_TYPE_xsd__int;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__int;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__int);
			((xsd__int*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__int[n];
			if (size)
				*size = n * sizeof(xsd__int);
			for (int i = 0; i < n; i++)
				((xsd__int*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__int*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:long"))
	{	cp->type = SOAP_TYPE_xsd__long;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__long;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__long);
			((xsd__long*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__long[n];
			if (size)
				*size = n * sizeof(xsd__long);
			for (int i = 0; i < n; i++)
				((xsd__long*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__long*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:short"))
	{	cp->type = SOAP_TYPE_xsd__short;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__short;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__short);
			((xsd__short*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__short[n];
			if (size)
				*size = n * sizeof(xsd__short);
			for (int i = 0; i < n; i++)
				((xsd__short*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__short*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:string"))
	{	cp->type = SOAP_TYPE_xsd__string;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__string;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__string);
			((xsd__string*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__string[n];
			if (size)
				*size = n * sizeof(xsd__string);
			for (int i = 0; i < n; i++)
				((xsd__string*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__string*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedByte"))
	{	cp->type = SOAP_TYPE_xsd__unsignedByte;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedByte;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__unsignedByte);
			((xsd__unsignedByte*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedByte[n];
			if (size)
				*size = n * sizeof(xsd__unsignedByte);
			for (int i = 0; i < n; i++)
				((xsd__unsignedByte*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedByte*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedInt"))
	{	cp->type = SOAP_TYPE_xsd__unsignedInt;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedInt;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__unsignedInt);
			((xsd__unsignedInt*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedInt[n];
			if (size)
				*size = n * sizeof(xsd__unsignedInt);
			for (int i = 0; i < n; i++)
				((xsd__unsignedInt*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedInt*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedLong"))
	{	cp->type = SOAP_TYPE_xsd__unsignedLong;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedLong;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__unsignedLong);
			((xsd__unsignedLong*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedLong[n];
			if (size)
				*size = n * sizeof(xsd__unsignedLong);
			for (int i = 0; i < n; i++)
				((xsd__unsignedLong*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedLong*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:unsignedShort"))
	{	cp->type = SOAP_TYPE_xsd__unsignedShort;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__unsignedShort;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__unsignedShort);
			((xsd__unsignedShort*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__unsignedShort[n];
			if (size)
				*size = n * sizeof(xsd__unsignedShort);
			for (int i = 0; i < n; i++)
				((xsd__unsignedShort*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__unsignedShort*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:serverState"))
	{	cp->type = SOAP_TYPE_s0__serverState_;
		if (n < 0)
		{	cp->ptr = (void*)new s0__serverState_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__serverState_);
			((s0__serverState_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__serverState_[n];
			if (size)
				*size = n * sizeof(s0__serverState_);
			for (int i = 0; i < n; i++)
				((s0__serverState_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__serverState_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:interfaceVersion"))
	{	cp->type = SOAP_TYPE_s0__interfaceVersion_;
		if (n < 0)
		{	cp->ptr = (void*)new s0__interfaceVersion_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__interfaceVersion_);
			((s0__interfaceVersion_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__interfaceVersion_[n];
			if (size)
				*size = n * sizeof(s0__interfaceVersion_);
			for (int i = 0; i < n; i++)
				((s0__interfaceVersion_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__interfaceVersion_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:qualityBits"))
	{	cp->type = SOAP_TYPE_s0__qualityBits_;
		if (n < 0)
		{	cp->ptr = (void*)new s0__qualityBits_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__qualityBits_);
			((s0__qualityBits_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__qualityBits_[n];
			if (size)
				*size = n * sizeof(s0__qualityBits_);
			for (int i = 0; i < n; i++)
				((s0__qualityBits_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__qualityBits_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:limitBits"))
	{	cp->type = SOAP_TYPE_s0__limitBits_;
		if (n < 0)
		{	cp->ptr = (void*)new s0__limitBits_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__limitBits_);
			((s0__limitBits_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__limitBits_[n];
			if (size)
				*size = n * sizeof(s0__limitBits_);
			for (int i = 0; i < n; i++)
				((s0__limitBits_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__limitBits_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:browseFilter"))
	{	cp->type = SOAP_TYPE_s0__browseFilter_;
		if (n < 0)
		{	cp->ptr = (void*)new s0__browseFilter_;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__browseFilter_);
			((s0__browseFilter_*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__browseFilter_[n];
			if (size)
				*size = n * sizeof(s0__browseFilter_);
			for (int i = 0; i < n; i++)
				((s0__browseFilter_*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__browseFilter_*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ReplyBase"))
	{	cp->type = SOAP_TYPE_s0__ReplyBase;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ReplyBase;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ReplyBase);
			((s0__ReplyBase*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ReplyBase[n];
			if (size)
				*size = n * sizeof(s0__ReplyBase);
			for (int i = 0; i < n; i++)
				((s0__ReplyBase*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ReplyBase*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ServerStatus"))
	{	cp->type = SOAP_TYPE_s0__ServerStatus;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ServerStatus;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ServerStatus);
			((s0__ServerStatus*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ServerStatus[n];
			if (size)
				*size = n * sizeof(s0__ServerStatus);
			for (int i = 0; i < n; i++)
				((s0__ServerStatus*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ServerStatus*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:RequestOptions"))
	{	cp->type = SOAP_TYPE_s0__RequestOptions;
		if (n < 0)
		{	cp->ptr = (void*)new s0__RequestOptions;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__RequestOptions);
			((s0__RequestOptions*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__RequestOptions[n];
			if (size)
				*size = n * sizeof(s0__RequestOptions);
			for (int i = 0; i < n; i++)
				((s0__RequestOptions*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__RequestOptions*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ReadRequestItemList"))
	{	cp->type = SOAP_TYPE_s0__ReadRequestItemList;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ReadRequestItemList;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ReadRequestItemList);
			((s0__ReadRequestItemList*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ReadRequestItemList[n];
			if (size)
				*size = n * sizeof(s0__ReadRequestItemList);
			for (int i = 0; i < n; i++)
				((s0__ReadRequestItemList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ReadRequestItemList*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ReadRequestItem"))
	{	cp->type = SOAP_TYPE_s0__ReadRequestItem;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ReadRequestItem;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ReadRequestItem);
			((s0__ReadRequestItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ReadRequestItem[n];
			if (size)
				*size = n * sizeof(s0__ReadRequestItem);
			for (int i = 0; i < n; i++)
				((s0__ReadRequestItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ReadRequestItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ReplyItemList"))
	{	cp->type = SOAP_TYPE_s0__ReplyItemList;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ReplyItemList;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ReplyItemList);
			((s0__ReplyItemList*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ReplyItemList[n];
			if (size)
				*size = n * sizeof(s0__ReplyItemList);
			for (int i = 0; i < n; i++)
				((s0__ReplyItemList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ReplyItemList*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ItemValue"))
	{	cp->type = SOAP_TYPE_s0__ItemValue;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ItemValue;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ItemValue);
			((s0__ItemValue*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ItemValue[n];
			if (size)
				*size = n * sizeof(s0__ItemValue);
			for (int i = 0; i < n; i++)
				((s0__ItemValue*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ItemValue*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:Value"))
	{	cp->type = SOAP_TYPE_s0__Value;
		if (n < 0)
		{	cp->ptr = (void*)new s0__Value;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__Value);
			((s0__Value*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__Value[n];
			if (size)
				*size = n * sizeof(s0__Value);
			for (int i = 0; i < n; i++)
				((s0__Value*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__Value*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:OPCQuality"))
	{	cp->type = SOAP_TYPE_s0__OPCQuality;
		if (n < 0)
		{	cp->ptr = (void*)new s0__OPCQuality;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__OPCQuality);
			((s0__OPCQuality*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__OPCQuality[n];
			if (size)
				*size = n * sizeof(s0__OPCQuality);
			for (int i = 0; i < n; i++)
				((s0__OPCQuality*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__OPCQuality*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:OPCError"))
	{	cp->type = SOAP_TYPE_s0__OPCError;
		if (n < 0)
		{	cp->ptr = (void*)new s0__OPCError;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__OPCError);
			((s0__OPCError*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__OPCError[n];
			if (size)
				*size = n * sizeof(s0__OPCError);
			for (int i = 0; i < n; i++)
				((s0__OPCError*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__OPCError*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ArrayOfFloat"))
	{	cp->type = SOAP_TYPE_s0__ArrayOfFloat;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ArrayOfFloat;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ArrayOfFloat);
			((s0__ArrayOfFloat*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ArrayOfFloat[n];
			if (size)
				*size = n * sizeof(s0__ArrayOfFloat);
			for (int i = 0; i < n; i++)
				((s0__ArrayOfFloat*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ArrayOfFloat*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ArrayOfInt"))
	{	cp->type = SOAP_TYPE_s0__ArrayOfInt;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ArrayOfInt;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ArrayOfInt);
			((s0__ArrayOfInt*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ArrayOfInt[n];
			if (size)
				*size = n * sizeof(s0__ArrayOfInt);
			for (int i = 0; i < n; i++)
				((s0__ArrayOfInt*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ArrayOfInt*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ArrayOfUnsignedInt"))
	{	cp->type = SOAP_TYPE_s0__ArrayOfUnsignedInt;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ArrayOfUnsignedInt;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ArrayOfUnsignedInt);
			((s0__ArrayOfUnsignedInt*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ArrayOfUnsignedInt[n];
			if (size)
				*size = n * sizeof(s0__ArrayOfUnsignedInt);
			for (int i = 0; i < n; i++)
				((s0__ArrayOfUnsignedInt*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ArrayOfUnsignedInt*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ArrayOfLong"))
	{	cp->type = SOAP_TYPE_s0__ArrayOfLong;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ArrayOfLong;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ArrayOfLong);
			((s0__ArrayOfLong*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ArrayOfLong[n];
			if (size)
				*size = n * sizeof(s0__ArrayOfLong);
			for (int i = 0; i < n; i++)
				((s0__ArrayOfLong*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ArrayOfLong*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ArrayOfUnsignedLong"))
	{	cp->type = SOAP_TYPE_s0__ArrayOfUnsignedLong;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ArrayOfUnsignedLong;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ArrayOfUnsignedLong);
			((s0__ArrayOfUnsignedLong*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ArrayOfUnsignedLong[n];
			if (size)
				*size = n * sizeof(s0__ArrayOfUnsignedLong);
			for (int i = 0; i < n; i++)
				((s0__ArrayOfUnsignedLong*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ArrayOfUnsignedLong*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ArrayOfDouble"))
	{	cp->type = SOAP_TYPE_s0__ArrayOfDouble;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ArrayOfDouble;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ArrayOfDouble);
			((s0__ArrayOfDouble*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ArrayOfDouble[n];
			if (size)
				*size = n * sizeof(s0__ArrayOfDouble);
			for (int i = 0; i < n; i++)
				((s0__ArrayOfDouble*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ArrayOfDouble*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ArrayOfUnsignedShort"))
	{	cp->type = SOAP_TYPE_s0__ArrayOfUnsignedShort;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ArrayOfUnsignedShort;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ArrayOfUnsignedShort);
			((s0__ArrayOfUnsignedShort*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ArrayOfUnsignedShort[n];
			if (size)
				*size = n * sizeof(s0__ArrayOfUnsignedShort);
			for (int i = 0; i < n; i++)
				((s0__ArrayOfUnsignedShort*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ArrayOfUnsignedShort*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ArrayOfBoolean"))
	{	cp->type = SOAP_TYPE_s0__ArrayOfBoolean;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ArrayOfBoolean;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ArrayOfBoolean);
			((s0__ArrayOfBoolean*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ArrayOfBoolean[n];
			if (size)
				*size = n * sizeof(s0__ArrayOfBoolean);
			for (int i = 0; i < n; i++)
				((s0__ArrayOfBoolean*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ArrayOfBoolean*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ArrayOfString"))
	{	cp->type = SOAP_TYPE_s0__ArrayOfString;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ArrayOfString;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ArrayOfString);
			((s0__ArrayOfString*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ArrayOfString[n];
			if (size)
				*size = n * sizeof(s0__ArrayOfString);
			for (int i = 0; i < n; i++)
				((s0__ArrayOfString*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ArrayOfString*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ArrayOfDateTime"))
	{	cp->type = SOAP_TYPE_s0__ArrayOfDateTime;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ArrayOfDateTime;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ArrayOfDateTime);
			((s0__ArrayOfDateTime*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ArrayOfDateTime[n];
			if (size)
				*size = n * sizeof(s0__ArrayOfDateTime);
			for (int i = 0; i < n; i++)
				((s0__ArrayOfDateTime*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ArrayOfDateTime*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ArrayOfAnyType"))
	{	cp->type = SOAP_TYPE_s0__ArrayOfAnyType;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ArrayOfAnyType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ArrayOfAnyType);
			((s0__ArrayOfAnyType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ArrayOfAnyType[n];
			if (size)
				*size = n * sizeof(s0__ArrayOfAnyType);
			for (int i = 0; i < n; i++)
				((s0__ArrayOfAnyType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ArrayOfAnyType*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ArrayOfDecimal"))
	{	cp->type = SOAP_TYPE_s0__ArrayOfDecimal;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ArrayOfDecimal;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ArrayOfDecimal);
			((s0__ArrayOfDecimal*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ArrayOfDecimal[n];
			if (size)
				*size = n * sizeof(s0__ArrayOfDecimal);
			for (int i = 0; i < n; i++)
				((s0__ArrayOfDecimal*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ArrayOfDecimal*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ArrayOfByte"))
	{	cp->type = SOAP_TYPE_s0__ArrayOfByte;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ArrayOfByte;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ArrayOfByte);
			((s0__ArrayOfByte*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ArrayOfByte[n];
			if (size)
				*size = n * sizeof(s0__ArrayOfByte);
			for (int i = 0; i < n; i++)
				((s0__ArrayOfByte*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ArrayOfByte*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ArrayOfShort"))
	{	cp->type = SOAP_TYPE_s0__ArrayOfShort;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ArrayOfShort;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ArrayOfShort);
			((s0__ArrayOfShort*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ArrayOfShort[n];
			if (size)
				*size = n * sizeof(s0__ArrayOfShort);
			for (int i = 0; i < n; i++)
				((s0__ArrayOfShort*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ArrayOfShort*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:WriteRequestItemList"))
	{	cp->type = SOAP_TYPE_s0__WriteRequestItemList;
		if (n < 0)
		{	cp->ptr = (void*)new s0__WriteRequestItemList;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__WriteRequestItemList);
			((s0__WriteRequestItemList*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__WriteRequestItemList[n];
			if (size)
				*size = n * sizeof(s0__WriteRequestItemList);
			for (int i = 0; i < n; i++)
				((s0__WriteRequestItemList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__WriteRequestItemList*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:SubscribeRequestItemList"))
	{	cp->type = SOAP_TYPE_s0__SubscribeRequestItemList;
		if (n < 0)
		{	cp->ptr = (void*)new s0__SubscribeRequestItemList;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__SubscribeRequestItemList);
			((s0__SubscribeRequestItemList*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__SubscribeRequestItemList[n];
			if (size)
				*size = n * sizeof(s0__SubscribeRequestItemList);
			for (int i = 0; i < n; i++)
				((s0__SubscribeRequestItemList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__SubscribeRequestItemList*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:SubscribeRequestItem"))
	{	cp->type = SOAP_TYPE_s0__SubscribeRequestItem;
		if (n < 0)
		{	cp->ptr = (void*)new s0__SubscribeRequestItem;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__SubscribeRequestItem);
			((s0__SubscribeRequestItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__SubscribeRequestItem[n];
			if (size)
				*size = n * sizeof(s0__SubscribeRequestItem);
			for (int i = 0; i < n; i++)
				((s0__SubscribeRequestItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__SubscribeRequestItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:SubscribeReplyItemList"))
	{	cp->type = SOAP_TYPE_s0__SubscribeReplyItemList;
		if (n < 0)
		{	cp->ptr = (void*)new s0__SubscribeReplyItemList;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__SubscribeReplyItemList);
			((s0__SubscribeReplyItemList*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__SubscribeReplyItemList[n];
			if (size)
				*size = n * sizeof(s0__SubscribeReplyItemList);
			for (int i = 0; i < n; i++)
				((s0__SubscribeReplyItemList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__SubscribeReplyItemList*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:SubscribeItemValue"))
	{	cp->type = SOAP_TYPE_s0__SubscribeItemValue;
		if (n < 0)
		{	cp->ptr = (void*)new s0__SubscribeItemValue;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__SubscribeItemValue);
			((s0__SubscribeItemValue*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__SubscribeItemValue[n];
			if (size)
				*size = n * sizeof(s0__SubscribeItemValue);
			for (int i = 0; i < n; i++)
				((s0__SubscribeItemValue*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__SubscribeItemValue*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:SubscribePolledRefreshReplyItemList"))
	{	cp->type = SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList;
		if (n < 0)
		{	cp->ptr = (void*)new s0__SubscribePolledRefreshReplyItemList;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__SubscribePolledRefreshReplyItemList);
			((s0__SubscribePolledRefreshReplyItemList*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__SubscribePolledRefreshReplyItemList[n];
			if (size)
				*size = n * sizeof(s0__SubscribePolledRefreshReplyItemList);
			for (int i = 0; i < n; i++)
				((s0__SubscribePolledRefreshReplyItemList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__SubscribePolledRefreshReplyItemList*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:BrowseElement"))
	{	cp->type = SOAP_TYPE_s0__BrowseElement;
		if (n < 0)
		{	cp->ptr = (void*)new s0__BrowseElement;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__BrowseElement);
			((s0__BrowseElement*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__BrowseElement[n];
			if (size)
				*size = n * sizeof(s0__BrowseElement);
			for (int i = 0; i < n; i++)
				((s0__BrowseElement*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__BrowseElement*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ItemProperty"))
	{	cp->type = SOAP_TYPE_s0__ItemProperty;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ItemProperty;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ItemProperty);
			((s0__ItemProperty*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ItemProperty[n];
			if (size)
				*size = n * sizeof(s0__ItemProperty);
			for (int i = 0; i < n; i++)
				((s0__ItemProperty*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ItemProperty*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:ItemIdentifier"))
	{	cp->type = SOAP_TYPE_s0__ItemIdentifier;
		if (n < 0)
		{	cp->ptr = (void*)new s0__ItemIdentifier;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__ItemIdentifier);
			((s0__ItemIdentifier*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__ItemIdentifier[n];
			if (size)
				*size = n * sizeof(s0__ItemIdentifier);
			for (int i = 0; i < n; i++)
				((s0__ItemIdentifier*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__ItemIdentifier*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "s0:PropertyReplyList"))
	{	cp->type = SOAP_TYPE_s0__PropertyReplyList;
		if (n < 0)
		{	cp->ptr = (void*)new s0__PropertyReplyList;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(s0__PropertyReplyList);
			((s0__PropertyReplyList*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new s0__PropertyReplyList[n];
			if (size)
				*size = n * sizeof(s0__PropertyReplyList);
			for (int i = 0; i < n; i++)
				((s0__PropertyReplyList*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (s0__PropertyReplyList*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__anyType;
		if (size)
			*size = sizeof(xsd__anyType);
		((xsd__anyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__anyType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__anyType);
		for (int i = 0; i < n; i++)
			((xsd__anyType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__anyType*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyType %p -> %p\n", q, p));
	*(xsd__anyType*)p = *(xsd__anyType*)q;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}
#ifdef __cplusplus
}
#endif

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type);
	soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}
#ifdef __cplusplus
}
#endif

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any, NULL);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}
#ifdef __cplusplus
}
#endif

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}
#ifdef __cplusplus
}
#endif

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}
#ifdef __cplusplus
}
#endif

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___s0__GetProperties(struct soap *soap, struct __s0__GetProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->s0__GetProperties = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___s0__GetProperties(struct soap *soap, const struct __s0__GetProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_s0__GetProperties(soap, &a->s0__GetProperties);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___s0__GetProperties(struct soap *soap, const struct __s0__GetProperties *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___s0__GetProperties(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___s0__GetProperties(struct soap *soap, const char *tag, int id, const struct __s0__GetProperties *a, const char *type)
{
	soap_out_PointerTo_s0__GetProperties(soap, "s0:GetProperties", -1, &a->s0__GetProperties, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __s0__GetProperties * SOAP_FMAC4 soap_get___s0__GetProperties(struct soap *soap, struct __s0__GetProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in___s0__GetProperties(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __s0__GetProperties * SOAP_FMAC4 soap_in___s0__GetProperties(struct soap *soap, const char *tag, struct __s0__GetProperties *a, const char *type)
{
	short soap_flag_s0__GetProperties = 1;
	int soap_flag;
	a = (struct __s0__GetProperties *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___s0__GetProperties, sizeof(struct __s0__GetProperties), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___s0__GetProperties(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_s0__GetProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_s0__GetProperties(soap, "s0:GetProperties", &a->s0__GetProperties, ""))
				{	soap_flag_s0__GetProperties--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __s0__GetProperties * SOAP_FMAC6 soap_new___s0__GetProperties(struct soap *soap, int n)
{	return soap_instantiate___s0__GetProperties(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___s0__GetProperties(struct soap *soap, struct __s0__GetProperties *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __s0__GetProperties * SOAP_FMAC4 soap_instantiate___s0__GetProperties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___s0__GetProperties(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___s0__GetProperties, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __s0__GetProperties;
		if (size)
			*size = sizeof(struct __s0__GetProperties);
	}
	else
	{	cp->ptr = (void*)new struct __s0__GetProperties[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __s0__GetProperties);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __s0__GetProperties*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___s0__GetProperties(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __s0__GetProperties %p -> %p\n", q, p));
	*(struct __s0__GetProperties*)p = *(struct __s0__GetProperties*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___s0__Browse(struct soap *soap, struct __s0__Browse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->s0__Browse = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___s0__Browse(struct soap *soap, const struct __s0__Browse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_s0__Browse(soap, &a->s0__Browse);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___s0__Browse(struct soap *soap, const struct __s0__Browse *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___s0__Browse(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___s0__Browse(struct soap *soap, const char *tag, int id, const struct __s0__Browse *a, const char *type)
{
	soap_out_PointerTo_s0__Browse(soap, "s0:Browse", -1, &a->s0__Browse, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __s0__Browse * SOAP_FMAC4 soap_get___s0__Browse(struct soap *soap, struct __s0__Browse *p, const char *tag, const char *type)
{
	if ((p = soap_in___s0__Browse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __s0__Browse * SOAP_FMAC4 soap_in___s0__Browse(struct soap *soap, const char *tag, struct __s0__Browse *a, const char *type)
{
	short soap_flag_s0__Browse = 1;
	int soap_flag;
	a = (struct __s0__Browse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___s0__Browse, sizeof(struct __s0__Browse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___s0__Browse(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_s0__Browse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_s0__Browse(soap, "s0:Browse", &a->s0__Browse, ""))
				{	soap_flag_s0__Browse--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __s0__Browse * SOAP_FMAC6 soap_new___s0__Browse(struct soap *soap, int n)
{	return soap_instantiate___s0__Browse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___s0__Browse(struct soap *soap, struct __s0__Browse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __s0__Browse * SOAP_FMAC4 soap_instantiate___s0__Browse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___s0__Browse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___s0__Browse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __s0__Browse;
		if (size)
			*size = sizeof(struct __s0__Browse);
	}
	else
	{	cp->ptr = (void*)new struct __s0__Browse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __s0__Browse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __s0__Browse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___s0__Browse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __s0__Browse %p -> %p\n", q, p));
	*(struct __s0__Browse*)p = *(struct __s0__Browse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___s0__SubscriptionCancel(struct soap *soap, struct __s0__SubscriptionCancel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->s0__SubscriptionCancel = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___s0__SubscriptionCancel(struct soap *soap, const struct __s0__SubscriptionCancel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_s0__SubscriptionCancel(soap, &a->s0__SubscriptionCancel);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___s0__SubscriptionCancel(struct soap *soap, const struct __s0__SubscriptionCancel *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___s0__SubscriptionCancel(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___s0__SubscriptionCancel(struct soap *soap, const char *tag, int id, const struct __s0__SubscriptionCancel *a, const char *type)
{
	soap_out_PointerTo_s0__SubscriptionCancel(soap, "s0:SubscriptionCancel", -1, &a->s0__SubscriptionCancel, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __s0__SubscriptionCancel * SOAP_FMAC4 soap_get___s0__SubscriptionCancel(struct soap *soap, struct __s0__SubscriptionCancel *p, const char *tag, const char *type)
{
	if ((p = soap_in___s0__SubscriptionCancel(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __s0__SubscriptionCancel * SOAP_FMAC4 soap_in___s0__SubscriptionCancel(struct soap *soap, const char *tag, struct __s0__SubscriptionCancel *a, const char *type)
{
	short soap_flag_s0__SubscriptionCancel = 1;
	int soap_flag;
	a = (struct __s0__SubscriptionCancel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___s0__SubscriptionCancel, sizeof(struct __s0__SubscriptionCancel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___s0__SubscriptionCancel(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_s0__SubscriptionCancel && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_s0__SubscriptionCancel(soap, "s0:SubscriptionCancel", &a->s0__SubscriptionCancel, ""))
				{	soap_flag_s0__SubscriptionCancel--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __s0__SubscriptionCancel * SOAP_FMAC6 soap_new___s0__SubscriptionCancel(struct soap *soap, int n)
{	return soap_instantiate___s0__SubscriptionCancel(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___s0__SubscriptionCancel(struct soap *soap, struct __s0__SubscriptionCancel *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __s0__SubscriptionCancel * SOAP_FMAC4 soap_instantiate___s0__SubscriptionCancel(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___s0__SubscriptionCancel(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___s0__SubscriptionCancel, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __s0__SubscriptionCancel;
		if (size)
			*size = sizeof(struct __s0__SubscriptionCancel);
	}
	else
	{	cp->ptr = (void*)new struct __s0__SubscriptionCancel[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __s0__SubscriptionCancel);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __s0__SubscriptionCancel*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___s0__SubscriptionCancel(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __s0__SubscriptionCancel %p -> %p\n", q, p));
	*(struct __s0__SubscriptionCancel*)p = *(struct __s0__SubscriptionCancel*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___s0__SubscriptionPolledRefresh(struct soap *soap, struct __s0__SubscriptionPolledRefresh *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->s0__SubscriptionPolledRefresh = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___s0__SubscriptionPolledRefresh(struct soap *soap, const struct __s0__SubscriptionPolledRefresh *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_s0__SubscriptionPolledRefresh(soap, &a->s0__SubscriptionPolledRefresh);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___s0__SubscriptionPolledRefresh(struct soap *soap, const struct __s0__SubscriptionPolledRefresh *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___s0__SubscriptionPolledRefresh(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___s0__SubscriptionPolledRefresh(struct soap *soap, const char *tag, int id, const struct __s0__SubscriptionPolledRefresh *a, const char *type)
{
	soap_out_PointerTo_s0__SubscriptionPolledRefresh(soap, "s0:SubscriptionPolledRefresh", -1, &a->s0__SubscriptionPolledRefresh, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __s0__SubscriptionPolledRefresh * SOAP_FMAC4 soap_get___s0__SubscriptionPolledRefresh(struct soap *soap, struct __s0__SubscriptionPolledRefresh *p, const char *tag, const char *type)
{
	if ((p = soap_in___s0__SubscriptionPolledRefresh(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __s0__SubscriptionPolledRefresh * SOAP_FMAC4 soap_in___s0__SubscriptionPolledRefresh(struct soap *soap, const char *tag, struct __s0__SubscriptionPolledRefresh *a, const char *type)
{
	short soap_flag_s0__SubscriptionPolledRefresh = 1;
	int soap_flag;
	a = (struct __s0__SubscriptionPolledRefresh *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___s0__SubscriptionPolledRefresh, sizeof(struct __s0__SubscriptionPolledRefresh), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___s0__SubscriptionPolledRefresh(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_s0__SubscriptionPolledRefresh && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_s0__SubscriptionPolledRefresh(soap, "s0:SubscriptionPolledRefresh", &a->s0__SubscriptionPolledRefresh, ""))
				{	soap_flag_s0__SubscriptionPolledRefresh--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __s0__SubscriptionPolledRefresh * SOAP_FMAC6 soap_new___s0__SubscriptionPolledRefresh(struct soap *soap, int n)
{	return soap_instantiate___s0__SubscriptionPolledRefresh(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___s0__SubscriptionPolledRefresh(struct soap *soap, struct __s0__SubscriptionPolledRefresh *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __s0__SubscriptionPolledRefresh * SOAP_FMAC4 soap_instantiate___s0__SubscriptionPolledRefresh(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___s0__SubscriptionPolledRefresh(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___s0__SubscriptionPolledRefresh, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __s0__SubscriptionPolledRefresh;
		if (size)
			*size = sizeof(struct __s0__SubscriptionPolledRefresh);
	}
	else
	{	cp->ptr = (void*)new struct __s0__SubscriptionPolledRefresh[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __s0__SubscriptionPolledRefresh);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __s0__SubscriptionPolledRefresh*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___s0__SubscriptionPolledRefresh(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __s0__SubscriptionPolledRefresh %p -> %p\n", q, p));
	*(struct __s0__SubscriptionPolledRefresh*)p = *(struct __s0__SubscriptionPolledRefresh*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___s0__Subscribe(struct soap *soap, struct __s0__Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->s0__Subscribe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___s0__Subscribe(struct soap *soap, const struct __s0__Subscribe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_s0__Subscribe(soap, &a->s0__Subscribe);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___s0__Subscribe(struct soap *soap, const struct __s0__Subscribe *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___s0__Subscribe(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___s0__Subscribe(struct soap *soap, const char *tag, int id, const struct __s0__Subscribe *a, const char *type)
{
	soap_out_PointerTo_s0__Subscribe(soap, "s0:Subscribe", -1, &a->s0__Subscribe, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __s0__Subscribe * SOAP_FMAC4 soap_get___s0__Subscribe(struct soap *soap, struct __s0__Subscribe *p, const char *tag, const char *type)
{
	if ((p = soap_in___s0__Subscribe(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __s0__Subscribe * SOAP_FMAC4 soap_in___s0__Subscribe(struct soap *soap, const char *tag, struct __s0__Subscribe *a, const char *type)
{
	short soap_flag_s0__Subscribe = 1;
	int soap_flag;
	a = (struct __s0__Subscribe *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___s0__Subscribe, sizeof(struct __s0__Subscribe), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___s0__Subscribe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_s0__Subscribe && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_s0__Subscribe(soap, "s0:Subscribe", &a->s0__Subscribe, ""))
				{	soap_flag_s0__Subscribe--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __s0__Subscribe * SOAP_FMAC6 soap_new___s0__Subscribe(struct soap *soap, int n)
{	return soap_instantiate___s0__Subscribe(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___s0__Subscribe(struct soap *soap, struct __s0__Subscribe *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __s0__Subscribe * SOAP_FMAC4 soap_instantiate___s0__Subscribe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___s0__Subscribe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___s0__Subscribe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __s0__Subscribe;
		if (size)
			*size = sizeof(struct __s0__Subscribe);
	}
	else
	{	cp->ptr = (void*)new struct __s0__Subscribe[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __s0__Subscribe);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __s0__Subscribe*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___s0__Subscribe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __s0__Subscribe %p -> %p\n", q, p));
	*(struct __s0__Subscribe*)p = *(struct __s0__Subscribe*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___s0__Write(struct soap *soap, struct __s0__Write *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->s0__Write = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___s0__Write(struct soap *soap, const struct __s0__Write *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_s0__Write(soap, &a->s0__Write);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___s0__Write(struct soap *soap, const struct __s0__Write *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___s0__Write(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___s0__Write(struct soap *soap, const char *tag, int id, const struct __s0__Write *a, const char *type)
{
	soap_out_PointerTo_s0__Write(soap, "s0:Write", -1, &a->s0__Write, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __s0__Write * SOAP_FMAC4 soap_get___s0__Write(struct soap *soap, struct __s0__Write *p, const char *tag, const char *type)
{
	if ((p = soap_in___s0__Write(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __s0__Write * SOAP_FMAC4 soap_in___s0__Write(struct soap *soap, const char *tag, struct __s0__Write *a, const char *type)
{
	short soap_flag_s0__Write = 1;
	int soap_flag;
	a = (struct __s0__Write *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___s0__Write, sizeof(struct __s0__Write), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___s0__Write(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_s0__Write && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_s0__Write(soap, "s0:Write", &a->s0__Write, ""))
				{	soap_flag_s0__Write--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __s0__Write * SOAP_FMAC6 soap_new___s0__Write(struct soap *soap, int n)
{	return soap_instantiate___s0__Write(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___s0__Write(struct soap *soap, struct __s0__Write *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __s0__Write * SOAP_FMAC4 soap_instantiate___s0__Write(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___s0__Write(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___s0__Write, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __s0__Write;
		if (size)
			*size = sizeof(struct __s0__Write);
	}
	else
	{	cp->ptr = (void*)new struct __s0__Write[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __s0__Write);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __s0__Write*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___s0__Write(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __s0__Write %p -> %p\n", q, p));
	*(struct __s0__Write*)p = *(struct __s0__Write*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___s0__Read(struct soap *soap, struct __s0__Read *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->s0__Read = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___s0__Read(struct soap *soap, const struct __s0__Read *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_s0__Read(soap, &a->s0__Read);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___s0__Read(struct soap *soap, const struct __s0__Read *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___s0__Read(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___s0__Read(struct soap *soap, const char *tag, int id, const struct __s0__Read *a, const char *type)
{
	soap_out_PointerTo_s0__Read(soap, "s0:Read", -1, &a->s0__Read, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __s0__Read * SOAP_FMAC4 soap_get___s0__Read(struct soap *soap, struct __s0__Read *p, const char *tag, const char *type)
{
	if ((p = soap_in___s0__Read(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __s0__Read * SOAP_FMAC4 soap_in___s0__Read(struct soap *soap, const char *tag, struct __s0__Read *a, const char *type)
{
	short soap_flag_s0__Read = 1;
	int soap_flag;
	a = (struct __s0__Read *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___s0__Read, sizeof(struct __s0__Read), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___s0__Read(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_s0__Read && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_s0__Read(soap, "s0:Read", &a->s0__Read, ""))
				{	soap_flag_s0__Read--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __s0__Read * SOAP_FMAC6 soap_new___s0__Read(struct soap *soap, int n)
{	return soap_instantiate___s0__Read(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___s0__Read(struct soap *soap, struct __s0__Read *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __s0__Read * SOAP_FMAC4 soap_instantiate___s0__Read(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___s0__Read(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___s0__Read, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __s0__Read;
		if (size)
			*size = sizeof(struct __s0__Read);
	}
	else
	{	cp->ptr = (void*)new struct __s0__Read[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __s0__Read);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __s0__Read*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___s0__Read(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __s0__Read %p -> %p\n", q, p));
	*(struct __s0__Read*)p = *(struct __s0__Read*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___s0__GetStatus(struct soap *soap, struct __s0__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->s0__GetStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___s0__GetStatus(struct soap *soap, const struct __s0__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_s0__GetStatus(soap, &a->s0__GetStatus);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___s0__GetStatus(struct soap *soap, const struct __s0__GetStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___s0__GetStatus(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___s0__GetStatus(struct soap *soap, const char *tag, int id, const struct __s0__GetStatus *a, const char *type)
{
	soap_out_PointerTo_s0__GetStatus(soap, "s0:GetStatus", -1, &a->s0__GetStatus, "");
	return SOAP_OK;
}

SOAP_FMAC3 struct __s0__GetStatus * SOAP_FMAC4 soap_get___s0__GetStatus(struct soap *soap, struct __s0__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___s0__GetStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct __s0__GetStatus * SOAP_FMAC4 soap_in___s0__GetStatus(struct soap *soap, const char *tag, struct __s0__GetStatus *a, const char *type)
{
	short soap_flag_s0__GetStatus = 1;
	int soap_flag;
	a = (struct __s0__GetStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE___s0__GetStatus, sizeof(struct __s0__GetStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___s0__GetStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_s0__GetStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_s0__GetStatus(soap, "s0:GetStatus", &a->s0__GetStatus, ""))
				{	soap_flag_s0__GetStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __s0__GetStatus * SOAP_FMAC6 soap_new___s0__GetStatus(struct soap *soap, int n)
{	return soap_instantiate___s0__GetStatus(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___s0__GetStatus(struct soap *soap, struct __s0__GetStatus *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __s0__GetStatus * SOAP_FMAC4 soap_instantiate___s0__GetStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___s0__GetStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___s0__GetStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __s0__GetStatus;
		if (size)
			*size = sizeof(struct __s0__GetStatus);
	}
	else
	{	cp->ptr = (void*)new struct __s0__GetStatus[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __s0__GetStatus);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __s0__GetStatus*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___s0__GetStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __s0__GetStatus %p -> %p\n", q, p));
	*(struct __s0__GetStatus*)p = *(struct __s0__GetStatus*)q;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__GetPropertiesResponse(struct soap *soap, _s0__GetPropertiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__s0__GetPropertiesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__GetPropertiesResponse(struct soap *soap, _s0__GetPropertiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__GetPropertiesResponse);
	if (soap_out_PointerTo_s0__GetPropertiesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__GetPropertiesResponse(struct soap *soap, const char *tag, int id, _s0__GetPropertiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__GetPropertiesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__GetPropertiesResponse ** SOAP_FMAC4 soap_get_PointerTo_s0__GetPropertiesResponse(struct soap *soap, _s0__GetPropertiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_s0__GetPropertiesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _s0__GetPropertiesResponse ** SOAP_FMAC4 soap_in_PointerTo_s0__GetPropertiesResponse(struct soap *soap, const char *tag, _s0__GetPropertiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_s0__GetPropertiesResponse **)soap_malloc(soap, sizeof(_s0__GetPropertiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_s0__GetPropertiesResponse *)soap_instantiate__s0__GetPropertiesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_s0__GetPropertiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__s0__GetPropertiesResponse, sizeof(_s0__GetPropertiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__GetProperties(struct soap *soap, _s0__GetProperties *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__s0__GetProperties))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__GetProperties(struct soap *soap, _s0__GetProperties *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__GetProperties);
	if (soap_out_PointerTo_s0__GetProperties(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__GetProperties(struct soap *soap, const char *tag, int id, _s0__GetProperties *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__GetProperties);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__GetProperties ** SOAP_FMAC4 soap_get_PointerTo_s0__GetProperties(struct soap *soap, _s0__GetProperties **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_s0__GetProperties(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _s0__GetProperties ** SOAP_FMAC4 soap_in_PointerTo_s0__GetProperties(struct soap *soap, const char *tag, _s0__GetProperties **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_s0__GetProperties **)soap_malloc(soap, sizeof(_s0__GetProperties *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_s0__GetProperties *)soap_instantiate__s0__GetProperties(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_s0__GetProperties **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__s0__GetProperties, sizeof(_s0__GetProperties), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__BrowseResponse(struct soap *soap, _s0__BrowseResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__s0__BrowseResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__BrowseResponse(struct soap *soap, _s0__BrowseResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__BrowseResponse);
	if (soap_out_PointerTo_s0__BrowseResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__BrowseResponse(struct soap *soap, const char *tag, int id, _s0__BrowseResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__BrowseResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__BrowseResponse ** SOAP_FMAC4 soap_get_PointerTo_s0__BrowseResponse(struct soap *soap, _s0__BrowseResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_s0__BrowseResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _s0__BrowseResponse ** SOAP_FMAC4 soap_in_PointerTo_s0__BrowseResponse(struct soap *soap, const char *tag, _s0__BrowseResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_s0__BrowseResponse **)soap_malloc(soap, sizeof(_s0__BrowseResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_s0__BrowseResponse *)soap_instantiate__s0__BrowseResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_s0__BrowseResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__s0__BrowseResponse, sizeof(_s0__BrowseResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__Browse(struct soap *soap, _s0__Browse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__s0__Browse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__Browse(struct soap *soap, _s0__Browse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__Browse);
	if (soap_out_PointerTo_s0__Browse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__Browse(struct soap *soap, const char *tag, int id, _s0__Browse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__Browse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__Browse ** SOAP_FMAC4 soap_get_PointerTo_s0__Browse(struct soap *soap, _s0__Browse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_s0__Browse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _s0__Browse ** SOAP_FMAC4 soap_in_PointerTo_s0__Browse(struct soap *soap, const char *tag, _s0__Browse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_s0__Browse **)soap_malloc(soap, sizeof(_s0__Browse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_s0__Browse *)soap_instantiate__s0__Browse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_s0__Browse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__s0__Browse, sizeof(_s0__Browse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__SubscriptionCancelResponse(struct soap *soap, _s0__SubscriptionCancelResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__s0__SubscriptionCancelResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__SubscriptionCancelResponse(struct soap *soap, _s0__SubscriptionCancelResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__SubscriptionCancelResponse);
	if (soap_out_PointerTo_s0__SubscriptionCancelResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__SubscriptionCancelResponse(struct soap *soap, const char *tag, int id, _s0__SubscriptionCancelResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__SubscriptionCancelResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__SubscriptionCancelResponse ** SOAP_FMAC4 soap_get_PointerTo_s0__SubscriptionCancelResponse(struct soap *soap, _s0__SubscriptionCancelResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_s0__SubscriptionCancelResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _s0__SubscriptionCancelResponse ** SOAP_FMAC4 soap_in_PointerTo_s0__SubscriptionCancelResponse(struct soap *soap, const char *tag, _s0__SubscriptionCancelResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_s0__SubscriptionCancelResponse **)soap_malloc(soap, sizeof(_s0__SubscriptionCancelResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_s0__SubscriptionCancelResponse *)soap_instantiate__s0__SubscriptionCancelResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_s0__SubscriptionCancelResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__s0__SubscriptionCancelResponse, sizeof(_s0__SubscriptionCancelResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__SubscriptionCancel(struct soap *soap, _s0__SubscriptionCancel *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__s0__SubscriptionCancel))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__SubscriptionCancel(struct soap *soap, _s0__SubscriptionCancel *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__SubscriptionCancel);
	if (soap_out_PointerTo_s0__SubscriptionCancel(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__SubscriptionCancel(struct soap *soap, const char *tag, int id, _s0__SubscriptionCancel *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__SubscriptionCancel);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__SubscriptionCancel ** SOAP_FMAC4 soap_get_PointerTo_s0__SubscriptionCancel(struct soap *soap, _s0__SubscriptionCancel **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_s0__SubscriptionCancel(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _s0__SubscriptionCancel ** SOAP_FMAC4 soap_in_PointerTo_s0__SubscriptionCancel(struct soap *soap, const char *tag, _s0__SubscriptionCancel **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_s0__SubscriptionCancel **)soap_malloc(soap, sizeof(_s0__SubscriptionCancel *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_s0__SubscriptionCancel *)soap_instantiate__s0__SubscriptionCancel(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_s0__SubscriptionCancel **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__s0__SubscriptionCancel, sizeof(_s0__SubscriptionCancel), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__SubscriptionPolledRefreshResponse(struct soap *soap, _s0__SubscriptionPolledRefreshResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__s0__SubscriptionPolledRefreshResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__SubscriptionPolledRefreshResponse(struct soap *soap, _s0__SubscriptionPolledRefreshResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__SubscriptionPolledRefreshResponse);
	if (soap_out_PointerTo_s0__SubscriptionPolledRefreshResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__SubscriptionPolledRefreshResponse(struct soap *soap, const char *tag, int id, _s0__SubscriptionPolledRefreshResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__SubscriptionPolledRefreshResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__SubscriptionPolledRefreshResponse ** SOAP_FMAC4 soap_get_PointerTo_s0__SubscriptionPolledRefreshResponse(struct soap *soap, _s0__SubscriptionPolledRefreshResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_s0__SubscriptionPolledRefreshResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _s0__SubscriptionPolledRefreshResponse ** SOAP_FMAC4 soap_in_PointerTo_s0__SubscriptionPolledRefreshResponse(struct soap *soap, const char *tag, _s0__SubscriptionPolledRefreshResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_s0__SubscriptionPolledRefreshResponse **)soap_malloc(soap, sizeof(_s0__SubscriptionPolledRefreshResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_s0__SubscriptionPolledRefreshResponse *)soap_instantiate__s0__SubscriptionPolledRefreshResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_s0__SubscriptionPolledRefreshResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__s0__SubscriptionPolledRefreshResponse, sizeof(_s0__SubscriptionPolledRefreshResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__SubscriptionPolledRefresh(struct soap *soap, _s0__SubscriptionPolledRefresh *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__s0__SubscriptionPolledRefresh))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__SubscriptionPolledRefresh(struct soap *soap, _s0__SubscriptionPolledRefresh *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__SubscriptionPolledRefresh);
	if (soap_out_PointerTo_s0__SubscriptionPolledRefresh(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__SubscriptionPolledRefresh(struct soap *soap, const char *tag, int id, _s0__SubscriptionPolledRefresh *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__SubscriptionPolledRefresh);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__SubscriptionPolledRefresh ** SOAP_FMAC4 soap_get_PointerTo_s0__SubscriptionPolledRefresh(struct soap *soap, _s0__SubscriptionPolledRefresh **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_s0__SubscriptionPolledRefresh(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _s0__SubscriptionPolledRefresh ** SOAP_FMAC4 soap_in_PointerTo_s0__SubscriptionPolledRefresh(struct soap *soap, const char *tag, _s0__SubscriptionPolledRefresh **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_s0__SubscriptionPolledRefresh **)soap_malloc(soap, sizeof(_s0__SubscriptionPolledRefresh *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_s0__SubscriptionPolledRefresh *)soap_instantiate__s0__SubscriptionPolledRefresh(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_s0__SubscriptionPolledRefresh **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__s0__SubscriptionPolledRefresh, sizeof(_s0__SubscriptionPolledRefresh), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__SubscribeResponse(struct soap *soap, _s0__SubscribeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__s0__SubscribeResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__SubscribeResponse(struct soap *soap, _s0__SubscribeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__SubscribeResponse);
	if (soap_out_PointerTo_s0__SubscribeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__SubscribeResponse(struct soap *soap, const char *tag, int id, _s0__SubscribeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__SubscribeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__SubscribeResponse ** SOAP_FMAC4 soap_get_PointerTo_s0__SubscribeResponse(struct soap *soap, _s0__SubscribeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_s0__SubscribeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _s0__SubscribeResponse ** SOAP_FMAC4 soap_in_PointerTo_s0__SubscribeResponse(struct soap *soap, const char *tag, _s0__SubscribeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_s0__SubscribeResponse **)soap_malloc(soap, sizeof(_s0__SubscribeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_s0__SubscribeResponse *)soap_instantiate__s0__SubscribeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_s0__SubscribeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__s0__SubscribeResponse, sizeof(_s0__SubscribeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__Subscribe(struct soap *soap, _s0__Subscribe *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__s0__Subscribe))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__Subscribe(struct soap *soap, _s0__Subscribe *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__Subscribe);
	if (soap_out_PointerTo_s0__Subscribe(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__Subscribe(struct soap *soap, const char *tag, int id, _s0__Subscribe *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__Subscribe);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__Subscribe ** SOAP_FMAC4 soap_get_PointerTo_s0__Subscribe(struct soap *soap, _s0__Subscribe **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_s0__Subscribe(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _s0__Subscribe ** SOAP_FMAC4 soap_in_PointerTo_s0__Subscribe(struct soap *soap, const char *tag, _s0__Subscribe **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_s0__Subscribe **)soap_malloc(soap, sizeof(_s0__Subscribe *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_s0__Subscribe *)soap_instantiate__s0__Subscribe(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_s0__Subscribe **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__s0__Subscribe, sizeof(_s0__Subscribe), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__WriteResponse(struct soap *soap, _s0__WriteResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__s0__WriteResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__WriteResponse(struct soap *soap, _s0__WriteResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__WriteResponse);
	if (soap_out_PointerTo_s0__WriteResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__WriteResponse(struct soap *soap, const char *tag, int id, _s0__WriteResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__WriteResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__WriteResponse ** SOAP_FMAC4 soap_get_PointerTo_s0__WriteResponse(struct soap *soap, _s0__WriteResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_s0__WriteResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _s0__WriteResponse ** SOAP_FMAC4 soap_in_PointerTo_s0__WriteResponse(struct soap *soap, const char *tag, _s0__WriteResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_s0__WriteResponse **)soap_malloc(soap, sizeof(_s0__WriteResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_s0__WriteResponse *)soap_instantiate__s0__WriteResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_s0__WriteResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__s0__WriteResponse, sizeof(_s0__WriteResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__Write(struct soap *soap, _s0__Write *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__s0__Write))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__Write(struct soap *soap, _s0__Write *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__Write);
	if (soap_out_PointerTo_s0__Write(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__Write(struct soap *soap, const char *tag, int id, _s0__Write *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__Write);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__Write ** SOAP_FMAC4 soap_get_PointerTo_s0__Write(struct soap *soap, _s0__Write **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_s0__Write(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _s0__Write ** SOAP_FMAC4 soap_in_PointerTo_s0__Write(struct soap *soap, const char *tag, _s0__Write **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_s0__Write **)soap_malloc(soap, sizeof(_s0__Write *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_s0__Write *)soap_instantiate__s0__Write(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_s0__Write **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__s0__Write, sizeof(_s0__Write), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__ReadResponse(struct soap *soap, _s0__ReadResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__s0__ReadResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__ReadResponse(struct soap *soap, _s0__ReadResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__ReadResponse);
	if (soap_out_PointerTo_s0__ReadResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__ReadResponse(struct soap *soap, const char *tag, int id, _s0__ReadResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__ReadResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__ReadResponse ** SOAP_FMAC4 soap_get_PointerTo_s0__ReadResponse(struct soap *soap, _s0__ReadResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_s0__ReadResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _s0__ReadResponse ** SOAP_FMAC4 soap_in_PointerTo_s0__ReadResponse(struct soap *soap, const char *tag, _s0__ReadResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_s0__ReadResponse **)soap_malloc(soap, sizeof(_s0__ReadResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_s0__ReadResponse *)soap_instantiate__s0__ReadResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_s0__ReadResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__s0__ReadResponse, sizeof(_s0__ReadResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__Read(struct soap *soap, _s0__Read *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__s0__Read))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__Read(struct soap *soap, _s0__Read *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__Read);
	if (soap_out_PointerTo_s0__Read(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__Read(struct soap *soap, const char *tag, int id, _s0__Read *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__Read);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__Read ** SOAP_FMAC4 soap_get_PointerTo_s0__Read(struct soap *soap, _s0__Read **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_s0__Read(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _s0__Read ** SOAP_FMAC4 soap_in_PointerTo_s0__Read(struct soap *soap, const char *tag, _s0__Read **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_s0__Read **)soap_malloc(soap, sizeof(_s0__Read *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_s0__Read *)soap_instantiate__s0__Read(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_s0__Read **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__s0__Read, sizeof(_s0__Read), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__GetStatusResponse(struct soap *soap, _s0__GetStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__s0__GetStatusResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__GetStatusResponse(struct soap *soap, _s0__GetStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__GetStatusResponse);
	if (soap_out_PointerTo_s0__GetStatusResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__GetStatusResponse(struct soap *soap, const char *tag, int id, _s0__GetStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__GetStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__GetStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_s0__GetStatusResponse(struct soap *soap, _s0__GetStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_s0__GetStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _s0__GetStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_s0__GetStatusResponse(struct soap *soap, const char *tag, _s0__GetStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_s0__GetStatusResponse **)soap_malloc(soap, sizeof(_s0__GetStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_s0__GetStatusResponse *)soap_instantiate__s0__GetStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_s0__GetStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__s0__GetStatusResponse, sizeof(_s0__GetStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_s0__GetStatus(struct soap *soap, _s0__GetStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__s0__GetStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_s0__GetStatus(struct soap *soap, _s0__GetStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_s0__GetStatus);
	if (soap_out_PointerTo_s0__GetStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_s0__GetStatus(struct soap *soap, const char *tag, int id, _s0__GetStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__s0__GetStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _s0__GetStatus ** SOAP_FMAC4 soap_get_PointerTo_s0__GetStatus(struct soap *soap, _s0__GetStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_s0__GetStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 _s0__GetStatus ** SOAP_FMAC4 soap_in_PointerTo_s0__GetStatus(struct soap *soap, const char *tag, _s0__GetStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_s0__GetStatus **)soap_malloc(soap, sizeof(_s0__GetStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_s0__GetStatus *)soap_instantiate__s0__GetStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (_s0__GetStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__s0__GetStatus, sizeof(_s0__GetStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__PropertyReplyList(struct soap *soap, s0__PropertyReplyList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_s0__PropertyReplyList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__PropertyReplyList(struct soap *soap, s0__PropertyReplyList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__PropertyReplyList);
	if (soap_out_PointerTos0__PropertyReplyList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__PropertyReplyList(struct soap *soap, const char *tag, int id, s0__PropertyReplyList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__PropertyReplyList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__PropertyReplyList ** SOAP_FMAC4 soap_get_PointerTos0__PropertyReplyList(struct soap *soap, s0__PropertyReplyList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__PropertyReplyList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 s0__PropertyReplyList ** SOAP_FMAC4 soap_in_PointerTos0__PropertyReplyList(struct soap *soap, const char *tag, s0__PropertyReplyList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (s0__PropertyReplyList **)soap_malloc(soap, sizeof(s0__PropertyReplyList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (s0__PropertyReplyList *)soap_instantiate_s0__PropertyReplyList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (s0__PropertyReplyList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__PropertyReplyList, sizeof(s0__PropertyReplyList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__ItemIdentifier(struct soap *soap, s0__ItemIdentifier *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_s0__ItemIdentifier))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__ItemIdentifier(struct soap *soap, s0__ItemIdentifier *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__ItemIdentifier);
	if (soap_out_PointerTos0__ItemIdentifier(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__ItemIdentifier(struct soap *soap, const char *tag, int id, s0__ItemIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__ItemIdentifier);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__ItemIdentifier ** SOAP_FMAC4 soap_get_PointerTos0__ItemIdentifier(struct soap *soap, s0__ItemIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__ItemIdentifier(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 s0__ItemIdentifier ** SOAP_FMAC4 soap_in_PointerTos0__ItemIdentifier(struct soap *soap, const char *tag, s0__ItemIdentifier **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (s0__ItemIdentifier **)soap_malloc(soap, sizeof(s0__ItemIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (s0__ItemIdentifier *)soap_instantiate_s0__ItemIdentifier(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (s0__ItemIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__ItemIdentifier, sizeof(s0__ItemIdentifier), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__BrowseElement(struct soap *soap, s0__BrowseElement *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_s0__BrowseElement))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__BrowseElement(struct soap *soap, s0__BrowseElement *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__BrowseElement);
	if (soap_out_PointerTos0__BrowseElement(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__BrowseElement(struct soap *soap, const char *tag, int id, s0__BrowseElement *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__BrowseElement);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__BrowseElement ** SOAP_FMAC4 soap_get_PointerTos0__BrowseElement(struct soap *soap, s0__BrowseElement **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__BrowseElement(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 s0__BrowseElement ** SOAP_FMAC4 soap_in_PointerTos0__BrowseElement(struct soap *soap, const char *tag, s0__BrowseElement **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (s0__BrowseElement **)soap_malloc(soap, sizeof(s0__BrowseElement *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (s0__BrowseElement *)soap_instantiate_s0__BrowseElement(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (s0__BrowseElement **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__BrowseElement, sizeof(s0__BrowseElement), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__browseFilter(struct soap *soap, enum s0__browseFilter *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_s0__browseFilter);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__browseFilter(struct soap *soap, enum s0__browseFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__browseFilter);
	if (soap_out_PointerTos0__browseFilter(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__browseFilter(struct soap *soap, const char *tag, int id, enum s0__browseFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__browseFilter);
	if (id < 0)
		return soap->error;
	return soap_out_s0__browseFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum s0__browseFilter ** SOAP_FMAC4 soap_get_PointerTos0__browseFilter(struct soap *soap, enum s0__browseFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__browseFilter(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum s0__browseFilter ** SOAP_FMAC4 soap_in_PointerTos0__browseFilter(struct soap *soap, const char *tag, enum s0__browseFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum s0__browseFilter **)soap_malloc(soap, sizeof(enum s0__browseFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_s0__browseFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum s0__browseFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__browseFilter, sizeof(enum s0__browseFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__SubscribePolledRefreshReplyItemList(struct soap *soap, s0__SubscribePolledRefreshReplyItemList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__SubscribePolledRefreshReplyItemList(struct soap *soap, s0__SubscribePolledRefreshReplyItemList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__SubscribePolledRefreshReplyItemList);
	if (soap_out_PointerTos0__SubscribePolledRefreshReplyItemList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__SubscribePolledRefreshReplyItemList(struct soap *soap, const char *tag, int id, s0__SubscribePolledRefreshReplyItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__SubscribePolledRefreshReplyItemList ** SOAP_FMAC4 soap_get_PointerTos0__SubscribePolledRefreshReplyItemList(struct soap *soap, s0__SubscribePolledRefreshReplyItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__SubscribePolledRefreshReplyItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 s0__SubscribePolledRefreshReplyItemList ** SOAP_FMAC4 soap_in_PointerTos0__SubscribePolledRefreshReplyItemList(struct soap *soap, const char *tag, s0__SubscribePolledRefreshReplyItemList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (s0__SubscribePolledRefreshReplyItemList **)soap_malloc(soap, sizeof(s0__SubscribePolledRefreshReplyItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (s0__SubscribePolledRefreshReplyItemList *)soap_instantiate_s0__SubscribePolledRefreshReplyItemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (s0__SubscribePolledRefreshReplyItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList, sizeof(s0__SubscribePolledRefreshReplyItemList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__SubscribeReplyItemList(struct soap *soap, s0__SubscribeReplyItemList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_s0__SubscribeReplyItemList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__SubscribeReplyItemList(struct soap *soap, s0__SubscribeReplyItemList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__SubscribeReplyItemList);
	if (soap_out_PointerTos0__SubscribeReplyItemList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__SubscribeReplyItemList(struct soap *soap, const char *tag, int id, s0__SubscribeReplyItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__SubscribeReplyItemList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__SubscribeReplyItemList ** SOAP_FMAC4 soap_get_PointerTos0__SubscribeReplyItemList(struct soap *soap, s0__SubscribeReplyItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__SubscribeReplyItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 s0__SubscribeReplyItemList ** SOAP_FMAC4 soap_in_PointerTos0__SubscribeReplyItemList(struct soap *soap, const char *tag, s0__SubscribeReplyItemList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (s0__SubscribeReplyItemList **)soap_malloc(soap, sizeof(s0__SubscribeReplyItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (s0__SubscribeReplyItemList *)soap_instantiate_s0__SubscribeReplyItemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (s0__SubscribeReplyItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__SubscribeReplyItemList, sizeof(s0__SubscribeReplyItemList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__SubscribeRequestItemList(struct soap *soap, s0__SubscribeRequestItemList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_s0__SubscribeRequestItemList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__SubscribeRequestItemList(struct soap *soap, s0__SubscribeRequestItemList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__SubscribeRequestItemList);
	if (soap_out_PointerTos0__SubscribeRequestItemList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__SubscribeRequestItemList(struct soap *soap, const char *tag, int id, s0__SubscribeRequestItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__SubscribeRequestItemList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__SubscribeRequestItemList ** SOAP_FMAC4 soap_get_PointerTos0__SubscribeRequestItemList(struct soap *soap, s0__SubscribeRequestItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__SubscribeRequestItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 s0__SubscribeRequestItemList ** SOAP_FMAC4 soap_in_PointerTos0__SubscribeRequestItemList(struct soap *soap, const char *tag, s0__SubscribeRequestItemList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (s0__SubscribeRequestItemList **)soap_malloc(soap, sizeof(s0__SubscribeRequestItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (s0__SubscribeRequestItemList *)soap_instantiate_s0__SubscribeRequestItemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (s0__SubscribeRequestItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__SubscribeRequestItemList, sizeof(s0__SubscribeRequestItemList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__WriteRequestItemList(struct soap *soap, s0__WriteRequestItemList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_s0__WriteRequestItemList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__WriteRequestItemList(struct soap *soap, s0__WriteRequestItemList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__WriteRequestItemList);
	if (soap_out_PointerTos0__WriteRequestItemList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__WriteRequestItemList(struct soap *soap, const char *tag, int id, s0__WriteRequestItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__WriteRequestItemList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__WriteRequestItemList ** SOAP_FMAC4 soap_get_PointerTos0__WriteRequestItemList(struct soap *soap, s0__WriteRequestItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__WriteRequestItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 s0__WriteRequestItemList ** SOAP_FMAC4 soap_in_PointerTos0__WriteRequestItemList(struct soap *soap, const char *tag, s0__WriteRequestItemList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (s0__WriteRequestItemList **)soap_malloc(soap, sizeof(s0__WriteRequestItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (s0__WriteRequestItemList *)soap_instantiate_s0__WriteRequestItemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (s0__WriteRequestItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__WriteRequestItemList, sizeof(s0__WriteRequestItemList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__OPCError(struct soap *soap, s0__OPCError *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_s0__OPCError))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__OPCError(struct soap *soap, s0__OPCError *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__OPCError);
	if (soap_out_PointerTos0__OPCError(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__OPCError(struct soap *soap, const char *tag, int id, s0__OPCError *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__OPCError);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__OPCError ** SOAP_FMAC4 soap_get_PointerTos0__OPCError(struct soap *soap, s0__OPCError **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__OPCError(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 s0__OPCError ** SOAP_FMAC4 soap_in_PointerTos0__OPCError(struct soap *soap, const char *tag, s0__OPCError **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (s0__OPCError **)soap_malloc(soap, sizeof(s0__OPCError *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (s0__OPCError *)soap_instantiate_s0__OPCError(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (s0__OPCError **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__OPCError, sizeof(s0__OPCError), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__ReplyItemList(struct soap *soap, s0__ReplyItemList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_s0__ReplyItemList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__ReplyItemList(struct soap *soap, s0__ReplyItemList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__ReplyItemList);
	if (soap_out_PointerTos0__ReplyItemList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__ReplyItemList(struct soap *soap, const char *tag, int id, s0__ReplyItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__ReplyItemList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__ReplyItemList ** SOAP_FMAC4 soap_get_PointerTos0__ReplyItemList(struct soap *soap, s0__ReplyItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__ReplyItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 s0__ReplyItemList ** SOAP_FMAC4 soap_in_PointerTos0__ReplyItemList(struct soap *soap, const char *tag, s0__ReplyItemList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (s0__ReplyItemList **)soap_malloc(soap, sizeof(s0__ReplyItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (s0__ReplyItemList *)soap_instantiate_s0__ReplyItemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (s0__ReplyItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__ReplyItemList, sizeof(s0__ReplyItemList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__ReadRequestItemList(struct soap *soap, s0__ReadRequestItemList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_s0__ReadRequestItemList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__ReadRequestItemList(struct soap *soap, s0__ReadRequestItemList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__ReadRequestItemList);
	if (soap_out_PointerTos0__ReadRequestItemList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__ReadRequestItemList(struct soap *soap, const char *tag, int id, s0__ReadRequestItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__ReadRequestItemList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__ReadRequestItemList ** SOAP_FMAC4 soap_get_PointerTos0__ReadRequestItemList(struct soap *soap, s0__ReadRequestItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__ReadRequestItemList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 s0__ReadRequestItemList ** SOAP_FMAC4 soap_in_PointerTos0__ReadRequestItemList(struct soap *soap, const char *tag, s0__ReadRequestItemList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (s0__ReadRequestItemList **)soap_malloc(soap, sizeof(s0__ReadRequestItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (s0__ReadRequestItemList *)soap_instantiate_s0__ReadRequestItemList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (s0__ReadRequestItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__ReadRequestItemList, sizeof(s0__ReadRequestItemList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__RequestOptions(struct soap *soap, s0__RequestOptions *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_s0__RequestOptions))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__RequestOptions(struct soap *soap, s0__RequestOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__RequestOptions);
	if (soap_out_PointerTos0__RequestOptions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__RequestOptions(struct soap *soap, const char *tag, int id, s0__RequestOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__RequestOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__RequestOptions ** SOAP_FMAC4 soap_get_PointerTos0__RequestOptions(struct soap *soap, s0__RequestOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__RequestOptions(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 s0__RequestOptions ** SOAP_FMAC4 soap_in_PointerTos0__RequestOptions(struct soap *soap, const char *tag, s0__RequestOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (s0__RequestOptions **)soap_malloc(soap, sizeof(s0__RequestOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (s0__RequestOptions *)soap_instantiate_s0__RequestOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (s0__RequestOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__RequestOptions, sizeof(s0__RequestOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__ServerStatus(struct soap *soap, s0__ServerStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_s0__ServerStatus))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__ServerStatus(struct soap *soap, s0__ServerStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__ServerStatus);
	if (soap_out_PointerTos0__ServerStatus(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__ServerStatus(struct soap *soap, const char *tag, int id, s0__ServerStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__ServerStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__ServerStatus ** SOAP_FMAC4 soap_get_PointerTos0__ServerStatus(struct soap *soap, s0__ServerStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__ServerStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 s0__ServerStatus ** SOAP_FMAC4 soap_in_PointerTos0__ServerStatus(struct soap *soap, const char *tag, s0__ServerStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (s0__ServerStatus **)soap_malloc(soap, sizeof(s0__ServerStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (s0__ServerStatus *)soap_instantiate_s0__ServerStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (s0__ServerStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__ServerStatus, sizeof(s0__ServerStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__ReplyBase(struct soap *soap, s0__ReplyBase *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_s0__ReplyBase))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__ReplyBase(struct soap *soap, s0__ReplyBase *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__ReplyBase);
	if (soap_out_PointerTos0__ReplyBase(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__ReplyBase(struct soap *soap, const char *tag, int id, s0__ReplyBase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__ReplyBase);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__ReplyBase ** SOAP_FMAC4 soap_get_PointerTos0__ReplyBase(struct soap *soap, s0__ReplyBase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__ReplyBase(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 s0__ReplyBase ** SOAP_FMAC4 soap_in_PointerTos0__ReplyBase(struct soap *soap, const char *tag, s0__ReplyBase **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (s0__ReplyBase **)soap_malloc(soap, sizeof(s0__ReplyBase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (s0__ReplyBase *)soap_instantiate_s0__ReplyBase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (s0__ReplyBase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__ReplyBase, sizeof(s0__ReplyBase), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__ItemProperty(struct soap *soap, s0__ItemProperty *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_s0__ItemProperty))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__ItemProperty(struct soap *soap, s0__ItemProperty *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__ItemProperty);
	if (soap_out_PointerTos0__ItemProperty(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__ItemProperty(struct soap *soap, const char *tag, int id, s0__ItemProperty *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__ItemProperty);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__ItemProperty ** SOAP_FMAC4 soap_get_PointerTos0__ItemProperty(struct soap *soap, s0__ItemProperty **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__ItemProperty(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 s0__ItemProperty ** SOAP_FMAC4 soap_in_PointerTos0__ItemProperty(struct soap *soap, const char *tag, s0__ItemProperty **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (s0__ItemProperty **)soap_malloc(soap, sizeof(s0__ItemProperty *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (s0__ItemProperty *)soap_instantiate_s0__ItemProperty(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (s0__ItemProperty **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__ItemProperty, sizeof(s0__ItemProperty), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__SubscribeItemValue(struct soap *soap, s0__SubscribeItemValue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_s0__SubscribeItemValue))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__SubscribeItemValue(struct soap *soap, s0__SubscribeItemValue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__SubscribeItemValue);
	if (soap_out_PointerTos0__SubscribeItemValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__SubscribeItemValue(struct soap *soap, const char *tag, int id, s0__SubscribeItemValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__SubscribeItemValue);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__SubscribeItemValue ** SOAP_FMAC4 soap_get_PointerTos0__SubscribeItemValue(struct soap *soap, s0__SubscribeItemValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__SubscribeItemValue(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 s0__SubscribeItemValue ** SOAP_FMAC4 soap_in_PointerTos0__SubscribeItemValue(struct soap *soap, const char *tag, s0__SubscribeItemValue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (s0__SubscribeItemValue **)soap_malloc(soap, sizeof(s0__SubscribeItemValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (s0__SubscribeItemValue *)soap_instantiate_s0__SubscribeItemValue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (s0__SubscribeItemValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__SubscribeItemValue, sizeof(s0__SubscribeItemValue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofloat(struct soap *soap, float *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_float);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofloat(struct soap *soap, float *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofloat);
	if (soap_out_PointerTofloat(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofloat(struct soap *soap, const char *tag, int id, float *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_float);
	if (id < 0)
		return soap->error;
	return soap_out_float(soap, tag, id, *a, type);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_get_PointerTofloat(struct soap *soap, float **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofloat(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_in_PointerTofloat(struct soap *soap, const char *tag, float **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (float **)soap_malloc(soap, sizeof(float *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_float(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (float **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_float, sizeof(float), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__SubscribeRequestItem(struct soap *soap, s0__SubscribeRequestItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_s0__SubscribeRequestItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__SubscribeRequestItem(struct soap *soap, s0__SubscribeRequestItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__SubscribeRequestItem);
	if (soap_out_PointerTos0__SubscribeRequestItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__SubscribeRequestItem(struct soap *soap, const char *tag, int id, s0__SubscribeRequestItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__SubscribeRequestItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__SubscribeRequestItem ** SOAP_FMAC4 soap_get_PointerTos0__SubscribeRequestItem(struct soap *soap, s0__SubscribeRequestItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__SubscribeRequestItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 s0__SubscribeRequestItem ** SOAP_FMAC4 soap_in_PointerTos0__SubscribeRequestItem(struct soap *soap, const char *tag, s0__SubscribeRequestItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (s0__SubscribeRequestItem **)soap_malloc(soap, sizeof(s0__SubscribeRequestItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (s0__SubscribeRequestItem *)soap_instantiate_s0__SubscribeRequestItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (s0__SubscribeRequestItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__SubscribeRequestItem, sizeof(s0__SubscribeRequestItem), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedShort(struct soap *soap, unsigned short *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_unsignedShort);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedShort(struct soap *soap, unsigned short *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedShort);
	if (soap_out_PointerTounsignedShort(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedShort(struct soap *soap, const char *tag, int id, unsigned short *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedShort);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedShort(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned short ** SOAP_FMAC4 soap_get_PointerTounsignedShort(struct soap *soap, unsigned short **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedShort(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 unsigned short ** SOAP_FMAC4 soap_in_PointerTounsignedShort(struct soap *soap, const char *tag, unsigned short **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned short **)soap_malloc(soap, sizeof(unsigned short *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedShort(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned short **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedShort, sizeof(unsigned short), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__limitBits(struct soap *soap, enum s0__limitBits *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_s0__limitBits);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__limitBits(struct soap *soap, enum s0__limitBits *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__limitBits);
	if (soap_out_PointerTos0__limitBits(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__limitBits(struct soap *soap, const char *tag, int id, enum s0__limitBits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__limitBits);
	if (id < 0)
		return soap->error;
	return soap_out_s0__limitBits(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum s0__limitBits ** SOAP_FMAC4 soap_get_PointerTos0__limitBits(struct soap *soap, enum s0__limitBits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__limitBits(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum s0__limitBits ** SOAP_FMAC4 soap_in_PointerTos0__limitBits(struct soap *soap, const char *tag, enum s0__limitBits **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum s0__limitBits **)soap_malloc(soap, sizeof(enum s0__limitBits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_s0__limitBits(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum s0__limitBits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__limitBits, sizeof(enum s0__limitBits), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__qualityBits(struct soap *soap, enum s0__qualityBits *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_s0__qualityBits);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__qualityBits(struct soap *soap, enum s0__qualityBits *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__qualityBits);
	if (soap_out_PointerTos0__qualityBits(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__qualityBits(struct soap *soap, const char *tag, int id, enum s0__qualityBits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__qualityBits);
	if (id < 0)
		return soap->error;
	return soap_out_s0__qualityBits(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum s0__qualityBits ** SOAP_FMAC4 soap_get_PointerTos0__qualityBits(struct soap *soap, enum s0__qualityBits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__qualityBits(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 enum s0__qualityBits ** SOAP_FMAC4 soap_in_PointerTos0__qualityBits(struct soap *soap, const char *tag, enum s0__qualityBits **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum s0__qualityBits **)soap_malloc(soap, sizeof(enum s0__qualityBits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_s0__qualityBits(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum s0__qualityBits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__qualityBits, sizeof(enum s0__qualityBits), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__OPCQuality(struct soap *soap, s0__OPCQuality *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_s0__OPCQuality))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__OPCQuality(struct soap *soap, s0__OPCQuality *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__OPCQuality);
	if (soap_out_PointerTos0__OPCQuality(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__OPCQuality(struct soap *soap, const char *tag, int id, s0__OPCQuality *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__OPCQuality);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__OPCQuality ** SOAP_FMAC4 soap_get_PointerTos0__OPCQuality(struct soap *soap, s0__OPCQuality **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__OPCQuality(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 s0__OPCQuality ** SOAP_FMAC4 soap_in_PointerTos0__OPCQuality(struct soap *soap, const char *tag, s0__OPCQuality **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (s0__OPCQuality **)soap_malloc(soap, sizeof(s0__OPCQuality *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (s0__OPCQuality *)soap_instantiate_s0__OPCQuality(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (s0__OPCQuality **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__OPCQuality, sizeof(s0__OPCQuality), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyType);
	if (soap_out_PointerToxsd__anyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyType(struct soap *soap, const char *tag, int id, xsd__anyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_get_PointerToxsd__anyType(struct soap *soap, xsd__anyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_in_PointerToxsd__anyType(struct soap *soap, const char *tag, xsd__anyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__anyType **)soap_malloc(soap, sizeof(xsd__anyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__anyType *)soap_instantiate_xsd__anyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__ItemValue(struct soap *soap, s0__ItemValue *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_s0__ItemValue))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__ItemValue(struct soap *soap, s0__ItemValue *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__ItemValue);
	if (soap_out_PointerTos0__ItemValue(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__ItemValue(struct soap *soap, const char *tag, int id, s0__ItemValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__ItemValue);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__ItemValue ** SOAP_FMAC4 soap_get_PointerTos0__ItemValue(struct soap *soap, s0__ItemValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__ItemValue(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 s0__ItemValue ** SOAP_FMAC4 soap_in_PointerTos0__ItemValue(struct soap *soap, const char *tag, s0__ItemValue **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (s0__ItemValue **)soap_malloc(soap, sizeof(s0__ItemValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (s0__ItemValue *)soap_instantiate_s0__ItemValue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (s0__ItemValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__ItemValue, sizeof(s0__ItemValue), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__QName(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__QName))
		soap_serialize_xsd__QName(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__QName(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__QName);
	if (soap_out_PointerToxsd__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__QName(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__QName);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__QName(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__QName(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__QName(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__QName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__QName, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTos0__ReadRequestItem(struct soap *soap, s0__ReadRequestItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_s0__ReadRequestItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTos0__ReadRequestItem(struct soap *soap, s0__ReadRequestItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTos0__ReadRequestItem);
	if (soap_out_PointerTos0__ReadRequestItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTos0__ReadRequestItem(struct soap *soap, const char *tag, int id, s0__ReadRequestItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_s0__ReadRequestItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 s0__ReadRequestItem ** SOAP_FMAC4 soap_get_PointerTos0__ReadRequestItem(struct soap *soap, s0__ReadRequestItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTos0__ReadRequestItem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 s0__ReadRequestItem ** SOAP_FMAC4 soap_in_PointerTos0__ReadRequestItem(struct soap *soap, const char *tag, s0__ReadRequestItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (s0__ReadRequestItem **)soap_malloc(soap, sizeof(s0__ReadRequestItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (s0__ReadRequestItem *)soap_instantiate_s0__ReadRequestItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (s0__ReadRequestItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_s0__ReadRequestItem, sizeof(s0__ReadRequestItem), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__dateTime(struct soap *soap, xsd__dateTime *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__dateTime))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__dateTime(struct soap *soap, xsd__dateTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__dateTime);
	if (soap_out_PointerToxsd__dateTime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__dateTime(struct soap *soap, const char *tag, int id, xsd__dateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__dateTime);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__dateTime ** SOAP_FMAC4 soap_get_PointerToxsd__dateTime(struct soap *soap, xsd__dateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__dateTime(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 xsd__dateTime ** SOAP_FMAC4 soap_in_PointerToxsd__dateTime(struct soap *soap, const char *tag, xsd__dateTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__dateTime **)soap_malloc(soap, sizeof(xsd__dateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__dateTime *)soap_instantiate_xsd__dateTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (xsd__dateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__dateTime, sizeof(xsd__dateTime), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_bool);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTobool);
	if (soap_out_PointerTobool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTos0__PropertyReplyList(struct soap *soap, std::vector<s0__PropertyReplyList * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTos0__PropertyReplyList(struct soap *soap, const std::vector<s0__PropertyReplyList * >*a)
{
	for (std::vector<s0__PropertyReplyList * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTos0__PropertyReplyList(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTos0__PropertyReplyList(struct soap *soap, const char *tag, int id, const std::vector<s0__PropertyReplyList * >*a, const char *type)
{
	for (std::vector<s0__PropertyReplyList * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTos0__PropertyReplyList(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<s0__PropertyReplyList * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTos0__PropertyReplyList(struct soap *soap, const char *tag, std::vector<s0__PropertyReplyList * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTos0__PropertyReplyList(soap, -1)))
		return NULL;
	s0__PropertyReplyList *n;
	s0__PropertyReplyList **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_s0__PropertyReplyList, SOAP_TYPE_std__vectorTemplateOfPointerTos0__PropertyReplyList, sizeof(s0__PropertyReplyList), 1))
				break;
			if (!(p = soap_in_PointerTos0__PropertyReplyList(soap, tag, NULL, "s0:PropertyReplyList")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTos0__PropertyReplyList(soap, tag, &n, "s0:PropertyReplyList"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<s0__PropertyReplyList * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTos0__PropertyReplyList(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTos0__PropertyReplyList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTos0__PropertyReplyList(struct soap *soap, std::vector<s0__PropertyReplyList * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<s0__PropertyReplyList * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTos0__PropertyReplyList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTos0__PropertyReplyList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTos0__PropertyReplyList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<s0__PropertyReplyList * >;
		if (size)
			*size = sizeof(std::vector<s0__PropertyReplyList * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<s0__PropertyReplyList * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<s0__PropertyReplyList * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<s0__PropertyReplyList * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTos0__PropertyReplyList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<s0__PropertyReplyList * > %p -> %p\n", q, p));
	*(std::vector<s0__PropertyReplyList * >*)p = *(std::vector<s0__PropertyReplyList * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTos0__ItemIdentifier(struct soap *soap, std::vector<s0__ItemIdentifier * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTos0__ItemIdentifier(struct soap *soap, const std::vector<s0__ItemIdentifier * >*a)
{
	for (std::vector<s0__ItemIdentifier * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTos0__ItemIdentifier(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTos0__ItemIdentifier(struct soap *soap, const char *tag, int id, const std::vector<s0__ItemIdentifier * >*a, const char *type)
{
	for (std::vector<s0__ItemIdentifier * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTos0__ItemIdentifier(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<s0__ItemIdentifier * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTos0__ItemIdentifier(struct soap *soap, const char *tag, std::vector<s0__ItemIdentifier * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTos0__ItemIdentifier(soap, -1)))
		return NULL;
	s0__ItemIdentifier *n;
	s0__ItemIdentifier **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_s0__ItemIdentifier, SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemIdentifier, sizeof(s0__ItemIdentifier), 1))
				break;
			if (!(p = soap_in_PointerTos0__ItemIdentifier(soap, tag, NULL, "s0:ItemIdentifier")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTos0__ItemIdentifier(soap, tag, &n, "s0:ItemIdentifier"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<s0__ItemIdentifier * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTos0__ItemIdentifier(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTos0__ItemIdentifier(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTos0__ItemIdentifier(struct soap *soap, std::vector<s0__ItemIdentifier * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<s0__ItemIdentifier * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTos0__ItemIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTos0__ItemIdentifier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemIdentifier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<s0__ItemIdentifier * >;
		if (size)
			*size = sizeof(std::vector<s0__ItemIdentifier * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<s0__ItemIdentifier * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<s0__ItemIdentifier * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<s0__ItemIdentifier * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTos0__ItemIdentifier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<s0__ItemIdentifier * > %p -> %p\n", q, p));
	*(std::vector<s0__ItemIdentifier * >*)p = *(std::vector<s0__ItemIdentifier * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTos0__BrowseElement(struct soap *soap, std::vector<s0__BrowseElement * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTos0__BrowseElement(struct soap *soap, const std::vector<s0__BrowseElement * >*a)
{
	for (std::vector<s0__BrowseElement * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTos0__BrowseElement(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTos0__BrowseElement(struct soap *soap, const char *tag, int id, const std::vector<s0__BrowseElement * >*a, const char *type)
{
	for (std::vector<s0__BrowseElement * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTos0__BrowseElement(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<s0__BrowseElement * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTos0__BrowseElement(struct soap *soap, const char *tag, std::vector<s0__BrowseElement * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTos0__BrowseElement(soap, -1)))
		return NULL;
	s0__BrowseElement *n;
	s0__BrowseElement **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_s0__BrowseElement, SOAP_TYPE_std__vectorTemplateOfPointerTos0__BrowseElement, sizeof(s0__BrowseElement), 1))
				break;
			if (!(p = soap_in_PointerTos0__BrowseElement(soap, tag, NULL, "s0:BrowseElement")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTos0__BrowseElement(soap, tag, &n, "s0:BrowseElement"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<s0__BrowseElement * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTos0__BrowseElement(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTos0__BrowseElement(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTos0__BrowseElement(struct soap *soap, std::vector<s0__BrowseElement * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<s0__BrowseElement * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTos0__BrowseElement(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTos0__BrowseElement(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTos0__BrowseElement, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<s0__BrowseElement * >;
		if (size)
			*size = sizeof(std::vector<s0__BrowseElement * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<s0__BrowseElement * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<s0__BrowseElement * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<s0__BrowseElement * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTos0__BrowseElement(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<s0__BrowseElement * > %p -> %p\n", q, p));
	*(std::vector<s0__BrowseElement * >*)p = *(std::vector<s0__BrowseElement * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__QName(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__QName(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__QName(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__QName(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__QName(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfxsd__QName(soap, -1)))
		return NULL;
	std::string n;
	std::string *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__QName, SOAP_TYPE_std__vectorTemplateOfxsd__QName, sizeof(std::string), 0))
				break;
			if (!(p = soap_in_xsd__QName(soap, tag, NULL, "xsd:QName")))
				break;
		}
		else
		{	soap_default_xsd__QName(soap, &n);
			if (!soap_in_xsd__QName(soap, tag, &n, "xsd:QName"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_new_std__vectorTemplateOfxsd__QName(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfxsd__QName(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfxsd__QName(struct soap *soap, std::vector<std::string >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<std::string > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfxsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__QName(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__QName, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfxsd__QName(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(struct soap *soap, std::vector<s0__SubscribePolledRefreshReplyItemList * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(struct soap *soap, const std::vector<s0__SubscribePolledRefreshReplyItemList * >*a)
{
	for (std::vector<s0__SubscribePolledRefreshReplyItemList * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTos0__SubscribePolledRefreshReplyItemList(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(struct soap *soap, const char *tag, int id, const std::vector<s0__SubscribePolledRefreshReplyItemList * >*a, const char *type)
{
	for (std::vector<s0__SubscribePolledRefreshReplyItemList * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTos0__SubscribePolledRefreshReplyItemList(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<s0__SubscribePolledRefreshReplyItemList * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(struct soap *soap, const char *tag, std::vector<s0__SubscribePolledRefreshReplyItemList * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(soap, -1)))
		return NULL;
	s0__SubscribePolledRefreshReplyItemList *n;
	s0__SubscribePolledRefreshReplyItemList **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_s0__SubscribePolledRefreshReplyItemList, SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList, sizeof(s0__SubscribePolledRefreshReplyItemList), 1))
				break;
			if (!(p = soap_in_PointerTos0__SubscribePolledRefreshReplyItemList(soap, tag, NULL, "s0:SubscribePolledRefreshReplyItemList")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTos0__SubscribePolledRefreshReplyItemList(soap, tag, &n, "s0:SubscribePolledRefreshReplyItemList"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<s0__SubscribePolledRefreshReplyItemList * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(struct soap *soap, std::vector<s0__SubscribePolledRefreshReplyItemList * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<s0__SubscribePolledRefreshReplyItemList * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<s0__SubscribePolledRefreshReplyItemList * >;
		if (size)
			*size = sizeof(std::vector<s0__SubscribePolledRefreshReplyItemList * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<s0__SubscribePolledRefreshReplyItemList * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<s0__SubscribePolledRefreshReplyItemList * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<s0__SubscribePolledRefreshReplyItemList * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTos0__SubscribePolledRefreshReplyItemList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<s0__SubscribePolledRefreshReplyItemList * > %p -> %p\n", q, p));
	*(std::vector<s0__SubscribePolledRefreshReplyItemList * >*)p = *(std::vector<s0__SubscribePolledRefreshReplyItemList * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTos0__OPCError(struct soap *soap, std::vector<s0__OPCError * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTos0__OPCError(struct soap *soap, const std::vector<s0__OPCError * >*a)
{
	for (std::vector<s0__OPCError * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTos0__OPCError(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTos0__OPCError(struct soap *soap, const char *tag, int id, const std::vector<s0__OPCError * >*a, const char *type)
{
	for (std::vector<s0__OPCError * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTos0__OPCError(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<s0__OPCError * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTos0__OPCError(struct soap *soap, const char *tag, std::vector<s0__OPCError * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTos0__OPCError(soap, -1)))
		return NULL;
	s0__OPCError *n;
	s0__OPCError **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_s0__OPCError, SOAP_TYPE_std__vectorTemplateOfPointerTos0__OPCError, sizeof(s0__OPCError), 1))
				break;
			if (!(p = soap_in_PointerTos0__OPCError(soap, tag, NULL, "s0:OPCError")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTos0__OPCError(soap, tag, &n, "s0:OPCError"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<s0__OPCError * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTos0__OPCError(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTos0__OPCError(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTos0__OPCError(struct soap *soap, std::vector<s0__OPCError * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<s0__OPCError * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTos0__OPCError(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTos0__OPCError(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTos0__OPCError, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<s0__OPCError * >;
		if (size)
			*size = sizeof(std::vector<s0__OPCError * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<s0__OPCError * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<s0__OPCError * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<s0__OPCError * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTos0__OPCError(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<s0__OPCError * > %p -> %p\n", q, p));
	*(std::vector<s0__OPCError * >*)p = *(std::vector<s0__OPCError * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTos0__ItemProperty(struct soap *soap, std::vector<s0__ItemProperty * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTos0__ItemProperty(struct soap *soap, const std::vector<s0__ItemProperty * >*a)
{
	for (std::vector<s0__ItemProperty * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTos0__ItemProperty(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTos0__ItemProperty(struct soap *soap, const char *tag, int id, const std::vector<s0__ItemProperty * >*a, const char *type)
{
	for (std::vector<s0__ItemProperty * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTos0__ItemProperty(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<s0__ItemProperty * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTos0__ItemProperty(struct soap *soap, const char *tag, std::vector<s0__ItemProperty * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTos0__ItemProperty(soap, -1)))
		return NULL;
	s0__ItemProperty *n;
	s0__ItemProperty **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_s0__ItemProperty, SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemProperty, sizeof(s0__ItemProperty), 1))
				break;
			if (!(p = soap_in_PointerTos0__ItemProperty(soap, tag, NULL, "s0:ItemProperty")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTos0__ItemProperty(soap, tag, &n, "s0:ItemProperty"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<s0__ItemProperty * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTos0__ItemProperty(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTos0__ItemProperty(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTos0__ItemProperty(struct soap *soap, std::vector<s0__ItemProperty * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<s0__ItemProperty * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTos0__ItemProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTos0__ItemProperty(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemProperty, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<s0__ItemProperty * >;
		if (size)
			*size = sizeof(std::vector<s0__ItemProperty * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<s0__ItemProperty * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<s0__ItemProperty * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<s0__ItemProperty * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTos0__ItemProperty(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<s0__ItemProperty * > %p -> %p\n", q, p));
	*(std::vector<s0__ItemProperty * >*)p = *(std::vector<s0__ItemProperty * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTos0__SubscribeItemValue(struct soap *soap, std::vector<s0__SubscribeItemValue * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTos0__SubscribeItemValue(struct soap *soap, const std::vector<s0__SubscribeItemValue * >*a)
{
	for (std::vector<s0__SubscribeItemValue * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTos0__SubscribeItemValue(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTos0__SubscribeItemValue(struct soap *soap, const char *tag, int id, const std::vector<s0__SubscribeItemValue * >*a, const char *type)
{
	for (std::vector<s0__SubscribeItemValue * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTos0__SubscribeItemValue(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<s0__SubscribeItemValue * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTos0__SubscribeItemValue(struct soap *soap, const char *tag, std::vector<s0__SubscribeItemValue * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTos0__SubscribeItemValue(soap, -1)))
		return NULL;
	s0__SubscribeItemValue *n;
	s0__SubscribeItemValue **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_s0__SubscribeItemValue, SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribeItemValue, sizeof(s0__SubscribeItemValue), 1))
				break;
			if (!(p = soap_in_PointerTos0__SubscribeItemValue(soap, tag, NULL, "s0:SubscribeItemValue")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTos0__SubscribeItemValue(soap, tag, &n, "s0:SubscribeItemValue"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<s0__SubscribeItemValue * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTos0__SubscribeItemValue(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribeItemValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTos0__SubscribeItemValue(struct soap *soap, std::vector<s0__SubscribeItemValue * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<s0__SubscribeItemValue * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribeItemValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribeItemValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribeItemValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<s0__SubscribeItemValue * >;
		if (size)
			*size = sizeof(std::vector<s0__SubscribeItemValue * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<s0__SubscribeItemValue * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<s0__SubscribeItemValue * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<s0__SubscribeItemValue * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTos0__SubscribeItemValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<s0__SubscribeItemValue * > %p -> %p\n", q, p));
	*(std::vector<s0__SubscribeItemValue * >*)p = *(std::vector<s0__SubscribeItemValue * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(struct soap *soap, std::vector<s0__SubscribeRequestItem * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(struct soap *soap, const std::vector<s0__SubscribeRequestItem * >*a)
{
	for (std::vector<s0__SubscribeRequestItem * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTos0__SubscribeRequestItem(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(struct soap *soap, const char *tag, int id, const std::vector<s0__SubscribeRequestItem * >*a, const char *type)
{
	for (std::vector<s0__SubscribeRequestItem * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTos0__SubscribeRequestItem(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<s0__SubscribeRequestItem * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(struct soap *soap, const char *tag, std::vector<s0__SubscribeRequestItem * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(soap, -1)))
		return NULL;
	s0__SubscribeRequestItem *n;
	s0__SubscribeRequestItem **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_s0__SubscribeRequestItem, SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribeRequestItem, sizeof(s0__SubscribeRequestItem), 1))
				break;
			if (!(p = soap_in_PointerTos0__SubscribeRequestItem(soap, tag, NULL, "s0:SubscribeRequestItem")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTos0__SubscribeRequestItem(soap, tag, &n, "s0:SubscribeRequestItem"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<s0__SubscribeRequestItem * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(struct soap *soap, std::vector<s0__SubscribeRequestItem * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<s0__SubscribeRequestItem * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTos0__SubscribeRequestItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<s0__SubscribeRequestItem * >;
		if (size)
			*size = sizeof(std::vector<s0__SubscribeRequestItem * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<s0__SubscribeRequestItem * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<s0__SubscribeRequestItem * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<s0__SubscribeRequestItem * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTos0__SubscribeRequestItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<s0__SubscribeRequestItem * > %p -> %p\n", q, p));
	*(std::vector<s0__SubscribeRequestItem * >*)p = *(std::vector<s0__SubscribeRequestItem * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfshort(struct soap *soap, std::vector<short >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfshort(struct soap *soap, const std::vector<short >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfshort(struct soap *soap, const char *tag, int id, const std::vector<short >*a, const char *type)
{
	for (std::vector<short >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_short(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<short >* SOAP_FMAC4 soap_in_std__vectorTemplateOfshort(struct soap *soap, const char *tag, std::vector<short >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfshort(soap, -1)))
		return NULL;
	short n;
	short *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_short, SOAP_TYPE_std__vectorTemplateOfshort, sizeof(short), 0))
				break;
			if (!(p = soap_in_short(soap, tag, NULL, "xsd:short")))
				break;
		}
		else
		{	soap_default_short(soap, &n);
			if (!soap_in_short(soap, tag, &n, "xsd:short"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<short > * SOAP_FMAC6 soap_new_std__vectorTemplateOfshort(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfshort(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfshort(struct soap *soap, std::vector<short >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<short > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfshort(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfshort(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfshort, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<short >;
		if (size)
			*size = sizeof(std::vector<short >);
	}
	else
	{	cp->ptr = (void*)new std::vector<short >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<short >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<short >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfshort(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<short > %p -> %p\n", q, p));
	*(std::vector<short >*)p = *(std::vector<short >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfbyte(struct soap *soap, std::vector<char >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfbyte(struct soap *soap, const std::vector<char >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfbyte(struct soap *soap, const char *tag, int id, const std::vector<char >*a, const char *type)
{
	for (std::vector<char >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_byte(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char >* SOAP_FMAC4 soap_in_std__vectorTemplateOfbyte(struct soap *soap, const char *tag, std::vector<char >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfbyte(soap, -1)))
		return NULL;
	char n;
	char *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_byte, SOAP_TYPE_std__vectorTemplateOfbyte, sizeof(char), 0))
				break;
			if (!(p = soap_in_byte(soap, tag, NULL, "xsd:byte")))
				break;
		}
		else
		{	soap_default_byte(soap, &n);
			if (!soap_in_byte(soap, tag, &n, "xsd:byte"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<char > * SOAP_FMAC6 soap_new_std__vectorTemplateOfbyte(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfbyte(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfbyte(struct soap *soap, std::vector<char >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<char > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfbyte(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfbyte(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfbyte, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<char >;
		if (size)
			*size = sizeof(std::vector<char >);
	}
	else
	{	cp->ptr = (void*)new std::vector<char >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<char >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<char >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfbyte(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<char > %p -> %p\n", q, p));
	*(std::vector<char >*)p = *(std::vector<char >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfxsd__decimal(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfxsd__decimal(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_xsd__decimal(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfxsd__decimal(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_xsd__decimal(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfxsd__decimal(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfxsd__decimal(soap, -1)))
		return NULL;
	std::string n;
	std::string *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_xsd__decimal, SOAP_TYPE_std__vectorTemplateOfxsd__decimal, sizeof(std::string), 0))
				break;
			if (!(p = soap_in_xsd__decimal(soap, tag, NULL, "xsd:decimal")))
				break;
		}
		else
		{	soap_default_xsd__decimal(soap, &n);
			if (!soap_in_xsd__decimal(soap, tag, &n, "xsd:decimal"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_new_std__vectorTemplateOfxsd__decimal(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfxsd__decimal(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfxsd__decimal(struct soap *soap, std::vector<std::string >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<std::string > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfxsd__decimal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfxsd__decimal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfxsd__decimal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfxsd__decimal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOf_XML(struct soap *soap, const std::vector<char * >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, int id, const std::vector<char * >*a, const char *type)
{
	for (std::vector<char * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_outliteral(soap, tag, &(*i), NULL))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<char * >* SOAP_FMAC4 soap_in_std__vectorTemplateOf_XML(struct soap *soap, const char *tag, std::vector<char * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOf_XML(soap, -1)))
		return NULL;
	char *n;
	char **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__XML, SOAP_TYPE_std__vectorTemplateOf_XML, sizeof(char *), 1))
				break;
			if (!(p = soap_inliteral(soap, tag, NULL)))
				break;
		}
		else
		{	n = NULL;
			if (!soap_inliteral(soap, tag, &n))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<char * > * SOAP_FMAC6 soap_new_std__vectorTemplateOf_XML(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOf_XML(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOf_XML(struct soap *soap, std::vector<char * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<char * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOf_XML(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOf_XML(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOf_XML, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<char * >;
		if (size)
			*size = sizeof(std::vector<char * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<char * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<char * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<char * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOf_XML(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<char * > %p -> %p\n", q, p));
	*(std::vector<char * >*)p = *(std::vector<char * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfbool(struct soap *soap, std::vector<bool >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfbool(struct soap *soap, const std::vector<bool >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfbool(struct soap *soap, const char *tag, int id, const std::vector<bool >*a, const char *type)
{
	for (std::vector<bool >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		bool b = (*i);
		if (soap_out_bool(soap, tag, id, &b, ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<bool >* SOAP_FMAC4 soap_in_std__vectorTemplateOfbool(struct soap *soap, const char *tag, std::vector<bool >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfbool(soap, -1)))
		return NULL;
	bool n;
	bool *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_bool, SOAP_TYPE_std__vectorTemplateOfbool, sizeof(bool), 0))
				break;
			if (!(p = soap_in_bool(soap, tag, NULL, "xsd:boolean")))
				break;
		}
		else
		{	soap_default_bool(soap, &n);
			if (!soap_in_bool(soap, tag, &n, "xsd:boolean"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<bool > * SOAP_FMAC6 soap_new_std__vectorTemplateOfbool(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfbool(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfbool(struct soap *soap, std::vector<bool >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<bool > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfbool(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfbool(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfbool, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<bool >;
		if (size)
			*size = sizeof(std::vector<bool >);
	}
	else
	{	cp->ptr = (void*)new std::vector<bool >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<bool >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<bool >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfbool(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<bool > %p -> %p\n", q, p));
	*(std::vector<bool >*)p = *(std::vector<bool >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfunsignedShort(struct soap *soap, std::vector<unsigned short >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfunsignedShort(struct soap *soap, const std::vector<unsigned short >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfunsignedShort(struct soap *soap, const char *tag, int id, const std::vector<unsigned short >*a, const char *type)
{
	for (std::vector<unsigned short >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_unsignedShort(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<unsigned short >* SOAP_FMAC4 soap_in_std__vectorTemplateOfunsignedShort(struct soap *soap, const char *tag, std::vector<unsigned short >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfunsignedShort(soap, -1)))
		return NULL;
	unsigned short n;
	unsigned short *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_unsignedShort, SOAP_TYPE_std__vectorTemplateOfunsignedShort, sizeof(unsigned short), 0))
				break;
			if (!(p = soap_in_unsignedShort(soap, tag, NULL, "xsd:unsignedShort")))
				break;
		}
		else
		{	soap_default_unsignedShort(soap, &n);
			if (!soap_in_unsignedShort(soap, tag, &n, "xsd:unsignedShort"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<unsigned short > * SOAP_FMAC6 soap_new_std__vectorTemplateOfunsignedShort(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfunsignedShort(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfunsignedShort(struct soap *soap, std::vector<unsigned short >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<unsigned short > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfunsignedShort(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfunsignedShort(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfunsignedShort, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<unsigned short >;
		if (size)
			*size = sizeof(std::vector<unsigned short >);
	}
	else
	{	cp->ptr = (void*)new std::vector<unsigned short >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<unsigned short >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<unsigned short >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfunsignedShort(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<unsigned short > %p -> %p\n", q, p));
	*(std::vector<unsigned short >*)p = *(std::vector<unsigned short >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfdouble(struct soap *soap, std::vector<double >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfdouble(struct soap *soap, const std::vector<double >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfdouble(struct soap *soap, const char *tag, int id, const std::vector<double >*a, const char *type)
{
	for (std::vector<double >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_double(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<double >* SOAP_FMAC4 soap_in_std__vectorTemplateOfdouble(struct soap *soap, const char *tag, std::vector<double >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfdouble(soap, -1)))
		return NULL;
	double n;
	double *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_double, SOAP_TYPE_std__vectorTemplateOfdouble, sizeof(double), 0))
				break;
			if (!(p = soap_in_double(soap, tag, NULL, "xsd:double")))
				break;
		}
		else
		{	soap_default_double(soap, &n);
			if (!soap_in_double(soap, tag, &n, "xsd:double"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<double > * SOAP_FMAC6 soap_new_std__vectorTemplateOfdouble(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfdouble(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfdouble(struct soap *soap, std::vector<double >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<double > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfdouble(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfdouble(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfdouble, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<double >;
		if (size)
			*size = sizeof(std::vector<double >);
	}
	else
	{	cp->ptr = (void*)new std::vector<double >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<double >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<double >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfdouble(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<double > %p -> %p\n", q, p));
	*(std::vector<double >*)p = *(std::vector<double >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfunsignedLONG64(struct soap *soap, std::vector<ULONG64 >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfunsignedLONG64(struct soap *soap, const std::vector<ULONG64 >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfunsignedLONG64(struct soap *soap, const char *tag, int id, const std::vector<ULONG64 >*a, const char *type)
{
	for (std::vector<ULONG64 >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_unsignedLONG64(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ULONG64 >* SOAP_FMAC4 soap_in_std__vectorTemplateOfunsignedLONG64(struct soap *soap, const char *tag, std::vector<ULONG64 >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfunsignedLONG64(soap, -1)))
		return NULL;
	ULONG64 n;
	ULONG64 *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_unsignedLONG64, SOAP_TYPE_std__vectorTemplateOfunsignedLONG64, sizeof(ULONG64), 0))
				break;
			if (!(p = soap_in_unsignedLONG64(soap, tag, NULL, "xsd:unsignedLong")))
				break;
		}
		else
		{	soap_default_unsignedLONG64(soap, &n);
			if (!soap_in_unsignedLONG64(soap, tag, &n, "xsd:unsignedLong"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ULONG64 > * SOAP_FMAC6 soap_new_std__vectorTemplateOfunsignedLONG64(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfunsignedLONG64(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfunsignedLONG64(struct soap *soap, std::vector<ULONG64 >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ULONG64 > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfunsignedLONG64(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfunsignedLONG64(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfunsignedLONG64, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ULONG64 >;
		if (size)
			*size = sizeof(std::vector<ULONG64 >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ULONG64 >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ULONG64 >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ULONG64 >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfunsignedLONG64(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ULONG64 > %p -> %p\n", q, p));
	*(std::vector<ULONG64 >*)p = *(std::vector<ULONG64 >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfLONG64(struct soap *soap, std::vector<LONG64 >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfLONG64(struct soap *soap, const std::vector<LONG64 >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfLONG64(struct soap *soap, const char *tag, int id, const std::vector<LONG64 >*a, const char *type)
{
	for (std::vector<LONG64 >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_LONG64(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<LONG64 >* SOAP_FMAC4 soap_in_std__vectorTemplateOfLONG64(struct soap *soap, const char *tag, std::vector<LONG64 >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfLONG64(soap, -1)))
		return NULL;
	LONG64 n;
	LONG64 *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_LONG64, SOAP_TYPE_std__vectorTemplateOfLONG64, sizeof(LONG64), 0))
				break;
			if (!(p = soap_in_LONG64(soap, tag, NULL, "xsd:long")))
				break;
		}
		else
		{	soap_default_LONG64(soap, &n);
			if (!soap_in_LONG64(soap, tag, &n, "xsd:long"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<LONG64 > * SOAP_FMAC6 soap_new_std__vectorTemplateOfLONG64(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfLONG64(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfLONG64(struct soap *soap, std::vector<LONG64 >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<LONG64 > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfLONG64(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfLONG64(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfLONG64, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<LONG64 >;
		if (size)
			*size = sizeof(std::vector<LONG64 >);
	}
	else
	{	cp->ptr = (void*)new std::vector<LONG64 >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<LONG64 >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<LONG64 >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfLONG64(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<LONG64 > %p -> %p\n", q, p));
	*(std::vector<LONG64 >*)p = *(std::vector<LONG64 >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfunsignedInt(struct soap *soap, std::vector<unsigned int >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfunsignedInt(struct soap *soap, const std::vector<unsigned int >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfunsignedInt(struct soap *soap, const char *tag, int id, const std::vector<unsigned int >*a, const char *type)
{
	for (std::vector<unsigned int >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_unsignedInt(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<unsigned int >* SOAP_FMAC4 soap_in_std__vectorTemplateOfunsignedInt(struct soap *soap, const char *tag, std::vector<unsigned int >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfunsignedInt(soap, -1)))
		return NULL;
	unsigned int n;
	unsigned int *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_unsignedInt, SOAP_TYPE_std__vectorTemplateOfunsignedInt, sizeof(unsigned int), 0))
				break;
			if (!(p = soap_in_unsignedInt(soap, tag, NULL, "xsd:unsignedInt")))
				break;
		}
		else
		{	soap_default_unsignedInt(soap, &n);
			if (!soap_in_unsignedInt(soap, tag, &n, "xsd:unsignedInt"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<unsigned int > * SOAP_FMAC6 soap_new_std__vectorTemplateOfunsignedInt(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfunsignedInt(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfunsignedInt(struct soap *soap, std::vector<unsigned int >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<unsigned int > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfunsignedInt(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfunsignedInt(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfunsignedInt, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<unsigned int >;
		if (size)
			*size = sizeof(std::vector<unsigned int >);
	}
	else
	{	cp->ptr = (void*)new std::vector<unsigned int >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<unsigned int >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<unsigned int >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfunsignedInt(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<unsigned int > %p -> %p\n", q, p));
	*(std::vector<unsigned int >*)p = *(std::vector<unsigned int >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfint(struct soap *soap, std::vector<int >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfint(struct soap *soap, const std::vector<int >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfint(struct soap *soap, const char *tag, int id, const std::vector<int >*a, const char *type)
{
	for (std::vector<int >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_int(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<int >* SOAP_FMAC4 soap_in_std__vectorTemplateOfint(struct soap *soap, const char *tag, std::vector<int >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfint(soap, -1)))
		return NULL;
	int n;
	int *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_int, SOAP_TYPE_std__vectorTemplateOfint, sizeof(int), 0))
				break;
			if (!(p = soap_in_int(soap, tag, NULL, "xsd:int")))
				break;
		}
		else
		{	soap_default_int(soap, &n);
			if (!soap_in_int(soap, tag, &n, "xsd:int"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<int > * SOAP_FMAC6 soap_new_std__vectorTemplateOfint(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfint(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfint(struct soap *soap, std::vector<int >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<int > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<int >;
		if (size)
			*size = sizeof(std::vector<int >);
	}
	else
	{	cp->ptr = (void*)new std::vector<int >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<int >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<int >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<int > %p -> %p\n", q, p));
	*(std::vector<int >*)p = *(std::vector<int >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOffloat(struct soap *soap, std::vector<float >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOffloat(struct soap *soap, const std::vector<float >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOffloat(struct soap *soap, const char *tag, int id, const std::vector<float >*a, const char *type)
{
	for (std::vector<float >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_float(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<float >* SOAP_FMAC4 soap_in_std__vectorTemplateOffloat(struct soap *soap, const char *tag, std::vector<float >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOffloat(soap, -1)))
		return NULL;
	float n;
	float *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_float, SOAP_TYPE_std__vectorTemplateOffloat, sizeof(float), 0))
				break;
			if (!(p = soap_in_float(soap, tag, NULL, "xsd:float")))
				break;
		}
		else
		{	soap_default_float(soap, &n);
			if (!soap_in_float(soap, tag, &n, "xsd:float"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<float > * SOAP_FMAC6 soap_new_std__vectorTemplateOffloat(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOffloat(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOffloat(struct soap *soap, std::vector<float >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<float > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOffloat(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOffloat(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOffloat, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<float >;
		if (size)
			*size = sizeof(std::vector<float >);
	}
	else
	{	cp->ptr = (void*)new std::vector<float >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<float >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<float >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOffloat(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<float > %p -> %p\n", q, p));
	*(std::vector<float >*)p = *(std::vector<float >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTos0__ItemValue(struct soap *soap, std::vector<s0__ItemValue * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTos0__ItemValue(struct soap *soap, const std::vector<s0__ItemValue * >*a)
{
	for (std::vector<s0__ItemValue * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTos0__ItemValue(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTos0__ItemValue(struct soap *soap, const char *tag, int id, const std::vector<s0__ItemValue * >*a, const char *type)
{
	for (std::vector<s0__ItemValue * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTos0__ItemValue(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<s0__ItemValue * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTos0__ItemValue(struct soap *soap, const char *tag, std::vector<s0__ItemValue * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTos0__ItemValue(soap, -1)))
		return NULL;
	s0__ItemValue *n;
	s0__ItemValue **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_s0__ItemValue, SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemValue, sizeof(s0__ItemValue), 1))
				break;
			if (!(p = soap_in_PointerTos0__ItemValue(soap, tag, NULL, "s0:ItemValue")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTos0__ItemValue(soap, tag, &n, "s0:ItemValue"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<s0__ItemValue * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTos0__ItemValue(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTos0__ItemValue(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTos0__ItemValue(struct soap *soap, std::vector<s0__ItemValue * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<s0__ItemValue * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTos0__ItemValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTos0__ItemValue(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTos0__ItemValue, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<s0__ItemValue * >;
		if (size)
			*size = sizeof(std::vector<s0__ItemValue * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<s0__ItemValue * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<s0__ItemValue * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<s0__ItemValue * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTos0__ItemValue(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<s0__ItemValue * > %p -> %p\n", q, p));
	*(std::vector<s0__ItemValue * >*)p = *(std::vector<s0__ItemValue * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTos0__ReadRequestItem(struct soap *soap, std::vector<s0__ReadRequestItem * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTos0__ReadRequestItem(struct soap *soap, const std::vector<s0__ReadRequestItem * >*a)
{
	for (std::vector<s0__ReadRequestItem * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTos0__ReadRequestItem(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTos0__ReadRequestItem(struct soap *soap, const char *tag, int id, const std::vector<s0__ReadRequestItem * >*a, const char *type)
{
	for (std::vector<s0__ReadRequestItem * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTos0__ReadRequestItem(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<s0__ReadRequestItem * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTos0__ReadRequestItem(struct soap *soap, const char *tag, std::vector<s0__ReadRequestItem * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTos0__ReadRequestItem(soap, -1)))
		return NULL;
	s0__ReadRequestItem *n;
	s0__ReadRequestItem **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_s0__ReadRequestItem, SOAP_TYPE_std__vectorTemplateOfPointerTos0__ReadRequestItem, sizeof(s0__ReadRequestItem), 1))
				break;
			if (!(p = soap_in_PointerTos0__ReadRequestItem(soap, tag, NULL, "s0:ReadRequestItem")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerTos0__ReadRequestItem(soap, tag, &n, "s0:ReadRequestItem"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<s0__ReadRequestItem * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTos0__ReadRequestItem(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTos0__ReadRequestItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTos0__ReadRequestItem(struct soap *soap, std::vector<s0__ReadRequestItem * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<s0__ReadRequestItem * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTos0__ReadRequestItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTos0__ReadRequestItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTos0__ReadRequestItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<s0__ReadRequestItem * >;
		if (size)
			*size = sizeof(std::vector<s0__ReadRequestItem * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<s0__ReadRequestItem * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<s0__ReadRequestItem * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<s0__ReadRequestItem * >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTos0__ReadRequestItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<s0__ReadRequestItem * > %p -> %p\n", q, p));
	*(std::vector<s0__ReadRequestItem * >*)p = *(std::vector<s0__ReadRequestItem * >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfs0__interfaceVersion(struct soap *soap, std::vector<enum s0__interfaceVersion >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfs0__interfaceVersion(struct soap *soap, const std::vector<enum s0__interfaceVersion >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfs0__interfaceVersion(struct soap *soap, const char *tag, int id, const std::vector<enum s0__interfaceVersion >*a, const char *type)
{
	for (std::vector<enum s0__interfaceVersion >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_s0__interfaceVersion(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum s0__interfaceVersion >* SOAP_FMAC4 soap_in_std__vectorTemplateOfs0__interfaceVersion(struct soap *soap, const char *tag, std::vector<enum s0__interfaceVersion >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfs0__interfaceVersion(soap, -1)))
		return NULL;
	enum s0__interfaceVersion n;
	enum s0__interfaceVersion *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_s0__interfaceVersion, SOAP_TYPE_std__vectorTemplateOfs0__interfaceVersion, sizeof(enum s0__interfaceVersion), 0))
				break;
			if (!(p = soap_in_s0__interfaceVersion(soap, tag, NULL, "s0:interfaceVersion")))
				break;
		}
		else
		{	soap_default_s0__interfaceVersion(soap, &n);
			if (!soap_in_s0__interfaceVersion(soap, tag, &n, "s0:interfaceVersion"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<enum s0__interfaceVersion > * SOAP_FMAC6 soap_new_std__vectorTemplateOfs0__interfaceVersion(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfs0__interfaceVersion(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfs0__interfaceVersion(struct soap *soap, std::vector<enum s0__interfaceVersion >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<enum s0__interfaceVersion > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfs0__interfaceVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfs0__interfaceVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfs0__interfaceVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<enum s0__interfaceVersion >;
		if (size)
			*size = sizeof(std::vector<enum s0__interfaceVersion >);
	}
	else
	{	cp->ptr = (void*)new std::vector<enum s0__interfaceVersion >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum s0__interfaceVersion >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum s0__interfaceVersion >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfs0__interfaceVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum s0__interfaceVersion > %p -> %p\n", q, p));
	*(std::vector<enum s0__interfaceVersion >*)p = *(std::vector<enum s0__interfaceVersion >*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	std::string *p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!(p = soap_in_std__string(soap, tag, NULL, "xsd:string")))
				break;
		}
		else
		{	soap_default_std__string(soap, &n);
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_new_std__vectorTemplateOfstd__string(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfstd__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<std::string > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}
#ifdef __cplusplus
}
#endif

/* End of opc_soap_C.cpp */
