/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include "flow_ctx.h"
#include "flow_topdf.h"

FlowPdf::FlowPdf(char* filename, void* flow_ctx, int page_border, int* sts)
    : border(page_border), ctx(flow_ctx), show_red(1), topdf(0)
{
  topdf = new CnvToPdf();
  topdf->set_filename(pdf_eFile_Body, filename);
  topdf->set_useoutlines(0);

  *sts = 1;
}

FlowPdf::~FlowPdf()
{
  if (topdf) {
    topdf->close();
    delete topdf;
  }
}

int FlowPdf::print_page(double ll_x, double ll_y, double ur_x, double ur_y)
{
  FlowCtx* cx = (FlowCtx*)ctx;

  if (1.4 * (ur_x - ll_x) > ur_y - ll_y)
    cx->print_zoom_factor = 780 / (ur_x - ll_x) / 1.4;
  else
    cx->print_zoom_factor = 780 / (ur_y - ll_y);
  cx->print_zoom();

  offset_x = ll_x * cx->print_zoom_factor;
  offset_y = ur_y * cx->print_zoom_factor;

  ((FlowCtx*)ctx)->current_print = this;

  topdf->set_confpass(true);
  topdf->open();
  ((FlowCtx*)ctx)->print(ll_x, ll_y, ur_x, ur_y);
  // topdf->print_pagebreak(0);
  topdf->set_confpass(false);

  topdf->open();
  ((FlowCtx*)ctx)->print(ll_x, ll_y, ur_x, ur_y);
  // topdf->print_pagebreak(0);

  return 1;
}

int FlowPdf::rect(double x, double y, double width, double height,
    flow_eDrawType type, double idx, int highlight)
{
  topdf->draw_rect(idx, x - offset_x, offset_y - y - height, width, height);
  return 1;
}

int FlowPdf::filled_rect(double x, double y, double width, double height,
    flow_eDrawType type, double idx)
{
  return 1;
}

int FlowPdf::triangle(double x, double y, double width, double height,
    flow_eDrawType type, double idx, int highlight)
{
  topdf->draw_triangle(idx, x - offset_x, offset_y - y - height, width, height);
  return 1;
}

int FlowPdf::filled_triangle(double x, double y, double width, double height,
    flow_eDrawType type, double idx)
{
  topdf->draw_filled_triangle(
      type, x - offset_x, offset_y - y - height, width, height);
  return 1;
}

int FlowPdf::arc(double x, double y, double width, double height, int angle1,
    int angle2, flow_eDrawType type, double idx, int highlight)
{
  topdf->draw_arc(
      idx, x - offset_x, offset_y - y - height, width, height, angle1, angle2);
  return 1;
}

int FlowPdf::text(double x, double y, char* text, int len, flow_eDrawType type,
    double size, int line)
{
  char t[500];

  // Replace ( with \( and ) with \)
  char* t1 = text;
  char* t2 = t;
  for (int i = 0; *t1; t1++, i++) {
    if (*t1 == ')' || *t1 == '(') {
      *t2 = '\\';
      t2++;
    }
    *t2 = *t1;
    t2++;

    if (t2 - t >= (int)sizeof(t))
      break;
    if (i >= len)
      break;
  }
  *t2 = 0;

  int bold = (type == flow_eDrawType_TextHelveticaBold);

  topdf->draw_text(x - offset_x, offset_y - y, t, bold, size);
  return 1;
}

int FlowPdf::pixmap(
    double x, double y, flow_sPixmapDataElem* data, flow_eDrawType type)
{
  return 1;
}

int FlowPdf::line(double x1, double y1, double x2, double y2,
    flow_eDrawType type, double idx, int hightlight)
{
  topdf->draw_line(idx, x1 - offset_x, offset_y - y1, x2 - offset_x,
      offset_y - y2, type == flow_eDrawType_LineDashed,
      type == flow_eDrawType_LineGray);
  return 1;
}

int FlowPdf::arrow(double x1, double y1, double x2, double y2, double x3,
    double y3, flow_eDrawType type, double idx)
{
  topdf->draw_arrow(x1 - offset_x, offset_y - y1, x2 - offset_x, offset_y - y2,
      x3 - offset_x, offset_y - y3, type == flow_eDrawType_LineGray);
  return 1;
}

void FlowPdf::move(double x, double y)
{
  fprintf(file, "%f %f moveto", x, y);
}

void FlowPdf::setlinewidth(double idx)
{
  fprintf(file, "%f setlinewidth\n", idx);
}
