/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <math.h>
#include <stdlib.h>
#include <string.h>

#include "flow_printdraw_gtk.h"

FlowPrintDrawGtk::FlowPrintDrawGtk(void* context, const char* t, int p,
    void* flow_ctx, int page_border, int* sts)
    : print_ctx((GtkPrintContext*)context), border(page_border),
      ctx((FlowCtx*)flow_ctx), show_red(1), page(p)
{
  strncpy(title, t, sizeof(title));

  if (ctx->type() == flow_eCtxType_Flow) {
    print_margin_x = 10;
    print_margin_y = 10;
  }

  *sts = 1;
}

FlowPrintDrawGtk::~FlowPrintDrawGtk()
{
}

int FlowPrintDrawGtk::print_page(
    double ll_x, double ll_y, double ur_x, double ur_y)
{
  PangoLayout* layout;
  gdouble width, text_height;
  gint layout_height, layout_width;
  PangoFontDescription* desc;
  char page_str[40];

  if (ctx->type() == flow_eCtxType_Flow) {
    if (ur_x - ll_x > ur_y - ll_y) {
      print_margin_x = 10;
      print_margin_y = 60;
    } else {
      print_margin_x = 60;
      print_margin_y = 10;
    }
  }

  if (ur_x - ll_x > ur_y - ll_y)
    ctx->print_zoom_factor = 730 / (ur_x - ll_x);
  else
    ctx->print_zoom_factor = 730 / (ur_y - ll_y);

  ctx->print_zoom();
  page_x = ll_x * ctx->print_zoom_factor;
  page_y = ll_y * ctx->print_zoom_factor;

  cairo = gtk_print_context_get_cairo_context(print_ctx);
  width = gtk_print_context_get_width(print_ctx);

  if (ctx->type() == flow_eCtxType_Brow) {
    cairo_move_to(cairo, print_margin_x, print_margin_y);
    cairo_line_to(cairo, print_margin_x + width, print_margin_y);
    cairo_set_source_rgb(cairo, 0, 0, 0);
    cairo_set_line_width(cairo, 0.5);
    cairo_stroke(cairo);

    layout = gtk_print_context_create_pango_layout(print_ctx);

    desc = pango_font_description_from_string("Lucida Sans 9");
    pango_layout_set_font_description(layout, desc);
    pango_font_description_free(desc);

    sprintf(page_str, "Page %d", page + 1);
    pango_layout_set_width(layout, -1);
    pango_layout_set_text(layout, page_str, -1);
    pango_layout_set_alignment(layout, PANGO_ALIGN_LEFT);

    pango_layout_get_size(layout, NULL, &layout_height);
    text_height = (gdouble)layout_height / PANGO_SCALE;

    cairo_move_to(
        cairo, print_margin_x + width - 90, print_margin_y - text_height);
    cairo_set_source_rgb(cairo, 0, 0, 0);
    pango_cairo_show_layout(cairo, layout);

    g_object_unref(layout);

    layout = gtk_print_context_create_pango_layout(print_ctx);

    desc = pango_font_description_from_string("Lucida Sans 9");
    pango_layout_set_font_description(layout, desc);
    pango_font_description_free(desc);

    pango_layout_set_width(layout, -1);
    pango_layout_set_alignment(layout, PANGO_ALIGN_CENTER);
    pango_layout_set_text(layout, title, -1);

    pango_layout_get_size(layout, &layout_width, &layout_height);
    text_height = (gdouble)layout_height / PANGO_SCALE;

    cairo_move_to(cairo,
        print_margin_x + width / 2 - (gdouble)layout_width / PANGO_SCALE / 2,
        print_margin_y - text_height);
    cairo_set_source_rgb(cairo, 0, 0, 0);
    pango_cairo_show_layout(cairo, layout);

    g_object_unref(layout);
  }
  cairo_rectangle(cairo, print_margin_x, print_margin_y,
      (ur_x - ll_x) * ctx->print_zoom_factor,
      (ur_y - ll_y) * ctx->print_zoom_factor);

  // cairo_stroke(cairo);
  cairo_clip(cairo);

  ((FlowCtx*)ctx)->current_print = this;
  ((FlowCtx*)ctx)->print(ll_x, ll_y, ur_x, ur_y);

  cairo_reset_clip(cairo);
  return 1;
}

int FlowPrintDrawGtk::rect(double x, double y, double width, double height,
    flow_eDrawType type, double idx, int highlight)
{
  if (highlight || type == flow_eDrawType_LineRed)
    cairo_set_source_rgb(cairo, 1, 0, 0);
  else
    cairo_set_source_rgb(cairo, 0, 0, 0);

  cairo_set_line_width(cairo, 0.5 * idx);
  cairo_rectangle(cairo, print_margin_x + x - page_x,
      print_margin_y + y - page_y, width, height);
  cairo_stroke(cairo);

  return 1;
}

int FlowPrintDrawGtk::filled_rect(double x, double y, double width,
    double height, flow_eDrawType type, double idx)
{
  switch (type) {
  case flow_eDrawType_LineRed:
    cairo_set_source_rgb(cairo, 1, 0, 0);
    break;
  case flow_eDrawType_Green:
    cairo_set_source_rgb(cairo, 0, 1, 0);
    break;
  case flow_eDrawType_Yellow:
    cairo_set_source_rgb(cairo, 1, 1, 0);
    break;
  case flow_eDrawType_DarkGray:
    cairo_set_source_rgb(cairo, 0.3, 0.3, 0.3);
    break;
  default:
    cairo_set_source_rgb(cairo, 0, 0, 0);
  }
  cairo_rectangle(cairo, print_margin_x + x - page_x,
      print_margin_y + y - page_y, width, height);
  cairo_fill(cairo);

  cairo_set_source_rgb(cairo, 0, 0, 0);
  cairo_set_line_width(cairo, 0.5 * idx);
  cairo_rectangle(cairo, print_margin_x + x - page_x,
      print_margin_y + y - page_y, width, height);
  cairo_stroke(cairo);

  return 1;
}

int FlowPrintDrawGtk::arc(double x, double y, double width, double height,
    int angle1, int angle2, flow_eDrawType type, double idx, int highlight)
{
  double dashed[] = { 4.0, 2.0 };

  if (highlight || type == flow_eDrawType_LineRed
      || type == flow_eDrawType_LineDashedRed)
    cairo_set_source_rgb(cairo, 1, 0, 0);
  else
    cairo_set_source_rgb(cairo, 0, 0, 0);

  if (type == flow_eDrawType_LineDashed || type == flow_eDrawType_LineDashedRed)
    cairo_set_dash(cairo, dashed, 2, 0);

  cairo_set_line_width(cairo, 0.5 * idx);
  cairo_arc(cairo, print_margin_x + x + width / 2 - page_x,
      print_margin_y + y + height / 2 - page_y, width / 2,
      -M_PI * (angle1 + angle2) / 180, -M_PI * angle1 / 180);
  cairo_stroke(cairo);

  if (type == flow_eDrawType_LineDashed || type == flow_eDrawType_LineDashedRed)
    cairo_set_dash(cairo, 0, 0, 0);

  return 1;
}

int FlowPrintDrawGtk::line(double x1, double y1, double x2, double y2,
    flow_eDrawType type, double idx, int highlight)
{
  double dashed[] = { 4.0, 2.0 };

  switch (type) {
  case flow_eDrawType_LineRed:
    cairo_set_source_rgb(cairo, 1, 0, 0);
    break;
  case flow_eDrawType_LineGray:
    cairo_set_source_rgb(cairo, 0.7, 0.7, 0.7);
    break;
  case flow_eDrawType_LineDashed:
    cairo_set_dash(cairo, dashed, 2, 0);
    cairo_set_source_rgb(cairo, 0, 0, 0);
    break;
  case flow_eDrawType_LineDashedRed:
    cairo_set_dash(cairo, dashed, 2, 0);
    cairo_set_source_rgb(cairo, 1, 0, 0);
    break;
  default:
    cairo_set_source_rgb(cairo, 0, 0, 0);
  }

  cairo_move_to(
      cairo, print_margin_x + x1 - page_x, print_margin_y + y1 - page_y);
  cairo_line_to(
      cairo, print_margin_x + x2 - page_x, print_margin_y + y2 - page_y);
  cairo_set_line_width(cairo, 0.5 * idx);
  cairo_stroke(cairo);

  switch (type) {
  case flow_eDrawType_LineDashed:
  case flow_eDrawType_LineDashedRed:
    cairo_set_dash(cairo, 0, 0, 0);
    break;
  default:;
  }

  return 1;
}

int FlowPrintDrawGtk::text(double x, double y, char* text, int len,
    flow_eDrawType type, double size, int line)
{
  char font[40];
  PangoLayout* layout = 0;
  PangoFontDescription* desc;
  int w, h;
  char* s;

  switch (type) {
  case flow_eDrawType_TextHelvetica:
    sprintf(font, "Lucida Sans %3.1f", 1.0 * size);
    break;
  case flow_eDrawType_TextHelveticaBold:
    sprintf(font, "Lucida Sans Bold %3.1f", 1.0 * size);
    break;
  default:;
  }

  desc = pango_font_description_from_string(font);

  for (s = text; *s; s++) {
    if (*s == 10)
      break;
  }

  char* textutf8
      = g_convert(text, s - text, "UTF-8", "ISO8859-1", NULL, NULL, NULL);
  if (s - text > 0) {
    layout = gtk_print_context_create_pango_layout(print_ctx);
    pango_layout_set_font_description(layout, desc);
    pango_layout_set_text(layout, textutf8, -1);
    pango_layout_set_alignment(layout, PANGO_ALIGN_LEFT);
    pango_layout_get_size(layout, &w, &h);
    // cairo_move_to( cairo, print_margin_x + x - page_x,  print_margin_y + y -
    // page_y - 0.8 / PANGO_SCALE * h);
    cairo_move_to(cairo, print_margin_x + x - page_x, print_margin_y + y
            - page_y - 0.8 / PANGO_SCALE * size * 1093
            + 0.4 / PANGO_SCALE * size * 1093 * line);
    cairo_set_source_rgb(cairo, 0, 0, 0);
    pango_cairo_show_layout(cairo, layout);
    g_object_unref(layout);
  }
  pango_font_description_free(desc);
  g_free(textutf8);

  return 1;
}

int FlowPrintDrawGtk::pixmap(
    double x, double y, flow_sPixmapDataElem* data, flow_eDrawType type)
{
  int stride;
  cairo_surface_t* surface;
  unsigned char* sdata;
  unsigned char *data_p, *sdata_p;
  int bit_cnt;
  int i, j;
  float scale = 0.7;

  // To do, set color
  switch (type) {
  case flow_eDrawType_LineRed:
    break;
  default:;
  }

  stride = cairo_format_stride_for_width(CAIRO_FORMAT_A1, data->width);
  sdata = (unsigned char*)calloc(1, stride * data->height);
  data_p = (unsigned char*)data->bits;
  for (i = 0; i < data->height; i++) {
    bit_cnt = 0;
    sdata_p = sdata + i * stride;
    for (j = 0; j < data->width; j++) {
      if (bit_cnt == 8) {
        bit_cnt = 0;
        data_p++;
        sdata_p++;
      }
      if (*data_p & (1 << bit_cnt))
        *sdata_p |= 1 << bit_cnt;
      bit_cnt++;
    }
    data_p++;
  }

  surface = cairo_image_surface_create_for_data(
      sdata, CAIRO_FORMAT_A1, data->width, data->height, stride);
  cairo_scale(cairo, scale, scale);
  // cairo_mask_surface( cairo, surface, (x - page_x)/scale, (y -
  // page_y)/scale);
  cairo_set_source_surface(cairo, surface,
      (print_margin_x + x - page_x) / scale,
      (print_margin_y + y - page_y) / scale);
  cairo_paint(cairo);
  cairo_scale(cairo, 1.0 / scale, 1.0 / scale);

  cairo_surface_destroy(surface);
  // free( sdata);
  return 1;
}

int FlowPrintDrawGtk::image(double x, double y, double width, double height,
    flow_tImImage image, flow_eDrawType type)
{
  int stride;
  cairo_surface_t* surface;
  unsigned char* sdata;
  unsigned char* sdata_p;
  float scale = 0.7;
  unsigned char *rgb, *rgb_row;
  int rgb_height;
  int rgb_width;
  int rowstride;
  int n_channels;

  rgb = gdk_pixbuf_get_pixels((GdkPixbuf*)image);
  rgb_height = gdk_pixbuf_get_height((GdkPixbuf*)image);
  rgb_width = gdk_pixbuf_get_width((GdkPixbuf*)image);
  rowstride = gdk_pixbuf_get_rowstride((GdkPixbuf*)image);
  n_channels = gdk_pixbuf_get_n_channels((GdkPixbuf*)image);

  stride = cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32, rgb_width);
  sdata = (unsigned char*)calloc(1, 4 * stride * rgb_height);

  rgb_row = rgb;
  for (int j = 0; j < rgb_height; j++) {
    rgb = rgb_row;
    sdata_p = sdata + j * stride;
    for (int i = 0; i < rgb_width; i++) {
      switch (n_channels) {
      case 1:
        sdata_p[0] = rgb[0];
        sdata_p[1] = rgb[0];
        sdata_p[2] = rgb[0];
        sdata_p[3] = 255;
        break;
      case 2:
        sdata_p[0] = rgb[0];
        sdata_p[1] = rgb[1];
        sdata_p[2] = rgb[1];
        sdata_p[3] = 255;
        break;
      case 3:
        sdata_p[0] = rgb[0];
        sdata_p[1] = rgb[1];
        sdata_p[2] = rgb[2];
        sdata_p[3] = 255;
        break;
      default:
        sdata_p[0] = rgb[2]; // Blue
        sdata_p[1] = rgb[1]; // Green
        sdata_p[2] = rgb[0]; // Red
        sdata_p[3] = rgb[3]; // Alpha
      }

      rgb += n_channels;
      sdata_p += 4;
    }
    rgb_row += rowstride;
  }

  surface = cairo_image_surface_create_for_data(
      sdata, CAIRO_FORMAT_ARGB32, rgb_width, rgb_height, stride);

  scale = width / rgb_width;
  cairo_scale(cairo, scale, scale);
  // cairo_mask_surface( cairo, surface, (x - page_x)/scale, (y -
  // page_y)/scale);
  cairo_set_source_surface(cairo, surface,
      (print_margin_x + x - page_x) / scale,
      (print_margin_y + y - page_y) / scale);
  cairo_paint(cairo);
  cairo_scale(cairo, 1.0 / scale, 1.0 / scale);

  cairo_surface_destroy(surface);
  // free( sdata);
  return 1;
}

int FlowPrintDrawGtk::arrow(double x1, double y1, double x2, double y2,
    double x3, double y3, flow_eDrawType type, double idx)
{
  switch (type) {
  case flow_eDrawType_LineRed:
    cairo_set_source_rgb(cairo, 1, 0, 0);
    break;
  case flow_eDrawType_LineGray:
    cairo_set_source_rgb(cairo, 0.7, 0.7, 0.7);
    break;
  default:
    cairo_set_source_rgb(cairo, 0, 0, 0);
  }

  cairo_move_to(
      cairo, print_margin_x + x1 - page_x, print_margin_y + y1 - page_y);
  cairo_line_to(
      cairo, print_margin_x + x2 - page_x, print_margin_y + y2 - page_y);
  cairo_line_to(
      cairo, print_margin_x + x3 - page_x, print_margin_y + y3 - page_y);
  cairo_line_to(
      cairo, print_margin_x + x1 - page_x, print_margin_y + y1 - page_y);
  cairo_close_path(cairo);
  cairo_fill_preserve(cairo);

  return 1;
}
