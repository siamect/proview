/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2012 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

#include "flow_std.h"


#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <float.h>
#include <gtk/gtk.h>

#include "flow_ctx.h"
#include "flow_printdraw_gtk.h"

FlowPrintDrawGtk::FlowPrintDrawGtk( void *context, const char *t, int p, void *flow_ctx, int page_border,
				    int *sts) :
  print_ctx((GtkPrintContext *)context), border(page_border), ctx((FlowCtx *)flow_ctx), show_red(1), page(p)
{
  strncpy( title, t, sizeof(title));

  if ( ctx->type() == flow_eCtxType_Flow) {
    print_margin_x = 10;
    print_margin_y = 10;
  }

  *sts = 1;
}

FlowPrintDrawGtk::~FlowPrintDrawGtk() 
{
}

int FlowPrintDrawGtk::print_page( double ll_x, double ll_y, double ur_x, double ur_y)
{
  PangoLayout *layout;
  gdouble width, text_height;
  gint layout_height, layout_width;
  PangoFontDescription *desc;
  char page_str[40];
          
  if ( ctx->type() == flow_eCtxType_Flow) {
    if ( ur_x - ll_x > ur_y - ll_y) {
      print_margin_x = 10;
      print_margin_y = 60;
    }
    else {
      print_margin_x = 60;
      print_margin_y = 10;
    }
  }

  if ( ur_x - ll_x > ur_y - ll_y)
    ctx->print_zoom_factor = 730 / (ur_x - ll_x);
  else
    ctx->print_zoom_factor = 730 / (ur_y - ll_y);

  ctx->print_zoom();
  page_x = ll_x * ctx->print_zoom_factor;
  page_y = ll_y * ctx->print_zoom_factor;

  cairo = gtk_print_context_get_cairo_context (print_ctx);
  width = gtk_print_context_get_width (print_ctx);
          
  if ( ctx->type() == flow_eCtxType_Brow) {
    cairo_move_to( cairo, print_margin_x, print_margin_y);
    cairo_line_to( cairo, print_margin_x + width, print_margin_y);
    cairo_set_source_rgb( cairo, 0, 0, 0);
    cairo_set_line_width( cairo, 0.5);
    cairo_stroke( cairo);

    layout = gtk_print_context_create_pango_layout( print_ctx);
          
    desc = pango_font_description_from_string( "Lucida Sans 9");
    pango_layout_set_font_description( layout, desc);
    pango_font_description_free( desc);
  
    sprintf( page_str, "Page %d", page + 1);
    pango_layout_set_width( layout, -1);
    pango_layout_set_text( layout, page_str, -1);
    pango_layout_set_alignment( layout, PANGO_ALIGN_LEFT);
  
    pango_layout_get_size( layout, NULL, &layout_height);
    text_height = (gdouble)layout_height / PANGO_SCALE;
          
    cairo_move_to( cairo, print_margin_x + width - 90, print_margin_y - text_height);
    cairo_set_source_rgb( cairo, 0, 0, 0);
    pango_cairo_show_layout( cairo, layout);
          
    g_object_unref( layout);

    layout = gtk_print_context_create_pango_layout (print_ctx);
          
    desc = pango_font_description_from_string( "Lucida Sans 9");
    pango_layout_set_font_description( layout, desc);
    pango_font_description_free( desc);
  
    pango_layout_set_width( layout, -1);
    pango_layout_set_alignment( layout, PANGO_ALIGN_CENTER);
    pango_layout_set_text( layout, title, -1);
  
    pango_layout_get_size( layout, &layout_width, &layout_height);
    text_height = (gdouble)layout_height / PANGO_SCALE;
          
    cairo_move_to (cairo, print_margin_x + width/2 - (gdouble)layout_width/PANGO_SCALE/2, 
		   print_margin_y - text_height);
    cairo_set_source_rgb( cairo, 0, 0, 0);
    pango_cairo_show_layout( cairo, layout);
          
    g_object_unref( layout);
  }
  cairo_rectangle( cairo, print_margin_x, print_margin_y, (ur_x - ll_x) * ctx->print_zoom_factor, 
		   (ur_y - ll_y) * ctx->print_zoom_factor);
          
  //cairo_stroke(cairo);
  cairo_clip( cairo);

  ((FlowCtx *)ctx)->current_print = this;
  ((FlowCtx *)ctx)->print( ll_x, ll_y, ur_x, ur_y);

  cairo_reset_clip( cairo);
  return 1;
}

int FlowPrintDrawGtk::rect( double x, double y, double width, double height, flow_eDrawType type, 
	double idx, int highlight)
{
  if ( highlight || type == flow_eDrawType_LineRed)
    cairo_set_source_rgb( cairo, 1, 0, 0);
  else
    cairo_set_source_rgb( cairo, 0, 0, 0);

  cairo_set_line_width( cairo, 0.5 * idx);
  cairo_rectangle( cairo, print_margin_x + x - page_x, print_margin_y + y - page_y, width, height);
  cairo_stroke( cairo);

  return 1;
}

int FlowPrintDrawGtk::filled_rect( double x, double y, double width, double height, flow_eDrawType type, 
	double idx)
{
  switch( type) {
  case flow_eDrawType_LineRed:
    cairo_set_source_rgb( cairo, 1, 0, 0);
    break;
  case flow_eDrawType_Green:
    cairo_set_source_rgb( cairo, 0, 1, 0);
    break;
  case flow_eDrawType_Yellow:
    cairo_set_source_rgb( cairo, 1, 1, 0);
    break;
  case flow_eDrawType_DarkGray:
    cairo_set_source_rgb( cairo, 0.3, 0.3, 0.3);
    break;
  default:
    cairo_set_source_rgb( cairo, 0, 0, 0);
  }  
  cairo_rectangle( cairo, print_margin_x + x - page_x, print_margin_y + y - page_y, width, height);
  cairo_fill( cairo);

  cairo_set_source_rgb( cairo, 0, 0, 0);
  cairo_set_line_width( cairo, 0.5 * idx);
  cairo_rectangle( cairo, print_margin_x + x - page_x, print_margin_y + y - page_y, width, height);
  cairo_stroke( cairo);

  return 1;
}

int FlowPrintDrawGtk::arc( double x, double y, double width, double height, int angle1, int angle2,
		flow_eDrawType type, double idx, int highlight)
{
  double dashed[] = {4.0, 2.0};

  if ( highlight || type == flow_eDrawType_LineRed || type == flow_eDrawType_LineDashedRed)
    cairo_set_source_rgb( cairo, 1, 0, 0);
  else
    cairo_set_source_rgb( cairo, 0, 0, 0);

  if ( type == flow_eDrawType_LineDashed || type == flow_eDrawType_LineDashedRed)
    cairo_set_dash( cairo, dashed, 2, 0);

  cairo_set_line_width( cairo, 0.5 * idx);
  cairo_arc( cairo, print_margin_x + x + width/2 - page_x, print_margin_y + y + height/2 - page_y, width/2, 
	     - M_PI * (angle1 + angle2) / 180, - M_PI * angle1 / 180);
  cairo_stroke( cairo);

  if ( type == flow_eDrawType_LineDashed || type == flow_eDrawType_LineDashedRed)
    cairo_set_dash( cairo, 0, 0, 0);

  return 1;
}

int FlowPrintDrawGtk::line( double x1, double y1, double x2, double y2, flow_eDrawType type, 
	double idx, int highlight)
{
  double dashed[] = {4.0, 2.0};

  switch( type) {
  case flow_eDrawType_LineRed:
    cairo_set_source_rgb( cairo, 1, 0, 0);
    break;    
  case flow_eDrawType_LineGray:
    cairo_set_source_rgb( cairo, 0.7, 0.7, 0.7);
    break;    
  case flow_eDrawType_LineDashed:
    cairo_set_dash( cairo, dashed, 2, 0);
    cairo_set_source_rgb( cairo, 0, 0, 0);
    break;    
  case flow_eDrawType_LineDashedRed:
    cairo_set_dash( cairo, dashed, 2, 0);
    cairo_set_source_rgb( cairo, 1, 0, 0);
    break;    
  default:
    cairo_set_source_rgb( cairo, 0, 0, 0);
  }  

  cairo_move_to( cairo, print_margin_x + x1 - page_x, print_margin_y + y1 - page_y);
  cairo_line_to( cairo, print_margin_x + x2 - page_x, print_margin_y + y2 - page_y);
  cairo_set_line_width( cairo, 0.5 * idx);
  cairo_stroke( cairo);

  switch( type) {
  case flow_eDrawType_LineDashed:
  case flow_eDrawType_LineDashedRed:
    cairo_set_dash( cairo, 0, 0, 0);
    break;    
  default: ;
  }
    
  return 1;
}

int FlowPrintDrawGtk::text( double x, double y, char *text, int len, flow_eDrawType type, 
			    double size, int line)
{
  char font[40];
  PangoLayout *layout = 0;
  PangoFontDescription *desc;
  int w, h;
  char *s;

  switch( type) {
  case flow_eDrawType_TextHelvetica:
    sprintf( font, "Lucida Sans %3.1f", 1.0 * size);
    break;
  case flow_eDrawType_TextHelveticaBold:
    sprintf( font, "Lucida Sans Bold %3.1f", 1.0 * size);
    break;
  default:
    ;
  }  
          
  desc = pango_font_description_from_string( font);
  
  for ( s = text; *s; s++) {
    if ( *s == 10)
      break;
  }

  char *textutf8 = g_convert( text, s - text, "UTF-8", "ISO8859-1", NULL, NULL, NULL);
  if ( s - text > 0) {
    layout = gtk_print_context_create_pango_layout( print_ctx);
    pango_layout_set_font_description( layout, desc);
    pango_layout_set_text( layout, textutf8, -1);
    pango_layout_set_alignment( layout, PANGO_ALIGN_LEFT);
    pango_layout_get_size( layout, &w, &h);
    // cairo_move_to( cairo, print_margin_x + x - page_x,  print_margin_y + y - page_y - 0.8 / PANGO_SCALE * h);
    cairo_move_to( cairo, print_margin_x + x - page_x,  print_margin_y + y - page_y - 0.8 / PANGO_SCALE * size * 1093 + 0.4 / PANGO_SCALE * size * 1093 * line);
    cairo_set_source_rgb( cairo, 0, 0, 0);
    pango_cairo_show_layout( cairo, layout);
    g_object_unref( layout);
  }
  pango_font_description_free( desc);
  g_free( textutf8);

  return 1;
}

int FlowPrintDrawGtk::pixmap( double x, double y, flow_sPixmapDataElem *data,
	flow_eDrawType type)
{
  int stride;
  cairo_surface_t *surface;
  unsigned char *sdata;
  unsigned char *data_p, *sdata_p;
  int bit_cnt;
  int i, j;
  float scale = 0.7;

  // To do, set color
  switch( type) {
  case flow_eDrawType_LineRed:
    break;
  default: ;
  }  

  stride = cairo_format_stride_for_width( CAIRO_FORMAT_A1, data->width);
  sdata = (unsigned char *) calloc( 1, stride * data->height);
  data_p = (unsigned char *)data->bits;
  for ( i = 0; i < data->height; i++) {
    bit_cnt = 0;
    sdata_p = sdata + i * stride;
    for ( j = 0; j < data->width; j++) {
      if ( bit_cnt == 8) {
        bit_cnt = 0;
        data_p++;
	sdata_p++;
      }
      if ( *data_p & ( 1 << bit_cnt))
	*sdata_p |= 1 << bit_cnt;
      bit_cnt++;
    }
    data_p++;
  }

  surface = cairo_image_surface_create_for_data( sdata, CAIRO_FORMAT_A1, data->width,
						 data->height, stride);
  cairo_scale( cairo, scale, scale);
  //cairo_mask_surface( cairo, surface, (x - page_x)/scale, (y - page_y)/scale);
  cairo_set_source_surface( cairo, surface, (print_margin_x + x - page_x)/scale, (print_margin_y + y - page_y)/scale);
  cairo_paint( cairo);
  cairo_scale( cairo, 1.0 / scale, 1.0 / scale);

  cairo_surface_destroy( surface);
  // free( sdata);
  return 1;
}

int FlowPrintDrawGtk::image( double x, double y, double width, double height, flow_tImImage image, 
			     flow_eDrawType type)
{
  int stride;
  cairo_surface_t *surface;
  unsigned char *sdata;
  unsigned char *sdata_p;
  float scale = 0.7;
  unsigned char *rgb, *rgb_row;
  int 		rgb_height;
  int 		rgb_width;
  int		rowstride;
  int		n_channels;
   
  rgb = gdk_pixbuf_get_pixels( (GdkPixbuf *)image);
  rgb_height = gdk_pixbuf_get_height( (GdkPixbuf *)image);
  rgb_width = gdk_pixbuf_get_width( (GdkPixbuf *)image);
  rowstride = gdk_pixbuf_get_rowstride( (GdkPixbuf *)image);
  n_channels = gdk_pixbuf_get_n_channels( (GdkPixbuf *)image);

  stride = cairo_format_stride_for_width( CAIRO_FORMAT_ARGB32, rgb_width);
  sdata = (unsigned char *) calloc( 1, 4 * stride * rgb_height);

  rgb_row = rgb;
  for ( int j = 0; j < rgb_height; j++) {
    rgb = rgb_row;
    sdata_p = sdata + j * stride;
    for ( int i = 0; i < rgb_width; i++) {
      switch( n_channels) {
      case 1:
	sdata_p[0] = rgb[0];
	sdata_p[1] = rgb[0];
	sdata_p[2] = rgb[0];
	sdata_p[3] = 255;
	break;
      case 2:
	sdata_p[0] = rgb[0];
	sdata_p[1] = rgb[1];
	sdata_p[2] = rgb[1];
	sdata_p[3] = 255;
	break;
      case 3:
	sdata_p[0] = rgb[0];
	sdata_p[1] = rgb[1];
	sdata_p[2] = rgb[2];
	sdata_p[3] = 255;
	break;
      default:
	sdata_p[0] = rgb[2]; // Blue
	sdata_p[1] = rgb[1]; // Green
	sdata_p[2] = rgb[0]; // Red
	sdata_p[3] = rgb[3]; // Alpha
      }
      
      rgb += n_channels;
      sdata_p += 4;
    }
    rgb_row += rowstride;
  }

  surface = cairo_image_surface_create_for_data( sdata, CAIRO_FORMAT_ARGB32, rgb_width,
						 rgb_height, stride);
  
  scale = width / rgb_width;
  cairo_scale( cairo, scale, scale);
  //cairo_mask_surface( cairo, surface, (x - page_x)/scale, (y - page_y)/scale);
  cairo_set_source_surface( cairo, surface, (print_margin_x + x - page_x)/scale, (print_margin_y + y - page_y)/scale);
  cairo_paint( cairo);
  cairo_scale( cairo, 1.0 / scale, 1.0 / scale);

  cairo_surface_destroy( surface);
  // free( sdata);
  return 1;
}

int FlowPrintDrawGtk::arrow( double x1, double y1, double x2, double y2, 
	double x3, double y3, flow_eDrawType type, double idx)
{
  switch( type) {
  case flow_eDrawType_LineRed:
    cairo_set_source_rgb( cairo, 1, 0, 0);
    break;    
  case flow_eDrawType_LineGray:
    cairo_set_source_rgb( cairo, 0.7, 0.7, 0.7);
    break;    
  default:
    cairo_set_source_rgb( cairo, 0, 0, 0);
  }  

  cairo_move_to( cairo, print_margin_x + x1 - page_x, print_margin_y + y1 - page_y);
  cairo_line_to( cairo, print_margin_x + x2 - page_x, print_margin_y + y2 - page_y);
  cairo_line_to( cairo, print_margin_x + x3 - page_x, print_margin_y + y3 - page_y);
  cairo_line_to( cairo, print_margin_x + x1 - page_x, print_margin_y + y1 - page_y);
  cairo_close_path( cairo);
  cairo_fill_preserve( cairo);

  return 1;
}


