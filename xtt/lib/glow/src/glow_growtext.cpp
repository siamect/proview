/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2019 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <math.h>
#include <stdlib.h>

#include <iostream>

#include "co_string.h"

#include "glow_growtext.h"
#include "glow_grownode.h"
#include "glow_draw.h"
#include "glow_exportflow.h"

GrowText::GrowText(GrowCtx* glow_ctx, const char* name, const char* text1,
    double x, double y, glow_eDrawType d_type, glow_eDrawType color_d_type,
    int t_size, glow_eFont t_font, glow_mDisplayLevel display_lev, int nodraw)
    : GlowText(
          glow_ctx, text1, x, y, d_type, color_d_type, t_size, display_lev),
      hot(0), pzero(ctx), highlight(0), inverse(0), user_data(NULL), dynamic(0),
      dynamicsize(0), original_color_drawtype(glow_eDrawType_Line),
      font(t_font), adjustment(glow_eAdjustment_Left)
{
  strcpy(n_name, name);
  pzero.nav_zoom();
  strcpy(last_group, "");

  if (ctx->grid_on) {
    double x_grid, y_grid;

    ctx->find_grid(p.x, p.y, &x_grid, &y_grid);
    p.posit(x_grid, y_grid);
  }
  get_node_borders();
  if (!nodraw)
    ctx->set_dirty();
}

GrowText::GrowText(const GrowText& n) : GlowText(n)
{
  memcpy((void *)this, (void *)&n, sizeof(n));
  if (n.text) {
    text = (char*)malloc(strlen(n.text) + 1);
    strcpy(text, n.text);
  }
}

GrowText::~GrowText()
{
  ctx->object_deleted(this);
  ctx->set_dirty();
  if (hot)
    ctx->gdraw->set_cursor(ctx->mw, glow_eDrawCursor_Normal);
}

void GrowText::move(double delta_x, double delta_y, int grid)
{
  if (grid) {
    double x_grid, y_grid;

    /* Move to closest grid point */
    ctx->find_grid(x_left + delta_x / ctx->mw->zoom_factor_x,
        y_low + delta_y / ctx->mw->zoom_factor_y, &x_grid, &y_grid);
    trf.move(x_grid - x_left, y_grid - y_low);
    get_node_borders();
  } else {
    double dx = delta_x / ctx->mw->zoom_factor_x;
    double dy = delta_y / ctx->mw->zoom_factor_y;
    trf.move(dx, dy);
    x_right += dx;
    x_left += dx;
    y_high += dy;
    y_low += dy;
  }
  ctx->set_dirty();
}

void GrowText::move_noerase(int delta_x, int delta_y, int grid)
{
  if (grid) {
    double x_grid, y_grid;

    /* Move to closest grid point */
    ctx->find_grid(x_left + double(delta_x) / ctx->mw->zoom_factor_x,
        y_low + double(delta_y) / ctx->mw->zoom_factor_y, &x_grid, &y_grid);
    trf.move(x_grid - x_left, y_grid - y_low);
    get_node_borders();
  } else {
    double dx = double(delta_x) / ctx->mw->zoom_factor_x;
    double dy = double(delta_y) / ctx->mw->zoom_factor_y;
    trf.move(dx, dy);
    x_right += dx;
    x_left += dx;
    y_high += dy;
    y_low += dy;
  }
  ctx->set_dirty();
}

int GrowText::local_event_handler(glow_eEvent event, double x, double y)
{
  return (x_left <= x && x <= x_right && y_low <= y && y <= y_high);
}

int GrowText::event_handler(glow_eEvent event, double fx, double fy)
{
  return local_event_handler(event, fx, fy);
}

int GrowText::event_handler(glow_eEvent event, int x, int y, double fx, double fy)
{
  int sts = 0;
  if (event == ctx->event_move_node) {
    sts = local_event_handler(event, fx, fy);
    if (sts) {
      /* Register node for potential movement */
      ctx->move_insert(this);
    }
    return sts;
  }
  switch (event) {
  case glow_eEvent_CursorMotion: {
    if (ctx->hot_mode == glow_eHotMode_TraceAction)
      sts = 0;
    else if (ctx->hot_found)
      sts = 0;
    else {
      sts = local_event_handler(event, fx, fy);
      if (sts)
        ctx->hot_found = 1;
    }
    if (sts && !hot
        && !(ctx->node_movement_active || ctx->node_movement_paste_active)) {
      ctx->gdraw->set_cursor(ctx->mw, glow_eDrawCursor_CrossHair);
      hot = 1;
      ctx->set_dirty();
    }
    if (!sts && hot) {
      if (!ctx->hot_found)
        ctx->gdraw->set_cursor(ctx->mw, glow_eDrawCursor_Normal);
      hot = 0;
      ctx->set_dirty();
    }
    break;
  }
  default:
    sts = local_event_handler(event, fx, fy);
  }
  if (sts)
    ctx->register_callback_object(glow_eObjectType_Node, this);
  return sts;
}

void GrowText::save(std::ofstream& fp, glow_eSaveMode mode)
{
  char* s;

  fp << int(glow_eSave_GrowText) << '\n';
  fp << int(glow_eSave_GrowText_n_name) << FSPACE << n_name << '\n';
  fp << int(glow_eSave_GrowText_x_right) << FSPACE << x_right << '\n';
  fp << int(glow_eSave_GrowText_x_left) << FSPACE << x_left << '\n';
  fp << int(glow_eSave_GrowText_y_high) << FSPACE << y_high << '\n';
  fp << int(glow_eSave_GrowText_y_low) << FSPACE << y_low << '\n';
  fp << int(glow_eSave_GrowText_original_color_drawtype) << FSPACE
     << int(original_color_drawtype) << '\n';
  fp << int(glow_eSave_GrowText_font) << FSPACE << int(font) << '\n';
  fp << int(glow_eSave_GrowText_adjustment) << FSPACE << int(adjustment)
     << '\n';
  fp << int(glow_eSave_GrowText_dynamicsize) << FSPACE << dynamicsize << '\n';
  fp << int(glow_eSave_GrowText_dynamic) << '\n';
  if (dynamic) {
    fp << "\"";
    for (s = dynamic; *s; s++) {
      if (*s == '"')
        fp << "\\";
      fp << *s;
    }
    fp << "\"\n";
  }
  fp << int(glow_eSave_GrowText_text_part) << '\n';
  GlowText::save(fp, mode);
  fp << int(glow_eSave_GrowText_trf) << '\n';
  trf.save(fp, mode);
  fp << int(glow_eSave_End) << '\n';
}

void GrowText::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;
  int j;
  char c;
  char* new_text;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GrowText: \"%d %s\"\n", type, dummy);
    }

    fp >> type;
    switch (type) {
    case glow_eSave_GrowText:
      break;
    case glow_eSave_GrowText_n_name:
      fp.get();
      fp.getline(n_name, sizeof(n_name));
      break;
    case glow_eSave_GrowText_x_right:
      fp >> x_right;
      break;
    case glow_eSave_GrowText_x_left:
      fp >> x_left;
      break;
    case glow_eSave_GrowText_y_high:
      fp >> y_high;
      break;
    case glow_eSave_GrowText_y_low:
      fp >> y_low;
      break;
    case glow_eSave_GrowText_original_color_drawtype:
      fp >> tmp;
      original_color_drawtype = (glow_eDrawType)tmp;
      break;
    case glow_eSave_GrowText_font:
      fp >> tmp;
      font = (glow_eFont)tmp;
      break;
    case glow_eSave_GrowText_adjustment:
      fp >> tmp;
      adjustment = (glow_eAdjustment)tmp;
      break;
    case glow_eSave_GrowText_dynamicsize:
      fp >> dynamicsize;
      break;
    case glow_eSave_GrowText_dynamic:
      fp.getline(dummy, sizeof(dummy));
      if (dynamicsize) {
        dynamic = (char*)calloc(1, dynamicsize);
        fp.get();
        for (j = 0; j < dynamicsize; j++) {
          if ((c = fp.get()) == '"') {
            if (dynamic[j - 1] == '\\')
              j--;
            else {
              dynamic[j] = 0;
              break;
            }
          }
          dynamic[j] = c;
        }
        fp.getline(dummy, sizeof(dummy));
      }
      break;
    case glow_eSave_GrowText_text_part:
      GlowText::open(fp);
      break;
    case glow_eSave_GrowText_trf:
      trf.open(fp);
      break;
    case glow_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GrowText:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }

  // Translate the text to current language
  if (ctx->translate_on && ctx->event_callback[glow_eEvent_Translate]) {
    if (ctx->translate_cb(this, text, &new_text)) {
      free(text);
      text = (char*)malloc(strlen(new_text) + 1);
      strcpy(text, new_text);
    }
    get_node_borders();
  }
}

void GrowText::draw(DrawWind* w, int ll_x, int ll_y, int ur_x, int ur_y)
{
  int tmp;

  if (ll_x > ur_x) {
    /* Shift */
    tmp = ll_x;
    ll_x = ur_x;
    ur_x = tmp;
  }
  if (ll_y > ur_y) {
    /* Shift */
    tmp = ll_y;
    ll_y = ur_y;
    ur_y = tmp;
  }

  if (x_right * w->zoom_factor_x - w->offset_x >= ll_x
      && x_left * w->zoom_factor_x - w->offset_x <= ur_x
      && y_high * w->zoom_factor_y - w->offset_y >= ll_y
      && y_low * w->zoom_factor_y - w->offset_y <= ur_y) {
    draw(w, (GlowTransform*)NULL, highlight, hot, NULL, NULL);
  }
}

void GrowText::draw(DrawWind* w, int* ll_x, int* ll_y, int* ur_x, int* ur_y)
{
  int tmp;
  int obj_ur_x = int(x_right * w->zoom_factor_x) - w->offset_x;
  int obj_ll_x = int(x_left * w->zoom_factor_x) - w->offset_x;
  int obj_ur_y = int(y_high * w->zoom_factor_y) - w->offset_y;
  int obj_ll_y = int(y_low * w->zoom_factor_y) - w->offset_y;

  if (*ll_x > *ur_x) {
    /* Shift */
    tmp = *ll_x;
    *ll_x = *ur_x;
    *ur_x = tmp;
  }
  if (*ll_y > *ur_y) {
    /* Shift */
    tmp = *ll_y;
    *ll_y = *ur_y;
    *ur_y = tmp;
  }

  if (obj_ur_x >= *ll_x && obj_ll_x <= *ur_x && obj_ur_y >= *ll_y
      && obj_ll_y <= *ur_y) {
    draw(w, (GlowTransform*)NULL, highlight, hot, NULL, NULL);

    // Increase the redraw area
    if (obj_ur_x > *ur_x)
      *ur_x = obj_ur_x;
    if (obj_ur_y > *ur_y)
      *ur_y = obj_ur_y;
    if (obj_ll_x < *ll_x)
      *ll_x = obj_ll_x;
    if (obj_ll_y < *ll_y)
      *ll_y = obj_ll_y;
  }
}

void GrowText::set_highlight(int on)
{
  highlight = on;
  ctx->set_dirty();
}

void GrowText::select_region_insert(double ll_x, double ll_y, double ur_x,
    double ur_y, glow_eSelectPolicy select_policy)
{
  if (select_policy == glow_eSelectPolicy_Surround) {
    if (x_left > ll_x && x_right < ur_x && y_high < ur_y && y_low > ll_y)
      ctx->select_insert(this);
  } else {
    if (x_right > ll_x && x_left < ur_x && y_low < ur_y && y_high > ll_y)
      ctx->select_insert(this);
  }
}

void GrowText::set_dynamic(char* code, int size)
{
  if (!dynamic) {
    dynamic = (char*)calloc(1, size + 1);
    dynamicsize = size + 1;
  } else if (dynamicsize < size + 1) {
    free(dynamic);
    dynamic = (char*)calloc(1, size + 1);
    dynamicsize = size + 1;
  }
  strncpy(dynamic, code, size + 1);
}

void GrowText::exec_dynamic()
{
  if (dynamicsize && !streq(dynamic, ""))
    ctx->dynamic_cb(this, dynamic, glow_eDynamicType_Object);
}

void GrowText::set_position(double x, double y)
{
  if (feq(trf.a13, x) && feq(trf.a23, y))
    return;

  trf.posit(x, y);
  get_node_borders();
  ctx->set_dirty();
}

void GrowText::set_scale(
    double scale_x, double scale_y, double x0, double y0, glow_eScaleType type)
{
  double old_x_left, old_x_right, old_y_low, old_y_high;

  if (trf.s_a11 && trf.s_a22
      && fabs(scale_x - trf.a11 / trf.s_a11) < FLT_EPSILON
      && fabs(scale_y - trf.a22 / trf.s_a22) < FLT_EPSILON)
    return;

  switch (type) {
  case glow_eScaleType_LowerLeft:
    x0 = x_left;
    y0 = y_low;
    break;
  case glow_eScaleType_LowerRight:
    x0 = x_right;
    y0 = y_low;
    break;
  case glow_eScaleType_UpperRight:
    x0 = x_right;
    y0 = y_high;
    break;
  case glow_eScaleType_UpperLeft:
    x0 = x_left;
    y0 = y_high;
    break;
  case glow_eScaleType_FixPoint:
    break;
  case glow_eScaleType_Center:
    x0 = (x_left + x_right) / 2;
    y0 = (y_low + y_high) / 2;
    break;
  default:;
  }

  old_x_left = x_left;
  old_x_right = x_right;
  old_y_low = y_low;
  old_y_high = y_high;
  trf.scale_from_stored(scale_x, scale_y, x0, y0);
  get_node_borders();

  switch (type) {
  case glow_eScaleType_LowerLeft:
    x_left = old_x_left;
    y_low = old_y_low;
    break;
  case glow_eScaleType_LowerRight:
    x_right = old_x_right;
    y_low = old_y_low;
    break;
  case glow_eScaleType_UpperRight:
    x_right = old_x_right;
    y_high = old_y_high;
    break;
  case glow_eScaleType_UpperLeft:
    x_left = old_x_left;
    y_high = old_y_high;
    break;
  case glow_eScaleType_FixPoint:
    break;
  case glow_eScaleType_Center:
    x0 = (x_left + x_right) / 2;
    y0 = (y_low + y_high) / 2;
    break;
  default:;
  }
  ctx->set_dirty();
}

void GrowText::set_rotation(
    double angle, double x0, double y0, glow_eRotationPoint type)
{
  if (fabs(angle - trf.rotation + trf.s_rotation) < FLT_EPSILON)
    return;

  switch (type) {
  case glow_eRotationPoint_LowerLeft:
    x0 = x_left;
    y0 = y_low;
    break;
  case glow_eRotationPoint_LowerRight:
    x0 = x_right;
    y0 = y_low;
    break;
  case glow_eRotationPoint_UpperRight:
    x0 = x_right;
    y0 = y_high;
    break;
  case glow_eRotationPoint_UpperLeft:
    x0 = x_left;
    y0 = y_high;
    break;
  case glow_eRotationPoint_Center:
    x0 = (x_left + x_right) / 2;
    y0 = (y_high + y_low) / 2;
    break;
  default:;
  }

  trf.rotate_from_stored(angle, x0, y0);
  get_node_borders();
  ctx->set_dirty();
}

void GrowText::draw(DrawWind* w, GlowTransform* t, int highlight, int hot,
    void* node, void* colornode)
{
  if (!(display_level & ctx->display_level))
    return;
  hot = (w == ctx->navw) ? 0 : hot;
  int x1, y1, rx1 = 0, ry1 = 0;
  int z_width = 0, z_height = 0, z_descent;
  int rot;
  double trf_scale = trf.vertical_scale(t);
  int idx = int(
      trf_scale * w->zoom_factor_y / w->base_zoom_factor * (text_size + 4) - 4);
  double tsize = trf_scale * w->zoom_factor_y / w->base_zoom_factor
      * (8 + 2 * text_size);
  idx = MIN(idx, DRAW_TYPE_SIZE - 1);
  int highl = highlight;
  if (node)
    highl = ((GrowNode*)node)->highlight;

  if (w == ctx->navw) {
    if (streq(text, ""))
      return;
    highl = 0;
  }

  glow_eFont lfont;
  glow_eDrawType ldraw_type;

  if (node && ((GrowNode*)node)->text_font != glow_eFont_No) {
    lfont = ((GrowNode*)node)->text_font;
    ldraw_type = ((GrowNode*)node)->text_type;
  } else {
    lfont = font;
    ldraw_type = draw_type;
  }

  if (!t) {
    x1 = int(trf.x(p.x, p.y) * w->zoom_factor_x + 0.5) - w->offset_x;
    y1 = int(trf.y(p.x, p.y) * w->zoom_factor_y + 0.5) - w->offset_y;
    rot = (int)trf.rot();
  } else {
    x1 = int(trf.x(t, p.x, p.y) * w->zoom_factor_x + 0.5) - w->offset_x;
    y1 = int(trf.y(t, p.x, p.y) * w->zoom_factor_y + 0.5) - w->offset_y;
    rot = (int)trf.rot(t);
  }
  if (adjustment == glow_eAdjustment_Center)
    rot = rot < 0 ? rot % 360 + 360 : rot % 360;
  else
    rot = 0;

  if (strcmp(text, "")) {
    if (highl || (hot && !node) || adjustment != glow_eAdjustment_Left) {
      ctx->gdraw->get_text_extent(text, strlen(text), ldraw_type, MAX(0, idx),
          lfont, &z_width, &z_height, &z_descent, tsize, rot);
      switch (adjustment) {
      case glow_eAdjustment_Left:
        rx1 = x1;
        ry1 = y1 - (z_height - z_descent);
        break;
      case glow_eAdjustment_Right:
        x1 -= z_width;
        rx1 = x1;
        ry1 = y1 - (z_height - z_descent);
        break;
      case glow_eAdjustment_Center:
        switch (rot) {
        case 90:
          rx1 = x1 - z_width / 2;
          ry1 = y1 - z_height / 2;
          x1 -= z_width / 2;
          y1 += z_height / 2;
          break;
        case 270:
          rx1 = x1 - z_width / 2;
          ry1 = y1 - z_height / 2;
          x1 -= z_width / 2;
          y1 -= z_height / 2 - z_width / 2;
          break;
        default:
          rx1 = x1 - z_width / 2;
          // ry1 = y1 - (z_height-z_descent) + z_height / 2;
          ry1 = y1 - z_height / 2;
          x1 -= z_width / 2;
          y1 += z_height / 2 - z_descent;
        }
        break;
      }
    }

    if (highl) {
      ctx->gdraw->rect(rx1, ry1, z_width, z_height,
          glow_eDrawType_FillHighlight, 0, MAX(1, MIN(idx + hot, 2)));
    } else if (hot && !node) {
      ctx->gdraw->rect(rx1, ry1, z_width, z_height, glow_eDrawType_LineGray,
          0, MAX(MIN(idx, 2), 1));
    }
    if (idx >= 0) {
      glow_eDrawType color = ctx->get_drawtype(color_drawtype,
          glow_eDrawType_LineHighlight, highlight, (GrowNode*)colornode, 2);
      ctx->gdraw->text(x1, y1, text, strlen(text), ldraw_type, color, idx,
          highlight, lfont, tsize, rot);
    }
  } else if (idx >= 0) {
    ctx->gdraw->get_text_extent("A", 1, draw_type, MAX(0, idx), font, &z_width,
        &z_height, &z_descent, tsize, rot);
    ctx->gdraw->rect(x1, y1 - (z_height - z_descent), z_width, z_height,
        glow_eDrawType_LineGray, 0, idx);
  }
}

static glow_eDrawType get_erase_gc(glow_eDrawType gc) {
  if (gc == glow_eDrawType_TextHelvetica) {
    return glow_eDrawType_TextHelveticaErase;
  } else if (gc == glow_eDrawType_TextHelveticaBold) {
    return glow_eDrawType_TextHelveticaEraseBold;
  } else {
    return gc;
  }
}

void GrowText::erase(DrawWind* w, GlowTransform* t, int hot, void* node)
{
  if (!(display_level & ctx->display_level))
    return;
  hot = (w == ctx->navw) ? 0 : hot;
  int x1, y1, rx1 = 0, ry1 = 0;
  int rot;
  double trf_scale = trf.vertical_scale(t);
  int idx = int(
      trf_scale * w->zoom_factor_y / w->base_zoom_factor * (text_size + 4) - 4);
  double tsize = trf_scale * w->zoom_factor_y / w->base_zoom_factor
      * (8 + 2 * text_size);
  idx = MIN(idx, DRAW_TYPE_SIZE - 1);
  int z_width = 0, z_height = 0, z_descent;
  int highl = highlight;
  if (node)
    highl = ((GrowNode*)node)->highlight;

  glow_eFont lfont;
  glow_eDrawType ldraw_type;

  if (node && ((GrowNode*)node)->text_font != glow_eFont_No) {
    lfont = ((GrowNode*)node)->text_font;
    ldraw_type = ((GrowNode*)node)->text_type;
  } else {
    lfont = font;
    ldraw_type = draw_type;
  }

  if (!t) {
    x1 = int(trf.x(p.x, p.y) * w->zoom_factor_x + 0.5) - w->offset_x;
    y1 = int(trf.y(p.x, p.y) * w->zoom_factor_y + 0.5) - w->offset_y;
    rot = (int)trf.rot();
  } else {
    x1 = int(trf.x(t, p.x, p.y) * w->zoom_factor_x + 0.5) - w->offset_x;
    y1 = int(trf.y(t, p.x, p.y) * w->zoom_factor_y + 0.5) - w->offset_y;
    rot = (int)trf.rot(t);
  }
  if (adjustment == glow_eAdjustment_Center)
    rot = rot < 0 ? rot % 360 + 360 : rot % 360;
  else
    rot = 0;

  if (strcmp(text, "")) {
    if (highl || (hot && !node) || adjustment != glow_eAdjustment_Left) {
      ctx->gdraw->get_text_extent(text, strlen(text), ldraw_type, MAX(0, idx),
          lfont, &z_width, &z_height, &z_descent, tsize, rot);
      switch (adjustment) {
      case glow_eAdjustment_Left:
        rx1 = x1;
        ry1 = y1 - (z_height - z_descent);
        break;
      case glow_eAdjustment_Right:
        x1 -= z_width;
        rx1 = x1;
        ry1 = y1 - (z_height - z_descent);
        break;
      case glow_eAdjustment_Center:
        switch (rot) {
        case 90:
          rx1 = x1 - z_width / 2;
          ry1 = y1 - z_height / 2;
          x1 -= z_width / 2;
          y1 += z_height / 2;
          break;
        case 270:
          rx1 = x1 - z_width / 2;
          ry1 = y1 - z_height / 2;
          x1 -= z_width / 2;
          y1 -= z_height / 2 - z_width / 2;
          break;
        default:
          rx1 = x1 - z_width / 2;
          ry1 = y1 - z_height / 2;
          x1 -= z_width / 2;
          y1 += z_height / 2 - z_descent;
        }
        break;
      }
    }

    if (highl) {
      ctx->gdraw->rect(rx1, ry1, z_width, z_height, glow_eDrawType_LineErase,
          0, MAX(1, MIN(idx + hot, 2)));
    } else if (hot && !node) {
      ctx->gdraw->rect(rx1, ry1, z_width, z_height, glow_eDrawType_LineErase,
          0, MAX(1, MIN(idx, 2)));
    }
    if (idx >= 0)
      ctx->gdraw->text(x1, y1, text, strlen(text), get_erase_gc(ldraw_type),
          glow_eDrawType_Line, idx, 0, lfont, tsize, rot);
  } else if (idx >= 0) {
    ctx->gdraw->get_text_extent("A", 1, draw_type, idx, font, &z_width,
        &z_height, &z_descent, tsize, rot);
    ctx->gdraw->rect(x1, y1 - (z_height - z_descent), z_width, z_height,
        glow_eDrawType_LineErase, 0, idx);
  }
}

void GrowText::get_borders(GlowTransform* t, double* x_right, double* x_left,
    double* y_high, double* y_low)
{
  double x, y, ll_x, ur_x, ll_y, ur_y;
  int z_width, z_height, z_descent;
  int rot;

  if (t) {
    x = trf.x(t, p.x, p.y);
    y = trf.y(t, p.x, p.y);
    rot = (int)trf.rot(t);
  } else {
    x = trf.x(p.x, p.y);
    y = trf.y(p.x, p.y);
    rot = (int)trf.rot();
  }
  if (adjustment == glow_eAdjustment_Center)
    rot = rot < 0 ? rot % 360 + 360 : rot % 360;
  else
    rot = 0;

  if (streq(text, ""))
    ctx->gdraw->get_text_extent("A", 1, draw_type, text_size, font, &z_width,
        &z_height, &z_descent,
        ctx->mw->zoom_factor_y / ctx->mw->base_zoom_factor * (8 + 2 * text_size),
        rot);
  else {
    double trf_scale = trf.vertical_scale(t);
    int idx = int(trf_scale * ctx->mw->zoom_factor_y / ctx->mw->base_zoom_factor
            * (text_size + 4)
        - 4);
    double tsize = trf_scale * ctx->mw->zoom_factor_y / ctx->mw->base_zoom_factor
        * (8 + 2 * text_size);
    idx = MAX(0, MIN(idx, DRAW_TYPE_SIZE - 1));

    ctx->gdraw->get_text_extent(text, strlen(text), draw_type, idx, font,
        &z_width, &z_height, &z_descent, tsize, rot);
  }
  switch (adjustment) {
  case glow_eAdjustment_Left:
    ll_x = x;
    ur_x = x + double(z_width) / ctx->mw->zoom_factor_y;
    ll_y = y - double(z_height - z_descent) / ctx->mw->zoom_factor_y;
    ur_y = y + double(z_descent) / ctx->mw->zoom_factor_y;
    break;
  case glow_eAdjustment_Right:
    ur_x = x;
    ll_x = x - double(z_width) / ctx->mw->zoom_factor_y;
    ll_y = y - double(z_height - z_descent) / ctx->mw->zoom_factor_y;
    ur_y = y + double(z_descent) / ctx->mw->zoom_factor_y;
    break;
  case glow_eAdjustment_Center:
    ll_x = x - double(z_width) / ctx->mw->zoom_factor_y / 2;
    ur_x = x + double(z_width) / ctx->mw->zoom_factor_y / 2;
    ll_y = y - double(z_height) / ctx->mw->zoom_factor_y / 2;
    ur_y = y + double(z_height) / ctx->mw->zoom_factor_y / 2;
    break;
  }

  if (display_level != glow_mDisplayLevel_1)
    return;
  if (ll_x < *x_left)
    *x_left = ll_x;
  if (ur_x > *x_right)
    *x_right = ur_x;
  if (ll_y < *y_low)
    *y_low = ll_y;
  if (ur_y > *y_high)
    *y_high = ur_y;
}

void GrowText::set_transform(GlowTransform* t)
{
  trf = *t * trf;
  get_node_borders();
}

void GrowText::set_text(char* new_text)
{
  free(text);
  text = (char*)malloc(strlen(new_text) + 1);
  strcpy(text, new_text);
  get_node_borders();

  ctx->set_dirty();
}

void GrowText::set_textsize(int size)
{
  text_size = size;
  get_node_borders();
  ctx->set_dirty();
}

void GrowText::set_textbold(int bold)
{
  if ((bold && draw_type == glow_eDrawType_TextHelveticaBold)
      || (!bold && draw_type == glow_eDrawType_TextHelvetica))
    return;

  if (bold)
    draw_type = glow_eDrawType_TextHelveticaBold;
  else
    draw_type = glow_eDrawType_TextHelvetica;
  get_node_borders();
  ctx->set_dirty();
}

void GrowText::set_textfont(glow_eFont textfont)
{
  font = textfont;
  get_node_borders();
  ctx->set_dirty();
}

void GrowText::export_javabean(GlowTransform* t, void* node,
    glow_eExportPass pass, int* shape_cnt, int node_cnt, int in_nc,
    std::ofstream& fp)
{
  int x1, y1;
  int z_width, z_height, z_descent;
  int rot;
  int bold;
  double trf_scale = trf.vertical_scale(t);
  int idx = int(trf_scale * ctx->mw->zoom_factor_y / ctx->mw->base_zoom_factor
          * (text_size + 4)
      - 4);
  idx = MIN(idx, DRAW_TYPE_SIZE - 1);
  double tsize = trf_scale * ctx->mw->zoom_factor_y / ctx->mw->base_zoom_factor
      * (8 + 2 * text_size);

  glow_eFont lfont;
  glow_eDrawType ldraw_type;

  if (node && ((GrowNode*)node)->text_font != glow_eFont_No) {
    lfont = ((GrowNode*)node)->text_font;
    ldraw_type = ((GrowNode*)node)->text_type;
  } else {
    lfont = font;
    ldraw_type = draw_type;
  }

  if (!t) {
    x1 = int(trf.x(p.x, p.y) * ctx->mw->zoom_factor_x) - ctx->mw->offset_x;
    y1 = int(trf.y(p.x, p.y) * ctx->mw->zoom_factor_y) - ctx->mw->offset_y;
    rot = (int)trf.rot();
  } else {
    x1 = int(trf.x(t, p.x, p.y) * ctx->mw->zoom_factor_x) - ctx->mw->offset_x;
    y1 = int(trf.y(t, p.x, p.y) * ctx->mw->zoom_factor_y) - ctx->mw->offset_y;
    rot = (int)trf.rot(t);
  }
  if (adjustment == glow_eAdjustment_Center)
    rot = rot < 0 ? rot % 360 + 360 : rot % 360;
  else
    rot = 0;

  ctx->gdraw->get_text_extent(text, strlen(text), ldraw_type, MAX(0, idx),
      lfont, &z_width, &z_height, &z_descent, tsize, rot);
  switch (adjustment) {
  case glow_eAdjustment_Left:
    break;
  case glow_eAdjustment_Right:
    x1 -= z_width;
    break;
  case glow_eAdjustment_Center:
    switch (rot) {
    case 90:
      x1 -= z_width / 2 - z_descent;
      y1 -= z_height / 2;
      break;
    case 270:
      x1 += z_width / 2 - z_descent;
      y1 += z_height / 2;
      break;
    case 180:
      x1 += z_width / 2;
      y1 -= z_height / 2 - z_descent;
      break;
    default:
      x1 -= z_width / 2;
      y1 += z_height / 2 - z_descent;
    }
    break;
  }

  bold = (draw_type == glow_eDrawType_TextHelveticaBold);

  ctx->export_jbean->text(x1, y1, text, draw_type, color_drawtype, bold, idx,
      rot, pass, shape_cnt, node_cnt, fp);
}

void GrowText::flip(double x0, double y0, glow_eFlipDirection dir)
{
  switch (dir) {
  case glow_eFlipDirection_Horizontal:
    trf.store();
    set_scale(1, -1, x0, y0, glow_eScaleType_FixPoint);
    break;
  case glow_eFlipDirection_Vertical:
    trf.store();
    set_scale(-1, 1, x0, y0, glow_eScaleType_FixPoint);
    break;
  }
}

void GrowText::align(double x, double y, glow_eAlignDirection direction)
{
  double dx, dy;

  ctx->set_dirty();
  switch (direction) {
  case glow_eAlignDirection_CenterVert:
    dx = x - (x_right + x_left) / 2;
    dy = 0;
    break;
  case glow_eAlignDirection_CenterHoriz:
    dx = 0;
    dy = y - (y_high + y_low) / 2;
    break;
  case glow_eAlignDirection_CenterCenter:
    dx = x - (x_right + x_left) / 2;
    dy = y - (y_high + y_low) / 2;
    break;
  case glow_eAlignDirection_Right:
    dx = x - x_right;
    dy = 0;
    break;
  case glow_eAlignDirection_Left:
    dx = x - x_left;
    dy = 0;
    break;
  case glow_eAlignDirection_Up:
    dx = 0;
    dy = y - y_high;
    break;
  case glow_eAlignDirection_Down:
    dx = 0;
    dy = y - y_low;
    break;
  }
  trf.move(dx, dy);
  x_right += dx;
  x_left += dx;
  y_high += dy;
  y_low += dy;
}

void GrowText::convert(glow_eConvert version)
{
  if (version == glow_eConvert_V34)
    draw_type = GlowColor::convert(version, draw_type);
}

void GrowText::export_flow(GlowExportFlow* ef)
{
  ef->text(this);
}
