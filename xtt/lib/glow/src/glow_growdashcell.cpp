/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <iostream>

#include "co_string.h"

#include "glow_growdashcell.h"
#include "glow_draw.h"
#include "glow_nodegroup.h"
#include "glow_dashboard.h"
#include "glow_msg.h"

GrowDashCell::GrowDashCell(
    GrowCtx* glow_ctx, const char* name, double x, double y, double w, double h, 
    glow_eDrawType border_color, int nodraw)
  : GrowGroup(glow_ctx, name), cell_rows(1), cell_columns(1)
{
  if (ctx->dashboard)
    ctx->dash->find_grid(x - 0.5 * ctx->dash_cell_width, y - 0.5 * ctx->dash_cell_height, &x, &y);

  object_type = glow_eObjectType_GrowDashCell;
  nc = new GlowNodeGroup(glow_ctx, name);
  frame = new GrowRect(glow_ctx, "R1", x, y, w, h, 
      border_color, 1, 0, glow_mDisplayLevel_1, 0, 1,
      0, glow_eCtColor_ButtonFillcolor, nodraw);
  get_node_borders();
  cell_rows_old = cell_rows;
  cell_columns_old = cell_columns;
}

GrowDashCell::GrowDashCell(GrowCtx* glow_ctx, const char* name)
  : GrowGroup(glow_ctx, name), cell_rows(1), cell_columns(1)
{
  object_type = glow_eObjectType_GrowDashCell;
}

GrowDashCell::~GrowDashCell()
{
  delete frame;
}

void GrowDashCell::copy_from(const GrowDashCell& n)
{
  memcpy((void *)this, (void *)&n, sizeof(n));
  if (n.dynamicsize) {
    dynamic = (char*)calloc(1, n.dynamicsize);
    memcpy(dynamic, n.nc->dynamic, n.dynamicsize);
  }
  // Get unique name
  sprintf(n_name, "Grp%d_", ((GrowCtx*)ctx)->objectname_cnt++);

  nc = new GlowNodeGroup((GlowNodeGroup&)*n.nc);
  nc->a.set_parent(this);

  if (ctx->userdata_copy_callback)
    (ctx->userdata_copy_callback)(
        this, user_data, &user_data, glow_eUserdataCbType_Node);
  frame = new GrowRect(*n.frame);
}

void GrowDashCell::save(std::ofstream& fp, glow_eSaveMode mode)
{
  fp << int(glow_eSave_GrowDashCell) << '\n';
  fp << int(glow_eSave_GrowDashCell_cell_rows) << FSPACE << cell_rows << '\n';
  fp << int(glow_eSave_GrowDashCell_cell_columns) << FSPACE << cell_columns << '\n';
  fp << int(glow_eSave_GrowDashCell_group_part) << '\n';
  GrowGroup::save(fp, mode);
  fp << int(glow_eSave_GrowDashCell_frame) << '\n';
  frame->save(fp, mode);
#if 0
  if (user_data && ctx->userdata_save_callback) {
    fp << int(glow_eSave_GrowDashCell_userdata_cb) << '\n';
    (ctx->userdata_save_callback)(&fp, this, glow_eUserdataCbType_Node);
  }
#endif
  fp << int(glow_eSave_End) << '\n';
}

void GrowDashCell::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GrowDashCell: \"%d %s\"\n", type, dummy);
    }

    fp >> type;
    switch (type) {
    case glow_eSave_GrowDashCell:
      break;
    case glow_eSave_GrowDashCell_cell_rows:
      fp >> cell_rows;
      break;
    case glow_eSave_GrowDashCell_cell_columns:
      fp >> cell_columns;
      break;
    case glow_eSave_GrowDashCell_group_part:
      GrowGroup::open(fp);
      break;
    case glow_eSave_GrowDashCell_frame:
      frame = new GrowRect(ctx, "");
      frame->open(fp);
      break;
#if 0
    case glow_eSave_GrowDashCell_userdata_cb:
      if (ctx->userdata_open_callback)
        (ctx->userdata_open_callback)(&fp, this, glow_eUserdataCbType_Node);
      break;
#endif
    case glow_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GrowDashCell:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
  cell_rows_old = cell_rows;
  cell_columns_old = cell_columns;
}

void GrowDashCell::update_attributes()
{
  if (cell_rows != cell_rows_old || cell_columns != cell_columns_old) {
    erase(&ctx->mw, (GlowTransform*)NULL, hot, NULL);
    erase(&ctx->navw, (GlowTransform*)NULL, hot, NULL);

    frame->ur.x = frame->ll.x + cell_columns * ctx->dash_cell_width;
    frame->ur.y = frame->ll.y + cell_rows * ctx->dash_cell_height;
    cell_rows_old = cell_rows;
    cell_columns_old = cell_columns;
    get_node_borders();
    ctx->draw(&ctx->mw,
        x_left * ctx->mw.zoom_factor_x - ctx->mw.offset_x - DRAW_MP,
        y_low * ctx->mw.zoom_factor_y - ctx->mw.offset_y - DRAW_MP,
        x_right * ctx->mw.zoom_factor_x - ctx->mw.offset_x + DRAW_MP,
        y_high * ctx->mw.zoom_factor_y - ctx->mw.offset_y + DRAW_MP);
    ctx->draw(&ctx->navw,
        x_left * ctx->navw.zoom_factor_x - ctx->navw.offset_x - 1,
        y_low * ctx->navw.zoom_factor_y - ctx->navw.offset_y - 1,
        x_right * ctx->navw.zoom_factor_x - ctx->navw.offset_x + 1,
        y_high * ctx->navw.zoom_factor_y - ctx->navw.offset_y + 1);
  }
}

void GrowDashCell::get_node_borders()
{
  x_left = y_low = 1e37;
  x_right = y_high = -1e37;
  get_borders(0, &x_right, &x_left, &y_high, &y_low);
}

void GrowDashCell::get_borders(GlowTransform* t, double* x1_right, double* x1_left,
    double* y1_high, double* y1_low)
{
  if (t) {
    GlowTransform t2 = *t * trf;
    frame->get_borders(&t2, x1_right, x1_left, y1_high, y1_low);
  } else
    frame->get_borders(&trf, x1_right, x1_left, y1_high, y1_low);
}

void GrowDashCell::draw(GlowWind* w, GlowTransform* t, int highlight, int hot,
    void* node, void* colornode)
{
  if (w == &ctx->navw) {
    if (ctx->no_nav)
      return;
    hot = 0;
  }
  if (node && !root_node && node != (void*)this)
    root_node = (GrowNode*)node;

  w->set_draw_buffer_only();
  GrowGroup::draw(w, t, highlight, hot, node, colornode);
  if (!node)
    node = (void*)this;
  if (!colornode)
    colornode = (void*)this;
  else if (((GrowNode*)colornode)->fill_drawtype == glow_eDrawType_No
      && ((GrowNode*)colornode)->color_tone == glow_eDrawTone_No)
    colornode = (void*)this;

  if (t) {
    GlowTransform t2 = *t * trf;
    frame->draw(w, &t2, highlight, hot, node, colornode);
  } else
    frame->draw(w, &trf, highlight, hot, node, colornode);

  w->reset_draw_buffer_only();

}

void GrowDashCell::erase(GlowWind* w, GlowTransform* t, int hot, void* node)
{
  w->set_draw_buffer_only();
  if (t) {
    GlowTransform t2 = *t * trf;
    frame->erase(w, &t2, hot, node);
  } else
    frame->erase(w, &trf, hot, node);
  w->reset_draw_buffer_only();
}

int GrowDashCell::local_event_handler(glow_eEvent event, double x, double y)
{
  if (frame->ll.x <= x && x <= frame->ur.x && frame->ll.y <= y && y <= frame->ur.y) {
    return 1;
  } else
    return 0;
}

int GrowDashCell::event_handler(
    GlowWind* w, glow_eEvent event, double fx, double fy)
{
  if (ctx->environment == glow_eEnv_Development) {
    double x, y;

    trf.reverse(fx, fy, &x, &y);
    return local_event_handler(event, x, y);
  }
  else
    return GrowGroup::event_handler(w, event, fx, fy);
}

int GrowDashCell::event_handler(
    GlowWind* w, glow_eEvent event, int x, int y, double fx, double fy)
{
  if (ctx->trace_started) {
    int sts;

    nc->recursive_trace = 1;
    sts = GrowNode::event_handler(w, event, x, y, fx, fy);
    if (sts && ctx->callback_object && 
	ctx->callback_object->type() == glow_eObjectType_GrowSlider) {
      ctx->move_insert(ctx->callback_object);
      ((GrowNode *)ctx->callback_object)->store_position();
      ctx->callback_object = 0;
      ctx->callback_object_type = (glow_eObjectType)0;
    }
    return sts;
  }
  if (ctx->environment == glow_eEnv_Development) {
    int sts;
    double rx, ry;

    // Convert coordinates to local koordinates
    trf.reverse(fx, fy, &rx, &ry);

    sts = 0;
    if (event == ctx->event_move_node) {
      sts = local_event_handler(event, rx, ry);
      if (sts) {
	/* Register node for potential movement */
	ctx->move_insert(this);
      }
      return sts;
    }

    // Check if any menue is active
    if (nc->a.a_size && nc->a[nc->a.a_size - 1]->type() == glow_eObjectType_GrowMenu) {
      for (int i = nc->a.a_size - 1; i >= 0; i--) {
	if (nc->a[i]->type() != glow_eObjectType_GrowMenu)
	  break;
	switch (event) {
	case glow_eEvent_CursorMotion:
	  sts = nc->a[i]->event_handler(&ctx->mw, event, x, y, fx, fy);
	  break;
	default:;
	}
      }
      switch (event) {
      case glow_eEvent_CursorMotion:
	return 1;
      case glow_eEvent_MB1Down:
      case glow_eEvent_MB1Up:
      case glow_eEvent_MB1Click:
      case glow_eEvent_Key_Return:
	sts = nc->a[nc->a.a_size - 1]->event_handler(&ctx->mw, event, x, y, fx, fy);
	if (sts == GLOW__TERMINATED || sts == GLOW__DESTROYED)
	  return sts;
	else if (sts)
	  return 1;
	break;
      case glow_eEvent_Key_Right:
      case glow_eEvent_Key_Left:
      case glow_eEvent_Key_Up:
      case glow_eEvent_Key_Down:
      case glow_eEvent_Key_BackSpace:
      case glow_eEvent_Key_Tab:
      case glow_eEvent_Key_ShiftTab:
      case glow_eEvent_Key_Escape:
      case glow_eEvent_Key_Ascii:
      case glow_eEvent_Exposure:
	break;
      default:;
	return 0;
      }
    }


    switch (event) {
    case glow_eEvent_CursorMotion: {
      int redraw = 0;
      
      if (ctx->hot_mode == glow_eHotMode_TraceAction)
	sts = 0;
      else if (ctx->hot_found)
	sts = 0;
      else {
	sts = local_event_handler(event, rx, ry);
	if (sts)
	  ctx->hot_found = 1;
      }
      if (sts && !hot
	  && !(ctx->node_movement_active || ctx->node_movement_paste_active)
	  && ctx->hot_mode != glow_eHotMode_Disabled) {
	ctx->gdraw->set_cursor(w, glow_eDrawCursor_CrossHair);
	hot = 1;
	redraw = 1;
      }
      if (!sts && hot) {
	if (!ctx->hot_found)
	  ctx->gdraw->set_cursor(w, glow_eDrawCursor_Normal);
	//erase(w);
	hot = 0;
	redraw = 1;
      }
      if (redraw) {
	ctx->draw(w, x_left * w->zoom_factor_x - w->offset_x - DRAW_MP,
		  y_low * w->zoom_factor_y - w->offset_y - DRAW_MP,
		  x_right * w->zoom_factor_x - w->offset_x + DRAW_MP,
		  y_high * w->zoom_factor_y - w->offset_y + DRAW_MP);
      }
      break;
    }
    default:
      sts = local_event_handler(event, rx, ry);
    }
    if (sts)
      ctx->register_callback_object(glow_eObjectType_Node, this);
    return sts;
  }
  else
    return GrowGroup::event_handler(w, event, x, y, fx, fy);
}

void GrowDashCell::get_info(int *rows, int *columns)
{
  *rows = cell_rows;
  *columns = cell_columns;
}

int GrowDashCell::insert(GlowArrayElem* element)
{
  int sts;
  GlowTransform t;
  trf.pos_inverse(&t);
  //element->dash_insert(&t);
  element->set_transform(&t);
  ctx->a.remove(element);
  
  sts = nc->a.insert(element);
  if (ODD(sts))
    element->parent = this;
  return sts;
}

int GrowDashCell::trace_init()
{
  nc->a.trace_init();
  return 1;
}

void GrowDashCell::convert(glow_eConvert version)
{
  switch (version) {
  case glow_eConvert_V34: {
    break;
  }
  }
}

