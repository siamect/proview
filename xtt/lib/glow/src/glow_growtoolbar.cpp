/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <iostream>

#include "co_string.h"

#include "glow_growtoolbar.h"
#include "glow_draw.h"
#include "glow_nodegroup.h"
#include "glow_msg.h"

#define TOOLBAR_SPACING 0.2

GrowToolbar::GrowToolbar(GrowCtx* glow_ctx, const char* name,
    const char* nc_name, char* tools1, char* tools2, int tools1_cnt,
    int tools2_cnt, double x, double y, int nodraw)
    : GrowNode(glow_ctx, name, 0, x, y, nodraw, 0), hot_tool(0), tools1_mask(0),
      tools2_mask(0)
{
  int sts;

  object_type = glow_eObjectType_GrowToolbar;
  if (tools1_cnt == 0 && tools2_cnt == 0)
    return;

  sts = ctx->find_nc_by_name(nc_name, (GlowArrayElem**)&nc);
  if (EVEN(sts)) {
    // Create the nodeclass
    nc = new GlowNodeClass(glow_ctx, name);

    configure(tools1, tools2, tools1_cnt, tools2_cnt, 31, 15, 0, 0);

    ctx->nodeclass_insert(nc);
  }

  get_node_borders();
}

GrowToolbar::~GrowToolbar()
{
  erase(&ctx->mw);
  erase(&ctx->navw);

  ctx->set_defered_redraw();
  ctx->delete_node_cons(this);
  ctx->draw(&ctx->mw,
      x_left * ctx->mw.zoom_factor_x - ctx->mw.offset_x - DRAW_MP,
      y_low * ctx->mw.zoom_factor_y - ctx->mw.offset_y - DRAW_MP,
      x_right * ctx->mw.zoom_factor_x - ctx->mw.offset_x + DRAW_MP,
      y_high * ctx->mw.zoom_factor_y - ctx->mw.offset_y + DRAW_MP);
  ctx->draw(&ctx->navw,
      x_left * ctx->navw.zoom_factor_x - ctx->navw.offset_x - 1,
      y_low * ctx->navw.zoom_factor_y - ctx->navw.offset_y - 1,
      x_right * ctx->navw.zoom_factor_x - ctx->navw.offset_x + 1,
      y_high * ctx->navw.zoom_factor_y - ctx->navw.offset_y + 1);
  ctx->redraw_defered();
  if (hot)
    ctx->gdraw->set_cursor(&ctx->mw, glow_eDrawCursor_Normal);
}

void GrowToolbar::copy_from(const GrowToolbar& n)
{
  memcpy((void *)this, (void *)&n, sizeof(n));
  if (n.dynamicsize) {
    dynamic = (char*)calloc(1, n.dynamicsize);
    memcpy(dynamic, n.nc->dynamic, n.dynamicsize);
  }
  if (ctx->userdata_copy_callback)
    (ctx->userdata_copy_callback)(
        this, user_data, &user_data, glow_eUserdataCbType_Node);

  ctx->a_nc.remove(nc);
  ctx->nodeclass_insert(nc);
}

void GrowToolbar::ungroup()
{
  nc->a.set_last_group(n_name);
  ((GlowNodeGroup*)nc)->ungroup(&trf);
}

void GrowToolbar::save(std::ofstream& fp, glow_eSaveMode mode)
{
  fp << int(glow_eSave_GrowToolbar) << '\n';
  fp << int(glow_eSave_GrowToolbar_grownode_part) << '\n';
  GrowNode::save(fp, mode);
  // fp << int(glow_eSave_GrowToolbar_nc) << '\n';
  // ((GlowNodeGroup *)nc)->save( fp, mode);
  fp << int(glow_eSave_End) << '\n';
}

void GrowToolbar::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GrowToolbar: \"%d %s\"\n", type, dummy);
    }

    fp >> type;
    switch (type) {
    case glow_eSave_GrowToolbar:
      break;
    case glow_eSave_GrowToolbar_grownode_part:
      GrowNode::open(fp);
      break;
    // case glow_eSave_GrowToolbar_nc:
    // nc = new GlowNodeGroup( ctx, n_name);
    // nc->open( fp);
    // break;
    case glow_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GrowToolbar:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GrowToolbar::trace_scan()
{
  int sts;

  if (trace.p && ctx->trace_scan_func) {
    sts = ctx->trace_scan_func((void*)this, trace.p);
    if (sts == GLOW__TERMINATED || sts == GLOW__SUBTERMINATED
        || sts == GLOW__SWAPTERMINATED)
      return sts;
  }
  return nc->a.trace_scan();
}

int GrowToolbar::trace_init()
{
  int sts;

  //  if ( !streq( trace.data[0], ""))
  sts = ctx->trace_connect_func((void*)this, &trace);

  nc->a.trace_init();
  return sts;
}

void GrowToolbar::trace_close()
{
  if (trace.p)
    ctx->trace_disconnect_func((void*)this);

  nc->a.trace_close();
}

GlowArrayElem* GrowToolbar::get_node_from_name(char* name)
{
  int i;

  for (i = 0; i < nc->a.a_size; i++) {
    if ((nc->a.a[i]->type() == glow_eObjectType_Node
            || nc->a.a[i]->type() == glow_eObjectType_GrowNode
            || nc->a.a[i]->type() == glow_eObjectType_GrowConGlue)
        && streq(((GlowNode*)nc->a.a[i])->n_name, name))
      return nc->a.a[i];
    else if (nc->a.a[i]->type() == glow_eObjectType_GrowToolbar) {
      GlowArrayElem* n = ((GrowToolbar*)nc->a.a[i])->get_node_from_name(name);
      if (n)
        return n;
    }
  }
  return 0;
}

void GrowToolbar::call_redraw_node_cons()
{
  ctx->redraw_node_cons(this);

  for (int i = 0; i < nc->a.a_size; i++) {
    nc->a.a[i]->call_redraw_node_cons();
  }
}

void GrowToolbar::link_insert(void** start)
{
  for (int i = 0; i < nc->a.a_size; i++) {
    if (nc->a[i]->type() == glow_eObjectType_Node
        || nc->a[i]->type() == glow_eObjectType_GrowNode
        || nc->a[i]->type() == glow_eObjectType_GrowToolbar)
      nc->a.a[i]->link_insert(start);
  }
}

void GrowToolbar::convert(glow_eConvert version)
{
  switch (version) {
  case glow_eConvert_V34: {
    // Conversion of colors
    GrowNode::convert(version);
    for (int i = 0; i < nc->a.a_size; i++) {
      nc->a.a[i]->convert(version);
    }

    break;
  }
  }
}

void GrowToolbar::set_rootnode(void* node)
{
  nc->a.set_rootnode(node);
}

int GrowToolbar::event_handler(
    GlowWind* w, glow_eEvent event, double fx, double fy)
{
  double x, y;
  int sts;

  if (invisible || dimmed)
    return 0;

  if (!ctx->trace_started)
    return GrowNode::event_handler(w, event, fx, fy);

  trf.reverse(fx, fy, &x, &y);
  sts = nc->event_handler(w, event, x, y);
  if (ctx->trace_started && sts) {
    // Register group members with click action
    if (is_sensitive())
      ctx->register_callback_object(glow_eObjectType_Node, this);
  }
  return sts;
}

int GrowToolbar::event_handler(
    GlowWind* w, glow_eEvent event, int x, int y, double fx, double fy)
{
  int sts, lsts;
  int hot_type;
  int idx = 0, mask_idx, category;
  double rx, ry;

  if (invisible || dimmed)
    return 0;

  if (!ctx->trace_started)
    return GrowNode::event_handler(w, event, x, y, fx, fy);

  switch (event) {
  case glow_eEvent_Key_Right:
  case glow_eEvent_Key_Left:
  case glow_eEvent_Key_BackSpace:
  case glow_eEvent_Key_Return:
  case glow_eEvent_Key_Ascii:
  case glow_eEvent_Key_Up:
  case glow_eEvent_Key_Down:
    return 0;
  default:;
  }

  // Convert koordinates to local koordinates
  trf.reverse(fx, fy, &rx, &ry);

  sts = 0;
  if (event == ctx->event_move_node) {
    sts = nc->event_handler(w, event, rx, ry);
    if (sts) {
      /* Register node for potential movement */
      ctx->move_insert(this);
      store_position();
    }
    return sts;
  } else if (event == ctx->event_create_con) {
    return sts;
  }
  switch (event) {
  case glow_eEvent_MB1Down:
    if (ctx->trace_started) {
      sts = nc_event_handler(w, event, rx, ry, &idx);
      if (sts)
        ((GrowNode*)nc->a.a[idx])->set_color_inverse(1);
    }
    break;
  case glow_eEvent_MB1Up:
    if (ctx->trace_started) {
      sts = nc_event_handler(w, event, rx, ry, &idx);
      if (sts)
        ((GrowNode*)nc->a.a[idx])->set_color_inverse(0);
    }
    break;
  case glow_eEvent_CursorMotion: {
    int redraw = 0;

    if (ctx->hot_mode == glow_eHotMode_TraceAction) {
      if (ctx->hot_found)
        sts = 0;
      else {
        if (is_sensitive()) {
          sts = nc_event_handler(w, event, rx, ry, &idx);
          if (sts) {
            ((GrowNode*)nc->a.a[idx])->set_hot(1);
            redraw = 1;
            ctx->hot_found = 1;
          }
        }
      }
    } else {
      if (ctx->hot_found)
        sts = 0;
      else {
        sts = nc_event_handler(w, event, rx, ry, &idx);
        if (sts)
          ctx->hot_found = 1;
      }
    }
    if (sts && !hot
        && !(ctx->node_movement_active || ctx->node_movement_paste_active)) {
      if ((hot_type = ctx->send_hot_request(this))) {
        if (!ctx->trace_started) {
          ctx->gdraw->set_cursor(w, glow_eDrawCursor_CrossHair);
          hot = 1;
          redraw = 1;
          ctx->tiptext_event(this, x, y);
        } else if (hot_type & glow_mHotType_CursorCrossHair) {
          ctx->gdraw->set_cursor(w, glow_eDrawCursor_CrossHair);
          hot_tool = idx + 1;
          lsts = get_mask_index(idx, &category, &mask_idx);
          if (ODD(lsts))
            ctx->tiptext_toolbar_event(this, x, y, category, mask_idx);
          redraw = 1;
        } else if (hot_type & glow_mHotType_CursorHand) {
          ctx->gdraw->set_cursor(w, glow_eDrawCursor_Hand);
          hot_tool = idx + 1;
          lsts = get_mask_index(idx, &category, &mask_idx);
          if (ODD(lsts))
            ctx->tiptext_toolbar_event(this, x, y, category, mask_idx);
          redraw = 1;
        }
      }
    }
    if (!sts
        && ((!ctx->trace_started && hot) || (ctx->trace_started && hot_tool))) {
      if (!ctx->hot_found)
        ctx->gdraw->set_cursor(w, glow_eDrawCursor_Normal);
      if (root_node)
        root_node->erase(w);
      else
        erase(w);
      if (hot_tool)
        ((GrowNode*)nc->a.a[hot_tool - 1])->set_hot(0);
      hot_tool = 0;
      hot = 0;
      redraw = 1;
      ctx->tiptext->remove_text(this);
    }
    if (redraw) {
      draw();
    }
    break;
  }
  case glow_eEvent_MB1Click:
    sts = nc_event_handler(w, event, rx, ry, &idx);
    if (sts) {
      lsts = get_mask_index(idx, &category, &mask_idx);
      if (ODD(lsts))
        ((GrowCtx*)ctx)
            ->send_toolbar_callback(this, event, fx, fy, category, mask_idx);
    }
    break;
  default:
    sts = nc_event_handler(w, event, rx, ry, &idx);
  }

  return sts;
}

int GrowToolbar::nc_event_handler(
    GlowWind* w, glow_eEvent event, double x, double y, int* idx)
{
  int i;
  int sts;

  for (i = 0; i < nc->a.a_size; i++) {
    sts = ((GrowNode*)nc->a.a[i])->event_handler(w, event, x, y);
    if (sts) {
      *idx = i;
      return sts;
    }
  }
  return 0;
}

void GrowToolbar::configure(char* tools1, char* tools2, int tools1_cnt,
    int tools2_cnt, unsigned int show_mask1, unsigned int show_mask2,
    unsigned int insensitive_mask1, unsigned int insensitive_mask2)
{
  double x1, y1;
  double ll_x, ll_y, ur_x, ur_y;

  GlowNodeClass* nc1;
  char subg_name[80];
  unsigned int mask;
  int sts;

  x1 = 0;
  y1 = 0;

  // Clear nc
  for (int i = 0; i < nc->a.size(); i++) {
    GlowArrayElem* e = nc->a.a[i];
    nc->a.remove(e);
    delete e;
    i--;
  }

  tools1_mask = 0;
  mask = 1;
  for (int i = 0; i < tools1_cnt; i++) {
    if (mask & show_mask1) {
      if (streq(&tools1[i * 80], "")) {
        mask = mask << 1;
        continue;
      }

      strcpy(subg_name, &tools1[i * 80]);

      sts = ctx->find_nc_by_name(subg_name, (GlowArrayElem**)&nc1);
      if (EVEN(sts)) {
        char fname[120];
        sprintf(fname, "$pwr_exe/%s.pwsg", subg_name);
        sts = ctx->open_subgraph(fname, glow_eSaveMode_SubGraph);
        if (ODD(sts))
          sts = ctx->find_nc_by_name(subg_name, (GlowArrayElem**)&nc1);
      }
      if (ODD(sts)) {
        GrowNode* n1;
        n1 = new GrowNode(ctx, subg_name, (GlowNodeClass*)nc1, x1, y1);
        n1->disable_callback();
        nc->insert(n1);

        if (mask & insensitive_mask1)
          n1->set_visibility(glow_eVis_Dimmed);

        n1->measure(&ll_x, &ll_y, &ur_x, &ur_y);
        x1 += ur_x - ll_x + TOOLBAR_SPACING;
        tools1_mask |= mask;
      }
    }
    mask = mask << 1;
  }
  if (!feq(x1, 0.0))
    x1 += TOOLBAR_SPACING * 2;

  tools2_mask = 0;
  mask = 1;
  for (int i = 0; i < tools2_cnt; i++) {
    if (mask & show_mask2) {
      if (streq(&tools2[i * 80], "")) {
        mask = mask << 1;
        continue;
      }

      strcpy(subg_name, &tools2[i * 80]);

      sts = ctx->find_nc_by_name(subg_name, (GlowArrayElem**)&nc1);
      if (EVEN(sts)) {
        char fname[120];
        sprintf(fname, "$pwr_exe/%s.pwsg", subg_name);
        sts = ctx->open_subgraph(fname, glow_eSaveMode_SubGraph);
        if (ODD(sts))
          sts = ctx->find_nc_by_name(subg_name, (GlowArrayElem**)&nc1);
      }
      if (ODD(sts)) {
        GrowNode* n1;
        n1 = new GrowNode(ctx, subg_name, (GlowNodeClass*)nc1, x1, y1);
        n1->disable_callback();
        nc->insert(n1);

        if (mask & insensitive_mask2)
          n1->set_visibility(glow_eVis_Dimmed);

        n1->measure(&ll_x, &ll_y, &ur_x, &ur_y);
        x1 += ur_x - ll_x + TOOLBAR_SPACING;
        tools2_mask |= mask;
      }
    }
    mask = mask << 1;
  }

  get_node_borders();
  scale();

  // Move the nc to after the methodbuttons nodeclasses, or they will be deleted
  // in the wrong order
  // when when deleted
  ctx->a_nc.remove(nc);
  ctx->nodeclass_insert(nc);
}

int GrowToolbar::get_mask_index(int idx, int* category, int* mask_idx)
{
  // Calculate category and index
  unsigned int mask;
  int cnt = 0;
  int i;
  for (i = 0; i < 64; i++) {
    if (i < 32)
      mask = 1 << i;
    else
      mask = 1 << (i - 32);
    if ((i < 32 && tools1_mask & mask) || (i >= 32 && tools2_mask & mask))
      cnt++;
    if (cnt == idx + 1) {
      *mask_idx = i % 32;
      *category = i / 32 + 1;
      return 1;
    }
  }
  return 0;
}

void GrowToolbar::scale()
{
  double scale;

  if (ctx->mw.window_width == 0)
    return;

  if (x_right * ctx->mw.zoom_factor_x - ctx->mw.offset_x
      > ctx->mw.window_width) {
    scale = (ctx->mw.window_width
                - (x_left * ctx->mw.zoom_factor_x - ctx->mw.offset_x) - 10)
        / ((x_right - x_left) * ctx->mw.zoom_factor_x);

    trf.scale(scale, 1, x_left, y_low);
    get_node_borders();
  }
}
