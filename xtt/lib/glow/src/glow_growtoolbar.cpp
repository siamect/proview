/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2014 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

#include "glow_std.h"


#include <iostream>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include "glow_growtoolbar.h"
#include "glow_draw.h"
#include "glow_growctx.h"
#include "glow_nodegroup.h"

#define TOOLBAR_SPACING 0.2

GrowToolbar::GrowToolbar( GrowCtx *glow_ctx, const char *name, const char *nc_name, 
			  char *tools1, char *tools2, int tools1_cnt, int tools2_cnt,
			  double x, double y, int nodraw) :
  GrowNode(glow_ctx,name,0,x,y,nodraw,0), hot_tool(0), tools1_mask(0), tools2_mask(0)
{
  int sts;

  object_type = glow_eObjectType_GrowToolbar;
  if ( tools1_cnt == 0 && tools2_cnt == 0)
    return;

  sts = ctx->find_nc_by_name( nc_name, (GlowArrayElem **)&nc);
  if ( EVEN(sts)) {
    // Create the nodeclass
    nc = new GlowNodeClass( glow_ctx, name);

    configure( tools1, tools2, tools1_cnt, tools2_cnt, 31, 15, 0, 0);

    ctx->nodeclass_insert( nc);
  }

  get_node_borders();
}

GrowToolbar::~GrowToolbar()
{
  erase( &ctx->mw);
  erase( &ctx->navw);

  ctx->set_defered_redraw();
  ctx->delete_node_cons( this);
  ctx->draw( &ctx->mw, x_left * ctx->mw.zoom_factor_x - ctx->mw.offset_x - DRAW_MP,
	     y_low * ctx->mw.zoom_factor_y - ctx->mw.offset_y - DRAW_MP,
  	     x_right * ctx->mw.zoom_factor_x - ctx->mw.offset_x + DRAW_MP,
	     y_high * ctx->mw.zoom_factor_y - ctx->mw.offset_y + DRAW_MP);
  ctx->draw( &ctx->navw, x_left * ctx->navw.zoom_factor_x - ctx->navw.offset_x - 1,
	     y_low * ctx->navw.zoom_factor_y - ctx->navw.offset_y - 1,
  	     x_right * ctx->navw.zoom_factor_x - ctx->navw.offset_x + 1,
	     y_high * ctx->navw.zoom_factor_y - ctx->navw.offset_y + 1);
  ctx->redraw_defered();
  if ( hot)
    ctx->gdraw->set_cursor( &ctx->mw, glow_eDrawCursor_Normal);

}

void GrowToolbar::copy_from( const GrowToolbar& n) 
{
  memcpy( this, &n, sizeof(n));
  if ( n.dynamicsize) {
    dynamic = (char *) calloc( 1, n.dynamicsize);
    memcpy( dynamic, n.nc->dynamic, n.dynamicsize);
  }
  if ( ctx->userdata_copy_callback)
    (ctx->userdata_copy_callback)( this, user_data, &user_data, glow_eUserdataCbType_Node);

  ctx->a_nc.remove(nc);
  ctx->nodeclass_insert( nc);

}

void GrowToolbar::ungroup()
{
  nc->a.set_last_group( n_name);
  ((GlowNodeGroup *)nc)->ungroup( &trf);
}

void GrowToolbar::save( ofstream& fp, glow_eSaveMode mode) 
{ 

  fp << int(glow_eSave_GrowToolbar) << endl;
  fp << int(glow_eSave_GrowToolbar_grownode_part) << endl;
  GrowNode::save( fp, mode);
  // fp << int(glow_eSave_GrowToolbar_nc) << endl;
  // ((GlowNodeGroup *)nc)->save( fp, mode);
  fp << int(glow_eSave_End) << endl;
}

void GrowToolbar::open( ifstream& fp)
{
  int		type;
  int 		end_found = 0;
  char		dummy[40];

  for (;;)
  {
    if ( !fp.good()) {
      fp.clear();
      fp.getline( dummy, sizeof(dummy));
      printf( "** Read error GrowToolbar: \"%d %s\"\n", type, dummy);      
    }

    fp >> type;
    switch( type) {
      case glow_eSave_GrowToolbar: break;
      case glow_eSave_GrowToolbar_grownode_part: 
        GrowNode::open( fp);
        break;
	// case glow_eSave_GrowToolbar_nc: 
        // nc = new GlowNodeGroup( ctx, n_name);
        // nc->open( fp);
        // break;
      case glow_eSave_End: end_found = 1; break;
      default:
        cout << "GrowToolbar:open syntax error" << endl;
        fp.getline( dummy, sizeof(dummy));
    }
    if ( end_found)
      break;
  }
}
 
void GrowToolbar::trace_scan()
{
  if ( trace.p && ctx->trace_scan_func)
    ctx->trace_scan_func( (void *) this, trace.p);

  nc->a.trace_scan();
}

int GrowToolbar::trace_init()
{
  int sts;

  //  if ( strcmp( trace.data[0], "") != 0)
  sts = ctx->trace_connect_func( (void *) this, &trace);

  nc->a.trace_init();
  return sts;
}

void GrowToolbar::trace_close()
{
  if ( trace.p)
    ctx->trace_disconnect_func( (void *) this);

  nc->a.trace_close();
}

GlowArrayElem *GrowToolbar::get_node_from_name( char *name)
{
  int i;
        
  for ( i = 0; i < nc->a.a_size; i++) {
    if ( (nc->a.a[i]->type() == glow_eObjectType_Node ||
          nc->a.a[i]->type() == glow_eObjectType_GrowNode ||
          nc->a.a[i]->type() == glow_eObjectType_GrowConGlue) &&
	 strcmp( ((GlowNode *) nc->a.a[i])->n_name, name) == 0)
      return nc->a.a[i];
    else if ( nc->a.a[i]->type() == glow_eObjectType_GrowToolbar) {
      GlowArrayElem *n = ((GrowToolbar *)nc->a.a[i])->get_node_from_name( name);
      if ( n)
	return n;
    }
  }
  return 0;
}

void GrowToolbar::call_redraw_node_cons()
{
  ctx->redraw_node_cons( this);
        
  for ( int i = 0; i < nc->a.a_size; i++) {
    nc->a.a[i]->call_redraw_node_cons();
  }
}

void GrowToolbar::link_insert( void **start)
{
  for ( int i = 0; i < nc->a.a_size; i++) {
    if ( nc->a[i]->type() == glow_eObjectType_Node ||
	 nc->a[i]->type() == glow_eObjectType_GrowNode ||
	 nc->a[i]->type() == glow_eObjectType_GrowToolbar) 
    nc->a.a[i]->link_insert( start);
  }
}

void GrowToolbar::convert( glow_eConvert version) 
{
  switch ( version) {
  case glow_eConvert_V34: {
    // Conversion of colors
    GrowNode::convert( version);
    for ( int i = 0; i < nc->a.a_size; i++) {
      nc->a.a[i]->convert( version);
    }

    break;
  }
  }  
}

void GrowToolbar::set_rootnode( void *node)
{
  nc->a.set_rootnode( node);
}

int GrowToolbar::event_handler( GlowWind *w, glow_eEvent event, double fx, double fy)
{
  double x, y;
  int sts;

  if ( invisible || dimmed)
    return 0;

  if ( !ctx->trace_started)
    return GrowNode::event_handler( w, event, fx, fy);

  trf.reverse( fx, fy, &x, &y);
  sts =  nc->event_handler( w, event, x, y);
  if  ( ctx->trace_started && sts) {
    // Register group members with click action
    if ( is_sensitive())
      ctx->register_callback_object( glow_eObjectType_Node, this);
  }
  return sts;
}

int GrowToolbar::event_handler( GlowWind *w, glow_eEvent event, int x, int y, double fx,
	double fy)
{
  int sts, lsts;
  int hot_type;
  int idx, mask_idx, category;
  double rx, ry;  

  if ( invisible || dimmed)
    return 0;

  if ( !ctx->trace_started)
    return GrowNode::event_handler( w, event, x, y, fx, fy);

  switch ( event) {
  case glow_eEvent_Key_Right:
  case glow_eEvent_Key_Left:
  case glow_eEvent_Key_BackSpace:
  case glow_eEvent_Key_Return:
  case glow_eEvent_Key_Ascii:
  case glow_eEvent_Key_Up:
  case glow_eEvent_Key_Down:
    return 0;
  default:
    ;
  }

  // Convert koordinates to local koordinates
  trf.reverse( fx, fy, &rx, &ry);

  sts = 0;
  if ( event == ctx->event_move_node) {
    sts = nc->event_handler( w, event, rx, ry);
    if ( sts) {
      /* Register node for potential movement */
      ctx->move_insert( this);
      store_position();
    }
    return sts;
  }
  else if ( event == ctx->event_create_con) {
    return sts;
  }
  switch ( event) {
    case glow_eEvent_MB1Down:
      if ( ctx->trace_started) {
	sts = nc_event_handler( w, event, rx, ry, &idx);
	if ( sts)
	  ((GrowNode *)nc->a.a[idx])->set_color_inverse(1);
      }
      break;
    case glow_eEvent_MB1Up:
      if ( ctx->trace_started) {
	sts = nc_event_handler( w, event, rx, ry, &idx);
	if ( sts)
	  ((GrowNode *)nc->a.a[idx])->set_color_inverse(0);
      }
      break;
    case glow_eEvent_CursorMotion: {
      int redraw = 0;

      if ( ctx->hot_mode == glow_eHotMode_TraceAction) {
        if ( ctx->hot_found)
          sts = 0;
        else {
          if ( is_sensitive()) {
            sts = nc_event_handler( w, event, rx, ry, &idx);
            if ( sts) {
	      ((GrowNode *)nc->a.a[idx])->set_hot(1);
	      redraw = 1;
              ctx->hot_found = 1;
	    }
          }
        }
      }
      else {
        if ( ctx->hot_found)
          sts = 0;
        else {
          sts = nc_event_handler( w, event, rx, ry, &idx);
          if ( sts)
            ctx->hot_found = 1;
        }
      }
      if ( sts && !hot  &&
	   !(ctx->node_movement_active || ctx->node_movement_paste_active)) {
        if ( (hot_type = ctx->send_hot_request( this))) {
          if ( !ctx->trace_started) {
            ctx->gdraw->set_cursor( w, glow_eDrawCursor_CrossHair);
            hot = 1;
            redraw = 1;
	    ctx->tiptext_event( this, x, y);
          }
          else if ( hot_type & glow_mHotType_CursorCrossHair) {
            ctx->gdraw->set_cursor( w, glow_eDrawCursor_CrossHair);
            hot_tool = idx + 1;
	    lsts = get_mask_index( idx, &category, &mask_idx);
	    if ( ODD(lsts))
	      ctx->tiptext_toolbar_event( this, x, y, category, mask_idx);
            redraw = 1;
          }
          else if ( hot_type & glow_mHotType_CursorHand) {
            ctx->gdraw->set_cursor( w, glow_eDrawCursor_Hand);
            hot_tool = idx + 1;
	    lsts = get_mask_index( idx, &category, &mask_idx);
	    if ( ODD(lsts))
	      ctx->tiptext_toolbar_event( this, x, y, category, mask_idx);
            redraw = 1;
          }
        }
      }
      if ( !sts && (( !ctx->trace_started && hot) || (ctx->trace_started && hot_tool))) {
        if ( !ctx->hot_found)
          ctx->gdraw->set_cursor( w, glow_eDrawCursor_Normal);
        if ( root_node)
          root_node->erase( w);
        else
          erase( w);
	if ( hot_tool)
	  ((GrowNode *)nc->a.a[hot_tool - 1])->set_hot(0);
	hot_tool = 0;
        hot = 0;
        redraw = 1;
	ctx->tiptext->remove_text( this);
      }
      if ( redraw) {
	draw();
      }
      break;
    }
    case glow_eEvent_MB1Click:
      sts = nc_event_handler( w, event, rx, ry, &idx);
      if ( sts) {
	lsts = get_mask_index( idx, &category, &mask_idx);
	if ( ODD(lsts))
	  ((GrowCtx *)ctx)->send_toolbar_callback( this, event, fx, fy, category, mask_idx);
      }
      break;
    default:
      sts = nc_event_handler( w, event, rx, ry, &idx);
  }

  return sts;
}

int GrowToolbar::nc_event_handler( GlowWind *w, glow_eEvent event, double x, double y, int *idx)
{
  int		i;
  int		sts;

  for ( i = 0; i < nc->a.a_size; i++) {
    sts = ((GrowNode *)nc->a.a[i])->event_handler( w, event, x, y);
    if ( sts) {
      *idx = i;
      return sts;
    }
  }
  return 0;
}


void GrowToolbar::configure( char *tools1, char *tools2, int tools1_cnt, int tools2_cnt,
			     unsigned int show_mask1, unsigned int show_mask2, 
			     unsigned int insensitive_mask1, unsigned int insensitive_mask2)
{
  double x1, y1;
  double ll_x, ll_y, ur_x, ur_y;

  GlowNodeClass *nc1;
  char subg_name[80];
  unsigned int mask;
  int sts;

  x1 = 0;
  y1 = 0;

  // Clear nc
  for ( int i = 0; i < nc->a.size(); i++) {
    GlowArrayElem *e = nc->a.a[i];
    nc->a.remove( e);
    delete e;
    i--;
  }

  tools1_mask = 0;
  mask = 1;
  for ( int i = 0; i < tools1_cnt; i++) {
    if ( mask & show_mask1) {
      if ( strcmp( &tools1[i*80], "") == 0) {
	mask = mask << 1;
	continue;
      }

      strcpy( subg_name, &tools1[i*80]);

      sts = ctx->find_nc_by_name( subg_name, (GlowArrayElem **)&nc1);
      if ( EVEN(sts)) {
	char fname[120];
	sprintf( fname, "$pwr_exe/%s.pwsg", subg_name);
	sts = ctx->open_subgraph( fname, glow_eSaveMode_SubGraph);
	if ( ODD(sts))
	  sts = ctx->find_nc_by_name( subg_name, (GlowArrayElem **)&nc1);
      }
      if ( ODD(sts)) {    
	GrowNode *n1;
	n1 = new GrowNode( ctx, subg_name, (GlowNodeClass *)nc1, x1, y1);
	n1->disable_callback();
	nc->insert(n1);
      
	if ( mask & insensitive_mask1)
	  n1->set_visibility( glow_eVis_Dimmed);

	n1->measure( &ll_x, &ll_y, &ur_x, &ur_y);      
	x1 += ur_x - ll_x + TOOLBAR_SPACING;
	tools1_mask |= mask;
      }      
    }
    mask = mask << 1;
  }
  if ( x1 != 0)
    x1 += TOOLBAR_SPACING * 2;
  
  tools2_mask = 0;
  mask = 1;
  for ( int i = 0; i < tools2_cnt; i++) {
    if ( mask & show_mask2) {
      if ( strcmp( &tools2[i*80], "") == 0) {
	mask = mask << 1;
	continue;
      }
    
      strcpy( subg_name, &tools2[i*80]);

      sts = ctx->find_nc_by_name( subg_name, (GlowArrayElem **)&nc1);
      if ( EVEN(sts)) {
	char fname[120];
	sprintf( fname, "$pwr_exe/%s.pwsg", subg_name);
	sts = ctx->open_subgraph( fname, glow_eSaveMode_SubGraph);
	if ( ODD(sts))
	  sts = ctx->find_nc_by_name( subg_name, (GlowArrayElem **)&nc1);
      }
      if ( ODD(sts)) {    
	GrowNode *n1;
	n1 = new GrowNode( ctx, subg_name, (GlowNodeClass *)nc1, x1, y1);
	n1->disable_callback();
	nc->insert(n1);
      
	if ( mask & insensitive_mask2)
	  n1->set_visibility( glow_eVis_Dimmed);

	n1->measure( &ll_x, &ll_y, &ur_x, &ur_y);      
	x1 += ur_x - ll_x + TOOLBAR_SPACING;
	tools2_mask |= mask;
      }
    }
    mask = mask << 1;
  }

  get_node_borders();

  // Move the nc to after the methodbuttons nodeclasses, or they will be deleted in the wrong order
  // when when deleted
  ctx->a_nc.remove(nc);
  ctx->nodeclass_insert( nc);
}

int GrowToolbar::get_mask_index( int idx, int *category, int *mask_idx)
{
  // Calculate category and index
  unsigned int mask;
  int cnt = 0;
  int i;
  for ( i = 0; i < 64; i++) {
    if ( i < 32)
      mask = 1 << i;
    else
      mask = 1 << (i - 32);
    if ( (i < 32 && tools1_mask & mask) ||
	 (i >= 32 && tools2_mask & mask))
      cnt++;
    if ( cnt == idx + 1) {
      *mask_idx = i % 32;
      *category = i / 32 + 1;
      return 1;
    }
  }
  return 0;
}
