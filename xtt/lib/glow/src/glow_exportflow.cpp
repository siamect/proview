/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <string.h>

#include "glow_growrect.h"
#include "glow_growline.h"
#include "glow_growconpoint.h"
#include "glow_growtext.h"
#include "glow_growsubannot.h"
#include "glow_growarc.h"
#include "glow_exportflow.h"
#include "flow.h"

#define FLOW_SCALE 0.05

int GlowExportFlow::export_flow(char* filename)
{
  char nc_name[80];
  char* s;

  if ((s = strrchr(filename, ':')))
    strcpy(nc_name, s + 1);
  else if ((s = strrchr(filename, '/')))
    strcpy(nc_name, s + 1);
  else
    strcpy(nc_name, filename);
  if ((s = strrchr(nc_name, '.')))
    *s = 0;
  fp.open(filename);

  // Save as NodeClass
  fp << int(flow_eSave_NodeClass) << '\n';
  fp << int(flow_eSave_NodeClass_nc_name) << FSPACE << nc_name << '\n';
  fp << int(flow_eSave_NodeClass_a) << '\n';
  ctx->a.export_flow(this);
  fp << int(flow_eSave_NodeClass_group) << FSPACE << int(glow_eNodeGroup_Common)
     << '\n';
  fp << int(flow_eSave_NodeClass_no_con_obstacle) << FSPACE
     << ctx->no_con_obstacle << '\n';
  fp << int(flow_eSave_End) << '\n';

  fp.close();
  return 1;
}

void GlowExportFlow::array(GlowArray* o)
{
  int i;

  fp << int(flow_eSave_Array) << '\n';
  for (i = 0; i < o->a_size; i++) {
    if (o->a[i]->type() != glow_eObjectType_Con)
      o->a[i]->export_flow(this);
  }
  fp << int(flow_eSave_End) << '\n';
}

void GlowExportFlow::rect(GrowRect* o)
{
  flow_eDrawType draw_type = flow_eDrawType_Line;

  if (o->draw_type >= 20 && o->draw_type < 60)
    draw_type = flow_eDrawType_LineGray;

  fp << int(flow_eSave_Rect) << '\n';
  fp << int(flow_eSave_Rect_draw_type) << FSPACE << int(draw_type) << '\n';
  fp << int(flow_eSave_Rect_line_width) << FSPACE << o->line_width << '\n';
  fp << int(flow_eSave_Rect_display_level) << FSPACE << int(o->display_level)
     << '\n';
  fp << int(flow_eSave_Rect_ll) << '\n';
  point(&o->ll, &o->trf);
  fp << int(flow_eSave_Rect_ur) << '\n';
  point(&o->ur, &o->trf);
  fp << int(flow_eSave_End) << '\n';
}

void GlowExportFlow::line(GrowLine* o)
{
  flow_eDrawType draw_type = flow_eDrawType_Line;

  if (o->draw_type >= 20 && o->draw_type < 60)
    draw_type = flow_eDrawType_LineGray;

  fp << int(flow_eSave_Line) << '\n';
  fp << int(flow_eSave_Line_draw_type) << FSPACE << int(draw_type) << '\n';
  fp << int(flow_eSave_Line_line_width) << FSPACE << o->line_width << '\n';
  fp << int(flow_eSave_Line_p1) << '\n';
  point(&o->p1, &o->trf);
  fp << int(flow_eSave_Line_p2) << '\n';
  point(&o->p2, &o->trf);
  fp << int(flow_eSave_End) << '\n';
}

void GlowExportFlow::conpoint(GrowConPoint* o)
{
  fp << int(flow_eSave_ConPoint) << '\n';
  fp << int(flow_eSave_ConPoint_number) << FSPACE << o->number << '\n';
  fp << int(flow_eSave_ConPoint_direction) << FSPACE << int(o->direction)
     << '\n';
  fp << int(flow_eSave_ConPoint_p) << '\n';
  point(&o->p, &o->trf);
  fp << int(flow_eSave_ConPoint_trace_attribute) << FSPACE << o->trace_attribute
     << '\n';
  fp << int(flow_eSave_ConPoint_trace_attr_type) << FSPACE
     << int(o->trace_attr_type) << '\n';
  fp << int(flow_eSave_End) << '\n';
}

void GlowExportFlow::text(GrowText* o)
{
  flow_eDrawType draw_type;

  switch (o->draw_type) {
  case glow_eDrawType_TextHelveticaBold:
    draw_type = flow_eDrawType_TextHelveticaBold;
    break;
  default:
    draw_type = flow_eDrawType_TextHelvetica;
  }

  fp << int(flow_eSave_Text) << '\n';
  fp << int(flow_eSave_Text_text_size) << FSPACE << o->text_size << '\n';
  fp << int(flow_eSave_Text_draw_type) << FSPACE << int(draw_type) << '\n';
  fp << int(flow_eSave_Text_text) << FSPACE << o->text << '\n';
  fp << int(flow_eSave_Text_p) << '\n';
  point(&o->p, &o->trf);
  fp << int(flow_eSave_End) << '\n';
}

void GlowExportFlow::annot(GrowSubAnnot* o)
{
  flow_eDrawType draw_type;

  switch (o->draw_type) {
  case glow_eDrawType_TextHelveticaBold:
    draw_type = flow_eDrawType_TextHelveticaBold;
    break;
  default:
    draw_type = flow_eDrawType_TextHelvetica;
  }

  fp << int(flow_eSave_Annot) << '\n';
  fp << int(flow_eSave_Annot_number) << FSPACE << o->number << '\n';
  fp << int(flow_eSave_Annot_draw_type) << FSPACE << int(draw_type) << '\n';
  fp << int(flow_eSave_Annot_text_size) << FSPACE << o->text_size << '\n';
  fp << int(flow_eSave_Annot_display_level) << FSPACE << int(o->display_level)
     << '\n';
  fp << int(flow_eSave_Annot_p) << '\n';
  point(&o->p, &o->trf);
  fp << int(flow_eSave_Annot_annot_type) << FSPACE << int(o->annot_type)
     << '\n';
  fp << int(flow_eSave_End) << '\n';
}

void GlowExportFlow::arc(GrowArc* o)
{
  flow_eDrawType draw_type = flow_eDrawType_Line;

  if (o->draw_type >= 20 && o->draw_type < 60)
    draw_type = flow_eDrawType_LineGray;

  fp << int(flow_eSave_Arc) << '\n';
  fp << int(flow_eSave_Arc_draw_type) << FSPACE << int(draw_type) << '\n';
  fp << int(flow_eSave_Arc_line_width) << FSPACE << o->line_width << '\n';
  fp << int(flow_eSave_Arc_angle1) << FSPACE << o->angle1 << '\n';
  fp << int(flow_eSave_Arc_angle2) << FSPACE << o->angle2 << '\n';
  fp << int(flow_eSave_Arc_ll) << '\n';
  point(&o->ll, &o->trf);
  fp << int(flow_eSave_Arc_ur) << '\n';
  point(&o->ur, &o->trf);
  fp << int(flow_eSave_End) << '\n';
}

void GlowExportFlow::point(GlowPoint* o, GlowTransform* trf)
{
  double x = trf->x(o->x, o->y) * FLOW_SCALE;
  double y = trf->y(o->x, o->y) * FLOW_SCALE;

  fp << int(flow_eSave_Point) << '\n';
  fp << int(flow_eSave_Point_x) << FSPACE << x << '\n';
  fp << int(flow_eSave_Point_y) << FSPACE << y << '\n';
  fp << int(flow_eSave_End) << '\n';
}
