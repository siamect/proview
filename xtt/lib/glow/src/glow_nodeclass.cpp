/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <math.h>
#include <stdlib.h>

#include <iostream>

#include "co_string.h"

#include "glow_growannot.h"
#include "glow_growrect.h"
#include "glow_msg.h"

GlowNodeClass::GlowNodeClass(
    GrowCtx* glow_ctx, const char* name, glow_eNodeGroup grp)
    : ctx(glow_ctx), a(10, 10), group(grp), dynamic(0), dynamicsize(0),
      arg_cnt(0), nc_extern(0), dyn_type1(0), dyn_type2(0), dyn_action_type1(0),
      dyn_action_type2(0), no_con_obstacle(0), slider(0), animation_count(1),
      y0(0), y1(0), x0(0), x1(0), next_nc(0), prev_nc(0),
      cycle(glow_eCycle_Slow), user_data(0), recursive_trace(0)
{
  memset(dyn_color, 0, sizeof(dyn_color));
  memset(dyn_attr, 0, sizeof(dyn_attr));
  strcpy(n_name, name);
  strcpy(java_name, "");
  strcpy(next_nodeclass, "");
  memset(argname, 0, sizeof(argname));
  memset(argtype, 0, sizeof(argtype));
}

GlowNodeClass::GlowNodeClass(const GlowNodeClass& nc)
{
  memcpy((void *)this, (void *)&nc, sizeof(nc));

  a.new_array(nc.a);
  a.copy_from(nc.a);
  if (dynamicsize) {
    dynamic = (char*)calloc(1, dynamicsize);
    memcpy(dynamic, nc.dynamic, dynamicsize);
  }
  if (user_data && ctx->userdata_copy_callback)
    (ctx->userdata_copy_callback)(
        this, user_data, &user_data, glow_eUserdataCbType_NodeClass);
}

GlowNodeClass::~GlowNodeClass()
{
  int i;
  GlowArrayElem* element;

  for (i = 0; i < a.a_size; i++) {
    element = a.a[i];
    a.remove(element);
    ctx->object_deleted(element);
    delete element;
    i--;
  }
  ctx->object_deleted(this);
}

void GlowNodeClass::print(GlowPoint* pos, void* node)
{
  int i;

  for (i = 0; i < a.a_size; i++) {
    a.a[i]->print(pos, node);
  }
}

void GlowNodeClass::save(std::ofstream& fp, glow_eSaveMode mode)
{
  char* s;
  int i;

  if (saved)
    return;
  set_saved(1);

  if (slider)
    x0 = x1 = y1 = 0;

  if (next_nc)
    ((GlowNodeClass*)next_nc)->save(fp, mode);

  if (nc_extern)
    return;
  if ((mode == glow_eSaveMode_Trace && group != glow_eNodeGroup_Trace)
      || (mode == glow_eSaveMode_Edit && group == glow_eNodeGroup_Trace))
    return;
  fp << int(glow_eSave_NodeClass) << '\n';
  fp << int(glow_eSave_NodeClass_nc_name) << FSPACE << n_name << '\n';
  fp << int(glow_eSave_NodeClass_a) << '\n';
  a.save(fp, mode);
  fp << int(glow_eSave_NodeClass_group) << FSPACE << int(group) << '\n';
  fp << int(glow_eSave_NodeClass_dynamicsize) << FSPACE << dynamicsize << '\n';
  fp << int(glow_eSave_NodeClass_dynamic) << '\n';
  if (dynamic) {
    fp << "\"";
    for (s = dynamic; *s; s++) {
      if (*s == '"')
        fp << "\\";
      fp << *s;
    }
    fp << "\"\n";
  }
  fp << int(glow_eSave_NodeClass_arg_cnt) << FSPACE << arg_cnt << '\n';
  fp << int(glow_eSave_NodeClass_argname) << '\n';
  for (i = 0; i < arg_cnt; i++)
    fp << argname[i] << '\n';
  fp << int(glow_eSave_NodeClass_argtype) << '\n';
  for (i = 0; i < arg_cnt; i++)
    fp << argtype[i] << '\n';
  fp << int(glow_eSave_NodeClass_dyn_type1) << FSPACE << dyn_type1 << '\n';
  fp << int(glow_eSave_NodeClass_dyn_type2) << FSPACE << dyn_type2 << '\n';
  fp << int(glow_eSave_NodeClass_dyn_action_type1) << FSPACE << dyn_action_type1
     << '\n';
  fp << int(glow_eSave_NodeClass_dyn_action_type2) << FSPACE << dyn_action_type2
     << '\n';
  fp << int(glow_eSave_NodeClass_dyn_color1) << FSPACE << int(dyn_color[0])
     << '\n';
  fp << int(glow_eSave_NodeClass_dyn_color2) << FSPACE << int(dyn_color[1])
     << '\n';
  fp << int(glow_eSave_NodeClass_dyn_color3) << FSPACE << int(dyn_color[2])
     << '\n';
  fp << int(glow_eSave_NodeClass_dyn_color4) << FSPACE << int(dyn_color[3])
     << '\n';
  fp << int(glow_eSave_NodeClass_dyn_attr1) << FSPACE << dyn_attr[0] << '\n';
  fp << int(glow_eSave_NodeClass_dyn_attr2) << FSPACE << dyn_attr[1] << '\n';
  fp << int(glow_eSave_NodeClass_dyn_attr3) << FSPACE << dyn_attr[2] << '\n';
  fp << int(glow_eSave_NodeClass_dyn_attr4) << FSPACE << dyn_attr[3] << '\n';
  fp << int(glow_eSave_NodeClass_no_con_obstacle) << FSPACE << no_con_obstacle
     << '\n';
  fp << int(glow_eSave_NodeClass_slider) << FSPACE << slider << '\n';
  fp << int(glow_eSave_NodeClass_java_name) << FSPACE << java_name << '\n';
  fp << int(glow_eSave_NodeClass_next_nodeclass) << FSPACE << next_nodeclass
     << '\n';
  fp << int(glow_eSave_NodeClass_animation_count) << FSPACE << animation_count
     << '\n';
  fp << int(glow_eSave_NodeClass_cycle) << FSPACE << int(cycle) << '\n';
  fp << int(glow_eSave_NodeClass_y0) << FSPACE << y0 << '\n';
  fp << int(glow_eSave_NodeClass_y1) << FSPACE << y1 << '\n';
  fp << int(glow_eSave_NodeClass_x0) << FSPACE << x0 << '\n';
  fp << int(glow_eSave_NodeClass_x1) << FSPACE << x1 << '\n';
  fp << int(glow_eSave_NodeClass_input_focus_mark) << FSPACE
     << int(input_focus_mark) << '\n';
  fp << int(glow_eSave_NodeClass_recursive_trace) << FSPACE << recursive_trace
     << '\n';
  if (user_data && ctx->userdata_save_callback) {
    fp << int(glow_eSave_NodeClass_userdata_cb) << '\n';
    (ctx->userdata_save_callback)(&fp, this, glow_eUserdataCbType_NodeClass);
  }
  fp << int(glow_eSave_End) << '\n';
}

void GlowNodeClass::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;
  int i, j;
  char c;
  int sts;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GlowNodeClass: \"%d %s\"\n", type, dummy);
    }

    fp >> type;
    switch (type) {
    case glow_eSave_NodeClass:
      break;
    case glow_eSave_NodeClass_nc_name:
      fp.get();
      fp.getline(n_name, sizeof(n_name));
      break;
    case glow_eSave_NodeClass_a:
      a.open(ctx, fp);
      break;
    case glow_eSave_NodeClass_group:
      fp >> tmp;
      group = (glow_eNodeGroup)tmp;
      break;
    case glow_eSave_NodeClass_dynamicsize:
      fp >> dynamicsize;
      break;
    case glow_eSave_NodeClass_dynamic:
      fp.getline(dummy, sizeof(dummy));
      if (dynamicsize) {
        dynamic = (char*)calloc(1, dynamicsize);
        fp.get();
        for (j = 0; j < dynamicsize; j++) {
          if ((c = fp.get()) == '"') {
            if (dynamic[j - 1] == '\\')
              j--;
            else {
              dynamic[j] = 0;
              break;
            }
          }
          dynamic[j] = c;
        }
        fp.getline(dummy, sizeof(dummy));
      }
      break;
    case glow_eSave_NodeClass_arg_cnt:
      fp >> arg_cnt;
      break;
    case glow_eSave_NodeClass_argname:
      fp.get();
      for (i = 0; i < arg_cnt; i++) {
        fp.getline(argname[i], sizeof(argname[0]));
      }
      break;
    case glow_eSave_NodeClass_argtype:
      for (i = 0; i < arg_cnt; i++)
        fp >> argtype[i];
      break;
    case glow_eSave_NodeClass_dyn_type1:
      fp >> dyn_type1;
      break;
    case glow_eSave_NodeClass_dyn_type2:
      fp >> dyn_type2;
      break;
    case glow_eSave_NodeClass_dyn_action_type1:
      fp >> dyn_action_type1;
      break;
    case glow_eSave_NodeClass_dyn_action_type2:
      fp >> dyn_action_type2;
      break;
    case glow_eSave_NodeClass_dyn_color1:
      fp >> tmp;
      dyn_color[0] = (glow_eDrawType)tmp;
      break;
    case glow_eSave_NodeClass_dyn_color2:
      fp >> tmp;
      dyn_color[1] = (glow_eDrawType)tmp;
      break;
    case glow_eSave_NodeClass_dyn_color3:
      fp >> tmp;
      dyn_color[2] = (glow_eDrawType)tmp;
      break;
    case glow_eSave_NodeClass_dyn_color4:
      fp >> tmp;
      dyn_color[3] = (glow_eDrawType)tmp;
      break;
    case glow_eSave_NodeClass_dyn_attr1:
      fp >> dyn_attr[0];
      break;
    case glow_eSave_NodeClass_dyn_attr2:
      fp >> dyn_attr[1];
      break;
    case glow_eSave_NodeClass_dyn_attr3:
      fp >> dyn_attr[2];
      break;
    case glow_eSave_NodeClass_dyn_attr4:
      fp >> dyn_attr[3];
      break;
    case glow_eSave_NodeClass_no_con_obstacle:
      fp >> no_con_obstacle;
      break;
    case glow_eSave_NodeClass_slider:
      fp >> slider;
      break;
    case glow_eSave_NodeClass_java_name:
      fp.get();
      fp.getline(java_name, sizeof(java_name));
      break;
    case glow_eSave_NodeClass_next_nodeclass:
      fp.get();
      fp.getline(next_nodeclass, sizeof(next_nodeclass));
      break;
    case glow_eSave_NodeClass_animation_count:
      fp >> animation_count;
      break;
    case glow_eSave_NodeClass_cycle:
      fp >> tmp;
      cycle = (glow_eCycle)tmp;
      break;
    case glow_eSave_NodeClass_y0:
      fp >> y0;
      break;
    case glow_eSave_NodeClass_y1:
      fp >> y1;
      break;
    case glow_eSave_NodeClass_x0:
      fp >> x0;
      break;
    case glow_eSave_NodeClass_x1:
      fp >> x1;
      break;
    case glow_eSave_NodeClass_input_focus_mark:
      fp >> tmp;
      input_focus_mark = (glow_eInputFocusMark)tmp;
      break;
    case glow_eSave_NodeClass_recursive_trace:
      fp >> recursive_trace;
      break;
    case glow_eSave_NodeClass_userdata_cb:
      if (ctx->userdata_open_callback)
        (ctx->userdata_open_callback)(
            &fp, this, glow_eUserdataCbType_NodeClass);
      break;
    case glow_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GlowNodeClass:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }

  if (!streq(next_nodeclass, "")) {
    next_nc = ctx->get_nodeclass_from_name(next_nodeclass);
    if (!next_nc) {
      sts = ctx->open_subgraph_from_name(
          next_nodeclass, glow_eSaveMode_SubGraph);
      if (ODD(sts)) {
        next_nc = ctx->get_nodeclass_from_name(next_nodeclass);
        if (next_nc)
          ((GlowNodeClass*)next_nc)->nc_extern = nc_extern;
      }
    }
    if (!next_nc)
      std::cout << "GlowNode:next_nodeclass not found: " << n_name << " "
                << next_nodeclass << '\n';
    else if (((GlowNodeClass*)next_nc)->prev_nc) {
      next_nc = 0;
      std::cout << "GlowNode:next_nodeclass already chained: " << n_name << " "
                << next_nodeclass << '\n';
    } else
      ((GlowNodeClass*)next_nc)->prev_nc = (GlowArrayElem*)this;
  }
}

void GlowNodeClass::draw(
    GlowWind* w, GlowPoint* pos, int highlight, int hot, void* node)
{
  int i;

  for (i = 0; i < a.a_size; i++) {
    a.a[i]->draw(w, pos, highlight, hot, node);
  }
}

void GlowNodeClass::erase(GlowWind* w, GlowPoint* pos, int hot, void* node)
{
  int i;

  for (i = 0; i < a.a_size; i++) {
    a.a[i]->erase(w, pos, hot, node);
  }
}

void GlowNodeClass::draw(GlowWind* w, GlowTransform* t, int highlight, int hot,
    void* node, void* colornode)
{
  int i;

  for (i = 0; i < a.a_size; i++) {
    a.a[i]->draw(w, t, highlight, hot, node, colornode);
  }
}

void GlowNodeClass::erase(GlowWind* w, GlowTransform* t, int hot, void* node)
{
  int i;

  for (i = 0; i < a.a_size; i++) {
    a.a[i]->erase(w, t, hot, node);
  }
}

int GlowNodeClass::get_conpoint(
    int num, double* x, double* y, glow_eDirection* dir)
{
  int i, sts;

  for (i = 0; i < a.a_size; i++) {
    sts = a.a[i]->get_conpoint(num, x, y, dir);
    if (sts)
      return sts;
  }
  return GLOW__NOCONPOINT;
}

int GlowNodeClass::get_conpoint(GlowTransform* t, int num, bool flip_horizontal,
    bool flip_vertical, double* x, double* y, glow_eDirection* dir)
{
  int i, sts;

  for (i = 0; i < a.a_size; i++) {
    sts = a.a[i]->get_conpoint(
        t, num, flip_horizontal, flip_vertical, x, y, dir);
    if (sts)
      return sts;
  }
  return GLOW__NOCONPOINT;
}

int GlowNodeClass::event_handler(
    GlowWind* w, void* pos, glow_eEvent event, int x, int y, void* node)
{
  return a.event_handler(w, pos, event, x, y, node);
}

int GlowNodeClass::event_handler(
    GlowWind* w, glow_eEvent event, double fx, double fy)
{
  return a.event_handler(w, event, fx, fy);
}

void GlowNodeClass::erase_annotation(
    void* pos, int highlight, int hot, void* node, int num)
{
  int i;

  for (i = 0; i < a.a_size; i++) {
    if ((a.a[i]->type() == glow_eObjectType_Annot
            || a.a[i]->type() == glow_eObjectType_GrowAnnot)
        && ((GlowAnnot*)a.a[i])->number == num) {
      a.a[i]->erase(&ctx->mw, pos, hot, node);
      a.a[i]->erase(&ctx->navw, pos, 0, node);
      break;
    }
  }
}

void GlowNodeClass::draw_annotation(
    void* pos, int highlight, int hot, void* node, int num)
{
  int i;

  for (i = 0; i < a.a_size; i++) {
    if ((a.a[i]->type() == glow_eObjectType_Annot
            || a.a[i]->type() == glow_eObjectType_GrowAnnot)
        && ((GlowAnnot*)a.a[i])->number == num) {
      a.a[i]->draw(&ctx->mw, pos, highlight, hot, node);
      a.a[i]->draw(&ctx->navw, pos, highlight, 0, node);
      break;
    }
  }
}

void GlowNodeClass::erase_annotation(
    GlowTransform* t, int highlight, int hot, void* node, int num)
{
  int i;

  for (i = 0; i < a.a_size; i++) {
    if (a.a[i]->type() == glow_eObjectType_GrowAnnot
        && ((GlowAnnot*)a.a[i])->number == num) {
      ((GrowAnnot*)a.a[i])->erase_background(&ctx->mw, t, hot, node);
      a.a[i]->erase(&ctx->navw, t, 0, node);
      break;
    }
  }
}

void GlowNodeClass::draw_annotation(
    GlowTransform* t, int highlight, int hot, void* node, int num)
{
  int i;

  for (i = 0; i < a.a_size; i++) {
    if (a.a[i]->type() == glow_eObjectType_GrowAnnot
        && ((GlowAnnot*)a.a[i])->number == num) {
      a.a[i]->draw(&ctx->mw, t, highlight, hot, node, NULL);
      a.a[i]->draw(&ctx->navw, t, highlight, 0, node, NULL);
      break;
    }
  }
}

int GlowNodeClass::check_annotation(int num)
{
  int i;

  for (i = 0; i < a.a_size; i++) {
    if ((a.a[i]->type() == glow_eObjectType_Annot
            || a.a[i]->type() == glow_eObjectType_GrowAnnot)
        && ((GlowAnnot*)a.a[i])->number == num)
      return 1;
  }
  return 0;
}

void GlowNodeClass::get_obstacle_borders(double pos_x, double pos_y,
    double* x_right, double* x_left, double* y_high, double* y_low, void* node)
{
  int i;

  switch (group) {
  case glow_eNodeGroup_Document:
    for (i = 0; i < a.a_size; i++) {
      if (a.a[i]->type() == glow_eObjectType_Rect)
        a.a[i]->get_borders(pos_x, pos_y, x_right, x_left, y_high, y_low, node);
    }
    break;
  default:
    a.get_borders(pos_x, pos_y, x_right, x_left, y_high, y_low, node);
  }
}

void GlowNodeClass::set_fill_color(glow_eDrawType drawtype)
{
  for (int i = 0; i < a.a_size; i++)
    a.a[i]->set_fill_color(drawtype);
}

void GlowNodeClass::set_original_fill_color(glow_eDrawType drawtype)
{
  for (int i = 0; i < a.a_size; i++)
    a.a[i]->set_original_fill_color(drawtype);
}

void GlowNodeClass::reset_fill_color()
{
  for (int i = 0; i < a.a_size; i++)
    a.a[i]->reset_fill_color();
}

void GlowNodeClass::set_border_color(glow_eDrawType drawtype)
{
  for (int i = 0; i < a.a_size; i++)
    a.a[i]->set_border_color(drawtype);
}

void GlowNodeClass::set_original_border_color(glow_eDrawType drawtype)
{
  for (int i = 0; i < a.a_size; i++)
    a.a[i]->set_original_border_color(drawtype);
}

void GlowNodeClass::reset_border_color()
{
  for (int i = 0; i < a.a_size; i++)
    a.a[i]->reset_border_color();
}

void GlowNodeClass::set_linewidth(int linewidth)
{
  for (int i = 0; i < a.a_size; i++)
    a.a[i]->set_linewidth(linewidth);
}

int GlowNodeClass::draw_annot_background(
    GlowTransform* t, void* node, double x, double y)
{
  int sts;

  for (int i = a.a_size - 1; i >= 0; i--) {
    if (a.a[i]->type() == glow_eObjectType_GrowRect) {
      sts = ((GrowRect*)a.a[i])->draw_annot_background(t, node, x, y);
      if (ODD(sts))
        return sts;
    }
  }
  return 0;
}

int GlowNodeClass::get_annot_background(
    GlowTransform* t, void* node, glow_eDrawType* background)
{
  int sts;

  for (int i = a.a_size - 1; i >= 0; i--) {
    if (a.a[i]->type() == glow_eObjectType_GrowRect) {
      sts = ((GrowRect*)a.a[i])->get_annot_background(t, node, background);
      if (ODD(sts))
        return sts;
    }
  }
  return 0;
}

void GlowNodeClass::get_annotation_numbers(int** numbers, int* cnt)
{
  int i;
  int* p;

  *cnt = 0;
  p = (int*)calloc(10, sizeof(int));
  for (i = 0; i < a.a_size; i++) {
    if (a.a[i]->type() == glow_eObjectType_Annot
        || a.a[i]->type() == glow_eObjectType_GrowAnnot) {
      if (*cnt >= 10)
        break;
      p[*cnt] = ((GlowAnnot*)a.a[i])->number;
      (*cnt)++;
    }
  }
  *numbers = p;
}

void GlowNodeClass::measure_javabean(double* pix_x_right, double* pix_x_left,
    double* pix_y_high, double* pix_y_low)
{
  double jb_x_right = -1e10;
  double jb_x_left = 1e10;
  double jb_y_high = -1e10;
  double jb_y_low = 1e10;

  GlowNodeClass* base = get_base_nc();

  if (/* (next_nc || prev_nc) && */
      !(fabs(base->x0 - base->x1) < DBL_EPSILON
          || fabs(base->y0 - base->y1) < DBL_EPSILON)) {
    jb_x_right = base->x1;
    jb_x_left = base->x0;
    jb_y_high = base->y1;
    jb_y_low = base->y0;
  } else
    a.get_borders(
        (GlowTransform*)NULL, &jb_x_right, &jb_x_left, &jb_y_high, &jb_y_low);

  *pix_x_right = jb_x_right * ctx->mw.zoom_factor_x - double(ctx->mw.offset_x);
  *pix_x_left = jb_x_left * ctx->mw.zoom_factor_x - double(ctx->mw.offset_x);
  *pix_y_high = jb_y_high * ctx->mw.zoom_factor_y - double(ctx->mw.offset_y);
  *pix_y_low = jb_y_low * ctx->mw.zoom_factor_y - double(ctx->mw.offset_y);
}

void GlowNodeClass::set_java_name(char* name)
{
  strcpy(java_name, name);
}

int GlowNodeClass::get_java_name(char* jname)
{
  if (!streq(java_name, "")) {
    strcpy(jname, java_name);
    return 1;
  }
  strcpy(jname, n_name);
  return 0;
}

int GlowNodeClass::get_pages()
{
  GlowNodeClass* next;
  int pages = 1;

  for (next = (GlowNodeClass*)next_nc; next;
       next = (GlowNodeClass*)next->next_nc)
    pages++;
  return pages;
}

GlowNodeClass* GlowNodeClass::get_base_nc()
{
  GlowNodeClass* base;

  for (base = this; base->prev_nc; base = (GlowNodeClass*)base->prev_nc)
    ;
  return base;
}

void GlowNodeClass::get_borders(GlowTransform* t, double* x_right,
    double* x_left, double* y_high, double* y_low)
{
  GlowNodeClass* base = get_base_nc();

  if ((!t || (t
                 && fabs(t->rotation / 90 - int(t->rotation / 90))
                     < DBL_EPSILON))
      &&
      /* (next_nc || prev_nc) && */
      !(fabs(base->x0 - base->x1) < DBL_EPSILON
          || fabs(base->y0 - base->y1) < DBL_EPSILON)) {
    // Borders are given i x0, y0, x1, y1
    // Will not work in rotated nodes
    double ll_x, ur_x, ll_y, ur_y, kx1, kx2, ky1, ky2;

    if (t) {
      kx1 = t->x(base->x0, base->y0);
      kx2 = t->x(base->x1, base->y1);
      ky1 = t->y(base->x0, base->y0);
      ky2 = t->y(base->x1, base->y1);
    } else {
      kx1 = base->x0;
      kx2 = base->x1;
      ky1 = base->y0;
      ky2 = base->y1;
    }

    ll_x = MIN(kx1, kx2);
    ur_x = MAX(kx1, kx2);
    ll_y = MIN(ky1, ky2);
    ur_y = MAX(ky1, ky2);

    if (ll_x < *x_left)
      *x_left = ll_x;
    if (ur_x > *x_right)
      *x_right = ur_x;
    if (ll_y < *y_low)
      *y_low = ll_y;
    if (ur_y > *y_high)
      *y_high = ur_y;
  } else
    a.get_borders(t, x_right, x_left, y_high, y_low);
}

void GlowNodeClass::get_origo(GlowTransform* t, double* x, double* y)
{
  GlowNodeClass* base = get_base_nc();

  if (/* (next_nc || prev_nc) && */
      !(fabs(base->x0 - base->x1) < DBL_EPSILON
          || fabs(base->y0 - base->y1) < DBL_EPSILON)) {
    // Borders are given i x0, y0, x1, y1

    if (t) {
      double ll_x, ll_y, ur_x, ur_y;
      ll_x = ll_y = 1e37;
      ur_x = ur_y = -1e37;

      get_borders(t, &ur_x, &ll_x, &ur_y, &ll_y);
      *x = t->x(0, 0) - ll_x;
      *y = t->y(0, 0) - ll_y;
    } else {
      *x = -base->x0;
      *y = -base->y0;
    }
  } else {
    double ll_x, ll_y, ur_x, ur_y;
    ll_x = ll_y = 1e37;
    ur_x = ur_y = -1e37;

    a.get_borders(t, &ur_x, &ll_x, &ur_y, &ll_y);
    *x = -ll_x;
    *y = -ll_y;
  }
}

void GlowNodeClass::convert(glow_eConvert version)
{
  a.convert(version);
  if (dyn_type1 == 3 || dyn_type1 == 4 || dyn_type1 == 12) {
    if ((glow_eDrawTone)dyn_color[0] == glow_eDrawTone_YellowGreen)
      dyn_color[0] = (glow_eDrawType)glow_eDrawTone_Yellow;
    if ((glow_eDrawTone)dyn_color[1] == glow_eDrawTone_YellowGreen)
      dyn_color[1] = (glow_eDrawType)glow_eDrawTone_Yellow;
  } else {
    dyn_color[0] = GlowColor::convert(version, dyn_color[0]);
    dyn_color[1] = GlowColor::convert(version, dyn_color[1]);
  }
}

int GlowNodeClass::find_nc(GlowArrayElem* nodeclass)
{
  return a.find_nc(nodeclass);
}

int GlowNodeClass::get_annotation_info(void* node, int num, int* t_size,
    glow_eDrawType* t_drawtype, glow_eDrawType* t_color, glow_eFont* t_font,
    glow_eAnnotType* t_type)
{
  int i;

  for (i = 0; i < a.a_size; i++) {
    if (a.a[i]->type() == glow_eObjectType_GrowAnnot
        && ((GrowAnnot*)a.a[i])->number == num) {
      ((GrowAnnot*)a.a[i])
          ->get_annotation_info(
              node, t_size, t_drawtype, t_color, t_font, t_type);
      return 1;
    }
  }
  return 0;
}

int GlowNodeClass::get_annotation_text_size(
    GlowTransform* t, int num, double* tsize)
{
  int i;

  for (i = 0; i < a.a_size; i++) {
    if (a.a[i]->type() == glow_eObjectType_GrowAnnot
        && ((GlowAnnot*)a.a[i])->number == num) {
      return ((GrowAnnot*)a.a[i])->get_text_size(t, tsize);
    }
  }
  return 0;
}

void GlowNodeClass::get_annotation_text_extent(
    GlowTransform* t, void* node, int num, double* width, double* height)
{
  int i;

  for (i = 0; i < a.a_size; i++) {
    if (a.a[i]->type() == glow_eObjectType_GrowAnnot
        && ((GlowAnnot*)a.a[i])->number == num) {
      ((GrowAnnot*)a.a[i])->get_text_extent(t, node, width, height);
      break;
    }
  }
}
