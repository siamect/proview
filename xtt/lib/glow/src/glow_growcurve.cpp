/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

#include "glow_std.h"


#include <iostream>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include "glow_growcurve.h"
#include "glow_grownode.h"
#include "glow_draw.h"
#include "glow_growctx.h"

GrowCurve::GrowCurve( GrowCtx *glow_ctx, const char *name, glow_sCurveData *data,
		      double x, double y,
		      double w, double h, glow_eDrawType border_d_type, int line_w,
		      glow_mDisplayLevel display_lev,
		      int fill_rect, int display_border, 
		      glow_eDrawType fill_d_type, int nodraw) : 
  GrowTrend(glow_ctx,name,x,y,w,h,border_d_type,line_w,
	    display_lev, fill_rect, display_border, fill_d_type, 1), type(glow_eCurveType_Line) 
{
  if ( data)
    configure_curves( data);
  if ( !nodraw)
    draw( &ctx->mw, (GlowTransform *)NULL, highlight, hot, NULL, NULL);

}

void GrowCurve::set_type( glow_eCurveType t)
{
  type = t;
}

void GrowCurve::configure_curves( glow_sCurveData *data)
{
  glow_eDrawType dt, dt_fill;
  int points;
  glow_sPoint *pointarray;
  glow_sPoint *point_p;
  int	i, idx = 0;
  double y_value, x_value, prev_y_value;
  glow_eCurveType curve_type;
  int pix = 0;

  // Remove old curves
  ctx->nodraw++;
  for ( i = 0; i < curve_cnt; i++) {
    if ( curve[i])
      delete curve[i];
  }
  ctx->nodraw--;

  if ( data->type == glow_eCurveDataType_CommonX) {

    curve_cnt = data->curves;
    no_of_points = data->rows[0];

    for ( i = 0; i < curve_cnt; i++) {
      y_max_value[i] = data->y_max_value[i];
      y_min_value[i] = data->y_min_value[i];
      curve_drawtype[i] = data->color[i];
      curve_fill_drawtype[i] = data->fillcolor[i];
    }

    curve_width = MIN( DRAW_TYPE_SIZE, MAX( 1, curve_width));

    for ( idx = 0; idx < curve_cnt; idx++) {

      if ( data->curve_type[idx] == glow_eCurveType_Inherit)
	curve_type = type;
      else
	curve_type = data->curve_type[idx];

      switch ( curve_type) {
      case glow_eCurveType_Inherit:
      case glow_eCurveType_Line:
      case glow_eCurveType_Points:
      case glow_eCurveType_LinePoints:
	points = no_of_points;
	if ( fill_curve)
	  points += 2;
	pointarray = (glow_sPoint *) calloc( points, sizeof(glow_sPoint));
	point_p = pointarray;
	for ( i = 0; i < points; i++) {
	  if ( !fill_curve) {
	    if ( data->x_reverse)
	      x_value = ur.x - (data->x_data[0][i] - data->x_min_value[0]) / 
		(data->x_max_value[0] - data->x_min_value[0]) * (ur.x - ll.x);
	    else
	      x_value = ll.x + (data->x_data[0][i] - data->x_min_value[0]) / 
		(data->x_max_value[0] - data->x_min_value[0]) * (ur.x - ll.x);
	    
	    x_value = MAX( ll.x, MIN( x_value, ur.x));
	    
	    y_value = ur.y - (data->y_data[idx][i] - y_min_value[idx]) / 
	      (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);
	    
	    y_value = MAX( ll.y, MIN( y_value, ur.y));
	    
	    point_p->y = y_value;
	    point_p->x = x_value;
	  }
	  else {
	    if ( i == 0) {
	      point_p->y = ur.y;
	      // point_p->x = ur.x;
	      if ( data->x_reverse)
		point_p->x = ur.x - (data->x_data[0][i] - data->x_min_value[0]) / 
		  (data->x_max_value[0] - data->x_min_value[0]) * (ur.x - ll.x);
	      else
		point_p->x = ll.x + (data->x_data[0][i] - data->x_min_value[0]) / 
		  (data->x_max_value[0] - data->x_min_value[0]) * (ur.x - ll.x);
	    }
	    else if ( i == points - 1) {
	      point_p->y = ur.y;
	      if ( data->x_reverse)
		point_p->x = ur.x - (data->x_data[0][i-2] - data->x_min_value[0]) / 
		  (data->x_max_value[0] - data->x_min_value[0]) * (ur.x - ll.x);
	      else
		point_p->x = ll.x + (data->x_data[0][i-2] - data->x_min_value[0]) / 
		  (data->x_max_value[0] - data->x_min_value[0]) * (ur.x - ll.x);
	      // point_p->x = ll.x;
	    }
	    else {
	      if ( data->x_reverse)
		x_value = ur.x - (data->x_data[0][i-1] - data->x_min_value[0]) / 
		  (data->x_max_value[0] - data->x_min_value[0]) * (ur.x - ll.x);
	      else
		x_value = ll.x + (data->x_data[0][i-1] - data->x_min_value[0]) / 
		  (data->x_max_value[0] - data->x_min_value[0]) * (ur.x - ll.x);
	      
	      x_value = MAX( ll.x, MIN( x_value, ur.x));
	      
	      y_value = ur.y - (data->y_data[idx][i-1] - y_min_value[idx]) / 
		(y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);
	      
	      y_value = MAX( ll.y, MIN( y_value, ur.y));

	      point_p->y = y_value;
	      point_p->x = x_value;
	    }
	  }
	  point_p++;
	}
	if ( curve_drawtype[idx] != glow_eDrawType_Inherit)
	  dt = curve_drawtype[idx];
	else
	  dt = draw_type;
      
	if ( curve_fill_drawtype[idx] != glow_eDrawType_Inherit)
	  dt_fill = curve_fill_drawtype[idx];
	else
	  dt_fill = draw_type;
      
	ctx->nodraw++;
	curve[idx] = new GrowPolyLine( ctx, "", pointarray, points, dt, 
				       curve_width,
				       0, fill_curve, 1, 0, dt_fill, 0, 0, 0, type);
	ctx->nodraw--;
	free( (char *) pointarray);
	break;

      case glow_eCurveType_Square:
	points = no_of_points * 2;
	if ( fill_curve)
	  points += 3;
	else
	  points += 1;
	pointarray = (glow_sPoint *) calloc( points, sizeof(glow_sPoint));

	if ( !fill_curve) {
	  for ( i = 0; i < data->rows[0]; i++) {
	    if ( data->x_reverse)
	      x_value = ur.x - (data->x_data[0][i] - data->x_min_value[0]) / 
		(data->x_max_value[0] - data->x_min_value[0]) * (ur.x - ll.x);
	    else
	      x_value = ll.x + (data->x_data[0][i] - data->x_min_value[0]) / 
		(data->x_max_value[0] - data->x_min_value[0]) * (ur.x - ll.x);
	    
	    x_value = MAX( ll.x, MIN( x_value, ur.x));
	    
	    y_value = ur.y - (data->y_data[idx][i] - y_min_value[idx]) / 
	      (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);
	    
	    y_value = MAX( ll.y, MIN( y_value, ur.y));
	    
	    if ( i == 0) {
	      pointarray[i*2].y = y_value;
	      pointarray[i*2].x = ll.x;
	    }
	    else {
	      pointarray[i*2].y = prev_y_value;
	      pointarray[i*2].x = x_value;
	    }
	    pointarray[i*2+1].y = y_value;
	    pointarray[i*2+1].x = x_value;
	    prev_y_value = y_value;
	  }
	  pointarray[points-1].y = pointarray[points-2].y;
	  pointarray[points-1].x = ur.x;
	}
	else {
	  // First point
	  pointarray[0].y = ur.y;
	  if ( data->x_reverse)
	    pointarray[0].x = ur.x - (data->x_data[0][0] - data->x_min_value[0]) / 
	      (data->x_max_value[0] - data->x_min_value[0]) * (ur.x - ll.x);
	  else
	    pointarray[0].x = ll.x + (data->x_data[0][0] - data->x_min_value[0]) / 
	      (data->x_max_value[0] - data->x_min_value[0]) * (ur.x - ll.x);

	  for ( i = 0; i < data->rows[0]; i++) {
	    if ( data->x_reverse)
	      x_value = ur.x - (data->x_data[0][i] - data->x_min_value[0]) / 
		(data->x_max_value[0] - data->x_min_value[0]) * (ur.x - ll.x);
	    else
	      x_value = ll.x + (data->x_data[0][i] - data->x_min_value[0]) / 
		(data->x_max_value[0] - data->x_min_value[0]) * (ur.x - ll.x);
	    
	    x_value = MAX( ll.x, MIN( x_value, ur.x));
	    
	    y_value = ur.y - (data->y_data[idx][i] - y_min_value[idx]) / 
	      (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);
	    
	    y_value = MAX( ll.y, MIN( y_value, ur.y));

	    if ( i == 0) {
	      pointarray[0].y = ur.y;
	      pointarray[0].x = ll.x;
	      pointarray[1].y = y_value;
	      pointarray[1].x = ll.x;
	    }
	    else {
	      pointarray[i*2+1].y = prev_y_value;
	      pointarray[i*2+1].x = x_value;
	    }
	    pointarray[i*2+2].y = y_value;
	    pointarray[i*2+2].x = x_value;
	    prev_y_value = y_value;
	  }

	  // Last point
	  pointarray[points-2].y = pointarray[points-3].y;
	  pointarray[points-2].x = ur.x;
	  pointarray[points-1].y = ur.y;
	  pointarray[points-1].x = ur.x;
	}
	if ( curve_drawtype[idx] != glow_eDrawType_Inherit)
	  dt = curve_drawtype[idx];
	else
	  dt = draw_type;
	  
	if ( curve_fill_drawtype[idx] != glow_eDrawType_Inherit)
	  dt_fill = curve_fill_drawtype[idx];
	else
	  dt_fill = draw_type;
	  
	ctx->nodraw++;
	curve[idx] = new GrowPolyLine( ctx, "", pointarray, points, dt, 
					 curve_width,
					 0, fill_curve, 1, 0, dt_fill);
	ctx->nodraw--;
	free( (char *) pointarray);
	break;
      case glow_eCurveType_DigSquare: {
	points = no_of_points * 2;
	if ( fill_curve)
	  points += 5;
	else
	  points += 3;
	pointarray = (glow_sPoint *) calloc( points, sizeof(glow_sPoint));

	double y1 = ur.y - (1 - y_min_value[idx]) / 
	  (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);	
	y1 = MAX( ll.y, MIN( y1, ur.y));

	if ( !fill_curve) {
	  pix = 0;
	  for ( i = 0; i < data->rows[0]; i++) {
	    if ( data->x_reverse)
	      x_value = ur.x - (data->x_data[0][i] - data->x_min_value[0]) / 
		(data->x_max_value[0] - data->x_min_value[0]) * (ur.x - ll.x);
	    else
	      x_value = ll.x + (data->x_data[0][i] - data->x_min_value[0]) / 
		(data->x_max_value[0] - data->x_min_value[0]) * (ur.x - ll.x);
	    
	    x_value = MAX( ll.x, MIN( x_value, ur.x));
	    
	    y_value = ur.y - (data->y_data[idx][i] - y_min_value[idx]) / 
	      (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);
	    
	    y_value = MAX( ll.y, MIN( y_value, ur.y));

	    if ( i == 0) {
	      if ( data->y_data[idx][0] == 1) {
		pointarray[pix].y = ur.y;
		pointarray[pix++].x = ll.x;
		pointarray[pix].y = ur.y;
		pointarray[pix++].x = x_value;
	      }
	      else {
		pointarray[pix].y = y1;
		pointarray[pix++].x = ll.x;
		pointarray[pix].y = y1;
		pointarray[pix++].x = x_value;
	      }
	    }
	    else {
	      pointarray[pix].y = prev_y_value;
	      pointarray[pix++].x = x_value;
	    }
	    pointarray[pix].y = y_value;
	    pointarray[pix++].x = x_value;
	    prev_y_value = y_value;
	  }
	  pointarray[pix].y = prev_y_value;
	  pointarray[pix++].x = ur.x;
	  points = pix;
	}
	else {

	  for ( i = 0; i < (points-5)/2; i++) {
	    if ( data->x_reverse)
	      x_value = ur.x - (data->x_data[0][i] - data->x_min_value[0]) / 
		(data->x_max_value[0] - data->x_min_value[0]) * (ur.x - ll.x);
	    else
	      x_value = ll.x + (data->x_data[0][i] - data->x_min_value[0]) / 
		(data->x_max_value[0] - data->x_min_value[0]) * (ur.x - ll.x);
	    
	    x_value = MAX( ll.x, MIN( x_value, ur.x));
	    
	    y_value = ur.y - (data->y_data[idx][i] - y_min_value[idx]) / 
	      (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);
	    
	    y_value = MAX( ll.y, MIN( y_value, ur.y));

	    if ( i == 0) {
	      if ( data->y_data[idx][0] == 1) {
		pointarray[pix].y = ur.y;
		pointarray[pix++].x = x_value;
		pointarray[pix].y = ur.y;
		pointarray[pix++].x = x_value;
		pointarray[pix].y = ur.y;
		pointarray[pix++].x = x_value;
	      }
	      else {
		pointarray[pix].y = ur.y;
		pointarray[pix++].x = ll.x;
		pointarray[pix].y = y1;
		pointarray[pix++].x = ll.x;
		pointarray[pix].y = y1;
		pointarray[pix++].x = x_value;
	      }
	    }
	    else {
	      pointarray[pix].y = prev_y_value;
	      pointarray[pix++].x = x_value;
	    }
	    pointarray[pix].y = y_value;
	    pointarray[pix++].x = x_value;
	    prev_y_value = y_value;
	  }

	  // Last point
	  if ( data->y_data[idx][data->rows[0]-1] != 0) {
	    pointarray[pix].y = y1;
	    pointarray[pix++].x = ur.x;
	    pointarray[pix].y = ur.y;
	    pointarray[pix++].x = ur.x;
	  }
	  points = pix;
	}
	if ( curve_drawtype[idx] != glow_eDrawType_Inherit)
	  dt = curve_drawtype[idx];
	else
	  dt = draw_type;
	  
	if ( curve_fill_drawtype[idx] != glow_eDrawType_Inherit)
	  dt_fill = curve_fill_drawtype[idx];
	else
	  dt_fill = draw_type;
	  
	ctx->nodraw++;
	curve[idx] = new GrowPolyLine( ctx, "", pointarray, points, dt, 
					 curve_width,
					 0, fill_curve, 1, 0, dt_fill);
	ctx->nodraw--;
	free( (char *) pointarray);
	break;
      }
      default: ;
      }
    }

    draw();
  }
  else if ( data->type == glow_eCurveDataType_SeparateX) {

    curve_cnt = data->curves;
    no_of_points = data->rows[0];

    for ( i = 0; i < curve_cnt; i++) {
      y_max_value[i] = data->y_max_value[i];
      y_min_value[i] = data->y_min_value[i];
      curve_drawtype[i] = data->color[i];
      curve_fill_drawtype[i] = data->fillcolor[i];
    }

    curve_width = MIN( DRAW_TYPE_SIZE, MAX( 1, curve_width));

    for ( idx = 0; idx < curve_cnt; idx++) {
      if ( data->curve_type[idx] == glow_eCurveType_Inherit)
	curve_type = type;
      else
	curve_type = data->curve_type[idx];

      switch ( curve_type) {
      case glow_eCurveType_Inherit:
      case glow_eCurveType_Line:
      case glow_eCurveType_Points:
      case glow_eCurveType_LinePoints:
	points = data->rows[idx];
	if ( fill_curve)
	  points += 2;
      
	pointarray = (glow_sPoint *) calloc( points, sizeof(glow_sPoint));

	if ( !fill_curve) {
	  for ( i = 0; i < points; i++) {
	    if ( data->x_reverse)
	      x_value = ur.x - (data->x_data[idx][i] - data->x_min_value[idx]) / 
		(data->x_max_value[idx] - data->x_min_value[idx]) * (ur.x - ll.x);
	    else
	      x_value = ll.x + (data->x_data[idx][i] - data->x_min_value[idx]) / 
		(data->x_max_value[idx] - data->x_min_value[idx]) * (ur.x - ll.x);
	    
	    x_value = max( ll.x, min( x_value, ur.x));

	    y_value = ur.y - (data->y_data[idx][i] - y_min_value[idx]) / 
	      (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);

	    y_value = max( ll.y, min( y_value, ur.y));

	    pointarray[i].y = y_value;
	    pointarray[i].x = x_value;
	  }
	}
	else {
	  for ( i = 0; i < points-2; i++) {
	    if ( data->x_reverse)
	      x_value = ur.x - (data->x_data[idx][i] - data->x_min_value[idx]) / 
		(data->x_max_value[idx] - data->x_min_value[idx]) * (ur.x - ll.x);
	    else
	      x_value = ll.x + (data->x_data[idx][i] - data->x_min_value[idx]) / 
		(data->x_max_value[idx] - data->x_min_value[idx]) * (ur.x - ll.x);
	    
	    x_value = max( ll.x, min( x_value, ur.x));

	    y_value = ur.y - (data->y_data[idx][i] - y_min_value[idx]) / 
	      (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);

	    y_value = max( ll.y, min( y_value, ur.y));

	    if ( i == 0) {
	      pointarray[0].y = ur.y;
	      pointarray[0].x = x_value;
	    }
	    pointarray[i+1].y = y_value;
	    pointarray[i+1].x = x_value;
	  }
	  pointarray[points - 1].y = ur.y;
	  pointarray[points - 1].x = pointarray[points - 2].x;
	}
	break;
      case glow_eCurveType_Square:
	points = data->rows[idx] * 2;
	if ( fill_curve)
	  points += 3;
	else
	  points += 1;
      
	pointarray = (glow_sPoint *) calloc( points, sizeof(glow_sPoint));
	
	if ( !fill_curve) {
	  pix = 0;
	  for ( i = 0; i < data->rows[idx]; i++) {
	    if ( data->x_reverse)
	      x_value = ur.x - (data->x_data[idx][i] - data->x_min_value[idx]) / 
		(data->x_max_value[idx] - data->x_min_value[idx]) * (ur.x - ll.x);
	    else
	      x_value = ll.x + (data->x_data[idx][i] - data->x_min_value[idx]) / 
		(data->x_max_value[idx] - data->x_min_value[idx]) * (ur.x - ll.x);

	    x_value = MAX( ll.x, MIN( x_value, ur.x));

	    y_value = ur.y - (data->y_data[idx][i] - y_min_value[idx]) / 
	      (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);
	    
	    y_value = MAX( ll.y, MIN( y_value, ur.y));
	  
	    if ( i == 0) {
	      pointarray[pix].y = y_value;
	      pointarray[pix++].x = ll.x;
	    }
	    else {
	      pointarray[pix].y = prev_y_value;
	      pointarray[pix++].x = x_value;
	    }
	    pointarray[pix].y = y_value;
	    pointarray[pix++].x = x_value;
	    prev_y_value = y_value;
	  }
	  pointarray[pix].y = pointarray[pix-1].y;
	  pointarray[pix++].x = ur.x;
	  points = pix;
	}
	else {
	  pix = 0;
	  for ( i = 0; i < data->rows[idx]; i++) {
	    if ( data->x_reverse)
	      x_value = ur.x - (data->x_data[idx][i] - data->x_min_value[idx]) / 
		(data->x_max_value[idx] - data->x_min_value[idx]) * (ur.x - ll.x);
	    else
	      x_value = ll.x + (data->x_data[idx][i] - data->x_min_value[idx]) / 
		(data->x_max_value[idx] - data->x_min_value[idx]) * (ur.x - ll.x);
	    
	    x_value = MAX( ll.x, MIN( x_value, ur.x));
	    
	    y_value = ur.y - (data->y_data[idx][i] - y_min_value[idx]) / 
	      (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);
	    
	    y_value = MAX( ll.y, MIN( y_value, ur.y));

	    if ( i == 0) {
	      pointarray[pix].y = ur.y;
	      pointarray[pix++].x = ll.x;
	      pointarray[pix].y = y_value;
	      pointarray[pix++].x = ll.x;
	    }
	    else {
	      pointarray[pix].y = prev_y_value;
	      pointarray[pix++].x = x_value;
	    }
	    pointarray[pix].y = y_value;
	    pointarray[pix++].x = x_value;
	    prev_y_value = y_value;
	  }

	  // Last point
	  pointarray[pix].y = pointarray[pix-1].y;
	  pointarray[pix++].x = ur.x;
	  pointarray[pix].y = ur.y;
	  pointarray[pix++].x = ur.x;
	  points = pix;
	}
	break;
      case glow_eCurveType_DigSquare: {
	points = data->rows[idx] * 2;
	if ( fill_curve)
	  points += 5;
	else
	  points += 3;
      
	pointarray = (glow_sPoint *) calloc( points, sizeof(glow_sPoint));
	
	double y1 = ur.y - (1 - y_min_value[idx]) / 
	  (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);
	
	y1 = MAX( ll.y, MIN( y1, ur.y));

	if ( !fill_curve) {
	  pix = 0;
	  for ( i = 0; i < data->rows[idx]; i++) {
	    if ( data->x_reverse)
	      x_value = ur.x - (data->x_data[idx][i] - data->x_min_value[idx]) / 
		(data->x_max_value[idx] - data->x_min_value[idx]) * (ur.x - ll.x);
	    else
	      x_value = ll.x + (data->x_data[idx][i] - data->x_min_value[idx]) / 
		(data->x_max_value[idx] - data->x_min_value[idx]) * (ur.x - ll.x);

	    x_value = MAX( ll.x, MIN( x_value, ur.x));

	    y_value = ur.y - (data->y_data[idx][i] - y_min_value[idx]) / 
	      (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);
	    
	    y_value = MAX( ll.y, MIN( y_value, ur.y));
	  
	    if ( i == 0) {
	      if ( data->y_data[idx][0] == 1) {
		pointarray[pix].y = ur.y;
		pointarray[pix++].x = ll.x;
		pointarray[pix].y = ur.y;
		pointarray[pix++].x = x_value;
	      }
	      else {
		pointarray[pix].y = y1;
		pointarray[pix++].x = ll.x;
		pointarray[pix].y = y1;
		pointarray[pix++].x = x_value;
	      }
	    }
	    else {
	      pointarray[pix].y = prev_y_value;
	      pointarray[pix++].x = x_value;
	    }
	    pointarray[pix].y = y_value;
	    pointarray[pix++].x = x_value;
	    prev_y_value = y_value;
	  }
	  // Last point
	  pointarray[pix].y = pointarray[pix-1].y;
	  pointarray[pix++].x = ur.x;
	  points = pix;
	}
	else {
	  pix = 0;
	  for ( i = 0; i < data->rows[idx]; i++) {
	    if ( data->x_reverse)
	      x_value = ur.x - (data->x_data[idx][i] - data->x_min_value[idx]) / 
		(data->x_max_value[idx] - data->x_min_value[idx]) * (ur.x - ll.x);
	    else
	      x_value = ll.x + (data->x_data[idx][i] - data->x_min_value[idx]) / 
		(data->x_max_value[idx] - data->x_min_value[idx]) * (ur.x - ll.x);
	    
	    x_value = MAX( ll.x, MIN( x_value, ur.x));
	    
	    y_value = ur.y - (data->y_data[idx][i] - y_min_value[idx]) / 
	      (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);
	    
	    y_value = MAX( ll.y, MIN( y_value, ur.y));

	    if ( i == 0) {
	      if ( data->y_data[idx][0] == 1) {
		pointarray[pix].y = ur.y;
		pointarray[pix++].x = x_value;
		pointarray[pix].y = ur.y;
		pointarray[pix++].x = x_value;
		pointarray[pix].y = ur.y;
		pointarray[pix++].x = x_value;
	      }
	      else {
 		pointarray[pix].y = ur.y;
		pointarray[pix++].x = ll.x;
 		pointarray[pix].y = y1;
		pointarray[pix++].x = ll.x;
		pointarray[pix].y = y1;
		pointarray[pix++].x = x_value;
	      }
	    }
	    else {
	      pointarray[pix].y = prev_y_value;
	      pointarray[pix++].x = x_value;
	    }
	    pointarray[pix].y = y_value;
	    pointarray[pix++].x = x_value;
	    prev_y_value = y_value;
	  }

	  // Last point
	  if ( data->y_data[idx][data->rows[idx]-1] != 0) {
	    pointarray[pix].y = y1;
	    pointarray[pix++].x = ur.x;
	    pointarray[pix].y = ur.y;
	    pointarray[pix++].x = ur.x;
	  }
	  printf( "Points %d pix %d\n", points, pix);
	  points = pix;
	}
	break;
      }
      default: ;
      }

      if ( curve_drawtype[idx] != glow_eDrawType_Inherit)
	dt = curve_drawtype[idx];
      else
	dt = draw_type;
      
      if ( curve_fill_drawtype[idx] != glow_eDrawType_Inherit)
	dt_fill = curve_fill_drawtype[idx];
      else
	dt_fill = draw_type;

      ctx->nodraw++;
      curve[idx] = new GrowPolyLine( ctx, "", pointarray, points, dt, 
				     curve_width,
				     0, fill_curve, 1, 0, dt_fill, 0, 0, 0, type);
      ctx->nodraw--;

      free( (char *) pointarray);
    }

    draw();
  }
}


void GrowCurve::add_points( glow_sCurveData *data, unsigned int no_of_points)
{
  if ( data->type == glow_eCurveDataType_CommonX) {

    // Remove old curves
    ctx->nodraw++;
    if ( no_of_points == 1) {
      double y_value;
      int	idx;

      for ( idx = 0; idx < curve_cnt; idx++) {
	y_value = ur.y - (data->y_data[idx][0] - y_min_value[idx]) / 
	  (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);

	y_value = MAX( ll.y, MIN( y_value, ur.y));

	if ( !fill)
	  erase( &ctx->mw);

	if ( !fill_curve)
	  curve[idx]->add_and_shift_y_value( y_value);
	else
	  curve[idx]->add_and_shift_y_value_filled( y_value);
      }
    }
    else {
      double *y_values;
      int i, idx;

      for ( idx = 0; idx < curve_cnt; idx++) {
	y_values = (double *)calloc( 1, no_of_points * sizeof(double));

	for ( i = 0; i < (int)no_of_points; i++) {
	  y_values[i] = ur.y - (data->y_data[idx][i] - y_min_value[idx]) / 
	    (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);

	  y_values[i] = MAX( ll.y, MIN( y_values[i], ur.y));
	}
	if ( !fill)
	  erase( &ctx->mw);

	if ( !fill_curve)
	  curve[idx]->add_and_shift_y_values( y_values, no_of_points);
	else
	  curve[idx]->add_and_shift_y_values_filled( y_values, no_of_points);

	free( (char *)y_values);
      }
    }
    ctx->nodraw--;
    
    draw();
    // draw( (GlowTransform *)NULL, highlight, hot, NULL, NULL);
    ctx->nav_draw( &ctx->navw, 0, 0, ctx->navw.window_width, ctx->navw.window_height);
    // nav_draw( (GlowTransform *) NULL, highlight, NULL, NULL);
  }
}
