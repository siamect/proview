/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <stdlib.h>

#include "glow_growcurve.h"
#include "glow_grownode.h"

GrowCurve::GrowCurve(GrowCtx* glow_ctx, const char* name, glow_sCurveData* data,
    double x, double y, double w, double h, glow_eDrawType border_d_type,
    int line_w, glow_mDisplayLevel display_lev, int fill_rect,
    int display_border, glow_eDrawType fill_d_type, int nodraw)
    : GrowTrend(glow_ctx, name, x, y, w, h, border_d_type, line_w, display_lev,
          fill_rect, display_border, fill_d_type, 1),
      type(glow_eCurveType_Line), split_digsquare(0)
{
  if (data)
    configure_curves(data);
  if (!nodraw)
    draw(&ctx->mw, (GlowTransform*)NULL, highlight, hot, NULL, NULL);
}

GrowCurve::~GrowCurve()
{
}

void GrowCurve::set_type(glow_eCurveType t)
{
  type = t;
}

void GrowCurve::configure_curves(glow_sCurveData* data)
{
  glow_eDrawType dt, dt_fill;
  int points;
  glow_sPoint* pointarray;
  glow_sPoint* point_p;
  int i, idx = 0;
  double y_value, x_value, prev_y_value = 0.0;
  glow_eCurveType curve_type;
  int pix = 0;
  int dix = 0;

  // Remove old curves
  ctx->nodraw++;
  for (i = 0; i < curve_cnt; i++) {
    if (curve[i])
      delete curve[i];
  }
  ctx->nodraw--;

  if (data->type == glow_eCurveDataType_CommonX) {
    curve_cnt = data->curves;
    no_of_points = data->rows[0];

    for (i = 0; i < curve_cnt; i++) {
      y_max_value[i] = data->y_max_value[i];
      y_min_value[i] = data->y_min_value[i];
      curve_drawtype[i] = data->color[i];
      curve_fill_drawtype[i] = data->fillcolor[i];
    }

    curve_width = MIN(DRAW_TYPE_SIZE, MAX(1, curve_width));

    for (idx = 0; idx < curve_cnt; idx++) {
      if (data->curve_type[idx] == glow_eCurveType_Inherit)
        curve_type = type;
      else
        curve_type = data->curve_type[idx];

      switch (curve_type) {
      case glow_eCurveType_Inherit:
      case glow_eCurveType_Line:
      case glow_eCurveType_Points:
      case glow_eCurveType_LinePoints:
        points = no_of_points;
        if (fill_curve)
          points += 2;
        pointarray = (glow_sPoint*)calloc(points, sizeof(glow_sPoint));
        point_p = pointarray;
        for (i = 0; i < points; i++) {
          if (!fill_curve) {
            if (data->x_reverse)
              x_value = ur.x
                  - (data->x_data[0][i] - data->x_min_value[0])
                      / (data->x_max_value[0] - data->x_min_value[0])
                      * (ur.x - ll.x);
            else
              x_value = ll.x
                  + (data->x_data[0][i] - data->x_min_value[0])
                      / (data->x_max_value[0] - data->x_min_value[0])
                      * (ur.x - ll.x);

            x_value = MAX(ll.x, MIN(x_value, ur.x));

            y_value = ur.y
                - (data->y_data[idx][i] - y_min_value[idx])
                    / (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);

            // y_value = MAX( ll.y, MIN( y_value, ur.y));

            point_p->y = y_value;
            point_p->x = x_value;
          } else {
            if (i == 0) {
              point_p->y = ur.y;
              // point_p->x = ur.x;
              if (data->x_reverse)
                point_p->x = ur.x
                    - (data->x_data[0][i] - data->x_min_value[0])
                        / (data->x_max_value[0] - data->x_min_value[0])
                        * (ur.x - ll.x);
              else
                point_p->x = ll.x
                    + (data->x_data[0][i] - data->x_min_value[0])
                        / (data->x_max_value[0] - data->x_min_value[0])
                        * (ur.x - ll.x);
            } else if (i == points - 1) {
              point_p->y = ur.y;
              if (data->x_reverse)
                point_p->x = ur.x
                    - (data->x_data[0][i - 2] - data->x_min_value[0])
                        / (data->x_max_value[0] - data->x_min_value[0])
                        * (ur.x - ll.x);
              else
                point_p->x = ll.x
                    + (data->x_data[0][i - 2] - data->x_min_value[0])
                        / (data->x_max_value[0] - data->x_min_value[0])
                        * (ur.x - ll.x);
              // point_p->x = ll.x;
            } else {
              if (data->x_reverse)
                x_value = ur.x
                    - (data->x_data[0][i - 1] - data->x_min_value[0])
                        / (data->x_max_value[0] - data->x_min_value[0])
                        * (ur.x - ll.x);
              else
                x_value = ll.x
                    + (data->x_data[0][i - 1] - data->x_min_value[0])
                        / (data->x_max_value[0] - data->x_min_value[0])
                        * (ur.x - ll.x);

              x_value = MAX(ll.x, MIN(x_value, ur.x));

              y_value = ur.y
                  - (data->y_data[idx][i - 1] - y_min_value[idx])
                      / (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);

              // y_value = MAX( ll.y, MIN( y_value, ur.y));

              point_p->y = y_value;
              point_p->x = x_value;
            }
          }
          point_p++;
        }
        if (curve_drawtype[idx] != glow_eDrawType_Inherit)
          dt = curve_drawtype[idx];
        else
          dt = draw_type;

        if (curve_fill_drawtype[idx] != glow_eDrawType_Inherit)
          dt_fill = curve_fill_drawtype[idx];
        else
          dt_fill = draw_type;

        ctx->nodraw++;
        curve[idx] = new GrowPolyLine(ctx, "", pointarray, points, dt,
            curve_width, 0, fill_curve, 1, 0, dt_fill, 0, 0, 0, type);
        ctx->nodraw--;
        free((char*)pointarray);
        break;

      case glow_eCurveType_Square:
        points = no_of_points * 2;
        if (fill_curve)
          points += 3;
        else
          points += 1;
        pointarray = (glow_sPoint*)calloc(points, sizeof(glow_sPoint));

        if (!fill_curve) {
          for (i = 0; i < data->rows[0]; i++) {
            if (data->x_reverse)
              x_value = ur.x
                  - (data->x_data[0][i] - data->x_min_value[0])
                      / (data->x_max_value[0] - data->x_min_value[0])
                      * (ur.x - ll.x);
            else
              x_value = ll.x
                  + (data->x_data[0][i] - data->x_min_value[0])
                      / (data->x_max_value[0] - data->x_min_value[0])
                      * (ur.x - ll.x);

            x_value = MAX(ll.x, MIN(x_value, ur.x));

            y_value = ur.y
                - (data->y_data[idx][i] - y_min_value[idx])
                    / (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);

            y_value = MAX(ll.y, MIN(y_value, ur.y));

            if (i == 0) {
              pointarray[i * 2].y = y_value;
              pointarray[i * 2].x = ll.x;
            } else {
              pointarray[i * 2].y = prev_y_value;
              pointarray[i * 2].x = x_value;
            }
            pointarray[i * 2 + 1].y = y_value;
            pointarray[i * 2 + 1].x = x_value;
            prev_y_value = y_value;
          }
          pointarray[points - 1].y = pointarray[points - 2].y;
          pointarray[points - 1].x = ur.x;
        } else {
          // First point
          pointarray[0].y = ur.y;
          if (data->x_reverse)
            pointarray[0].x = ur.x
                - (data->x_data[0][0] - data->x_min_value[0])
                    / (data->x_max_value[0] - data->x_min_value[0])
                    * (ur.x - ll.x);
          else
            pointarray[0].x = ll.x
                + (data->x_data[0][0] - data->x_min_value[0])
                    / (data->x_max_value[0] - data->x_min_value[0])
                    * (ur.x - ll.x);

          for (i = 0; i < data->rows[0]; i++) {
            if (data->x_reverse)
              x_value = ur.x
                  - (data->x_data[0][i] - data->x_min_value[0])
                      / (data->x_max_value[0] - data->x_min_value[0])
                      * (ur.x - ll.x);
            else
              x_value = ll.x
                  + (data->x_data[0][i] - data->x_min_value[0])
                      / (data->x_max_value[0] - data->x_min_value[0])
                      * (ur.x - ll.x);

            x_value = MAX(ll.x, MIN(x_value, ur.x));

            y_value = ur.y
                - (data->y_data[idx][i] - y_min_value[idx])
                    / (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);

            y_value = MAX(ll.y, MIN(y_value, ur.y));

            if (i == 0) {
              pointarray[0].y = ur.y;
              pointarray[0].x = ll.x;
              pointarray[1].y = y_value;
              pointarray[1].x = ll.x;
            } else {
              pointarray[i * 2 + 1].y = prev_y_value;
              pointarray[i * 2 + 1].x = x_value;
            }
            pointarray[i * 2 + 2].y = y_value;
            pointarray[i * 2 + 2].x = x_value;
            prev_y_value = y_value;
          }

          // Last point
          pointarray[points - 2].y = pointarray[points - 3].y;
          pointarray[points - 2].x = ur.x;
          pointarray[points - 1].y = ur.y;
          pointarray[points - 1].x = ur.x;
        }
        if (curve_drawtype[idx] != glow_eDrawType_Inherit)
          dt = curve_drawtype[idx];
        else
          dt = draw_type;

        if (curve_fill_drawtype[idx] != glow_eDrawType_Inherit)
          dt_fill = curve_fill_drawtype[idx];
        else
          dt_fill = draw_type;

        ctx->nodraw++;
        curve[idx] = new GrowPolyLine(ctx, "", pointarray, points, dt,
            curve_width, 0, fill_curve, 1, 0, dt_fill);
        ctx->nodraw--;
        free((char*)pointarray);
        break;
      case glow_eCurveType_DigSquare: {
        points = no_of_points * 2;
        if (fill_curve)
          points += 5;
        else
          points += 3;
        pointarray = (glow_sPoint*)calloc(points, sizeof(glow_sPoint));

        double yoffs;
        if (split_digsquare)
          yoffs = (dix % 10) * (ur.y - ll.y) / 10;
        else
          yoffs = 0;
        dix++;
        double y0 = ur.y - yoffs;
        double y1 = y0 - (ur.y - ll.y) * 0.08;

        if (!fill_curve) {
          pix = 0;
          for (i = 0; i < data->rows[0]; i++) {
            if (data->x_reverse)
              x_value = ur.x
                  - (data->x_data[0][i] - data->x_min_value[0])
                      / (data->x_max_value[0] - data->x_min_value[0])
                      * (ur.x - ll.x);
            else
              x_value = ll.x
                  + (data->x_data[0][i] - data->x_min_value[0])
                      / (data->x_max_value[0] - data->x_min_value[0])
                      * (ur.x - ll.x);

            x_value = MAX(ll.x, MIN(x_value, ur.x));

            if (data->y_data[idx][i])
              y_value = y1;
            else
              y_value = y0;

            if (i == 0) {
              if (feq(data->y_data[idx][0], 1.0)) {
                pointarray[pix].y = y0;
                pointarray[pix++].x = ll.x;
                pointarray[pix].y = y0;
                pointarray[pix++].x = x_value;
              } else {
                pointarray[pix].y = y1;
                pointarray[pix++].x = ll.x;
                pointarray[pix].y = y1;
                pointarray[pix++].x = x_value;
              }
            } else {
              pointarray[pix].y = prev_y_value;
              pointarray[pix++].x = x_value;
            }
            pointarray[pix].y = y_value;
            pointarray[pix++].x = x_value;
            prev_y_value = y_value;
          }
          pointarray[pix].y = prev_y_value;
          pointarray[pix++].x = ur.x;
          points = pix;
        } else {
          for (i = 0; i < (points - 5) / 2; i++) {
            if (data->x_reverse)
              x_value = ur.x
                  - (data->x_data[0][i] - data->x_min_value[0])
                      / (data->x_max_value[0] - data->x_min_value[0])
                      * (ur.x - ll.x);
            else
              x_value = ll.x
                  + (data->x_data[0][i] - data->x_min_value[0])
                      / (data->x_max_value[0] - data->x_min_value[0])
                      * (ur.x - ll.x);

            x_value = MAX(ll.x, MIN(x_value, ur.x));

            if (data->y_data[idx][i])
              y_value = y1;
            else
              y_value = y0;

            if (i == 0) {
              if (feq(data->y_data[idx][0], 1.0)) {
                pointarray[pix].y = y0;
                pointarray[pix++].x = x_value;
              } else {
                pointarray[pix].y = y0;
                pointarray[pix++].x = ll.x;
                pointarray[pix].y = y1;
                pointarray[pix++].x = ll.x;
                pointarray[pix].y = y1;
                pointarray[pix++].x = x_value;
              }
            } else {
              pointarray[pix].y = prev_y_value;
              pointarray[pix++].x = x_value;
            }
            pointarray[pix].y = y_value;
            pointarray[pix++].x = x_value;
            prev_y_value = y_value;
          }

          // Last point
          if (!feq(data->y_data[idx][data->rows[0] - 1], 0.0)) {
            pointarray[pix].y = y1;
            pointarray[pix++].x = ur.x;
            pointarray[pix].y = y0;
            pointarray[pix++].x = ur.x;
          }
          points = pix;
        }
        if (curve_drawtype[idx] != glow_eDrawType_Inherit)
          dt = curve_drawtype[idx];
        else
          dt = draw_type;

        if (curve_fill_drawtype[idx] != glow_eDrawType_Inherit)
          dt_fill = curve_fill_drawtype[idx];
        else
          dt_fill = draw_type;

        ctx->nodraw++;
        curve[idx] = new GrowPolyLine(ctx, "", pointarray, points, dt,
            curve_width, 0, fill_curve, 1, 0, dt_fill);
        ctx->nodraw--;
        free((char*)pointarray);
        break;
      }
      default:;
      }
    }

    draw();
  } else if (data->type == glow_eCurveDataType_SeparateX) {
    curve_cnt = data->curves;
    no_of_points = data->rows[0];

    for (i = 0; i < curve_cnt; i++) {
      y_max_value[i] = data->y_max_value[i];
      y_min_value[i] = data->y_min_value[i];
      curve_drawtype[i] = data->color[i];
      curve_fill_drawtype[i] = data->fillcolor[i];
    }

    curve_width = MIN(DRAW_TYPE_SIZE, MAX(1, curve_width));

    for (idx = 0; idx < curve_cnt; idx++) {
      if (data->curve_type[idx] == glow_eCurveType_Inherit)
        curve_type = type;
      else
        curve_type = data->curve_type[idx];

      switch (curve_type) {
      case glow_eCurveType_Inherit:
      case glow_eCurveType_Line:
      case glow_eCurveType_Points:
      case glow_eCurveType_LinePoints:
        points = data->rows[idx];
        if (fill_curve)
          points += 2;

        pointarray = (glow_sPoint*)calloc(points, sizeof(glow_sPoint));

        if (!fill_curve) {
          for (i = 0; i < points; i++) {
            if (data->x_reverse)
              x_value = ur.x
                  - (data->x_data[idx][i] - data->x_min_value[idx])
                      / (data->x_max_value[idx] - data->x_min_value[idx])
                      * (ur.x - ll.x);
            else
              x_value = ll.x
                  + (data->x_data[idx][i] - data->x_min_value[idx])
                      / (data->x_max_value[idx] - data->x_min_value[idx])
                      * (ur.x - ll.x);

            x_value = MAX(ll.x, MIN(x_value, ur.x));

            y_value = ur.y
                - (data->y_data[idx][i] - y_min_value[idx])
                    / (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);

            // y_value = MAX( ll.y, MIN( y_value, ur.y));

            pointarray[i].y = y_value;
            pointarray[i].x = x_value;
          }
        } else {
          for (i = 0; i < points - 2; i++) {
            if (data->x_reverse)
              x_value = ur.x
                  - (data->x_data[idx][i] - data->x_min_value[idx])
                      / (data->x_max_value[idx] - data->x_min_value[idx])
                      * (ur.x - ll.x);
            else
              x_value = ll.x
                  + (data->x_data[idx][i] - data->x_min_value[idx])
                      / (data->x_max_value[idx] - data->x_min_value[idx])
                      * (ur.x - ll.x);

            x_value = MAX(ll.x, MIN(x_value, ur.x));

            y_value = ur.y
                - (data->y_data[idx][i] - y_min_value[idx])
                    / (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);

            // y_value = MAX( ll.y, MIN( y_value, ur.y));

            if (i == 0) {
              pointarray[0].y = ur.y;
              pointarray[0].x = x_value;
            }
            pointarray[i + 1].y = y_value;
            pointarray[i + 1].x = x_value;
          }
          pointarray[points - 1].y = ur.y;
          pointarray[points - 1].x = pointarray[points - 2].x;
        }
        break;
      case glow_eCurveType_Square:
        points = data->rows[idx] * 2;
        if (fill_curve)
          points += 3;
        else
          points += 1;

        pointarray = (glow_sPoint*)calloc(points, sizeof(glow_sPoint));

        if (!fill_curve) {
          pix = 0;
          for (i = 0; i < data->rows[idx]; i++) {
            if (data->x_reverse)
              x_value = ur.x
                  - (data->x_data[idx][i] - data->x_min_value[idx])
                      / (data->x_max_value[idx] - data->x_min_value[idx])
                      * (ur.x - ll.x);
            else
              x_value = ll.x
                  + (data->x_data[idx][i] - data->x_min_value[idx])
                      / (data->x_max_value[idx] - data->x_min_value[idx])
                      * (ur.x - ll.x);

            x_value = MAX(ll.x, MIN(x_value, ur.x));

            y_value = ur.y
                - (data->y_data[idx][i] - y_min_value[idx])
                    / (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);

            y_value = MAX(ll.y, MIN(y_value, ur.y));

            if (i == 0) {
              pointarray[pix].y = y_value;
              pointarray[pix++].x = ll.x;
            } else {
              pointarray[pix].y = prev_y_value;
              pointarray[pix++].x = x_value;
            }
            pointarray[pix].y = y_value;
            pointarray[pix++].x = x_value;
            prev_y_value = y_value;
          }
          pointarray[pix].y = pointarray[pix - 1].y;
          pointarray[pix++].x = ur.x;
          points = pix;
        } else {
          pix = 0;
          for (i = 0; i < data->rows[idx]; i++) {
            if (data->x_reverse)
              x_value = ur.x
                  - (data->x_data[idx][i] - data->x_min_value[idx])
                      / (data->x_max_value[idx] - data->x_min_value[idx])
                      * (ur.x - ll.x);
            else
              x_value = ll.x
                  + (data->x_data[idx][i] - data->x_min_value[idx])
                      / (data->x_max_value[idx] - data->x_min_value[idx])
                      * (ur.x - ll.x);

            x_value = MAX(ll.x, MIN(x_value, ur.x));

            y_value = ur.y
                - (data->y_data[idx][i] - y_min_value[idx])
                    / (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);

            y_value = MAX(ll.y, MIN(y_value, ur.y));

            if (i == 0) {
              pointarray[pix].y = ur.y;
              pointarray[pix++].x = ll.x;
              pointarray[pix].y = y_value;
              pointarray[pix++].x = ll.x;
            } else {
              pointarray[pix].y = prev_y_value;
              pointarray[pix++].x = x_value;
            }
            pointarray[pix].y = y_value;
            pointarray[pix++].x = x_value;
            prev_y_value = y_value;
          }

          // Last point
          pointarray[pix].y = pointarray[pix - 1].y;
          pointarray[pix++].x = ur.x;
          pointarray[pix].y = ur.y;
          pointarray[pix++].x = ur.x;
          points = pix;
        }
        break;
      case glow_eCurveType_DigSquare: {
        points = data->rows[idx] * 2;
        if (fill_curve)
          points += 5;
        else
          points += 3;

        pointarray = (glow_sPoint*)calloc(points, sizeof(glow_sPoint));

        double yoffs;
        if (split_digsquare)
          yoffs = (dix % 10) * (ur.y - ll.y) / 10;
        else
          yoffs = 0;
        dix++;
        double y0 = ur.y - yoffs;
        double y1 = y0 - (ur.y - ll.y) * 0.08;

        if (!fill_curve) {
          pix = 0;
          for (i = 0; i < data->rows[idx]; i++) {
            if (data->x_reverse)
              x_value = ur.x
                  - (data->x_data[idx][i] - data->x_min_value[idx])
                      / (data->x_max_value[idx] - data->x_min_value[idx])
                      * (ur.x - ll.x);
            else
              x_value = ll.x
                  + (data->x_data[idx][i] - data->x_min_value[idx])
                      / (data->x_max_value[idx] - data->x_min_value[idx])
                      * (ur.x - ll.x);

            x_value = MAX(ll.x, MIN(x_value, ur.x));

            if (data->y_data[idx][i])
              y_value = y1;
            else
              y_value = y0;

            if (i == 0) {
              if (feq(data->y_data[idx][0], 1.0)) {
                pointarray[pix].y = y0;
                pointarray[pix++].x = ll.x;
                pointarray[pix].y = y0;
                pointarray[pix++].x = x_value;
              } else {
                pointarray[pix].y = y1;
                pointarray[pix++].x = ll.x;
                pointarray[pix].y = y1;
                pointarray[pix++].x = x_value;
              }
            } else {
              pointarray[pix].y = prev_y_value;
              pointarray[pix++].x = x_value;
            }
            pointarray[pix].y = y_value;
            pointarray[pix++].x = x_value;
            prev_y_value = y_value;
          }
          // Last point
          pointarray[pix].y = pointarray[pix - 1].y;
          pointarray[pix++].x = ur.x;
          points = pix;
        } else {
          pix = 0;
          for (i = 0; i < data->rows[idx]; i++) {
            if (data->x_reverse)
              x_value = ur.x
                  - (data->x_data[idx][i] - data->x_min_value[idx])
                      / (data->x_max_value[idx] - data->x_min_value[idx])
                      * (ur.x - ll.x);
            else
              x_value = ll.x
                  + (data->x_data[idx][i] - data->x_min_value[idx])
                      / (data->x_max_value[idx] - data->x_min_value[idx])
                      * (ur.x - ll.x);

            x_value = MAX(ll.x, MIN(x_value, ur.x));

            if (data->y_data[idx][i])
              y_value = y1;
            else
              y_value = y0;

            if (i == 0) {
              if (feq(data->y_data[idx][0], 1.0)) {
                pointarray[pix].y = y0;
                pointarray[pix++].x = x_value;
              } else {
                pointarray[pix].y = y0;
                pointarray[pix++].x = ll.x;
                pointarray[pix].y = y1;
                pointarray[pix++].x = ll.x;
                pointarray[pix].y = y1;
                pointarray[pix++].x = x_value;
              }
            } else {
              pointarray[pix].y = prev_y_value;
              pointarray[pix++].x = x_value;
            }
            pointarray[pix].y = y_value;
            pointarray[pix++].x = x_value;
            prev_y_value = y_value;
          }

          // Last point
          if (!feq(data->y_data[idx][data->rows[idx] - 1], 0.0)) {
            pointarray[pix].y = y1;
            pointarray[pix++].x = ur.x;
            pointarray[pix].y = y0;
            pointarray[pix++].x = ur.x;
          }
          printf("Points %d pix %d\n", points, pix);
          points = pix;
        }
        break;
      }
      default:;
      }

      if (curve_drawtype[idx] != glow_eDrawType_Inherit)
        dt = curve_drawtype[idx];
      else
        dt = draw_type;

      if (curve_fill_drawtype[idx] != glow_eDrawType_Inherit)
        dt_fill = curve_fill_drawtype[idx];
      else
        dt_fill = draw_type;

      ctx->nodraw++;
      curve[idx] = new GrowPolyLine(ctx, "", pointarray, points, dt,
          curve_width, 0, fill_curve, 1, 0, dt_fill, 0, 0, 0, type);
      ctx->nodraw--;

      free((char*)pointarray);
    }

    draw();
  }
}

void GrowCurve::add_points(glow_sCurveData* data, unsigned int* no_of_points)
{
  if (data->type == glow_eCurveDataType_CommonX) {
    ctx->nodraw++;
    for (int idx = 0; idx < curve_cnt; idx++) {
      if (no_of_points[0] == 1) {
        double y_value;

        if (no_of_points[idx] == 0) {
          // Add old value
          y_value = ((GlowPoint*)curve[idx]->a_points[0])->y;
        } else {
          y_value = ur.y
              - (data->y_data[idx][0] - y_min_value[idx])
                  / (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);

          y_value = MAX(ll.y, MIN(y_value, ur.y));
        }
        if (!fill)
          erase(&ctx->mw);

        if (!fill_curve)
          curve[idx]->add_and_shift_y_value(y_value);
        else
          curve[idx]->add_and_shift_y_value_filled(y_value);
      } else {
        double* y_values;
        int i;
        unsigned int k;

        y_values = (double*)calloc(1, no_of_points[0] * sizeof(double));

        if (no_of_points[idx] == no_of_points[0]) {
          for (i = 0; i < (int)no_of_points[0]; i++) {
            y_values[i] = ur.y
                - (data->y_data[idx][i] - y_min_value[idx])
                    / (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);

            y_values[i] = MAX(ll.y, MIN(y_values[i], ur.y));
          }
        } else {
          for (i = 0; i < (int)no_of_points[0]; i++) {
            k = (float)i * no_of_points[idx] / no_of_points[0] + 0.49;
            if (k > no_of_points[0])
              k = no_of_points[0];
            y_values[i] = ur.y
                - (data->y_data[idx][k] - y_min_value[idx])
                    / (y_max_value[idx] - y_min_value[idx]) * (ur.y - ll.y);

            y_values[i] = MAX(ll.y, MIN(y_values[i], ur.y));
          }
        }
        if (!fill)
          erase(&ctx->mw);

        if (!fill_curve)
          curve[idx]->add_and_shift_y_values(y_values, no_of_points[0]);
        else
          curve[idx]->add_and_shift_y_values_filled(y_values, no_of_points[0]);

        free((char*)y_values);
      }
    }
    ctx->nodraw--;

    draw();
    // draw( (GlowTransform *)NULL, highlight, hot, NULL, NULL);
    ctx->nav_draw(
        &ctx->navw, 0, 0, ctx->navw.window_width, ctx->navw.window_height);
    // nav_draw( (GlowTransform *) NULL, highlight, NULL, NULL);
  }
}
