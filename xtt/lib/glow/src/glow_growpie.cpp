/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2014 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

#include "glow_std.h"


#include <iostream>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include "glow_growpie.h"
#include "glow_grownode.h"
#include "glow_draw.h"
#include "glow_growctx.h"
#include "pwr.h"
#include "co_time.h"

#if defined OS_OPENBSD
# define nearbyint rint
#endif

GrowPie::GrowPie( GrowCtx *glow_ctx, const char *name, double x1, double y1, 
		  double x2, double y2, int ang1, int ang2,
		  glow_eDrawType border_d_type, int line_w,
		  int display_border, int display_shadow,
		  glow_eDrawType fill_d_type, int nodraw) :
  GrowArc(glow_ctx,name,x1,y1,x2,y2,ang1, ang2, border_d_type,line_w,
	  1, display_border, display_shadow, fill_d_type, 1),
  sectors(0), min_value(0), max_value(1)
{
  memset( sector_color, 0, sizeof(sector_color));
  memset( sector_size, 0, sizeof(sector_size));

  if ( !nodraw)
    draw( &ctx->mw, (GlowTransform *)NULL, highlight, hot, NULL, NULL);

}

GrowPie::~GrowPie()
{
  if ( ctx->nodraw) return;
  erase( &ctx->mw);
  erase( &ctx->navw);
}

void GrowPie::save( ofstream& fp, glow_eSaveMode mode)
{ 

  fp << int(glow_eSave_GrowPie) << endl;
  fp << int(glow_eSave_GrowPie_arc_part) << endl;
  GrowArc::save( fp, mode);
  fp << int(glow_eSave_GrowPie_sectors) << FSPACE << sectors << endl;
  fp << int(glow_eSave_GrowPie_min_value) << FSPACE << min_value << endl;
  fp << int(glow_eSave_GrowPie_max_value) << FSPACE << max_value << endl;
  for ( int i = 0; i < PIE_MAX_SECTORS; i++)
    fp << int(glow_eSave_GrowPie_sector_color1)+i << FSPACE << (int)sector_color[i] << endl;
  for ( int i = 0; i < PIE_MAX_SECTORS; i++)
    fp << int(glow_eSave_GrowPie_sector_size1)+i << FSPACE << sector_size[i] << endl;
  if ( user_data && ctx->userdata_save_callback) {
    fp << int(glow_eSave_GrowPie_userdata_cb) << endl;
    (ctx->userdata_save_callback)(&fp, this, glow_eUserdataCbType_Node);
  }
  fp << int(glow_eSave_End) << endl;
}

void GrowPie::open( ifstream& fp)
{
  int		type;
  int 		end_found = 0;
  char		dummy[40];
  int           tmp;

  for (;;) {
    if ( !fp.good()) {
      fp.clear();
      fp.getline( dummy, sizeof(dummy));
      printf( "** Read error GrowPie: \"%d %s\"\n", type, dummy);      
    }
    
    fp >> type;
    switch( type) {
    case glow_eSave_GrowPie: break;
    case glow_eSave_GrowPie_arc_part: 
      GrowArc::open( fp);
      break;
    case glow_eSave_GrowPie_sectors: fp >> sectors; break;
    case glow_eSave_GrowPie_min_value: fp >> min_value; break;
    case glow_eSave_GrowPie_max_value: fp >> max_value; break;
    case glow_eSave_GrowPie_sector_color1: fp >> tmp; sector_color[0] = (glow_eDrawType)tmp; break;
    case glow_eSave_GrowPie_sector_color2: fp >> tmp; sector_color[1] = (glow_eDrawType)tmp; break;
    case glow_eSave_GrowPie_sector_color3: fp >> tmp; sector_color[2] = (glow_eDrawType)tmp; break;
    case glow_eSave_GrowPie_sector_color4: fp >> tmp; sector_color[3] = (glow_eDrawType)tmp; break;
    case glow_eSave_GrowPie_sector_color5: fp >> tmp; sector_color[4] = (glow_eDrawType)tmp; break;
    case glow_eSave_GrowPie_sector_color6: fp >> tmp; sector_color[5] = (glow_eDrawType)tmp; break;
    case glow_eSave_GrowPie_sector_color7: fp >> tmp; sector_color[6] = (glow_eDrawType)tmp; break;
    case glow_eSave_GrowPie_sector_color8: fp >> tmp; sector_color[7] = (glow_eDrawType)tmp; break;
    case glow_eSave_GrowPie_sector_color9: fp >> tmp; sector_color[8] = (glow_eDrawType)tmp; break;
    case glow_eSave_GrowPie_sector_color10: fp >> tmp; sector_color[9] = (glow_eDrawType)tmp; break;
    case glow_eSave_GrowPie_sector_color11: fp >> tmp; sector_color[10] = (glow_eDrawType)tmp; break;
    case glow_eSave_GrowPie_sector_color12: fp >> tmp; sector_color[11] = (glow_eDrawType)tmp; break;
    case glow_eSave_GrowPie_sector_size1: fp >> sector_size[0]; break;
    case glow_eSave_GrowPie_sector_size2: fp >> sector_size[1]; break;
    case glow_eSave_GrowPie_sector_size3: fp >> sector_size[2]; break;
    case glow_eSave_GrowPie_sector_size4: fp >> sector_size[3]; break;
    case glow_eSave_GrowPie_sector_size5: fp >> sector_size[4]; break;
    case glow_eSave_GrowPie_sector_size6: fp >> sector_size[5]; break;
    case glow_eSave_GrowPie_sector_size7: fp >> sector_size[6]; break;
    case glow_eSave_GrowPie_sector_size8: fp >> sector_size[7]; break;
    case glow_eSave_GrowPie_sector_size9: fp >> sector_size[8]; break;
    case glow_eSave_GrowPie_sector_size10: fp >> sector_size[9]; break;
    case glow_eSave_GrowPie_sector_size11: fp >> sector_size[10]; break;
    case glow_eSave_GrowPie_sector_size12: fp >> sector_size[11]; break;
    case glow_eSave_GrowPie_userdata_cb:
      if ( ctx->userdata_open_callback)
	(ctx->userdata_open_callback)(&fp, this, glow_eUserdataCbType_Node);
      break;
    case glow_eSave_End: end_found = 1; break;
    default:
      cout << "GrowPie:open syntax error" << endl;
      fp.getline( dummy, sizeof(dummy));
    }
    if ( end_found)
      break;
  }
}

void GrowPie::trace_scan()
{
  if ( trace.p && ctx->trace_scan_func)
    ctx->trace_scan_func( (void *) this, trace.p);
}

int GrowPie::trace_init()
{
  int sts = 1;

  sts = ctx->trace_connect_func( (void *) this, &trace);
  return sts;
}

void GrowPie::trace_close()
{
  if ( trace.p)
    ctx->trace_disconnect_func( (void *) this);

}

void GrowPie::draw( GlowWind *w, int ll_x, int ll_y, int ur_x, int ur_y) 
{ 
  int tmp;

  if ( ll_x > ur_x) {
    /* Shift */
    tmp = ll_x;
    ll_x = ur_x;
    ur_x = tmp;
  }
  if ( ll_y > ur_y) {
    /* Shift */
    tmp = ll_y;
    ll_y = ur_y;
    ur_y = tmp;
  }

  if ( x_right * w->zoom_factor_x - w->offset_x >= ll_x &&
      	x_left * w->zoom_factor_x - w->offset_x <= ur_x &&
       	y_high * w->zoom_factor_y - w->offset_y >= ll_y &&
       	y_low * w->zoom_factor_y - w->offset_y <= ur_y) {
    draw( w, (GlowTransform *)NULL, highlight, hot, NULL, NULL);
  }
}

void GrowPie::draw( GlowWind *w, int *ll_x, int *ll_y, int *ur_x, int *ur_y) 
{ 
  int 	tmp;
  int 	obj_ur_x = int( x_right * w->zoom_factor_x) - w->offset_x;
  int	obj_ll_x = int( x_left * w->zoom_factor_x) - w->offset_x;
  int	obj_ur_y = int( y_high * w->zoom_factor_y) - w->offset_y;
  int   obj_ll_y = int( y_low * w->zoom_factor_y) - w->offset_y;


  if ( *ll_x > *ur_x) {
    /* Shift */
    tmp = *ll_x;
    *ll_x = *ur_x;
    *ur_x = tmp;
  }
  if ( *ll_y > *ur_y) {
    /* Shift */
    tmp = *ll_y;
    *ll_y = *ur_y;
    *ur_y = tmp;
  }

  if (  obj_ur_x >= *ll_x &&
      	obj_ll_x <= *ur_x &&
       	obj_ur_y >= *ll_y &&
       	obj_ll_y <= *ur_y) {
    draw( w, (GlowTransform *)NULL, highlight, hot, NULL, NULL);

    // Increase the redraw area
    if ( obj_ur_x > *ur_x)
      *ur_x = obj_ur_x;
    if ( obj_ur_y > *ur_y)
      *ur_y = obj_ur_y;
    if ( obj_ll_x < *ll_x)
      *ll_x = obj_ll_x;
    if ( obj_ll_y < *ll_y)
      *ll_y = obj_ll_y;
  }
}

void GrowPie::set_highlight( int on)
{
  highlight = on;
  draw();
}

void GrowPie::draw( GlowWind *w, GlowTransform *t, int highlight, int hot, void *node, 
		     void *colornode)
{
  if ( ctx->nodraw)
    return;
  if ( w == &ctx->navw) {
    if ( ctx->no_nav)
      return;
    hot = 0;
  }
  int chot = 0;
  if ( hot && ctx->environment != glow_eEnv_Development) {
    if ( ctx->hot_indication == glow_eHotIndication_No)
	 hot = 0;
    else if ( ctx->hot_indication == glow_eHotIndication_DarkColor) {
      chot = hot;
      hot = 0;
    }
    else if ( ctx->hot_indication == glow_eHotIndication_LightColor) {
      chot = -hot;
      hot = 0;
    }
  }
  int idx;
  int rot;
  glow_eDrawType drawtype;

  if ( node && ((GrowNode *)node)->line_width)
    idx = int( w->zoom_factor_y / w->base_zoom_factor * 
		((GrowNode *)node)->line_width - 1);
  else
    idx = int( w->zoom_factor_y / w->base_zoom_factor * line_width - 1);
  idx += hot;
  idx = max( 0, idx);
  idx = min( idx, DRAW_TYPE_SIZE-1);
  int x1, y1, x2, y2, ll_x, ll_y, ur_x, ur_y;

  if (!t) {
    x1 = int( trf.x( ll.x, ll.y) * w->zoom_factor_x + 0.5) - w->offset_x;
    y1 = int( trf.y( ll.x, ll.y) * w->zoom_factor_y + 0.5) - w->offset_y;
    x2 = int( trf.x( ur.x, ur.y) * w->zoom_factor_x + 0.5) - w->offset_x;
    y2 = int( trf.y( ur.x, ur.y) * w->zoom_factor_y + 0.5) - w->offset_y;
    rot = int( trf.rot());
  }
  else {
    x1 = int( trf.x( t, ll.x, ll.y) * w->zoom_factor_x + 0.5) - w->offset_x;
    y1 = int( trf.y( t, ll.x, ll.y) * w->zoom_factor_y + 0.5) - w->offset_y;
    x2 = int( trf.x( t, ur.x, ur.y) * w->zoom_factor_x + 0.5) - w->offset_x;
    y2 = int( trf.y( t, ur.x, ur.y) * w->zoom_factor_y + 0.5) - w->offset_y;
    rot = int( trf.rot( t));
  }

  ll_x = min( x1, x2);
  ur_x = max( x1, x2);
  ll_y = min( y1, y2);
  ur_y = max( y1, y2);

  int display_shadow = ((node && ((GrowNode *)node)->shadow) || shadow) && !disable_shadow;
  glow_eGradient grad = gradient;
  if ( gradient == glow_eGradient_No && 
       (node && ((GrowNode *)node)->gradient != glow_eGradient_No) && !disable_gradient)
    grad = ((GrowNode *)node)->gradient;
  
  double a1 = angle1;
  double a2;
  int ia1 = angle1;
  int ia2;
  for ( int i = 0; i < sectors + 1; i++) {
    glow_eDrawType fillcolor;

    if ( i == sectors) {
      if ( ia1 >= angle1 + angle2)
	break;
      ia2 = angle1 + angle2 - ia1;
      fillcolor = ctx->get_drawtype( fill_drawtype, glow_eDrawType_FillHighlight,
				     highlight, (GrowNode *)colornode, 1);
    }
    else {
       if ( sector_size[i] <= min_value)
	continue;
      if ( a1 >= angle2 + angle1)
	break;
      a2 = sector_size[i] / (max_value - min_value) * angle2;
      if ( a1 + a2 > angle1 + angle2)
	a2 = angle1 + angle2 - a1;
      ia2 = a2 + a1 - ia1 + 0.5;

      fillcolor = ctx->get_drawtype( sector_color[i], glow_eDrawType_FillHighlight,
				     highlight, (GrowNode *)colornode, 1);
    }
    
    
    if ( grad == glow_eGradient_No || fillcolor == glow_eDrawType_ColorRed) {
      if ( chot)
	drawtype = GlowColor::shift_drawtype( fillcolor, chot, 0);
      else
	drawtype = fillcolor;
      ctx->gdraw->fill_arc( w,  ll_x, ll_y, ur_x - ll_x, ur_y - ll_y,
			    ia1 - rot, ia2, drawtype, 0);
    }
    else if ( !display_shadow || shadow_width == 0) {
      glow_eDrawType f1, f2;
      if ( gradient_contrast >= 0) {
	f2 = GlowColor::shift_drawtype( fillcolor, -gradient_contrast/2 + chot, 0);
	f1 = GlowColor::shift_drawtype( fillcolor, int(float(gradient_contrast)/2+0.6) + chot, 0);
      }
      else {
	f2 = GlowColor::shift_drawtype( fillcolor, -int(float(gradient_contrast)/2-0.6) + chot, 0);
	f1 = GlowColor::shift_drawtype( fillcolor, gradient_contrast/2 + chot, 0);
      }
      ctx->gdraw->gradient_fill_arc( w, ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, ia1 - rot, 
				     ia2, fillcolor, f1, f2, grad);
    }
    else {
      int ish = int( shadow_width / 100 * min(ur_x - ll_x, ur_y - ll_y) + 0.5);
      int drawtype_incr = shadow_contrast;
      if ( relief == glow_eRelief_Down)
	drawtype_incr = -shadow_contrast;

      glow_eDrawType f1, f2;

      // Draw shadow
      f1 = ctx->shift_drawtype( fillcolor, -drawtype_incr + chot, (GrowNode *)colornode);
      f2 = ctx->shift_drawtype( fillcolor, drawtype_incr + chot, (GrowNode *)colornode);

      ctx->gdraw->gradient_fill_arc( w,  ll_x, ll_y, ur_x - ll_x, ur_y - ll_y,
				     ia1 - rot, ia2, fillcolor, f2, f1, glow_eGradient_DiagonalUpperLeft);

      // Draw circle
      if ( gradient_contrast >= 0) {
	f2 = GlowColor::shift_drawtype( fillcolor, -gradient_contrast/2 + chot, 0);
	f1 = GlowColor::shift_drawtype( fillcolor, int(float(gradient_contrast)/2+0.6) + chot, 0);
      }
      else {
	f2 = GlowColor::shift_drawtype( fillcolor, -int(float(gradient_contrast)/2-0.6) + chot, 0);
	f1 = GlowColor::shift_drawtype( fillcolor, gradient_contrast/2 + chot, 0);
      }
      ctx->gdraw->gradient_fill_arc( w,  ll_x + ish, ll_y + ish, ur_x - ll_x - 2*ish, ur_y - ll_y - 2*ish,
				     ia1 - rot, ia2, fillcolor, f1, f2, grad);
    }
    a1 += a2;
    ia1 += ia2;
  }

  if ( border) {
    drawtype = ctx->get_drawtype( draw_type, glow_eDrawType_LineHighlight,
				  highlight, (GrowNode *)colornode, 0);

    // printf( "draw: %d %d\n", ll_x, ll_y);
    ctx->gdraw->arc( w,  ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, 
		     angle1 - rot, angle2, drawtype, idx, 0);
  }
}

void GrowPie::erase( GlowWind *w, GlowTransform *t, int hot, void *node)
{
  if ( ctx->nodraw)
    return;

  int idx;

  if ( w == &ctx->navw) {
    if ( ctx->no_nav)
      return;
    hot = 0;
  }
  if ( node && ((GrowNode *)node)->line_width)
    idx = int( w->zoom_factor_y / w->base_zoom_factor * 
		((GrowNode *)node)->line_width - 1);
  else
    idx = int( w->zoom_factor_y / w->base_zoom_factor * line_width - 1);
  idx += hot;
  idx = max( 0, idx);
  idx = min( idx, DRAW_TYPE_SIZE-1);

  int x1, y1, x2, y2, ll_x, ll_y, ur_x, ur_y;
  int rot;

  if (!t) {
    x1 = int( trf.x( ll.x, ll.y) * w->zoom_factor_x + 0.5) - w->offset_x;
    y1 = int( trf.y( ll.x, ll.y) * w->zoom_factor_y + 0.5) - w->offset_y;
    x2 = int( trf.x( ur.x, ur.y) * w->zoom_factor_x + 0.5) - w->offset_x;
    y2 = int( trf.y( ur.x, ur.y) * w->zoom_factor_y + 0.5) - w->offset_y;
    rot = int( trf.rot());
  }
  else {
    x1 = int( trf.x( t, ll.x, ll.y) * w->zoom_factor_x + 0.5) - w->offset_x;
    y1 = int( trf.y( t, ll.x, ll.y) * w->zoom_factor_y + 0.5) - w->offset_y;
    x2 = int( trf.x( t, ur.x, ur.y) * w->zoom_factor_x + 0.5) - w->offset_x;
    y2 = int( trf.y( t, ur.x, ur.y) * w->zoom_factor_y + 0.5) - w->offset_y;
    rot = int( trf.rot( t));
  }

  ll_x = min( x1, x2);
  ur_x = max( x1, x2);
  ll_y = min( y1, y2);
  ur_y = max( y1, y2);

  // printf( "eras: %d %d\n", ll_x, ll_y);

  w->set_draw_buffer_only();
  if ( border)
    ctx->gdraw->arc_erase( w, ll_x, ll_y, ur_x - ll_x, ur_y - ll_y,
			   angle1 - rot, angle2, idx);
  ctx->gdraw->fill_arc( w, ll_x, ll_y, ur_x - ll_x, ur_y - ll_y,
			angle1 - rot, angle2, glow_eDrawType_LineErase, 0);
  w->reset_draw_buffer_only();
}

void GrowPie::draw()
{
  ctx->draw( &ctx->mw, x_left * ctx->mw.zoom_factor_x - ctx->mw.offset_x - DRAW_MP,
	     y_low * ctx->mw.zoom_factor_y - ctx->mw.offset_y - DRAW_MP,
  	     x_right * ctx->mw.zoom_factor_x - ctx->mw.offset_x + DRAW_MP,
	     y_high * ctx->mw.zoom_factor_y - ctx->mw.offset_y + DRAW_MP);
  ctx->draw( &ctx->navw, x_left * ctx->navw.zoom_factor_x - ctx->navw.offset_x - 1,
	     y_low * ctx->navw.zoom_factor_y - ctx->navw.offset_y - 1,
  	     x_right * ctx->navw.zoom_factor_x - ctx->navw.offset_x + 1,
	     y_high * ctx->navw.zoom_factor_y - ctx->navw.offset_y + 1);
}

void GrowPie::align( double x, double y, glow_eAlignDirection direction)
{
    double dx, dy;

    erase( &ctx->mw);
    erase( &ctx->navw);
    ctx->set_defered_redraw();
    draw();
    switch ( direction) {
      case glow_eAlignDirection_CenterVert:
        dx = x - (x_right + x_left) / 2;
        dy = 0;
        break;        
      case glow_eAlignDirection_CenterHoriz:
        dx = 0;
        dy = y - (y_high + y_low) / 2;
        break;        
      case glow_eAlignDirection_CenterCenter:
        dx = x - (x_right + x_left) / 2;
        dy = y - (y_high + y_low) / 2;
        break;        
      case glow_eAlignDirection_Right:
        dx = x - x_right;
        dy = 0;
        break;        
      case glow_eAlignDirection_Left:
        dx = x - x_left;
        dy = 0;
        break;        
      case glow_eAlignDirection_Up:
        dx = 0;
        dy = y - y_high;
        break;        
      case glow_eAlignDirection_Down:
        dx = 0;
        dy = y - y_low;
        break;        
    }
    trf.move( dx, dy);
    x_right += dx;
    x_left += dx;
    y_high += dy;
    y_low += dy;

    draw();
    ctx->redraw_defered();
}

void GrowPie::export_javabean( GlowTransform *t, void *node,
	glow_eExportPass pass, int *shape_cnt, int node_cnt, int in_nc, ofstream &fp)
{
  double x1, y1, x2, y2, ll_x, ll_y, ur_x, ur_y;
  double rotation;
  double ish;
  int gc1, gc2;

  if (!t)
  {
    x1 = trf.x( ll.x, ll.y) * ctx->mw.zoom_factor_x - ctx->mw.offset_x;
    y1 = trf.y( ll.x, ll.y) * ctx->mw.zoom_factor_y - ctx->mw.offset_y;
    x2 = trf.x( ur.x, ur.y) * ctx->mw.zoom_factor_x - ctx->mw.offset_x;
    y2 = trf.y( ur.x, ur.y) * ctx->mw.zoom_factor_y - ctx->mw.offset_y;
  }
  else
  {
    x1 = trf.x( t, ll.x, ll.y) * ctx->mw.zoom_factor_x - ctx->mw.offset_x;
    y1 = trf.y( t, ll.x, ll.y) * ctx->mw.zoom_factor_y - ctx->mw.offset_y;
    x2 = trf.x( t, ur.x, ur.y) * ctx->mw.zoom_factor_x - ctx->mw.offset_x;
    y2 = trf.y( t, ur.x, ur.y) * ctx->mw.zoom_factor_y - ctx->mw.offset_y;
  }

  ll_x = min( x1, x2);
  ur_x = max( x1, x2);
  ll_y = min( y1, y2);
  ur_y = max( y1, y2);

  if ( t)
    rotation = (trf.rot( t) / 360 - floor( trf.rot( t) / 360)) * 360;
  else
    rotation = (trf.rot() / 360 - floor( trf.rot() / 360)) * 360;

  ish = shadow_width / 100 * min(ur_x - ll_x, ur_y - ll_y);

  if ( gradient_contrast >= 0) {
    gc1 = gradient_contrast/2;
    gc2 = -int(float(gradient_contrast)/2+0.6);
  }
  else {
    gc1 = int(float(gradient_contrast)/2-0.6);
    gc2 = -gradient_contrast/2;
  }

  ctx->export_jbean->pie( ll_x, ll_y, ur_x, ur_y, angle1, angle2,
    	draw_type, fill_drawtype, fill,
	border, sectors, sector_color, min_value, max_value,
	line_width, rotation, ish, shadow, gradient, gc1, gc2,
    	pass, shape_cnt, node_cnt, fp);
}

void GrowPie::set_conf( int sector_num, double min_val, double max_val, glow_eDrawType *color)
{
  sectors = sector_num;
  min_value = min_val;
  max_value = max_val;
  for ( int i = 0; i < sectors; i++)
    sector_color[i] = color[i];
  draw();
}

void GrowPie::get_conf( int *sector_num, double *min_val, double *max_val)
{
  *sector_num = sectors;
  *min_val = min_value;
  *max_val = max_value;
}

void GrowPie::set_values( double *values)
{
  for ( int i = 0; i < sectors; i++)
    sector_size[i] = values[i];
  draw();
}

void GrowPie::convert( glow_eConvert version) 
{
}












