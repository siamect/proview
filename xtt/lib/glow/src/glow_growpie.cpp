/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2019 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <math.h>
#include <stdlib.h>
#include <string.h>

#include <iostream>

#include "co_time.h"

#include "glow_growpie.h"
#include "glow_grownode.h"
#include "glow_draw.h"

#if defined OS_OPENBSD
#define nearbyint rint
#endif

GrowPie::GrowPie(GrowCtx* glow_ctx, const char* name, double x1, double y1,
    double x2, double y2, int ang1, int ang2, glow_eDrawType border_d_type,
    int line_w, int display_border, int display_shadow,
    glow_eDrawType fill_d_type, int nodraw)
    : GrowArc(glow_ctx, name, x1, y1, x2, y2, ang1, ang2, border_d_type, line_w,
          1, display_border, display_shadow, fill_d_type, 1),
      sectors(0), min_value(0), max_value(1)
{
  memset(sector_color, 0, sizeof(sector_color));
  memset(sector_size, 0, sizeof(sector_size));

  if (!nodraw)
    ctx->set_dirty();
}

GrowPie::~GrowPie()
{
  ctx->set_dirty();
}

void GrowPie::save(std::ofstream& fp, glow_eSaveMode mode)
{
  fp << int(glow_eSave_GrowPie) << '\n';
  fp << int(glow_eSave_GrowPie_arc_part) << '\n';
  GrowArc::save(fp, mode);
  fp << int(glow_eSave_GrowPie_sectors) << FSPACE << sectors << '\n';
  fp << int(glow_eSave_GrowPie_min_value) << FSPACE << min_value << '\n';
  fp << int(glow_eSave_GrowPie_max_value) << FSPACE << max_value << '\n';
  for (int i = 0; i < PIE_MAX_SECTORS; i++)
    fp << int(glow_eSave_GrowPie_sector_color1) + i << FSPACE
       << (int)sector_color[i] << '\n';
  for (int i = 0; i < PIE_MAX_SECTORS; i++)
    fp << int(glow_eSave_GrowPie_sector_size1) + i << FSPACE << sector_size[i]
       << '\n';
  if (user_data && ctx->userdata_save_callback) {
    fp << int(glow_eSave_GrowPie_userdata_cb) << '\n';
    (ctx->userdata_save_callback)(&fp, this, glow_eUserdataCbType_Node);
  }
  fp << int(glow_eSave_End) << '\n';
}

void GrowPie::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GrowPie: \"%d %s\"\n", type, dummy);
    }

    fp >> type;
    switch (type) {
    case glow_eSave_GrowPie:
      break;
    case glow_eSave_GrowPie_arc_part:
      GrowArc::open(fp);
      break;
    case glow_eSave_GrowPie_sectors:
      fp >> sectors;
      break;
    case glow_eSave_GrowPie_min_value:
      fp >> min_value;
      break;
    case glow_eSave_GrowPie_max_value:
      fp >> max_value;
      break;
    case glow_eSave_GrowPie_sector_color1:
      fp >> tmp;
      sector_color[0] = (glow_eDrawType)tmp;
      break;
    case glow_eSave_GrowPie_sector_color2:
      fp >> tmp;
      sector_color[1] = (glow_eDrawType)tmp;
      break;
    case glow_eSave_GrowPie_sector_color3:
      fp >> tmp;
      sector_color[2] = (glow_eDrawType)tmp;
      break;
    case glow_eSave_GrowPie_sector_color4:
      fp >> tmp;
      sector_color[3] = (glow_eDrawType)tmp;
      break;
    case glow_eSave_GrowPie_sector_color5:
      fp >> tmp;
      sector_color[4] = (glow_eDrawType)tmp;
      break;
    case glow_eSave_GrowPie_sector_color6:
      fp >> tmp;
      sector_color[5] = (glow_eDrawType)tmp;
      break;
    case glow_eSave_GrowPie_sector_color7:
      fp >> tmp;
      sector_color[6] = (glow_eDrawType)tmp;
      break;
    case glow_eSave_GrowPie_sector_color8:
      fp >> tmp;
      sector_color[7] = (glow_eDrawType)tmp;
      break;
    case glow_eSave_GrowPie_sector_color9:
      fp >> tmp;
      sector_color[8] = (glow_eDrawType)tmp;
      break;
    case glow_eSave_GrowPie_sector_color10:
      fp >> tmp;
      sector_color[9] = (glow_eDrawType)tmp;
      break;
    case glow_eSave_GrowPie_sector_color11:
      fp >> tmp;
      sector_color[10] = (glow_eDrawType)tmp;
      break;
    case glow_eSave_GrowPie_sector_color12:
      fp >> tmp;
      sector_color[11] = (glow_eDrawType)tmp;
      break;
    case glow_eSave_GrowPie_sector_size1:
      fp >> sector_size[0];
      break;
    case glow_eSave_GrowPie_sector_size2:
      fp >> sector_size[1];
      break;
    case glow_eSave_GrowPie_sector_size3:
      fp >> sector_size[2];
      break;
    case glow_eSave_GrowPie_sector_size4:
      fp >> sector_size[3];
      break;
    case glow_eSave_GrowPie_sector_size5:
      fp >> sector_size[4];
      break;
    case glow_eSave_GrowPie_sector_size6:
      fp >> sector_size[5];
      break;
    case glow_eSave_GrowPie_sector_size7:
      fp >> sector_size[6];
      break;
    case glow_eSave_GrowPie_sector_size8:
      fp >> sector_size[7];
      break;
    case glow_eSave_GrowPie_sector_size9:
      fp >> sector_size[8];
      break;
    case glow_eSave_GrowPie_sector_size10:
      fp >> sector_size[9];
      break;
    case glow_eSave_GrowPie_sector_size11:
      fp >> sector_size[10];
      break;
    case glow_eSave_GrowPie_sector_size12:
      fp >> sector_size[11];
      break;
    case glow_eSave_GrowPie_userdata_cb:
      if (ctx->userdata_open_callback)
        (ctx->userdata_open_callback)(&fp, this, glow_eUserdataCbType_Node);
      break;
    case glow_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GrowPie:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GrowPie::trace_scan()
{
  if (trace.p && ctx->trace_scan_func)
    ctx->trace_scan_func((void*)this, trace.p);
  return 1;
}

int GrowPie::trace_init()
{
  return ctx->trace_connect_func((void*)this, &trace);
}

void GrowPie::trace_close()
{
  if (trace.p)
    ctx->trace_disconnect_func((void*)this);
}

void GrowPie::draw(DrawWind* w, int ll_x, int ll_y, int ur_x, int ur_y)
{
  int tmp;

  if (ll_x > ur_x) {
    /* Shift */
    tmp = ll_x;
    ll_x = ur_x;
    ur_x = tmp;
  }
  if (ll_y > ur_y) {
    /* Shift */
    tmp = ll_y;
    ll_y = ur_y;
    ur_y = tmp;
  }

  if (x_right * w->zoom_factor_x - w->offset_x >= ll_x
      && x_left * w->zoom_factor_x - w->offset_x <= ur_x
      && y_high * w->zoom_factor_y - w->offset_y >= ll_y
      && y_low * w->zoom_factor_y - w->offset_y <= ur_y) {
    draw(w, (GlowTransform*)NULL, highlight, hot, NULL, NULL);
  }
}

void GrowPie::draw(DrawWind* w, int* ll_x, int* ll_y, int* ur_x, int* ur_y)
{
  int tmp;
  int obj_ur_x = int(x_right * w->zoom_factor_x) - w->offset_x;
  int obj_ll_x = int(x_left * w->zoom_factor_x) - w->offset_x;
  int obj_ur_y = int(y_high * w->zoom_factor_y) - w->offset_y;
  int obj_ll_y = int(y_low * w->zoom_factor_y) - w->offset_y;

  if (*ll_x > *ur_x) {
    /* Shift */
    tmp = *ll_x;
    *ll_x = *ur_x;
    *ur_x = tmp;
  }
  if (*ll_y > *ur_y) {
    /* Shift */
    tmp = *ll_y;
    *ll_y = *ur_y;
    *ur_y = tmp;
  }

  if (obj_ur_x >= *ll_x && obj_ll_x <= *ur_x && obj_ur_y >= *ll_y
      && obj_ll_y <= *ur_y) {
    draw(w, (GlowTransform*)NULL, highlight, hot, NULL, NULL);

    // Increase the redraw area
    if (obj_ur_x > *ur_x)
      *ur_x = obj_ur_x;
    if (obj_ur_y > *ur_y)
      *ur_y = obj_ur_y;
    if (obj_ll_x < *ll_x)
      *ll_x = obj_ll_x;
    if (obj_ll_y < *ll_y)
      *ll_y = obj_ll_y;
  }
}

void GrowPie::set_highlight(int on)
{
  if (highlight != on) {
    highlight = on;
    ctx->set_dirty();
  }
}

void GrowPie::draw(DrawWind* w, GlowTransform* t, int highlight, int hot,
    void* node, void* colornode)
{
  hot = (w == ctx->navw) ? 0 : hot;
  int chot = 0;
  if (hot && ctx->environment != glow_eEnv_Development) {
    if (ctx->hot_indication == glow_eHotIndication_No)
      hot = 0;
    else if (ctx->hot_indication == glow_eHotIndication_DarkColor) {
      chot = hot;
      hot = 0;
    } else if (ctx->hot_indication == glow_eHotIndication_LightColor) {
      chot = -hot;
      hot = 0;
    }
  }
  int idx;
  glow_eDrawType drawtype;

  if (node && ((GrowNode*)node)->line_width)
    idx = int(
        w->zoom_factor_y / w->base_zoom_factor * ((GrowNode*)node)->line_width
        - 1);
  else
    idx = int(w->zoom_factor_y / w->base_zoom_factor * line_width - 1);
  idx += hot;
  idx = MAX(0, idx);
  idx = MIN(idx, DRAW_TYPE_SIZE - 1);

  Matrix tmp = t ? (*t * trf) : trf;
  glow_sPoint p1 = tmp * ll;
  glow_sPoint p2 = tmp * ur;

  p1.x = p1.x * w->zoom_factor_x - w->offset_x;
  p1.y = p1.y * w->zoom_factor_y - w->offset_y;
  p2.x = p2.x * w->zoom_factor_x - w->offset_x;
  p2.y = p2.y * w->zoom_factor_y - w->offset_y;
  int ll_x = int(MIN(p1.x, p2.x));
  int ur_x = int(MAX(p1.x, p2.x));
  int ll_y = int(MIN(p1.y, p2.y));
  int ur_y = int(MAX(p1.y, p2.y));
  int rot = int(tmp.rotation);

  int display_shadow
      = ((node && ((GrowNode*)node)->shadow) || shadow) && !disable_shadow;
  glow_eGradient grad = gradient;
  if (gradient == glow_eGradient_No
      && (node && ((GrowNode*)node)->gradient != glow_eGradient_No)
      && !disable_gradient)
    grad = ((GrowNode*)node)->gradient;

  double a1 = angle1;
  double a2 = 0.0;
  int ia1 = angle1;
  int ia2;
  for (int i = 0; i < sectors + 1; i++) {
    glow_eDrawType fillcolor;

    if (i == sectors) {
      if (ia1 >= angle1 + angle2)
        break;
      ia2 = angle1 + angle2 - ia1;
      fillcolor = ctx->get_drawtype(fill_drawtype, glow_eDrawType_FillHighlight,
          highlight, (GrowNode*)colornode, 1);
    } else {
      if (sector_size[i] <= min_value)
        continue;
      if (a1 >= angle2 + angle1)
        break;
      a2 = sector_size[i] / (max_value - min_value) * angle2;
      if (a1 + a2 > angle1 + angle2)
        a2 = angle1 + angle2 - a1;
      ia2 = a2 + a1 - ia1 + 0.5;

      fillcolor = ctx->get_drawtype(sector_color[i],
          glow_eDrawType_FillHighlight, highlight, (GrowNode*)colornode, 1);
    }

    if (grad == glow_eGradient_No || fillcolor == glow_eDrawType_ColorRed) {
      if (chot)
        drawtype = GlowColor::shift_drawtype(fillcolor, chot, 0);
      else
        drawtype = fillcolor;
      ctx->gdraw->arc(
          ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, ia1 - rot, ia2, drawtype, 1, 0);
    } else if (!display_shadow || feq(shadow_width, 0.0)) {
      glow_eDrawType f1, f2;
      if (gradient_contrast >= 0) {
        f2 = GlowColor::shift_drawtype(
            fillcolor, -gradient_contrast / 2 + chot, 0);
        f1 = GlowColor::shift_drawtype(
            fillcolor, int(float(gradient_contrast) / 2 + 0.6) + chot, 0);
      } else {
        f2 = GlowColor::shift_drawtype(
            fillcolor, -int(float(gradient_contrast) / 2 - 0.6) + chot, 0);
        f1 = GlowColor::shift_drawtype(
            fillcolor, gradient_contrast / 2 + chot, 0);
      }
      ctx->gdraw->gradient_fill_arc(ll_x, ll_y, ur_x - ll_x, ur_y - ll_y,
          ia1 - rot, ia2, fillcolor, f1, f2, grad);
    } else {
      int ish = int(shadow_width / 100 * MIN(ur_x - ll_x, ur_y - ll_y) + 0.5);
      int drawtype_incr = shadow_contrast;
      if (relief == glow_eRelief_Down)
        drawtype_incr = -shadow_contrast;

      glow_eDrawType f1, f2;

      // Draw shadow
      f1 = ctx->shift_drawtype(
          fillcolor, -drawtype_incr + chot, (GrowNode*)colornode);
      f2 = ctx->shift_drawtype(
          fillcolor, drawtype_incr + chot, (GrowNode*)colornode);

      ctx->gdraw->gradient_fill_arc(ll_x, ll_y, ur_x - ll_x, ur_y - ll_y,
          ia1 - rot, ia2, fillcolor, f2, f1, glow_eGradient_DiagonalUpperLeft);

      // Draw circle
      if (gradient_contrast >= 0) {
        f2 = GlowColor::shift_drawtype(
            fillcolor, -gradient_contrast / 2 + chot, 0);
        f1 = GlowColor::shift_drawtype(
            fillcolor, int(float(gradient_contrast) / 2 + 0.6) + chot, 0);
      } else {
        f2 = GlowColor::shift_drawtype(
            fillcolor, -int(float(gradient_contrast) / 2 - 0.6) + chot, 0);
        f1 = GlowColor::shift_drawtype(
            fillcolor, gradient_contrast / 2 + chot, 0);
      }
      ctx->gdraw->gradient_fill_arc(ll_x + ish, ll_y + ish,
          ur_x - ll_x - 2 * ish, ur_y - ll_y - 2 * ish, ia1 - rot, ia2,
          fillcolor, f1, f2, grad);
    }
    a1 += a2;
    ia1 += ia2;
  }

  if (border) {
    drawtype = ctx->get_drawtype(draw_type, glow_eDrawType_LineHighlight,
        highlight, (GrowNode*)colornode, 0);

    ctx->gdraw->arc(ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, angle1 - rot,
        angle2, drawtype, 0, idx);
  }
}

void GrowPie::erase(DrawWind* w, GlowTransform* t, int hot, void* node)
{
  int idx;

  hot = (w == ctx->navw) ? 0 : hot;
  if (node && ((GrowNode*)node)->line_width)
    idx = int(
        w->zoom_factor_y / w->base_zoom_factor * ((GrowNode*)node)->line_width
        - 1);
  else
    idx = int(w->zoom_factor_y / w->base_zoom_factor * line_width - 1);
  idx += hot;
  idx = MAX(0, idx);
  idx = MIN(idx, DRAW_TYPE_SIZE - 1);

  Matrix tmp = t ? (*t * trf) : trf;
  glow_sPoint p1 = tmp * ll;
  glow_sPoint p2 = tmp * ur;

  p1.x = p1.x * w->zoom_factor_x - w->offset_x;
  p1.y = p1.y * w->zoom_factor_y - w->offset_y;
  p2.x = p2.x * w->zoom_factor_x - w->offset_x;
  p2.y = p2.y * w->zoom_factor_y - w->offset_y;
  int ll_x = int(MIN(p1.x, p2.x));
  int ur_x = int(MAX(p1.x, p2.x));
  int ll_y = int(MIN(p1.y, p2.y));
  int ur_y = int(MAX(p1.y, p2.y));
  int rot = int(tmp.rotation);

  if (border)
    ctx->gdraw->arc(ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, angle1 - rot, angle2,
        glow_eDrawType_LineErase, 0, idx);
  ctx->gdraw->arc(ll_x, ll_y, ur_x - ll_x, ur_y - ll_y, angle1 - rot, angle2,
      glow_eDrawType_LineErase, 1, 0);
}

void GrowPie::align(double x, double y, glow_eAlignDirection direction)
{
  double dx, dy;

  switch (direction) {
  case glow_eAlignDirection_CenterVert:
    dx = x - (x_right + x_left) / 2;
    dy = 0;
    break;
  case glow_eAlignDirection_CenterHoriz:
    dx = 0;
    dy = y - (y_high + y_low) / 2;
    break;
  case glow_eAlignDirection_CenterCenter:
    dx = x - (x_right + x_left) / 2;
    dy = y - (y_high + y_low) / 2;
    break;
  case glow_eAlignDirection_Right:
    dx = x - x_right;
    dy = 0;
    break;
  case glow_eAlignDirection_Left:
    dx = x - x_left;
    dy = 0;
    break;
  case glow_eAlignDirection_Up:
    dx = 0;
    dy = y - y_high;
    break;
  case glow_eAlignDirection_Down:
    dx = 0;
    dy = y - y_low;
    break;
  }
  if (!feq(dx, 0.0) || !feq(dy, 0.0)) {
    ctx->set_dirty();
  }
  trf.move(dx, dy);
  x_right += dx;
  x_left += dx;
  y_high += dy;
  y_low += dy;
}

void GrowPie::export_javabean(GlowTransform* t, void* node,
    glow_eExportPass pass, int* shape_cnt, int node_cnt, int in_nc,
    std::ofstream& fp)
{
  Matrix tmp = t ? (*t * trf) : trf;
  glow_sPoint p1 = tmp * ll;
  glow_sPoint p2 = tmp * ur;

  p1.x = p1.x * ctx->mw->zoom_factor_x - ctx->mw->offset_x;
  p1.y = p1.y * ctx->mw->zoom_factor_y - ctx->mw->offset_y;
  p2.x = p2.x * ctx->mw->zoom_factor_x - ctx->mw->offset_x;
  p2.y = p2.y * ctx->mw->zoom_factor_y - ctx->mw->offset_y;
  int ll_x = int(MIN(p1.x, p2.x));
  int ur_x = int(MAX(p1.x, p2.x));
  int ll_y = int(MIN(p1.y, p2.y));
  int ur_y = int(MAX(p1.y, p2.y));
  double rotation = (tmp.rotation / 360 - floor(tmp.rotation / 360)) * 360;

  double ish = shadow_width / 100 * MIN(ur_x - ll_x, ur_y - ll_y);

  int gc1, gc2;
  if (gradient_contrast >= 0) {
    gc1 = gradient_contrast / 2;
    gc2 = -int(float(gradient_contrast) / 2 + 0.6);
  } else {
    gc1 = int(float(gradient_contrast) / 2 - 0.6);
    gc2 = -gradient_contrast / 2;
  }

  ctx->export_jbean->pie(ll_x, ll_y, ur_x, ur_y, angle1, angle2, draw_type,
      fill_drawtype, fill, border, sectors, sector_color, min_value, max_value,
      line_width, rotation, ish, shadow, gradient, gc1, gc2, pass, shape_cnt,
      node_cnt, fp);
}

void GrowPie::set_conf(
    int sector_num, double min_val, double max_val, glow_eDrawType* color)
{
  sectors = sector_num;
  min_value = min_val;
  max_value = max_val;
  for (int i = 0; i < sectors; i++)
    sector_color[i] = color[i];
  ctx->set_dirty();
}

void GrowPie::get_conf(int* sector_num, double* min_val, double* max_val)
{
  *sector_num = sectors;
  *min_val = min_value;
  *max_val = max_value;
}

void GrowPie::set_values(double* values)
{
  for (int i = 0; i < sectors; i++)
    sector_size[i] = values[i];
  ctx->set_dirty();
}

void GrowPie::convert(glow_eConvert version)
{
}
