/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <math.h>
#include <stdlib.h>
#include <iostream>

#include "glow_dashboard.h"
#include "glow_growdashcell.h"
#include "glow_msg.h"

void GrowDashboard::position(double x, double y)
{
  ctx->a_move.move(x - ctx->node_move_last_x, y - ctx->node_move_last_y, 2);
}

int GrowDashboard::get_next_free(int start_row, int start_col, 
				 int rows, int cols, double *x, double *y)
{
  int *table;
  GrowDashCell *dc;
  double ll_x, ll_y, ur_x, ur_y;
  int row, col;

  table = (int *)calloc(dash_rows * dash_columns, sizeof(int));

  for (int i = 0; i < ctx->a.size(); i++) {
    if (ctx->a[i]->type() == glow_eObjectType_GrowDashCell) {
      dc = (GrowDashCell *)ctx->a[i];
      dc->measure(&ll_x, &ll_y, &ur_x, &ur_y);
      row = round(ll_y / ctx->dash_cell_height);
      col = round(ll_x / ctx->dash_cell_width);
      for (int j = 0; j < dc->cell_rows; j++) {
	for (int k = 0; k < dc->cell_columns; k++) {
	  if ((k + col) < dash_columns && (j + row) < dash_rows) {
	    table[(j + row) * dash_columns + (k + col)] = 1; 
	  }
	}
      }
    }
  }

#if 0
  for (int j = 0; j < dash_rows; j++) {
    for (int k = 0; k < dash_columns; k++) {
      printf("%d", table[j * dash_columns + k]);
    }
    printf("\n");
  }
#endif

  int found = 0;
  // Loop over the next space
  for (int j = start_row; j < dash_rows; j++) {
    for (int k = start_col; k < dash_columns; k++) {
      // Loop over cell area
      int no = 0;
      for (int l = 0; l < rows; l++) {
	for (int m = 0; m < cols; m++) {
	  if ((j + l) >= dash_rows || 
	      (k + m) >= dash_columns || 
	      table[(j + l) * dash_columns + (k + m)] == 1) {
	    no = 1;
	    break;
	  }
	}
	if (no)
	  break;
      }
      if (!no) {
	*x = ctx->dash_cell_width * k;
	*y = ctx->dash_cell_height * j;
	found = 1;
	break;
      }
    }
    if (found)
      break;
  }
  free(table);

  if (!found) {
    *x = 0;
    *y = 0;
    return GLOW__DASH_FULL;
  }
  return 1;
}

void GrowDashboard::find_grid(double x, double y, double* x_grid, double* y_grid)
{
  double x1, y1;
  double grid_size_x = ctx->dash_cell_width;
  double grid_size_y = ctx->dash_cell_height;

  x1 = floor(x / grid_size_x) * grid_size_x;
  if (x - x1 < 0.5 * grid_size_x)
    *x_grid = x1;
  else
    *x_grid = x1 + grid_size_x;

  y1 = floor(y / grid_size_y) * grid_size_y;
  if (y - y1 < 0.5 * grid_size_y)
    *y_grid = y1;
  else
    *y_grid = y1 + grid_size_y;
}

void GrowDashboard::save(std::ofstream& fp, glow_eSaveMode mode)
{
  fp << int(glow_eSave_GrowDashboard) << '\n';
  fp << int(glow_eSave_GrowDashboard_dash_columns) << FSPACE << dash_columns << '\n';
  fp << int(glow_eSave_GrowDashboard_dash_rows) << FSPACE << dash_rows << '\n';
  fp << int(glow_eSave_End) << '\n';
}

void GrowDashboard::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GrowDashboard: \"%d %s\"\n", type, dummy);
    }

    fp >> type;
    switch (type) {
    case glow_eSave_GrowDashboard:
      break;
    case glow_eSave_GrowDashboard_dash_columns:
      fp >> dash_columns;
      break;
    case glow_eSave_GrowDashboard_dash_rows:
      fp >> dash_rows;
      break;
    case glow_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GrowDashboard:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}
