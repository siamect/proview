/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <math.h>

#include "co_string.h"

#include "glow_colpalctx.h"
#include "glow_conpoint.h"
#include "glow_con.h"
#include "glow_growrect.h"
#include "glow_growtext.h"
#include "glow_draw.h"
#include "glow_msg.h"

static int tone_color_match(int tone);

void ColPalCtx::configure()
{
  GrowText* text;
  GrowRect* rect;
  double x, y = 0.0;
  int i;
  double d = 0.02;

  if (nodraw)
    return;

  display_fill = new GrowRect(this, "FillRect", d, 0,
      display_entry_width - 2 * d, entry_height, glow_eDrawType_Color37, 1, 0,
      glow_mDisplayLevel_1, 1, 1, 0, current_fill);
  insert((GlowArrayElem*)display_fill);
  active_fill = new GrowRect(this, "FillRectActive", d, 0,
      display_entry_width - 2 * d, entry_height, glow_eDrawType_Line, 1, 0,
      glow_mDisplayLevel_1, 0, 1, 1, current_fill);
  insert((GlowArrayElem*)active_fill);
  ((GrowRect*)active_fill)->shadow_width = 15;
  ((GrowRect*)active_fill)->relief = glow_eRelief_Down;
  text_fill
      = new GrowText(this, "FillText", "Fill", 0.3, entry_height / 2 + 0.2,
          glow_eDrawType_TextHelvetica, glow_eDrawType_Line, 2);
  insert(text_fill);

  display_border = new GrowRect(this, "BorderRect", display_entry_width + d, 0,
      display_entry_width - 2 * d, entry_height, glow_eDrawType_Color37, 1, 0,
      glow_mDisplayLevel_1, 1, 1, 0, current_border);
  insert((GlowArrayElem*)display_border);
  active_border = new GrowRect(this, "BorderRectActive",
      display_entry_width + d, 0, display_entry_width - 2 * d, entry_height,
      glow_eDrawType_Line, 1, 0, glow_mDisplayLevel_1, 0, 1, 1, current_border);
  insert((GlowArrayElem*)active_border);
  ((GrowRect*)active_border)->shadow_width = 15;
  ((GrowRect*)active_border)->relief = glow_eRelief_Down;
  ((GrowRect*)active_border)->display_level = glow_mDisplayLevel_2;
  text_border = new GrowText(this, "BorderText", "Border",
      display_entry_width + 0.3, entry_height / 2 + 0.2,
      glow_eDrawType_TextHelvetica, glow_eDrawType_Color4, 2);
  insert(text_border);

  display_text = new GrowRect(this, "TextRect", display_entry_width * 2 + d, 0,
      display_entry_width - 2 * d, entry_height, glow_eDrawType_Color37, 1, 0,
      glow_mDisplayLevel_1, 1, 1, 0, current_text);
  insert((GlowArrayElem*)display_text);
  active_text = new GrowRect(this, "TextRectActive",
      display_entry_width * 2 + d, 0, display_entry_width - 2 * d, entry_height,
      glow_eDrawType_Line, 1, 0, glow_mDisplayLevel_1, 0, 1, 1, current_text);
  ((GrowRect*)active_text)->shadow_width = 15;
  ((GrowRect*)active_text)->relief = glow_eRelief_Down;
  ((GrowRect*)active_text)->display_level = glow_mDisplayLevel_2;
  insert((GlowArrayElem*)active_text);
  ((GrowRect*)active_text)->display_level = glow_mDisplayLevel_2;
  text_text = new GrowText(this, "TextText", "Text",
      display_entry_width * 2 + 0.3, entry_height / 2 + 0.2,
      glow_eDrawType_TextHelvetica, glow_eDrawType_Color4, 2);
  insert(text_text);

  for (i = glow_eDrawType_Line; i <= glow_eDrawType_Color300; i++) {
    x = entry_width * (double(i) / columns - floor(double(i) / columns))
        * columns;
    y = entry_height * (1 + floor(i / columns + DBL_EPSILON));
    rect = new GrowRect(this, "ColorEntry", x, y, entry_width, entry_height,
        glow_eDrawType_Line, 1, 0, glow_mDisplayLevel_1, 1, 1, 0,
        (glow_eDrawType)i);
    insert(rect);
  }

  int custom_columns = 15;
  double custom_entry_width = 2 * entry_width;
  double dw;
  for (i = glow_eDrawType_CustomColor1; i <= glow_eDrawType_CustomColor90;
       i += 4) {
    int i_pos = glow_eDrawType_CustomColor1
        + (i - glow_eDrawType_CustomColor1) / 4 - 10;
    dw = (((i_pos + 1) % 5) == 0 && ((i_pos + 1) % 15) != 0) ? 0.1 * entry_width
                                                             : 0;
    x = custom_entry_width * (double(i_pos) / custom_columns
                                 - floor(double(i_pos) / custom_columns))
        * custom_columns;
    y = entry_height * (1 + 300 / columns + floor((i_pos - 300) / custom_columns
                                                + DBL_EPSILON));
    rect = new GrowRect(this, "ColorEntry", x, y, custom_entry_width - dw,
        entry_height, glow_eDrawType_Line, 1, 0, glow_mDisplayLevel_1, 1, 1, 0,
        (glow_eDrawType)i);
    insert(rect);
  }
  y += entry_height;
  x = 0;
  color_description_bg = new GrowRect(this, "ColorDescriptionBg", x, y + 0.04,
      custom_entry_width * 16, entry_height - 0.04, glow_eDrawType_Line, 1, 0,
      glow_mDisplayLevel_1, 1, 0, 0, glow_eDrawType_LineErase);
  color_description = new GrowText(this, "ColorDescription", "", x,
      y + entry_height / 2 + 0.15, glow_eDrawType_TextHelvetica,
      glow_eDrawType_Line, 3);
  insert(color_description_bg);
  insert(color_description);

  double tone_entry_width = 3 * entry_width;
  y += entry_height;
  x = 0;

  active_tone = new GrowRect(this, "ToneRect", x, y, tone_entry_width * 2,
      entry_height, glow_eDrawType_Line, 1, 0, glow_mDisplayLevel_1, 1, 1, 0,
      glow_eDrawType_Color34);
  insert(active_tone);
  text_tone = new GrowText(this, "ToneText", "Tone", x + 0.15,
      y + entry_height / 2 + 0.25, glow_eDrawType_TextHelveticaBold,
      glow_eDrawType_Line, 2);
  insert(text_tone);

  x += 2 * tone_entry_width;
  sprintf(name, "ToneEntry%d", 0);
  rect = new GrowRect(this, name, x, y, tone_entry_width * 2, entry_height,
      glow_eDrawType_Line, 1, 0, glow_mDisplayLevel_1, 1, 1, 1,
      glow_eDrawType_Color34);
  rect->shadow_width = 15;
  rect->relief = glow_eRelief_Down;
  insert(rect);
  text
      = new GrowText(this, name, "Reset", x + 0.15, y + entry_height / 2 + 0.25,
          glow_eDrawType_TextHelvetica, glow_eDrawType_Line, 2);
  insert((GlowArrayElem*)text);
  x += 2 * tone_entry_width;
  sprintf(name, "ColorEntryBg");
  rect = new GrowRect(this, name, x, y, tone_entry_width * 2, entry_height,
      glow_eDrawType_Line, 1, 0, glow_mDisplayLevel_1, 1, 1, 1,
      glow_eDrawType_Color34);
  rect->shadow_width = 15;
  rect->relief = glow_eRelief_Down;
  insert(rect);
  text = new GrowText(this, name, " Bg", x + 0.15, y + entry_height / 2 + 0.25,
      glow_eDrawType_TextHelvetica, glow_eDrawType_Line, 2);
  insert((GlowArrayElem*)text);

  x = 0;
  for (i = glow_eDrawTone_No + 1; i < glow_eDrawTone_GrayHighSaturation; i++) {
    char name[16];
    glow_eDrawType drawtype;

    drawtype = (glow_eDrawType)tone_color_match(i);
    if (i == glow_eDrawTone_Gray || i == glow_eDrawTone_LightGray
        || i == glow_eDrawTone_DarkGray) {
      // New row
      y += entry_height;
      x = 0;
    } else
      x += tone_entry_width;

    sprintf(name, "ToneEntry%d", i);
    rect = new GrowRect(this, name, x, y, tone_entry_width, entry_height,
        glow_eDrawType_Line, 1, 0, glow_mDisplayLevel_1, 1, 1, 0, drawtype);
    insert(rect);
  }
  get_borders();
  a.zoom();
  redraw();
  change_scrollbar();
  set_colors();
  hot_mode = glow_eHotMode_Disabled;
}

void ColPalCtx::change_scrollbar()
{
  glow_sScroll data;

  if (!scroll_size) {
    scroll_size = entry_height + 1.0 / mw.zoom_factor_y;
  }

  data.scroll_data = scroll_data;
  data.total_width = int((x_right - x_left) / scroll_size) + 1;
  data.total_height = int((y_high - y_low) / scroll_size) + 1;
  data.window_width = int(mw.window_width / scroll_size / mw.zoom_factor_x) + 1;
  data.window_height
      = int(mw.window_height / scroll_size / mw.zoom_factor_y) + 1;
  data.offset_x = int(
      mw.offset_x / scroll_size / mw.zoom_factor_x - x_left / scroll_size);
  data.offset_y
      = int(mw.offset_y / scroll_size / mw.zoom_factor_y - y_low / scroll_size);

  (scroll_callback)(&data);
}

void ColPalCtx::redraw()
{
  clear(&mw);
  draw(&mw, 0, 0, mw.window_width, mw.window_height);
  nav_zoom();
}

void ColPalCtx::zoom(double factor)
{
  if (fabs(factor) < DBL_EPSILON)
    return;

  mw.zoom_factor_x *= factor;
  mw.zoom_factor_y *= factor;
  if (mw.offset_x != 0)
    mw.offset_x = int(
        (mw.offset_x - mw.window_width / 2.0 * (1.0 / factor - 1)) * factor);
  if (mw.offset_y != 0)
    mw.offset_y = int(
        (mw.offset_y - mw.window_height / 2.0 * (1.0 / factor - 1)) * factor);
  mw.offset_x = MAX(mw.offset_x, 0);
  mw.offset_y = MAX(mw.offset_y, 0);
  if ((x_right - x_left) * mw.zoom_factor_x <= mw.window_width)
    mw.offset_x = 0;
  if ((y_high - y_low) * mw.zoom_factor_y <= mw.window_height)
    mw.offset_y = 0;
  a.zoom();
  clear(&mw);
  draw(&mw, 0, 0, mw.window_width, mw.window_height);
  nav_zoom();
  change_scrollbar();
}

void ColPalCtx::print(char* filename)
{
  int i;
  double ll_x, ll_y, ur_x, ur_y;
  double width, height;

  if (a.size() == 0)
    return;
  ((GlowNode*)a[0])->measure(&ll_x, &ll_y, &ur_x, &ur_y);
  height = 60 * (ur_y - ll_y);
  width = 0.70 * height;

  print_ps = new GlowPscript(filename, this, 1);

  for (i = 0;; i++) {
    ll_y = i * height;
    ur_y = ll_y + height;
    ll_x = 0;
    ur_x = width;
    if (ll_y > y_high)
      break;

    print_ps->print_page(ll_x, ll_y, ur_x, ur_y);
  }
  delete print_ps;
}

void colpal_scroll_horizontal(ColPalCtx* ctx, int value, int bottom)
{
  int x_pix;

  x_pix = int(-value * ctx->scroll_size * ctx->mw.zoom_factor_x
      + (ctx->mw.offset_x - ctx->x_left * ctx->mw.zoom_factor_x));
  ctx->scroll(x_pix, 0);
}

void colpal_scroll_vertical(ColPalCtx* ctx, int value, int bottom)
{
  int y_pix;

  y_pix = int(-value * ctx->scroll_size * ctx->mw.zoom_factor_y
      + (ctx->mw.offset_y - ctx->y_low * ctx->mw.zoom_factor_y));
  // Correction for the bottom position
  if (bottom
      && (y_pix >= 0
             || ctx->mw.window_height + y_pix
                 < ctx->y_high * ctx->mw.zoom_factor_y - ctx->mw.offset_y))
    //        window_height >= (y_high - y_low) * zoom_factor_y)
    y_pix = int(ctx->mw.window_height + ctx->mw.offset_y
        - ctx->y_high * ctx->mw.zoom_factor_y);
  ctx->scroll(0, y_pix);
}

int ColPalCtx::event_handler(glow_eEvent event, int x, int y, int w, int h)
{
  int sts = 0;
  int i;
  GlowCtx* ctx;
  double fx, fy;
  int callback = 0;
  static int current_idx = -1;

  ctx = this;
  //  std::cout << "Event: " << event << '\n';

  fx = double(x + ctx->mw.offset_x) / ctx->mw.zoom_factor_x;
  fy = double(y + ctx->mw.offset_y) / ctx->mw.zoom_factor_y;

  callback_object_type = glow_eObjectType_NoObject;
  callback_object = 0;

  switch (event) {
  case glow_eEvent_MB1Down: {
    sts = 0;
    for (i = 0; i < a.a_size; i++) {
      sts = a.a[i]->event_handler(&ctx->mw, event, x, y, fx, fy);
      if (sts == GLOW__NO_PROPAGATE)
        break;
    }

    int enable_doubleclick = 0;
    if (callback_object_type != glow_eObjectType_NoObject) {
      if (callback_object->type() == glow_eObjectType_GrowRect) {
        GrowRect* rect;
        char name[32];

        rect = (GrowRect*)callback_object;
        rect->get_object_name(name, sizeof(name), glow_eName_Object);
        if (streq(name, "ColorEntry")) {
          if (rect->fill_drawtype >= glow_eDrawType_CustomColor1
              && rect->fill_drawtype < glow_eDrawType_CustomColor__) {
            enable_doubleclick = 1;
          }
        }
      }
    }
    if (!enable_doubleclick)
      ctx->gdraw->set_click_sensitivity(&ctx->mw, glow_mSensitivity_MB1Click);
    break;
  }
  case glow_eEvent_MB1Click:
  case glow_eEvent_MB1ClickShift:
  case glow_eEvent_MB2Click:
    sts = 0;
    for (i = 0; i < a.a_size; i++) {
      sts = a.a[i]->event_handler(&ctx->mw, event, x, y, fx, fy);
      if (sts == GLOW__NO_PROPAGATE)
        break;
    }

    if (callback_object_type != glow_eObjectType_NoObject) {
      if (callback_object->type() == glow_eObjectType_GrowText) {
        GrowText* text;
        char name[32];

        text = (GrowText*)callback_object;
        text->get_object_name(name, sizeof(name), glow_eName_Object);
        if (str_StartsWith(name, "FillText") && event == glow_eEvent_MB1Click) {
          set_active(colpal_eActive_FillColor);
        } else if (str_StartsWith(name, "BorderText")
            && event == glow_eEvent_MB1Click) {
          set_active(colpal_eActive_BorderColor);
        } else if (str_StartsWith(name, "TextText")
            && event == glow_eEvent_MB1Click) {
          set_active(colpal_eActive_TextColor);
        } else if (str_StartsWith(name, "ToneEntry")
            && event == glow_eEvent_MB1Click) {
          glow_eDrawTone tone;

          sscanf(&name[9], "%d", (int*)&tone);
          if (event_callback[event] && sts != GLOW__NO_PROPAGATE) {
            static glow_sEvent e;

            e.event = event;
            e.any.type = glow_eEventType_ColorTone;
            e.any.x_pixel = x;
            e.any.y_pixel = y;
            e.any.x = 1.0 * (x + mw.offset_x) / mw.zoom_factor_x;
            e.any.y = 1.0 * (y + mw.offset_y) / mw.zoom_factor_y;
            e.colortone.tone = tone;
            event_callback[event](this, &e);
          }
          current_tone = (glow_eDrawType)tone;
          break;
        }
        if (streq(name, "ColorEntryBg")) {
          if (event == glow_eEvent_MB1Click) {
            current_fill = glow_eDrawType_LineErase;
            ((GrowRect*)display_fill)->set_fill_color(glow_eDrawType_Color4);
          } else if (event == glow_eEvent_MB1ClickShift) {
            current_text = glow_eDrawType_LineErase;
            ((GrowRect*)display_text)->set_fill_color(glow_eDrawType_Color4);
          } else {
            current_border = glow_eDrawType_LineErase;
            ((GrowRect*)display_border)->set_fill_color(glow_eDrawType_Color4);
          }
          callback = 1;
        }
      } else if (callback_object->type() == glow_eObjectType_GrowRect) {
        GrowRect* rect;
        char name[32];

        rect = (GrowRect*)callback_object;
        rect->get_object_name(name, sizeof(name), glow_eName_Object);
        if (str_StartsWith(name, "FillRect") && event == glow_eEvent_MB1Click) {
          set_active(colpal_eActive_FillColor);
        } else if (str_StartsWith(name, "BorderRect")
            && event == glow_eEvent_MB1Click) {
          set_active(colpal_eActive_BorderColor);
        } else if (str_StartsWith(name, "TextRect")
            && event == glow_eEvent_MB1Click) {
          set_active(colpal_eActive_TextColor);
        } else if (str_StartsWith(name, "ToneEntry")
            && event == glow_eEvent_MB1Click) {
          glow_eDrawTone tone;

          sscanf(&name[9], "%d", (int*)&tone);
          if (event_callback[event] && sts != GLOW__NO_PROPAGATE) {
            static glow_sEvent e;

            e.event = event;
            e.any.type = glow_eEventType_ColorTone;
            e.any.x_pixel = x;
            e.any.y_pixel = y;
            e.any.x = 1.0 * (x + mw.offset_x) / mw.zoom_factor_x;
            e.any.y = 1.0 * (y + mw.offset_y) / mw.zoom_factor_y;
            e.colortone.tone = tone;
            event_callback[event](this, &e);
          }
          current_tone = (glow_eDrawType)tone;
          ((GrowRect*)active_tone)
              ->set_fill_color((glow_eDrawType)tone_color_match((int)tone));
          break;
        }
        if (!str_StartsWith(name, "ColorEntry"))
          break;
        if (streq(name, "ColorEntryBg")) {
          if (event == glow_eEvent_MB1Click) {
            current_fill = glow_eDrawType_LineErase;
            ((GrowRect*)display_fill)->set_fill_color(glow_eDrawType_Color4);
          } else if (event == glow_eEvent_MB1ClickShift) {
            current_text = glow_eDrawType_LineErase;
            ((GrowRect*)display_text)->set_fill_color(glow_eDrawType_Color4);
          } else {
            current_border = glow_eDrawType_LineErase;
            ((GrowRect*)display_border)->set_fill_color(glow_eDrawType_Color4);
          }
          callback = 1;
        } else {
          if (event == glow_eEvent_MB1Click) {
            switch (active) {
            case colpal_eActive_FillColor:
              current_fill = rect->fill_drawtype;
              break;
            case colpal_eActive_BorderColor:
              current_border = rect->fill_drawtype;
              break;
            case colpal_eActive_TextColor:
              current_text = rect->fill_drawtype;
              break;
            }
            set_colors();
          } else if (event == glow_eEvent_MB1ClickShift) {
            current_text = rect->fill_drawtype;
            set_colors();
          } else {
            current_border = rect->fill_drawtype;
            set_colors();
          }
          callback = 1;
        }
      } else if (callback_object->type() == glow_eObjectType_GrowText) {
      }
    }
    break;

  case glow_eEvent_MB1ClickShiftCtrl:
    sts = 0;
    for (i = 0; i < a.a_size; i++) {
      sts = a.a[i]->event_handler(&ctx->mw, event, x, y, fx, fy);
      if (sts == GLOW__NO_PROPAGATE)
        break;
    }

    if (callback_object_type != glow_eObjectType_NoObject) {
      if (callback_object->type() == glow_eObjectType_GrowRect) {
        GrowRect* rect;
        char name[32];

        rect = (GrowRect*)callback_object;
        rect->get_object_name(name, sizeof(name), glow_eName_Object);
        if (streq(name, "ColorEntry")) {
          if (event_callback[event]) {
            static glow_sEvent e;

            e.event = event;
            e.any.type = glow_eEventType_ColorTone;
            e.any.x_pixel = x;
            e.any.y_pixel = y;
            e.any.x = 1.0 * (x + mw.offset_x) / mw.zoom_factor_x;
            e.any.y = 1.0 * (y + mw.offset_y) / mw.zoom_factor_y;
            e.colortone.tone = (glow_eDrawTone)rect->fill_drawtype;
            event_callback[event](this, &e);
          }
        } else if (streq(name, "ColorEntryBg")) {
          if (event_callback[event]) {
            static glow_sEvent e;

            e.event = event;
            e.any.type = glow_eEventType_ColorTone;
            e.any.x_pixel = x;
            e.any.y_pixel = y;
            e.any.x = 1.0 * (x + mw.offset_x) / mw.zoom_factor_x;
            e.any.y = 1.0 * (y + mw.offset_y) / mw.zoom_factor_y;
            e.colortone.tone = (glow_eDrawTone)glow_eDrawType_LineErase;
            event_callback[event](this, &e);
          }
        }
      } else if (callback_object->type() == glow_eObjectType_GrowText) {
        GrowText* text;
        char name[32];

        text = (GrowText*)callback_object;
        text->get_object_name(name, sizeof(name), glow_eName_Object);
        if (streq(name, "ColorEntryBg")) {
          if (event_callback[event]) {
            static glow_sEvent e;

            e.event = event;
            e.any.type = glow_eEventType_ColorTone;
            e.any.x_pixel = x;
            e.any.y_pixel = y;
            e.any.x = 1.0 * (x + mw.offset_x) / mw.zoom_factor_x;
            e.any.y = 1.0 * (y + mw.offset_y) / mw.zoom_factor_y;
            e.colortone.tone = (glow_eDrawTone)glow_eDrawType_LineErase;
            event_callback[event](this, &e);
          }
        }
      }
    }
    break;

  case glow_eEvent_MB1DoubleClick:
    sts = 0;
    for (i = 0; i < a.a_size; i++) {
      sts = a.a[i]->event_handler(&ctx->mw, event, x, y, fx, fy);
      if (sts == GLOW__NO_PROPAGATE)
        break;
    }

    if (callback_object_type != glow_eObjectType_NoObject) {
      if (callback_object->type() == glow_eObjectType_GrowRect) {
        GrowRect* rect;
        char name[32];
        int sts;

        rect = (GrowRect*)callback_object;
        rect->get_object_name(name, sizeof(name), glow_eName_Object);
        if (streq(name, "ColorEntry")) {
          current_fill = rect->fill_drawtype;
          if (rect->fill_drawtype >= glow_eDrawType_CustomColor1
              && rect->fill_drawtype < glow_eDrawType_CustomColor__) {
            double r, g, b;

            sts = customcolors->get_color(rect->fill_drawtype, &r, &g, &b);
            if (EVEN(sts))
              r = g = b = 1;

            sts = gdraw->open_color_selection(&r, &g, &b);
            if (ODD(sts)) {
              // Send custom color changed callback
              if (event_callback[event]) {
                static glow_sEvent e;

                e.event = event;
                e.any.type = glow_eEventType_CustomColor;
                e.any.x_pixel = x;
                e.any.y_pixel = y;
                e.any.x = 1.0 * (x + mw.offset_x) / mw.zoom_factor_x;
                e.any.y = 1.0 * (y + mw.offset_y) / mw.zoom_factor_y;
                e.customcolor.color = rect->fill_drawtype;
                e.customcolor.red = r;
                e.customcolor.green = g;
                e.customcolor.blue = b;
                event_callback[event](this, &e);

                // Redraw with the new color
                // draw( &mw, 0, 0, mw.window_width, mw.window_height);
                gdraw->update_color(rect->fill_drawtype);
                redraw();
              }
            }
          }
        }
      }
    }
    break;

  case glow_eEvent_Leave:
    current_idx = -1;
    ((GrowText*)color_description)->set_text((char*)" ");
    break;
  case glow_eEvent_CursorMotion: {
    int idx = -1;
    sts = 0;

    hot_found = 0;
    for (i = 0; i < a.a_size; i++) {
      sts = a.a[i]->event_handler(&ctx->mw, event, x, y, fx, fy);
      if (sts == GLOW__NO_PROPAGATE)
        break;
    }

    if (callback_object_type != glow_eObjectType_NoObject) {
      if (callback_object->type() == glow_eObjectType_GrowRect) {
        GrowRect* rect;
        char name[32];

        rect = (GrowRect*)callback_object;
        rect->get_object_name(name, sizeof(name), glow_eName_Object);
        if (streq(name, "ColorEntry")) {
          idx = rect->fill_drawtype;
        }
      }
    }
    if (current_idx != idx) {
      if (idx == -1)
        ((GrowText*)color_description)->set_text((char*)" ");
      else {
        if (idx >= glow_eDrawType_CustomColor1
            && idx < glow_eDrawType_CustomColor__) {
          if (customcolors && customcolors->is_default_colortheme) {
	    char text[80];

	    sprintf(text, "%d %s", (idx - glow_eDrawType_CustomColor1) / 4 + 1, 
		    colortheme_idx_to_text((idx - glow_eDrawType_CustomColor1) / 4));
            ((GrowText*)color_description)->set_text(text);
	  }
          else
            ((GrowText*)color_description)
                ->set_text(customcolor_idx_to_text(idx));
        } else
          ((GrowText*)color_description)->set_text(color_idx_to_text(idx));
      }
      current_idx = idx;
    }
    break;
  }
  case glow_eEvent_Exposure:
    int width, height;

    gdraw->get_window_size(&mw, &width, &height);
    if (mw.window_width != width || mw.window_height != height) {
      mw.window_width = width;
      mw.window_height = height;
      change_scrollbar();
    }

    draw(&mw, x, y, x + w, y + h);
    break;
  default:;
  }

  if (event_callback[event] && sts != GLOW__NO_PROPAGATE && callback) {
    static glow_sEvent e;

    e.event = event;
    e.any.type = glow_eEventType_Object;
    e.any.x_pixel = x;
    e.any.y_pixel = y;
    e.any.x = 1.0 * (x + mw.offset_x) / mw.zoom_factor_x;
    e.any.y = 1.0 * (y + mw.offset_y) / mw.zoom_factor_y;
    e.object.object_type = callback_object_type;
    if (callback_object_type != glow_eObjectType_NoObject)
      e.object.object = callback_object;
    event_callback[event](this, &e);
  }
  return 1;
}

void ColPalCtx::set_active(colpal_eActive a)
{
  active = a;
  switch (active) {
  case colpal_eActive_FillColor:
    ((GrowRect*)active_fill)->display_level = glow_mDisplayLevel_1;
    ((GrowRect*)active_border)->display_level = glow_mDisplayLevel_2;
    ((GrowRect*)active_text)->display_level = glow_mDisplayLevel_2;
    break;
  case colpal_eActive_BorderColor:
    ((GrowRect*)active_fill)->display_level = glow_mDisplayLevel_2;
    ((GrowRect*)active_border)->display_level = glow_mDisplayLevel_1;
    ((GrowRect*)active_text)->display_level = glow_mDisplayLevel_2;
    break;
  case colpal_eActive_TextColor:
    ((GrowRect*)active_fill)->display_level = glow_mDisplayLevel_2;
    ((GrowRect*)active_border)->display_level = glow_mDisplayLevel_2;
    ((GrowRect*)active_text)->display_level = glow_mDisplayLevel_1;
    break;
  }
  set_colors();
}

void ColPalCtx::set_colors()
{
  glow_eDrawType shadowcolor;
  glow_eDrawType textcolor;

  ((GrowRect*)display_fill)->set_fill_color(current_fill);
  switch (current_fill) {
  case 0:
    shadowcolor = glow_eDrawType_Color30;
    break;
  case 1:
    shadowcolor = glow_eDrawType_Color188;
    break;
  case 2:
    shadowcolor = glow_eDrawType_Color24;
    break;
  case 3:
    shadowcolor = glow_eDrawType_Color31;
    break;
  case 4:
    shadowcolor = glow_eDrawType_Color87;
    break;
  case 5:
    shadowcolor = glow_eDrawType_Color115;
    break;
  case 6:
    shadowcolor = glow_eDrawType_Color144;
    break;
  case 7:
    shadowcolor = glow_eDrawType_Color145;
    break;
  case 8:
    shadowcolor = glow_eDrawType_Color175;
    break;
  case 9:
    shadowcolor = glow_eDrawType_Color176;
    break;
  case 10:
    shadowcolor = glow_eDrawType_Color205;
    break;
  case 11:
    shadowcolor = glow_eDrawType_Color206;
    break;
  case 12:
    shadowcolor = glow_eDrawType_Color209;
    break;
  case 13:
    shadowcolor = glow_eDrawType_Color239;
    break;
  case 14:
    shadowcolor = glow_eDrawType_Color238;
    break;
  case 15:
    shadowcolor = glow_eDrawType_Color236;
    break;
  case 16:
    shadowcolor = glow_eDrawType_Color264;
    break;
  case 17:
    shadowcolor = glow_eDrawType_Color264;
    break;
  case 18:
    shadowcolor = glow_eDrawType_Color294;
    break;
  case 19:
    shadowcolor = glow_eDrawType_Color294;
    break;
  default:
    shadowcolor = current_fill;
  }
  ((GrowRect*)active_fill)->set_fill_color(shadowcolor);

  if (current_fill < glow_eDrawType_Color__) {
    if (current_fill == glow_eDrawType_Line
        || (((current_fill + 1) % 10 == 0) && current_fill > 20)
        || (((current_fill + 2) % 10 == 0) && current_fill > 20))
      textcolor = glow_eDrawType_Color4;
    else
      textcolor = glow_eDrawType_Line;
  } else if (customcolors && current_fill >= glow_eDrawType_CustomColor1
      && current_fill < glow_eDrawType_CustomColor__) {
    double r, g, b;
    GlowColor::rgb_color(current_fill, &r, &g, &b, customcolors);
    if ((r + g + b) / 3 < 0.4)
      textcolor = glow_eDrawType_Color4;
    else
      textcolor = glow_eDrawType_Line;
  } else
    textcolor = glow_eDrawType_Line;
  text_fill->set_text_color(textcolor);

  ((GrowRect*)display_border)->set_fill_color(current_border);
  switch (current_border) {
  case 0:
    shadowcolor = glow_eDrawType_Color30;
    break;
  case 1:
    shadowcolor = glow_eDrawType_Color188;
    break;
  case 2:
    shadowcolor = glow_eDrawType_Color24;
    break;
  case 3:
    shadowcolor = glow_eDrawType_Color31;
    break;
  case 4:
    shadowcolor = glow_eDrawType_Color87;
    break;
  case 5:
    shadowcolor = glow_eDrawType_Color115;
    break;
  case 6:
    shadowcolor = glow_eDrawType_Color144;
    break;
  case 7:
    shadowcolor = glow_eDrawType_Color145;
    break;
  case 8:
    shadowcolor = glow_eDrawType_Color175;
    break;
  case 9:
    shadowcolor = glow_eDrawType_Color176;
    break;
  case 10:
    shadowcolor = glow_eDrawType_Color205;
    break;
  case 11:
    shadowcolor = glow_eDrawType_Color206;
    break;
  case 12:
    shadowcolor = glow_eDrawType_Color209;
    break;
  case 13:
    shadowcolor = glow_eDrawType_Color239;
    break;
  case 14:
    shadowcolor = glow_eDrawType_Color238;
    break;
  case 15:
    shadowcolor = glow_eDrawType_Color236;
    break;
  case 16:
    shadowcolor = glow_eDrawType_Color264;
    break;
  case 17:
    shadowcolor = glow_eDrawType_Color264;
    break;
  case 18:
    shadowcolor = glow_eDrawType_Color294;
    break;
  case 19:
    shadowcolor = glow_eDrawType_Color294;
    break;
  default:
    shadowcolor = current_border;
  }
  ((GrowRect*)active_border)->set_fill_color(shadowcolor);

  if (current_border < glow_eDrawType_Color__) {
    if (current_border == glow_eDrawType_Line
        || (((current_border + 1) % 10 == 0) && current_border > 20)
        || (((current_border + 2) % 10 == 0) && current_border > 20))
      textcolor = glow_eDrawType_Color4;
    else
      textcolor = glow_eDrawType_Line;
  } else if (customcolors && current_border >= glow_eDrawType_CustomColor1
      && current_border < glow_eDrawType_CustomColor__) {
    double r, g, b;
    GlowColor::rgb_color(current_border, &r, &g, &b, customcolors);
    if ((r + g + b) / 3 < 0.4)
      textcolor = glow_eDrawType_Color4;
    else
      textcolor = glow_eDrawType_Line;
  } else
    textcolor = glow_eDrawType_Line;
  text_border->set_text_color(textcolor);

  ((GrowRect*)display_text)->set_fill_color(current_text);
  switch (current_text) {
  case 0:
    shadowcolor = glow_eDrawType_Color30;
    break;
  case 1:
    shadowcolor = glow_eDrawType_Color188;
    break;
  case 2:
    shadowcolor = glow_eDrawType_Color24;
    break;
  case 3:
    shadowcolor = glow_eDrawType_Color31;
    break;
  case 4:
    shadowcolor = glow_eDrawType_Color87;
    break;
  case 5:
    shadowcolor = glow_eDrawType_Color115;
    break;
  case 6:
    shadowcolor = glow_eDrawType_Color144;
    break;
  case 7:
    shadowcolor = glow_eDrawType_Color145;
    break;
  case 8:
    shadowcolor = glow_eDrawType_Color175;
    break;
  case 9:
    shadowcolor = glow_eDrawType_Color176;
    break;
  case 10:
    shadowcolor = glow_eDrawType_Color205;
    break;
  case 11:
    shadowcolor = glow_eDrawType_Color206;
    break;
  case 12:
    shadowcolor = glow_eDrawType_Color209;
    break;
  case 13:
    shadowcolor = glow_eDrawType_Color239;
    break;
  case 14:
    shadowcolor = glow_eDrawType_Color238;
    break;
  case 15:
    shadowcolor = glow_eDrawType_Color236;
    break;
  case 16:
    shadowcolor = glow_eDrawType_Color264;
    break;
  case 17:
    shadowcolor = glow_eDrawType_Color264;
    break;
  case 18:
    shadowcolor = glow_eDrawType_Color294;
    break;
  case 19:
    shadowcolor = glow_eDrawType_Color294;
    break;
  default:
    shadowcolor = current_text;
  }
  ((GrowRect*)active_text)->set_fill_color(shadowcolor);

  if (current_text < glow_eDrawType_Color__) {
    if (current_text == glow_eDrawType_Line
        || (((current_text + 1) % 10 == 0) && current_text > 20)
        || (((current_text + 2) % 10 == 0) && current_text > 20))
      textcolor = glow_eDrawType_Color4;
    else
      textcolor = glow_eDrawType_Line;
  } else if (customcolors && current_text >= glow_eDrawType_CustomColor1
      && current_text < glow_eDrawType_CustomColor__) {
    double r, g, b;
    GlowColor::rgb_color(current_text, &r, &g, &b, customcolors);
    if ((r + g + b) / 3 < 0.4)
      textcolor = glow_eDrawType_Color4;
    else
      textcolor = glow_eDrawType_Line;
  } else
    textcolor = glow_eDrawType_Line;
  text_text->set_text_color(textcolor);

  draw(&mw, 0, 0, mw.window_width, mw.window_height);
}

int tone_color_match(int tone)
{
  int drawtype;

  switch (tone) {
  case glow_eDrawTone_No:
    drawtype = glow_eDrawType_Color32;
    break;
  case glow_eDrawTone_Gray:
    drawtype = glow_eDrawType_Color35;
    break;
  case glow_eDrawTone_YellowGreen:
    drawtype = glow_eDrawType_Color85;
    break;
  case glow_eDrawTone_Yellow:
    drawtype = glow_eDrawType_Color115;
    break;
  case glow_eDrawTone_Orange:
    drawtype = glow_eDrawType_Color145;
    break;
  case glow_eDrawTone_Red:
    drawtype = glow_eDrawType_Color175;
    break;
  case glow_eDrawTone_Magenta:
    drawtype = glow_eDrawType_Color205;
    break;
  case glow_eDrawTone_Blue:
    drawtype = glow_eDrawType_Color235;
    break;
  case glow_eDrawTone_Seablue:
    drawtype = glow_eDrawType_Color265;
    break;
  case glow_eDrawTone_Green:
    drawtype = glow_eDrawType_Color295;
    break;
  case glow_eDrawTone_DarkGray:
    drawtype = glow_eDrawType_Color38;
    break;
  case glow_eDrawTone_DarkYellowGreen:
    drawtype = glow_eDrawType_Color88;
    break;
  case glow_eDrawTone_DarkYellow:
    drawtype = glow_eDrawType_Color118;
    break;
  case glow_eDrawTone_DarkOrange:
    drawtype = glow_eDrawType_Color148;
    break;
  case glow_eDrawTone_DarkRed:
    drawtype = glow_eDrawType_Color178;
    break;
  case glow_eDrawTone_DarkMagenta:
    drawtype = glow_eDrawType_Color208;
    break;
  case glow_eDrawTone_DarkBlue:
    drawtype = glow_eDrawType_Color238;
    break;
  case glow_eDrawTone_DarkSeablue:
    drawtype = glow_eDrawType_Color268;
    break;
  case glow_eDrawTone_DarkGreen:
    drawtype = glow_eDrawType_Color298;
    break;
  case glow_eDrawTone_LightGray:
    drawtype = glow_eDrawType_Color32;
    break;
  case glow_eDrawTone_LightYellowGreen:
    drawtype = glow_eDrawType_Color82;
    break;
  case glow_eDrawTone_LightYellow:
    drawtype = glow_eDrawType_Color112;
    break;
  case glow_eDrawTone_LightOrange:
    drawtype = glow_eDrawType_Color142;
    break;
  case glow_eDrawTone_LightRed:
    drawtype = glow_eDrawType_Color172;
    break;
  case glow_eDrawTone_LightMagenta:
    drawtype = glow_eDrawType_Color202;
    break;
  case glow_eDrawTone_LightBlue:
    drawtype = glow_eDrawType_Color232;
    break;
  case glow_eDrawTone_LightSeablue:
    drawtype = glow_eDrawType_Color262;
    break;
  case glow_eDrawTone_LightGreen:
    drawtype = glow_eDrawType_Color292;
    break;
  default:
    return glow_eDrawType_No;
  }

  return drawtype;
}

void ColPalCtx::update_custom_colors(GlowCustomColors* cc)
{
  set_custom_colors(cc);
  gdraw->set_customcolors(cc);

  for (int i = glow_eDrawType_CustomColor1; i < glow_eDrawType_CustomColor__;
       i += 4)
    gdraw->update_color((glow_eDrawType)i);
  redraw();
}

char* ColPalCtx::color_idx_to_text(int idx)
{
  static char text[30][20] = { "Black", "Red", "Grey", "White", "YellowGreen",
    "Yellow", "Gold", "Orange", "OrangeRed", "Red", "RedViolet", "Violet",
    "BlueViolet", "BlueBlueViolet", "Blue", "BlueBlueGreen", "BlueGreen",
    "GreenGreenBlue", "Green", "GreenGreenYellow", "GrayFix1", "GrayFix2",
    "GrayFix3", "GrayFix4", "GrayFix5", "GrayFix6", "GrayFix7", "GrayFix8",
    "GrayFix9", "GrayFix10" };

  static char tonestr[9][20] = { "Gray", "Yellowgreen", "Yellow", "Orange",
    "Red", "Magenta", "Blue", "SeaBlue", "Green" };
  static char intensitystr[3][20] = { "Low", "Medium", "High" };
  static char str[40];
  int tone, intensity, lightness;

  if (idx >= 0 && idx < 30)
    return text[idx];
  else if (idx >= 30 && idx < 300) {
    tone = idx / 30 - 1;
    intensity = (idx / 10) % 3;
    lightness = idx % 10 + 1;
    sprintf(str, "%s%s%d", tonestr[tone], intensitystr[intensity], lightness);
    return str;
  }
  strcpy(str, "");
  return str;
}

char* ColPalCtx::customcolor_idx_to_text(int idx)
{
  static char str[20];

  sprintf(str, "CustomColor%d", (idx - glow_eDrawType_CustomColor1) / 4 + 1);
  return str;
}

char* ColPalCtx::colortheme_idx_to_text(int idx)
{
  static char text[90][40] = { "Background", "Background gradient",
    "Delimiter area", "Delimiter line", "Text/Lines on background",
    "Inputfield fill color", "Inputfield border color", "Inputfield text color",
    " ", " ", "Red indicator", "Red curve", "Red bar", "Red bar limit",
    "Red valuefield color", "Indicator border color", "Indicator low color",
    "Indicator on delimiter low color", "Slider color",
    "Slider background color", "Valuefield fill color",
    "Valuefield border color", "Valuefield text color", " ", " ",
    "Green indicator", "Green curve", "Green bar", "Green bar limit",
    "Green valuefield color", "Limitswitch high color", "Limitswitch low color",
    "Limitswitch border color", "Text/lines on delimiter",
    "Button active color", "Button fill color", "Button border color",
    "Button text color", "Button insensitive text color",
    "Button insensitive border color", "Yellow indicator", "Yellow curve",
    "Yellow bar", "Yellow bar limit", "Yellow valuefield color",
    "Symbol fill color", "Symbol border color", "Symbol low color",
    "Symbol empty color", " ", "Bar bar color", "Bar background color",
    "Bar bar limit color", "Bar background area", "Bar background lines",
    "Blue indicator", "Blue curve", "Blue bar", "Blue bar limit",
    "Blue valuefield color", "Menu fill color", "Menu text color",
    "Toolbar fill color", "Toolbar border color", "Toolbar text color",
    "Diagram fill color", "Diagram border color", "Diagram curve color",
    "Axis border color", " ", "Orange indicator", "Orange curve", "Orange bar",
    "Orange bar limit", "Orange valuefield color", "Table fill color",
    "Table border color", "Table text color", "Scrollbar fill color",
    "Scrollbar background color", " ", " ", " ", " ", " ", "Magenta indicator",
    "Magenta curve", "Magenta bar", "Magenta bar limit",
    "Magenta valuefield color" };
  static char nullstr[] = " ";

  if (idx >= 0 && idx < 90)
    return text[idx];
  else
    return nullstr;
}
