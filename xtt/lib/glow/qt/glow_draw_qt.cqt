/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2019 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <assert.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>

#include <iostream>

#include "cow_qt_helpers.h"

#include "glow_browctx.h"
#include "glow_colpalctx.h"
#include "glow_curvectx.h"
#include "glow_draw_qt.h"
#include "glow_growctx.h"
#include "glow_keyboardctx.h"
#include "glow_msg.h"
#include "glow_scroll_widget_qt.h"

#include <QApplication>
#include <QBitmap>
#include <QColorDialog>
#include <QKeyEvent>
#include <QMouseEvent>
#include <QTimer>

#define DRAW_PRESS_PIX 9

static QMouseEvent* last_event;
static QWidget* last_target;

static QColor glow_allocate_named_color(
    GlowDrawQt* draw_ctx, const char* named_color);

static QColor glow_allocate_color(
    GlowDrawQt* draw_ctx, int rgb_red, int rgb_green, int rgb_blue);

static QColor glow_allocate_custom_color(GlowDrawQt* draw_ctx,
    glow_eDrawType drawtype, int rgb_red, int rgb_green, int rgb_blue);

static unique_ptr<QColor[]> glow_read_color_file(
    const char* filename, int* size, int* sts);

static QColor draw_type_to_color(
    GlowDrawQt* draw_ctx, int painter_type, int size)
{
  switch (painter_type) {
  case glow_eDrawType_Line:
  case glow_eDrawType_LineDashed:
  case glow_eDrawType_TextHelvetica:
  case glow_eDrawType_TextHelveticaBold:
    return glow_allocate_named_color(draw_ctx, "black");
  case glow_eDrawType_LineErase:
  case glow_eDrawType_TextHelveticaErase:
  case glow_eDrawType_TextHelveticaEraseBold:
    return draw_ctx->background;
  case glow_eDrawType_LineRed:
  case glow_eDrawType_LineDashedRed:
    return glow_allocate_named_color(draw_ctx, "red");
  case glow_eDrawType_LineGray:
    return glow_allocate_named_color(draw_ctx, "gray");
  default: {
    if (painter_type >= glow_eDrawType_Color4
        && painter_type <= glow_eDrawType_Color300) {
      int sts = 0;
      unique_ptr<QColor[]> color_array = glow_read_color_file(
          "/home/claes/test/ge_colors.dat", &size, &sts);
      if (ODD(sts)) {
        QColor color_p = color_array[painter_type - glow_eDrawType_Color4];
        QColor color = glow_allocate_color(
            draw_ctx, color_p.red(), color_p.green(), color_p.blue());
        return color;
      }
    }

    double r, g, b;

    GlowColor::rgb_color(
        painter_type, &r, &g, &b, draw_ctx->get_customcolors());
    if (GlowColor::is_custom((glow_eDrawType)painter_type)) {
      return glow_allocate_custom_color(draw_ctx, (glow_eDrawType)painter_type,
          int(r * 255), int(g * 255), int(b * 255));
    } else {
      return glow_allocate_color(
          draw_ctx, int(r * 255), int(g * 255), int(b * 255));
    }
  }
  }
}

#define FONT_SCALE 0.7
#define FONT_DESCENT 0.22

static QFont get_font(int font_idx, int painter_type, double size)
{
  QFont res;

  switch (font_idx) {
  case glow_eFont_Helvetica:
    res = QFont("Helvetica");
    break;
  case glow_eFont_Times:
    res = QFont("Times");
    break;
  case glow_eFont_NewCenturySchoolbook:
    res = QFont("Century Schoolbook L");
    break;
  case glow_eFont_Courier:
    res = QFont("Courier 10 pitch");
    break;
  default:
    res = QFont("Lucida Sans");
    break;
  }

  res.setPointSizeF(FONT_SCALE * size);
  if (painter_type == glow_eDrawType_TextHelveticaBold || painter_type == glow_eDrawType_TextHelveticaEraseBold) {
    res.setBold(true);
  }
  return res;
}

static unique_ptr<QPainter> get_painter(
    QPaintDevice* window, GlowDrawQt* draw_ctx, int painter_type, int size)
{
  unique_ptr<QPainter> painter = new QPainter(window);
  switch (painter_type) {
  case glow_eDrawType_LineDashed:
  case glow_eDrawType_LineDashedRed: {
    painter->setBrush(QBrush(draw_type_to_color(draw_ctx, painter_type, size)));
    painter->setBackground(QBrush(draw_ctx->background));
    QPen pen = QPen(painter->brush(), size + 1, Qt::DashLine);
    QVector<double> dashes;
    dashes << 7 + size << 7 + size;
    pen.setDashPattern(dashes);
    painter->setPen(pen);
    return painter;
  }
  case glow_eDrawType_TextHelvetica:
  case glow_eDrawType_TextHelveticaBold:
  case glow_eDrawType_TextHelveticaErase:
  case glow_eDrawType_TextHelveticaEraseBold: {
    painter->setBrush(QBrush(draw_type_to_color(draw_ctx, painter_type, size)));
    painter->setPen(QPen(painter->brush(), size + 1));
    painter->setBackground(QBrush(draw_ctx->background));
    if (size > 0) {
      painter->setFont(get_font(glow_eFont_Helvetica, painter_type, size));
    }
    return painter;
  }
  case glow_eDrawType_Line:
  case glow_eDrawType_LineErase:
  case glow_eDrawType_LineRed:
  case glow_eDrawType_LineGray:
  default: {
    painter->setBrush(QBrush(draw_type_to_color(draw_ctx, painter_type, size)));
    painter->setBackground(QBrush(draw_ctx->background));
    painter->setPen(QPen(painter->brush(), size + 1));
    return painter;
  }
  }
}

static QColor glow_allocate_named_color(
    GlowDrawQt* draw_ctx, const char* named_color)
{
  QColor color;

  color = QColor(named_color);
  if (!color.isValid()) {
    color = Qt::black;
  }

  return color;
}

static QColor glow_allocate_color(
    GlowDrawQt* draw_ctx, int rgb_red, int rgb_green, int rgb_blue)
{
  return QColor::fromRgb(rgb_red, rgb_green, rgb_blue);
}

static QColor glow_allocate_custom_color(GlowDrawQt* draw_ctx,
    glow_eDrawType drawtype, int rgb_red, int rgb_green, int rgb_blue)
{
  if (!draw_ctx->get_customcolors()) {
    return QColor();
  }

  QColor color(rgb_red, rgb_green, rgb_blue);

  draw_ctx->get_customcolors()->color_vect[drawtype - glow_eDrawType_CustomColor1] = color;

  return color;
}

GlowDrawQt::~GlowDrawQt()
{
  closing_down = 1;

  ctx->set_nodraw();
  if (ctx->type() == glow_eCtxType_Grow) {
    delete (GrowCtx*)ctx;
  } else {
    delete ctx;
  }

  if (m_wind->background_pixmap) {
    delete m_wind->background_pixmap;
  }

  if (nav_wind->background_pixmap) {
    delete nav_wind->background_pixmap;
  }
}

int GlowDrawQt::init_nav(QWidget* nav_widget)
{
  assert(dynamic_cast<QtScrollWidgetGlow*>(nav_widget) != NULL);
  nav_wind->window = dynamic_cast<QtScrollWidgetGlow*>(nav_widget);
  nav_wind->buffer = &(dynamic_cast<QtScrollWidgetGlow*>(nav_widget)->image);

  QPalette pal;
  pal.setColor(QPalette::Background, background);
  nav_widget->setAutoFillBackground(true);
  nav_widget->setPalette(pal);

  ctx->no_nav = 0;
  return 1;
}

GlowDrawQt::GlowDrawQt(QWidget* toplevel, void** glow_ctx,
    int (*init_proc)(QWidget* w, GlowCtx* ctx, void* client_data),
    void* client_data, glow_eCtxType type)
    : click_sensitivity(0), closing_down(0), customcolors_cnt(0)
{
  timer_id = new QTimer(this);
  m_wind = new DrawWindQt();
  nav_wind = new DrawWindQt();
  nav_wind->is_nav = 1;

  memset(customcolors, 0, sizeof(customcolors));

  if (type == glow_eCtxType_Brow) {
    ctx = (GlowCtx*)new BrowCtx("Claes context", 20);
  } else if (type == glow_eCtxType_Grow) {
    ctx = (GlowCtx*)new GrowCtx("Claes context", 20);
  } else if (type == glow_eCtxType_ColPal) {
    ctx = (GlowCtx*)new ColPalCtx("Claes context", 20);
  } else if (type == glow_eCtxType_Keyboard) {
    ctx = (GlowCtx*)new KeyboardCtx("Claes context", 20);
  } else if (type == glow_eCtxType_Curve) {
    ctx = (GlowCtx*)new CurveCtx("Claes context", 20);
  } else {
    ctx = new GlowCtx("Claes context", 20);
  }
  *glow_ctx = (void*)ctx;

  ctx->gdraw = this;

  assert(dynamic_cast<QtScrollWidgetGlow*>(toplevel) != NULL);
  m_wind->window = dynamic_cast<QtScrollWidgetGlow*>(toplevel);
  m_wind->buffer = &(dynamic_cast<QtScrollWidgetGlow*>(toplevel)->image);

  ctx->mw.window = m_wind;
  ctx->navw.window = nav_wind;

  QPalette pal = m_wind->window->palette();
  background = pal.color(QPalette::Background);
  original_background = background;

  if (type == glow_eCtxType_Grow || type == glow_eCtxType_Curve
      || type == glow_eCtxType_Keyboard) {
    ctx->customcolors = create_customcolors();
    push_customcolors(ctx->customcolors);
  }

  get_window_size(&ctx->mw, &ctx->mw.window_width, &ctx->mw.window_height);
  create_buffer(&ctx->mw);
  init_proc(toplevel, ctx, client_data);
}

int GlowDrawQt::event_handler(QEvent* event, QWidget* target)
{
  static int button_pressed = 0;
  static int button_clicked = 0;
  static int button_clicked_and_pressed = 0;
  static int button1_pressed = 0;
  static int button2_pressed = 0;
  static int button3_pressed = 0;
  static int last_press_x = 0;
  static int last_press_y = 0;
  int sts = 1;

  if (closing_down) {
    return 1;
  }

  if (target == m_wind->window || event->type() == QEvent::KeyPress) {
    if (GlowCtx::eventlog_enabled) {
      log_event(event);
    }

    switch (event->type()) {
    case QEvent::KeyPress: {
      QKeyEvent* keyEvent = ((QKeyEvent*)event);
      int keysym;

      keysym = keyEvent->key();
      if (keysym >= Qt::Key_Space && keysym <= Qt::Key_AsciiTilde) {
        char buff = QChar(keysym).toAscii();

        if (keyEvent->modifiers() & Qt::ControlModifier) {
          sts = ctx->event_handler(glow_eEvent_Key_CtrlAscii, 0, 0, buff, 0);
        } else {
          sts = ctx->event_handler(glow_eEvent_Key_Ascii, 0, 0, buff, 0);
        }
      } else {
        switch (keysym) {
        case Qt::Key_Return:
        case Qt::Key_Enter:
          sts = ctx->event_handler(glow_eEvent_Key_Return, 0, 0, 0, 0);
          break;
        case Qt::Key_Up:
          sts = ctx->event_handler(glow_eEvent_Key_Up, 0, 0, 0, 0);
          break;
        case Qt::Key_Down:
          sts = ctx->event_handler(glow_eEvent_Key_Down, 0, 0, 0, 0);
          break;
        case Qt::Key_Right:
          sts = ctx->event_handler(glow_eEvent_Key_Right, 0, 0, 0, 0);
          break;
        case Qt::Key_Left:
          sts = ctx->event_handler(glow_eEvent_Key_Left, 0, 0, 0, 0);
          break;
        case Qt::Key_PageUp:
          sts = ctx->event_handler(glow_eEvent_Key_PageUp, 0, 0, 0, 0);
          break;
        case Qt::Key_PageDown:
          sts = ctx->event_handler(glow_eEvent_Key_PageDown, 0, 0, 0, 0);
          break;
        case Qt::Key_Delete:
        case Qt::Key_Backspace:
          sts = ctx->event_handler(glow_eEvent_Key_BackSpace, 0, 0, 0, 0);
          break;
        case Qt::Key_F1:
          sts = ctx->event_handler(glow_eEvent_Key_PF1, 0, 0, 0, 0);
          break;
        case Qt::Key_F2:
          sts = ctx->event_handler(glow_eEvent_Key_PF2, 0, 0, 0, 0);
          break;
        case Qt::Key_F3:
          sts = ctx->event_handler(glow_eEvent_Key_PF3, 0, 0, 0, 0);
          break;
        case Qt::Key_F4:
          sts = ctx->event_handler(glow_eEvent_Key_PF4, 0, 0, 0, 0);
          break;
        case Qt::Key_Cancel:
        case Qt::Key_Escape:
          sts = ctx->event_handler(glow_eEvent_Key_Escape, 0, 0, 0, 0);
          break;
        case Qt::Key_Tab:
          if (keyEvent->modifiers() & Qt::ShiftModifier) {
            sts = ctx->event_handler(glow_eEvent_Key_ShiftTab, 0, 0, 0, 0);
          } else {
            sts = ctx->event_handler(glow_eEvent_Key_Tab, 0, 0, 0, 0);
          }
          break;
        default:;
        }
      }
      break;
    }
    case QEvent::MouseButtonPress: {
      QMouseEvent* mouseEvent = ((QMouseEvent*)event);
      switch (mouseEvent->button()) {
      case Qt::LeftButton:
        sts = ctx->event_handler(
            glow_eEvent_MB1Down, mouseEvent->x(), mouseEvent->y(), 0, 0);
        if (click_sensitivity & glow_mSensitivity_MB1Click
            && !(click_sensitivity & glow_mSensitivity_MB1DoubleClick)
            && !(click_sensitivity & glow_mSensitivity_MB1Press)) {
          button_pressed = 0;
          button_clicked = 1;
          last_press_x = mouseEvent->x();
          last_press_y = mouseEvent->y();
          return 1;
        } else if (!(click_sensitivity & glow_mSensitivity_MB1Click)
            && !(click_sensitivity & glow_mSensitivity_MB1DoubleClick)
            && click_sensitivity & glow_mSensitivity_MB1Press) {
          button_pressed = 1;
          button_clicked = 0;
          last_press_x = mouseEvent->x();
          last_press_y = mouseEvent->y();
        }
        break;
      case Qt::RightButton:
        sts = ctx->event_handler(
            glow_eEvent_MB3Down, mouseEvent->x(), mouseEvent->y(), 0, 0);
        if (click_sensitivity & glow_mSensitivity_MB3Press
            && !(click_sensitivity & glow_mSensitivity_MB3DoubleClick)
            && !(click_sensitivity & glow_mSensitivity_MB3Click)) {
          sts = ctx->event_handler(
              glow_eEvent_MB3Press, mouseEvent->x(), mouseEvent->y(), 0, 0);
          click_sensitivity = 0;
          return 1;
        } else if (click_sensitivity & glow_mSensitivity_MB3Click
            && !(click_sensitivity & glow_mSensitivity_MB3DoubleClick)
            && !(click_sensitivity & glow_mSensitivity_MB3Press)) {
          button_pressed = 0;
          button_clicked = 1;
          last_press_x = mouseEvent->x();
          last_press_y = mouseEvent->y();
          return 1;
        }
        break;
      default:
        break;
      }

      /* Detect press or click event */
      if (button_clicked) {
        /* Wait for release */
        button_clicked_and_pressed = 1;
        cancel_event_timer();
        button_clicked = 0;
        button_pressed = mouseEvent->button();
        last_press_x = mouseEvent->x();
        last_press_y = mouseEvent->y();
        event_timer(mouseEvent, target);
        return 1;
      }
      if (!button_pressed) {
        button_pressed = mouseEvent->button();
        last_press_x = mouseEvent->x();
        last_press_y = mouseEvent->y();
        event_timer(mouseEvent, target);
        return 1;
      } else {
        /* Press event, callback from timer */
        button_pressed = 0;
        button_clicked_and_pressed = 0;
        switch (mouseEvent->button()) {
        case Qt::LeftButton: // Button 1
          button1_pressed = 1;
          if ((mouseEvent->modifiers() & Qt::ShiftModifier)
              && !(mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = ctx->event_handler(glow_eEvent_MB1PressShift, mouseEvent->x(),
                mouseEvent->y(), 0, 0);
          } else if (!(mouseEvent->modifiers() & Qt::ShiftModifier)
              && (mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = ctx->event_handler(glow_eEvent_MB1PressCtrl, mouseEvent->x(),
                mouseEvent->y(), 0, 0);
          } else if ((mouseEvent->modifiers() & Qt::ShiftModifier)
              && (mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = ctx->event_handler(glow_eEvent_MB1PressShiftCtrl,
                mouseEvent->x(), mouseEvent->y(), 0, 0);
          } else {
            sts = ctx->event_handler(
                glow_eEvent_MB1Press, mouseEvent->x(), mouseEvent->y(), 0, 0);
          }
          click_sensitivity = 0;
          break;
        case Qt::MidButton: // Button2
          button2_pressed = 1;
          if ((mouseEvent->modifiers() & Qt::ShiftModifier)
              && !(mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = ctx->event_handler(glow_eEvent_MB2PressShift, mouseEvent->x(),
                mouseEvent->y(), 0, 0);
          } else if (!(mouseEvent->modifiers() & Qt::ShiftModifier)
              && (mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = ctx->event_handler(glow_eEvent_MB2PressShift, mouseEvent->x(),
                mouseEvent->y(), 0, 0);
          } else if ((mouseEvent->modifiers() & Qt::ShiftModifier)
              && (mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = ctx->event_handler(glow_eEvent_MB2PressShiftCtrl,
                mouseEvent->x(), mouseEvent->y(), 0, 0);
          } else {
            sts = ctx->event_handler(
                glow_eEvent_MB2Press, mouseEvent->x(), mouseEvent->y(), 0, 0);
          }
          click_sensitivity = 0;
          break;
        case Qt::RightButton: // Button3
          button3_pressed = 1;
          sts = ctx->event_handler(
              glow_eEvent_MB3Press, mouseEvent->x(), mouseEvent->y(), 0, 0);
          click_sensitivity = 0;
          break;
        default:
          break;
        }
      }
      break;
    }
    case QEvent::MouseButtonRelease: {
      QMouseEvent* mouseEvent = ((QMouseEvent*)event);
      button1_pressed = 0;
      button2_pressed = 0;
      button3_pressed = 0;

      if (mouseEvent->button() == Qt::LeftButton) {
        sts = ctx->event_handler(
            glow_eEvent_MB1Up, mouseEvent->x(), mouseEvent->y(), 0, 0);
      }

      if (!button_pressed) {
        if (button_clicked) {
          /* Button click, callback from timer */
          button_clicked = 0;
          switch (mouseEvent->button()) {
          case Qt::LeftButton: // Button1
            if ((mouseEvent->modifiers() & Qt::ShiftModifier)
                && !(mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = ctx->event_handler(glow_eEvent_MB1ClickShift,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else if (!(mouseEvent->modifiers() & Qt::ShiftModifier)
                && (mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = ctx->event_handler(glow_eEvent_MB1ClickCtrl,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else if ((mouseEvent->modifiers() & Qt::ShiftModifier)
                && (mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = ctx->event_handler(glow_eEvent_MB1ClickShiftCtrl,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else {
              sts = ctx->event_handler(
                  glow_eEvent_MB1Click, mouseEvent->x(), mouseEvent->y(), 0, 0);
            }

            if (sts == GLOW__TERMINATED || sts == GLOW__DESTROYED) {
              return 1;
            }
            click_sensitivity = 0;
            break;
          case Qt::MidButton: // Button2
            if ((mouseEvent->modifiers() & Qt::ShiftModifier)
                && !(mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = ctx->event_handler(glow_eEvent_MB2ClickShift,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else if (!(mouseEvent->modifiers() & Qt::ShiftModifier)
                && (mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = ctx->event_handler(glow_eEvent_MB2ClickCtrl,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else if ((mouseEvent->modifiers() & Qt::ShiftModifier)
                && (mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = ctx->event_handler(glow_eEvent_MB2ClickShiftCtrl,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else {
              sts = ctx->event_handler(
                  glow_eEvent_MB2Click, mouseEvent->x(), mouseEvent->y(), 0, 0);
            }

            if (sts == GLOW__TERMINATED || sts == GLOW__DESTROYED) {
              return 1;
            }
            click_sensitivity = 0;
            break;
          case Qt::RightButton: // Button3
            sts = ctx->event_handler(
                glow_eEvent_MB3Click, mouseEvent->x(), mouseEvent->y(), 0, 0);

            if (sts == GLOW__TERMINATED || sts == GLOW__DESTROYED) {
              return 1;
            }
            click_sensitivity = 0;
            break;
          default:
            break;
          }
        } else {
          /* Button release */
          sts = ctx->event_handler(glow_eEvent_ButtonRelease, mouseEvent->x(),
              mouseEvent->y(), 0, 0);
          if (sts == GLOW__TERMINATED || sts == GLOW__DESTROYED) {
            return 1;
          }
        }
      } else {
        /* Button click */
        cancel_event_timer();
        if (!button_clicked_and_pressed) {
          /* wait for button double click */
          button_clicked = 1;
          event_timer(mouseEvent, target);
          button_pressed = 0;
          return 1;
        } else {
          /* Button double click */
          cancel_event_timer();
          button_clicked = 0;
          button_pressed = 0;
          button_clicked_and_pressed = 0;
          switch (mouseEvent->button()) {
          case Qt::LeftButton: // Button1
            if ((mouseEvent->modifiers() & Qt::ShiftModifier)
                && !(mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = ctx->event_handler(glow_eEvent_MB1DoubleClickShift,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else if (!(mouseEvent->modifiers() & Qt::ShiftModifier)
                && (mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = ctx->event_handler(glow_eEvent_MB1DoubleClickCtrl,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else if ((mouseEvent->modifiers() & Qt::ShiftModifier)
                && (mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = ctx->event_handler(glow_eEvent_MB1DoubleClickShiftCtrl,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else {
              sts = ctx->event_handler(glow_eEvent_MB1DoubleClick,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            }

            if (sts == GLOW__TERMINATED || sts == GLOW__DESTROYED) {
              return 1;
            }
            click_sensitivity = 0;
            break;
          case Qt::MidButton: // Button2
            if ((mouseEvent->modifiers() & Qt::ShiftModifier)
                && !(mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = ctx->event_handler(glow_eEvent_MB2DoubleClickShift,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else if (!(mouseEvent->modifiers() & Qt::ShiftModifier)
                && (mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = ctx->event_handler(glow_eEvent_MB2DoubleClickCtrl,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else if ((mouseEvent->modifiers() & Qt::ShiftModifier)
                && (mouseEvent->modifiers() & Qt::ControlModifier)) {
              sts = ctx->event_handler(glow_eEvent_MB2DoubleClickShiftCtrl,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            } else {
              sts = ctx->event_handler(glow_eEvent_MB2DoubleClick,
                  mouseEvent->x(), mouseEvent->y(), 0, 0);
            }

            if (sts == GLOW__TERMINATED || sts == GLOW__DESTROYED) {
              return 1;
            }
            click_sensitivity = 0;
            break;
          case Qt::RightButton: // Button3
            click_sensitivity = 0;
            break;
          default:
            break;
          }
        }
      }
      break;
    }
    case QEvent::Paint:
    case QEvent::UpdateRequest: {
      QPaintEvent* paintEvent = ((QPaintEvent*)event);
      ctx->clear(&ctx->mw);
      sts = ctx->event_handler(glow_eEvent_Exposure, paintEvent->rect().x(),
          paintEvent->rect().y(), paintEvent->rect().width(),
          paintEvent->rect().height());
      break;
    }
    case QEvent::WindowUnblocked: {
      sts = ctx->event_handler(glow_eEvent_VisibilityUnobscured, 0, 0, 0, 0);
      break;
    }
    case QEvent::WindowBlocked: {
      sts = ctx->event_handler(glow_eEvent_VisibilityObscured, 0, 0, 0, 0);
      break;
    }
    case QEvent::MouseMove: {
      QMouseEvent* mouseEvent = ((QMouseEvent*)event);
      QPoint pos = mouseEvent->pos();

      if (button3_pressed) {
        button3_pressed = 0;
        button_pressed = 0;
        button_clicked_and_pressed = 0;
      }
      if (button_pressed
          && (ABS(pos.x() - last_press_x) > DRAW_PRESS_PIX
                 || ABS(pos.y() - last_press_y) > DRAW_PRESS_PIX)) {
        pos.setX(last_press_x);
        pos.setY(last_press_y);

        /* Button press */
        cancel_event_timer();
        switch (button_pressed) {
        case Qt::LeftButton: // Button1
          button1_pressed = 1;
          if ((mouseEvent->modifiers() & Qt::ShiftModifier)
              && !(mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = ctx->event_handler(
                glow_eEvent_MB1PressShift, pos.x(), pos.y(), 0, 0);
          } else if (!(mouseEvent->modifiers() & Qt::ShiftModifier)
              && (mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = ctx->event_handler(
                glow_eEvent_MB1PressCtrl, pos.x(), pos.y(), 0, 0);
          } else if ((mouseEvent->modifiers() & Qt::ShiftModifier)
              && (mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = ctx->event_handler(
                glow_eEvent_MB1PressShiftCtrl, pos.x(), pos.y(), 0, 0);
          } else {
            sts = ctx->event_handler(
                glow_eEvent_MB1Press, pos.x(), pos.y(), 0, 0);
          }
          break;
        case Qt::MidButton: // Button2
          button2_pressed = 1;
          if ((mouseEvent->modifiers() & Qt::ShiftModifier)
              && !(mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = ctx->event_handler(
                glow_eEvent_MB2PressShift, pos.x(), pos.y(), 0, 0);
          } else if (!(mouseEvent->modifiers() & Qt::ShiftModifier)
              && (mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = ctx->event_handler(
                glow_eEvent_MB2PressShift, pos.x(), pos.y(), 0, 0);
          } else if ((mouseEvent->modifiers() & Qt::ShiftModifier)
              && (mouseEvent->modifiers() & Qt::ControlModifier)) {
            sts = ctx->event_handler(
                glow_eEvent_MB2PressShiftCtrl, pos.x(), pos.y(), 0, 0);
          } else {
            sts = ctx->event_handler(
                glow_eEvent_MB2Press, pos.x(), pos.y(), 0, 0);
          }
          break;
        case Qt::RightButton: // Button3
          button3_pressed = 1;
          sts = ctx->event_handler(
              glow_eEvent_MB3Press, pos.x(), pos.y(), 0, 0);
          break;
        }
        button_pressed = 0;
        button_clicked_and_pressed = 0;
      }
      if (button1_pressed || button2_pressed || button3_pressed) {
        sts = ctx->event_handler(
            glow_eEvent_ButtonMotion, pos.x(), pos.y(), 0, 0);
      } else {
        sts = ctx->event_handler(
            glow_eEvent_CursorMotion, pos.x(), pos.y(), 0, 0);
      }
      break;
    }
    case QEvent::Enter: {
      QPoint pos = QCursor::pos();
      sts = ctx->event_handler(glow_eEvent_Enter, pos.x(), pos.y(), 0, 0);
      break;
    }
    case QEvent::Leave: {
      QPoint pos = QCursor::pos();
      sts = ctx->event_handler(glow_eEvent_Leave, pos.x(), pos.y(), 0, 0);
      break;
    }
    case QEvent::Show: {
      sts = ctx->event_handler(glow_eEvent_Map, 0, 0, 0, 0);
      break;
    }
    case QEvent::Hide: {
      sts = ctx->event_handler(glow_eEvent_Unmap, 0, 0, 0, 0);
      break;
    }
    case QEvent::FocusIn:
    case QEvent::FocusOut:
      break;
    case QEvent::Wheel: {
      // TODO: the event handler should also take scroll delta as a parameter
      QWheelEvent* wheelEvent = ((QWheelEvent*)event);
      if (wheelEvent->delta() > 0) {
        sts = ctx->event_handler(
            glow_eEvent_ScrollUp, wheelEvent->x(), wheelEvent->y(), 0, 0);
      } else if (wheelEvent->delta() < 0) {
        sts = ctx->event_handler(
            glow_eEvent_ScrollDown, wheelEvent->x(), wheelEvent->y(), 0, 0);
      }
      break;
    }
    default:
      break;
    }
  } else if (target == nav_wind->window) {
    switch (event->type()) {
    case QEvent::MouseButtonPress: {
      QMouseEvent* mouseEvent = ((QMouseEvent*)event);
      switch (mouseEvent->button()) {
      case Qt::LeftButton: // Button1
        button1_pressed = 1;
        ctx->event_handler_nav(
            glow_eEvent_MB1Press, mouseEvent->x(), mouseEvent->y());
        break;
      case Qt::MidButton: // Button2
        button2_pressed = 1;
        ctx->event_handler_nav(
            glow_eEvent_MB2Press, mouseEvent->x(), mouseEvent->y());
        break;
      case Qt::RightButton: // Button3
        button3_pressed = 1;
        break;
      default:
        break;
      }
      break;
    }
    case QEvent::MouseButtonRelease: {
      QMouseEvent* mouseEvent = ((QMouseEvent*)event);
      switch (mouseEvent->button()) {
      case Qt::LeftButton: // Button1
        button1_pressed = 0;
        break;
      case Qt::MidButton: // Button2
        button2_pressed = 0;
        break;
      case Qt::RightButton: // Button3
        button3_pressed = 0;
        break;
      default:
        break;
      }
      sts = ctx->event_handler_nav(
          glow_eEvent_ButtonRelease, mouseEvent->x(), mouseEvent->y());
      break;
    }
    case QEvent::Show: {
      sts = ctx->event_handler_nav(glow_eEvent_Exposure, 0, 0);
      break;
    }
    case QEvent::Paint:
    case QEvent::UpdateRequest: {
      ctx->nav_clear();
      sts = ctx->event_handler_nav(glow_eEvent_Exposure, 0, 0);
      nav_wind->window->update();
      break;
    }
    case QEvent::MouseMove: {
      QMouseEvent* mouseEvent = ((QMouseEvent*)event);
      if (button1_pressed || button2_pressed || button3_pressed) {
        sts = ctx->event_handler_nav(
            glow_eEvent_ButtonMotion, mouseEvent->x(), mouseEvent->y());
      } else {
        sts = ctx->event_handler_nav(
            glow_eEvent_CursorMotion, mouseEvent->x(), mouseEvent->y());
      }
      break;
    }
    default:
      break;
    }
  }
  if (sts == GLOW__TERMINATED || sts == GLOW__DESTROYED) {
    return 1;
  }

  m_wind->window->update();
  return 1;
}

void GlowDrawQt::enable_event(glow_eEvent event, glow_eEventType event_type,
    int (*event_cb)(GlowCtx* ctx, glow_tEvent event))
{
  ctx->enable_event(event, event_type, event_cb);
}

int GlowDrawQt::rect_helper(GlowWind* wind, int painter_type, int size, int x,
    int y, int width, int height, bool fill)
{
  if (ctx->nodraw) {
    return 1;
  }
  DrawWindQt* w = (DrawWindQt*)wind->window;

  unique_ptr<QPainter> painter = get_painter(w->buffer, this, painter_type, size);

  if (w->clip_on) {
    set_clip(w, painter);
  }

  if (fill) {
    painter->fillRect(x, y, width, height, painter->brush());
  } else {
    painter->setBrush(Qt::NoBrush);
    painter->drawRect(x, y, width, height);
  }

  return 1;
}

int GlowDrawQt::rect(GlowWind* wind, int x, int y, int width, int height,
    glow_eDrawType painter_type, int idx, int highlight)
{
  if (painter_type == glow_eDrawType_LineGray && highlight) {
    painter_type = glow_eDrawType_Line;
  }

  return rect_helper(wind, painter_type + highlight, idx, x, y, width, height);
}

int GlowDrawQt::rect_erase(
    GlowWind* wind, int x, int y, int width, int height, int idx)
{
  return rect_helper(wind, glow_eDrawType_LineErase, idx, x, y, width, height);
}

int GlowDrawQt::arrow_helper(GlowWind* wind, int painter_type, int size, int x1,
    int y1, int x2, int y2, int x3, int y3)
{
  if (ctx->nodraw) {
    return 1;
  }
  DrawWindQt* w = (DrawWindQt*)wind->window;

  QPolygon poly(4);
  poly[0] = QPoint(x1, y1);
  poly[1] = QPoint(x2, y2);
  poly[2] = QPoint(x3, y3);
  poly[3] = QPoint(x1, y1);

  unique_ptr<QPainter> painter = get_painter(w->buffer, this, painter_type, size);

  if (w->clip_on) {
    set_clip(w, painter);
  }

  QPainterPath path;
  path.addPolygon(poly);
  painter->fillPath(path, painter->brush());

  return 1;
}

int GlowDrawQt::arrow(GlowWind* wind, int x1, int y1, int x2, int y2, int x3,
    int y3, glow_eDrawType painter_type, int idx, int highlight)
{
  if (painter_type == glow_eDrawType_LineGray && highlight) {
    painter_type = glow_eDrawType_Line;
  }

  return arrow_helper(
      wind, painter_type + highlight, idx, x1, y1, x2, y2, x3, y3);
}

int GlowDrawQt::arrow_erase(
    GlowWind* wind, int x1, int y1, int x2, int y2, int x3, int y3, int idx)
{
  return arrow_helper(
      wind, glow_eDrawType_LineErase, idx, x1, y1, x2, y2, x3, y3);
}

int GlowDrawQt::arc_helper(GlowWind* wind, int painter_type, int size, int x,
    int y, int width, int height, int angle1, int angle2, bool fill)
{
  if (ctx->nodraw) {
    return 1;
  }
  DrawWindQt* w = (DrawWindQt*)wind->window;

  if (!fill) {
    if (w->clip_on
        && !(w->clip_rectangle[w->clip_cnt - 1].x() <= x + width
               && w->clip_rectangle[w->clip_cnt - 1].x()
                       + w->clip_rectangle[w->clip_cnt - 1].width()
                   >= x
               && w->clip_rectangle[w->clip_cnt - 1].y() <= y + height
               && w->clip_rectangle[w->clip_cnt - 1].y()
                       + w->clip_rectangle[w->clip_cnt - 1].height()
                   >= y)) {
      return 1;
    }
  }

  unique_ptr<QPainter> painter = get_painter(w->buffer, this, painter_type, size);

  if (w->clip_on) {
    set_clip(w, painter);
  }

  if (fill) {
    painter->drawPie(x, y, width, height, angle1 * 16, angle2 * 16);
  } else {
    painter->setBrush(Qt::NoBrush);
    painter->drawArc(x, y, width, height, angle1 * 16, angle2 * 16);
  }

  return 1;
}

int GlowDrawQt::arc(GlowWind* wind, int x, int y, int width, int height,
    int angle1, int angle2, glow_eDrawType painter_type, int idx, int highlight)
{
  if (painter_type == glow_eDrawType_LineGray && highlight) {
    painter_type = glow_eDrawType_Line;
  }

  // Fix for highlight for connections in grow
  if (highlight && ctx->type() == glow_eCtxType_Grow) {
    painter_type = glow_eDrawType_LineHighlight;
  }

  if (angle1 >= 360) {
    angle1 = angle1 - angle1 / 360 * 360;
  } else if (angle1 < 0) {
    angle1 = angle1 + (-angle1 / 360 + 1) * 360;
  }

  return arc_helper(
      wind, painter_type + highlight, idx, x, y, width, height, angle1, angle2);
}

int GlowDrawQt::fill_arc(GlowWind* wind, int x, int y, int width, int height,
    int angle1, int angle2, glow_eDrawType painter_type, int highlight)
{
  if (painter_type == glow_eDrawType_LineGray && highlight) {
    painter_type = glow_eDrawType_LineRed;
  }

  if (angle1 >= 360) {
    angle1 = angle1 - angle1 / 360 * 360;
  } else if (angle1 < 0) {
    angle1 = angle1 + (-angle1 / 360 + 1) * 360;
  }

  return arc_helper(wind, painter_type + highlight, 0, x, y, width, height,
      angle1, angle2, true);
}

int GlowDrawQt::arc_erase(GlowWind* wind, int x, int y, int width, int height,
    int angle1, int angle2, int idx)
{
  if (angle1 >= 360) {
    angle1 = angle1 - angle1 / 360 * 360;
  } else if (angle1 < 0) {
    angle1 = angle1 + (-angle1 / 360 + 1) * 360;
  }

  return arc_helper(
      wind, glow_eDrawType_LineErase, idx, x, y, width, height, angle1, angle2);
}

int GlowDrawQt::line_helper(GlowWind* wind, int painter_type, int size, int x1,
    int y1, int x2, int y2, glow_eLineType line_type)
{
  if (ctx->nodraw) {
    return 1;
  }
  DrawWindQt* w = (DrawWindQt*)wind->window;

  if (w->clip_on
      && !(w->clip_rectangle[w->clip_cnt - 1].x() <= MAX(x1, x2)
             && w->clip_rectangle[w->clip_cnt - 1].x()
                     + w->clip_rectangle[w->clip_cnt - 1].width()
                 >= MIN(x1, x2)
             && w->clip_rectangle[w->clip_cnt - 1].y() <= MAX(y1, y2)
             && w->clip_rectangle[w->clip_cnt - 1].y()
                     + w->clip_rectangle[w->clip_cnt - 1].height()
                 >= MIN(y1, y2))) {
    return 1;
  }

  unique_ptr<QPainter> painter = get_painter(w->buffer, this, painter_type, size);

  if (w->clip_on) {
    set_clip(w, painter);
  }

  if (line_type != glow_eLineType_Solid) {
    QPen pen = painter->pen();
    pen.setWidth(size + 1);
    pen.setStyle(Qt::DashLine);
    pen.setJoinStyle(Qt::MiterJoin);
    painter->setPen(pen);
    QVector<double> dashes;
    switch (line_type) {
    case glow_eLineType_Dashed1: {
      dashes << 1 + size << 1 + size;
      break;
    }
    case glow_eLineType_Dashed2: {
      dashes << 1 + 2 * size << 1 + 2 * size;
      break;
    }
    case glow_eLineType_Dashed3: {
      dashes << 1 + 3 * size << 1 + 3 * size;
      break;
    }
    case glow_eLineType_Dotted: {
      dashes << 1 + size << 1 + size;
      dashes << 1 + 4 * size << 1 + 4 * size;
      break;
    }
    case glow_eLineType_DotDashed1: {
      dashes << 1 + 3 * size << 1 + 3 * size;
      dashes << 1 + 2 * size << 1 + 2 * size;
      dashes << 1 + size << 1 + size;
      dashes << 1 + 2 * size << 1 + 2 * size;
      break;
    }
    case glow_eLineType_DotDashed2: {
      dashes << 1 + 6 * size << 1 + 6 * size;
      dashes << 1 + 3 * size << 1 + 3 * size;
      dashes << 1 + size << 1 + size;
      dashes << 1 + 3 * size << 1 + 3 * size;
      break;
    }
    default:;
    }
    pen.setDashPattern(dashes);
    painter->setPen(pen);
  }

  painter->drawLine(x1, y1, x2, y2);

  return 1;
}

int GlowDrawQt::line(GlowWind* wind, int x1, int y1, int x2, int y2,
    glow_eDrawType painter_type, int idx, int highlight)
{
  // Fix for highlight for connections in grow
  if (highlight && ctx->type() == glow_eCtxType_Grow) {
    painter_type = glow_eDrawType_LineHighlight;
  }

  if (painter_type == glow_eDrawType_LineGray && highlight) {
    painter_type = glow_eDrawType_Line;
  }

  return line_helper(wind, painter_type + highlight, idx, x1, y1, x2, y2);
}

int GlowDrawQt::line_dashed(GlowWind* wind, int x1, int y1, int x2, int y2,
    glow_eDrawType painter_type, int idx, int highlight,
    glow_eLineType line_type)
{
  // Fix for highlight for connections in grow
  if (highlight && ctx->type() == glow_eCtxType_Grow) {
    painter_type = glow_eDrawType_LineHighlight;
  }

  if (painter_type == glow_eDrawType_LineGray && highlight) {
    painter_type = glow_eDrawType_Line;
  }

  return line_helper(
      wind, painter_type + highlight, idx, x1, y1, x2, y2, line_type);
}

int GlowDrawQt::line_erase(
    GlowWind* wind, int x1, int y1, int x2, int y2, int idx)
{
  return line_helper(wind, glow_eDrawType_LineErase, idx, x1, y1, x2, y2);
}

int GlowDrawQt::polyline_helper(GlowWind* wind, int painter_type, int size,
    glow_sPointX* points, int point_cnt, bool fill)
{
  if (ctx->nodraw) {
    return 1;
  }
  DrawWindQt* w = (DrawWindQt*)wind->window;

  unique_ptr<QPainter> painter = get_painter(w->buffer, this, painter_type, size);

  if (w->clip_on) {
    set_clip(w, painter);
  }

  if (fill) {
    unique_ptr<QPoint[]> qpoints = points_to_qt_points(points, point_cnt);
    painter->drawPolygon(qpoints.get(), point_cnt);
  } else {
    int cnt;
    unique_ptr<QPoint[]> qpoints = points_to_qt_points_curve(wind, points, point_cnt, &cnt);
    painter->setBrush(Qt::NoBrush);
    painter->drawPolyline(qpoints.get(), cnt);
  }

  return 1;
}

int GlowDrawQt::polyline(GlowWind* wind, glow_sPointX* points, int point_cnt,
    glow_eDrawType painter_type, int idx, int highlight)
{
  if (painter_type == glow_eDrawType_LineGray && highlight) {
    painter_type = glow_eDrawType_Line;
  }

  return polyline_helper(
      wind, painter_type + highlight, idx, points, point_cnt);
}

int GlowDrawQt::fill_polyline(GlowWind* wind, glow_sPointX* points,
    int point_cnt, glow_eDrawType painter_type, int highlight)
{
  if (painter_type == glow_eDrawType_LineGray && highlight) {
    painter_type = glow_eDrawType_Line;
  }

  return polyline_helper(
      wind, painter_type + highlight, 0, points, point_cnt, true);
}

int GlowDrawQt::polyline_erase(
    GlowWind* wind, glow_sPointX* points, int point_cnt, int idx)
{
  return polyline_helper(
      wind, glow_eDrawType_LineErase, idx, points, point_cnt);
}

int GlowDrawQt::text(GlowWind* wind, int x, int y, char* text, int len,
    glow_eDrawType painter_type, glow_eDrawType color, int idx, int highlight,
    int line, glow_eFont font_idx, double size, int rot)
{
  if (ctx->nodraw) {
    return 1;
  }
  DrawWindQt* w = (DrawWindQt*)wind->window;

  if (!((GrowCtx*)ctx)->bitmap_fonts) {
    return text_qt(wind, x, y, text, len, painter_type, color, idx, highlight,
        line, font_idx, size, rot);
  }

  if (font_idx > glow_eFont_Courier) {
    font_idx = glow_eFont_Helvetica;
  }

  unique_ptr<QPainter> painter = get_painter(w->buffer, this, painter_type, idx);

  if (w->clip_on) {
    set_clip(w, painter);
  }

  if (font_idx != glow_eFont_Helvetica) {
    painter->setFont(get_font(font_idx, painter_type, idx));
  }

  if (color != glow_eDrawType_Line) {
    painter->setBrush(QBrush(draw_type_to_color(this, color, idx)));
    painter->setPen(QPen(painter->brush(), size + 1));
  }

  QRect rect
      = painter->fontMetrics().boundingRect(QString::fromLocal8Bit(text, len));
  painter->drawText(x, y, rect.width(), rect.height(), Qt::TextDontClip,
      QString::fromLocal8Bit(text, len));

  return 1;
}

int GlowDrawQt::text_cursor(GlowWind* wind, int x, int y, char* text, int len,
    glow_eDrawType painter_type, glow_eDrawType color, int idx, int highlight,
    int pos, glow_eFont font, double size)
{
  if (ctx->nodraw) {
    return 1;
  }
  DrawWindQt* w = (DrawWindQt*)wind->window;

  int theight, tdescent, width, height, descent;
  get_text_extent(
      "A", 1, painter_type, idx, font, &width, &height, &descent, size, 0);
  if (pos != 0) {
    get_text_extent(text, pos, painter_type, idx, font, &width, &theight,
        &tdescent, size, 0);
  } else {
    width = 0;
  }

  unique_ptr<QPainter> painter = get_painter(w->buffer, this, color, 1);

  if (w->clip_on) {
    set_clip(w, painter);
  }

  painter->drawLine(x + width, y + descent, x + width, y - height + descent);

  return 1;
}

int GlowDrawQt::text_erase(GlowWind* wind, int x, int y, char* text, int len,
    glow_eDrawType painter_type, int idx, int line, glow_eFont font_idx,
    double size, int rot)
{
  if (ctx->nodraw) {
    return 1;
  }
  DrawWindQt* w = (DrawWindQt*)wind->window;

  if (!((GrowCtx*)ctx)->bitmap_fonts) {
    return text_erase_qt(
        wind, x, y, text, len, painter_type, idx, line, font_idx, size, rot);
  }

  if (font_idx > glow_eFont_Courier) {
    font_idx = glow_eFont_Helvetica;
  }

  if (painter_type == glow_eDrawType_TextHelvetica) {
    painter_type = glow_eDrawType_TextHelveticaErase;
  } else if (painter_type == glow_eDrawType_TextHelveticaBold) {
    painter_type = glow_eDrawType_TextHelveticaEraseBold;
  }

  unique_ptr<QPainter> painter = get_painter(w->buffer, this, painter_type, idx);

  if (font_idx != glow_eFont_Helvetica) {
    painter->setFont(get_font(font_idx, painter_type, idx));
  }

  if (w->clip_on) {
    set_clip(w, painter);
  }

  QRect rect
      = painter->fontMetrics().boundingRect(QString::fromLocal8Bit(text, len));
  painter->drawText(x, y, rect.width(), rect.height(), Qt::TextDontClip,
      QString::fromLocal8Bit(text, len));

  return 1;
}

int GlowDrawQt::pixmaps_create(
    GlowWind* wind, glow_sPixmapData* pixmap_data, void** pixmaps)
{
  return 1;
}

void GlowDrawQt::pixmaps_delete(GlowWind* wind, void* pixmaps)
{
}

int GlowDrawQt::pixmap(GlowWind* wind, int x, int y,
    glow_sPixmapData* pixmap_data, void* pixmaps, glow_eDrawType painter_type,
    int idx, int highlight, int line)
{
  return 1;
}

int GlowDrawQt::pixmap_inverse(GlowWind* wind, int x, int y,
    glow_sPixmapData* pixmap_data, void* pixmaps, glow_eDrawType painter_type,
    int idx, int line)
{
  return 1;
}

int GlowDrawQt::pixmap_erase(GlowWind* wind, int x, int y,
    glow_sPixmapData* pixmap_data, void* pixmaps, glow_eDrawType painter_type,
    int idx, int line)
{
  return 1;
}

int GlowDrawQt::image_helper(GlowWind* wind, int x, int y, int width,
    int height, glow_tImImage image, glow_tPixmap clip_mask, bool d)
{
  DrawWindQt* w = (DrawWindQt*)wind->window;
  if (ctx->nodraw) {
    return 1;
  }

  if (width == 0 || height == 0) {
    return 1;
  }

  unique_ptr<QPainter> painter = get_painter(w->buffer, this, glow_eDrawType_Line, 0);

  if (clip_mask) {
    set_image_clip_mask(painter, clip_mask, x, y);
  } else if (w->clip_on) {
    set_clip(w, painter);
  }

  if (d) {
    painter->drawImage(QPoint(x, y), *((QImage*)image));
  } else {
    painter->drawImage(QRect(x, y, width, height), *((QImage*)image));
  }

  return 1;
}

int GlowDrawQt::image(GlowWind* wind, int x, int y, int width, int height,
    glow_tImImage image, glow_tPixmap pixmap, glow_tPixmap clip_mask)
{
  return image_helper(wind, x, y, width, height, image, clip_mask);
}

int GlowDrawQt::image_d(GlowWind* wind, double x, double y, int width,
    int height, glow_tImImage image, glow_tPixmap pixmap,
    glow_tPixmap clip_mask)
{
  return image_helper(wind, x, y, width, height, image, clip_mask, true);
}

int GlowDrawQt::fill_rect(GlowWind* wind, int x, int y, int width, int height,
    glow_eDrawType painter_type)
{
  return rect_helper(wind, painter_type, 0, x, y, width, height, true);
}

void GlowDrawQt::clear(GlowWind* wind)
{
  if (ctx->nodraw) {
    return;
  }
  DrawWindQt* w = (DrawWindQt*)wind->window;

  buffer_background(w, 0);
}

void GlowDrawQt::copy_buffer(
    GlowWind* wind, int ll_x, int ll_y, int ur_x, int ur_y)
{
  if (ctx->nodraw) {
    return;
  }
  DrawWindQt* w = (DrawWindQt*)wind->window;

  int x0 = MIN(ll_x, ur_x);
  int x1 = MAX(ll_x, ur_x);
  int y0 = MIN(ll_y, ur_y);
  int y1 = MAX(ll_y, ur_y);

  if (w->clip_cnt) {
    x0 = MAX(x0, w->clip_rectangle[w->clip_cnt - 1].x());
    y0 = MAX(y0, w->clip_rectangle[w->clip_cnt - 1].y());
    x1 = MIN(x1, w->clip_rectangle[w->clip_cnt - 1].x()
            + w->clip_rectangle[w->clip_cnt - 1].width());
    y1 = MIN(y1, w->clip_rectangle[w->clip_cnt - 1].y()
            + w->clip_rectangle[w->clip_cnt - 1].height());
  }

  unique_ptr<QPainter> painter = get_painter(w->buffer, this, glow_eDrawType_Line, 0);

  painter->drawImage(x0, y0, *(w->buffer), x0, y0, x1 - x0, y1 - y0);
}

void GlowDrawQt::get_window_size(GlowWind* wind, int* width, int* height)
{
  DrawWindQt* w = (DrawWindQt*)wind->window;
  QSize size = w->buffer->size();
  *width = size.width();
  *height = size.height();
}

void GlowDrawQt::set_window_size(GlowWind* wind, int width, int height)
{
  DrawWindQt* w = (DrawWindQt*)wind->window;

  if (!w->window) {
    return;
  }

  w->window->resize(width, height);
}

bool GlowDrawQt::draw_timer_cb()
{
  GlowDrawQt* draw_ctx = (GlowDrawQt*)timer_cb->ctx->gdraw;

  (timer_cb->callback_func)(timer_cb->ctx);

  draw_ctx->m_wind->window->update();
  delete timer_cb->timer_id;
  delete timer_cb;
  return FALSE;
}

bool GlowDrawQt::event_timer_cb()
{
  timer_id->stop();
  event_handler(last_event, last_target);
  return FALSE;
}

void GlowDrawQt::cancel_event_timer()
{
  if (timer_id) {
    timer_id->stop();
  }
}

void GlowDrawQt::event_timer(QMouseEvent* event, QWidget *target)
{
  if (last_event) {
    delete last_event;
  }
  last_event = new QMouseEvent(event->type(), event->pos(), event->globalPos(),
      event->button(), event->buttons(), event->modifiers());
  last_target = target;

  initOneShotTimer(timer_id, SLOT(event_timer_cb()), 200);
}

void GlowDrawQt::set_timer(GlowCtx* paintertx, int time_ms,
    void (*callback_func)(GlowCtx* ctx), void** id)
{
  timer_cb = new glow_draw_sTimerCb();
  timer_cb->ctx = paintertx;
  timer_cb->callback_func = callback_func;
  timer_cb->timer_id = new QTimer(this);

  initOneShotTimer(timer_cb->timer_id, SLOT(draw_timer_cb()), time_ms);

  *id = (void*)timer_cb;
}

void GlowDrawQt::remove_timer(void* id)
{
  delete (((glow_draw_sTimerCb*)id)->timer_id);

  delete ((char*)id);
}

void GlowDrawQt::set_cursor(GlowWind* wind, glow_eDrawCursor cursor)
{
  DrawWindQt* w = (DrawWindQt*)wind->window;
  if (!w->window) {
    return;
  }

  if (cursor == glow_eDrawCursor_Normal) {
    w->window->unsetCursor();
  } else {
    switch (cursor) {
    case glow_eDrawCursor_CrossHair:
      w->window->setCursor(QCursor(Qt::CrossCursor));
      break;
    case glow_eDrawCursor_DiamondCross:
      w->window->setCursor(QCursor(Qt::SizeAllCursor));
      break;
    case glow_eDrawCursor_Hand:
      w->window->setCursor(QCursor(Qt::PointingHandCursor));
      break;
    case glow_eDrawCursor_BottomLeftCorner:
    case glow_eDrawCursor_TopRightCorner:
      w->window->setCursor(QCursor(Qt::SizeBDiagCursor));
      break;
    case glow_eDrawCursor_BottomRightCorner:
    case glow_eDrawCursor_TopLeftCorner:
      w->window->setCursor(QCursor(Qt::SizeFDiagCursor));
      break;
    case glow_eDrawCursor_BottomSide:
    case glow_eDrawCursor_TopSide:
      w->window->setCursor(QCursor(Qt::SizeVerCursor));
      break;
    case glow_eDrawCursor_RightSide:
    case glow_eDrawCursor_LeftSide:
      w->window->setCursor(QCursor(Qt::SizeHorCursor));
      break;
    default:
      break;
    }
  }
}

int GlowDrawQt::get_text_extent(const char* text, int len,
    glow_eDrawType painter_type, int idx, glow_eFont font_idx, int* width,
    int* height, int* descent, double size, int rot)
{
  if (!((GrowCtx*)ctx)->bitmap_fonts) {
    return get_text_extent_qt(text, len, painter_type, idx, font_idx, width,
        height, descent, size, rot);
  }

  if (font_idx > glow_eFont_Courier) {
    font_idx = glow_eFont_Helvetica;
  }

  QFont font = get_font(font_idx, painter_type, idx);

  QFontMetrics fontMetrics = QFontMetrics(font);
  QRect rect = fontMetrics.boundingRect(QString::fromLocal8Bit(text, len));
  *width = rect.width();
  int text_ascent = fontMetrics.ascent();

  text_ascent = int(1.2 * text_ascent);
  *height = int(1.3 * text_ascent);
  *descent = int(0.3 * text_ascent);
  return 1;
}

void GlowDrawQt::set_inputfocus(GlowWind* wind)
{
  DrawWindQt* w = (DrawWindQt*)wind->window;
  w->window->setFocus(Qt::OtherFocusReason);
}

static unique_ptr<QColor[]> glow_read_color_file(
    const char* filename, int* size, int* sts)
{
  char line[80];
  std::ifstream fp;
  int nr;
  int line_cnt;
  float f_red, f_green, f_blue;

  unique_ptr<QColor[]> color_array(new QColor[300]);

  if (!check_file(filename)) {
    *sts = 0;
    return color_array;
  } else {
    printf("** Opening color file %s\n", filename);

    fp.open(filename);
    if (!fp) {
      *sts = GLOW__FILEOPEN;
      return color_array;
    }

    *size = 0;
    line_cnt = 0;
    while (*size < 300) {
      fp.getline(line, sizeof(line));
      if (line[0] == 0) {
        break;
      }
      line_cnt++;
      if (line[0] == '!' || line[0] == '#') {
        continue;
      }
      nr = sscanf(line, "%f %f %f", &f_red, &f_green, &f_blue);
      if (nr != 3) {
        printf("** Syntax error in file %s, line %d", filename, line_cnt);
      } else {
        color_array[*size].setRgb(
            int(f_red * 255), int(f_green * 255), int(f_blue * 255));
        (*size)++;
      }
    }
    fp.close();
  }

  *sts = 1;
  return color_array;
}

void GlowDrawQt::set_background(GlowWind* wind, glow_eDrawType drawtype,
    glow_tPixmap pixmap, glow_tImImage image, int pixmap_width,
    int pixmap_height)
{
  DrawWindQt* w = (DrawWindQt*)wind->window;
  double r, g, b;

  if (drawtype == glow_eDrawType_LineErase) {
    drawtype = glow_eDrawType_Color32;
  }

  GlowColor::rgb_color((int)drawtype, &r, &g, &b, get_customcolors());
  background
      = glow_allocate_color(this, int(r * 255), int(g * 255), int(b * 255));

  if (!image) {
    QPalette pal;
    pal.setBrush(QPalette::Background, background);
    w->window->setPalette(pal);

    if (w->buffer) {
      buffer_background(w, 0);
    }
  } else {
    if (w->background_pixmap) {
      delete w->background_pixmap;
    }

    w->background_pixmap = new QPixmap(QPixmap::fromImage(*((QImage*)image)));
    w->background_pixmap_width = pixmap_width;
    w->background_pixmap_height = pixmap_height;
    QPalette pal;
    pal.setBrush(QPalette::Background,
        w->background_pixmap->scaled(w->buffer->size(), Qt::IgnoreAspectRatio));
    w->window->setPalette(pal);
    if (w->buffer) {
      buffer_background(w, 0);
    }
  }
}

void GlowDrawQt::reset_background(GlowWind* wind)
{
  background = original_background;

  QPalette pal;
  pal.setBrush(QPalette::Background, background);
  m_wind->window->setPalette(pal);
}

void GlowDrawQt::set_clip(DrawWind* wind, unique_ptr<QPainter>& painter)
{
  DrawWindQt* w = (DrawWindQt*)wind;
  painter->setClipRect(w->clip_rectangle[w->clip_cnt - 1]);
  painter->setClipping(true);
}

void GlowDrawQt::set_image_clip_mask(
    unique_ptr<QPainter>& painter, glow_tPixmap pixmap, int x, int y)
{
  QRegion clipRegion
      = QRegion(((QPixmap*)pixmap)->createMaskFromColor(Qt::black));
  painter->setClipRegion(clipRegion.translated(x, y));
  painter->setClipping(true);
}

int GlowDrawQt::set_clip_rectangle(
    GlowWind* wind, int ll_x, int ll_y, int ur_x, int ur_y)
{
  DrawWindQt* w = (DrawWindQt*)wind->window;
  if (w->clip_cnt >= DRAW_CLIP_SIZE) {
    printf("** Draw clip refused\n");
    return 0;
  }
  int x0, x1, y0, y1;
  if (w->clip_cnt == 0) {
    x0 = MIN(ll_x, ur_x);
    x1 = MAX(ll_x, ur_x);
    y0 = MIN(ll_y, ur_y);
    y1 = MAX(ll_y, ur_y);
  } else {
    x0 = MIN(ll_x, ur_x);
    x1 = MAX(ll_x, ur_x);
    y0 = MIN(ll_y, ur_y);
    y1 = MAX(ll_y, ur_y);

    x0 = MAX(x0, w->clip_rectangle[w->clip_cnt - 1].x());
    x1 = MIN(x1, w->clip_rectangle[w->clip_cnt - 1].x()
            + w->clip_rectangle[w->clip_cnt - 1].width());
    y0 = MAX(y0, w->clip_rectangle[w->clip_cnt - 1].y());
    y1 = MIN(y1, w->clip_rectangle[w->clip_cnt - 1].y()
            + w->clip_rectangle[w->clip_cnt - 1].height());
    if (x0 > x1) {
      x0 = x1;
    }
    if (y0 > y1) {
      y0 = y1;
    }
  }
  w->clip_rectangle[w->clip_cnt].setX(x0);
  w->clip_rectangle[w->clip_cnt].setY(y0);
  w->clip_rectangle[w->clip_cnt].setWidth(x1 - x0);
  w->clip_rectangle[w->clip_cnt].setHeight(y1 - y0);
  w->clip_cnt++;
  w->clip_on = 1;
  return 1;
}

void GlowDrawQt::reset_clip_rectangle(GlowWind* wind)
{
  DrawWindQt* w = (DrawWindQt*)wind->window;
  if (w->clip_cnt == 0) {
    printf("** Draw clip mismatch\n");
    return;
  }
  w->clip_cnt--;
  if (w->clip_cnt == 0) {
    w->clip_on = 0;
  }
}

int GlowDrawQt::clip_level(GlowWind* wind)
{
  DrawWindQt* w = (DrawWindQt*)wind->window;
  return w->clip_cnt;
}

int GlowDrawQt::draw_point(
    GlowWind* wind, int x1, int y1, glow_eDrawType painter_type)
{
  DrawWindQt* w = (DrawWindQt*)wind->window;
  if (ctx->nodraw) {
    return 1;
  }

  unique_ptr<QPainter> painter = get_painter(w->buffer, this, painter_type, 0);

  if (w->clip_on) {
    set_clip(w, painter);
  }

  painter->drawPoint(x1, y1);

  return 1;
}

int GlowDrawQt::draw_points(GlowWind* wind, glow_sPointX* points, int point_num,
    glow_eDrawType painter_type, int idx)
{
  if (ctx->nodraw) {
    return 1;
  }
  DrawWindQt* w = (DrawWindQt*)wind->window;

  unique_ptr<QPoint[]> qpoints = points_to_qt_points(points, point_num);
  unique_ptr<QPainter> painter = get_painter(w->buffer, this, painter_type, 0);

  if (w->clip_on) {
    set_clip(w, painter);
  }

  if (idx > 0) {
    for (int i = 0; i < point_num; i++) {
      painter->fillRect(points[i].x - idx / 2, points[i].y - idx / 2, idx, idx,
          painter->brush());
    }
  } else {
    painter->drawPoints(qpoints.get(), point_num);
  }

  return 1;
}

void GlowDrawQt::set_click_sensitivity(GlowWind* wind, int value)
{
  click_sensitivity = value;
}

void GlowDrawQt::draw_background(GlowWind* wind, int x, int y, int w, int h)
{
  DrawWindQt* ww = (DrawWindQt*)wind->window;
  QPainter(ww->window).eraseRect(x, y, w, h);
}

int GlowDrawQt::create_buffer(GlowWind* wind)
{
  DrawWindQt* w = (DrawWindQt*)wind->window;
  int window_width, window_height;

  if (!w->is_nav) {
    window_width = ctx->mw.window_width;
    window_height = ctx->mw.window_height;
  } else {
    window_width = ctx->navw.window_width;
    window_height = ctx->navw.window_height;
  }

  buffer_background(w, 0);
  return 1;
}

void GlowDrawQt::delete_buffer(GlowWind* wind)
{
}

void GlowDrawQt::buffer_background(DrawWind* wind, GlowCtx* cctx)
{
  DrawWindQt* w = (DrawWindQt*)wind;
  int window_width, window_height, subwindow_x, subwindow_y;

  if (ctx->mw.window == wind) {
    window_width = ctx->mw.window_width;
    window_height = ctx->mw.window_height;
    subwindow_x = ctx->mw.subwindow_x;
    subwindow_y = ctx->mw.subwindow_y;
  } else {
    window_width = ctx->navw.window_width;
    window_height = ctx->navw.window_height;
    subwindow_x = ctx->navw.subwindow_x;
    subwindow_y = ctx->navw.subwindow_y;
  }

  if (!window_width) {
    return;
  }

  if (w->background_pixmap) {
    unique_ptr<QPainter> painterBg
        = get_painter(w->background_pixmap, this, glow_eDrawType_Line, 0);

    if (w->clip_on) {
      set_clip(w, painterBg);
    }

    if (!((GrowCtx*)ctx)->background_tiled) {
      painterBg->drawImage(0, 0, *(w->buffer));
    } else {
      int i, j;
      for (i = 0; i <= w->buffer->width() / w->background_pixmap_width; i++) {
        for (j = 0; j <= w->buffer->height() / w->background_pixmap_height;
             j++) {
          painterBg->drawImage(i * w->background_pixmap_width,
              j * w->background_pixmap_height, *(w->buffer), 0, 0,
              w->background_pixmap_width, w->background_pixmap_height);
        }
      }
    }
  } else {
    glow_eDrawType bg;
    if (cctx) {
      bg = ((GrowCtx*)cctx)->background_color;
    } else {
      bg = ((GrowCtx*)ctx)->background_color;
    }

    unique_ptr<QPainter> painter = get_painter(w->buffer, this, bg, 0);

    if (w->clip_on) {
      set_clip(w, painter);
    }

    painter->fillRect(subwindow_x, subwindow_y, window_width, window_height,
        painter->brush());
  }
}

int GlowDrawQt::export_image(char* filename)
{
  DrawWindQt* w = m_wind;
  QImage* image = w->buffer;
  if (image->isNull()) {
    return 0;
  }

  bool sts = image->save(filename, "PNG", 0);
  if (sts) {
    return 0;
  }

  return 1;
}

int GlowDrawQt::print(char* filename, double x0, double x1, int end)
{
#define ps_cPageHeight 820
#define ps_cPageWidth 535
#define ps_cLeftMargin 100
#define ps_cTopMargin 100

  DrawWindQt* w = m_wind;
  int width, height;
  int i, j, k;
  int grey;
  int red, blue, green;
  double scalex = 0.71;
  double scaley = 0.78;
  double x, y;
  bool colorimage = true;
  static DrawPs* ps = 0;
  bool new_file = false;

  x = ps_cLeftMargin;
  y = ps_cPageHeight - ps_cTopMargin;

  QImage* image = w->buffer;
  if (image->isNull()) {
    return 0;
  }

  if (!ps) {
    ps = new DrawPs(filename);
    new_file = true;
    ps->y = y;
  } else {
    y = ps->y;
  }

  width = image->width();
  height = image->height();

  if (!feq(x0, 0.0) || !feq(x1, 0.0)) {
    double total_width = width / (x1 - x0);

    if (total_width * scalex > ps_cPageWidth - ps_cLeftMargin) {
      x = ps_cPageWidth - total_width * scalex;
      if (x < 50) {
        double scale_factor = (ps_cPageWidth - 50) / (total_width * scalex);
        x = 50;
        scalex = scalex * scale_factor;
        scaley = scaley * scale_factor;
      }
    }
    x += scalex * total_width * x0;
  } else if (width * scalex > ps_cPageWidth - ps_cLeftMargin) {
    x = ps_cPageWidth - width * scalex;
    if (x < 50) {
      double scale_factor = (ps_cPageWidth - 50) / (width * scalex);
      x = 50;
      scalex = scalex * scale_factor;
      scaley = scaley * scale_factor;
    }
  }
  if ((feq(x0, 0.0) && feq(x1, 0.0)) || feq(x1, 1.0)) {
    ps->y -= scaley * height;
  }

  if (new_file) {
    ps->fp << "%!PS-Adobe-2.0 EPSF-1.2\n"
           << "%%Creator: Proview Glow" << '\n'
           << "%%EndComments\n\n";
  } else {
    ps->fp << "restore\n";
  }

  ps->fp << "1.000000 1.000000 scale\n"
         << "save\n"
         << scalex * width << " " << scaley * height << " scale\n"
         << "/oneline " << width << " string def\n"
         << "/drawimage {" << '\n'
         << " " << width << " " << height << " 8 [" << width << " 0 0 -"
         << height << " 0 " << height << "]\n"
         << " { currentfile oneline readhexstring pop }\n";
  if (colorimage) {
    ps->fp << "false 3\n"
           << "colorimage\n";
  } else {
    ps->fp << "image\n";
  }

  ps->fp << "} def\n"
         << x / scalex / width << " " << (y - height * scaley) / scaley / height
         << " translate\n"
         << "drawimage\n";

  ps->fp.flags((ps->fp.flags() & ~std::ios_base::dec) | std::ios_base::hex
      | std::ios_base::uppercase);
  ps->fp.fill('0');
  j = 0;
  for (k = 0; k < height; k++) {
    for (i = 0; i < width; i++) {
      QColor pixel = QColor(image->pixel(i, k));
      if (!colorimage) {
        if (!pixel.alpha()) {
          grey = 255;
        } else {
          grey = (int)((0.0 + pixel.red() + pixel.green() + pixel.blue()) / 3
              + 0.5);
        }

        ps->fp.width(2);
        ps->fp << grey;
        if (++j >= 40) {
          j = 0;
          ps->fp << '\n';
        }
      } else {
        if (!pixel.alpha()) {
          red = blue = green = 255;
        } else {
          red = pixel.red();
          green = pixel.green();
          blue = pixel.blue();
        }
        ps->fp.width(2);
        ps->fp << red;
        ps->fp.width(2);
        ps->fp << green;
        ps->fp.width(2);
        ps->fp << blue;
        if (++j >= 20) {
          j = 0;
          ps->fp << '\n';
        }
      }
    }
  }

  if (end) {
    ps->fp << '\n'
           << "restore\n"
           << "showpage\n";
    delete ps;
    ps = 0;
  } else {
    ps->fp.flags(
        ((ps->fp.flags() & ~std::ios_base::hex) & ~std::ios_base::uppercase)
        | std::ios_base::dec);
  }

  return 1;
}

unique_ptr<QPoint[]> GlowDrawQt::points_to_qt_points(glow_sPointX* points, int point_cnt)
{
  unique_ptr<QPoint[]> qpoints(new QPoint[point_cnt]);
  for (int i = 0; i < point_cnt; i++) {
    qpoints[i].setX(points[i].x);
    qpoints[i].setY(points[i].y);
  }
  return qpoints;
}

//
// Points outside window in x direction excluded
//
unique_ptr<QPoint[]> GlowDrawQt::points_to_qt_points_curve(
    GlowWind* w, glow_sPointX* points, int point_cnt, int* cnt)
{
  unique_ptr<QPoint[]> qpoints(new QPoint[point_cnt]);
  int idx = 0;
  int last_idx = 0;
  for (int i = 0; i < point_cnt; i++) {
    if (idx == 0 && i != point_cnt - 1
        && ((points[i].x < w->subwindow_x && points[i + 1].x < w->subwindow_x)
               || (points[i].x > w->subwindow_x + w->window_width
                      && points[i + 1].x > w->subwindow_x + w->window_width))) {
      continue;
    }
    if (idx != 0
        && !((points[i].x < w->subwindow_x && points[i - 1].x < w->subwindow_x)
               || (points[i].x > w->subwindow_x + w->window_width
                      && points[i - 1].x > w->subwindow_x + w->window_width))) {
      last_idx = idx;
    }
    qpoints[idx].setX(points[i].x);
    qpoints[idx].setY(points[i].y);
    idx++;
  }
  *cnt = idx;
  if (last_idx != 0) {
    *cnt = last_idx + 1;
  }
  return qpoints;
}

// Image functions
int GlowDrawQt::image_get_width(glow_tImImage image)
{
  return ((QImage*)image)->width();
}

int GlowDrawQt::image_get_height(glow_tImImage image)
{
  return ((QImage*)image)->height();
}

int GlowDrawQt::image_get_rowstride(glow_tImImage image)
{
  return ((QImage*)image)->bytesPerLine();
}

unsigned char* GlowDrawQt::image_get_data(glow_tImImage image)
{
  return ((QImage*)image)->convertToFormat(QImage::Format_ARGB32).bits();
}

void GlowDrawQt::image_copy(glow_tImImage orig_image, glow_tImImage* image)
{
  if (*image) {
    delete ((QImage*)*image);
  }

  *image = new QImage(((QImage*)orig_image)->copy());
}

void GlowDrawQt::image_rotate(
    glow_tImImage* image, int to_rotation, int from_rotation)
{
  int drot = to_rotation - from_rotation;
  drot = int((float(drot) / 360 - floor(float(drot) / 360)) * 360);
  QTransform trans;
  trans.rotate(drot);

  QImage* im = new QImage(((QImage*)*image)->transformed(trans));
  delete ((QImage*)*image);
  *image = (glow_tImImage)im;
}

void GlowDrawQt::image_flip_vertical(glow_tImImage* image)
{
  QImage* im = new QImage(((QImage*)*image)->mirrored());
  delete ((QImage*)*image);
  *image = (glow_tImImage)im;
}

void GlowDrawQt::image_flip_horizontal(glow_tImImage* image)
{
  QImage* im = new QImage(((QImage*)*image)->mirrored(true, false));
  delete ((QImage*)*image);
  *image = (glow_tImImage)im;
}

int GlowDrawQt::image_scale(int width, int height, glow_tImImage orig_im,
    glow_tImImage* im, glow_tImData* im_data, glow_tPixmap* im_pixmap,
    glow_tPixmap* im_mask)
{
  if (width == ((QImage*)*im)->width() && height == ((QImage*)*im)->height()) {
    return 0;
  }
  if (width == 0 && height == 0) {
    width = ((QImage*)*im)->width();
    height = ((QImage*)*im)->height();
  }

  if (!orig_im) {
    // Scale from im
    if (!*im) {
      return 0;
    }

    delete ((QImage*)*im);
    *im = new QImage(((QImage*)orig_im)->scaled(width, height));
  } else {
// Scale from orig_im
    if (*im) {
      delete ((QImage*)*im);
    }
    *im = new QImage(((QImage*)orig_im)->scaled(width, height));
  }
  return 1;
}

int GlowDrawQt::image_load(char* imagefile, glow_tImImage* orig_im,
    glow_tImImage* im, glow_tImData* im_data)
{
  if (im && *im) {
    delete ((QImage*)*im);
  }
  if (*orig_im) {
    delete ((QImage*)*orig_im);
  }
  *orig_im = new QImage(imagefile);
  if (((QImage*)*orig_im)->isNull()) {
    if (im) {
      *im = 0;
    }
    return 0;
  }
  if (im) {
    *im = new QImage(((QImage*)*orig_im)->copy());
  }
  return 1;
}

int GlowDrawQt::image_render(int width, int height, glow_tImImage orig_im,
    glow_tImImage* im, glow_tPixmap* im_pixmap, glow_tPixmap* im_mask)
{
  return 1;
}

void GlowDrawQt::image_free(glow_tImImage image)
{
  delete ((QImage*)image);
}

void GlowDrawQt::pixmap_free(glow_tPixmap pixmap)
{
}

void GlowDrawQt::image_pixel_iter(glow_tImImage orig_image,
    glow_tImImage* image, void (*pixel_cb)(void*, unsigned char*),
    void* userdata)
{
  unsigned char *rgb, *rgb_row;
  int rgb_height;
  int rgb_width;
  int rowstride;

  if (orig_image) {
    if (image && *image != orig_image) {
      delete ((QImage*)*image);
    }
    *((QImage*)*image) = ((QImage*)orig_image)->copy();
  } else if (!*image) {
    return;
  }

  rgb = ((QImage*)*image)->convertToFormat(QImage::Format_ARGB32).bits();
  rgb_height = ((QImage*)*image)->height();
  rgb_width = ((QImage*)*image)->width();
  rowstride = ((QImage*)*image)->bytesPerLine();

  rgb_row = rgb;
  for (int j = 0; j < rgb_height; j++) {
    rgb = rgb_row;
    for (int i = 0; i < rgb_width; i++) {
      if (*(rgb + 3)) {
        (pixel_cb)(userdata, rgb);
      }
      rgb += 4;
    }
    rgb_row += rowstride;
  }
}

int GlowDrawQt::gradient_create_pattern(int x, int y, int w, int h,
    glow_eDrawType d0, glow_eDrawType d1, glow_eDrawType d2,
    glow_eGradient gradient, QGradient** pat)
{
  double r1, g1, b1, r2, g2, b2;
  int a = 15;

  GlowColor::rgb_color(d1, &r1, &g1, &b1, get_customcolors());
  GlowColor::rgb_color(d2, &r2, &g2, &b2, get_customcolors());

  switch (gradient) {
  case glow_eGradient_HorizontalUp:
    *pat = new QLinearGradient(x, y, x, y + h);
    (*pat)->setColorAt(0.1, QColor::fromRgbF(r2, g2, b2));
    (*pat)->setColorAt(0.9, QColor::fromRgbF(r1, g1, b1));
    break;
  case glow_eGradient_HorizontalDown:
    *pat = new QLinearGradient(x, y, x, y + h);
    (*pat)->setColorAt(0.1, QColor::fromRgbF(r1, g1, b1));
    (*pat)->setColorAt(0.9, QColor::fromRgbF(r2, g2, b2));
    break;
  case glow_eGradient_HorizontalTube1:
    *pat = new QLinearGradient(x, y, x, y + h);
    (*pat)->setColorAt(0, QColor::fromRgbF(r1, g1, b1));
    (*pat)->setColorAt(0.5, QColor::fromRgbF(r2, g2, b2));
    (*pat)->setColorAt(1, QColor::fromRgbF(r1, g1, b1));
    break;
  case glow_eGradient_HorizontalTube2: {
    double r0, g0, b0;

    *pat = new QLinearGradient(x, y, x, y + h);
    GlowColor::rgb_color(d0, &r0, &g0, &b0, get_customcolors());
    (*pat)->setColorAt(0, QColor::fromRgbF(r0, g0, b0));
    (*pat)->setColorAt(0.3, QColor::fromRgbF(r2, g2, b2));
    (*pat)->setColorAt(0.95, QColor::fromRgbF(r1, g1, b1));
    break;
  }
  case glow_eGradient_VerticalRight:
    *pat = new QLinearGradient(x, y, x + w, y);
    (*pat)->setColorAt(0.1, QColor::fromRgbF(r1, g1, b1));
    (*pat)->setColorAt(0.9, QColor::fromRgbF(r2, g2, b2));
    break;
  case glow_eGradient_VerticalLeft:
    *pat = new QLinearGradient(x, y, x + w, y);
    (*pat)->setColorAt(0.1, QColor::fromRgbF(r2, g2, b2));
    (*pat)->setColorAt(0.9, QColor::fromRgbF(r1, g1, b1));
    break;
  case glow_eGradient_VerticalTube1:
    *pat = new QLinearGradient(x, y, x + w, y);
    (*pat)->setColorAt(0, QColor::fromRgbF(r1, g1, b1));
    (*pat)->setColorAt(0.5, QColor::fromRgbF(r2, g2, b2));
    (*pat)->setColorAt(1, QColor::fromRgbF(r1, g1, b1));
    break;
  case glow_eGradient_VerticalTube2: {
    double r0, g0, b0;

    GlowColor::rgb_color(d0, &r0, &g0, &b0, get_customcolors());
    *pat = new QLinearGradient(x, y, x + w, y);
    (*pat)->setColorAt(0, QColor::fromRgbF(r0, g0, b0));
    (*pat)->setColorAt(0.3, QColor::fromRgbF(r2, g2, b2));
    (*pat)->setColorAt(0.95, QColor::fromRgbF(r1, g1, b1));
    break;
  }
  case glow_eGradient_DiagonalUpperLeft: {
    double x0, x1, y0, y1;

    if (w > h) {
      x0 = x + w / 2 - h / 2;
      y0 = y - (w - h) / a;
      x1 = x + w / 2 + h / 2;
      y1 = y + h + (w - h) / a;
    } else {
      y0 = y + h / 2 - w / 2;
      x0 = x - (h - w) / a;
      y1 = y + h / 2 + w / 2;
      x1 = x + w + (h - w) / a;
    }
    *pat = new QLinearGradient(x0, y0, x1, y1);
    (*pat)->setColorAt(0.1, QColor::fromRgbF(r2, g2, b2));
    (*pat)->setColorAt(0.9, QColor::fromRgbF(r1, g1, b1));
    break;
  }
  case glow_eGradient_DiagonalLowerLeft: {
    double x0, x1, y0, y1;
    if (w > h) {
      x0 = x + w / 2 - h / 2;
      y0 = y + h + (w - h) / a;
      x1 = x + w / 2 + h / 2;
      y1 = y - (w - h) / a;
    } else {
      y1 = y + h / 2 - w / 2;
      x1 = x + w + (h - w) / a;
      y0 = y + h / 2 + w / 2;
      x0 = x - (h - w) / a;
    }
    *pat = new QLinearGradient(x0, y0, x1, y1);
    (*pat)->setColorAt(0.1, QColor::fromRgbF(r2, g2, b2));
    (*pat)->setColorAt(0.9, QColor::fromRgbF(r1, g1, b1));
    break;
  }
  case glow_eGradient_DiagonalUpperRight: {
    double x0, x1, y0, y1;
    if (w > h) {
      x0 = x + w / 2 - h / 2;
      y0 = y + h + (w - h) / a;
      x1 = x + w / 2 + h / 2;
      y1 = y - (w - h) / a;
    } else {
      y1 = y + h / 2 - w / 2;
      x1 = x + w + (h - w) / a;
      y0 = y + h / 2 + w / 2;
      x0 = x - (h - w) / a;
    }
    *pat = new QLinearGradient(x0, y0, x1, y1);
    (*pat)->setColorAt(0.1, QColor::fromRgbF(r1, g1, b1));
    (*pat)->setColorAt(0.9, QColor::fromRgbF(r2, g2, b2));
    break;
  }
  case glow_eGradient_DiagonalLowerRight: {
    double x0, x1, y0, y1;

    if (w > h) {
      x0 = x + w / 2 - h / 2;
      y0 = y - (w - h) / a;
      x1 = x + w / 2 + h / 2;
      y1 = y + h + (w - h) / a;
    } else {
      y0 = y + h / 2 - w / 2;
      x0 = x - (h - w) / a;
      y1 = y + h / 2 + w / 2;
      x1 = x + w + (h - w) / a;
    }
    *pat = new QLinearGradient(x0, y0, x1, y1);
    (*pat)->setColorAt(0.1, QColor::fromRgbF(r1, g1, b1));
    (*pat)->setColorAt(0.9, QColor::fromRgbF(r2, g2, b2));
    break;
  }
  case glow_eGradient_DiagonalUpTube: {
    double x0, x1, y0, y1;

    if (w > h) {
      x0 = x + w / 2 - h / 2;
      y0 = y - (w - h) / a;
      x1 = x + w / 2 + h / 2;
      y1 = y + h + (w - h) / a;
    } else {
      y0 = y + h / 2 - w / 2;
      x0 = x - (h - w) / a;
      y1 = y + h / 2 + w / 2;
      x1 = x + w + (h - w) / a;
    }
    *pat = new QLinearGradient(x0, y0, x1, y1);
    (*pat)->setColorAt(0.1, QColor::fromRgbF(r1, g1, b1));
    (*pat)->setColorAt(0.5, QColor::fromRgbF(r2, g2, b2));
    (*pat)->setColorAt(0.9, QColor::fromRgbF(r1, g1, b1));
    break;
  }
  case glow_eGradient_DiagonalDownTube: {
    double x0, x1, y0, y1;
    if (w > h) {
      x0 = x + w / 2 - h / 2;
      y0 = y + h + (w - h) / a;
      x1 = x + w / 2 + h / 2;
      y1 = y - (w - h) / a;
    } else {
      y1 = y + h / 2 - w / 2;
      x1 = x + w + (h - w) / a;
      y0 = y + h / 2 + w / 2;
      x0 = x - (h - w) / a;
    }
    *pat = new QLinearGradient(x0, y0, x1, y1);
    (*pat)->setColorAt(0.1, QColor::fromRgbF(r1, g1, b1));
    (*pat)->setColorAt(0.5, QColor::fromRgbF(r2, g2, b2));
    (*pat)->setColorAt(0.9, QColor::fromRgbF(r1, g1, b1));
    break;
  }
  case glow_eGradient_Globe:
    *pat = new QRadialGradient(
        x + w / 3, y + h / 3, sqrt(w * w / 4 + h * h / 4));
    (*pat)->setColorAt(0.9, QColor::fromRgbF(r1, g1, b1));
    (*pat)->setColorAt(0.1, QColor::fromRgbF(r2, g2, b2));
    break;
  case glow_eGradient_RadialCenter:
    *pat = new QRadialGradient(
        x + w / 2, y + h / 2, sqrt(w * w / 4 + h * h / 4));
    (*pat)->setColorAt(0.9, QColor::fromRgbF(r1, g1, b1));
    (*pat)->setColorAt(0.1, QColor::fromRgbF(r2, g2, b2));
    break;
  case glow_eGradient_RadialUpperLeft:
    *pat = new QRadialGradient(x, y, sqrt(w * w + h * h));
    (*pat)->setColorAt(0.9, QColor::fromRgbF(r1, g1, b1));
    (*pat)->setColorAt(0.1, QColor::fromRgbF(r2, g2, b2));
    break;
  case glow_eGradient_RadialLowerLeft:
    *pat = new QRadialGradient(x, y + h, sqrt(w * w + h * h));
    (*pat)->setColorAt(0.9, QColor::fromRgbF(r1, g1, b1));
    (*pat)->setColorAt(0.1, QColor::fromRgbF(r2, g2, b2));
    break;
  case glow_eGradient_RadialUpperRight:
    *pat = new QRadialGradient(x + w, y, sqrt(w * w + h * h));
    (*pat)->setColorAt(0.9, QColor::fromRgbF(r1, g1, b1));
    (*pat)->setColorAt(0.1, QColor::fromRgbF(r2, g2, b2));
    break;
  case glow_eGradient_RadialLowerRight:
    *pat = new QRadialGradient(x + w, y + h, sqrt(w * w + h * h));
    (*pat)->setColorAt(0.9, QColor::fromRgbF(r1, g1, b1));
    (*pat)->setColorAt(0.1, QColor::fromRgbF(r2, g2, b2));
    break;
  default:
    return 0;
  }
  return 1;
}

glow_eGradient GlowDrawQt::gradient_rotate(double rot, glow_eGradient gradient)
{
  glow_eGradient g;
  double rotation = (rot / 360 - floor(rot / 360)) * 360;

  if (45 >= rotation || rotation > 315) {
    g = gradient;
  } else if (45 < rotation && rotation <= 135) {
    switch (gradient) {
    case glow_eGradient_HorizontalUp:
      g = glow_eGradient_VerticalRight;
      break;
    case glow_eGradient_HorizontalDown:
      g = glow_eGradient_VerticalLeft;
      break;
    case glow_eGradient_HorizontalTube1:
      g = glow_eGradient_VerticalTube1;
      break;
    case glow_eGradient_HorizontalTube2:
      g = glow_eGradient_VerticalTube2;
      break;
    case glow_eGradient_VerticalLeft:
      g = glow_eGradient_HorizontalUp;
      break;
    case glow_eGradient_VerticalRight:
      g = glow_eGradient_HorizontalDown;
      break;
    case glow_eGradient_VerticalTube1:
      g = glow_eGradient_HorizontalTube1;
      break;
    case glow_eGradient_VerticalTube2:
      g = glow_eGradient_HorizontalTube2;
      break;
    case glow_eGradient_DiagonalUpperLeft:
      g = glow_eGradient_DiagonalUpperRight;
      break;
    case glow_eGradient_DiagonalLowerLeft:
      g = glow_eGradient_DiagonalUpperLeft;
      break;
    case glow_eGradient_DiagonalUpperRight:
      g = glow_eGradient_DiagonalLowerRight;
      break;
    case glow_eGradient_DiagonalLowerRight:
      g = glow_eGradient_DiagonalLowerLeft;
      break;
    case glow_eGradient_DiagonalUpTube:
      g = glow_eGradient_DiagonalDownTube;
      break;
    case glow_eGradient_DiagonalDownTube:
      g = glow_eGradient_DiagonalUpTube;
      break;
    case glow_eGradient_RadialUpperLeft:
      g = glow_eGradient_RadialUpperRight;
      break;
    case glow_eGradient_RadialLowerLeft:
      g = glow_eGradient_RadialUpperLeft;
      break;
    case glow_eGradient_RadialUpperRight:
      g = glow_eGradient_RadialLowerRight;
      break;
    case glow_eGradient_RadialLowerRight:
      g = glow_eGradient_RadialLowerLeft;
      break;
    default:
      g = gradient;
    }
  } else if (135 < rotation && rotation <= 225) {
    switch (gradient) {
    case glow_eGradient_HorizontalUp:
      g = glow_eGradient_HorizontalDown;
      break;
    case glow_eGradient_HorizontalDown:
      g = glow_eGradient_HorizontalUp;
      break;
    case glow_eGradient_VerticalLeft:
      g = glow_eGradient_VerticalRight;
      break;
    case glow_eGradient_VerticalRight:
      g = glow_eGradient_VerticalLeft;
      break;
    case glow_eGradient_DiagonalUpperLeft:
      g = glow_eGradient_DiagonalLowerRight;
      break;
    case glow_eGradient_DiagonalLowerLeft:
      g = glow_eGradient_DiagonalUpperRight;
      break;
    case glow_eGradient_DiagonalUpperRight:
      g = glow_eGradient_DiagonalLowerLeft;
      break;
    case glow_eGradient_DiagonalLowerRight:
      g = glow_eGradient_DiagonalUpperLeft;
      break;
    case glow_eGradient_RadialUpperLeft:
      g = glow_eGradient_RadialLowerRight;
      break;
    case glow_eGradient_RadialLowerLeft:
      g = glow_eGradient_RadialUpperRight;
      break;
    case glow_eGradient_RadialUpperRight:
      g = glow_eGradient_RadialLowerLeft;
      break;
    case glow_eGradient_RadialLowerRight:
      g = glow_eGradient_RadialUpperLeft;
      break;
    default:
      g = gradient;
    }
  } else { // if (225 < rotation && rotation <= 315)
    switch (gradient) {
    case glow_eGradient_HorizontalUp:
      g = glow_eGradient_VerticalLeft;
      break;
    case glow_eGradient_HorizontalDown:
      g = glow_eGradient_VerticalRight;
      break;
    case glow_eGradient_HorizontalTube1:
      g = glow_eGradient_VerticalTube1;
      break;
    case glow_eGradient_HorizontalTube2:
      g = glow_eGradient_VerticalTube2;
      break;
    case glow_eGradient_VerticalLeft:
      g = glow_eGradient_HorizontalDown;
      break;
    case glow_eGradient_VerticalRight:
      g = glow_eGradient_HorizontalUp;
      break;
    case glow_eGradient_VerticalTube1:
      g = glow_eGradient_HorizontalTube1;
      break;
    case glow_eGradient_VerticalTube2:
      g = glow_eGradient_HorizontalTube2;
      break;
    case glow_eGradient_DiagonalUpperLeft:
      g = glow_eGradient_DiagonalLowerLeft;
      break;
    case glow_eGradient_DiagonalLowerLeft:
      g = glow_eGradient_DiagonalLowerRight;
      break;
    case glow_eGradient_DiagonalUpperRight:
      g = glow_eGradient_DiagonalUpperLeft;
      break;
    case glow_eGradient_DiagonalLowerRight:
      g = glow_eGradient_DiagonalUpperRight;
      break;
    case glow_eGradient_DiagonalUpTube:
      g = glow_eGradient_DiagonalDownTube;
      break;
    case glow_eGradient_DiagonalDownTube:
      g = glow_eGradient_DiagonalUpTube;
      break;
    case glow_eGradient_RadialUpperLeft:
      g = glow_eGradient_RadialLowerLeft;
      break;
    case glow_eGradient_RadialLowerLeft:
      g = glow_eGradient_RadialLowerRight;
      break;
    case glow_eGradient_RadialUpperRight:
      g = glow_eGradient_RadialUpperLeft;
      break;
    case glow_eGradient_RadialLowerRight:
      g = glow_eGradient_RadialUpperRight;
      break;
    default:
      g = gradient;
    }
  }
  return g;
}

int GlowDrawQt::gradient_fill_rect(GlowWind* wind, int x, int y, int w, int h,
    glow_eDrawType d0, glow_eDrawType d1, glow_eDrawType d2,
    glow_eGradient gradient)
{
  DrawWindQt* ww = (DrawWindQt*)wind->window;
  if (ctx->nodraw) {
    return 1;
  }

  unique_ptr<QPainter> painter = new QPainter(ww->buffer);

  if (ww->clip_on) {
    set_clip(ww, painter);
  }

  QGradient* pat;
  if (!gradient_create_pattern(x, y, w, h, d0, d1, d2, gradient, &pat)) {
    return 0;
  }
  painter->fillRect(QRect(x, y, w, h), *pat);

  delete pat;

  return 1;
}

int GlowDrawQt::gradient_fill_rectrounded(GlowWind* wind, int x, int y, int w,
    int h, int roundamount, glow_eDrawType d0, glow_eDrawType d1,
    glow_eDrawType d2, glow_eGradient gradient)
{
  DrawWindQt* ww = (DrawWindQt*)wind->window;
  if (ctx->nodraw) {
    return 1;
  }

  unique_ptr<QPainter> painter = new QPainter(ww->buffer);

  if (ww->clip_on) {
    set_clip(ww, painter);
  }

  QGradient* pat;
  if (!gradient_create_pattern(x, y, w, h, d0, d1, d2, gradient, &pat)) {
    return 0;
  }

  if (roundamount >= 0) {
    QPainterPath path;
    path.addRoundedRect(QRect(x, y, w, h), roundamount, roundamount);
    painter->fillPath(path, *pat);
  } else {
    painter->fillRect(QRect(x, y, w, h), *pat);
  }

  delete pat;

  return 1;
}

int GlowDrawQt::gradient_fill_arc(GlowWind* wind, int x, int y, int w, int h,
    int angle1, int angle2, glow_eDrawType d0, glow_eDrawType d1,
    glow_eDrawType d2, glow_eGradient gradient)
{
  DrawWindQt* ww = (DrawWindQt*)wind->window;
  if (ctx->nodraw) {
    return 1;
  }

  while (angle1 >= 360) {
    angle1 -= 360;
  }
  while (angle1 < 360) {
    angle1 += 360;
  }

  unique_ptr<QPainter> painter = new QPainter(ww->buffer);

  if (ww->clip_on) {
    set_clip(ww, painter);
  }

  QGradient* pat;
  if (!gradient_create_pattern(-1, -1, 2, 2, d0, d1, d2, gradient, &pat)) {
    return 0;
  }

  painter->translate(x + w / 2.0, y + h / 2.0);
  painter->scale(w / 2.0, h / 2.0);
  QPainterPath path;
  if (!(angle2 == 360 || angle2 == 180))
    path.moveTo(0, 0);
  path.arcTo(-1, -1, 2, 2, angle1, angle2);
  if (!(angle2 == 360 || angle2 == 180))
    path.moveTo(0, 0);
  painter->fillPath(path, *pat);

  delete pat;

  return 1;
}

int GlowDrawQt::gradient_fill_polyline(GlowWind* wind, glow_sPointX* points,
    int point_cnt, glow_eDrawType d0, glow_eDrawType d1, glow_eDrawType d2,
    glow_eGradient gradient)
{
  DrawWindQt* ww = (DrawWindQt*)wind->window;
  if (ctx->nodraw || point_cnt < 1) {
    return 1;
  }

  unique_ptr<QPainter> painter = new QPainter(ww->buffer);
  QPainterPath path;
  double x0, y0, x1, y1;

  if (ww->clip_on) {
    set_clip(ww, painter);
  }

  x0 = x1 = points[0].x;
  y0 = y1 = points[0].y;
  path.moveTo(points[0].x, points[0].y);
  for (int j = 0; j < point_cnt; j++) {
    x0 = MIN(x0, points[j].x);
    y0 = MIN(y0, points[j].y);
    x1 = MAX(x1, points[j].x);
    y1 = MAX(y1, points[j].y);

    path.lineTo(points[j].x, points[j].y);
  }

  QGradient* pat;
  if (!gradient_create_pattern((int)x0, (int)y0, (int)(x1 - x0), (int)(y1 - y0),
          d0, d1, d2, gradient, &pat)) {
    return 0;
  }
  painter->fillPath(path, *pat);

  delete pat;

  return 1;
}

int GlowDrawQt::text_qt(GlowWind* wind, int x, int y, char* text, int len,
    glow_eDrawType painter_type, glow_eDrawType color, int idx, int highlight,
    int line, glow_eFont font_idx, double size, int rot)
{
  if (ctx->nodraw) {
    return 1;
  }
  DrawWindQt* w = (DrawWindQt*)wind->window;

  if (font_idx >= glow_eFont__) {
    font_idx = glow_eFont_Helvetica;
  }

  unique_ptr<QPainter> painter = get_painter(w->buffer, this, painter_type, idx);

  if (w->clip_on) {
    set_clip(w, painter);
  }

  if (color != glow_eDrawType_Line) {
    painter->setBrush(QBrush(draw_type_to_color(this, color, idx)));
    painter->setPen(QPen(painter->brush(), size + 1));
  }

  QString str;
  if (((GrowCtx*)ctx)->text_coding != glow_eTextCoding_UTF_8) {
    str = QString::fromLatin1(text);
  } else {
    str = QString::fromUtf8(text);
  }

  if (rot != 0) {
    rot = 360 - rot;
    painter->rotate(rot);
  }

  painter->setFont(get_font(font_idx, painter_type, size));

  QRect rect = painter->fontMetrics().boundingRect(str);
  int width = rect.width();
  int height = rect.height();
  height = (int)(height * 0.9);

  int px, py;
  if (rot == 180) {
    px = -x - width;
    py = (int)(-y - FONT_DESCENT * height);
  } else if (rot == 90) {
    px = -y - width + height / 2;
    py = x;
  } else if (rot == 270) {
    px = y - width;
    py = -x - height;
  } else {
    px = x;
    py = (int)(y - (1.0 - FONT_DESCENT) * height);
  }
  painter->drawText(px, py, rect.width(), rect.height(), Qt::TextDontClip, str);

  return 1;
}

int GlowDrawQt::text_erase_qt(GlowWind* wind, int x, int y, char* text, int len,
    glow_eDrawType painter_type, int idx, int line, glow_eFont font_idx,
    double size, int rot)
{
  if (ctx->nodraw) {
    return 1;
  }
  DrawWindQt* w = (DrawWindQt*)wind->window;
  int px, py, pw, ph;

  if (font_idx >= glow_eFont__) {
    font_idx = glow_eFont_Helvetica;
  }

  if (painter_type == glow_eDrawType_TextHelvetica) {
    painter_type = glow_eDrawType_TextHelveticaErase;
  } else if (painter_type == glow_eDrawType_TextHelveticaBold) {
    painter_type = glow_eDrawType_TextHelveticaEraseBold;
  }

  int width, height;

  {
    unique_ptr<QPainter> painter = get_painter(w->buffer, this, painter_type, 0);

    QString str;
    if (((GrowCtx*)ctx)->text_coding != glow_eTextCoding_UTF_8) {
      str = QString::fromLatin1(text);
    } else {
      str = QString::fromUtf8(text);
    }

    painter->setFont(get_font(font_idx, painter_type, size));

    QRect rect = painter->fontMetrics().boundingRect(str);
    width = rect.width();
    height = rect.height();
    height = (int)(height * 0.9);
  }

  if (rot == 90) {
    px = x; // - height/2;
    py = y - width;
    ph = width;
    pw = height;
  } else if (rot == 270) {
    px = x; // - height/2;
    py = y - height / 2;
    ph = width;
    pw = height;
  } else {
    px = x;
    py = (int)(y - (1.0 - FONT_DESCENT) * height);
    pw = width;
    ph = height;
  }

  unique_ptr<QPainter> painter = get_painter(w->buffer, this, painter_type, idx);

  if (w->clip_on) {
    set_clip(w, painter);
  }

  painter->fillRect(px, py, pw, ph, painter->brush());

  return 1;
}

int GlowDrawQt::get_text_extent_qt(const char* text, int len,
    glow_eDrawType painter_type, int idx, glow_eFont font_idx, int* width,
    int* height, int* descent, double size, int rot)
{
  DrawWindQt* w = m_wind;

  if (font_idx >= glow_eFont__) {
    font_idx = glow_eFont_Helvetica;
  }

  if (painter_type == glow_eDrawType_TextHelvetica) {
    painter_type = glow_eDrawType_TextHelveticaErase;
  } else if (painter_type == glow_eDrawType_TextHelveticaBold) {
    painter_type = glow_eDrawType_TextHelveticaEraseBold;
  }

  unique_ptr<QPainter> painter = get_painter(w->buffer, this, painter_type, 0);
  painter->setFont(get_font(font_idx, painter_type, size));

  QString str;
  if (((GrowCtx*)ctx)->text_coding != glow_eTextCoding_UTF_8) {
    str = QString::fromLatin1(text);
  } else {
    str = QString::fromUtf8(text);
  }

  QRect boundingRect = painter->fontMetrics().boundingRect(str);
  int lwidth = boundingRect.width();
  int lheight = boundingRect.height();
  lheight = (int)(lheight * 0.9);

  if (rot == 90 || rot == 270) {
    *height = lwidth;
    *width = lheight;
  } else {
    *width = lwidth;
    *height = lheight;
  }
  *descent = (int)(FONT_DESCENT * lheight);

  return 1;
}

void GlowDrawQt::log_event(QEvent* event)
{
  /*
  if (ctx->eventlog_callback) {
    QEvent e(QEvent::None);

    memcpy(&e, event, sizeof(e));

    switch (e.type()) {
      case QEvent::KeyPress:
        *(char *) & e.key.string = e.key.string[0];
        break;
      case QEvent::MouseMove: {
        int x, y;

        QPoint pos = QCursor::pos();
        e.button.x = pos.x;
        e.button.y = pos.y;
        e.motion.is_hint = 0;
        break;
      }
      case QEvent::Show: {
        int width, height;

        get_window_size(&ctx->mw, &width, &height);
        if (e.expose.area.x == 0 && e.expose.area.y == 0) {
          e.expose.area.x = -999;
          e.expose.area.y = -999;
          e.expose.area.width = width;
          e.expose.area.height = height;
        }
        break;
      }
      default:;
    }

    (ctx->eventlog_callback)(ctx, &e, sizeof(e));
  }
   */
}

void GlowDrawQt::event_exec(void* event, unsigned int size)
{
  QEvent e(QEvent::None);

  if (size != sizeof(e)) {
    return;
  }

  memcpy((void*)&e, (void*)event, size);
  // e.any.window = m_wind->window;

  switch (e.type()) {
  case QEvent::Show: {
    QWidget* parent = m_wind->window->window();
    if (parent->isVisible()) {
      QRegion area = parent->visibleRegion();
      parent->resize(area.boundingRect().width(), area.boundingRect().height());
    }
    break;
  }
  default:;
  }

  event_handler(&e, m_wind->window);
}

int GlowDrawQt::open_color_selection(double* r, double* g, double* b)
{
  QColor color = QColor::fromRgbF(*r, *g, *b);
  color = QColorDialog::getColor(color);
  if (color.isValid()) {
    *r = color.redF();
    *g = color.greenF();
    *b = color.blueF();
    return 1;
  } else {
    return 0;
  }
}

void GlowDrawQt::update_color(glow_eDrawType color)
{
}

void GlowDrawQt::push_customcolors(GlowCustomColors* cc)
{
  if (customcolors_cnt > 10) {
    printf("** Max number custom colors exceede\n");
    return;
  }

  for (int i = customcolors_cnt; i > 0; i--)
    customcolors[i] = customcolors[i - 1];
  customcolors[0] = (GlowCustomColorsQt*)cc;
  customcolors_cnt++;
}

void GlowDrawQt::set_customcolors(GlowCustomColors* cc)
{
  customcolors[0] = (GlowCustomColorsQt*)cc;
  customcolors_cnt = 1;
}

void GlowDrawQt::pop_customcolors()
{
  if (customcolors_cnt <= 0) {
    printf("** Customcolor stack disorder\n");
  }
  for (int i = 0; i < customcolors_cnt - 1; i++)
    customcolors[i] = customcolors[i + 1];
  customcolors_cnt--;
}

GlowCustomColorsQt* GlowDrawQt::get_customcolors()
{
  if (customcolors_cnt == 0)
    return 0;
  return customcolors[0];
}

GlowCustomColors* GlowDrawQt::create_customcolors()
{
  return new GlowCustomColorsQt();
}

void GlowDrawQt::reset_customcolors(GlowCustomColors* cc)
{
  memset(((GlowCustomColorsQt*)cc)->color_vect, 0,
      sizeof(((GlowCustomColorsQt*)cc)->color_vect));
}