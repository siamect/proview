/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2012 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

#ifndef xtt_evlist_h
#define xtt_evlist_h

/* xtt_evlist.h -- Alarm and event windows in xtt */


// Status is defined as int i xlib...
#ifdef Status
# undef Status
#endif

#ifndef pwr_h
# include "pwr.h"
#endif
#ifndef rt_mh_h
# include "rt_mh.h"
#endif
#ifndef rt_mh_outunit_h
# include "rt_mh_outunit.h"
#endif

#ifndef flow_h
#include "flow.h"
#endif

#ifndef flow_browctx_h
#include "flow_browctx.h"
#endif

#ifndef flow_browapi_h
#include "flow_browapi.h"
#endif

class ItemAlarm;

#define ALARM_INFO_A_SIZE  5
#define ALARM_INFO_B_SIZE  2
#define ALARM_INFO_C_SIZE  2
#define ALARM_INFO_D_SIZE  2
#define ALARM_INFO_I_SIZE  2
typedef struct {
	char	a_alarm_text[ALARM_INFO_A_SIZE][80];
	char	a_alarm_alias[ALARM_INFO_A_SIZE][40];
	pwr_tTime a_alarm_time[ALARM_INFO_A_SIZE];
	int	a_alarm_active[ALARM_INFO_A_SIZE];
	int	a_alarm_exist[ALARM_INFO_A_SIZE];
	char	b_alarm_text[ALARM_INFO_B_SIZE][80];
	char	b_alarm_alias[ALARM_INFO_A_SIZE][40];
	pwr_tTime b_alarm_time[ALARM_INFO_B_SIZE];
	int	b_alarm_active[ALARM_INFO_B_SIZE];
	int	b_alarm_exist[ALARM_INFO_B_SIZE];
	char	c_alarm_text[ALARM_INFO_C_SIZE][80];
	char	c_alarm_alias[ALARM_INFO_A_SIZE][40];
	pwr_tTime c_alarm_time[ALARM_INFO_C_SIZE];
	int	c_alarm_active[ALARM_INFO_C_SIZE];
	int	c_alarm_exist[ALARM_INFO_C_SIZE];
	char	d_alarm_text[ALARM_INFO_D_SIZE][80];
	char	d_alarm_alias[ALARM_INFO_A_SIZE][40];
	pwr_tTime d_alarm_time[ALARM_INFO_D_SIZE];
	int	d_alarm_active[ALARM_INFO_D_SIZE];
	int	d_alarm_exist[ALARM_INFO_D_SIZE];
	char	i_alarm_text[ALARM_INFO_I_SIZE][80];
	char	i_alarm_alias[ALARM_INFO_A_SIZE][40];
	pwr_tTime i_alarm_time[ALARM_INFO_I_SIZE];
	int	i_alarm_active[ALARM_INFO_I_SIZE];
	int	i_alarm_exist[ALARM_INFO_I_SIZE];
	int	alarms_total;
	int	alarms_notacked;
	} evlist_sAlarmInfo;

typedef enum {
	ev_eType_AlarmList,
	ev_eType_EventList,
	ev_eType_HistList,
	ev_eType_BlockList
	} ev_eType;

typedef enum {
	evlist_eEventType_Info,
	evlist_eEventType_Return,
	evlist_eEventType_Ack,
	evlist_eEventType_Alarm,
	evlist_eEventType_Block,
	evlist_eEventType_Cancel
	} evlist_eEventType;

typedef enum {
	evlist_eItemType_Alarm,
	evlist_eItemType_Category
	} evlist_eItemType;

typedef enum {
	evlist_mOpen_All       	= ~0,
	evlist_mOpen_Children	= 1 << 0
	} evlist_mOpen;

class EvListBrow {
  public:
  EvListBrow( BrowCtx *brow_ctx, void *evl) : ctx(brow_ctx), evlist(evl) {};
    ~EvListBrow();

    BrowCtx		*ctx;
    void		*evlist;
    brow_tNodeClass 	nc_event;
    brow_tNodeClass 	nc_a_alarm;
    brow_tNodeClass 	nc_b_alarm;
    brow_tNodeClass 	nc_info;
    brow_tNodeClass 	nc_category;
    brow_tNodeClass 	nc_category_a;
    brow_tNodeClass 	nc_category_b;
    brow_tNodeClass 	nc_category_c;
    brow_tNodeClass 	nc_category_d;
    brow_tNodeClass 	nc_category_i;
    brow_tNodeClass 	nc_category_flash;
    flow_sAnnotPixmap 	*pixmap_leaf;
    flow_sAnnotPixmap 	*pixmap_map;
    flow_sAnnotPixmap 	*pixmap_openmap;
    flow_sAnnotPixmap 	*pixmap_attr;
    flow_sAnnotPixmap 	*pixmap_attrarray;
    flow_sAnnotPixmap 	*pixmap_alarm;
    flow_sAnnotPixmap 	*pixmap_ack;
    flow_sAnnotPixmap 	*pixmap_eventalarm;
    flow_sAnnotPixmap 	*pixmap_eventacked;
    flow_sAnnotPixmap 	*pixmap_eventreturn;
    flow_sAnnotPixmap 	*pixmap_info;
    flow_sAnnotPixmap 	*pixmap_blockr;
    flow_sAnnotPixmap 	*pixmap_blockl;

    void free_pixmaps();
    void allocate_pixmaps();
    void create_nodeclasses();
    void brow_setup();
};

class EvList {
  public:
    EvList( void *ev_parent_ctx,
	    ev_eType ev_type,
	    int ev_size,
	    int ev_eventname_seg,
	    void (*ev_init_cb)( void *) = 0);
    virtual ~EvList();

    void 		*parent_ctx;
    ev_eType		type;
    EvListBrow		*brow;
    EvListBrow		*browbase;
    EvListBrow		*browtree;
    int			size;
    int			max_size;
    int			display_hundredth;
    int			hide_object;
    int			hide_text;
    void 		(*start_trace_cb)( void *, pwr_tObjid, char *);
    void 		(*display_in_xnav_cb)( void *, pwr_tAttrRef *);
    void 		(*popup_menu_cb)( void *, pwr_tAttrRef, unsigned long,
					  unsigned long, char *, int x, int y);
    char		*(*name_to_alias_cb)( void *, char *);
    int			(*sound_cb)( void *, pwr_tAttrRef *);
    void       		(*selection_changed_cb)( void *);
    void		(*init_cb)( void *);
    void		(*help_event_cb)( void *, void *);
    double		acc_beep_time;
    double		beep_interval;
    pwr_tAttrRef	aalarm_sound;
    pwr_tAttrRef	balarm_sound;
    pwr_tAttrRef	calarm_sound;
    pwr_tAttrRef	dalarm_sound;
    pwr_tAttrRef	info_sound;
    int			eventname_seg;
    pwr_tObjid		current_view;
    bool 		flash_value;

    virtual void set_input_focus() {}
    virtual void bell() {}
    virtual void popup_position( int x_event, int y_event, int *x, int *y) {}
    virtual void print( const char *title) {}

    void event_info( mh_sMessage *msg);
    void event_alarm( mh_sMessage *msg);
    void event_block( mh_sBlock *msg);
    void event_cancel( mh_sReturn *msg);
    void event_ack( mh_sAck *msg);
    void event_return( mh_sReturn *msg);
    void event_clear_alarmlist( pwr_tNodeIndex nix);
    int get_last_not_acked( mh_sEventId **id);
    int get_last_not_acked_beep( mh_sEventId **id);
    int id_to_item( mh_sEventId *id, void **item);
    int oid_to_item( pwr_tOid oid, void **item);
    void ack( mh_sEventId *id);
    void zoom( double zoom_factor);
    void unzoom();
    void beep( double scantime);
    void start_trace();
    void display_in_xnav();
    void set_nodraw();
    void reset_nodraw();
    void update_text();
    void set_display_hundredth( int value);
    void set_hide_object( int value);
    void set_hide_text( int value);
    int get_alarm_info( evlist_sAlarmInfo *info);
    int get_last_not_acked_prio( mh_sEventId **id, unsigned long type, unsigned long prio);
    int get_selected_event( char *eventname, ItemAlarm **item);
    int get_destination( pwr_tTime time, void **dest);
    void block_remove();
    void print_nodia( char *filename);
    pwr_tStatus set_view(pwr_tOid view);
    pwr_tStatus view_init( pwr_tOid view);
    void view_configure();
    void view_alarm( ItemAlarm *alarm_item);
    void flash();
    void copy_list( EvList* evl);

    static int init_brow_cb( FlowCtx *fctx, void *client_data);
    static int init_browtree_cb( BrowCtx *fctx, void *client_data);
    static int brow_cb( FlowCtx *ctx, flow_tEvent event);
    static int browtree_cb( FlowCtx *ctx, flow_tEvent event);
    static int get_select( void *ctx, pwr_tAttrRef *attrref, int *is_attr);
    static int get_select_supobject( void *ctx, pwr_tAttrRef *attrref, int *is_attr);

};

class ItemEvBase {
  public:
    evlist_eItemType type;
};

class ItemAlarm : public ItemEvBase {
  public:
    ItemAlarm( EvList *evlist, const char *item_name, pwr_tTime item_time,
	const char *item_eventtext, char *item_eventname, int item_eventflags,
	unsigned long item_eventprio, mh_sEventId item_eventid,
	pwr_tAttrRef *item_object, pwr_tAttrRef *item_eventsound, 
        char *item_eventmoretext,unsigned long item_status,
        evlist_eEventType item_event_type, pwr_tAttrRef *item_supobject,
	brow_tNode dest, flow_eDest dest_code, int *rsts);
    evlist_eEventType	event_type;
    EvList		*evlist;
    brow_tNode		node;
    brow_tNode		tree_node;
    char	 	name[40];
    pwr_tTime		time;
    char		eventtext[80];
    pwr_tAName		eventname;
    int			eventflags;
    unsigned long	eventprio;
    mh_sEventId		eventid;
    pwr_tAttrRef       	object;
    unsigned long	status;
    char		alias[40];
    pwr_tAttrRef	eventsound;
    pwr_tText256        eventmoretext;
    pwr_tAttrRef       	supobject;

    void	update_text(int tree_node);
};

class ItemCategory : public ItemEvBase {
  public:
    ItemCategory( EvList *evlist, const char *item_name, pwr_sClass_AlarmCategory *cop,
		  brow_tNode dest, flow_eDest dest_code, int *rsts);
    EvList		*evlist;
    brow_tNode		node;
    char		name[80];
    char	 	text[80];
    unsigned int	prio;
    unsigned int	event_priority;
    pwr_tAName		members[100];
    int			member_cnt;
    brow_tNodeClass 	base_nc;
    int			notacked_child;

    int open_children( EvList *evlist, double x, double y);
    void close( EvList *evlist, double x, double y);
    void configure( EvList *evlist);
    void alarm( EvList *evlist, ItemAlarm *alarm);
    void flash( EvList *evlist);
};

#endif
