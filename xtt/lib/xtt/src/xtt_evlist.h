/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#ifndef xtt_evlist_h
#define xtt_evlist_h

/* xtt_evlist.h -- Alarm and event windows in xtt */

// Status is defined as int i xlib...
#ifdef Status
#undef Status
#endif

#include "pwr_baseclasses.h"

#include "rt_mh.h"
#include "rt_mh_outunit.h"

#include "flow_browapi.h"
#include "flow_browctx.h"

class ItemAlarm;

#define ALARM_TABLE_SIZE 10
typedef pwr_tAName ev_sAlarmTableMembers[200];

typedef enum {
  ev_eType_AlarmList,
  ev_eType_EventList,
  ev_eType_HistList,
  ev_eType_BlockList
} ev_eType;

typedef enum {
  evlist_eEventType_Info,
  evlist_eEventType_InfoSuccess,
  evlist_eEventType_Return,
  evlist_eEventType_Ack,
  evlist_eEventType_Alarm,
  evlist_eEventType_Block,
  evlist_eEventType_Cancel
} evlist_eEventType;

typedef enum {
  evlist_eItemType_Alarm,
  evlist_eItemType_Category
} evlist_eItemType;

typedef enum {
  evlist_mOpen_All = ~0,
  evlist_mOpen_Children = 1 << 0
} evlist_mOpen;

#define ALARM_INFO_A_SIZE 5
#define ALARM_INFO_B_SIZE 2
#define ALARM_INFO_C_SIZE 2
#define ALARM_INFO_D_SIZE 2
#define ALARM_INFO_I_SIZE 2
typedef struct {
  char a_alarm_text[ALARM_INFO_A_SIZE][80];
  char a_alarm_moretext[ALARM_INFO_A_SIZE][256];
  char a_alarm_alias[ALARM_INFO_A_SIZE][40];
  pwr_tTime a_alarm_time[ALARM_INFO_A_SIZE];
  int a_alarm_active[ALARM_INFO_A_SIZE];
  int a_alarm_exist[ALARM_INFO_A_SIZE];
  char b_alarm_text[ALARM_INFO_B_SIZE][80];
  char b_alarm_moretext[ALARM_INFO_B_SIZE][256];
  char b_alarm_alias[ALARM_INFO_B_SIZE][40];
  pwr_tTime b_alarm_time[ALARM_INFO_B_SIZE];
  int b_alarm_active[ALARM_INFO_B_SIZE];
  int b_alarm_exist[ALARM_INFO_B_SIZE];
  char c_alarm_text[ALARM_INFO_C_SIZE][80];
  char c_alarm_moretext[ALARM_INFO_C_SIZE][256];
  char c_alarm_alias[ALARM_INFO_C_SIZE][40];
  pwr_tTime c_alarm_time[ALARM_INFO_C_SIZE];
  int c_alarm_active[ALARM_INFO_C_SIZE];
  int c_alarm_exist[ALARM_INFO_C_SIZE];
  char d_alarm_text[ALARM_INFO_D_SIZE][80];
  char d_alarm_moretext[ALARM_INFO_A_SIZE][256];
  char d_alarm_alias[ALARM_INFO_A_SIZE][40];
  pwr_tTime d_alarm_time[ALARM_INFO_D_SIZE];
  int d_alarm_active[ALARM_INFO_D_SIZE];
  int d_alarm_exist[ALARM_INFO_D_SIZE];
  char i_alarm_text[ALARM_INFO_I_SIZE][80];
  char i_alarm_moretext[ALARM_INFO_I_SIZE][256];
  char i_alarm_alias[ALARM_INFO_I_SIZE][40];
  pwr_tTime i_alarm_time[ALARM_INFO_I_SIZE];
  int i_alarm_active[ALARM_INFO_I_SIZE];
  int i_alarm_exist[ALARM_INFO_I_SIZE];
  evlist_eEventType i_alarm_eventtype[ALARM_INFO_I_SIZE];
  int alarms_total;
  int alarms_notacked;
} evlist_sAlarmInfo;

class EvListBrow {
public:
  EvListBrow(BrowCtx* brow_ctx, void* evl) : ctx(brow_ctx), evlist(evl){}
  ~EvListBrow();

  BrowCtx* ctx;
  void* evlist;
  brow_tNodeClass nc_event;
  brow_tNodeClass nc_a_alarm;
  brow_tNodeClass nc_b_alarm;
  brow_tNodeClass nc_info;
  brow_tNodeClass nc_infosuccess;
  brow_tNodeClass nc_category;
  brow_tNodeClass nc_category_a;
  brow_tNodeClass nc_category_b;
  brow_tNodeClass nc_category_c;
  brow_tNodeClass nc_category_d;
  brow_tNodeClass nc_category_i;
  brow_tNodeClass nc_category_flash;
  flow_sAnnotPixmap* pixmap_leaf;
  flow_sAnnotPixmap* pixmap_map;
  flow_sAnnotPixmap* pixmap_openmap;
  flow_sAnnotPixmap* pixmap_attr;
  flow_sAnnotPixmap* pixmap_attrarray;
  flow_sAnnotPixmap* pixmap_alarm;
  flow_sAnnotPixmap* pixmap_ack;
  flow_sAnnotPixmap* pixmap_eventalarm;
  flow_sAnnotPixmap* pixmap_eventacked;
  flow_sAnnotPixmap* pixmap_eventreturn;
  flow_sAnnotPixmap* pixmap_info;
  flow_sAnnotPixmap* pixmap_maintenance;
  flow_sAnnotPixmap* pixmap_system;
  flow_sAnnotPixmap* pixmap_blockr;
  flow_sAnnotPixmap* pixmap_blockl;

  void free_pixmaps();
  void allocate_pixmaps();
  void create_nodeclasses();
  void brow_setup();
};

class EvList {
public:
  EvList(void* ev_parent_ctx, ev_eType ev_type, int ev_size,
      int ev_eventname_seg, void (*ev_init_cb)(void*) = 0);
  virtual ~EvList();

  void* parent_ctx;
  ev_eType type;
  EvListBrow* brow;
  EvListBrow* browbase;
  EvListBrow* browtree;
  int size;
  int max_size;
  int display_hundredth;
  int hide_object;
  int hide_text;
  void (*start_trace_cb)(void*, pwr_tObjid, char*);
  void (*display_in_xnav_cb)(void*, pwr_tAttrRef*);
  void (*popup_menu_cb)(
      void*, pwr_tAttrRef, unsigned long, unsigned long, char*, int x, int y);
  char* (*name_to_alias_cb)(void*, char*);
  int (*sound_cb)(void*, pwr_tAttrRef*);
  void (*selection_changed_cb)(void*);
  void (*init_cb)(void*);
  void (*help_event_cb)(void*, void*);
  double acc_beep_time;
  double beep_interval;
  pwr_tAttrRef aalarm_sound;
  pwr_tAttrRef balarm_sound;
  pwr_tAttrRef calarm_sound;
  pwr_tAttrRef dalarm_sound;
  pwr_tAttrRef info_sound;
  int eventname_seg;
  pwr_tObjid current_view;
  bool flash_value;
  unsigned int alarm_table_cnt;
  pwr_sClass_AlarmTable* alarm_tables[ALARM_TABLE_SIZE];
  ev_sAlarmTableMembers* alarm_table_members[ALARM_TABLE_SIZE];
  int alarm_table_member_cnt[ALARM_TABLE_SIZE];
  pwr_tRefId alarm_tables_refid[ALARM_TABLE_SIZE];

  virtual void set_input_focus()
  {
  }
  virtual void bell()
  {
  }
  virtual void popup_position(int x_event, int y_event, int* x, int* y)
  {
  }
  virtual void print(const char* title)
  {
  }

  void event_info(mh_sMessage* msg);
  void event_alarm(mh_sMessage* msg);
  void event_block(mh_sBlock* msg);
  void event_cancel(mh_sReturn* msg);
  void event_ack(mh_sAck* msg);
  void event_return(mh_sReturn* msg);
  void event_clear_alarmlist(pwr_tNodeIndex nix);
  int event_delete(mh_sEventId* id);
  int get_num_not_acked();
  int get_last_not_acked(mh_sEventId** id);
  int get_last_not_acked_beep(mh_sEventId** id);
  int id_to_item(mh_sEventId* id, void** item);
  int oid_to_item(pwr_tOid oid, void** item);
  void ack(mh_sEventId* id);
  void zoom(double zoom_factor);
  void unzoom();
  void beep(double scantime);
  void start_trace();
  void display_in_xnav();
  void set_nodraw();
  void reset_nodraw();
  void update_text();
  void set_display_hundredth(int value);
  void set_hide_object(int value);
  void set_hide_text(int value);
  int get_alarm_info(evlist_sAlarmInfo* info, int backward, int alarmsize);
  int get_last_not_acked_prio(mh_sEventId** id, unsigned long type, 
			      unsigned long prio, int backward, int timecheck);
  int get_selected_event(char* eventname, ItemAlarm** item);
  int get_destination(pwr_tTime time, void** dest);
  void block_remove();
  void print_nodia(char* filename);
  pwr_tStatus set_view(pwr_tOid view);
  pwr_tStatus view_init(pwr_tOid view);
  void view_configure();
  void view_alarm(ItemAlarm* alarm_item);
  void flash();
  void copy_list(EvList* evl);
  int get_alarm_tables(pwr_tOid user);
  void fill_alarm_tables();

  static int init_brow_cb(FlowCtx* fctx, void* client_data);
  static int init_browtree_cb(BrowCtx* fctx, void* client_data);
  static int brow_cb(FlowCtx* ctx, flow_tEvent event);
  static int browtree_cb(FlowCtx* ctx, flow_tEvent event);
  static int get_select(void* ctx, pwr_tAttrRef* attrref, int* is_attr);
  static int get_select_supobject(
      void* ctx, pwr_tAttrRef* attrref, int* is_attr);
};

class ItemEvBase {
public:
  evlist_eItemType type;
};

class ItemAlarm : public ItemEvBase {
public:
  ItemAlarm(EvList* evlist, const char* item_name, pwr_tTime item_time,
      const char* item_eventtext, char* item_eventname, int item_eventttype,
      int item_eventflags, unsigned long item_eventprio,
      mh_sEventId item_eventid, pwr_tAttrRef* item_object,
      pwr_tAttrRef* item_eventsound, char* item_eventmoretext,
      unsigned long item_status, evlist_eEventType item_event_type,
      pwr_tAttrRef* item_supobject, brow_tNode dest, flow_eDest dest_code,
      int* rsts);
  evlist_eEventType event_type;
  EvList* evlist;
  brow_tNode node;
  brow_tNode tree_node;
  char name[40];
  pwr_tTime time;
  char eventtext[80];
  pwr_tAName eventname;
  int eventtype;
  int eventflags;
  unsigned long eventprio;
  mh_sEventId eventid;
  pwr_tAttrRef object;
  mh_mEventStatus status;
  char alias[40];
  pwr_tAttrRef eventsound;
  pwr_tText256 eventmoretext;
  pwr_tAttrRef supobject;
  int check;
  pwr_tTime display_time;

  void update_text(int tree_node);
};

class ItemCategory : public ItemEvBase {
public:
  ItemCategory(EvList* evlist, const char* item_name,
      pwr_sClass_AlarmCategory* cop, brow_tNode dest, flow_eDest dest_code,
      int* rsts);
  EvList* evlist;
  brow_tNode node;
  char name[80];
  char text[80];
  unsigned int prio;
  unsigned int select_priority;
  unsigned int select_eventtype;
  pwr_tAName members[100];
  int member_cnt;
  brow_tNodeClass base_nc;
  int notacked_child;

  int open_children(EvList* evlist, double x, double y);
  void close(EvList* evlist, double x, double y);
  void configure(EvList* evlist);
  void alarm(EvList* evlist, ItemAlarm* alarm);
  void flash(EvList* evlist);
};

#endif
