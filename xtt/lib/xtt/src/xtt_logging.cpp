/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* xtt_logging.c

   This module contains routines for handling of logging in xtt. */

/*_Include files_________________________________________________________*/

#include <stdarg.h>
#include <stdlib.h>
#include <pthread.h>

#include "co_cdh.h"
#include "co_ccm_msg.h"
#include "co_dcli.h"
#include "co_string.h"

#include "rt_gdh_msg.h"
#include "rt_xnav_msg.h"

#include "xtt_xnav.h"

static void* xtt_logproc(void* arg);
static int log_ccm_registred = 0;

static int log_errormessage_func(char* msg, int severity, void* data)
{
  ((XttLogging*)data)->message(severity, msg);
  printf("Condition error: %s\n", msg);
  return 1;
}

static int logccm_geta_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  int sts;

  if (arg_count != 1 || arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = gdh_GetObjectInfo(
      arg_list->value_string, return_float, sizeof(*return_float));
  if (EVEN(sts))
    return sts;

  *return_decl = CCM_DECL_FLOAT;
  return 1;
}

static int logccm_getd_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  int sts;

  if (arg_count != 1 || arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = gdh_GetObjectInfo(
      arg_list->value_string, return_int, sizeof(*return_int));
  if (EVEN(sts))
    return sts;

  *return_decl = CCM_DECL_INT;
  return 1;
}

XttLogging::XttLogging()
    : xnav(0), index(0), active(0), intern(0), stop_logg(0),
      logg_type(xtt_LoggType_Cont), logg_priority(0), logg_format(xtt_eLoggFormat_Std), 
      condition_ptr(0), logg_time(200), logg_file(0), line_size(10000), parameter_count(0),
      print_shortname(0), buffer_size(100), wanted_buffer_size(100),
      buffer_count(0), buffer_ptr(0), cond_ccm_ctx(0)
{
  for (int i = 0; i < RTT_LOGG_MAXPAR; i++) {
    parameterstr[i][0] = 0;
    shortname[i][0] = 0;
  }
  memset(parameter_type, 0, sizeof(parameter_type));
  memset(parameter_size, 0, sizeof(parameter_size));
  memset(old_value, 0, sizeof(old_value));

  strcpy(logg_filename, "rtt_logging.rtt_log");
}

void XttLogging::init(int logg_index, void* logg_xnav)
{
  index = logg_index;
  xnav = logg_xnav;
}

XttLogging::~XttLogging()
{
  if (buffer_ptr)
    free(buffer_ptr);
}

/*************************************************************************
*
* Name:		logging_set()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Modify parameter in the logging table.
*
**************************************************************************/

int XttLogging::logging_set(float a_logg_time, char* filename, char* parameter,
    char* condition, int a_logg_type, int a_logg_format, int insert, int a_buffer_size, int stop,
    int priority, int create, int a_line_size, int shortname)
{
  int i, sts;
  int found, par_index = 0;
  char buffer[8];
  char msg[80];
  int type_error;
  pwr_tTypeId atype;
  unsigned int asize, aoffset, aelem;

  if (active) {
    message('E', "Unable to modify entry, entry is started");
    return XNAV__HOLDCOMMAND;
  }

  if (a_buffer_size != 0 || buffer_ptr == 0) {
    if (a_buffer_size != 0) {
      buffer_size = a_buffer_size;
      wanted_buffer_size = a_buffer_size;
    }
    /* Reallocate the buffer to store logging info in */
    if (buffer_ptr != 0)
      free(buffer_ptr);
    buffer_ptr = (char*)calloc(1, buffer_size * 512);
    if (buffer_ptr == 0) {
      message('E', "Buffer is to large");
      /* set default buffer */
      buffer_size = RTT_BUFFER_DEFSIZE;
      wanted_buffer_size = RTT_BUFFER_DEFSIZE;

      /* Reallocate the buffer to store logging info in */
      buffer_ptr = (char*)calloc(1, buffer_size * 512);
      if (buffer_ptr == 0)
        exit(XNAV__NOMEMORY);
    }
  }

  /* Insert in the entry */
  if (filename != NULL) {
    dcli_get_defaultfilename(filename, logg_filename, ".rtt_log");
  }
  if (parameter != NULL) {
    /* Get a free parameter index */
    found = 0;
    for (i = 0; i < RTT_LOGG_MAXPAR; i++) {
      if (parameterstr[i][0] == 0) {
        found = 1;
        par_index = i;
        break;
      }
    }
    if (!found) {
      message('E', "Max number of parameters exceeded");
      return XNAV__HOLDCOMMAND;
    }

    /* Check that parameter exists */
    sts = gdh_GetObjectInfo(parameter, &buffer, sizeof(buffer));
    if (EVEN(sts)) {
      message('E', "Parameter doesn't exist");
      return XNAV__HOLDCOMMAND;
    }

    sts = gdh_GetAttributeCharacteristics(
        parameter, &atype, &asize, &aoffset, &aelem);
    if (EVEN(sts)) {
      message('E', "Parameter doesn't exist");
      return XNAV__HOLDCOMMAND;
    }
    strcpy(parameterstr[par_index], parameter);
    parameter_type[par_index] = atype;
    parameter_size[par_index] = asize / aelem;
  }

  if (condition != NULL) {
    if (str_NoCaseStrncmp(condition, "EXPR(", 5) == 0)
      strcpy(conditionstr, condition);
    else {
      /* Attribute, Check that parameter exists */
      sts = gdh_GetObjectInfo(condition, &buffer, sizeof(buffer));
      if (EVEN(sts)) {
        message('E', "Condition doesn't exist");
        return XNAV__HOLDCOMMAND;
      }
      strcpy(conditionstr, condition);
    }
  }
  if (!feqf(a_logg_time, 0.0f))
    logg_time = a_logg_time;

  if (a_logg_type != 0)
    logg_type = a_logg_type;

  if (a_logg_format >= 0)
    logg_format = (xtt_eLoggFormat)a_logg_format;

  if (priority < -1 || priority > 32) {
    message('E', "Priority out of range");
    return XNAV__HOLDCOMMAND;
  } else if (priority != -1)
    logg_priority = priority;

  if (a_line_size != 0)
    line_size = a_line_size;

  if (shortname != -1)
    print_shortname = shortname;

  if (stop != -1)
    intern = stop;

  if (insert) {
    pwr_sAttrRef *alist, *ap;
    int *is_attrp, *is_attr;
    pwr_tTypeId attr_type;
    unsigned int attr_size, attr_offset, attr_dimension;
    pwr_tAName name;

    /* Insert from collection picture */
    sts = ((XNav*)xnav)->get_all_collect_objects(&alist, &is_attr);
    if (EVEN(sts)) {
      message('E', "Nothing to insert");
      return XNAV__HOLDCOMMAND;
    }

    /* Clear all parameters */
    memset(&(parameterstr), 0, sizeof(parameterstr));

    i = 0;
    type_error = 0;

    ap = alist;
    is_attrp = is_attr;
    while (cdh_ObjidIsNotNull(ap->Objid)) {
      if (*is_attrp) {
        if (i >= RTT_LOGG_MAXPAR) {
          message('E', "Max number of parameters exceeded");
          break;
        }

        sts = gdh_AttrrefToName(ap, name, sizeof(name), cdh_mNName);
        if (EVEN(sts))
          return sts;

        sts = gdh_GetAttributeCharacteristics(
            name, &attr_type, &attr_size, &attr_offset, &attr_dimension);
        if (EVEN(sts)) {
          sts = gdh_AttrrefToName(
              ap, name, sizeof(name), cdh_mName_volumeStrict);
          if (EVEN(sts))
            return sts;

          sts = gdh_GetAttributeCharacteristics(
              name, &attr_type, &attr_size, &attr_offset, &attr_dimension);
          if (EVEN(sts))
            return sts;
        }

        strcpy(parameterstr[i], name);
        parameter_type[i] = attr_type;
        parameter_size[i] = attr_size / attr_dimension;
        switch (parameter_type[i]) {
        case pwr_eType_Float32:
        case pwr_eType_Float64:
        case pwr_eType_UInt8:
        case pwr_eType_Boolean:
        case pwr_eType_Char:
        case pwr_eType_Int8:
        case pwr_eType_Int16:
        case pwr_eType_UInt16:
        case pwr_eType_Int32:
        case pwr_eType_UInt32:
        case pwr_eType_Int64:
        case pwr_eType_UInt64:
        case pwr_eType_String:
        case pwr_eType_Objid:
        case pwr_eType_AttrRef:
        case pwr_eType_Time:
          break;
        default:
          sprintf(
              msg, "Error in parameter nr %d: type is not supported", i + 1);
          message('E', msg);
          type_error = 1;
        }
        i++;
      }
      ap++;
      is_attrp++;
    }
    free(alist);
    free(is_attr);

    if (i < RTT_LOGG_MAXPAR && !type_error)
      message('I', "Parameters copied");
  }

  /* Count the parameters */
  parameter_count = 0;
  for (i = 0; i < RTT_LOGG_MAXPAR; i++) {
    if (parameterstr[i][0] != 0)
      parameter_count++;
  }

  return XNAV__SUCCESS;
}

/*************************************************************************
*
* Name:		rtt_logging_show()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Show the entry.
*
**************************************************************************/

int XttLogging::show()
{
  char* buff;
  int buff_cnt;

  buff = (char*)calloc(1, 120000);
  if (buff == 0)
    return XNAV__NOMEMORY;
  buff_cnt = 0;
  show_entry(buff, &buff_cnt);
  printf("%s", buff);
  free(buff);

  return 1;
}

int XttLogging::show_entry(char* buff, int* buff_cnt)
{
  int i;
  int par_cnt;

  (*buff_cnt) += sprintf(buff + *buff_cnt, "   Entry:     %d", index + 1);

  if (active)
    (*buff_cnt) += sprintf(buff + *buff_cnt, "       ACTIVE\n");
  else
    (*buff_cnt) += sprintf(buff + *buff_cnt, "       NOT ACTIVE\n");

  if (logg_type == xtt_LoggType_Mod)
    (*buff_cnt) += sprintf(buff + *buff_cnt, "   Type:      Event\n");
  else if (logg_type == xtt_LoggType_Cont)
    (*buff_cnt) += sprintf(buff + *buff_cnt, "   Type:      Cont\n");

  (*buff_cnt)
      += sprintf(buff + *buff_cnt, "   Time:      %5.1f ms\n", logg_time);
  (*buff_cnt)
      += sprintf(buff + *buff_cnt, "   Buffer:    %d pages\n", buffer_size);
  (*buff_cnt) += sprintf(buff + *buff_cnt, "   Priority:  %d\n", logg_priority);
  (*buff_cnt) += sprintf(buff + *buff_cnt, "   Line size: %d\n", line_size);
  if (intern)
    (*buff_cnt) += sprintf(buff + *buff_cnt, "   Stop when buffer is full\n");
  (*buff_cnt) += sprintf(buff + *buff_cnt, "   Filename:  %s\n", logg_filename);
  (*buff_cnt) += sprintf(
      buff + *buff_cnt, "   Number of parameters: %d\n", parameter_count);
  par_cnt = 0;
  for (i = 0; i < RTT_LOGG_MAXPAR; i++) {
    if (parameterstr[i][0] != 0) {
      par_cnt++;
      (*buff_cnt) += sprintf(buff + *buff_cnt, "Parameter%d :	%s\n", par_cnt,
          parameterstr[i]);
    }
  }
  (*buff_cnt) += sprintf(buff + *buff_cnt, "Condition:	%s\n", conditionstr);
  (*buff_cnt) += sprintf(buff + *buff_cnt, "\n");

  return XNAV__SUCCESS;
}

/*************************************************************************
*
* Name:		rtt_logging_analyse()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Analyse an entry.
*
**************************************************************************/

int XttLogging::analyse()
{
  pwr_tCmd cmd;

  if (logg_format != xtt_eLoggFormat_Py) {
    message('E', "File format has to be \"Py\"");
    return XNAV__HOLDCOMMAND;
  }

  sprintf( cmd, "sev_analyse.py -f %s &", logg_filename);
  system(cmd);
  return 1;
}

/*************************************************************************
*
* Name:		rtt_logging_store_entry()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Store one entry.
*
**************************************************************************/

int XttLogging::store(char* filename)
{
  int i;
  pwr_tFileName filename_str;
  FILE* outfile;
  char msg[pwr_cSizFileName+15];
  int found_parameter;

  found_parameter = 0;
  for (i = 0; i < RTT_LOGG_MAXPAR; i++) {
    if (parameterstr[i][0] != 0)
      found_parameter++;
  }
  if (!found_parameter) {
    message('E', "No parameters found in Logging entry");
    return XNAV__SUCCESS;
  }

  dcli_get_defaultfilename(filename, filename_str, ".rtt_com");

  outfile = fopen(filename_str, "w");
  if (outfile == 0) {
    char tmp[280];
    snprintf(tmp, sizeof(tmp), "Unable to open file \"%s\"", filename_str);
    message('E', tmp);
    return XNAV__HOLDCOMMAND;
  }

  fprintf(
      outfile, "logging set/create/entry=current/file=\"%s\"\n", logg_filename);
  fprintf(outfile, "logging delete/entry=current/all\n");
  if (!feqf(logg_time, 0.0f))
    fprintf(outfile, "logging set/entry=current/time=%f\n", logg_time);
  fprintf(outfile, "logging set/entry=current/buffer=%d\n", wanted_buffer_size);
  fprintf(outfile, "logging set/entry=current/line_size=%d\n", line_size);
  fprintf(outfile, "logging set/entry=current/priority=%d\n", logg_priority);
  if (print_shortname)
    fprintf(outfile, "logging set/entry=current/shortname\n");
  else
    fprintf(outfile, "logging set/entry=current/noshortname\n");

  if (logg_type == xtt_LoggType_Mod)
    fprintf(outfile, "logging set/entry=current/type=event\n");
  else if (logg_type == xtt_LoggType_Cont)
    fprintf(outfile, "logging set/entry=current/type=cont\n");

  if (logg_format == xtt_eLoggFormat_Std)
    fprintf(outfile, "logging set/entry=current/format=std\n");
  else if (logg_format == xtt_eLoggFormat_Py)
    fprintf(outfile, "logging set/entry=current/format=py\n");

  for (i = 0; i < RTT_LOGG_MAXPAR; i++) {
    if (parameterstr[i][0] != 0)
      fprintf(outfile, "logging set/entry=current/parameter=\"%s\"\n",
          parameterstr[i]);
  }
  if (conditionstr[0] != 0) {
    pwr_tCmd cond;
    char *s, *t;

    // Replace " with \"
    for (s = conditionstr, t = cond; *s; s++) {
      if (*s == '"') {
        *t = '\\';
        t++;
      }
      *t = *s;
      t++;
    }
    *t = 0;

    fprintf(outfile, "logging set/entry=current/condition=\"%s\"\n", cond);
  }
  if (intern)
    fprintf(outfile, "logging set/entry=current/stop\n");
  else
    fprintf(outfile, "logging set/entry=current/nostop\n");

  dcli_fgetname(outfile, filename_str, filename_str);
  fclose(outfile);

  sprintf(msg, "%s created", filename_str);
  message('I', msg);
  return XNAV__SUCCESS;
}

/*************************************************************************
*
* Name:		rtt_logging_start()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Start the entry.
*
**************************************************************************/

int XttLogging::start()
{
  int sts;
  int i, found;
  char msg[256];

  if (active) {
    message('E', "Entry is already started");
    return XNAV__HOLDCOMMAND;
  }

  if (wanted_buffer_size != buffer_size || buffer_ptr == 0) {
    // Reallocate
    if (buffer_ptr != 0)
      free(buffer_ptr);
    buffer_ptr = (char*)calloc(1, wanted_buffer_size * 512);
    if (buffer_ptr == 0)
      exit(XNAV__NOMEMORY);

    buffer_size = wanted_buffer_size;
  }

  /* Get the parameters */
  found = 0;
  for (i = 0; i < RTT_LOGG_MAXPAR; i++) {
    if (parameterstr[i][0] != 0) {
      found = 1;

      sts = gdh_RefObjectInfo(parameterstr[i], (pwr_tAddress*)&parameter_ptr[i],
          &(parameter_subid[i]), parameter_size[i]);
      if (EVEN(sts)) {
        message('E', "Parameter not found");
        return XNAV__HOLDCOMMAND;
      }
    }
  }
  if (!found) {
    message('E', "Parameter is missing");
    return XNAV__HOLDCOMMAND;
  }

  /* Get the condition */
  if (conditionstr[0] != 0) {
    if (str_NoCaseStrncmp(conditionstr, "EXPR(", 5) == 0) {
      pwr_tCmd expr;

      strncpy(expr, &conditionstr[5], sizeof(expr));
      char* s = strrchr(expr, ')');
      if (!s) {
        message('E', "Condition expression syntax error");
        return XNAV__HOLDCOMMAND;
      }
      *s = 0;

      if (!log_ccm_registred) {
        sts = ccm_register_function("Logging", "GetA", logccm_geta_func);
        if (EVEN(sts))
          return sts;
        sts = ccm_register_function("Logging", "GetD", logccm_getd_func);
        if (EVEN(sts))
          return sts;
        sts = ccm_register_function("Logging", "GetI", logccm_getd_func);
        if (EVEN(sts))
          return sts;
        log_ccm_registred = 1;
      }

      sts = ccm_singleline_init(
          &cond_ccm_ctx, expr, log_errormessage_func, this);
      if (EVEN(sts)) {
        message('E', "Condition expression syntax error");
        return XNAV__HOLDCOMMAND;
      }
      condition_ptr = 0;
    } else {
      sts = gdh_RefObjectInfo(
          conditionstr, (pwr_tAddress*)&condition_ptr, &(condition_subid), 1);
      if (EVEN(sts)) {
        condition_ptr = 0;
        message('E', "Condition parameter not found");
        return XNAV__HOLDCOMMAND;
      }
      cond_ccm_ctx = 0;
    }
  } else {
    condition_ptr = 0;
    cond_ccm_ctx = 0;
  }

  /* Open the file */
  if (logg_filename[0] != 0) {
    logg_file = fopen(logg_filename, "w");
    if (logg_file == 0) {
      message('E', "Unable to open file");
      return XNAV__HOLDCOMMAND;
    }
  } else {
    message('E', "File is missing");
    return XNAV__HOLDCOMMAND;
  }

  /* Check time */
  if (feqf(logg_time, 0.0f)) {
    message('E', "Time is missing");
    return XNAV__HOLDCOMMAND;
  }

  /* Clear buffer */
  buffer_count = 0;
  *(buffer_ptr) = 0;

  active = 1;
  stop_logg = 0;

/* Create a subprocess */
  sts = pthread_create(&thread, NULL, /* attr */
      xtt_logproc, /* start_routine */
      (void*)this); /* arg */
  if (sts != 0)
    return sts;

  strcpy(msg, "Logg start ");
  dcli_fgetname(logg_file, msg + strlen(msg), logg_filename);
  message('I', msg);
  return XNAV__SUCCESS;
}
/*************************************************************************
*
* Name:		rtt_logging_stop()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Stop the entry.
*
**************************************************************************/

int XttLogging::stop()
{
  if (!active) {
    message('E', "Entry is already stopped");
    return XNAV__HOLDCOMMAND;
  }

  entry_stop();

  message('I', "Logging stopped");
  return XNAV__SUCCESS;
}

/*************************************************************************
*
* Name:		entry_stop()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Stop the entry.
*
**************************************************************************/

int XttLogging::entry_stop()
{
  int i;
  int sts;

  /* This will stop the subprocess */
  // active = 0;
  stop_logg = 1;

  /* Unref from gdh */
  for (i = 0; i < RTT_LOGG_MAXPAR; i++) {
    if (parameterstr[i][0] != 0) {
      sts = gdh_UnrefObjectInfo(parameter_subid[i]);
    }
  }
  if (condition_ptr != 0) {
    sts = gdh_UnrefObjectInfo(condition_subid);
    condition_ptr = 0;
  }
  if (cond_ccm_ctx != 0) {
    ccm_singleline_free(cond_ccm_ctx);
    cond_ccm_ctx = 0;
  }

  return XNAV__SUCCESS;
}

/*************************************************************************
*
* Name:		rtt_logging_delete()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Delete the entry.
*
**************************************************************************/

int XttLogging::remove(char* parameter)
{
  int i;
  int found = 0;

  if (parameter) {
    /* Remove this parameter */
    found = 0;
    for (i = 0; i < RTT_LOGG_MAXPAR; i++) {
      if (str_NoCaseStrcmp(parameterstr[i], parameter) == 0) {
        /* Parmeter is found, remove it */
        parameterstr[i][0] = 0;
        message('I', "Parameter removed");
        found = 1;
        break;
      }
    }
  }
  if (!found) {
    message('E', "Parameter not found");
    return XNAV__HOLDCOMMAND;
  } else {
    /* Clear all parameters */
    for (i = 0; i < RTT_LOGG_MAXPAR; i++)
      parameterstr[i][0] = 0;
  }

  return XNAV__SUCCESS;
}

/*************************************************************************
*
* Name:		xtt_logproc()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Logging subprocess.
*
**************************************************************************/

static void* xtt_logproc(void* arg)
{
  int sts;
  int i, j, k;
  int char_cnt;
  pwr_tTime time;
  pwr_tDeltaTime timediff;
  char time_str[80];
  float time_float;
  char* value_ptr;
  char* old_value_ptr;
  int first_scan;
  pwr_tObjid objid;
  pwr_sAttrRef* attrref;
  pwr_tAName hiername;
  char timstr[64];
  char parname[40];
  char* s;
  ccm_tInt cond;
  pwr_tTime nextime;
  pwr_tTime restime;
  pwr_tDeltaTime deltatime;
  pwr_tDeltaTime wait_time;
  XttLogging* logg = (XttLogging*)arg;

  char_cnt = 0;
  first_scan = 1;

  time_GetTime(&nextime);

  logg->starttime = nextime;

  /* Print starttime and logged parameters on the file */
  time_AtoAscii(
      &logg->starttime, time_eFormat_DateAndTime, time_str, sizeof(time_str));

  switch (logg->logg_type) {
  case xtt_LoggType_Cont:
    switch (logg->logg_format) {
    case xtt_eLoggFormat_Py:
      if (logg->logg_file)
	char_cnt += fprintf(logg->logg_file, "Time");
      break;
    default:
      if (logg->logg_file)
	char_cnt += fprintf(logg->logg_file, "\"%s\"", time_str);
    }    
    /* Find a unique shortname for each parameter */
    for (i = 0; i < RTT_LOGG_MAXPAR; i++) {
      if (logg->print_shortname) {
        if (logg->parameterstr[i][0] != 0) {
          /* Print only last segment and not ActualValue */
          xnav_cut_segments(logg->shortname[i], logg->parameterstr[i], 1);
          if ((s = strchr(logg->shortname[i], '.')) != 0) {
            str_ToUpper(parname, s + 1);
            if (streq(parname, "ACTUALVALUE"))
              *s = 0;
          }
          /* Check that this name is unique */
          for (j = 0; j < RTT_LOGG_MAXPAR; j++) {
            if (j != i && !strcmp(logg->shortname[i], logg->shortname[j])) {
              for (k = 2; k < 7; k++) {
                /* Increase number of segments */
                xnav_cut_segments(logg->shortname[i], logg->parameterstr[i], k);
                if ((s = strchr(logg->shortname[i], '.')) != 0) {
                  str_ToUpper(parname, s + 1);
                  if (streq(parname, "ACTUALVALUE"))
                    *s = 0;
                }
                xnav_cut_segments(logg->shortname[j], logg->parameterstr[j], k);
                if ((s = strchr(logg->shortname[j], '.')) != 0) {
                  str_ToUpper(parname, s + 1);
                  if (streq(parname, "ACTUALVALUE"))
                    *s = 0;
                }
                if (strcmp(logg->shortname[i], logg->shortname[j]))
                  break;
              }
            }
          }
        }
      } else
        strcpy(logg->shortname[i], logg->parameterstr[i]);
    }
    for (i = 0; i < RTT_LOGG_MAXPAR; i++) {
      if (logg->parameterstr[i][0] != 0) {
        if (logg->logg_file) {
	  switch (logg->logg_format) {
	  case xtt_eLoggFormat_Py:
	    char_cnt += fprintf(logg->logg_file, ",%s", logg->shortname[i]);
	    break;
	  default:
	    char_cnt += fprintf(logg->logg_file, "	%s", logg->shortname[i]);
	    if (char_cnt + 120 > logg->line_size) {
	      fprintf(logg->logg_file, "\n");
	      char_cnt = 0;	      
	    }
	  }
        }
      }
    }
    if (logg->logg_file) {
      fprintf(logg->logg_file, "\n");
      char_cnt = 0;
    }
    break;

  case xtt_LoggType_Mod:
    if (logg->logg_file)
      fprintf(logg->logg_file, "RTT LOGGING STARTED AT %s\n", time_str);
    for (i = 0; i < RTT_LOGG_MAXPAR; i++) {
      if (logg->parameterstr[i][0] != 0) {
        if (logg->logg_file)
          fprintf(logg->logg_file, "Parameter: %s\n", logg->parameterstr[i]);
      }
    }
    break;
  }

  time_FloatToD(&deltatime, logg->logg_time / 1000);

  if (logg->logg_priority != 0)
    sts = logg->set_prio(logg->logg_priority);

  for (;;) {
    /* Calculation of starttime for next loop */
    time_Aadd(&restime, &nextime, &deltatime);
    nextime = restime;

    if (logg->condition_ptr || logg->cond_ccm_ctx) {
      if (logg->active && !logg->stop_logg) {
        if (logg->condition_ptr)
          cond = *logg->condition_ptr;
        else {
          sts = ccm_singleline_exec_int(logg->cond_ccm_ctx, &cond);
          if (EVEN(sts)) {
            logg->message(' ', XNav::get_message(sts));
            cond = 0;
          }
        }

        if (!cond) {
/*  Don't log, wait until next scan */
          time_GetTime(&time);
          time_Adiff(&wait_time, &nextime, &time);

          struct timespec wait_time_ts;
          wait_time_ts.tv_sec = wait_time.tv_sec;
          wait_time_ts.tv_nsec = wait_time.tv_nsec;
          nanosleep(&wait_time_ts, NULL);
          continue;
        }
      }
    }

    time_GetTime(&time);
    switch (logg->logg_type) {
    case xtt_LoggType_Cont:
      /* Convert time to seconds since start */
      time_Adiff(&timediff, &time, &logg->starttime);
      time_float = time_DToFloat(NULL, &timediff);

      /* fix */
      if (first_scan)
        time_float = 0.;
      /* Print time and the value of the parameter on the file */
      switch (logg->logg_format) {
      case xtt_eLoggFormat_Py:
	time_AtoAscii(&time, time_eFormat_NumDateAndTime, time_str, sizeof(time_str));	
	char_cnt += logg->log_print("%s", time_str);
	break;
      default:
	char_cnt += logg->log_print("%12.4f", time_float);
      }
      for (i = 0; i < RTT_LOGG_MAXPAR; i++) {
        if (logg->parameterstr[i][0] != 0) {
          value_ptr = logg->parameter_ptr[i];
          switch (logg->parameter_type[i]) {
          case pwr_eType_Float32:
	    switch (logg->logg_format) {
	    case xtt_eLoggFormat_Py:
	      char_cnt += logg->log_print(",%f", *(pwr_tFloat32*)value_ptr);
	      break;
	    default:
	      char_cnt += logg->log_print("	%f", *(pwr_tFloat32*)value_ptr);
	    }
            break;

          case pwr_eType_Float64:
	    switch (logg->logg_format) {
	    case xtt_eLoggFormat_Py:
	      char_cnt += logg->log_print(",%f", *(pwr_tFloat64*)value_ptr);
	      break;
	    default:
	      char_cnt += logg->log_print("	%f", *(pwr_tFloat64*)value_ptr);
	    }
            break;

          case pwr_eType_UInt8:
	    switch (logg->logg_format) {
	    case xtt_eLoggFormat_Py:
	      char_cnt += logg->log_print(",%d", *(pwr_tUInt8*)value_ptr);
	      break;
	    default:
	      char_cnt += logg->log_print("	%d", *(pwr_tUInt8*)value_ptr);
	    }
            break;
          case pwr_eType_Boolean:
	    switch (logg->logg_format) {
	    case xtt_eLoggFormat_Py:
	      char_cnt += logg->log_print(",%d", *(pwr_tBoolean*)value_ptr);
	      break;
	    default:
	      char_cnt += logg->log_print("	%d", *(pwr_tBoolean*)value_ptr);
	    }
            break;
          case pwr_eType_Char:
	    switch (logg->logg_format) {
	    case xtt_eLoggFormat_Py:
	      char_cnt += logg->log_print(",%c", *(pwr_tChar*)value_ptr);
	      break;
	    default:
	      char_cnt += logg->log_print("	%c", *(pwr_tChar*)value_ptr);
	    }
            break;
          case pwr_eType_Int8:
	    switch (logg->logg_format) {
	    case xtt_eLoggFormat_Py:
	      char_cnt += logg->log_print(",%d", *(pwr_tInt8*)value_ptr);
	      break;
	    default:
	      char_cnt += logg->log_print("	%d", *(pwr_tInt8*)value_ptr);
	    }
            break;
          case pwr_eType_Int16:
	    switch (logg->logg_format) {
	    case xtt_eLoggFormat_Py:
	      char_cnt += logg->log_print(",%d", *(pwr_tInt16*)value_ptr);
	      break;
	    default:
	      char_cnt += logg->log_print("	%d", *(pwr_tInt16*)value_ptr);
	    }
            break;
          case pwr_eType_UInt16:
	    switch (logg->logg_format) {
	    case xtt_eLoggFormat_Py:
	      char_cnt += logg->log_print(",%d", *(pwr_tUInt16*)value_ptr);
	      break;
	    default:
	      char_cnt += logg->log_print("	%d", *(pwr_tUInt16*)value_ptr);
	    }
            break;
          case pwr_eType_Int32:
	    switch (logg->logg_format) {
	    case xtt_eLoggFormat_Py:
	      char_cnt += logg->log_print(",%d", *(pwr_tInt32*)value_ptr);
	      break;
	    default:
	      char_cnt += logg->log_print("	%d", *(pwr_tInt32*)value_ptr);
	    }
            break;
          case pwr_eType_UInt32:
	    switch (logg->logg_format) {
	    case xtt_eLoggFormat_Py:
	      char_cnt += logg->log_print(",%d", *(pwr_tUInt32*)value_ptr);
	      break;
	    default:
	      char_cnt += logg->log_print("	%d", *(pwr_tUInt32*)value_ptr);
	    }
            break;
          case pwr_eType_Int64:
	    switch (logg->logg_format) {
	    case xtt_eLoggFormat_Py:
	      char_cnt += logg->log_print(",%lld", *(pwr_tInt64*)value_ptr);
	      break;
	    default:
	      char_cnt += logg->log_print("	%lld", *(pwr_tInt64*)value_ptr);
	    }
            break;
          case pwr_eType_UInt64:
	    switch (logg->logg_format) {
	    case xtt_eLoggFormat_Py:
	      char_cnt += logg->log_print(",%llu", *(pwr_tUInt64*)value_ptr);
	      break;
	    default:
	      char_cnt += logg->log_print("	%llu", *(pwr_tUInt64*)value_ptr);
	    }
            break;
          case pwr_eType_String:
	    switch (logg->logg_format) {
	    case xtt_eLoggFormat_Py:
	      char_cnt += logg->log_print(",%s", value_ptr);
	      break;
	    default:
	      char_cnt += logg->log_print("	%s", value_ptr);
	    }
            break;
          case pwr_eType_Objid:
            objid = *(pwr_tObjid*)value_ptr;
            if (!objid.oix)
              sts = gdh_ObjidToName(
                  objid, hiername, sizeof(hiername), cdh_mName_volumeStrict);
            else
              sts = gdh_ObjidToName(
                  objid, hiername, sizeof(hiername), cdh_mNName);
            if (EVEN(sts))
              strcpy(hiername, "** Unknown objid");
	    switch (logg->logg_format) {
	    case xtt_eLoggFormat_Py:
	      char_cnt += logg->log_print(",%s", hiername);
	      break;
	    default:
	      char_cnt += logg->log_print("	%s", hiername);
	    }
            break;
          case pwr_eType_AttrRef:
            attrref = (pwr_sAttrRef*)value_ptr;
            sts = gdh_AttrrefToName(
                attrref, hiername, sizeof(hiername), cdh_mNName);
            if (EVEN(sts))
              strcpy(hiername, "** Unknown attrref");
	    switch (logg->logg_format) {
	    case xtt_eLoggFormat_Py:
	      char_cnt += logg->log_print(",%s", hiername);
	      break;
	    default:
	      char_cnt += logg->log_print("	%s", hiername);
	    }
            break;
          case pwr_eType_Time:
            sts = time_AtoAscii((pwr_tTime*)value_ptr, time_eFormat_DateAndTime,
                timstr, sizeof(timstr));
            if (EVEN(sts))
              strcpy(timstr, "Undefined time");
	    switch (logg->logg_format) {
	    case xtt_eLoggFormat_Py:
	      char_cnt += logg->log_print(",%s", timstr);
	      break;
	    default:
	      char_cnt += logg->log_print("	%s", timstr);
	    }
            break;
          case pwr_eType_DeltaTime:
            sts = time_DtoAscii(
                (pwr_tDeltaTime*)value_ptr, 1, timstr, sizeof(timstr));
            if (EVEN(sts))
              strcpy(timstr, "Undefined time");
	    switch (logg->logg_format) {
	    case xtt_eLoggFormat_Py:
	      char_cnt += logg->log_print(",%s", timstr);
	      break;
	    default:
	      char_cnt += logg->log_print("	%s", timstr);
	    }
            break;
          default:
	    switch (logg->logg_format) {
	    case xtt_eLoggFormat_Py:
	      char_cnt += logg->log_print(",%s", "Type error");
	      break;
	    default:
	      char_cnt += logg->log_print("	%s", "Type error");
	    }
          }
          if (char_cnt + 10 > logg->line_size) {
	    switch (logg->logg_format) {
	    case xtt_eLoggFormat_Py:
	      break;
	    default:
	      logg->log_print("\n");
	      char_cnt = 0;
	    }
          }
        }
      }
      logg->log_print("\n");
      char_cnt = 0;

      break;

    case xtt_LoggType_Mod:
      /* Write only if value is changed */
      for (i = 0; i < RTT_LOGG_MAXPAR; i++) {
        if (logg->parameterstr[i][0] != 0) {
          value_ptr = logg->parameter_ptr[i];
          old_value_ptr = (char*)&logg->old_value[i];
          switch (logg->parameter_type[i]) {
          case pwr_eType_Float32:
            if ((!feqf(*(pwr_tFloat32*)value_ptr, *(pwr_tFloat32*)old_value_ptr))
                || first_scan) {
              /* Value is changed, print */
              time_AtoAscii(
                  &time, time_eFormat_DateAndTime, time_str, sizeof(time_str));
              logg->log_print("%s", &time_str);
              logg->log_print("	%s", &(logg->parameterstr[i]));
              logg->log_print("	%f\n", *(pwr_tFloat32*)value_ptr);
              *(pwr_tFloat32*)old_value_ptr = *(pwr_tFloat32*)value_ptr;
            }
            break;

          case pwr_eType_Float64:
            if ((!feq(*(pwr_tFloat64*)value_ptr, *(pwr_tFloat64*)old_value_ptr))
                || first_scan) {
              logg->log_print("	%s", &(logg->parameterstr[i]));
              logg->log_print("	%f\n", *(pwr_tFloat64*)value_ptr);
              *(pwr_tFloat64*)old_value_ptr = *(pwr_tFloat64*)value_ptr;
            }
            break;

          case pwr_eType_Boolean:
            if ((*(pwr_tBoolean*)value_ptr != *(pwr_tBoolean*)old_value_ptr)
                || first_scan) {
              /* Value is changed, print */
              time_AtoAscii(
                  &time, time_eFormat_DateAndTime, time_str, sizeof(time_str));
              logg->log_print("%s", &time_str);
              logg->log_print("	%s", &(logg->parameterstr[i]));
              logg->log_print("	%d\n", *(pwr_tBoolean*)value_ptr);
              *(pwr_tBoolean*)old_value_ptr = *(pwr_tBoolean*)value_ptr;
            }
            break;
          case pwr_eType_Char:
            if ((*(pwr_tChar*)value_ptr != *(pwr_tChar*)old_value_ptr)
                || first_scan) {
              /* Value is changed, print */
              time_AtoAscii(
                  &time, time_eFormat_DateAndTime, time_str, sizeof(time_str));
              logg->log_print("%s", &time_str);
              logg->log_print("	%s", &(logg->parameterstr[i]));
              logg->log_print("	%c\n", *(pwr_tChar*)value_ptr);
              *(pwr_tChar*)old_value_ptr = *(pwr_tChar*)value_ptr;
            }
            break;
          case pwr_eType_UInt8:
            if ((*(pwr_tUInt8*)value_ptr != *(pwr_tUInt8*)old_value_ptr)
                || first_scan) {
              /* Value is changed, print */
              time_AtoAscii(
                  &time, time_eFormat_DateAndTime, time_str, sizeof(time_str));
              logg->log_print("%s", &time_str);
              logg->log_print("	%s", &(logg->parameterstr[i]));
              logg->log_print("	%d\n", *(pwr_tUInt8*)value_ptr);
              *(pwr_tUInt8*)old_value_ptr = *(pwr_tUInt8*)value_ptr;
            }
            break;
          case pwr_eType_Int8:
            if ((*(pwr_tInt8*)value_ptr != *(pwr_tInt8*)old_value_ptr)
                || first_scan) {
              /* Value is changed, print */
              time_AtoAscii(
                  &time, time_eFormat_DateAndTime, time_str, sizeof(time_str));
              logg->log_print("%s", &time_str);
              logg->log_print("	%s", &(logg->parameterstr[i]));
              logg->log_print("	%d\n", *value_ptr);
              *(pwr_tInt8*)old_value_ptr = *(pwr_tInt8*)value_ptr;
            }
            break;
          case pwr_eType_UInt16:
            if ((*(pwr_tUInt16*)value_ptr != *(pwr_tUInt16*)old_value_ptr)
                || first_scan) {
              /* Value is changed, print */
              time_AtoAscii(
                  &time, time_eFormat_DateAndTime, time_str, sizeof(time_str));
              logg->log_print("%s", &time_str);
              logg->log_print("	%s", &(logg->parameterstr[i]));
              logg->log_print("	%d\n", *(pwr_tUInt16*)value_ptr);
              *(pwr_tUInt16*)old_value_ptr = *(pwr_tUInt16*)value_ptr;
            }
            break;
          case pwr_eType_Int16:
            if ((*(pwr_tInt16*)value_ptr != *(pwr_tInt16*)old_value_ptr)
                || first_scan) {
              /* Value is changed, print */
              time_AtoAscii(
                  &time, time_eFormat_DateAndTime, time_str, sizeof(time_str));
              logg->log_print("%s", &time_str);
              logg->log_print("	%s", &(logg->parameterstr[i]));
              logg->log_print("	%d\n", *(pwr_tInt16*)value_ptr);
              *(pwr_tInt16*)old_value_ptr = *(pwr_tInt16*)value_ptr;
            }
            break;
          case pwr_eType_UInt32:
            if ((*(pwr_tUInt32*)value_ptr != *(pwr_tUInt32*)old_value_ptr)
                || first_scan) {
              /* Value is changed, print */
              time_AtoAscii(
                  &time, time_eFormat_DateAndTime, time_str, sizeof(time_str));
              logg->log_print("%s", &time_str);
              logg->log_print("	%s", &(logg->parameterstr[i]));
              logg->log_print("	%d\n", *(pwr_tUInt32*)value_ptr);
              *(pwr_tUInt32*)old_value_ptr = *(pwr_tUInt32*)value_ptr;
            }
            break;
          case pwr_eType_Int32:
            if ((*(pwr_tInt32*)value_ptr != *(pwr_tInt32*)old_value_ptr)
                || first_scan) {
              /* Value is changed, print */
              time_AtoAscii(
                  &time, time_eFormat_DateAndTime, time_str, sizeof(time_str));
              logg->log_print("%s", &time_str);
              logg->log_print("	%s", &(logg->parameterstr[i]));
              logg->log_print("	%d\n", *(pwr_tInt32*)value_ptr);
              *(pwr_tInt32*)old_value_ptr = *(pwr_tInt32*)value_ptr;
            }
            break;
          case pwr_eType_UInt64:
            if ((*(pwr_tUInt64*)value_ptr != *(pwr_tUInt64*)old_value_ptr)
                || first_scan) {
              /* Value is changed, print */
              time_AtoAscii(
                  &time, time_eFormat_DateAndTime, time_str, sizeof(time_str));
              logg->log_print("%s", &time_str);
              logg->log_print("	%s", &(logg->parameterstr[i]));
              logg->log_print("	%llu\n", *(pwr_tUInt64*)value_ptr);
              *(pwr_tUInt64*)old_value_ptr = *(pwr_tUInt64*)value_ptr;
            }
            break;
          case pwr_eType_String:
            if (strncmp(value_ptr, old_value_ptr, sizeof(logg->old_value[0]))
                    != 0
                || first_scan) {
              /* Value is changed, print */
              time_AtoAscii(
                  &time, time_eFormat_DateAndTime, time_str, sizeof(time_str));
              logg->log_print("%s", &time_str);
              logg->log_print("	%s", &(logg->parameterstr[i]));
              logg->log_print("	%s\n", value_ptr);
              strncpy(old_value_ptr, value_ptr, sizeof(logg->old_value[0]));
            }
            break;
          case pwr_eType_Objid:
            if (memcmp(value_ptr, old_value_ptr, sizeof(pwr_tObjid)) != 0
                || first_scan) {
              /* Value is changed, print */
              objid = *(pwr_tObjid*)value_ptr;
              if (!objid.oix)
                sts = gdh_ObjidToName(
                    objid, hiername, sizeof(hiername), cdh_mName_volumeStrict);
              else
                sts = gdh_ObjidToName(
                    objid, hiername, sizeof(hiername), cdh_mNName);
              if (EVEN(sts))
                strcpy(hiername, "** Unknown objid");
              time_AtoAscii(
                  &time, time_eFormat_DateAndTime, time_str, sizeof(time_str));
              logg->log_print("%s", &time_str);
              logg->log_print("	%s", &(logg->parameterstr[i]));
              logg->log_print("	%s\n", hiername);
              memcpy(old_value_ptr, value_ptr, sizeof(pwr_tObjid));
            }
            break;
          case pwr_eType_AttrRef:
            attrref = (pwr_sAttrRef*)value_ptr;
            /* There is only space for the objid of the attrref in oldvalue ..
             */
            if (memcmp(
                    (char*)&attrref->Objid, old_value_ptr, sizeof(pwr_tObjid))
                    != 0
                || first_scan) {
              /* At least the objid is changed */
              sts = gdh_AttrrefToName(
                  attrref, hiername, sizeof(hiername), cdh_mNName);
              if (EVEN(sts))
                strcpy(hiername, "** Unknown attrref");
              time_AtoAscii(
                  &time, time_eFormat_DateAndTime, time_str, sizeof(time_str));
              logg->log_print("%s", &time_str);
              logg->log_print("	%s", &(logg->parameterstr[i]));
              logg->log_print("	%s\n", hiername);
              memcpy(old_value_ptr, (char*)&attrref->Objid, sizeof(pwr_tObjid));
            }
            break;
          case pwr_eType_Time:
            if (memcmp(value_ptr, old_value_ptr, sizeof(pwr_tTime)) != 0
                || first_scan) {
              /* Value is changed, print */
              sts = time_AtoAscii((pwr_tTime*)value_ptr,
                  time_eFormat_DateAndTime, timstr, sizeof(timstr));
              if (EVEN(sts))
                strcpy(timstr, "Undefined time");

              time_AtoAscii(
                  &time, time_eFormat_DateAndTime, time_str, sizeof(time_str));
              logg->log_print("%s", &time_str);
              logg->log_print("	%s", &(logg->parameterstr[i]));
              logg->log_print("	%s\n", timstr);
              memcpy(old_value_ptr, value_ptr, sizeof(pwr_tTime));
            }
            break;
          case pwr_eType_DeltaTime:
            if (memcmp(value_ptr, old_value_ptr, sizeof(pwr_tTime)) != 0
                || first_scan) {
              /* Value is changed, print */
              sts = time_DtoAscii(
                  (pwr_tDeltaTime*)value_ptr, 1, timstr, sizeof(timstr));
              if (EVEN(sts))
                strcpy(timstr, "Undefined time");

              time_AtoAscii(
                  &time, time_eFormat_DateAndTime, time_str, sizeof(time_str));
              logg->log_print("%s", &time_str);
              logg->log_print("	%s", &(logg->parameterstr[i]));
              logg->log_print("	%s\n", timstr);
              memcpy(old_value_ptr, value_ptr, sizeof(pwr_tDeltaTime));
            }
            break;
          }
        }
      }

      break;
    }
    first_scan = 0;

    /*  Wait "cytime" ms */

    if (!logg->active || logg->stop_logg) {
      logg->active = 0;
      logg->entry_stop();
      logg->print_buffer();
      if (logg->logg_file)
        fclose(logg->logg_file);
      logg->logg_file = 0;

      if (logg->logg_priority != 0)
        sts = logg->set_default_prio();

      pthread_exit((void*)1);
    }
    time_GetTime(&time);
    while (time_Acomp(&time, &nextime) > 0) {
      /* To late for next lap, skip it */
      time_Aadd(&restime, &nextime, &deltatime);
      nextime = restime;
    }
    time_Adiff(&wait_time, &nextime, &time);

    struct timespec wait_time_ts;
    wait_time_ts.tv_sec = wait_time.tv_sec;
    wait_time_ts.tv_nsec = wait_time.tv_nsec;
    nanosleep(&wait_time_ts, NULL);
  }
  // pthread_exit(0);

  // return NULL;
}

/*************************************************************************
*
* Name:		log_print()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Print. Equivalent to fprintf but the character string is put
*	in a buffer and printed when the buffer size is exceeded or
*	when r_print_buffer is called.
*	The max size of the character string is 500.
*
**************************************************************************/

int XttLogging::log_print(const char* format, ...)
{
  char buff[500];
  int sts;
  char* s;
  va_list ap;

  va_start(ap, format);
  sts = vsprintf(buff, format, ap);
  va_end(ap);

  s = buffer_ptr + buffer_count;
  strcpy(s, buff);
  buffer_count += strlen(buff);

  if (buffer_count > (buffer_size * 512 - (int)sizeof(buff))) {
    if (intern) {
      stop_logg = 1;
      return 1;
    }
    print_buffer();
  }
  return sts;
}

/*************************************************************************
*
* Name:		print_buffer()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*
**************************************************************************/

int XttLogging::print_buffer()
{
  if (logg_priority != 0)
    set_default_prio();

  if (logg_file)
    fwrite(buffer_ptr, 1, buffer_count, logg_file);

  if (logg_priority != 0)
    set_prio(logg_priority);

  buffer_count = 0;
  *(buffer_ptr) = 0;

  return XNAV__SUCCESS;
}

/*************************************************************************
*
* Name:		rtt_logging_close_files()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Close all open files.
*	This file is called at execute termintation to close the files.
*
**************************************************************************/
int XttLogging::close_files()
{
  if (active) {
    if (logg_file) {
      print_buffer();
      fclose(logg_file);
    }
  }
  return XNAV__SUCCESS;
}

void XttLogging::message(char severity, const char* msg)
{
  ((XNav*)xnav)->message(severity, msg);
}
