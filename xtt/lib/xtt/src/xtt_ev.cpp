/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2019 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* xtt_ev.cpp -- Alarm and event window in xtt */

#include <stdlib.h>

#include "pwr_privilege.h"

#include "co_cdh.h"
#include "co_dcli.h"
#include "co_string.h"
#include "co_time.h"

#include "rt_gdh.h"
#include "rt_mh_util.h"
#include "rt_xnav_msg.h"

#include "cow_wow.h"

#include "xtt_ev.h"
#include "xtt_methodtoolbar.h"

// Static pointer to Ev for mh callbacks
Ev* Ev::ev = 0;

Ev::Ev(void* ev_parent_ctx, char* eve_name, char* ala_name, char* blk_name,
    pwr_tObjid ev_user, int display_ala, int display_eve, int display_blk,
    int display_return, int display_ack, int ev_beep, pwr_tMask ev_pop_mask,
    int ev_eventname_seg, pwr_tStatus* status)
    : parent_ctx(ev_parent_ctx), user(ev_user), eve_display_ack(display_ack),
      eve_display_return(display_return), start_trace_cb(NULL),
      display_in_xnav_cb(NULL), update_info_cb(NULL), help_cb(NULL),
      popup_menu_cb(0), sound_cb(0), pop_cb(0), is_authorized_cb(0), eve(NULL),
      ala(NULL), blk(0), connected(0), beep(ev_beep), pop_mask(ev_pop_mask),
      eventname_seg(ev_eventname_seg), sala_cnt(0), seve_cnt(0), modified(0)
{
}

//
//  Delete ev
//
Ev::~Ev()
{
}

void Ev::eve_start_trace_cb(void* ctx, pwr_tObjid objid, char* name)
{
  if (((Ev*)ctx)->start_trace_cb)
    ((Ev*)ctx)->start_trace_cb(((Ev*)ctx)->parent_ctx, objid, name);
}

void Ev::ala_start_trace_cb(void* ctx, pwr_tObjid objid, char* name)
{
  if (((Ev*)ctx)->start_trace_cb)
    ((Ev*)ctx)->start_trace_cb(((Ev*)ctx)->parent_ctx, objid, name);
}

void Ev::blk_start_trace_cb(void* ctx, pwr_tObjid objid, char* name)
{
  if (((Ev*)ctx)->start_trace_cb)
    ((Ev*)ctx)->start_trace_cb(((Ev*)ctx)->parent_ctx, objid, name);
}

void Ev::ev_popup_menu_cb(void* ctx, pwr_tAttrRef attrref,
    unsigned long item_type, unsigned long utility, char* arg, int x, int y)
{
  if (((Ev*)ctx)->popup_menu_cb)
    (((Ev*)ctx)->popup_menu_cb)(
        ((Ev*)ctx)->parent_ctx, attrref, item_type, utility, arg, x, y);
}

int Ev::ev_sound_cb(void* ctx, pwr_tAttrRef* attrref)
{
  if (((Ev*)ctx)->sound_cb)
    return (((Ev*)ctx)->sound_cb)(((Ev*)ctx)->parent_ctx, attrref);
  return 0;
}

void Ev::eve_selection_changed_cb(void* ctx)
{
  ((Ev*)ctx)->eve_methodtoolbar->set_sensitive();
  ((Ev*)ctx)->eve_sup_methodtoolbar->set_sensitive();
}

void Ev::ala_selection_changed_cb(void* ctx)
{
  ((Ev*)ctx)->ala_methodtoolbar->set_sensitive();
  ((Ev*)ctx)->ala_sup_methodtoolbar->set_sensitive();
}

char* Ev::ev_name_to_alias_cb(void* ctx, char* name)
{
  return ((Ev*)ctx)->name_to_alias(name);
}

void Ev::eve_display_in_xnav_cb(void* ctx, pwr_tAttrRef* arp)
{
  if (((Ev*)ctx)->display_in_xnav_cb)
    ((Ev*)ctx)->display_in_xnav_cb(((Ev*)ctx)->parent_ctx, arp);
}

void Ev::ala_display_in_xnav_cb(void* ctx, pwr_tAttrRef* arp)
{
  if (((Ev*)ctx)->display_in_xnav_cb)
    ((Ev*)ctx)->display_in_xnav_cb(((Ev*)ctx)->parent_ctx, arp);
}

void Ev::blk_display_in_xnav_cb(void* ctx, pwr_tAttrRef* arp)
{
  if (((Ev*)ctx)->display_in_xnav_cb)
    ((Ev*)ctx)->display_in_xnav_cb(((Ev*)ctx)->parent_ctx, arp);
}

void Ev::ala_help_cb(void* ctx, const char* key)
{
  if (((Ev*)ctx)->help_cb)
    ((Ev*)ctx)->help_cb(((Ev*)ctx)->parent_ctx, key);
}

int Ev::ala_is_authorized_cb(void* ctx, unsigned int access)
{
  if (((Ev*)ctx)->is_authorized_cb)
    return ((Ev*)ctx)->is_authorized_cb(((Ev*)ctx)->parent_ctx, access);
  return 0;
}

int Ev::sala_acknowledge_cb(void* ctx, mh_sEventId* id)
{
  Ev* ev = (Ev*)ctx;

  mh_sEventId lid = *id;
  ev->ala->ack(id);
  ev->eve->ack(id);
  for (int i = 0; i < ev->sala_cnt; i++)
    ev->sala[i]->ack(id);
  for (int i = 0; i < ev->seve_cnt; i++)
    ev->seve[i]->ack(id);
  mh_OutunitAck(&lid);
  return 1;
}

void Ev::sala_copy_list_cb(void* ctx, EvList* evl)
{
  Ev* ev = (Ev*)ctx;

  ev->ala->copy_list(evl);
}

void Ev::sala_close_cb(void* ctx, EvAla* sala)
{
  Ev* ev = (Ev*)ctx;

  bool found = false;
  for (int i = 0; i < ev->sala_cnt; i++) {
    if (ev->sala[i] == sala)
      found = true;
    if (found && i != ev->sala_cnt - 1)
      ev->sala[i] = ev->sala[i + 1];
  }
  if (found)
    ev->sala_cnt--;
}

int Ev::seve_acknowledge_cb(void* ctx, mh_sEventId* id)
{
  Ev* ev = (Ev*)ctx;

  mh_sEventId lid = *id;
  ev->ala->ack(id);
  ev->eve->ack(id);
  for (int i = 0; i < ev->seve_cnt; i++)
    ev->seve[i]->ack(id);
  for (int i = 0; i < ev->sala_cnt; i++)
    ev->sala[i]->ack(id);
  mh_OutunitAck(&lid);
  return 1;
}

void Ev::seve_copy_list_cb(void* ctx, EvList* evl)
{
  Ev* ev = (Ev*)ctx;

  ev->eve->copy_list(evl);
}

void Ev::seve_close_cb(void* ctx, EvEve* seve)
{
  Ev* ev = (Ev*)ctx;

  bool found = false;
  for (int i = 0; i < ev->seve_cnt; i++) {
    if (ev->seve[i] == seve)
      found = true;
    if (found && i != ev->seve_cnt - 1)
      ev->seve[i] = ev->seve[i + 1];
  }
  if (found)
    ev->seve_cnt--;
}

void Ev::help_event_cb(void* ctx, void* item)
{
  ItemAlarm* aitem = (ItemAlarm*)item;

  switch (aitem->type) {
  case evlist_eItemType_Alarm:
    ((Ev*)ctx)->wow->DisplayText("Event MoreText", aitem->eventmoretext);
    break;
  default:
    return;
  }
}

void Ev::eve_activate_print()
{
  char title[80];

  strcpy(title, Lng::translate("Event List"));
  eve->print(title);
}

void Ev::ala_activate_print()
{
  char title[80];

  strcpy(title, Lng::translate("Alarm List"));
  ala->print(title);
}

void Ev::blk_activate_print()
{
  char title[80];

  strcpy(title, Lng::translate("Blocked Alarms"));
  blk->print(title);
}

void Ev::eve_activate_export()
{
  wow->CreateFileSelDia("Export", (void*)this,
      eve_export_file_selected_cb, wow_eFileSelType_Tmp, wow_eFileSelAction_Save);
}

void Ev::eve_export_file_selected_cb(void *ctx, char *filename, wow_eFileSelType file_type)
{
  ((Ev *)ctx)->eve_export_events(filename);  
}

int Ev::eve_export_events(const char *filename)
{
  brow_tObject *list;
  int list_cnt;
  ItemAlarm *item;
  char timstr[40];
  char supobjectstr[80];
  pwr_tFileName fname;
  FILE *fp;

  dcli_translate_filename(fname, filename);
  fp = fopen(fname, "w");
  if (!fp)
    return 0;
  fprintf(fp, "Time,Type,Prio,Text,Name,SupObject,Id,Status\n");
  brow_GetObjectList(eve->brow->ctx, &list, &list_cnt);
  for (int i = list_cnt - 1; i >= 0; i--) {
    brow_GetUserData(list[i], (void **)&item);
    time_AtoAscii(&item->time, time_eFormat_NumDateAndTime, timstr, sizeof(timstr));
    strcpy(supobjectstr, cdh_ObjidToString(item->supobject.Objid, 1));
    if (item->supobject.Flags.b.ObjectAttr)
      sprintf(&supobjectstr[strlen(supobjectstr)], "#%u:%u", item->supobject.Offset,
	      item->supobject.Size);
    fprintf(fp, "%s,%u,%lu,\"%s\",\"%s\",%s,\"(%u,%u)\",%u\n",
	   timstr, item->eventtype, item->eventprio, item->eventtext, item->eventname, 
	   supobjectstr, item->eventid.Nix, item->eventid.Idx, item->status);
  }
  fclose(fp);
  return 1;
}

void Ev::eve_activate_analyse()
{
  eve_export_events("$pwrp_tmp/pwr_eventlist.dat");  
  system("sev_eva.py -f $pwrp_tmp/pwr_eventlist.dat &");
}

void Ev::eve_activate_ack_last()
{
  mh_sEventId* id;
  int sts;

  if (is_authorized_cb
      && !is_authorized_cb(
             parent_ctx, pwr_mAccess_RtEventsAck | pwr_mAccess_System))
    return;

  sts = ala->get_last_not_acked(&id);
  if (EVEN(sts))
    return;

  mh_sEventId lid = *id;
  ala->ack(id);
  eve->ack(id);
  for (int i = 0; i < sala_cnt; i++)
    sala[i]->ack(id);
  for (int i = 0; i < seve_cnt; i++)
    seve[i]->ack(id);
  if (update_info_cb)
    update_info_cb(parent_ctx);
  ala->fill_alarm_tables();
  mh_OutunitAck(&lid);
}

void Ev::ala_activate_ack_last()
{
  mh_sEventId* id;
  int sts;

  if (is_authorized_cb
      && !is_authorized_cb(
             parent_ctx, pwr_mAccess_RtEventsAck | pwr_mAccess_System))
    return;

  if (ala->brow == ala->browbase) {
    // Flat view, acknowledge last
    sts = ala->get_last_not_acked(&id);
    if (EVEN(sts))
      return;
  } else {
    // Tree view, acknowledge selected
    ItemAlarm* item;
    pwr_tAName eventname;

    sts = ala->get_selected_event(eventname, &item);
    if (EVEN(sts))
      return;

    switch (item->type) {
    case evlist_eItemType_Alarm:
      id = &item->eventid;
      break;
    default:
      return;
    }
  }

  mh_sEventId lid = *id;
  ala->ack(id);
  eve->ack(id);
  for (int i = 0; i < sala_cnt; i++)
    sala[i]->ack(id);
  for (int i = 0; i < seve_cnt; i++)
    seve[i]->ack(id);
  if (update_info_cb)
    update_info_cb(parent_ctx);
  ala->fill_alarm_tables();
  mh_OutunitAck(&lid);
}

void Ev::eve_activate_ack_all()
{
  if (is_authorized_cb
      && !is_authorized_cb(
             parent_ctx, pwr_mAccess_RtEventsAck | pwr_mAccess_System))
    return;

  ack_all();
}

void Ev::eve_activate_help()
{
  if (help_cb)
    (help_cb)(parent_ctx, "opg_eventlist");
}

void Ev::eve_activate_helpevent()
{
  char eventname[80];
  int sts;
  ItemAlarm* item;

  if (help_cb) {
    sts = ev->eve->get_selected_event(eventname, &item);
    if (ODD(sts)) {
      wow->DisplayText(eventname, item->eventmoretext);
    }
  }
}

void Ev::ala_activate_help()
{
  if (help_cb)
    (help_cb)(parent_ctx, "opg_alarmlist");
}

void Ev::ala_activate_helpevent()
{
  char eventname[80];
  int sts;
  ItemAlarm* item;

  if (help_cb) {
    sts = ala->get_selected_event(eventname, &item);
    if (ODD(sts)) {
      wow->DisplayText(eventname, item->eventmoretext);
    }
  }
}

void Ev::blk_activate_help()
{
  if (help_cb)
    (help_cb)(parent_ctx, "opg_blocklist");
}

int Ev::get_alarm_info(evlist_sAlarmInfo* info, int backward, int alarmsize)
{
  return ala->get_alarm_info(info, backward, alarmsize);
}

int Ev::outunit_connect(pwr_tObjid user)
{
  int sts;

  // Wait for mh has flagged initizated
  mh_UtilWaitForMh();

  sts = mh_OutunitConnect(user, mh_eOutunitType_Operator, 0, mh_ack_bc,
      mh_alarm_bc, mh_block_bc, mh_cancel_bc, mh_clear_alarmlist_bc,
      mh_clear_blocklist_bc, mh_info_bc, mh_return_bc, mh_alarmstatus_bc);
  if (EVEN(sts))
    return sts;

  connected = 1;
  return XNAV__SUCCESS;
}

void Ev::update(double scantime)
{
  int sts;
  int nodraw_set = 0;
  int redraw = 0;

  sts = mh_OutunitReceive();
  while (ODD(sts)) {
    if (!nodraw_set) {
      eve->set_nodraw();
      ala->set_nodraw();
      nodraw_set = 1;
    }
    sts = mh_OutunitReceive();
    redraw = redraw | ev->modified;
  }
  if (nodraw_set) {
    if (redraw) {
      eve->reset_nodraw();
      ala->reset_nodraw();
    } else {
      brow_ResetNodraw(eve->brow->ctx);
      brow_ResetNodraw(ala->brow->ctx);
    }
  }

  ala->flash();
  for (int i = 0; i < sala_cnt; i++)
    sala[i]->update();
  if (beep)
    ala->beep(scantime);
}

void Ev::ack_last_prio(unsigned long type, unsigned long prio, int backward, int timecheck)
{
  mh_sEventId* id;
  int sts;

  if (is_authorized_cb
      && !is_authorized_cb(
             parent_ctx, pwr_mAccess_RtEventsAck | pwr_mAccess_System))
    return;

  sts = ala->get_last_not_acked_prio(&id, type, prio, backward, timecheck);
  if (ODD(sts)) {
    mh_sEventId lid = *id;

    ala->ack(id);
    eve->ack(id);
    for (int i = 0; i < sala_cnt; i++)
      sala[i]->ack(id);
    for (int i = 0; i < seve_cnt; i++)
      seve[i]->ack(id);
    if (update_info_cb)
      update_info_cb(parent_ctx);
    ala->fill_alarm_tables();
    mh_OutunitAck(&lid);
  }
}

void Ev::ack_all()
{
  mh_sEventId *id, *idv;
  int sts;
  int num;
  int idx;

  if (is_authorized_cb
      && !is_authorized_cb(
             parent_ctx, pwr_mAccess_RtEventsAck | pwr_mAccess_System))
    return;

  num = ala->get_num_not_acked();
  if (num == 0)
    return;

  idv = (mh_sEventId*)calloc(num, sizeof(mh_sEventId));

  idx = 0;
  sts = ala->get_last_not_acked(&id);
  while (ODD(sts)) {
    mh_sEventId lid = *id;
    ala->ack(id);
    eve->ack(id);
    for (int i = 0; i < sala_cnt; i++)
      sala[i]->ack(id);
    for (int i = 0; i < seve_cnt; i++)
      seve[i]->ack(id);
    idv[idx++] = lid;

    sts = ala->get_last_not_acked(&id);
  }
  if (update_info_cb)
    update_info_cb(parent_ctx);
  ala->fill_alarm_tables();

  for (int i = 0; i < idx; i++)
    mh_OutunitAck(&idv[i]);

  free((char*)idv);
}

int Ev::get_last_not_acked_prio(
    mh_sEventId** id, unsigned long type, unsigned long prio)
{
  return ala->get_last_not_acked_prio(id, type, prio, 0, 0);
}

void Ev::create_aliaslist(void* up)
{
  char alias_array[2][80];
  int nr;
  int i, j;
  int alias_size;
  ev_sAlias dum;
  pwr_sClass_OpPlace* userp = (pwr_sClass_OpPlace*)up;
  int listsize
      = MIN(sizeof(userp->EventSelectList) / sizeof(userp->EventSelectList[0]),
          sizeof(alias_list) / sizeof(alias_list[0]));

  for (i = 0, j = 0; i < listsize; i++) {
    strcpy(alias_list[i].Alias, "");
    strcpy(alias_list[i].Object, "");
  }
  for (i = 0, j = 0; i < listsize; i++) {
    nr = dcli_parse(userp->EventSelectList[i], " 	", "",
        (char*)alias_array, sizeof(alias_array) / sizeof(alias_array[0]),
        sizeof(alias_array[0]), 0);
    if (nr < 2)
      continue;

    str_ToUpper(alias_list[j].Object, alias_array[0]);
    strncpy(alias_list[j].Alias, alias_array[1], sizeof(alias_list[j].Alias));
    alias_list[j].Alias[sizeof(alias_list[j].Alias) - 1] = 0;
    j++;
  }
  alias_size = j;

  // Order
  for (i = alias_size - 1; i > 0; i--) {
    for (j = 0; j < i; j++) {
      if (strcmp(alias_list[j].Object, alias_list[j + 1].Object) <= 0) {
        memcpy(&dum, &alias_list[j + 1], sizeof(dum));
        memcpy(&alias_list[j + 1], &alias_list[j], sizeof(dum));
        memcpy(&alias_list[j], &dum, sizeof(dum));
      }
    }
  }
}

char* Ev::name_to_alias(char* name)
{
  char oname[120];
  static char alias[40];

  str_ToUpper(oname, name);

  for (int i = 0; i < (int)(sizeof(alias_list) / sizeof(alias_list[0])); i++) {
    if (alias_list[i].Alias[0] == 0)
      break;
    if (!streq(alias_list[i].Object, "")
        && str_StartsWith(oname, alias_list[i].Object)) {
      strcpy(alias, alias_list[i].Alias);
      return alias;
    }
  }
  strcpy(alias, "");
  return alias;
}

pwr_tStatus Ev::mh_ack_bc(mh_sAck* MsgP)
{
  if (ev->eve_display_ack) {
    // Insert in eve
    ev->eve->event_ack(MsgP);
    for (int i = 0; i < ev->seve_cnt; i++)
      ev->seve[i]->mh_ack(MsgP);
  }
  ev->ala->event_ack(MsgP);
  for (int i = 0; i < ev->sala_cnt; i++)
    ev->sala[i]->mh_ack(MsgP);

  if (ev->update_info_cb)
    ev->update_info_cb(ev->parent_ctx);
  ev->ala->fill_alarm_tables();
  ev->modified = 1;
  return 1;
}

pwr_tStatus Ev::mh_return_bc(mh_sReturn* MsgP)
{
  if (ev->eve_display_return) {
    // Insert in eve
    ev->eve->event_return(MsgP);
    for (int i = 0; i < ev->seve_cnt; i++)
      ev->seve[i]->mh_return(MsgP);
  }
  ev->ala->event_return(MsgP);
  for (int i = 0; i < ev->sala_cnt; i++)
    ev->sala[i]->mh_return(MsgP);

  if (ev->update_info_cb)
    ev->update_info_cb(ev->parent_ctx);
  ev->ala->fill_alarm_tables();
  ev->modified = 1;
  return 1;
}

pwr_tStatus Ev::mh_alarm_bc(mh_sMessage* MsgP)
{
  ev->eve->event_alarm(MsgP);
  for (int i = 0; i < ev->seve_cnt; i++)
    ev->seve[i]->mh_alarm(MsgP);
  ev->ala->event_alarm(MsgP);
  for (int i = 0; i < ev->sala_cnt; i++)
    ev->sala[i]->mh_alarm(MsgP);
  if (ev->update_info_cb)
    ev->update_info_cb(ev->parent_ctx);
  ev->ala->fill_alarm_tables();
  if (ev->pop_cb) {
    int pop = 0;

    switch (((mh_sMsgInfo*)MsgP)->EventPrio) {
    case mh_eEventPrio_A:
      if (ev->pop_mask & pwr_mOpWindPopMask_Aalarm)
        pop = 1;
      break;
    case mh_eEventPrio_B:
      if (ev->pop_mask & pwr_mOpWindPopMask_Balarm)
        pop = 1;
      break;
    case mh_eEventPrio_C:
      if (ev->pop_mask & pwr_mOpWindPopMask_Calarm)
        pop = 1;
      break;
    case mh_eEventPrio_D:
      if (ev->pop_mask & pwr_mOpWindPopMask_Dalarm)
        pop = 1;
      break;
    default:;
    }
    if (pop)
      ev->pop_cb(ev->parent_ctx);
  }
  ev->modified = 1;
  return 1;
}

pwr_tStatus Ev::mh_block_bc(mh_sBlock* MsgP)
{
  ev->blk->event_block(MsgP);
  ev->eve->event_block(MsgP);
  if (ev->update_info_cb)
    ev->update_info_cb(ev->parent_ctx);
  ev->ala->fill_alarm_tables();
  ev->modified = 1;
  return 1;
}

pwr_tStatus Ev::mh_cancel_bc(mh_sReturn* MsgP)
{
  ev->ala->event_cancel(MsgP);
  for (int i = 0; i < ev->sala_cnt; i++)
    ev->sala[i]->mh_cancel(MsgP);

  if (ev->update_info_cb)
    ev->update_info_cb(ev->parent_ctx);
  ev->ala->fill_alarm_tables();
  ev->modified = 1;
  return 1;
}

pwr_tStatus Ev::mh_info_bc(mh_sMessage* MsgP)
{
  ev->eve->event_info(MsgP);
  for (int i = 0; i < ev->seve_cnt; i++)
    ev->seve[i]->mh_info(MsgP);
  ev->ala->event_info(MsgP);
  for (int i = 0; i < ev->sala_cnt; i++)
    ev->sala[i]->mh_info(MsgP);
  if (ev->update_info_cb)
    ev->update_info_cb(ev->parent_ctx);
  ev->ala->fill_alarm_tables();
  if (ev->pop_mask & pwr_mOpWindPopMask_InfoMsg)
    ev->pop_cb(ev->parent_ctx);
  ev->modified = 1;

  return 1;
}

pwr_tStatus Ev::mh_clear_alarmlist_bc(pwr_tNodeIndex nix)
{
  ev->ala->event_clear_alarmlist(nix);
  for (int i = 0; i < ev->sala_cnt; i++)
    ev->sala[i]->mh_clear_alarmlist(nix);

  if (ev->update_info_cb)
    ev->update_info_cb(ev->parent_ctx);
  ev->ala->fill_alarm_tables();
  ev->modified = 1;
  return 1;
}

pwr_tStatus Ev::mh_clear_blocklist_bc(pwr_tNodeIndex nix)
{
  ev->blk->event_clear_alarmlist(nix);
  ev->modified = 1;
  return 1;
}

pwr_tStatus Ev::mh_alarmstatus_bc(mh_sAlarmStatus* MsgP)
{
  brow_tObject* object_list;
  int object_cnt;
  ItemAlarm* item;
  int i;
  unsigned int j;
  int* found;
  mh_sOutunitAlarmReq* rmsg;
  int modified = 0;

  found = (int*)calloc(1, MsgP->Count * sizeof(int));

  brow_GetObjectList(ev->ala->browbase->ctx, &object_list, &object_cnt);
  ev->ala->size = object_cnt;

  // Reset check to find obsolete items
  for (i = 0; i < object_cnt; i++) {
    brow_GetUserData(object_list[i], (void**)&item);
    switch (item->type) {
    case evlist_eItemType_Alarm:
      if (MsgP->Nix == item->eventid.Nix)
        item->check = 0;
      break;
    default:;
    }
  }
  for (i = 0; i < object_cnt; i++) {
    brow_GetUserData(object_list[i], (void**)&item);
    switch (item->type) {
    case evlist_eItemType_Alarm:
      for (j = 0; j < MsgP->Count; j++) {
        if (MsgP->Nix == item->eventid.Nix
            && MsgP->Sts[j].Idx == item->eventid.Idx) {
          found[j] = 1;
          item->check = 1;
          if (!(MsgP->Sts[j].Status & mh_mEventStatus_NotRet)
              && (item->status & mh_mEventStatus_NotRet)) {
            pwr_tUInt32 status = item->status;
            mh_sReturn retmsg;
            memset(&retmsg, 0, sizeof(retmsg));
            retmsg.TargetId = item->eventid;

            ev->ala->event_return(&retmsg);
            for (int k = 0; k < ev->sala_cnt; k++)
              ev->sala[k]->mh_return(&retmsg);
            modified = 1;
            if (!(status & mh_mEventStatus_NotAck)) {
              // Item was removed
              i--;
              object_cnt--;
              continue;
            }
          }
          if (!(MsgP->Sts[j].Status & mh_mEventStatus_NotAck)
              && (item->status & mh_mEventStatus_NotAck)) {
            pwr_tUInt32 status = item->status;
            mh_sAck ackmsg;
            memset(&ackmsg, 0, sizeof(ackmsg));
            ackmsg.TargetId = item->eventid;

            ev->ala->event_ack(&ackmsg);
            for (int k = 0; k < ev->sala_cnt; k++)
              ev->sala[k]->mh_ack(&ackmsg);
            modified = 1;
            if (!(status & mh_mEventStatus_NotRet)) {
              // Item was removed
              i--;
              object_cnt--;
              continue;
            }
          }
        }
      }
      break;
    default:;
    }
  }

  // Find and remove the obsolete items
  brow_GetObjectList(ev->ala->browbase->ctx, &object_list, &object_cnt);
  for (i = 0; i < object_cnt; i++) {
    brow_GetUserData(object_list[i], (void**)&item);
    switch (item->type) {
    case evlist_eItemType_Alarm:
      if (MsgP->Nix == item->eventid.Nix && !item->check) {
        mh_sEventId eventid = item->eventid;
        ev->ala->event_delete(&item->eventid);
        // Note, item is now deleted

        for (int k = 0; k < ev->sala_cnt; k++)
          ev->sala[k]->event_delete(&eventid);
        i--;
        object_cnt--;
        modified = 1;
      }
      break;
    default:;
    }
  }

  if (modified) {
    if (ev->update_info_cb)
      ev->update_info_cb(ev->parent_ctx);
    ev->ala->fill_alarm_tables();
  }

  // Request info about any missing ids

  rmsg = (mh_sOutunitAlarmReq*)calloc(1, sizeof(*rmsg));
  rmsg->Nix = MsgP->Nix;
  for (j = 0; j < MsgP->Count; j++) {
    if (!found[j]) {
      // Request info about this id
      rmsg->Idx[rmsg->Count] = MsgP->Sts[j].Idx;
      rmsg->Count++;
    }
    if (rmsg->Count >= sizeof(rmsg->Idx) / sizeof(rmsg->Idx[0]))
      break;
  }
  if (rmsg->Count > 0)
    mh_OutunitAlarmRequest(rmsg);

  free((char*)rmsg);
  free((char*)found);
  ev->modified = modified;

  return 1;
}

pwr_tStatus Ev::set_view(pwr_tOid view)
{
  pwr_tStatus sts;

  sts = ala->set_view(view);
  if (ODD(sts)) {
    pwr_tString80 name;

    if (cdh_ObjidIsNull(view)) {
      strcpy(name, "Alarm List");
    } else {
      pwr_tAttrRef name_ar, ar;

      ar = cdh_ObjidToAref(view);
      sts = gdh_ArefANameToAref(&ar, "Name", &name_ar);
      if (EVEN(sts))
        return sts;

      sts = gdh_GetObjectInfoAttrref(&name_ar, name, sizeof(name));
      if (EVEN(sts))
        return sts;
    }
    set_title_ala(name);
  }
  return sts;
}

void Ev::view_shift()
{
  pwr_sClass_OpPlace* opp;
  pwr_tStatus sts;

  sts = gdh_ObjidToPointer(user, (pwr_tAddress*)&opp);
  if (EVEN(sts))
    return;

  if (cdh_ObjidIsNull(ala->current_view)) {
    set_view(opp->AlarmViews[0]);
  } else {
    for (unsigned int i = 0;
         i < sizeof(opp->AlarmViews) / sizeof(opp->AlarmViews[0]); i++) {
      if (cdh_ObjidIsEqual(ala->current_view, opp->AlarmViews[i])) {
        if (i == sizeof(opp->AlarmViews) / sizeof(opp->AlarmViews[0]) - 1)
          set_view(pwr_cNObjid);
        else
          set_view(opp->AlarmViews[i + 1]);
        break;
      }
    }
  }
}
