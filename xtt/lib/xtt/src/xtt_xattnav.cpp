/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* wb_xattnav.cpp -- Display object info */

#include <stdlib.h>

#include "co_cdh.h"
#include "co_error.h"
#include "co_string.h"

#include "rt_xatt_msg.h"
#include "rt_mh_net.h"

#include "cow_wow.h"

#include "flow_msg.h"

#include "xtt_xatt.h"
#include "xtt_xattnav.h"
#include "xtt_item.h"

void XAttNav::message(char sev, const char* text)
{
  if (message_cb)
    (message_cb)(parent_ctx, sev, text);
}

//
// Create the navigator widget
//
XAttNav::XAttNav(void* xa_parent_ctx, xattnav_eType xa_type,
    const char* xa_name, pwr_sAttrRef* xa_objar, int xa_advanced_user,
    void* xa_userdata, pwr_tStatus* status)
    : parent_ctx(xa_parent_ctx), type(xa_type), objar(*xa_objar),
      advanced_user(xa_advanced_user), userdata(xa_userdata), bypass(0),
      trace_started(0), message_cb(NULL), close_cb(0), change_value_cb(0),
      popup_menu_cb(0), start_trace_cb(0), is_authorized_cb(0), displayed(0),
      scantime(500)
{
  strcpy(name, xa_name);
  *status = 1;
}

//
//  Delete a nav context
//
XAttNav::~XAttNav()
{
}

//
// Check that the current selected item is valid for change
//
int XAttNav::check_attr(int* multiline, brow_tObject* node, char* name,
    char** init_value, int* size)
{
  brow_tNode* node_list;
  int node_count;
  Item* base_item;
  pwr_tStatus sts;

  *init_value = 0;
  *multiline = 0;

  brow_GetSelectedNodes(brow->ctx, &node_list, &node_count);
  if (!node_count)
    return XATT__NOSELECT;

  brow_GetUserData(node_list[0], (void**)&base_item);
  *node = node_list[0];
  free(node_list);

  switch (base_item->type) {
  case xnav_eItemType_Attr:
  case xnav_eItemType_AttrArrayElem:
  case xnav_eItemType_Collect: {
    pwr_tTypeId a_tid;
    pwr_tUInt32 a_size, a_offs, a_elem;
    ItemBaseAttr* item = (ItemBaseAttr*)base_item;

    if (item->noedit)
      return XATT__NOCHANGE;

    strcpy(name, item->attr);

    sts = gdh_GetAttributeCharacteristics(
        name, &a_tid, &a_size, &a_offs, &a_elem);
    if (ODD(sts))
      *size = cdh_TypeToMaxStrSize((pwr_eType)item->type_id, a_size, a_elem);
    else
      *size = 80;

    return 1;
  }
  default:
    return XATT__NOCHANGE;
  }
}

//
// Callbacks from brow
//
int XAttNav::brow_cb(FlowCtx* ctx, flow_tEvent event)
{
  XAttNav* xattnav;
  Item* item;

  if (event->event == flow_eEvent_ObjectDeleted) {
    brow_GetUserData(event->object.object, (void**)&item);
    delete item;
    return 1;
  }

  brow_GetCtxUserData((BrowCtx*)ctx, (void**)&xattnav);
  xattnav->message(' ', "");

  switch (event->event) {
  case flow_eEvent_Key_Up: {
    brow_tNode* node_list;
    int node_count;
    brow_tObject object;
    int sts;

    brow_GetSelectedNodes(xattnav->brow->ctx, &node_list, &node_count);
    if (!node_count) {
      sts = brow_GetLastVisible(xattnav->brow->ctx, &object);
      if (EVEN(sts))
        return 1;
    } else {
      if (!brow_IsVisible(
              xattnav->brow->ctx, node_list[0], flow_eVisible_Partial)) {
        sts = brow_GetLastVisible(xattnav->brow->ctx, &object);
        if (EVEN(sts))
          return 1;
      } else {
        sts = brow_GetPrevious(xattnav->brow->ctx, node_list[0], &object);
        if (EVEN(sts)) {
          if (node_count)
            free(node_list);
          return 1;
        }
      }
    }
    brow_SelectClear(xattnav->brow->ctx);
    brow_SetInverse(object, 1);
    brow_SelectInsert(xattnav->brow->ctx, object);
    if (!brow_IsVisible(xattnav->brow->ctx, object, flow_eVisible_Full))
      brow_CenterObject(xattnav->brow->ctx, object, 0.25);
    if (node_count)
      free(node_list);
    break;
  }
  case flow_eEvent_Key_Down: {
    brow_tNode* node_list;
    int node_count;
    brow_tObject object;
    int sts;

    brow_GetSelectedNodes(xattnav->brow->ctx, &node_list, &node_count);
    if (!node_count) {
      sts = brow_GetFirstVisible(xattnav->brow->ctx, &object);
      if (EVEN(sts))
        return 1;
    } else {
      if (!brow_IsVisible(
              xattnav->brow->ctx, node_list[0], flow_eVisible_Partial)) {
        sts = brow_GetFirstVisible(xattnav->brow->ctx, &object);
        if (EVEN(sts))
          return 1;
      } else {
        sts = brow_GetNext(xattnav->brow->ctx, node_list[0], &object);
        if (EVEN(sts)) {
          if (node_count)
            free(node_list);
          return 1;
        }
      }
    }
    brow_SelectClear(xattnav->brow->ctx);
    brow_SetInverse(object, 1);
    brow_SelectInsert(xattnav->brow->ctx, object);
    if (!brow_IsVisible(xattnav->brow->ctx, object, flow_eVisible_Full))
      brow_CenterObject(xattnav->brow->ctx, object, 0.75);
    if (node_count)
      free(node_list);
    break;
  }
  case flow_eEvent_SelectClear:
    brow_ResetSelectInverse(xattnav->brow->ctx);
    break;
  case flow_eEvent_MB1Click: {
    // Select
    double ll_x, ll_y, ur_x, ur_y;
    int sts;

    switch (event->object.object_type) {
    case flow_eObjectType_Node:
      brow_MeasureNode(event->object.object, &ll_x, &ll_y, &ur_x, &ur_y);
      if (event->object.x < ll_x + 1.0) {
        // Simulate doubleclick
        flow_tEvent doubleclick_event;

        doubleclick_event = (flow_tEvent)calloc(1, sizeof(*doubleclick_event));
        memcpy(doubleclick_event, event, sizeof(*doubleclick_event));
        doubleclick_event->event = flow_eEvent_MB1DoubleClick;
        sts = brow_cb(ctx, doubleclick_event);
        free((char*)doubleclick_event);
        return sts;
      }

      if (brow_FindSelectedObject(xattnav->brow->ctx, event->object.object)) {
        brow_SelectClear(xattnav->brow->ctx);
      } else {
        brow_SelectClear(xattnav->brow->ctx);
        brow_SetInverse(event->object.object, 1);
        brow_SelectInsert(xattnav->brow->ctx, event->object.object);
      }
      break;
    default:
      brow_SelectClear(xattnav->brow->ctx);
    }
    break;
  }
  case flow_eEvent_Key_PageDown: {
    brow_Page(xattnav->brow->ctx, 0.8);
    break;
  }
  case flow_eEvent_Key_PageUp: {
    brow_Page(xattnav->brow->ctx, -0.8);
    break;
  }
  case flow_eEvent_ScrollDown: {
    brow_Page(xattnav->brow->ctx, 0.1);
    break;
  }
  case flow_eEvent_ScrollUp: {
    brow_Page(xattnav->brow->ctx, -0.1);
    break;
  }
  case flow_eEvent_Key_Left: {
    brow_tNode* node_list;
    int node_count;
    brow_tObject object;
    int sts;

    brow_GetSelectedNodes(xattnav->brow->ctx, &node_list, &node_count);
    if (!node_count)
      return 1;

    if (brow_IsOpen(node_list[0]))
      // Close this node
      object = node_list[0];
    else {
      // Close parent
      sts = brow_GetParent(xattnav->brow->ctx, node_list[0], &object);
      if (EVEN(sts)) {
        free(node_list);
        return 1;
      }
    }
    brow_GetUserData(object, (void**)&item);
    switch (item->type) {
    case xnav_eItemType_Attr:
      ((ItemAttr*)item)->close(xattnav->brow, 0, 0);
      break;
    case xnav_eItemType_AttrArrayElem:
      ((ItemAttrArrayElem*)item)->close(xattnav->brow, 0, 0);
      break;
    case xnav_eItemType_AttrArray:
      ((ItemAttrArray*)item)->close(xattnav->brow, 0, 0);
      break;
    case xnav_eItemType_AttrObject:
      ((ItemAttrObject*)item)->close(xattnav->brow, 0, 0);
      break;
    default:;
    }
    brow_SelectClear(xattnav->brow->ctx);
    brow_SetInverse(object, 1);
    brow_SelectInsert(xattnav->brow->ctx, object);
    if (!brow_IsVisible(xattnav->brow->ctx, object, flow_eVisible_Full))
      brow_CenterObject(xattnav->brow->ctx, object, 0.25);
    free(node_list);
    break;
  }
  case flow_eEvent_MB3Down: {
    brow_SetClickSensitivity(xattnav->brow->ctx, flow_mSensitivity_MB3Press);
    break;
  }
  case flow_eEvent_MB3Press: {
    // Popup menu
    int x, y;
    pwr_sAttrRef attrref;
    int sts;

    switch (event->object.object_type) {
    case flow_eObjectType_Node:
      brow_GetUserData(event->object.object, (void**)&item);
      if (cdh_ObjidIsNull(item->objid))
        break;

      xattnav->popup_position(
          event->any.x_pixel + 8, event->any.y_pixel, &x, &y);

      memset(&attrref, 0, sizeof(attrref));
      switch (item->type) {
      case xnav_eItemType_Attr:
      case xnav_eItemType_AttrArrayElem:
      case xnav_eItemType_AttrObject: {
        pwr_tAName attr_str;

        sts = gdh_ObjidToName(
            item->objid, attr_str, sizeof(attr_str), cdh_mName_volumeStrict);
        if (EVEN(sts))
          return sts;

        strcat(attr_str, ".");
        strcat(attr_str, item->name);
        sts = gdh_NameToAttrref(pwr_cNObjid, attr_str, &attrref);
        if (EVEN(sts))
          return sts;

        (xattnav->popup_menu_cb)(xattnav->parent_ctx, attrref,
            (unsigned long)xmenu_eItemType_Attribute,
            (unsigned long)xmenu_mUtility_AttrEditor, NULL, x, y);

        break;
      }
      case xnav_eItemType_Collect: {
        sts = gdh_NameToAttrref(pwr_cNObjid, item->name, &attrref);
        if (EVEN(sts))
          return sts;

        (xattnav->popup_menu_cb)(xattnav->parent_ctx, attrref,
            (unsigned long)xmenu_eItemType_Attribute,
            (unsigned long)xmenu_mUtility_AttrEditor, NULL, x, y);

        break;
      }
      case xnav_eItemType_Crossref: {
        ItemCrossref* itemc = (ItemCrossref*)item;

        attrref = cdh_ObjidToAref(itemc->objid);
        (xattnav->popup_menu_cb)(xattnav->parent_ctx, attrref,
            (unsigned long)xmenu_eItemType_Crossref,
            (unsigned long)xmenu_mUtility_AttrEditor, itemc->ref_name, x, y);
        break;
      }
      default:;
      }
      break;
    default:;
    }
    break;
  }
  case flow_eEvent_Key_Right: {
    brow_tNode* node_list;
    int node_count;
    pwr_tStatus sts;

    brow_GetSelectedNodes(xattnav->brow->ctx, &node_list, &node_count);
    if (!node_count)
      return 1;

    brow_GetUserData(node_list[0], (void**)&item);
    switch (item->type) {
    case xnav_eItemType_Attr:
    case xnav_eItemType_AttrArrayElem:
    case xnav_eItemType_Collect:
      sts = item->open_children(xattnav->brow, 0, 0);
      if (ODD(sts))
        break;

      if (xattnav->advanced_user && xattnav->change_value_cb)
        (xattnav->change_value_cb)(xattnav->parent_ctx);
      break;
    case xnav_eItemType_AttrArray:
      ((ItemAttrArray*)item)->open_attributes(xattnav->brow, 0, 0);
      break;
    case xnav_eItemType_AttrObject:
      ((ItemAttrObject*)item)->open_attributes(xattnav->brow, 0, 0);
      break;
    case xnav_eItemType_Enum:
      if (xattnav->advanced_user)
        ((ItemEnum*)item)->set_value();
      break;
    case xnav_eItemType_Mask:
      if (xattnav->advanced_user)
        ((ItemMask*)item)->toggle_value();
      break;
    default:;
    }
    free(node_list);
    break;
  }
  case flow_eEvent_MB1DoubleClick:
    switch (event->object.object_type) {
    case flow_eObjectType_Node:
      brow_GetUserData(event->object.object, (void**)&item);

      switch (item->type) {
      case xnav_eItemType_Attr:
        ((ItemAttr*)item)
            ->open_children(xattnav->brow, event->object.x, event->object.y);
        break;
      case xnav_eItemType_AttrArray:
        ((ItemAttrArray*)item)
            ->open_attributes(xattnav->brow, event->object.x, event->object.y);
        break;
      case xnav_eItemType_AttrObject:
        ((ItemAttrObject*)item)
            ->open_attributes(xattnav->brow, event->object.x, event->object.y);
        break;
      case xnav_eItemType_AttrArrayElem:
        ((ItemAttrArrayElem*)item)
            ->open_children(xattnav->brow, event->object.x, event->object.y);
        break;
      case xnav_eItemType_Crossref:
        if (xattnav->start_trace_cb) {
          (xattnav->start_trace_cb)(xattnav->parent_ctx, item->objid,
              ((ItemCrossref*)item)->ref_name);
          if (xattnav->close_cb) {
            (xattnav->close_cb)(xattnav->parent_ctx);
            return FLOW__TERMINATED;
          }
        }
        break;
      default:;
      }
      break;
    default:;
    }
    break;
  case flow_eEvent_Radiobutton: {
    switch (event->object.object_type) {
    case flow_eObjectType_Node:
      brow_GetUserData(event->object.object, (void**)&item);
      switch (item->type) {
      case xnav_eItemType_Enum:
        if (!event->radiobutton.value)
          ((ItemEnum*)item)->set_value();
        break;
      case xnav_eItemType_Mask:
        ((ItemMask*)item)->set_value(!event->radiobutton.value);
        break;
      default:;
      }
      break;
    default:;
    }
    break;
  }
  case flow_eEvent_Map: {
    xattnav->displayed = 1;
    break;
  }

  default:;
  }
  return 1;
}

int XAttNav::trace_connect_bc(
    brow_tObject object, char* name, char* attr, flow_eTraceType type, void** p)
{
  pwr_tAName attr_str;
  int sts;
  Item* base_item;

  /*  printf( "Connecting %s.%s\n", name, attr);  */

  if (streq(name, ""))
    return 1;

  brow_GetUserData(object, (void**)&base_item);
  switch (base_item->type) {
  case xnav_eItemType_Attr:
  case xnav_eItemType_Enum:
  case xnav_eItemType_Mask:
  case xnav_eItemType_AttrArrayElem:
  case xnav_eItemType_Collect: {
    ItemAttr* item;

    item = (ItemAttr*)base_item;
    strcpy(attr_str, name);
    strcat(attr_str, ".");
    strcat(attr_str, attr);
    sts = gdh_RefObjectInfo(attr_str, p, &item->subid, item->size);
    if (EVEN(sts))
      return sts;
    break;
  }
  default:;
  }
  return 1;
}

int XAttNav::trace_disconnect_bc(brow_tObject object)
{
  Item* base_item;

  brow_GetUserData(object, (void**)&base_item);
  switch (base_item->type) {
  case xnav_eItemType_Attr:
  case xnav_eItemType_AttrArrayElem: {
    ItemAttr* item = (ItemAttr*)base_item;

    gdh_UnrefObjectInfo(item->subid);
    break;
  }
  default:;
  }
  return 1;
}

int XAttNav::trace_scan_bc(brow_tObject object, void* p)
{
  Item* base_item;
  char buf[500];
  int len;

  brow_GetUserData(object, (void**)&base_item);
  switch (base_item->type) {
  case xnav_eItemType_Attr:
  case xnav_eItemType_AttrArrayElem:
  case xnav_eItemType_Collect: {
    ItemAttr* item;

    item = (ItemAttr*)base_item;

    if (item->type == xnav_eItemType_Collect) {
      // Add signal flags
      XAttNav* xattnav;
      brow_GetCtxUserData(brow_GetCtx(item->node), (void**)&xattnav);
      try {
        ((ItemCollect*)item)->set_signal_flags(xattnav->brow);
      } catch (co_error&) {
      }
    }

    if (!item->first_scan) {
      if (item->size > (int)sizeof(item->old_value)
          && item->type_id == pwr_eType_String
          && strlen((char*)p) < sizeof(item->old_value)
          && streq((char*)p, item->old_value))
        // No change since last time
        return 1;
      else if (memcmp(item->old_value, p, item->size) == 0)
        // No change since last time
        return 1;
    } else
      item->first_scan = 0;

    XNav::attrvalue_to_string(item->type_id, item->tid, p, buf, sizeof(buf),
        &len, NULL, item->conversion);
    brow_SetAnnotation(object, 1, buf, len);
    memcpy(item->old_value, p, MIN(item->size, (int)sizeof(item->old_value)));
    break;
  }
  case xnav_eItemType_Enum: {
    ItemEnum* item;

    item = (ItemEnum*)base_item;
    if (!item->first_scan) {
      if (memcmp(item->old_value, p, sizeof(pwr_tEnum)) == 0)
        // No change since last time
        return 1;
    } else
      item->first_scan = 0;

    if (*(pwr_tEnum*)p == item->num)
      brow_SetRadiobutton(object, 0, 1);
    else
      brow_SetRadiobutton(object, 0, 0);
    memcpy(item->old_value, p, sizeof(pwr_tEnum));
    break;
  }
  case xnav_eItemType_Mask: {
    ItemMask* item;

    item = (ItemMask*)base_item;
    if (!item->first_scan) {
      if (memcmp(item->old_value, p, sizeof(pwr_tMask)) == 0)
        // No change since last time
        return 1;
    } else
      item->first_scan = 0;

    if (*(pwr_tMask*)p & item->num)
      brow_SetRadiobutton(object, 0, 1);
    else
      brow_SetRadiobutton(object, 0, 0);
    memcpy(item->old_value, p, sizeof(pwr_tMask));
    break;
  }
  default:;
  }
  return 1;
}

void XAttNav::trace_scan(void* data)
{
  XAttNav* xattnav = (XAttNav*)data;

  if (xattnav->trace_started) {
    brow_TraceScan(xattnav->brow->ctx);

    xattnav->trace_timerid->add(xattnav->scantime, trace_scan, xattnav);
  }
}

void XAttNav::enable_events()
{
  brow_EnableEvent(
      brow->ctx, flow_eEvent_MB1Click, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_MB1DoubleClick, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_MB3Press, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_MB3Down, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_SelectClear, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_ObjectDeleted, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_Key_Up, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_Key_Down, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_Key_Right, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_Key_Left, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_Key_PF3, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_Radiobutton, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_Map, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_Key_PageUp, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_Key_PageDown, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_ScrollUp, flow_eEventType_CallBack, brow_cb);
  brow_EnableEvent(
      brow->ctx, flow_eEvent_ScrollDown, flow_eEventType_CallBack, brow_cb);
}

//
// Backcall routine called at creation of the brow widget
// Enable event, create nodeclasses and insert the root objects.
//
int XAttNav::init_brow_cb(FlowCtx* fctx, void* client_data)
{
  int sts;
  XAttNav* xattnav = (XAttNav*)client_data;
  BrowCtx* ctx = (BrowCtx*)fctx;

  xattnav->brow = new XNavBrow(ctx, (void*)xattnav, brow_eUserType_XAttNav);

  xattnav->brow->brow_setup();
  xattnav->brow->create_nodeclasses();
  xattnav->enable_events();

  // Create the items
  if (xattnav->init_cb)
    (xattnav->init_cb)(xattnav->parent_ctx);

  sts = brow_TraceInit(
      ctx, trace_connect_bc, trace_disconnect_bc, trace_scan_bc);
  xattnav->trace_started = 1;

  trace_scan(xattnav);

  return 1;
}

int XAttNav::object_exist(brow_tObject object)
{
  brow_tObject* object_list;
  int object_cnt;
  int i;

  brow_GetObjectList(brow->ctx, &object_list, &object_cnt);
  for (i = 0; i < object_cnt; i++) {
    if (object_list[i] == object)
      return 1;
  }
  return 0;
}

//
// Set attribute value
//
int XAttNav::set_attr_value(brow_tObject node, char* name, char* value_str)
{
  Item* base_item;
  int sts;
  char buff[1024];
  pwr_tAName attr_str;

  // Check authorization
  if (is_authorized_cb) {
    if (!(is_authorized_cb(
            parent_ctx, pwr_mAccess_RtWrite | pwr_mAccess_System))) {
      message('E', "Not authorized for this operation");
      return XATT__NOTAUTHORIZED;
    }
  }

  // Check that object still exist
  if (!object_exist(node))
    return XATT__DISAPPEARD;

  brow_GetUserData(node, (void**)&base_item);

  switch (base_item->type) {
  case xnav_eItemType_AttrArrayElem:
  case xnav_eItemType_Attr:
  case xnav_eItemType_Collect: {
    ItemAttr* item = (ItemAttr*)base_item;

    // Check that objid is still the same
    if (!streq(item->attr, name))
      return XATT__DISAPPEARD;

    sts = gdh_ObjidToName(
        item->objid, attr_str, sizeof(attr_str), cdh_mName_volumeStrict);
    if (EVEN(sts))
      return sts;
    strcat(attr_str, ".");
    strcat(attr_str, item->attr);

    sts = XNav::attr_string_to_value(
        item->type_id, value_str, buff, sizeof(buff), item->size);
    if (EVEN(sts))
      message('E', "Input syntax error");
    else {
      sts = gdh_SetObjectInfo(attr_str, buff, item->size);
      if (EVEN(sts))
        return sts;
    }
    return sts;
  }
  default:;
  }
  return 1;
}

void XAttNav::redraw()
{
  brow_Redraw(brow->ctx, 0);
}

int XAttNav::select_by_name(char* name)
{
  Item* base_item;
  brow_tObject* object_list;
  int object_cnt;
  int i;
  int found;
  brow_tObject object = NULL;

  brow_GetObjectList(brow->ctx, &object_list, &object_cnt);
  found = 0;
  for (i = 0; i < object_cnt; i++) {
    brow_GetUserData(object_list[i], (void**)&base_item);

    switch (base_item->type) {
    case xnav_eItemType_Attr:
    case xnav_eItemType_AttrArrayElem: {
      ItemBaseAttr* item = (ItemBaseAttr*)base_item;

      if (streq(name, item->attr)) {
        object = object_list[i];
        found = 1;
      }
      break;
    }
    default:;
    }
    if (found)
      break;
  }
  if (!found)
    return XATT__ATTRNOTFOUND;

  brow_SelectClear(brow->ctx);
  brow_SetInverse(object, 1);
  brow_SelectInsert(brow->ctx, object);
  return XATT__SUCCESS;
}

void XAttNav::start_trace()
{
  brow_tNode* node_list;
  int node_count;
  ItemCrossref* item;

  brow_GetSelectedNodes(brow->ctx, &node_list, &node_count);
  if (!node_count)
    return;

  brow_GetUserData(node_list[0], (void**)&item);
  free(node_list);

  switch (item->type) {
  case xnav_eItemType_Crossref:
    if (start_trace_cb)
      (start_trace_cb)(parent_ctx, item->objid, item->ref_name);
    break;
  default:;
  }
}

int XAttNav::get_select(pwr_tAttrRef* arp)
{
  brow_tNode* node_list;
  int node_count;
  ItemCollect* item;
  pwr_tStatus sts;

  brow_GetSelectedNodes(brow->ctx, &node_list, &node_count);
  if (node_count != 1)
    return 0;

  brow_GetUserData(node_list[0], (void**)&item);
  free(node_list);

  switch (item->type) {
  case xnav_eItemType_Collect:
    sts = gdh_NameToAttrref(pwr_cNObjid, item->name, arp);
    if (EVEN(sts))
      return sts;
    break;
  default:
    return 0;
  }
  return XATT__SUCCESS;
}

void XAttNav::swap(int mode)
{
  if (mode == 0) {
    if (trace_started) {
      brow_TraceClose(brow->ctx);
      trace_timerid->remove();
    }
  } else if (mode == 1) {
    if (trace_started) {
      brow_TraceInit(
          brow->ctx, trace_connect_bc, trace_disconnect_bc, trace_scan_bc);
      trace_scan(this);
    }
  }
}

//
//  Get zoom
//
void XAttNav::get_zoom(double* zoom_factor)
{
  brow_GetZoom(brow->ctx, zoom_factor);
}

//
//  Zoom
//
void XAttNav::zoom(double zoom_factor)
{
  brow_Zoom(brow->ctx, zoom_factor);
}

//
//  Return to base zoom factor
//
void XAttNav::unzoom()
{
  brow_UnZoom(brow->ctx);
}
