/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include "co_cdh.h"
#include "co_string.h"

#include "rt_gdh_msg.h"
#include "rt_xnav_msg.h"

#include "cow_wow.h"

#include "glow_curveapi.h"

#include "xtt_xnav.h"
#include "xtt_trend.h"

XttTrend::XttTrend(void* parent_ctx, char* name, pwr_sAttrRef* trend_list,
    pwr_sAttrRef* plotgroup, unsigned int x_options, int xn_color_theme,
    int* sts)
    : xnav(parent_ctx), trend_cnt(0), gcd(0), curve(0), update_time(1000),
      options(x_options), timerid(0), close_cb(0), help_cb(0), command_cb(0),
      get_select_cb(0), color_theme(xn_color_theme), otree(0)
{
  pwr_sAttrRef* aref_list;
  pwr_sAttrRef* aref_p;
  pwr_sAttrRef plot_trends[XTT_TREND_MAX];
  pwr_sClass_PlotGroup plot;
  pwr_tAName object_name[XTT_TREND_MAX];
  pwr_sClass_DsTrend tp[XTT_TREND_MAX];
  pwr_tAName plot_name;
  int i, j, k;
  int start_idx;
  int time;
  pwr_tTid tid;
  int trend_buff_size
      = (int)sizeof(trend_p[0]->DataBuffer) / sizeof(trend_p[0]->DataBuffer[0]);

  *sts = XNAV__SUCCESS;

  memset(cb_info, 0, sizeof(cb_info));

  if (trend_list) {
    // List of trend objects as input
    aref_list = trend_list;
  } else {
    // Plotgroup as input
    *sts = gdh_AttrrefToName(
        plotgroup, plot_name, sizeof(plot_name), cdh_mNName);
    if (EVEN(*sts))
      return;

    *sts = gdh_GetObjectInfo(plot_name, &plot, sizeof(plot));
    if (EVEN(*sts))
      return;

    for (i = 0; i < 20; i++) {
      if (cdh_ObjidIsNull(plot.YObjectName[i].Objid))
        break;
      plot_trends[i] = plot.YObjectName[i];
    }
    plot_trends[i] = pwr_cNAttrRef;
    aref_list = plot_trends;
  }

  for (aref_p = aref_list; cdh_ObjidIsNotNull(aref_p->Objid); aref_p++) {
    *sts = gdh_GetAttrRefTid(aref_p, &tid);
    if (EVEN(*sts))
      return;

    trend_tid = tid;
  }

  if (trend_tid == pwr_cClass_DsTrend) {
    // Get current status of the trend objects
    i = 0;
    aref_p = aref_list;
    while (cdh_ObjidIsNotNull(aref_p->Objid)) {
      *sts = gdh_AttrrefToName(
          aref_p, trend_name[i], sizeof(trend_name[0]), cdh_mNName);
      if (EVEN(*sts))
        return;

      *sts = gdh_GetObjectInfo(trend_name[i], &tp[i], sizeof(tp[0]));
      if (EVEN(*sts))
        return;

      *sts = gdh_AttrrefToName(
          &tp[i].DataName, object_name[i], sizeof(object_name[0]), cdh_mNName);
      if (EVEN(*sts))
        return;

      i++;
      aref_p++;
    }
    trend_cnt = i;

    if (trend_cnt == 0) {
      *sts = XNAV__TRENDCONFIG;
      return;
    }

    // Calculate number of points
    max_time = 0;
    min_interval = 100000;
    for (i = 0; i < trend_cnt; i++) {
      time = tp[i].Multiple * tp[i].ScanTime * tp[i].NoOfBuffers
          * tp[i].NoOfSample;
      if (time > max_time)
        max_time = time;

      if ((int)(tp[i].Multiple * tp[i].ScanTime) < min_interval) {
        min_interval = tp[i].Multiple * tp[i].ScanTime;
        min_interval_idx = i;
      }
    }

    if (min_interval == 0) {
      *sts = XNAV__TRENDCONFIG;
      return;
    }

    max_points = max_time / min_interval;

    for (i = 0; i < trend_cnt; i++) {
      interval[i] = tp[i].Multiple * tp[i].ScanTime / min_interval;
    }

    // Create data for time axis
    gcd = new GeCurveData(curve_eDataType_DsTrend);
    gcd->x_data[0] = (double*)malloc(8 * max_points);
    strcpy(gcd->x_name, "Time");
    for (j = 0; j < max_points; j++) {
      gcd->x_data[0][j] = double(j * min_interval);
    }
    gcd->x_axis_type[0] = curve_eAxis_x;

    for (i = 0; i < trend_cnt; i++) {
      gcd->y_data[i] = (double*)calloc(1, 8 * max_points);

      int write_buffer = (int)tp[i].WriteBuffer;
      start_idx = write_buffer * trend_buff_size / 2
          + int(tp[i].NextWriteIndex[write_buffer]);
      if (start_idx == 0) {
        start_idx = tp[i].NoOfSample - 1 + trend_buff_size / 2;
        write_buffer = 1;
      } else if (start_idx == trend_buff_size / 2) {
        start_idx = tp[i].NoOfSample - 1;
        write_buffer = 0;
      } else
        start_idx--;

      int idx = 0;
      for (j = start_idx; j >= write_buffer * trend_buff_size / 2; j--) {
        for (k = 0; k < interval[i]; k++) {
          gcd->y_data[i][idx] = tp[i].DataBuffer[j];
          idx++;
        }
      }
      for (j = tp[i].NoOfSample - 1 + (!write_buffer) * trend_buff_size / 2;
           j >= (!write_buffer) * trend_buff_size / 2; j--) {
        for (k = 0; k < interval[i]; k++) {
          gcd->y_data[i][idx] = tp[i].DataBuffer[j];
          idx++;
        }
      }
      if (start_idx
          != (int)tp[i].NoOfSample - 1 + write_buffer * trend_buff_size / 2) {
        for (j = tp[i].NoOfSample - 1 + write_buffer * trend_buff_size / 2;
             j > start_idx; j--) {
          for (k = 0; k < interval[i]; k++) {
            gcd->y_data[i][idx] = tp[i].DataBuffer[j];
            idx++;
          }
        }
      }
      last_buffer[i] = tp[i].WriteBuffer;
      last_next_index[i] = tp[i].NextWriteIndex[last_buffer[i]];
      gcd->y_axis_type[i] = curve_eAxis_y;
    }

    // Subscribe to object
    for (i = 0; i < trend_cnt; i++) {
      *sts = gdh_RefObjectInfo(trend_name[i], (pwr_tAddress*)&trend_p[i],
          &subid[i], sizeof(pwr_sClass_DsTrend));
      if (EVEN(*sts))
        return;

      strcpy(gcd->y_name[i], object_name[i]);

      switch (trend_p[i]->DataType) {
      case pwr_eType_Float32:
      case pwr_eType_Int32:
      case pwr_eType_UInt32:
        element_size[i] = 4;
        break;
      case pwr_eType_Float64:
      case pwr_eType_Int64:
      case pwr_eType_UInt64:
        element_size[i] = 8;
        break;
      case pwr_eType_Int16:
      case pwr_eType_UInt16:
        element_size[i] = 2;
        break;
      case pwr_eType_Int8:
      case pwr_eType_UInt8:
        element_size[i] = 1;
        break;
      default:
        element_size[i] = 4;
      }
      gcd->rows[i] = max_points;
      gcd->y_orig_type[i] = (pwr_eType)trend_p[i]->DataType;
    }
    gcd->cols = trend_cnt;
    gcd->x_reverse = 1;
    gcd->get_borders();
    gcd->get_default_axis();
    gcd->select_color(0);

    // Try to find unit and descripion
    for (i = 0; i < trend_cnt; i++) {
      pwr_tAName aname;
      char unit[40];
      char description[80];
      pwr_tStatus lsts;
      char* s;

      strcpy(aname, object_name[i]);
      if ((s = strrchr(aname, '.')))
        *s = 0;
      strcat(aname, ".Unit");
      lsts = gdh_GetObjectInfo(aname, unit, sizeof(unit));
      if (ODD(lsts))
        strncpy(gcd->y_unit[i], unit, sizeof(gcd->y_unit[0]));

      strcpy(aname, object_name[i]);
      if ((s = strrchr(aname, '.')))
        *s = 0;
      strcat(aname, ".Description");
      lsts = gdh_GetObjectInfo(aname, description, sizeof(description));
      if (ODD(lsts))
        strncpy(
            gcd->y_description[i], description, sizeof(gcd->y_description[0]));
    }

    if (!trend_list) {
      // Use axis values from plotgroup object
      for (i = 0; i < trend_cnt; i++) {
        if (plot.YMinValue[i] != plot.YMaxValue[i])
          gcd->scale(gcd->y_axis_type[i], gcd->y_value_type[i],
              plot.YMinValue[i], plot.YMaxValue[i], &gcd->y_min_value_axis[i],
              &gcd->y_max_value_axis[i], &gcd->y_trend_lines[i],
              &gcd->y_axis_lines[i], &gcd->y_axis_linelongq[i],
              &gcd->y_axis_valueq[i], gcd->y_format[i], &gcd->y_axis_width[i],
              1, 1);
      }
    }
  } else if (trend_tid == pwr_cClass_DsTrendCurve) {
    pwr_sClass_DsTrendCurve tcp[XTT_TREND_MAX];
    unsigned int actual_data_size[XTT_TREND_MAX];
    double fmin_interval = 0.0;
    int tcp_i;

    // Get current status of the trend objects
    i = 0;
    tcp_i = 0;
    max_points = 0;

    for (aref_p = aref_list; cdh_ObjidIsNotNull(aref_p->Objid); aref_p++) {
      *sts = gdh_AttrrefToName(
          aref_p, trend_name[i], sizeof(trend_name[0]), cdh_mNName);
      if (EVEN(*sts))
        return;

      *sts = gdh_GetObjectInfo(trend_name[i], &tcp[tcp_i], sizeof(tcp[0]));
      if (EVEN(*sts))
        return;

      for (int j = 0; j < 10; j++) {
        if (cdh_ObjidIsNotNull(tcp[tcp_i].Attribute[j].Objid)
            && cdh_ObjidIsNotNull(tcp[tcp_i].Buffers[j].Objid)) {
          *sts = gdh_AttrrefToName(&tcp[tcp_i].Buffers[j], object_name[i],
              sizeof(object_name[0]), cdh_mNName);
          if (EVEN(*sts))
            return;

          *sts = gdh_AttrrefToName(&tcp[tcp_i].Attribute[j], object_name[i],
              sizeof(object_name[0]), cdh_mNName);
          if (EVEN(*sts))
            return;

          element_size[i]
              = cdh_TypeToSize((pwr_eType)tcp[tcp_i].AttributeType[j]);
          element_type[i] = (pwr_eType)tcp[tcp_i].AttributeType[j];
          cb_info[i].resolution = tcp[tcp_i].DisplayResolution;
          if (cb_info[i].resolution <= 0)
            cb_info[i].resolution = 1;
          cb_info[i].samples = tcp[tcp_i].DisplayTime / tcp[tcp_i].ScanTime
              / cb_info[i].resolution;
          cb_info[i].bufsize = cb_info[i].samples * element_size[i];
          cb_info[i].bufp = (char*)calloc(1, cb_info[i].bufsize);
          cb_info[i].circ_aref = tcp[tcp_i].Buffers[j];
          *sts = cbuf_GetCircBuffInfo(&cb_info[i], 1);
          if (EVEN(*sts))
            continue;

          actual_data_size[i] = cb_info[i].size;
          if (actual_data_size[i] > cb_info[i].bufsize)
            printf("** Sample size error !!!\n");

          if (tcp[tcp_i].Function & 2)
            options |= curve_mOptions_ShowDescrFirst;
          i++;
        }
      }
      if (tcp_i == 0) {
        update_time = tcp[0].DisplayUpdateTime * 1000;
        fmin_interval = tcp[0].ScanTime;
      }
      tcp_i++;
    }
    trend_cnt = i;

    if (trend_cnt == 0) {
      *sts = XNAV__TRENDCONFIG;
      return;
    }

    for (i = 0; i < trend_cnt; i++) {
      if ((int)cb_info[i].samples > max_points)
        max_points = cb_info[i].samples;
    }

    // Create data for time axis
    gcd = new GeCurveData(curve_eDataType_DsTrend);
    gcd->x_data[0] = (double*)malloc(8 * max_points);
    strcpy(gcd->x_name, "Time");
    for (j = 0; j < max_points; j++) {
      gcd->x_data[0][j] = double(fmin_interval * j * tcp[0].DisplayResolution);
    }
    gcd->x_axis_type[0] = curve_eAxis_x;

    // Try to find unit
    for (i = 0; i < trend_cnt; i++) {
      pwr_tAName aname;
      char unit[40];
      char description[80];
      pwr_tStatus lsts;
      char* s;

      strcpy(aname, object_name[i]);
      if ((s = strrchr(aname, '.')))
        *s = 0;
      strcat(aname, ".Unit");
      lsts = gdh_GetObjectInfo(aname, unit, sizeof(unit));
      if (ODD(lsts))
        strncpy(gcd->y_unit[i], unit, sizeof(gcd->y_unit[0]));

      strcpy(aname, object_name[i]);
      if ((s = strrchr(aname, '.')))
        *s = 0;
      strcat(aname, ".Description");
      lsts = gdh_GetObjectInfo(aname, description, sizeof(description));
      if (ODD(lsts))
        strncpy(
            gcd->y_description[i], description, sizeof(gcd->y_description[0]));
    }

    for (i = 0; i < trend_cnt; i++) {
      gcd->y_data[i] = (double*)calloc(1, 8 * max_points);
      gcd->y_orig_type[i] = element_type[i];

      switch (element_type[i]) {
      case pwr_eType_Float32:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tFloat32*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tFloat32));
        break;
      case pwr_eType_Float64:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tFloat64*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tFloat64));
        break;
      case pwr_eType_Boolean:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tBoolean*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tBoolean));
        break;
      case pwr_eType_Int64:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tInt64*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tInt64));
        break;
      case pwr_eType_UInt64:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tUInt64*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tUInt64));
        break;
      case pwr_eType_Int32:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tInt32*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tInt32));
        break;
      case pwr_eType_UInt32:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tUInt32*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tUInt32));
        break;
      case pwr_eType_Int16:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tInt16*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tInt16));
        break;
      case pwr_eType_UInt16:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tUInt16*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tUInt16));
        break;
      case pwr_eType_Int8:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tInt8*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tInt8));
        break;
      case pwr_eType_UInt8:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tUInt8*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tUInt8));
        break;
      default:;
      }

      gcd->y_axis_type[i] = curve_eAxis_y;
      strcpy(gcd->y_name[i], object_name[i]);
      gcd->rows[i] = max_points;
    }

    gcd->cols = trend_cnt;
    gcd->x_reverse = 1;
    gcd->get_borders();
    gcd->get_default_axis();
    gcd->select_color(0);

    if (!trend_list) {
      // Use axis values from plotgroup object
      for (i = 0; i < trend_cnt; i++) {
        if (plot.YMinValue[i] != plot.YMaxValue[i])
          gcd->scale(gcd->y_axis_type[i], gcd->y_value_type[i],
              plot.YMinValue[i], plot.YMaxValue[i], &gcd->y_min_value_axis[i],
              &gcd->y_max_value_axis[i], &gcd->y_trend_lines[i],
              &gcd->y_axis_lines[i], &gcd->y_axis_linelongq[i],
              &gcd->y_axis_valueq[i], gcd->y_format[i], &gcd->y_axis_width[i],
              1, 1);
      }
    }
  }
}

XttTrend::~XttTrend()
{
  for (int i = 0; i < XTT_TREND_MAX; i++)
    if (cb_info[i].bufp)
      free(cb_info[i].bufp);
}

void XttTrend::pop()
{
  curve->pop();
}

void XttTrend::setup()
{
  if (!curve)
    return;

  if (trend_tid == pwr_cClass_DsTrendCurve)
    curve->setup(curve_mEnable_Snapshot | curve_mEnable_Add
        | curve_mEnable_CurveType | curve_mEnable_FillCurve);
  else
    curve->setup(
        curve_mEnable_Add | curve_mEnable_CurveType | curve_mEnable_FillCurve);
}

void XttTrend::trend_close_cb(void* ctx)
{
  XttTrend* trend = (XttTrend*)ctx;

  if (trend->close_cb)
    (trend->close_cb)(trend->xnav, trend);
  else
    delete trend;
}

void XttTrend::trend_snapshot_cb(void* ctx)
{
  XttTrend* trend = (XttTrend*)ctx;
  char cmd[820];

  sprintf(cmd, "open tcurve %s/title=%s", trend->trend_name[0],
      trend->trend_name[0]);

  if (trend->command_cb)
    (trend->command_cb)(trend->xnav, cmd);
}

void XttTrend::trend_madd_cb(void* ctx)
{
  XttTrend* trend = (XttTrend*)ctx;

  if (trend->otree)
    trend->otree->pop();
  else {
    pwr_tAttrRef* list;
    int listcnt;
    pwr_tCid cid[2] = { pwr_cClass_DsTrend, pwr_cClass_DsTrendCurve };
    int options = 0;
    pwr_tStatus sts;

    sts = gdh_GetGlobalClassList(2, cid, 1, &list, &listcnt);
    if (EVEN(sts))
      return;

    if (!listcnt)
      return;

    if (listcnt > 20)
      options |= tree_mOptions_LayoutTree;
    else
      options |= tree_mOptions_LayoutList;
    options |= tree_mOptions_AlphaOrder;

    trend->otree = trend->tree_new(
        "Add attribute", list, listcnt, options, trend_otree_action_cb);
    trend->otree->close_cb = trend_otree_close_cb;

    free((char*)list);
  }
}

pwr_tStatus XttTrend::trend_otree_action_cb(void* ctx, pwr_tAttrRef* aref)
{
  XttTrend* trend = (XttTrend*)ctx;
  pwr_tStatus sts;

  trend->curve_add(aref, 0, &sts);
  if (EVEN(sts))
    printf("Trend add failure\n");
  return sts;
}

void XttTrend::trend_otree_close_cb(void* ctx)
{
  XttTrend* trend = (XttTrend*)ctx;

  if (trend->otree) {
    delete trend->otree;
    trend->otree = 0;
  }
}

void XttTrend::trend_add_cb(void* ctx)
{
  trend_madd_cb(ctx);
}

void XttTrend::trend_help_cb(void* ctx)
{
  XttTrend* trend = (XttTrend*)ctx;

  if (trend->help_cb)
    (trend->help_cb)(trend->xnav, "opg_trend");
}

void XttTrend::trend_scan(void* data)
{
  XttTrend* trend = (XttTrend*)data;
  int i, j, k;

  if (trend->trend_tid == pwr_cClass_DsTrend) {
    int write_buffer;
    int idx;
    int values;
    unsigned int size = 1;
    int trend_buff_size = (int)sizeof(trend->trend_p[0]->DataBuffer)
        / sizeof(trend->trend_p[0]->DataBuffer[0]);

    // Check if any new value
    i = trend->min_interval_idx;
    if (trend->trend_p[i]->NextWriteIndex[trend->trend_p[i]->WriteBuffer]
        != trend->last_next_index[i]) {
      values = trend->trend_p[i]->NextWriteIndex[trend->trend_p[i]->WriteBuffer]
          - trend->last_next_index[i];
      if (values < 0)
        values = values + trend->trend_p[i]->NoOfSample;

      trend->last_next_index[i]
          = trend->trend_p[i]->NextWriteIndex[trend->trend_p[i]->WriteBuffer];

      for (k = 0; k < values; k++) {
        // Add new points
        for (i = 0; i < trend->trend_cnt; i++) {
          // Shift data
          for (j = trend->max_points - 1; j > 0; j--)
            trend->gcd->y_data[i][j] = trend->gcd->y_data[i][j - 1];
          // Insert new value
          write_buffer = trend->trend_p[i]->WriteBuffer;
          idx = write_buffer * trend_buff_size / 2
              + int(trend->trend_p[i]->NextWriteIndex[write_buffer])
              - (values - 1 - k);
	  if (idx < 0)
	    idx += trend_buff_size;
          trend->gcd->y_data[i][0] = trend->trend_p[i]->DataBuffer[idx];
        }
        trend->curve->points_added(&size);
      }
    }
  } else if (trend->trend_tid == pwr_cClass_DsTrendCurve) {
    pwr_tStatus sts;
    unsigned int size[CURVE_MAX_COLS];

    sts = cbuf_UpdateCircBuffInfo(trend->cb_info, trend->trend_cnt);
    if (EVEN(sts))
      return;

    for (i = 0; i < trend->trend_cnt; i++) {
      size[i] = trend->cb_info[i].size;
      if (size[i] > 0) {
        // Shift data

        for (j = trend->cb_info[i].samples - 1; j >= (int)size[i]; j--) {
          if (j < trend->gcd->rows[i])
            trend->gcd->y_data[i][j] = trend->gcd->y_data[i][j - size[i]];
        }

        // Insert new value
        size[i] = MIN((int)size[i], trend->max_points);
        switch (trend->element_type[i]) {
        case pwr_eType_Float64:
          for (j = 0; j < (int)size[i]; j++)
            trend->gcd->y_data[i][j]
                = *(pwr_tFloat64*)((char*)trend->cb_info[i].bufp
                    + (size[i] - j - 1) * sizeof(pwr_tFloat64));
          break;
        case pwr_eType_Float32:
          for (j = 0; j < (int)size[i]; j++)
            trend->gcd->y_data[i][j]
                = *(pwr_tFloat32*)((char*)trend->cb_info[i].bufp
                    + (size[i] - j - 1) * sizeof(pwr_tFloat32));
          break;
        case pwr_eType_Boolean:
          for (j = 0; j < (int)size[i]; j++)
            trend->gcd->y_data[i][j]
                = *(pwr_tBoolean*)((char*)trend->cb_info[i].bufp
                    + (size[i] - j - 1) * sizeof(pwr_tBoolean));
          break;
        case pwr_eType_Int64:
          for (j = 0; j < (int)size[i]; j++)
            trend->gcd->y_data[i][j]
                = *(pwr_tInt64*)((char*)trend->cb_info[i].bufp
                    + (size[i] - j - 1) * sizeof(pwr_tInt64));
          break;
        case pwr_eType_UInt64:
          for (j = 0; j < (int)size[i]; j++)
            trend->gcd->y_data[i][j]
                = *(pwr_tUInt64*)((char*)trend->cb_info[i].bufp
                    + (size[i] - j - 1) * sizeof(pwr_tUInt64));
          break;
        case pwr_eType_Int32:
          for (j = 0; j < (int)size[i]; j++)
            trend->gcd->y_data[i][j]
                = *(pwr_tInt32*)((char*)trend->cb_info[i].bufp
                    + (size[i] - j - 1) * sizeof(pwr_tInt32));
          break;
        case pwr_eType_UInt32:
          for (j = 0; j < (int)size[i]; j++)
            trend->gcd->y_data[i][j]
                = *(pwr_tUInt32*)((char*)trend->cb_info[i].bufp
                    + (size[i] - j - 1) * sizeof(pwr_tUInt32));
          break;
        case pwr_eType_Int16:
          for (j = 0; j < (int)size[i]; j++)
            trend->gcd->y_data[i][j]
                = *(pwr_tInt16*)((char*)trend->cb_info[i].bufp
                    + (size[i] - j - 1) * sizeof(pwr_tInt16));
          break;
        case pwr_eType_UInt16:
          for (j = 0; j < (int)size[i]; j++)
            trend->gcd->y_data[i][j]
                = *(pwr_tUInt16*)((char*)trend->cb_info[i].bufp
                    + (size[i] - j - 1) * sizeof(pwr_tUInt16));
          break;
        case pwr_eType_Int8:
          for (j = 0; j < (int)size[i]; j++)
            trend->gcd->y_data[i][j]
                = *(pwr_tInt8*)((char*)trend->cb_info[i].bufp
                    + (size[i] - j - 1) * sizeof(pwr_tInt8));
          break;
        case pwr_eType_UInt8:
          for (j = 0; j < (int)size[i]; j++)
            trend->gcd->y_data[i][j]
                = *(pwr_tUInt8*)((char*)trend->cb_info[i].bufp
                    + (size[i] - j - 1) * sizeof(pwr_tUInt8));
          break;
        default:;
        }
      }
    }
    trend->curve->points_added(size);
  }
  trend->timerid->add(trend->update_time, trend_scan, trend);
}

void XttTrend::curve_add(
    pwr_tAttrRef* arp, pwr_tAttrRef* trend_arp, pwr_tStatus* sts)
{
  pwr_tTid tid;
  pwr_tAttrRef defaref, deftrend;
  pwr_tAttrRef trend_aref, attr_aref;
  pwr_tStatus lsts;
  pwr_tObjid child;
  int trend_found = 0;
  int attr_found = 0;
  unsigned int trend_idx[20];
  unsigned int trend_idx_cnt = 0;

  *sts = XNAV__SUCCESS;

  if (trend_cnt == XTT_TREND_MAX) {
    *sts = 0;
    return;
  }

  if (trend_arp) {
    trend_aref = *trend_arp;
    trend_found = 1;
    if (arp) {
      attr_found = 1;
      attr_aref = *arp;
    }
  }

  if (!trend_found) {
    *sts = gdh_GetAttrRefTid(arp, &tid);
    if (EVEN(*sts))
      return;

    switch (tid) {
    case pwr_cClass_DsTrend:
      trend_aref = *arp;
      trend_found = 1;
      break;
    case pwr_cClass_DsTrendCurve:
      trend_aref = *arp;
      trend_found = 1;
      break;
    default:
      // Get DefaultTrend
      *sts = gdh_ArefANameToAref(arp, "DefTrend", &defaref);
      if (ODD(*sts)) {
        *sts = gdh_GetObjectInfoAttrref(&defaref, &deftrend, sizeof(deftrend));
        if (EVEN(*sts))
          return;

        *sts = gdh_GetAttrRefTid(&deftrend, &tid);
        if (ODD(*sts)) {
          switch (tid) {
          case pwr_cClass_DsTrend:
          case pwr_cClass_DsTrendCurve:
            trend_aref = deftrend;
            attr_aref = *arp;
            trend_found = 1;
            attr_found = 1;
            break;
          case pwr_cClass_PlotGroup: {
            pwr_sClass_PlotGroup plot;
            pwr_tAName vname;
            pwr_tAName attr_name;
            unsigned int vsize
                = sizeof(plot.YObjectName) / sizeof(plot.YObjectName[0]);

            *sts = gdh_GetObjectInfoAttrref(&deftrend, &plot, sizeof(plot));
            if (EVEN(*sts))
              return;

            for (unsigned int i = 0; i < vsize; i++) {
              if (cdh_ObjidIsNull(plot.YObjectName[i].Objid))
                break;

              *sts = gdh_GetAttrRefTid(&plot.YObjectName[i], &tid);
              if (EVEN(*sts))
                continue;

              if (tid != trend_tid) {
                *sts = 0;
                return;
              }

              switch (tid) {
              case pwr_cClass_DsTrend: {
                pwr_sClass_DsTrend tp;

                *sts = gdh_GetObjectInfoAttrref(
                    &plot.YObjectName[i], &tp, sizeof(tp));
                if (EVEN(*sts))
                  return;

                *sts = gdh_AttrrefToName(
                    arp, attr_name, sizeof(attr_name), cdh_mName_volumeStrict);
                if (EVEN(*sts))
                  return;

                *sts = gdh_AttrrefToName(
                    &tp.DataName, vname, sizeof(vname), cdh_mName_volumeStrict);
                if (EVEN(*sts))
                  return;

                if (str_StartsWith(vname, attr_name)) {
                  trend_aref = plot.YObjectName[i];
                  trend_found = 1;
                  attr_aref = *arp;
                  attr_found = 1;
                }
                break;
              }
              case pwr_cClass_DsTrendCurve: {
                pwr_sClass_DsTrendCurve tp;
                pwr_tAName vname;
                unsigned int asize
                    = sizeof(tp.Attribute) / sizeof(tp.Attribute[0]);

                *sts = gdh_GetObjectInfoAttrref(
                    &plot.YObjectName[i], &tp, sizeof(tp));
                if (EVEN(*sts))
                  return;

                *sts = gdh_AttrrefToName(
                    arp, attr_name, sizeof(attr_name), cdh_mName_volumeStrict);

                for (unsigned int j = 0; j < asize; j++) {
                  if (cdh_ObjidIsNull(tp.Attribute[j].Objid))
                    break;

                  *sts = gdh_AttrrefToName(&tp.Attribute[j], vname,
                      sizeof(vname), cdh_mName_volumeStrict);
                  if (EVEN(*sts))
                    return;

                  if (str_StartsWith(vname, attr_name)) {
                    trend_aref = plot.YObjectName[i];
                    trend_found = 1;
                    attr_aref = *arp;
                    attr_found = 1;
                    trend_idx[trend_idx_cnt] = j;
                    trend_idx_cnt++;
                  }
                }
                break;
              }
              default:;
              }
              if (trend_found)
                break;
            }
            break;
          }
          default:
            // Search children
            for (lsts = gdh_GetChild(arp->Objid, &child); ODD(lsts);
                 lsts = gdh_GetNextSibling(child, &child)) {
              *sts = gdh_GetObjectClass(child, &tid);
              if (EVEN(*sts))
                return;

              switch (tid) {
              case pwr_cClass_DsTrend:
              case pwr_cClass_DsTrendCurve:
                trend_aref = cdh_ObjidToAref(child);
                attr_aref = *arp;
                trend_found = 1;
                attr_found = 1;
                break;
              default:;
              }
              if (trend_found)
                break;
            }
          }
        }
      }
    }
  }
  if (!trend_found) {
    *sts = 0;
    return;
  }

  *sts = gdh_GetAttrRefTid(&trend_aref, &tid);
  if (EVEN(*sts))
    return;

  if (tid != trend_tid) {
    *sts = 0;
    return;
  }

  if (trend_tid == pwr_cClass_DsTrendCurve && attr_found
      && trend_idx_cnt == 0) {
    // Find index for attribute
    pwr_sClass_DsTrendCurve tp;
    pwr_tAName attr_name, vname;
    unsigned int asize = sizeof(tp.Attribute) / sizeof(tp.Attribute[0]);

    *sts = gdh_GetObjectInfoAttrref(&trend_aref, &tp, sizeof(tp));
    if (EVEN(*sts))
      return;

    *sts = gdh_AttrrefToName(
        &attr_aref, attr_name, sizeof(attr_name), cdh_mName_volumeStrict);

    for (unsigned int j = 0; j < asize; j++) {
      if (cdh_ObjidIsNull(tp.Attribute[j].Objid))
        break;

      *sts = gdh_AttrrefToName(
          &tp.Attribute[j], vname, sizeof(vname), cdh_mName_volumeStrict);
      if (EVEN(*sts))
        return;

      if (str_StartsWith(vname, attr_name)) {
        trend_idx[trend_idx_cnt] = j;
        trend_idx_cnt++;
      }
    }
  }

  if (trend_tid == pwr_cClass_DsTrend) {
    pwr_sClass_DsTrend tp;
    pwr_tAName object_name;
    int start_idx;
    int trend_buff_size = (int)sizeof(tp.DataBuffer) / sizeof(tp.DataBuffer[0]);

    // Get current status of the trend objects
    int i = trend_cnt;
    *sts = gdh_AttrrefToName(
        &trend_aref, trend_name[i], sizeof(trend_name[0]), cdh_mNName);
    if (EVEN(*sts))
      return;

    *sts = gdh_GetObjectInfo(trend_name[i], &tp, sizeof(tp));
    if (EVEN(*sts))
      return;

    *sts = gdh_AttrrefToName(
        &tp.DataName, object_name, sizeof(object_name), cdh_mNName);
    if (EVEN(*sts))
      return;
    trend_cnt++;

    gcd->y_data[i] = (double*)calloc(1, 8 * max_points);

    interval[i] = tp.Multiple * tp.ScanTime / min_interval;

    int write_buffer = (int)tp.WriteBuffer;
    start_idx = write_buffer * trend_buff_size / 2
        + int(tp.NextWriteIndex[write_buffer]);
    if (start_idx == 0) {
      start_idx = tp.NoOfSample - 1 + trend_buff_size / 2;
      write_buffer = 1;
    } else if (start_idx == trend_buff_size / 2) {
      start_idx = tp.NoOfSample - 1;
      write_buffer = 0;
    } else
      start_idx--;

    int idx = 0;
    for (int j = start_idx; j >= write_buffer * trend_buff_size / 2; j--) {
      for (int k = 0; k < interval[i]; k++) {
        gcd->y_data[i][idx] = tp.DataBuffer[j];
        idx++;
      }
    }
    for (int j = tp.NoOfSample - 1 + (!write_buffer) * trend_buff_size / 2;
         j >= (!write_buffer) * trend_buff_size / 2; j--) {
      for (int k = 0; k < interval[i]; k++) {
        gcd->y_data[i][idx] = tp.DataBuffer[j];
        idx++;
      }
    }
    if (start_idx
        != (int)tp.NoOfSample - 1 + write_buffer * trend_buff_size / 2) {
      for (int j = tp.NoOfSample - 1 + write_buffer * trend_buff_size / 2;
           j > start_idx; j--) {
        for (int k = 0; k < interval[i]; k++) {
          gcd->y_data[i][idx] = tp.DataBuffer[j];
          idx++;
        }
      }
    }
    last_buffer[i] = tp.WriteBuffer;
    last_next_index[i] = tp.NextWriteIndex[last_buffer[i]];
    gcd->y_axis_type[i] = curve_eAxis_y;

    // Subscribe to object
    *sts = gdh_RefObjectInfo(trend_name[i], (pwr_tAddress*)&trend_p[i],
        &subid[i], sizeof(pwr_sClass_DsTrend));
    if (EVEN(*sts))
      return;

    strcpy(gcd->y_name[i], object_name);

    switch (trend_p[i]->DataType) {
    case pwr_eType_Float32:
    case pwr_eType_Int32:
    case pwr_eType_UInt32:
      element_size[i] = 4;
      break;
    case pwr_eType_Float64:
    case pwr_eType_Int64:
    case pwr_eType_UInt64:
      element_size[i] = 8;
      break;
    case pwr_eType_Int16:
    case pwr_eType_UInt16:
      element_size[i] = 2;
      break;
    case pwr_eType_Int8:
    case pwr_eType_UInt8:
      element_size[i] = 1;
      break;
    default:
      element_size[i] = 4;
    }
    gcd->rows[i] = max_points;

    gcd->cols = trend_cnt;
    gcd->get_borders();
    gcd->get_default_axis();
    gcd->select_color(0);

    // Try to find unit and descripion
    pwr_tAName aname;
    char unit[40];
    char description[80];
    pwr_tStatus lsts;
    char* s;

    strcpy(aname, object_name);
    if ((s = strrchr(aname, '.')))
      *s = 0;
    strcat(aname, ".Unit");
    lsts = gdh_GetObjectInfo(aname, unit, sizeof(unit));
    if (ODD(lsts))
      strncpy(gcd->y_unit[i], unit, sizeof(gcd->y_unit[0]));

    strcpy(aname, object_name);
    if ((s = strrchr(aname, '.')))
      *s = 0;
    strcat(aname, ".Description");
    lsts = gdh_GetObjectInfo(aname, description, sizeof(description));
    if (ODD(lsts))
      strncpy(
          gcd->y_description[i], description, sizeof(gcd->y_description[0]));

    curve->config_names();
    curve->configure_curves();
    curve->configure_axes();
  } else if (trend_tid == pwr_cClass_DsTrendCurve) {
    pwr_sClass_DsTrendCurve tcp;
    unsigned int actual_data_size[XTT_TREND_MAX];
    pwr_tAName object_name[XTT_TREND_MAX];
    int i, start_idx;

    // Get current status of the trend objects
    i = start_idx = trend_cnt;

    *sts = gdh_AttrrefToName(
        &trend_aref, trend_name[i], sizeof(trend_name[0]), cdh_mNName);
    if (EVEN(*sts))
      return;

    *sts = gdh_GetObjectInfo(trend_name[i], &tcp, sizeof(tcp));
    if (EVEN(*sts))
      return;

    i = start_idx;
    for (unsigned int j = 0; j < 10; j++) {
      if (cdh_ObjidIsNotNull(tcp.Attribute[j].Objid)
          && cdh_ObjidIsNotNull(tcp.Buffers[j].Objid)) {
        if (trend_idx_cnt > 0) {
          // Add only specific indexes
          int found = 0;
          for (unsigned int k = 0; k < trend_idx_cnt; k++) {
            if (trend_idx[k] == j) {
              found = 1;
              break;
            }
          }
          if (!found)
            continue;
        }

        *sts = gdh_AttrrefToName(&tcp.Buffers[j], object_name[i],
            sizeof(object_name[0]), cdh_mNName);
        if (EVEN(*sts))
          return;

        *sts = gdh_AttrrefToName(&tcp.Attribute[j], object_name[i],
            sizeof(object_name[0]), cdh_mNName);
        if (EVEN(*sts))
          return;

        element_size[i] = cdh_TypeToSize((pwr_eType)tcp.AttributeType[j]);
        element_type[i] = (pwr_eType)tcp.AttributeType[j];
        cb_info[i].resolution = tcp.DisplayResolution;
        if (cb_info[i].resolution <= 0)
          cb_info[i].resolution = 1;
        cb_info[i].samples
            = tcp.DisplayTime / tcp.ScanTime / cb_info[i].resolution;
        cb_info[i].bufsize = cb_info[i].samples * element_size[i];
        cb_info[i].bufp = (char*)calloc(1, cb_info[i].bufsize);
        cb_info[i].circ_aref = tcp.Buffers[j];
        *sts = cbuf_GetCircBuffInfo(&cb_info[i], 1);
        if (EVEN(*sts))
          continue;

        actual_data_size[i] = cb_info[i].size;
        if (actual_data_size[i] > cb_info[i].bufsize)
          printf("** Sample size error !!!\n");

        i++;
      }
    }
    trend_cnt = i;

    // Try to find unit
    for (i = start_idx; i < trend_cnt; i++) {
      pwr_tAName aname;
      char unit[40];
      char description[80];
      pwr_tStatus lsts;
      char* s;

      strcpy(aname, object_name[i]);
      if ((s = strrchr(aname, '.')))
        *s = 0;
      strcat(aname, ".Unit");
      lsts = gdh_GetObjectInfo(aname, unit, sizeof(unit));
      if (ODD(lsts))
        strncpy(gcd->y_unit[i], unit, sizeof(gcd->y_unit[0]));

      strcpy(aname, object_name[i]);
      if ((s = strrchr(aname, '.')))
        *s = 0;
      strcat(aname, ".Description");
      lsts = gdh_GetObjectInfo(aname, description, sizeof(description));
      if (ODD(lsts))
        strncpy(
            gcd->y_description[i], description, sizeof(gcd->y_description[0]));
    }

    for (i = start_idx; i < trend_cnt; i++) {
      gcd->y_data[i] = (double*)calloc(
          1, 8 * MAX((unsigned int)max_points, actual_data_size[i]));

      switch (element_type[i]) {
      case pwr_eType_Float32:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tFloat32*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tFloat32));
        break;
      case pwr_eType_Float64:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tFloat64*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tFloat64));
        break;
      case pwr_eType_Boolean:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tBoolean*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tBoolean));
        break;
      case pwr_eType_Int64:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tInt64*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tInt64));
        break;
      case pwr_eType_UInt64:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tUInt64*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tUInt64));
        break;
      case pwr_eType_Int32:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tInt32*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tInt32));
        break;
      case pwr_eType_UInt32:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tUInt32*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tUInt32));
        break;
      case pwr_eType_Int16:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tInt16*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tInt16));
        break;
      case pwr_eType_UInt16:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tUInt16*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tUInt16));
        break;
      case pwr_eType_Int8:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tInt8*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tInt8));
        break;
      case pwr_eType_UInt8:
        for (unsigned int j = 0; j < actual_data_size[i]; j++)
          gcd->y_data[i][j] = *(pwr_tUInt8*)((char*)cb_info[i].bufp
              + (actual_data_size[i] - j - 1) * sizeof(pwr_tUInt8));
        break;
      default:;
      }

      gcd->y_axis_type[i] = curve_eAxis_y;
      strcpy(gcd->y_name[i], object_name[i]);
      gcd->rows[i] = actual_data_size[i];
    }

    gcd->cols = trend_cnt;
    gcd->get_borders();
    gcd->get_default_axis();
    gcd->select_color(0);
    curve->config_names();
    curve->configure_curves();
    curve->configure_axes();
  }
}
