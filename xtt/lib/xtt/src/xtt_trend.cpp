/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2014 SSAB AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

#include "flow_std.h"

#include <stdio.h>
#include <stdlib.h>
#include <vector>

#include "pwr.h"
#include "pwr_baseclasses.h"
#include "rt_gdh.h"
#include "rt_cbuf.h"
#include "rt_gdh_msg.h"
#include "co_cdh.h"
#include "co_time.h"
#include "cow_wow.h"
#include "rt_xnav_msg.h"

#include "flow.h"
#include "flow_browctx.h"
#include "flow_browapi.h"
#include "glow_growctx.h"
#include "glow_growapi.h"
#include "glow_curvectx.h"
#include "glow_curveapi.h"

#include "xtt_xnav.h"
#include "xtt_trend.h"

#include "ge_curve.h"

XttTrend::XttTrend( void *parent_ctx,
		    char *name,
		    pwr_sAttrRef *trend_list,
		    pwr_sAttrRef *plotgroup,
		    unsigned int x_options,
		    int *sts) :
  xnav(parent_ctx), trend_cnt(0), update_time(1000), options(x_options), 
  close_cb(0), help_cb(0), command_cb(0), get_select_cb(0)
{
  pwr_sAttrRef *aref_list;
  pwr_sAttrRef *aref_p;
  pwr_sAttrRef plot_trends[XTT_TREND_MAX];
  pwr_sClass_PlotGroup plot;
  pwr_tAName object_name[XTT_TREND_MAX];
  pwr_sClass_DsTrend tp[XTT_TREND_MAX];
  pwr_tAName plot_name;
  int i, j, k;
  int start_idx;
  int time;
  pwr_tTid tid;
  int trend_buff_size = (int) sizeof( trend_p[0]->DataBuffer) /
                          sizeof( trend_p[0]->DataBuffer[0]);
    
  *sts = XNAV__SUCCESS;

  memset( cb_info, 0, sizeof(cb_info));

  if ( trend_list) {
    // List of trend objects as input
    aref_list = trend_list;
  }
  else {
    // Plotgroup as input
    *sts = gdh_AttrrefToName( plotgroup, plot_name, sizeof(plot_name), 
                cdh_mNName);
    if (EVEN(*sts)) return;

    *sts = gdh_GetObjectInfo( plot_name, &plot, sizeof(plot));
    if ( EVEN(*sts)) return;

    for ( i = 0; i < 20; i++) {
      if ( cdh_ObjidIsNull( plot.YObjectName[i].Objid))
        break;
      plot_trends[i] = plot.YObjectName[i];
    }
    plot_trends[i] = pwr_cNAttrRef;
    aref_list = plot_trends;
  }

  for ( aref_p = aref_list; cdh_ObjidIsNotNull( aref_p->Objid); aref_p++) {
    *sts = gdh_GetAttrRefTid( aref_p, &tid);
    if ( EVEN(*sts)) return;

    trend_tid = tid;
  }

  if ( trend_tid == pwr_cClass_DsTrend) {
    // Get current status of the trend objects
    i = 0;
    aref_p = aref_list;
    while ( cdh_ObjidIsNotNull( aref_p->Objid)) {
      *sts = gdh_AttrrefToName( aref_p, trend_name[i], sizeof(trend_name[0]), 
				cdh_mNName);
      if (EVEN(*sts)) return;
      
      *sts = gdh_GetObjectInfo( trend_name[i], &tp[i], sizeof(tp[0]));
      if ( EVEN(*sts)) return;
      
      *sts = gdh_AttrrefToName( &tp[i].DataName, object_name[i], 
				sizeof(object_name[0]), cdh_mNName);
      if (EVEN(*sts)) return;

      i++;
      aref_p++;
    }
    trend_cnt = i;

    if ( trend_cnt == 0) {
      *sts = XNAV__TRENDCONFIG;
      return;
    }

    // Calculate number of points
    max_time = 0;
    min_interval = 100000;
    for ( i = 0; i < trend_cnt; i++) {
      time = tp[i].Multiple * tp[i].ScanTime * tp[i].NoOfBuffers *
	tp[i].NoOfSample;
      if ( time > max_time)
	max_time = time;
      
      if ( (int) (tp[i].Multiple * tp[i].ScanTime) < min_interval) {
	min_interval = tp[i].Multiple * tp[i].ScanTime;
	min_interval_idx = i;
      }
    }

    if ( min_interval == 0) {
      *sts = XNAV__TRENDCONFIG;
      return;
    }
    
    max_points = max_time / min_interval;
    
    for ( i = 0; i < trend_cnt; i++) {
      interval[i] = tp[i].Multiple * tp[i].ScanTime / min_interval;
    }

    // Create data for time axis
    gcd = new GeCurveData( curve_eDataType_DsTrend);
    gcd->x_data[0] = (double *) malloc( 8 * max_points);
    strcpy( gcd->x_name, "Time");
    for ( j = 0; j < max_points; j++) {
      gcd->x_data[0][j] = double( j * min_interval);
    }
    gcd->x_axis_type[0] = curve_eAxis_x;
    
    for ( i = 0; i < trend_cnt; i++) {
      gcd->y_data[i] = (double *) calloc( 1, 8 * max_points);
      
      int write_buffer = (int) tp[i].WriteBuffer;
      start_idx = write_buffer * trend_buff_size / 2
	+ int( tp[i].NextWriteIndex[write_buffer]);
      if ( start_idx == 0) {
	start_idx = tp[i].NoOfSample - 1 + trend_buff_size / 2;
	write_buffer = 1;
      }
      else if ( start_idx == trend_buff_size / 2) {
	start_idx = tp[i].NoOfSample - 1;
	write_buffer = 0;
      }
      else
	start_idx--;
      
      int idx = 0;
      for ( j = start_idx; j >= write_buffer * trend_buff_size/2; j--) {
	for ( k = 0; k < interval[i]; k++) {
	  gcd->y_data[i][idx] = tp[i].DataBuffer[j];
	  idx++;
	}
      }
      for ( j = tp[i].NoOfSample - 1 + (!write_buffer) * trend_buff_size/2;
	    j >= (!write_buffer) * trend_buff_size/2; j--) {
	for ( k = 0; k < interval[i]; k++) {
	  gcd->y_data[i][idx] = tp[i].DataBuffer[j];
	  idx++;
	}
      }
      if ( start_idx != (int) tp[i].NoOfSample - 1 + 
	   write_buffer * trend_buff_size/2) {
	for ( j = tp[i].NoOfSample - 1 + write_buffer * trend_buff_size/2; 
	      j > start_idx; j--) {
	  for ( k = 0; k < interval[i]; k++) {
	    gcd->y_data[i][idx] = tp[i].DataBuffer[j];
	    idx++;
	  }
	}
      }
      last_buffer[i] = tp[i].WriteBuffer;
      last_next_index[i] = tp[i].NextWriteIndex[last_buffer[i]];
      gcd->y_axis_type[i] = curve_eAxis_y;
    }

    // Subscribe to object
    for ( i = 0; i < trend_cnt; i++) {
      
      *sts = gdh_RefObjectInfo( trend_name[i], (pwr_tAddress *)&trend_p[i], 
				&subid[i], sizeof(pwr_sClass_DsTrend));
      if ( EVEN(*sts)) return;
      
      strcpy( gcd->y_name[i], object_name[i]);
      
      switch( trend_p[i]->DataType) {
      case pwr_eType_Float32:
      case pwr_eType_Int32:
      case pwr_eType_UInt32:
        element_size[i] = 4;
        break;
      case pwr_eType_Float64:
      case pwr_eType_Int64:
      case pwr_eType_UInt64:
        element_size[i] = 8;
        break;
      case pwr_eType_Int16:
      case pwr_eType_UInt16:
        element_size[i] = 2;
        break;
      case pwr_eType_Int8:
      case pwr_eType_UInt8:
        element_size[i] = 1;
        break;
      default:
        element_size[i] = 4;
      }
      gcd->rows[i] = max_points;
    }
    gcd->cols = trend_cnt;
    gcd->x_reverse = 1;
    gcd->get_borders();
    gcd->get_default_axis();
    gcd->select_color( 0);
    
    // Try to find unit and descripion
    for ( i = 0; i < trend_cnt; i++) {
      pwr_tAName aname;
      char unit[40];
      char description[80];
      pwr_tStatus lsts;
      char *s;

      strcpy( aname, object_name[i]);
      if ( (s = strrchr( aname, '.')))
	*s = 0;
      strcat( aname, ".Unit");
      lsts = gdh_GetObjectInfo( aname, unit, sizeof(unit));
      if ( ODD(lsts))
	strncpy( gcd->y_unit[i], unit, sizeof(gcd->y_unit[0]));

      strcpy( aname, object_name[i]);
      if ( (s = strrchr( aname, '.')))
	*s = 0;
      strcat( aname, ".Description");
      lsts = gdh_GetObjectInfo( aname, description, sizeof(description));
      if ( ODD(lsts))
	strncpy( gcd->y_description[i], description, sizeof(gcd->y_description[0]));
    }

    if ( !trend_list) {
      // Use axis values from plotgroup object
      for ( i = 0; i < trend_cnt; i++) {
	if ( plot.YMinValue[i] != plot.YMaxValue[i])
	  gcd->scale( gcd->y_axis_type[i], gcd->y_value_type[i], 
		      plot.YMinValue[i],  plot.YMaxValue[i], 
		      &gcd->y_min_value_axis[i], &gcd->y_max_value_axis[i], 
		      &gcd->y_trend_lines[i], &gcd->y_axis_lines[i], &gcd->y_axis_linelongq[i], 
		      &gcd->y_axis_valueq[i], gcd->y_format[i], 
		      &gcd->y_axis_width[i], 1, 1);
      }
    }
  }
  else if ( trend_tid == pwr_cClass_DsTrendCurve) {
    pwr_sClass_DsTrendCurve tcp[XTT_TREND_MAX];
    unsigned int actual_data_size[XTT_TREND_MAX];
    double fmin_interval;
    int tcp_i;
    
    // Get current status of the trend objects
    i = 0;
    tcp_i = 0;
    max_points = 0;    

    for ( aref_p = aref_list; cdh_ObjidIsNotNull( aref_p->Objid); aref_p++) {
      *sts = gdh_AttrrefToName( aref_p, trend_name[i], sizeof(trend_name[0]), 
				cdh_mNName);
      if (EVEN(*sts)) return;
      
      *sts = gdh_GetObjectInfo( trend_name[i], &tcp[tcp_i], sizeof(tcp[0]));
      if ( EVEN(*sts)) return;
      
      for ( int j = 0; j < 10; j++) {
	if ( cdh_ObjidIsNotNull( tcp[tcp_i].Attribute[j].Objid) &&
	     cdh_ObjidIsNotNull( tcp[tcp_i].Buffers[j].Objid)) {
	  *sts = gdh_AttrrefToName( &tcp[tcp_i].Buffers[j], object_name[i],
				    sizeof(object_name[0]), cdh_mNName);
	  if (EVEN(*sts)) return;

	  *sts = gdh_AttrrefToName( &tcp[tcp_i].Attribute[j], object_name[i], 
				    sizeof(object_name[0]), cdh_mNName);
	  if (EVEN(*sts)) return;

	  
	  element_size[i] = cdh_TypeToSize( (pwr_eType)tcp[tcp_i].AttributeType[j]);
	  element_type[i] = (pwr_eType)tcp[tcp_i].AttributeType[j];
	  cb_info[i].resolution = tcp[tcp_i].DisplayResolution;
	  if ( cb_info[i].resolution <= 0)
	    cb_info[i].resolution = 1;
	  cb_info[i].samples = tcp[tcp_i].DisplayTime / tcp[tcp_i].ScanTime / cb_info[i].resolution;
	  cb_info[i].bufsize = cb_info[i].samples * element_size[i];
	  cb_info[i].bufp = (char *) calloc( 1, cb_info[i].bufsize);
	  cb_info[i].circ_aref = tcp[tcp_i].Buffers[j];
	  *sts = cbuf_GetCircBuffInfo( &cb_info[i], 1); 
	  if ( EVEN(*sts))
	    continue;

	  actual_data_size[i] = cb_info[i].size;
	  if ( actual_data_size[i] > cb_info[i].bufsize)
	    printf( "** Sample size error !!!\n");

	  if ( tcp[tcp_i].Function & 2)
	    options |= curve_mOptions_ShowDescrFirst;
	  i++;
	}
      }
      if ( tcp_i == 0) {
	update_time = tcp[0].DisplayUpdateTime * 1000;
	fmin_interval = tcp[0].ScanTime;
      }
      tcp_i++;
    }
    trend_cnt = i;

    if ( trend_cnt == 0) {
      *sts = XNAV__TRENDCONFIG;
      return;
    }

    for ( i = 0; i < trend_cnt; i++) {
      if ( (int)cb_info[i].samples > max_points)
	max_points = cb_info[i].samples;
    }

    // Create data for time axis
    gcd = new GeCurveData( curve_eDataType_DsTrend);
    gcd->x_data[0] = (double *) malloc( 8 * max_points);
    strcpy( gcd->x_name, "Time");
    for ( j = 0; j < max_points; j++) {
      gcd->x_data[0][j] = double( fmin_interval * j * tcp[0].DisplayResolution);
    }
    gcd->x_axis_type[0] = curve_eAxis_x;
    
    // Try to find unit
    for ( i = 0; i < trend_cnt; i++) {
      pwr_tAName aname;
      char unit[40];
      char description[80];
      pwr_tStatus lsts;
      char *s;

      strcpy( aname, object_name[i]);
      if ( (s = strrchr( aname, '.')))
	*s = 0;
      strcat( aname, ".Unit");
      lsts = gdh_GetObjectInfo( aname, unit, sizeof(unit));
      if ( ODD(lsts))
	strncpy( gcd->y_unit[i], unit, sizeof(gcd->y_unit[0]));

      strcpy( aname, object_name[i]);
      if ( (s = strrchr( aname, '.')))
	*s = 0;
      strcat( aname, ".Description");
      lsts = gdh_GetObjectInfo( aname, description, sizeof(description));
      if ( ODD(lsts))
	strncpy( gcd->y_description[i], description, sizeof(gcd->y_description[0]));
    }

    for ( i = 0; i < trend_cnt; i++) {
      gcd->y_data[i] = (double *) calloc( 1, 8 * max_points);
      
      switch ( element_type[i]) {
      case pwr_eType_Float32:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tFloat32 *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tFloat32));
	break;
      case pwr_eType_Float64:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tFloat64 *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tFloat64));
	break;
      case pwr_eType_Boolean:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tBoolean *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tBoolean));
	break;
      case pwr_eType_Int64:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tInt64 *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tInt64));
	break;
      case pwr_eType_UInt64:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tUInt64 *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tUInt64));
	break;
      case pwr_eType_Int32:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tInt32 *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tInt32));
	break;
      case pwr_eType_UInt32:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tUInt32 *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tUInt32));
	break;
      case pwr_eType_Int16:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tInt16 *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tInt16));
	break;
      case pwr_eType_UInt16:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tUInt16 *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tUInt16));
	break;
      case pwr_eType_Int8:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tInt8 *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tInt8));
	break;
      case pwr_eType_UInt8:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tUInt8 *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tUInt8));
	break;
      default: ;
      }
      
      gcd->y_axis_type[i] = curve_eAxis_y;
      strcpy( gcd->y_name[i], object_name[i]);      
      gcd->rows[i] = max_points;
    }

    gcd->cols = trend_cnt;
    gcd->x_reverse = 1;
    gcd->get_borders();
    gcd->get_default_axis();
    gcd->select_color( 0);
    
    if ( !trend_list) {
      // Use axis values from plotgroup object
      for ( i = 0; i < trend_cnt; i++) {
	if ( plot.YMinValue[i] != plot.YMaxValue[i])
	  gcd->scale( gcd->y_axis_type[i], gcd->y_value_type[i], 
		      plot.YMinValue[i],  plot.YMaxValue[i], 
		      &gcd->y_min_value_axis[i], &gcd->y_max_value_axis[i], 
		      &gcd->y_trend_lines[i], &gcd->y_axis_lines[i], &gcd->y_axis_linelongq[i], 
		      &gcd->y_axis_valueq[i], gcd->y_format[i], 
		      &gcd->y_axis_width[i], 1, 1);
      }
    }

  }
}

XttTrend::~XttTrend()
{
  for ( int i = 0; i < XTT_TREND_MAX; i++)
    if ( cb_info[i].bufp)
      free( cb_info[i].bufp);
}

void XttTrend::pop()
{
  curve->pop();
}

void XttTrend::setup()
{
  if ( trend_tid == pwr_cClass_DsTrendCurve)
    curve->setup( curve_mEnable_Snapshot | curve_mEnable_Add);
  else
    curve->setup( curve_mEnable_Add);
}

void XttTrend::trend_close_cb( void *ctx)
{
  XttTrend *trend = (XttTrend *) ctx;

  if ( trend->close_cb)
    (trend->close_cb)( trend->xnav, trend);
  else
    delete trend;
}

void XttTrend::trend_snapshot_cb( void *ctx)
{
  XttTrend *trend = (XttTrend *) ctx;
  pwr_tCmd cmd;

  sprintf( cmd, "open tcurve %s/title=%s", trend->trend_name[0], trend->trend_name[0]);

  if ( trend->command_cb)
    (trend->command_cb)( trend->xnav, cmd);
}

class AttrList {
public:
  AttrList( char *a, char *t) : attr(a), trend(t) {}
  string attr;
  string trend;
};

class AttrListCtx {
public:
  AttrListCtx( XttTrend *t) : trend(t) {}
  XttTrend *trend;
  vector<AttrList> v;
};
  
static void add_objectlist_cb( void *ctx, char *text)
{
  printf( "%s\n", text);

  pwr_tStatus sts;
  pwr_tAttrRef trend_aref, attr_aref;
  AttrListCtx *vctx = (AttrListCtx *)ctx;
  unsigned int i;
  int found = 0;

  for ( i = 0; i < vctx->v.size(); i++) {
    if ( strcmp( vctx->v[i].attr.c_str(), text) == 0) {
      found = 1;
      break;
    }
  }
  if ( !found)
    return;

  sts = gdh_NameToAttrref( pwr_cNOid, vctx->v[i].attr.c_str(), &attr_aref);
  if ( EVEN(sts)) return;

  sts = gdh_NameToAttrref( pwr_cNOid, vctx->v[i].trend.c_str(), &trend_aref);
  if ( EVEN(sts)) return;

  vctx->trend->curve_add( &attr_aref, &trend_aref, &sts);
  if ( EVEN(sts))
    printf( "Trend add failure\n");

  delete vctx;
}

static void add_objectlist_cancel_cb( void *ctx)
{
  delete (AttrListCtx *)ctx;
}

void XttTrend::trend_madd_cb( void *ctx)
{
  XttTrend *trend = (XttTrend *) ctx;
  pwr_tAttrRef trend_aref, attr_aref;
  pwr_tAName trend_name, attr_name;
  pwr_tStatus sts;
  pwr_tAName *names;
  
  printf( "Madd\n");

  AttrListCtx *vctx = new AttrListCtx(trend);

  for ( sts = gdh_GetClassListAttrRef( trend->trend_tid, &trend_aref);
	ODD(sts);
	sts = gdh_GetNextAttrRef( trend->trend_tid, &trend_aref, &trend_aref)) {
    switch ( trend->trend_tid) {
    case pwr_cClass_DsTrend: {      
      pwr_tAttrRef dataname_aref;

      sts = gdh_ArefANameToAref( &trend_aref, "DataName", &dataname_aref);
      if ( EVEN(sts)) return;

      sts = gdh_GetObjectInfoAttrref( &dataname_aref, &attr_aref, sizeof(attr_aref));  
      if ( EVEN(sts)) return;

      sts = gdh_AttrrefToName( &attr_aref, attr_name, sizeof(attr_name),
			       cdh_mNName);
      if ( EVEN(sts)) continue;

      sts = gdh_AttrrefToName( &trend_aref, trend_name, sizeof(trend_name),
			       cdh_mNName);
      if ( EVEN(sts)) continue;

      AttrList l( attr_name, trend_name);
      vctx->v.push_back(l);
      break;
    }      
    case pwr_cClass_DsTrendCurve: {      
      pwr_sClass_DsTrendCurve tp;
      unsigned int asize = sizeof(tp.Attribute)/sizeof(tp.Attribute[0]);

      sts = gdh_GetObjectInfoAttrref( &trend_aref, &tp, sizeof(tp));
      if ( EVEN(sts)) return;

      sts = gdh_AttrrefToName( &trend_aref, trend_name, sizeof(trend_name),
			       cdh_mNName);
      if ( EVEN(sts)) continue;

      for ( unsigned int j = 0; j < asize; j++) {
	if ( cdh_ObjidIsNull(tp.Attribute[j].Objid))
	  break;

	sts = gdh_AttrrefToName( &tp.Attribute[j], attr_name, sizeof(attr_name), 
				 cdh_mNName);
	if (EVEN(sts)) continue;

	AttrList l( attr_name, trend_name);
	vctx->v.push_back(l);
      }
      break;
    }
    default: ;
    }
  }

  names = (pwr_tAName *)calloc( vctx->v.size() + 1, sizeof(pwr_tAName));
  for ( unsigned int i = 0; i < vctx->v.size(); i++) {
    strcpy( names[i], vctx->v[i].attr.c_str());
  }

  // Sort
  pwr_tAName tmp;
  for ( unsigned int i = vctx->v.size() - 1; i > 0; i--) {
    for ( unsigned int j = 0; j < i; j++) {
      if ( strcmp(names[j], names[j+1]) > 0) {
	strcpy( tmp, names[j+1]);
	strcpy( names[j+1], names[j]);
	strcpy( names[j], tmp);
      }
    }
  }

  trend->wow->CreateList( "Add attribute", (char *)names, sizeof(names[0]), 
			  add_objectlist_cb, add_objectlist_cancel_cb, vctx);
  free( names);  
}

void XttTrend::trend_add_cb( void *ctx)
{
  XttTrend *trend = (XttTrend *) ctx;
  pwr_tAttrRef aref;
  int is_attr;
  pwr_tStatus sts;

  if ( !trend->get_select_cb)
    return;

  sts = trend->get_select_cb( trend->xnav, &aref, &is_attr);
  if ( EVEN(sts)) return;

  trend->curve_add( &aref, 0, &sts);
  if ( EVEN(sts))
    printf( "Trend add failure\n");
}

void XttTrend::trend_help_cb( void *ctx)
{
  XttTrend *trend = (XttTrend *) ctx;

  if ( trend->help_cb)
    (trend->help_cb)( trend->xnav, "opg_trend");
}

void XttTrend::trend_scan( void *data)
{
  XttTrend *trend = (XttTrend *)data;
  int i, j, k;  

  if ( trend->trend_tid == pwr_cClass_DsTrend) {
    int write_buffer;
    int idx;
    int values;
    int trend_buff_size = (int) sizeof( trend->trend_p[0]->DataBuffer) /
      sizeof( trend->trend_p[0]->DataBuffer[0]);

    // Check if any new value
    i = trend->min_interval_idx;
    if ( trend->trend_p[i]->NextWriteIndex[trend->trend_p[i]->WriteBuffer] !=
	 trend->last_next_index[i]) {
      values = trend->trend_p[i]->NextWriteIndex[trend->trend_p[i]->WriteBuffer]
	- trend->last_next_index[i];
      if ( values < 0)
	values = values + trend->trend_p[i]->NoOfSample;

      trend->last_next_index[i] =
	trend->trend_p[i]->NextWriteIndex[trend->trend_p[i]->WriteBuffer];

      for ( k = 0; k < values; k++) {
	// Add new points
	for ( i = 0; i < trend->trend_cnt; i++) {
	  // Shift data
	  for ( j = trend->max_points - 1; j > 0; j--)
	    trend->gcd->y_data[i][j] = trend->gcd->y_data[i][j-1];
	  // Insert new value
	  write_buffer = trend->trend_p[i]->WriteBuffer;
	  idx = write_buffer * trend_buff_size / 2
	    + int( trend->trend_p[i]->NextWriteIndex[write_buffer]) - (values - 1 - k);
	  if ( idx == 0 || idx == trend_buff_size/2)
	    idx = trend->trend_p[i]->NoOfSample - 1 + (!write_buffer) *
	      trend_buff_size/2;
	  else
	    idx--;
	  
	  trend->gcd->y_data[i][0] = trend->trend_p[i]->DataBuffer[idx];
	}
	trend->curve->points_added( 1);
      }
    }    
  }
  else if ( trend->trend_tid == pwr_cClass_DsTrendCurve) {
    pwr_tStatus sts;
    unsigned int size;

    sts = cbuf_UpdateCircBuffInfo( trend->cb_info, trend->trend_cnt);
    if ( EVEN(sts)) return;

    for ( i = 0; i < trend->trend_cnt; i++) {

      size = trend->cb_info[i].size;
      if ( size > 0) {
 
	// Shift data
	for ( j = trend->cb_info[i].samples - 1; j >= (int)size; j--)
	  trend->gcd->y_data[i][j] = trend->gcd->y_data[i][j-size];
	// Insert new value
	switch ( trend->element_type[i]) {
	case pwr_eType_Float64:
	  for ( j = 0; j < (int)size; j++)
	    trend->gcd->y_data[i][j] = *(pwr_tFloat64 *)((char *)trend->cb_info[i].bufp + (size - j - 1) * sizeof(pwr_tFloat64));
	  break;
	case pwr_eType_Float32:
	  for ( j = 0; j < (int)size; j++)
	    trend->gcd->y_data[i][j] = *(pwr_tFloat32 *)((char *)trend->cb_info[i].bufp + (size - j - 1) * sizeof(pwr_tFloat32));
	  break;
	case pwr_eType_Boolean:
	  for ( j = 0; j < (int)size; j++)
	    trend->gcd->y_data[i][j] = *(pwr_tBoolean *)((char *)trend->cb_info[i].bufp + (size - j - 1) * sizeof(pwr_tBoolean));
	  break;
	case pwr_eType_Int64:
	  for ( j = 0; j < (int)size; j++)
	    trend->gcd->y_data[i][j] = *(pwr_tInt64 *)((char *)trend->cb_info[i].bufp + (size - j - 1) * sizeof(pwr_tInt64));
	  break;
	case pwr_eType_UInt64:
	  for ( j = 0; j < (int)size; j++)
	    trend->gcd->y_data[i][j] = *(pwr_tUInt64 *)((char *)trend->cb_info[i].bufp + (size - j - 1) * sizeof(pwr_tUInt64));
	  break;
	case pwr_eType_Int32:
	  for ( j = 0; j < (int)size; j++)
	    trend->gcd->y_data[i][j] = *(pwr_tInt32 *)((char *)trend->cb_info[i].bufp + (size - j - 1) * sizeof(pwr_tInt32));
	  break;
	case pwr_eType_UInt32:
	  for ( j = 0; j < (int)size; j++)
	    trend->gcd->y_data[i][j] = *(pwr_tUInt32 *)((char *)trend->cb_info[i].bufp + (size - j - 1) * sizeof(pwr_tUInt32));
	  break;
	case pwr_eType_Int16:
	  for ( j = 0; j < (int)size; j++)
	    trend->gcd->y_data[i][j] = *(pwr_tInt16 *)((char *)trend->cb_info[i].bufp + (size - j - 1) * sizeof(pwr_tInt16));
	  break;
	case pwr_eType_UInt16:
	  for ( j = 0; j < (int)size; j++)
	    trend->gcd->y_data[i][j] = *(pwr_tUInt16 *)((char *)trend->cb_info[i].bufp + (size - j - 1) * sizeof(pwr_tUInt16));
	  break;
	case pwr_eType_Int8:
	  for ( j = 0; j < (int)size; j++)
	    trend->gcd->y_data[i][j] = *(pwr_tInt8 *)((char *)trend->cb_info[i].bufp + (size - j - 1) * sizeof(pwr_tInt8));
	  break;
	case pwr_eType_UInt8:
	  for ( j = 0; j < (int)size; j++)
	    trend->gcd->y_data[i][j] = *(pwr_tUInt8 *)((char *)trend->cb_info[i].bufp + (size - j - 1) * sizeof(pwr_tUInt8));
	  break;
	default: ;
	}
      }
    }
    if ( size > 0)
      trend->curve->points_added( size);
  }
  trend->timerid->add( trend->update_time, trend_scan, trend);
}

void XttTrend::curve_add( pwr_tAttrRef *arp, pwr_tAttrRef *trend_arp, pwr_tStatus *sts)
{
  pwr_tTid tid;
  pwr_tAttrRef defaref, deftrend;
  pwr_tAttrRef trend_aref, attr_aref;
  pwr_tStatus lsts;
  pwr_tObjid child;
  int trend_found = 0;
  int attr_found = 0;
  unsigned int trend_idx[20];
  unsigned int trend_idx_cnt = 0;
    

  *sts = XNAV__SUCCESS;

  if ( trend_cnt == XTT_TREND_MAX) {
    *sts = 0;
    return;
  }

  if ( trend_arp) {
    trend_aref = *trend_arp;
    trend_found = 1;
    if ( arp) {
      attr_found = 1;
      attr_aref = *arp;
    }
  }

  if ( !trend_found) {
    *sts = gdh_GetAttrRefTid( arp, &tid);
    if ( EVEN(*sts)) return;

    switch( tid) {
    case pwr_cClass_DsTrend:
      trend_aref = *arp;
      trend_found = 1;
      break;
    case pwr_cClass_DsTrendCurve:
      trend_aref = *arp;
      trend_found = 1;
      break;
    default:
      // Get DefaultTrend
      *sts = gdh_ArefANameToAref( arp, "DefTrend", &defaref);
      if ( ODD(*sts)) {
	*sts = gdh_GetObjectInfoAttrref( &defaref, &deftrend, sizeof(deftrend));  
	if ( EVEN(*sts)) return;
	
	*sts = gdh_GetAttrRefTid( &deftrend, &tid);
	if ( ODD(*sts)) {
	  
	  switch( tid) {
	  case pwr_cClass_DsTrend:
	  case pwr_cClass_DsTrendCurve:
	    trend_aref = deftrend;
	    attr_aref = *arp;
	    trend_found = 1;
	    attr_found = 1;
	    break;
	  case pwr_cClass_PlotGroup: {
	    pwr_sClass_PlotGroup plot;
	    pwr_tAName vname;
	    pwr_tAName attr_name;
	    unsigned int vsize = sizeof(plot.YObjectName)/sizeof(plot.YObjectName[0]);
	    
	    *sts = gdh_GetObjectInfoAttrref( &deftrend, &plot, sizeof(plot));
	    if ( EVEN(*sts)) return;
	    
	    for ( unsigned int i = 0; i < vsize; i++) {
	    
	      if ( cdh_ObjidIsNull(plot.YObjectName[i].Objid))
		break;
	    	      
	      *sts = gdh_GetAttrRefTid( &plot.YObjectName[i], &tid);
	      if ( EVEN(*sts)) continue;

	      if ( tid != trend_tid) {
		*sts = 0;
		return;
	      }
		
	      switch ( tid) {
	      case pwr_cClass_DsTrend: {
		pwr_sClass_DsTrend tp;

		*sts = gdh_GetObjectInfoAttrref( &plot.YObjectName[i], &tp, sizeof(tp));
		if ( EVEN(*sts)) return;

		*sts = gdh_AttrrefToName( arp, attr_name, sizeof(attr_name), 
					  cdh_mName_volumeStrict);
		if ( EVEN(*sts)) return;
		
		*sts = gdh_AttrrefToName( &tp.DataName, vname, sizeof(vname), 
					  cdh_mName_volumeStrict);
		if (EVEN(*sts)) return;

		if ( strncmp( attr_name, vname, strlen(attr_name)) == 0) {
		  trend_aref = plot.YObjectName[i];
		  trend_found = 1;
		  attr_aref = *arp;
		  attr_found = 1;
		}
		break;
	      }
	      case pwr_cClass_DsTrendCurve: {
		pwr_sClass_DsTrendCurve tp;
		pwr_tAName vname;
		unsigned int asize = sizeof(tp.Attribute)/sizeof(tp.Attribute[0]);

		*sts = gdh_GetObjectInfoAttrref( &plot.YObjectName[i], &tp, sizeof(tp));
		if ( EVEN(*sts)) return;

		*sts = gdh_AttrrefToName( arp, attr_name, sizeof(attr_name), 
					  cdh_mName_volumeStrict);

		for ( unsigned int j = 0; j < asize; j++) {
		  if ( cdh_ObjidIsNull(tp.Attribute[j].Objid))
		    break;
		  
		  *sts = gdh_AttrrefToName( &tp.Attribute[j], vname, sizeof(vname), 
					    cdh_mName_volumeStrict);
		  if (EVEN(*sts)) return;

		  if ( strncmp( attr_name, vname, strlen(attr_name)) == 0) {
		    trend_aref = plot.YObjectName[i];
		    trend_found = 1;
		    attr_aref = *arp;
		    attr_found = 1;
		    trend_idx[trend_idx_cnt] = j;
		    trend_idx_cnt++;
		  }
		}
		break;
	      }
	      default: ;
	      }
	      if ( trend_found)
		break;
	    }	    
	    break;
	  }
	  default:
	    // Search children
	    for ( lsts = gdh_GetChild( arp->Objid, &child); ODD(lsts); lsts = gdh_GetNextSibling( child, &child)) {
	      *sts = gdh_GetObjectClass( child, &tid);
	      if ( EVEN(*sts)) return;
	      
	      switch( tid) {
	      case pwr_cClass_DsTrend:
	      case pwr_cClass_DsTrendCurve:
		trend_aref = cdh_ObjidToAref( child);
		attr_aref = *arp;
		trend_found = 1;
		attr_found = 1;
		break;
	      default: ;
	      }
	      if ( trend_found)
		break;
	    }
	  }
	}
      }
    }
  }
  if (!trend_found) {
    *sts = 0;
    return;
  }

  *sts = gdh_GetAttrRefTid( &trend_aref, &tid);
  if ( EVEN(*sts)) return;

  if ( tid != trend_tid) {
    *sts = 0;
    return;
  }
  
  if ( trend_tid == pwr_cClass_DsTrendCurve && attr_found && trend_idx_cnt == 0) {
    // Find index for attribute
    pwr_sClass_DsTrendCurve tp;
    pwr_tAName attr_name, vname;
    unsigned int asize = sizeof(tp.Attribute)/sizeof(tp.Attribute[0]);

    *sts = gdh_GetObjectInfoAttrref( &trend_aref, &tp, sizeof(tp));
    if ( EVEN(*sts)) return;

    *sts = gdh_AttrrefToName( &attr_aref, attr_name, sizeof(attr_name), 
			      cdh_mName_volumeStrict);
    
    for ( unsigned int j = 0; j < asize; j++) {
      if ( cdh_ObjidIsNull(tp.Attribute[j].Objid))
	break;
		  
      *sts = gdh_AttrrefToName( &tp.Attribute[j], vname, sizeof(vname), 
				cdh_mName_volumeStrict);
      if (EVEN(*sts)) return;

      if ( strncmp( attr_name, vname, strlen(attr_name)) == 0) {
	trend_idx[trend_idx_cnt] = j;
	trend_idx_cnt++;
      }
    }    
  }

  if ( trend_tid == pwr_cClass_DsTrend) {
    pwr_sClass_DsTrend tp;
    pwr_tAName object_name;
    int start_idx;
    int trend_buff_size = (int) sizeof( tp.DataBuffer) /
      sizeof( tp.DataBuffer[0]);

    // Get current status of the trend objects
    int i = trend_cnt;
    *sts = gdh_AttrrefToName( &trend_aref, trend_name[i], sizeof(trend_name[0]), 
			      cdh_mNName);
    if (EVEN(*sts)) return;
      
    *sts = gdh_GetObjectInfo( trend_name[i], &tp, sizeof(tp));
    if ( EVEN(*sts)) return;
      
    *sts = gdh_AttrrefToName( &tp.DataName, object_name, 
			      sizeof(object_name), cdh_mNName);
    if (EVEN(*sts)) return;
    trend_cnt++;


    gcd->y_data[i] = (double *) calloc( 1, 8 * max_points);
      
    interval[i] = tp.Multiple * tp.ScanTime / min_interval;

    int write_buffer = (int) tp.WriteBuffer;
    start_idx = write_buffer * trend_buff_size / 2
      + int( tp.NextWriteIndex[write_buffer]);
    if ( start_idx == 0) {
      start_idx = tp.NoOfSample - 1 + trend_buff_size / 2;
      write_buffer = 1;
    }
    else if ( start_idx == trend_buff_size / 2) {
      start_idx = tp.NoOfSample - 1;
      write_buffer = 0;
    }
    else
      start_idx--;
      
    int idx = 0;
    for ( int j = start_idx; j >= write_buffer * trend_buff_size/2; j--) {

      for ( int k = 0; k < interval[i]; k++) {
	gcd->y_data[i][idx] = tp.DataBuffer[j];
	idx++;
      }
    }
    for ( int j = tp.NoOfSample - 1 + (!write_buffer) * trend_buff_size/2;
	  j >= (!write_buffer) * trend_buff_size/2; j--) {
      for ( int k = 0; k < interval[i]; k++) {
	gcd->y_data[i][idx] = tp.DataBuffer[j];
	idx++;
      }
    }
    if ( start_idx != (int) tp.NoOfSample - 1 + 
	 write_buffer * trend_buff_size/2) {
      for ( int j = tp.NoOfSample - 1 + write_buffer * trend_buff_size/2; 
	    j > start_idx; j--) {
	for ( int k = 0; k < interval[i]; k++) {
	  gcd->y_data[i][idx] = tp.DataBuffer[j];
	  idx++;
	}
      }
    }
    last_buffer[i] = tp.WriteBuffer;
    last_next_index[i] = tp.NextWriteIndex[last_buffer[i]];
    gcd->y_axis_type[i] = curve_eAxis_y; 

    // Subscribe to object
    *sts = gdh_RefObjectInfo( trend_name[i], (pwr_tAddress *)&trend_p[i], 
			      &subid[i], sizeof(pwr_sClass_DsTrend));
    if ( EVEN(*sts)) return;
      
    strcpy( gcd->y_name[i], object_name);
      
    switch( trend_p[i]->DataType) {
    case pwr_eType_Float32:
    case pwr_eType_Int32:
    case pwr_eType_UInt32:
      element_size[i] = 4;
      break;
    case pwr_eType_Float64:
    case pwr_eType_Int64:
    case pwr_eType_UInt64:
      element_size[i] = 8;
      break;
    case pwr_eType_Int16:
    case pwr_eType_UInt16:
      element_size[i] = 2;
      break;
    case pwr_eType_Int8:
    case pwr_eType_UInt8:
      element_size[i] = 1;
      break;
    default:
      element_size[i] = 4;
    }
    gcd->rows[i] = max_points;

    gcd->cols = trend_cnt;
    gcd->get_borders();
    gcd->get_default_axis();
    gcd->select_color( 0);
    
    // Try to find unit and descripion
    pwr_tAName aname;
    char unit[40];
    char description[80];
    pwr_tStatus lsts;
    char *s;
      
    strcpy( aname, object_name);
    if ( (s = strrchr( aname, '.')))
      *s = 0;
    strcat( aname, ".Unit");
    lsts = gdh_GetObjectInfo( aname, unit, sizeof(unit));
    if ( ODD(lsts))
      strncpy( gcd->y_unit[i], unit, sizeof(gcd->y_unit[0]));

    strcpy( aname, object_name);
    if ( (s = strrchr( aname, '.')))
      *s = 0;
    strcat( aname, ".Description");
    lsts = gdh_GetObjectInfo( aname, description, sizeof(description));
    if ( ODD(lsts))
      strncpy( gcd->y_description[i], description, sizeof(gcd->y_description[0]));

    curve->config_names();
    curve->configure_curves();
    curve->configure_axes();
  }
  else if ( trend_tid == pwr_cClass_DsTrendCurve) {
    pwr_sClass_DsTrendCurve tcp;
    unsigned int actual_data_size[XTT_TREND_MAX];
    pwr_tAName object_name[XTT_TREND_MAX];
    int i, start_idx;
    
    // Get current status of the trend objects
    i = start_idx = trend_cnt;

    *sts = gdh_AttrrefToName( &trend_aref, trend_name[i], sizeof(trend_name[0]), 
			      cdh_mNName);
    if (EVEN(*sts)) return;
      
    *sts = gdh_GetObjectInfo( trend_name[i], &tcp, sizeof(tcp));
    if ( EVEN(*sts)) return;
      
    i = start_idx;
    for ( unsigned int j = 0; j < 10; j++) {
      if ( cdh_ObjidIsNotNull( tcp.Attribute[j].Objid) &&
	   cdh_ObjidIsNotNull( tcp.Buffers[j].Objid)) {
	if ( trend_idx_cnt > 0) {
	  // Add only specific indexes
	  int found = 0;
	  for ( unsigned int k = 0; k < trend_idx_cnt; k++) {
	    if ( trend_idx[k] == j) {
	      found = 1;
	      break;
	    }
	  }
	  if ( !found)
	    continue;
	}

	*sts = gdh_AttrrefToName( &tcp.Buffers[j], object_name[i],
				  sizeof(object_name[0]), cdh_mNName);
	if (EVEN(*sts)) return;

	*sts = gdh_AttrrefToName( &tcp.Attribute[j], object_name[i], 
				  sizeof(object_name[0]), cdh_mNName);
	if (EVEN(*sts)) return;
	
	  
	element_size[i] = cdh_TypeToSize( (pwr_eType)tcp.AttributeType[j]);
	element_type[i] = (pwr_eType)tcp.AttributeType[j];
	cb_info[i].resolution = tcp.DisplayResolution;
	if ( cb_info[i].resolution <= 0)
	  cb_info[i].resolution = 1;
	cb_info[i].samples = tcp.DisplayTime / tcp.ScanTime / cb_info[i].resolution;
	cb_info[i].bufsize = cb_info[i].samples * element_size[i];
	cb_info[i].bufp = (char *) calloc( 1, cb_info[i].bufsize);
	cb_info[i].circ_aref = tcp.Buffers[j];
	*sts = cbuf_GetCircBuffInfo( &cb_info[i], 1); 
	if ( EVEN(*sts))
	  continue;

	actual_data_size[i] = cb_info[i].size;
	if ( actual_data_size[i] > cb_info[i].bufsize)
	  printf( "** Sample size error !!!\n");
	
	i++;
      }
    }
    trend_cnt = i;


    // Try to find unit
    for ( i = start_idx; i < trend_cnt; i++) {
      pwr_tAName aname;
      char unit[40];
      char description[80];
      pwr_tStatus lsts;
      char *s;

      strcpy( aname, object_name[i]);
      if ( (s = strrchr( aname, '.')))
	*s = 0;
      strcat( aname, ".Unit");
      lsts = gdh_GetObjectInfo( aname, unit, sizeof(unit));
      if ( ODD(lsts))
	strncpy( gcd->y_unit[i], unit, sizeof(gcd->y_unit[0]));

      strcpy( aname, object_name[i]);
      if ( (s = strrchr( aname, '.')))
	*s = 0;
      strcat( aname, ".Description");
      lsts = gdh_GetObjectInfo( aname, description, sizeof(description));
      if ( ODD(lsts))
	strncpy( gcd->y_description[i], description, sizeof(gcd->y_description[0]));
    }

    for ( i = start_idx; i < trend_cnt; i++) {
      gcd->y_data[i] = (double *) calloc( 1, 8 * max_points);
      
      switch ( element_type[i]) {
      case pwr_eType_Float32:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tFloat32 *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tFloat32));
	break;
      case pwr_eType_Float64:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tFloat64 *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tFloat64));
	break;
      case pwr_eType_Boolean:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tBoolean *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tBoolean));
	break;
      case pwr_eType_Int64:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tInt64 *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tInt64));
	break;
      case pwr_eType_UInt64:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tUInt64 *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tUInt64));
	break;
      case pwr_eType_Int32:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tInt32 *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tInt32));
	break;
      case pwr_eType_UInt32:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tUInt32 *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tUInt32));
	break;
      case pwr_eType_Int16:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tInt16 *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tInt16));
	break;
      case pwr_eType_UInt16:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tUInt16 *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tUInt16));
	break;
      case pwr_eType_Int8:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tInt8 *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tInt8));
	break;
      case pwr_eType_UInt8:
	for ( unsigned int j = 0; j < actual_data_size[i]; j++)
	  gcd->y_data[i][j] = *(pwr_tUInt8 *)((char *)cb_info[i].bufp + (actual_data_size[i] - j - 1) * sizeof(pwr_tUInt8));
	break;
      default: ;
      }
      
      gcd->y_axis_type[i] = curve_eAxis_y;
      strcpy( gcd->y_name[i], object_name[i]);      
      gcd->rows[i] = max_points;
    }

    gcd->cols = trend_cnt;
    gcd->get_borders();
    gcd->get_default_axis();
    gcd->select_color( 0);
    curve->config_names();
    curve->configure_curves();
    curve->configure_axes();
  }
}






