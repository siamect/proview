/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* xtt_hist.cpp -- Historical event window in xtt

   Author: Jonas Nylund.
   Last modification: 030217
*/

#if defined PWRE_CONF_LIBDB

#include <db.h>
#include <stdlib.h>

#include <algorithm>
#include <deque>
#include <string>
#include <vector>

#include "co_cdh.h"
#include "co_time.h"
#include "cow_wow.h"
#include "rt_gdh.h"
#include "rt_mh.h"
#include "rt_mh_outunit.h"
#include "rt_mh_util.h"
#include "rt_elog.h"
#include "co_dcli.h"

#include "co_lng.h"
#include "xtt_hist.h"
#include "rt_xnav_msg.h"
#include "xtt_methodtoolbar.h"

#define SENS 1
#define INSENS 0
/* 24 hours in seconds */
#define ONEDAY 86400

pwr_tStatus mh_clear_alarmlist_bc(pwr_tNodeIndex nix);
bool compDate(sEvent ev1, sEvent ev2);

Hist::Hist(void* hist_parent_ctx, char* hist_name, pwr_tAttrRef* arp,
    pwr_tStatus* status)
    : parent_ctx(hist_parent_ctx), start_trace_cb(NULL),
      display_in_xnav_cb(NULL), update_info_cb(NULL), help_cb(NULL), hist(NULL),
      minTime_str(NULL), maxTime_str(NULL), eventName_str(NULL),
      eventText_str(NULL), eventPrio_A(false), eventPrio_B(false),
      eventPrio_C(false), eventPrio_D(false), eventType_Ack(false),
      eventType_Alarm(false), eventType_Info(false),
      eventType_InfoSuccess(false), eventType_Return(false),
      eventType_Cancel(false), eventType_Block(false), eventType_Unblock(false),
      eventType_Reblock(false), eventType_CancelBlock(false)
{
  if (arp)
    aref = *arp;
  else
    memset(&aref, 0, sizeof(aref));
}

//
//  Delete hist
//
Hist::~Hist()
{
}

void Hist::hist_start_trace_cb(void* ctx, pwr_tObjid objid, char* name)
{
  if (((Hist*)ctx)->start_trace_cb)
    ((Hist*)ctx)->start_trace_cb(((Hist*)ctx)->parent_ctx, objid, name);
}

void Hist::hist_popup_menu_cb(void* ctx, pwr_sAttrRef attrref,
    unsigned long item_type, unsigned long utility, char* arg, int x, int y)
{
  if (((Hist*)ctx)->popup_menu_cb)
    (((Hist*)ctx)->popup_menu_cb)(
        ((Hist*)ctx)->parent_ctx, attrref, item_type, utility, arg, x, y);
}

void Hist::help_event_cb(void* ctx, void* item)
{
  ItemAlarm* aitem = (ItemAlarm*)item;

  switch (aitem->type) {
  case evlist_eItemType_Alarm:
    ((Hist*)ctx)->wow->DisplayText("Event MoreText", aitem->eventmoretext);
    break;
  default:
    return;
  }
}

void Hist::selection_changed_cb(void* ctx)
{
  ((Hist*)ctx)->methodtoolbar->set_sensitive();
  ((Hist*)ctx)->sup_methodtoolbar->set_sensitive();
}

void Hist::hist_display_in_xnav_cb(void* ctx, pwr_sAttrRef* arp)
{
  if (((Hist*)ctx)->display_in_xnav_cb)
    ((Hist*)ctx)->display_in_xnav_cb(((Hist*)ctx)->parent_ctx, arp);
}

void Hist::activate_print()
{
  if (CoWow::PrintDialogIsDisabled()) {
    char filename[200];
    dcli_translate_filename(filename, "$pwrp_tmp/xnav.ps");

    hist->print_nodia(filename);
  } else
    hist->print(Lng::translate("Eventlog"));
}

void Hist::activate_export()
{
  wow->CreateFileSelDia("Export", (void*)this,
      export_file_selected_cb, wow_eFileSelType_Tmp, wow_eFileSelAction_Save);
}

void Hist::activate_analyse()
{
  export_events("$pwrp_tmp/pwr_eventlog.dat");
  system("sev_eva.py -f $pwrp_tmp/pwr_eventlog.dat &");
}

void Hist::export_file_selected_cb(void *ctx, char *filename, wow_eFileSelType file_type)
{
  ((Hist *)ctx)->export_events(filename);  
}

int Hist::export_events(const char *filename)
{
  brow_tObject *list;
  int list_cnt;
  ItemAlarm *item;
  char timstr[40];
  char supobjectstr[80];
  pwr_tFileName fname;
  FILE *fp;

  dcli_translate_filename(fname, filename);
  fp = fopen(fname, "w");
  if (!fp)
    return 0;
  fprintf(fp, "Time,Type,Prio,Text,Name,SupObject,Id,Status\n");
  brow_GetObjectList(hist->brow->ctx, &list, &list_cnt);
  for (int i = list_cnt - 1; i >= 0; i--) {
    brow_GetUserData(list[i], (void **)&item);
    time_AtoAscii(&item->time, time_eFormat_NumDateAndTime, timstr, sizeof(timstr));
    strcpy(supobjectstr, cdh_ObjidToString(item->supobject.Objid, 1));
    if (item->supobject.Flags.b.ObjectAttr)
      sprintf(&supobjectstr[strlen(supobjectstr)], "#%u:%u", item->supobject.Offset,
	      item->supobject.Size);
    fprintf(fp, "%s,%u,%lu,\"%s\",\"%s\",%s,\"(%u,%u)\",%u\n",
	   timstr, item->eventtype, item->eventprio, item->eventtext, item->eventname, 
	   supobjectstr, item->eventid.Nix, item->eventid.Idx, item->status);
  }
  fclose(fp);
  return 1;
}

void Hist::activate_help()
{
  if (help_cb)
    (help_cb)(parent_ctx, "opg_eventlog");
}

void Hist::activate_helpevent()
{
  char eventname[80];
  int sts;
  ItemAlarm* item;

  if (help_cb) {
    sts = hist->get_selected_event(eventname, &item);
    if (ODD(sts)) {
      wow->DisplayText(eventname, item->eventmoretext);
    }
  }
}

void Hist::time_cb(time_ePeriod period)
{
  pwr_tTime StartTime;
  pwr_tTime StopTime;

  int daybreak = 0;
  if (period == time_ePeriod_Today || period == time_ePeriod_ThisWeek || period == time_ePeriod_ThisMonth || period == time_ePeriod_AllTime)
    daybreak = 1;

  time_Period(period == time_ePeriod_UserDefined ? time_ePeriod_AllTime : period, &StartTime, &StopTime, 0, daybreak);

  SetListTime(StartTime, StopTime, period == time_ePeriod_UserDefined ? SENS : INSENS);
}

pwr_tStatus Hist::hist_add_ack_mess(mh_sAck* MsgP)
{
  // Insert in hist
  hist->event_ack(MsgP);
  return 1;
}

pwr_tStatus Hist::hist_add_return_mess(mh_sReturn* MsgP)
{
  // Insert in hist
  hist->event_return(MsgP);
  return 1;
}

pwr_tStatus Hist::hist_add_alarm_mess(mh_sMessage* MsgP)
{
  hist->event_alarm(MsgP);
  return 1;
}

pwr_tStatus Hist::hist_add_info_mess(mh_sMessage* MsgP)
{
  hist->event_info(MsgP);
  return 1;
}

pwr_tStatus Hist::hist_clear_histlist()
{
  //  hist->event_clear_list();
  return 1;
}

void Hist::get_hist_list()
{
  DB* dataBaseP = NULL;
  pwr_tInt32 ret, sts;
  char dbName[200];

  // printf("I get_hist_list\n");

  dcli_translate_filename(dbName, DATABASE);

  printSearchStr();

  /*create the database if it's not already created*/
  if ((ret = db_create(&dataBaseP, NULL, 0)) != 0) {
    /*error creating db-handle send the mess to errh, then exit*/
    printf("error db_create: %s\n", db_strerror(ret));
    printf(" Fel vid skapande av databashandtag avslutar\n");
    return;
  }

#if DB_VERSION_MAJOR > 3 && DB_VERSION_MINOR > 0
  //        int  (*open) __P((DB *, DB_TXN *,
  //              const char *, const char *, DBTYPE, u_int32_t, int));

  ret = dataBaseP->open(
      dataBaseP, NULL, dbName, NULL, DATABASETYPE, DB_RDONLY, 0);
#else
  ret = dataBaseP->open(dataBaseP, dbName, NULL, DATABASETYPE, DB_RDONLY, 0);
#endif
  if (ret != 0) {
    /*error opening/creating db send the mess to errh, then exit*/
    printf("error db_open: %s\n", db_strerror(ret));
    // goto err;
  }

  pwr_tUInt32 nrOfEvents = 0;
  sEvent* eventp;
  DBT data, key;
  DBC* dbcp;
  std::deque<sEvent> evDeq;

  /* Acquire a cursor for the database. */
  if ((ret = dataBaseP->cursor(dataBaseP, NULL, &dbcp, 0)) != 0) {
    printf("error dataBaseP->cursor: %s\n", db_strerror(ret));
    return;
  }

  /* Initialize the key/data return pair. */
  memset(&key, 0, sizeof(key));
  memset(&data, 0, sizeof(data));

  if ((ret = dbcp->c_get(dbcp, &key, &data, DB_FIRST)) == 0) {
    eventp = (sEvent*)data.data;
    sts = check_conditions(eventp);
    if (sts == ERROR_TIME_CONVERT) {
      printf("Error trying to convert userinput in time-field\n");
    }
    if (ODD(sts)) {
      nrOfEvents++;
      evDeq.push_front((sEvent)*eventp);
    }
  }

  while ((ret = dbcp->c_get(dbcp, &key, &data, DB_NEXT)) == 0) {
    eventp = (sEvent*)data.data;
    sts = check_conditions(eventp);
    if (ODD(sts)) {
      nrOfEvents++;
      evDeq.push_front(*eventp);
    } else if (sts == ERROR_TIME_CONVERT) {
      printf("Error trying to convert userinput in time-field\n");
    }
  }
  if (ret != DB_NOTFOUND) {
    printf("error dbcp->c_get: %s\n", db_strerror(ret));
    printf("Fel vid försök att läsa post nr %u, avslutar\n", nrOfEvents);
  }

  set_num_of_events(nrOfEvents);

  /*Close the cursor*/
  if ((ret = dbcp->c_close(dbcp)) != 0) {
    printf("Error dbcp->c_close(): %s\n", db_strerror(ret));
  }
  /*close the database*/

  if ((ret = dataBaseP->close(dataBaseP, 0) != 0)) {
    printf("error db_close: %s\n", db_strerror(ret));
  }

  std::deque<sEvent>::iterator it;
  it = evDeq.begin();
  // sort the deque
  sort(it, evDeq.end(), compDate);
  hist->set_nodraw();
  while (it != evDeq.end()) {
    switch (it->EventType) {
    case mh_eEvent_Alarm:
    case mh_eEvent_MaintenanceAlarm:
    case mh_eEvent_SystemAlarm:
    case mh_eEvent_UserAlarm1:
    case mh_eEvent_UserAlarm2:
    case mh_eEvent_UserAlarm3:
    case mh_eEvent_UserAlarm4:
      hist_add_alarm_mess(&(it->Mess.message));
      break;
    case mh_eEvent_Info:
    case mh_eEvent_InfoSuccess:
      hist_add_info_mess(&(it->Mess.message));
      break;
    case mh_eEvent_Ack:
      hist_add_ack_mess(&(it->Mess.ack));
      break;
    case mh_eEvent_Cancel:
      // strcpy(ret, "Cancel");
      break;
    case mh_eEvent_Return:
      hist_add_return_mess(&(it->Mess.ret));
      break;
    case mh_eEvent_Block:
      // strcpy(ret, "Block");
      break;
    case mh_eEvent_Unblock:
      // strcpy(ret, "Unblock");
      break;
    case mh_eEvent_Reblock:
      // strcpy(ret, "Reblock");
      break;
    case mh_eEvent_CancelBlock:
      // strcpy(ret, "CancelBlock");
      break;
    default:
      // strcpy(ret, " ");
      break;
    }

    it++;
  }
  hist->reset_nodraw();
}

typedef struct {
  sEvent event;
  int cnt;
} sStat;

struct evv_greater_than {
  inline bool operator()(const sStat& struct1, const sStat& struct2)
  {
    return (struct1.cnt > struct2.cnt);
  }
};

void Hist::stat()
{
  DB* dataBaseP = NULL;
  pwr_tInt32 ret;
  char dbName[200];
  int event_cnt = 0;

  brow_DeleteAll(hist->brow->ctx);

  dcli_translate_filename(dbName, DATABASE);

  printSearchStr();

  /*create the database if it's not already created*/
  if ((ret = db_create(&dataBaseP, NULL, 0)) != 0) {
    /*error creating db-handle send the mess to errh, then exit*/
    printf("error db_create: %s\n", db_strerror(ret));
    printf(" Fel vid skapande av databashandtag avslutar\n");
    return;
  }

#if DB_VERSION_MAJOR > 3 && DB_VERSION_MINOR > 0
  //        int  (*open) __P((DB *, DB_TXN *,
  //              const char *, const char *, DBTYPE, u_int32_t, int));

  ret = dataBaseP->open(
      dataBaseP, NULL, dbName, NULL, DATABASETYPE, DB_RDONLY, 0);
#else
  ret = dataBaseP->open(dataBaseP, dbName, NULL, DATABASETYPE, DB_RDONLY, 0);
#endif
  if (ret != 0) {
    /*error opening/creating db send the mess to errh, then exit*/
    printf("error db_open: %s\n", db_strerror(ret));
    // goto err;
  }

  sEvent* eventp;
  DBT data, key;
  DBC* dbcp;
  std::vector<sStat> evv;
  int found;

  /* Acquire a cursor for the database. */
  if ((ret = dataBaseP->cursor(dataBaseP, NULL, &dbcp, 0)) != 0) {
    printf("error dataBaseP->cursor: %s\n", db_strerror(ret));
    return;
  }

  /* Initialize the key/data return pair. */
  memset(&key, 0, sizeof(key));
  memset(&data, 0, sizeof(data));

  for (ret = dbcp->c_get(dbcp, &key, &data, DB_FIRST); ret == 0;
       ret = dbcp->c_get(dbcp, &key, &data, DB_NEXT)) {
    eventp = (sEvent*)data.data;

    switch (eventp->EventType) {
    case mh_eEvent_Alarm:
    case mh_eEvent_Info:
      event_cnt++;
      found = 0;
      for (unsigned int i = 0; i < evv.size(); i++) {
        if (strcmp(eventp->Mess.message.EventText,
                evv[i].event.Mess.message.EventText)
                == 0
            && strcmp(eventp->Mess.message.EventName,
                   evv[i].event.Mess.message.EventName)
                == 0) {
          evv[i].cnt++;
          found = 1;
        }
      }
      if (!found) {
        sStat stat;
        stat.event = *eventp;
        stat.cnt = 1;
        evv.push_back(stat);
      }
      break;
    case mh_eEvent_Ack:
    case mh_eEvent_Cancel:
    case mh_eEvent_Return:
    case mh_eEvent_Block:
    case mh_eEvent_Unblock:
    case mh_eEvent_Reblock:
    case mh_eEvent_CancelBlock:
      break;
    default:;
    }
  }

  std::sort(evv.begin(), evv.end(), evv_greater_than());

  hist->set_nodraw();
  for (unsigned int i = 0; i < evv.size(); i++) {
    char tmp[80];

    memset(&evv[i].event.Mess.message.Info.EventTime, 0,
        sizeof(evv[i].event.Mess.message.Info.EventTime));
    evv[i].event.Mess.message.Status = 0;

    // Print count in beginning of event text
    strncpy(tmp, evv[i].event.Mess.message.EventText, sizeof(tmp));
    sprintf(evv[i].event.Mess.message.EventText, "%-5d ", evv[i].cnt);
    strncpy(&evv[i].event.Mess.message.EventText[6], tmp,
        sizeof(evv[i].event.Mess.message.EventText) - 6);
    evv[i]
        .event.Mess.message
        .EventText[sizeof(evv[i].event.Mess.message.EventText) - 1]
        = 0;

    switch (evv[i].event.EventType) {
    case mh_eEvent_Alarm:
    case mh_eEvent_MaintenanceAlarm:
    case mh_eEvent_SystemAlarm:
    case mh_eEvent_UserAlarm1:
    case mh_eEvent_UserAlarm2:
    case mh_eEvent_UserAlarm3:
    case mh_eEvent_UserAlarm4:
      hist_add_alarm_mess(&evv[i].event.Mess.message);
      break;
    case mh_eEvent_Info:
    case mh_eEvent_InfoSuccess:
      hist_add_info_mess(&evv[i].event.Mess.message);
      break;
    default:;
    }
  }
  hist->reset_nodraw();
  set_num_of_events(event_cnt);
  set_search_string(Lng::translate("Statistics"), "", "", "");
}

// sorting function that might be more complicated in the future
// we might want to sort the display of the events with more conditions than
// just the time
bool compDate(sEvent ev1, sEvent ev2)
{
  return (time_Acomp(&(ev1.EventTime), &(ev2.EventTime)) > 0);
}

int Hist::check_conditions(sEvent* evp)
{
  pwr_tTime minTime;
  pwr_tTime maxTime;
  int sts;

  // first we compare the time
  if ((minTime_str != NULL) && (strlen(minTime_str) != 0)) {
    sts = time_FormAsciiToA(minTime_str, SWE, SECOND, &minTime);
    if (EVEN(sts))
      return ERROR_TIME_CONVERT;
    sts = time_Acomp_NE(&minTime, &(evp->EventTime));
    if (sts > 0 || sts == -2)
      return 2; // evensts
  }
  if (maxTime_str != NULL && (strlen(maxTime_str) != 0)) {
    sts = time_FormAsciiToA(maxTime_str, SWE, SECOND, &maxTime);
    if (EVEN(sts))
      return ERROR_TIME_CONVERT;
    sts = time_Acomp(&maxTime, &(evp->EventTime));
    if (sts < 0 || sts == -2)
      return 2; // evensts
  }
  bool ret = false;
  // then we compare the EventType if nothing is selected everything is selected
  if (eventType_Ack || eventType_Alarm || eventType_MaintenanceAlarm
      || eventType_SystemAlarm || eventType_UserAlarm1 || eventType_UserAlarm2
      || eventType_UserAlarm3 || eventType_UserAlarm4 || eventType_Info
      || eventType_InfoSuccess || eventType_Return || eventType_Cancel
      || eventType_Block || eventType_Unblock || eventType_Reblock
      || eventType_CancelBlock) {
    switch (evp->EventType) {
    case mh_eEvent_Alarm:
      if (!eventType_Alarm)
        ret = true;
      break;
    case mh_eEvent_SystemAlarm:
      if (!eventType_SystemAlarm)
        ret = true;
      break;
    case mh_eEvent_MaintenanceAlarm:
      if (!eventType_MaintenanceAlarm)
        ret = true;
      break;
    case mh_eEvent_UserAlarm1:
      if (!eventType_UserAlarm1)
        ret = true;
      break;
    case mh_eEvent_UserAlarm2:
      if (!eventType_UserAlarm2)
        ret = true;
      break;
    case mh_eEvent_UserAlarm3:
      if (!eventType_UserAlarm3)
        ret = true;
      break;
    case mh_eEvent_UserAlarm4:
      if (!eventType_UserAlarm4)
        ret = true;
      break;
    case mh_eEvent_Info:
      if (!eventType_Info)
        ret = true;
      break;
    case mh_eEvent_InfoSuccess:
      if (!eventType_InfoSuccess)
        ret = true;
      break;
    case mh_eEvent_Ack:
      if (!eventType_Ack)
        ret = true;
      break;
    case mh_eEvent_Cancel:
      if (!eventType_Cancel)
        ret = true;
      break;
    case mh_eEvent_Return:
      if (!eventType_Return)
        ret = true;
      break;
    case mh_eEvent_Block:
      if (!eventType_Block)
        ret = true;
      break;
    case mh_eEvent_Unblock:
      if (!eventType_Unblock)
        ret = true;
      break;
    case mh_eEvent_Reblock:
      if (!eventType_Reblock)
        ret = true;
      break;
    case mh_eEvent_CancelBlock:
      if (!eventType_CancelBlock)
        ret = true;
      break;
    default:
      ret = true;
    }
  }
  if (ret)
    return 2;

  mh_sMsgInfo* msgInfop = NULL;
  mh_sMessage* mp = NULL;
  mh_sReturn* rp = NULL;
  char* eventNamep;

  switch (evp->EventType) {
  case mh_eEvent_Alarm:
  case mh_eEvent_MaintenanceAlarm:
  case mh_eEvent_SystemAlarm:
  case mh_eEvent_UserAlarm1:
  case mh_eEvent_UserAlarm2:
  case mh_eEvent_UserAlarm3:
  case mh_eEvent_UserAlarm4:
  case mh_eEvent_Info:
  case mh_eEvent_InfoSuccess:
    msgInfop = &(evp->Mess.message.Info);
    eventNamep = evp->Mess.message.EventName;
    mp = &(evp->Mess.message);
    break;
  case mh_eEvent_Ack:
    msgInfop = &(evp->Mess.ack.Info);
    eventNamep = evp->Mess.ack.EventName;
    break;
  case mh_eEvent_Cancel:
  case mh_eEvent_Return:
    msgInfop = &(evp->Mess.ret.Info);
    eventNamep = evp->Mess.ret.EventName;
    rp = &(evp->Mess.ret);
    break;
  case mh_eEvent_Block:
  case mh_eEvent_Unblock:
  case mh_eEvent_Reblock:
  case mh_eEvent_CancelBlock:
    msgInfop = &(evp->Mess.block.Info);
    eventNamep = evp->Mess.block.EventName;
    break;
  default:
    return 2;
  }

  // compare the prio, if nothing is selected everything is selected
  if (this->eventPrio_A || this->eventPrio_B || this->eventPrio_C
      || this->eventPrio_D) {
    // compare the EventPrio
    switch (msgInfop->EventPrio) {
    case mh_eEventPrio_A:
      if (!eventPrio_A)
        return 2;
      break;
    case mh_eEventPrio_B:
      if (!eventPrio_B)
        return 2;
      break;
    case mh_eEventPrio_C:
      if (!eventPrio_C)
        return 2;
      break;
    case mh_eEventPrio_D:
      if (!eventPrio_D)
        return 2;
      break;
    default:
      return 2;
    }
  }

  // compare the EventName
  if (eventName_str != NULL && (strlen(eventName_str) != 0)) {
    if (EVEN(compareStr(eventNamep, eventName_str)))
      return 2;
  }
  if (eventText_str != NULL && (strlen(eventText_str) != 0)) {
    if (mp != NULL) {
      if (EVEN(compareStr(mp->EventText, eventText_str)))
        return 2;
    } else if (rp != NULL) {
      if (EVEN(compareStr(rp->EventText, eventText_str)))
        return 2;
    } else
      return 2;
  }

  // every condition was true so the mess is alright
  return 1;
}

int Hist::compareStr(char* ev, char* usr)
{
  int sts;
  int startPos = 0;
  unsigned long endPos = 0;
  char* str1;
  sts = dcli_toupper(usr, usr);
  if (ODD(sts)) {
    sts = dcli_wildcard(usr, ev);
    sts += 1;
    if (ODD(sts))
      return sts;

    std::string s = usr;
    endPos = s.find_first_of(';', startPos);
    while (endPos != std::string::npos) {
      str1 = (char*)(s.substr(startPos, endPos - startPos)).c_str();
      sts = dcli_wildcard(str1, ev);
      sts += 1;
      startPos = endPos + 1;
      if (ODD(sts))
        return sts;
      endPos = s.find_first_of(';', startPos);
    }
    str1 = (char*)(s.substr(startPos)).c_str();
    sts = dcli_wildcard(str1, ev);
    sts += 1;
  }
  return sts;
}

void Hist::printSearchStr()
{
  // return;
  bool addAnd = false;
  bool prioPrinted = false;
  int i = 0;
  std::string searchStr[4];
  searchStr[0] = Lng::translate(" All events");
  searchStr[1] = "";
  searchStr[2] = "";
  searchStr[3] = "";

  if ((minTime_str != NULL) && (strlen(minTime_str) > 0)) {
    searchStr[i] += Lng::translate(" from ");
    searchStr[i] += minTime_str;
    addAnd = true;
  }
  if ((maxTime_str != NULL) && (strlen(maxTime_str) > 0)) {
    searchStr[i] += Lng::translate(" to ");
    searchStr[i] += maxTime_str;
    addAnd = true;
  }
  if (eventPrio_A || eventPrio_B || eventPrio_C || eventPrio_D) {
    if (addAnd)
      searchStr[i] += Lng::translate(" and");
    i++;
    prioPrinted = true;
    searchStr[i] += Lng::translate(" with prio ");
    if (eventPrio_A)
      searchStr[i] += "A";
    if (eventPrio_B)
      searchStr[i] += "B";
    if (eventPrio_C)
      searchStr[i] += "C";
    if (eventPrio_D)
      searchStr[i] += "D";
    addAnd = true;
  }
  if (eventType_Ack || eventType_Alarm || eventType_Info
      || eventType_InfoSuccess || eventType_Return) {
    if (addAnd)
      searchStr[i] += Lng::translate(" and");
    if (!prioPrinted)
      i++;
    searchStr[i] += Lng::translate(" with type ");
    if (eventType_Ack) {
      searchStr[i] += Lng::translate("Ack");
      searchStr[i] += " ";
      ;
    }
    if (eventType_Alarm) {
      searchStr[i] += Lng::translate("Active");
      searchStr[i] += " ";
      ;
    }
    if (eventType_Info) {
      searchStr[i] += Lng::translate("Info");
      searchStr[i] += " ";
      ;
    }
    if (eventType_InfoSuccess) {
      searchStr[i] += Lng::translate("InfoSuccess");
      searchStr[i] += " ";
      ;
    }
    if (eventType_Return)
      searchStr[i] += Lng::translate("Return");
    addAnd = true;
  }
  if ((eventName_str != NULL) && (strlen(eventName_str) > 0)) {
    if (addAnd)
      searchStr[i] += Lng::translate(" and");
    i++;
    searchStr[i] += Lng::translate(" with EventName ");
    searchStr[i] += eventName_str;
    addAnd = true;
  }
  if ((eventText_str != NULL) && (strlen(eventText_str) > 0)) {
    if (addAnd)
      searchStr[i] += Lng::translate(" and");
    i++;
    searchStr[i] += Lng::translate(" with EventText ");
    searchStr[i] += eventText_str;
  }

  set_search_string(searchStr[0].c_str(), searchStr[1].c_str(),
      searchStr[2].c_str(), searchStr[3].c_str());
}

/************************************************************************
*
* Name:	GoBackMonth (TimeIn, FromTime, ToTime)
*
* Type:	int
*
* TYPE		PARAMETER	IOGF	DESCRIPTION
* pwr_tTime	TimeIn		I	Start time
* pwr_tTime	*FromTime	O	The first day of the month
* pwr_tTime     *ToTime		O	The last day of the month
*
* Description:	This function computes dates for the first to the last day
*		of the previous month, from the time TimeIn.
*		Output times are only date, e g 1-MAY-1992 00:00:00.00.
*************************************************************************/
int Hist::GoBackMonth(pwr_tTime TimeIn, pwr_tTime* FromTime, pwr_tTime* ToTime)
{
  struct tm* Tm;
  int DaysOfMonth = 0, Month, TmYear, Year;

  /* Get the time in and blank time values. */

  time_t sec = TimeIn.tv_sec;
  Tm = localtime(&sec);

  /* Get number of days in the previous month. */
  if (Tm->tm_mon == 0) {
    Month = 11;
    TmYear = Tm->tm_year - 1;
  } else {
    Month = Tm->tm_mon - 1;
    TmYear = Tm->tm_year;
  }

  switch (Month) {
  case 0:
  case 2:
  case 4:
  case 6:
  case 7:
  case 9:
  case 11:
    DaysOfMonth = 31;
    break;

  case 3:
  case 5:
  case 8:
  case 10:
    DaysOfMonth = 30;
    break;

  case 1:
    Year = TmYear + 1900;
    if ((Year % 4 == 0 && Year % 100 != 0) || (Year + 1900) % 400 == 0)
      DaysOfMonth = 29;
    else
      DaysOfMonth = 28;
    break;
  }

  // memset(Tm, 0, sizeof(*Tm));
  Tm->tm_sec = 0;
  Tm->tm_min = 0;
  Tm->tm_hour = 0;
  Tm->tm_mday = 1;
  Tm->tm_mon = Month;
  Tm->tm_year = TmYear;

  FromTime->tv_sec = mktime(Tm);
  FromTime->tv_nsec = 0;

  ToTime->tv_sec = FromTime->tv_sec + DaysOfMonth * ONEDAY;
  // Tm->tm_mday = DaysOfMonth;
  // ToTime->tv_sec = mktime(Tm);
  ToTime->tv_nsec = 0;

  return (1);
} /* END GoBackMonth */

/************************************************************************
*
* Name:	GoBackWeek( TimeIn, FromTime, ToTime)
*
* Type:	int
*
* TYPE		PARAMETER	IOGF	DESCRIPTION
* pwr_tTime	TimeIn		I	Start time
* pwr_tTime	*FromTime	O	The first day of the month
* pwr_tTime     *ToTime		O	The last day of the month
*
* Description:	This function computes dates for monday to sunday in the
*		previous week from the time now.
*		Output times are only date, e g 1-MAY-1992 00:00:00.00.
*************************************************************************/
int Hist::GoBackWeek(pwr_tTime TimeIn, pwr_tTime* FromTime, pwr_tTime* ToTime)
{
  struct tm* Tm;
  int Days;
  pwr_tTime Time;

  time_t sec = TimeIn.tv_sec;
  Tm = localtime(&sec);
  if (Tm->tm_wday == 0) /* Sunday */
    Days = 13;
  else
    Days = Tm->tm_wday + 6;

  Tm->tm_sec = 0;
  Tm->tm_min = 0;
  Tm->tm_hour = 0;
  Time.tv_sec = mktime(Tm);

  FromTime->tv_sec = Time.tv_sec - Days * ONEDAY;
  FromTime->tv_nsec = 0;

  ToTime->tv_sec = FromTime->tv_sec + 7 * ONEDAY;
  ToTime->tv_nsec = 0;

  return (1);
} /* END GoBackWeek */

/************************************************************************
*
* Name: AdjustForDayBreak
*
* Type: void
*
* Type          Parameter       IOGF    Description
* pwr_tTime     *Time           I       The time
* pwr_tTime	*NewTime  	 O	The adjusted time
*
* Description:
*
*
*************************************************************************/
pwr_tStatus Hist::AdjustForDayBreak(
    Hist* histOP, pwr_tTime* Time, pwr_tTime* NewTime)
{
  struct tm* Tm;

  time_t sec = Time->tv_sec;
  Tm = localtime(&sec);

  Tm->tm_sec = 0;
  Tm->tm_min = 0;
  Tm->tm_hour = 0;

  NewTime->tv_sec = mktime(Tm);
  NewTime->tv_nsec = 0;

  return 1;
} /* AdjustForDayBreak */

void Hist::hist_init_cb(void* ctx)
{
  Hist* hist = (Hist*)ctx;
  pwr_tAName name_str;
  pwr_tStatus sts;

  // If objid is applied, search for this object
  if (cdh_ObjidIsNotNull(hist->aref.Objid)) {
    sts = gdh_AttrrefToName(
        &hist->aref, name_str, sizeof(name_str), cdh_mName_pathStrict);
    if (ODD(sts)) {
      hist->insert_eventname(name_str);
      hist->eventName_str = name_str;
      hist->get_hist_list();
    }
  }
}
#endif
