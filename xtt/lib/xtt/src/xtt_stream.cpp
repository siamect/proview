/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include "co_cdh.h"
#include "co_dcli.h"
#include "co_string.h"

#include "rt_gdh_msg.h"
#include "rt_xnav_msg.h"

#include "cow_wow.h"

#include "glow_growapi.h"
#include "glow_curveapi.h"

#include "xtt_xnav.h"
#include "xtt_stream.h"

static int debug = 0;

XttStream::XttStream(void* st_parent_ctx, const char* name, const char* st_uri,
    int st_width, int st_height, int x, int y, double st_scan_time,
    unsigned int st_options, int st_embedded, pwr_tAttrRef* st_arp)
    : parent_ctx(st_parent_ctx), options(st_options), embedded(st_embedded),
      timerid(0), scroll_timerid(0), x_offset(0), y_offset(0), width(st_width),
      height(st_height), stream_width(0), stream_height(0), close_cb(0),
      camera_control(0), control_protocol(pwr_eCameraControlEnum_No)
{
  pwr_tStatus sts;

  strncpy(uri, st_uri, sizeof(uri));
  if (st_scan_time < 0.02)
    scan_time = 250;
  else
    scan_time = 1000 * st_scan_time;

  if (st_arp)
    aref = *st_arp;
  else
    memset(&aref, 0, sizeof(aref));

  if (st_arp) {
    pwr_tAttrRef aaref;

    sts = gdh_ArefANameToAref(&aref, "StreamWidth", &aaref);
    if (ODD(sts))
      sts = gdh_GetObjectInfoAttrref(
          &aaref, &stream_width, sizeof(stream_width));
    if (EVEN(sts))
      stream_width = 0;

    sts = gdh_ArefANameToAref(&aref, "StreamHeight", &aaref);
    if (ODD(sts))
      sts = gdh_GetObjectInfoAttrref(
          &aaref, &stream_height, sizeof(stream_height));
    if (EVEN(sts))
      stream_height = 0;

    sts = gdh_ArefANameToAref(&aref, "Control", &aaref);
    if (ODD(sts))
      sts = gdh_GetObjectInfoAttrref(
          &aaref, &control_protocol, sizeof(control_protocol));
    if (EVEN(sts))
      control_protocol = pwr_eCameraControlEnum_No;

    sts = gdh_ArefANameToAref(&aref, "User", &aaref);
    if (ODD(sts))
      sts = gdh_GetObjectInfoAttrref(&aaref, user, sizeof(user));
    if (EVEN(sts))
      strcpy(user, "");

    sts = gdh_ArefANameToAref(&aref, "Password", &aaref);
    if (ODD(sts))
      sts = gdh_GetObjectInfoAttrref(&aaref, password, sizeof(password));
    if (EVEN(sts))
      strcpy(user, "");

    pwr_tFloat32 tmo = 0.0;
    sts = gdh_ArefANameToAref(&aref, "ConnectionTimeout", &aaref);
    if (ODD(sts))
      sts = gdh_GetObjectInfoAttrref(&aaref, &tmo, sizeof(tmo));
    if (ODD(sts)) {
      connection_timeout = tmo;
      if (connection_timeout < 1)
        connection_timeout = 10;
    } else
      connection_timeout = 10;

    pwr_tFloat32 time = 0.0;
    sts = gdh_ArefANameToAref(&aref, "ReconnectTime", &aaref);
    if (ODD(sts))
      sts = gdh_GetObjectInfoAttrref(&aaref, &time, sizeof(time));
    if (ODD(sts)) {
      reconnect_time = time;
      if (connection_timeout < 1)
        reconnect_time = 5;
    } else
      reconnect_time = 5;

    if (!streq(user, "") && !streq(password, "")) {
      // sprintf( &uri[strlen(uri)], "?user=%s&pwd=%s", user, password);
    }

    switch (control_protocol) {
    case pwr_eCameraControlEnum_VAPIX:
      camera_control = new XttCameraControlVapix(uri, user, password);
      break;
    case pwr_eCameraControlEnum_ONVIF:
      // Not yet implemented...
      break;
    default:;
    }
  }
  if (stream_width == 0 || stream_height == 0) {
    stream_width = 700;
    stream_height = 580;
  }
  stream_ratio = ((float)stream_width) / stream_height;

  if (width > height * stream_ratio) {
    x_offset = (width - height * stream_ratio) / 2;
    y_offset = 0;
  } else {
    x_offset = 0;
    y_offset = (height - ((float)width) / stream_ratio) / 2;
  }
}

XttStream::~XttStream()
{
  delete camera_control;
}

void XttStream::position(double pan, double tilt, double zoom)
{
  if (!camera_control)
    return;

  camera_control->pan_tilt_zoom_absolute(pan, tilt, zoom);
}

void XttStream::action_click(int x, int y)
{
  if (!camera_control)
    return;

  camera_control->center(x - x_offset, y - y_offset, width - 2 * x_offset,
      height - 2 * y_offset, stream_width, stream_height);
}

void XttStream::action_areaselect(int x, int y, int w, int h)
{
  if (!camera_control)
    return;

  camera_control->area_zoom(x - x_offset, y - y_offset, w, h,
      width - 2 * x_offset, height - 2 * y_offset, stream_width, stream_height);
}

void XttStream::action_scroll(int direction, int x, int y, int cnt)
{
  if (!camera_control)
    return;

  double zoom;

  if (direction)
    zoom = cnt * 4;
  else
    zoom = -cnt * 4;

  camera_control->zoom_relative(zoom);
}

void XttStream::action_mb2click(int x, int y)
{
  if (!camera_control)
    return;

  double zoom = 1;

  camera_control->zoom_absolute(zoom);
}

void XttStream::action_mb3click(int x, int y)
{
  if (!camera_control)
    return;

  create_popup_menu(x, y);
}

void XttStream::activate_preset_position(int idx)
{
  if (!camera_control)
    return;

  if (cdh_ObjidIsNull(aref.Objid))
    return;

  pwr_tOName aname;
  pwr_tAttrRef aaref;
  pwr_tStatus sts;

  sprintf(aname, "PresetPosition[%d]", idx);

  sts = gdh_ArefANameToAref(&aref, aname, &aaref);
  if (EVEN(sts))
    return;

  pwr_sClass_CameraPtz pos;
  sts = gdh_GetObjectInfoAttrref(&aaref, &pos, sizeof(pos));
  if (EVEN(sts))
    return;

  camera_control->pan_tilt_zoom_absolute(pos.Pan, pos.Tilt, pos.Zoom);
}

void XttStream::activate_preset_store_pos(int idx)
{
  if (!camera_control)
    return;

  if (cdh_ObjidIsNull(aref.Objid))
    return;

  pwr_tOName aname;
  pwr_tAttrRef aaref;
  pwr_tStatus sts;
  double pan, tilt, zoom;

  sprintf(aname, "PresetPosition[%d]", idx);

  sts = gdh_ArefANameToAref(&aref, aname, &aaref);
  if (EVEN(sts))
    return;

  camera_control->get_position(&pan, &tilt, &zoom);

  pwr_sClass_CameraPtz pos;
  pos.Pan = pan;
  pos.Tilt = tilt;
  pos.Zoom = zoom;

  sts = gdh_SetObjectInfoAttrref(&aaref, &pos, sizeof(pos));
  if (EVEN(sts))
    return;
}

void XttStream::pop()
{
}

void XttStream::set_size(int width, int height)
{
}

void XttStream::setup()
{
}

void* XttStream::get_widget()
{
  return 0;
}

void XttStream::create_popup_menu(int x, int y)
{
}

XttCameraControl::XttCameraControl(char* x_url)
{
}

XttCameraControl::~XttCameraControl()
{
}

void XttCameraControl::zoom_relative(double factor)
{
}

void XttCameraControl::zoom_absolute(double factor)
{
}

void XttCameraControl::pan_relative(double value)
{
}

void XttCameraControl::pan_absolute(double value)
{
}

void XttCameraControl::tilt_relative(double value)
{
}

void XttCameraControl::tilt_absolute(double value)
{
}

void XttCameraControl::pan_tilt_zoom_absolute(
    double pan, double tilt, double zoom)
{
}

void XttCameraControl::center(
    int x, int y, int width, int height, int stream_width, int stream_height)
{
}

void XttCameraControl::area_zoom(int x, int y, int width, int height,
    int window_width, int window_height, int stream_width, int stream_height)
{
}

int XttCameraControl::get_position(double* pan, double* tilt, double* zoom)
{
  return 0;
}

XttCameraControlVapix::XttCameraControlVapix(
    char* x_url, char* x_user, char* x_password)
    : XttCameraControl(x_url)
{
  strncpy(url, x_url, sizeof(url));
  char* s = strchr(url, '/');
  if (s)
    s = strchr(++s, '/');
  if (s)
    s = strchr(++s, '/');
  if (s)
    *s = 0;

  if (debug)
    strcpy(outstr, "");
  else
    strcpy(outstr, "-o /dev/null");

  if (!streq(x_user, "") && !streq(x_password, ""))
    sprintf(authstr, "--user %s --password %s", x_user, x_password);
  else
    strcpy(authstr, "");
}

XttCameraControlVapix::~XttCameraControlVapix()
{
}

// Relative zoom, factor is -100 - 100, - zoom out, + zoom in.
void XttCameraControlVapix::zoom_relative(double factor)
{
  pwr_tCmd cmd;
  int zoom = (int)(factor * 100);
  if (zoom > 9999)
    zoom = 9999;
  if (zoom < -9999)
    zoom = -9999;

  sprintf(cmd,
      "wget --ignore-length %s %s %s/axis-cgi/com/ptz.cgi?camera=1\\&rzoom=%d",
      authstr, outstr, url, zoom);
  int sts = system(cmd);
  if (sts != 0)
    printf("** Error from wget: %d\n", sts >> 8);
}

// Absolute zoom, 0 - 100, 0 is max out, 100 is max in.
void XttCameraControlVapix::zoom_absolute(double factor)
{
  pwr_tCmd cmd;
  int zoom = (int)(factor * 100);
  if (zoom < 1)
    zoom = 1;
  if (zoom > 9999)
    zoom = 9999;

  sprintf(cmd,
      "wget --ignore-length %s %s %s/axis-cgi/com/ptz.cgi?camera=1\\&zoom=%d",
      authstr, outstr, url, zoom);
  int sts = system(cmd);
  if (sts != 0)
    printf("** Error from wget: %d\n", sts >> 8);
}

// Relative pan, value is -100 - 100.
void XttCameraControlVapix::pan_relative(double value)
{
  pwr_tCmd cmd;
  int pan = (int)(value / 100 * 360);
  if (pan > 360)
    pan = 360;
  if (pan < -360)
    pan = -360;

  sprintf(cmd,
      "wget --ignore-length %s %s %s/axis-cgi/com/ptz.cgi?camera=1\\&rpan=%d",
      authstr, outstr, url, pan);
  int sts = system(cmd);
  if (sts != 0)
    printf("** Error from wget: %d\n", sts >> 8);
}

// Absolute pan, value is 0 - 100.
void XttCameraControlVapix::pan_absolute(double value)
{
  pwr_tCmd cmd;
  int pan = (int)(value / 100 * 360 - 180);
  if (pan > 180)
    pan = 180;
  if (pan < -180)
    pan = -180;

  sprintf(cmd,
      "wget --ignore-length %s %s %s/axis-cgi/com/ptz.cgi?camera=1\\&rpan=%d",
      authstr, outstr, url, pan);
  int sts = system(cmd);
  if (sts != 0)
    printf("** Error from wget: %d\n", sts >> 8);
}

// Relative tilt, value is -100 - 100.
void XttCameraControlVapix::tilt_relative(double value)
{
  pwr_tCmd cmd;
  int tilt = (int)(value / 100 * 360);
  if (tilt > 360)
    tilt = 360;
  if (tilt < -360)
    tilt = -360;

  sprintf(cmd,
      "wget --ignore-length %s %s %s/axis-cgi/com/ptz.cgi?camera=1\\&rtilt=%d",
      authstr, outstr, url, tilt);
  int sts = system(cmd);
  if (sts != 0)
    printf("** Error from wget: %d\n", sts >> 8);
}

// Absolute tilt, value is 0 - 100.
void XttCameraControlVapix::tilt_absolute(double value)
{
  pwr_tCmd cmd;
  int tilt = (int)(value / 100 * 360 - 180);
  if (tilt > 180)
    tilt = 180;
  if (tilt < -180)
    tilt = -180;

  sprintf(cmd,
      "wget --ignore-length %s %s %s/axis-cgi/com/ptz.cgi?camera=1\\&rtilt=%d",
      authstr, outstr, url, tilt);
  int sts = system(cmd);
  if (sts != 0)
    printf("** Error from wget: %d\n", sts >> 8);
}

// Absolute pan, tilt and zoom.
void XttCameraControlVapix::pan_tilt_zoom_absolute(
    double pan, double tilt, double zoom)
{
  pwr_tCmd cmd;
  double ipan = pan / 100 * 360 - 180;
  if (ipan > 180)
    ipan = 180;
  if (ipan < -180)
    ipan = -180;

  double itilt = tilt / 100 * 360 - 180;
  if (itilt > 180)
    itilt = 180;
  if (itilt < -180)
    itilt = -180;

  int izoom = int(zoom * 100);
  if (izoom < 1)
    zoom = 1;
  if (izoom > 19999)
    izoom = 19999;

  sprintf(cmd, "wget --ignore-length %s %s "
               "%s/axis-cgi/com/"
               "ptz.cgi?camera=1\\&pan=%.2f\\&tilt=%.2f\\&zoom=%d",
      authstr, outstr, url, ipan, itilt, izoom);
  int sts = system(cmd);
  if (sts != 0)
    printf("** Error from wget: %d\n", sts >> 8);
}

// Center coordinates. Coordinates in current camera window size.
void XttCameraControlVapix::center(
    int x, int y, int width, int height, int stream_width, int stream_height)
{
  pwr_tCmd cmd;

  if (stream_width == 0 || stream_height == 0) {
    stream_width = 700;
    stream_height = 580;
  }

  x = ((float)stream_width) / width * x;
  y = ((float)stream_height) / height * y;

  // sprintf( cmd, "wget --ignore-length %s %s
  // %s/axis-cgi/com/ptz.cgi?camera=1\\&center=%d,%d\\&imagewidth=%d",
  //	   authstr, outstr, url, x, y, width);
  sprintf(cmd, "wget --ignore-length %s %s "
               "%s/axis-cgi/com/ptz.cgi?camera=1\\&center=%d,%d",
      authstr, outstr, url, x, y);
  int sts = system(cmd);
  if (sts != 0)
    printf("** Error from wget: %d\n", sts >> 8);
}

void XttCameraControlVapix::area_zoom(int x, int y, int width, int height,
    int window_width, int window_height, int stream_width, int stream_height)
{
  pwr_tCmd cmd;
  int zoom;
  float fzoom;

  x += width / 2;
  y += height / 2;

  x = ((float)stream_width) / window_width * x;
  y = ((float)stream_height) / window_height * y;
  if (width == 0 || height == 0)
    return;

  fzoom = MIN((float)window_width / width, (float)window_height / height);
  zoom = 100 * fzoom;
  if (zoom > 9999)
    zoom = 9999;

  sprintf(cmd, "wget --ignore-length %s %s "
               "%s/axis-cgi/com/ptz.cgi?camera=1\\&areazoom=%d,%d,%d",
      authstr, outstr, url, x, y, zoom);
  int sts = system(cmd);
  if (sts != 0)
    printf("** Error from wget: %d\n", sts >> 8);
}

// Get current pan, tilt and zoom.
int XttCameraControlVapix::get_position(double* pan, double* tilt, double* zoom)
{
  char cmd[630];
  pwr_tFileName fname = "/tmp/campos.txt";
  FILE* fp;
  char line[100];
  char* s;
  int sts;
  float cpan = 0.0, ctilt = 0.0, czoom = 0.0;
  int pan_found, tilt_found, zoom_found;
  pwr_tTime old_time;
  pwr_tTime time;
  int old_file_found;
  int new_file_found;

  old_file_found = 0;
  sts = dcli_file_time(fname, &old_time);
  if (ODD(sts))
    old_file_found = 1;

  sprintf(cmd, "wget --ignore-length %s %s "
               "%s/axis-cgi/com/ptz.cgi?camera=1\\&query=position "
               "--output-document=%s",
      authstr, outstr, url, fname);
  sts = system(cmd);
  if (sts != 0)
    printf("** Error from wget: %d\n", sts >> 8);

  new_file_found = 0;
  sts = dcli_file_time(fname, &time);
  if (ODD(sts)) {
    if (!old_file_found)
      new_file_found = 1;
    else {
      if (time_Acomp(&old_time, &time) != 0)
        new_file_found = 1;
    }
  }
  if (!new_file_found)
    return 0;

  fp = fopen(fname, "r");
  if (!fp)
    return 0;

  pan_found = 0;
  tilt_found = 0;
  zoom_found = 0;
  while (ODD(dcli_read_line(line, sizeof(line), fp))) {
    if ((s = strstr(line, "pan=")) != 0) {
      sts = sscanf(s + 4, "%f", &cpan);
      if (sts == 1)
        pan_found = 1;
    } else if ((s = strstr(line, "tilt=")) != 0) {
      sts = sscanf(s + 5, "%f", &ctilt);
      if (sts == 1)
        tilt_found = 1;
    } else if ((s = strstr(line, "zoom=")) != 0) {
      sts = sscanf(s + 5, "%f", &czoom);
      if (sts == 1)
        zoom_found = 1;
    }
    if (pan_found && tilt_found && zoom_found) {
      break;
    }
  }
  fclose(fp);

  sprintf(cmd, "rm -f %s", fname);
  system(cmd);

  if (!(pan_found && tilt_found && zoom_found))
    return 0;

  *pan = (cpan + 180) / 360 * 100;
  *tilt = (ctilt + 180) / 360 * 100;
  *zoom = czoom / 100;

  return 1;
}
