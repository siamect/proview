/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* xtt_xnav_command.cpp
   This module contains routines for handling of command line in xnav. */

#include "pwr_nmpsclasses.h"
#include "pwr_sevclasses.h"

#include "pwr_msg.h"
#include "co_api_user.h"
#include "co_ccm_msg.h"
#include "co_cdh.h"
#include "co_dcli_msg.h"
#include "co_error.h"
#include "co_string.h"
#include "co_user.h"

#include "rt_gdh_msg.h"

#include "cow_login.h"
#include "cow_xhelp.h"

#include "glow_msg.h"

#include "ge_graph.h"

#include "xtt_clog.h"
#include "xtt_ev.h"
#include "xtt_fast.h"
#include "xtt_fileview.h"
#include "xtt_ge.h"
#include "xtt_hist.h"
#include "xtt_item.h"
#include "xtt_log.h"
#include "xtt_op.h"
#include "xtt_sevhist.h"
#include "xtt_ssaboxclasses.h"
#include "xtt_stream.h"
#include "xtt_tcurve.h"
#include "xtt_trace.h"
#include "xtt_trend.h"
#include "xtt_url.h"
#include "xtt_xattone.h"
#include "xtt_xcolwind.h"
#include "xtt_xcrr.h"
#include "xtt_xnav_crr.h"

class xnav_file {
public:
  xnav_file(char* text, char* file, item_eFileType file_type)
      : m_file_type(file_type)
  {
    strcpy(m_text, text);
    strcpy(m_file, file);
  }
  bool operator<(const xnav_file& x)
  {
    return (strcmp(m_text, x.m_text) < 0);
  }

  char m_text[80];
  pwr_tFileName m_file;
  item_eFileType m_file_type;
};

typedef struct {
  pwr_tOid oid;
  XNav* xnav;
  char title[256];
} xnav_sHistList;

typedef struct {
  pwr_tCid cid;
  XNav* xnav;
  char title[256];
} xnav_sObjectList;

#define IF_NOGDH_RETURN                                                        \
  if (!xnav->gbl.gdh_started) {                                                \
    xnav->message('E', "Xtt is not connected to nethandler");                  \
    return XNAV__SUCCESS;                                                      \
  }

#define XNAV_MENU_CREATE 0
#define XNAV_MENU_ADD 1

pwr_dImport pwr_BindXttClasses(Base);

static char null_str[] = "";
static char xtt_version[] = "V3.3a";
static XNav* current_xnav;
static pwr_tStatus command_sts = 1;

static void xnav_ev_help_cb(void* xnav, const char* key);
static void xnav_ev_display_in_xnav_cb(void* xnav, pwr_sAttrRef* arp);
static int xnav_ev_sound_cb(void* xnav, pwr_sAttrRef* arp);
static void xnav_ev_pop_cb(void* xnav);
static void xnav_ev_update_info_cb(void* xnav);
static void xnav_ge_help_cb(void* ctx, const char* key);
static int xnav_ge_get_current_objects_cb(
    void* vxnav, pwr_sAttrRef** alist, int** is_areflist);
static int xnav_ge_sound_cb(void* xnav, pwr_sAttrRef* arp);
static void xnav_ge_eventlog_cb(
    void* xnav, void* gectx, int type, void* data, unsigned int size);
static void xnav_ge_keyboard_cb(void* ctx, void* gectx, int action, int type);
static void xnav_ge_display_in_xnav_cb(void* xnav, pwr_sAttrRef* arp);
static int xnav_ge_is_authorized_cb(void* xnav, unsigned int access);
static void xnav_ge_namechanged_cb(void* ctx, void* gectx, char* name);
static int xnav_ge_get_select_cb(void* ctx, char* oname, pwr_tTypeId* type);
static int xnav_attribute_func(char* name, int* return_decl,
    ccm_tFloat* return_float, ccm_tInt* return_int, char* return_string);
static int xnav_multiview_command_cb(
    void* gectx, char* command, char* script, void* caller);
static int xnav_ge_command_cb(
    void* gectx, char* command, char* script, void* caller);
static void xnav_ge_close_cb(void* xnav, void* gectx);
static void xnav_multiview_close_cb(void* xnav, void* mvctx);
static void xnav_stream_close_cb(void* xnav, XttStream* strmctx);
// new code by Jonas Nylund 030131
static void xnav_hist_close_cb(void* ctx);
// end new code by Jonas Nylund 030131
static int xnav_op_command_cb(void* xnav, char* command);
static void xnav_op_close_cb(void* ctx);
static void xnav_op_help_cb(void* ctx, const char* key);
static void xnav_op_map_cb(void* ctx);
static int xnav_op_get_alarm_info_cb(void* xnav, evlist_sAlarmInfo* info, int backward, int alarmsize);
static void xnav_op_ack_last_cb(void* xnav, unsigned long type, unsigned long prio, int backward,
				int timecheck);
static void xnav_trend_close_cb(void* ctx, XttTrend* trend);
static void xnav_trend_command_cb(void* ctx, const char* key);
static void xnav_trend_help_cb(void* ctx, const char* key);
static void xnav_tcurve_close_cb(void* ctx, XttTCurve* trend);
static void xnav_tcurve_help_cb(void* ctx, const char* key);
static void xnav_sevhist_help_cb(void* ctx, const char* key);
static void xnav_sevhist_close_cb(void* ctx, XttSevHist* hist);
static int xnav_sevhist_get_select_cb(
    void* ctx, pwr_tOid* oid, char* aname, char* oname);
static int xnav_get_select_cb(void* ctx, pwr_tAttrRef* aref, int* is_attr);
static void xnav_fast_close_cb(void* ctx, XttFast* fast);
static void xnav_fast_help_cb(void* ctx, const char* key);
static void xnav_xao_close_cb(void* ctx, XAttOne* xao);
static void xnav_clog_close_cb(void* ctx);
static void xnav_open_shist_cb(void* ctx, char* text, int ok_pressed);
static void xnav_open_shist_cancel_cb(void* ctx);
static void xnav_show_objectlist_cb(void* ctx, char* text, int ok_pressed);
static void xnav_show_objectlist_cancel_cb(void* ctx);
static void xnav_colortheme_selector_ok_cb(
    void* ctx, char* text, int ok_pressed);
static void xnav_keyboard_key_pressed_cb(void*, int);
static void xnav_keyboard_close_cb(void*);
static int xnav_replace_node_str(char* out, char* object_str);
static pwr_tStatus xnav_otree_action_cb(void* xnav, pwr_tAttrRef* aref);

static int xnav_help_func(void* client_data, void* client_flag);
static int xnav_define_func(void* client_data, void* client_flag);
static int xnav_logout_func(void* client_data, void* client_flag);
static int xnav_login_func(void* client_data, void* client_flag);
static int xnav_show_func(void* client_data, void* client_flag);
static int xnav_open_func(void* client_data, void* client_flag);
static int xnav_close_func(void* client_data, void* client_flag);
static int xnav_create_func(void* client_data, void* client_flag);
static int xnav_delete_func(void* client_data, void* client_flag);
static int xnav_add_func(void* client_data, void* client_flag);
static int xnav_collect_func(void* client_data, void* client_flag);
static int xnav_dashboard_func(void* client_data, void* client_flag);
static int xnav_store_func(void* client_data, void* client_flag);
static int xnav_exit_func(void* client_data, void* client_flag);
static int xnav_crossref_func(void* client_data, void* client_flag);
static int xnav_setup_func(void* client_data, void* client_flag);
static int xnav_search_func(void* client_data, void* client_flag);
static int xnav_eventlist_func(void* client_data, void* client_flag);
static int xnav_set_func(void* client_data, void* client_flag);
static int xnav_test_func(void* client_data, void* client_flag);
static int xnav_logging_func(void* client_data, void* client_flag);
static int xnav_call_func(void* client_data, void* client_flag);
static int xnav_check_func(void* client_data, void* client_flag);
static int xnav_print_func(void* client_data, void* client_flag);
static int xnav_export_func(void* client_data, void* client_flag);
static int xnav_sound_func(void* client_data, void* client_flag);
static int xnav_write_func(void* client_data, void* client_flag);
static int xnav_read_func(void* client_data, void* client_flag);
static int xnav_wait_func(void* client_data, void* client_flag);
static int xnav_oplog_func(void* client_data, void* client_flag);
static int xnav_emit_func(void* client_data, void* client_flag);

dcli_tCmdTable xnav_command_table[] = {
  { "SHOW", &xnav_show_func,
      { "dcli_arg1", "dcli_arg2", "/NAME", "/CLASS", "/HIERARCHY", "/PARAMETER",
          "/OBJID", "/FILE", "/LOCAL", "/INITSTEP", "/MAXOBJECTS", "/VOLUME",
          "/ALL", "/TYPE", "/OPTION", "/ENTRY", "/NEW", "/TITLE", "/WINDOW",
          "/ALARMVIEW", "/WIDTH", "/HEIGHT", "/XPOSITION", "/YPOSITION",
          "/FULLSCREEN", "/MAXIMIZE", "/FULLMAXIMIZE", "/SORT", "/TEXT",
          "/LAYOUT", "/GLOBAL", "/ALPHAORDER", "" } },
  { "OPEN", &xnav_open_func,
      { "dcli_arg1", "dcli_arg2", "/NAME", "/FILE", "/SCROLLBAR", "/WIDTH",
          "/HEIGHT", "/MENU", "/NAVIGATOR", "/CENTER", "/OBJECT", "/NEW",
          "/INSTANCE", "/COLLECT", "/FOCUS", "/INPUTEMPTY", "/MAIN", "/ENTRY",
          "/TITLE", "/ACCESS", "/DASHBOARD", "/CLASSGRAPH", "/PARENT", "/PWINDOW",
          "/PINSTANCE", "/BYPASS", "/CLOSEBUTTON", "/TARGET", "/TRIGGER",
          "/TYPE", "/FTYPE", "/FULLSCREEN", "/MAXIMIZE", "/FULLMAXIMIZE",
          "/ICONIFY", "/HIDE", "/XPOSITION", "/YPOSITION", "/X0", "/Y0", "/X1",
          "/Y1", "/URL", "/CONTINOUS", "/CAMERAPOSITION", "/CAMERACONTROLPANEL",
          "/VIDEOCONTROLPANEL", "/VIDEOPROGRESSBAR", "/SCANTIME", "/KEYMAP",
	  "" } },
  { "CLOSE", &xnav_close_func,
      { "dcli_arg1", "dcli_arg2", "/NAME", "/OBJECT", "/INSTANCE",
          "/CLASSGRAPH", "/ALL", "/EXCEPT", "/MVEXCEPT", "/ICONIFY", "" } },
  { "CREATE", &xnav_create_func,
      { "dcli_arg1", "/TEXT", "/MENU", "/DESTINATION", "/COMMAND", "/AFTER",
          "/BEFORE", "/FIRSTCHILD", "/LASTCHILD", "/CLASS", "/NAME", "/PIXMAP",
          "" } },
  { "DELETE", &xnav_delete_func, { "dcli_arg1", "/NAME", "" } },
  { "ADD", &xnav_add_func,
      { "dcli_arg1", "dcli_arg2", "/NAME", "/CLASS", "/HIERARCHY", "/PARAMETER",
          "/LOCAL", "/TEXT", "/OBJECT", "/COMMAND", "" } },
  { "STORE", &xnav_store_func,
      { "dcli_arg1", "/COLLECT", "/FILE", "/SYMBOLS", "" } },
  { "EXIT", &xnav_exit_func,
      {
          "",
      } },
  { "QUIT", &xnav_exit_func,
      {
          "",
      } },
  { "DEFINE", &xnav_define_func,
      { "dcli_arg1", "dcli_arg2", "dcli_arg3", "dcli_arg4", "" } },
  { "HELP", &xnav_help_func,
      { "dcli_arg1", "dcli_arg2", "dcli_arg3", "dcli_arg4", "/HELPFILE",
          "/POPNAVIGATOR", "/BOOKMARK", "/INDEX", "/BASE", "/RETURNCOMMAND",
          "/WIDTH", "/HEIGHT", "/VERSION", "/STRICT", "" } },
  { "LOGOUT", &xnav_logout_func, { "/MESSAGEWINDOW", "" } },
  { "LOGIN", &xnav_login_func, { "dcli_arg1", "dcli_arg2", "" } },
  { "COLLECT", &xnav_collect_func,
      { "dcli_arg1", "/NAME", "/NEWWINDOW", "/ADDWINDOW", "/LAST", "/TITLE",
          "/WIDTH", "/HEIGHT", "/SCANTIME", "/ZOOMFACTOR", "/FILE", "" } },
  { "DASHBOARD", &xnav_dashboard_func,
      { "dcli_arg1", "dcli_arg2", "/NAME", "" } },
  { "CROSSREFERENCE", &xnav_crossref_func,
      { "dcli_arg1", "/NAME", "/FILE", "/STRING", "/BRIEF", "/FUNCTION",
          "/CASE_SENSITIVE", "/WINDOW", "" } },
  { "SET", &xnav_set_func,
      { "dcli_arg1", "dcli_arg2", "/NAME", "/VALUE", "/BYPASS", "/PUBLICWRITE",
          "/INDEX", "/SOURCE", "/OBJECT", "/CONTINUE", "/X0", "/Y0", "/X1",
          "/Y1", "/INSTANCE", "/ESCAPESTORE", "/FOCUS", "/INPUTEMPTY",
          "/ICONIFY", "/BELOW", "/ON", "/OFF", "" } },
  { "SETUP", &xnav_setup_func,
      {
          "",
      } },
  { "SEARCH", &xnav_search_func,
      { "dcli_arg1", "/REGULAREXPRESSION", "/NEXT", "" } },
  { "EVENTLIST", &xnav_eventlist_func,
      {
	"dcli_arg1", "/PRIORITY", "/NAME", "/ALL", "/AUTOACKNOWLEDGE", "/OLDEST",
	"/TIMECHECK", "",
      } },
  { "TEST", &xnav_test_func, { "dcli_arg1", "dcli_arg2", "" } },
  { "LOGGING", &xnav_logging_func,
      { "dcli_arg1", "dcli_arg2", "/FILE", "/TIME", "/ENTRY", "/TYPE", "/FORMAT",
          "/PARAMETER", "/CONDITION", "/INSERT", "/BUFFER_SIZE", "/PRIORITY",
          "/STOP", "/NOSTOP", "/CREATE", "/ALL", "/LINE_SIZE", "/SHORTNAME",
          "/NOSHORTNAME", "" } },
  { "CALL", &xnav_call_func,
      { "dcli_arg1", "/METHOD", "/OBJECT", "/FUNCTION", "" } },
  { "CHECK", &xnav_check_func,
      { "dcli_arg1", "/METHOD", "/OBJECT", "/FILTER", "" } },
  { "PRINT", &xnav_print_func,
      { "dcli_arg1", "dcli_arg2", "/NAME", "/FILE", "/OBJECT", "/CLASSGRAPH",
          "/INSTANCE", "" } },
  { "EXPORT", &xnav_export_func,
      { "dcli_arg1", "/GRAPH", "/NAME", "/FILE", "/OBJECT", "/CLASSGRAPH",
          "/INSTANCE", "" } },
  { "SOUND", &xnav_sound_func, { "dcli_arg1", "/OBJECT", "" } },
  { "WRITE", &xnav_write_func, { "dcli_arg1", "/OBJECT", "/FILE", "" } },
  { "READ", &xnav_read_func, { "dcli_arg1", "/OBJECT", "/FILE", "" } },
  { "WAIT", &xnav_wait_func, { "dcli_arg1", "/TIME", "" } },
  { "OPLOG", &xnav_oplog_func,
      { "dcli_arg1", "/FILE", "/SPEED", "/PID", "/EVENT", "" } },
  { "EMIT", &xnav_emit_func,
      { "dcli_arg1", "/SIGNALNAME", "/GRAPH", "/INSTANCE", "" } },
  {
      "", NULL, { "" }
  }
};

static void xnav_store_xnav(XNav* xnav)
{
  current_xnav = xnav;
}

static void xnav_get_stored_xnav(XNav** xnav)
{
  *xnav = current_xnav;
}

static int xnav_help_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;
  int sts;
  char arg_str[80];
  char file_str[80];
  char bookmark_str[80];
  char key[80];
  char return_str[80];
  int pop;
  int width, height;
  int nr;

  if (ODD(dcli_get_qualifier("/INDEX", file_str, sizeof(file_str)))) {
    if (ODD(dcli_get_qualifier("/HELPFILE", file_str, sizeof(file_str)))) {
      sts = CoXHelp::dhelp_index(navh_eHelpFile_Other, file_str);
      if (EVEN(sts))
        xnav->message('E', "Unable to find file");
    } else {
      if (ODD(dcli_get_qualifier("/BASE", 0, 0)))
        sts = CoXHelp::dhelp_index(navh_eHelpFile_Base, NULL);
      else
        sts = CoXHelp::dhelp_index(navh_eHelpFile_Project, NULL);
    }
    return 1;
  }

  if (ODD(dcli_get_qualifier("/VERSION", 0, 0))) {
    sts = CoXHelp::dhelp("version", "", navh_eHelpFile_Other,
        "$pwr_load/xtt_version_help.dat", 0);
    if (EVEN(sts))
      xnav->message('E', "No help on this subject");
    return sts;
  }

  int strict = ODD(dcli_get_qualifier("/STRICT", 0, 0));

  if (EVEN(dcli_get_qualifier("dcli_arg1", arg_str, sizeof(arg_str)))) {
    sts = CoXHelp::dhelp("help command", "", navh_eHelpFile_Base, NULL, strict);
    return 1;
  }
  if (EVEN(dcli_get_qualifier("/BOOKMARK", bookmark_str, sizeof(bookmark_str))))
    strcpy(bookmark_str, "");

  strcpy(key, arg_str);
  if (ODD(dcli_get_qualifier("dcli_arg2", arg_str, sizeof(arg_str)))) {
    strcat(key, " ");
    strcat(key, arg_str);
    if (ODD(dcli_get_qualifier("dcli_arg3", arg_str, sizeof(arg_str)))) {
      strcat(key, " ");
      strcat(key, arg_str);
      if (ODD(dcli_get_qualifier("dcli_arg3", arg_str, sizeof(arg_str)))) {
        strcat(key, " ");
        strcat(key, arg_str);
        if (ODD(dcli_get_qualifier("dcli_arg4", arg_str, sizeof(arg_str)))) {
          strcat(key, " ");
          strcat(key, arg_str);
        }
      }
    }
  }
  if (!ODD(
          dcli_get_qualifier("/RETURNCOMMAND", return_str, sizeof(return_str))))
    strcpy(return_str, "");

  if (ODD(dcli_get_qualifier("/WIDTH", arg_str, sizeof(arg_str)))) {
    // convert to integer
    nr = sscanf(arg_str, "%d", &width);
    if (nr != 1) {
      xnav->message('E', "Width syntax error");
      return XNAV__HOLDCOMMAND;
    }
  } else
    width = 0;

  if (ODD(dcli_get_qualifier("/HEIGHT", arg_str, sizeof(arg_str)))) {
    // convert to integer
    nr = sscanf(arg_str, "%d", &height);
    if (nr != 1) {
      xnav->message('E', "Height syntax error");
      return XNAV__HOLDCOMMAND;
    }
  } else
    height = 0;

  pop = ODD(dcli_get_qualifier("/POPNAVIGATOR", 0, 0));

  if (ODD(dcli_get_qualifier("/HELPFILE", file_str, sizeof(file_str)))) {
    sts = CoXHelp::dhelp(
        key, bookmark_str, navh_eHelpFile_Other, file_str, strict);
    if (EVEN(sts))
      xnav->message('E', "No help on this subject");
    else if (!streq(return_str, ""))
      xnav->set_push_command(return_str);
  } else if (ODD(dcli_get_qualifier("/BASE", 0, 0))) {
    sts = CoXHelp::dhelp(key, bookmark_str, navh_eHelpFile_Base, 0, strict);
    if (EVEN(sts))
      xnav->message('E', "No help on this subject");
    else if (!streq(return_str, ""))
      xnav->set_push_command(return_str);
  } else {
    sts = CoXHelp::dhelp(key, bookmark_str, navh_eHelpFile_Project, 0, strict);
    if (EVEN(sts)) {
      sts = CoXHelp::dhelp(key, bookmark_str, navh_eHelpFile_Base, 0, strict);
      if (EVEN(sts))
        xnav->message('E', "No help on this subject");
    }
    // if ( ODD(sts) && !streq( return_str, ""))
    //  xnav->xhelp->set_push_command( return_str);
  }

  return 1;
}

static int xnav_define_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;
  int sts;
  char arg1_str[200];
  char arg2_str[200];
  char arg3_str[80];
  char arg4_str[80];
  char* arg3_ptr;
  char* arg4_ptr;

  if (EVEN(dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str)))) {
    xnav->message('E', "Syntax error");
    return 1;
  }
  if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
    xnav->message('E', "Syntax error");
    return 1;
  }
  if (EVEN(dcli_get_qualifier("dcli_arg3", arg3_str, sizeof(arg3_str))))
    arg3_ptr = 0;
  else
    arg3_ptr = arg3_str;
  if (EVEN(dcli_get_qualifier("dcli_arg4", arg4_str, sizeof(arg4_str))))
    arg4_ptr = 0;
  else
    arg4_ptr = arg4_str;
  sts = dcli_define_symbol(arg1_str, arg2_str, arg3_ptr, arg4_ptr);
  if (ODD(sts))
    xnav->message('I', "Symbol defined");
  return sts;
}

static void xnav_login_success_bc(void* ctx)
{
  XNav* xnav = (XNav*)ctx;
  char msg[120];

  CoLogin::get_login_info(0, 0, xnav->user, (unsigned long*)&xnav->priv, 0);
  sprintf(msg, "User %s logged in", xnav->user);
  XttLog::dlog(xttlog_eCategory_User, msg, 0, 0);
  xnav->cologin = 0;
  xnav->message('I', msg);
  if (xnav->op)
    xnav->op->set_title(xnav->user);
}

static void xnav_login_cancel_bc(void* xnav)
{
  ((XNav*)xnav)->cologin = 0;
}

static int xnav_login_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;
  int sts;
  char arg1_str[80];
  char arg2_str[80];
  char systemgroup[80];
  unsigned int priv;
  char msg[120];
  void* basewidget = 0;

  sts = gdh_GetObjectInfo(
      "pwrNode-System.SystemGroup", &systemgroup, sizeof(systemgroup));
  if (EVEN(sts))
    return sts;

  if (EVEN(dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str)))) {
    if (xnav->cologin)
      xnav->cologin->pop();
    else {
      if (xnav->opplace_p->Options & pwr_mOpPlaceOptionsMask_AllMainTransient) {
        if (xnav->ge_main)
          basewidget = xnav->ge_main->get_widget();
        else if (xnav->multiview_main)
          basewidget = xnav->multiview_main->get_widget();
      }

      xnav->cologin = xnav->login_new("PwR Login", systemgroup,
          xnav_login_success_bc, xnav_login_cancel_bc, basewidget, &sts);
    }
    return 1;
  }
  if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
    xnav->message('E', "Syntax error");
    return 1;
  }

  str_ToLower(arg1_str, arg1_str);
  str_ToLower(arg2_str, arg2_str);
  sts = user_CheckUser(
      systemgroup, arg1_str, UserList::pwcrypt(arg2_str), &priv);
  if (EVEN(sts))
    xnav->message('E', "Login failure");
  else {
    strcpy(xnav->user, arg1_str);
    xnav->priv = priv;
    sprintf(msg, "User %s logged in", arg1_str);
    XttLog::dlog(xttlog_eCategory_User, msg, 0, 0);
    xnav->message('I', msg);
    if (xnav->op)
      xnav->op->set_title(xnav->user);
  }
  return sts;
}

static int xnav_logout_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;
  char msg[200];

  int window = ODD(dcli_get_qualifier("/MESSAGEWINDOW", 0, 0));

  if (streq(xnav->base_user, "")) {
    sprintf(msg, "User %s logged out", xnav->user);
    XttLog::dlog(xttlog_eCategory_User, msg, 0, 0);
    xnav->message('I', msg);
    if (window)
      xnav->wow->DisplayText("Logout", msg);
  } else {
    sprintf(msg, "User %s logged out, returned to user %s", xnav->user,
        xnav->base_user);
    XttLog::dlog(xttlog_eCategory_User, msg, 0, 0);
    sprintf(msg, "Returned to user %s", xnav->base_user);
    xnav->message('I', msg);
    if (window)
      xnav->wow->DisplayText("User Return", msg);
  }
  strcpy(xnav->user, xnav->base_user);
  xnav->priv = xnav->base_priv;
  if (xnav->op)
    xnav->op->set_title(xnav->user);
  return 1;
}

static int xnav_set_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;
  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "JOP_QUEID", strlen(arg1_str)) == 0) {
    // Command is "SET JOP_QUEID"
    char arg2_str[80];
    int nr;
    int qid;

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      xnav->message('E', "Syntax error");
      return 1;
    }

    // Convert to qid
    nr = sscanf(arg2_str, "%d", &qid);
    if (nr != 1) {
      xnav->message('E', "Syntax error");
      return XNAV__HOLDCOMMAND;
    }
    xnav->op->set_jop_qid(qid);
  } else if (str_NoCaseStrncmp(arg1_str, "ADVANCEDUSER", strlen(arg1_str))
      == 0) {
    xnav->gbl.advanced_user = 1;
    xnav->message('I', "Advanced user");
  } else if (str_NoCaseStrncmp(arg1_str, "NOADVANCEDUSER", strlen(arg1_str))
      == 0) {
    xnav->gbl.advanced_user = 0;
  } else if (str_NoCaseStrncmp(arg1_str, "SHOWTRUEDB", strlen(arg1_str)) == 0) {
    xnav->gbl.show_truedb = 1;
  } else if (str_NoCaseStrncmp(arg1_str, "NOSHOWTRUEDB", strlen(arg1_str))
      == 0) {
    xnav->gbl.show_truedb = 0;
  } else if (str_NoCaseStrncmp(arg1_str, "SHOWALLATTR", strlen(arg1_str))
      == 0) {
    xnav->gbl.show_allattr = 1;
  } else if (str_NoCaseStrncmp(arg1_str, "NOSHOWALLATTR", strlen(arg1_str))
      == 0) {
    xnav->gbl.show_allattr = 0;
  } else if (str_NoCaseStrncmp(arg1_str, "PARAMETER", strlen(arg1_str)) == 0) {
    // Command is "SET PARAMETER"
    pwr_tAName name_str;
    char value_str[400];
    int sts;
    int bypass;
    int publicwrite;

    bypass = ODD(dcli_get_qualifier("/BYPASS", 0, 0));
    if (bypass) {
      xnav->message('E', "Bypass is obsolete");
      return XNAV__HOLDCOMMAND;
    }

    publicwrite = ODD(dcli_get_qualifier("/PUBLICWRITE", 0, 0));

    if (EVEN(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
      xnav->message('E', "Enter name of parameter");
      return XNAV__HOLDCOMMAND;
    }
    if (EVEN(dcli_get_qualifier("/VALUE", value_str, sizeof(value_str)))) {
      xnav->message('E', "Enter value");
      return XNAV__HOLDCOMMAND;
    }
    sts = xnav->set_parameter(name_str, value_str, publicwrite);
    if (sts == XNAV__NOTAUTHORIZED)
      xnav->message('E', "Not authorized for this operation");
    else if (EVEN(sts)) {
      xnav->message('E', "Unable to set parameter");
      return XNAV__HOLDCOMMAND;
    } else
      return sts;
  } else if (str_NoCaseStrncmp(arg1_str, "FOLDER", strlen(arg1_str)) == 0) {
    // Command is "SET FOLDER"
    XttGe* gectx;
    char graph_str[80];
    char object_str[80];
    char idx_str[20];
    int nr;
    int idx;

    if (EVEN(dcli_get_qualifier("dcli_arg2", graph_str, sizeof(graph_str)))) {
      xnav->message('E', "Graph name is missing");
      return XNAV__HOLDCOMMAND;
    }

    if (EVEN(dcli_get_qualifier("/NAME", object_str, sizeof(object_str)))) {
      xnav->message('E', "Object name is missing");
      return XNAV__HOLDCOMMAND;
    }
    if (EVEN(dcli_get_qualifier("/INDEX", idx_str, sizeof(idx_str)))) {
      xnav->message('E', "Syntax error");
      return XNAV__HOLDCOMMAND;
    }
    nr = sscanf(idx_str, "%d", &idx);
    if (nr != 1) {
      xnav->message('E', "Syntax error");
      return XNAV__HOLDCOMMAND;
    }

    if (!xnav->appl.find(applist_eType_Graph, graph_str, 0, (void**)&gectx)) {
      xnav->message('E', "Graph is not open");
      return XNAV__HOLDCOMMAND;
    }
    gectx->set_folder_index(object_str, idx);
  } else if (str_NoCaseStrncmp(arg1_str, "SUBWINDOW", strlen(arg1_str)) == 0) {
    // Command is "SET SUBWINDOW"
    XttGe* gectx;
    XttMultiView* mvctx;
    pwr_tOName graph_str;
    char name_str[80];
    char object_str[800];
    char* object_p;
    pwr_tOName source_str;
    int cont;
    int inputempty;
    char focus_str[200];
    char* focus_p;
    int sts;
    char focus[200];

    if (EVEN(dcli_get_qualifier("dcli_arg2", graph_str, sizeof(graph_str)))) {
      xnav->message('E', "Graph name is missing");
      return XNAV__HOLDCOMMAND;
    }

    if (EVEN(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
      xnav->message('E', "Object name is missing");
      return XNAV__HOLDCOMMAND;
    }

    if (EVEN(dcli_get_qualifier("/SOURCE", source_str, sizeof(source_str))))
      strcpy(source_str, "");

    if (ODD(dcli_get_qualifier("/OBJECT", object_str, sizeof(object_str))))
      object_p = object_str;
    else
      object_p = 0;

    inputempty = ODD(dcli_get_qualifier("/INPUTEMPTY", 0, 0));

    if (ODD(dcli_get_qualifier("/FOCUS", focus_str, sizeof(focus_str))))
      focus_p = focus_str;
    else
      focus_p = 0;

    if (object_p)
      xnav_replace_node_str(object_p, object_p);

    cont = ODD(dcli_get_qualifier("/CONTINUE", 0, 0));

    if (str_NoCaseStrcmp(graph_str, "$current") == 0 && xnav->current_cmd_ctx) {
      gectx = (XttGe*)xnav->current_cmd_ctx;
      sts = gectx->set_subwindow_source(name_str, source_str, object_p);

      if (focus_p) {
        sprintf(focus, "%s.%s", name_str, focus_p);
        gectx->set_object_focus(focus, inputempty);
      }
      if (cont && sts == GLOW__SUBTERMINATED)
        return XNAV__SUCCESS;
      return sts;
    } else if (xnav->appl.find_graph(graph_str, 0, (void**)&gectx)) {
      if (streq(source_str, "")) {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
      sts = gectx->set_subwindow_source(name_str, source_str, object_p);

      if (focus_p) {
        sprintf(focus, "%s.%s", name_str, focus_p);
        gectx->set_object_focus(focus, inputempty);
      }
      return sts;
    } else {
      pwr_tStatus sts;
      pwr_tAttrRef aref;
      char tmp_str[80];
      int nr;
      double borders[4] = { 0, 0, 0, 0 };
      double* bordersp = borders;

      xnav_replace_node_str(graph_str, graph_str);

      if (ODD(dcli_get_qualifier("/X0", tmp_str, sizeof(tmp_str)))) {
        nr = sscanf(tmp_str, "%lf", &borders[0]);
        if (nr != 1) {
          xnav->message('E', "Syntax error in x0");
          return XNAV__HOLDCOMMAND;
        }
      } else
        borders[0] = 0;

      if (ODD(dcli_get_qualifier("/Y0", tmp_str, sizeof(tmp_str)))) {
        nr = sscanf(tmp_str, "%lf", &borders[1]);
        if (nr != 1) {
          xnav->message('E', "Syntax error in y0");
          return XNAV__HOLDCOMMAND;
        }
      } else
        borders[1] = 0;

      if (ODD(dcli_get_qualifier("/X1", tmp_str, sizeof(tmp_str)))) {
        nr = sscanf(tmp_str, "%lf", &borders[2]);
        if (nr != 1) {
          xnav->message('E', "Syntax error in x1");
          return XNAV__HOLDCOMMAND;
        }
      } else
        borders[2] = 0;

      if (ODD(dcli_get_qualifier("/Y1", tmp_str, sizeof(tmp_str)))) {
        nr = sscanf(tmp_str, "%lf", &borders[3]);
        if (nr != 1) {
          xnav->message('E', "Syntax error in y1");
          return XNAV__HOLDCOMMAND;
        }
      } else
        borders[3] = 0;

      if (feq(borders[0], 0.0) && feq(borders[1], 0.0) && feq(borders[2], 0.0)
          && feq(borders[3], 0.0))
        bordersp = 0;

      sts = gdh_NameToAttrref(pwr_cNObjid, graph_str, &aref);
      if (ODD(sts)
          && xnav->appl.find(applist_eType_MultiView, &aref, (void**)&mvctx)) {
        return mvctx->set_subwindow_source(
            name_str, source_str, object_p, bordersp, cont);
      } else {
        xnav->message('E', "Graph is not open");
        return XNAV__HOLDCOMMAND;
      }
    }
  } else if (str_NoCaseStrncmp(arg1_str, "NEXTSUBWINDOW", strlen(arg1_str))
      == 0) {
    // Command is "SET NEXTSUBWINDOW"
    XttGe* gectx;
    XttMultiView* mvctx;
    pwr_tOName graph_str;
    char name_str[80];

    if (EVEN(dcli_get_qualifier("dcli_arg2", graph_str, sizeof(graph_str)))) {
      xnav->message('E', "Graph name is missing");
      return XNAV__HOLDCOMMAND;
    }

    if (EVEN(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
      xnav->message('E', "Object name is missing");
      return XNAV__HOLDCOMMAND;
    }

    if (xnav->appl.find_graph(graph_str, 0, (void**)&gectx)) {
      // todo
    } else {
      pwr_tStatus sts;
      pwr_tAttrRef aref;

      xnav_replace_node_str(graph_str, graph_str);

      sts = gdh_NameToAttrref(pwr_cNObjid, graph_str, &aref);
      if (ODD(sts)
          && xnav->appl.find(applist_eType_MultiView, &aref, (void**)&mvctx)) {
        return mvctx->set_subwindow_next(name_str);
      } else {
        xnav->message('E', "Graph is not open");
        return XNAV__HOLDCOMMAND;
      }
    }
  } else if (str_NoCaseStrncmp(arg1_str, "PREVSUBWINDOW", strlen(arg1_str))
      == 0) {
    // Command is "SET PREVSUBWINDOW"
    XttGe* gectx;
    XttMultiView* mvctx;
    pwr_tOName graph_str;
    char name_str[80];

    if (EVEN(dcli_get_qualifier("dcli_arg2", graph_str, sizeof(graph_str)))) {
      xnav->message('E', "Graph name is missing");
      return XNAV__HOLDCOMMAND;
    }

    if (EVEN(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
      xnav->message('E', "Object name is missing");
      return XNAV__HOLDCOMMAND;
    }

    if (xnav->appl.find_graph(graph_str, 0, (void**)&gectx)) {
      // todo
    } else {
      pwr_tStatus sts;
      pwr_tAttrRef aref;

      xnav_replace_node_str(graph_str, graph_str);

      sts = gdh_NameToAttrref(pwr_cNObjid, graph_str, &aref);
      if (ODD(sts)
          && xnav->appl.find(applist_eType_MultiView, &aref, (void**)&mvctx)) {
        return mvctx->set_subwindow_prev(name_str);
      } else {
        xnav->message('E', "Graph is not open");
        return XNAV__HOLDCOMMAND;
      }
    }
  } else if (str_NoCaseStrncmp(arg1_str, "LANGUAGE", strlen(arg1_str)) == 0) {
    char language_str[80];
    ApplListElem* elem;
    pwr_tStatus sts;

    // Command is "SET LANGUAGE"
    if (EVEN(dcli_get_qualifier(
            "dcli_arg2", language_str, sizeof(language_str)))) {
      xnav->message('E', "Enter language");
      return XNAV__HOLDCOMMAND;
    }
    str_ToLower(language_str, language_str);
    sts = Lng::set(language_str);
    if (EVEN(sts)) {
      xnav->message(' ', XNav::get_message(sts));
      return XNAV__SUCCESS;
    }

    // Set new coding to all graphs
    for (elem = xnav->appl.root; elem; elem = elem->next) {
      if (elem->type == applist_eType_Graph)
        ((XttGe*)elem->ctx)->set_text_coding(Lng::translatefile_coding());
    }
  } else if (str_NoCaseStrncmp(arg1_str, "NORATIO", strlen(arg1_str)) == 0) {
    // Command is "SET NORATIO"
    xnav->gbl.no_graph_ratio = 1;
  } else if (str_NoCaseStrcmp(arg1_str, "crashtest") == 0) {
    // Command is "SET CRASHTEST"
    char* p = 0;
    char c;
    c = *p;
  } else if (str_NoCaseStrncmp(arg1_str, "DISPLAY", strlen(arg1_str)) == 0) {
    // Command is "SET DISPLAY"
    xnav_eConv conv;
    char arg2_str[80];

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      xnav->message('E', "Syntax error");
      return 1;
    }

    if (str_NoCaseStrncmp(arg2_str, "HEXADECIMAL", strlen(arg2_str)) == 0)
      conv = xnav_eConv_Hex;
    else if (str_NoCaseStrncmp(arg2_str, "DECIMAL", strlen(arg2_str)) == 0)
      conv = xnav_eConv_Decimal;
    else if (str_NoCaseStrncmp(arg2_str, "OCTAL", strlen(arg2_str)) == 0)
      conv = xnav_eConv_Octal;
    else if (str_NoCaseStrncmp(arg2_str, "BINARY", strlen(arg2_str)) == 0)
      conv = xnav_eConv_Binary;
    else if (str_NoCaseStrncmp(arg2_str, "FLOAT", strlen(arg2_str)) == 0)
      conv = xnav_eConv_Float;
    else if (str_NoCaseStrncmp(arg2_str, "INTEGER", strlen(arg2_str)) == 0)
      conv = xnav_eConv_Integer;
    else if (str_NoCaseStrncmp(arg2_str, "IDENTITY", strlen(arg2_str)) == 0)
      conv = xnav_eConv_Identity;
    else if (str_NoCaseStrncmp(arg2_str, "DEFAULT", strlen(arg2_str)) == 0)
      conv = xnav_eConv_No;
    else {
      xnav->message('E', "Syntax error");
      return 1;
    }

    xnav->set_select_conversion(conv);
  } else if (str_NoCaseStrncmp(arg1_str, "ALARMVIEW", strlen(arg1_str)) == 0) {
    // Command is "SET ALARMVIEW"
    pwr_tOName name_str;
    pwr_tObjid objid;
    pwr_tStatus sts;

    if (!xnav->ev) {
      xnav->message('E', "Alarmlist is not loaded");
      return XNAV__SUCCESS;
    }

    if (EVEN(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (EVEN(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
        xnav->message('E', "Object name is missing");
        return XNAV__HOLDCOMMAND;
      }
    }

    if (str_NoCaseStrcmp(name_str, "none") == 0) {
      sts = xnav->ev->set_view(pwr_cNOid);
      return XNAV__SUCCESS;
    }

    sts = gdh_NameToObjid(name_str, &objid);
    if (EVEN(sts)) {
      xnav->message('E', "Object not found");
      return XNAV__SUCCESS;
    }

    sts = xnav->ev->set_view(objid);
    if (EVEN(sts))
      return sts;
    return XNAV__SUCCESS;
  } else if (str_NoCaseStrncmp(arg1_str, "COLORTHEME", strlen(arg1_str)) == 0) {
    // Command is "SET COLORTHEME"
    char idx_str[20];
    int idx;
    int num;
    ApplListElem* elem;

    if (EVEN(dcli_get_qualifier("/INDEX", idx_str, sizeof(idx_str)))) {
      xnav->message('E', "Type syntax error");
      return XNAV__HOLDCOMMAND;
    }

    num = sscanf(idx_str, "%d", &idx);
    if (num != 1) {
      xnav->message('E', "Type syntax error");
      return XNAV__HOLDCOMMAND;
    }

    if (xnav->gbl.color_theme != idx) {
      xnav->gbl.color_theme = idx;

      for (elem = xnav->appl.root; elem; elem = elem->next) {
        if (elem->type == applist_eType_Graph)
          ((XttGe*)elem->ctx)->update_color_theme(idx);
        else if (elem->type == applist_eType_SevHist)
          ((XttSevHist*)elem->ctx)->update_color_theme(idx);
        else if (elem->type == applist_eType_Trend)
          ((XttTrend*)elem->ctx)->update_color_theme(idx);
        else if (elem->type == applist_eType_Fast)
          ((XttFast*)elem->ctx)->update_color_theme(idx);
      }
      if (xnav->keyboard)
        xnav->keyboard->update_color_theme(idx);
    }
    if (xnav->op)
      xnav->op->set_color_theme(idx);
  } else if (str_NoCaseStrncmp(arg1_str, "GRAPH", strlen(arg1_str)) == 0) {
    // Command is "SET GRAPH"
    pwr_tAName instance_str;
    char* instance_p = 0;
    char name_str[200];
    char iconify_str[20];
    char below_str[20];
    XttGe* gectx;

    if (ODD(dcli_get_qualifier(
            "/INSTANCE", instance_str, sizeof(instance_str))))
      instance_p = instance_str;

    if (EVEN(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      xnav->message('E', "Syntax error");
      return XNAV__SUCCESS;
    }
    if (!xnav->appl.find(
            applist_eType_Graph, name_str, instance_p, (void**)&gectx)) {
      xnav->message('E', "Graph not found");
      return XNAV__SUCCESS;
    }

    if (ODD(dcli_get_qualifier("/ESCAPESTORE", 0, 0))) {
      gectx->set_object_focus(0, 0);
    } else if (ODD(dcli_get_qualifier(
                   "/ICONIFY", iconify_str, sizeof(iconify_str)))) {
      int iconify;
      if (streq(iconify_str, "1"))
        iconify = 1;
      else if (streq(iconify_str, "0"))
        iconify = 0;
      else {
        xnav->message('E', "Syntax error");
        return XNAV__SUCCESS;
      }

      gectx->iconify(iconify);
    } else if (ODD(dcli_get_qualifier(
                   "/BELOW", below_str, sizeof(below_str)))) {
      int below;
      if (streq(below_str, "1"))
        below = 1;
      else if (streq(below_str, "0"))
        below = 0;
      else {
        xnav->message('E', "Syntax error");
        return XNAV__SUCCESS;
      }

      gectx->set_below(below);
    } else {
      xnav->message('E', "Syntax error");
      return XNAV__SUCCESS;
    }
  } else if (str_NoCaseStrncmp(arg1_str, "SIGNAL", strlen(arg1_str)) == 0) {
    char arg2_str[80];

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      xnav->message('E', "Syntax error");
      return XNAV__SUCCESS;
    }

    if (str_NoCaseStrncmp(arg2_str, "INVERT", strlen(arg2_str)) == 0) {
      // Check authorization
      if (!(xnav->priv & pwr_mPrv_System)) {
        xnav->message('E', "Not authorized for this operation");
        return XNAV__SUCCESS;
      }

      pwr_tAName name_str;
      pwr_tAttrRef aref;
      pwr_tStatus sts;
      int is_attr;
      int selected = 0;
      int on = ODD(dcli_get_qualifier("/ON", 0, 0));
      int off = ODD(dcli_get_qualifier("/OFF", 0, 0));

      if ((on && off) || (!on && !off)) {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }

      if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
        sts = gdh_NameToAttrref(pwr_cNObjid, name_str, &aref);
        if (EVEN(sts)) {
          xnav->message('E', "No such object");
          return XNAV__SUCCESS;
        }
      } else {
        /* Get the selected object */
        sts = xnav->get_select(&aref, &is_attr);
        if (EVEN(sts)) {
          xnav->message('E', "Enter name or select an object");
          return XNAV__SUCCESS;
        }
        selected = 1;
      }

      sts = xnav->set_signal(&aref, xnav_eSetSignal_Invert, on);
      if (EVEN(sts)) {
        xnav->message(' ', XNav::get_message(sts));
        return XNAV__SUCCESS;
      }

      if (selected)
        xnav->refresh();
    } else if (str_NoCaseStrncmp(arg2_str, "CONVERSION", strlen(arg2_str))
        == 0) {
      // Check authorization
      if (!(xnav->priv & pwr_mPrv_System)) {
        xnav->message('E', "Not authorized for this operation");
        return XNAV__SUCCESS;
      }

      pwr_tAName name_str;
      pwr_tAttrRef aref;
      pwr_tStatus sts;
      int is_attr;
      int selected = 0;
      int on = ODD(dcli_get_qualifier("/ON", 0, 0));
      int off = ODD(dcli_get_qualifier("/OFF", 0, 0));

      if ((on && off) || (!on && !off)) {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }

      if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
        sts = gdh_NameToAttrref(pwr_cNObjid, name_str, &aref);
        if (EVEN(sts)) {
          xnav->message('E', "No such object");
          return XNAV__SUCCESS;
        }
      } else {
        /* Get the selected object */
        sts = xnav->get_select(&aref, &is_attr);
        if (EVEN(sts)) {
          xnav->message('E', "Enter name or select an object");
          return XNAV__SUCCESS;
        }
        selected = 1;
      }

      sts = xnav->set_signal(&aref, xnav_eSetSignal_Conversion, on);
      if (EVEN(sts)) {
        xnav->message(' ', XNav::get_message(sts));
        return XNAV__SUCCESS;
      }
      if (selected)
        xnav->refresh();
    } else if (str_NoCaseStrncmp(arg2_str, "TEST", strlen(arg2_str)) == 0) {
      // Check authorization
      if (!(xnav->priv & pwr_mPrv_System)) {
        xnav->message('E', "Not authorized for this operation");
        return XNAV__SUCCESS;
      }

      pwr_tAName name_str;
      pwr_tAttrRef aref;
      pwr_tStatus sts;
      int is_attr;
      int selected = 0;
      int on = ODD(dcli_get_qualifier("/ON", 0, 0));
      int off = ODD(dcli_get_qualifier("/OFF", 0, 0));

      if ((on && off) || (!on && !off)) {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }

      if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
        sts = gdh_NameToAttrref(pwr_cNObjid, name_str, &aref);
        if (EVEN(sts)) {
          xnav->message('E', "No such object");
          return XNAV__SUCCESS;
        }
      } else {
        /* Get the selected object */
        sts = xnav->get_select(&aref, &is_attr);
        if (EVEN(sts)) {
          xnav->message('E', "Enter name or select an object");
          return XNAV__SUCCESS;
        }
        selected = 1;
      }

      sts = xnav->set_signal(&aref, xnav_eSetSignal_Test, on);
      if (EVEN(sts)) {
        xnav->message(' ', XNav::get_message(sts));
        return XNAV__SUCCESS;
      }
      if (selected)
        xnav->refresh();
    } else if (str_NoCaseStrncmp(arg2_str, "TESTVALUE", strlen(arg2_str))
        == 0) {
      // Check authorization
      if (!(xnav->priv & pwr_mPrv_System)) {
        xnav->message('E', "Not authorized for this operation");
        return XNAV__SUCCESS;
      }

      pwr_tAName name_str;
      pwr_tAttrRef aref;
      pwr_tStatus sts;
      int is_attr;
      int selected = 0;
      int on = ODD(dcli_get_qualifier("/ON", 0, 0));
      int off = ODD(dcli_get_qualifier("/OFF", 0, 0));

      if ((on && off) || (!on && !off)) {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }

      if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
        sts = gdh_NameToAttrref(pwr_cNObjid, name_str, &aref);
        if (EVEN(sts)) {
          xnav->message('E', "No such object");
          return XNAV__SUCCESS;
        }
      } else {
        /* Get the selected object */
        sts = xnav->get_select(&aref, &is_attr);
        if (EVEN(sts)) {
          xnav->message('E', "Enter name or select an object");
          return XNAV__SUCCESS;
        }
        selected = 1;
      }

      sts = xnav->set_signal(&aref, xnav_eSetSignal_TestValue, on);
      if (EVEN(sts)) {
        xnav->message(' ', XNav::get_message(sts));
        return XNAV__SUCCESS;
      }
      if (selected)
        xnav->refresh();
    } else
      xnav->message('E', "Syntax error");
  } else
    xnav->message('E', "Syntax error");
  return 1;
}

static int xnav_show_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;

  int sts;
  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "VERSION", strlen(arg1_str)) == 0) {
    // Command is "SHOW VERSION"
    char message_str[100];

    strcpy(message_str, "Xtt version ");
    strcat(message_str, xtt_version);
    xnav->message('I', message_str);
    return 1;
  } else if (str_NoCaseStrncmp(arg1_str, "LICENSE", strlen(arg1_str)) == 0) {
    // Command is "SHOW LICENSE"
    xnav->wow->DisplayLicense();
    return 1;
  } else if (str_NoCaseStrncmp(arg1_str, "SYMBOL", strlen(arg1_str)) == 0) {
    /* Command is "SHOW SYMBOL" */
    char arg2_str[80];
    char message_str[400];
    char value[DCLI_SYM_VALUE_SIZE];

    if (ODD(dcli_get_qualifier("/ALL", 0, 0))) {
      sts = xnav->show_symbols();
      return sts;
    } else {
      if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
        sts = xnav->show_symbols();
        return sts;
      }
      sts = dcli_get_symbol(arg2_str, value);
      if (EVEN(sts)) {
        xnav->message('E', "Symbol not found");
        return 1;
      }
      sprintf(message_str, "Symbol %s = %s", arg2_str, value);
      xnav->message('I', message_str);
      return 1;
    }
  } else if (str_NoCaseStrncmp(arg1_str, "PLCPGM", strlen(arg1_str)) == 0) {
    /* Command is "SHOW PLCPGM" */
    xnav->show_plcpgm();
    return 1;
  } else if (str_NoCaseStrncmp(arg1_str, "PLCTHREADS", strlen(arg1_str)) == 0) {
    /* Command is "SHOW PLCTHREAD" */
    xnav->show_plcthreads();
    return 1;
  } else if (str_NoCaseStrncmp(arg1_str, "NODES", strlen(arg1_str)) == 0) {
    /* Command is "SHOW NODES" */
    xnav->show_nethandler();
    return 1;
  } else if (str_NoCaseStrncmp(arg1_str, "LINKS", strlen(arg1_str)) == 0) {
    /* Command is "SHOW LINKS" */
    xnav->show_nethandler();
    return 1;
  } else if (str_NoCaseStrncmp(arg1_str, "SUBSRV", strlen(arg1_str)) == 0) {
    /* Command is "SHOW SUBSRV" */
    xnav->show_subsrv();
    return 1;
  } else if (str_NoCaseStrncmp(arg1_str, "SUBCLI", strlen(arg1_str)) == 0) {
    /* Command is "SHOW SUBCLI" */
    xnav->show_subcli();
    return 1;
  } else if (str_NoCaseStrncmp(arg1_str, "DEVICE", strlen(arg1_str)) == 0) {
    /* Command is "SHOW DEVICE" */
    xnav->show_device();
    return 1;
  } else if (str_NoCaseStrncmp(arg1_str, "REMNODE", strlen(arg1_str)) == 0) {
    /* Command is "SHOW REMNODE" */
    xnav->show_remnode();
    return 1;
  } else if (str_NoCaseStrncmp(arg1_str, "REMTRANS", strlen(arg1_str)) == 0) {
    /* Command is "SHOW REMTRANS" */
    xnav->show_remtrans(pwr_cNObjid);
    return 1;
  } else if (str_NoCaseStrncmp(arg1_str, "DATABASE", strlen(arg1_str)) == 0) {
    /* Command is "SHOW DATABASE" */
    xnav->show_database();
    return 1;
  } else if (str_NoCaseStrncmp(arg1_str, "LOGGING", strlen(arg1_str)) == 0) {
    /* Command is "SHOW LOGGING" */
    char entry_str[80];
    int entry;
    int nr;

    if (ODD(dcli_get_qualifier("/ENTRY", entry_str, sizeof(entry_str)))) {
      /* convert to integer */
      nr = sscanf(entry_str, "%d", &entry);
      if (nr != 1) {
        xnav->message('E', "Entry syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      // entry 1 is default
      entry = 1;
    }
    if (entry > XNAV_LOGG_MAX || entry < 1) {
      xnav->message('E', "Entry out of range");
      return XNAV__HOLDCOMMAND;
    }

    xnav->show_logging(entry - 1);
  } else if (str_NoCaseStrncmp(arg1_str, "FILE", strlen(arg1_str)) == 0) {
    /* Command is "SHOW FILE" */
    char arg2_str[80];
    char title[80];
    char filename[80];
    char option_str[80];
    int hide_dir = 0;

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      hide_dir = 1;
      dcli_get_defaultfilename("*", filename, ".rtt_com");
      strcpy(title, "Stored pictures and scripts");
    } else {
      dcli_get_defaultfilename(arg2_str, filename, ".rtt_com");
      strcpy(title, "File list");
    }
    if (ODD(dcli_get_qualifier("/OPTION", option_str, sizeof(option_str)))) {
      if (str_NoCaseStrcmp(option_str, "HIDE_DIR") == 0)
        hide_dir = 1;
    }
    sts = xnav->show_file(filename, title, hide_dir);
    if (EVEN(sts)) {
      xnav->message('E', "No files found");
      return XNAV__SUCCESS;
    }
    return sts;
  } else if (str_NoCaseStrncmp(arg1_str, "GRAPH", strlen(arg1_str)) == 0) {
    /* Command is "SHOW GRAPH" */
    char arg2_str[80];
    char title[80];
    char filename[80];
    char option_str[80];
    int hide_dir = 0;

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      hide_dir = 1;
      dcli_get_defaultfilename("pwrp_exe:*", filename, ".pwg");
      strcpy(title, "Graphs");
    } else {
      dcli_get_defaultfilename(arg2_str, filename, ".pwg");
      strcpy(title, "Graph list");
    }
    if (ODD(dcli_get_qualifier("/OPTION", option_str, sizeof(option_str)))) {
      if (str_NoCaseStrcmp(option_str, "HIDE_DIR") == 0)
        hide_dir = 1;
    }
    sts = xnav->show_file(filename, title, hide_dir);
    if (EVEN(sts)) {
      xnav->message('E', "No files found");
      return XNAV__SUCCESS;
    }
    return sts;
  } else if (str_NoCaseStrncmp(arg1_str, "LOGFILES", strlen(arg1_str)) == 0) {
    /* Command is "SHOW LOGFILES" */
    char arg2_str[80];
    char title[80];
    char filename[80];
    char option_str[80];
    int hide_dir = 0;

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      hide_dir = 1;
      dcli_get_defaultfilename("*", filename, ".rtt_log");
      strcpy(title, "RttLogFiles");
    } else {
      dcli_get_defaultfilename(arg2_str, filename, ".rtt_log");
      strcpy(title, "RttLogFiles");
    }
    if (ODD(dcli_get_qualifier("/OPTION", option_str, sizeof(option_str)))) {
      if (str_NoCaseStrcmp(option_str, "HIDE_DIR") == 0)
        hide_dir = 1;
    }
    sts = xnav->show_file(filename, title, hide_dir);
    if (EVEN(sts)) {
      xnav->message('E', "No files found");
      return XNAV__SUCCESS;
    }
    return sts;
  } else if (str_NoCaseStrncmp(arg1_str, "TIME", strlen(arg1_str)) == 0) {
    /* Command is "SHOW TIME" */
    char message_str[100];

    xnav->update_time();
    sprintf(message_str, "Time is %s", xnav->gbl.time);
    xnav->message('I', message_str);
    return XNAV__SUCCESS;
  } else if (str_NoCaseStrncmp(arg1_str, "DEFAULT", strlen(arg1_str)) == 0) {
    /* Command is "SHOW DEFAULT" */
    char message_str[100];

    sprintf(message_str, "Default directory: %s", xnav->gbl.default_directory);
    xnav->message('I', message_str);
    return XNAV__SUCCESS;
  } else if (str_NoCaseStrncmp(arg1_str, "MENU", strlen(arg1_str)) == 0) {
    /* Command is "SHOW MENU" */
    char name_str[80];

    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (name_str[0] == '/') {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      if (EVEN(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
        xnav->message('E', "Syntax error, name not found");
        return XNAV__HOLDCOMMAND;
      }
    }
    //    sts = rtt_show_menu( ctx, name_str);
    sts = 0;
    return sts;
  } else if (str_NoCaseStrncmp(arg1_str, "HIERARCHY", strlen(arg1_str)) == 0) {
    /* Command is "SHOW HIERARCHY" */
    IF_NOGDH_RETURN;
    sts = dcli_cli(
        (dcli_tCmdTable*)&xnav_command_table, "SHOW DATABASE", (void*)xnav, 0);
    return sts;
  } else if (str_NoCaseStrncmp(arg1_str, "CHILDREN", strlen(arg1_str)) == 0) {
    // Command is "SHOW CHILDREN"
    pwr_tOName name_str;
    pwr_tObjid objid;
    int newlist;

    IF_NOGDH_RETURN;
    if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
      sts = gdh_NameToObjid(name_str, &objid);
      if (EVEN(sts)) {
        xnav->message('E', "Object not found");
        return XNAV__SUCCESS;
      }
      sts = gdh_ObjidToName(
          objid, name_str, sizeof(name_str), cdh_mName_volumeStrict);
      if (EVEN(sts))
        return sts;
    } else {
      /* Get the selected object */
      sts = xnav->get_current_object(
          &objid, name_str, sizeof(name_str), cdh_mName_volumeStrict);
      if (EVEN(sts)) {
        xnav->message('E', "Select an object or enter name");
        return XNAV__SUCCESS;
      }
    }
    newlist = ODD(dcli_get_qualifier("/NEW", 0, 0));

    try {
      if (!newlist)
        xnav->display_object(objid, 1);
      else {
        sts = gdh_ObjidToName(objid, name_str, sizeof(name_str), cdh_mNName);
        xnav->brow_pop();
        ItemObject* item
            = new ItemObject(xnav->brow, objid, NULL, flow_eDest_IntoLast, 1);
        new ItemHeader(
            xnav->brow, "Title", name_str, NULL, flow_eDest_IntoLast);
        item->open_children(xnav->brow, 0, 0);
        delete item;
      }
    } catch (co_error& e) {
      xnav->brow_push_all();
      brow_Redraw(xnav->brow->ctx, 0);
      xnav->message('E', (char*)e.what().c_str());
    }

    return XNAV__SUCCESS;
  } else if (str_NoCaseStrncmp(arg1_str, "OBJECT", strlen(arg1_str)) == 0) {
    /* Command is "SHOW OBJECT" */
    pwr_tObjName class_str;
    pwr_tOName name_str;
    pwr_tOName hierarchy_str;
    char objdid_str[80];
    char maxobjects_str[80];
    char type_str[80];
    pwr_tFileName file_str;
    int maxobjects;
    char* class_ptr;
    char* name_ptr;
    char* hierarchy_ptr;
    int global;
    char str[80];
    int nr;

    IF_NOGDH_RETURN;
    if (ODD(dcli_get_qualifier("/OBJID", objdid_str, sizeof(objdid_str)))) {
      pwr_tObjid objid;
      pwr_tClassId classid;

      /* Convert to objid */
      sts = cdh_StringToObjid(objdid_str, &objid);
      if (EVEN(sts)) {
        xnav->message('E', "Syntax error in objid");
        return XNAV__HOLDCOMMAND;
      }
      sts = gdh_GetObjectClass(objid, &classid);
      if (EVEN(sts)) {
        xnav->message('E', "Objid not found");
        return XNAV__HOLDCOMMAND;
      }
      /* Get the object name */
      sts = gdh_ObjidToName(
          objid, name_str, sizeof(name_str), cdh_mName_volumeStrict);

      if (EVEN(sts))
        return sts;

      name_ptr = name_str;
      //      sts = rtt_show_obj_hier_class_name( ctx, 0, 0,
      //  		name_ptr, 0, 0);
      sts = 0;
      return sts;
    } else if (ODD(dcli_get_qualifier("/TYPE", type_str, sizeof(type_str)))) {
      pwr_tObjid objid;
      char* msg;

      if (EVEN(dcli_get_qualifier("/FILE", file_str, sizeof(file_str)))) {
        xnav->message('E', "Enter filename");
        return XNAV__HOLDCOMMAND;
      }
      if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
        sts = gdh_NameToObjid(name_str, &objid);
        if (EVEN(sts)) {
          xnav->message('E', "Object not found");
          return XNAV__SUCCESS;
        }
        sts = gdh_ObjidToName(
            objid, name_str, sizeof(name_str), cdh_mName_volumeStrict);
        if (EVEN(sts))
          return sts;
      } else {
        /* Get the selected object */
        sts = xnav->get_current_object(
            &objid, name_str, sizeof(name_str), cdh_mName_volumeStrict);
        if (EVEN(sts)) {
          xnav->message('E', "Select an object or enter name");
          return XNAV__SUCCESS;
        }
      }
      sts = xnav->show_object_as_struct(objid, type_str, file_str);
      if (EVEN(sts) && dcli_readstruct_get_message(&msg))
        xnav->message('E', msg);

      return sts;
    }

    /* Get maxobjects qualifier */
    if (ODD(dcli_get_qualifier(
            "/MAXOBJECTS", maxobjects_str, sizeof(maxobjects_str)))) {
      /* Convert to objid */
      nr = sscanf(maxobjects_str, "%d", &maxobjects);
      if (nr != 1) {
        xnav->message('E', "Syntax error in maxobjects");
        return XNAV__HOLDCOMMAND;
      }
    } else
      /* Default value */
      maxobjects = 0;

    /* Get the name qualifier */
    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (name_str[0] != '/')
        /* Assume that this is the namestring */
        name_ptr = name_str;
      else {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str))))
        name_ptr = name_str;
      else
        name_ptr = NULL;
    }

    if (ODD(dcli_get_qualifier("/CLASS", class_str, sizeof(class_str))))
      class_ptr = class_str;
    else
      class_ptr = NULL;
    if (ODD(dcli_get_qualifier(
            "/HIERARCHY", hierarchy_str, sizeof(hierarchy_str))))
      hierarchy_ptr = hierarchy_str;
    else
      hierarchy_ptr = NULL;
    if (ODD(dcli_get_qualifier("/LOCAL", str, sizeof(str))))
      global = 0;
    else
      global = 1;

    //    sts = rtt_show_obj_hier_class_name( ctx, hierarchy_ptr, class_ptr,
    //			name_ptr, global, maxobjects);
    sts = 0;
    return sts;
  }

  else if (str_NoCaseStrncmp(arg1_str, "OBJID", strlen(arg1_str)) == 0) {
    /* Command is "SHOW OBJID" */
    pwr_tOName name_str;
    pwr_tObjid objid;
    char msg[220];

    IF_NOGDH_RETURN;
    if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
      sts = gdh_NameToObjid(name_str, &objid);
      if (EVEN(sts)) {
        xnav->message('E', "Object not found");
        return XNAV__SUCCESS;
      }
      sts = gdh_ObjidToName(
          objid, name_str, sizeof(name_str), cdh_mName_volumeStrict);
      if (EVEN(sts))
        return sts;
    } else {
      /* Get the selected object */
      sts = xnav->get_current_object(
          &objid, name_str, sizeof(name_str), cdh_mName_volumeStrict);
      if (EVEN(sts)) {
        xnav->message('E', "Select an object or enter name");
        return XNAV__SUCCESS;
      }
    }

    sprintf(msg, "Objid %s, Name %s", cdh_ObjidToString(objid, 0), name_str);
    xnav->message('I', msg);
    return XNAV__SUCCESS;
  }

  else if (str_NoCaseStrncmp(arg1_str, "SIGNALS", strlen(arg1_str)) == 0) {
    /* Command is "SHOW SIGNALS" */
    pwr_tFileName file_str;
    pwr_tOName name_str;
    char* file_ptr;
    char* name_ptr;
    pwr_tObjid objid;
    pwr_tObjid parentobjid;
    pwr_tClassId classid;
    char classname[80];

    IF_NOGDH_RETURN;
    if (ODD(dcli_get_qualifier("/FILE", file_str, sizeof(file_str))))
      file_ptr = file_str;
    else
      file_ptr = NULL;

    /* Get the name qualifier */
    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (name_str[0] != '/')
        /* Assume that this is the namestring */
        name_ptr = name_str;
      else {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str))))
      name_ptr = name_str;
    else {
      /* Get the selected object */
      sts = xnav->get_current_object(&objid, name_str, sizeof(name_str),
          cdh_mName_path | cdh_mName_object);
      if (EVEN(sts)) {
        xnav->message('E', "Enter name or select an object");
        return XNAV__HOLDCOMMAND;
      }
      name_ptr = name_str;

      sts = gdh_GetObjectClass(objid, &classid);
      if (EVEN(sts))
        return sts;
      sts = gdh_ObjidToName(cdh_ClassIdToObjid(classid), classname,
          sizeof(classname), cdh_mName_volumeStrict);
      if (EVEN(sts))
        return sts;
      /* Check that this is a or a plc */
      if (streq(classname, "pwrb:Class-PlcPgm")) {
        /* Get all the windows in the plc */
        strcat(name_str, "-W*");
      } else if (!((streq(classname, "pwrb:Class-WindowPlc"))
                     || (streq(classname, "pwrb:Class-WindowOrderact"))
                     || (streq(classname, "pwrb:Class-WindowCond"))
                     || (streq(classname, "pwrb:Class-WindowSubstep")))) {
        /* Try with the parent */
        sts = gdh_GetParent(objid, &parentobjid);
        if (EVEN(sts))
          return sts;
        sts = gdh_GetObjectClass(parentobjid, &classid);
        if (EVEN(sts))
          return sts;
        sts = gdh_ObjidToName(cdh_ClassIdToObjid(classid), classname,
            sizeof(classname), cdh_mName_volumeStrict);
        if (EVEN(sts))
          return sts;

        if (!((streq(classname, "pwrb:Class-WindowPlc"))
                || (streq(classname, "pwrb:Class-WindowOrderact"))
                || (streq(classname, "pwrb:Class-WindowCond"))
                || (streq(classname, "pwrb:Class-WindowSubstep")))) {
          xnav->message(
              'E', "Selected object has to be in a plcpgm or a plcpgm");
          return XNAV__HOLDCOMMAND;
        } else {
          sts = gdh_ObjidToName(
              parentobjid, name_str, sizeof(name_str), cdh_mName_volumeStrict);
          if (EVEN(sts))
            return sts;
        }
      }
    }
    //    sts = rtt_show_signals( ctx, file_ptr, name_ptr, 0);
    sts = 0;
    return sts;
  }

  else if (str_NoCaseStrncmp(arg1_str, "PARAMETER", strlen(arg1_str)) == 0) {
    /* Command is "SHOW PARAMETER" */
    pwr_tOName parameter_str;
    pwr_tObjName class_str;
    pwr_tOName name_str;
    pwr_tOName hierarchy_str;
    char* class_ptr;
    char* name_ptr;
    char* hierarchy_ptr;
    char* parameter_ptr;
    int global;
    char str[80];
    int nr;
    char maxobjects_str[80];
    int maxobjects;

    IF_NOGDH_RETURN;
    /* Get maxobjects qualifier */
    if (ODD(dcli_get_qualifier(
            "/MAXOBJECTS", maxobjects_str, sizeof(maxobjects_str)))) {
      /* Convert to objid */
      nr = sscanf(maxobjects_str, "%d", &maxobjects);
      if (nr != 1) {
        xnav->message('E', "Syntax error in maxobjects");
        return XNAV__HOLDCOMMAND;
      }
    } else
      /* Default value */
      maxobjects = 0;

    if (ODD(dcli_get_qualifier(
            "/PARAMETER", parameter_str, sizeof(parameter_str))))
      parameter_ptr = parameter_str;
    else
      parameter_ptr = NULL;

    /* Get the name qualifier */
    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (name_str[0] != '/')
        /* Assume that this is the namestring */
        name_ptr = name_str;
      else {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str))))
        name_ptr = name_str;
      else
        name_ptr = NULL;
    }
    if (ODD(dcli_get_qualifier("/CLASS", class_str, sizeof(class_str))))
      class_ptr = class_str;
    else
      class_ptr = NULL;
    if (ODD(dcli_get_qualifier(
            "/HIERARCHY", hierarchy_str, sizeof(hierarchy_str))))
      hierarchy_ptr = hierarchy_str;
    else
      hierarchy_ptr = NULL;
    if (ODD(dcli_get_qualifier("/LOCAL", str, sizeof(str))))
      global = 0;
    else
      global = 1;

    sts = xnav->show_par_hier_class_name(parameter_ptr, hierarchy_ptr,
        class_ptr, name_ptr, XNAV_MENU_CREATE, global, maxobjects);
    sts = 0;
    return sts;
  } else if (str_NoCaseStrncmp(arg1_str, "CONVERSION", strlen(arg1_str)) == 0) {
  } else if (str_NoCaseStrncmp(arg1_str, "INVERT", strlen(arg1_str)) == 0) {
  } else if (str_NoCaseStrncmp(arg1_str, "DOTEST", strlen(arg1_str)) == 0) {
  } else if (str_NoCaseStrncmp(arg1_str, "TESTVALUE", strlen(arg1_str)) == 0) {
  } else if (str_NoCaseStrncmp(arg1_str, "EVENTLIST", strlen(arg1_str)) == 0) {
    char arg2_str[80];
    int arg2_sts;
    unsigned int options = 0;
    void* basewidget = 0;

    if (ODD(dcli_get_qualifier("/FULLSCREEN", 0, 0)))
      options |= ev_mAlaOptions_FullScreen;
    if (ODD(dcli_get_qualifier("/MAXIMIZE", 0, 0)))
      options |= ev_mAlaOptions_Maximize;
    if (ODD(dcli_get_qualifier("/FULLMAXIMIZE", 0, 0)))
      options |= ev_mAlaOptions_FullMaximize;
    if (ODD(dcli_get_qualifier("/ICONIFY", 0, 0)))
      options |= ev_mAlaOptions_Iconify;

    if (!xnav->ev) {
      char alarm_title[40], event_title[40], block_title[40];

      strcpy(alarm_title, Lng::translate("Alarm List"));
      strcpy(event_title, Lng::translate("Event List"));
      strcpy(block_title, Lng::translate("Blocked Alarms"));
      xnav->ev = xnav->ev_new(event_title, alarm_title, block_title,
          xnav->gbl.OpObject, 0, 1, 0, xnav->gbl.AlarmReturn,
          xnav->gbl.AlarmAck, xnav->gbl.AlarmBeep, xnav->gbl.op_wind_pop,
          xnav->gbl.op_wind_eventname_seg, &sts);
      if (EVEN(sts)) {
        delete xnav->ev;
        xnav->ev = NULL;
        xnav->message('E', "Unable to load eventlist");
        return XNAV__SUCCESS;
      }
      xnav->ev->start_trace_cb = xnav_start_trace_cb;
      xnav->ev->help_cb = xnav_ev_help_cb;
      xnav->ev->display_in_xnav_cb = xnav_ev_display_in_xnav_cb;
      xnav->ev->update_info_cb = xnav_ev_update_info_cb;
      xnav->ev->popup_menu_cb = xnav_popup_menu_cb;
      xnav->ev->sound_cb = xnav_ev_sound_cb;
      xnav->ev->pop_cb = xnav_ev_pop_cb;
      xnav->ev->is_authorized_cb = xnav->is_authorized_cb;
    }

    arg2_sts = dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str));
    if (ODD(arg2_sts)) {
      if (str_NoCaseStrncmp(arg2_str, "SATELLITE", strlen(arg2_str)) == 0) {
        pwr_tOName alarmview_str;
        char tmp_str[40];
        pwr_tOid alarmview_oid = pwr_cNOid;
        int width, height, x, y;
        int nr;

        if (ODD(dcli_get_qualifier(
                "/ALARMVIEW", alarmview_str, sizeof(alarmview_str)))) {
          sts = gdh_NameToObjid(alarmview_str, &alarmview_oid);
          if (EVEN(sts)) {
            xnav->message('E', "Alarmview not found");
            return XNAV__SUCCESS;
          }
        }

        if (ODD(dcli_get_qualifier("/WIDTH", tmp_str, sizeof(tmp_str)))) {
          nr = sscanf(tmp_str, "%d", &width);
          if (nr != 1) {
            xnav->message('E', "Syntax error in width");
            return XNAV__HOLDCOMMAND;
          }
        } else
          width = 0;

        if (ODD(dcli_get_qualifier("/HEIGHT", tmp_str, sizeof(tmp_str)))) {
          nr = sscanf(tmp_str, "%d", &height);
          if (nr != 1) {
            xnav->message('E', "Syntax error in height");
            return XNAV__HOLDCOMMAND;
          }
        } else
          height = 0;

        if (ODD(dcli_get_qualifier("/XPOSITION", tmp_str, sizeof(tmp_str)))) {
          nr = sscanf(tmp_str, "%d", &x);
          if (nr != 1) {
            xnav->message('E', "Syntax error in x coordinate");
            return XNAV__HOLDCOMMAND;
          }
        } else
          x = 0;

        if (ODD(dcli_get_qualifier("/YPOSITION", tmp_str, sizeof(tmp_str)))) {
          nr = sscanf(tmp_str, "%d", &y);
          if (nr != 1) {
            xnav->message('E', "Syntax error in y coordinate");
            return XNAV__HOLDCOMMAND;
          }
        } else
          y = 0;

        if (xnav->ev)
          xnav->ev->open_eventlist_satellite(
              "Eventlist Satellite", &sts, width, height, x, y, alarmview_oid);
        else {
          xnav->message('E', "Eventlist not loaded");
          return XNAV__HOLDCOMMAND;
        }
      } else {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      xnav->ev->map_eve(options);

      if (xnav->opplace_p->Options & pwr_mOpPlaceOptionsMask_AllMainTransient) {
        if (xnav->ge_main)
          basewidget = xnav->ge_main->get_widget();
        else if (xnav->multiview_main)
          basewidget = xnav->multiview_main->get_widget();
        if (basewidget)
          xnav->ev->set_transient_eve(basewidget);
      }
    }
  }
  /*new code by Jonas Nylund 030122*/
  else if (str_NoCaseStrncmp(arg1_str, "HISTLIST", strlen(arg1_str)) == 0) {
    char hist_title[40];
    pwr_tAName name_str;
    pwr_tAttrRef* arp = 0;
    pwr_tAttrRef aref;

    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      sts = gdh_NameToAttrref(pwr_cNOid, name_str, &aref);
      if (EVEN(sts)) {
        xnav->message('E', "Object not found");
        return XNAV__HOLDCOMMAND;
      }
      arp = &aref;
    }

    strcpy(hist_title, Lng::translate("Event Log"));
    Hist* hist;
    hist = xnav->hist_new(hist_title, arp, &sts);
    if (EVEN(sts)) {
      delete hist;
      hist = NULL;
      xnav->message('E', "Unable to load histlist");
      return XNAV__SUCCESS;
    }
    xnav->appl.insert(applist_eType_Hist, (void*)hist, pwr_cNObjid, "", "");
    hist->close_cb = xnav_hist_close_cb;
    hist->start_trace_cb = xnav_start_trace_cb;
    hist->help_cb = xnav_ev_help_cb;
    hist->display_in_xnav_cb = xnav_ev_display_in_xnav_cb;
    hist->update_info_cb = xnav_ev_update_info_cb;
    hist->popup_menu_cb = xnav_popup_menu_cb;
  }
  /*end new code by Jonas Nylund 030122*/
  else if (str_NoCaseStrncmp(arg1_str, "ALARMLIST", strlen(arg1_str)) == 0) {
    char arg2_str[80];
    int arg2_sts;
    unsigned int options = 0;
    void* basewidget = 0;

    if (ODD(dcli_get_qualifier("/FULLSCREEN", 0, 0)))
      options |= ev_mAlaOptions_FullScreen;
    if (ODD(dcli_get_qualifier("/MAXIMIZE", 0, 0)))
      options |= ev_mAlaOptions_Maximize;
    if (ODD(dcli_get_qualifier("/FULLMAXIMIZE", 0, 0)))
      options |= ev_mAlaOptions_FullMaximize;
    if (ODD(dcli_get_qualifier("/ICONIFY", 0, 0)))
      options |= ev_mAlaOptions_Iconify;

    if (!xnav->ev) {
      char alarm_title[40], event_title[40], block_title[40];

      strcpy(alarm_title, Lng::translate("Alarm List"));
      strcpy(event_title, Lng::translate("Event List"));
      strcpy(block_title, Lng::translate("Blocked Alarms"));
      xnav->ev = xnav->ev_new(event_title, alarm_title, block_title,
          xnav->gbl.OpObject, 1, 0, 0, xnav->gbl.AlarmReturn,
          xnav->gbl.AlarmAck, xnav->gbl.AlarmBeep, xnav->gbl.op_wind_pop,
          xnav->gbl.op_wind_eventname_seg, &sts);
      if (EVEN(sts)) {
        delete xnav->ev;
        xnav->ev = NULL;
        xnav->message('E', "Unable to load eventlist");
        return XNAV__SUCCESS;
      }
      xnav->ev->start_trace_cb = xnav_start_trace_cb;
      xnav->ev->help_cb = xnav_ev_help_cb;
      xnav->ev->display_in_xnav_cb = xnav_ev_display_in_xnav_cb;
      xnav->ev->update_info_cb = xnav_ev_update_info_cb;
      xnav->ev->popup_menu_cb = xnav_popup_menu_cb;
      xnav->ev->sound_cb = xnav_ev_sound_cb;
      xnav->ev->pop_cb = xnav_ev_pop_cb;
      xnav->ev->is_authorized_cb = xnav->is_authorized_cb;
    }

    arg2_sts = dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str));
    if (ODD(arg2_sts)) {
      if (str_NoCaseStrncmp(arg2_str, "SATELLITE", strlen(arg2_str)) == 0) {
        pwr_tOName alarmview_str;
        char tmp_str[40];
        pwr_tOid alarmview_oid = pwr_cNOid;
        int width, height, x, y;
        int nr;

        if (ODD(dcli_get_qualifier(
                "/ALARMVIEW", alarmview_str, sizeof(alarmview_str)))) {
          sts = gdh_NameToObjid(alarmview_str, &alarmview_oid);
          if (EVEN(sts)) {
            xnav->message('E', "Alarmview not found");
            return XNAV__SUCCESS;
          }
        }

        if (ODD(dcli_get_qualifier("/WIDTH", tmp_str, sizeof(tmp_str)))) {
          nr = sscanf(tmp_str, "%d", &width);
          if (nr != 1) {
            xnav->message('E', "Syntax error in width");
            return XNAV__HOLDCOMMAND;
          }
        } else
          width = 0;

        if (ODD(dcli_get_qualifier("/HEIGHT", tmp_str, sizeof(tmp_str)))) {
          nr = sscanf(tmp_str, "%d", &height);
          if (nr != 1) {
            xnav->message('E', "Syntax error in height");
            return XNAV__HOLDCOMMAND;
          }
        } else
          height = 0;

        if (ODD(dcli_get_qualifier("/XPOSITION", tmp_str, sizeof(tmp_str)))) {
          nr = sscanf(tmp_str, "%d", &x);
          if (nr != 1) {
            xnav->message('E', "Syntax error in x coordinate");
            return XNAV__HOLDCOMMAND;
          }
        } else
          x = 0;

        if (ODD(dcli_get_qualifier("/YPOSITION", tmp_str, sizeof(tmp_str)))) {
          nr = sscanf(tmp_str, "%d", &y);
          if (nr != 1) {
            xnav->message('E', "Syntax error in y coordinate");
            return XNAV__HOLDCOMMAND;
          }
        } else
          y = 0;

        if (xnav->ev)
          xnav->ev->open_alarmlist_satellite(
              "Alarmlist Satellite", &sts, width, height, x, y, alarmview_oid);
        else {
          xnav->message('E', "Eventlist not loaded");
          return XNAV__HOLDCOMMAND;
        }
      } else {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      xnav->ev->map_ala(options);

      if (xnav->opplace_p->Options & pwr_mOpPlaceOptionsMask_AllMainTransient) {
        if (xnav->ge_main)
          basewidget = xnav->ge_main->get_widget();
        else if (xnav->multiview_main)
          basewidget = xnav->multiview_main->get_widget();
        if (basewidget)
          xnav->ev->set_transient_ala(basewidget);
      }
    }
  } else if (str_NoCaseStrncmp(arg1_str, "BLOCKLIST", strlen(arg1_str)) == 0) {
    unsigned int options = 0;
    void* basewidget = 0;

    if (ODD(dcli_get_qualifier("/FULLSCREEN", 0, 0)))
      options |= ev_mAlaOptions_FullScreen;
    if (ODD(dcli_get_qualifier("/MAXIMIZE", 0, 0)))
      options |= ev_mAlaOptions_Maximize;
    if (ODD(dcli_get_qualifier("/FULLMAXIMIZE", 0, 0)))
      options |= ev_mAlaOptions_FullMaximize;
    if (ODD(dcli_get_qualifier("/ICONIFY", 0, 0)))
      options |= ev_mAlaOptions_Iconify;

    if (!xnav->ev) {
      char alarm_title[40], event_title[40], block_title[40];

      strcpy(alarm_title, Lng::translate("Alarm List"));
      strcpy(event_title, Lng::translate("Event List"));
      strcpy(block_title, Lng::translate("Blocked Alarms"));
      xnav->ev = xnav->ev_new(event_title, alarm_title, block_title,
          xnav->gbl.OpObject, 0, 0, 1, xnav->gbl.AlarmReturn,
          xnav->gbl.AlarmAck, xnav->gbl.AlarmBeep, xnav->gbl.op_wind_pop,
          xnav->gbl.op_wind_eventname_seg, &sts);
      if (EVEN(sts)) {
        delete xnav->ev;
        xnav->ev = NULL;
        xnav->message('E', "Unable to load eventlist");
        return XNAV__SUCCESS;
      }
      xnav->ev->start_trace_cb = xnav_start_trace_cb;
      xnav->ev->help_cb = xnav_ev_help_cb;
      xnav->ev->display_in_xnav_cb = xnav_ev_display_in_xnav_cb;
      xnav->ev->update_info_cb = xnav_ev_update_info_cb;
      xnav->ev->popup_menu_cb = xnav_popup_menu_cb;
      xnav->ev->sound_cb = xnav_ev_sound_cb;
      xnav->ev->pop_cb = xnav_ev_pop_cb;
      xnav->ev->is_authorized_cb = xnav->is_authorized_cb;
    } else
      xnav->ev->map_blk(options);

    if (xnav->opplace_p->Options & pwr_mOpPlaceOptionsMask_AllMainTransient) {
      if (xnav->ge_main)
        basewidget = xnav->ge_main->get_widget();
      else if (xnav->multiview_main)
        basewidget = xnav->multiview_main->get_widget();
      if (basewidget)
        xnav->ev->set_transient_blk(basewidget);
    }
  } else if (str_NoCaseStrncmp(arg1_str, "USER", strlen(arg1_str)) == 0) {
    char msg[256];
    char priv_str[80];

    int window = ODD(dcli_get_qualifier("/WINDOW", 0, 0));

    if (streq(xnav->user, "")) {
      user_RtPrivToString(xnav->priv, priv_str, sizeof(priv_str));
      if (window) {
        sprintf(msg, "Current User:   Not logged in\n\nPrivileges:   %s)",
            priv_str);
        xnav->wow->DisplayText("User", msg);
      } else {
        sprintf(msg, "Not logged in (%s)", priv_str);
        xnav->message('I', msg);
      }
    } else {
      user_RtPrivToString(xnav->priv, priv_str, sizeof(priv_str));
      if (window) {
        sprintf(msg, "Current User:   %s\n\nPrivileges:   %s", xnav->user,
            priv_str);
        if (!streq(xnav->base_user, "")
            && !streq(xnav->base_user, xnav->user)) {
          strcat(msg, "\n\nOriginal User:   ");
          strcat(msg, xnav->base_user);
        }
        xnav->wow->DisplayText("User", msg);
      } else {
        sprintf(msg, "User %s (%s)", xnav->user, priv_str);
        xnav->message('I', msg);
      }
    }
  } else if (str_NoCaseStrncmp(arg1_str, "MESSAGE", strlen(arg1_str)) == 0) {
    char text_str[256];
    char title_str[256];

    if (EVEN(dcli_get_qualifier("/TEXT", text_str, sizeof(text_str)))) {
      xnav->message('E', "Syntax error");
      return XNAV__SUCCESS;
    }

    if (EVEN(dcli_get_qualifier("/TITLE", title_str, sizeof(title_str))))
      strncpy(title_str, Lng::translate("Message"), sizeof(title_str));

    xnav->wow->DisplayText(title_str, text_str);
  } else if (str_NoCaseStrncmp(arg1_str, "VOLUMES", strlen(arg1_str)) == 0) {
    /* Command is "SHOW VOLUMES" */
    pwr_tVid vid;
    pwr_tOid oid;
    pwr_tStatus nsts;
    int volume_cnt = 0;
    Item* item;

    sts = gdh_GetVolumeList(&vid);
    while (ODD(sts)) {
      oid.oix = 0;
      oid.vid = vid;

      if (!volume_cnt) {
        xnav->brow_pop();
        brow_SetNodraw(xnav->brow->ctx);
      }
      nsts = xnav->create_object_item(
          oid, NULL, flow_eDest_IntoLast, (void**)&item, 0);
      volume_cnt++;

      sts = gdh_GetNextVolume(vid, &vid);
    }
    brow_ResetNodraw(xnav->brow->ctx);
    brow_Redraw(xnav->brow->ctx, 0);
  } else if (str_NoCaseStrncmp(arg1_str, "NODEOBJECTS", strlen(arg1_str))
      == 0) {
    /* Command is "SHOW NODEOBJECTS" */
    pwr_tVid vid;
    pwr_tOid oid;
    pwr_tStatus nsts;
    int node_cnt = 0;
    Item* item;
    gdh_sVolumeInfo info;

    for (sts = gdh_GetVolumeList(&vid); ODD(sts);
         sts = gdh_GetNextVolume(vid, &vid)) {
      sts = gdh_GetVolumeInfo(vid, &info);
      if (EVEN(sts))
        continue;

      if (info.cid != pwr_eClass_RootVolume || info.nid == 0)
        continue;

      sts = gdh_GetNodeObject(info.nid, &oid);
      if (EVEN(sts))
        continue;

      if (!node_cnt) {
        xnav->brow_pop();
        brow_SetNodraw(xnav->brow->ctx);
      }
      nsts = xnav->create_object_item(
          oid, NULL, flow_eDest_IntoLast, (void**)&item, 0);
      node_cnt++;
    }
    brow_ResetNodraw(xnav->brow->ctx);
    brow_Redraw(xnav->brow->ctx, 0);
  } else if (str_NoCaseStrncmp(arg1_str, "NODEINFO", strlen(arg1_str)) == 0) {
    /* Command is "SHOW NODEINFO" */
    pwr_tVid vid;
    pwr_tOid oid;
    int node_cnt = 0;
    Item* item;
    gdh_sVolumeInfo info;
    pwr_tObjName name;
    pwr_tOName vname;
    pwr_tCmd cmd;
    char descr[120];
    char* descr_p;

    for (sts = gdh_GetVolumeList(&vid); ODD(sts);
         sts = gdh_GetNextVolume(vid, &vid)) {
      sts = gdh_GetVolumeInfo(vid, &info);
      if (EVEN(sts))
        continue;

      if (info.cid != pwr_eClass_RootVolume || info.nid == 0)
        continue;

      sts = gdh_GetNodeObject(info.nid, &oid);
      if (EVEN(sts))
        continue;

      if (!node_cnt) {
        xnav->brow_pop();
        brow_SetNodraw(xnav->brow->ctx);
      }
      sts = gdh_ObjidToName(oid, name, sizeof(name), cdh_mName_object);
      if (EVEN(sts))
        return sts;
      sts = gdh_ObjidToName(oid, vname, sizeof(vname), cdh_mName_volumeStrict);
      if (EVEN(sts))
        return sts;
      sprintf(cmd, "open graph/class/inst=%s", vname);

      // Set description annotation
      strcat(vname, ".Description");
      sts = gdh_GetObjectInfo(vname, descr, sizeof(descr));
      if (ODD(sts))
        descr_p = descr;
      else
        descr_p = 0;

      item = (Item*)new ItemCommand(xnav->brow, name, descr, NULL,
          flow_eDest_IntoLast, cmd, 0, xnav->brow->pixmap_list);
      node_cnt++;
    }
    brow_ResetNodraw(xnav->brow->ctx);
    brow_Redraw(xnav->brow->ctx, 0);
  } else if (str_NoCaseStrncmp(arg1_str, "METHODS", strlen(arg1_str)) == 0) {
    /* Command is "SHOW METHODS" */
    xnav->print_methods();
  } else if (str_NoCaseStrncmp(arg1_str, "OBJECTLIST", strlen(arg1_str)) == 0) {
    // Command is "SHOW OBJECTLIST"
    pwr_tAttrRef aref;
    int cnt = 0;
    pwr_tObjName class_str;
    char title_str[80];
    pwr_tOName* names;
    xnav_sObjectList* ctx;
    pwr_tCid cid[10];
    pwr_tVid root_vid;
    pwr_tObjName class_array[10];
    int class_num;
    int i;

    if (EVEN(dcli_get_qualifier("/CLASS", class_str, sizeof(class_str)))) {
      xnav->message('E', "Class is missing");
      return XNAV__HOLDCOMMAND;
    }

    // The class string can contain several classes separated by ','
    class_num = dcli_parse(class_str, ",", "", (char*)class_array,
        sizeof(class_array) / sizeof(class_array[0]), sizeof(class_array[0]),
        0);

    gdh_GetRootVolume(&root_vid);

    for (i = 0; i < class_num; i++) {
      sts = gdh_ClassNameToId(class_array[i], &cid[i]);
      if (EVEN(sts)) {
        xnav->message('E', "Unknown class");
        return XNAV__HOLDCOMMAND;
      }

      for (sts = gdh_GetClassListAttrRef(cid[i], &aref); ODD(sts);
           sts = gdh_GetNextAttrRef(cid[i], &aref, &aref)) {
        cnt++;
      }
    }

    names = (pwr_tOName*)calloc(cnt + 1, sizeof(pwr_tOName));

    int idx = 0;
    for (i = 0; i < class_num; i++) {
      for (sts = gdh_GetClassListAttrRef(cid[i], &aref); ODD(sts);
           sts = gdh_GetNextAttrRef(cid[i], &aref, &aref)) {
        if (aref.Objid.vid == root_vid)
          sts = gdh_AttrrefToName(
              &aref, names[idx], sizeof(names[0]), cdh_mNName);
        else
          sts = gdh_AttrrefToName(
              &aref, names[idx], sizeof(names[0]), cdh_mName_volumeStrict);
        if (EVEN(sts))
          continue;

        idx++;
        if (idx > cnt)
          break;
      }
    }

    if (EVEN(dcli_get_qualifier("/TITLE", title_str, sizeof(title_str)))) {
      sts = gdh_ObjidToName(cdh_ClassIdToObjid(cid[i]), title_str,
          sizeof(title_str), cdh_mName_object);
      if (EVEN(sts))
        return sts;

      strcat(title_str, Lng::translate(" List"));
    }

    int sort = ODD(dcli_get_qualifier("/SORT", 0, 0));
    if (sort) {
      // Sort
      pwr_tOName tmp;
      for (int i = cnt - 1; i > 0; i--) {
        for (int j = 0; j < i; j++) {
          if (strcmp(names[j], names[j + 1]) > 0) {
            strcpy(tmp, names[j + 1]);
            strcpy(names[j + 1], names[j]);
            strcpy(names[j], tmp);
          }
        }
      }
    }

    ctx = (xnav_sObjectList*)calloc(1, sizeof(xnav_sObjectList));
    ctx->cid = cid[0];
    ctx->xnav = xnav;

    xnav->wow->CreateList(title_str, (char*)names, sizeof(names[0]),
        xnav_show_objectlist_cb, xnav_show_objectlist_cancel_cb, ctx);
    free(names);
  } else if (str_NoCaseStrncmp(arg1_str, "OBJECTTREE", strlen(arg1_str)) == 0) {
    char class_str[80];

    // Command is "SHOW OBJECTTREE"
    if (ODD(dcli_get_qualifier("/CLASS", class_str, sizeof(class_str)))) {
      pwr_tCid cid[20];
      pwr_tObjName class_array[20];
      int class_num;
      pwr_tAttrRef* list;
      int listcnt;
      unsigned int options = 0;
      char layout_str[40];
      char title_str[80];
      int i;
      int global;
      int alphaorder;

      global = ODD(dcli_get_qualifier("/GLOBAL", 0, 0));
      alphaorder = ODD(dcli_get_qualifier("/ALPHAORDER", 0, 0));

      if (EVEN(dcli_get_qualifier("/TITLE", title_str, sizeof(title_str))))
        strcpy(title_str, "Objects");

      // The class string can contain several classes separated by ','
      class_num = dcli_parse(class_str, ",", "", (char*)class_array,
          sizeof(class_array) / sizeof(class_array[0]), sizeof(class_array[0]),
          0);

      for (i = 0; i < class_num; i++) {
        sts = gdh_ClassNameToId(class_array[i], &cid[i]);
        if (EVEN(sts)) {
          xnav->message('E', "Unknown class");
          return XNAV__HOLDCOMMAND;
        }
      }

      if (global)
        sts = gdh_GetGlobalClassList(class_num, cid, 1, &list, &listcnt);
      else
        sts = gdh_GetLocalClassList(class_num, cid, 1, &list, &listcnt);
      if (EVEN(sts)) {
        xnav->message('E', "Class list error");
        return XNAV__HOLDCOMMAND;
      }
      if (listcnt == 0) {
        xnav->message('E', "No objects found");
        return XNAV__EMPTYLIST;
      }

      if (ODD(dcli_get_qualifier("/LAYOUT", layout_str, sizeof(layout_str)))) {
        if (str_NoCaseStrcmp(layout_str, "list") == 0)
          options |= tree_mOptions_LayoutList;
        else if (str_NoCaseStrcmp(layout_str, "tree") == 0)
          options |= tree_mOptions_LayoutTree;
        else if (str_NoCaseStrcmp(layout_str, "default") == 0) {
          if (listcnt > 20)
            options |= tree_mOptions_LayoutTree;
          else
            options |= tree_mOptions_LayoutList;
        } else {
          xnav->message('E', "No such layout");
          return XNAV__HOLDCOMMAND;
        }
      } else {
        if (listcnt > 20)
          options |= tree_mOptions_LayoutTree;
        else
          options |= tree_mOptions_LayoutList;
      }
      if (alphaorder)
        options |= tree_mOptions_AlphaOrder;

      xnav->tree_new(title_str, list, listcnt, options, xnav_otree_action_cb);

      free((char*)list);
      return XNAV__SUCCESS;
    } else {
      xnav->message('E', "Syntax error");
      return XNAV__HOLDCOMMAND;
    }
  } else if (str_NoCaseStrncmp(arg1_str, "HISTORY", strlen(arg1_str)) == 0) {
    int sts;
    pwr_tOid root;
    pwr_tOid child;
    Item* item;
    int cnt;

    // Get the toplevel objects
    sts = gdh_NameToObjid("pwrNode-sev", &root);
    if (EVEN(sts)) {
      xnav->message('E', "No storage server on this node");
      return XNAV__SUCCESS;
    }

    //  Loop through all root objects and see if they are valid at toplevel
    cnt = 0;
    for (sts = gdh_GetChild(root, &child); ODD(sts);
         sts = gdh_GetNextSibling(child, &child)) {
      if (cnt == 0) {
        xnav->brow_pop();
        brow_SetNodraw(xnav->brow->ctx);
      }
      sts = xnav->create_object_item(
          child, NULL, flow_eDest_IntoLast, (void**)&item, 0);

      cnt++;
    }

    if (!cnt) {
      xnav->message('E', "No history objects found");
      return XNAV__SUCCESS;
    }
    brow_ResetNodraw(xnav->brow->ctx);
    brow_Redraw(xnav->brow->ctx, 0);
  } else {
    /* This might be a system picture */
    sts = 0; // rttsys_start_system_picture( ctx, arg1_str);
    if (sts == 0) {
      xnav->message('E', "Unknown qualifier");
      return XNAV__HOLDCOMMAND;
    }
    return sts;
  }
  return XNAV__SUCCESS;
}

static int xnav_eventlist_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;

  int sts;
  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "LOAD", strlen(arg1_str)) == 0) {
    // Command is "EVENTLIST LOAD"
    if (!xnav->ev) {
      char alarm_title[40], event_title[40], block_title[40];

      strcpy(alarm_title, Lng::translate("Alarm List"));
      strcpy(event_title, Lng::translate("Event List"));
      strcpy(block_title, Lng::translate("Blocked Alarms"));
      xnav->ev = xnav->ev_new(event_title, alarm_title, block_title,
          xnav->gbl.OpObject, 0, 0, 0, xnav->gbl.AlarmReturn,
          xnav->gbl.AlarmAck, xnav->gbl.AlarmBeep, xnav->gbl.op_wind_pop,
          xnav->gbl.op_wind_eventname_seg, &sts);
      if (EVEN(sts)) {
        delete xnav->ev;
        xnav->ev = NULL;
        xnav->message('E', "Unable to load eventlist");
        return XNAV__SUCCESS;
      }
      xnav->ev->start_trace_cb = xnav_start_trace_cb;
      xnav->ev->help_cb = xnav_ev_help_cb;
      xnav->ev->display_in_xnav_cb = xnav_ev_display_in_xnav_cb;
      xnav->ev->update_info_cb = xnav_ev_update_info_cb;
      xnav->ev->popup_menu_cb = xnav_popup_menu_cb;
      xnav->ev->sound_cb = xnav_ev_sound_cb;
      xnav->ev->pop_cb = xnav_ev_pop_cb;
      xnav->ev->is_authorized_cb = xnav->is_authorized_cb;
    } else {
      xnav->message('I', "Eventlist is already loaded");
    }
    return XNAV__SUCCESS;
  } else if (str_NoCaseStrncmp(arg1_str, "UNLOAD", strlen(arg1_str)) == 0) {
    // Command is "EVENTLIST UNLOAD"
    if (xnav->ev) {
      delete ((XNav*)xnav)->ev;
      ((XNav*)xnav)->ev = NULL;
    } else
      xnav->message('I', "Eventlist is not loaded");
  } else if (str_NoCaseStrncmp(arg1_str, "ACKNOWLEDGE", strlen(arg1_str))
      == 0) {
    // Command is "EVENTLIST ACKNOWLEDGE"
    char prio_str[80];
    char autoack_str[80];
    mh_sEventId* id;
    int all;
    int oldest;
    int timecheck;

    oldest = ODD(dcli_get_qualifier("/OLDEST", 0, 0));
    timecheck = ODD(dcli_get_qualifier("/TIMECHECK", 0, 0));

    all = ODD(dcli_get_qualifier("/ALL", 0, 0));
    if (all) {
      if (xnav->ev)
        xnav->ev->ack_all();
      return XNAV__SUCCESS;
    }

    if (ODD(dcli_get_qualifier(
            "/AUTOACKNOWLEDGE", autoack_str, sizeof(autoack_str)))) {
      float ftime;

      // Check authorization
      if (!(xnav->priv & pwr_mPrv_System)) {
        xnav->message('E', "Not authorized for this operation");
        return XNAV__SUCCESS;
      }

      int nr = sscanf(autoack_str, "%f", &ftime);
      if (nr != 1) {
        xnav->message('E', "Syntax error in time");
        return XNAV__HOLDCOMMAND;
      }
      xnav->autoack_scantime = ftime;
      int time = int(xnav->autoack_scantime * 1000);
      if (time == 0)
        xnav->autoack_timerid->remove();
      else
        xnav->autoack_timerid->add(time, XNav::autoack_scan, xnav);
      return XNAV__SUCCESS;
    }

    if (xnav->ev) {
      if (ODD(dcli_get_qualifier("/PRIORITY", prio_str, sizeof(prio_str)))) {
        str_ToUpper(prio_str, prio_str);
        if (streq(prio_str, "A"))
          xnav->ev->ack_last_prio(evlist_eEventType_Alarm, mh_eEventPrio_A, oldest, timecheck);
        else if (streq(prio_str, "B"))
          xnav->ev->ack_last_prio(evlist_eEventType_Alarm, mh_eEventPrio_B, oldest, timecheck);
        else if (streq(prio_str, "C"))
          xnav->ev->ack_last_prio(evlist_eEventType_Alarm, mh_eEventPrio_C, oldest, timecheck);
        else if (streq(prio_str, "D"))
          xnav->ev->ack_last_prio(evlist_eEventType_Alarm, mh_eEventPrio_D, oldest, timecheck);
        else if (str_StartsWith(prio_str, "I"))
          xnav->ev->ack_last_prio(evlist_eEventType_Info, 0, oldest, timecheck);
        else if (streq(prio_str, "NOA")) {
          if (ODD(xnav->ev->get_last_not_acked_prio(
                  &id, evlist_eEventType_Alarm, mh_eEventPrio_B)))
            xnav->ev->ack_last_prio(evlist_eEventType_Alarm, mh_eEventPrio_B, oldest, timecheck);
          else if (ODD(xnav->ev->get_last_not_acked_prio(
                       &id, evlist_eEventType_Alarm, mh_eEventPrio_C)))
            xnav->ev->ack_last_prio(evlist_eEventType_Alarm, mh_eEventPrio_C, oldest, timecheck);
          else if (ODD(xnav->ev->get_last_not_acked_prio(
                       &id, evlist_eEventType_Alarm, mh_eEventPrio_D)))
            xnav->ev->ack_last_prio(evlist_eEventType_Alarm, mh_eEventPrio_D, oldest, timecheck);
          else if (ODD(xnav->ev->get_last_not_acked_prio(
                       &id, evlist_eEventType_Info, 0)))
            xnav->ev->ack_last_prio(evlist_eEventType_Info, 0, oldest, timecheck);
        } else
          xnav->message('E', "Unknown priority");
      } else
        xnav->message('E', "Enter priority");
    } else
      xnav->message('I', "Eventlist is not loaded");
  } else if (str_NoCaseStrncmp(arg1_str, "BLOCK", strlen(arg1_str)) == 0) {
    // Command is "EVENTLIST BLOCK"
    char prio_str[80];
    pwr_tOName name_str;
    pwr_tObjid objid;
    mh_eEventPrio prio;

    if (!xnav->ev) {
      xnav->message('E', "Eventlist is not loaded");
      return XNAV__SUCCESS;
    }

    if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
      sts = gdh_NameToObjid(name_str, &objid);
      if (EVEN(sts)) {
        xnav->message('E', "Object not found");
        return XNAV__SUCCESS;
      }
    } else {
      // Get the selected object
      sts = xnav->get_current_object(
          &objid, name_str, sizeof(name_str), cdh_mName_volumeStrict);
      if (EVEN(sts)) {
        xnav->message('E', "Enter name or select an object");
        return XNAV__HOLDCOMMAND;
      }
    }

    if (ODD(dcli_get_qualifier("/PRIORITY", prio_str, sizeof(prio_str)))) {
      str_ToUpper(prio_str, prio_str);
      switch (prio_str[0]) {
      case 'A':
        prio = mh_eEventPrio_A;
        break;
      case 'B':
        prio = mh_eEventPrio_B;
        break;
      case 'C':
        prio = mh_eEventPrio_C;
        break;
      case 'D':
        prio = mh_eEventPrio_D;
        break;
      default:
        xnav->message('E', "Unknown priority");
        return XNAV__HOLDCOMMAND;
      }

      sts = mh_OutunitBlock(objid, prio);
      if (EVEN(sts))
        xnav->message(' ', XNav::get_message(sts));
    } else {
      pwr_sAttrRef oar = cdh_ObjidToAref(objid);

      xnav->block_new(&oar, Lng::translate("Alarm Blocking"), xnav->priv, &sts);
      xnav->message('E', "Enter priority");
      return XNAV__HOLDCOMMAND;
    }

  } else if (str_NoCaseStrncmp(arg1_str, "UNBLOCK", strlen(arg1_str)) == 0) {
    // Command is "EVENTLIST UNBLOCK"
    pwr_tOName name_str;
    pwr_tObjid objid;

    if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
      sts = gdh_NameToObjid(name_str, &objid);
      if (EVEN(sts)) {
        xnav->message('E', "Object not found");
        return XNAV__SUCCESS;
      }
    } else {
      // Get the selected object
      sts = xnav->get_current_object(
          &objid, name_str, sizeof(name_str), cdh_mName_volumeStrict);
      if (EVEN(sts)) {
        xnav->message('E', "Enter name or select an object");
        return XNAV__HOLDCOMMAND;
      }
    }

    sts = mh_OutunitBlock(objid, (mh_eEventPrio)0);
    if (EVEN(sts))
      xnav->message(' ', XNav::get_message(sts));
  } else {
    xnav->message('E', "Unknown qualifier");
    return XNAV__HOLDCOMMAND;
  }
  return XNAV__SUCCESS;
}

static int xnav_add_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;
  int sts;
  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "PARAMETER", strlen(arg1_str)) == 0) {
    /* Command is "ADD PARAMETER" */
    pwr_tOName parameter_str;
    pwr_tObjName class_str;
    pwr_tOName name_str;
    pwr_tOName hierarchy_str;
    char* class_ptr;
    char* name_ptr;
    char* hierarchy_ptr;
    char* parameter_ptr;
    int global;
    char str[80];

    IF_NOGDH_RETURN;

    if (ODD(dcli_get_qualifier(
            "/PARAMETER", parameter_str, sizeof(parameter_str))))
      parameter_ptr = parameter_str;
    else
      parameter_ptr = NULL;

    /* Get the name qualifier */
    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (name_str[0] != '/')
        /* Assume that this is the namestring */
        name_ptr = name_str;
      else {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str))))
        name_ptr = name_str;
      else
        name_ptr = NULL;
    }
    if (ODD(dcli_get_qualifier("/CLASS", class_str, sizeof(class_str))))
      class_ptr = class_str;
    else
      class_ptr = NULL;
    if (ODD(dcli_get_qualifier(
            "/HIERARCHY", hierarchy_str, sizeof(hierarchy_str))))
      hierarchy_ptr = hierarchy_str;
    else
      hierarchy_ptr = NULL;
    if (ODD(dcli_get_qualifier("/LOCAL", str, sizeof(str))))
      global = 0;
    else
      global = 1;

    sts = xnav->show_par_hier_class_name(parameter_ptr, hierarchy_ptr,
        class_ptr, name_ptr, XNAV_MENU_ADD, global, 0);
    return sts;
  }

  if (str_NoCaseStrncmp(arg1_str, "DEBUG", strlen(arg1_str)) == 0) {
    /* Command is "ADD DEBUG" */
    pwr_tObjName class_str;
    pwr_tOName name_str;
    pwr_tOName hierarchy_str;
    char* class_ptr;
    char* name_ptr;
    char* hierarchy_ptr;
    int global;
    char str[80];

    IF_NOGDH_RETURN;

    /* Get the name qualifier */
    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (name_str[0] != '/')
        /* Assume that this is the namestring */
        name_ptr = name_str;
      else {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str))))
        name_ptr = name_str;
      else
        name_ptr = NULL;
    }
    if (ODD(dcli_get_qualifier("/CLASS", class_str, sizeof(class_str))))
      class_ptr = class_str;
    else
      class_ptr = NULL;
    if (ODD(dcli_get_qualifier(
            "/HIERARCHY", hierarchy_str, sizeof(hierarchy_str))))
      hierarchy_ptr = hierarchy_str;
    else
      hierarchy_ptr = NULL;
    if (ODD(dcli_get_qualifier("/LOCAL", str, sizeof(str))))
      global = 0;
    else
      global = 1;

    //    sts = rtt_debug_obj_hier_class_name( ctx,
    //			hierarchy_ptr, class_ptr, name_ptr, RTT_MENU_ADD,
    //			global);
    sts = 0;
    return sts;
  } else if (str_NoCaseStrncmp(arg1_str, "MENU", strlen(arg1_str)) == 0) {
    /* Command is "ADD MENU" */
    int sts;
    char object_str[80];
    char text_str[80];
    char command_str[80];
    int command;
    int object;
    pwr_tObjid objid;

    if (EVEN(dcli_get_qualifier("/TEXT", text_str, sizeof(text_str)))) {
      xnav->message('E', "Enter text");
      return XNAV__HOLDCOMMAND;
    }
    if (ODD(dcli_get_qualifier("/COMMAND", command_str, sizeof(command_str))))
      command = 1;
    else
      command = 0;
    if (ODD(dcli_get_qualifier("/OBJECT", object_str, sizeof(object_str)))) {
      IF_NOGDH_RETURN;
      object = 1;
      sts = gdh_NameToObjid(object_str, &objid);
      if (EVEN(sts)) {
        xnav->message('E', "Object not found");
        return XNAV__HOLDCOMMAND;
      }
    } else
      object = 0;

    try {
      if (object)
        new ItemObject(xnav->brow, objid, NULL, flow_eDest_IntoLast, 0);
      else if (command)
        new ItemCommand(xnav->brow, text_str, 0, NULL, flow_eDest_IntoLast,
            command_str, 0, xnav->brow->pixmap_map);
      //    else
      //      new ItemMenu( xnav->brow, text_str, NULL,
      //		flow_eDest_IntoLast, (xnav_sMenu *) menu->action,
      //		0);
    } catch (co_error& e) {
      xnav->brow_push_all();
      brow_Redraw(xnav->brow->ctx, 0);
      xnav->message('E', (char*)e.what().c_str());
    }
    return XNAV__SUCCESS;
  }

  return XNAV__SUCCESS;
}


static void xnav_dashboard_open_cb(void* ctx, char* text, int ok_pressed)
{
  XNav* xnav = (XNav*)ctx;
  pwr_tCmd cmd;

  sprintf(cmd, "open graph %s/dash/menu", text);

  xnav->command(cmd);
}

static int xnav_open_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;

  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "GRAPH", strlen(arg1_str)) == 0) {
    pwr_tAName object_str;
    pwr_tAName instance_str;
    char* instance_p;
    int classgraph;
    int parent;
    pwr_tStatus sts;
    unsigned int options = 0;
    pwr_tFileName pwindow_str;
    pwr_tAName pinstance_str;
    void* basewidget = 0;

    // Command is "OPEN GRAPH"

    parent = ODD(dcli_get_qualifier("/PARENT", 0, 0));

    if (ODD(dcli_get_qualifier("/FULLSCREEN", 0, 0)))
      options |= ge_mOptions_FullScreen;
    if (ODD(dcli_get_qualifier("/MAXIMIZE", 0, 0)))
      options |= ge_mOptions_Maximize;
    if (ODD(dcli_get_qualifier("/FULLMAXIMIZE", 0, 0)))
      options |= ge_mOptions_FullMaximize;
    if (ODD(dcli_get_qualifier("/ICONIFY", 0, 0)))
      options |= ge_mOptions_Iconify;
    if (ODD(dcli_get_qualifier("/HIDE", 0, 0)))
      options |= ge_mOptions_Invisible;
    if (ODD(dcli_get_qualifier("/MAIN", 0, 0)) && !xnav->op && !xnav->ge_main
        && !xnav->multiview_main) {
      options |= ge_mOptions_IsMain;
      if (xnav->opplace_p->OpWindLayout & pwr_mOpWindLayoutMask_HideCloseButton)
        options |= ge_mOptions_HideCloseButton;
    }

    if (ODD(dcli_get_qualifier("/PWINDOW", pwindow_str, sizeof(pwindow_str)))) {
      char* pinstance_p = 0;
      XttGe* gectx;

      if (str_NoCaseStrcmp(pwindow_str, "$current") == 0) {
        if (xnav->current_cmd_ctx) {
          pwr_tFileName name;
          pwr_tAName inst;

          if (xnav->appl.find(
                  applist_eType_Graph, xnav->current_cmd_ctx, name, inst))
            basewidget = ((XttGe*)xnav->current_cmd_ctx)->get_widget();
          else if (xnav->appl.find(applist_eType_MultiView,
                       xnav->current_cmd_ctx, name, inst))
            basewidget = ((XttMultiView*)xnav->current_cmd_ctx)->get_widget();
        }
      } else {
        if (ODD(dcli_get_qualifier(
                "/PINSTANCE", pinstance_str, sizeof(pinstance_str)))) {
          pinstance_p = pinstance_str;
        }

        if (xnav->appl.find(
                applist_eType_Graph, pwindow_str, pinstance_p, (void**)&gectx))
          basewidget = gectx->get_widget();
      }
    } else if (xnav->opplace_p->Options
        & pwr_mOpPlaceOptionsMask_AllMainTransient) {
      if (xnav->ge_main)
        basewidget = xnav->ge_main->get_widget();
      else if (xnav->multiview_main)
        basewidget = xnav->multiview_main->get_widget();
    }

    if (ODD(dcli_get_qualifier(
            "/INSTANCE", instance_str, sizeof(instance_str)))) {
      instance_p = instance_str;

      if (instance_str[0] == '&') {
        pwr_tStatus sts;
        pwr_tTid tid;
        pwr_tUInt32 size, offs, elem;
        char* instp;

        if (instance_str[1] == '('
            && instance_str[strlen(instance_str) - 1] == ')') {
          instp = &instance_str[2];
          instance_str[strlen(instance_str) - 1] = 0;
        } else
          instp = &instance_str[1];

        sts = gdh_GetAttributeCharacteristics(instp, &tid, &size, &offs, &elem);
        if (EVEN(sts)) {
          xnav->message('E', "Instance object not found");
          return XNAV__HOLDCOMMAND;
        }

        switch (tid) {
        case pwr_eType_Objid: {
          pwr_tOid oid;

          // Objid attribute the contains the instance
          sts = gdh_GetObjectInfo(instp, &oid, sizeof(oid));
          if (ODD(sts))
            sts = gdh_ObjidToName(oid, instance_str, sizeof(instance_str),
                cdh_mName_volumeStrict);
          if (EVEN(sts)) {
            xnav->message('E', "Instance object not found");
            return XNAV__HOLDCOMMAND;
          }
          break;
        }
        case pwr_eType_AttrRef: {
          pwr_tAttrRef aref;

          // Objid attribute the contains the instance
          sts = gdh_GetObjectInfo(instp, &aref, sizeof(aref));
          if (ODD(sts))
            sts = gdh_AttrrefToName(&aref, instance_str, sizeof(instance_str),
                cdh_mName_volumeStrict);
          if (EVEN(sts)) {
            xnav->message('E', "Instance object not found");
            return XNAV__HOLDCOMMAND;
          }
          break;
        }
        default:
          xnav->message('E', "Instance object not found");
          return XNAV__HOLDCOMMAND;
        }
      }
      if (parent) {
        // Replace instance object with parent object attribute
        char* s;
        if ((s = strrchr(instance_str, '.')))
          *s = 0;
        else if ((s = strrchr(instance_str, '-')))
          *s = 0;
      }
    } else
      instance_p = 0;

    if (ODD(dcli_get_qualifier("/CLASSGRAPH", 0, 0))) {
      classgraph = 1;
      if (!instance_p) {
        xnav->message('E', "Instance is missing");
        return XNAV__HOLDCOMMAND;
      }
    } else
      classgraph = 0;

    if (ODD(dcli_get_qualifier("/OBJECT", object_str, sizeof(object_str)))) {
      pwr_tObjid objid;
      pwr_tAName xttgraph_name;
      int sts;
      char focus_str[80];
      char* focus_p;
      int inputempty;
      char tmp_str[80];
      int use_default_access;
      unsigned int access = 0;
      int nr;

      IF_NOGDH_RETURN;

      xnav_replace_node_str(xttgraph_name, object_str);

      sts = gdh_NameToObjid(xttgraph_name, &objid);
      if (EVEN(sts)) {
        xnav->message('E', "Object not found");
        return XNAV__HOLDCOMMAND;
      }

      inputempty = ODD(dcli_get_qualifier("/INPUTEMPTY", 0, 0));

      if (ODD(dcli_get_qualifier("/FOCUS", focus_str, sizeof(focus_str))))
        focus_p = focus_str;
      else
        focus_p = 0;

      if (ODD(dcli_get_qualifier("/ACCESS", tmp_str, sizeof(tmp_str)))) {
        nr = sscanf(tmp_str, "%u", &access);
        if (nr != 1) {
          xnav->message('E', "Syntax error in access");
          return XNAV__HOLDCOMMAND;
        }
        use_default_access = 1;
      } else
        use_default_access = 0;

      xnav->exec_xttgraph(objid, instance_p, focus_p, inputempty,
          use_default_access, access, options, basewidget);
    } else {
      pwr_tFileName file_str;
      pwr_tAName name_str;
      char focus_str[80];
      char tmp_str[80];
      char* focus_p;
      int width, height, nr, scrollbar, menu, navigator;
      double borders[4] = { 0, 0, 0, 0 };
      double* bordersp = borders;
      int inputempty;
      pwr_tFileName fname;
      int use_default_access;
      unsigned int access = 0;
      int dashboard;

      // Command is "OPEN GRAPH" without graph object
      scrollbar = ODD(dcli_get_qualifier("/SCROLLBAR", 0, 0));
      dashboard = ODD(dcli_get_qualifier("/DASHBOARD", 0, 0));

      if (ODD(dcli_get_qualifier("/COLLECT", 0, 0))) {
        scrollbar = ODD(dcli_get_qualifier("/SCROLLBAR", 0, 0));
        menu = ODD(dcli_get_qualifier("/MENU", 0, 0));
        navigator = ODD(dcli_get_qualifier("/NAVIGATOR", 0, 0));

        xnav->open_graph("Collect", "_none_", scrollbar, menu, navigator, 0, 0,
	     0, 0, "collect", NULL, 0, 0, 0, options, basewidget, 0, 0);
        return XNAV__SUCCESS;
      }
      if (ODD(dcli_get_qualifier("dcli_arg2", file_str, sizeof(file_str)))) {
        // Get base class graphs on $pwr_exe
        str_ToLower(fname, file_str);
        if (instance_p && (str_NoCaseStrncmp(fname, "pwr_c_", 6) == 0
                              || str_NoCaseStrncmp(fname, "pwr_c_", 6) == 0)) {
          strcpy(fname, "$pwr_exe/");
          strcat(fname, file_str);
          strcpy(file_str, fname);
        }
      } else if (ODD(dcli_get_qualifier("/FILE", file_str, sizeof(file_str)))) {
        // Get base class graphs on $pwr_exe
        str_ToLower(fname, file_str);
        if (instance_p && (str_NoCaseStrncmp(fname, "pwr_c_", 6) == 0
                              || str_NoCaseStrncmp(fname, "pwr_t_", 6) == 0)) {
          strcpy(fname, "$pwr_exe/");
          strcat(fname, file_str);
          strcpy(file_str, fname);
        }
      } else {
        if (classgraph) {
          // Get file from class of instance object
          pwr_tAttrRef aref;
          pwr_tCid cid;

          if (!instance_p) {
            xnav->message('E', "Enter instance object");
            return XNAV__HOLDCOMMAND;
          }

          sts = XNav::get_instance_classgraph(instance_p, file_str);
          if (EVEN(sts)) {
            xnav->message('E', XNav::get_message(sts));
            return XNAV__HOLDCOMMAND;
          }

          sts = gdh_NameToAttrref(pwr_cNObjid, instance_p, &aref);
          if (EVEN(sts))
            return sts;

          sts = gdh_GetAttrRefTid(&aref, &cid);
          if (EVEN(sts))
            return sts;

          switch (cid) {
          case pwr_cClass_NMpsCell:
          case pwr_cClass_NMpsStoreCell:
            scrollbar = 0;
            break;
          default:;
          }
        } else {
          xnav->message('E', "Enter file");
          return XNAV__HOLDCOMMAND;
        }
      }
      if (EVEN(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
        if (instance_p) {
          pwr_sAttrRef aref;
          char* s;

          // Use object name as title
          if ((s = strchr(instance_p, ',')))
            *s = 0;
          sts = gdh_NameToAttrref(pwr_cNObjid, instance_p, &aref);
          if (EVEN(sts)) {
            xnav->message('E', "Instance object not found");
            return XNAV__HOLDCOMMAND;
          }
          if (s)
            *s = ',';
          sts = gdh_AttrrefToName(
              &aref, name_str, sizeof(name_str), cdh_mName_pathStrict);
          if (EVEN(sts))
            return sts;
        } else {
          if (file_str[0] == '/') {
            char* t = strrchr(file_str, '/');
            strncpy(name_str, t + 1, sizeof(name_str));
          } else
            strncpy(name_str, file_str, sizeof(name_str));
        }
      }
      if (ODD(dcli_get_qualifier("/FOCUS", focus_str, sizeof(focus_str))))
        focus_p = focus_str;
      else
        focus_p = 0;

      menu = ODD(dcli_get_qualifier("/MENU", 0, 0));
      navigator = ODD(dcli_get_qualifier("/NAVIGATOR", 0, 0));
      inputempty = ODD(dcli_get_qualifier("/INPUTEMPTY", 0, 0));

      if (ODD(dcli_get_qualifier("/WIDTH", tmp_str, sizeof(tmp_str)))) {
        nr = sscanf(tmp_str, "%d", &width);
        if (nr != 1) {
          xnav->message('E', "Syntax error in width");
          return XNAV__HOLDCOMMAND;
        }
      } else
        width = 0;

      if (ODD(dcli_get_qualifier("/HEIGHT", tmp_str, sizeof(tmp_str)))) {
        nr = sscanf(tmp_str, "%d", &height);
        if (nr != 1) {
          xnav->message('E', "Syntax error in height");
          return XNAV__HOLDCOMMAND;
        }
      } else
        height = 0;

      if (ODD(dcli_get_qualifier("/X0", tmp_str, sizeof(tmp_str)))) {
        nr = sscanf(tmp_str, "%lf", &borders[0]);
        if (nr != 1) {
          xnav->message('E', "Syntax error in x0");
          return XNAV__HOLDCOMMAND;
        }
      } else
        borders[0] = 0;

      if (ODD(dcli_get_qualifier("/Y0", tmp_str, sizeof(tmp_str)))) {
        nr = sscanf(tmp_str, "%lf", &borders[1]);
        if (nr != 1) {
          xnav->message('E', "Syntax error in y0");
          return XNAV__HOLDCOMMAND;
        }
      } else
        borders[1] = 0;

      if (ODD(dcli_get_qualifier("/X1", tmp_str, sizeof(tmp_str)))) {
        nr = sscanf(tmp_str, "%lf", &borders[2]);
        if (nr != 1) {
          xnav->message('E', "Syntax error in x1");
          return XNAV__HOLDCOMMAND;
        }
      } else
        borders[2] = 0;

      if (ODD(dcli_get_qualifier("/Y1", tmp_str, sizeof(tmp_str)))) {
        nr = sscanf(tmp_str, "%lf", &borders[3]);
        if (nr != 1) {
          xnav->message('E', "Syntax error in y1");
          return XNAV__HOLDCOMMAND;
        }
      } else
        borders[3] = 0;

      if (feq(borders[0], 0.0) && feq(borders[1], 0.0) && feq(borders[2], 0.0)
          && feq(borders[3], 0.0))
        bordersp = 0;

      if (ODD(dcli_get_qualifier("/ACCESS", tmp_str, sizeof(tmp_str)))) {
        nr = sscanf(tmp_str, "%u", &access);
        if (nr != 1) {
          xnav->message('E', "Syntax error in access");
          return XNAV__HOLDCOMMAND;
        }
        use_default_access = 1;
      } else
        use_default_access = 0;

      xnav->open_graph(name_str, file_str, scrollbar, menu, navigator, width,
          height, 0, 0, instance_p, focus_p, inputempty, use_default_access,
	  access, options, basewidget, bordersp, dashboard);
      return XNAV__SUCCESS;
    }
  } else if (str_NoCaseStrncmp(arg1_str, "MULTIVIEW", strlen(arg1_str)) == 0) {
    char tmp_str[80];
    int width, height;
    int x, y;
    unsigned int options = 0;
    pwr_tAttrRef aref = pwr_cNAttrRef;
    pwr_tOName name_str;
    char* name_ptr = 0;
    int nr;
    pwr_tStatus sts;
    pwr_tAttrRef aref_vect[2];
    void* basewidget = 0;

    // Command is "OPEN MULTIVIEW"

    /* Get the name qualifier */
    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (name_str[0] != '/')
        /* Assume that this is the namestring */
        name_ptr = name_str;
      else {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str))))
        name_ptr = name_str;
      else {
        /* Get the selected object */
        sts = xnav->get_current_aref(&aref_vect[0], name_str, sizeof(name_str),
            cdh_mName_path | cdh_mName_object | cdh_mName_attribute);
        if (EVEN(sts)) {
          xnav->message('E', "Enter name or select an object");
          return XNAV__SUCCESS;
        }
        name_ptr = name_str;
      }
    }

    xnav_replace_node_str(name_ptr, name_ptr);

    sts = gdh_NameToAttrref(pwr_cNObjid, name_ptr, &aref);
    if (EVEN(sts)) {
      xnav->message('E', "MultiView object not found");
      return XNAV__HOLDCOMMAND;
    }

    if (ODD(dcli_get_qualifier("/FULLSCREEN", 0, 0)))
      options |= ge_mOptions_FullScreen;
    if (ODD(dcli_get_qualifier("/MAXIMIZE", 0, 0)))
      options |= ge_mOptions_Maximize;
    if (ODD(dcli_get_qualifier("/FULLMAXIMIZE", 0, 0)))
      options |= ge_mOptions_FullMaximize;
    if (ODD(dcli_get_qualifier("/ICONIFY", 0, 0)))
      options |= ge_mOptions_Iconify;
    if (ODD(dcli_get_qualifier("/HIDE", 0, 0)))
      options |= ge_mOptions_Invisible;
    if (ODD(dcli_get_qualifier("/MAIN", 0, 0)) && !xnav->op && !xnav->ge_main
        && !xnav->multiview_main) {
      options |= ge_mOptions_IsMain;
      if (xnav->opplace_p->OpWindLayout & pwr_mOpWindLayoutMask_HideCloseButton)
        options |= ge_mOptions_HideCloseButton;
    }

    if (ODD(dcli_get_qualifier("/WIDTH", tmp_str, sizeof(tmp_str)))) {
      nr = sscanf(tmp_str, "%d", &width);
      if (nr != 1) {
        xnav->message('E', "Syntax error in width");
        return XNAV__HOLDCOMMAND;
      }
    } else
      width = 0;

    if (ODD(dcli_get_qualifier("/HEIGHT", tmp_str, sizeof(tmp_str)))) {
      nr = sscanf(tmp_str, "%d", &height);
      if (nr != 1) {
        xnav->message('E', "Syntax error in height");
        return XNAV__HOLDCOMMAND;
      }
    } else
      height = 0;

    if (ODD(dcli_get_qualifier("/XPOSITION", tmp_str, sizeof(tmp_str)))) {
      nr = sscanf(tmp_str, "%d", &x);
      if (nr != 1) {
        xnav->message('E', "Syntax error in x coordinate");
        return XNAV__HOLDCOMMAND;
      }
    } else
      x = 0;

    if (ODD(dcli_get_qualifier("/YPOSITION", tmp_str, sizeof(tmp_str)))) {
      nr = sscanf(tmp_str, "%d", &y);
      if (nr != 1) {
        xnav->message('E', "Syntax error in y coordinate");
        return XNAV__HOLDCOMMAND;
      }
    } else
      y = 0;

    XttMultiView* mvctx;

    if (xnav->appl.find(applist_eType_MultiView, &aref, (void**)&mvctx)) {
      mvctx->pop();
    } else {
      if (xnav->opplace_p->Options & pwr_mOpPlaceOptionsMask_AllMainTransient) {
        if (xnav->ge_main)
          basewidget = xnav->ge_main->get_widget();
        else if (xnav->multiview_main)
          basewidget = xnav->multiview_main->get_widget();
      }

      mvctx = xnav->multiview_new(name_str, &aref, width, height, x, y, options,
          basewidget, xnav->gbl.color_theme, &sts, &xnav_multiview_command_cb,
          &xnav_ge_get_current_objects_cb, &xnav_ge_is_authorized_cb,
          &xnav_ge_keyboard_cb);
      if (EVEN(sts)) {
        xnav->message(' ', XNav::get_message(sts));
        return sts;
      }
      mvctx->close_cb = xnav_multiview_close_cb;
      mvctx->help_cb = xnav_ge_help_cb;
      mvctx->display_in_xnav_cb = xnav_ge_display_in_xnav_cb;
      mvctx->popup_menu_cb = xnav_popup_menu_cb;
      mvctx->call_method_cb = xnav_call_method_cb;
      mvctx->sound_cb = xnav_ge_sound_cb;
      mvctx->eventlog_cb = xnav_ge_eventlog_cb;
      mvctx->get_select_cb = xnav_sevhist_get_select_cb;

      xnav->appl.insert(applist_eType_MultiView, (void*)mvctx, &aref, "", NULL);

      if (options & ge_mOptions_IsMain) {
        if (xnav->opplace_p->OpWindLayout
            & pwr_mOpWindLayoutMask_HideCloseButton)
          options |= ge_mOptions_HideCloseButton;
        if (!xnav->op && !xnav->ge_main)
          xnav->multiview_main = mvctx;
      }
    }
    return XNAV__SUCCESS;
  } else if (str_NoCaseStrncmp(arg1_str, "DASHBOARD", strlen(arg1_str)) == 0) {
    char name_str[80];
    int name_found = 0;

    // Command is "OPEN DASHBOARD"

    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str))))
      name_found = 1;
    else if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str))))
      name_found = 1;
    if (!name_found) {
      xnav->wow->CreateFileList("Open Dashboard", "$pwrp_exe", "*", "pwd",
	    xnav_dashboard_open_cb, 0, xnav, 1);

      return XNAV__SUCCESS;
    } else {
      // Name found
      pwr_tCmd cmd;
      sprintf(cmd, "open graph %s/dash/menu", name_str);
      
      xnav->command(cmd);
    }
  } else if (str_NoCaseStrncmp(arg1_str, "CAMERA", strlen(arg1_str)) == 0
      || str_NoCaseStrncmp(arg1_str, "VIDEO", strlen(arg1_str)) == 0) {
    char tmp_str[80];
    int width, height;
    int x, y;
    float scantime;
    unsigned int options = 0;
    pwr_tString80 name_str;
    int nr;
    pwr_tStatus sts;
    pwr_tURL url_str;
    pwr_tAName object_str;
    pwr_tAName camerapos_str;
    int camerapos_found = 0;
    pwr_sClass_CameraPosition pos;
    int is_video
        = (str_NoCaseStrncmp(arg1_str, "VIDEO", strlen(arg1_str)) == 0);

    // Command is "OPEN CAMERA" or "OPEN VIDEO"

    if (ODD(dcli_get_qualifier(
            "/CAMERAPOSITION", camerapos_str, sizeof(camerapos_str)))) {
      // CameraPosition object supplied

      sts = gdh_GetObjectInfo(camerapos_str, &pos, sizeof(pos));
      if (EVEN(sts)) {
        xnav->message('E', "Object not found");
        return XNAV__HOLDCOMMAND;
      }

      sts = gdh_AttrrefToName(
          &pos.VideoObject, object_str, sizeof(object_str), cdh_mNName);
      if (EVEN(sts)) {
        xnav->message('E', "Configuration error, video object not found");
        return XNAV__HOLDCOMMAND;
      }
      camerapos_found = 1;
    }
    if (camerapos_found
        || ODD(dcli_get_qualifier("/OBJECT", object_str, sizeof(object_str)))) {
      // XttCamera object supplied, fetch data from object
      pwr_tOName xttcamera_name;
      pwr_sClass_XttCamera xttcamera;
      pwr_tObjid objid;
      pwr_tCid cid;

      xnav_replace_node_str(xttcamera_name, object_str);

      sts = gdh_NameToObjid(xttcamera_name, &objid);
      if (EVEN(sts)) {
        xnav->message('E', "Object not found");
        return XNAV__HOLDCOMMAND;
      }

      sts = gdh_GetObjectClass(objid, &cid);
      if (EVEN(sts))
        return sts;

      if (cid != pwr_cClass_XttCamera) {
        xnav->message('E', "Error in object class");
        return XNAV__HOLDCOMMAND;
      }
      pwr_tAttrRef aref = cdh_ObjidToAref(objid);

      sts = gdh_GetObjectInfoAttrref(
          &aref, (pwr_tAddress)&xttcamera, sizeof(xttcamera));
      if (EVEN(sts))
        return sts;

      strncpy(name_str, xttcamera.Title, sizeof(name_str));
      strncpy(url_str, xttcamera.URL, sizeof(url_str));
      width = xttcamera.Width;
      height = xttcamera.Height;
      x = xttcamera.X;
      y = xttcamera.Y;
      options = 0;
      if (xttcamera.Options & pwr_mCameraOptionsMask_FullScreen)
        options |= strm_mOptions_FullScreen;
      if (xttcamera.Options & pwr_mCameraOptionsMask_Maximize)
        options |= strm_mOptions_Maximize;
      if (xttcamera.Options & pwr_mCameraOptionsMask_FullMaximize)
        options |= strm_mOptions_FullMaximize;
      if (xttcamera.Options & pwr_mCameraOptionsMask_Iconify)
        options |= strm_mOptions_Iconify;
      if (is_video) {
        if (ODD(dcli_get_qualifier("/VIDEOCONTROLPANEL", 0, 0)))
          options |= strm_mOptions_VideoControlPanel;
        if (ODD(dcli_get_qualifier("/VIDEOPROGRESSBAR", 0, 0)))
          options |= strm_mOptions_VideoProgressBar;
      } else {
        if (xttcamera.Options & pwr_mCameraOptionsMask_CameraControlPanel)
          options |= strm_mOptions_CameraControlPanel;
      }
      if (xttcamera.Options & pwr_mCameraOptionsMask_HttpBasicAuthentication)
        options |= strm_mOptions_HttpBasicAuthentication;
      if (xttcamera.Options & pwr_mCameraOptionsMask_CgiParameterAuthentication)
        options |= strm_mOptions_CgiParameterAuthentication;

      XttStream* strmctx;

      if (xnav->appl.find(applist_eType_Stream, objid, (void**)&strmctx)) {
        strmctx->pop();
      } else {
        strmctx = xnav->stream_new(
            name_str, url_str, width, height, x, y, 0, options, 0, &aref, &sts);
        if (EVEN(sts)) {
          xnav->message(' ', XNav::get_message(sts));
          return sts;
        }
        strmctx->close_cb = xnav_stream_close_cb;

        xnav->appl.insert(
            applist_eType_Stream, (void*)strmctx, objid, name_str, url_str);
      }
      if (camerapos_found)
        strmctx->position(pos.Pan, pos.Tilt, pos.Zoom);
    } else {
      /* Get the name qualifier */
      if (EVEN(dcli_get_qualifier("/NAME", name_str, sizeof(name_str))))
        strcpy(name_str, "");

      if (EVEN(dcli_get_qualifier("/URL", url_str, sizeof(url_str)))) {
        xnav->message('E', "Url is missing");
        return XNAV__SUCCESS;
      }

      if (ODD(dcli_get_qualifier("/FULLSCREEN", 0, 0)))
        options |= strm_mOptions_FullScreen;
      if (ODD(dcli_get_qualifier("/MAXIMIZE", 0, 0)))
        options |= strm_mOptions_Maximize;
      if (ODD(dcli_get_qualifier("/FULLMAXIMIZE", 0, 0)))
        options |= strm_mOptions_FullMaximize;
      if (ODD(dcli_get_qualifier("/ICONIFY", 0, 0)))
        options |= strm_mOptions_Iconify;
      if (is_video) {
        if (ODD(dcli_get_qualifier("/VIDEOCONTROLPANEL", 0, 0)))
          options |= strm_mOptions_VideoControlPanel;
        if (ODD(dcli_get_qualifier("/VIDEOPROGRESSBAR", 0, 0)))
          options |= strm_mOptions_VideoProgressBar;
      } else {
        if (ODD(dcli_get_qualifier("/CAMERACONTROLPANEL", 0, 0)))
          options |= strm_mOptions_CameraControlPanel;
      }

      if (ODD(dcli_get_qualifier("/WIDTH", tmp_str, sizeof(tmp_str)))) {
        nr = sscanf(tmp_str, "%d", &width);
        if (nr != 1) {
          xnav->message('E', "Syntax error in width");
          return XNAV__HOLDCOMMAND;
        }
      } else
        width = 0;

      if (ODD(dcli_get_qualifier("/HEIGHT", tmp_str, sizeof(tmp_str)))) {
        nr = sscanf(tmp_str, "%d", &height);
        if (nr != 1) {
          xnav->message('E', "Syntax error in height");
          return XNAV__HOLDCOMMAND;
        }
      } else
        height = 0;

      if (ODD(dcli_get_qualifier("/XPOSITION", tmp_str, sizeof(tmp_str)))) {
        nr = sscanf(tmp_str, "%d", &x);
        if (nr != 1) {
          xnav->message('E', "Syntax error in x coordinate");
          return XNAV__HOLDCOMMAND;
        }
      } else
        x = 0;

      if (ODD(dcli_get_qualifier("/YPOSITION", tmp_str, sizeof(tmp_str)))) {
        nr = sscanf(tmp_str, "%d", &y);
        if (nr != 1) {
          xnav->message('E', "Syntax error in y coordinate");
          return XNAV__HOLDCOMMAND;
        }
      } else
        y = 0;

      if (ODD(dcli_get_qualifier("/SCANTIME", tmp_str, sizeof(tmp_str)))) {
        nr = sscanf(tmp_str, "%f", &scantime);
        if (nr != 1) {
          xnav->message('E', "Syntax error in scantime");
          return XNAV__HOLDCOMMAND;
        }
      } else
        scantime = 0;

      XttStream* strmctx;

      if (xnav->appl.find(
              applist_eType_Stream, name_str, url_str, (void**)&strmctx)) {
        strmctx->pop();
      } else {
        strmctx = xnav->stream_new(name_str, url_str, width, height, x, y,
            scantime, options, 0, 0, &sts);
        if (EVEN(sts)) {
          xnav->message(' ', XNav::get_message(sts));
          return sts;
        }
        strmctx->close_cb = xnav_stream_close_cb;

        xnav->appl.insert(
            applist_eType_Stream, (void*)strmctx, pwr_cNOid, name_str, url_str);
      }
    }
    return XNAV__SUCCESS;
  } else if (str_NoCaseStrncmp(arg1_str, "TRACE", strlen(arg1_str)) == 0) {
    pwr_tOName name_str;
    char center_str[80];
    char* center_p;
    pwr_sAttrRef attrref;
    int is_attr;
    pwr_tObjid objid;
    int sts;

    // Command is "OPEN TRACE"
    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      sts = gdh_NameToObjid(name_str, &objid);
      if (EVEN(sts)) {
        xnav->message('E', "Object not found");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
        sts = gdh_NameToObjid(name_str, &objid);
        if (EVEN(sts)) {
          xnav->message('E', "Object not found");
          return XNAV__HOLDCOMMAND;
        }
      } else {
        sts = xnav->get_select(&attrref, &is_attr);
        if (EVEN(sts)) {
          xnav->message('E', "Enter name or select object");
          return XNAV__SUCCESS;
        }
        objid = attrref.Objid;
      }
    }

    if (ODD(dcli_get_qualifier("/CENTER", center_str, sizeof(center_str))))
      center_p = center_str;
    else
      center_p = NULL;

    xnav->start_trace(objid, center_p);
    return XNAV__SUCCESS;
  } else if (str_NoCaseStrncmp(arg1_str, "OPERATORWINDOW", strlen(arg1_str))
      == 0) {
    int sts;
    char opplace_str[80];

    if (!xnav->op) {
      if (xnav->ge_main || xnav->multiview_main) {
        xnav->message('E', "Main window alreay opened");
        return XNAV__HOLDCOMMAND;
      }
      if (EVEN(dcli_get_qualifier(
              "dcli_arg2", opplace_str, sizeof(opplace_str)))) {
        xnav->message('E', "Enter opplace");
        return XNAV__HOLDCOMMAND;
      }

      int closebutton = ODD(dcli_get_qualifier("/CLOSEBUTTON", 0, 0));

      strcpy(xnav->opplace_name, opplace_str);
      xnav->gbl.load_config(xnav);

      if (!xnav->gbl.hide_opwind) {
        xnav->op = xnav->op_new(opplace_str, &sts);
        if (EVEN(sts)) {
          delete xnav->op;
          xnav->op = NULL;
          xnav->message('E', "Unable to open operator window");
          return XNAV__SUCCESS;
        }
        xnav->op->command_cb = xnav_op_command_cb;
        xnav->op->close_cb = xnav_op_close_cb;
        xnav->op->help_cb = xnav_op_help_cb;
        xnav->op->map_cb = xnav_op_map_cb;
        xnav->op->get_alarm_info_cb = xnav_op_get_alarm_info_cb;
        xnav->op->ack_last_cb = xnav_op_ack_last_cb;
        xnav->op->is_authorized_cb = xnav->is_authorized_cb;

        if (closebutton)
          xnav->op->add_close_button();
        strcpy(xnav->opplace_name, opplace_str);
        xnav->op->set_title(xnav->user);
      }

      // Load eventlist
      if (xnav->ev) {
        delete ((XNav*)xnav)->ev;
        ((XNav*)xnav)->ev = NULL;
      }

      xnav->load_ev_from_opplace();
      xnav->appl_startup();
    } else {
      xnav->op->map();
    }
  } else if (str_NoCaseStrncmp(arg1_str, "JGRAPH", strlen(arg1_str)) == 0) {
    char arg2_str[80];
    pwr_tCmd command;

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      xnav->message('E', "Syntax error");
      return 1;
    }

    if (xnav->op) {
      strcpy(command, "open jgraph ");
      strcat(command, arg2_str);
      xnav->op->jop_command(command);
    } else
      xnav->message('E', "Java process not started");
  } else if (str_NoCaseStrncmp(arg1_str, "LOGGFILE", strlen(arg1_str)) == 0) {
    char file_str[80];
    char entry_str[80];
    int entry;
    int nr;

    if (ODD(dcli_get_qualifier("/ENTRY", entry_str, sizeof(entry_str)))) {
      if (!str_NoCaseStrcmp(entry_str, "CURRENT")) {
        if (xnav->current_logging_index == -1) {
          xnav->message('E', "No current logging entry");
          return XNAV__HOLDCOMMAND;
        }
        entry = xnav->current_logging_index + 1;
      } else {
        /* convert to integer */
        nr = sscanf(entry_str, "%d", &entry);
        if (nr != 1) {
          xnav->message('E', "Entry syntax error");
          return XNAV__HOLDCOMMAND;
        }
      }
      strcpy(file_str, xnav->logg[entry - 1].logg_filename);

      if (xnav->logg[entry - 1].active) {
        xnav->message('E', "Logging entry is active");
        return XNAV__HOLDCOMMAND;
      }
    } else if (EVEN(dcli_get_qualifier("/FILE", file_str, sizeof(file_str)))) {
      if (EVEN(dcli_get_qualifier("dcli_arg2", file_str, sizeof(file_str)))) {
        xnav->message('E', "Enter filename");
        return XNAV__HOLDCOMMAND;
      }
    }
    xnav->open_rttlog(file_str, file_str);
  } else if (str_NoCaseStrncmp(arg1_str, "TREND", strlen(arg1_str)) == 0) {
    pwr_tAName name_str;
    char* name_ptr;
    pwr_tAName title_str;
    pwr_sAttrRef aref_vect[11];
    int sts;
    pwr_tAName name_array[10];
    int i, names;
    int plotgroup_found = 0;
    pwr_sAttrRef plotgroup = pwr_cNAttrRef;
    pwr_tClassId classid;
    pwr_tObjid node_objid;
    pwr_tAName trend_name;
    XttTrend* trend;
    unsigned int options = 0;
    int width, height, nr;
    char tmp_str[40];

    // Command is "OPEN TREND"

    if (ODD(dcli_get_qualifier("/FULLSCREEN", 0, 0)))
      options |= curve_mOptions_FullScreen;
    if (ODD(dcli_get_qualifier("/MAXIMIZE", 0, 0)))
      options |= curve_mOptions_Maximize;
    if (ODD(dcli_get_qualifier("/FULLMAXIMIZE", 0, 0)))
      options |= curve_mOptions_FullMaximize;
    if (ODD(dcli_get_qualifier("/ICONIFY", 0, 0)))
      options |= curve_mOptions_Iconify;
    if (ODD(dcli_get_qualifier("/HIDE", 0, 0)))
      options |= curve_mOptions_Invisible;

    if (ODD(dcli_get_qualifier("/WIDTH", tmp_str, sizeof(tmp_str)))) {
      nr = sscanf(tmp_str, "%d", &width);
      if (nr != 1) {
        xnav->message('E', "Syntax error in width");
        return XNAV__HOLDCOMMAND;
      }
    } else
      width = 0;

    if (ODD(dcli_get_qualifier("/HEIGHT", tmp_str, sizeof(tmp_str)))) {
      nr = sscanf(tmp_str, "%d", &height);
      if (nr != 1) {
        xnav->message('E', "Syntax error in height");
        return XNAV__HOLDCOMMAND;
      }
    } else
      height = 0;

    /* Get the name qualifier */
    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (name_str[0] != '/')
        /* Assume that this is the namestring */
        name_ptr = name_str;
      else {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str))))
        name_ptr = name_str;
      else {
        /* Get the selected object */
        sts = xnav->get_current_aref(&aref_vect[0], name_str, sizeof(name_str),
            cdh_mName_path | cdh_mName_object | cdh_mName_attribute);
        if (EVEN(sts)) {
          xnav->message('E', "Enter name or select an object");
          return XNAV__SUCCESS;
        }
        name_ptr = name_str;
      }
    }

    // The name string can contain several trends separated by ','
    names = dcli_parse(name_str, ",", "", (char*)name_array,
        sizeof(name_array) / sizeof(name_array[0]), sizeof(name_array[0]), 0);

    for (i = 0; i < names; i++) {
      if (str_StartsWith(name_array[i], "*-")) {
        // Replace * by the node object
        sts = gdh_GetNodeObject(0, &node_objid);
        if (EVEN(sts))
          return sts;
        sts = gdh_ObjidToName(
            node_objid, trend_name, sizeof(trend_name), cdh_mNName);
        if (EVEN(sts))
          return sts;
        strcat(trend_name, &name_array[i][1]);
      } else
        strcpy(trend_name, name_array[i]);

      sts = gdh_NameToAttrref(pwr_cNObjid, trend_name, &aref_vect[i]);
      if (EVEN(sts)) {
        xnav->message('E', "Object not found");
        return XNAV__HOLDCOMMAND;
      }
      sts = gdh_GetAttrRefTid(&aref_vect[i], &classid);
      if (EVEN(sts))
        return sts;

      switch (classid) {
      case pwr_cClass_DsTrend:
        break;
      case pwr_cClass_DsTrendCurve:
        break;
      case pwr_cClass_PlotGroup:
        plotgroup = aref_vect[i];
        plotgroup_found = 1;
        if (i != 0) {
          xnav->message('E', "Error in object class");
          return XNAV__HOLDCOMMAND;
        }
        break;
      default:
        xnav->message('E', "Error in object class");
        return XNAV__HOLDCOMMAND;
      }
      if (plotgroup_found)
        break;
    }
    aref_vect[i] = pwr_cNAttrRef;

    if (EVEN(dcli_get_qualifier("/TITLE", title_str, sizeof(title_str)))) {
      if (plotgroup_found) {
        pwr_tAName attr;

        // Get title from plotgroup object
        strcpy(attr, trend_name);
        strcat(attr, ".Title");
        sts = gdh_GetObjectInfo(attr, &title_str, sizeof(title_str));
        if (EVEN(sts))
          return sts;
      } else
        strcpy(title_str, "Trend");
    }

    void* basewidget = 0;
    if (xnav->opplace_p->Options & pwr_mOpPlaceOptionsMask_AllMainTransient) {
      if (xnav->ge_main)
        basewidget = xnav->ge_main->get_widget();
      else if (xnav->multiview_main)
        basewidget = xnav->multiview_main->get_widget();
    }

    if (plotgroup_found) {
      if (xnav->appl.find(applist_eType_Trend, &plotgroup, (void**)&trend)) {
        trend->pop();
      } else {
        trend = xnav->xtttrend_new(title_str, NULL, &plotgroup, width, height,
            options, xnav->gbl.color_theme, basewidget, &sts);
        if (EVEN(sts))
          xnav->message('E', "Error in trend configuration");
        else {
          trend->close_cb = xnav_trend_close_cb;
          trend->help_cb = xnav_trend_command_cb;
          trend->help_cb = xnav_trend_help_cb;
          trend->command_cb = xnav_trend_command_cb;
          trend->get_select_cb = xnav_get_select_cb;
          xnav->appl.insert(
              applist_eType_Trend, (void*)trend, &plotgroup, "", NULL);
        }
      }
    } else {
      if (names == 1) {
        if (xnav->appl.find(
                applist_eType_Trend, &aref_vect[0], (void**)&trend)) {
          trend->pop();
        } else {
          trend = xnav->xtttrend_new(title_str, aref_vect, 0, width, height,
              options, xnav->gbl.color_theme, basewidget, &sts);
          if (EVEN(sts))
            xnav->message('E', "Error in trend configuration");
          else {
            trend->close_cb = xnav_trend_close_cb;
            trend->command_cb = xnav_trend_command_cb;
            trend->help_cb = xnav_trend_help_cb;
            trend->get_select_cb = xnav_get_select_cb;
            xnav->appl.insert(
                applist_eType_Trend, (void*)trend, &aref_vect[0], "", NULL);
          }
        }
      } else {
        trend = xnav->xtttrend_new(title_str, aref_vect, 0, width, height,
            options, xnav->gbl.color_theme, basewidget, &sts);
        if (ODD(sts)) {
          trend->close_cb = xnav_trend_close_cb;
          trend->command_cb = xnav_trend_command_cb;
          trend->help_cb = xnav_trend_help_cb;
          trend->get_select_cb = xnav_get_select_cb;
        }
      }
    }
  } else if (str_NoCaseStrncmp(arg1_str, "SHISTORY", strlen(arg1_str)) == 0) {
    pwr_tAName name_str;
    char* name_ptr;
    pwr_tOid oid, coid;
    pwr_tString80 cname[30];
    xnav_sHistList* ctx;
    pwr_tAttrRef aref;
    pwr_tStatus sts;
    pwr_tCid cid;
    int idx;

    /* Get the name qualifier */
    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (name_str[0] != '/')
        /* Assume that this is the namestring */
        name_ptr = name_str;
      else {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str))))
        name_ptr = name_str;
      else {
        /* Get the selected object */
        sts = xnav->get_current_aref(&aref, name_str, sizeof(name_str),
            cdh_mName_path | cdh_mName_object | cdh_mName_attribute);
        if (EVEN(sts)) {
          xnav->message('E', "Enter name or select an object");
          return XNAV__SUCCESS;
        }
        name_ptr = name_str;
      }
    }

    sts = gdh_NameToObjid(name_ptr, &oid);
    if (EVEN(sts)) {
      xnav->message('E', "Object not found");
      return XNAV__HOLDCOMMAND;
    }
    idx = 0;
    for (sts = gdh_GetChild(oid, &coid); ODD(sts);
         sts = gdh_GetNextSibling(coid, &coid)) {
      sts = gdh_GetObjectClass(coid, &cid);
      if (EVEN(sts))
        return sts;

      if (!(cid == pwr_cClass_SevHist || cid == pwr_cClass_SevHistObject))
        continue;

      sts = gdh_ObjidToName(
          coid, cname[idx], sizeof(cname[0]), cdh_mName_object);
      if (EVEN(sts))
        return sts;

      idx++;

      if (idx >= int(sizeof(cname) / sizeof(cname[0]) - 1))
        break;
    }
    strcpy(cname[idx], "");

    ctx = (xnav_sHistList*)calloc(1, sizeof(xnav_sHistList));
    ctx->oid = oid;
    ctx->xnav = xnav;
    xnav->wow->CreateList("History List", (char*)cname, sizeof(cname[0]),
        xnav_open_shist_cb, xnav_open_shist_cancel_cb, ctx);
  } else if (str_NoCaseStrncmp(arg1_str, "TCURVE", strlen(arg1_str)) == 0) {
    pwr_tAName name_str;
    char* name_ptr;
    pwr_tAttrRef aref_vect[2];
    pwr_tStatus sts;
    char title_str[80];
    unsigned int options = 0;
    int width, height, nr;
    char tmp_str[40];

    if (ODD(dcli_get_qualifier("/FULLSCREEN", 0, 0)))
      options |= curve_mOptions_FullScreen;
    if (ODD(dcli_get_qualifier("/MAXIMIZE", 0, 0)))
      options |= curve_mOptions_Maximize;
    if (ODD(dcli_get_qualifier("/FULLMAXIMIZE", 0, 0)))
      options |= curve_mOptions_FullMaximize;
    if (ODD(dcli_get_qualifier("/ICONIFY", 0, 0)))
      options |= curve_mOptions_Iconify;
    if (ODD(dcli_get_qualifier("/HIDE", 0, 0)))
      options |= curve_mOptions_Invisible;

    if (ODD(dcli_get_qualifier("/WIDTH", tmp_str, sizeof(tmp_str)))) {
      nr = sscanf(tmp_str, "%d", &width);
      if (nr != 1) {
        xnav->message('E', "Syntax error in width");
        return XNAV__HOLDCOMMAND;
      }
    } else
      width = 0;

    if (ODD(dcli_get_qualifier("/HEIGHT", tmp_str, sizeof(tmp_str)))) {
      nr = sscanf(tmp_str, "%d", &height);
      if (nr != 1) {
        xnav->message('E', "Syntax error in height");
        return XNAV__HOLDCOMMAND;
      }
    } else
      height = 0;

    if (EVEN(dcli_get_qualifier("/TITLE", title_str, sizeof(title_str)))) {
      strcpy(title_str, "Trend");
    }

    void* basewidget = 0;
    if (xnav->opplace_p->Options & pwr_mOpPlaceOptionsMask_AllMainTransient) {
      if (xnav->ge_main)
        basewidget = xnav->ge_main->get_widget();
      else if (xnav->multiview_main)
        basewidget = xnav->multiview_main->get_widget();
    }

    if (ODD(dcli_get_qualifier("/NEW", 0, 0))) {
      XttTCurve* tcurve = xnav->xtttcurve_new(title_str, 0, width, height,
          options, xnav->gbl.color_theme, basewidget, &sts);
      if (ODD(sts)) {
        tcurve->close_cb = xnav_tcurve_close_cb;
        tcurve->command_cb = xnav_trend_command_cb;
        tcurve->help_cb = xnav_tcurve_help_cb;
      }
      return XNAV__SUCCESS;
    }

    /* Get the name qualifier */
    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (name_str[0] != '/')
        /* Assume that this is the namestring */
        name_ptr = name_str;
      else {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str))))
        name_ptr = name_str;
      else {
        /* Get the selected object */
        sts = xnav->get_current_aref(&aref_vect[0], name_str, sizeof(name_str),
            cdh_mName_path | cdh_mName_object | cdh_mName_attribute);
        if (EVEN(sts)) {
          xnav->message('E', "Enter name or select an object");
          return XNAV__SUCCESS;
        }
        name_ptr = name_str;
      }
    }

    memset(aref_vect, 0, sizeof(aref_vect));
    sts = gdh_NameToAttrref(pwr_cNObjid, name_str, &aref_vect[0]);
    if (EVEN(sts)) {
      xnav->message('E', "Object not found");
      return XNAV__HOLDCOMMAND;
    }
    XttTCurve* tcurve = xnav->xtttcurve_new(title_str, aref_vect, width, height,
        options, xnav->gbl.color_theme, basewidget, &sts);
    if (ODD(sts)) {
      tcurve->close_cb = xnav_tcurve_close_cb;
      tcurve->command_cb = xnav_trend_command_cb;
      tcurve->help_cb = xnav_tcurve_help_cb;
    }
    return XNAV__SUCCESS;
  } else if (str_NoCaseStrncmp(arg1_str, "HISTORY", strlen(arg1_str)) == 0) {
    pwr_tAName name_str;
    char* name_ptr;
    pwr_tAName title_str;
    pwr_tAttrRef attr_aref, sevhist_aref, histthread_aref;
    pwr_tOid histthread_oid;
    char server_node[40];
    pwr_tOid oidv[11];
    pwr_tOName anamev[11];
    pwr_tOName onamev[11];
    bool sevhistobjectv[11];
    int oid_cnt = 0;
    int sts;
    pwr_tAName name_array[10];
    int i, names;
    int plotgroup_found = 0;
    int sevplotgroup_found = 0;
    int sevitem_found = 0;
    pwr_sAttrRef plotgroup = pwr_cNAttrRef;
    pwr_tClassId classid;
    pwr_tObjid node_objid;
    pwr_tAName hist_name;
    XttSevHist* hist;
    pwr_tAttrRef aref;
    pwr_tAName aname;
    char* s;
    bool sevHistObjectFound = false;
    pwr_tFileName file_str;
    unsigned int options = 0;
    int width, height, nr;
    char tmp_str[40];
    time_ePeriod period = time_ePeriod_;

    // Command is "OPEN HISTORY"
    for (i = 0; i < 11; i++) {
      strcpy(onamev[i], "");
      strcpy(anamev[i], "");
    }

    if (ODD(dcli_get_qualifier("/FULLSCREEN", 0, 0)))
      options |= curve_mOptions_FullScreen;
    if (ODD(dcli_get_qualifier("/MAXIMIZE", 0, 0)))
      options |= curve_mOptions_Maximize;
    if (ODD(dcli_get_qualifier("/FULLMAXIMIZE", 0, 0)))
      options |= curve_mOptions_FullMaximize;
    if (ODD(dcli_get_qualifier("/ICONIFY", 0, 0)))
      options |= curve_mOptions_Iconify;
    if (ODD(dcli_get_qualifier("/HIDE", 0, 0)))
      options |= curve_mOptions_Invisible;

    if (ODD(dcli_get_qualifier("/WIDTH", tmp_str, sizeof(tmp_str)))) {
      nr = sscanf(tmp_str, "%d", &width);
      if (nr != 1) {
        xnav->message('E', "Syntax error in width");
        return XNAV__HOLDCOMMAND;
      }
    } else
      width = 0;

    if (ODD(dcli_get_qualifier("/HEIGHT", tmp_str, sizeof(tmp_str)))) {
      nr = sscanf(tmp_str, "%d", &height);
      if (nr != 1) {
        xnav->message('E', "Syntax error in height");
        return XNAV__HOLDCOMMAND;
      }
    } else
      height = 0;

    void* basewidget = 0;
    if (xnav->opplace_p->Options & pwr_mOpPlaceOptionsMask_AllMainTransient) {
      if (xnav->ge_main)
        basewidget = xnav->ge_main->get_widget();
      else if (xnav->multiview_main)
        basewidget = xnav->multiview_main->get_widget();
    }

    if (ODD(dcli_get_qualifier("/FILE", file_str, sizeof(file_str)))) {
      // Open exported history file

      hist = xnav->xttsevhist_new(file_str, 0, 0, 0, 0, 0, file_str, width,
          height, options, xnav->gbl.color_theme, time_ePeriod_, basewidget,
          &sts);
      if (ODD(sts)) {
        hist->help_cb = xnav_sevhist_help_cb;
        hist->close_cb = xnav_sevhist_close_cb;
        // hist->get_select_cb = xnav_sevhist_get_select_cb;
        xnav->appl.insert(
            applist_eType_SevHist, (void*)hist, pwr_cNOid, "", NULL);
      }
      return XNAV__SUCCESS;
    }

    /* Get the name qualifier */
    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (name_str[0] != '/')
        /* Assume that this is the namestring */
        name_ptr = name_str;
      else {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str))))
        name_ptr = name_str;
      else {
        /* Get the selected object */
        sts = xnav->get_current_aref(&sevhist_aref, name_str, sizeof(name_str),
            cdh_mName_path | cdh_mName_object | cdh_mName_attribute);
        if (EVEN(sts)) {
          xnav->message('E', "Enter name or select an object");
          return XNAV__SUCCESS;
        }
        name_ptr = name_str;
      }
    }

    // The name string can contain several hists separated by ','
    names = dcli_parse(name_str, ",", "", (char*)name_array,
        sizeof(name_array) / sizeof(name_array[0]), sizeof(name_array[0]), 0);

    for (i = 0; i < names; i++) {
      if (str_StartsWith(name_array[i], "*-")) {
        // Replace * by the node object
        sts = gdh_GetNodeObject(0, &node_objid);
        if (EVEN(sts))
          return sts;
        sts = gdh_ObjidToName(
            node_objid, hist_name, sizeof(hist_name), cdh_mNName);
        if (EVEN(sts))
          return sts;
        strcat(hist_name, &name_array[i][1]);
      } else
        strcpy(hist_name, name_array[i]);

      sts = gdh_NameToAttrref(pwr_cNObjid, hist_name, &sevhist_aref);
      if (EVEN(sts)) {
        xnav->message('E', "Object not found");
        return XNAV__HOLDCOMMAND;
      }
      sts = gdh_GetAttrRefTid(&sevhist_aref, &classid);
      if (EVEN(sts))
        return sts;

      switch (classid) {
      case pwr_cClass_SevHist:
        break;
      case pwr_cClass_SevHistObject:
        sevHistObjectFound = true;
        break;
      case pwr_cClass_PlotGroup:
        plotgroup = sevhist_aref;
        plotgroup_found = 1;
        break;
      case pwr_cClass_SevPlotGroup:
        plotgroup = sevhist_aref;
        sevplotgroup_found = 1;
        break;
      case pwr_cClass_SevItemInt32:
      case pwr_cClass_SevItemFloat32:
      case pwr_cClass_SevItemBoolean:
        sevitem_found = 1;
        break;
      default:
        xnav->message('E', "Error in object class");
        return XNAV__HOLDCOMMAND;
      }

      if (sevitem_found) {
        pwr_sClass_SevItem item;
        sts = gdh_GetObjectInfoAttrref(&sevhist_aref, &item, sizeof(item));
        if (EVEN(sts))
          return sts;

        oidv[0] = item.Oid;
        oid_cnt = 1;
        sevhistobjectv[0] = item.NoOfAttr > 1;
        sevhistobjectv[1] = false;
        if (!sevhistobjectv[0]) {
          strcpy(anamev[0], item.Attr);
          strcpy(onamev[0], item.ObjectName);
        } else {
          char* s;
          pwr_tAName aname;
          s = strchr(item.ObjectName, '.');
          if (!s) {
            // It is a complete object
            aname[0] = '\0';
          } else {
            strcpy(aname, s + 1);
          }
          strcpy(anamev[0], aname);
        }
      } else if (plotgroup_found || sevplotgroup_found) {
        pwr_tAttrRef plot_objects[20];
        unsigned int plot_layout;
        int plot_timerange;
        pwr_tCid cid;
        int j;

        if (plotgroup_found) {
          pwr_sClass_PlotGroup plot;

          sts = gdh_GetObjectInfo(hist_name, &plot, sizeof(plot));
          if (EVEN(sts))
            return sts;

          memcpy(plot_objects, plot.YObjectName, sizeof(plot_objects));
          plot_layout = plot.Layout;
          plot_timerange = plot.TimeRange;
        } else {
          pwr_sClass_SevPlotGroup plot;

          sts = gdh_GetObjectInfo(hist_name, &plot, sizeof(plot));
          if (EVEN(sts))
            return sts;

          memset(plot_objects, 0, sizeof(plot_objects));
          for (j = 0; j < 20; j++) {
            if (!streq(plot.ObjectName[j], "")) {
              sts = gdh_NameToAttrref(
                  pwr_cNObjid, plot.ObjectName[j], &plot_objects[j]);
              if (EVEN(sts))
                continue;
            }
          }
          plot_layout = plot.Layout;
          plot_timerange = plot.TimeRange;
        }

        if (plot_layout & pwr_mCurveLayoutMask_AttrDescrFirst)
          options |= curve_mOptions_ShowDescrFirst;
        if (plot_layout & pwr_mCurveLayoutMask_CurveTypeLine)
          options |= curve_mOptions_CurveTypeLine;
        if (plot_layout & pwr_mCurveLayoutMask_CurveTypePoints)
          options |= curve_mOptions_CurveTypePoints;
        if (plot_layout & pwr_mCurveLayoutMask_CurveTypeLinePoints)
          options |= curve_mOptions_CurveTypeLinePoints;
        if (plot_layout & pwr_mCurveLayoutMask_CurveTypeSquare)
          options |= curve_mOptions_CurveTypeSquare;
        if (plot_layout & pwr_mCurveLayoutMask_FillCurve)
          options |= curve_mOptions_FillCurve;
        if (plot_layout & pwr_mCurveLayoutMask_SplitDigital)
          options |= curve_mOptions_SplitDigital;
        if (plot_layout & pwr_mCurveLayoutMask_LightBackground)
          options |= curve_mOptions_LightBackground;
        switch (plot_timerange) {
        case pwr_eTimeRangeEnum_Second:
          period = time_ePeriod_OneSecond;
          break;
        case pwr_eTimeRangeEnum_10Seconds:
          period = time_ePeriod_10Seconds;
          break;
        case pwr_eTimeRangeEnum_Minute:
          period = time_ePeriod_OneMinute;
          break;
        case pwr_eTimeRangeEnum_10Minutes:
          period = time_ePeriod_10Minutes;
          break;
        case pwr_eTimeRangeEnum_Hour:
          period = time_ePeriod_OneHour;
          break;
        case pwr_eTimeRangeEnum_Day:
          period = time_ePeriod_OneDay;
          break;
        case pwr_eTimeRangeEnum_Week:
          period = time_ePeriod_OneWeek;
          break;
        case pwr_eTimeRangeEnum_Month:
          period = time_ePeriod_OneMonth;
          break;
        case pwr_eTimeRangeEnum_Year:
          period = time_ePeriod_OneYear;
          break;
        default:;
        }

        for (j = 0; j < 20; j++) {
          if (cdh_ObjidIsNull(plot_objects[j].Objid))
            break;

          sevhist_aref = plot_objects[j];
          sts = gdh_GetAttrRefTid(&sevhist_aref, &cid);
          if (EVEN(sts))
            return sts;

          switch (cid) {
          case pwr_cClass_SevHist: {
            sts = gdh_ArefANameToAref(&sevhist_aref, "Attribute", &attr_aref);
            if (EVEN(sts))
              return sts;

            sts = gdh_GetObjectInfoAttrref(&attr_aref, &aref, sizeof(aref));
            if (EVEN(sts))
              return sts;

            sts = gdh_AttrrefToName(&aref, aname, sizeof(aname), cdh_mNName);
            if (EVEN(sts)) {
              xnav->message('E', "Error in SevHist configuration");
              return XNAV__HOLDCOMMAND;
            }
            s = strchr(aname, '.');
            if (!s) {
              xnav->message('E', "Error in SevHist configuration");
              return XNAV__HOLDCOMMAND;
            }

            *s = 0;
            strcpy(onamev[oid_cnt], aname);
            strcpy(anamev[oid_cnt], s + 1);
            oidv[oid_cnt] = aref.Objid;
            sevhistobjectv[oid_cnt] = false;
            oid_cnt++;

            break;
          }
          case pwr_cClass_SevHistObject: {
            sts = gdh_ArefANameToAref(&sevhist_aref, "Object", &attr_aref);
            if (EVEN(sts))
              return sts;

            sts = gdh_GetObjectInfoAttrref(&attr_aref, &aref, sizeof(aref));
            if (EVEN(sts))
              return sts;

            sts = gdh_AttrrefToName(&aref, aname, sizeof(aname), cdh_mNName);
            if (EVEN(sts)) {
              xnav->message('E', "Error in SevHist configuration");
              return XNAV__HOLDCOMMAND;
            }
            s = strchr(aname, '.');
            if (!s) {
              // It is a complete object
              anamev[oid_cnt][0] = '\0';
            } else {
              strcpy(anamev[oid_cnt], s + 1);
              *s = 0;
            }
            strcpy(onamev[oid_cnt], aname);
            oidv[oid_cnt] = aref.Objid;
            sevhistobjectv[oid_cnt] = true;
            oid_cnt++;
            break;
          }
          case pwr_cClass_SevItemBoolean:
          case pwr_cClass_SevItemFloat32:
          case pwr_cClass_SevItemInt32: {
            pwr_tOName oname;
            pwr_tOid oid;

            sts = gdh_ArefANameToAref(&sevhist_aref, "ObjectName", &attr_aref);
            if (EVEN(sts))
              return sts;

            sts = gdh_GetObjectInfoAttrref(&attr_aref, oname, sizeof(oname));
            if (EVEN(sts))
              return sts;

            sts = gdh_ArefANameToAref(&sevhist_aref, "Attr", &attr_aref);
            if (EVEN(sts))
              return sts;

            sts = gdh_GetObjectInfoAttrref(&attr_aref, aname, sizeof(aname));
            if (EVEN(sts))
              return sts;

            sts = gdh_ArefANameToAref(&sevhist_aref, "Oid", &attr_aref);
            if (EVEN(sts))
              return sts;

            sts = gdh_GetObjectInfoAttrref(&attr_aref, &oid, sizeof(oid));
            if (EVEN(sts))
              return sts;

            strncpy(onamev[oid_cnt], oname, sizeof(onamev[0]));
            strncpy(anamev[oid_cnt], aname, sizeof(anamev[0]));
            oidv[oid_cnt] = oid;
            sevhistobjectv[oid_cnt] = false;
            oid_cnt++;

            break;
          }
          default:;
          }
        }
        if (oid_cnt == 0) {
          xnav->message('E', "History objects in PlotGroup not found");
          return XNAV__SUCCESS;
        }
      } else if (sevHistObjectFound) {
        sts = gdh_ArefANameToAref(&sevhist_aref, "Object", &attr_aref);
        if (EVEN(sts))
          return sts;

        sts = gdh_GetObjectInfoAttrref(&attr_aref, &aref, sizeof(aref));
        if (EVEN(sts))
          return sts;

        sts = gdh_AttrrefToName(&aref, aname, sizeof(aname), cdh_mNName);
        if (EVEN(sts)) {
          xnav->message('E', "Error in SevHist configuration");
          return XNAV__HOLDCOMMAND;
        }
        s = strchr(aname, '.');
        if (!s) {
          // It is a complete object
          anamev[oid_cnt][0] = '\0';
        } else {
          strcpy(anamev[oid_cnt], s + 1);
        }
        oidv[oid_cnt] = aref.Objid;
        sevhistobjectv[oid_cnt] = true;
        strcpy(onamev[oid_cnt], "");
        oid_cnt++;
      } else {
        sts = gdh_ArefANameToAref(&sevhist_aref, "Attribute", &attr_aref);
        if (EVEN(sts))
          return sts;

        sts = gdh_GetObjectInfoAttrref(&attr_aref, &aref, sizeof(aref));
        if (EVEN(sts))
          return sts;

        sts = gdh_AttrrefToName(&aref, aname, sizeof(aname), cdh_mNName);
        if (EVEN(sts)) {
          xnav->message('E', "Error in SevHist configuration");
          return XNAV__HOLDCOMMAND;
        }
        s = strchr(aname, '.');
        if (!s) {
          xnav->message('E', "Error in SevHist configuration");
          return XNAV__HOLDCOMMAND;
        }

        strcpy(anamev[oid_cnt], s + 1);
        oidv[oid_cnt] = aref.Objid;
        sevhistobjectv[oid_cnt] = false;
        strcpy(onamev[oid_cnt], "");
        sts = gdh_ObjidToName(
            aref.Objid, onamev[oid_cnt], sizeof(onamev[0]), cdh_mNName);
        oid_cnt++;
      }

      // Get server and connect to server
      if (sevitem_found || sevplotgroup_found) {
        // Connect to local node
        syi_NodeName(&sts, server_node, sizeof(server_node));
      } else {
        sts = gdh_ArefANameToAref(&sevhist_aref, "ThreadObject", &attr_aref);
        if (EVEN(sts))
          return sts;

        sts = gdh_GetObjectInfoAttrref(
            &attr_aref, &histthread_oid, sizeof(histthread_oid));
        if (EVEN(sts))
          return sts;

        histthread_aref = cdh_ObjidToAref(histthread_oid);
        sts = gdh_ArefANameToAref(&histthread_aref, "ServerNode", &attr_aref);
        if (EVEN(sts)) {
          xnav->message('E', "Error in SevHist configuration");
          return XNAV__HOLDCOMMAND;
        }

        sts = gdh_GetObjectInfoAttrref(
            &attr_aref, server_node, sizeof(server_node));
        if (EVEN(sts))
          return sts;
      }

      xnav->scctx = sevcli_get_stored_ctx();
      if (!xnav->scctx) {
        sevcli_init(&sts, &xnav->scctx);
        if (EVEN(sts))
          return sts;
	sevcli_store_ctx(xnav->scctx);
      }
      sevcli_set_servernode(&sts, xnav->scctx, server_node);
      if (EVEN(sts))
        return sts;
    }
    oidv[oid_cnt] = pwr_cNOid;

    if (EVEN(dcli_get_qualifier("/TITLE", title_str, sizeof(title_str)))) {
      if (plotgroup_found || sevplotgroup_found) {
        pwr_tAName attr;

        // Get title from plotgroup object
        strcpy(attr, hist_name);
        strcat(attr, ".Title");
        sts = gdh_GetObjectInfo(attr, &title_str, sizeof(title_str));
        if (EVEN(sts))
          return sts;
      } else
        strcpy(title_str, "History");
    }

    xnav->set_clock_cursor();
    if (plotgroup_found || sevplotgroup_found || sevitem_found) {
      hist = xnav->xttsevhist_new(title_str, oidv, anamev, onamev,
          sevhistobjectv, xnav->scctx, 0, width, height, options,
          xnav->gbl.color_theme, period, basewidget, &sts);
      if (ODD(sts)) {
        hist->help_cb = xnav_sevhist_help_cb;
        hist->close_cb = xnav_sevhist_close_cb;
        if (sevitem_found)
          hist->get_select_cb = xnav_sevhist_get_select_cb;
        xnav->appl.insert(
            applist_eType_SevHist, (void*)hist, oidv[0], "", NULL);
      }
    } else {
      hist = xnav->xttsevhist_new(title_str, oidv, anamev, onamev,
          sevhistobjectv, xnav->scctx, 0, width, height, options,
          xnav->gbl.color_theme, time_ePeriod_, basewidget, &sts);
      if (ODD(sts)) {
        hist->help_cb = xnav_sevhist_help_cb;
        hist->close_cb = xnav_sevhist_close_cb;
        // hist->get_select_cb = xnav_sevhist_get_select_cb;
        xnav->appl.insert(
            applist_eType_SevHist, (void*)hist, oidv[0], "", NULL);
      }
    }
    xnav->reset_cursor();
  } else if (str_NoCaseStrncmp(arg1_str, "FAST", strlen(arg1_str)) == 0) {
    pwr_tAName name_str;
    char* name_ptr;
    pwr_tAName title_str;
    pwr_sAttrRef aref;
    int sts;
    pwr_tClassId classid;
    unsigned int options = 0;
    int width, height, nr;
    char tmp_str[40];
    pwr_tFileName file_str;

    // Command is "OPEN FAST"

    if (ODD(dcli_get_qualifier("/FULLSCREEN", 0, 0)))
      options |= curve_mOptions_FullScreen;
    if (ODD(dcli_get_qualifier("/MAXIMIZE", 0, 0)))
      options |= curve_mOptions_Maximize;
    if (ODD(dcli_get_qualifier("/FULLMAXIMIZE", 0, 0)))
      options |= curve_mOptions_FullMaximize;
    if (ODD(dcli_get_qualifier("/ICONIFY", 0, 0)))
      options |= curve_mOptions_Iconify;
    if (ODD(dcli_get_qualifier("/HIDE", 0, 0)))
      options |= curve_mOptions_Invisible;

    if (ODD(dcli_get_qualifier("/WIDTH", tmp_str, sizeof(tmp_str)))) {
      nr = sscanf(tmp_str, "%d", &width);
      if (nr != 1) {
        xnav->message('E', "Syntax error in width");
        return XNAV__HOLDCOMMAND;
      }
    } else
      width = 0;

    if (ODD(dcli_get_qualifier("/HEIGHT", tmp_str, sizeof(tmp_str)))) {
      nr = sscanf(tmp_str, "%d", &height);
      if (nr != 1) {
        xnav->message('E', "Syntax error in height");
        return XNAV__HOLDCOMMAND;
      }
    } else
      height = 0;

    void* basewidget = 0;
    if (xnav->opplace_p->Options & pwr_mOpPlaceOptionsMask_AllMainTransient) {
      if (xnav->ge_main)
        basewidget = xnav->ge_main->get_widget();
      else if (xnav->multiview_main)
        basewidget = xnav->multiview_main->get_widget();
    }

    if (ODD(dcli_get_qualifier("/FILE", file_str, sizeof(file_str)))) {
      // Open exported fast file
      XttFast* fast = xnav->xttfast_new(title_str, 0, width, height, 0,
          file_str, xnav->gbl.color_theme, basewidget, &sts);
      if (EVEN(sts))
        xnav->message('E', "Error in fast configuration");
      else {
        fast->close_cb = xnav_fast_close_cb;
        fast->help_cb = xnav_fast_help_cb;
      }
      return XNAV__SUCCESS;
    }

    /* Get the name qualifier */
    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (name_str[0] != '/')
        /* Assume that this is the namestring */
        name_ptr = name_str;
      else {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str))))
        name_ptr = name_str;
      else {
        /* Get the selected object */
        sts = xnav->get_current_aref(&aref, name_str, sizeof(name_str),
            cdh_mName_path | cdh_mName_object | cdh_mName_attribute);
        if (EVEN(sts)) {
          xnav->message('E', "Enter name or select an object");
          return XNAV__SUCCESS;
        }
        name_ptr = name_str;
      }
    }

    sts = gdh_NameToAttrref(pwr_cNObjid, name_str, &aref);
    if (EVEN(sts)) {
      xnav->message('E', "Object not found");
      return XNAV__HOLDCOMMAND;
    }
    sts = gdh_GetAttrRefTid(&aref, &classid);
    if (EVEN(sts))
      return sts;

    switch (classid) {
    case pwr_cClass_DsFastCurve:
      break;
    default:
      xnav->message('E', "Error in object class");
      return XNAV__HOLDCOMMAND;
    }

    if (EVEN(dcli_get_qualifier("/TITLE", title_str, sizeof(title_str)))) {
      strcpy(title_str, "");
    }

    XttFast* fast;
    if (xnav->appl.find(applist_eType_Fast, &aref, (void**)&fast)) {
      fast->pop();
    } else {
      fast = xnav->xttfast_new(title_str, &aref, width, height, options, 0,
          xnav->gbl.color_theme, basewidget, &sts);
      if (EVEN(sts))
        xnav->message('E', "Error in fast configuration");
      else {
        fast->close_cb = xnav_fast_close_cb;
        fast->help_cb = xnav_fast_help_cb;
        xnav->appl.insert(applist_eType_Fast, (void*)fast, &aref, "", NULL);
      }
    }
  } else if (str_NoCaseStrncmp(arg1_str, "PLOTGROUP", strlen(arg1_str)) == 0) {
    char cmd[430];
    pwr_tAName name_str;
    char* name_ptr;
    pwr_tAName title_str;
    pwr_sAttrRef aref;
    int sts;
    pwr_tClassId classid;
    int width = 0, height = 0, nr;
    char tmp_str[40];
    int fullscreen;
    int maximize;
    int fullmaximize;
    int iconify;
    int hide;
    pwr_tAName aname;
    pwr_tAttrRef yo;
    char type[20];
    int width_found;
    int height_found;
    int title_found;

    // Command is "OPEN PLOTGROUP"

    fullscreen = ODD(dcli_get_qualifier("/FULLSCREEN", 0, 0));
    maximize = ODD(dcli_get_qualifier("/MAXIMIZE", 0, 0));
    fullmaximize = ODD(dcli_get_qualifier("/FULLMAXIMIZE", 0, 0));
    iconify = ODD(dcli_get_qualifier("/ICONIFY", 0, 0));
    hide = ODD(dcli_get_qualifier("/HIDE", 0, 0));

    if (ODD(dcli_get_qualifier("/WIDTH", tmp_str, sizeof(tmp_str)))) {
      nr = sscanf(tmp_str, "%d", &width);
      if (nr != 1) {
        xnav->message('E', "Syntax error in width");
        return XNAV__HOLDCOMMAND;
      }
      width_found = 1;
    } else
      width_found = 0;

    if (ODD(dcli_get_qualifier("/HEIGHT", tmp_str, sizeof(tmp_str)))) {
      nr = sscanf(tmp_str, "%d", &height);
      if (nr != 1) {
        xnav->message('E', "Syntax error in height");
        return XNAV__HOLDCOMMAND;
      }
      height_found = 1;
    } else
      height_found = 0;

    /* Get the name qualifier */
    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (name_str[0] != '/')
        /* Assume that this is the namestring */
        name_ptr = name_str;
      else {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str))))
        name_ptr = name_str;
      else {
        /* Get the selected object */
        sts = xnav->get_current_aref(&aref, name_str, sizeof(name_str),
            cdh_mName_path | cdh_mName_object | cdh_mName_attribute);
        if (EVEN(sts)) {
          xnav->message('E', "Enter name or select an object");
          return XNAV__SUCCESS;
        }
        name_ptr = name_str;
      }
    }

    if (ODD(dcli_get_qualifier("/TITLE", title_str, sizeof(title_str))))
      title_found = 1;
    else
      title_found = 0;

    strcpy(aname, name_str);
    strcat(aname, ".YObjectName[0]");

    sts = gdh_GetObjectInfo(aname, (void*)&yo, sizeof(yo));
    if (EVEN(sts))
      return sts;

    if (cdh_ObjidIsNull(yo.Objid)) {
      xnav->message('E', "Error in plotgroup configuration");
      return XNAV__SUCCESS;
    }

    sts = gdh_GetAttrRefTid(&yo, &classid);
    if (EVEN(sts))
      return sts;

    switch (classid) {
    case pwr_cClass_DsTrend:
    case pwr_cClass_DsTrendCurve:
      strcpy(type, "trend");
      break;
    case pwr_cClass_DsFast:
    case pwr_cClass_DsFastCurve:
      strcpy(type, "fast");
      break;
    case pwr_cClass_SevHist:
    case pwr_cClass_SevHistObject:
      strcpy(type, "history");
      break;
      ;
    default:
      xnav->message('E', "Error in plotgroup configuration");
      return XNAV__SUCCESS;
    }

    sprintf(cmd, "open %s/name=%s", type, name_str);
    if (title_found)
      sprintf(&cmd[strlen(cmd)], "/title=\"%s\"", title_str);
    if (width_found)
      sprintf(&cmd[strlen(cmd)], "/width=%d", width);
    if (height_found)
      sprintf(&cmd[strlen(cmd)], "/height=%d", height);
    if (fullscreen)
      strcat(cmd, "/fullscr");
    if (maximize)
      strcat(cmd, "/maximiz");
    if (fullmaximize)
      strcat(cmd, "/fullmax");
    if (iconify)
      strcat(cmd, "/iconify");
    if (hide)
      strcat(cmd, "/hide");

    xnav->command(cmd);
  } else if (str_NoCaseStrncmp(arg1_str, "ATTRIBUTE", strlen(arg1_str)) == 0) {
    pwr_tAName name_str;
    char* name_ptr;
    char title_str[80];
    pwr_sAttrRef aref;
    int sts;
    pwr_tClassId classid;
    int bypass;

    // Command is "OPEN ATTRIBUTE"

    bypass = ODD(dcli_get_qualifier("/BYPASS", 0, 0));

    /* Get the name qualifier */
    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (name_str[0] != '/')
        /* Assume that this is the namestring */
        name_ptr = name_str;
      else {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str))))
        name_ptr = name_str;
      else {
        /* Get the selected object */
        sts = xnav->get_current_aref(&aref, name_str, sizeof(name_str),
            cdh_mName_path | cdh_mName_object | cdh_mName_attribute);
        if (EVEN(sts)) {
          xnav->message('E', "Enter name or select an object");
          return XNAV__SUCCESS;
        }
        name_ptr = name_str;
      }
    }

    sts = gdh_NameToAttrref(pwr_cNObjid, name_str, &aref);
    if (EVEN(sts)) {
      xnav->message('E', "Attribute not found");
      return XNAV__HOLDCOMMAND;
    }
    sts = gdh_GetAttrRefTid(&aref, &classid);
    if (EVEN(sts))
      return sts;

    if (EVEN(dcli_get_qualifier("/TITLE", title_str, sizeof(title_str)))) {
      strcpy(title_str, "Attribute");
    }

    XAttOne* xao;
    if (xnav->appl.find(applist_eType_AttrOne, &aref, (void**)&xao)) {
      xao->pop();
    } else {
      xao = xnav->xattone_new(
          &aref, title_str, bypass ? pwr_mPrv_RtWrite : ((pwr_mPrv) xnav->priv), &sts);
      if (EVEN(sts))
        xnav->message('E', "Unable to open attribute");
      else {
        xao->close_cb = xnav_xao_close_cb;
        xnav->appl.insert(applist_eType_AttrOne, (void*)xao, &aref, "", NULL);
      }
    }
  } else if (str_NoCaseStrncmp(arg1_str, "URL", strlen(arg1_str)) == 0) {
    char arg2_str[80];
    int sts;

    if (EVEN(dcli_get_qualifier("dcli_arg2", arg2_str, sizeof(arg2_str)))) {
      xnav->message('E', "Syntax error");
      return 1;
    }

    sts = xnav_open_URL(arg2_str);
    if (EVEN(sts))
      xnav->message(' ', XNav::get_message(sts));
  } else if (str_NoCaseStrncmp(arg1_str, "CONSOLELOG", strlen(arg1_str)) == 0) {
    int sts;

    if (xnav->clog)
      xnav->clog->pop();
    else {
      xnav->clog = xnav->clog_new("System Messages", &sts);
      if (EVEN(sts)) {
        delete xnav->clog;
        xnav->clog = 0;
        xnav->message('E', "Unable to open console log");
        return XNAV__SUCCESS;
      }
      xnav->clog->help_cb = xnav_ev_help_cb;
      xnav->clog->close_cb = xnav_clog_close_cb;
    }
  } else if (str_NoCaseStrncmp(arg1_str, "FILEVIEW", strlen(arg1_str)) == 0) {
    XttFileview* fileview;
    pwr_tFileName file_str;
    pwr_tFileName dir_str;
    pwr_tAName target_str;
    pwr_tAName trigger_str;
    char title_str[80];
    char type_str[80];
    char filetype_str[80];
    char* filetype_p = 0;
    int type;
    char* s;
    pwr_tAttrRef aref;
    pwr_tStatus sts;

    if (EVEN(dcli_get_qualifier("/FILE", dir_str, sizeof(dir_str)))) {
      xnav->message('E', "Enter file specification");
      return XNAV__HOLDCOMMAND;
    }
    if (EVEN(dcli_get_qualifier("/TARGET", target_str, sizeof(target_str)))) {
      xnav->message('E', "Enter target attribute");
      return XNAV__HOLDCOMMAND;
    }
    if (EVEN(
            dcli_get_qualifier("/TRIGGER", trigger_str, sizeof(trigger_str)))) {
      xnav->message('E', "Enter trigger attribute");
      return XNAV__HOLDCOMMAND;
    }
    if (ODD(dcli_get_qualifier("/TYPE", type_str, sizeof(type_str)))) {
      if (str_NoCaseStrcmp(type_str, "SAVE") == 0)
        type = fileview_eType_Save;
      else if (str_NoCaseStrcmp(type_str, "OPEN") == 0)
        type = fileview_eType_Open;
      else {
        xnav->message('E', "Type syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else
      type = fileview_eType_Open;

    if (ODD(dcli_get_qualifier("/FTYPE", filetype_str, sizeof(filetype_str))))
      filetype_p = filetype_str;

    if (EVEN(dcli_get_qualifier("/TITLE", title_str, sizeof(title_str)))) {
      if (type == fileview_eType_Open)
        strcpy(title_str, "Open File");
      else if (type == fileview_eType_Save)
        strcpy(title_str, "Save File");
    }

    if ((s = strrchr(dir_str, '/'))) {
      *s = 0;
      strcpy(file_str, s + 1);
    }

    sts = gdh_NameToAttrref(pwr_cNObjid, target_str, &aref);
    if (EVEN(sts)) {
      xnav->message('E', "Uable to find target object");
      return XNAV__HOLDCOMMAND;
    }

    fileview = xnav->fileview_new(aref.Objid, title_str, dir_str, file_str,
        type, target_str, trigger_str, filetype_p);
  } else if (str_NoCaseStrncmp(arg1_str, "NAVIGATOR", strlen(arg1_str)) == 0) {
    pwr_tAName object_str;
    pwr_tAttrRef aref;
    pwr_tStatus sts;
    void* basewidget = 0;

    if (ODD(dcli_get_qualifier("/OBJECT", object_str, sizeof(object_str)))) {
      sts = gdh_NameToAttrref(pwr_cNObjid, object_str, &aref);
      if (EVEN(sts)) {
        xnav->message('E', "Uable to find object");
        return XNAV__HOLDCOMMAND;
      }

      xnav->display_object(&aref, 0);
    }

    xnav->pop();

    if (xnav->opplace_p->Options & pwr_mOpPlaceOptionsMask_AllMainTransient) {
      if (xnav->ge_main)
        basewidget = xnav->ge_main->get_widget();
      else if (xnav->multiview_main)
        basewidget = xnav->multiview_main->get_widget();
      if (basewidget)
        xnav->set_transient(basewidget);
    }

  } else if (str_NoCaseStrncmp(arg1_str, "COLORTHEMESELECTOR", strlen(arg1_str))
      == 0) {
    gdh_sValueDef* vd;
    pwr_tString80 cname[30];
    pwr_tTid tid;
    int rows;
    int i;
    pwr_tOid oid;
    pwr_tStatus sts;

    sts = gdh_NameToObjid("pwrb:Type-ColorThemeEnum", &oid);
    if (EVEN(sts))
      return sts;
    tid = cdh_TypeObjidToId(oid);
    sts = gdh_GetEnumValueDef(tid, &vd, &rows);
    if (EVEN(sts))
      return sts;

    if (rows > int(sizeof(cname) / sizeof(cname[0])) - 1)
      rows = int(sizeof(cname) / sizeof(cname[0])) - 1;

    for (i = 0; i < rows; i++)
      strncpy(cname[i], vd[i].Name, sizeof(cname[0]));
    strcpy(cname[i], "");
    free(vd);

    xnav->wow->CreateList("ColorTheme Selector", (char*)cname, sizeof(cname[0]),
        xnav_colortheme_selector_ok_cb, 0, xnav);
  } else if (str_NoCaseStrncmp(arg1_str, "KEYBOARD", strlen(arg1_str)) == 0) {
    char keymap_str[80];
    char type_str[80];
    keyboard_eKeymap keymap;
    graph_eKeyboard type;

    if (ODD(dcli_get_qualifier("/KEYMAP", keymap_str, sizeof(keymap_str)))) {
      if (str_NoCaseStrcmp(keymap_str, "en_us") == 0)
        keymap = keyboard_eKeymap_Low_en_us;
      else if (str_NoCaseStrcmp(keymap_str, "sv_se") == 0)
        keymap = keyboard_eKeymap_Low_sv_se;
      else {
        xnav->message('E', "Unknown keymap");
        return XNAV__HOLDCOMMAND;
      }
    } else
      keymap = keyboard_eKeymap_;

    if (ODD(dcli_get_qualifier("/TYPE", type_str, sizeof(type_str)))) {
      if (str_NoCaseStrcmp(type_str, "standard") == 0)
        type = graph_eKeyboard_Standard;
      else if (str_NoCaseStrcmp(type_str, "numeric") == 0)
        type = graph_eKeyboard_Numeric;
      else if (str_NoCaseStrcmp(type_str, "alphabetic") == 0)
        type = graph_eKeyboard_Alphabetic;
      else {
        xnav->message('E', "Unknown type");
        return XNAV__HOLDCOMMAND;
      }
    } else
      type = graph_eKeyboard_Standard;

    xnav->open_keyboard(0, keymap, type);
  } else
    xnav->message('E', "Syntax error");

  return XNAV__SUCCESS;
}

static int xnav_close_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;

  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "GRAPH", strlen(arg1_str)) == 0) {
    pwr_tAName object_str;
    pwr_tAName instance_str;
    char* instance_p;
    int classgraph;
    int iconify;

    iconify = ODD(dcli_get_qualifier("/ICONIFY", 0, 0));

    if (ODD(dcli_get_qualifier(
            "/INSTANCE", instance_str, sizeof(instance_str))))
      instance_p = instance_str;
    else
      instance_p = 0;

    if (ODD(dcli_get_qualifier("/CLASSGRAPH", 0, 0))) {
      classgraph = 1;
      if (!instance_p) {
        xnav->message('E', "Instance is missing");
        return XNAV__HOLDCOMMAND;
      }
    } else
      classgraph = 0;

    if (ODD(dcli_get_qualifier("/OBJECT", object_str, sizeof(object_str)))) {
      pwr_tObjid objid;
      pwr_tAName xttgraph_name;
      int sts;
      pwr_sClass_XttGraph* xttgraph_p;
      char action[80];
      char* s;

      IF_NOGDH_RETURN;

      xnav_replace_node_str(xttgraph_name, object_str);

      sts = gdh_NameToObjid(xttgraph_name, &objid);
      if (EVEN(sts)) {
        xnav->message('E', "Object not found");
        return XNAV__HOLDCOMMAND;
      }

      sts = gdh_ObjidToPointer(objid, (void**)&xttgraph_p);
      if (EVEN(sts))
        return sts;

      str_ToLower(action, xttgraph_p->Action);
      if ((s = strstr(action, ".pwg"))) {
        *s = 0;
        xnav->close_graph(action, 0, iconify);
      }
    } else {
      char file_str[80];
      char fname[80];

      // Command is "CLOSE GRAPH"
      if (ODD(dcli_get_qualifier("dcli_arg2", file_str, sizeof(file_str)))) {
      } else if (classgraph) {
        // Get file from class of instance object
        pwr_tStatus sts;

        if (!instance_p) {
          xnav->message('E', "Enter instance object");
          return XNAV__HOLDCOMMAND;
        }

        sts = XNav::get_instance_classgraph(instance_p, file_str);
        if (EVEN(sts)) {
          xnav->message('E', XNav::get_message(sts));
          return XNAV__HOLDCOMMAND;
        }
      } else if (ODD(dcli_get_qualifier("/FILE", file_str, sizeof(file_str)))) {
        // Get base class graphs on $pwr_exe
        if (instance_p && (str_NoCaseStrncmp(fname, "pwr_c_", 6) == 0
                              || str_NoCaseStrncmp(fname, "pwr_t_", 6) == 0)) {
          strcpy(fname, "$pwr_exe/");
          strcat(fname, file_str);
          strcpy(file_str, fname);
        }
      } else {
        xnav->message('E', "Enter file");
        return XNAV__HOLDCOMMAND;
      }

      if (str_NoCaseStrcmp(file_str, "$current") == 0) {
        if (xnav->current_cmd_ctx) {
          if (iconify)
            ((XttGe*)xnav->current_cmd_ctx)->iconify();
          else {
            xnav->appl.remove((void*)xnav->current_cmd_ctx);
            delete (XttGe*)xnav->current_cmd_ctx;
            return GLOW__TERMINATED;
          }
        } else {
          xnav->message('E', "No current graph");
          return XNAV__SUCCESS;
        }
      }

      xnav->close_graph(file_str, instance_p, iconify);
      return XNAV__SUCCESS;
    }
  } else if (str_NoCaseStrncmp(arg1_str, "MULTIVIEW", strlen(arg1_str)) == 0) {
    pwr_tAName name_str;
    char* name_ptr;
    pwr_tAttrRef aref;
    int sts;
    pwr_tClassId classid;
    XttMultiView* mvctx;

    // Command is "CLOSE MULTIVIEW"

    /* Get the name qualifier */
    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (name_str[0] != '/')
        /* Assume that this is the namestring */
        name_ptr = name_str;
      else {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str))))
        name_ptr = name_str;
      else {
        xnav->message('E', "Enter name");
        return XNAV__SUCCESS;
      }
    }

    if (str_NoCaseStrcmp(name_str, "$current") == 0) {
      if (xnav->current_cmd_ctx) {
        xnav->appl.remove((void*)xnav->current_cmd_ctx);
        delete (XttMultiView*)xnav->current_cmd_ctx;
        return GLOW__TERMINATED;
      } else {
        xnav->message('E', "No current multiview");
        return XNAV__SUCCESS;
      }
    }

    xnav_replace_node_str(name_ptr, name_ptr);

    sts = gdh_NameToAttrref(pwr_cNObjid, name_ptr, &aref);
    if (EVEN(sts)) {
      xnav->message('E', "Object not found");
      return XNAV__HOLDCOMMAND;
    }
    sts = gdh_GetAttrRefTid(&aref, &classid);
    if (EVEN(sts))
      return sts;

    switch (classid) {
    case pwr_cClass_XttMultiView:
      break;
    default:
      xnav->message('E', "Error in object class");
      return XNAV__HOLDCOMMAND;
    }

    if (xnav->appl.find(applist_eType_MultiView, &aref, (void**)&mvctx)) {
      xnav->appl.remove((void*)mvctx);
      delete mvctx;
    }
  } else if (str_NoCaseStrncmp(arg1_str, "TREND", strlen(arg1_str)) == 0) {
    pwr_tAName name_str;
    char* name_ptr;
    pwr_tAttrRef aref;
    int sts;
    int plotgroup_found = 0;
    pwr_tClassId classid;
    pwr_tObjid node_objid;
    pwr_tOName trend_name;
    XttTrend* trend;

    // Command is "CLOSE TREND"

    /* Get the name qualifier */
    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (name_str[0] != '/')
        /* Assume that this is the namestring */
        name_ptr = name_str;
      else {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str))))
        name_ptr = name_str;
      else {
        xnav->message('E', "Enter name");
        return XNAV__SUCCESS;
      }
    }

    if (str_StartsWith(name_str, "*-")) {
      // Replace * by the node object
      sts = gdh_GetNodeObject(0, &node_objid);
      if (EVEN(sts))
        return sts;
      sts = gdh_ObjidToName(
          node_objid, trend_name, sizeof(trend_name), cdh_mNName);
      if (EVEN(sts))
        return sts;
      strcat(trend_name, &name_str[1]);
    } else
      strcpy(trend_name, name_str);

    sts = gdh_NameToAttrref(pwr_cNObjid, trend_name, &aref);
    if (EVEN(sts)) {
      xnav->message('E', "Object not found");
      return XNAV__HOLDCOMMAND;
    }
    sts = gdh_GetAttrRefTid(&aref, &classid);
    if (EVEN(sts))
      return sts;

    switch (classid) {
    case pwr_cClass_PlotGroup:
    case pwr_cClass_DsTrend:
    case pwr_cClass_DsTrendCurve:
      plotgroup_found = 1;
      break;
    default:
      xnav->message('E', "Error in object class");
      return XNAV__HOLDCOMMAND;
    }

    if (plotgroup_found) {
      if (xnav->appl.find(applist_eType_Trend, &aref, (void**)&trend)) {
        xnav->appl.remove((void*)trend);
        delete trend;
      }
    }
  } else if (str_NoCaseStrncmp(arg1_str, "ALARMLIST", strlen(arg1_str)) == 0) {
    if (xnav->ev && xnav->ev->is_mapped_ala())
      xnav->ev->unmap_ala();
  } else if (str_NoCaseStrncmp(arg1_str, "EVENTLIST", strlen(arg1_str)) == 0) {
    if (xnav->ev && xnav->ev->is_mapped_eve())
      xnav->ev->unmap_eve();
  } else if (str_NoCaseStrncmp(arg1_str, "NAVIGATOR", strlen(arg1_str)) == 0) {
    if (xnav->close_cb)
      (xnav->close_cb)(xnav->parent_ctx,
          xnav->op || xnav->ge_main || xnav->multiview_main ? 0 : 1);
  } else if (str_NoCaseStrncmp(arg1_str, "ALL", strlen(arg1_str)) == 0) {
    char except_str[400];
    char name_array[20][80];
    char mvname_array[10][200];
    int names;
    int mvnames;
    pwr_tAttrRef mv_aref_array[10];
    ApplListElem *elem, *next_elem;
    applist_eType type;
    XttMultiView* mvctx;
    int keep;
    int i;
    pwr_tStatus sts;
    int except_current = 0;

    // Close everything

    if (ODD(dcli_get_qualifier("/EXCEPT", except_str, sizeof(except_str)))) {
      // The except string can contain several items separated by ','
      names = dcli_parse(except_str, ",", "", (char*)name_array,
          sizeof(name_array) / sizeof(name_array[0]), sizeof(name_array[0]), 0);
      for (int i = 0; i < names; i++) {
        if (streq(name_array[i], "$current")) {
          except_current = 1;
          break;
        }
      }
    } else
      names = 0;

    if (ODD(dcli_get_qualifier("/MVEXCEPT", except_str, sizeof(except_str)))) {
      // The except string can contain several items separated by ','
      mvnames = dcli_parse(except_str, ",", "", (char*)mvname_array,
          sizeof(mvname_array) / sizeof(mvname_array[0]),
          sizeof(mvname_array[0]), 0);
      for (int i = 0; i < mvnames; i++) {
        if (streq(mvname_array[i], "$current")) {
          except_current = 1;
        } else {
          sts = gdh_NameToAttrref(
              pwr_cNObjid, mvname_array[i], &mv_aref_array[i]);
          if (EVEN(sts)) {
            xnav->message('E', "No such multiview");
            return XNAV__HOLDCOMMAND;
          }
        }
      }
    } else
      mvnames = 0;

    // Close graphs
    type = applist_eType_Graph;
    for (elem = xnav->appl.root; elem;) {
      if (elem->type == type) {
        keep = 0;
        if (except_current && elem->ctx == xnav->current_cmd_ctx) {
          keep = 1;
        } else {
          for (i = 0; i < names; i++) {
            if (str_NoCaseStrcmp(name_array[i], elem->name) == 0) {
              keep = 1;
              break;
            }
          }
        }
        if (keep) {
          elem = elem->next;
          continue;
        }
        next_elem = elem->next;
        xnav->close_graph(elem->name, elem->instance, 0);
        elem = next_elem;
        continue;
      }
      elem = elem->next;
    }

    // Close multiviews
    type = applist_eType_MultiView;
    for (elem = xnav->appl.root; elem;) {
      if (elem->type == type) {
        keep = 0;
        if (except_current && elem->ctx == xnav->current_cmd_ctx) {
          keep = 1;
        } else {
          for (i = 0; i < mvnames; i++) {
            if (cdh_ObjidIsEqual(mv_aref_array[i].Objid, elem->aref.Objid)
                && mv_aref_array[i].Offset == elem->aref.Offset) {
              keep = 1;
              break;
            }
          }
        }
        if (keep) {
          elem = elem->next;
          continue;
        }
        next_elem = elem->next;
        mvctx = (XttMultiView*)elem->ctx;
        xnav->appl.remove((void*)mvctx);
        delete mvctx;
        elem = next_elem;
        continue;
      }
      elem = elem->next;
    }

    // Close all trends
    type = applist_eType_Trend;
    for (elem = xnav->appl.root; elem;) {
      if (elem->type == type) {
        next_elem = elem->next;
        delete (XttTrend*)elem->ctx;
        xnav->appl.remove(elem->ctx);
        elem = next_elem;
        continue;
      }
      elem = elem->next;
    }

    // Close all trends
    type = applist_eType_Fast;
    for (elem = xnav->appl.root; elem;) {
      if (elem->type == type) {
        next_elem = elem->next;
        delete (XttFast*)elem->ctx;
        xnav->appl.remove(elem->ctx);
        elem = next_elem;
        continue;
      }
      elem = elem->next;
    }

    // Close all hists
    type = applist_eType_Hist;
    for (elem = xnav->appl.root; elem;) {
      if (elem->type == type) {
        next_elem = elem->next;
        delete (Hist*)elem->ctx;
        xnav->appl.remove(elem->ctx);
        elem = next_elem;
        continue;
      }
      elem = elem->next;
    }

    // Close navigator
    keep = 0;
    for (i = 0; i < names; i++) {
      if (str_NoCaseStrcmp(name_array[i], "NAVIGATOR") == 0) {
        keep = 1;
        break;
      }
    }
    if (!keep) {
      if (xnav->close_cb)
        (xnav->close_cb)(xnav->parent_ctx, 0);
    }

    // Close alarmlist
    keep = 0;
    for (i = 0; i < names; i++) {
      if (str_NoCaseStrcmp(name_array[i], "ALARMLIST") == 0) {
        keep = 1;
        break;
      }
    }
    if (!keep) {
      if (xnav->ev && xnav->ev->is_mapped_ala())
        xnav->ev->unmap_ala();
    }

    // Close eventlist
    keep = 0;
    for (i = 0; i < names; i++) {
      if (str_NoCaseStrcmp(name_array[i], "EVENTLIST") == 0) {
        keep = 1;
        break;
      }
    }
    if (!keep) {
      if (xnav->ev && xnav->ev->is_mapped_eve())
        xnav->ev->unmap_eve();
    }
  } else if (str_NoCaseStrncmp(arg1_str, "TRACE", strlen(arg1_str)) == 0) {
    RtTrace* tractx;
    pwr_tOName name_str;
    pwr_tStatus sts;
    pwr_tCid cid;
    pwr_tOid window_oid, oid;

    if (EVEN(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (EVEN(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
        if (EVEN(xnav->get_current_object(&oid, name_str, sizeof(name_str),
                cdh_mName_path | cdh_mName_object | cdh_mName_attribute))) {
          xnav->message('E', "Enter name or select an object");
          return XNAV__SUCCESS;
        }
      }
    }

    sts = gdh_NameToObjid(name_str, &oid);
    if (EVEN(sts)) {
      xnav->message('E', "No such object");
      return XNAV__SUCCESS;
    }

    sts = gdh_GetObjectClass(oid, &cid);
    if (EVEN(sts))
      return sts;

    if (cid == pwr_cClass_plc) {
      // Take the first child
      sts = gdh_GetChild(oid, &window_oid);
      if (EVEN(sts))
        return sts;
    } else
      window_oid = oid;

    if (xnav->appl.find(applist_eType_Trace, window_oid, (void**)&tractx)) {
      xnav->appl.remove((void*)tractx);
      delete tractx;
    }
  } else
    xnav->message('E', "Syntax error");

  return XNAV__SUCCESS;
}

static void xnav_ge_help_cb(void* ctx, const char* key)
{
  XNav* xnav = (XNav*)ctx;
  int sts;

  sts = CoXHelp::dhelp(key, "", navh_eHelpFile_Project, NULL, 0);
  if (EVEN(sts))
    sts = CoXHelp::dhelp("graph window", "", navh_eHelpFile_Base, NULL, 0);
  if (EVEN(sts))
    xnav->message('E', "Unable to find topic");
  else
    xnav->message(' ', null_str);
}

static int xnav_multiview_command_cb(
    void* ctx, char* command, char* script, void* caller)
{
  ((XNav*)ctx)->current_cmd_ctx = caller;
  if (command)
    ((XNav*)ctx)->command(command);
  else if (script)
    ((XNav*)ctx)->script(command);
  ((XNav*)ctx)->current_cmd_ctx = 0;
  return ((XNav*)ctx)->get_command_sts();
}

static int xnav_ge_command_cb(
    void* ctx, char* command, char* script, void* caller)
{
  ((XNav*)ctx)->current_cmd_ctx = caller;
  if (command)
    ((XNav*)ctx)->command(command);
  else if (script) {
    ((XNav*)ctx)->script(script);
  }
  ((XNav*)ctx)->current_cmd_ctx = 0;
  return ((XNav*)ctx)->get_command_sts();
}

static void xnav_ge_close_cb(void* nav, void* ctx)
{
  XNav* xnav = (XNav*)nav;

  if (ctx == xnav->ge_main) {
    if (xnav->close_cb)
      (xnav->close_cb)(xnav->parent_ctx, 1);
    else
      exit(0);
  } else {
    if (xnav->keyboard_owner == ctx)
      xnav->close_keyboard(keyboard_mAction_Close);

    xnav->appl.remove((void*)ctx);
  }
}

static void xnav_multiview_close_cb(void* nav, void* ctx)
{
  XNav* xnav = (XNav*)nav;

  if (ctx == xnav->multiview_main) {
    if (xnav->close_cb)
      (xnav->close_cb)(xnav->parent_ctx, 1);
    else
      exit(0);
  } else
    xnav->appl.remove((void*)ctx);
}

static void xnav_stream_close_cb(void* nav, XttStream* ctx)
{
  XNav* xnav = (XNav*)nav;

  xnav->appl.remove((void*)ctx);
}

// new code Jonas Nylund 030131
static void xnav_hist_close_cb(void* ctx)
{
  ((XNav*)((Hist*)ctx)->parent_ctx)->appl.remove((void*)ctx);
  delete (Hist*)ctx;
}
// end new code Jonas Nylund 030131

static void xnav_trend_close_cb(void* ctx, XttTrend* trend)
{
  XNav* xnav = (XNav*)ctx;

  xnav->appl.remove((void*)trend);
  delete trend;
}

static void xnav_trend_command_cb(void* ctx, const char* cmd)
{
  XNav* xnav = (XNav*)ctx;

  xnav->command((char*)cmd);
}

static void xnav_trend_help_cb(void* ctx, const char* key)
{
  XNav* xnav = (XNav*)ctx;

  int sts;

  sts = CoXHelp::dhelp(key, "", navh_eHelpFile_Base, NULL, 0);
  if (EVEN(sts))
    xnav->message('E', "Unable to find topic");
  else
    xnav->message(' ', null_str);
}

static void xnav_tcurve_close_cb(void* ctx, XttTCurve* trend)
{
  XNav* xnav = (XNav*)ctx;

  xnav->appl.remove((void*)trend);
  delete trend;
}

static void xnav_tcurve_help_cb(void* ctx, const char* key)
{
  XNav* xnav = (XNav*)ctx;

  int sts;

  sts = CoXHelp::dhelp(key, "", navh_eHelpFile_Base, NULL, 0);
  if (EVEN(sts))
    xnav->message('E', "Unable to find topic");
  else
    xnav->message(' ', null_str);
}

static void xnav_sevhist_help_cb(void* ctx, const char* key)
{
  XNav* xnav = (XNav*)ctx;

  int sts;

  sts = CoXHelp::dhelp(key, "", navh_eHelpFile_Base, NULL, 0);
  if (EVEN(sts))
    xnav->message('E', "Unable to find topic");
  else
    xnav->message(' ', null_str);
}

static void xnav_sevhist_close_cb(void* ctx, XttSevHist* hist)
{
  XNav* xnav = (XNav*)ctx;

  xnav->appl.remove((void*)hist);
  delete hist;
}

static int xnav_sevhist_get_select_cb(
    void* ctx, pwr_tOid* oid, char* aname, char* oname)
{
  XNav* xnav = (XNav*)ctx;
  pwr_tAttrRef sel_aref, attr_aref, aref;
  int is_attr;
  int sts;
  pwr_tAName name;
  pwr_tCid cid;
  pwr_tAName arefname;
  pwr_tOName attrname;
  char* s;
  pwr_tOid ch;

  sts = xnav->get_select(&sel_aref, &is_attr);
  if (EVEN(sts))
    return sts;

  sts = gdh_ObjidToName(sel_aref.Objid, name, sizeof(name), cdh_mNName);
  if (EVEN(sts))
    return sts;

  sts = gdh_GetObjectClass(sel_aref.Objid, &cid);
  switch (cid) {
  case pwr_cClass_SevHist:
  case pwr_cClass_SevItemFloat32:
  case pwr_cClass_SevItemInt32:
  case pwr_cClass_SevItemBoolean:
    break;
  case pwr_cClass_SevHistObject:
    return 0; // NYI
  default:
    // Look for a SevHist child
    for (sts = gdh_GetChild(sel_aref.Objid, &ch); ODD(sts);
         sts = gdh_GetNextSibling(ch, &ch)) {
      sts = gdh_GetObjectClass(ch, &cid);
      if (EVEN(sts))
        return sts;

      switch (cid) {
      case pwr_cClass_SevHist:
      case pwr_cClass_SevItemFloat32:
      case pwr_cClass_SevItemInt32:
      case pwr_cClass_SevItemBoolean:
        sel_aref = cdh_ObjidToAref(ch);
        break;
      default:
        return 0;
      }
    }
  }

  switch (cid) {
  case pwr_cClass_SevHist:
    sts = gdh_ArefANameToAref(&sel_aref, "Attribute", &attr_aref);
    if (EVEN(sts))
      return sts;

    sts = gdh_GetObjectInfoAttrref(&attr_aref, &aref, sizeof(aref));
    if (EVEN(sts))
      return sts;

    sts = gdh_AttrrefToName(&aref, arefname, sizeof(arefname), cdh_mNName);
    if (EVEN(sts))
      return sts;

    s = strchr(arefname, '.');
    if (!s)
      return 0;

    *s = 0;

    strcpy(oname, arefname);
    strcpy(aname, s + 1);
    *oid = aref.Objid;
    break;
  case pwr_cClass_SevItemFloat32:
  case pwr_cClass_SevItemInt32:
  case pwr_cClass_SevItemBoolean:
    sts = gdh_ArefANameToAref(&sel_aref, "ObjectName", &attr_aref);
    if (EVEN(sts))
      return sts;

    sts = gdh_GetObjectInfoAttrref(&attr_aref, &arefname, sizeof(arefname));
    if (EVEN(sts))
      return sts;

    sts = gdh_ArefANameToAref(&sel_aref, "Attr", &attr_aref);
    if (EVEN(sts))
      return sts;

    sts = gdh_GetObjectInfoAttrref(&attr_aref, &attrname, sizeof(attrname));
    if (EVEN(sts))
      return sts;

    sts = gdh_ArefANameToAref(&sel_aref, "Oid", &attr_aref);
    if (EVEN(sts))
      return sts;

    sts = gdh_GetObjectInfoAttrref(&attr_aref, oid, sizeof(*oid));
    if (EVEN(sts))
      return sts;

    strcpy(oname, arefname);
    strcpy(aname, attrname);
    break;
  }

  return XNAV__SUCCESS;
}

static int xnav_get_select_cb(void* ctx, pwr_tAttrRef* aref, int* is_attr)
{
  XNav* xnav = (XNav*)ctx;

  return xnav->get_select(aref, is_attr);
}

static void xnav_fast_close_cb(void* ctx, XttFast* fast)
{
  XNav* xnav = (XNav*)ctx;

  xnav->appl.remove((void*)fast);
  delete fast;
}

static void xnav_fast_help_cb(void* ctx, const char* key)
{
  XNav* xnav = (XNav*)ctx;

  int sts;

  sts = CoXHelp::dhelp(key, "", navh_eHelpFile_Base, NULL, 0);
  if (EVEN(sts))
    xnav->message('E', "Unable to find topic");
  else
    xnav->message(' ', null_str);
}

static void xnav_xao_close_cb(void* ctx, XAttOne* xao)
{
  XNav* xnav = (XNav*)ctx;

  xnav->appl.remove((void*)xao);
  delete xao;
}

static int xnav_create_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;

  int sts;
  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "ITEM", strlen(arg1_str)) == 0) {
    char text_str[80];
    char destination_str[80];
    char* destination_p = destination_str;
    char command_str[80];
    char pixmap_str[80];
    menu_ePixmap pixmap;
    int dest_code;
    int item_type = 0;
    xnav_sMenu* menu_item;

    // Command is "CREATE ITEM"
    if (ODD(dcli_get_qualifier("dcli_arg2", text_str, sizeof(text_str)))) {
      if (text_str[0] == '/') {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else if (EVEN(dcli_get_qualifier("/TEXT", text_str, sizeof(text_str)))) {
      xnav->message('E', "Enter text");
      return XNAV__HOLDCOMMAND;
    }
    if (EVEN(dcli_get_qualifier(
            "/DESTINATION", destination_str, sizeof(destination_str)))) {
      xnav->message('E', "Enter destination");
      return XNAV__HOLDCOMMAND;
    }
    if (streq(destination_str, ""))
      destination_p = 0;
    if (ODD(dcli_get_qualifier("/COMMAND", command_str, sizeof(command_str))))
      item_type = xnav_eItemType_Command;
    if (ODD(dcli_get_qualifier("/MENU", 0, 0)))
      item_type = xnav_eItemType_Menu;
    if (ODD(dcli_get_qualifier("/AFTER", 0, 0)))
      dest_code = xnav_eDestCode_After;
    else if (ODD(dcli_get_qualifier("/BEFORE", 0, 0)))
      dest_code = xnav_eDestCode_Before;
    else if (ODD(dcli_get_qualifier("/FIRSTCHILD", 0, 0)))
      dest_code = xnav_eDestCode_FirstChild;
    else if (ODD(dcli_get_qualifier("/LASTCHILD", 0, 0)))
      dest_code = xnav_eDestCode_LastChild;
    else
      dest_code = xnav_eDestCode_After;

    if (ODD(dcli_get_qualifier("/PIXMAP", pixmap_str, sizeof(pixmap_str)))) {
      if (str_NoCaseStrcmp(pixmap_str, "MAP") == 0)
        pixmap = menu_ePixmap_Map;
      else if (str_NoCaseStrcmp(pixmap_str, "GRAPH") == 0)
        pixmap = menu_ePixmap_Graph;
      else if (str_NoCaseStrcmp(pixmap_str, "SCRIPT") == 0)
        pixmap = menu_ePixmap_Script;
      else if (str_NoCaseStrcmp(pixmap_str, "LIST") == 0)
        pixmap = menu_ePixmap_List;
      else if (str_NoCaseStrcmp(pixmap_str, "LEAF") == 0)
        pixmap = menu_ePixmap_Leaf;
      else
        pixmap = menu_ePixmap_Map;
    } else
      pixmap = menu_ePixmap_Map;

    sts = xnav->menu_tree_insert(text_str, item_type, command_str, pixmap,
        destination_p, dest_code, &menu_item);
    if (EVEN(sts))
      xnav->message('E', "Destination not found");

    return XNAV__SUCCESS;
  } else if (str_NoCaseStrncmp(arg1_str, "OPMENUITEM", strlen(arg1_str)) == 0) {
    char name_str[80];
    pwr_tCmd command_str;
    char pixmap_str[80];
    int pixmap;
    int append = 1;

    // Command is "CREATE OPMENUITEM"
    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (name_str[0] == '/') {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else if (EVEN(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
      xnav->message('E', "Enter name");
      return XNAV__HOLDCOMMAND;
    }
    if (EVEN(
            dcli_get_qualifier("/COMMAND", command_str, sizeof(command_str)))) {
      xnav->message('E', "Enter name");
      return XNAV__HOLDCOMMAND;
    }

    if (ODD(dcli_get_qualifier("/PIXMAP", pixmap_str, sizeof(pixmap_str)))) {
      if (str_NoCaseStrcmp(pixmap_str, "GRAPH") == 0)
        pixmap = wow_ePixmap_Graph;
      else
        pixmap = wow_ePixmap_No;
    } else
      pixmap = wow_ePixmap_No;

    if (ODD(dcli_get_qualifier("/BEFORE", 0, 0)))
      append = 0;

    if (xnav->op) {
      sts = xnav->op->create_menu_item(name_str, pixmap, append, command_str);
      if (EVEN(sts))
        xnav->message('E', "Unable to create op menu item");
    }
    return XNAV__SUCCESS;
  } else if (str_NoCaseStrncmp(arg1_str, "OBJECT", strlen(arg1_str)) == 0) {
    // Command is "CREATE OBJECT"

    pwr_tOName name_str;
    pwr_tObjName class_str;

    IF_NOGDH_RETURN;

    // Check authorization
    if (!((xnav->priv & pwr_mPrv_RtWrite) || (xnav->priv & pwr_mPrv_System))) {
      xnav->message('E', "Not authorized for this operation");
      return 0;
    }

    if (EVEN(dcli_get_qualifier("/CLASS", class_str, sizeof(class_str)))) {
      xnav->message('E', "Enter class");
      return XNAV__HOLDCOMMAND;
    }

    if (EVEN(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
      xnav->message('E', "Enter name");
      return XNAV__HOLDCOMMAND;
    }

    sts = xnav->create_object(class_str, name_str);
    return sts;
  } else
    xnav->message('E', "Syntax error");

  return XNAV__SUCCESS;
}

static int xnav_delete_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;

  int sts;
  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "ITEM", strlen(arg1_str)) == 0) {
    char name_str[80];

    // Command is "DELETE ITEM"
    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (name_str[0] == '/') {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else if (EVEN(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
      xnav->message('E', "Enter name");
      return XNAV__HOLDCOMMAND;
    }

    sts = xnav->menu_tree_delete(name_str);
    if (EVEN(sts))
      xnav->message('E', "Item not found");

    return XNAV__SUCCESS;
  } else if (str_NoCaseStrncmp(arg1_str, "OPMENUITEM", strlen(arg1_str)) == 0) {
    char name_str[80];

    // Command is "DELETE OPMENUITEM"
    if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str)))) {
      if (name_str[0] == '/') {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else if (EVEN(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
      xnav->message('E', "Enter name");
      return XNAV__HOLDCOMMAND;
    }

    if (xnav->op) {
      sts = xnav->op->delete_menu_item(name_str);
      if (EVEN(sts))
        xnav->message('E', "Unable to delete op menu item");
    }
    return XNAV__SUCCESS;
  } else if (str_NoCaseStrncmp(arg1_str, "OBJECT", strlen(arg1_str)) == 0) {
    // Command is "DELETE OBJECT"

    char name_str[80];

    IF_NOGDH_RETURN;

    // Check authorization
    if (!((xnav->priv & pwr_mPrv_RtWrite) || (xnav->priv & pwr_mPrv_System))) {
      xnav->message('E', "Not authorized for this operation");
      return 0;
    }

    if (EVEN(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
      xnav->message('E', "Enter name");
      return XNAV__HOLDCOMMAND;
    }

    sts = xnav->delete_object(name_str);
    return sts;
  } else if (str_NoCaseStrncmp(arg1_str, "TREE", strlen(arg1_str)) == 0) {
    // Command is "DELETE TREE"

    char name_str[80];
    pwr_tObjid objid;

    IF_NOGDH_RETURN;

    // Check authorization
    if (!((xnav->priv & pwr_mPrv_RtWrite) || (xnav->priv & pwr_mPrv_System))) {
      xnav->message('E', "Not authorized for this operation");
      return 0;
    }

    if (EVEN(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
      xnav->message('E', "Enter name");
      return XNAV__HOLDCOMMAND;
    }


    /* Get objid for the object */
    sts = gdh_NameToObjid(name_str, &objid);
    if (EVEN(sts)) {
      xnav->message('E', "Object does not exist");
      return XNAV__HOLDCOMMAND;
    }

    sts = gdh_DeleteObjectTree(objid);
    if (EVEN(sts)) {
      xnav->message('E', "Unable to delete object tree");
      return XNAV__HOLDCOMMAND;
    }

    xnav->message('I', "Object deleted");
    return XNAV__SUCCESS;
  } else
    xnav->message('E', "Syntax error");

  return XNAV__SUCCESS;
}

static void xnav_collect_open_cb(void* ctx, char* text, int ok_pressed)
{
  XNav* xnav = (XNav*)ctx;
  pwr_tCmd cmd;

  sprintf(cmd, "@\"$pwrp_load/%s.rtt_col\"", text);

  xnav->command(cmd);
}

static int xnav_collect_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;
  int sts;
  char arg1_str[80];
  pwr_tAName name_str;
  pwr_sAttrRef attrref;
  int is_attr;
  double scantime, zoomfactor;

  IF_NOGDH_RETURN;

  if (EVEN(dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str)))) {
    int newwindow;
    int addwindow;
    int last;
    char title_str[80] = "";
    int width, height;
    char str[80];
    int num;

    if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
      sts = gdh_NameToAttrref(pwr_cNObjid, name_str, &attrref);
      if (EVEN(sts)) {
        xnav->message('E', "No such object");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      sts = xnav->get_select(&attrref, &is_attr);
      if (EVEN(sts)) {
        xnav->message('E', "Enter name or select object");
        return XNAV__SUCCESS;
      }
    }

    newwindow = ODD(dcli_get_qualifier("/NEWWINDOW", 0, 0));
    addwindow = ODD(dcli_get_qualifier("/ADDWINDOW", 0, 0));
    last = ODD(dcli_get_qualifier("/LAST", 0, 0));

    if (ODD(dcli_get_qualifier("/WIDTH", str, sizeof(str)))) {
      num = sscanf(str, "%d", &width);
      if (num != 1) {
        xnav->message('E', "Width syntax error");
        return XNAV__SUCCESS;
      }
    } else
      width = 0;

    if (ODD(dcli_get_qualifier("/HEIGHT", str, sizeof(str)))) {
      num = sscanf(str, "%d", &height);
      if (num != 1) {
        xnav->message('E', "Height syntax error");
        return XNAV__SUCCESS;
      }
    } else
      height = 0;

    if (ODD(dcli_get_qualifier("/ZOOMFACTOR", str, sizeof(str)))) {
      num = sscanf(str, "%lf", &zoomfactor);
      if (num != 1) {
        xnav->message('E', "Zoomfactor syntax error");
        return XNAV__SUCCESS;
      }
    } else
      zoomfactor = 0;

    if (ODD(dcli_get_qualifier("/SCANTIME", str, sizeof(str)))) {
      num = sscanf(str, "%lf", &scantime);
      if (num != 1) {
        xnav->message('E', "Scantime syntax error");
        return XNAV__SUCCESS;
      }
    } else
      scantime = 0;

    if (newwindow) {
      // Create a new window and insert into window
      pwr_tAttrRef* arlist = (pwr_tAttrRef*)calloc(2, sizeof(pwr_tAttrRef));
      arlist[0] = attrref;

      dcli_get_qualifier("/TITLE", title_str, sizeof(title_str));

      xnav->last_xcolwind = xnav->xcolwind_new(arlist, title_str,
          xnav->gbl.advanced_user, xcolwind_eType_Collect, &sts);
      if (EVEN(sts)) {
        xnav->last_xcolwind = 0;
        return XNAV__SUCCESS;
      }
      // xnav->last_xcolwind->close_cb = xatt_close_cb;
      xnav->last_xcolwind->popup_menu_cb = xnav_popup_menu_cb;
      xnav->last_xcolwind->call_method_cb = xnav_call_method_cb;
      xnav->last_xcolwind->is_authorized_cb = xnav->is_authorized_cb;
      xnav->last_xcolwind->command_cb = xnav_op_command_cb;
      xnav->last_xcolwind->get_select_cb = xnav_get_select_cb;

      if (width != 0 && height != 0)
        xnav->last_xcolwind->set_window_size(width, height);

      if (!feq(zoomfactor, 0.0))
        xnav->last_xcolwind->zoom(zoomfactor);

      if (!feq(scantime, 0.0))
        xnav->last_xcolwind->set_scantime(int(scantime * 1000 + 0.5));

      if (last)
        xnav->last_xcolwind = 0;
    } else if (addwindow) {
      // Add to last created window
      if (!xnav->last_xcolwind) {
        xnav->message('E', "No last collection window");
        return XNAV__SUCCESS;
      }
      xnav->last_xcolwind->collect_insert(&attrref);

      if (last)
        xnav->last_xcolwind = 0;
    } else {
      sts = xnav->collect_insert(&attrref);
    }
    return sts;
  } else if (str_NoCaseStrncmp(arg1_str, "OPEN", strlen(arg1_str)) == 0) {
    pwr_tFileName file_str;

    if (ODD(dcli_get_qualifier("/FILE", file_str, sizeof(file_str)))) {
      pwr_tCmd cmd;

      strcpy(cmd, "@\"");
      if (!strchr(file_str, '/'))
        strcat(cmd, "$pwrp_load/");
      strcat(cmd, file_str);
      if (!strchr(file_str, '.'))
        strcat(cmd, ".rtt_col");
      strcat(cmd, "\"");

      xnav->command(cmd);
    } else
      xnav->wow->CreateFileList("Open Collection", "$pwrp_load", "*", "rtt_col",
          xnav_collect_open_cb, 0, xnav, 1);

    return XNAV__SUCCESS;
  } else if (str_NoCaseStrncmp(arg1_str, "SHOW", strlen(arg1_str)) == 0) {
    sts = xnav->collect_show();
    return sts;
  } else if (str_NoCaseStrncmp(arg1_str, "REMOVE", strlen(arg1_str)) == 0) {
    sts = xnav->collect_remove();
    if (EVEN(sts))
      xnav->message(' ', XNav::get_message(sts));

    return XNAV__SUCCESS;
  } else if (str_NoCaseStrncmp(arg1_str, "CLEAR", strlen(arg1_str)) == 0) {
    xnav->collect_clear();
    return XNAV__SUCCESS;
  } else {
    xnav->message('E', "Unknown qualifier");
    return XNAV__HOLDCOMMAND;
  }
}

static int xnav_dashboard_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;
  char arg1_str[80];

  IF_NOGDH_RETURN;

  if (ODD(dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str)))) {
    if (str_NoCaseStrncmp(arg1_str, "OPEN", strlen(arg1_str)) == 0) {
      char name_str[80];
      int name_found = 0;

      if (ODD(dcli_get_qualifier("dcli_arg2", name_str, sizeof(name_str))))
	name_found = 1;
      else if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str))))
	name_found = 1;
      if (!name_found) {
	xnav->wow->CreateFileList("Open Dashboard", "$pwrp_exe", "*", "pwd",
	     xnav_dashboard_open_cb, 0, xnav, 1);

	return XNAV__SUCCESS;
      } else {
	// Name found
	pwr_tCmd cmd;
	sprintf(cmd, "open graph %s/dash/menu", name_str);

	xnav->command(cmd);
      }
    } else {
      xnav->message('E', "Unknown qualifier");
      return XNAV__HOLDCOMMAND;
    }
  } else {
    xnav->message('E', "Missing qualifier");
    return XNAV__HOLDCOMMAND;
  }
  return XNAV__SUCCESS;
}

static int xnav_store_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;
  int sts;
  char* file_ptr;
  char file_str[80];
  char filename[80];
  char str[80];
  int collect;

  IF_NOGDH_RETURN;

  if (ODD(dcli_get_qualifier("/SYMBOLS", str, sizeof(str)))) {
    if (ODD(dcli_get_qualifier("/FILE", file_str, sizeof(file_str))))
      file_ptr = file_str;
    else if (ODD(dcli_get_qualifier("dcli_arg1", file_str, sizeof(file_str)))) {
      if (file_str[0] != '/')
        /* Assume that this is the filestring */
        file_ptr = file_str;
      else
        file_ptr = xnav->gbl.setupscript;
    } else
      file_ptr = xnav->gbl.setupscript;

    dcli_get_defaultfilename(file_ptr, filename, ".rtt_com");
    sts = dcli_store_symbols(filename);
    return sts;
  } else {
    if (ODD(dcli_get_qualifier("/FILE", file_str, sizeof(file_str))))
      file_ptr = file_str;
    else if (ODD(dcli_get_qualifier("dcli_arg1", file_str, sizeof(file_str)))) {
      if (file_str[0] != '/')
        /* Assume that this is the filestring */
        file_ptr = file_str;
      else {
        xnav->message('E', "Enter file");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      xnav->message('E', "Enter file");
      return XNAV__HOLDCOMMAND;
    }

    /* Store a menue */
    if (ODD(dcli_get_qualifier("/COLLECT", str, sizeof(str))))
      collect = 1;
    else
      collect = 0;

    sts = xnav->store(file_str, collect);
    return sts;
  }
}

static int xnav_crossref_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;
  int sts;
  pwr_tFileName file_str;
  pwr_tAName name_str;
  char string_str[80];
  char func_str[80];
  char* file_ptr;
  char* name_ptr;
  pwr_sAttrRef objar;
  pwr_tClassId classid;
  int brief;
  int window;
  int case_sens;
  char title[430];

  IF_NOGDH_RETURN;

  if (ODD(dcli_get_qualifier("/FILE", file_str, sizeof(file_str))))
    file_ptr = file_str;
  else
    file_ptr = NULL;

  if (ODD(dcli_get_qualifier("/STRING", string_str, sizeof(string_str)))) {
    if (ODD(dcli_get_qualifier("/FUNCTION", func_str, sizeof(func_str)))) {
      xnav->message('E', "Syntax error");
      return XNAV__SUCCESS;
    }
    brief = ODD(dcli_get_qualifier("/BRIEF", name_str, sizeof(name_str)));
    case_sens = ODD(
        dcli_get_qualifier("/CASE_SENSITIVE", name_str, sizeof(name_str)));
    xnav->brow_pop();
    brow_SetNodraw(xnav->brow->ctx);
    sts = xnav_crr_code(xnav->brow, file_ptr, string_str, brief, 0, case_sens);
    brow_ResetNodraw(xnav->brow->ctx);
    brow_Redraw(xnav->brow->ctx, 0);
    if (EVEN(sts)) {
      xnav->brow_push();
      xnav->message(' ', XNav::get_message(sts));
    }
  } else if (ODD(dcli_get_qualifier("/FUNCTION", func_str, sizeof(func_str)))) {
    brief = ODD(dcli_get_qualifier("/BRIEF", 0, 0));
    case_sens = ODD(dcli_get_qualifier("/CASE_SENSITIVE", 0, 0));
    xnav->brow_pop();
    brow_SetNodraw(xnav->brow->ctx);
    sts = xnav_crr_code(xnav->brow, file_ptr, func_str, brief, 1, case_sens);
    brow_ResetNodraw(xnav->brow->ctx);
    brow_Redraw(xnav->brow->ctx, 0);
    if (EVEN(sts)) {
      xnav->brow_push();
      xnav->message(' ', XNav::get_message(sts));
    }
  } else {
    /* Get the name qualifier */
    if (ODD(dcli_get_qualifier("dcli_arg1", name_str, sizeof(name_str)))) {
      if (name_str[0] != '/')
        /* Assume that this is the namestring */
        name_ptr = name_str;
      else {
        xnav->message('E', "Syntax error");
        return XNAV__SUCCESS;
      }
    } else if (ODD(dcli_get_qualifier("/NAME", name_str, sizeof(name_str)))) {
      name_ptr = name_str;
      sts = gdh_NameToAttrref(pwr_cNObjid, name_str, &objar);
      if (EVEN(sts)) {
        xnav->message('E', "Object not found");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      /* Get the selected object */
      sts = xnav->get_current_aref(&objar, name_str, sizeof(name_str),
          cdh_mName_path | cdh_mName_object);
      if (EVEN(sts)) {
        xnav->message('E', "Enter name or select an object");
        return XNAV__SUCCESS;
      }
      name_ptr = name_str;
    }

    sts = gdh_GetAttrRefTid(&objar, &classid);
    if (EVEN(sts))
      return sts;

    window = ODD(dcli_get_qualifier("/WINDOW", 0, 0));
    if (window) {
      XCrr* xcrr = xnav->xcrr_new(&objar, xnav->gbl.advanced_user, &sts);
      if (EVEN(sts))
        xnav->message(' ', XNav::get_message(sts));
      else {
        xcrr->popup_menu_cb = xnav_popup_menu_cb;
        xcrr->start_trace_cb = xnav_start_trace_cb;
      }
      return XNAV__SUCCESS;
    }

    xnav->brow_pop();
    brow_SetNodraw(xnav->brow->ctx);

    sts = gdh_AttrrefToName(&objar, name_str, sizeof(name_str), cdh_mNName);
    sprintf(title, "Crossreference list %s\n", name_str);
    new ItemHeader(xnav->brow, "Title", title, NULL, flow_eDest_IntoLast);

    switch (classid) {
    case pwr_cClass_Di:
    case pwr_cClass_Dv:
    case pwr_cClass_Do:
    case pwr_cClass_Po:
    case pwr_cClass_Av:
    case pwr_cClass_Ai:
    case pwr_cClass_Ao:
    case pwr_cClass_Iv:
    case pwr_cClass_Ii:
    case pwr_cClass_Io:
    case pwr_cClass_Co:
    case pwr_cClass_Sv:
    case pwr_cClass_ATv:
    case pwr_cClass_DTv:
      if (!file_ptr) {
        strcpy(file_str, "*");
        file_ptr = file_str;
      }
      sts = xnav_crr_signal(xnav->brow, file_ptr, name_ptr, NULL);
      break;
    default:
      /* Not a signal */
      if (!file_ptr) {
        strcpy(file_str, "*");
        file_ptr = file_str;
      }
      sts = xnav_crr_object(xnav->brow, file_ptr, name_ptr, NULL);
    }
    if (EVEN(sts))
      xnav->message(' ', XNav::get_message(sts));
    brow_ResetNodraw(xnav->brow->ctx);
    brow_Redraw(xnav->brow->ctx, 0);
  }
  return sts;
}

static int xnav_exit_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;

  if (xnav->close_cb)
    (xnav->close_cb)(xnav->parent_ctx, xnav->op ? 0 : 1);
  else
    exit(1);
  return 1;
}

static int xnav_setup_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;

  xnav->setup();
  return 1;
}

static int xnav_search_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;
  int sts;
  char arg1_str[80];
  int regexp;

  if (ODD(dcli_get_qualifier("/NEXT", 0, 0))) {
    sts = xnav->search_next();
    if (EVEN(sts))
      xnav->message(' ', XNav::get_message(sts));
    return sts;
  } else if (ODD(dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str)))) {
    regexp = ODD(dcli_get_qualifier("/REGULAREXPRESSION", 0, 0));

    sts = xnav->search(arg1_str, regexp);
    if (EVEN(sts))
      xnav->message(' ', XNav::get_message(sts));
    return sts;
  } else {
    xnav->message('E', "Syntax error");
    return XNAV__SYNTAX;
  }
}

static int xnav_test_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;
  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "BELL", strlen(arg1_str)) == 0) {
    // Command is "TEST BELL"
    xnav->bell(100);
  } else if (str_NoCaseStrncmp(arg1_str, "BEEP", strlen(arg1_str)) == 0) {
    // Command is "TEST BEEP"
    putchar('\7');
  }
  return 1;
}

static int xnav_logging_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;
  char arg1_str[80];
  int arg1_sts;
  int sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "SET", strlen(arg1_str)) == 0
      || str_NoCaseStrncmp(arg1_str, "CREATE", strlen(arg1_str)) == 0) {
    /* Command is "LOGGING SET" */

    char entry_str[80];
    char line_size_str[80];
    char parameter_str[80];
    char time_str[80];
    char file_str[80];
    char condition_str[80];
    char buffer_size_str[80];
    char priority_str[80];
    char str[80];
    int stop;
    int priority;
    int entry;
    int line_size;
    char* parameter_ptr;
    float logg_time;
    char* file_ptr;
    char* condition_ptr;
    int buffer_size;
    int nr;
    int logg_type = 0;
    int logg_format = -1;
    int insert;
    int create;
    int shortname;

    if (ODD(dcli_get_qualifier("/ENTRY", entry_str, sizeof(entry_str)))) {
      if (!str_NoCaseStrcmp(entry_str, "CURRENT")) {
        if (xnav->current_logging_index == -1) {
          xnav->message('E', "No current logging entry");
          return XNAV__HOLDCOMMAND;
        }
        entry = xnav->current_logging_index + 1;
      } else {
        /* convert to integer */
        nr = sscanf(entry_str, "%d", &entry);
        if (nr != 1) {
          xnav->message('E', "Entry syntax error");
          return XNAV__HOLDCOMMAND;
        }
      }
    } else {
      xnav->message('E', "Enter entry");
      return XNAV__HOLDCOMMAND;
    }

    if (ODD(dcli_get_qualifier("/TIME", time_str, sizeof(time_str)))) {
      /* convert to integer */
      nr = sscanf(time_str, "%f", &logg_time);
      if (nr != 1) {
        xnav->message('E', "Time syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else
      logg_time = 0;

    if (ODD(dcli_get_qualifier(
            "/BUFFER_SIZE", buffer_size_str, sizeof(buffer_size_str)))) {
      /* convert to integer */
      nr = sscanf(buffer_size_str, "%d", &buffer_size);
      if (nr != 1) {
        xnav->message('E', "Buffer size syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else
      buffer_size = 0;

    if (ODD(dcli_get_qualifier(
            "/LINE_SIZE", line_size_str, sizeof(line_size_str)))) {
      /* convert to integer */
      nr = sscanf(line_size_str, "%d", &line_size);
      if (nr != 1) {
        xnav->message('E', "Line size syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else
      line_size = 0;

    if (ODD(dcli_get_qualifier("/FILE", file_str, sizeof(file_str))))
      file_ptr = file_str;
    else
      file_ptr = NULL;

    if (ODD(dcli_get_qualifier(
            "/PARAMETER", parameter_str, sizeof(parameter_str))))
      parameter_ptr = parameter_str;
    else
      parameter_ptr = NULL;

    if (ODD(dcli_get_qualifier(
            "/CONDITION", condition_str, sizeof(condition_str))))
      condition_ptr = condition_str;
    else
      condition_ptr = NULL;

    if (ODD(dcli_get_qualifier("/TYPE", str, sizeof(str)))) {
      if (str_NoCaseStrncmp(str, "EVENT", strlen(str)) == 0)
        logg_type = xtt_LoggType_Mod;
      else if (str_NoCaseStrncmp(str, "CONTINOUS", strlen(str)) == 0)
        logg_type = xtt_LoggType_Cont;
    } else
      logg_type = 0;

    if (ODD(dcli_get_qualifier("/FORMAT", str, sizeof(str)))) {
      if (str_NoCaseStrncmp(str, "STD", strlen(str)) == 0)
        logg_format = xtt_eLoggFormat_Std;
      else if (str_NoCaseStrncmp(str, "PY", strlen(str)) == 0)
        logg_format = xtt_eLoggFormat_Py;
    } else
      logg_format = -1;

    if (ODD(dcli_get_qualifier(
            "/PRIORITY", priority_str, sizeof(priority_str)))) {
      /* convert to integer */
      nr = sscanf(priority_str, "%d", &priority);
      if (nr != 1) {
        xnav->message('E', "Priority syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else
      priority = -1;

    if (ODD(dcli_get_qualifier("/STOP", 0, 0)))
      stop = 1;
    else if (ODD(dcli_get_qualifier("/NOSTOP", 0, 0)))
      stop = 0;
    else
      stop = -1;

    if (ODD(dcli_get_qualifier("/INSERT", 0, 0)))
      insert = 1;
    else
      insert = 0;

    if (ODD(dcli_get_qualifier("/SHORTNAME", 0, 0)))
      shortname = 1;
    else if (ODD(dcli_get_qualifier("/NOSHORTNAME", 0, 0)))
      shortname = 0;
    else
      shortname = -1;

    if (ODD(dcli_get_qualifier("/CREATE", 0, 0)))
      create = 1;
    else
      create = 0;

    if (entry > XNAV_LOGG_MAX || entry < 1) {
      xnav->message('E', "Entry out of range");
      return XNAV__HOLDCOMMAND;
    }

    sts = xnav->logg[entry - 1].logging_set(logg_time, file_ptr, parameter_ptr,
	condition_ptr, logg_type, logg_format, insert, buffer_size, stop, priority, create,
        line_size, shortname);
    return sts;
  }

  else if (str_NoCaseStrncmp(arg1_str, "DELETE", strlen(arg1_str)) == 0) {
    /* Command is "LOGGING DELETE" */

    char entry_str[80];
    char parameter_str[80];
    char* parameter_ptr;
    int entry;
    int nr;

    if (ODD(dcli_get_qualifier("/ENTRY", entry_str, sizeof(entry_str)))) {
      if (!str_NoCaseStrcmp(entry_str, "CURRENT")) {
        if (xnav->current_logging_index == -1) {
          xnav->message('E', "No current logging entry");
          return XNAV__HOLDCOMMAND;
        }
        entry = xnav->current_logging_index + 1;
      } else {
        /* convert to integer */
        nr = sscanf(entry_str, "%d", &entry);
        if (nr != 1) {
          xnav->message('E', "Entry syntax error");
          return XNAV__HOLDCOMMAND;
        }
      }
    } else {
      xnav->message('E', "Enter entry");
      return XNAV__HOLDCOMMAND;
    }

    if (entry > XNAV_LOGG_MAX || entry < 1) {
      xnav->message('E', "Entry out of range");
      return XNAV__HOLDCOMMAND;
    }

    if (ODD(dcli_get_qualifier("/ALL", 0, 0)))
      parameter_ptr = 0;
    else if (ODD(dcli_get_qualifier(
                 "/PARAMETER", parameter_str, sizeof(parameter_str))))
      parameter_ptr = parameter_str;
    else
      return XNAV__SUCCESS;

    sts = xnav->logg[entry - 1].remove(parameter_ptr);

    return sts;
  }

  else if (str_NoCaseStrncmp(arg1_str, "START", strlen(arg1_str)) == 0) {
    /* Command is "LOGGING START" */

    char entry_str[80];
    int entry;
    int nr;

    if (ODD(dcli_get_qualifier("/ENTRY", entry_str, sizeof(entry_str)))) {
      /* convert to integer */
      nr = sscanf(entry_str, "%d", &entry);
      if (nr != 1) {
        xnav->message('E', "Entry syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      xnav->message('E', "Enter entry");
      return XNAV__HOLDCOMMAND;
    }

    if (entry > XNAV_LOGG_MAX || entry < 1) {
      xnav->message('E', "Entry out of range");
      return XNAV__HOLDCOMMAND;
    }

    sts = xnav->logg[entry - 1].start();
    return sts;
  }

  else if (str_NoCaseStrncmp(arg1_str, "STOP", strlen(arg1_str)) == 0) {
    /* Command is "LOGGING STOP" */

    char entry_str[80];
    int entry;
    int nr;

    if (ODD(dcli_get_qualifier("/ENTRY", entry_str, sizeof(entry_str)))) {
      /* convert to integer */
      nr = sscanf(entry_str, "%d", &entry);
      if (nr != 1) {
        xnav->message('E', "Entry syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      xnav->message('E', "Enter entry");
      return XNAV__HOLDCOMMAND;
    }

    if (entry > XNAV_LOGG_MAX || entry < 1) {
      xnav->message('E', "Entry out of range");
      return XNAV__HOLDCOMMAND;
    }

    sts = xnav->logg[entry - 1].stop();
    return sts;
  } else if (str_NoCaseStrncmp(arg1_str, "SHOW", strlen(arg1_str)) == 0) {
    /* Command is "LOGGING SHOW" */

    char entry_str[80];
    int entry;
    int nr;

    if (ODD(dcli_get_qualifier("/ENTRY", entry_str, sizeof(entry_str)))) {
      /* convert to integer */
      nr = sscanf(entry_str, "%d", &entry);
      if (nr != 1) {
        xnav->message('E', "Entry syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      entry = 0;
    }

    if (entry > XNAV_LOGG_MAX || entry < 1) {
      xnav->message('E', "Entry out of range");
      return XNAV__HOLDCOMMAND;
    }

    sts = xnav->logg[entry - 1].show();
    return sts;
  } else if (str_NoCaseStrncmp(arg1_str, "ANALYSE", strlen(arg1_str)) == 0) {
    /* Command is "LOGGING ANALYSE" */

    char entry_str[80];
    int entry;
    int nr;

    if (ODD(dcli_get_qualifier("/ENTRY", entry_str, sizeof(entry_str)))) {
      if (!str_NoCaseStrcmp(entry_str, "CURRENT")) {
        if (xnav->current_logging_index == -1) {
          xnav->message('E', "No current logging entry");
          return XNAV__HOLDCOMMAND;
        }
        entry = xnav->current_logging_index + 1;
      } else {
        /* convert to integer */
        nr = sscanf(entry_str, "%d", &entry);
        if (nr != 1) {
          xnav->message('E', "Entry syntax error");
          return XNAV__HOLDCOMMAND;
        }
      }
    } else {
      xnav->message('E', "Enter entry");
      return XNAV__HOLDCOMMAND;
    }

    if (entry > XNAV_LOGG_MAX || entry < 1) {
      xnav->message('E', "Entry out of range");
      return XNAV__HOLDCOMMAND;
    }

    sts = xnav->logg[entry - 1].analyse();
    return sts;
  } else if (str_NoCaseStrncmp(arg1_str, "STORE", strlen(arg1_str)) == 0) {
    /* Command is "LOGGING STORE" */

    char entry_str[80];
    char file_str[80];
    char* file_ptr;
    int entry;
    int nr;

    if (ODD(dcli_get_qualifier("/FILE", file_str, sizeof(file_str))))
      file_ptr = file_str;
    else if (ODD(dcli_get_qualifier("dcli_arg2", file_str, sizeof(file_str)))) {
      if (file_str[0] != '/')
        /* Assume that this is the filestring */
        file_ptr = file_str;
      else {
        xnav->message('E', "Enter file");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      xnav->message('E', "Enter file");
      return XNAV__HOLDCOMMAND;
    }

    if (ODD(dcli_get_qualifier("/ENTRY", entry_str, sizeof(entry_str)))) {
      /* convert to integer */
      nr = sscanf(entry_str, "%d", &entry);
      if (nr != 1) {
        xnav->message('E', "Entry syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else {
      if (xnav->current_logging_index == -1) {
        xnav->message('E', "Entry syntax error");
        return XNAV__HOLDCOMMAND;
      }
      entry = xnav->current_logging_index + 1;
    }
    if (entry > XNAV_LOGG_MAX || entry < 1) {
      xnav->message('E', "Entry out of range");
      return XNAV__HOLDCOMMAND;
    }

    sts = xnav->logg[entry - 1].store(file_str);
    return sts;
  } else {
    xnav->message('E', "Unknown qualifier");
    return XNAV__HOLDCOMMAND;
  }

  // return XNAV__SUCCESS;
}
static int xnav_call_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;
  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "METHOD", strlen(arg1_str)) == 0) {
    // Command is "CALL METHOD"
    char method_str[80];
    pwr_tAName object_str;
    int sts;
    xmenu_eItemType menu_type;
    pwr_sAttrRef aref;

    if (ODD(dcli_get_qualifier("/FUNCTION", method_str, sizeof(method_str)))) {
      xmenu_sMenuCall mcp;
      pwr_tStatus (*method)(xmenu_sMenuCall*);

      sts = XNav::GetMethod(method_str, &method);
      if (EVEN(sts)) {
        xnav->message('E', "Method not found");
        return XNAV__HOLDCOMMAND;
      }

      if (EVEN(dcli_get_qualifier("/OBJECT", object_str, sizeof(object_str)))) {
        xnav->message('E', "Enter object");
        return XNAV__HOLDCOMMAND;
      }

      sts = gdh_NameToAttrref(pwr_cNObjid, object_str, &aref);
      if (EVEN(sts)) {
        xnav->message('E', "No such object");
        return XNAV__HOLDCOMMAND;
      }

      memset(&mcp, 0, sizeof(mcp));
      mcp.Pointed = aref;
      mcp.Selected = &aref;
      mcp.SelectCount = 1;
      mcp.EditorContext = xnav;

      sts = (method)(&mcp);
      return sts;
    } else {
      if (EVEN(dcli_get_qualifier("/METHOD", method_str, sizeof(method_str)))) {
        xnav->message('E', "Enter method");
        return XNAV__HOLDCOMMAND;
      }
      if (EVEN(dcli_get_qualifier("/OBJECT", object_str, sizeof(object_str)))) {
        xnav->message('E', "Enter object");
        return XNAV__HOLDCOMMAND;
      }

      sts = gdh_NameToAttrref(pwr_cNObjid, object_str, &aref);
      if (EVEN(sts)) {
        xnav->message('E', "No such object");
        return XNAV__HOLDCOMMAND;
      }

      if (aref.Flags.b.Object)
        menu_type = xmenu_eItemType_Object;
      else if (aref.Flags.b.ObjectAttr)
        menu_type = xmenu_eItemType_AttrObject;
      else
        menu_type = xmenu_eItemType_Attribute;

      sts = xnav->call_object_method(
          aref, menu_type, xmenu_mUtility_XNav, xnav->priv, method_str);
      if (EVEN(sts)) {
        xnav->message('E', "Unable to call method");
        return XNAV__HOLDCOMMAND;
      } else
        return sts;
    }
  } else
    xnav->message('E', "Syntax error");
  return 1;
}

static int xnav_check_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;
  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "METHOD", strlen(arg1_str)) == 0) {
    // Command is "CHECK METHOD"
    char method_str[80];
    pwr_tAName object_str;
    int sts;
    xmenu_eItemType menu_type;
    pwr_sAttrRef aref;

    if (ODD(dcli_get_qualifier("/FILTER", method_str, sizeof(method_str)))) {
      xmenu_sMenuCall mcp;
      pwr_tStatus (*method)(xmenu_sMenuCall*);

      sts = XNav::GetMethod(method_str, &method);
      if (EVEN(sts)) {
        xnav->message('E', "Method not found");
        return XNAV__HOLDCOMMAND;
      }

      if (EVEN(dcli_get_qualifier("/OBJECT", object_str, sizeof(object_str)))) {
        xnav->message('E', "Enter object");
        return XNAV__HOLDCOMMAND;
      }

      sts = gdh_NameToAttrref(pwr_cNObjid, object_str, &aref);
      if (EVEN(sts)) {
        xnav->message('E', "No such object");
        return XNAV__HOLDCOMMAND;
      }

      memset(&mcp, 0, sizeof(mcp));
      mcp.Pointed = aref;
      mcp.Selected = &aref;
      mcp.SelectCount = 1;
      mcp.EditorContext = xnav;

      sts = (method)(&mcp);
      return sts;
    } else {
      if (EVEN(dcli_get_qualifier("/METHOD", method_str, sizeof(method_str)))) {
        xnav->message('E', "Enter method");
        return XNAV__HOLDCOMMAND;
      }
      if (EVEN(dcli_get_qualifier("/OBJECT", object_str, sizeof(object_str)))) {
        xnav->message('E', "Enter object");
        return XNAV__HOLDCOMMAND;
      }

      sts = gdh_NameToAttrref(pwr_cNObjid, object_str, &aref);
      if (EVEN(sts)) {
        xnav->message('E', "No such object");
        return XNAV__HOLDCOMMAND;
      }

      if (aref.Flags.b.Object)
        menu_type = xmenu_eItemType_Object;
      else if (aref.Flags.b.ObjectAttr)
        menu_type = xmenu_eItemType_AttrObject;
      else
        menu_type = xmenu_eItemType_Attribute;

      sts = xnav->check_object_methodfilter(
          aref, menu_type, xmenu_mUtility_XNav, xnav->priv, method_str);
      return sts;
    }
  }
  if (str_NoCaseStrncmp(arg1_str, "ISATTRIBUTE", strlen(arg1_str)) == 0) {
    // Command is "CHECK ISATTRIBUTE"
    pwr_tAName object_str;

    if (EVEN(dcli_get_qualifier("/OBJECT", object_str, sizeof(object_str)))) {
      xnav->message('E', "Enter object");
      return XNAV__HOLDCOMMAND;
    }

    if (strrchr(object_str, '.'))
      return 1;
    else
      return 0;
  } else
    xnav->message('E', "Syntax error");
  return 1;
}

static int xnav_print_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;

  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "GRAPH", strlen(arg1_str)) == 0) {
    pwr_tFileName file_str;
    pwr_tAName instance_str;
    pwr_tAName object_str;
    XttGe* gectx;
    pwr_tFileName fname;
    int classgraph;
    char* instance_p;
    int sts;

    if (ODD(dcli_get_qualifier(
            "/INSTANCE", instance_str, sizeof(instance_str)))) {
      instance_p = instance_str;
    } else
      instance_p = 0;

    if (ODD(dcli_get_qualifier("/CLASSGRAPH", 0, 0))) {
      classgraph = 1;
      if (!instance_p) {
        xnav->message('E', "Instance is missing");
        return XNAV__HOLDCOMMAND;
      }
    } else
      classgraph = 0;

    if (ODD(dcli_get_qualifier("dcli_arg2", file_str, sizeof(file_str)))) {
      if (file_str[0] == '/') {
        xnav->message('E', "Syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else if (ODD(dcli_get_qualifier("/FILE", file_str, sizeof(file_str)))) {
      // Get base class graphs on $pwr_exe
      str_ToLower(fname, file_str);
    } else if (classgraph) {
      // Get file from class of instance object
      pwr_sAttrRef aref;
      pwr_tObjName cname;
      pwr_tCid cid;
      pwr_tFileName found_file;

      if (!instance_p) {
        xnav->message('E', "Enter instance object");
        return XNAV__HOLDCOMMAND;
      }

      sts = gdh_NameToAttrref(pwr_cNObjid, instance_p, &aref);
      if (EVEN(sts)) {
        xnav->message('E', "Instance object not found");
        return XNAV__HOLDCOMMAND;
      }
      sts = gdh_AttrrefToName(
          &aref, instance_str, sizeof(instance_str), cdh_mName_volumeStrict);
      if (EVEN(sts))
        return sts;

      sts = gdh_GetAttrRefTid(&aref, &cid);
      while (ODD(sts)) {
        // Try all superclasses
        sts = gdh_ObjidToName(
            cdh_ClassIdToObjid(cid), cname, sizeof(cname), cdh_mName_object);
        if (EVEN(sts))
          return sts;

        str_ToLower(cname, cname);
        if (cdh_CidToVid(cid) < cdh_cUserClassVolMin
            || (cdh_CidToVid(cid) >= cdh_cManufactClassVolMin
                   && cdh_CidToVid(cid) <= cdh_cManufactClassVolMax)) {
          if (cname[0] == '$')
            sprintf(file_str, "pwr_c_%s", &cname[1]);
          else
            sprintf(file_str, "pwr_c_%s", cname);
        } else
          strcpy(file_str, cname);

        // Get base class graphs on $pwr_exe
        str_ToLower(fname, file_str);
        if (instance_p && (str_NoCaseStrncmp(fname, "pwr_c_", 6) == 0
                              || str_NoCaseStrncmp(fname, "pwr_c_", 6) == 0)) {
          strcpy(fname, "$pwr_exe/");
          strcat(fname, file_str);
        } else {
          strcpy(fname, "$pwrp_exe/");
          strcat(fname, file_str);
        }
        strcat(fname, ".pwg");
        strcpy(file_str, fname);
        sts = dcli_search_file(fname, found_file, DCLI_DIR_SEARCH_INIT);
        dcli_search_file(fname, found_file, DCLI_DIR_SEARCH_END);
        if (ODD(sts))
          break;

        sts = gdh_GetSuperClass(cid, &cid, aref.Objid);
      }
      if (EVEN(sts)) {
        xnav->message('E', "No classgraph found");
        return XNAV__HOLDCOMMAND;
      }
    }

    if (ODD(dcli_get_qualifier("/OBJECT", object_str, sizeof(object_str)))) {
      // Find graph from XttGraph object
      pwr_tObjid objid;
      pwr_tAName xttgraph_name;
      char* s;
      pwr_sClass_XttGraph xttgraph_o;

      xnav_replace_node_str(xttgraph_name, object_str);

      sts = gdh_NameToObjid(xttgraph_name, &objid);
      if (EVEN(sts)) {
        xnav->message('E', "Object not found");
        return XNAV__HOLDCOMMAND;
      }

      sts = gdh_GetObjectInfo(
          xttgraph_name, (void*)&xttgraph_o, sizeof(xttgraph_o));
      if (EVEN(sts))
        return sts;

      str_ToLower(file_str, xttgraph_o.Action);
      if ((s = strrchr(file_str, '.')))
        *s = 0;

      if (cdh_ObjidIsNotNull(xttgraph_o.Object[0])) {
        sts = gdh_ObjidToName(xttgraph_o.Object[0], instance_str,
            sizeof(instance_str), cdh_mName_volumeStrict);
        if (EVEN(sts))
          return sts;

        instance_p = instance_str;
      } else
        instance_p = 0;
    }

    if (xnav->appl.find(
            applist_eType_Graph, file_str, instance_p, (void**)&gectx))
      gectx->print();
    else {
      xnav->message('E', "Graph not found");
      return XNAV__HOLDCOMMAND;
    }
  } else
    xnav->message('E', "Syntax error");

  return XNAV__SUCCESS;
}

static int xnav_export_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;

  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "GRAPH", strlen(arg1_str)) == 0) {
    pwr_tFileName file_str;
    pwr_tFileName graph_str;
    pwr_tAName instance_str;
    pwr_tAName object_str;
    XttGe* gectx;
    pwr_tFileName fname;
    int classgraph;
    char* instance_p;
    int sts;

    if (ODD(dcli_get_qualifier(
            "/INSTANCE", instance_str, sizeof(instance_str)))) {
      instance_p = instance_str;
    } else
      instance_p = 0;

    if (ODD(dcli_get_qualifier("/CLASSGRAPH", 0, 0))) {
      classgraph = 1;
      if (!instance_p) {
        xnav->message('E', "Instance is missing");
        return XNAV__HOLDCOMMAND;
      }
    } else
      classgraph = 0;

    if (EVEN(dcli_get_qualifier("/file", file_str, sizeof(file_str)))) {
      xnav->message('E', "File is missing");
      return XNAV__HOLDCOMMAND;
    }

    if (ODD(dcli_get_qualifier("/GRAPH", graph_str, sizeof(graph_str)))) {
      // Get base class graphs on $pwr_exe
      str_ToLower(graph_str, graph_str);
    } else if (classgraph) {
      // Get file from class of instance object
      pwr_sAttrRef aref;
      pwr_tObjName cname;
      pwr_tCid cid;
      pwr_tFileName found_file;

      if (!instance_p) {
        xnav->message('E', "Enter instance object");
        return XNAV__HOLDCOMMAND;
      }

      sts = gdh_NameToAttrref(pwr_cNObjid, instance_p, &aref);
      if (EVEN(sts)) {
        xnav->message('E', "Instance object not found");
        return XNAV__HOLDCOMMAND;
      }
      sts = gdh_GetAttrRefTid(&aref, &cid);
      while (ODD(sts)) {
        // Try all superclasses
        sts = gdh_ObjidToName(
            cdh_ClassIdToObjid(cid), cname, sizeof(cname), cdh_mName_object);
        if (EVEN(sts))
          return sts;

        str_ToLower(cname, cname);
        if (cdh_CidToVid(cid) < cdh_cUserClassVolMin
            || (cdh_CidToVid(cid) >= cdh_cManufactClassVolMin
                   && cdh_CidToVid(cid) <= cdh_cManufactClassVolMax)) {
          if (cname[0] == '$')
            sprintf(graph_str, "pwr_c_%s", &cname[1]);
          else
            sprintf(graph_str, "pwr_c_%s", cname);
        } else
          strcpy(graph_str, cname);

        // Get base class graphs on $pwr_exe
        str_ToLower(fname, graph_str);
        if (instance_p && (str_NoCaseStrncmp(fname, "pwr_c_", 6) == 0
                              || str_NoCaseStrncmp(fname, "pwr_c_", 6) == 0)) {
          strcpy(fname, "$pwr_exe/");
          strcat(fname, graph_str);
          strcpy(graph_str, fname);
        } else {
          strcpy(fname, "$pwrp_exe/");
          strcat(fname, graph_str);
          strcpy(graph_str, fname);
        }
        strcat(fname, ".pwg");
        sts = dcli_search_file(fname, found_file, DCLI_DIR_SEARCH_INIT);
        dcli_search_file(fname, found_file, DCLI_DIR_SEARCH_END);
        if (ODD(sts))
          break;

        sts = gdh_GetSuperClass(cid, &cid, aref.Objid);
      }
      if (EVEN(sts)) {
        xnav->message('E', "No classgraph found");
        return XNAV__HOLDCOMMAND;
      }
    }

    if (ODD(dcli_get_qualifier("/OBJECT", object_str, sizeof(object_str)))) {
      // Find graph from XttGraph object
      pwr_tObjid objid;
      pwr_tAName xttgraph_name;
      char* s;
      pwr_sClass_XttGraph xttgraph_o;

      xnav_replace_node_str(xttgraph_name, object_str);

      sts = gdh_NameToObjid(xttgraph_name, &objid);
      if (EVEN(sts)) {
        xnav->message('E', "Object not found");
        return XNAV__HOLDCOMMAND;
      }

      sts = gdh_GetObjectInfo(
          xttgraph_name, (void*)&xttgraph_o, sizeof(xttgraph_o));
      if (EVEN(sts))
        return sts;

      str_ToLower(graph_str, xttgraph_o.Action);
      if ((s = strrchr(graph_str, '.')))
        *s = 0;

      if (cdh_ObjidIsNotNull(xttgraph_o.Object[0])) {
        sts = gdh_ObjidToName(xttgraph_o.Object[0], instance_str,
            sizeof(instance_str), cdh_mName_volumeStrict);
        if (EVEN(sts))
          return sts;

        instance_p = instance_str;
      } else
        instance_p = 0;
    }

    if (xnav->appl.find(
            applist_eType_Graph, graph_str, instance_p, (void**)&gectx))
      gectx->export_image(file_str);
    else {
      xnav->message('E', "Graph not found");
      return XNAV__HOLDCOMMAND;
    }
  } else
    xnav->message('E', "Syntax error");

  return XNAV__SUCCESS;
}

static int xnav_sound_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;

  pwr_tOName object_str;
  int sts;
  pwr_tAttrRef aref;

  if (EVEN(dcli_get_qualifier("/OBJECT", object_str, sizeof(object_str)))) {
    if (EVEN(dcli_get_qualifier("dcli_arg1", object_str, sizeof(object_str)))) {
      xnav->message('E', "Object is missing");
      return XNAV__HOLDCOMMAND;
    }
  }

  sts = gdh_NameToAttrref(pwr_cNObjid, object_str, &aref);
  if (EVEN(sts)) {
    xnav->message('E', "Sound object not found");
    return XNAV__HOLDCOMMAND;
  }

  xnav->sound(&aref);

  return XNAV__SUCCESS;
}

static int xnav_write_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;

  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "OBJECT", strlen(arg1_str)) == 0) {
    pwr_tOName object_str;
    pwr_tFileName file_str;
    int sts;
    pwr_tAttrRef aref;

    if (EVEN(dcli_get_qualifier("/OBJECT", object_str, sizeof(object_str)))) {
      if (EVEN(dcli_get_qualifier(
              "dcli_arg2", object_str, sizeof(object_str)))) {
        xnav->message('E', "Object is missing");
        return XNAV__HOLDCOMMAND;
      }
    }

    if (EVEN(dcli_get_qualifier("/FILE", file_str, sizeof(file_str)))) {
      xnav->message('E', "Enter file");
      return XNAV__HOLDCOMMAND;
    }

    sts = gdh_NameToAttrref(pwr_cNObjid, object_str, &aref);
    if (EVEN(sts)) {
      xnav->message('E', "Object not found");
      return XNAV__HOLDCOMMAND;
    }

    sts = gdh_FWriteObject(file_str, &aref);
    if (EVEN(sts))
      xnav->message(' ', XNav::get_message(sts));
  } else {
    xnav->message('E', "Syntax error");
    return XNAV__HOLDCOMMAND;
  }

  return XNAV__SUCCESS;
}

static int xnav_read_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;

  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "OBJECT", strlen(arg1_str)) == 0) {
    pwr_tOName object_str;
    pwr_tFileName file_str;
    int sts;
    pwr_tAttrRef aref;

    if (EVEN(dcli_get_qualifier("/OBJECT", object_str, sizeof(object_str)))) {
      if (EVEN(dcli_get_qualifier(
              "dcli_arg2", object_str, sizeof(object_str)))) {
        xnav->message('E', "Object is missing");
        return XNAV__HOLDCOMMAND;
      }
    }

    if (EVEN(dcli_get_qualifier("/FILE", file_str, sizeof(file_str)))) {
      xnav->message('E', "Enter file");
      return XNAV__HOLDCOMMAND;
    }

    sts = gdh_NameToAttrref(pwr_cNObjid, object_str, &aref);
    if (EVEN(sts)) {
      xnav->message('E', "Object not found");
      return XNAV__HOLDCOMMAND;
    }

    sts = gdh_FReadObject(file_str, &aref);
    if (EVEN(sts))
      xnav->message(' ', XNav::get_message(sts));
  } else {
    xnav->message('E', "Syntax error");
    return XNAV__HOLDCOMMAND;
  }

  return XNAV__SUCCESS;
}

static int xnav_wait_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;

  char time_str[80];
  float ftime;
  int sts;

  if (EVEN(dcli_get_qualifier("/TIME", time_str, sizeof(time_str)))) {
    if (EVEN(dcli_get_qualifier("dcli_arg1", time_str, sizeof(time_str)))) {
      xnav->message('E', "Time is missing");
      return XNAV__HOLDCOMMAND;
    }
  }

  sts = sscanf(time_str, "%f", &ftime);
  if (sts != 1) {
    xnav->message('E', "Time syntax error");
    return XNAV__HOLDCOMMAND;
  }

  xnav->wow->Wait(ftime);

  return XNAV__SUCCESS;
}

static int xnav_oplog_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;

  char arg1_str[80];
  int arg1_sts;
  pwr_tCmd cmd;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "START", strlen(arg1_str)) == 0) {
    pwr_tFileName file_str;

    int event = ODD(dcli_get_qualifier("/EVENT", 0, 0));

    if (EVEN(dcli_get_qualifier("/FILE", file_str, sizeof(file_str)))) {
      char* s;

      if ((s = strrchr(xnav->opplace_name, '-')))
        s++;
      else
        s = xnav->opplace_name;

      sprintf(file_str, xttlog_cLogFile, cdh_Low(s));

      // Save any previous file with this name
      sprintf(cmd, "pwrp_env.sh save file %s", file_str);
      system(cmd);
    }

    if (event)
      XttGe::eventlog_enable(1);

    XttLog* log = new XttLog(file_str, event);
    XttLog::delete_default();
    log->set_default();

    xnav->message('I', "Operator logging started");
  } else if (str_NoCaseStrncmp(arg1_str, "STOP", strlen(arg1_str)) == 0) {
    XttLog::delete_default();

    xnav->message('I', "Operator logging stopped");
  } else if (str_NoCaseStrncmp(arg1_str, "PLAY", strlen(arg1_str)) == 0) {
    pwr_tStatus sts;
    pwr_tFileName file_str;
    int num;
    char speed_str[40];
    double speed;
    char pid_str[40];
    int pid;

    if (EVEN(dcli_get_qualifier("/FILE", file_str, sizeof(file_str)))) {
      char* s;

      if ((s = strrchr(xnav->opplace_name, '-')))
        s++;
      else
        s = xnav->opplace_name;

      sprintf(file_str, xttlog_cLogFile, cdh_Low(s));
    }

    if (ODD(dcli_get_qualifier("/SPEED", speed_str, sizeof(speed_str)))) {
      num = sscanf(speed_str, "%lf", &speed);
      if (num != 1) {
        xnav->message('E', "Speed syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else
      speed = 1;

    if (ODD(dcli_get_qualifier("/PID", pid_str, sizeof(pid_str)))) {
      num = sscanf(pid_str, "%d", &pid);
      if (num != 1) {
        xnav->message('E', "Pid syntax error");
        return XNAV__HOLDCOMMAND;
      }
    } else
      pid = 0;

    sts = XttLog::play(xnav, file_str, speed, pid);
    if (EVEN(sts))
      xnav->message(' ', XNav::get_message(sts));
  } else {
    xnav->message('E', "Syntax error");
    return XNAV__HOLDCOMMAND;
  }
  return XNAV__SUCCESS;
}

static int xnav_emit_func(void* client_data, void* client_flag)
{
  XNav* xnav = (XNav*)client_data;

  char arg1_str[80];
  int arg1_sts;

  arg1_sts = dcli_get_qualifier("dcli_arg1", arg1_str, sizeof(arg1_str));

  if (str_NoCaseStrncmp(arg1_str, "SIGNAL", strlen(arg1_str)) == 0) {
    pwr_tString80 signalname_str;
    ApplListElem* elem;
    char* instance_p;
    char* graph_p;
    pwr_tAName instance_str;
    pwr_tString80 graph_str;
    void* appl_ctx;

    if (EVEN(dcli_get_qualifier(
            "/SIGNALNAME", signalname_str, sizeof(signalname_str)))) {
      xnav->message('E', "Syntax error");
      return XNAV__HOLDCOMMAND;
    }

    if (ODD(dcli_get_qualifier("/GRAPH", graph_str, sizeof(graph_str))))
      graph_p = graph_str;
    else
      graph_p = 0;

    if (ODD(dcli_get_qualifier(
            "/INSTANCE", instance_str, sizeof(instance_str))))
      instance_p = instance_str;
    else
      instance_p = 0;

    if (graph_p) {
      // Send to specified graph
      if (xnav->appl.find(applist_eType_Graph, graph_p, instance_p, &appl_ctx))
        ((XttGe*)appl_ctx)->signal_send(signalname_str);
      else if (xnav->appl.find(
                   applist_eType_MultiView, graph_p, instance_p, &appl_ctx))
        ((XttMultiView*)appl_ctx)->signal_send(signalname_str);
    } else {
      // Graph not specified, send to all
      for (elem = xnav->appl.root; elem; elem = elem->next) {
        if (elem->type == applist_eType_Graph)
          ((XttGe*)elem->ctx)->signal_send(signalname_str);
        else if (elem->type == applist_eType_MultiView)
          ((XttMultiView*)elem->ctx)->signal_send(signalname_str);
      }
    }
  } else {
    xnav->message('E', "Syntax error");
    return XNAV__HOLDCOMMAND;
  }
  return XNAV__SUCCESS;
}

int XNav::show_database(int nopop)
{
  int sts;
  pwr_tObjid root;
  pwr_tClassId classid;
  Item* item;
  int toplevel_cnt;

  // Get the toplevel objects
  sts = gdh_GetRootList(&root);
  if (sts == GDH__NOSUCHOBJ)
    return 1;
  if (EVEN(sts))
    return sts;

  //  Loop through all root objects and see if they are valid at toplevel
  toplevel_cnt = 0;
  while (ODD(sts)) {
    sts = gdh_GetObjectClass(root, &classid);
    if (ODD(sts)) {
      if (!toplevel_cnt) {
        if (!nopop)
          brow_pop();
        brow_SetNodraw(brow->ctx);
      }
      sts = create_object_item(
          root, NULL, flow_eDest_IntoLast, (void**)&item, 0);
      if (EVEN(sts))
        return sts;
      toplevel_cnt++;
    }
    sts = gdh_GetNextSibling(root, &root);
  }

  if (!toplevel_cnt) {
    message('I', "No objects found in database");
    return 1;
  }
  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
  return 1;
}

pwr_tStatus XNav::get_command_sts()
{
  return command_sts;
}

int XNav::script(char* buffer)
{
  int sts;

  sts = readcmdfile(0, buffer);
  if (EVEN(sts))
    return sts;

  command_sts = sts;
  return DCLI__SUCCESS;
}

int XNav::command(char* input_str)
{
  char command[1000];
  int sts, sym_sts;
  char symbol_value[DCLI_SYM_VALUE_SIZE];

  if (input_str[0] == '@') {
    sts = dcli_replace_symbol(input_str, command, sizeof(command));
    if (EVEN(sts))
      return sts;

    /* Read command file */
    sts = readcmdfile(&command[1], 0);
    if (sts == DCLI__NOFILE) {
      char tmp[1030];
      snprintf(tmp, sizeof(tmp), "Unable to open file \"%s\"", &command[1]);
      message('E', tmp);
      return DCLI__SUCCESS;
    } else if (EVEN(sts))
      return sts;

    command_sts = sts;
    return DCLI__SUCCESS;
  }
  // dcli_toupper( input_str, input_str);
  sts = dcli_replace_symbol(input_str, command, sizeof(command));
  if (EVEN(sts))
    return sts;

  XttLog::dlog(xttlog_eCategory_Command, command, 0, 0);

  sts = dcli_cli((dcli_tCmdTable*)&xnav_command_table, command, (void*)this, 0);
  if (sts == DCLI__COM_NODEF) {
    /* Try to find a matching symbol */
    sym_sts = dcli_get_symbol_cmd(command, symbol_value);
    if (ODD(sym_sts)) {
      if (symbol_value[0] == '@') {
        /* Read command file */
        sts = readcmdfile(&symbol_value[1], 0);
        if (sts == DCLI__NOFILE) {
          char tmp[230];
          snprintf(tmp, sizeof(tmp), "Unable to open file \"%s\"", &symbol_value[1]);
          message('E', tmp);
          return DCLI__SUCCESS;
        } else if (EVEN(sts))
          return sts;
        return DCLI__SUCCESS;
      }
      sts = dcli_cli(
          (dcli_tCmdTable*)&xnav_command_table, symbol_value, (void*)this, 0);
    } else if (sym_sts == DCLI__SYMBOL_AMBIG)
      sts = sym_sts;
  }
  if (sts == DCLI__COM_AMBIG)
    message('E', "Ambiguous command");
  else if (sts == DCLI__COM_NODEF)
    message('E', "Undefined command");
  else if (sts == DCLI__QUAL_AMBIG)
    message('E', "Ambiguous qualifier");
  else if (sts == DCLI__QUAL_NODEF)
    message('E', "Undefined qualifier");
  else if (sts == DCLI__SYMBOL_AMBIG)
    message('E', "Ambiguous symbol abbrevation");

  command_sts = sts;
  return DCLI__SUCCESS;
}

static int xnav_getcurrenttext_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  XNav* xnav;
  char text[80];
  brow_tNode* node_list;
  int node_count;

  if (arg_count != 0)
    return CCM__ARGMISM;

  xnav_get_stored_xnav(&xnav);
  brow_GetSelectedNodes(xnav->brow->ctx, &node_list, &node_count);
  if (!node_count)
    strcpy(return_string, "");
  else {
    // Get annotation number 0
    brow_GetAnnotation(node_list[0], 0, text, sizeof(text));
    free(node_list);
    strcpy(return_string, text);
  }
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int xnav_getcurrentobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  XNav* xnav;
  pwr_tOName name;
  int sts;
  pwr_sAttrRef attrref;
  int is_attr;

  if (arg_count != 0)
    return CCM__ARGMISM;

  xnav_get_stored_xnav(&xnav);
  sts = xnav->get_select(&attrref, &is_attr);
  if (ODD(sts))
    sts = gdh_ObjidToName(attrref.Objid, name, sizeof(name), cdh_mNName);
  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int xnav_getchild_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  int sts;
  pwr_tOName name;
  pwr_tObjid parent_objid;
  pwr_tObjid child_objid;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = gdh_NameToObjid(arg_list->value_string, &parent_objid);
  if (ODD(sts)) {
    sts = gdh_GetChild(parent_objid, &child_objid);
    if (ODD(sts))
      sts = gdh_ObjidToName(child_objid, name, sizeof(name), cdh_mNName);
  }
  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int xnav_getparent_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  int sts;
  pwr_tOName name;
  pwr_tObjid parent_objid;
  pwr_tObjid child_objid;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = gdh_NameToObjid(arg_list->value_string, &child_objid);
  if (ODD(sts)) {
    sts = gdh_GetParent(child_objid, &parent_objid);
    if (ODD(sts))
      sts = gdh_ObjidToName(parent_objid, name, sizeof(name), cdh_mNName);
  }
  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int xnav_getnextsibling_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  pwr_tOName name;
  pwr_tObjid objid;
  pwr_tObjid next_objid;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = gdh_NameToObjid(arg_list->value_string, &objid);
  if (ODD(sts)) {
    sts = gdh_GetNextSibling(objid, &next_objid);
    if (ODD(sts))
      sts = gdh_ObjidToName(next_objid, name, sizeof(name), cdh_mNName);
  }
  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int xnav_getclasslist_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  pwr_tOName name;
  pwr_tClassId classid;
  pwr_tObjid objid;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = gdh_ClassNameToId(arg_list->value_string, &classid);
  if (ODD(sts)) {
    sts = gdh_GetClassList(classid, &objid);
    if (ODD(sts))
      sts = gdh_ObjidToName(objid, name, sizeof(name), cdh_mNName);
  }
  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int xnav_getrootlist_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  pwr_tOName name;
  pwr_tObjid objid;

  if (arg_count != 0)
    return CCM__ARGMISM;

  sts = gdh_GetRootList(&objid);
  if (ODD(sts))
    sts = gdh_ObjidToName(objid, name, sizeof(name), cdh_mNName);

  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int xnav_getnodeobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  pwr_tOName name;
  pwr_tObjid objid;

  if (arg_count != 0)
    return CCM__ARGMISM;

  sts = gdh_GetNodeObject(0, &objid);
  if (ODD(sts))
    sts = gdh_ObjidToName(objid, name, sizeof(name), cdh_mNName);

  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int xnav_getnextobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  pwr_tOName name;
  pwr_tObjid objid;
  pwr_tObjid next_objid;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = gdh_NameToObjid(arg_list->value_string, &objid);
  if (ODD(sts)) {
    sts = gdh_GetNextObject(objid, &next_objid);
    if (ODD(sts))
      sts = gdh_ObjidToName(next_objid, name, sizeof(name), cdh_mNName);
  }
  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int xnav_getobjectclass_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  int sts;
  pwr_tOName name;
  pwr_tObjid objid;
  pwr_tClassId classid = 0;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  sts = gdh_NameToObjid(arg_list->value_string, &objid);
  if (ODD(sts))
    sts = gdh_GetObjectClass(objid, &classid);
  if (ODD(sts))
    sts = gdh_ObjidToName(
        cdh_ClassIdToObjid(classid), name, sizeof(name), cdh_mName_object);
  if (ODD(sts))
    strcpy(return_string, name);
  else
    strcpy(return_string, "");
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int xnav_messageerror_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  XNav* xnav;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  xnav_get_stored_xnav(&xnav);
  xnav->message('E', arg_list->value_string);

  *return_int = 1;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int xnav_messageinfo_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  XNav* xnav;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  xnav_get_stored_xnav(&xnav);
  xnav->message('I', arg_list->value_string);

  *return_int = 1;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int xnav_confirmdialog_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  XNav* xnav;
  ccm_sArg* arg_p2;
  int sts;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  xnav_get_stored_xnav(&xnav);
  sts = xnav->confirm_dialog(arg_list->value_string, arg_p2->value_string);

  *return_int = sts;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int xnav_cutobjectname_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;
  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  xnav_cut_segments(return_string, arg_list->value_string, arg_p2->value_int);

  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int xnav_getattribute_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  ccm_sArg* arg_p2;
  int sts;
  int value_decl;
  ccm_tInt value_int;
  ccm_tFloat value_float;
  ccm_tString value_string;

  if (!(arg_count == 2 || arg_count == 1))
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;
  if (arg_count == 2 && arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  sts = xnav_attribute_func(arg_list->value_string, &value_decl, &value_float,
      &value_int, value_string);
  if (EVEN(sts)) {
    if (arg_count == 2) {
      arg_p2->value_int = 0;
      arg_p2->value_returned = 1;
      arg_p2->var_decl = arg_p2->value_decl;
    }
    *return_decl = CCM_DECL_UNKNOWN;
  } else {
    if (value_decl == CCM_DECL_INT) {
      *return_int = value_int;
      *return_decl = CCM_DECL_INT;
    } else if (value_decl == CCM_DECL_FLOAT) {
      *return_float = value_float;
      *return_decl = CCM_DECL_FLOAT;
    } else if (value_decl == CCM_DECL_STRING) {
      strcpy(return_string, value_string);
      *return_decl = CCM_DECL_STRING;
    }
    if (arg_count == 2) {
      arg_p2->value_int = 1;
      arg_p2->value_returned = 1;
      arg_p2->var_decl = arg_p2->value_decl;
    }
  }

  return 1;
}

static int xnav_setattribute_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  ccm_sArg *arg_p2, *arg_p3;
  int sts;
  pwr_sAttrRef attrref;
  pwr_tTypeId attr_type;
  unsigned int attr_size, attr_offset, attr_dim;
  unsigned int a_flags;
  int publicwrite = 0;
  XNav* xnav;

  if (!(arg_count == 3 || arg_count == 2))
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;
  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;
  if (arg_count == 3) {
    if (arg_p3->value_decl != CCM_DECL_INT)
      return CCM__ARGMISM;

    if (arg_p3->value_int == 1)
      publicwrite = 1;
  }

  xnav_get_stored_xnav(&xnav);

  sts = gdh_NameToAttrref(pwr_cNObjid, arg_list->value_string, &attrref);
  if (EVEN(sts)) {
    *return_int = sts;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  // Check authorization
  if (publicwrite) {
    sts = gdh_GetAttributeFlags(&attrref, &a_flags);
    if (EVEN(sts))
      return sts;

    if (!(a_flags & pwr_mAdef_publicwrite))
      sts = XNAV__NOTAUTHORIZED;
    if (!((xnav->priv & pwr_mPrv_RtRead) || (xnav->priv & pwr_mPrv_RtWrite)
            || (xnav->priv & pwr_mPrv_System)
            || (xnav->priv & pwr_mPrv_Maintenance)
            || (xnav->priv & pwr_mPrv_Process)
            || (xnav->priv & pwr_mPrv_Instrument)
            || (xnav->priv & pwr_mPrv_Operator1)
            || (xnav->priv & pwr_mPrv_Operator2)
            || (xnav->priv & pwr_mPrv_Operator3)
            || (xnav->priv & pwr_mPrv_Operator4)
            || (xnav->priv & pwr_mPrv_Operator5)
            || (xnav->priv & pwr_mPrv_Operator6)
            || (xnav->priv & pwr_mPrv_Operator7)
            || (xnav->priv & pwr_mPrv_Operator8)
            || (xnav->priv & pwr_mPrv_Operator9)
            || (xnav->priv & pwr_mPrv_Operator10)))
      sts = XNAV__NOTAUTHORIZED;
  } else {
    if (!((xnav->priv & pwr_mPrv_RtWrite) || (xnav->priv & pwr_mPrv_System)))
      sts = XNAV__NOTAUTHORIZED;
  }

  if (EVEN(sts)) {
    *return_int = sts;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  sts = gdh_GetAttributeCharAttrref(
      &attrref, &attr_type, &attr_size, &attr_offset, &attr_dim);
  if (EVEN(sts))
    return sts;

  switch (arg_p2->value_decl) {
  case CCM_DECL_STRING: {
    char buffer[512];

    sts = xnav->attr_string_to_value(
        attr_type, arg_p2->value_string, buffer, sizeof(buffer), attr_size);
    if (ODD(sts))
      sts = gdh_SetObjectInfo(arg_list->value_string, buffer, attr_size);
    break;
  }
  case CCM_DECL_INT: {
    switch (attr_type) {
    case pwr_eType_Int8: {
      pwr_tInt8 val = arg_p2->value_int;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    case pwr_eType_Int16: {
      pwr_tInt16 val = arg_p2->value_int;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    case pwr_eType_Int32: {
      pwr_tInt32 val = arg_p2->value_int;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    case pwr_eType_Int64: {
      pwr_tInt64 val = arg_p2->value_int;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    case pwr_eType_UInt8: {
      pwr_tUInt8 val = arg_p2->value_int;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    case pwr_eType_UInt16: {
      pwr_tUInt16 val = arg_p2->value_int;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    case pwr_eType_UInt32: {
      pwr_tUInt32 val = arg_p2->value_int;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    case pwr_eType_UInt64: {
      pwr_tUInt64 val = arg_p2->value_int;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    case pwr_eType_Float32: {
      pwr_tFloat32 val = arg_p2->value_int;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    case pwr_eType_Float64: {
      pwr_tFloat64 val = arg_p2->value_int;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    case pwr_eType_Boolean: {
      pwr_tBoolean val = arg_p2->value_int ? 1 : 0;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    }
    break;
  }
  case CCM_DECL_FLOAT: {
    switch (attr_type) {
    case pwr_eType_Int8: {
      pwr_tInt8 val = arg_p2->value_float;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    case pwr_eType_Int16: {
      pwr_tInt16 val = arg_p2->value_float;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    case pwr_eType_Int32: {
      pwr_tInt32 val = arg_p2->value_float;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    case pwr_eType_Int64: {
      pwr_tInt64 val = arg_p2->value_float;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    case pwr_eType_UInt8: {
      pwr_tUInt8 val = arg_p2->value_float;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    case pwr_eType_UInt16: {
      pwr_tUInt16 val = arg_p2->value_float;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    case pwr_eType_UInt32: {
      pwr_tUInt32 val = arg_p2->value_float;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    case pwr_eType_UInt64: {
      pwr_tUInt64 val = arg_p2->value_float;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    case pwr_eType_Float32: {
      pwr_tFloat32 val = arg_p2->value_float;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    case pwr_eType_Float64: {
      pwr_tFloat64 val = arg_p2->value_float;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    case pwr_eType_Boolean: {
      pwr_tBoolean val = arg_p2->value_float ? 1 : 0;
      sts = gdh_SetObjectInfo(arg_list->value_string, &val, attr_size);
      break;
    }
    }
    break;
  }
  }

  *return_int = sts;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int xnav_getuser_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  XNav* xnav;

  if (arg_count != 0)
    return CCM__ARGMISM;

  xnav_get_stored_xnav(&xnav);

  strcpy(return_string, xnav->user);
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int xnav_getprivileges_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  XNav* xnav;

  if (arg_count != 0)
    return CCM__ARGMISM;

  xnav_get_stored_xnav(&xnav);

  *return_int = xnav->priv;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int xnav_getgraphinstance_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  XNav* xnav;
  XttGe* gectx;
  int sts;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  xnav_get_stored_xnav(&xnav);

  if (xnav->appl.find_graph_first(arg_list->value_string, (void**)&gectx)) {
    sts = gectx->get_object_name(0, sizeof(ccm_tString), return_string);
    if (EVEN(sts))
      strcpy(return_string, "");
  } else
    strcpy(return_string, "");

  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int xnav_getgraphinstancenext_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  XNav* xnav;
  XttGe* gectx;
  int sts;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  if (arg_p2->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  xnav_get_stored_xnav(&xnav);

  if (xnav->appl.find_graph_next(
          arg_list->value_string, arg_p2->value_string, (void**)&gectx)) {
    sts = gectx->get_object_name(0, sizeof(ccm_tString), return_string);
    if (EVEN(sts))
      strcpy(return_string, "");
  } else
    strcpy(return_string, "");

  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int xnav_setsubwindow_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  XNav* xnav;
  XttGe* gectx;
  int sts;
  ccm_sArg *arg_p2, *arg_p3, *arg_p4, *arg_p5;
  XttMultiView* mvctx;
  pwr_tOName graph_str;
  char name_str[80];
  char object_str[800];
  char *object_p = 0;
  pwr_tOName source_str;
  int self = 0;

  if (arg_count < 3)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  if (arg_p2->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  if (arg_p3->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  if (arg_count > 3) {
    arg_p4 = arg_p3->next;
    if (arg_p4->value_decl != CCM_DECL_STRING)
      return CCM__ARGMISM;
    if (strcmp(arg_p4->value_string, "") != 0) {
      strncpy(object_str, arg_p4->value_string, sizeof(object_str)-1);
      object_p = object_str;
    }
  }
  
  if (arg_count > 4) {
    arg_p5 = arg_p4->next;
    if (arg_p5->value_decl != CCM_DECL_INT)
      return CCM__ARGMISM;
    self = arg_p5->value_int; 
  }
  
  strncpy(graph_str, arg_list->value_string, sizeof(graph_str)-1);
  strncpy(name_str, arg_p2->value_string, sizeof(name_str)-1);
  strncpy(source_str, arg_p3->value_string, sizeof(source_str)-1);
  if (strcmp(object_str, "") == 0)
    object_p = 0;
  else
    object_p = object_str;

  xnav_get_stored_xnav(&xnav);

  if (str_NoCaseStrcmp(graph_str, "$current") == 0 && xnav->current_cmd_ctx) {
    gectx = (XttGe*)xnav->current_cmd_ctx;
    sts = gectx->set_subwindow_source(name_str, source_str, object_p);
    if (self) {
      *return_int = GLOW__SUBTERMINATED;      
      *return_decl = CCM_DECL_INT;
      return CCM__EXITFUNC;
    }

#if 0
    if (focus_p) {
      sprintf(focus, "%s.%s", name_str, focus_p);
      gectx->set_object_focus(focus, inputempty);
    }
#endif
  } else if (xnav->appl.find_graph(graph_str, 0, (void**)&gectx)) {
    if (streq(source_str, "")) {
      xnav->message('E', "Syntax error");
      return XNAV__HOLDCOMMAND;
    }
    sts = gectx->set_subwindow_source(name_str, source_str, object_p);
    if (self) {
      *return_int = GLOW__SUBTERMINATED;      
      *return_decl = CCM_DECL_INT;
      return CCM__EXITFUNC;
    }

#if 0
    if (focus_p) {
      sprintf(focus, "%s.%s", name_str, focus_p);
      gectx->set_object_focus(focus, inputempty);
    }
#endif
  } else {
    pwr_tStatus sts;
    pwr_tAttrRef aref;
    double borders[4] = { 0, 0, 0, 0 };
    double* bordersp = borders;
    int cont = 0;

    xnav_replace_node_str(graph_str, graph_str);

    bordersp = 0;

    sts = gdh_NameToAttrref(pwr_cNObjid, graph_str, &aref);
    if (ODD(sts)
	&& xnav->appl.find(applist_eType_MultiView, &aref, (void**)&mvctx)) {
      return mvctx->set_subwindow_source(
	  name_str, source_str, object_p, bordersp, cont);
    }
  }
  *return_int = sts;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int xnav_quit_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  exit(0);
}

static int xnav_sleep_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  XNav* xnav;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  xnav_get_stored_xnav(&xnav);
  xnav->wow->Wait(arg_list->value_float);
  return 1;
}

static int xnav_ccm_deffilename_func(
    char* outfile, char* infile, void* client_data)
{
  pwr_tFileName fname;

  dcli_translate_filename(fname, infile);
  dcli_get_defaultfilename(fname, outfile, ".rtt_com");
  return 1;
}

static int xnav_ccm_errormessage_func(
    char* msg, int severity, void* client_data)
{
  XNav* xnav = (XNav*)client_data;

  switch(severity) {
  case msg_eSeverity_Info:
  case msg_eSeverity_Success:
    xnav->message('I', msg);
    break;
  case msg_eSeverity_Warning:
    xnav->message('W', msg);
    break;
  case msg_eSeverity_Error:
  case msg_eSeverity_Fatal:
    xnav->message('E', msg);
    break;
  }
  return 1;
}

int xnav_externcmd_func(char* cmd, void* client_data)
{
  XNav* xnav = (XNav*)client_data;

  return xnav->command(cmd);
}

/*************************************************************************
*
* Name:		readcmdfile()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*
**************************************************************************/

int XNav::readcmdfile(char* incommand, char* buffer)
{
  char input_str[160];
  int sts = 0;
  int appl_sts = 0;

  if (!ccm_func_registred) {
    sts = ccm_register_function(
        "Xtt", "GetCurrentText", xnav_getcurrenttext_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Xtt", "GetCurrentObject", xnav_getcurrentobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Xtt", "GetChild", xnav_getchild_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Xtt", "GetParent", xnav_getparent_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Xtt", "GetNextSibling", xnav_getnextsibling_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Xtt", "GetClassList", xnav_getclasslist_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Xtt", "GetRootList", xnav_getrootlist_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Xtt", "GetNodeObject", xnav_getnodeobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Xtt", "GetNextObject", xnav_getnextobject_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Xtt", "GetObjectClass", xnav_getobjectclass_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Xtt", "MessageError", xnav_messageerror_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Xtt", "MessageInfo", xnav_messageinfo_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Xtt", "CutObjectName", xnav_cutobjectname_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Xtt", "GetAttribute", xnav_getattribute_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Xtt", "SetAttribute", xnav_setattribute_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Xtt", "ConfirmDialog", xnav_confirmdialog_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Xtt", "GetUser", xnav_getuser_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Xtt", "GetPrivileges", xnav_getprivileges_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Xtt", "GetGraphInstance", xnav_getgraphinstance_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Xtt", "GetGraphInstanceNext", xnav_getgraphinstancenext_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function(
        "Xtt", "SetSubwindow", xnav_setsubwindow_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Xtt", "Quit", xnav_quit_func);
    if (EVEN(sts))
      return sts;
    sts = ccm_register_function("Xtt", "Sleep", xnav_sleep_func);
    if (EVEN(sts))
      return sts;

    sts = ccm_create_external_var(
        "GLOW__SUBTERMINATED", CCM_DECL_INT, 0, GLOW__SUBTERMINATED, 0);

    ccm_func_registred = 1;
  }

  if (incommand) {
    strcpy(input_str, incommand);
    str_trim(input_str, input_str);
    xnav_store_xnav(this);

    /* Read and execute the command file */
    sts = ccm_file_exec(input_str, xnav_externcmd_func,
        xnav_ccm_deffilename_func, xnav_ccm_errormessage_func, &appl_sts,
        verify, 0, NULL, 0, 0, NULL, (void*)this);
    if (EVEN(sts))
      return sts;
  } else if (buffer) {
    /* Execute the buffer */
    sts = ccm_buffer_exec(buffer, xnav_externcmd_func,
        xnav_ccm_deffilename_func, xnav_ccm_errormessage_func, &appl_sts, 
	verify, 0, NULL, 0, NULL, (void*)this);
    if (EVEN(sts))
      return sts;
  }

  if (sts == CCM__EXITFUNC)
    return appl_sts;
  return 1;
}

int xnav_cut_segments(char* outname, char* name, int segments)
{
  char* s[20];
  int i, j, last_i = 0;

  if (segments == 0) {
    strcpy(outname, "");
    return 1;
  }
      
  for (i = 0; i < segments; i++) {
    s[i] = strrchr(name, '-');
    if (s[i] == 0) {
      last_i = i;
      break;
    }
    *s[i] = '+';
    last_i = i;
  }
  for (j = 0; j <= last_i; j++) {
    if (s[j] != 0)
      *s[j] = '-';
  }
  if (s[last_i] == 0)
    strcpy(outname, name);
  else
    strcpy(outname, s[last_i] + 1);

  return 1;
}

/*************************************************************************
*
* Name:		xnav_attribute_func()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*		Backcall function for ccm.
*
**************************************************************************/
static int xnav_attribute_func(char* name, int* return_decl,
    ccm_tFloat* return_float, ccm_tInt* return_int, char* return_string)
{
  int sts;
  char object_par[80];
  char* object_element;
  int decl = 0;
  ccm_tInt int_val = 0;
  ccm_tFloat float_val = 0.0;
  ccm_tString string_val;
  pwr_sAttrRef attrref;
  pwr_tTypeId attrtype;
  unsigned int attrsize, attroffs, attrelem;

  sts = gdh_NameToAttrref(pwr_cNObjid, name, &attrref);
  if (EVEN(sts))
    return sts;

  /* Get type of attribute */
  sts = gdh_GetAttributeCharacteristics(
      name, &attrtype, &attrsize, &attroffs, &attrelem);
  if (EVEN(sts))
    return sts;

  /* Get the pointer to attribute */
  sts = gdh_GetObjectInfo(name, &object_par, sizeof(object_par));
  if (EVEN(sts))
    return sts;

  object_element = object_par;

  switch (attrtype) {
  case pwr_eType_Boolean: {
    int_val = *(pwr_tBoolean*)object_element;
    decl = CCM_DECL_INT;
    break;
  }
  case pwr_eType_Float32: {
    float_val = *(pwr_tFloat32*)object_element;
    decl = CCM_DECL_FLOAT;
    break;
  }
  case pwr_eType_Float64: {
    float_val = *(pwr_tFloat64*)object_element;
    decl = CCM_DECL_FLOAT;
    break;
  }
  case pwr_eType_Char: {
    int_val = *(pwr_tChar*)object_element;
    decl = CCM_DECL_INT;
    break;
  }
  case pwr_eType_Int8: {
    int_val = *(pwr_tInt8*)object_element;
    decl = CCM_DECL_INT;
    break;
  }
  case pwr_eType_Int16: {
    int_val = *(pwr_tInt16*)object_element;
    decl = CCM_DECL_INT;
    break;
  }
  case pwr_eType_Int32:
  case pwr_eType_Enum: {
    int_val = *(pwr_tInt32*)object_element;
    decl = CCM_DECL_INT;
    break;
  }
  case pwr_eType_Int64: {
    int_val = *(pwr_tInt64*)object_element;
    decl = CCM_DECL_INT;
    break;
  }
  case pwr_eType_UInt8: {
    int_val = *(pwr_tUInt8*)object_element;
    decl = CCM_DECL_INT;
    break;
  }
  case pwr_eType_UInt16: {
    int_val = *(pwr_tUInt16*)object_element;
    decl = CCM_DECL_INT;
    break;
  }
  case pwr_eType_UInt32:
  case pwr_eType_ClassId:
  case pwr_eType_TypeId:
  case pwr_eType_CastId:
  case pwr_eType_VolumeId:
  case pwr_eType_ObjectIx:
  case pwr_eType_Status:
  case pwr_eType_NetStatus:
  case pwr_eType_Mask: {
    int_val = *(pwr_tUInt32*)object_element;
    decl = CCM_DECL_INT;
    break;
  }
  case pwr_eType_UInt64: {
    int_val = *(pwr_tUInt64*)object_element;
    decl = CCM_DECL_INT;
    break;
  }
  case pwr_eType_String: {
    strncpy(string_val, object_element, sizeof(string_val));
    string_val[sizeof(string_val) - 1] = 0;
    decl = CCM_DECL_STRING;
    break;
  }
  case pwr_eType_Text: {
    strncpy(string_val, object_element, sizeof(string_val));
    string_val[sizeof(string_val) - 1] = 0;
    decl = CCM_DECL_STRING;
    break;
  }
  case pwr_eType_Objid: {
    pwr_tOName hier_name;

    /* Get the object name from ldh */
    sts = gdh_ObjidToName(*(pwr_tObjid*)object_element, hier_name,
        sizeof(hier_name), cdh_mName_volumeStrict);
    if (EVEN(sts))
      strcpy(string_val, "Undefined Object");
    else
      strncpy(string_val, hier_name, sizeof(string_val));
    string_val[sizeof(string_val) - 1] = 0;
    decl = CCM_DECL_STRING;
    break;
  }
  case pwr_eType_AttrRef: {
    pwr_tAName hier_name;

    /* Get the object name from ldh */
    sts = gdh_AttrrefToName((pwr_sAttrRef*)object_element, hier_name,
        sizeof(hier_name), cdh_mName_volumeStrict);
    if (EVEN(sts))
      strcpy(string_val, "Undefined attribute");
    else
      strncpy(string_val, hier_name, sizeof(string_val));
    string_val[sizeof(string_val) - 1] = 0;
    decl = CCM_DECL_STRING;
    break;
  }
  case pwr_eType_Time: {
    /* Convert time to ascii */
    sts = time_AtoAscii((pwr_tTime*)object_element, time_eFormat_DateAndTime,
        string_val, sizeof(string_val));
    string_val[20] = 0;
    decl = CCM_DECL_STRING;
    break;
  }
  case pwr_eType_DeltaTime: {
    /* Convert time to ascii */
    sts = time_DtoAscii((pwr_tDeltaTime*)object_element, 1,
        string_val, sizeof(string_val));
    decl = CCM_DECL_STRING;
    break;
  }
  }

  *return_decl = decl;
  if (decl == CCM_DECL_INT)
    *return_int = int_val;
  else if (decl == CCM_DECL_FLOAT)
    *return_float = float_val;
  else if (decl == CCM_DECL_STRING)
    strcpy(return_string, string_val);

  return DCLI__SUCCESS;
}

int XNav::get_current_object(
    pwr_tObjid* objid, char* objectname, int size, pwr_tBitMask nametype)
{
  int sts;
  pwr_sAttrRef attrref;
  int is_attr;

  sts = get_select(&attrref, &is_attr);
  if (ODD(sts)) {
    *objid = attrref.Objid;
    sts = gdh_ObjidToName(attrref.Objid, objectname, size, nametype);
  }
  return sts;
}

int XNav::get_current_aref(
    pwr_sAttrRef* arp, char* arname, int size, pwr_tBitMask nametype)
{
  int sts;
  int is_attr;

  sts = get_select(arp, &is_attr);
  if (ODD(sts))
    sts = gdh_AttrrefToName(arp, arname, size, nametype);

  return sts;
}
/*************************************************************************
*
* Name:		show_file()
*
* Type		int
*
* Type		Parameter	IOGF	Description
*
* Description:
*	Displays all files with matching a wilcard specification.
*
**************************************************************************/

int XNav::show_file(char* filename, char* intitle, int hide_dir)
{
  int sts;
  char title[80] = "FILE LIST";
  pwr_tFileName found_file;
  pwr_tFileName file, dir;
  char dev[80], type[80];
  int version;
  pwr_tFileName file_spec;
  pwr_tFileName text;
  item_eFileType file_type;
  std::vector<xnav_file> filelist;

  if (intitle)
    strcpy(title, intitle);

  strcpy(file_spec, filename);

  sts = dcli_search_file(file_spec, found_file, DCLI_DIR_SEARCH_INIT);
  if (EVEN(sts))
    return sts;

  dcli_parse_filename(found_file, dev, dir, file, type, &version);
  if (hide_dir) {
    strcpy(text, file);
    // str_ToLower( text, text);
    // text[0] = toupper( text[0]);
  } else
    strcpy(text, found_file);
  // str_ToUpper( type, type);
  if (streq(type, ".rtt_com"))
    file_type = item_eFileType_Script;
  else if (streq(type, ".pwg"))
    file_type = item_eFileType_Graph;
  else if (streq(type, ".rtt_log"))
    file_type = item_eFileType_RttLog;
  else
    file_type = item_eFileType_Unknown;

  brow_pop();
  brow_SetNodraw(brow->ctx);
  new ItemHeader(brow, "Title", title, NULL, flow_eDest_IntoLast);
  // new ItemFile( brow, "", text, found_file, file_type, NULL,
  // flow_eDest_IntoLast);
  xnav_file fi(text, found_file, file_type);
  filelist.push_back(fi);

  while (ODD(sts)) {
    sts = dcli_search_file(file_spec, found_file, DCLI_DIR_SEARCH_NEXT);
    if (ODD(sts)) {
      dcli_parse_filename(found_file, dev, dir, file, type, &version);
      if (hide_dir) {
        strcpy(text, file);
        // str_ToLower( text, text);
        // text[0] = toupper( text[0]);
      } else
        strcpy(text, found_file);
      // str_ToUpper( type, type);
      if (streq(type, ".rtt_com"))
        file_type = item_eFileType_Script;
      else if (streq(type, ".pwg"))
        file_type = item_eFileType_Graph;
      else if (streq(type, ".rtt_log"))
        file_type = item_eFileType_RttLog;
      else
        file_type = item_eFileType_Unknown;
      // new ItemFile( brow, "", text, found_file, file_type, NULL,
      // flow_eDest_IntoLast);

      xnav_file fi(text, found_file, file_type);
      filelist.push_back(fi);
    }
  }
  dcli_search_file(filename, found_file, DCLI_DIR_SEARCH_END);

  // Sort
  for (unsigned int i = filelist.size() - 1; i > 0; i--) {
    for (unsigned int j = 0; j < i; j++) {
      if (!(filelist[j] < filelist[j + 1])) {
        xnav_file fi = filelist[j + 1];
        filelist[j + 1] = filelist[j];
        filelist[j] = fi;
      }
    }
  }

  for (unsigned int i = 0; i < filelist.size(); i++)
    new ItemFile(brow, "", filelist[i].m_text, filelist[i].m_file,
        filelist[i].m_file_type, NULL, flow_eDest_IntoLast);

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);

  return XNAV__SUCCESS;
}

void XNav::update_time()
{
  char timstr[64];

  time_AtoAscii(NULL, time_eFormat_DateAndTime, timstr, sizeof(timstr));
  timstr[strlen(timstr) - 3] = '\0';
  strcpy(gbl.time, timstr);
}

/*************************************************************************
*
* Name:		rtt_show_par_hier_class_name()
*
* Type		int
*
* Type		Parameter	IOGF	Description
* char		*parametername	I	name of parameter.
* char		*hiername	I	name of hierarchy object.
* char		*classname	I	name of class.
* char		*name		I	name description.
* int		add		I	if added to existing menulist or
*					createing a new menu.
*
* Description:
*	This function is called when a 'show parameter' command is recieved.
*	All object under the hierarchy object, with the specified class
*	that fits in the name description is inserted in a menulist
*	and displayed on the screen.
*
**************************************************************************/

int XNav::show_par_hier_class_name(char* parametername, char* hiername,
    char* classname, char* namep, int add, int global, int max_objects)
{
  ItemCollect* item;
  int sts;
  pwr_tAName attr;
  char* s;
  pwr_tAName obj_name;
  pwr_sAttrRef ar;
  pwr_tTypeId a_type_id;
  unsigned int a_size;
  unsigned int a_offset;
  unsigned int a_dim;
  pwr_tTid a_tid;
  unsigned int a_flags = 0;
  pwr_tAName name;

  if (!namep) {
    message('E', "Syntax error");
    return XNAV__HOLDCOMMAND;
  }

  if (add != XNAV_MENU_ADD)
    brow_pop();

  try {
    pwr_tAttrRef aref;
    sts = gdh_NameToAttrref(pwr_cNObjid, namep, &aref);
    if (EVEN(sts))
      return sts;

    sts = gdh_AttrrefToName(&aref, name, sizeof(name), cdh_mNName);
    if (EVEN(sts))
      return sts;

    if (!aref.Flags.b.Object && !aref.Flags.b.ObjectAttr) {
      if ((s = strchr(name, '.')) == 0)
        return 0;
      strcpy(attr, s + 1);

      sts = gdh_GetAttributeCharAttrref(
          &aref, &a_type_id, &a_size, &a_offset, &a_dim);
      if (EVEN(sts))
        return sts;

      sts = gdh_GetAttributeFlags(&ar, &a_flags);
      if (EVEN(sts))
        return sts;

      sts = gdh_GetAttrRefTid(&aref, &a_tid);
      if (EVEN(sts))
        return sts;
    } else {
      sts = get_trace_attr(&aref, attr);
      if (EVEN(sts))
        return sts;
      strcpy(obj_name, name);
      strcat(obj_name, ".");
      strcat(obj_name, attr);
      sts = gdh_NameToAttrref(pwr_cNObjid, obj_name, &ar);
      if (EVEN(sts))
        return sts;

      strcpy(attr, strchr(obj_name, '.') + 1);

      sts = gdh_GetAttributeCharAttrref(
          &ar, &a_type_id, &a_size, &a_offset, &a_dim);
      if (EVEN(sts))
        return sts;

      sts = gdh_GetAttributeFlags(&ar, &a_flags);
      if (EVEN(sts))
        return sts;

      sts = gdh_GetAttrRefTid(&aref, &a_tid);
      if (EVEN(sts))
        return sts;
    }

    item = new ItemCollect(brow, aref.Objid, attr, NULL, flow_eDest_IntoLast,
        a_type_id, a_tid, a_size, a_flags, 0);
  } catch (co_error& e) {
    brow_push_all();
    brow_Redraw(brow->ctx, 0);
    message('E', (char*)e.what().c_str());
  }

  return XNAV__SUCCESS;
}

int XNav::find_name(char* name, pwr_tObjid* objid)
{
  int sts;

  sts = gdh_NameToObjid(name, objid);
  return sts;
}

int XNav::store(char* filename, int collect)
{
  pwr_tFileName filename_str;
  FILE* outfile;
  int first;
  brow_tNode* node_list;
  int node_count;
  Item* item;
  int i;

  /* Add default extention '.rtt_com' if there is no extention given */
  dcli_get_defaultfilename(filename, filename_str, ".rtt_com");

  /* Open the file */
  outfile = fopen(filename_str, "w");
  if (outfile == 0) {
    char tmp[280];
    snprintf(tmp, sizeof(tmp), "Unable to open file \"%s\"", filename_str);
    message('E', tmp);
    return XNAV__HOLDCOMMAND;
  }

  /* Loop through the menu item */
  if (collect)
    brow_GetObjectList(collect_brow->ctx, &node_list, &node_count);
  else
    brow_GetObjectList(brow->ctx, &node_list, &node_count);

  first = 1;
  for (i = 0; i < node_count; i++) {
    brow_GetUserData(node_list[i], (void**)&item);
    if (first) {
      if (collect) {
        fprintf(outfile, "collect clear\n");
        fprintf(outfile, "collect/name=%s\n", item->name);
      } else
        fprintf(outfile, "show parameter/name=%s\n", item->name);
      first = 0;
    } else {
      if (collect)
        fprintf(outfile, "collect/name=%s\n", item->name);
      else
        fprintf(outfile, "add parameter/name=%s\n", item->name);
    }
  }

  if (collect)
    fprintf(outfile, "collect show\n");

  dcli_fgetname(outfile, filename_str, filename_str);
  fclose(outfile);

  char msg[15 + sizeof(filename_str) + 1];
  sprintf(msg, "Picture stored %s", filename_str);
  message('I', msg);
  return XNAV__SUCCESS;
}

int XNav::show_symbols()
{
  int sts;
  int i;
  char key[DCLI_SYM_KEY_SIZE];
  char value[DCLI_SYM_VALUE_SIZE];
  char text[410];

  i = 0;
  while (1) {
    sts = dcli_get_symbol_by_index(i, key, value);
    if (EVEN(sts))
      break;

    sprintf(text, "%s = \"%s\"", key, value);
    if (i == 0) {
      brow_pop();
      brow_SetNodraw(brow->ctx);
      new ItemHeader(brow, "Title", "Symbols", NULL, flow_eDest_IntoLast);
    }
    new ItemCommand(
        brow, text, 0, NULL, flow_eDest_IntoLast, key, 0, brow->pixmap_symbol);
    i++;
  }
  if (i == 0)
    message('I', "Symboltable is empty");
  else {
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, 0);
  }
  return XNAV__SUCCESS;
}

void xnav_popup_menu_cb(void* xnav, pwr_sAttrRef attrref,
    unsigned long item_type, unsigned long utility, char* arg, int x, int y)
{
  ((XNav*)xnav)
      ->get_popup_menu(attrref, (xmenu_eItemType)item_type,
          (xmenu_mUtility)utility, ((XNav*)xnav)->priv, arg, x, y);
}

int xnav_call_method_cb(void* xnav, const char* method, const char* filter,
    pwr_sAttrRef attrref, unsigned long item_type, unsigned long utility,
    char* arg)
{
  return ((XNav*)xnav)
      ->call_method(method, filter, attrref, (xmenu_eItemType)item_type,
          (xmenu_mUtility)utility, ((XNav*)xnav)->priv, arg);
}

void xnav_start_trace_cb(void* xnav, pwr_tObjid objid, char* name)
{
  ((XNav*)xnav)->start_trace(objid, name);
}

static void xnav_clog_close_cb(void* ctx)
{
  XNav* xnav = (XNav*)ctx;
  delete xnav->clog;
  xnav->clog = 0;
}

static void xnav_ev_help_cb(void* ctx, const char* key)
{
  XNav* xnav = (XNav*)ctx;
  int sts;
  pwr_tObjid objid;
  char objid_str[40];

  sts = CoXHelp::dhelp(key, "", navh_eHelpFile_Project, NULL, 0);
  if (EVEN(sts)) {
    // Try to convert to objid and search for objid as topic
    sts = gdh_NameToObjid(key, &objid);
    if (ODD(sts)) {
      cdh_OidToString(objid_str, sizeof(objid_str), objid, 1);
      sts = CoXHelp::dhelp(objid_str, "", navh_eHelpFile_Project, NULL, 0);
    }
  }
  if (EVEN(sts))
    sts = CoXHelp::dhelp(key, "", navh_eHelpFile_Base, NULL, 0);

  if (EVEN(sts))
    xnav->message('E', "Unable to find topic");
  else
    xnav->message(' ', null_str);
}

static void xnav_ev_display_in_xnav_cb(void* xnav, pwr_sAttrRef* arp)
{
  ((XNav*)xnav)->display_object(arp, 0);
  ((XNav*)xnav)->pop();
}

static int xnav_ev_sound_cb(void* xnav, pwr_sAttrRef* arp)
{
  return ((XNav*)xnav)->sound(arp);
}

static int xnav_ge_sound_cb(void* xnav, pwr_sAttrRef* arp)
{
  return ((XNav*)xnav)->sound(arp);
}

static void xnav_ge_namechanged_cb(void* xnav, void *gectx, char *name)
{
  for (ApplListElem* elem = ((XNav *)xnav)->appl.root; elem; elem = elem->next) {
    if (elem->ctx == gectx) {
      strcpy(elem->name, name);
      break;
    }
  }
}

static int xnav_ge_get_select_cb(void* xnav, char* oname, pwr_tTypeId *type)
{
  int sts;
  pwr_tAttrRef aref;
  int is_attrref;

  sts = ((XNav *)xnav)->get_select(&aref, &is_attrref);
  if (EVEN(sts))
    return sts;

  return ((XNav *)xnav)->get_dashboard_name(&aref, oname, type);
}

static void xnav_ge_eventlog_cb(
    void* xnav, void* gectx, int type, void* data, unsigned int size)
{
  int sts;
  char name[80];
  pwr_tAName instance;
  char text[600];

  sts = ((XNav*)xnav)->appl.find(applist_eType_Graph, gectx, name, instance);
  if (ODD(sts)) {
    strcpy(text, name);
    strcat(text, ":");
    strcat(text, instance);
    XttLog::dlog((xttlog_eCategory)type, text, (const char*)data,
        xttlog_mOption_Binary, size);
  }
}

static void xnav_ge_keyboard_cb(void* ctx, void* gectx, int action, int type)
{
  int sts;
  XNav* xnav = (XNav*)ctx;
  char name[80];
  pwr_tAName instance;
  pwr_tTime current_time;
  pwr_tDeltaTime dt;
  static pwr_tTime open_time = pwr_cNTime;

  if (!(xnav->opplace_p->Options & pwr_mOpPlaceOptionsMask_VirtualKeyboard))
    return;

  if (action & keyboard_mAction_Open) {
    // Open keyboard
    sts = xnav->appl.find(applist_eType_Graph, gectx, name, instance);
    if (ODD(sts))
      xnav->open_keyboard(gectx, keyboard_eKeymap_, type);
    else {
      sts = xnav->appl.find(applist_eType_MultiView, gectx, name, instance);
      if (ODD(sts))
        xnav->open_keyboard(gectx, keyboard_eKeymap_, type);
    }
    if (EVEN(sts)) {
      switch (((XttUtility*)gectx)->get_type()) {
      case xtt_eUtility_Graph:
      case xtt_eUtility_MultiView:
        xnav->open_keyboard(gectx, keyboard_eKeymap_, type);
        break;
      default:;
      }
    }
    // Disable close keyboard request from lost input focus
    time_GetTime(&open_time);

  } else {
    // Close keyboard
    time_GetTime(&current_time);
    if (time_DToFloat(0, time_Adiff(&dt, &current_time, &open_time)) < 0.1)
      return;

    xnav->close_keyboard(action);
  }
}

static void xnav_ev_pop_cb(void* xnav)
{
  if (((XNav*)xnav)->op)
    ((XNav*)xnav)->op->map();
}

static void xnav_ev_update_info_cb(void* xnav)
{
  if (((XNav*)xnav)->op)
    ((XNav*)xnav)->op->update_alarm_info();
}

static void xnav_ge_display_in_xnav_cb(void* xnav, pwr_sAttrRef* arp)
{
  ((XNav*)xnav)->display_object(arp, 0);
  ((XNav*)xnav)->pop();
}

static int xnav_ge_is_authorized_cb(void* xnav, unsigned int access)
{
  return (((XNav*)xnav)->priv & access) != 0;
}

static int xnav_ge_get_current_objects_cb(
    void* vxnav, pwr_sAttrRef** alist, int** is_areflist)
{
  int sts;
  XNav* xnav = (XNav*)vxnav;

  // if ( xnav->brow->ctx == xnav->collect_brow->ctx)
  sts = xnav->get_all_objects(alist, is_areflist);
  // else
  // sts = xnav->get_select_all( alist, is_areflist);
  return sts;
}

static void xnav_keyboard_key_pressed_cb(void* ctx, int ascii)
{
  XNav* xnav = (XNav*)ctx;
  ApplListElem* elem;

  if (ascii == 27) {
    // Escape, close all input
    for (elem = xnav->appl.root; elem; elem = elem->next) {
      if (elem->type == applist_eType_Graph)
        ((XttGe*)elem->ctx)->close_input_all();
      else if (elem->type == applist_eType_MultiView)
        ((XttMultiView*)elem->ctx)->close_input_all();
    }
    xnav->keyboard_owner = 0;
    xnav->close_keyboard(keyboard_mAction_Close | keyboard_mAction_ResetInput);
  } else {
    // Forward key to current owner
    for (elem = xnav->appl.root; elem; elem = elem->next) {
      if (elem->ctx == xnav->keyboard_owner) {
        if (elem->type == applist_eType_Graph)
          ((XttGe*)elem->ctx)->key_pressed(ascii);
        else if (elem->type == applist_eType_MultiView)
          ((XttMultiView*)elem->ctx)->key_pressed(ascii);
        break;
      }
    }
  }
}

static void xnav_keyboard_close_cb(void* ctx)
{
  XNav* xnav = (XNav*)ctx;

  xnav->close_keyboard(keyboard_mAction_Close | keyboard_mAction_ResetInput);
}

static pwr_tStatus xnav_otree_action_cb(void* ctx, pwr_tAttrRef* aref)
{
  XNav* xnav = (XNav*)ctx;
  pwr_tStatus sts;
  pwr_tAName aname;
  char cmd[830];
  pwr_tCid cid;

  sts = gdh_GetAttrRefTid(aref, &cid);
  if (EVEN(sts))
    return sts;

  sts = gdh_AttrrefToName(aref, aname, sizeof(aname), cdh_mNName);
  if (EVEN(sts))
    return sts;

  switch (cid) {
  case pwr_cClass_DsTrend:
  case pwr_cClass_DsTrendCurve:
    sprintf(cmd, "open trend/name=%s/title=\"%s\"", aname, aname);
    break;
  case pwr_cClass_DsFastCurve:
    sprintf(cmd, "open fast/name=%s/title=\"%s\"", aname, aname);
    break;
  case pwr_cClass_SevHist:
  case pwr_cClass_SevHistObject:
  case pwr_cClass_SevItemFloat32:
  case pwr_cClass_SevItemInt32:
  case pwr_cClass_SevItemBoolean:
  case pwr_cClass_SevPlotGroup:
    sprintf(cmd, "open history/name=%s/title=\"%s\"", aname, aname);
    break;
  case pwr_cClass_XttGraph:
    sprintf(cmd, "open graph/object=%s", aname);
    break;
  default:
    sprintf(cmd, "open graph/class/inst=%s", aname);
  }

  xnav->command(cmd);

  return 1;
}

void XNav::open_graph(const char* name, const char* filename, int scrollbar,
    int menu, int navigator, int width, int height, int x, int y,
    const char* object_name, const char* focus_name, int input_focus_empty,
    int use_default_access, unsigned int access, unsigned int options,
    void* basewidget, double* borders, int dashboard)
{
  XttGe* gectx;

  if (appl.find(dashboard ? applist_eType_Dashboard : applist_eType_Graph, 
      filename, object_name, (void**)&gectx)) {
    gectx->pop();
    if (focus_name)
      gectx->set_object_focus(focus_name, input_focus_empty);
  } else {
    gectx = xnav_ge_new(name, filename, scrollbar, menu, navigator, width,
        height, x, y, gbl.scantime, object_name, use_default_access, access,
	options, basewidget, borders, gbl.color_theme, dashboard, 
        &xnav_ge_command_cb, &xnav_ge_get_current_objects_cb, 
        &xnav_ge_is_authorized_cb, &xnav_ge_keyboard_cb);
    gectx->close_cb = xnav_ge_close_cb;
    gectx->help_cb = xnav_ge_help_cb;
    gectx->display_in_xnav_cb = xnav_ge_display_in_xnav_cb;
    gectx->popup_menu_cb = xnav_popup_menu_cb;
    gectx->call_method_cb = xnav_call_method_cb;
    gectx->sound_cb = xnav_ge_sound_cb;
    gectx->eventlog_cb = xnav_ge_eventlog_cb;
    gectx->namechanged_cb = xnav_ge_namechanged_cb;
    gectx->get_select_cb = xnav_ge_get_select_cb;

    appl.insert(
	dashboard ? applist_eType_Dashboard : applist_eType_Graph, 
	(void*)gectx, pwr_cNObjid, filename, object_name);
    if (focus_name)
      gectx->set_object_focus(focus_name, input_focus_empty);
    if (options & ge_mOptions_IsMain) {
      if (!op && !multiview_main)
        ge_main = gectx;
    }
  }
}

void XNav::close_graph(char* filename, char* object_name, int iconify)
{
  XttGe* gectx;

  if (appl.find(applist_eType_Graph, filename, object_name, (void**)&gectx)) {
    if (iconify)
      gectx->iconify();
    else
      delete gectx;
  }
}

int XNav::exec_xttgraph(pwr_tObjid xttgraph, char* instance, char* focus,
    int inputempty, int use_default_access, unsigned int access,
    unsigned int options, void* basewidget)
{
  pwr_sClass_XttGraph xttgraph_o;
  char action[80];
  char* s;
  int sts;
  char instance_str[800];
  pwr_tAName name;
  int scrollbars, menu, navigator;
  double borders[4];
  double* bordersp = 0;

  sts = gdh_ObjidToName(xttgraph, name, sizeof(name), cdh_mName_volumeStrict);
  if (EVEN(sts))
    return sts;

  sts = gdh_GetObjectInfo(name, (void*)&xttgraph_o, sizeof(xttgraph_o));
  if (EVEN(sts))
    return sts;

  str_ToLower(action, xttgraph_o.Action);
  if (!instance) {
    for (int i = 0; i < 4; i++) {
      pwr_tOName oname;

      if (cdh_ObjidIsNull(xttgraph_o.Object[i]))
        break;

      sts = gdh_ObjidToName(
          xttgraph_o.Object[i], oname, sizeof(oname), cdh_mName_volumeStrict);
      if (EVEN(sts))
        break;

      if (i == 0)
        strncpy(instance_str, oname, sizeof(instance_str));
      else {
        strncat(instance_str, ",", sizeof(instance_str) - strlen(instance_str) - 1);
        strncat(instance_str, oname, sizeof(instance_str) - strlen(instance_str) - 1);
      }
      instance = instance_str;
    }
  }

  if (!feqf(xttgraph_o.Borders[0], 0.0f) || !feqf(xttgraph_o.Borders[1], 0.0f)
      || !feqf(xttgraph_o.Borders[2], 0.0f) || !feqf(xttgraph_o.Borders[3], 0.0f)) {
    for (int i = 0; i < 4; i++)
      borders[i] = xttgraph_o.Borders[i];
    bordersp = borders;
  }

  if ((s = strstr(action, ".pwg")) || action[0] == '@') {
    // Open graph
    if (s)
      *s = 0;
    scrollbars
        = xttgraph_o.Options & pwr_mXttGraphOptionsMask_Scrollbars ? 1 : 0;
    menu = xttgraph_o.Options & pwr_mXttGraphOptionsMask_Menu ? 1 : 0;
    navigator = xttgraph_o.Options & pwr_mXttGraphOptionsMask_Navigator ? 1 : 0;
    if (xttgraph_o.Options & pwr_mXttGraphOptionsMask_FullScreen)
      options |= ge_mOptions_FullScreen;
    if (xttgraph_o.Options & pwr_mXttGraphOptionsMask_Maximize)
      options |= ge_mOptions_Maximize;
    if (xttgraph_o.Options & pwr_mXttGraphOptionsMask_FullMaximize)
      options |= ge_mOptions_FullMaximize;
    if (xttgraph_o.Options & pwr_mXttGraphOptionsMask_Iconify)
      options |= ge_mOptions_Iconify;
    if (xttgraph_o.Options & pwr_mXttGraphOptionsMask_HideDecorations)
      options |= ge_mOptions_HideDecorations;
    if (xttgraph_o.Options & pwr_mXttGraphOptionsMask_Dialog)
      options |= ge_mOptions_Dialog;

    open_graph(xttgraph_o.Title, action, scrollbars, menu, navigator,
        xttgraph_o.Width, xttgraph_o.Height, xttgraph_o.X, xttgraph_o.Y,
        instance, focus, inputempty, use_default_access, access, options,
	basewidget, bordersp, 0);
  } else if ((strstr(action, ".class"))) {
    // Open jgraph
    char cmd[80];

    strcpy(action, xttgraph_o.Action);
    s = strrchr(action, '.');
    *s = 0;

    if (op) {
      strcpy(cmd, "open jgraph ");
      strcat(cmd, s);
      op->jop_command(cmd);
    } else
      message('E', "Java process not started");
  } else {
    // Execute command
    return command(xttgraph_o.Action);
  }
  return XNAV__SUCCESS;
}

void XNav::ge_event_exec(
    int type, char* name, char* instance, void* event, unsigned int size)
{
  int sts;
  XttGe* gectx;

  sts = appl.find(applist_eType_Graph, name, instance, (void**)&gectx);
  if (ODD(sts)) {
    gectx->event_exec(type, event, size);
  }
}

static int xnav_op_get_alarm_info_cb(void* xnav, evlist_sAlarmInfo* info, int backward, int alarmsize)
{
  if (((XNav*)xnav)->ev)
    return ((XNav*)xnav)->ev->get_alarm_info(info, backward, alarmsize);
  else
    return 0;
}

static void xnav_op_ack_last_cb(void* xnav, unsigned long type, unsigned long prio, int backward,
				int timecheck)
{
  if (((XNav*)xnav)->ev)
    ((XNav*)xnav)->ev->ack_last_prio(type, prio, backward, timecheck);
}

static int xnav_op_command_cb(void* xnav, char* command)
{
  ((XNav*)xnav)->command(command);
  return ((XNav*)xnav)->get_command_sts();
}

static void xnav_op_map_cb(void* ctx)
{
  XNav* xnav = (XNav*)ctx;
  if (xnav->map_cb)
    (xnav->map_cb)(xnav->parent_ctx);
}

static void xnav_op_close_cb(void* ctx)
{
  XNav* xnav = (XNav*)ctx;
  // delete xnav->op;
  // xnav->op = 0;
  if (xnav->close_cb)
    (xnav->close_cb)(xnav->parent_ctx, 1);
}

static void xnav_op_help_cb(void* ctx, const char* key)
{
  XNav* xnav = (XNav*)ctx;
  int sts;

  sts = CoXHelp::dhelp(key, "", navh_eHelpFile_Project, NULL, 0);
  if (EVEN(sts))
    sts = CoXHelp::dhelp(key, "", navh_eHelpFile_Base, NULL, 0);
  if (EVEN(sts))
    xnav->message('E', "Unable to find topic");
  else
    xnav->message(' ', null_str);
}

int XNav::set_parameter(char* name_str, char* value_str, int publicwrite)
{
  pwr_sAttrRef attrref;
  int sts;
  pwr_tTypeId attr_type;
  unsigned int attr_size, attr_offset, attr_dim;
  char buffer[80];
  unsigned int a_flags;

  sts = gdh_NameToAttrref(pwr_cNObjid, name_str, &attrref);
  if (EVEN(sts))
    return sts;

  // Check authorization
  if (publicwrite) {
    sts = gdh_GetAttributeFlags(&attrref, &a_flags);
    if (EVEN(sts))
      return sts;

    if (!(a_flags & pwr_mAdef_publicwrite))
      return XNAV__NOTAUTHORIZED;
    if (!((priv & pwr_mPrv_RtRead) || (priv & pwr_mPrv_RtWrite)
            || (priv & pwr_mPrv_System) || (priv & pwr_mPrv_Maintenance)
            || (priv & pwr_mPrv_Process) || (priv & pwr_mPrv_Instrument)
            || (priv & pwr_mPrv_Operator1) || (priv & pwr_mPrv_Operator2)
            || (priv & pwr_mPrv_Operator3) || (priv & pwr_mPrv_Operator4)
            || (priv & pwr_mPrv_Operator5) || (priv & pwr_mPrv_Operator6)
            || (priv & pwr_mPrv_Operator7) || (priv & pwr_mPrv_Operator8)
            || (priv & pwr_mPrv_Operator9) || (priv & pwr_mPrv_Operator10)))
      return XNAV__NOTAUTHORIZED;
  } else {
    if (!((priv & pwr_mPrv_RtWrite) || (priv & pwr_mPrv_System)))
      return XNAV__NOTAUTHORIZED;
  }

  sts = gdh_GetAttributeCharAttrref(
      &attrref, &attr_type, &attr_size, &attr_offset, &attr_dim);
  if (EVEN(sts))
    return sts;

  sts = attr_string_to_value(
      attr_type, value_str, buffer, sizeof(buffer), attr_size);
  if (EVEN(sts))
    return sts;

  sts = gdh_SetObjectInfo(name_str, buffer, attr_size);
  if (EVEN(sts))
    return sts;

  return 1;
}

void XNav::open_rttlog(char* name, char* filename)
{
  void* basewidget = 0;
  if (opplace_p->Options & pwr_mOpPlaceOptionsMask_AllMainTransient) {
    if (ge_main)
      basewidget = ge_main->get_widget();
    else if (multiview_main)
      basewidget = multiview_main->get_widget();
  }

  GeCurve* c
      = gecurve_new(name, filename, NULL, 0, 0, gbl.color_theme, basewidget);
  c->setup(curve_mEnable_CurveType | curve_mEnable_CurveTypeSquare
      | curve_mEnable_FillCurve);
}

int XNav::search(char* search_str, int regexp)
{
  int sts;
  pwr_tObjid found_objid;
  char str[200];

  if (regexp) {
    if (search_compiled)
      regfree(&search_creg);

    sts = regcomp(&search_creg, search_str, REG_NOSUB | REG_ICASE);
    if (sts != 0) {
      search_compiled = 0;
      search_type = xnav_eSearchType_No;
      return XNAV__SEARCHCOMPILE;
    }
    search_compiled = 1;
    search_type = xnav_eSearchType_RegularExpr;
  } else
    search_type = xnav_eSearchType_Name;

  str_ToUpper(str, search_str);
  sts = search_root(str, &found_objid, 0);
  if (EVEN(sts))
    return sts;

  // Store for search next
  search_last = found_objid;
  strcpy(search_string, str);

  sts = display_object(found_objid, 0);
  return sts;
}

int XNav::search_next()
{
  int sts;
  pwr_tObjid found_objid;

  if (search_type == xnav_eSearchType_No)
    return XNAV__NOSEARCH;

  search_last_found = 0;
  sts = search_root(search_string, &found_objid, 1);
  if (EVEN(sts))
    return sts;

  // Store for search next
  search_last = found_objid;

  sts = display_object(found_objid, 0);
  return sts;
}

int XNav::search_root(char* search_str, pwr_tObjid* found_objid, int next)
{
  pwr_tObjid root;
  int sts, search_sts;

  search_sts = 0;

  sts = gdh_GetRootList(&root);
  while (ODD(sts)) {
    search_sts = search_object(root, search_str, found_objid, next);
    if (ODD(search_sts))
      break;
    sts = gdh_GetNextSibling(root, &root);
  }
  return search_sts;
}

int XNav::search_object(
    pwr_tObjid objid, char* search_str, pwr_tObjid* found_objid, int next)
{
  pwr_tObjName name;
  int sts, search_sts;
  pwr_tObjid child;
  pwr_tClassId classid;

  if (next && !search_last_found) {
    if (cdh_ObjidIsEqual(objid, search_last))
      search_last_found = 1;
  } else {
    sts = gdh_ObjidToName(objid, name, sizeof(name), cdh_mName_object);
    if (EVEN(sts))
      return sts;

    if (search_type == xnav_eSearchType_Name) {
      // str_ToUpper( name, name);
      if (str_NoCaseStrcmp(name, search_str) == 0) {
        *found_objid = objid;
        return XNAV__SUCCESS;
      }
    } else {
      sts = regexec(&search_creg, name, 0, NULL, 0);
      if (sts == REG_OK) {
        *found_objid = objid;
        return XNAV__SUCCESS;
      }
    }
  }

  // If mountobject, don't search children
  sts = gdh_GetObjectClass(objid, &classid);
  if (EVEN(sts))
    return sts;

  if (classid == pwr_eClass_MountObject)
    return XNAV__NOMATCH;

  search_sts = XNAV__NOMATCH;
  sts = gdh_GetChild(objid, &child);
  while (ODD(sts)) {
    search_sts = search_object(child, search_str, found_objid, next);
    if (ODD(search_sts))
      break;
    sts = gdh_GetNextSibling(child, &child);
  }
  return search_sts;
}

int XNav::create_object(char* classname, char* name)
{
  int sts;
  pwr_tObjid objid;
  pwr_tClassId classid = 0;

  /* Check if class */
  if (classname != NULL) {
    /* Get classid for the class */
    sts = gdh_ClassNameToId(classname, &classid);
    if (EVEN(sts)) {
      /* Class not found */
      message('E', "Unknown class");
      return XNAV__HOLDCOMMAND;
    }
  }

  sts = gdh_CreateObject(name, classid, 0, &objid, pwr_cNObjid, 0, pwr_cNObjid);
  if (EVEN(sts)) {
    message('E', "Error in object name");
    return XNAV__HOLDCOMMAND;
  }

  message('I', "Object created");
  return XNAV__SUCCESS;
}

int XNav::delete_object(char* name)
{
  int sts;
  pwr_tObjid objid;

  /* Get objid for the object */
  sts = gdh_NameToObjid(name, &objid);
  if (EVEN(sts)) {
    message('E', "Object does not exist");
    return XNAV__HOLDCOMMAND;
  }

  sts = gdh_DeleteObject(objid);
  if (EVEN(sts)) {
    message('E', "Unable to delete object");
    return XNAV__HOLDCOMMAND;
  }

  message('I', "Object deleted");
  return XNAV__SUCCESS;
}

void XNav::print_methods()
{
  int i, j;

  printf("Base Methods\n");
  for (i = 0;; i++) {
    if (pwr_gBase_XttClassMethods[i].ClassName[0] == '\0')
      break;

    printf("%3d %-20s\n", i, pwr_gBase_XttClassMethods[i].ClassName);
    for (j = 0;; j++) {
      if ((*pwr_gBase_XttClassMethods[i].Methods)[j].MethodName[0] == '\0')
        break;
      printf(
          "       %s\n", (*pwr_gBase_XttClassMethods[i].Methods)[j].MethodName);
    }
  }
}

static void xnav_open_shist_cb(void* ctx, char* text, int ok_pressed)
{
  pwr_tOName oname;
  pwr_tOid coid;
  pwr_tCmd cmd;
  pwr_tStatus sts;
  XNav* xnav = ((xnav_sHistList*)ctx)->xnav;
  pwr_tOid oid = ((xnav_sHistList*)ctx)->oid;
  free(ctx);

  sts = gdh_ObjidToName(oid, oname, sizeof(oname), cdh_mName_volumeStrict);
  if (EVEN(sts))
    return;

  strcat(oname, "-");
  strcat(oname, text);

  sts = gdh_NameToObjid(oname, &coid);
  if (EVEN(sts))
    return;

  sprintf(cmd, "open history/name=%s", oname);
  xnav->command(cmd);
}

static void xnav_open_shist_cancel_cb(void* ctx)
{
  free(ctx);
}

static void xnav_colortheme_selector_ok_cb(
    void* ctx, char* text, int ok_pressed)
{
  XNav* xnav = (XNav*)ctx;
  gdh_sValueDef* vd;
  pwr_tTid tid;
  int rows;
  int i;
  pwr_tOid oid;
  pwr_tStatus sts;
  int found;
  int idx = 0;
  ApplListElem* elem;

  sts = gdh_NameToObjid("pwrb:Type-ColorThemeEnum", &oid);
  if (EVEN(sts))
    return;
  tid = cdh_TypeObjidToId(oid);
  sts = gdh_GetEnumValueDef(tid, &vd, &rows);
  if (EVEN(sts))
    return;

  found = 0;
  for (i = 0; i < rows; i++) {
    if (streq(text, vd[i].Name)) {
      idx = vd[i].Value->Value;
      found = 1;
      break;
    }
  }
  if (found) {
    if (xnav->gbl.color_theme != idx) {
      xnav->gbl.color_theme = idx;

      for (elem = xnav->appl.root; elem; elem = elem->next) {
        if (elem->type == applist_eType_Graph)
          ((XttGe*)elem->ctx)->update_color_theme(idx);
        else if (elem->type == applist_eType_SevHist)
          ((XttSevHist*)elem->ctx)->update_color_theme(idx);
        else if (elem->type == applist_eType_Trend)
          ((XttTrend*)elem->ctx)->update_color_theme(idx);
        else if (elem->type == applist_eType_Fast)
          ((XttFast*)elem->ctx)->update_color_theme(idx);
      }
      if (xnav->keyboard)
        xnav->keyboard->update_color_theme(idx);
    }
    if (xnav->op)
      xnav->op->set_color_theme(idx);
  }
  free(vd);
}

static void xnav_show_objectlist_cb(void* ctx, char* text, int ok_pressed)
{
  XNav* xnav = ((xnav_sObjectList*)ctx)->xnav;
  pwr_tCid cid = ((xnav_sObjectList*)ctx)->cid;
  pwr_tCmd cmd;

  free(ctx);

  switch (cid) {
  case pwr_cClass_DsTrend:
  case pwr_cClass_DsTrendCurve:
    sprintf(cmd, "open trend/name=%s/title=\"%s\"", text, text);
    break;
  case pwr_cClass_DsFastCurve:
    sprintf(cmd, "open fast/name=%s/title=\"%s\"", text, text);
    break;
  case pwr_cClass_SevHist:
  case pwr_cClass_SevHistObject:
    sprintf(cmd, "open history/name=%s/title=\"%s\"", text, text);
    break;
  case pwr_cClass_XttGraph:
    sprintf(cmd, "open graph/object=%s", text);
    break;
  default:
    sprintf(cmd, "open graph/class/instance=%s", text);
  }

  xnav->command(cmd);
}

static void xnav_show_objectlist_cancel_cb(void* ctx)
{
  free(ctx);
}

pwr_tStatus XNav::get_instance_classgraph(
    char* instance_str, pwr_tFileName filename)
{
  // Get file from class of instance object
  pwr_tStatus sts;
  pwr_sAttrRef aref;
  pwr_tObjName cname;
  pwr_tCid cid;
  pwr_tFileName found_file, fname, file_str;
  pwr_tAName aname;
  pwr_tEnum graph_conf;
  int i;
  int is_baseclass = 0;
  int found = 0;

  sts = gdh_NameToAttrref(pwr_cNObjid, instance_str, &aref);
  if (EVEN(sts))
    return sts;

  sts = gdh_GetAttrRefTid(&aref, &cid);
  while (ODD(sts)) {
    // Try all superclasses
    sts = gdh_ObjidToName(
        cdh_ClassIdToObjid(cid), cname, sizeof(cname), cdh_mName_object);
    if (EVEN(sts))
      return sts;

    str_ToLower(cname, cname);
    if (cdh_CidToVid(cid) < cdh_cUserClassVolMin
        || (cdh_CidToVid(cid) >= cdh_cManufactClassVolMin
               && cdh_CidToVid(cid) <= cdh_cManufactClassVolMax)) {
      is_baseclass = 1;
      if (cname[0] == '$')
        sprintf(file_str, "pwr_c_%s", &cname[1]);
      else
        sprintf(file_str, "pwr_c_%s", cname);
    } else
      strcpy(file_str, cname);

    // Get base class graphs on $pwrp_exe or $pwr_exe
    for (i = 0; i < 2; i++) {
      str_ToLower(fname, file_str);
      if (is_baseclass && i == 1) {
        strcpy(fname, "$pwr_exe/");
        strcat(fname, file_str);
      } else {
        strcpy(fname, "$pwrp_exe/");
        strcat(fname, file_str);
      }

      // Add any GraphConfiguration to filename
      strcpy(aname, instance_str);
      strcat(aname, ".GraphConfiguration");
      sts = gdh_GetObjectInfo(aname, &graph_conf, sizeof(graph_conf));
      if (ODD(sts)) {
        if (graph_conf != 0) {
          char gc[12];
          sprintf(gc, "%d", graph_conf);
          strcat(fname, gc);
        }
      }

      strcat(fname, ".pwg");
      sts = dcli_search_file(fname, found_file, DCLI_DIR_SEARCH_INIT);
      dcli_search_file(fname, found_file, DCLI_DIR_SEARCH_END);
      if (ODD(sts)) {
        found = 1;
        break;
      }
      if (!is_baseclass)
        break;
    }
    if (found)
      break;

    sts = gdh_GetSuperClass(cid, &cid, aref.Objid);
  }
  if (EVEN(sts))
    return XNAV__NOCLASSGRAPH;

  strcpy(filename, fname);
  return XNAV__SUCCESS;
}

int XNav::collect_window(int copy, int type)
{
  brow_tNode* node_list;
  int node_count;
  Item* item;
  int sts;
  pwr_sAttrRef* ap;
  int i;
  XColWind* xcolwind;

  if (type == xcolwind_eType_Collect) {
    if (copy) {
      brow_GetObjectList(collect_brow->ctx, &node_list, &node_count);
      if (!node_count)
        return 0;

      ap = (pwr_sAttrRef*)calloc(node_count + 1, sizeof(pwr_sAttrRef));

      for (i = 0; i < node_count; i++) {
        brow_GetUserData(node_list[i], (void**)&item);

        switch (item->type) {
        case xnav_eItemType_Collect:
          sts = gdh_NameToAttrref(pwr_cNObjid, item->name, &ap[i]);
          if (EVEN(sts))
            return sts;

          break;
        default:;
        }
      }

      xcolwind = xcolwind_new(
          ap, 0, gbl.advanced_user, xcolwind_eType_Collect, &sts);
    } else
      xcolwind
          = xcolwind_new(0, 0, gbl.advanced_user, xcolwind_eType_Collect, &sts);

    if (ODD(sts)) {
      xcolwind->close_cb = xatt_close_cb;
      xcolwind->popup_menu_cb = xnav_popup_menu_cb;
      xcolwind->call_method_cb = xnav_call_method_cb;
      xcolwind->is_authorized_cb = is_authorized_cb;
      xcolwind->command_cb = xnav_op_command_cb;
      xcolwind->get_select_cb = xnav_get_select_cb;

      if (copy)
        collect_clear();
    }
  } else if (type == xcolwind_eType_CollectSignals
      || type == xcolwind_eType_CollectIOSignals) {
    pwr_tAttrRef attrref;
    int is_attr;

    sts = get_select(&attrref, &is_attr);
    if (EVEN(sts))
      return sts;

    xcolwind = xcolwind_new(&attrref, 0, gbl.advanced_user, type, &sts);
    if (ODD(sts)) {
      xcolwind->close_cb = xatt_close_cb;
      xcolwind->popup_menu_cb = xnav_popup_menu_cb;
      xcolwind->call_method_cb = xnav_call_method_cb;
      xcolwind->is_authorized_cb = is_authorized_cb;
      xcolwind->command_cb = xnav_op_command_cb;
      xcolwind->get_select_cb = xnav_get_select_cb;
    }
  }
  return XNAV__SUCCESS;
}

void XNav::open_keyboard(void* owner, keyboard_eKeymap keymap, int type)
{
  pwr_tStatus sts;
  keyboard_eType keyboard_type = keyboard_eType_Standard;
  int shifted = 0;
  void* basewidget = 0;

  if (!(opplace_p->Options & pwr_mOpPlaceOptionsMask_VirtualKeyboard))
    return;

  if (keymap == keyboard_eKeymap_)
    keymap = keyboard_eKeymap_Low_en_us;

  if (keyboard)
    delete keyboard;

  switch (type) {
  case graph_eKeyboard_StandardShifted:
    shifted = 1;
  case graph_eKeyboard_Standard:
    keyboard_type = keyboard_eType_Standard;
    break;
  case graph_eKeyboard_Numeric:
    keyboard_type = keyboard_eType_Numeric;
    break;
  case graph_eKeyboard_AlphabeticShifted:
    shifted = 1;
  case graph_eKeyboard_Alphabetic:
    keyboard_type = keyboard_eType_Alphabetic;
    break;
  }

  keyboard
      = keyboard_new("Keyboard", keymap, keyboard_type, gbl.color_theme, &sts);
  keyboard->key_pressed_cb = xnav_keyboard_key_pressed_cb;
  keyboard->close_cb = xnav_keyboard_close_cb;
  keyboard_owner = owner;

  if (shifted)
    keyboard->set_shift(1);

  if (opplace_p->Options & pwr_mOpPlaceOptionsMask_AllMainTransient) {
    if (ge_main)
      basewidget = ge_main->get_widget();
    else if (multiview_main)
      basewidget = multiview_main->get_widget();
    if (basewidget)
      keyboard->set_transient(basewidget);
  }
}

void XNav::close_keyboard(int action)
{
  ApplListElem* elem;

  if (!(opplace_p->Options & pwr_mOpPlaceOptionsMask_VirtualKeyboard))
    return;

  if (keyboard) {
    delete keyboard;
    keyboard = 0;
    keyboard_owner = 0;

    if (action & keyboard_mAction_ResetInput) {
      for (elem = appl.root; elem; elem = elem->next) {
        if (elem->type == applist_eType_Graph)
          ((XttGe*)elem->ctx)->close_input_all();
        else if (elem->type == applist_eType_MultiView)
          ((XttMultiView*)elem->ctx)->close_input_all();
      }
    }
  }
}

static int xnav_replace_node_str(char* out, char* object_str)
{
  if (str_StartsWith(object_str, "*-")
      || str_NoCaseStrncmp(object_str, "$node-", 6) == 0) {
    // Replace * by the node object
    pwr_tObjid node_objid;
    pwr_tAName str;
    pwr_tStatus sts;

    sts = gdh_GetNodeObject(0, &node_objid);
    if (EVEN(sts))
      return sts;
    sts = gdh_ObjidToName(node_objid, str, sizeof(str), cdh_mNName);
    if (EVEN(sts))
      return sts;
    if (object_str[0] == '*')
      strcat(str, &object_str[1]);
    else
      strcat(str, &object_str[5]);

    strcpy(out, str);
    return 1;
  }

  if (out != object_str)
    strcpy(out, object_str);
  return 0;
}

int XNav::set_signal(pwr_tAttrRef* arp, xnav_eSetSignal type, int on)
{
  int sts;
  pwr_tCid sig_cid, chan_cid, card_cid, cid;
  pwr_tAttrRef aref, chan_aref, card_aref, value_aref;
  pwr_tOid card_oid;
  pwr_tMask valuemask;
  pwr_tBoolean value_on;

  static char card_mask1[][32]
      = { "ConvMask1", "InvMask1", "TestMask1", "TestValue1" };
  static char card_mask2[][32]
      = { "ConvMask2", "InvMask2", "TestMask2", "TestValue2" };
  static char chan_attr[][32]
      = { "ConversionOn", "InvertOn", "TestOn", "TestValue" };

  sts = gdh_GetAttrRefTid(arp, &sig_cid);
  if (EVEN(sts))
    return sts;

  switch (sig_cid) {
  case pwr_cClass_Di:
  case pwr_cClass_Do:
  case pwr_cClass_Po:
  case pwr_cClass_Ai:
  case pwr_cClass_Ao:
    sts = gdh_ArefANameToAref(arp, "SigChanCon", &aref);
    if (EVEN(sts))
      return sts;

    sts = gdh_GetObjectInfoAttrref(&aref, &chan_aref, sizeof(chan_aref));
    if (EVEN(sts))
      return sts;

    sts = gdh_GetAttrRefTid(&chan_aref, &chan_cid);
    if (EVEN(sts))
      return sts;
    break;
  case pwr_cClass_ChanDi:
  case pwr_cClass_ChanDo:
  case pwr_cClass_ChanAi:
  case pwr_cClass_ChanAo:
  case pwr_cClass_ChanIi:
  case pwr_cClass_ChanIo:
    chan_aref = *arp;
    chan_cid = sig_cid;
    break;
  default:
    return XNAV__INVALIDOBJECT;
  }

  switch (chan_cid) {
  case pwr_cClass_ChanDi:
    if (!(type == xnav_eSetSignal_Conversion || type == xnav_eSetSignal_Invert))
      return XNAV__INVALIDOBJECT;
    break;
  case pwr_cClass_ChanDo:
    if (!(type == xnav_eSetSignal_Invert || type == xnav_eSetSignal_Test
            || type == xnav_eSetSignal_TestValue))
      return XNAV__INVALIDOBJECT;
    break;
  case pwr_cClass_ChanAi:
  case pwr_cClass_ChanIi:
    if (!(type == xnav_eSetSignal_Conversion))
      return XNAV__INVALIDOBJECT;
    break;
  case pwr_cClass_ChanAo:
  case pwr_cClass_ChanIo:
    if (!(type == xnav_eSetSignal_Test))
      return XNAV__INVALIDOBJECT;
    break;
  default:
    return XNAV__INVALIDOBJECT;
  }

  // Get the card object
  if (chan_aref.Flags.b.Object) {
    sts = gdh_GetParent(chan_aref.Objid, &card_oid);
    if (EVEN(sts))
      return sts;
  } else
    card_oid = chan_aref.Objid;

  sts = gdh_GetObjectClass(card_oid, &card_cid);
  if (EVEN(sts))
    return sts;

  sts = gdh_GetSuperClass(card_cid, &cid, card_oid);
  while (ODD(sts)) {
    card_cid = cid;
    sts = gdh_GetSuperClass(card_cid, &cid, card_oid);
  }

  switch (card_cid) {
  case pwr_cClass_Ssab_BaseDiCard:
  case pwr_cClass_Ssab_BaseDoCard: {
    pwr_tUInt32 number;

    card_aref = cdh_ObjidToAref(card_oid);

    sts = gdh_ArefANameToAref(&chan_aref, "Number", &aref);
    if (EVEN(sts))
      return sts;

    sts = gdh_GetObjectInfoAttrref(&aref, &number, sizeof(number));
    if (EVEN(sts))
      return sts;

    if (number < 16) {
      sts = gdh_ArefANameToAref(&card_aref, card_mask1[type], &value_aref);
      if (EVEN(sts))
        return sts;
    } else if (number >= 16 && number < 32) {
      sts = gdh_ArefANameToAref(&card_aref, card_mask2[type], &value_aref);
      if (EVEN(sts))
        return sts;

      number -= 16;
    } else
      return XNAV__INVALIDOBJECT;

    sts = gdh_GetObjectInfoAttrref(&value_aref, &valuemask, sizeof(valuemask));
    if (EVEN(sts))
      return sts;

    if (on)
      valuemask |= 1 << number;
    else
      valuemask &= ~(1 << number);

    sts = gdh_SetObjectInfoAttrref(&value_aref, &valuemask, sizeof(valuemask));
    if (EVEN(sts))
      return sts;

    break;
  }
  default:;
  }

  // Set the flag in the channelobject
  sts = gdh_ArefANameToAref(&chan_aref, chan_attr[type], &value_aref);
  if (EVEN(sts))
    return sts;

  value_on = on;

  sts = gdh_SetObjectInfoAttrref(&value_aref, &value_on, sizeof(value_on));
  if (EVEN(sts))
    return sts;

  return XNAV__SUCCESS;
}
