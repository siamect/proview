/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include "co_cdh.h"
#include "co_dcli.h"
#include "co_string.h"

#include "rt_gdh_msg.h"
#include "rt_sev_msg.h"

#include "cow_wow.h"

#include "glow_curveapi.h"

#include "xtt_xnav.h"
#include "xtt_sevhist.h"

XttSevHist::XttSevHist(void* parent_ctx, const char* name, pwr_tOid* xn_oidv,
    pwr_tOName* xn_anamev, pwr_tOName* xn_onamev, bool* xn_sevhistobjectv,
    sevcli_tCtx xn_scctx, int xn_color_theme, time_ePeriod time_range, int* sts)
    : xnav(parent_ctx), gcd(0), curve(0), rows(0), vsize(0), timerid(0),
      close_cb(0), help_cb(0), get_select_cb(0), first_scan(1), scctx(xn_scctx),
      wow(0), time_low_old(0), time_high_old(0), initial_period(time_ePeriod_),
      color_theme(xn_color_theme), otree(0)
{
  pwr_tTime from, to;

  if (xn_oidv == 0 || xn_oidv[0].vid == 0) {
    oid_cnt = 0;
    gcd = new GeCurveData(curve_eDataType_DsTrend);
    return;
  }

  // Count number of curves
  for (oid_cnt = 0; xn_oidv[oid_cnt].vid != 0; oid_cnt++)
    ;

  if (oid_cnt > XTT_SEVHIST_MAX)
    oid_cnt = XTT_SEVHIST_MAX;

  memcpy(oidv, xn_oidv, oid_cnt * sizeof(oidv[0]));
  memcpy(anamev, xn_anamev, oid_cnt * sizeof(anamev[0]));
  memcpy(onamev, xn_onamev, oid_cnt * sizeof(onamev[0]));
  memcpy(
      sevhistobjectv, xn_sevhistobjectv, oid_cnt * sizeof(sevhistobjectv[0]));

  if (time_range == time_ePeriod_)
    time_range = time_ePeriod_LastHour;

  time_Period(time_range, &from, &to, 0, 0);
#if 0
  time_GetTime( &to);
  from.tv_sec = to.tv_sec - 3600;
  from.tv_nsec = to.tv_nsec;
#endif
  if (oid_cnt == 1) {
    get_data(sts, from, to);
    if (*sts == SEV__NOPOINTS) {
// Try month
#if 0
      from.tv_sec = to.tv_sec - 31 * 24 * 3600;
      from.tv_nsec = to.tv_nsec;
#endif
      time_range = time_ePeriod_LastMonth;
      time_Period(time_range, &from, &to, 0, 0);
      get_data(sts, from, to);
      if (EVEN(*sts))
        return;
    } else if (EVEN(*sts))
      return;
    initial_period = time_range;
  } else {
    get_multidata(sts, from, to);
    if (*sts == SEV__NOPOINTS) {
      // Try month
      time_range = time_ePeriod_LastMonth;
      time_Period(time_range, &from, &to, 0, 0);
      get_multidata(sts, from, to);
      if (EVEN(*sts))
        return;
    } else if (EVEN(*sts))
      return;
    initial_period = time_range;
  }
  str_StrncpyCutOff(title, name, sizeof(title), 1);
}

XttSevHist::XttSevHist(void* parent_ctx, const char* name, char* filename,
    int xn_color_theme, int* sts)
    : xnav(parent_ctx), gcd(0), curve(0), rows(0), vsize(0), timerid(0),
      close_cb(0), help_cb(0), get_select_cb(0), first_scan(1), scctx(0),
      wow(0), time_low_old(0), time_high_old(0), initial_period(time_ePeriod_),
      color_theme(xn_color_theme)
{
  strncpy(title, filename, sizeof(title));

  *sts = read_export(filename);
}

XttSevHist::~XttSevHist()
{
}

int XttSevHist::get_data(pwr_tStatus* sts, pwr_tTime from, pwr_tTime to)
{
  if (sevhistobjectv[0]) {
    return get_objectdata(sts, from, to);
  }
  pwr_tTime* tbuf;
  void* vbuf;
  pwr_tDeltaTime trange;

  if (curve)
    curve->set_clock_cursor();
  sevcli_get_itemdata(sts, scctx, oidv[0], anamev[0], from, to, 1000, &tbuf,
      &vbuf, &rows, &vtype, &vsize);
  if (curve)
    curve->reset_cursor();
  if (EVEN(*sts))
    return 0;

  if (rows == 0) {
    *sts = SEV__NODATATIME;
    return 0;
  }

  // Create data for time axis
  gcd = new GeCurveData(curve_eDataType_DsTrend);

  gcd->x_data[0] = (double*)calloc(1, 8 * rows);
  for (int i = 0; i < rows; i++)
    gcd->x_data[0][i] = (double)tbuf[i].tv_sec + (double)1e-9 * tbuf[i].tv_nsec;

  strcpy(gcd->x_name, "Time");
  gcd->x_axis_type[0] = curve_eAxis_x;
  strcpy(gcd->x_format[0], "%10t");

  strcpy(gcd->y_name[0], onamev[0]);
  if (!streq(onamev[0], ""))
    strcat(gcd->y_name[0], ".");
  strcat(gcd->y_name[0], anamev[0]);
  gcd->y_data[0] = (double*)calloc(1, 8 * rows);

  for (int i = 0; i < rows; i++) {
    switch (vtype) {
    case pwr_eType_Int64:
      gcd->y_data[0][i] = ((pwr_tInt32*)vbuf)[i];
      break;
    case pwr_eType_Int32:
      gcd->y_data[0][i] = ((pwr_tInt32*)vbuf)[i];
      break;
    case pwr_eType_Int16:
      gcd->y_data[0][i] = ((pwr_tInt32*)vbuf)[i];
      break;
    case pwr_eType_Int8:
      gcd->y_data[0][i] = ((pwr_tInt32*)vbuf)[i];
      break;
    case pwr_eType_UInt64:
      gcd->y_data[0][i] = ((pwr_tUInt32*)vbuf)[i];
      break;
    case pwr_eType_UInt32:
      gcd->y_data[0][i] = ((pwr_tUInt32*)vbuf)[i];
      break;
    case pwr_eType_UInt16:
      gcd->y_data[0][i] = ((pwr_tUInt32*)vbuf)[i];
      break;
    case pwr_eType_UInt8:
      gcd->y_data[0][i] = ((pwr_tUInt32*)vbuf)[i];
      break;
    case pwr_eType_Float32:
      gcd->y_data[0][i] = ((pwr_tFloat32*)vbuf)[i];
      break;
    case pwr_eType_Float64:
      gcd->y_data[0][i] = ((pwr_tFloat64*)vbuf)[i];
      break;
    case pwr_eType_Boolean:
      gcd->y_data[0][i] = ((pwr_tBoolean*)vbuf)[i];
      break;
    default:
      *sts = SEV__CURVETYPE;
      return 0;
    }
  }
  free(tbuf);
  free(vbuf);

  gcd->y_axis_type[0] = curve_eAxis_y;
  gcd->y_orig_type[0] = vtype;

  gcd->cols = 1;
  gcd->rows[0] = rows;

  gcd->get_borders();
  gcd->get_default_axis();

  if (to.tv_sec != 0 && from.tv_sec != 0) {
    time_Adiff(&trange, &to, &from);
    if (time_DToFloat(0, &trange) < 600)
      strcpy(gcd->x_format[0], "%10t");
    else
      strcpy(gcd->x_format[0], "%11t");
  } else
    strcpy(gcd->x_format[0], "%11t");

  gcd->select_color(0);

  if (curve) {
    curve->set_curvedata(gcd); // This will free the old gcd
    curve->configure_curves();
    curve->configure_axes();
    curve->redraw();
  }
  *sts = SEV__SUCCESS;
  return 1;
}

int XttSevHist::get_objectdata(pwr_tStatus* sts, pwr_tTime from, pwr_tTime to)
{
  pwr_tTime* tbuf;
  void* vbuf;
  sevcli_sHistAttr* histattrbuf;
  int numAttributes;

  pwr_tDeltaTime trange;

  if (curve)
    curve->set_clock_cursor();
  sevcli_get_objectitemdata(sts, scctx, oidv[0], anamev[0], from, to, 1000,
      &tbuf, &vbuf, &rows, &histattrbuf, &numAttributes);
  if (curve)
    curve->reset_cursor();
  if (EVEN(*sts))
    return 0;

  if (rows == 0) {
    *sts = SEV__NODATATIME;
    return 0;
  }

  // Create data for time axis
  gcd = new GeCurveData(curve_eDataType_DsTrend);

  gcd->x_data[0] = (double*)calloc(1, 8 * rows);
  for (int i = 0; i < rows; i++)
    gcd->x_data[0][i] = (double)tbuf[i].tv_sec + (double)1e-9 * tbuf[i].tv_nsec;

  strcpy(gcd->x_name, "Time");
  gcd->x_axis_type[0] = curve_eAxis_x;
  strcpy(gcd->x_format[0], "%10t");

  // todo linesize bör vi kunna få från sevcli_get_objectitemdata
  int linesize = 0;
  for (int i = 0; i < numAttributes; i++) {
    linesize += histattrbuf[i].size;
  }
  void* dataptr = vbuf;
  int tmp = 0;
  gcd->cols = 0;
  for (int i = 0; i < numAttributes; i++) {
    switch (histattrbuf[i].type) {
    case pwr_eType_Int64:
    case pwr_eType_Int32:
    case pwr_eType_Int16:
    case pwr_eType_Int8:
    case pwr_eType_UInt64:
    case pwr_eType_UInt32:
    case pwr_eType_UInt16:
    case pwr_eType_UInt8:
    case pwr_eType_Float32:
    case pwr_eType_Float64:
    case pwr_eType_Boolean:
      break;
    default:
      tmp += histattrbuf[i].size;
      continue;
    }

    if (gcd->cols >= CURVE_MAX_COLS) {
      printf("To many columns for curve class max:%d\n", CURVE_MAX_COLS);
      break;
    }

    gcd->cols++;

    strcpy(gcd->y_name[gcd->cols - 1], onamev[0]);
    if (!streq(onamev[0], ""))
      strcat(gcd->y_name[gcd->cols - 1], ".");
    strcat(gcd->y_name[gcd->cols - 1], histattrbuf[i].aname);
    gcd->y_data[gcd->cols - 1] = (double*)calloc(1, 8 * rows);
    gcd->y_axis_type[gcd->cols - 1] = curve_eAxis_y;

    dataptr = (char*)vbuf + tmp;
    // tmp += histattrbuf[i].size;
    for (int j = 0; j < rows; j++) {
      // dataptr = (char *)dataptr + linesize*j;
      dataptr = ((char*)vbuf) + j * linesize + tmp;
      switch (histattrbuf[i].type) {
      case pwr_eType_Int64:
        gcd->y_data[gcd->cols - 1][j] = *(pwr_tInt64*)dataptr;
        break;
      case pwr_eType_Int32:
        gcd->y_data[gcd->cols - 1][j] = *(pwr_tInt32*)dataptr;
        break;
      case pwr_eType_Int16:
        gcd->y_data[gcd->cols - 1][j] = *(pwr_tInt16*)dataptr;
        break;
      case pwr_eType_Int8:
        gcd->y_data[gcd->cols - 1][j] = *(pwr_tInt8*)dataptr;
        break;
      case pwr_eType_UInt64:
        gcd->y_data[gcd->cols - 1][j] = *(pwr_tUInt64*)dataptr;
        break;
      case pwr_eType_UInt32:
        gcd->y_data[gcd->cols - 1][j] = *(pwr_tUInt32*)dataptr;
        break;
      case pwr_eType_UInt16:
        gcd->y_data[gcd->cols - 1][j] = *(pwr_tUInt16*)dataptr;
        break;
      case pwr_eType_UInt8:
        gcd->y_data[gcd->cols - 1][j] = *(pwr_tUInt8*)dataptr;
        break;
      case pwr_eType_Float32:
        gcd->y_data[gcd->cols - 1][j] = *(pwr_tFloat32*)dataptr;
        break;
      case pwr_eType_Float64:
        gcd->y_data[gcd->cols - 1][j] = *(pwr_tFloat64*)dataptr;
        break;
      case pwr_eType_Boolean:
        gcd->y_data[gcd->cols - 1][j] = *(pwr_tBoolean*)dataptr;
        break;
      default:
        *sts = SEV__CURVETYPE;
        return 0;
      }
    }
    tmp += histattrbuf[i].size;
  }
  free(tbuf);
  free(vbuf);
  free(histattrbuf);

  for (int i = 0; i < gcd->cols; i++)
    gcd->rows[i] = rows;

  gcd->get_borders();
  gcd->get_default_axis();

  if (to.tv_sec != 0 && from.tv_sec != 0) {
    time_Adiff(&trange, &to, &from);
    if (time_DToFloat(0, &trange) < 600)
      strcpy(gcd->x_format[0], "%10t");
    else
      strcpy(gcd->x_format[0], "%11t");
  } else
    strcpy(gcd->x_format[0], "%11t");

  gcd->select_color(0);

  if (curve) {
    curve->set_curvedata(gcd); // This will free the old gcd
    curve->configure_curves();
    curve->configure_axes();
    curve->redraw();
  }
  *sts = SEV__SUCCESS;
  return 1;
}

int XttSevHist::get_multidata(pwr_tStatus* sts, pwr_tTime from, pwr_tTime to)
{
  pwr_tTime* tbuf;
  void* vbuf;
  pwr_tDeltaTime trange;
  int curve_cnt = 0;
  int data_found;

  // Create data for time axis
  gcd = new GeCurveData(curve_eDataType_MultiTrend);
  strcpy(gcd->x_name, "Time");

  for (int k = 0; k < oid_cnt; k++) {
    if (curve_cnt >= CURVE_MAX_COLS) {
      printf("To many columns for curve class max: %d\n", CURVE_MAX_COLS);
      break;
    }

    if (!sevhistobjectv[k]) {
      if (curve)
        curve->set_clock_cursor();
      sevcli_get_itemdata(sts, scctx, oidv[k], anamev[k], from, to, 1000, &tbuf,
          &vbuf, &rows, &vtype, &vsize);
      if (curve)
        curve->reset_cursor();
      if (EVEN(*sts) && *sts != SEV__NOPOINTS)
        return 0;

      if (rows == 0 || *sts == SEV__NOPOINTS) {
        rows = 0;
        gcd->x_data[curve_cnt] = (double*)calloc(1, 8 * rows);

        gcd->x_axis_type[curve_cnt] = curve_eAxis_x;
        strcpy(gcd->x_format[curve_cnt], "%10t");

        gcd->x_axis_type[curve_cnt] = curve_eAxis_x;
        strcpy(gcd->x_format[curve_cnt], "%10t");

        strcpy(gcd->y_name[curve_cnt], onamev[k]);
        if (!streq(onamev[k], ""))
          strcat(gcd->y_name[curve_cnt], ".");
        strcat(gcd->y_name[curve_cnt], anamev[k]);
        gcd->y_data[curve_cnt] = (double*)calloc(1, 8 * rows);

        gcd->y_axis_type[curve_cnt] = curve_eAxis_y;

        gcd->rows[curve_cnt] = rows;
        curve_cnt++;
        continue;
      }

      gcd->x_data[curve_cnt] = (double*)calloc(1, 8 * rows);
      for (int i = 0; i < rows; i++)
        gcd->x_data[curve_cnt][i]
            = (double)tbuf[i].tv_sec + (double)1e-9 * tbuf[i].tv_nsec;

      gcd->x_axis_type[curve_cnt] = curve_eAxis_x;
      strcpy(gcd->x_format[curve_cnt], "%10t");

      strcpy(gcd->y_name[curve_cnt], onamev[k]);
      if (!streq(onamev[k], ""))
        strcat(gcd->y_name[curve_cnt], ".");
      strcat(gcd->y_name[curve_cnt], anamev[k]);
      gcd->y_data[curve_cnt] = (double*)calloc(1, 8 * rows);

      for (int i = 0; i < rows; i++) {
        switch (vtype) {
        case pwr_eType_Int64:
          gcd->y_data[curve_cnt][i] = ((pwr_tInt32*)vbuf)[i];
          break;
        case pwr_eType_Int32:
          gcd->y_data[curve_cnt][i] = ((pwr_tInt32*)vbuf)[i];
          break;
        case pwr_eType_Int16:
          gcd->y_data[curve_cnt][i] = ((pwr_tInt32*)vbuf)[i];
          break;
        case pwr_eType_Int8:
          gcd->y_data[curve_cnt][i] = ((pwr_tInt32*)vbuf)[i];
          break;
        case pwr_eType_UInt64:
          gcd->y_data[curve_cnt][i] = ((pwr_tUInt32*)vbuf)[i];
          break;
        case pwr_eType_UInt32:
          gcd->y_data[curve_cnt][i] = ((pwr_tUInt32*)vbuf)[i];
          break;
        case pwr_eType_UInt16:
          gcd->y_data[curve_cnt][i] = ((pwr_tUInt32*)vbuf)[i];
          break;
        case pwr_eType_UInt8:
          gcd->y_data[curve_cnt][i] = ((pwr_tUInt32*)vbuf)[i];
          break;
        case pwr_eType_Float32:
          gcd->y_data[curve_cnt][i] = ((pwr_tFloat32*)vbuf)[i];
          break;
        case pwr_eType_Float64:
          gcd->y_data[curve_cnt][i] = ((pwr_tFloat64*)vbuf)[i];
          break;
        case pwr_eType_Boolean:
          gcd->y_data[curve_cnt][i] = ((pwr_tBoolean*)vbuf)[i];
          break;
        default:
          *sts = SEV__CURVETYPE;
          return 0;
        }
      }
      free(tbuf);
      free(vbuf);

      gcd->y_axis_type[curve_cnt] = curve_eAxis_y;

      gcd->rows[curve_cnt] = rows;
      curve_cnt++;
    } else {
      // SevHistObject object
      sevcli_sHistAttr* histattrbuf;
      int numAttributes;

      sevcli_get_objectitemdata(sts, scctx, oidv[k], anamev[k], from, to, 1000,
          &tbuf, &vbuf, &rows, &histattrbuf, &numAttributes);
      if (EVEN(*sts))
        return 0;

      if (rows == 0)
        continue;

      gcd->x_data[curve_cnt] = (double*)calloc(1, 8 * rows);
      for (int i = 0; i < rows; i++)
        gcd->x_data[curve_cnt][i]
            = (double)tbuf[i].tv_sec + (double)1e-9 * tbuf[i].tv_nsec;

      strcpy(gcd->x_name, "Time");
      gcd->x_axis_type[curve_cnt] = curve_eAxis_x;
      strcpy(gcd->x_format[0], "%10t");

      // todo linesize bör vi kunna få från sevcli_get_objectitemdata
      int linesize = 0;
      for (int i = 0; i < numAttributes; i++) {
        linesize += histattrbuf[i].size;
      }
      void* dataptr = vbuf;
      int tmp = 0;
      for (int i = 0; i < numAttributes; i++) {
        gcd->x_data[curve_cnt] = (double*)calloc(1, 8 * rows);
        for (int j = 0; j < rows; j++)
          gcd->x_data[curve_cnt][j]
              = (double)tbuf[j].tv_sec + (double)1e-9 * tbuf[j].tv_nsec;

        strcpy(gcd->x_name, "Time");
        gcd->x_axis_type[curve_cnt] = curve_eAxis_x;
        strcpy(gcd->x_format[curve_cnt], "%10t");

        switch (histattrbuf[i].type) {
        case pwr_eType_Int64:
        case pwr_eType_Int32:
        case pwr_eType_Int16:
        case pwr_eType_Int8:
        case pwr_eType_UInt64:
        case pwr_eType_UInt32:
        case pwr_eType_UInt16:
        case pwr_eType_UInt8:
        case pwr_eType_Float32:
        case pwr_eType_Float64:
        case pwr_eType_Boolean:
          break;
        default:
          tmp += histattrbuf[i].size;
          continue;
        }

        if (curve_cnt >= CURVE_MAX_COLS) {
          printf("To many columns for curve class max:%d\n", CURVE_MAX_COLS);
          break;
        }

        strcpy(gcd->y_name[curve_cnt], onamev[k]);
        if (!streq(onamev[k], ""))
          strcat(gcd->y_name[curve_cnt], ".");
        strcat(gcd->y_name[curve_cnt], histattrbuf[i].aname);
        gcd->y_data[curve_cnt] = (double*)calloc(1, 8 * rows);
        gcd->y_axis_type[curve_cnt] = curve_eAxis_y;

        dataptr = (char*)vbuf + tmp;
        for (int j = 0; j < rows; j++) {
          dataptr = ((char*)vbuf) + j * linesize + tmp;
          switch (histattrbuf[i].type) {
          case pwr_eType_Int64:
            gcd->y_data[curve_cnt][j] = *(pwr_tInt64*)dataptr;
            break;
          case pwr_eType_Int32:
            gcd->y_data[curve_cnt][j] = *(pwr_tInt32*)dataptr;
            break;
          case pwr_eType_Int16:
            gcd->y_data[curve_cnt][j] = *(pwr_tInt16*)dataptr;
            break;
          case pwr_eType_Int8:
            gcd->y_data[curve_cnt][j] = *(pwr_tInt8*)dataptr;
            break;
          case pwr_eType_UInt64:
            gcd->y_data[curve_cnt][j] = *(pwr_tUInt64*)dataptr;
            break;
          case pwr_eType_UInt32:
            gcd->y_data[curve_cnt][j] = *(pwr_tUInt32*)dataptr;
            break;
          case pwr_eType_UInt16:
            gcd->y_data[curve_cnt][j] = *(pwr_tUInt16*)dataptr;
            break;
          case pwr_eType_UInt8:
            gcd->y_data[curve_cnt][j] = *(pwr_tUInt8*)dataptr;
            break;
          case pwr_eType_Float32:
            gcd->y_data[curve_cnt][j] = *(pwr_tFloat32*)dataptr;
            break;
          case pwr_eType_Float64:
            gcd->y_data[curve_cnt][j] = *(pwr_tFloat64*)dataptr;
            break;
          case pwr_eType_Boolean:
            gcd->y_data[curve_cnt][j] = *(pwr_tBoolean*)dataptr;
            break;
          default:
            *sts = SEV__CURVETYPE;
            return 0;
          }
        }
        tmp += histattrbuf[i].size;
        gcd->y_axis_type[curve_cnt] = curve_eAxis_y;

        gcd->rows[curve_cnt] = rows;
        curve_cnt++;
      }
      free(tbuf);
      free(vbuf);
      free(histattrbuf);
    }
  }

  if (curve_cnt == 0) {
    delete gcd;
    *sts = SEV__NODATATIME;
    return 0;
  }

  data_found = 0;
  for (int i = 0; i < curve_cnt; i++) {
    if (gcd->rows[i]) {
      data_found = 1;
      break;
    }
  }

  gcd->cols = curve_cnt;

  if (data_found) {
    gcd->get_borders();
    gcd->get_default_axis();
  }
  if (to.tv_sec != 0 && from.tv_sec != 0) {
    time_Adiff(&trange, &to, &from);
    if (time_DToFloat(0, &trange) < 600)
      strcpy(gcd->x_format[0], "%10t");
    else
      strcpy(gcd->x_format[0], "%11t");
  } else
    strcpy(gcd->x_format[0], "%11t");

  gcd->select_color(0);

  if (curve) {
    curve->set_curvedata(gcd); // This will free the old gcd
    curve->configure_curves();
    curve->configure_axes();
    curve->redraw();
  }
  *sts = SEV__SUCCESS;
  return 1;
}

void XttSevHist::curve_add(
    pwr_tOid oid, pwr_tOName aname, pwr_tOName oname, bool sevhistobject)
{
  if (oid_cnt == XTT_SEVHIST_MAX)
    return;

  if (gcd->type != curve_eDataType_MultiTrend) {
    // Convert to multidata

    for (int i = 1; i < gcd->cols; i++) {
      gcd->rows[i] = gcd->rows[0];
      gcd->x_data[i] = (double*)calloc(1, 8 * gcd->rows[i]);
      memcpy(gcd->x_data[i], gcd->x_data[0], 8 * gcd->rows[i]);

      gcd->x_axis_type[i] = curve_eAxis_x;
      strcpy(gcd->x_format[i], "%10t");
    }
    gcd->type = curve_eDataType_MultiTrend;
  }

  oidv[oid_cnt] = oid;
  strncpy(anamev[oid_cnt], aname, sizeof(anamev[0]));
  strncpy(onamev[oid_cnt], oname, sizeof(onamev[0]));
  sevhistobjectv[oid_cnt] = false;
  oid_cnt++;

  int curve_cnt = gcd->cols;
  rows = 0;

  gcd->x_data[curve_cnt] = (double*)calloc(1, 8 * rows);

  gcd->x_axis_type[curve_cnt] = curve_eAxis_x;
  strcpy(gcd->x_format[curve_cnt], "%10t");

  strcpy(gcd->y_name[curve_cnt], oname);
  if (!streq(oname, ""))
    strcat(gcd->y_name[curve_cnt], ".");
  strcat(gcd->y_name[curve_cnt], aname);
  gcd->y_data[curve_cnt] = (double*)calloc(1, 8 * rows);

  gcd->cols++;

  gcd->select_color(0);
  curve->config_names();
}

void XttSevHist::pop()
{
  curve->pop();
}

void XttSevHist::setup()
{
  if (!curve)
    return;
  curve->setup(curve_mEnable_Timebox | curve_mEnable_Export
      | curve_mEnable_ExportTime | curve_mEnable_CurveType
      | curve_mEnable_CurveTypeSquare | curve_mEnable_FillCurve
      | curve_mEnable_DigitalSplit);
}

void XttSevHist::sevhist_close_cb(void* ctx)
{
  XttSevHist* sevhist = (XttSevHist*)ctx;

  if (sevhist->close_cb)
    (sevhist->close_cb)(sevhist->xnav, sevhist);
  else
    delete sevhist;
}

void XttSevHist::sevhist_decrease_period_cb(void* ctx)
{
  XttSevHist* sevhist = (XttSevHist*)ctx;
  time_ePeriod period;
  pwr_tStatus sts;
  int changed;

  sts = sevhist->curve->get_period(&period);

  changed = time_PeriodZoomIn(&period);
  if (changed)
    sevhist->curve->set_period(period, 0);
}

void XttSevHist::sevhist_increase_period_cb(void* ctx)
{
  XttSevHist* sevhist = (XttSevHist*)ctx;
  time_ePeriod period;
  pwr_tStatus sts;
  int changed;

  sts = sevhist->curve->get_period(&period);

  changed = time_PeriodZoomOut(&period);
  if (changed)
    sevhist->curve->set_period(period, 0);
}

void XttSevHist::sevhist_reload_cb(void* ctx)
{
  XttSevHist* sevhist = (XttSevHist*)ctx;
  pwr_tTime t_low, t_high;
  pwr_tStatus sts;

  sts = sevhist->curve->get_times(&t_low, &t_high);
  if (EVEN(sts)) {
    sevhist->wow->DisplayError("Time", "Time syntax error");
    return;
  }

  if (time_Acomp(&t_high, &t_low) != 1) {
    sevhist->wow->DisplayError("Time", "Start time later than end time");
    return;
  }

  if (t_low.tv_sec < 0)
    t_low.tv_sec = 0;

  if (sevhist->oid_cnt == 1)
    sevhist->get_data(&sts, t_low, t_high);
  else
    sevhist->get_multidata(&sts, t_low, t_high);

  if (EVEN(sts)) {
    sevhist->wow->DisplayError("Data error", XNav::get_message(sts));
    return;
  }

  sevhist->time_low_old = 0;
  sevhist->time_high_old = 0;
  sevhist->curve->set_center_from_window(1);
}

void XttSevHist::sevhist_prev_period_cb(void* ctx)
{
  XttSevHist* sevhist = (XttSevHist*)ctx;
  pwr_tTime from, to, prev_from, prev_to;
  pwr_tStatus sts;
  time_ePeriod period;

  sts = sevhist->curve->get_times(&prev_from, &prev_to);
  if (EVEN(sts)) {
    sevhist->wow->DisplayError("Time", "Time syntax error");
    return;
  }

  sts = sevhist->curve->get_period(&period);

  if (time_Acomp(&prev_to, &prev_from) != 1) {
    sevhist->wow->DisplayError("Time", "Start time later than end time");
    return;
  }

  time_PreviousPeriod(period, &prev_from, &prev_to, &from, &to);

  sevhist->curve->set_times(&from, &to);

  int change_period = 1;
  switch (period) {
  case time_ePeriod_LastMinute:
    period = time_ePeriod_OneMinute;
    break;
  case time_ePeriod_Last10Minutes:
    period = time_ePeriod_10Minutes;
    break;
  case time_ePeriod_LastHour:
    period = time_ePeriod_OneHour;
    break;
  case time_ePeriod_Today:
    period = time_ePeriod_Yesterday;
    break;
  case time_ePeriod_Yesterday:
    period = time_ePeriod_OneDay;
    break;
  case time_ePeriod_ThisWeek:
    period = time_ePeriod_LastWeek;
    break;
  case time_ePeriod_LastWeek:
    period = time_ePeriod_OneWeek;
    break;
  case time_ePeriod_ThisMonth:
    period = time_ePeriod_LastMonth;
    break;
  case time_ePeriod_LastMonth:
    period = time_ePeriod_OneMonth;
    break;
  case time_ePeriod_ThisYear:
    period = time_ePeriod_OneYear;
    break;
  default:
    change_period = 0;
  }
  if (change_period)
    sevhist->curve->set_period(period, 1);
}

void XttSevHist::sevhist_next_period_cb(void* ctx)
{
  XttSevHist* sevhist = (XttSevHist*)ctx;
  pwr_tTime from, to, prev_from, prev_to;
  pwr_tStatus sts;
  time_ePeriod period;

  sts = sevhist->curve->get_times(&prev_from, &prev_to);
  if (EVEN(sts)) {
    sevhist->wow->DisplayError("Time", "Time syntax error");
    return;
  }

  sts = sevhist->curve->get_period(&period);

  if (time_Acomp(&prev_to, &prev_from) != 1) {
    sevhist->wow->DisplayError("Time", "Start time later than end time");
    return;
  }

  time_NextPeriod(period, &prev_from, &prev_to, &from, &to);

  sevhist->curve->set_times(&from, &to);
}

void XttSevHist::sevhist_add_cb(void* ctx)
{
  XttSevHist* sevhist = (XttSevHist*)ctx;
  if (!sevhist->get_select_cb) {
    if (sevhist->otree)
      sevhist->otree->pop();
    else {
      pwr_tAttrRef* list;
      int listcnt;
      pwr_tCid cid[2] = { pwr_cClass_SevHist, pwr_cClass_SevHistObject };
      int options = 0;
      pwr_tStatus sts;

      sts = gdh_GetGlobalClassList(2, cid, 1, &list, &listcnt);
      if (EVEN(sts))
        return;

      if (!listcnt)
        return;

      if (listcnt > 20)
        options |= tree_mOptions_LayoutTree;
      else
        options |= tree_mOptions_LayoutList;
      options |= tree_mOptions_AlphaOrder;

      sevhist->otree = sevhist->tree_new(
          "Add attribute", list, listcnt, options, sevhist_otree_action_cb);
      sevhist->otree->close_cb = sevhist_otree_close_cb;

      free((char*)list);
    }
  } else {
    pwr_tOid oid;
    pwr_tOName aname, oname;
    int sts;

    if (!sevhist->get_select_cb)
      return;

    sts = sevhist->get_select_cb(sevhist->xnav, &oid, aname, oname);
    if (EVEN(sts))
      return;

    sevhist->curve_add(oid, aname, oname, false);
  }
}

pwr_tStatus XttSevHist::sevhist_otree_action_cb(void* ctx, pwr_tAttrRef* aref)
{
  XttSevHist* sevhist = (XttSevHist*)ctx;
  pwr_tStatus sts;
  pwr_tAttrRef aaref;
  pwr_tAName oname;
  pwr_tAName aname;
  char* s;
  pwr_tCid cid;

  sts = gdh_GetAttrRefTid(aref, &cid);
  if (EVEN(sts))
    return sts;

  sts = gdh_ArefANameToAref(aref, "Attribute", &aaref);
  if (EVEN(sts))
    return sts;

  sts = gdh_GetObjectInfoAttrref(&aaref, &aaref, sizeof(pwr_tAttrRef));
  if (EVEN(sts))
    return sts;

  sts = gdh_AttrrefToName(&aaref, oname, sizeof(oname), cdh_mNName);
  if (EVEN(sts))
    return sts;

  s = strchr(oname, '.');
  if (s) {
    *s = 0;
    strncpy(aname, s + 1, sizeof(aname));
  }

  sevhist->curve_add(
      aaref.Objid, aname, oname, cid == pwr_cClass_SevHistObject);
  if (EVEN(sts))
    printf("SevHist add failure\n");
  return sts;
}

void XttSevHist::sevhist_otree_close_cb(void* ctx)
{
  XttSevHist* sevhist = (XttSevHist*)ctx;

  if (sevhist->otree) {
    delete sevhist->otree;
    sevhist->otree = 0;
  }
}

void XttSevHist::sevhist_remove_cb(void* ctx)
{
  // To do
}

int XttSevHist::sevhist_export_cb(void* ctx, pwr_tTime* from, pwr_tTime* to,
    int rows, int idx, char* filename)
{
  XttSevHist* sevhist = (XttSevHist*)ctx;
  pwr_tFileName fname;
  pwr_tTime* tbuf;
  void* vbuf;
  pwr_eType vtype;
  unsigned int vsize;
  pwr_tStatus sts;
  int rrows;
  char timestr[40];
  FILE* fp;
  pwr_tOName oname;

  // Replace $date with date
  strncpy(fname, filename, sizeof(fname));
  char* s1 = strstr(fname, "$date");
  if (s1) {
    char timstr[40];
    pwr_tFileName str;

    sts = time_AtoAscii(
        0, time_eFormat_FileDateAndTime, timstr, sizeof(timstr));

    strncpy(str, s1 + strlen("$date"), sizeof(str));
    *s1 = 0;
    strncat(fname, timstr, sizeof(fname) - strlen(fname) - 1);
    strncat(fname, str, sizeof(fname) - strlen(fname) - 1);
  }

  dcli_translate_filename(fname, fname);

  if (idx == -1) {
    // Export all attributes
    fp = fopen(fname, "w");
    if (!fp)
      return SEV__EXPORTFILE;

    for (int j = 0; j < sevhist->oid_cnt; j++) {
      sts = gdh_ObjidToName(
          sevhist->oidv[j], oname, sizeof(oname), cdh_mName_volumeStrict);
      if (EVEN(sts))
        continue;

      fprintf(fp, "# Attribute %s.%s\n", oname, sevhist->anamev[j]);

      sevhist->curve->set_clock_cursor();
      sevcli_get_itemdata(&sts, sevhist->scctx, sevhist->oidv[j],
          sevhist->anamev[j], *from, *to, rows, &tbuf, &vbuf, &rrows, &vtype,
          &vsize);
      sevhist->curve->reset_cursor();
      if (EVEN(sts)) {
        free(tbuf);
        free(vbuf);
        fclose(fp);
        return sts;
      }

      if (rrows == 0)
        continue;

      fprintf(fp, "# Rows %d\n", rrows);

      for (int i = 0; i < rrows; i++) {
        time_AtoAscii(
            &tbuf[i], time_eFormat_DateAndTime, timestr, sizeof(timestr));
        fprintf(fp, "%s, ", timestr);
        switch (vtype) {
        case pwr_eType_Int32:
        case pwr_eType_Int64:
        case pwr_eType_Int16:
        case pwr_eType_Int8:
          fprintf(fp, "%d", ((pwr_tInt32*)vbuf)[i]);
          break;
        case pwr_eType_UInt64:
        case pwr_eType_UInt32:
        case pwr_eType_UInt16:
        case pwr_eType_UInt8:
          fprintf(fp, "%u", ((pwr_tUInt32*)vbuf)[i]);
          break;
        case pwr_eType_Float32:
          fprintf(fp, "%g", ((pwr_tFloat32*)vbuf)[i]);
          break;
        case pwr_eType_Float64:
          fprintf(fp, "%g", ((pwr_tFloat64*)vbuf)[i]);
          break;
        case pwr_eType_Boolean:
          fprintf(fp, "%d", ((pwr_tBoolean*)vbuf)[i]);
          break;
        default:
          sts = SEV__CURVETYPE;
        }
        fprintf(fp, "\n");
      }
      free(tbuf);
      free(vbuf);
    }
    fclose(fp);
  } else {
    sevhist->curve->set_clock_cursor();
    sevcli_get_itemdata(&sts, sevhist->scctx, sevhist->oidv[idx],
        sevhist->anamev[idx], *from, *to, rows, &tbuf, &vbuf, &rrows, &vtype,
        &vsize);
    sevhist->curve->reset_cursor();
    if (EVEN(sts)) {
      free(tbuf);
      free(vbuf);
      return sts;
    }

    if (rrows == 0) {
      free(tbuf);
      free(vbuf);
      return SEV__NODATATIME;
    }

    fp = fopen(fname, "w");
    if (!fp) {
      free(tbuf);
      free(vbuf);
      return SEV__EXPORTFILE;
    }

    for (int i = 0; i < rrows; i++) {
      time_AtoAscii(
          &tbuf[i], time_eFormat_DateAndTime, timestr, sizeof(timestr));
      fprintf(fp, "%s, ", timestr);
      switch (vtype) {
      case pwr_eType_Int32:
      case pwr_eType_Int64:
      case pwr_eType_Int16:
      case pwr_eType_Int8:
        fprintf(fp, "%d", ((pwr_tInt32*)vbuf)[i]);
        break;
      case pwr_eType_UInt64:
      case pwr_eType_UInt32:
      case pwr_eType_UInt16:
      case pwr_eType_UInt8:
        fprintf(fp, "%u", ((pwr_tUInt32*)vbuf)[i]);
        break;
      case pwr_eType_Float32:
        fprintf(fp, "%g", ((pwr_tFloat32*)vbuf)[i]);
        break;
      case pwr_eType_Float64:
        fprintf(fp, "%g", ((pwr_tFloat64*)vbuf)[i]);
        break;
      case pwr_eType_Boolean:
        fprintf(fp, "%d", ((pwr_tBoolean*)vbuf)[i]);
        break;
      default:
        sts = SEV__CURVETYPE;
      }
      fprintf(fp, "\n");
    }
    free(tbuf);
    free(vbuf);
    fclose(fp);

    printf("Exported %d rows to file \"%s\" (%d)\n", rrows, fname, idx);

    if (EVEN(sts))
      return sts;
  }
  return SEV__SUCCESS;
}

int XttSevHist::read_export(char* filename)
{
  pwr_tFileName fname;
  FILE* fp;
  char line[200];
  int idx = -1;
  int rowcnt = 0;
  int rows;
  char timstr[40];
  double y;
  char* s;
  pwr_tStatus sts;
  pwr_tTime t;

  dcli_translate_filename(fname, filename);

  fp = fopen(fname, "r");
  if (!fp)
    return 0;

  gcd = new GeCurveData(curve_eDataType_DsTrend);

  while (1) {
    sts = dcli_read_line(line, sizeof(line), fp);
    if (!sts)
      break;

    if (line[0] == '#') {
      if (str_StartsWith(&line[2], "Attribute")) {
        // New attribute
        idx++;
        strncpy(onamev[idx], &line[12], sizeof(onamev[0]));
        s = strchr(onamev[idx], '.');
        if (s) {
          *s = 0;
          strncpy(anamev[idx], s + 1, sizeof(anamev[0]));
        }
        rowcnt = 0;

        gcd->y_axis_type[idx] = curve_eAxis_y;
        gcd->x_axis_type[idx] = curve_eAxis_x;
        strcpy(gcd->x_format[idx], "%11t");

        strcpy(gcd->y_name[idx], onamev[idx]);
        strcat(gcd->y_name[idx], ".");
        strcat(gcd->y_name[idx], anamev[idx]);
      } else if (str_StartsWith(&line[2], "Rows")) {
        if (idx < 0)
          continue;

        sscanf(&line[7], "%d", &rows);
        gcd->rows[idx] = rows;
        gcd->x_data[idx] = (double*)calloc(1, 8 * rows);
        gcd->y_data[idx] = (double*)calloc(1, 8 * rows);
      }
    } else {
      if (idx < 0)
        continue;

      strncpy(timstr, line, 23);
      timstr[23] = 0;
      sscanf(&line[25], "%lf", &y);
      if (rowcnt > gcd->rows[idx])
        continue;

      time_AsciiToA(timstr, &t);

      gcd->x_data[idx][rowcnt] = (double)t.tv_sec + (double)1e-9 * t.tv_nsec;
      gcd->y_data[idx][rowcnt] = y;
      rowcnt++;
    }
  }
  if (idx > 0)
    gcd->rows[idx - 1] = rowcnt;
  gcd->cols = idx + 1;

  fclose(fp);

  gcd->get_borders();
  gcd->get_default_axis();
  gcd->select_color(0);
  strcpy(gcd->x_format[0], "%11t");

  if (curve) {
    curve->set_curvedata(gcd); // This will free the old gcd
    curve->configure_curves();
    curve->configure_axes();
    curve->redraw();
  }

  return 1;
}

void XttSevHist::sevhist_help_cb(void* ctx)
{
  XttSevHist* sevhist = (XttSevHist*)ctx;

  if (sevhist->help_cb)
    (sevhist->help_cb)(sevhist->xnav, "opg_history");
}

void XttSevHist::sevhist_scan(void* data)
{
  XttSevHist* sevhist = (XttSevHist*)data;

  if (sevhist->timerid)
    sevhist->timerid->add(1000, sevhist_scan, sevhist);
}
