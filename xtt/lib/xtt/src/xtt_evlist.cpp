/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2014 SSAB AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

/* xtt_evlist.cpp -- Alarm or event list in xtt */

#include "glow_std.h"

#include <stdio.h>
#include <stdlib.h>

#include "pwr.h"
#include "pwr_baseclasses.h"
#include "cow_wow.h"
#include "co_lng.h"
#include "co_time.h"
#include "rt_gdh.h"
#include "flow.h"
#include "flow_browctx.h"
#include "flow_browapi.h"
#include "xtt_evlist.h"
#include "xtt_menu.h"
#include "xtt_methodtoolbar.h"

#include "xnav_bitmap_leaf12.h"
#include "xnav_bitmap_map12.h"
#include "xnav_bitmap_openmap12.h"
#include "xnav_bitmap_attr12.h"
#include "xnav_bitmap_attrarra12.h"
#include "xnav_bitmap_ack8.h"
#include "xnav_bitmap_ack10.h"
#include "xnav_bitmap_ack12.h"
#include "xnav_bitmap_ack14.h"
#include "xnav_bitmap_ack16.h"
#include "xnav_bitmap_ack18.h"
#include "xnav_bitmap_ack20.h"
#include "xnav_bitmap_ack24.h"
#include "xnav_bitmap_alarm8.h"
#include "xnav_bitmap_alarm10.h"
#include "xnav_bitmap_alarm12.h"
#include "xnav_bitmap_alarm14.h"
#include "xnav_bitmap_alarm16.h"
#include "xnav_bitmap_alarm18.h"
#include "xnav_bitmap_alarm20.h"
#include "xnav_bitmap_alarm24.h"
#include "xnav_bitmap_eventalarm8.h"
#include "xnav_bitmap_eventalarm10.h"
#include "xnav_bitmap_eventalarm12.h"
#include "xnav_bitmap_eventalarm14.h"
#include "xnav_bitmap_eventalarm16.h"
#include "xnav_bitmap_eventalarm18.h"
#include "xnav_bitmap_eventalarm20.h"
#include "xnav_bitmap_eventalarm24.h"
#include "xnav_bitmap_eventacked8.h"
#include "xnav_bitmap_eventacked10.h"
#include "xnav_bitmap_eventacked12.h"
#include "xnav_bitmap_eventacked14.h"
#include "xnav_bitmap_eventacked16.h"
#include "xnav_bitmap_eventacked18.h"
#include "xnav_bitmap_eventacked20.h"
#include "xnav_bitmap_eventacked24.h"
#include "xnav_bitmap_eventreturn8.h"
#include "xnav_bitmap_eventreturn10.h"
#include "xnav_bitmap_eventreturn12.h"
#include "xnav_bitmap_eventreturn14.h"
#include "xnav_bitmap_eventreturn16.h"
#include "xnav_bitmap_eventreturn18.h"
#include "xnav_bitmap_eventreturn20.h"
#include "xnav_bitmap_eventreturn24.h"
#include "xnav_bitmap_info8.h"
#include "xnav_bitmap_info10.h"
#include "xnav_bitmap_info12.h"
#include "xnav_bitmap_info14.h"
#include "xnav_bitmap_info16.h"
#include "xnav_bitmap_info18.h"
#include "xnav_bitmap_info20.h"
#include "xnav_bitmap_info24.h"
#include "xnav_bitmap_system8.h"
#include "xnav_bitmap_system10.h"
#include "xnav_bitmap_system12.h"
#include "xnav_bitmap_system14.h"
#include "xnav_bitmap_system16.h"
#include "xnav_bitmap_system18.h"
#include "xnav_bitmap_system20.h"
#include "xnav_bitmap_system24.h"
#include "xnav_bitmap_maintenance8.h"
#include "xnav_bitmap_maintenance10.h"
#include "xnav_bitmap_maintenance12.h"
#include "xnav_bitmap_maintenance14.h"
#include "xnav_bitmap_maintenance16.h"
#include "xnav_bitmap_maintenance18.h"
#include "xnav_bitmap_maintenance20.h"
#include "xnav_bitmap_maintenance24.h"
#include "xnav_bitmap_blockr_12.h"
#include "xnav_bitmap_blockl_12.h"

typedef union alau_Event ala_uEvent;
union alau_Event 
{
    mh_sMsgInfo Info;
    mh_sAck	Ack;
    mh_sMessage Msg;
    mh_sReturn  Return;
    mh_sBlock   Block;
};

static unsigned int prio_enum_to_mask( unsigned int prio);

//
//  Free pixmaps
//
void EvListBrow::free_pixmaps()
{
  brow_FreeAnnotPixmap( ctx, pixmap_leaf);
  brow_FreeAnnotPixmap( ctx, pixmap_map);
  brow_FreeAnnotPixmap( ctx, pixmap_openmap);
  brow_FreeAnnotPixmap( ctx, pixmap_attr);
  brow_FreeAnnotPixmap( ctx, pixmap_attrarray);
  brow_FreeAnnotPixmap( ctx, pixmap_alarm);
  brow_FreeAnnotPixmap( ctx, pixmap_ack);
  brow_FreeAnnotPixmap( ctx, pixmap_eventalarm);
  brow_FreeAnnotPixmap( ctx, pixmap_eventacked);
  brow_FreeAnnotPixmap( ctx, pixmap_eventreturn);
  brow_FreeAnnotPixmap( ctx, pixmap_info);
  brow_FreeAnnotPixmap( ctx, pixmap_system);
  brow_FreeAnnotPixmap( ctx, pixmap_maintenance);
  brow_FreeAnnotPixmap( ctx, pixmap_blockr);
  brow_FreeAnnotPixmap( ctx, pixmap_blockl);
}

//
//  Create pixmaps for leaf, closed map and open map
//
void EvListBrow::allocate_pixmaps()
{
  flow_sPixmapData pixmap_data;
  int i;

  for ( i = 0; i < 9; i++) {
    pixmap_data[i].width =xnav_bitmap_leaf12_width;
    pixmap_data[i].height =xnav_bitmap_leaf12_height;
    pixmap_data[i].bits = (char *)xnav_bitmap_leaf12_bits;
  }

  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_leaf);

  for ( i = 0; i < 9; i++) {
    pixmap_data[i].width =xnav_bitmap_map12_width;
    pixmap_data[i].height =xnav_bitmap_map12_height;
    pixmap_data[i].bits = (char *)xnav_bitmap_map12_bits;
  }

  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_map);

  for ( i = 0; i < 9; i++) {
    pixmap_data[i].width =xnav_bitmap_openmap12_width;
    pixmap_data[i].height =xnav_bitmap_openmap12_height;
    pixmap_data[i].bits = (char *)xnav_bitmap_openmap12_bits;
  }

  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_openmap);

  for ( i = 0; i < 9; i++) {
    pixmap_data[i].width =xnav_bitmap_attr12_width;
    pixmap_data[i].height =xnav_bitmap_attr12_height;
    pixmap_data[i].bits = (char *)xnav_bitmap_attr12_bits;
  }

  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_attr);

  for ( i = 0; i < 9; i++) {
    pixmap_data[i].width =xnav_bitmap_attrarra12_width;
    pixmap_data[i].height =xnav_bitmap_attrarra12_height;
    pixmap_data[i].bits = (char *)xnav_bitmap_attrarra12_bits;
  }

  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_attrarray);

  i = 0;
  pixmap_data[i].width =xnav_bitmap_alarm8_width;
  pixmap_data[i].height =xnav_bitmap_alarm8_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_alarm8_bits;
  pixmap_data[i].width =xnav_bitmap_alarm10_width;
  pixmap_data[i].height =xnav_bitmap_alarm10_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_alarm10_bits;
  pixmap_data[i].width =xnav_bitmap_alarm12_width;
  pixmap_data[i].height =xnav_bitmap_alarm12_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_alarm12_bits;
  pixmap_data[i].width =xnav_bitmap_alarm14_width;
  pixmap_data[i].height =xnav_bitmap_alarm14_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_alarm14_bits;
  pixmap_data[i].width =xnav_bitmap_alarm16_width;
  pixmap_data[i].height =xnav_bitmap_alarm16_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_alarm16_bits;
  pixmap_data[i].width =xnav_bitmap_alarm18_width;
  pixmap_data[i].height =xnav_bitmap_alarm18_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_alarm18_bits;
  pixmap_data[i].width =xnav_bitmap_alarm20_width;
  pixmap_data[i].height =xnav_bitmap_alarm20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_alarm20_bits;
  pixmap_data[i].width =xnav_bitmap_alarm20_width;
  pixmap_data[i].height =xnav_bitmap_alarm20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_alarm20_bits;
  pixmap_data[i].width =xnav_bitmap_alarm24_width;
  pixmap_data[i].height =xnav_bitmap_alarm24_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_alarm24_bits;

  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_alarm);

  i = 0;
  pixmap_data[i].width =xnav_bitmap_ack8_width;
  pixmap_data[i].height =xnav_bitmap_ack8_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_ack8_bits;
  pixmap_data[i].width =xnav_bitmap_ack10_width;
  pixmap_data[i].height =xnav_bitmap_ack10_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_ack10_bits;
  pixmap_data[i].width =xnav_bitmap_ack12_width;
  pixmap_data[i].height =xnav_bitmap_ack12_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_ack12_bits;
  pixmap_data[i].width =xnav_bitmap_ack14_width;
  pixmap_data[i].height =xnav_bitmap_ack14_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_ack14_bits;
  pixmap_data[i].width =xnav_bitmap_ack16_width;
  pixmap_data[i].height =xnav_bitmap_ack16_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_ack16_bits;
  pixmap_data[i].width =xnav_bitmap_ack18_width;
  pixmap_data[i].height =xnav_bitmap_ack18_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_ack18_bits;
  pixmap_data[i].width =xnav_bitmap_ack20_width;
  pixmap_data[i].height =xnav_bitmap_ack20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_ack20_bits;
  pixmap_data[i].width =xnav_bitmap_ack20_width;
  pixmap_data[i].height =xnav_bitmap_ack20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_ack20_bits;
  pixmap_data[i].width =xnav_bitmap_ack24_width;
  pixmap_data[i].height =xnav_bitmap_ack24_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_ack24_bits;

  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_ack);

  i = 0;
  pixmap_data[i].width =xnav_bitmap_eventalarm8_width;
  pixmap_data[i].height =xnav_bitmap_eventalarm8_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventalarm8_bits;
  pixmap_data[i].width =xnav_bitmap_eventalarm10_width;
  pixmap_data[i].height =xnav_bitmap_eventalarm10_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventalarm10_bits;
  pixmap_data[i].width =xnav_bitmap_eventalarm12_width;
  pixmap_data[i].height =xnav_bitmap_eventalarm12_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventalarm12_bits;
  pixmap_data[i].width =xnav_bitmap_eventalarm14_width;
  pixmap_data[i].height =xnav_bitmap_eventalarm14_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventalarm14_bits;
  pixmap_data[i].width =xnav_bitmap_eventalarm16_width;
  pixmap_data[i].height =xnav_bitmap_eventalarm16_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventalarm16_bits;
  pixmap_data[i].width =xnav_bitmap_eventalarm18_width;
  pixmap_data[i].height =xnav_bitmap_eventalarm18_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventalarm18_bits;
  pixmap_data[i].width =xnav_bitmap_eventalarm20_width;
  pixmap_data[i].height =xnav_bitmap_eventalarm20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventalarm20_bits;
  pixmap_data[i].width =xnav_bitmap_eventalarm20_width;
  pixmap_data[i].height =xnav_bitmap_eventalarm20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventalarm20_bits;
  pixmap_data[i].width =xnav_bitmap_eventalarm24_width;
  pixmap_data[i].height =xnav_bitmap_eventalarm24_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventalarm24_bits;


  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_eventalarm);

  i = 0;
  pixmap_data[i].width =xnav_bitmap_eventacked8_width;
  pixmap_data[i].height =xnav_bitmap_eventacked8_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventacked8_bits;
  pixmap_data[i].width =xnav_bitmap_eventacked10_width;
  pixmap_data[i].height =xnav_bitmap_eventacked10_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventacked10_bits;
  pixmap_data[i].width =xnav_bitmap_eventacked12_width;
  pixmap_data[i].height =xnav_bitmap_eventacked12_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventacked12_bits;
  pixmap_data[i].width =xnav_bitmap_eventacked14_width;
  pixmap_data[i].height =xnav_bitmap_eventacked14_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventacked14_bits;
  pixmap_data[i].width =xnav_bitmap_eventacked16_width;
  pixmap_data[i].height =xnav_bitmap_eventacked16_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventacked16_bits;
  pixmap_data[i].width =xnav_bitmap_eventacked18_width;
  pixmap_data[i].height =xnav_bitmap_eventacked18_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventacked18_bits;
  pixmap_data[i].width =xnav_bitmap_eventacked20_width;
  pixmap_data[i].height =xnav_bitmap_eventacked20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventacked20_bits;
  pixmap_data[i].width =xnav_bitmap_eventacked20_width;
  pixmap_data[i].height =xnav_bitmap_eventacked20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventacked20_bits;
  pixmap_data[i].width =xnav_bitmap_eventacked24_width;
  pixmap_data[i].height =xnav_bitmap_eventacked24_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventacked24_bits;

  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_eventacked);

  i = 0;
  pixmap_data[i].width =xnav_bitmap_eventreturn8_width;
  pixmap_data[i].height =xnav_bitmap_eventreturn8_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventreturn8_bits;
  pixmap_data[i].width =xnav_bitmap_eventreturn10_width;
  pixmap_data[i].height =xnav_bitmap_eventreturn10_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventreturn10_bits;
  pixmap_data[i].width =xnav_bitmap_eventreturn12_width;
  pixmap_data[i].height =xnav_bitmap_eventreturn12_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventreturn12_bits;
  pixmap_data[i].width =xnav_bitmap_eventreturn14_width;
  pixmap_data[i].height =xnav_bitmap_eventreturn14_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventreturn14_bits;
  pixmap_data[i].width =xnav_bitmap_eventreturn16_width;
  pixmap_data[i].height =xnav_bitmap_eventreturn16_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventreturn16_bits;
  pixmap_data[i].width =xnav_bitmap_eventreturn18_width;
  pixmap_data[i].height =xnav_bitmap_eventreturn18_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventreturn18_bits;
  pixmap_data[i].width =xnav_bitmap_eventreturn20_width;
  pixmap_data[i].height =xnav_bitmap_eventreturn20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventreturn20_bits;
  pixmap_data[i].width =xnav_bitmap_eventreturn20_width;
  pixmap_data[i].height =xnav_bitmap_eventreturn20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventreturn20_bits;
  pixmap_data[i].width =xnav_bitmap_eventreturn24_width;
  pixmap_data[i].height =xnav_bitmap_eventreturn24_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_eventreturn24_bits;


  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_eventreturn);

  i = 0;
  pixmap_data[i].width =xnav_bitmap_info8_width;
  pixmap_data[i].height =xnav_bitmap_info8_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_info8_bits;
  pixmap_data[i].width =xnav_bitmap_info10_width;
  pixmap_data[i].height =xnav_bitmap_info10_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_info10_bits;
  pixmap_data[i].width =xnav_bitmap_info12_width;
  pixmap_data[i].height =xnav_bitmap_info12_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_info12_bits;
  pixmap_data[i].width =xnav_bitmap_info14_width;
  pixmap_data[i].height =xnav_bitmap_info14_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_info14_bits;
  pixmap_data[i].width =xnav_bitmap_info16_width;
  pixmap_data[i].height =xnav_bitmap_info16_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_info16_bits;
  pixmap_data[i].width =xnav_bitmap_info18_width;
  pixmap_data[i].height =xnav_bitmap_info18_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_info18_bits;
  pixmap_data[i].width =xnav_bitmap_info20_width;
  pixmap_data[i].height =xnav_bitmap_info20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_info20_bits;
  pixmap_data[i].width =xnav_bitmap_info20_width;
  pixmap_data[i].height =xnav_bitmap_info20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_info20_bits;
  pixmap_data[i].width =xnav_bitmap_info24_width;
  pixmap_data[i].height =xnav_bitmap_info24_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_info24_bits;


  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_info);

  i = 0;
  pixmap_data[i].width =xnav_bitmap_maintenance8_width;
  pixmap_data[i].height =xnav_bitmap_maintenance8_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_maintenance8_bits;
  pixmap_data[i].width =xnav_bitmap_maintenance10_width;
  pixmap_data[i].height =xnav_bitmap_maintenance10_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_maintenance10_bits;
  pixmap_data[i].width =xnav_bitmap_maintenance12_width;
  pixmap_data[i].height =xnav_bitmap_maintenance12_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_maintenance12_bits;
  pixmap_data[i].width =xnav_bitmap_maintenance14_width;
  pixmap_data[i].height =xnav_bitmap_maintenance14_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_maintenance14_bits;
  pixmap_data[i].width =xnav_bitmap_maintenance16_width;
  pixmap_data[i].height =xnav_bitmap_maintenance16_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_maintenance16_bits;
  pixmap_data[i].width =xnav_bitmap_maintenance18_width;
  pixmap_data[i].height =xnav_bitmap_maintenance18_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_maintenance18_bits;
  pixmap_data[i].width =xnav_bitmap_maintenance20_width;
  pixmap_data[i].height =xnav_bitmap_maintenance20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_maintenance20_bits;
  pixmap_data[i].width =xnav_bitmap_maintenance20_width;
  pixmap_data[i].height =xnav_bitmap_maintenance20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_maintenance20_bits;
  pixmap_data[i].width =xnav_bitmap_maintenance24_width;
  pixmap_data[i].height =xnav_bitmap_maintenance24_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_maintenance24_bits;


  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_maintenance);

  i = 0;
  pixmap_data[i].width =xnav_bitmap_system8_width;
  pixmap_data[i].height =xnav_bitmap_system8_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_system8_bits;
  pixmap_data[i].width =xnav_bitmap_system10_width;
  pixmap_data[i].height =xnav_bitmap_system10_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_system10_bits;
  pixmap_data[i].width =xnav_bitmap_system12_width;
  pixmap_data[i].height =xnav_bitmap_system12_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_system12_bits;
  pixmap_data[i].width =xnav_bitmap_system14_width;
  pixmap_data[i].height =xnav_bitmap_system14_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_system14_bits;
  pixmap_data[i].width =xnav_bitmap_system16_width;
  pixmap_data[i].height =xnav_bitmap_system16_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_system16_bits;
  pixmap_data[i].width =xnav_bitmap_system18_width;
  pixmap_data[i].height =xnav_bitmap_system18_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_system18_bits;
  pixmap_data[i].width =xnav_bitmap_system20_width;
  pixmap_data[i].height =xnav_bitmap_system20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_system20_bits;
  pixmap_data[i].width =xnav_bitmap_system20_width;
  pixmap_data[i].height =xnav_bitmap_system20_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_system20_bits;
  pixmap_data[i].width =xnav_bitmap_system24_width;
  pixmap_data[i].height =xnav_bitmap_system24_height;
  pixmap_data[i++].bits = (char *)xnav_bitmap_system24_bits;


  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_system);

  for ( i = 0; i < 9; i++) {
    pixmap_data[i].width =xnav_bitmap_blockr_12_width;
    pixmap_data[i].height =xnav_bitmap_blockr_12_height;
    pixmap_data[i].bits = (char *)xnav_bitmap_blockr_12_bits;
  }

  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_blockr);

  for ( i = 0; i < 9; i++) {
    pixmap_data[i].width =xnav_bitmap_blockl_12_width;
    pixmap_data[i].height =xnav_bitmap_blockl_12_height;
    pixmap_data[i].bits = (char *)xnav_bitmap_blockl_12_bits;
  }

  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_blockl);
}

//
// Create nodeclasses
//
void EvListBrow::create_nodeclasses()
{
  allocate_pixmaps();

  // Create common-class

  brow_CreateNodeClass( ctx, "EventDefault", 
		flow_eNodeGroup_Common, &nc_event);
  brow_AddAnnot( nc_event, 0.8, 0.6, 0,
		flow_eDrawType_TextHelveticaBold, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnotPixmap( nc_event, 0, 1.6, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap( nc_event, 1, 2.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmapButton( nc_event, 2, 3.0, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap( nc_event, 3, 3.8, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot( nc_event, 4.8, 0.6, 1,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		0);
  brow_AddAnnot( nc_event, 11.5, 0.6, 2,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		0);
  brow_AddAnnot( nc_event, 13.5, 0.6, 3,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		1);
  brow_AddAnnot( nc_event, 29.5, 0.6, 4,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		1);
  brow_AddFrame( nc_event, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Nodeclass for A-alarm
  brow_CreateNodeClass( ctx, "A_Alarm", 
		flow_eNodeGroup_Common, &nc_a_alarm);
  brow_AddFilledRect( nc_a_alarm, 0.2, 0.15, 0.4, 0.4, flow_eDrawType_LineRed);
  brow_AddRect( nc_a_alarm, 0.2, 0.15, 0.4, 0.4, flow_eDrawType_Line, 0, 0);
  brow_AddAnnot( nc_a_alarm, 0.8, 0.6, 0,
		flow_eDrawType_TextHelveticaBold, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnotPixmap( nc_a_alarm, 0, 1.6, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap( nc_a_alarm, 1, 2.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmapButton( nc_a_alarm, 2, 3.0, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap( nc_a_alarm, 3, 3.8, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot( nc_a_alarm, 4.8, 0.6, 1,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot( nc_a_alarm, 11.5, 0.6, 2,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot( nc_a_alarm, 13.5, 0.6, 3,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddAnnot( nc_a_alarm, 29.5, 0.6, 4,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddFrame( nc_a_alarm, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Nodeclass for B-alarm
  brow_CreateNodeClass( ctx, "B_Alarm", 
		flow_eNodeGroup_Common, &nc_b_alarm);
  brow_AddFilledRect( nc_b_alarm, 0.2, 0.15, 0.4, 0.4, flow_eDrawType_Yellow);
  brow_AddRect( nc_b_alarm, 0.2, 0.15, 0.4, 0.4, flow_eDrawType_Line, 0, 0);
  brow_AddAnnot( nc_b_alarm, 0.8, 0.6, 0,
		flow_eDrawType_TextHelveticaBold, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnotPixmap( nc_b_alarm, 0, 1.6, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap( nc_b_alarm, 1, 2.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmapButton( nc_b_alarm, 2, 3.0, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap( nc_b_alarm, 3, 3.8, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot( nc_b_alarm, 4.8, 0.6, 1,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot( nc_b_alarm, 11.5, 0.6, 2,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot( nc_b_alarm, 13.5, 0.6, 3,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddAnnot( nc_b_alarm, 29.5, 0.6, 4,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddFrame( nc_b_alarm, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Nodeclass for Info
  brow_CreateNodeClass( ctx, "Info", 
		flow_eNodeGroup_Common, &nc_info);
  brow_AddFilledRect( nc_info, 0.2, 0.15, 0.4, 0.4, flow_eDrawType_Green);
  brow_AddRect( nc_info, 0.2, 0.15, 0.4, 0.4, flow_eDrawType_Line, 0, 0);
  brow_AddAnnot( nc_info, 0.8, 0.6, 0,
		flow_eDrawType_TextHelveticaBold, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnotPixmap( nc_info, 0, 1.6, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap( nc_info, 1, 2.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmapButton( nc_info, 2, 3.0, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot( nc_info, 4.8, 0.6, 1,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot( nc_info, 11.5, 0.6, 2,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot( nc_info, 13.5, 0.6, 3,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddAnnot( nc_info, 29.5, 0.6, 4,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 1);
  brow_AddFrame( nc_info, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Nodeclass for Category
  brow_CreateNodeClass( ctx, "Category", 
		flow_eNodeGroup_Common, &nc_category);
  brow_AddAnnotPixmap( nc_category, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap( nc_category, 1, 1.8, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddRect( nc_category, 1.2, 0.15, 0.4, 0.4, flow_eDrawType_LineGray, 0, 0);
  brow_AddAnnot( nc_category, 2.5, 0.6, 0,
		flow_eDrawType_TextHelveticaBold, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot( nc_category, 4.8, 0.6, 1,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot( nc_category, 11.5, 0.6, 2,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddFrame( nc_category, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Nodeclass for Category
  brow_CreateNodeClass( ctx, "CategoryA", 
		flow_eNodeGroup_Common, &nc_category_a);
  brow_AddAnnotPixmap( nc_category_a, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap( nc_category_a, 1, 1.8, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddFilledRect( nc_category_a, 1.2, 0.15, 0.4, 0.4, flow_eDrawType_LineRed);
  brow_AddRect( nc_category_a, 1.2, 0.15, 0.4, 0.4, flow_eDrawType_Line, 0, 0);
  brow_AddAnnot( nc_category_a, 2.5, 0.6, 0,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot( nc_category_a, 4.8, 0.6, 1,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot( nc_category_a, 11.5, 0.6, 2,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddFrame( nc_category_a, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Nodeclass for Category
  brow_CreateNodeClass( ctx, "CategoryB", 
		flow_eNodeGroup_Common, &nc_category_b);
  brow_AddAnnotPixmap( nc_category_b, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap( nc_category_b, 1, 1.8, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddFilledRect( nc_category_b, 1.2, 0.15, 0.4, 0.4, flow_eDrawType_Yellow);
  brow_AddRect( nc_category_b, 1.2, 0.15, 0.4, 0.4, flow_eDrawType_Line, 0, 0);
  brow_AddAnnot( nc_category_b, 2.5, 0.6, 0,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot( nc_category_b, 4.8, 0.6, 1,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot( nc_category_b, 11.5, 0.6, 2,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddFrame( nc_category_b, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Nodeclass for Category
  brow_CreateNodeClass( ctx, "CategoryC", 
		flow_eNodeGroup_Common, &nc_category_c);
  brow_AddAnnotPixmap( nc_category_c, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap( nc_category_c, 1, 1.8, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddFilledRect( nc_category_c, 1.2, 0.15, 0.4, 0.4, flow_eDrawType_LineGray);
  brow_AddRect( nc_category_c, 1.2, 0.15, 0.4, 0.4, flow_eDrawType_Line, 0, 0);
  brow_AddAnnot( nc_category_c, 2.5, 0.6, 0,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot( nc_category_c, 4.8, 0.6, 1,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot( nc_category_c, 11.5, 0.6, 2,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddFrame( nc_category_c, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Nodeclass for Category
  brow_CreateNodeClass( ctx, "CategoryD", 
		flow_eNodeGroup_Common, &nc_category_d);
  brow_AddAnnotPixmap( nc_category_d, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap( nc_category_d, 1, 1.8, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddFilledRect( nc_category_d, 1.2, 0.15, 0.4, 0.4, flow_eDrawType_LineGray);
  brow_AddRect( nc_category_d, 1.2, 0.15, 0.4, 0.4, flow_eDrawType_Line, 0, 0);
  brow_AddAnnot( nc_category_d, 2.5, 0.6, 0,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot( nc_category_d, 4.8, 0.6, 1,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot( nc_category_d, 11.5, 0.6, 2,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddFrame( nc_category_d, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Nodeclass for Category
  brow_CreateNodeClass( ctx, "CategoryInfo", 
		flow_eNodeGroup_Common, &nc_category_i);
  brow_AddAnnotPixmap( nc_category_i, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap( nc_category_i, 1, 1.8, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddFilledRect( nc_category_i, 1.2, 0.15, 0.4, 0.4, flow_eDrawType_Green);
  brow_AddRect( nc_category_i, 1.2, 0.15, 0.4, 0.4, flow_eDrawType_Line, 0, 0);
  brow_AddAnnot( nc_category_i, 2.5, 0.6, 0,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot( nc_category_i, 4.8, 0.6, 1,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot( nc_category_i, 11.5, 0.6, 2,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddFrame( nc_category_i, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Nodeclass for category flash
  brow_CreateNodeClass( ctx, "CategoryFlash", 
		flow_eNodeGroup_Common, &nc_category_flash);
  brow_AddAnnotPixmap( nc_category_flash, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnotPixmap( nc_category_flash, 1, 1.8, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddFilledRect( nc_category_flash, 1.2, 0.15, 0.4, 0.4, flow_eDrawType_Line);
  brow_AddRect( nc_category_flash, 1.2, 0.15, 0.4, 0.4, flow_eDrawType_Line, 0, 0);
  brow_AddAnnot( nc_category_flash, 2.5, 0.6, 0,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot( nc_category_flash, 4.8, 0.6, 1,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddAnnot( nc_category_flash, 11.5, 0.6, 2,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 0);
  brow_AddFrame( nc_category_flash, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);
}

void EvListBrow::brow_setup()
{
  brow_sAttributes brow_attr;
  unsigned long mask;

  if ( Lng::translatefile_coding() == lng_eCoding_UTF_8)
    brow_SetTextCoding( ctx, flow_eTextCoding_UTF_8);

  mask = 0;
  mask |= brow_eAttr_indentation;
  brow_attr.indentation = 0.5;
  mask |= brow_eAttr_annotation_space;
  brow_attr.annotation_space = 0.5;
  brow_SetAttributes( ctx, &brow_attr, mask); 
  brow_SetCtxUserData( ctx, evlist);

  brow_EnableEvent( ctx, flow_eEvent_MB1Click, flow_eEventType_CallBack, 
	EvList::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_MB1DoubleClick, flow_eEventType_CallBack, 
	EvList::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_MB3Press, flow_eEventType_CallBack, 
	EvList::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_MB3Down, flow_eEventType_CallBack, 
	EvList::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_SelectClear, flow_eEventType_CallBack, 
	EvList::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_ObjectDeleted, flow_eEventType_CallBack, 
	EvList::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_Up, flow_eEventType_CallBack, 
	EvList::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_Down, flow_eEventType_CallBack, 
	EvList::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_Right, flow_eEventType_CallBack, 
	EvList::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_Left, flow_eEventType_CallBack, 
	EvList::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_PF3, flow_eEventType_CallBack, 
	EvList::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Radiobutton, flow_eEventType_CallBack, 
	EvList::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_PixmapButton, flow_eEventType_CallBack, 
	EvList::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_PageUp, flow_eEventType_CallBack, 
	EvList::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_PageDown, flow_eEventType_CallBack, 
	EvList::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_ScrollUp, flow_eEventType_CallBack, 
	EvList::brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_ScrollDown, flow_eEventType_CallBack, 
	EvList::brow_cb);
  //brow_EnableEvent( ctx, flow_eEvent_TipText, flow_eEventType_CallBack, 
  //	EvList::brow_cb);
}

//
// Backcall routine called at creation of the brow widget
// Enable event, create nodeclasses and insert the root objects.
//
int EvList::init_brow_cb( FlowCtx *fctx, void *client_data)
{
  EvList *evlist = (EvList *) client_data;
  BrowCtx *ctx = (BrowCtx *)fctx;

  evlist->brow = new EvListBrow( ctx, (void *)evlist);

  evlist->browbase = evlist->brow;
  evlist->brow->brow_setup();
  evlist->brow->create_nodeclasses();

  if ( evlist->init_cb)
    evlist->init_cb( evlist->parent_ctx);
  return 1;
}

int EvList::init_browtree_cb( BrowCtx *fctx, void *client_data)
{
  EvList *evlist = (EvList *) client_data;
  BrowCtx *ctx = (BrowCtx *)fctx;

  evlist->browtree = new EvListBrow( ctx, (void *)evlist);

  evlist->browtree->brow_setup();

  // Redirect callback object deleted
  brow_EnableEvent( evlist->browtree->ctx, flow_eEvent_ObjectDeleted, flow_eEventType_CallBack, browtree_cb);

  evlist->browtree->create_nodeclasses();

  return 1;
}

EvList::EvList(
	void *ev_parent_ctx,
	ev_eType ev_type, 
	int ev_size,
	int ev_eventname_seg,
	void (*ev_init_cb)( void *)) :
  parent_ctx(ev_parent_ctx),
  type(ev_type), browbase(0), browtree(0), size(0), max_size(ev_size), display_hundredth(0),
  hide_object(0), hide_text(0),
  start_trace_cb(0), display_in_xnav_cb(0), name_to_alias_cb(0), 
  sound_cb(0), selection_changed_cb(0), init_cb(ev_init_cb), help_event_cb(0), acc_beep_time(0),
  beep_interval(4), eventname_seg(ev_eventname_seg), current_view(pwr_cNOid), 
  flash_value(false), alarm_table_cnt(0)
{
  memset(alarm_table_member_cnt, 0, sizeof(alarm_table_member_cnt));

  if ( max_size <= 0) {
    switch ( type) {
    case ev_eType_AlarmList:
      max_size = 1000;
      break;
    case ev_eType_BlockList:
      max_size = 200;
      break;
    default:
      max_size = 500;
    }
  }

  if ( type == ev_eType_AlarmList) {
    // Fetch sound objects
    pwr_tStatus sts;

    sts = gdh_NameToAttrref( pwr_cNObjid, "rt:Sounds-AAlarm", &aalarm_sound);
    if ( EVEN(sts))
      aalarm_sound = pwr_cNAttrRef;

    sts = gdh_NameToAttrref( pwr_cNObjid, "rt:Sounds-BAlarm", &balarm_sound);
    if ( EVEN(sts))
      balarm_sound = pwr_cNAttrRef;

    sts = gdh_NameToAttrref( pwr_cNObjid, "rt:Sounds-CAlarm", &calarm_sound);
    if ( EVEN(sts))
      calarm_sound = pwr_cNAttrRef;

    sts = gdh_NameToAttrref( pwr_cNObjid, "rt:Sounds-DAlarm", &dalarm_sound);
    if ( EVEN(sts))
      dalarm_sound = pwr_cNAttrRef;

    sts = gdh_NameToAttrref( pwr_cNObjid, "rt:Sounds-InfoEvent", &info_sound);
    if ( EVEN(sts))
      info_sound = pwr_cNAttrRef;
  }
}


//
//  Delete ev
//
EvList::~EvList()
{
  for ( unsigned int i = 0; i < alarm_table_cnt; i++) {
    gdh_DLUnrefObjectInfo(alarm_tables_refid[i]);
    if ( alarm_table_member_cnt[i] > 0)
      free( alarm_table_members[i]);
  }
}

EvListBrow::~EvListBrow()
{
  free_pixmaps();
  // delete ctx;
}

void EvList::event_info( mh_sMessage *msg)
{
  ala_uEvent 	*event = (ala_uEvent *) msg;
  int		sts;
  ItemAlarm	*dest;
  flow_eDest	dest_code;
  brow_tNode	dest_node;

  if ( type == ev_eType_AlarmList &&
       !( msg->Status & mh_mEventStatus_NotAck ||
          msg->Status & mh_mEventStatus_NotRet))
    return;

  if ( type != ev_eType_HistList ) {
    sts = get_destination( net_NetTimeToTime( &event->Info.EventTime), (void **)&dest);
    if ( EVEN(sts)) {
      dest_code = flow_eDest_IntoLast;
      dest_node = NULL;
    }
    else {
      dest_code = flow_eDest_Before;
      dest_node = dest->node;
    }
  }
  else {
    dest_code = flow_eDest_IntoLast;
    dest_node = NULL;
  }

  new ItemAlarm( this, "Alarm",
		 net_NetTimeToTime( &event->Info.EventTime), event->Msg.EventText,
		 event->Msg.EventName, event->Info.EventType, event->Info.EventFlags,
		 event->Info.EventPrio, event->Info.Id,
		 &event->Msg.Object, &event->Msg.EventSound, 
		 event->Msg.EventMoreText, msg->Status, 
		 evlist_eEventType_Info, &event->Msg.SupObject, dest_node, dest_code, &sts);
  if ( EVEN(sts)) return;
  size++;
}

void EvList::event_alarm( mh_sMessage *msg)
{
  ala_uEvent 	*event = (ala_uEvent *) msg;
  int		sts;
  ItemAlarm	*dest;
  flow_eDest	dest_code;
  brow_tNode	dest_node;

  if ( type == ev_eType_AlarmList ) {
    if ( !( msg->Status & mh_mEventStatus_NotAck ||
	    msg->Status & mh_mEventStatus_NotRet))
      return;

    // Check that this id not already inserted
    ItemAlarm *item;

    if ( id_to_item( &event->Info.Id, (void **)&item))
      return;      
  }
  if ( type != ev_eType_HistList ) {
    sts = get_destination( net_NetTimeToTime( &event->Info.EventTime), (void **)&dest);
    if ( EVEN(sts)) {
      dest_code = flow_eDest_IntoLast;
      dest_node = NULL;
    }
    else {
      dest_code = flow_eDest_Before;
      dest_node = dest->node;
    }
  }
  else {
    dest_code = flow_eDest_IntoLast;
    dest_node = NULL;
  }

  ItemAlarm *item = new ItemAlarm( this, "Alarm",
		 net_NetTimeToTime( &event->Info.EventTime), event->Msg.EventText,
	         event->Msg.EventName, event->Info.EventType, event->Info.EventFlags,
		 event->Info.EventPrio, event->Info.Id,
		 &event->Msg.Object, &event->Msg.EventSound, 
		 event->Msg.EventMoreText, msg->Status, 
		 evlist_eEventType_Alarm, &event->Msg.SupObject, dest_node, dest_code, &sts);
  if ( EVEN(sts)) return;
  size++;

  view_alarm( item);
  view_configure();
}

void EvList::event_block( mh_sBlock *msg)
{
  ala_uEvent 	*event = (ala_uEvent *) msg;
  int		sts;

  if ( type == ev_eType_BlockList) {

    switch( msg->Info.EventType) {
    case mh_eEvent_Block:
    case mh_eEvent_Reblock: {
      ItemAlarm 	*item;
      ItemAlarm	*dest;
      flow_eDest	dest_code;
      brow_tNode	dest_node;
      char name[80];
      char text[100];

      if ( oid_to_item( msg->Object.Objid, (void **)&item)) {
	brow_DeleteNode( browbase->ctx, item->node);
	size--;
      }
      sts = get_destination( net_NetTimeToTime( &event->Info.EventTime), (void **)&dest);
      if ( EVEN(sts)) {
	dest_code = flow_eDest_IntoLast;
	dest_node = NULL;
      }
      else {
	dest_code = flow_eDest_Before;
	dest_node = dest->node;
      }
      sts = gdh_ObjidToName( msg->Outunit, name, sizeof(name), 
			     cdh_mName_path | cdh_mName_object);
      if ( ODD(sts)) {
	strcpy( text, "User: ");
	strcat( text, name);
      }
      else
	strcpy( text, "Unknown");
      
      new ItemAlarm( this, "Alarm",
		     net_NetTimeToTime( &event->Info.EventTime), event->Block.EventName,
		     text, event->Info.EventType, event->Info.EventFlags,
		     event->Info.EventPrio, event->Info.Id,
		     &event->Block.Object, 0, 0, 0, evlist_eEventType_Block,
		     &event->Block.SupObject, dest_node, dest_code, &sts);
      if ( EVEN(sts)) return;
      size++;
      break;
    }
    case mh_eEvent_CancelBlock:
    case mh_eEvent_Unblock: {
      ItemAlarm 	*item;
      
      if ( !oid_to_item( msg->Object.Objid, (void **)&item))
	break;
      
      brow_DeleteNode( browbase->ctx, item->node);
      size--;
      break;
    }
    default:
      ;
    }
  }
  else if ( type == ev_eType_EventList) {
    char text[100];
    char name[80];
    flow_eDest	dest_code;
    brow_tNode	dest_node;

    sts = gdh_ObjidToName( msg->Outunit, name, sizeof(name), 
			     cdh_mName_path | cdh_mName_object);
    if ( EVEN(sts))
      strcpy( name, "");

    switch( msg->Info.EventType) {
    case mh_eEvent_Block:
      strcpy( text, "Blocked by: ");
      break;
    case mh_eEvent_Reblock:
      strcpy( text, "Reblocked by: ");
      break;
    case mh_eEvent_CancelBlock:
      strcpy( text, "CancelBlocked by: ");
      break;
    case mh_eEvent_Unblock:
      strcpy( text, "Unblocked by: ");
      break;
    default:
      strcpy( text, "Unknown ");
    }
    strcat( text, name);

    dest_code = flow_eDest_IntoLast;
    dest_node = NULL;

    ItemAlarm *item = new ItemAlarm( this, "Alarm",
				     net_NetTimeToTime( &event->Info.EventTime), text, 
				     event->Block.EventName, event->Info.EventType, event->Info.EventFlags,
				     event->Info.EventPrio, event->Info.Id,
				     &event->Block.Object, 0, 0, 0, evlist_eEventType_Block,
				     &event->Block.SupObject, dest_node, dest_code, &sts);
    if ( EVEN(sts)) return;

    switch( msg->Info.EventType) {
    case mh_eEvent_Block:
    case mh_eEvent_Reblock:
      brow_SetAnnotPixmap( item->node, 0, browbase->pixmap_blockr);
      break;
    case mh_eEvent_CancelBlock:
    case mh_eEvent_Unblock:
      brow_SetAnnotPixmap( item->node, 0, browbase->pixmap_blockl);
      break;
    default: ;
    }
    size++;
  }
}

void EvList::block_remove()
{
  brow_tNode	*node_list;
  int		node_count;
  ItemAlarm	*item;
  mh_eEventPrio prio = (mh_eEventPrio) 0;
  pwr_tStatus 	sts;

  brow_GetSelectedNodes( browbase->ctx, &node_list, &node_count);
  if ( !node_count)
    return;

  for ( int i = 0; i < node_count; i++) {
    brow_GetUserData( node_list[i], (void **)&item);

    switch( item->type) {
    case evlist_eItemType_Alarm:
      sts = mh_OutunitBlock( item->object.Objid, prio);
      break;
    default: ;
    }
  }
  free( node_list);
}

void EvList::event_cancel( mh_sReturn *msg)
{
  if ( type != ev_eType_AlarmList)
    return;

  ItemAlarm 	*item;

  if ( !id_to_item( &msg->TargetId, (void **)&item))
    return;

  brow_DeleteNode( browbase->ctx, item->node);
  size--;
}

void EvList::event_ack( mh_sAck *msg)
{
  ala_uEvent 	*event = (ala_uEvent *) msg;
  int		sts;
  ItemAlarm	*dest;
  flow_eDest	dest_code;
  brow_tNode	dest_node;

  if ( type == ev_eType_EventList || type == ev_eType_HistList) {
    if(type == ev_eType_EventList) {
      sts = get_destination( net_NetTimeToTime( &event->Info.EventTime), (void **)&dest);
      if ( EVEN(sts)) {
        dest_code = flow_eDest_IntoLast;
        dest_node = NULL;
      }
      else {
        dest_code = flow_eDest_Before;
        dest_node = dest->node;
      }
    }
    else {   
      dest_code = flow_eDest_IntoLast;
      dest_node = NULL;
    }
    ItemAlarm *item = new ItemAlarm( this, "Alarm",
		   net_NetTimeToTime( &event->Info.EventTime), "",
		   event->Ack.EventName, event->Info.EventType, event->Info.EventFlags,
	event->Info.EventPrio, event->Info.Id,
	&event->Ack.Object, 0, 0, 0, evlist_eEventType_Ack,
	&event->Ack.SupObject, dest_node, dest_code, &sts);
    if ( EVEN(sts)) return;
    size++;

    view_alarm( item);
    view_configure();
  }
  
  else {
    // Alarmlist
    ItemAlarm 	*item;

    if ( !id_to_item( &msg->TargetId, (void **)&item))
      return;

    switch( item->event_type) {
      case evlist_eEventType_Alarm:
        if ( item->status & mh_mEventStatus_NotRet) {
          item->status &= ~mh_mEventStatus_NotAck;
          item->update_text(0);
	  if ( item->tree_node)
	    item->update_text(1);
        }
        else {
          brow_DeleteNode( browbase->ctx, item->node);
	  if ( browtree) {
	    if ( item->tree_node)
	      brow_DeleteNode( browtree->ctx, item->tree_node);
	    view_configure();
	  }
          size--;
        }
        break;
      case evlist_eEventType_Info:
        if ( item->eventflags & mh_mEventFlags_InfoWindow) {
          brow_DeleteNode( browbase->ctx, item->node);
	  if ( browtree) {
	    if ( item->tree_node)
	      brow_DeleteNode( browtree->ctx, item->tree_node);
	    view_configure();
	  }
          size--;
        }
        break;
      default:
        ;
    }
  }
}

void EvList::event_return( mh_sReturn *msg)
{
  ala_uEvent 	*event = (ala_uEvent *) msg;
  int		sts;
  ItemAlarm	*dest;
  flow_eDest	dest_code;
  brow_tNode	dest_node;

  if ( type == ev_eType_EventList || type == ev_eType_HistList) {
    if(type == ev_eType_EventList) {
      sts = get_destination( net_NetTimeToTime( &event->Info.EventTime), (void **)&dest);
      if ( EVEN(sts)) {
        dest_code = flow_eDest_IntoLast;
        dest_node = NULL;
      }
      else {
        dest_code = flow_eDest_Before;
        dest_node = dest->node;
      }
    }
    else {
      dest_code = flow_eDest_IntoLast;
      dest_node = NULL;
    }
    ItemAlarm *item = new ItemAlarm( this, "Alarm",
		   net_NetTimeToTime( &event->Info.EventTime), event->Msg.EventText,
		   event->Return.EventName, event->Info.EventType, event->Info.EventFlags,
		   event->Info.EventPrio, event->Info.Id,
		   &event->Return.Object, 0, 0, 0, evlist_eEventType_Return,
		   &event->Return.SupObject, dest_node, dest_code, &sts);
    if ( EVEN(sts)) return;
    size++;

    view_alarm( item);
    view_configure();
  }

  else {
    // Alarmlist
    ItemAlarm 	*item;

    if ( !id_to_item( &msg->TargetId, (void **)&item))
      return;

    if ( item->status & mh_mEventStatus_NotAck) {
      item->status &= ~mh_mEventStatus_NotRet;
      item->update_text(0);
      if ( item->tree_node)
	item->update_text(1);
    }
    else {
      brow_DeleteNode( browbase->ctx, item->node);
      if ( browtree) {
	if ( item->tree_node)
	  brow_DeleteNode( browtree->ctx, item->tree_node);
	view_configure();
      }
      size--;
    }
  }
}

void EvList::print_nodia( char *filename)
{
  brow_Print( brow->ctx, filename);
}

void EvList::event_clear_alarmlist( pwr_tNodeIndex nix)
{
  int		i;
  brow_tObject 	*object_list, *stored_object_list;
  int		object_cnt;
  ItemAlarm	*object_item;

  brow_GetObjectList( browbase->ctx, &object_list, &object_cnt);
  if ( object_cnt == 0)
    return;

  // Copy the objectlist, to avoid changes when object are deleted
  stored_object_list = (brow_tObject *) calloc( object_cnt, sizeof(brow_tObject));
  memcpy( stored_object_list, object_list, object_cnt * sizeof(brow_tObject));

  // Remove all items with the present node index
  for ( i = 0; i < object_cnt; i++) {
    brow_GetUserData( stored_object_list[i], (void **)&object_item);
    switch( object_item->type) {
    case evlist_eItemType_Alarm:
      if ( object_item->eventid.Nix == nix) {
	brow_DeleteNode( browbase->ctx, object_item->node);
	if ( browtree) {
	  if ( object_item->tree_node)
	    brow_DeleteNode( browtree->ctx, object_item->tree_node);
	  view_configure();
	}
      }
      break;
    default:
      ;
    }
  }
  free( (char *)stored_object_list);
}

//
//  Zoom
//
void EvList::zoom( double zoom_factor)
{
  brow_Zoom( brow->ctx, zoom_factor);
}

//
//  Return to base zoom factor
//
void EvList::unzoom()
{
  brow_UnZoom( brow->ctx);
}

void EvList::beep( double scantime)
{
  int sts;
  mh_sEventId *id;

  if ( acc_beep_time >= beep_interval)
     acc_beep_time = 0;

  sts = get_last_not_acked_beep( &id);
  if ( ODD(sts)) {
    if ( acc_beep_time == 0) {
      sts = 0;
      if ( sound_cb) {
	ItemAlarm *item;

	if ( id_to_item( id, (void **)&item)) {
	  pwr_tAttrRef *sound_arp;

	  if ( cdh_ObjidIsNotNull(item->eventsound.Objid))
	    sound_arp = &item->eventsound;
	  else {
	    switch ( item->event_type) {
	    case evlist_eEventType_Alarm:
	      switch ( item->eventprio) {
	      case mh_eEventPrio_A:
		sound_arp = &aalarm_sound;
		break;
	      case mh_eEventPrio_B:
		sound_arp = &balarm_sound;
		break;
	      case mh_eEventPrio_C:
		sound_arp = &calarm_sound;
		break;
	      default:
		sound_arp = &dalarm_sound;
	      }
	      break;
	    default:
	      sound_arp = &info_sound;
	      break;
	    }
	  }
	  sts = (sound_cb)( parent_ctx, sound_arp);
	}
      }
      if ( EVEN(sts))
	// Sound is not loaded
	bell();
    }
    acc_beep_time += scantime;
  }
  else
    acc_beep_time = 0;
}

void EvList::set_nodraw()
{
  brow_SetNodraw( brow->ctx);
}

void EvList::reset_nodraw()
{
  brow_ResetNodraw( brow->ctx);
  brow_Redraw( brow->ctx, 0);
}

void EvList::start_trace()
{
  brow_tNode	*node_list;
  int		node_count;
  ItemAlarm	*item;
  char		name[80];
  pwr_tObjid	parent;
  pwr_tClassId	classid;
  int		sts;

  brow_GetSelectedNodes( brow->ctx, &node_list, &node_count);
  if ( !node_count)
    return;

  brow_GetUserData( node_list[0], (void **)&item);
  free( node_list);

  switch( item->type)
  {
    case evlist_eItemType_Alarm:
      
      sts = gdh_GetParent( item->object.Objid, &parent);
      if ( EVEN(sts)) return;
      
      sts = gdh_GetObjectClass( parent, &classid);
      if ( EVEN(sts)) return;

      if ( ! (classid == pwr_cClass_windowplc ||
              classid == pwr_cClass_windowcond ||
              classid == pwr_cClass_windoworderact ||
              classid == pwr_cClass_windowsubstep))
        return;

      sts = gdh_ObjidToName( item->object.Objid, 
	    	name, sizeof(name), cdh_mName_object);
      if ( EVEN(sts)) return;

      if ( start_trace_cb)
        (start_trace_cb)( parent_ctx, parent, name);

      break;
    default:
      ;
  }
}

void EvList::display_in_xnav()
{
  brow_tNode	*node_list;
  int		node_count;
  ItemAlarm	*item;

  brow_GetSelectedNodes( brow->ctx, &node_list, &node_count);
  if ( !node_count)
    return;

  brow_GetUserData( node_list[0], (void **)&item);
  free( node_list);

  switch( item->type)
  {
    case evlist_eItemType_Alarm:
      if ( cdh_ObjidIsNull( item->object.Objid))
        return;
      if ( display_in_xnav_cb) {
        (display_in_xnav_cb)( parent_ctx, &item->object);
      }
      break;
    default:
      ;
  }
}

//
// Callbacks from brow
//
int EvList::browtree_cb( FlowCtx *ctx, flow_tEvent event)
{
  ItemEvBase 		*item;

  if ( event->event == flow_eEvent_ObjectDeleted) {
    brow_GetUserData( event->object.object, (void **)&item);
    if ( item->type == evlist_eItemType_Category)
      delete item;
    else if ( item->type == evlist_eItemType_Alarm)
      ((ItemAlarm *)item)->tree_node = 0;
    
    return 1;
  }
  else
    brow_cb( ctx, event);

  return 1;
}

int EvList::brow_cb( FlowCtx *ctx, flow_tEvent event)
{
  EvList		*evlist;
  ItemAlarm 		*item;

  if ( event->event == flow_eEvent_ObjectDeleted)
  {
    brow_GetUserData( event->object.object, (void **)&item);
    delete item;
    return 1;
  }

  brow_GetCtxUserData( (BrowCtx *)ctx, (void **) &evlist);
  switch ( event->event)
  {
    case flow_eEvent_Key_Up:
    {
      brow_tNode	*node_list;
      int		node_count;
      brow_tObject	object;
      int		sts;

      brow_GetSelectedNodes( evlist->brow->ctx, &node_list, &node_count);
      if ( !node_count) {
        sts = brow_GetLastVisible( evlist->brow->ctx, &object);
        if ( EVEN(sts)) return 1;
      }
      else {
	if ( !brow_IsVisible( evlist->brow->ctx, node_list[0], flow_eVisible_Partial)) {
	  sts = brow_GetLastVisible( evlist->brow->ctx, &object);
	  if ( EVEN(sts)) return 1;
	}
	else {
	  sts = brow_GetPrevious( evlist->brow->ctx, node_list[0], &object);
	  if ( EVEN(sts)) {
            if ( node_count)
	      free( node_list);
            return 1;
 	  }
        }
      }
      brow_SelectClear( evlist->brow->ctx);
      brow_SetInverse( object, 1);
      brow_SelectInsert( evlist->brow->ctx, object);
      if ( !brow_IsVisible( evlist->brow->ctx, object, flow_eVisible_Full))
        brow_CenterObject( evlist->brow->ctx, object, 0.25);
      if ( node_count)
        free( node_list);
      if ( evlist->selection_changed_cb)
	(evlist->selection_changed_cb)( evlist->parent_ctx);
      break;
    }
    case flow_eEvent_Key_Down:
    {
      brow_tNode	*node_list;
      int		node_count;
      brow_tObject	object;
      int		sts;

      brow_GetSelectedNodes( evlist->brow->ctx, &node_list, &node_count);
      if ( !node_count) {
        sts = brow_GetFirstVisible( evlist->brow->ctx, &object);
        if ( EVEN(sts)) return 1;
      }
      else {
	if ( !brow_IsVisible( evlist->brow->ctx, node_list[0], flow_eVisible_Partial)) {
	  sts = brow_GetFirstVisible( evlist->brow->ctx, &object);
	  if ( EVEN(sts)) return 1;
	}
	else {
	  sts = brow_GetNext( evlist->brow->ctx, node_list[0], &object);
	  if ( EVEN(sts)) {
            if ( node_count)
	      free( node_list);
            return 1;
 	  }
        }
      }
      brow_SelectClear( evlist->brow->ctx);
      brow_SetInverse( object, 1);
      brow_SelectInsert( evlist->brow->ctx, object);
      if ( !brow_IsVisible( evlist->brow->ctx, object, flow_eVisible_Full))
        brow_CenterObject( evlist->brow->ctx, object, 0.75);
      if ( node_count)
        free( node_list);
      if ( evlist->selection_changed_cb)
	(evlist->selection_changed_cb)( evlist->parent_ctx);
      break;
    }
    case flow_eEvent_SelectClear:
      brow_ResetSelectInverse( evlist->brow->ctx);
      break;
    case flow_eEvent_MB1Click: {
      // Select
      double ll_x, ll_y, ur_x, ur_y;
      int sts;

      switch ( event->object.object_type)
      {
        case flow_eObjectType_Node:
          brow_MeasureNode( event->object.object, &ll_x, &ll_y,
			&ur_x, &ur_y);
	  if ( event->object.x < ll_x + 1.0)
          {
            // Simulate doubleclick
            flow_tEvent doubleclick_event;

            doubleclick_event = (flow_tEvent) calloc( 1, sizeof(*doubleclick_event));
            memcpy( doubleclick_event, event, sizeof(*doubleclick_event));
            doubleclick_event->event = flow_eEvent_MB1DoubleClick;
            sts = brow_cb( ctx, doubleclick_event);
            free( (char *) doubleclick_event);
            return sts;
          }
          if ( brow_FindSelectedObject( evlist->brow->ctx, event->object.object))
          {
            brow_SelectClear( evlist->brow->ctx);
          }
          else
          {
            brow_SelectClear( evlist->brow->ctx);
            brow_SetInverse( event->object.object, 1);
            brow_SelectInsert( evlist->brow->ctx, event->object.object);
          }
	  if ( evlist->selection_changed_cb)
	    (evlist->selection_changed_cb)( evlist->parent_ctx);
          break;
        default:
          brow_SelectClear( evlist->brow->ctx);
      }
      break;
    }
    case flow_eEvent_MB3Down:
    {
      brow_SetClickSensitivity( evlist->brow->ctx, 
				      flow_mSensitivity_MB3Press);
      break;
    }
    case flow_eEvent_MB3Press:
    {            
      // Popup menu
      int x, y;

      switch ( event->object.object_type)
      {
        case flow_eObjectType_Node:
          if ( evlist->popup_menu_cb) {
            brow_GetUserData( event->object.object, (void **)&item);
	    if ( event->any.x < 2 ) {
	      // Popup menu methods for sup object
	      if ( cdh_ObjidIsNotNull( item->supobject.Objid)) {
		evlist->popup_position( event->any.x_pixel + 8, event->any.y_pixel, &x, &y);
		(evlist->popup_menu_cb)( evlist->parent_ctx, item->supobject,
					 (unsigned long)xmenu_eItemType_Object, 
					 (unsigned long)xmenu_mUtility_EventList, NULL, x, y);
	      }
	    }
	    else {
	      // Popup menu methods for eventname object
	      if ( cdh_ObjidIsNotNull( item->object.Objid)) {
		pwr_tAttrRef aref;
		pwr_tObjName cname;
		pwr_tStatus sts;
		pwr_tCid cid;

		// Show menu for parent object for some attribute objects instead
		sts = gdh_GetAttrRefTid( &item->object, &cid);
		if ( EVEN(sts)) break;

		sts = gdh_ObjidToName( cdh_ClassIdToObjid(cid), cname, sizeof(cname), 
				       cdh_mName_object);
		if ( ODD(sts)) {
		  if ( strncmp( cname, "CompMode", 8) == 0) {
		    // Take parent object level
		    sts = gdh_AttrArefToObjectAref( &item->object, &aref);
		    if ( EVEN(sts)) 
		      aref = item->object;
		  }
		  else
		    aref = item->object;
		}
		else 
		  aref = item->object;

		evlist->popup_position( event->any.x_pixel + 8, event->any.y_pixel, &x, &y);
		(evlist->popup_menu_cb)( evlist->parent_ctx, aref,
					 (unsigned long)xmenu_eItemType_Object, 
					 (unsigned long)xmenu_mUtility_EventList, NULL, x, y);
	      }
            }
          }
          break;
        default:
          ;
      }
      break;
    }
    case flow_eEvent_Key_PageDown: {
      brow_Page( evlist->brow->ctx, 0.9);
      break;
    }
    case flow_eEvent_Key_PageUp: {
      brow_Page( evlist->brow->ctx, -0.9);
      break;
    }
    case flow_eEvent_ScrollDown: {
      brow_Page( evlist->brow->ctx, 0.1);
      break;
    }
    case flow_eEvent_ScrollUp: {
      brow_Page( evlist->brow->ctx, -0.1);
      break;
    }
    case flow_eEvent_Key_Left:
    {
      brow_tNode	*node_list;
      int		node_count;
      brow_tObject	object;
      int		sts;

      brow_GetSelectedNodes( evlist->brow->ctx, &node_list, &node_count);
      if ( !node_count)
        return 1;

      if ( brow_IsOpen( node_list[0]))
        // Close this node
        object = node_list[0];
      else
      {
        // Close parent
        sts = brow_GetParent( evlist->brow->ctx, node_list[0], &object);
        if ( EVEN(sts))
        {
          free( node_list);
          return 1;
        }
      }
      brow_GetUserData( object, (void **)&item);
      switch( item->type)
      {
        case evlist_eItemType_Alarm:
//	  ((ItemLocal *)item)->close( evlist, 0, 0);
          break;
        case evlist_eItemType_Category:
	  ((ItemCategory *)item)->close( evlist, 0, 0);
          break;
        default:
          ;
      }
      brow_SelectClear( evlist->brow->ctx);
      brow_SetInverse( object, 1);
      brow_SelectInsert( evlist->brow->ctx, object);
      if ( !brow_IsVisible( evlist->brow->ctx, object, flow_eVisible_Full))
        brow_CenterObject( evlist->brow->ctx, object, 0.25);
      free( node_list);
      break;
    }
    case flow_eEvent_Key_Right:
    {
      brow_tNode	*node_list;
      int		node_count;

      brow_GetSelectedNodes( evlist->brow->ctx, &node_list, &node_count);
      if ( !node_count)
        return 1;

      brow_GetUserData( node_list[0], (void **)&item);
      switch( item->type)
      {
        case evlist_eItemType_Alarm:
//	  ((ItemAlarm *)item)->open_children( evlist, 0, 0);
          break;
        case evlist_eItemType_Category:
	  ((ItemCategory *)item)->open_children( evlist, 0, 0);
          break;
        default:
          ;
      }
    }
    case flow_eEvent_MB1DoubleClick:
      switch ( event->object.object_type)
      {
        case flow_eObjectType_Node:
          brow_GetUserData( event->object.object, (void **)&item);
          switch( item->type)
          {
            case evlist_eItemType_Alarm: 
//	      ((ItemAlarm *)item)->open_children( evlist,
//			event->object.x, event->object.y);
              break;
            case evlist_eItemType_Category: 
	      ((ItemCategory *)item)->open_children( evlist,
			event->object.x, event->object.y);
              break;
            default:
              ;
          }
          break;
        default:
          ;
      }
      break;
    case flow_eEvent_TipText: {
      brow_GetUserData( event->object.object, (void **)&item);
      switch( item->type) {
        case evlist_eItemType_Alarm:
	  if ( strcmp( ((ItemAlarm *)item)->eventmoretext, "") != 0) {
	    brow_SetTipText( evlist->brow->ctx, event->object.object, ((ItemAlarm *)item)->eventmoretext, 
			 event->any.x_pixel, event->any.y_pixel);
	  }
          break;
        default:
          ;
      }
      break;
    }
    case flow_eEvent_PixmapButton: {
      brow_GetUserData( event->object.object, (void **)&item);
      switch( item->type) {
        case evlist_eItemType_Alarm:
	  if ( strcmp( ((ItemAlarm *)item)->eventmoretext, "") != 0) {
	    if ( evlist->help_event_cb)
	      evlist->help_event_cb( evlist->parent_ctx, item);
	  }
          break;
        default:
          ;
      }
      break;
    }
    default:
      ;
  }
  return 1;
}

ItemAlarm::ItemAlarm( EvList *item_evlist, const char *item_name, pwr_tTime item_time,
	const char *item_eventtext, char *item_eventname, int item_eventtype, int item_eventflags,
	unsigned long item_eventprio, mh_sEventId item_eventid,
	pwr_tAttrRef *item_object, pwr_tAttrRef *item_eventsound, char *item_eventmoretext,
        unsigned long item_status, evlist_eEventType item_event_type, pwr_tAttrRef *item_supobject,
	brow_tNode dest, flow_eDest dest_code, int *rsts):
        event_type(item_event_type), evlist(item_evlist), tree_node(0), time(item_time), 
	eventtype(item_eventtype), eventflags(item_eventflags), eventprio(item_eventprio),
	eventid(item_eventid), object(*item_object), status(item_status), supobject(*item_supobject)
{
  type = evlist_eItemType_Alarm;
  brow_tNodeClass 	nc;

  *rsts = 1;
  strcpy( name, item_name);
  strncpy( eventtext, Lng::translate( item_eventtext), sizeof(eventtext));
  eventtext[sizeof(eventtext)-1] = 0;
  strncpy( eventname, item_eventname, sizeof(eventname));
  eventname[sizeof(eventname)-1] = 0;
  if ( evlist->name_to_alias_cb)
    strcpy( alias, evlist->name_to_alias_cb( evlist->parent_ctx, eventname));
  else
    strcpy( alias, "");
  if ( item_eventsound)
    eventsound = *item_eventsound;
  if ( eventmoretext && item_eventmoretext)
    strncpy( eventmoretext, item_eventmoretext, sizeof(eventmoretext));
  else
    strcpy( eventmoretext, "");

  switch ( event_type) { 
  case evlist_eEventType_Alarm:
  case evlist_eEventType_Block:
    switch ( eventprio) {
    case mh_eEventPrio_A:
      nc = evlist->browbase->nc_a_alarm;
      break;
    case mh_eEventPrio_B:
      nc = evlist->browbase->nc_b_alarm;
      break;
    default:
      nc = evlist->browbase->nc_event;
    }
    break;
  case evlist_eEventType_Info:
    nc = evlist->browbase->nc_info;
    break;
  default:
    nc = evlist->browbase->nc_event;
    break;
  }

  brow_CreateNode( evlist->browbase->ctx, item_name, nc,
		   dest, dest_code, (void *) this, 1, &node);

//  brow_SetAnnotPixmap( node, 0, evlist->browbase->pixmap_leaf);
  update_text(0);

  if ( evlist->size > evlist->max_size)
  {
    // Delete last
    brow_tObject last_node;
    int sts;
    ItemAlarm *item;

    sts = brow_GetLast( evlist->browbase->ctx, &last_node);
    if ( ODD(sts))
    {
      if ( node == last_node)
	// I'm deleting myself
	*rsts = 0;

      brow_GetUserData( last_node, (void **)&item);

      brow_DeleteNode( evlist->browbase->ctx, last_node);
      if ( item->type == evlist_eItemType_Alarm && evlist->browtree) {
	if ( item->tree_node)
	  brow_DeleteNode( evlist->browtree->ctx, item->tree_node);
	evlist->view_configure();
      }
      
      // Note! This ItemAlarm might be deleted by now if node == last_node
      item_evlist->size--;
    }
  }
}

void ItemAlarm::update_text( int use_treenode)
{
  char type_str[8];
  char info_str[8];
  char time_str[40];
  brow_tObject n;

  if ( use_treenode)
    n = tree_node;
  else
    n = node;
  
  strcpy( info_str, "");
  if ( evlist->type == ev_eType_AlarmList)
  {
    if ( status & mh_mEventStatus_NotAck) 
      brow_SetAnnotPixmap( n, 0, evlist->browbase->pixmap_ack);
    else
      brow_RemoveAnnotPixmap( n, 0);
    if ( status & mh_mEventStatus_NotRet) 
      brow_SetAnnotPixmap( n, 1, evlist->browbase->pixmap_alarm);
    else
      brow_RemoveAnnotPixmap( n, 1);
  }
  else
  {
    switch ( event_type)
    {
      case evlist_eEventType_Return:
        brow_SetAnnotPixmap( n, 0, evlist->browbase->pixmap_eventreturn);
        break;
      case evlist_eEventType_Ack:
        brow_SetAnnotPixmap( n, 0, evlist->browbase->pixmap_eventacked);
        break;
      case evlist_eEventType_Info:
      case evlist_eEventType_Alarm:
        brow_SetAnnotPixmap( n, 0, evlist->browbase->pixmap_eventalarm);
        break;
      case evlist_eEventType_Block:
        break;
      default:
        ;
    }
  }

  switch ( event_type)
  {
    case evlist_eEventType_Info:
      strcpy( type_str, "I");
      brow_SetAnnotation( n, 1, type_str, strlen(type_str));
      break;
    case evlist_eEventType_Block:
    case evlist_eEventType_Alarm:
      switch ( eventprio) {
      case mh_eEventPrio_A:
	strcpy( type_str, "A");
	break;
      case mh_eEventPrio_B:
	strcpy( type_str, "B");
	break;
      case mh_eEventPrio_C:
	strcpy( type_str, "C");
	break;
      case mh_eEventPrio_D:
	strcpy( type_str, "D");
	break;
      default:
	strcpy( type_str, "Unkw");
      }
      brow_SetAnnotation( n, 0, type_str, strlen(type_str));
      break;
    default:
      ;
  }

  time_AtoAscii( &time, time_eFormat_ComprDateAndTime, time_str, 
	sizeof(time_str));
  if ( !evlist->display_hundredth)
    time_str[17] = 0;
  brow_SetAnnotation( n, 1, time_str, strlen(time_str));

  switch ( event_type)
  {
    case evlist_eEventType_Info:
    case evlist_eEventType_Alarm:
    case evlist_eEventType_Return:
    case evlist_eEventType_Block:
      if ( ! evlist->hide_text) {
        brow_SetAnnotation( n, 2, alias, strlen(alias));
        brow_SetAnnotation( n, 3, eventtext, strlen(eventtext));
      }
      else {
        brow_SetAnnotation( n, 2, "", 0);
        brow_SetAnnotation( n, 3, "", 0);
      }
      break;
    default:
      brow_SetAnnotation( n, 2, "", 0);
      brow_SetAnnotation( n, 3, "", 0);
  }

  if ( !evlist->hide_object && evlist->hide_text)
  {
    brow_SetAnnotation( n, 2, eventname, strlen(eventname));
    brow_SetAnnotation( n, 3, "", 0);
    brow_SetAnnotation( n, 4, "", 0);
  }
  else if ( !evlist->hide_object)
    brow_SetAnnotation( n, 4, eventname, strlen(eventname));
  else
    brow_SetAnnotation( n, 4, "", 0);

  if ( strcmp( eventmoretext, "") != 0)
    brow_SetAnnotPixmap( n, 2, evlist->browbase->pixmap_info);

  switch ( eventtype) {
  case mh_eEvent_SystemAlarm:
    brow_SetAnnotPixmap( n, 3, evlist->browbase->pixmap_system);
    break;
  case mh_eEvent_MaintenanceAlarm:
    brow_SetAnnotPixmap( n, 3, evlist->browbase->pixmap_maintenance);
    break;
  default: ;
  }
}

ItemCategory::ItemCategory( EvList *item_evlist, const char *item_name, pwr_sClass_AlarmCategory *cop,
			    brow_tNode dest, flow_eDest dest_code, int *rsts) :
  evlist(item_evlist), prio(0), base_nc(0), notacked_child(0)
{
  pwr_tStatus sts;

  type = evlist_eItemType_Category;

  *rsts = 1;
  strcpy( name, item_name);
  strcpy( text, cop->Text);
  select_priority = cop->EventPriority;
  select_eventtype = cop->EventType;

  member_cnt = 0;
  for ( unsigned int i = 0; i < sizeof(cop->Members)/sizeof(cop->Members[0]); i++) {
    if ( cdh_ObjidIsNull( cop->Members[i].Objid))
      break;
    sts = gdh_AttrrefToName( &cop->Members[i], members[i], sizeof(members[0]),
			     cdh_mName_pathStrict);
    member_cnt++;
  }

  brow_CreateNode( evlist->brow->ctx, name, evlist->brow->nc_category,
		   dest, dest_code, (void *) this, 1, &node);

  brow_SetAnnotation( node, 1, text, strlen(text));
  brow_SetAnnotPixmap( node, 0, evlist->brow->pixmap_map);
}

void ItemCategory::configure( EvList *evlist)
{
  ItemAlarm *item;
  pwr_tStatus sts;
  unsigned int child_prio = 0;
  brow_tObject next;

  if ( brow_IsOpen( node) & evlist_mOpen_Children) {
    // Check children
    for ( sts = brow_GetChild( evlist->brow->ctx, node, &next);
	  ODD(sts);
	  sts = brow_GetNextSibling( evlist->brow->ctx, next, &next)) {
      brow_GetUserData( next, (void **)&item);
      if ( item->event_type == evlist_eEventType_Info) {
	if ( 1 > child_prio)
	  child_prio = 1;
      }	
      else if ( item->eventprio > child_prio)
	child_prio = item->eventprio;
    }
  }
  else {
    // Check potential children
    brow_tObject *object_list;
    int		object_cnt;

    brow_GetObjectList( evlist->browbase->ctx, &object_list, &object_cnt);
    for ( int i = 0; i < object_cnt; i++) {
      brow_GetUserData( object_list[i], (void **)&item);
      switch( item->type) {
      case evlist_eItemType_Alarm: {
	for ( int j = 0; j < member_cnt; j++) {
	  if ( item->eventtype != mh_eEvent_Info &&  select_priority != 0 && !(select_priority & prio_enum_to_mask( item->eventprio)))
	    continue;
	  if ( select_eventtype != 0 && !(select_eventtype & item->eventtype))
	    continue;

	  if ( strncmp( members[j], item->eventname, strlen(members[j])) == 0) {
	    // Presupmtive child
	    if ( item->event_type == evlist_eEventType_Info) {
	      if ( 1 > child_prio)
		child_prio = 1;
	    }	
	    else if ( item->eventprio > child_prio)
	      child_prio = item->eventprio;	    

	  }
	}
        break;
      }
      default:
        ;
      }
    }
  }

  if ( prio != child_prio) {
    prio = child_prio;
    switch ( prio) {
    case 1: 
      base_nc = evlist->brow->nc_category_i;
      break;
    case mh_eEventPrio_A:
      base_nc = evlist->brow->nc_category_a;
      break;
    case mh_eEventPrio_B:
      base_nc = evlist->brow->nc_category_b;
      break;
    case mh_eEventPrio_C:
      base_nc = evlist->brow->nc_category_c;
      break;
    case mh_eEventPrio_D:
      base_nc = evlist->brow->nc_category_d;
      break;
    default:
      base_nc = evlist->brow->nc_category;
    }
    
    brow_ChangeObjectNodeClass( node, base_nc);
  }
  if ( base_nc == 0)
    base_nc = evlist->brow->nc_category;
    
  if ( prio == 0) {
    brow_SetAnnotPixmap( node, 0, evlist->brow->pixmap_leaf);
    if ( brow_IsOpen( node) & evlist_mOpen_Children)
      brow_ResetOpen( node, evlist_mOpen_All);
  }
  else if ( brow_IsOpen( node) & evlist_mOpen_Children)
    brow_SetAnnotPixmap( node, 0, evlist->brow->pixmap_openmap);
  else
    brow_SetAnnotPixmap( node, 0, evlist->brow->pixmap_map);
}

void ItemCategory::alarm( EvList *evlist, ItemAlarm *item)
{
  brow_tNodeClass nc;

  if ( !(brow_IsOpen( node) & evlist_mOpen_Children))
    return;
  
  if ( item->tree_node)
    return;

  switch( item->type) {
  case evlist_eItemType_Alarm: {
    for ( int j = 0; j < member_cnt; j++) {
      if ( strncmp( members[j], item->eventname, strlen(members[j])) == 0) {
	// Insert item
	switch ( item->event_type) { 
	case evlist_eEventType_Alarm:
	case evlist_eEventType_Block:
	  switch ( item->eventprio) {
	  case mh_eEventPrio_A:
	    nc = evlist->brow->nc_a_alarm;
	    break;
	  case mh_eEventPrio_B:
	    nc = evlist->brow->nc_b_alarm;
	    break;
	  default:
	    nc = evlist->brow->nc_event;
	  }
	  break;
	case evlist_eEventType_Info:
	  nc = evlist->brow->nc_info;
	  break;
	default:
	  nc = evlist->brow->nc_event;
	  break;
	}
	
	brow_CreateNode( evlist->brow->ctx, name, nc,
			 node, flow_eDest_IntoFirst, item, 1, &item->tree_node);
	item->update_text( 1);
	brow_SetAnnotPixmap( node, 0, evlist->brow->pixmap_openmap);
      }
    }
    break;
  }
  default:
    ;
  }
}

void ItemCategory::close( EvList *evlist, double x, double y)
{
  double	node_x, node_y;

  brow_GetNodePosition( node, &node_x, &node_y);

  if ( brow_IsOpen( node)) {
    // Close
    brow_SetNodraw( evlist->brow->ctx);
    brow_CloseNode( evlist->brow->ctx, node);
    if ( brow_IsOpen( node) & evlist_mOpen_Children) {
	brow_SetAnnotPixmap( node, 0, evlist->brow->pixmap_map);
    }
    brow_ResetOpen( node, evlist_mOpen_All);
    brow_ResetNodraw( evlist->brow->ctx);
    brow_Redraw( evlist->brow->ctx, node_y);
  }
}

int ItemCategory::open_children( EvList *evlist, double x, double y)
{
  double	node_x, node_y;

  brow_GetNodePosition( node, &node_x, &node_y);

  if ( brow_IsOpen( node)) {
    // Close
    brow_SetNodraw( evlist->brow->ctx);
    brow_CloseNode( evlist->brow->ctx, node);
    if ( brow_IsOpen( node) & evlist_mOpen_Children) {
	brow_SetAnnotPixmap( node, 0, evlist->brow->pixmap_map);
    }
    brow_ResetOpen( node, evlist_mOpen_All);
    brow_ResetNodraw( evlist->brow->ctx);
    brow_Redraw( evlist->brow->ctx, node_y);
  }
  else {
    ItemAlarm 	*item;
    brow_tObject *object_list;
    int		object_cnt;
    int 	child_exist;
    brow_tNodeClass 	nc;

    // Create some children
    brow_SetNodraw( evlist->brow->ctx);

    child_exist = 0;
    brow_GetObjectList( evlist->browbase->ctx, &object_list, &object_cnt);
    for ( int i = 0; i < object_cnt; i++) {
      brow_GetUserData( object_list[i], (void **)&item);
      switch( item->type) {
      case evlist_eItemType_Alarm: {
	if ( item->tree_node)
	  continue;
	if ( item->eventtype != mh_eEvent_Info &&  select_priority != 0 && !(select_priority & prio_enum_to_mask( item->eventprio)))
	  continue;
	if ( select_eventtype != 0 && !(select_eventtype & item->eventtype))
	  continue;
	    
	for ( int j = 0; j < member_cnt; j++) {
	  if ( strncmp( members[j], item->eventname, strlen(members[j])) == 0) {
	    // Insert item
	    switch ( item->event_type) { 
	    case evlist_eEventType_Alarm:
	    case evlist_eEventType_Block:
	      switch ( item->eventprio) {
	      case mh_eEventPrio_A:
		nc = evlist->brow->nc_a_alarm;
		break;
	      case mh_eEventPrio_B:
		nc = evlist->brow->nc_b_alarm;
		break;
	      default:
		nc = evlist->brow->nc_event;
	      }
	      break;
	    case evlist_eEventType_Info:
	      nc = evlist->brow->nc_info;
	      break;
	    default:
	      nc = evlist->brow->nc_event;
	      break;
	    }

	    brow_CreateNode( evlist->brow->ctx, name, nc,
			     node, flow_eDest_IntoLast, item, 1, &item->tree_node);
	    item->update_text( 1);
	    child_exist = 1;
	  }
	}
        break;
      }
      default:
        ;
      }
    }


    if ( child_exist) {
      brow_SetOpen( node, evlist_mOpen_Children);
      brow_SetAnnotPixmap( node, 0, evlist->brow->pixmap_openmap);
    }
    brow_ResetNodraw( evlist->brow->ctx);
    if ( child_exist)
      brow_Redraw( evlist->brow->ctx, node_y);
  }
  return 1;
}

void ItemCategory::flash( EvList *evlist)
{
  ItemAlarm *item;
  pwr_tStatus sts;
  brow_tNode next;
  int notacked = 0;

  notacked = false;
  if ( brow_IsOpen( node) & evlist_mOpen_Children) {
    // Check children
    for ( sts = brow_GetChild( evlist->brow->ctx, node, &next);
	  ODD(sts);
	  sts = brow_GetNextSibling( evlist->brow->ctx, next, &next)) {
      brow_GetUserData( next, (void **)&item);

      if ( item->status & mh_mEventStatus_NotAck) {
	notacked++;
      }
    }
  }
  else {
    // Check potential children
    brow_tObject *object_list;
    int		object_cnt;

    brow_GetObjectList( evlist->browbase->ctx, &object_list, &object_cnt);
    for ( int i = 0; i < object_cnt; i++) {
      brow_GetUserData( object_list[i], (void **)&item);
      switch( item->type) {
      case evlist_eItemType_Alarm: {
	if ( select_priority != 0 && !(select_priority & prio_enum_to_mask( item->eventprio)))
	  continue;
	if ( select_eventtype != 0 && !(select_eventtype & item->eventtype))
	  continue;
	for ( int j = 0; j < member_cnt; j++) {
	  if ( strncmp( members[j], item->eventname, strlen(members[j])) == 0) {
	    // Presupmtive child
	    if ( item->status & mh_mEventStatus_NotAck) {
	      notacked++;
	    }
	  }
	}
        break;
      }
      default:
        ;
      }
    }
  }

  if ( notacked != notacked_child) {
    if ( !notacked)
      brow_SetAnnotation( node, 0, "", 0);
    else {
      char notacked_str[20];
      sprintf(notacked_str, "%d", notacked);

      brow_SetAnnotation( node, 0, notacked_str, strlen(notacked_str));
    }
  }

  if ( notacked && !notacked_child)
    brow_SetAnnotPixmap( node, 1, evlist->browbase->pixmap_ack);
  else if ( !notacked && notacked_child) {
    brow_ChangeObjectNodeClass( node, base_nc);
    brow_RemoveAnnotPixmap( node, 1);
  }
  notacked_child = notacked;

  if ( notacked_child) {
    if ( evlist->flash_value)
      brow_ChangeObjectNodeClass( node, base_nc);
    else
      brow_ChangeObjectNodeClass( node, evlist->brow->nc_category_flash);
  }
}

int EvList::get_last_not_acked( mh_sEventId **id)
{
  int		i;
  brow_tObject 	*object_list;
  int		object_cnt;
  ItemAlarm	*object_item;

  brow_GetObjectList( browbase->ctx, &object_list, &object_cnt);
  for ( i = 0; i < object_cnt; i++)
  {
    brow_GetUserData( object_list[i], (void **)&object_item);
    switch( object_item->type)
    {
      case evlist_eItemType_Alarm:
        if ( object_item->status & mh_mEventStatus_NotAck) 
        {
          *id = &object_item->eventid;
          return 1;
        }
        break;
      default:
        ;
    }
  }
  return 0;
}

int EvList::get_last_not_acked_beep( mh_sEventId **id)
{
  int		i;
  brow_tObject 	*object_list;
  int		object_cnt;
  ItemAlarm	*object_item;
  int		found = 0;
  unsigned int 	prio = 0;

  // Get first not acked event with highest priority
  brow_GetObjectList( browbase->ctx, &object_list, &object_cnt);
  for ( i = 0; i < object_cnt; i++) {

    brow_GetUserData( object_list[i], (void **)&object_item);
    switch( object_item->type) {

      case evlist_eItemType_Alarm:
        if ( object_item->status & mh_mEventStatus_NotAck &&
	     object_item->eventflags & mh_mEventFlags_Bell)  {
	  switch ( object_item->event_type) {
          case evlist_eEventType_Alarm:
	    if ( object_item->eventprio > prio) {
	      *id = &object_item->eventid;
	      prio = object_item->eventprio;
	      found = 1;
	      if ( prio == mh_eEventPrio_A)
		return 1;
	    }
	    break;
          case evlist_eEventType_Info:
	    *id = &object_item->eventid;
	    prio = 1;
	    found = 1;
	    break;
	  default: ;
	  }
        }
        break;
      default: ;
    }
  }
  return found;
}

int EvList::get_last_not_acked_prio( mh_sEventId **id, unsigned long type, 
	unsigned long prio)
{
  int		i;
  brow_tObject 	*object_list;
  int		object_cnt;
  ItemAlarm	*object_item;

  brow_GetObjectList( browbase->ctx, &object_list, &object_cnt);
  for ( i = 0; i < object_cnt; i++)
  {
    brow_GetUserData( object_list[i], (void **)&object_item);
    switch( object_item->type)
    {
      case evlist_eItemType_Alarm:
        switch( object_item->event_type)
        {
          case evlist_eEventType_Alarm:
            if ( object_item->status & mh_mEventStatus_NotAck &&
	         object_item->event_type == (evlist_eEventType) type &&
	         object_item->eventprio == prio)
            {
              *id = &object_item->eventid;
              return 1;
            }
            break;
          case evlist_eEventType_Info:
            if ( object_item->status & mh_mEventStatus_NotAck &&
	         object_item->event_type == (evlist_eEventType) type)
            {
              *id = &object_item->eventid;
              return 1;
            }
            break;
          default:
            ;
        }
        break;
      default:
        ;
    }
  }
  return 0;
}

int EvList::get_alarm_info( evlist_sAlarmInfo *info)
{
  int		i;
  brow_tObject 	*object_list;
  int		object_cnt;
  ItemAlarm	*object_item;
  int		a_cnt = 0;
  int		b_cnt = 0;
  int		c_cnt = 0;
  int		d_cnt = 0;
  int		i_cnt = 0;

  memset( info, 0, sizeof(*info));

  brow_GetObjectList( browbase->ctx, &object_list, &object_cnt);
  for ( i = 0; i < object_cnt; i++)
  {
    brow_GetUserData( object_list[i], (void **)&object_item);
    switch( object_item->type)
    {
      case evlist_eItemType_Alarm:
        switch( object_item->event_type)
        {
          case evlist_eEventType_Alarm:
            if ( object_item->status & mh_mEventStatus_NotRet)
              info->alarms_total++;

            if ( object_item->status & mh_mEventStatus_NotAck) 
            {
	      // Compose the alarmtext from eventtext and eventname
	      char eventtext[600];

	      strcpy( eventtext, object_item->eventtext);
	      if ( eventname_seg &&
		   !( strcmp( object_item->eventname, "") == 0 || 
		      strstr( object_item->eventname, "-W-") != 0)) {
		strcat( eventtext, ", ");
		cdh_CutNameSegments( &eventtext[strlen(eventtext)], object_item->eventname,
				     eventname_seg);
	      }

              info->alarms_notacked++;
              switch( object_item->eventprio)
              {
                case mh_eEventPrio_A:
                  if ( a_cnt >= ALARM_INFO_A_SIZE)
                    break;
                  strncpy( info->a_alarm_text[a_cnt], eventtext, 
			   sizeof(info->a_alarm_text[0]));
                  strncpy( info->a_alarm_moretext[a_cnt], object_item->eventmoretext, 
			   sizeof(info->a_alarm_moretext[0]));
		  info->a_alarm_text[a_cnt][sizeof(info->a_alarm_text[0])-1] = 0;
                  strncpy( info->a_alarm_alias[a_cnt], object_item->alias, 
			  sizeof(info->a_alarm_alias[0]));
                  info->a_alarm_time[a_cnt] = object_item->time;
                  info->a_alarm_active[a_cnt] = object_item->status & mh_mEventStatus_NotRet;
                  info->a_alarm_exist[a_cnt] = 1;
                  a_cnt++;
                  break;
                case mh_eEventPrio_B:
                  if ( b_cnt >= ALARM_INFO_B_SIZE)
                    break;
                  strncpy( info->b_alarm_text[b_cnt], eventtext,
			   sizeof(info->b_alarm_text[0]));
                  strncpy( info->b_alarm_moretext[b_cnt], object_item->eventmoretext, 
			   sizeof(info->b_alarm_moretext[0]));
		  info->b_alarm_text[b_cnt][sizeof(info->b_alarm_text[0])-1] = 0;
                  strncpy( info->b_alarm_alias[b_cnt], object_item->alias,
			   sizeof(info->b_alarm_alias[0]));
                  info->b_alarm_time[b_cnt] = object_item->time;
                  info->b_alarm_active[b_cnt] = object_item->status & mh_mEventStatus_NotRet;
                  info->b_alarm_exist[b_cnt] = 1;
                  b_cnt++;
                  break;
                case mh_eEventPrio_C:
                  if ( c_cnt >= ALARM_INFO_C_SIZE)
                    break;
                  strncpy( info->c_alarm_text[c_cnt], eventtext,
			   sizeof(info->c_alarm_text[0]));
                  strncpy( info->c_alarm_moretext[c_cnt], object_item->eventmoretext, 
			   sizeof(info->c_alarm_moretext[0]));
		  info->c_alarm_text[c_cnt][sizeof(info->c_alarm_text[0])-1] = 0;
                  strncpy( info->c_alarm_alias[c_cnt], object_item->alias,
			   sizeof(info->c_alarm_alias[0]));
                  info->c_alarm_time[c_cnt] = object_item->time;
                  info->c_alarm_active[c_cnt] = object_item->status & mh_mEventStatus_NotRet;
                  info->c_alarm_exist[c_cnt] = 1;
                  c_cnt++;
                  break;
                case mh_eEventPrio_D:
                  if ( d_cnt >= ALARM_INFO_D_SIZE)
                    break;
                  strncpy( info->d_alarm_text[d_cnt], eventtext,
			   sizeof(info->d_alarm_text[0]));
                  strncpy( info->d_alarm_moretext[d_cnt], object_item->eventmoretext, 
			   sizeof(info->d_alarm_moretext[0]));
		  info->d_alarm_text[d_cnt][sizeof(info->d_alarm_text[0])-1] = 0;
                  strncpy( info->d_alarm_alias[d_cnt], object_item->alias,
			   sizeof(info->d_alarm_alias[0]));
                  info->d_alarm_time[d_cnt] = object_item->time;
                  info->d_alarm_active[d_cnt] = object_item->status & mh_mEventStatus_NotRet;
                  info->d_alarm_exist[d_cnt] = 1;
                  d_cnt++;
                  break;
                default:
                  ;
              }
            }
            break;
          case evlist_eEventType_Info:
            if ( object_item->eventflags & mh_mEventFlags_InfoWindow && 
                 object_item->status & mh_mEventStatus_NotAck) 
            {
              if ( i_cnt >= ALARM_INFO_I_SIZE)
                break;
              strncpy( info->i_alarm_text[i_cnt], object_item->eventtext,
		       sizeof(info->i_alarm_text[0]));
	      strncpy( info->i_alarm_moretext[i_cnt], object_item->eventmoretext, 
		       sizeof(info->i_alarm_moretext[0]));
              strncpy( info->i_alarm_alias[i_cnt], object_item->alias,
		       sizeof(info->i_alarm_alias[0]));
	      info->i_alarm_time[i_cnt] = object_item->time;
              info->i_alarm_active[i_cnt] = object_item->status & mh_mEventStatus_NotRet;
              info->i_alarm_exist[i_cnt] = 1;
              i_cnt++;
            }
            break;
          default:
            ;
        }
        break;
      default:
        ;
    }
  }
  return 1;
}

void EvList::set_display_hundredth( int value)
{
  if ( type == ev_eType_BlockList)
    return;

  display_hundredth = value;
  update_text();
}

void EvList::set_hide_object( int value)
{
  if ( type == ev_eType_BlockList)
    return;

  hide_object = value;
  update_text();
}

void EvList::set_hide_text( int value)
{
  if ( type == ev_eType_BlockList)
    return;

  hide_text = value;
  update_text();
}

void EvList::update_text()
{
  int		i;
  brow_tObject 	*object_list;
  int		object_cnt;
  ItemAlarm	*object_item;

  brow_SetNodraw( browbase->ctx);
  brow_GetObjectList( browbase->ctx, &object_list, &object_cnt);
  for ( i = 0; i < object_cnt; i++)
  {
    brow_GetUserData( object_list[i], (void **)&object_item);
    switch( object_item->type)
      {
      case evlist_eItemType_Alarm:
        object_item->update_text(0);
        break;
      default:
        ;
    }
  }
  brow_ResetNodraw( browbase->ctx);
  brow_Redraw( browbase->ctx, 0);
}

int EvList::id_to_item( mh_sEventId *id, void **item)
{
  int		i;
  brow_tObject 	*object_list;
  int		object_cnt;
  ItemAlarm	*object_item;

  brow_GetObjectList( browbase->ctx, &object_list, &object_cnt);

  for ( i = 0; i < object_cnt; i++) {
    brow_GetUserData( object_list[i], (void **)&object_item);
    switch( object_item->type) {
    case evlist_eItemType_Alarm:
      if ( memcmp( &object_item->eventid, id, sizeof(object_item->eventid))
	   == 0) {
	*item = (void *)object_item;
	return 1;
      }
      break;
    default:
      ;
    }
  }
  return 0;
}

int EvList::oid_to_item( pwr_tOid oid, void **item)
{
  int		i;
  brow_tObject 	*object_list;
  int		object_cnt;
  ItemAlarm	*object_item;

  brow_GetObjectList( browbase->ctx, &object_list, &object_cnt);

  for ( i = 0; i < object_cnt; i++) {
    brow_GetUserData( object_list[i], (void **)&object_item);
    switch( object_item->type) {
    case evlist_eItemType_Alarm:
      if ( cdh_ObjidIsEqual( object_item->object.Objid, oid)) {
	*item = (void *)object_item;
	return 1;
      }
      break;
    default:
      ;
    }
  }
  return 0;
}

void EvList::ack( mh_sEventId *id)
{
  ItemAlarm 	*item;

  if ( !id_to_item( id, (void **)&item))
    return;

  if ( item->status & mh_mEventStatus_NotAck) 
    item->status &= ~mh_mEventStatus_NotAck;

  if ( item->status & mh_mEventStatus_NotRet) 
    // Remove the not ack marks in the item text
    item->update_text(0);
  else if ( type == ev_eType_AlarmList)
  {
    // Detete the item from the alarm list
    brow_DeleteNode( browbase->ctx, item->node);
    if ( browtree) {
      if ( item->tree_node)
	brow_DeleteNode( browtree->ctx, item->tree_node);
      view_configure();
    }
    size--;
  }
}

int EvList::get_selected_event( char *eventname, ItemAlarm **item)
{
  brow_tNode	*node_list;
  int		node_count;

  if ( !browbase)
    return 0;

  brow_GetSelectedNodes( brow->ctx, &node_list, &node_count);
  if ( !node_count)
    return 0;

  brow_GetUserData( node_list[0], (void **)item);
  free( node_list);
  switch( (*item)->type)
  {
    case evlist_eItemType_Alarm:
      strcpy( eventname, (*item)->eventname);
      break;
    default:
      return 0;
  }
  return 1;
}

int EvList::get_destination( pwr_tTime time, void **dest)
{
  int		i;
  brow_tObject 	*object_list;
  int		object_cnt;
  ItemAlarm	*object_item;

  brow_GetObjectList( browbase->ctx, &object_list, &object_cnt);
  for ( i = 0; i < object_cnt; i++)
  {
    brow_GetUserData( object_list[i], (void **)&object_item);
    switch( object_item->type)
    {
      case evlist_eItemType_Alarm:
        if ( time_Acomp( &time, &object_item->time) >= 0)
        {
          *dest = (void *) object_item;
          return 1;
        }
        break;
      default:
        ;
    }
  }
  return 0;
}

int EvList::get_select( void *ctx, pwr_tAttrRef *attrref, int *is_attr)
{
  EvList *ev = (EvList *)ctx;
  pwr_tStatus sts;
  ItemAlarm *item;
  pwr_tAName eventname;

  if ( !ev->browbase)
    return 0;

  sts = ev->get_selected_event( eventname, &item);
  if ( EVEN(sts)) return sts;

  *attrref = item->object;
  *is_attr = item->object.Flags.b.Object ? 1 : 0;

  return sts;
}

int EvList::get_select_supobject( void *ctx, pwr_tAttrRef *attrref, int *is_attr)
{
  EvList *ev = (EvList *)ctx;
  pwr_tStatus sts;
  ItemAlarm *item;
  pwr_tAName eventname;

  if ( !ev->browbase)
    return 0;

  sts = ev->get_selected_event( eventname, &item);
  if ( EVEN(sts)) return sts;

  *attrref = item->supobject;
  *is_attr = item->supobject.Flags.b.Object ? 1 : 0;

  return sts;
}

pwr_tStatus EvList::set_view( pwr_tOid view)
{
  if ( cdh_ObjidIsNull( view)) {
    if ( browtree == 0)
      return 0;

    brow_ChangeCtx( brow->ctx, browbase->ctx);
    brow = browbase;
    delete browtree;
    browtree = 0;

    current_view = pwr_cNObjid;
  }
  else {
    BrowCtx *secondary_ctx;
    EvListBrow		*prev_browtree = browtree;

    brow_CreateSecondaryCtx( browbase->ctx, &secondary_ctx,
			     init_browtree_cb, (void *)this, flow_eCtxType_Brow);

    brow_ChangeCtx( brow->ctx, browtree->ctx);
    brow = browtree;

    if ( prev_browtree)
      delete prev_browtree;

    view_init( view);
  }
  return 1;
}

pwr_tStatus EvList::view_init( pwr_tOid view)
{
  pwr_tStatus sts;
  pwr_tOid child;

  for ( sts = gdh_GetChild( view, &child);
	ODD(sts);
	sts = gdh_GetNextSibling( child, &child)) {

    pwr_tAttrRef aref = cdh_ObjidToAref( child);
    pwr_sClass_AlarmCategory body;

    sts = gdh_GetObjectInfoAttrref( &aref, &body, sizeof(body));
    if ( EVEN(sts)) return sts;

    new ItemCategory( this, "Category", &body, 0, flow_eDest_IntoLast, &sts);
    if ( EVEN(sts)) return sts;

  }
  current_view = view;
  view_configure();
  return 1;
}

// New alarm received, check if it should be inserted
void EvList::view_alarm( ItemAlarm *alarm_item)
{
  if ( !browtree)
    return;

  pwr_tStatus sts;
  brow_tObject node;
  ItemCategory *item;

  for ( sts = brow_GetFirst( brow->ctx, &node);
	ODD(sts);
	sts = brow_GetNextSibling( brow->ctx, node, &node)) {
    brow_GetUserData( node, (void **)&item);
    if ( item->type == evlist_eItemType_Category)
      item->alarm( this, alarm_item);
  }  
}

void EvList::view_configure()
{
  if ( !browtree)
    return;

  pwr_tStatus sts;
  brow_tObject node;
  ItemCategory *item;

  for ( sts = brow_GetFirst( brow->ctx, &node);
	ODD(sts);
	sts = brow_GetNextSibling( brow->ctx, node, &node)) {
    brow_GetUserData( node, (void **)&item);
    if ( item->type == evlist_eItemType_Category)
      item->configure( this);
  }
}

void EvList::flash()
{
  int		i;
  brow_tObject 	*object_list;
  int		object_cnt;
  ItemCategory	*item;

  flash_value = !flash_value;

  brow_GetObjectList( brow->ctx, &object_list, &object_cnt);
  for ( i = 0; i < object_cnt; i++) {
    brow_GetUserData( object_list[i], (void **)&item);
    switch( item->type) {
      case evlist_eItemType_Category:
	item->flash( this);
        break;
      default:
        ;
    }
  }
}

void EvList::copy_list( EvList* evl) 
{
  int		i;
  brow_tObject 	*object_list;
  int		object_cnt;
  ItemAlarm	*item;
  pwr_tStatus 	sts;

  brow_GetObjectList( browbase->ctx, &object_list, &object_cnt);
  for ( i = 0; i < object_cnt; i++) {
    brow_GetUserData( object_list[i], (void **)&item);
    switch( item->type) {
      case evlist_eItemType_Alarm:
	new ItemAlarm( evl, item->name,
		       item->time, item->eventtext, item->eventname, item->eventtype, item->eventflags,
		       item->eventprio, item->eventid, &item->object, &item->eventsound, 
		       item->eventmoretext, item->status, item->event_type, 
		       &item->supobject, 0, flow_eDest_IntoLast, &sts);
        break;
      default:
        ;
    }
  }
}

int EvList::get_alarm_tables( pwr_tOid user) 
{
  pwr_tOid ch;
  pwr_tStatus sts;
  pwr_tCid cid;
  pwr_tAttrRef aref;

  // Find alarm tables
  alarm_table_cnt = 0;
  for ( pwr_tStatus lsts = gdh_GetChild( user, &ch); 
	ODD(lsts); 
	lsts = gdh_GetNextSibling( ch, &ch)) {
    sts = gdh_GetObjectClass( ch, &cid);
    if ( EVEN(sts)) return sts;
    
    switch ( cid) {
    case pwr_cClass_AlarmTable: {
      pwr_sClass_AlarmTable *op;
      int idx = alarm_table_cnt;

      if ( alarm_table_cnt > ALARM_TABLE_SIZE)
	break;

      aref = cdh_ObjidToAref( ch);
      sts = gdh_DLRefObjectInfoAttrref( &aref, (void **)&op, 
				      &alarm_tables_refid[idx]);
      if ( EVEN(sts)) return sts;

      alarm_tables[idx] = op;

      alarm_table_member_cnt[idx] = 0;
      int mix = 0;
      for ( unsigned int i = 0; i < sizeof(op->Members)/sizeof(op->Members[0]); i++) {
	if ( cdh_ObjidIsNull( op->Members[i].Objid))
	  break;
	if ( mix == 0) {
	  alarm_table_members[idx] = (ev_sAlarmTableMembers *)calloc( 1, sizeof(ev_sAlarmTableMembers));
	}
	sts = gdh_AttrrefToName( &op->Members[i], (char *)(*alarm_table_members[idx])[mix], 
				 sizeof(pwr_tAName), cdh_mName_pathStrict);
	mix++;
      }
      alarm_table_member_cnt[idx] = mix;
      alarm_table_cnt++;

      break;
    }
    default: ;
    }
  }
  return 1;
}

void EvList::fill_alarm_tables()
{
  if ( !alarm_table_cnt) return;

  int		i;
  brow_tObject 	*object_list;
  int 		object_cnt;
  ItemAlarm	*item;
  pwr_sClass_AlarmTable at;
  int		idx;
  int		eventtype;

  brow_GetObjectList( browbase->ctx, &object_list, &object_cnt);
  for ( unsigned int j = 0; j < alarm_table_cnt; j++) {
    memset( &at, 0, sizeof(at));

    idx = 0;
    for ( i = 0; i < object_cnt; i++) {
      if ( idx > int(sizeof(at.ActiveArray)/sizeof(at.ActiveArray[0])))
	break;

      brow_GetUserData( object_list[i], (void **)&item);
      switch( item->type) {
      case evlist_eItemType_Alarm: {
	if (  alarm_tables[j]->Options & pwr_mAlarmTableOptionsMask_UnackedOnly &&
	      !(item->status & mh_mEventStatus_NotAck))
	  break;

	// Check membership
	int skip = 0;
	if ( alarm_table_member_cnt[j] > 0) {
	  skip = 1;
	  for ( int i = 0; i < alarm_table_member_cnt[j]; i++) {
	    if ( strncmp( (char *)(*alarm_table_members[j])[i], item->eventname, 
			  strlen((char *)(*alarm_table_members[j])[i])) == 0) {
	      skip = 0;
	      break;
	    }
	  }
	}
	if ( skip)
	  break;

	// Check event type and priority
	skip = 0;
	switch ( item->event_type) {
	case evlist_eEventType_Info:
	  if ( alarm_tables[j]->EventType & pwr_mEventTypeMask_Info)
	    eventtype = pwr_eEventTypeEnum_Info;
	  else
	    skip = 1;
	  break;
	case evlist_eEventType_Alarm:
	  if ( alarm_tables[j]->EventType & item->eventtype) {
	    eventtype = item->eventtype;
	    if (  !(alarm_tables[j]->EventPriority & item->eventprio))
	      skip = 1;
	  }
	  else
	    skip = 1;
	  break;
	default:
	  skip = 1;
	}
	if ( skip)
	  break;

	// Insert alarm
	at.NotAckedArray[idx] = item->status & mh_mEventStatus_NotAck ? 1 : 0;
	at.ActiveArray[idx] = item->status & mh_mEventStatus_NotRet ? 1 : 0;
	at.TimeArray[idx] = item->time;
	at.EventTypeArray[idx] = eventtype;
	at.EventPrioArray[idx] = item->eventprio;
	strcpy(at.EventTextArray[idx], item->eventtext);
	strcpy(at.EventNameArray[idx], item->eventname);
	strcpy(at.AliasArray[idx], item->alias);
	at.ObjectArray[idx] = item->object;

	if ( at.NotAckedArray[idx]) 
	  at.NoOfUnackedAlarms++;
	idx++;

        break;
      }
      default:
        ;
      }
    }
    at.NoOfAlarms = idx;
    memcpy( &alarm_tables[j]->NoOfAlarms, &at.NoOfAlarms, 
	    sizeof(at) - offsetof(pwr_sClass_AlarmTable, NoOfAlarms));
  }
}

static unsigned int prio_enum_to_mask( unsigned int prio) 
{
  switch ( prio) {
  case mh_eEventPrio_A:
    return pwr_mEventPrioMask_A;
  case mh_eEventPrio_B:
    return pwr_mEventPrioMask_B;
  case mh_eEventPrio_C:
    return pwr_mEventPrioMask_C;
  case mh_eEventPrio_D:
    return pwr_mEventPrioMask_D;
  }
  return 0;
}
