/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2014 SSAB AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

#include "glow_std.h"

#include <stdio.h>
#include <stdlib.h>

#include "glow.h"
#include "xtt_xnav.h"
#include "rt_gdh.h"
#include "rt_gdh_msg.h"
#include "co_cdh.h"
#include "co_dcli.h"
#include "co_time.h"
#include "glow_growctx.h"
#include "glow_growapi.h"
#include "co_lng.h"
#include "xtt_ge.h"
#include "xtt_trend.cpp"
#include "xtt_multiview.h"
#include "xtt_log.h"

void MVRecall::insert( char *str, char *obj)
{
  if ( current_idx == -1) {
    current_idx = 0;
    first_idx = 0;
    last_idx = 0;
  }
  else {
    current_idx++;
    if ( current_idx >= MV_RECALL_SIZE)
      current_idx = 0;
    last_idx = current_idx;
    if ( current_idx == first_idx) {
      first_idx++;
      if ( first_idx >= MV_RECALL_SIZE)
	last_idx = 0;
    }     
  }
  strncpy( buff[current_idx], str, sizeof(buff[0]));
  if ( obj)
    strncpy( object[current_idx], obj, sizeof(object[0]));    
  else
    strcpy( object[current_idx], "");
}

int MVRecall::get_previous()
{
  if ( current_idx == first_idx)
    return -1;
  current_idx--;
  if ( current_idx < 0)
    current_idx = MV_RECALL_SIZE - 1;
  return current_idx;
}

int MVRecall::get_next()
{
  if ( current_idx == last_idx)
    return -1;
  current_idx++;
  if ( current_idx >= MV_RECALL_SIZE)
    current_idx = 0;
  return current_idx;
}

void XttMultiView::eventlog_enable( int enable) 
{ 
  // Graph::eventlog_enable( enable);
}


void XttMultiView::multiview_ge_close_cb( void *parent_ctx, void *client_data)
{
}

int XttMultiView::multiview_ge_command_cb( void *multiview_ctx, char *cmd, void *caller)
{
  XttMultiView *multiview = (XttMultiView *) multiview_ctx;
  int		sts;

  if ( multiview->command_cb) {
    sts = (multiview->command_cb)( multiview->parent_ctx, cmd, multiview_ctx);
    return sts;
  }
  return 0;
}

int XttMultiView::multiview_ge_sound_cb( void *multiview_ctx, pwr_tAttrRef *aref)
{
  XttMultiView	*multiview = (XttMultiView *)multiview_ctx;

  if ( multiview->sound_cb)
    return (multiview->sound_cb)( multiview->parent_ctx, aref);

  return 0;
}

void XttMultiView::multiview_ge_display_in_xnav_cb( void *multiview_ctx, pwr_sAttrRef *arp)
{
  XttMultiView	*multiview = (XttMultiView *)multiview_ctx;

  if ( multiview->display_in_xnav_cb)
    (multiview->display_in_xnav_cb)( multiview->parent_ctx, arp);
}

void XttMultiView::multiview_ge_popup_menu_cb( void *multiview_ctx, pwr_sAttrRef attrref,
			   unsigned long item_type, unsigned long utility, 
			   char *arg, int x, int y)
{
  XttMultiView	*multiview = (XttMultiView *)multiview_ctx;

  if ( multiview->popup_menu_cb)
    (multiview->popup_menu_cb)( multiview->parent_ctx, attrref, item_type, utility, 
			    arg, x, y);
}

int XttMultiView::multiview_ge_call_method_cb( void *multiview_ctx, const char *method, const char *filter,
			   pwr_sAttrRef attrref, unsigned long item_type, 
			   unsigned long utility, char *arg)
{
  XttMultiView	*multiview = (XttMultiView *)multiview_ctx;

  if ( multiview->call_method_cb)
    return (multiview->call_method_cb)( multiview->parent_ctx, method, filter, attrref, item_type, utility, 
			    arg);
  else return 0;
}

int XttMultiView::multiview_ge_is_authorized_cb( void *multiview_ctx, unsigned int access)
{
  XttMultiView	*multiview = (XttMultiView *)multiview_ctx;

  if ( multiview->is_authorized_cb)
    return (multiview->is_authorized_cb)( multiview->parent_ctx, access);
  return 0;
}

int XttMultiView::multiview_ge_get_current_objects_cb( void *multiview_ctx, pwr_sAttrRef **alist,
				   int **is_alist)
{
  XttMultiView	*multiview = (XttMultiView *)multiview_ctx;

  if ( multiview->get_current_objects_cb)
    return (multiview->get_current_objects_cb)( multiview->parent_ctx, alist, is_alist);
  return 0;
}

void XttMultiView::multiview_ge_eventlog_cb( void *multiview_ctx, void *gectx, int category,
					     void *data, unsigned int size)
{
  XttMultiView	*multiview = (XttMultiView *)multiview_ctx;

  if ( multiview->eventlog_cb)
    (multiview->eventlog_cb)( multiview->parent_ctx, gectx, category, data, size);
}

void XttMultiView::multiview_ge_help_cb( void *multiview_ctx, const char *key)
{
  XttMultiView	*multiview = (XttMultiView *)multiview_ctx;

  if ( multiview->help_cb)
    (multiview->help_cb)( multiview->parent_ctx, key);
}

void XttMultiView::multiview_trend_close_cb( void *ctx, XttTrend *trend)
{
}

void XttMultiView::multiview_trend_command_cb( void *ctx, const char *cmd)
{
  XttMultiView *multiview = (XttMultiView *) ctx;
  int		sts;

  if ( multiview->command_cb) {
    sts = (multiview->command_cb)( multiview->parent_ctx, (char *)cmd, ctx);
    return;
  }
}

void XttMultiView::multiview_trend_help_cb( void *ctx, const char *key)
{
  XttMultiView	*multiview = (XttMultiView *)ctx;

  if ( multiview->help_cb)
    (multiview->help_cb)( multiview->parent_ctx, key);
}

int XttMultiView::multiview_sevhist_get_select_cb( void *ctx, pwr_tOid *oid, char *aname, char *oname)
{
  XttMultiView	*multiview = (XttMultiView *)ctx;

  if ( multiview->get_select_cb)
    return (multiview->get_select_cb)( multiview->parent_ctx, oid, aname, oname);
  return 0;
}

void XttMultiView::message_cb( void *ctx, char severity, const char *msg)
{
  ((XttMultiView *)ctx)->message( severity, msg);
}

void XttMultiView::message( char severity, const char *msg)
{
  if ( strcmp( msg, "") != 0)
    printf("** XttMultiView: %s\n", msg);
}


int XttMultiView::set_object_focus( const char *name, int empty)
{
  return 1; // graph->set_object_focus( name, empty);
}

int XttMultiView::set_folder_index( const char *name, int idx)
{
  return 1; // graph->set_folder_index( name, idx);
}

XttMultiView::~XttMultiView()
{
}


void XttMultiView::swap( int mode)
{
}

int XttMultiView::find_graph( const char *name, const char *instance, void **ctx)
{
  return appl.find_graph( name, instance, ctx);
}

int XttMultiView::name_to_idx( const char *name) 
{
  pwr_sClass_XttMultiView mv;
  pwr_tStatus sts;
   
  sts = gdh_GetObjectInfoAttrref( &aref, &mv, sizeof(mv));
  if ( EVEN(sts)) return sts;
  
  for ( int i = 0; i < cols; i++) {
    for ( int j = 0; j < rows; j++) {
      if ( cdh_NoCaseStrcmp( name, mv.Action[i*rows+j].Name) == 0)
	return i*rows+j;
    }
  }
  return -1;
}


int XttMultiView::set_subwindow_next( const char *name) {
  int i = name_to_idx( name);
  if ( i < 0)
    return 0;

  int next = recall_buffer[i].get_next();
  if ( next < 0)
    return 0;

  char *op = 0;
  if ( strcmp(recall_buffer[i].object[next], "") != 0)
    op = recall_buffer[i].object[next];
  return set_subwindow_source( name, (char *)recall_buffer[i].buff[next], op, 0);
}

int XttMultiView::set_subwindow_prev( const char *name) {
  int i = name_to_idx( name);
  if ( i < 0)
    return 0;

  int prev = recall_buffer[i].get_previous();
  if ( prev < 0)
    return 0;

  char *op = 0;
  if ( strcmp(recall_buffer[i].object[prev], "") != 0)
    op = recall_buffer[i].object[prev];
  return set_subwindow_source( name, (char *)recall_buffer[i].buff[prev], op, 0);
}

XNav *XttMultiView::get_xnav()
{
  if ( options & ge_mOptions_Embedded)
    return ((XttMultiView *)parent_ctx)->get_xnav();
  else
    return (XNav *)parent_ctx;
}

XttMultiView::XttMultiView( void *mv_parent_ctx, const char *mv_name,
			    pwr_tAttrRef *mv_aref, int mv_width, int mv_height,
			    int mv_x, int mv_y, unsigned int mv_options,
			    int (*mv_command_cb) (void *, char *, void *),
			    int (*mv_get_current_objects_cb) (void *, pwr_sAttrRef **, int **),
			    int (*mv_is_authorized_cb) (void *, unsigned int)) :
  parent_ctx(mv_parent_ctx), options(mv_options),
  command_cb(mv_command_cb), close_cb(0), help_cb(0), display_in_xnav_cb(0), 
  is_authorized_cb(mv_is_authorized_cb), popup_menu_cb(0), call_method_cb(0), 
  get_current_objects_cb(mv_get_current_objects_cb), sound_cb(0), eventlog_cb(0),
  get_select_cb(0),
  width(mv_width), height(mv_height)
{
  strcpy( name, mv_name);
  aref = *mv_aref;
}

