/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include "co_cdh.h"
#include "co_string.h"

#include "rt_gdh_msg.h"

#include "xtt_ge.h"
#include "xtt_log.h"
#include "xtt_trend.h"
#include "xtt_xnav.h"

void MVRecall::insert(char* str, char* obj)
{
  if (current_idx == -1) {
    current_idx = 0;
    first_idx = 0;
    last_idx = 0;
  } else {
    current_idx++;
    if (current_idx >= MV_RECALL_SIZE)
      current_idx = 0;
    last_idx = current_idx;
    if (current_idx == first_idx) {
      first_idx++;
      if (first_idx >= MV_RECALL_SIZE)
        last_idx = 0;
    }
  }
  strncpy(buff[current_idx], str, sizeof(buff[0]));
  if (obj)
    strncpy(object[current_idx], obj, sizeof(object[0]));
  else
    strcpy(object[current_idx], "");
}

int MVRecall::get_previous()
{
  if (current_idx == first_idx)
    return -1;
  current_idx--;
  if (current_idx < 0)
    current_idx = MV_RECALL_SIZE - 1;
  return current_idx;
}

int MVRecall::get_next()
{
  if (current_idx == last_idx)
    return -1;
  current_idx++;
  if (current_idx >= MV_RECALL_SIZE)
    current_idx = 0;
  return current_idx;
}

void XttMultiView::eventlog_enable(int enable)
{
  // Graph::eventlog_enable( enable);
}

void XttMultiView::multiview_ge_close_cb(void* parent_ctx, void* client_data)
{
}

int XttMultiView::multiview_ge_command_cb(
    void* multiview_ctx, char* cmd, char* script, void* caller)
{
  XttMultiView* multiview = (XttMultiView*)multiview_ctx;
  int sts;

  if (multiview->command_cb) {
    sts = (multiview->command_cb)(
        multiview->parent_ctx, cmd, script, multiview_ctx);
    return sts;
  }
  return 0;
}

int XttMultiView::multiview_ge_sound_cb(void* multiview_ctx, pwr_tAttrRef* aref)
{
  XttMultiView* multiview = (XttMultiView*)multiview_ctx;

  if (multiview->sound_cb)
    return (multiview->sound_cb)(multiview->parent_ctx, aref);

  return 0;
}

void XttMultiView::multiview_ge_display_in_xnav_cb(
    void* multiview_ctx, pwr_sAttrRef* arp)
{
  XttMultiView* multiview = (XttMultiView*)multiview_ctx;

  if (multiview->display_in_xnav_cb)
    (multiview->display_in_xnav_cb)(multiview->parent_ctx, arp);
}

void XttMultiView::multiview_ge_popup_menu_cb(void* multiview_ctx,
    pwr_sAttrRef attrref, unsigned long item_type, unsigned long utility,
    char* arg, int x, int y)
{
  XttMultiView* multiview = (XttMultiView*)multiview_ctx;

  if (multiview->popup_menu_cb)
    (multiview->popup_menu_cb)(
        multiview->parent_ctx, attrref, item_type, utility, arg, x, y);
}

int XttMultiView::multiview_ge_call_method_cb(void* multiview_ctx,
    const char* method, const char* filter, pwr_sAttrRef attrref,
    unsigned long item_type, unsigned long utility, char* arg)
{
  XttMultiView* multiview = (XttMultiView*)multiview_ctx;

  if (multiview->call_method_cb)
    return (multiview->call_method_cb)(multiview->parent_ctx, method, filter,
        attrref, item_type, utility, arg);
  else
    return 0;
}

int XttMultiView::multiview_ge_is_authorized_cb(
    void* multiview_ctx, unsigned int access)
{
  XttMultiView* multiview = (XttMultiView*)multiview_ctx;

  if (multiview->is_authorized_cb)
    return (multiview->is_authorized_cb)(multiview->parent_ctx, access);
  return 0;
}

int XttMultiView::multiview_ge_get_current_objects_cb(
    void* multiview_ctx, pwr_sAttrRef** alist, int** is_alist)
{
  XttMultiView* multiview = (XttMultiView*)multiview_ctx;

  if (multiview->get_current_objects_cb)
    return (multiview->get_current_objects_cb)(
        multiview->parent_ctx, alist, is_alist);
  return 0;
}

void XttMultiView::multiview_ge_eventlog_cb(void* multiview_ctx, void* gectx,
    int category, void* data, unsigned int size)
{
  XttMultiView* multiview = (XttMultiView*)multiview_ctx;

  if (multiview->eventlog_cb)
    (multiview->eventlog_cb)(
        multiview->parent_ctx, gectx, category, data, size);
}

void XttMultiView::multiview_keyboard_cb(
    void* multiview_ctx, void* ge_ctx, int action, int type)
{
  XttMultiView* multiview = (XttMultiView*)multiview_ctx;

  if (multiview->keyboard_cb)
    (multiview->keyboard_cb)(multiview->parent_ctx, multiview, action, type);
}

void XttMultiView::multiview_ge_help_cb(void* multiview_ctx, const char* key)
{
  XttMultiView* multiview = (XttMultiView*)multiview_ctx;

  if (multiview->help_cb)
    (multiview->help_cb)(multiview->parent_ctx, key);
}

void XttMultiView::multiview_trend_close_cb(void* ctx, XttTrend* trend)
{
}

void XttMultiView::multiview_trend_command_cb(void* ctx, const char* cmd)
{
  XttMultiView* multiview = (XttMultiView*)ctx;
  int sts;

  if (multiview->command_cb) {
    sts = (multiview->command_cb)(multiview->parent_ctx, (char*)cmd, 0, ctx);
    return;
  }
}

void XttMultiView::multiview_trend_help_cb(void* ctx, const char* key)
{
  XttMultiView* multiview = (XttMultiView*)ctx;

  if (multiview->help_cb)
    (multiview->help_cb)(multiview->parent_ctx, key);
}

int XttMultiView::multiview_sevhist_get_select_cb(
    void* ctx, pwr_tOid* oid, char* aname, char* oname)
{
  XttMultiView* multiview = (XttMultiView*)ctx;

  if (multiview->get_select_cb)
    return (multiview->get_select_cb)(multiview->parent_ctx, oid, aname, oname);
  return 0;
}

void XttMultiView::multiview_strm_close_cb(void* ctx, XttStream* strm)
{
}

void XttMultiView::message_cb(void* ctx, char severity, const char* msg)
{
  ((XttMultiView*)ctx)->message(severity, msg);
}

void XttMultiView::message(char severity, const char* msg)
{
  if (!streq(msg, ""))
    printf("** XttMultiView: %s\n", msg);
}

int XttMultiView::set_object_focus(const char* name, int empty)
{
  return 1; // graph->set_object_focus( name, empty);
}

int XttMultiView::set_folder_index(const char* name, int idx)
{
  return 1; // graph->set_folder_index( name, idx);
}

XttMultiView::~XttMultiView()
{
}

void XttMultiView::swap(int mode)
{
}

int XttMultiView::find_graph(const char* name, const char* instance, void** ctx)
{
  return appl.find_graph(name, instance, ctx);
}

int XttMultiView::name_to_idx(const char* name)
{
  pwr_sClass_XttMultiView mv;
  pwr_tStatus sts;

  sts = gdh_GetObjectInfoAttrref(&aref, &mv, sizeof(mv));
  if (EVEN(sts))
    return sts;

  for (int i = 0; i < cols; i++) {
    for (int j = 0; j < rows; j++) {
      if (str_NoCaseStrcmp(name, mv.Action[i * rows + j].Name) == 0)
        return i * rows + j;
    }
  }
  return -1;
}

int XttMultiView::set_subwindow_next(const char* name)
{
  int i = name_to_idx(name);
  if (i < 0)
    return 0;

  int next = recall_buffer[i].get_next();
  if (next < 0)
    return 0;

  char* op = 0;
  if (!streq(recall_buffer[i].object[next], ""))
    op = recall_buffer[i].object[next];
  return set_subwindow_source(name, (char*)recall_buffer[i].buff[next], op, 0);
}

int XttMultiView::set_subwindow_prev(const char* name)
{
  int i = name_to_idx(name);
  if (i < 0)
    return 0;

  int prev = recall_buffer[i].get_previous();
  if (prev < 0)
    return 0;

  char* op = 0;
  if (!streq(recall_buffer[i].object[prev], ""))
    op = recall_buffer[i].object[prev];
  return set_subwindow_source(name, (char*)recall_buffer[i].buff[prev], op, 0);
}

XNav* XttMultiView::get_xnav()
{
  if (options & ge_mOptions_Embedded)
    return ((XttMultiView*)parent_ctx)->get_xnav();
  else
    return (XNav*)parent_ctx;
}

XttMultiView::XttMultiView(void* mv_parent_ctx, const char* mv_name,
    pwr_tAttrRef* mv_aref, int mv_width, int mv_height, int mv_x, int mv_y,
    unsigned int mv_options, int mv_color_theme,
    int (*mv_command_cb)(void*, char*, char*, void*),
    int (*mv_get_current_objects_cb)(void*, pwr_sAttrRef**, int**),
    int (*mv_is_authorized_cb)(void*, unsigned int),
    void (*mv_keyboard_cb)(void*, void*, int, int))
    : parent_ctx(mv_parent_ctx), options(mv_options),
      color_theme(mv_color_theme), command_cb(mv_command_cb), close_cb(0),
      help_cb(0), display_in_xnav_cb(0), is_authorized_cb(mv_is_authorized_cb),
      popup_menu_cb(0), call_method_cb(0),
      get_current_objects_cb(mv_get_current_objects_cb), sound_cb(0),
      eventlog_cb(0), get_select_cb(0), keyboard_cb(mv_keyboard_cb),
      width(mv_width), height(mv_height)
{
  strcpy(name, mv_name);
  aref = *mv_aref;
}
