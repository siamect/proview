/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include "co_cdh.h"
#include "co_dcli.h"
#include "co_string.h"

#include "rt_gdh_msg.h"
#include "rt_xnav_msg.h"

#include "cow_wow.h"

#include "glow_curveapi.h"

#include "xtt_xnav.h"
#include "xtt_fast.h"

XttFast::XttFast(void* parent_ctx, char* name, pwr_sAttrRef* fast_arp,
    int xn_color_theme, int* sts)
    : xnav(parent_ctx), fast_cnt(0), gcd(0), curve(0), timerid(0), close_cb(0),
      help_cb(0), first_scan(1), axis_configured(false),
      color_theme(xn_color_theme)
{
  pwr_sAttrRef aref = pwr_cNAttrRef;
  pwr_tAName fast_name;
  pwr_tAName attr_name;
  pwr_sClass_DsFastCurve fp;
  int i, j;

  *sts = XNAV__SUCCESS;

  // Get current status of the fast objects
  i = 0;
  aref = *fast_arp;
  if (cdh_ObjidIsNull(aref.Objid)) {
    *sts = XNAV__FASTCONFIG;
    return;
  }

  *sts = gdh_AttrrefToName(&aref, fast_name, sizeof(fast_name), cdh_mNName);
  if (EVEN(*sts))
    return;

  *sts = gdh_GetObjectInfo(fast_name, &fp, sizeof(fp));
  if (EVEN(*sts))
    return;

  max_points = fp.NoOfPoints;
  fast_function = fp.Function;

  strcpy(attr_name, fast_name);
  strcat(attr_name, ".TriggTime");
  gdh_NameToAttrref(pwr_cNObjid, attr_name, &trigg_time_attr);

  if (fast_function & fast_mFunction_BeforeTrigg) {
    strcpy(attr_name, fast_name);
    strcat(attr_name, ".TriggIndex");
    gdh_NameToAttrref(pwr_cNObjid, attr_name, &trigg_index_attr);

    strcpy(attr_name, fast_name);
    strcat(attr_name, ".FirstIndex");
    gdh_NameToAttrref(pwr_cNObjid, attr_name, &first_index_attr);

    strcpy(attr_name, fast_name);
    strcat(attr_name, ".LastIndex");
    gdh_NameToAttrref(pwr_cNObjid, attr_name, &last_index_attr);
  }

  // Create data for time axis
  gcd = new GeCurveData(curve_eDataType_DsTrend);
  gcd->x_data[0] = (double*)malloc(8 * max_points);
  strcpy(gcd->x_name, "Time");
  gcd->x_axis_type[0] = curve_eAxis_x;
  memcpy(&time_buff, &fp.TimeBuffer, sizeof(time_buff));

  fast_cnt = 0;
  for (i = 0; i < FAST_CURVES; i++) {
    if (fp.CurveValid[i]) {
      gcd->y_data[fast_cnt] = (double*)calloc(1, 8 * max_points);
      gcd->y_axis_type[fast_cnt] = curve_eAxis_y;
      memcpy(&buff[fast_cnt], &fp.Buffers[i], sizeof(buff[0]));
      type[fast_cnt] = (pwr_eType)fp.AttributeType[i];
      fast_idx[i] = fast_cnt;
      curve_idx[fast_cnt] = i;

      *sts = gdh_AttrrefToName(
          &fp.Attribute[i], attr_name, sizeof(attr_name), cdh_mNName);
      if (EVEN(*sts))
        continue;
      strcpy(gcd->y_name[fast_cnt], attr_name);
      fast_cnt++;
    }
  }

  if (!fast_cnt) {
    *sts = XNAV__NOVALIDCURVE;
    free(gcd);
    gcd = 0;
    return;
  }

  // Subscribe to object
  strcpy(attr_name, fast_name);
  strcat(attr_name, ".New");
  *sts = gdh_RefObjectInfo(
      attr_name, (pwr_tAddress*)&new_p, &new_subid, sizeof(pwr_tBoolean));
  if (EVEN(*sts))
    return;

  for (i = 0; i < fast_cnt; i++) {
    switch (type[i]) {
    case pwr_eType_Float32:
    case pwr_eType_Int32:
    case pwr_eType_UInt32:
    case pwr_eType_Boolean:
      element_size[i] = 4;
      break;
    case pwr_eType_Float64:
    case pwr_eType_Int64:
    case pwr_eType_UInt64:
      element_size[i] = 8;
      break;
    case pwr_eType_Int16:
    case pwr_eType_UInt16:
      element_size[i] = 2;
      break;
    case pwr_eType_Int8:
    case pwr_eType_UInt8:
      element_size[i] = 1;
      break;
    default:
      element_size[i] = 4;
    }
    gcd->rows[i] = max_points;
    gcd->y_orig_type[i] = type[i];
  }
  gcd->cols = fast_cnt;

  axis_configured = true;
  for (i = 0; i < FAST_CURVES; i++) {
    if (fp.CurveValid[i]) {
      j = fast_idx[i];
      if (!feqf(fp.YMinValue[i], fp.YMaxValue[i]))
        gcd->scale(gcd->y_axis_type[j], gcd->y_value_type[j], fp.YMinValue[i],
            fp.YMaxValue[i], &gcd->y_min_value_axis[j],
            &gcd->y_max_value_axis[j], &gcd->y_trend_lines[j],
            &gcd->y_axis_lines[j], &gcd->y_axis_linelongq[j],
            &gcd->y_axis_valueq[j], gcd->y_format[j], &gcd->y_axis_width[j], 1,
            1);
      else
        axis_configured = false;
    }
  }

  if (fp.Active)
    first_scan = 0;
  fast_scan(this);
  gcd->select_color(0);

  if (!streq(fp.Title, ""))
    strcpy(title, fp.Title);
  else
    str_StrncpyCutOff(title, name, sizeof(title), 1);

  // timerid = XtAppAddTimeOut(
  //	XtWidgetToApplicationContext(parent_widget), 1000,
  //	(XtTimerCallbackProc)fast_scan, this);
}

XttFast::XttFast(void* parent_ctx, const char* name, char* filename,
    int xn_color_theme, int* sts)
    : xnav(parent_ctx), fast_cnt(0), timerid(0), close_cb(0), help_cb(0),
      first_scan(1), axis_configured(false), color_theme(xn_color_theme)

{
  *sts = read_export(filename);
}

XttFast::~XttFast()
{
}

void XttFast::pop()
{
  curve->pop();
}

void XttFast::setup()
{
  curve->setup(
      curve_mEnable_Export | curve_mEnable_CurveType | curve_mEnable_FillCurve);
}

void XttFast::fast_close_cb(void* ctx)
{
  XttFast* fast = (XttFast*)ctx;

  if (fast->close_cb)
    (fast->close_cb)(fast->xnav, fast);
  else
    delete fast;
}

void XttFast::fast_help_cb(void* ctx)
{
  XttFast* fast = (XttFast*)ctx;

  if (fast->help_cb)
    (fast->help_cb)(fast->xnav, "opg_fastcurves");
}

void XttFast::fast_scan(void* data)
{
  XttFast* fast = (XttFast*)data;
  int i, j, k;
  pwr_tStatus sts;
  int trigg_index, first_index = 0, last_index = 0;

  // Check if any new value
  if ((*fast->new_p && !fast->old_new) || fast->first_scan) {
    // Update curves
    if (fast->fast_function & fast_mFunction_BeforeTrigg) {
      // Get first, last and trigg index
      sts = gdh_GetObjectInfoAttrref(
          &fast->trigg_index_attr, &trigg_index, sizeof(trigg_index));
      if (EVEN(sts))
        return;
      sts = gdh_GetObjectInfoAttrref(
          &fast->first_index_attr, &first_index, sizeof(first_index));
      if (EVEN(sts))
        return;
      sts = gdh_GetObjectInfoAttrref(
          &fast->last_index_attr, &last_index, sizeof(last_index));
      if (EVEN(sts))
        return;

      // Read into temporary buffer
      pwr_tFloat32* tmp = (pwr_tFloat32*)calloc(fast->max_points, 4);
      sts = gdh_GetObjectInfoAttrref(
          &fast->time_buff, tmp, fast->max_points * 4);
      if (EVEN(sts))
        return;

      k = first_index;
      for (j = 0; j < fast->max_points; j++) {
        if (k >= fast->max_points)
          k = 0;
        fast->gcd->x_data[0][j] = tmp[k] - tmp[trigg_index];
        if (k == last_index)
          break;
        k++;
      }
      // If to few points, fill with dummy data
      for (; j < fast->max_points; j++) {
        fast->gcd->x_data[0][j] = tmp[k] - tmp[trigg_index];
      }
      free(tmp);
    } else {
      pwr_tFloat32* tmp = (pwr_tFloat32*)calloc(fast->max_points, 4);
      sts = gdh_GetObjectInfoAttrref(
          &fast->time_buff, tmp, fast->max_points * 4);
      if (EVEN(sts))
        return;

      for (j = 0; j < fast->max_points; j++)
        fast->gcd->x_data[0][j] = tmp[j];
      free(tmp);
    }
    for (i = 0; i < fast->fast_cnt; i++) {
      if (fast->fast_function & fast_mFunction_BeforeTrigg) {
        // Read into temporary buffer
        void* tmp = calloc(fast->max_points, fast->element_size[i]);
        sts = gdh_GetObjectInfoAttrref(
            &fast->buff[i], tmp, fast->max_points * fast->element_size[i]);
        if (EVEN(sts))
          return;

        k = first_index;
        for (j = 0; j < fast->max_points; j++) {
          if (k >= fast->max_points)
            k = 0;
          switch (fast->type[i]) {
          case pwr_eType_Float32:
            fast->gcd->y_data[i][j] = ((pwr_tFloat32*)tmp)[k];
            break;
          case pwr_eType_Float64:
            fast->gcd->y_data[i][j] = ((pwr_tFloat64*)tmp)[k];
            break;
          case pwr_eType_Int64:
            fast->gcd->y_data[i][j] = ((pwr_tInt64*)tmp)[k];
            break;
          case pwr_eType_UInt64:
            fast->gcd->y_data[i][j] = ((pwr_tUInt64*)tmp)[k];
            break;
          case pwr_eType_Int32:
            fast->gcd->y_data[i][j] = ((pwr_tInt32*)tmp)[k];
            break;
          case pwr_eType_UInt32:
            fast->gcd->y_data[i][j] = ((pwr_tUInt32*)tmp)[k];
            break;
          case pwr_eType_Int16:
            fast->gcd->y_data[i][j] = ((pwr_tUInt16*)tmp)[k];
            break;
          case pwr_eType_UInt16:
            fast->gcd->y_data[i][j] = ((pwr_tUInt16*)tmp)[k];
            break;
          case pwr_eType_Int8:
            fast->gcd->y_data[i][j] = ((pwr_tInt8*)tmp)[k];
            break;
          case pwr_eType_UInt8:
            fast->gcd->y_data[i][j] = ((pwr_tUInt8*)tmp)[k];
            break;
          case pwr_eType_Boolean:
            fast->gcd->y_data[i][j] = ((pwr_tBoolean*)tmp)[k];
            break;
          default:;
          }
          if (k == last_index)
            break;
          k++;
        }
        // If to few points, fill with 0
        for (; j < fast->max_points; j++) {
          switch (fast->type[i]) {
          case pwr_eType_Float32:
            fast->gcd->y_data[i][j] = ((pwr_tFloat32*)tmp)[k];
            break;
          case pwr_eType_Float64:
            fast->gcd->y_data[i][j] = ((pwr_tFloat64*)tmp)[k];
            break;
          case pwr_eType_Int64:
            fast->gcd->y_data[i][j] = ((pwr_tInt64*)tmp)[k];
            break;
          case pwr_eType_UInt64:
            fast->gcd->y_data[i][j] = ((pwr_tUInt64*)tmp)[k];
            break;
          case pwr_eType_Int32:
            fast->gcd->y_data[i][j] = ((pwr_tInt32*)tmp)[k];
            break;
          case pwr_eType_UInt32:
            fast->gcd->y_data[i][j] = ((pwr_tUInt32*)tmp)[k];
            break;
          case pwr_eType_Int16:
            fast->gcd->y_data[i][j] = ((pwr_tInt16*)tmp)[k];
            break;
          case pwr_eType_UInt16:
            fast->gcd->y_data[i][j] = ((pwr_tInt16*)tmp)[k];
            break;
          case pwr_eType_Int8:
            fast->gcd->y_data[i][j] = ((pwr_tInt8*)tmp)[k];
            break;
          case pwr_eType_UInt8:
            fast->gcd->y_data[i][j] = ((pwr_tUInt8*)tmp)[k];
            break;
          case pwr_eType_Boolean:
            fast->gcd->y_data[i][j] = ((pwr_tBoolean*)tmp)[k];
            break;
          default:;
          }
        }
        free(tmp);
      } else {
        void* tmp = calloc(fast->max_points, fast->element_size[i]);
        sts = gdh_GetObjectInfoAttrref(
            &fast->buff[i], tmp, fast->max_points * fast->element_size[i]);
        if (EVEN(sts))
          return;

        for (j = 0; j < fast->max_points; j++) {
          switch (fast->type[i]) {
          case pwr_eType_Float32:
            fast->gcd->y_data[i][j] = ((pwr_tFloat32*)tmp)[j];
            break;
          case pwr_eType_Float64:
            fast->gcd->y_data[i][j] = ((pwr_tFloat64*)tmp)[j];
            break;
          case pwr_eType_Int64:
            fast->gcd->y_data[i][j] = ((pwr_tInt64*)tmp)[j];
            break;
          case pwr_eType_UInt64:
            fast->gcd->y_data[i][j] = ((pwr_tUInt64*)tmp)[j];
            break;
          case pwr_eType_Int32:
            fast->gcd->y_data[i][j] = ((pwr_tInt32*)tmp)[j];
            break;
          case pwr_eType_UInt32:
            fast->gcd->y_data[i][j] = ((pwr_tUInt32*)tmp)[j];
            break;
          case pwr_eType_Int16:
            fast->gcd->y_data[i][j] = ((pwr_tInt16*)tmp)[j];
            break;
          case pwr_eType_UInt16:
            fast->gcd->y_data[i][j] = ((pwr_tInt16*)tmp)[j];
            break;
          case pwr_eType_Int8:
            fast->gcd->y_data[i][j] = ((pwr_tInt8*)tmp)[j];
            break;
          case pwr_eType_UInt8:
            fast->gcd->y_data[i][j] = ((pwr_tUInt8*)tmp)[j];
            break;
          case pwr_eType_Boolean:
            fast->gcd->y_data[i][j] = ((pwr_tBoolean*)tmp)[j];
            break;
          default:;
          }
        }
        free(tmp);
      }
    }

    // Get trigg time
    pwr_tTime trigg_time;
    sts = gdh_GetObjectInfoAttrref(
        &fast->trigg_time_attr, &trigg_time, sizeof(trigg_time));
    if (EVEN(sts))
      return;

    if (!fast->axis_configured) {
      fast->gcd->get_borders();
      fast->gcd->get_default_axis();
      if (!fast->first_scan) {
        fast->curve->configure_curves();
        fast->curve->configure_axes();
        fast->curve->set_time(trigg_time);
      }
    } else {
      double axis_width;

      fast->gcd->get_borders();
      // fast->gcd->get_default_axis();
      fast->gcd->scale(fast->gcd->x_axis_type[0], fast->gcd->x_value_type[0],
          fast->gcd->x_min_value[0], fast->gcd->x_max_value[0],
          &fast->gcd->x_min_value_axis[0], &fast->gcd->x_max_value_axis[0],
          &fast->gcd->x_trend_lines[0], &fast->gcd->x_axis_lines[0],
          &fast->gcd->x_axis_linelongq[0], &fast->gcd->x_axis_valueq[0],
          fast->gcd->x_format[0], &axis_width, 1, 1);
      if (!fast->first_scan) {
        fast->curve->configure_curves();
        // fast->curve->configure_axes();
        fast->curve->set_time(trigg_time);
      }
    }
    fast->first_scan = 0;
  }
  fast->old_new = *fast->new_p;

  if (fast->timerid)
    fast->timerid->add(1000, fast_scan, fast);
}

int XttFast::fast_export_cb(void* ctx, pwr_tTime* from, pwr_tTime* to, int rows,
    int idx, char* filename)
{
  XttFast* fast = (XttFast*)ctx;
  pwr_tFileName fname;
  pwr_tStatus sts;
  FILE* fp;

  // Replace $date with date
  strncpy(fname, filename, sizeof(fname));
  char* s1 = strstr(fname, "$date");
  if (s1) {
    char timstr[40];
    pwr_tFileName str;

    sts = time_AtoAscii(
        0, time_eFormat_FileDateAndTime, timstr, sizeof(timstr));

    strncpy(str, s1 + strlen("$date"), sizeof(str));
    *s1 = 0;
    strncat(fname, timstr, sizeof(fname) - strlen(fname) - 1);
    strncat(fname, str, sizeof(fname) - strlen(fname) - 1);
  }

  dcli_translate_filename(fname, fname);

  if (idx == -1) {
    // Export all attributes
    fp = fopen(fname, "w");
    if (!fp)
      return XNAV__NOFILE;

    fprintf(fp, "# Columns %d\n", fast->fast_cnt);
    fprintf(fp, "# Rows %d\n", fast->max_points);
    for (int i = 0; i < fast->fast_cnt; i++)
      fprintf(fp, "# Attribute %s\n", fast->gcd->y_name[i]);

    for (int j = 0; j < fast->max_points; j++) {
      fprintf(fp, "%f ", fast->gcd->x_data[0][j]);
      for (int i = 0; i < fast->fast_cnt; i++) {
        fprintf(fp, "%f ", fast->gcd->y_data[i][j]);
      }
      fprintf(fp, "\n");
    }
    fclose(fp);
  } else {
    fp = fopen(fname, "w");
    if (!fp)
      return XNAV__NOFILE;

    fprintf(fp, "# Columns %d\n", 1);
    fprintf(fp, "# Rows %d\n", fast->max_points);
    fprintf(fp, "# Attribute %s\n", fast->gcd->y_name[idx]);

    for (int j = 0; j < fast->max_points; j++) {
      fprintf(fp, "%f ", fast->gcd->x_data[0][j]);
      fprintf(fp, "%f ", fast->gcd->y_data[idx][j]);
      fprintf(fp, "\n");
    }
    fclose(fp);
  }

  return XNAV__SUCCESS;
}

int XttFast::read_export(char* filename)
{
  pwr_tFileName fname;
  FILE* fp;
  char line[200];
  int idx = -1;
  int rowcnt = 0;
  pwr_tStatus sts;
  char line_part[40][20];

  dcli_translate_filename(fname, filename);

  fp = fopen(fname, "r");
  if (!fp)
    return 0;

  gcd = new GeCurveData(curve_eDataType_DsTrend);

  while (1) {
    sts = dcli_read_line(line, sizeof(line), fp);
    if (!sts)
      break;

    if (line[0] == '#') {
      if (str_StartsWith(&line[2], "Attribute")) {
        // New attribute
        idx++;
        strncpy(gcd->y_name[idx], &line[12], sizeof(gcd->y_name[idx]));
        gcd->y_data[idx] = (double*)calloc(1, 8 * max_points);
        gcd->y_axis_type[idx] = curve_eAxis_y;
      } else if (str_StartsWith(&line[2], "Rows")) {
        sscanf(&line[7], "%d", &max_points);
        gcd->rows[0] = max_points;
        gcd->x_data[0] = (double*)calloc(1, 8 * max_points);
      } else if (str_StartsWith(&line[2], "Columns")) {
        sscanf(&line[10], "%d", &fast_cnt);
      }
    } else {
      if (idx < 0 || fast_cnt != idx + 1)
        continue;

      if (rowcnt >= max_points)
        continue;

      int nr = dcli_parse(line, " 	", "", (char*)line_part,
          sizeof(line_part) / sizeof(line_part[0]), sizeof(line_part[0]), 0);
      if (nr < fast_cnt + 1)
        return 0;

      sscanf(line_part[0], "%lf", &gcd->x_data[0][rowcnt]);
      for (int i = 0; i < fast_cnt; i++)
        sscanf(line_part[i + 1], "%lf", &gcd->y_data[i][rowcnt]);

      rowcnt++;
    }
  }
  if (fast_cnt == 0)
    return 0;

  for (int i = 0; i < fast_cnt; i++)
    gcd->rows[i] = max_points;
  gcd->cols = fast_cnt;
  strcpy(gcd->x_name, "Time");
  gcd->x_axis_type[0] = curve_eAxis_x;

  fclose(fp);

  gcd->select_color(0);
  gcd->get_borders();
  gcd->get_default_axis();

  return 1;
}
