/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#ifndef xtt_xnav_h
#define xtt_xnav_h

/* xtt_xnav.h -- Simple navigator */

#if defined __cplusplus
extern "C" {
#endif

#include "pwr_baseclasses.h"
#include "co_regex.h"
#include "co_time.h"
#include "co_nav_help.h"

#if defined __cplusplus
}
#endif

#include "flow_api.h"
#include "xtt_xnav_brow.h"
#include "xtt_localdb.h"
#include "xtt_menu.h"
#include "xtt_logging.h"
#include "rt_sevcli.h"
#include "xtt_multiview.h"
#include "xtt_keyboard.h"
#include "xtt_otree.h"

#define xnav_cVersion "X3.0b"
#define XNAV_BROW_MAX 25
#define XNAV_LOGG_MAX 10

class CoWowTimer;
class XAtt;
class XCrr;
class XColWind;
class Block;
class XttTrend;
class XttSevHist;
class XttTCurve;
class XttFast;
class XAttOne;
class GeCurve;
class GeCurveData;
class CoWow;
class XttAudio;
class Ev;
class Op;
class Hist;
class CLog;
class XttGe;
class RtTrace;
class XttFileview;
class CoLogin;
class XttStream;

typedef enum {
  xnav_mOpen_All = ~0,
  xnav_mOpen_Children = 1 << 0,
  xnav_mOpen_Attributes = 1 << 1,
  xnav_mOpen_Crossref = 1 << 2
} xnav_mOpen;

typedef enum {
  xnav_eType_GdbNodeFlags = 10000,
  xnav_eType_Empty = 10001,
  xnav_eType_FixStr = 10002,
  xnav_eType_ShortTime = 10003,
  xnav_eType_NetTime = 10004
} xnav_eType;

typedef enum {
  xnav_eDestCode_After,
  xnav_eDestCode_Before,
  xnav_eDestCode_FirstChild,
  xnav_eDestCode_LastChild
} xnav_eDestCode;

typedef enum {
  xnav_eSearchType_No,
  xnav_eSearchType_Name,
  xnav_eSearchType_RegularExpr
} xnav_eSearchType;

typedef enum {
  menu_ePixmap_Map,
  menu_ePixmap_Graph,
  menu_ePixmap_Script,
  menu_ePixmap_List,
  menu_ePixmap_Leaf
} menu_ePixmap;

typedef enum {
  xnav_eConv_No,
  xnav_eConv_Hex,
  xnav_eConv_Decimal,
  xnav_eConv_Binary,
  xnav_eConv_Octal,
  xnav_eConv_Integer,
  xnav_eConv_Float,
  xnav_eConv_Identity
} xnav_eConv;

typedef struct {
  char title[80];
  int item_type;
  int pixmap;
  void* action;
} xnav_sStartMenu;

typedef struct xnav_s_Menu {
  char title[80];
  int item_type;
  char command[256];
  menu_ePixmap pixmap;
  struct xnav_s_Menu* child_list;
  struct xnav_s_Menu* parent;
  struct xnav_s_Menu* next;
} xnav_sMenu;

typedef struct s_trace_node t_trace_node;

struct s_trace_node {
  t_trace_node* Next;
  RtTrace* tractx;
  pwr_tObjid Objid;
};

typedef enum {
  ge_mOptions_FullScreen = 1 << 0,
  ge_mOptions_Maximize = 1 << 1,
  ge_mOptions_FullMaximize = 1 << 2,
  ge_mOptions_Iconify = 1 << 3,
  ge_mOptions_Invisible = 1 << 4,
  ge_mOptions_Embedded = 1 << 5,
  ge_mOptions_IsMain = 1 << 6,
  ge_mOptions_HideCloseButton = 1 << 7,
  ge_mOptions_HideDecorations = 1 << 8,
  ge_mOptions_Dialog = 1 << 9
} ge_mOptions;

typedef enum {
  xnav_eSetSignal_Conversion,
  xnav_eSetSignal_Invert,
  xnav_eSetSignal_Test,
  xnav_eSetSignal_TestValue
} xnav_eSetSignal;

class XNav;

class XNavGbl {
public:
  XNavGbl()
      : priv(0), OpObject(pwr_cNObjid), AlarmBeep(0), AlarmReturn(0),
        AlarmAck(0), hide_opwind(0), hide_statusbar(0), op_wind_pop(0),
        op_wind_eventname_seg(0), gdh_started(1), verify(0), scantime(0.5),
        signal_test_mode(0), advanced_user(1), show_truedb(0), show_allattr(0),
        no_graph_ratio(0), color_theme(0)
  {
    strcpy(version, xnav_cVersion);
    strcpy(time, "");
    strcpy(OpPlace, "");
    strcpy(default_directory, "");
    strcpy(setupscript, "");
  }
  char version[10];
  char time[80];
  unsigned long priv;
  pwr_tOName OpPlace;
  pwr_tObjid OpObject;
  int AlarmBeep;
  int AlarmReturn;
  int AlarmAck;
  int hide_opwind;
  int hide_statusbar;
  pwr_tMask op_wind_pop;
  int op_wind_eventname_seg;
  int gdh_started;
  int verify;
  char default_directory[80];
  double scantime;
  pwr_tFileName setupscript;
  int signal_test_mode;
  int advanced_user;
  int show_truedb;
  int show_allattr;
  int no_graph_ratio;
  int color_theme;

  int load_config(XNav* xnav);
  int setupscript_exec(XNav* xnav);
};

class XNav {
public:
  XNav(void* xn_parent_ctx, const char* xn_name, xnav_sStartMenu* root_menu,
      char* xn_opplace_name, int xn_op_close_button, pwr_tStatus* status);
  virtual ~XNav();

  XNavGbl gbl;
  XNavLdb ldb;
  ApplList appl;
  XttLogging logg[XNAV_LOGG_MAX];
  void* parent_ctx;
  char name[80];
  XNavBrow* brow;
  XNavBrow* collect_brow;
  XNavBrow* brow_stack[XNAV_BROW_MAX];
  int brow_cnt;
  pwr_tObjid root_objid;
  void* root_item;
  t_trace_node* TraceList;
  CoWowTimer* trace_timerid;
  CoWowTimer* autoack_timerid;
  float autoack_scantime;
  int trace_started;
  void (*message_cb)(void*, char, const char*);
  void (*close_cb)(void*, int);
  void (*map_cb)(void*);
  void (*change_value_cb)(void*);
  void (*set_dimension_cb)(void*, int, int);
  void (*selection_changed_cb)(void*);
  int ccm_func_registred;
  int verify;
  xnav_sMenu* menu_tree;
  Ev* ev;
  Op* op;
  XttGe* ge_main;
  XttMultiView* multiview_main;
  CLog* clog;
  int closing_down;
  pwr_tOName opplace_name;
  pwr_sClass_OpPlace* opplace_p;
  char base_user[80];
  char user[80];
  unsigned int base_priv;
  unsigned int priv;
  int displayed;
  int current_logging_index;
  pwr_tObjid search_last;
  char search_string[200];
  int search_last_found;
  regex_t search_creg;
  int search_compiled;
  xnav_eSearchType search_type;
  int init_help;
  int attach_audio;
  XttAudio* audio;
  CoWow* wow;
  int op_close_button;
  static xmenu_sMenuCall* mcp;
  CoLogin* cologin;
  sevcli_tCtx scctx;
  XColWind* last_xcolwind;
  void* current_cmd_ctx;
  int elog_enabled;
  int elog_checked;
  int dialog_ok;
  int dialog_cancel;
  XttKeyboard* keyboard;
  void* keyboard_owner;

  virtual void set_inputfocus()
  {
  }
  virtual void pop()
  {
  }
  virtual void set_transient(void* basewidget)
  {
  }
  virtual void create_popup_menu(pwr_sAttrRef attrref,
      xmenu_eItemType item_type, xmenu_mUtility caller, unsigned int priv,
      char* arg, int x, int y)
  {
  }
  virtual RtTrace* plctrace_new(pwr_tOid oid, pwr_tStatus* sts)
  {
    return 0;
  }
  virtual XAtt* xatt_new(pwr_tAttrRef* arp, int advanced_user, pwr_tStatus* sts)
  {
    return 0;
  }
  virtual XCrr* xcrr_new(pwr_tAttrRef* arp, int advanced_user, pwr_tStatus* sts)
  {
    return 0;
  }
  virtual XColWind* xcolwind_new(pwr_tAttrRef* ar_list, char* title,
      int advanced_user, int type, pwr_tStatus* sts)
  {
    return 0;
  }
  virtual Ev* ev_new(char* eve_name, char* ala_name, char* blk_name,
      pwr_tObjid ev_user, int display_ala, int display_eve, int display_blk,
      int display_return, int display_ack, int ev_beep, pwr_tMask ev_pop_mask,
      int ev_eventname_seg, pwr_tStatus* status)
  {
    return 0;
  }
  virtual Hist* hist_new(char* title, pwr_tAttrRef* arp, pwr_tStatus* sts)
  {
    return 0;
  }
  virtual Block* block_new(
      pwr_tAttrRef* arp, char* name, unsigned int priv, pwr_tStatus* sts)
  {
    return 0;
  }
  virtual Op* op_new(char* opplace, pwr_tStatus* sts)
  {
    return 0;
  }
  virtual XttTrend* xtttrend_new(char* name, pwr_tAttrRef* objar,
      pwr_tAttrRef* plotgroup, int width, int height, unsigned int options,
      int color_theme, void* basewidget, pwr_tStatus* sts)
  {
    return 0;
  }
  virtual XttSevHist* xttsevhist_new(char* name, pwr_tOid* oidv,
      pwr_tOName* aname, pwr_tOName* oname, bool* sevhistobjectv,
      sevcli_tCtx scctx, char* filename, int width, int height,
      unsigned int options, int color_theme, time_ePeriod time_range,
      void* basewidget, pwr_tStatus* sts)
  {
    return 0;
  }
  virtual XttTCurve* xtttcurve_new(char* name, pwr_tAttrRef* arefv, int width,
      int height, unsigned int options, int color_theme, void* basewidget,
      pwr_tStatus* sts)
  {
    return 0;
  }
  virtual XttFast* xttfast_new(char* name, pwr_tAttrRef* objar, int width,
      int height, unsigned int options, char* filename, int color_theme,
      void* basewidget, pwr_tStatus* sts)
  {
    return 0;
  }
  virtual XAttOne* xattone_new(
      pwr_tAttrRef* objar, char* title, unsigned int priv, pwr_tStatus* sts)
  {
    return 0;
  }
  virtual CLog* clog_new(const char* name, pwr_tStatus* sts)
  {
    return 0;
  }
  virtual XttGe* xnav_ge_new(const char* name, const char* filename,
      int scrollbar, int menu, int navigator, int width, int height, int x,
      int y, double scan_time, const char* object_name, int use_default_access,
      unsigned int access, unsigned int options, void* basewidget,
      double* borders, int color_theme, int dashboard,
      int (*xg_command_cb)(void*, char*, char*, void*),
      int (*xg_get_current_objects_cb)(void*, pwr_sAttrRef**, int**),
      int (*xg_is_authorized_cb)(void*, unsigned int),
      void (*xg_keyboard_cb)(void*, void*, int, int))
  {
    return 0;
  }
  virtual XttMultiView* multiview_new(const char* name, pwr_tAttrRef* aref,
      int width, int height, int x, int y, unsigned int options,
      void* basewidget, int color_theme, pwr_tStatus* sts,
      int (*command_cb)(void*, char*, char*, void*),
      int (*get_current_objects_cb)(void*, pwr_sAttrRef**, int**),
      int (*is_authorized_cb)(void*, unsigned int),
      void (*keyboard_cb)(void*, void*, int, int))
  {
    return 0;
  }
  virtual XttStream* stream_new(const char* name, const char* uri, int width,
      int height, int x, int y, double scan_time, unsigned int options,
      int embedded, pwr_tAttrRef* arp, pwr_tStatus* sts)
  {
    return 0;
  }
  virtual GeCurve* gecurve_new(char* name, char* filename, GeCurveData* data,
      int pos_right, unsigned int options, int color_theme, void* basewidget)
  {
    return 0;
  }
  virtual XttFileview* fileview_new(pwr_tOid oid, char* title, char* dir,
      char* pattern, int type, char* target_attr, char* trigger_attr,
      char* filetype)
  {
    return 0;
  }
  virtual CoLogin* login_new(const char* wl_name, const char* wl_groupname,
      void (*wl_bc_success)(void*), void (*wl_bc_cancel)(void*),
      void* basewidget, pwr_tStatus* status)
  {
    return 0;
  }
  virtual XttKeyboard* keyboard_new(const char* name, keyboard_eKeymap keymap,
      keyboard_eType type, int color_theme, pwr_tStatus* status)
  {
    return 0;
  }
  virtual XttOTree* tree_new(const char* title, pwr_tAttrRef* itemlist,
      int itemcnt, unsigned int options,
      pwr_tStatus (*action_cb)(void*, pwr_tAttrRef*))
  {
    return 0;
  }
  virtual void bell(int time)
  {
  }
  virtual int confirm_dialog(char* title, char* text)
  {
    return 0;
  }
  virtual void set_clock_cursor()
  {
  }
  virtual void reset_cursor()
  {
  }

  void start_trace(pwr_tObjid Objid, char* object_str);
  void start_trace_selected();
  void show_crossref();
  int create_object_item(pwr_tObjid objid, brow_tNode dest,
      flow_eDest dest_code, void** item, int is_root);
  void print(char* filename);
  void print_draw_page(void* context, const char* title, int page,
      flow_eOrientation orientation);
  void print_get_pages(flow_eOrientation orientation, int* pages);
  void zoom(double zoom_factor);
  void get_zoom(double* zoom_factor);
  void unzoom();
  int set_attr_value(char* value_str);
  int check_attr_value();
  int get_select(pwr_sAttrRef* attrref, int* is_attr);
  int get_select_all(pwr_sAttrRef** attrref, int** is_attr);
  int get_all_objects(pwr_sAttrRef** attrref, int** is_attr);
  int get_all_collect_objects(pwr_sAttrRef** attrref, int** is_attr);
  void set_select_conversion(xnav_eConv conv);
  int collect_insert(pwr_sAttrRef* attrref);
  int collect_remove();
  int collect_show();
  int collect_window(int copy, int type);
  void collect_clear();
  int get_dashboard_name(pwr_sAttrRef* arp, char* dash_name, 
      pwr_tTypeId* dash_type);
  int dashboard_insert(pwr_sAttrRef* attrref);
  void clear();
  void message(char sev, const char* text);
  int brow_pop();
  int brow_push();
  int brow_push_all();
  void set_push_command(char* cmd);
  int find(pwr_tObjid objid, void** item);
  int find(pwr_tObjid objid, char* attr, void** item);
  int display_object(pwr_sAttrRef* arp, int open);
  int display_object(pwr_tObjid objid, int open);
  int setup();
  int show_logging(int entry);
  void force_trace_scan();
  void menu_tree_build(xnav_sStartMenu* root);
  xnav_sMenu* menu_tree_build_children(
      xnav_sStartMenu* first_child, xnav_sMenu* parent);
  void menu_tree_free();
  void menu_tree_free_children(xnav_sMenu* first_child);
  int menu_tree_search(char* name, xnav_sMenu** menu_item);
  int menu_tree_search_children(
      char* name, xnav_sMenu* child_list, xnav_sMenu** menu_item);
  int menu_tree_insert(char* title, int item_type, char* command,
      menu_ePixmap pixmap, char* destination, int dest_code,
      xnav_sMenu** menu_item);
  int menu_tree_delete(char* name);
  int load_ev_from_opplace();
  int login_from_opplace();
  int login();
  void open_login();
  void logout();
  int is_authorized(unsigned int access = pwr_mAccess_AllRt, int msg = 1);
  static char* get_message(int sts);
  int show_object_as_struct(pwr_tObjid objid, char* type_str, char* file_str);
  void enable_events(XNavBrow* brow);
  int open_object(pwr_sAttrRef* arp);
  int open_crossref(pwr_sAttrRef* arp);
  void swap(int mode);
  int update_alarminfo();
  int sound(pwr_tAttrRef* arp);
  int sound_attached();
  int eventlog_enabled();
  void appl_startup();
  void refresh();

  static int init_brow_base_cb(FlowCtx* fctx, void* client_data);
  static int get_trace_attr(pwr_sAttrRef* arp, char* attr);
  static int attr_string_to_value(int type_id, char* value_str,
      void* buffer_ptr, int buff_size, int attr_size);
  static void attrvalue_to_string(int type_id, pwr_tTid tid, void* value_ptr,
      char* str, int size, int* len, char* format, int conv);
  static void trace_subwindow_cb(void* ctx, pwr_tObjid objid);
  static void trace_display_object_cb(void* ctx, pwr_tObjid objid);
  static int is_authorized_cb(void* xnav, unsigned int access);
  static void trace_collect_insert_cb(void* ctx, pwr_tObjid objid);
  static void trace_close_cb(RtTrace* tractx);
  static void trace_help_cb(RtTrace* tractx, const char* key, const char* file);
  static void xatt_close_cb(void* xnav, void* xatt);
  static void xcrr_close_cb(void* xnav, void* xcrr);
  static int brow_cb(FlowCtx* ctx, flow_tEvent event);
  static void trace_scan(void* data);
  static int trace_scan_bc(brow_tObject object, void* p);
  static int trace_connect_bc(brow_tObject object, char* name, char* attr,
      flow_eTraceType type, void** p);
  static int trace_disconnect_bc(brow_tObject object);
  static int init_brow_collect_cb(BrowCtx* ctx, void* client_data);
  static int init_brow_cb(BrowCtx* ctx, void* client_data);
  static void autoack_scan(void* data);

  // Command module member functions
  int command(char* cmd);
  int script(char* buffer);
  pwr_tStatus get_command_sts();
  int readcmdfile(char* incommand, char* buffer);
  int show_database(int nopop = 0);
  int get_current_object(
      pwr_tObjid* objid, char* objectname, int size, pwr_tBitMask nametype);
  int get_current_aref(
      pwr_sAttrRef* arp, char* arname, int size, pwr_tBitMask nametype);
  int show_file(char* filename, char* intitle, int hide_dir);
  void update_time();
  int find_name(char* name, pwr_tObjid* objid);
  int show_par_hier_class_name(char* parametername, char* hiername,
      char* classname, char* name, int add, int global, int max_objects);
  int store(char* filename, int collect);
  int show_symbols();
  void open_graph(const char* name, const char* filename, int scrollbar,
      int menu, int navigator, int width, int height, int x, int y,
      const char* object_name, const char* focus, int inputempty,
      int use_default_access, unsigned int access, unsigned int options,
      void* basewidget, double* borders, int dashboard);
  void close_graph(char* filename, char* object_name, int iconify);
  int exec_xttgraph(pwr_tObjid xttgraph, char* instance, char* focus,
      int inputempty, int use_default_access, unsigned int access,
      unsigned int options, void* basewidget);
  void ge_event_exec(
      int type, char* name, char* instance, void* event, unsigned int size);
  int set_parameter(char* name_str, char* value_str, int bypass);
  void open_rttlog(char* name, char* filename);
  int search(char* search_str, int regexp);
  int search_root(char* search_str, pwr_tObjid* found_objid, int next);
  int search_object(
      pwr_tObjid objid, char* search_str, pwr_tObjid* found_objid, int next);
  int search_next();
  int create_object(char* classname, char* name);
  int delete_object(char* name);
  void open_keyboard(void* owner, keyboard_eKeymap keymap, int type);
  void close_keyboard(int action);
  int set_signal(pwr_tAttrRef* arp, xnav_eSetSignal type, int on);
  static void print_methods();
  static pwr_tStatus get_instance_classgraph(
      char* instance_str, pwr_tFileName filename);

  // Table module member functions
  int show_plcthreads();
  int show_nethandler();
  int show_subsrv();
  int show_subcli();
  int show_device();
  int show_channels(pwr_tObjid card_objid);
  int show_attr_channels(pwr_tAttrRef* mod_aref, void* cardp,
      pwr_tSubid* card_subid, pwr_tCid card_cid);
  int show_object(pwr_tAttrRef* oarp, brow_tNode node);
  int show_remnode();
  int show_remtrans(pwr_tObjid remnode_objid);
  int show_plcpgm();

  // Help module member functions
  int help(char* key, char* help_bookmark, navh_eHelpFile file_type,
      char* file_name, int pop);
  int help_index(navh_eHelpFile file_type, char* file_name, int pop);

  // Methods and Popup menu functions
  virtual void get_popup_menu(pwr_sAttrRef attrref, xmenu_eItemType item_type,
      xmenu_mUtility caller, unsigned int priv, char* arg, int x, int y)
  {
  }
  void get_popup_menu_items(pwr_sAttrRef attrref, xmenu_eItemType item_type,
      xmenu_mUtility caller, unsigned int priv, char* arg);
  static int CallMenuMethod(xmenu_sMenuCall* ip, int idx);
  static int CheckMenuMethodFilter(xmenu_sMenuCall* ip, int idx);
  int call_method(const char* method, const char* filter, pwr_sAttrRef attrref,
      xmenu_eItemType item_type, xmenu_mUtility caller, unsigned int priv,
      char* arg);
  int call_object_method(pwr_sAttrRef attrref, xmenu_eItemType item_type,
      xmenu_mUtility caller, unsigned int priv, char* method_name);
  int check_object_methodfilter(pwr_sAttrRef attrref, xmenu_eItemType item_type,
      xmenu_mUtility caller, unsigned int priv, char* method_name);
  static int GetObjectMenu(xmenu_sMenuCall* ip, pwr_tCid classid,
      xmenu_sMenuItem** Item, pwr_tUInt32 Level, int* nItems, int AddSeparator,
      pwr_sAttrRef* CurrentObject);
  static int GetMethod(
      const char* name, pwr_tStatus (**method)(xmenu_sMenuCall*));
  static int getAllMenuItems(xmenu_sMenuCall* ip, xmenu_sMenuItem** Item,
      pwr_tObjid objid, pwr_tUInt32 Level, int* nItems, int AddSeparator,
      pwr_sAttrRef* CurrentObject);
  static int GetMenu(xmenu_sMenuCall* ip);
};

int xnav_cut_segments(char* outname, char* name, int segments);

int xnav_attr_string_to_value(int type_id, char* value_str, void* buffer_ptr,
    int buff_size, int attr_size);
void xnav_attrvalue_to_string(int type_id, pwr_tTid tid, void* value_ptr,
    char* str, int size, int* len, char* format);

void xnav_create_popup_menu(XNav* xnav, pwr_sAttrRef attrref,
    xmenu_eItemType item_type, xmenu_mUtility caller, unsigned int priv,
    char* arg, int x, int y);
int xnav_call_method(XNav* xnav, char* method, char* filter,
    pwr_sAttrRef attrref, xmenu_eItemType item_type, xmenu_mUtility caller,
    unsigned int priv, char* arg);
int xnav_call_object_method(XNav* xnav, pwr_sAttrRef attrref,
    xmenu_eItemType item_type, xmenu_mUtility caller, unsigned int priv,
    char* method_name);
int xnav_check_object_methodfilter(XNav* xnav, pwr_sAttrRef attrref,
    xmenu_eItemType item_type, xmenu_mUtility caller, unsigned int priv,
    char* method_name);

void xnav_popup_menu_cb(void* xnav, pwr_sAttrRef attrref,
    unsigned long item_type, unsigned long utility, char* arg, int x, int y);
int xnav_call_method_cb(void* xnav, const char* method, const char* filter,
    pwr_sAttrRef attrref, unsigned long item_type, unsigned long utility,
    char* arg);
void xnav_start_trace_cb(void* xnav, pwr_tObjid objid, char* name);
int xnav_get_trace_attr(pwr_sAttrRef* arp, char* attr);

#endif
