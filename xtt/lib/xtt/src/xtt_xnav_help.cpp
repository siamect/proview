/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* xtt_xnav_help.cpp
   This module contains routines for displaying help in xtt. */

/*_Include files_________________________________________________________*/

#include <stdlib.h>

#include "pwr_names.h"

#include "co_dcli.h"
#include "co_dcli_msg.h"
#include "co_string.h"

#include "xtt_item.h"
#include "xtt_trace.h"
#include "xtt_xnav_crr.h"

static int help_cmp_items(const void* node1, const void* node2);

/*************************************************************************
*
* Name:		help()
*
**************************************************************************/

void* xnav_help_insert_cb(void* ctx, navh_eItemType item_type,
    const char* text1, const char* text2, const char* text3, const char* link,
    const char* bookmark, const char* file_name, navh_eHelpFile file_type,
    int help_index, const char* bm, int coding)
{
  XNav* xnav = (XNav*)ctx;

  if (xnav->init_help == 1) {
    xnav->brow_pop();
    brow_SetNodraw(xnav->brow->ctx);
    brow_SetTextCoding(xnav->brow->ctx, (flow_eTextCoding)coding);
    xnav->init_help = 0;
  } else if (xnav->init_help == 2) {
    brow_SetTextCoding(xnav->brow->ctx, (flow_eTextCoding)coding);
    xnav->init_help = 0;
  }

  switch (item_type) {
  case navh_eItemType_Help:
  case navh_eItemType_HelpCode: {
    ItemHelp* item = new ItemHelp(xnav->brow, "help", text1, text2, text3, link,
        bookmark, file_name, file_type, help_index, NULL, flow_eDest_IntoLast);
    return item->node;
  }
  case navh_eItemType_HelpBold: {
    ItemHelpBold* item = new ItemHelpBold(xnav->brow, "help", text1, text2,
        text3, link, bookmark, file_name, file_type, help_index, NULL,
        flow_eDest_IntoLast);
    return item->node;
  }
  case navh_eItemType_HelpHeader: {
    ItemHelpHeader* item = new ItemHelpHeader(
        xnav->brow, "help", text1, NULL, flow_eDest_IntoLast);
    return item->node;
  }
  case navh_eItemType_Header: {
    ItemHeader* item
        = new ItemHeader(xnav->brow, "help", text1, NULL, flow_eDest_IntoLast);
    return item->node;
  }
  case navh_eItemType_HeaderLarge: {
    ItemHeaderLarge* item = new ItemHeaderLarge(
        xnav->brow, "help", text1, NULL, flow_eDest_IntoLast);
    return item->node;
  }
  default:
    return 0;
  }
}

int XNav::help(char* help_key, char* help_bookmark, navh_eHelpFile file_type,
    char* file_name, int pop)
{
  int sts;
  brow_tNode bookmark_node;
  brow_tNode prev, first;
  NavHelp* navhelp
      = new NavHelp((void*)this, pwr_cNameBaseXttHelp, pwr_cNameProjectXttHelp);
  navhelp->insert_cb = xnav_help_insert_cb;

  if (pop)
    init_help = 1;
  else {
    init_help = 2;
    brow_SetNodraw(brow->ctx);
  }
  sts = navhelp->help(
      help_key, help_bookmark, file_type, file_name, &bookmark_node, false);
  if (EVEN(sts)) {
    if (!pop || init_help != 1) {
      brow_push();
      brow_ResetNodraw(brow->ctx);
    }
    return sts;
  }

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
  if (bookmark_node) {
    brow_CenterObject(brow->ctx, bookmark_node, 0.0);
    sts = brow_GetPrevious(brow->ctx, bookmark_node, &prev);
    if (ODD(sts)) {
      brow_SelectClear(brow->ctx);
      brow_SetInverse(prev, 1);
      brow_SelectInsert(brow->ctx, prev);
    }
  } else {
    sts = brow_GetFirst(brow->ctx, &first);
    if (ODD(sts))
      brow_CenterObject(brow->ctx, first, 0.0);
  }
  delete navhelp;

  return XNAV__SUCCESS;
}

/*************************************************************************
*
* Name:		help_index()
*
**************************************************************************/

int XNav::help_index(navh_eHelpFile file_type, char* file_name, int pop)
{
  int sts;
  brow_tObject* object_list;
  int object_cnt;
  NavHelp* navhelp
      = new NavHelp((void*)this, pwr_cNameBaseXttHelp, pwr_cNameProjectXttHelp);
  navhelp->insert_cb = xnav_help_insert_cb;

  if (pop)
    brow_pop();
  brow_SetNodraw(brow->ctx);
  new ItemHelpHeader(brow, "help_index", "Index", NULL, flow_eDest_IntoLast);
  new ItemHelp(brow, "help_index", "", "", "", "", "", NULL,
      navh_eHelpFile_Base, 0, NULL, flow_eDest_IntoLast);

  sts = navhelp->help_index(file_type, file_name);

  brow_GetObjectList(brow->ctx, &object_list, &object_cnt);
  qsort(
      &object_list[2], object_cnt - 2, sizeof(object_list[0]), help_cmp_items);

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
  return sts;
}

static int help_cmp_items(const void* node1, const void* node2)
{
  char text1[80];
  char text2[80];

  brow_GetAnnotation(*(brow_tNode*)node1, 0, text1, sizeof(text1));
  brow_GetAnnotation(*(brow_tNode*)node2, 0, text2, sizeof(text2));
  str_ToLower(text1, text1);
  str_ToLower(text2, text2);

  return (strcmp(text1, text2));
}
