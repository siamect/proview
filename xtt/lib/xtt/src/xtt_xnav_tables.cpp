/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2012 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */

#include "flow_std.h"

#include <stdio.h>
#include <stdlib.h>

#include "rt_net.h"
#include "rt_gdh.h"
#include "rt_gdh_msg.h"
#include "co_cdh.h"
#include "co_time.h"
#include "pwr_baseclasses.h"
#include "pwr_remoteclasses.h"
#include "xtt_ssaboxclasses.h"
#include "rt_xnav_msg.h"
#include "flow.h"
#include "flow_browctx.h"
#include "flow_browapi.h"
#include "xtt_trace.h"
#include "xtt_xnav.h"
#include "xtt_item.h"

extern "C" {
#include "rt_gdh.h"
#include "rt_qdb.h"
#include "rt_hash.h"
#include "rt_pool.h"
#include "rt_sub.h"
#include "rt_io_base.h"
}

typedef struct {
  void *chanp;
  void *cardp;
  pwr_tCid chan_cid;
  pwr_tCid card_cid;
} tab_sChannelFlagsData;

static int	xnav_subcli_remote_cnt;


static int	xnav_get_nodename( pwr_tNodeId nid, char *nodename);
static int xnav_show_subsrv_insert( XNav *xnav, sub_sServer *ssrvp);
extern "C" void xnav_show_subsrv_scan( XNav *xnav);
static int xnav_show_subcli_insert( XNav *xnav, gdb_sNode *np,
		sub_sClient *sclip);
extern "C" void xnav_show_subcli_scan( XNav *xnav);

int XNav::show_plcthreads()
{
  item_sTableHeader 	th;
  item_sTable 		t;
  item_sTableSubid	ts;
  pwr_tTypeId		attrtype;
  unsigned int		attrsize, attroffs, attrelem;
  pwr_tSubid		subid;
  pwr_tOName   		object_name;
  pwr_tAName   		attr_name;
  char			*s;
  int			sts;
  pwr_tObjid		objid;
  pwr_sAttrRef		attrref;
  pwr_sClass_PlcThread	*object_ptr;

  brow_pop();
  brow_SetNodraw( brow->ctx);

  th.table_cnt = 0;
  strcpy( th.title[th.table_cnt++], "PlcThread");
  strcpy( th.title[th.table_cnt++], "Prio");
  strcpy( th.title[th.table_cnt++], "LoopCnt");
  strcpy( th.title[th.table_cnt++], "ScanTime");
  strcpy( th.title[th.table_cnt++], "Mean");
  strcpy( th.title[th.table_cnt++], "Coverage");
  strcpy( th.title[th.table_cnt++], "Count 1/8");
  strcpy( th.title[th.table_cnt++], "Count 1/4");
  strcpy( th.title[th.table_cnt++], "Count 1/2");
  strcpy( th.title[th.table_cnt++], "Count 1/1");
  new ItemTableHeader( brow, this, "Title", &th,  NULL, flow_eDest_IntoLast);

  sts = gdh_GetClassList ( pwr_cClass_PlcThread, &objid);
  while ( ODD(sts))
  {
    memset( &attrref, 0, sizeof( attrref));
    attrref.Objid = objid;
    sts = gdh_DLRefObjectInfoAttrref ( &attrref,
		(pwr_tAddress *) &object_ptr,
		&subid);
    if ( EVEN(sts)) return sts;

    sts = gdh_ObjidToName ( objid, object_name,
			sizeof(object_name), cdh_mName_volumeStrict);
    if ( EVEN(sts)) return sts;

    t.elem_cnt = 0;

    // Object name
    s = strrchr( object_name, '-');
    if ( s == 0)
      s = object_name;
    else
      s++;

    strcpy( t.elem[t.elem_cnt].fix_str, s);
    t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

    // Prio
    strcpy( attr_name, object_name);
    strcat( attr_name, ".Prio");
    sts = gdh_GetAttributeCharacteristics ( attr_name,
		&attrtype, &attrsize, &attroffs, &attrelem);
    if ( EVEN(sts)) return sts;

    t.elem[t.elem_cnt].value_p = &object_ptr->Prio;
    t.elem[t.elem_cnt].type_id = attrtype;
    t.elem[t.elem_cnt].size = attrsize;
    strcpy( t.elem[t.elem_cnt++].format, "%3d");

    // Count
    strcpy( attr_name, object_name);
    strcat( attr_name, ".Count");
    sts = gdh_GetAttributeCharacteristics ( attr_name,
		&attrtype, &attrsize, &attroffs, &attrelem);
    if ( EVEN(sts)) return sts;

    t.elem[t.elem_cnt].value_p = &object_ptr->Count;
    t.elem[t.elem_cnt].type_id = attrtype;
    t.elem[t.elem_cnt].size = attrsize;
    strcpy( t.elem[t.elem_cnt++].format, "%10d");

    // ScanTime
    strcpy( attr_name, object_name);
    strcat( attr_name, ".ScanTime");
    sts = gdh_GetAttributeCharacteristics ( attr_name,
		&attrtype, &attrsize, &attroffs, &attrelem);
    if ( EVEN(sts)) return sts;

    t.elem[t.elem_cnt].value_p = &object_ptr->ScanTime;
    t.elem[t.elem_cnt].type_id = attrtype;
    t.elem[t.elem_cnt].size = attrsize;
    strcpy( t.elem[t.elem_cnt++].format, "%8.3f");

    // ScanTimeMean
    strcpy( attr_name, object_name);
    strcat( attr_name, ".ScanTimeMean");
    sts = gdh_GetAttributeCharacteristics ( attr_name,
		&attrtype, &attrsize, &attroffs, &attrelem);
    if ( EVEN(sts)) return sts;

    t.elem[t.elem_cnt].value_p = &object_ptr->ScanTimeMean;
    t.elem[t.elem_cnt].type_id = attrtype;
    t.elem[t.elem_cnt].size = attrsize;
    strcpy( t.elem[t.elem_cnt++].format, "%8.3f");

    // Coverage
    strcpy( attr_name, object_name);
    strcat( attr_name, ".Coverage");
    sts = gdh_GetAttributeCharacteristics ( attr_name,
		&attrtype, &attrsize, &attroffs, &attrelem);
    if ( EVEN(sts)) return sts;

    t.elem[t.elem_cnt].value_p = &object_ptr->Coverage;
    t.elem[t.elem_cnt].type_id = attrtype;
    t.elem[t.elem_cnt].size = attrsize;
    strcpy( t.elem[t.elem_cnt++].format, "%8.3f");

    // Count_1_8
    strcpy( attr_name, object_name);
    strcat( attr_name, ".Count_1_8");
    sts = gdh_GetAttributeCharacteristics ( attr_name,
		&attrtype, &attrsize, &attroffs, &attrelem);
    if ( EVEN(sts)) return sts;

    t.elem[t.elem_cnt].value_p = &object_ptr->Count_1_8;
    t.elem[t.elem_cnt].type_id = attrtype;
    t.elem[t.elem_cnt].size = attrsize;
    strcpy( t.elem[t.elem_cnt++].format, "%10d");

    // Count_1_4
    strcpy( attr_name, object_name);
    strcat( attr_name, ".Count_1_4");
    sts = gdh_GetAttributeCharacteristics ( attr_name,
		&attrtype, &attrsize, &attroffs, &attrelem);
    if ( EVEN(sts)) return sts;

    t.elem[t.elem_cnt].value_p = &object_ptr->Count_1_4;
    t.elem[t.elem_cnt].type_id = attrtype;
    t.elem[t.elem_cnt].size = attrsize;
    strcpy( t.elem[t.elem_cnt++].format, "%10d");

    // Count_1_2
    strcpy( attr_name, object_name);
    strcat( attr_name, ".Count_1_2");
    sts = gdh_GetAttributeCharacteristics ( attr_name,
		&attrtype, &attrsize, &attroffs, &attrelem);
    if ( EVEN(sts)) return sts;

    t.elem[t.elem_cnt].value_p = &object_ptr->Count_1_2;
    t.elem[t.elem_cnt].type_id = attrtype;
    t.elem[t.elem_cnt].size = attrsize;
    strcpy( t.elem[t.elem_cnt++].format, "%10d");

    // Count_1_1
    strcpy( attr_name, object_name);
    strcat( attr_name, ".Count_1_1");
    sts = gdh_GetAttributeCharacteristics ( attr_name,
		&attrtype, &attrsize, &attroffs, &attrelem);
    if ( EVEN(sts)) return sts;

    t.elem[t.elem_cnt].value_p = &object_ptr->Count_1_1;
    t.elem[t.elem_cnt].type_id = attrtype;
    t.elem[t.elem_cnt].size = attrsize;
    strcpy( t.elem[t.elem_cnt++].format, "%10d");

    ts.subid[0] = subid;
    ts.subid_cnt = 1;
    new ItemTable( brow, this, objid, &t, &ts, -1, 0, 0, 0, NULL, flow_eDest_IntoLast);

    sts = gdh_GetNextObject ( objid, &objid);
  }

  brow_ResetNodraw( brow->ctx);
  brow_Redraw( brow->ctx, 0);
  force_trace_scan();
  return XNAV__SUCCESS;
}

int XNav::show_nethandler()
{
  item_sTableHeader 	th;
  item_sTable 		t;
  item_sTableSubid	ts;
  int			sts;
  pool_sQlink		*nl;
  gdb_sNode		*np;

  brow_pop();
  brow_SetNodraw( brow->ctx);

  th.table_cnt = 0;
  strcpy( th.title[th.table_cnt++], "Node");
  strcpy( th.title[th.table_cnt++], "Os");
  strcpy( th.title[th.table_cnt++], "Link");
  strcpy( th.title[th.table_cnt++], "UpCount");
  strcpy( th.title[th.table_cnt++], "Time up");
  new ItemTableHeader( brow, this, "Title", &th,  NULL, flow_eDest_IntoLast);

  gdb_ScopeLock {
    for (
	  nl = pool_Qsucc(&sts, gdbroot->pool, &gdbroot->db->nod_lh);
	  nl != &gdbroot->db->nod_lh;
	  nl = pool_Qsucc(&sts, gdbroot->pool, nl))
    {

      np = pool_Qitem(nl, gdb_sNode, nod_ll);

      if ( strcmp( np->name, "******") == 0)
        continue;

      t.elem_cnt = 0;

      // Node name
      strcpy( t.elem[t.elem_cnt].fix_str, np->name);
      t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

      // Os
      switch ( np->hw) {
        case co_eHW_x86: strcpy( t.elem[t.elem_cnt].fix_str, "x86"); break;
        case co_eHW_x86_64: strcpy( t.elem[t.elem_cnt].fix_str, "x86_64"); break;
        case co_eHW_68k: strcpy( t.elem[t.elem_cnt].fix_str, "68k"); break;
        case co_eHW_VAX: strcpy( t.elem[t.elem_cnt].fix_str, "VAX"); break;
        case co_eHW_Alpha: strcpy( t.elem[t.elem_cnt].fix_str, "AXP"); break;
        case co_eHW_PPC: strcpy( t.elem[t.elem_cnt].fix_str, "PPC"); break;
        case co_eHW_ARM: strcpy( t.elem[t.elem_cnt].fix_str, "ARM"); break;
        default: strcpy( t.elem[t.elem_cnt].fix_str, "-");
      }
      switch ( np->os) {
        case co_eOS_Lynx: strcat( t.elem[t.elem_cnt].fix_str, "_Lynx"); break;
        case co_eOS_Linux: strcat( t.elem[t.elem_cnt].fix_str, "_Linux"); break;
        case co_eOS_VMS: strcat( t.elem[t.elem_cnt].fix_str, "_VMS"); break;
        case co_eOS_ELN: strcat( t.elem[t.elem_cnt].fix_str, "_ELN"); break;
        case co_eOS_MacOS: strcat( t.elem[t.elem_cnt].fix_str, "_MacOS"); break;
        case co_eOS_FreeBSD: strcat( t.elem[t.elem_cnt].fix_str, "_FreeBSD"); break;
        case co_eOS_OpenBSD: strcat( t.elem[t.elem_cnt].fix_str, "_OpenBSD"); break;
        case co_eOS_Cygwin: strcat( t.elem[t.elem_cnt].fix_str, "_Cygwin"); break;
        default: ;
      }
      t.elem[t.elem_cnt].fix_str[11] = 0;
      t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

      if (np == gdbroot->my_node)
      {
        // Local node
        strcpy( t.elem[t.elem_cnt].fix_str, "Local");
        t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;
      }
      else
      {
        t.elem[t.elem_cnt].value_p = &np->flags;
        t.elem[t.elem_cnt].type_id = xnav_eType_GdbNodeFlags;
        t.elem[t.elem_cnt].size = sizeof(np->flags.b);
        strcpy( t.elem[t.elem_cnt++].format, "%s");
      }

      // UpCnt
      t.elem[t.elem_cnt].value_p = &np->upcnt;
      t.elem[t.elem_cnt].type_id = pwr_eType_UInt32;
      t.elem[t.elem_cnt].size = sizeof(np->upcnt);
      strcpy( t.elem[t.elem_cnt++].format, "%8d");

      // Time up
      t.elem[t.elem_cnt].value_p = &np->timeup;
      t.elem[t.elem_cnt].type_id = pwr_eType_Time;
      t.elem[t.elem_cnt++].size = sizeof(np->timeup);

      ts.subid_cnt = 0;
      new ItemTable( brow, this, pwr_cNObjid, &t, &ts, -1, 0, 0, 0, NULL, 
		flow_eDest_IntoLast);
    }
  } gdb_ScopeUnlock;

  brow_ResetNodraw( brow->ctx);
  brow_Redraw( brow->ctx, 0);
  force_trace_scan();
  return XNAV__SUCCESS;
}


static int	xnav_get_nodename( pwr_tNodeId nid, char *nodename)
{
	gdb_sNode 		*np;
	int			sts;

	np = (gdb_sNode*) hash_Search( &sts, gdbroot->nid_ht, &nid);
	if (ODD(sts)) 
	  strcpy( nodename, np->name);
	else
	  strcpy( nodename, "Undef");
	return sts;
}

int XNav::show_subsrv()
{
  pool_sQlink		*sl;
  sub_sServer	 	*ssrvp;
  item_sTableHeader 	th;
  int			sts;
  ItemTableHeader	*item_header;

  brow_pop();
  brow_SetNodraw( brow->ctx);

  th.table_cnt = 0;
  strcpy( th.title[th.table_cnt++], "Subid");
  strcpy( th.title[th.table_cnt++], "Count");
  strcpy( th.title[th.table_cnt++], "Node");
  strcpy( th.title[th.table_cnt++], "Size");
  strcpy( th.title[th.table_cnt++], "Offset");
  strcpy( th.title[th.table_cnt++], "Attribute");
  item_header = new ItemTableHeader( brow, this, "Title", &th,  NULL, flow_eDest_IntoLast);
  item_header->add_bc( xnav_show_subsrv_scan, NULL);

  gdb_ScopeLock {
    for (
	  sl = pool_Qsucc(&sts, gdbroot->pool, &gdbroot->db->subs_lh);
	  sl != &gdbroot->db->subs_lh;
	  sl = pool_Qsucc(&sts, gdbroot->pool, sl))
    {
      ssrvp = pool_Qitem(sl, sub_sServer, subs_ll);

      xnav_show_subsrv_insert( this, ssrvp);
    }
  } gdb_ScopeUnlock;

  brow_ResetNodraw( brow->ctx);
  brow_Redraw( brow->ctx, 0);
  force_trace_scan();
  return XNAV__SUCCESS;
}

static int xnav_show_subsrv_insert( XNav *xnav, sub_sServer *ssrvp)
{
  item_sTable 		t;
  item_sTableSubid	ts;
  ItemTable		*item;

  t.elem_cnt = 0;

  // Subid
  t.elem[t.elem_cnt].value_p = &ssrvp->sid;
  t.elem[t.elem_cnt].type_id = pwr_eType_RefId;
  t.elem[t.elem_cnt].size = sizeof(ssrvp->sid);
  strcpy( t.elem[t.elem_cnt++].format, "%8d");

  // Count
  t.elem[t.elem_cnt].value_p = &ssrvp->count;
  t.elem[t.elem_cnt].type_id = pwr_eType_UInt32;
  t.elem[t.elem_cnt].size = sizeof(ssrvp->count);
  strcpy( t.elem[t.elem_cnt++].format, "%8d");

  // Node
  xnav_get_nodename( ssrvp->nid, t.elem[t.elem_cnt].fix_str);
  t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

  // Size
  t.elem[t.elem_cnt].value_p = &ssrvp->aref.Size;
  t.elem[t.elem_cnt].type_id = pwr_eType_UInt32;
  t.elem[t.elem_cnt].size = sizeof(ssrvp->aref.Size);
  strcpy( t.elem[t.elem_cnt++].format, "%8d");

  // Offset
  t.elem[t.elem_cnt].value_p = &ssrvp->aref.Offset;
  t.elem[t.elem_cnt].type_id = pwr_eType_UInt32;
  t.elem[t.elem_cnt].size = sizeof(ssrvp->aref.Offset);
  strcpy( t.elem[t.elem_cnt++].format, "%8d");

  // Attribute
  t.elem[t.elem_cnt].value_p = &ssrvp->aref;
  t.elem[t.elem_cnt].type_id = pwr_eType_AttrRef;
  t.elem[t.elem_cnt++].size = sizeof(ssrvp->aref);

  ts.subid_cnt = 0;
  item = new ItemTable( xnav->brow, xnav, pwr_cNObjid, &t, &ts, -1, 0, 0, 0, NULL, 
		flow_eDest_IntoLast);
  item->found = 1;
  return XNAV__SUCCESS;
}

extern "C" void xnav_show_subsrv_scan( XNav *xnav)
{
  brow_tObject	*node_list;
  brow_tObject	*object_p;
  int		node_cnt;
  ItemTable	*item;
  int		i;
  pool_sQlink	*sl;
  sub_sServer	 *ssrvp;
  int		sts;
  int		found;
  int		change_detected = 0;

  brow_SetNodraw( xnav->brow->ctx);
  brow_GetObjectList( xnav->brow->ctx, &node_list, &node_cnt);

  // Reset found
  object_p = node_list + 1;
  for ( i = 1; i < node_cnt; i++)
  {    
    brow_GetUserData( *object_p, (void **)&item);
    item->found = 0;
    object_p++;    
  }

  gdb_ScopeLock {
    for (
	  sl = pool_Qsucc(&sts, gdbroot->pool, &gdbroot->db->subs_lh);
	  sl != &gdbroot->db->subs_lh;
	  sl = pool_Qsucc(&sts, gdbroot->pool, sl))
    {
      ssrvp = pool_Qitem(sl, sub_sServer, subs_ll);

      object_p = node_list + 1;
      found = 0;
      for ( i = 1; i < node_cnt; i++)
      {    
        brow_GetUserData( *object_p, (void **)&item);
        if ( memcmp( item->col.elem[0].value_p, &ssrvp->sid, sizeof(pwr_tSubid))
		 == 0)
        {
          found = 1;
          break;
        }		
        object_p++;
      }
      if ( !found)
      {
        xnav_show_subsrv_insert( xnav, ssrvp);
        change_detected = 1;
      }
      else
        item->found = 1;
    }
  } gdb_ScopeUnlock;

  // Remove all that were not found
  object_p = node_list + 1;
  for ( i = 1; i < node_cnt; i++)
  {    
    brow_GetUserData( *object_p, (void **)&item);
    if ( ! item->found)
    {
      brow_DeleteNode( xnav->brow->ctx, item->node);
      change_detected = 1;
    }
    else
      object_p++;
  }
  brow_ResetNodraw( xnav->brow->ctx);
  if ( change_detected)
    brow_Redraw( xnav->brow->ctx, 0);
}


int XNav::show_subcli()
{
  pool_sQlink		*sl;
  pool_sQlink		*nl;
  sub_sClient 		*sclip;
  gdb_sNode 		*np;
  item_sTableHeader 	th;
  int			sts;
  ItemTableHeader	*item_header;
  item_sTable 		t;
  item_sTableSubid	ts;

  brow_pop();
  brow_SetNodraw( brow->ctx);

  t.elem_cnt = 0;
  t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;

  // Local
  strcpy( t.elem[t.elem_cnt].fix_str, "Local:");
  t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

  t.elem[t.elem_cnt].value_p = &gdbroot->my_node->subc_lc;
  t.elem[t.elem_cnt].type_id = pwr_eType_UInt32;
  t.elem[t.elem_cnt].size = sizeof(gdbroot->my_node->subc_lc);
  strcpy( t.elem[t.elem_cnt++].format, "%8d");

  // Remote
  strcpy( t.elem[t.elem_cnt].fix_str, "Remote:");
  t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

  t.elem[t.elem_cnt].value_p = &xnav_subcli_remote_cnt;
  t.elem[t.elem_cnt].type_id = pwr_eType_UInt32;
  t.elem[t.elem_cnt].size = sizeof(xnav_subcli_remote_cnt);
  strcpy( t.elem[t.elem_cnt++].format, "%8d");

  // Unknown
  strcpy( t.elem[t.elem_cnt].fix_str, "Unknown:");
  t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

  t.elem[t.elem_cnt].value_p = &gdbroot->no_node->subc_lc;
  t.elem[t.elem_cnt].type_id = pwr_eType_UInt32;
  t.elem[t.elem_cnt].size = sizeof(gdbroot->no_node->subc_lc);
  strcpy( t.elem[t.elem_cnt++].format, "%8d");

  ts.subid_cnt = 0;
  new ItemTable( brow, this, pwr_cNObjid, &t, &ts, -1, 0, 0, 0, NULL, 
		flow_eDest_IntoLast);

  th.table_cnt = 0;
  strcpy( th.title[th.table_cnt++], "Subid");
  strcpy( th.title[th.table_cnt++], "Time");
  strcpy( th.title[th.table_cnt++], "Count");
  strcpy( th.title[th.table_cnt++], "Node");
  strcpy( th.title[th.table_cnt++], "Size");
  strcpy( th.title[th.table_cnt++], "Attribute");
  item_header = new ItemTableHeader( brow, this, "Title", &th,  NULL, flow_eDest_IntoLast);
  item_header->add_bc( xnav_show_subcli_scan, NULL);

  xnav_subcli_remote_cnt = 0;
  gdb_ScopeLock {
    for (
	  nl = pool_Qsucc(&sts, gdbroot->pool, &gdbroot->db->nod_lh);
	  nl != &gdbroot->db->nod_lh;
	  nl = pool_Qsucc(&sts, gdbroot->pool, nl)) 
    {
      np = pool_Qitem(nl, gdb_sNode, nod_ll);
      for (
	    sl = pool_Qsucc(&sts, gdbroot->pool, &np->subc_lh);
	    sl != &np->subc_lh;
	    sl = pool_Qsucc(&sts, gdbroot->pool, sl))
      {
        sclip = pool_Qitem(sl, sub_sClient, subc_ll);
        xnav_show_subcli_insert( this, np, sclip);
      }
      if ( !(np == gdbroot->my_node || np == gdbroot->no_node))
        xnav_subcli_remote_cnt += np->subc_lc;
    }
  } gdb_ScopeUnlock;

  brow_ResetNodraw( brow->ctx);
  brow_Redraw( brow->ctx, 0);
  force_trace_scan();
  return XNAV__SUCCESS;
}

static int xnav_show_subcli_insert( XNav *xnav, gdb_sNode *np,
		sub_sClient *sclip)
{
  item_sTable 		t;
  item_sTableSubid	ts;
  ItemTable		*item;
  static int 		zero = 0;
  char			astr[80];
  net_sSubData 		*sdatap;
  int			sts;

  t.elem_cnt = 0;

  // Subid
  t.elem[t.elem_cnt].value_p = &sclip->sid;
  t.elem[t.elem_cnt].type_id = pwr_eType_RefId;
  t.elem[t.elem_cnt].size = sizeof(sclip->sid);
  strcpy( t.elem[t.elem_cnt++].format, "%8d");

  // Time
  t.elem[t.elem_cnt].value_p = &sclip->lastupdate;
  t.elem[t.elem_cnt].type_id = xnav_eType_ShortTime;
  t.elem[t.elem_cnt++].size = sizeof(sclip->lastupdate);

  // Count
  t.elem[t.elem_cnt].value_p = &sclip->count;
  t.elem[t.elem_cnt].type_id = pwr_eType_UInt32;
  t.elem[t.elem_cnt].size = sizeof(sclip->count);
  strcpy( t.elem[t.elem_cnt++].format, "%8d");

  // Node
  if ( sclip->nid == pwr_cNNodeId)
    strcpy( t.elem[t.elem_cnt].fix_str, "Unknown");
  else
    strcpy( t.elem[t.elem_cnt].fix_str, np->name);
  t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

  // Size
  sdatap = (net_sSubData *) pool_Address( &sts, gdbroot->pool, sclip->subdata);
  if (sdatap == NULL)
    t.elem[t.elem_cnt].value_p = &zero;
  else
    t.elem[t.elem_cnt].value_p = &sdatap->size;
  t.elem[t.elem_cnt].type_id = pwr_eType_UInt16;
  t.elem[t.elem_cnt].size = sizeof(pwr_tUInt16);
  strcpy( t.elem[t.elem_cnt++].format, "%8hd");

  // Name
  if (sclip->sub_by_name)
    strcpy( t.elem[t.elem_cnt].fix_str, sclip->name);
  else 
  {
    if ( sclip->aref.Flags.b.Indirect)
      strcpy( astr, "@");
    else
      strcpy( astr, "");
    cdh_ArefToString( astr, &sclip->aref, 1);
    strcpy( t.elem[t.elem_cnt].fix_str, astr);
  }
  t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

  ts.subid_cnt = 0;
  item = new ItemTable( xnav->brow, xnav, pwr_cNObjid, &t, &ts, -1, 0, 0, 0, NULL, 
		flow_eDest_IntoLast);
  item->found = 1;
  return XNAV__SUCCESS;
}

extern "C" void xnav_show_subcli_scan( XNav *xnav)
{
  brow_tObject	*node_list;
  brow_tObject	*object_p;
  int		node_cnt;
  ItemTable	*item;
  int		i;
  pool_sQlink	*sl;
  pool_sQlink	*nl;
  sub_sClient 	*sclip;
  gdb_sNode 	*np;
  int		sts;
  int		found;
  int		change_detected = 0;

  brow_SetNodraw( xnav->brow->ctx);
  brow_GetObjectList( xnav->brow->ctx, &node_list, &node_cnt);

  // Reset found
  object_p = node_list + 2;
  for ( i = 2; i < node_cnt; i++)
  {    
    brow_GetUserData( *object_p, (void **)&item);
    item->found = 0;
    object_p++;    
  }

  xnav_subcli_remote_cnt = 0;
  gdb_ScopeLock {
    for (
	  nl = pool_Qsucc(&sts, gdbroot->pool, &gdbroot->db->nod_lh);
	  nl != &gdbroot->db->nod_lh;
	  nl = pool_Qsucc(&sts, gdbroot->pool, nl)) 
    {
      np = pool_Qitem(nl, gdb_sNode, nod_ll);
      for (
	    sl = pool_Qsucc(&sts, gdbroot->pool, &np->subc_lh);
	    sl != &np->subc_lh;
	    sl = pool_Qsucc(&sts, gdbroot->pool, sl))
      {
        sclip = pool_Qitem(sl, sub_sClient, subc_ll);

        object_p = node_list + 2;
        found = 0;
        for ( i = 1; i < node_cnt; i++)
        {    
          brow_GetUserData( *object_p, (void **)&item);
          if ( memcmp( item->col.elem[0].value_p, &sclip->sid, sizeof(pwr_tSubid))
		 == 0)
          {
            found = 1;
            break;
          }		
          object_p++;
        }
        if ( !found)
        {
          xnav_show_subcli_insert( xnav, np, sclip);
          change_detected = 1;
        }
        else
          item->found = 1;
      }
      if ( !(np == gdbroot->my_node || np == gdbroot->no_node))
        xnav_subcli_remote_cnt += np->subc_lc;
    }
  } gdb_ScopeUnlock;

  // Remove all that were not found
  object_p = node_list + 2;
  for ( i = 2; i < node_cnt; i++)
  {    
    brow_GetUserData( *object_p, (void **)&item);
    if ( ! item->found)
    {
      brow_DeleteNode( xnav->brow->ctx, item->node);
      change_detected = 1;
    }
    else
      object_p++;
  }
  brow_ResetNodraw( xnav->brow->ctx);
  if ( change_detected)
    brow_Redraw( xnav->brow->ctx, 0);
}


int XNav::show_device()
{
  item_sTableHeader 	th;
  item_sTable 		t;
  item_sTableSubid	ts;
  pwr_tTypeId		attrtype;
  unsigned int		attrsize, attroffs, attrelem;
  pwr_tSubid		subid;
  pwr_tOName   		object_name;
  pwr_tAName   		attr_name;
  int			sts;
  pwr_tObjid		rack_objid;
  pwr_tObjid		device_objid;
  pwr_sAttrRef		attrref;
  pwr_tClassId		classid;
  pwr_tUInt32		process;
  pwr_tUInt32		address;
  pwr_tObjid		thread_objid;
  char			namebuf[80];
  int			rack_class_cnt;
  pwr_tClassId		*rack_class;
  int			i;
  void			*attr_ptr;

  brow_pop();
  brow_SetNodraw( brow->ctx);

  th.table_cnt = 0;
  strcpy( th.title[th.table_cnt++], "Device");
  strcpy( th.title[th.table_cnt++], "Class");
  strcpy( th.title[th.table_cnt++], "ErrorCount");
  strcpy( th.title[th.table_cnt++], "Process");
  strcpy( th.title[th.table_cnt++], "PlcThread");
  strcpy( th.title[th.table_cnt++], "Address");
  new ItemTableHeader( brow, this, "Title", &th,  NULL, flow_eDest_IntoLast);

  // Get the rack objects
  sts = io_GetIoTypeClasses( io_eType_Rack, &rack_class, &rack_class_cnt);
  if ( EVEN(sts)) return sts;

  for ( i = 0; i < rack_class_cnt; i++)
  {
    sts = gdh_GetClassList ( rack_class[i], &rack_objid);
    while (ODD(sts))
    {
      // Get all children
      sts = gdh_GetChild( rack_objid, &device_objid);
      while( ODD(sts))
      {

        sts = gdh_ObjidToName ( device_objid, object_name,
			sizeof(object_name), cdh_mName_volumeStrict);
        if ( EVEN(sts)) return sts;


        t.elem_cnt = 0;
        ts.subid_cnt = 0;

        // Object name
	xnav_cut_segments( namebuf, object_name, 2);

        strcpy( t.elem[t.elem_cnt].fix_str, namebuf);
        t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

        // Class name
        sts = gdh_GetObjectClass( device_objid, &classid);
        sts = gdh_ObjidToName( cdh_ClassIdToObjid( classid),
		  namebuf, sizeof(namebuf), cdh_mName_object);
        strcpy( t.elem[t.elem_cnt].fix_str, namebuf);
        t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

        // ErrorCount
        strcpy( attr_name, object_name);
        strcat( attr_name, ".ErrorCount");
        sts = gdh_GetAttributeCharacteristics ( attr_name,
		&attrtype, &attrsize, &attroffs, &attrelem);
        if ( EVEN(sts)) {
          strcpy( t.elem[t.elem_cnt].fix_str, "       -");
	  t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;
	}
	else {
	  sts = gdh_NameToAttrref( pwr_cNObjid, attr_name, &attrref);
	  if ( EVEN(sts)) return sts;

	  sts = gdh_DLRefObjectInfoAttrref ( &attrref, &attr_ptr, &subid);
	  if ( EVEN(sts)) return sts;

	  t.elem[t.elem_cnt].value_p = attr_ptr;
	  t.elem[t.elem_cnt].type_id = attrtype;
	  t.elem[t.elem_cnt].size = attrsize;
	  strcpy( t.elem[t.elem_cnt++].format, "%8d");
	  ts.subid[ts.subid_cnt++] = subid;
	}

        // Process
        strcpy( attr_name, object_name);
        strcat( attr_name, ".Process");
        sts = gdh_GetObjectInfo( attr_name,
		(void *) &process, sizeof(process));
        if ( ODD(sts))
          sprintf( t.elem[t.elem_cnt].fix_str, "%4d", process);
        else
          strcpy( t.elem[t.elem_cnt].fix_str, "-");
        t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

        // ThreadObject
        strcpy( attr_name, object_name);
        strcat( attr_name, ".ThreadObject");
        sts = gdh_GetObjectInfo( attr_name,
		(void *) &thread_objid, sizeof(thread_objid));
        if ( ODD(sts))
        {
          sts = gdh_ObjidToName ( thread_objid, namebuf,
			sizeof(namebuf), cdh_mName_object);
          if ( ODD(sts))
            strcpy( t.elem[t.elem_cnt].fix_str, namebuf);
          else
            strcpy( t.elem[t.elem_cnt].fix_str, "-");
        }
        else
          strcpy( t.elem[t.elem_cnt].fix_str, "-");
        t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

        // RegAddress
        strcpy( attr_name, object_name);
        strcat( attr_name, ".RegAddress");
        sts = gdh_GetObjectInfo( attr_name,
		(void *) &address, sizeof(address));
        if ( ODD(sts))
          sprintf( t.elem[t.elem_cnt].fix_str, "%d", address);
        else
          strcpy( t.elem[t.elem_cnt].fix_str, "-");
        t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

        new ItemDevice( brow, this, device_objid, &t, &ts, -1, 0, 0, 0, 
		NULL, flow_eDest_IntoLast);
        sts = gdh_GetNextSibling ( device_objid, &device_objid);
      }
      sts = gdh_GetNextObject ( rack_objid, &rack_objid);
    }
  }
  free( (char *)rack_class);

  brow_ResetNodraw( brow->ctx);
  brow_Redraw( brow->ctx, 0);
  force_trace_scan();
  return XNAV__SUCCESS;
}

static void xnav_channel_get_flags( void *cardp, void *chanp, 
				    pwr_tCid card_cid, pwr_tCid chan_cid,
				    int *conv, int *inv, int *teston)
{
  switch ( card_cid) {
  case pwr_cClass_Ssab_DI32D: {
    pwr_sClass_Ssab_BaseDiCard *cp = (pwr_sClass_Ssab_BaseDiCard *)cardp;
    pwr_tMask mask;
    unsigned int chan_idx;

    chan_idx = ((char *)chanp - (char *)cp - pwr_AlignLW(sizeof(pwr_sClass_Ssab_BaseDiCard))) / pwr_AlignLW(sizeof(pwr_sClass_ChanDi));
    if ( chan_idx < 16) {
      mask = 1 << chan_idx;
      *conv = cp->ConvMask1 & mask ? 1 : 0;
      *inv = cp->InvMask1 & mask ? 1 : 0;
      *teston = 0;
    }
    else if ( chan_idx < 32) {
      mask = 1 << (chan_idx - 16);
      *conv = cp->ConvMask2 & mask ? 1 : 0;
      *inv = cp->InvMask2 & mask ? 1 : 0;
      *teston = 0;
    }    
    break;
  }
  case pwr_cClass_Ssab_DO32DKS:
  case pwr_cClass_Ssab_DO32DKS_Stall: {
    pwr_sClass_Ssab_BaseDoCard *cp = (pwr_sClass_Ssab_BaseDoCard *)cardp;
    pwr_tMask mask;
    unsigned int chan_idx;

    chan_idx = ((char *)chanp - (char *)cp - pwr_AlignLW(sizeof(pwr_sClass_Ssab_BaseDoCard))) / pwr_AlignLW(sizeof(pwr_sClass_ChanDo));
    if ( chan_idx < 16) {
      mask = 1 << chan_idx;
      *conv = 1;
      *inv = cp->InvMask1 & mask ? 1 : 0;
      *teston = cp->TestMask1 & mask ? 1: 0;
    }
    else if ( chan_idx < 32) {
      mask = 1 << (chan_idx - 16);
      *conv = 1;
      *inv = cp->InvMask2 & mask ? 1 : 0;
      *teston = cp->TestMask2 & mask ? 1: 0;
    }    
    break;
  }
  default: {
    switch ( chan_cid) {
    case pwr_cClass_ChanDi: {
      pwr_sClass_ChanDi *cp = (pwr_sClass_ChanDi *)chanp;

      *inv = cp->InvertOn;
      *conv = cp->ConversionOn;
      *teston = 0;
      break;
    }
    case pwr_cClass_ChanDo: {
      pwr_sClass_ChanDo *cp = (pwr_sClass_ChanDo *)chanp;

      *inv = cp->InvertOn;
      *conv = 1;
      *teston = cp->TestOn;
      break;
    }
    case pwr_cClass_ChanD: {
      pwr_sClass_ChanD *cp = (pwr_sClass_ChanD *)chanp;
      
      *inv = cp->InvertOn;
      *conv = cp->ConversionOn;
      *teston = cp->TestOn;
      break;
    }
    case pwr_cClass_ChanIi: {
      pwr_sClass_ChanIi *cp = (pwr_sClass_ChanIi *)chanp;
      
      *inv = 0;
      *conv = cp->ConversionOn;
      *teston = 0;
      break;
    }
    case pwr_cClass_ChanIo: {
      pwr_sClass_ChanIo *cp = (pwr_sClass_ChanIo *)chanp;
      
      *inv = 0;
      *conv = 1;
      *teston = cp->TestOn;
      break;
    }
    case pwr_cClass_ChanAi: {
      pwr_sClass_ChanAi *cp = (pwr_sClass_ChanAi *)chanp;
      
      *inv = 0;
      *conv = cp->ConversionOn;
      *teston = 0;
      break;
    }
    case pwr_cClass_ChanAit: {
      pwr_sClass_ChanAit *cp = (pwr_sClass_ChanAit *)chanp;
      
      *inv = 0;
      *conv = cp->ConversionOn;
      *teston = 0;
      break;
    }
    case pwr_cClass_ChanAo: {
      pwr_sClass_ChanAo *cp = (pwr_sClass_ChanAo *)chanp;
      
      *inv = 0;
      *conv = 1;
      *teston = cp->TestOn;
      break;
    }
    case pwr_cClass_ChanBi: {
      pwr_sClass_ChanBi *cp = (pwr_sClass_ChanBi *)chanp;
      
      *inv = 0;
      *conv = cp->ConversionOn;
      *teston = 0;
      break;
    }
    case pwr_cClass_ChanBo:
    case pwr_cClass_ChanBiBlob:
    case pwr_cClass_ChanBoBlob:
      *inv = 0;
      *conv = 1;
      *teston = 0;
      break;
    }
  }
  }
}

static void xnav_show_channels_scan( XNav *xnav)
{
  brow_tObject	*node_list;
  int		node_cnt;
  ItemTable	*item;
  int		i;
  int		conv, inv, teston;
  flow_sAnnotPixmap *pixmap;

  brow_GetObjectList( xnav->brow->ctx, &node_list, &node_cnt);

  for ( i = 1; i < node_cnt; i++) {    
    brow_GetUserData( node_list[i], (void **)&item);

    if ( item->type == xnav_eItemType_Channel) {
      xnav_channel_get_flags( ((tab_sChannelFlagsData *)item->col.user)->cardp,
			      ((tab_sChannelFlagsData *)item->col.user)->chanp,
			      ((tab_sChannelFlagsData *)item->col.user)->card_cid,
			      ((tab_sChannelFlagsData *)item->col.user)->chan_cid,
			      &conv, &inv, &teston);

      strcpy( (char *)item->col.elem[2].value_p, "");
      if ( !conv)
	strcat( (char *)item->col.elem[2].value_p, "Off ");
      if ( inv)
	strcat( (char *)item->col.elem[2].value_p, "Inv ");
      if ( teston)
	strcat( (char *)item->col.elem[2].value_p, "Test ");

      brow_GetAnnotPixmap( node_list[i], 1, &pixmap);
      if ( !conv) {
	brow_GetAnnotPixmap( node_list[i], 1, &pixmap);
	if ( pixmap != xnav->brow->pixmap_offline)
	  brow_SetAnnotPixmap( node_list[i], 1, xnav->brow->pixmap_offline);
      }
      else if ( teston) {
	if ( pixmap != xnav->brow->pixmap_teston)
	  brow_SetAnnotPixmap( node_list[i], 1, xnav->brow->pixmap_teston);
      }
      else if ( inv) {
	if ( pixmap != xnav->brow->pixmap_inverted)
	  brow_SetAnnotPixmap( node_list[i], 1, xnav->brow->pixmap_inverted);
      }
      else {
	if ( pixmap == xnav->brow->pixmap_offline ||
	     pixmap == xnav->brow->pixmap_teston ||
	     pixmap == xnav->brow->pixmap_inverted)
	  brow_RemoveAnnotPixmap( node_list[i], 1);
      }
    }
  }
}

static void xnav_show_channels_close( XNav *xnav)
{
  brow_tObject	*node_list;
  int		node_cnt;
  ItemTable	*item;
  int		i;

  brow_GetObjectList( xnav->brow->ctx, &node_list, &node_cnt);

  for ( i = 1; i < node_cnt; i++) {    
    brow_GetUserData( node_list[i], (void **)&item);
    if ( item->type == xnav_eItemType_Channel) {
      free( item->col.elem[2].value_p);
      free( item->col.user);
    }
  }
}

int XNav::show_channels( pwr_tObjid card_objid)
{
  item_sTableHeader 	th;
  item_sTable 		t;
  item_sTableSubid	ts;
  pwr_tTypeId		attrtype;
  unsigned int		attrsize, attroffs, attrelem;
  pwr_tSubid		subid;
  pwr_tSubid		card_subid;
  pwr_tOName   		object_name;
  pwr_tAName   		attr_name;
  int			sts;
  pwr_tObjid		chan_objid;
  pwr_sAttrRef		attrref;
  pwr_sAttrRef		signal_aref;
  char			descr[80];
  char			namebuf[80];
  void			*attr_ptr;
  ItemChannel		*item;
  pwr_tCid		chan_cid;
  pwr_tCid		card_cid;
  pwr_tAName   		signal_name;
  int			child_found = 0;
  ItemTableHeader      	*item_header;
  void 			*cardp;
  void			*chanp;
  pwr_tAttrRef		aref;

  brow_pop();
  brow_SetNodraw( brow->ctx);

  th.table_cnt = 0;
  strcpy( th.title[th.table_cnt++], "Channel");
  strcpy( th.title[th.table_cnt++], "Value");
  strcpy( th.title[th.table_cnt++], "Flags");
  strcpy( th.title[th.table_cnt++], "Signal");
  strcpy( th.title[th.table_cnt++], "");
  strcpy( th.title[th.table_cnt++], "");
  strcpy( th.title[th.table_cnt++], "");
  strcpy( th.title[th.table_cnt++], "Description");
  item_header = new ItemTableHeader( brow, this, "Title", &th,  NULL, flow_eDest_IntoLast);
  item_header->add_bc( xnav_show_channels_scan, xnav_show_channels_close);

  sts = gdh_GetObjectClass( card_objid, &card_cid);
  if ( EVEN(sts)) return sts;

  aref = cdh_ObjidToAref( card_objid);
  sts = gdh_DLRefObjectInfoAttrref( &aref, &cardp, &card_subid);
  if ( EVEN(sts)) return sts;

  // Get all children
  sts = gdh_GetChild( card_objid, &chan_objid);
  while( ODD(sts)) {
    child_found = 1;

    t.elem_cnt = 0;
    ts.subid_cnt = 0;

    sts = gdh_ObjidToName( chan_objid, object_name,
			sizeof(object_name), cdh_mName_volumeStrict);
    if ( EVEN(sts)) return sts;

    sts = gdh_GetObjectClass( chan_objid, &chan_cid);
    if ( EVEN(sts)) return sts;

    aref = cdh_ObjidToAref( chan_objid);
    sts = gdh_DLRefObjectInfoAttrref( &aref, &chanp, &subid);
    if ( EVEN(sts)) return sts;

    ts.subid[ts.subid_cnt++] = subid;
    if ( card_subid.nid != 0) {
      ts.subid[ts.subid_cnt++] = card_subid;
      card_subid = pwr_cNSubid;
    }

    t.user = calloc( 1, sizeof(tab_sChannelFlagsData));
    ((tab_sChannelFlagsData *)t.user)->chanp = chanp;
    ((tab_sChannelFlagsData *)t.user)->cardp = cardp;
    ((tab_sChannelFlagsData *)t.user)->card_cid = card_cid;
    ((tab_sChannelFlagsData *)t.user)->chan_cid = chan_cid;

    // Get connected signal
    strcpy( attr_name, object_name);
    strcat( attr_name, ".SigChanCon");
    sts = gdh_GetObjectInfo( attr_name,
		(void *) &signal_aref, sizeof(signal_aref));
    if ( ODD(sts)) {
      sts = gdh_AttrrefToName( &signal_aref, signal_name,
			       sizeof(signal_name), cdh_mNName);
      if ( EVEN(sts)) {
        signal_aref.Objid = pwr_cNObjid;
        strcpy( signal_name, "-");
      }
    }
    else
      signal_aref.Objid = pwr_cNObjid;

    // Object name
    xnav_cut_segments( namebuf, object_name, 2);

    strcpy( t.elem[t.elem_cnt].fix_str, namebuf);
    t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

    // Value
    if ( cdh_ObjidIsNotNull( signal_aref.Objid) &&
	 !(chan_cid == pwr_cClass_ChanBi ||
	   chan_cid == pwr_cClass_ChanBo ||
	   chan_cid == pwr_cClass_ChanBiBlob ||
	   chan_cid == pwr_cClass_ChanBiBlob)) {
      strcpy( attr_name, signal_name);
      switch( chan_cid)
      {
        case pwr_cClass_ChanDi:
        case pwr_cClass_ChanDo:
        case pwr_cClass_ChanD:
        case pwr_cClass_ChanAi:
        case pwr_cClass_ChanAo:
        case pwr_cClass_ChanIi:
        case pwr_cClass_ChanIo:
          strcat( attr_name, ".ActualValue");
          break;
        case pwr_cClass_ChanCo:
          strcat( attr_name, ".RawValue");
          break;
      }
      sts = gdh_GetAttributeCharacteristics ( attr_name,
		&attrtype, &attrsize, &attroffs, &attrelem);
      if ( EVEN(sts)) return sts;

      sts = gdh_NameToAttrref( pwr_cNObjid, attr_name, &attrref);
      if ( EVEN(sts)) return sts;

      sts = gdh_DLRefObjectInfoAttrref( &attrref, &attr_ptr, &subid);
      if ( EVEN(sts)) return sts;

      t.elem[t.elem_cnt].value_p = attr_ptr;
      t.elem[t.elem_cnt].type_id = attrtype;
      t.elem[t.elem_cnt].size = attrsize;

      switch( chan_cid) {
      case pwr_cClass_ChanDi:
      case pwr_cClass_ChanDo:
      case pwr_cClass_ChanD:
      case pwr_cClass_ChanIi:
      case pwr_cClass_ChanIo:
      case pwr_cClass_ChanCo:
	strcpy( t.elem[t.elem_cnt++].format, "%8d");
	break;
      case pwr_cClass_ChanAi:
      case pwr_cClass_ChanAo:
	strcpy( t.elem[t.elem_cnt++].format, "%f");
	break;
      default:
	t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;
      }
      ts.subid[ts.subid_cnt++] = subid;
    }
    else
      t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;

    // Flags
    t.elem[t.elem_cnt].value_p = calloc( 1, sizeof(pwr_tString80));
    t.elem[t.elem_cnt].size = sizeof(pwr_tString80);
    // t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;
    strcpy( t.elem[t.elem_cnt].format, "%s");
    t.elem[t.elem_cnt++].type_id = pwr_eType_String;

    // Signal
    if ( cdh_ObjidIsNotNull( signal_aref.Objid))
    {
      strcpy( t.elem[t.elem_cnt].fix_str, signal_name);
    }
    else
      strcpy( t.elem[t.elem_cnt].fix_str, "-");
    t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;


    // Description in signal
    t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;
    t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;
    t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;

    if ( cdh_ObjidIsNotNull( signal_aref.Objid))
      strcpy( attr_name, signal_name);
    else
      strcpy( attr_name, object_name);
    strcat( attr_name, ".Description");
    sts = gdh_GetObjectInfo( attr_name,
		(void *) &descr, sizeof(descr));
    if ( EVEN(sts)) return sts;

    strcpy( t.elem[t.elem_cnt].fix_str, descr);
    t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

    item = new ItemChannel( brow, this, chan_objid, &t, &ts, -1, 0, 0, 1, 
		NULL, flow_eDest_IntoLast);
    item->signal_aref = signal_aref;

    sts = gdh_GetNextSibling ( chan_objid, &chan_objid);
  }

  // Get all intern channels
  if ( !child_found) {
    pwr_tAttrRef card_aref = cdh_ObjidToAref( card_objid);

    sts = show_attr_channels( &card_aref, cardp, &card_subid, card_cid);
    if ( EVEN(sts)) return sts;
  }
	  
  brow_ResetNodraw( brow->ctx);
  brow_Redraw( brow->ctx, 0);
  force_trace_scan();
  return XNAV__SUCCESS;
}


int XNav::show_attr_channels( pwr_tAttrRef *mod_aref, void *cardp, pwr_tSubid *card_subid,
			      pwr_tCid card_cid)
{
  gdh_sAttrDef *bd;
  int rows;
  int i;
  int elem;
  pwr_tCid cid;
  pwr_tAName mod_name;
  int sts;
  item_sTable 		t;
  item_sTableSubid	ts;
  pwr_tTypeId		attrtype;
  unsigned int		attrsize, attroffs, attrelem;
  pwr_tSubid		subid;
  pwr_tOName   		object_name;
  pwr_tAName   		attr_name;
  pwr_sAttrRef		attrref;
  pwr_sAttrRef		signal_aref;
  char			descr[80];
  char			namebuf[80];
  void			*attr_ptr;
  ItemChannel		*item;
  pwr_tCid		chan_cid;
  pwr_tAName   		signal_name;
  pwr_tAttrRef		aref;
  void 			*chanp;

  sts = gdh_GetAttrRefTid( mod_aref, &cid);
  if ( EVEN(sts)) return sts;

  sts = gdh_AttrrefToName( mod_aref, mod_name, sizeof(mod_name), cdh_mName_volumeStrict);
  if ( EVEN(sts)) return sts;
  
  sts = gdh_GetObjectBodyDef( cid, &bd, &rows, pwr_cNObjid);
  if ( EVEN(sts)) return sts;

  for ( i = 0; i < rows; i++) {
    
    switch ( bd[i].attr->Param.TypeRef) {
    case pwr_cClass_ChanAi:
    case pwr_cClass_ChanAit:
    case pwr_cClass_ChanAo:
    case pwr_cClass_ChanDi:
    case pwr_cClass_ChanDo:
    case pwr_cClass_ChanD:
    case pwr_cClass_ChanIi:
    case pwr_cClass_ChanIo:
    case pwr_cClass_ChanCo:
    case pwr_cClass_ChanBo:
    case pwr_cClass_ChanBi:
    case pwr_cClass_ChanBoBlob:
    case pwr_cClass_ChanBiBlob:
      break;
    default:
      if ( bd[i].attr->Param.Info.Flags & PWR_MASK_CLASS) {
	// This could be an IO module object, look for channels
	pwr_sAttrRef aref;

	gdh_ArefANameToAref( mod_aref, bd[i].attrName, &aref);
	
	sts = show_attr_channels( &aref, cardp, card_subid, card_cid);
	if ( EVEN(sts)) return sts;
      }
      continue;
    }

    chan_cid = bd[i].attr->Param.TypeRef;
    
    if ( bd[i].attr->Param.Info.Flags & PWR_MASK_ARRAY)
      elem = bd[i].attr->Param.Info.Elements;
    else
      elem = 1;

    for ( int j = 0; j < elem; j++) {

      t.elem_cnt = 0;
      ts.subid_cnt = 0;
      
      if ( elem == 1) {
	strcpy( object_name, mod_name);
	strcat( object_name, ".");
	strcat( object_name, bd[i].attrName);
      }
      else {
	sprintf( object_name, "%s.%s[%d]", mod_name, bd[i].attrName, j);
      }
	
      sts = gdh_NameToAttrref( pwr_cNOid, object_name, &aref);
      if ( EVEN(sts)) return sts;

      sts = gdh_DLRefObjectInfoAttrref( &aref, &chanp, &subid);
      if ( EVEN(sts)) return sts;

      ts.subid[ts.subid_cnt++] = subid;
      if ( card_subid->nid != 0) {
	ts.subid[ts.subid_cnt++] = *card_subid;
	*card_subid = pwr_cNSubid;
      }

      t.user = calloc( 1, sizeof(tab_sChannelFlagsData));
      ((tab_sChannelFlagsData *)t.user)->chanp = chanp;
      ((tab_sChannelFlagsData *)t.user)->cardp = cardp;
      ((tab_sChannelFlagsData *)t.user)->card_cid = card_cid;
      ((tab_sChannelFlagsData *)t.user)->chan_cid = chan_cid;

      // Get connected signal
      strcpy( attr_name, object_name);
      strcat( attr_name, ".SigChanCon");
      sts = gdh_GetObjectInfo( attr_name,
			       (void *) &signal_aref, sizeof(signal_aref));
      if ( ODD(sts)) {
	sts = gdh_AttrrefToName( &signal_aref, signal_name,
				 sizeof(signal_name), cdh_mNName);
	if ( EVEN(sts)) {
	  signal_aref.Objid = pwr_cNObjid;
	  strcpy( signal_name, "-");
	}
      }
      else
	signal_aref.Objid = pwr_cNObjid;
      
      // Object name
      xnav_cut_segments( namebuf, object_name, 2);

      strcpy( t.elem[t.elem_cnt].fix_str, namebuf);
      t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

      // Value
      if ( cdh_ObjidIsNotNull( signal_aref.Objid) &&
	   !(chan_cid == pwr_cClass_ChanBi ||
	     chan_cid == pwr_cClass_ChanBo ||
	     chan_cid == pwr_cClass_ChanBiBlob ||
	     chan_cid == pwr_cClass_ChanBiBlob)) {
	strcpy( attr_name, signal_name);
	switch( chan_cid) {
	case pwr_cClass_ChanDi:
	case pwr_cClass_ChanDo:
	case pwr_cClass_ChanD:
	case pwr_cClass_ChanAi:
	case pwr_cClass_ChanAo:
	case pwr_cClass_ChanIi:
	case pwr_cClass_ChanIo:
	  strcat( attr_name, ".ActualValue");
	  break;
	case pwr_cClass_ChanCo:
	  strcat( attr_name, ".RawValue");
	  break;
	}
	sts = gdh_GetAttributeCharacteristics ( attr_name,
		&attrtype, &attrsize, &attroffs, &attrelem);
	if ( EVEN(sts)) return sts;

	sts = gdh_NameToAttrref( pwr_cNObjid, attr_name, &attrref);
	if ( EVEN(sts)) return sts;

	sts = gdh_DLRefObjectInfoAttrref ( &attrref, &attr_ptr, &subid);
	if ( EVEN(sts)) return sts;

	t.elem[t.elem_cnt].value_p = attr_ptr;
	t.elem[t.elem_cnt].type_id = attrtype;
	t.elem[t.elem_cnt].size = attrsize;
	
	switch( chan_cid) {
	case pwr_cClass_ChanDi:
	case pwr_cClass_ChanDo:
	case pwr_cClass_ChanD:
	case pwr_cClass_ChanIi:
	case pwr_cClass_ChanIo:
	case pwr_cClass_ChanCo:
	  strcpy( t.elem[t.elem_cnt++].format, "%8d");
	  break;
	case pwr_cClass_ChanAi:
	case pwr_cClass_ChanAo:
	  strcpy( t.elem[t.elem_cnt++].format, "%f");
	  break;
	}
	ts.subid[ts.subid_cnt++] = subid;
      }
      else
	t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;

      // Flags
      t.elem[t.elem_cnt].value_p = calloc( 1, sizeof(pwr_tString80));
      t.elem[t.elem_cnt].size = sizeof(pwr_tString80);
      strcpy( t.elem[t.elem_cnt].format, "%s");
      t.elem[t.elem_cnt++].type_id = pwr_eType_String;

      // Signal
      if ( cdh_ObjidIsNotNull( signal_aref.Objid)) {
	strcpy( t.elem[t.elem_cnt].fix_str, signal_name);
      }
      else
	strcpy( t.elem[t.elem_cnt].fix_str, "-");
      t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;


      // Description in signal
      t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;
      t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;
      t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;
	
      if ( cdh_ObjidIsNotNull( signal_aref.Objid))
	strcpy( attr_name, signal_name);
      else
	strcpy( attr_name, object_name);
      strcat( attr_name, ".Description");
      sts = gdh_GetObjectInfo( attr_name,
			       (void *) &descr, sizeof(descr));
      if ( EVEN(sts)) return sts;

      strcpy( t.elem[t.elem_cnt].fix_str, descr);
      t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;
      
      item = new ItemChannel( brow, this, mod_aref->Objid, &t, &ts, -1, 0, 0, 1, 
			      NULL, flow_eDest_IntoLast);
      item->signal_aref = signal_aref;
      
    }
  }
  free( (char *)bd);
  return XNAV__SUCCESS;
}


int XNav::show_object( pwr_tAttrRef *oarp, brow_tNode node)
{
  double	node_x, node_y;

  if ( cdh_ObjidIsNull( oarp->Objid))
    return 1;

  brow_GetNodePosition( node, &node_x, &node_y);

  if ( brow_IsOpen( node) & xnav_mOpen_Attributes)
  {
    // Attributes is open, close
    brow_SetNodraw( brow->ctx);
    brow_CloseNode( brow->ctx, node);
    brow_ResetOpen( node, xnav_mOpen_Attributes);
    brow_RemoveAnnotPixmap( node, 1);
    brow_ResetNodraw( brow->ctx);
    brow_Redraw( brow->ctx, node_y);
  }
  else 
  {
    int			sts;
    Item 		*item;
    pwr_tTypeId		atype;
    unsigned int	asize, aoffset, adim, aflags;

    if ( brow_IsOpen( node) & xnav_mOpen_Children ||
	 brow_IsOpen( node) & xnav_mOpen_Crossref) {
      // Close children first
      brow_SetNodraw( brow->ctx);
      brow_CloseNode( brow->ctx, node);
      brow_ResetOpen( node, xnav_mOpen_Children);
      brow_ResetOpen( node, xnav_mOpen_Crossref);
      brow_SetAnnotPixmap( node, 0, brow->pixmap_map);
      brow_ResetNodraw( brow->ctx);
      brow_Redraw( brow->ctx, node_y);
    }

    sts = gdh_GetAttributeCharAttrref( oarp, &atype, &asize, &aoffset, &adim);

    if ( oarp->Flags.b.Object) {
      item = (Item *)new ItemObject( brow, oarp->Objid, node, flow_eDest_IntoLast, 0);
    }
    else {
      pwr_tAName aname;
      pwr_tOName attrname;
      char *s;

      sts = gdh_AttrrefToName ( oarp, aname, sizeof(aname), cdh_mNName);
      if ( EVEN(sts)) return sts;

      if ( (s = strchr( aname, '.')))
	strcpy( attrname, s+1);

      aflags = PWR_MASK_CLASS;

      item = (Item *) new ItemAttrObject( brow, oarp->Objid, node, 
					  flow_eDest_IntoLast,
					  attrname, atype, asize, aflags, 0, 0);
    }
    brow_SetOpen( node, xnav_mOpen_Attributes);
    brow_SetAnnotPixmap( node, 1, brow->pixmap_openattr);

    item->open_attributes( brow, node_x, node_y);
  }
  return 1;
}

int XNav::show_remnode()
{
  item_sTableHeader 	th;
  item_sTable 		t;
  item_sTableSubid	ts;
  pwr_tOName   		object_name;
  char			id[40];
  char			description[80];
  int			sts;
  pwr_tObjid		objid;
  pwr_tOName   		namebuf;
  pwr_tCid		cid;
  void			*object_ptr;

  brow_pop();
  brow_SetNodraw( brow->ctx);

  th.table_cnt = 0;
  strcpy( th.title[th.table_cnt++], "RemNode");
  strcpy( th.title[th.table_cnt++], "");
  strcpy( th.title[th.table_cnt++], "Type");
  strcpy( th.title[th.table_cnt++], "Description");
  new ItemTableHeader( brow, this, "Title", &th,  NULL, flow_eDest_IntoLast);

  for ( int i = 0; i < 8; i++) {
    switch ( i) {
    case 0: cid = pwr_cClass_RemnodeUDP; break;
    case 1: cid = pwr_cClass_RemnodeTCP; break;
    case 2: cid = pwr_cClass_Remnode3964R; break;
    case 3: cid = pwr_cClass_RemnodeALCM; break;
    case 4: cid = pwr_cClass_RemnodeSerial; break;
    case 5: cid = pwr_cClass_RemnodeModbus; break;
    case 6: cid = pwr_cClass_RemnodeMQ; break;
    case 7: cid = pwr_cClass_RemnodeWMQ; break;
    }

    sts = gdh_GetClassList( cid, &objid);
    while ( ODD(sts)) {
      sts = gdh_ObjidToPointer( objid, (void **) &object_ptr);
      if ( EVEN(sts)) return sts;

      sts = gdh_ObjidToName ( objid, object_name,
			      sizeof(object_name), cdh_mName_volumeStrict);
      if ( EVEN(sts)) return sts;

      switch ( i) {
      case 0: 
	strncpy( id, ((pwr_sClass_RemnodeUDP *)object_ptr)->Id, sizeof(id));
	strncpy( description, ((pwr_sClass_RemnodeUDP *)object_ptr)->Description, 
		 sizeof(description));
	break;
      case 1: 
	strncpy( id, ((pwr_sClass_RemnodeTCP *)object_ptr)->Id, sizeof(id));
	strncpy( description, ((pwr_sClass_RemnodeTCP *)object_ptr)->Description, 
		 sizeof(description));
	break;
      case 2: 
	strncpy( id, ((pwr_sClass_Remnode3964R *)object_ptr)->Id, sizeof(id));
	strncpy( description, ((pwr_sClass_Remnode3964R *)object_ptr)->Description, 
		 sizeof(description));
	break;
      case 3: 
	strncpy( id, ((pwr_sClass_RemnodeALCM *)object_ptr)->Id, sizeof(id));
	strncpy( description, ((pwr_sClass_RemnodeALCM *)object_ptr)->Description, 
		 sizeof(description));
	break;
      case 4: 
	strncpy( id, ((pwr_sClass_RemnodeSerial *)object_ptr)->Id, sizeof(id));
	strncpy( description, ((pwr_sClass_RemnodeSerial *)object_ptr)->Description, 
		 sizeof(description));
	break;
      case 5: 
	strncpy( id, ((pwr_sClass_RemnodeModbus *)object_ptr)->Id, sizeof(id));
	strncpy( description, ((pwr_sClass_RemnodeModbus *)object_ptr)->Description, 
		 sizeof(description));
	break;
      case 6: 
	strncpy( id, ((pwr_sClass_RemnodeMQ *)object_ptr)->Id, sizeof(id));
	strncpy( description, ((pwr_sClass_RemnodeMQ *)object_ptr)->Description, 
		 sizeof(description));
	break;
      case 7: 
	strncpy( id, ((pwr_sClass_RemnodeWMQ *)object_ptr)->Id, sizeof(id));
	strncpy( description, ((pwr_sClass_RemnodeWMQ *)object_ptr)->Description, 
		 sizeof(description));
	break;
      }

      t.elem_cnt = 0;

      // Object name
      xnav_cut_segments( namebuf, object_name, 2);

      strcpy( t.elem[t.elem_cnt].fix_str, namebuf);
      t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

      t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;
      
      // Type
      strcpy( t.elem[t.elem_cnt].fix_str, id);
      t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

      // Description
      strcpy( t.elem[t.elem_cnt].fix_str, description);
      t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

      ts.subid_cnt = 0;
      new ItemRemNode( brow, this, objid, &t, &ts, -1, 0, 0, 1, NULL, flow_eDest_IntoLast);

      sts = gdh_GetNextObject ( objid, &objid);
    }
  }

  brow_ResetNodraw( brow->ctx);
  brow_Redraw( brow->ctx, 0);
  force_trace_scan();
  return XNAV__SUCCESS;
}

int XNav::show_remtrans( pwr_tObjid remnode_objid)
{
  item_sTableHeader 	th;
  item_sTable 		t;
  item_sTableSubid	ts;
  pwr_tTypeId		attrtype;
  unsigned int		attrsize, attroffs, attrelem;
  pwr_tSubid		subid;
  pwr_tOName   		object_name;
  pwr_tAName   		attr_name;
  int			sts;
  pwr_tObjid		objid;
  pwr_sAttrRef		attrref;
  pwr_sClass_RemTrans	*object_ptr;
  pwr_tOName   		namebuf;
  pwr_tCid		cid;

  brow_pop();
  brow_SetNodraw( brow->ctx);

  th.table_cnt = 0;
  strcpy( th.title[th.table_cnt++], "RemTrans");
  strcpy( th.title[th.table_cnt++], "");
  strcpy( th.title[th.table_cnt++], "DataValid");
  strcpy( th.title[th.table_cnt++], "Direction");
  strcpy( th.title[th.table_cnt++], "TransCnt");
  strcpy( th.title[th.table_cnt++], "TransTime");
  strcpy( th.title[th.table_cnt++], "");
  strcpy( th.title[th.table_cnt++], "ErrCount");
  strcpy( th.title[th.table_cnt++], "LastSts");
  new ItemTableHeader( brow, this, "Title", &th,  NULL, flow_eDest_IntoLast);

  if ( cdh_ObjidIsNull( remnode_objid))
    sts = gdh_GetClassList ( pwr_cClass_RemTrans, &objid);
  else
    sts = gdh_GetChild( remnode_objid, &objid);
  while ( ODD(sts)) {
    sts = gdh_GetObjectClass( objid, &cid);
    if ( EVEN(sts)) return sts;

    if ( cid == pwr_cClass_RemTrans) {
      memset( &attrref, 0, sizeof( attrref));
      attrref.Objid = objid;
      sts = gdh_DLRefObjectInfoAttrref ( &attrref,
					 (pwr_tAddress *) &object_ptr,
					 &subid);
      if ( EVEN(sts)) return sts;

      sts = gdh_ObjidToName ( objid, object_name,
			      sizeof(object_name), cdh_mName_volumeStrict);
      if ( EVEN(sts)) return sts;

      t.elem_cnt = 0;

      // Object name
      xnav_cut_segments( namebuf, object_name, 1);

      strcpy( t.elem[t.elem_cnt].fix_str, namebuf);
      t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

      t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;

      // DataValid
      strcpy( attr_name, object_name);
      strcat( attr_name, ".DataValid");
      sts = gdh_GetAttributeCharacteristics ( attr_name,
					      &attrtype, &attrsize, &attroffs, &attrelem);
      if ( EVEN(sts)) return sts;

      t.elem[t.elem_cnt].value_p = &object_ptr->DataValid;
      t.elem[t.elem_cnt].type_id = attrtype;
      t.elem[t.elem_cnt].size = attrsize;
      strcpy( t.elem[t.elem_cnt++].format, "%2d");

      // Direction
      switch( object_ptr->Direction)
	{
	case 1:
	  strcpy( t.elem[t.elem_cnt].fix_str, "Rcv");
	  break;
	case 2:
	  strcpy( t.elem[t.elem_cnt].fix_str, "Snd");
	  break;
	}
      t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

      // TransCount
      strcpy( attr_name, object_name);
      strcat( attr_name, ".TransCount");
      sts = gdh_GetAttributeCharacteristics ( attr_name,
					      &attrtype, &attrsize, &attroffs, &attrelem);
      if ( EVEN(sts)) return sts;

      t.elem[t.elem_cnt].value_p = &object_ptr->TransCount;
      t.elem[t.elem_cnt].type_id = attrtype;
      t.elem[t.elem_cnt].size = attrsize;
      strcpy( t.elem[t.elem_cnt++].format, "%2d");

      // TransTime
      strcpy( attr_name, object_name);
      strcat( attr_name, ".TransTime");
      sts = gdh_GetAttributeCharacteristics ( attr_name,
					      &attrtype, &attrsize, &attroffs, &attrelem);
      if ( EVEN(sts)) return sts;

      t.elem[t.elem_cnt].value_p = &object_ptr->TransTime;
      t.elem[t.elem_cnt].type_id = attrtype;
      t.elem[t.elem_cnt].size = attrsize;
      strcpy( t.elem[t.elem_cnt++].format, "");

      t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;

      // ErrCount
      strcpy( attr_name, object_name);
      strcat( attr_name, ".ErrCount");
      sts = gdh_GetAttributeCharacteristics ( attr_name,
					      &attrtype, &attrsize, &attroffs, &attrelem);
      if ( EVEN(sts)) return sts;

      t.elem[t.elem_cnt].value_p = &object_ptr->ErrCount;
      t.elem[t.elem_cnt].type_id = attrtype;
      t.elem[t.elem_cnt].size = attrsize;
      strcpy( t.elem[t.elem_cnt++].format, "%8d");

      // LastSts
      strcpy( attr_name, object_name);
      strcat( attr_name, ".LastSts");
      sts = gdh_GetAttributeCharacteristics ( attr_name,
					      &attrtype, &attrsize, &attroffs, &attrelem);
      if ( EVEN(sts)) return sts;

      t.elem[t.elem_cnt].value_p = &object_ptr->LastSts;
      t.elem[t.elem_cnt].type_id = attrtype;
      t.elem[t.elem_cnt].size = attrsize;
      strcpy( t.elem[t.elem_cnt++].format, "%8d");

      ts.subid[0] = subid;
      ts.subid_cnt = 1;
      new ItemRemTrans( brow, this, objid, &t, &ts, -1, 0, 0, 0, NULL,
			flow_eDest_IntoLast);
    }
    if ( cdh_ObjidIsNull( remnode_objid))
      sts = gdh_GetNextObject( objid, &objid);
    else
      sts = gdh_GetNextSibling( objid, &objid);
  }

  brow_ResetNodraw( brow->ctx);
  brow_Redraw( brow->ctx, 0);
  force_trace_scan();
  return XNAV__SUCCESS;
}

int XNav::show_plcpgm()
{
  item_sTableHeader 	th;
  item_sTable 		t;
  item_sTableSubid	ts;
  pwr_tOName   		object_name;
  pwr_tAName   		attr_name;
  int			sts;
  pwr_tObjid		objid;
  pwr_sClass_PlcThread	*object_ptr;
  pwr_tObjid		thread_objid;
  pwr_tOName   		namebuf;
  pwr_tObjid		parent;
  pwr_tCid		cid;

  brow_pop();
  brow_SetNodraw( brow->ctx);

  th.table_cnt = 0;
  strcpy( th.title[th.table_cnt++], "PlcPgm");
  strcpy( th.title[th.table_cnt++], "");
  strcpy( th.title[th.table_cnt++], "");
  strcpy( th.title[th.table_cnt++], "");
  strcpy( th.title[th.table_cnt++], "PlcThread");
  strcpy( th.title[th.table_cnt++], "Description");
  new ItemTableHeader( brow, this, "Title", &th,  NULL, flow_eDest_IntoLast);

  sts = gdh_GetClassList ( pwr_cClass_plc, &objid);
  while ( ODD(sts))
  {
    // Don't display template plcpgm in class volumes
    sts = gdh_GetParent( objid, &parent);
    if ( ODD(sts)) {
      sts = gdh_GetObjectClass( parent, &cid);
      if ( EVEN(sts)) return sts;

      if ( cid == pwr_eClass_ClassDef) {
	sts = gdh_GetNextObject ( objid, &objid);
	continue;
      }
    }

    sts = gdh_ObjidToPointer( objid, (void **) &object_ptr);
    if ( EVEN(sts)) return sts;

    sts = gdh_ObjidToName ( objid, object_name,
			sizeof(object_name), cdh_mNName);
    if ( EVEN(sts)) return sts;

    t.elem_cnt = 0;

    // Object name
    strcpy( t.elem[t.elem_cnt].fix_str, object_name);
    t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

    t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;
    t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;
    t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;

    // ThreadObject
    strcpy( attr_name, object_name);
    strcat( attr_name, ".ThreadObject");
    sts = gdh_GetObjectInfo( attr_name,
		(void *) &thread_objid, sizeof(thread_objid));
    if ( ODD(sts))
    {
      sts = gdh_ObjidToName ( thread_objid, namebuf,
			sizeof(namebuf), cdh_mName_object);
      if ( ODD(sts))
        strcpy( t.elem[t.elem_cnt].fix_str, namebuf);
      else
        strcpy( t.elem[t.elem_cnt].fix_str, "-");
    }
    else
      strcpy( t.elem[t.elem_cnt].fix_str, "-");
    t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

    // Description
    strcpy( t.elem[t.elem_cnt].fix_str, object_ptr->Description);
    t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

    ts.subid_cnt = 0;
    new ItemPlc( brow, this, objid, &t, &ts, -1, 0, 0, 1, NULL, flow_eDest_IntoLast);

    sts = gdh_GetNextObject ( objid, &objid);
  }

  brow_ResetNodraw( brow->ctx);
  brow_Redraw( brow->ctx, 0);
  force_trace_scan();
  return XNAV__SUCCESS;
}


