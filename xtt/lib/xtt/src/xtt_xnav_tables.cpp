/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <stdlib.h>

#include "pwr_remoteclasses.h"

#include "co_string.h"

#include "rt_gdh_msg.h"

#include "xtt_ssaboxclasses.h"
#include "xtt_trace.h"
#include "xtt_item.h"

extern "C" {
#include "rt_qdb.h"
#include "rt_sub.h"
#include "rt_io_base.h"
}

typedef struct {
  void* chanp;
  void* cardp;
  pwr_tCid chan_cid;
  pwr_tCid card_cid;
} tab_sChannelFlagsData;

static int xnav_subcli_remote_cnt;

static int xnav_get_nodename(pwr_tNodeId nid, char* nodename);
static int xnav_show_subsrv_insert(XNav* xnav, sub_sServer* ssrvp);
extern "C" void xnav_show_subsrv_scan(XNav* xnav);
static int xnav_show_subcli_insert(
    XNav* xnav, gdb_sNode* np, sub_sClient* sclip);
extern "C" void xnav_show_subcli_scan(XNav* xnav);

int XNav::show_plcthreads()
{
  item_sTableHeader th;
  item_sTable t;
  item_sTableSubid ts;
  pwr_tTypeId attrtype;
  unsigned int attrsize, attroffs, attrelem;
  pwr_tSubid subid;
  pwr_tOName object_name;
  pwr_tAName attr_name;
  char* s;
  int sts;
  pwr_tObjid objid;
  pwr_sAttrRef attrref;
  pwr_sClass_PlcThread* object_ptr;

  brow_pop();
  brow_SetNodraw(brow->ctx);

  th.table_cnt = 0;
  strcpy(th.title[th.table_cnt++], "PlcThread");
  strcpy(th.title[th.table_cnt++], "Prio");
  strcpy(th.title[th.table_cnt++], "LoopCnt");
  strcpy(th.title[th.table_cnt++], "ScanTime");
  strcpy(th.title[th.table_cnt++], "Mean");
  strcpy(th.title[th.table_cnt++], "Coverage");
  strcpy(th.title[th.table_cnt++], "Count 1/8");
  strcpy(th.title[th.table_cnt++], "Count 1/4");
  strcpy(th.title[th.table_cnt++], "Count 1/2");
  strcpy(th.title[th.table_cnt++], "Count 1/1");
  new ItemTableHeader(brow, this, "Title", &th, NULL, flow_eDest_IntoLast);

  sts = gdh_GetClassList(pwr_cClass_PlcThread, &objid);
  while (ODD(sts)) {
    attrref = cdh_ObjidToAref(objid);
    sts = gdh_DLRefObjectInfoAttrref(
        &attrref, (pwr_tAddress*)&object_ptr, &subid);
    if (EVEN(sts))
      return sts;

    sts = gdh_ObjidToName(
        objid, object_name, sizeof(object_name), cdh_mName_volumeStrict);
    if (EVEN(sts))
      return sts;

    t.elem_cnt = 0;

    // Object name
    s = strrchr(object_name, '-');
    if (s == 0)
      s = object_name;
    else
      s++;

    strcpy(t.elem[t.elem_cnt].fix_str, s);
    t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

    // Prio
    strcpy(attr_name, object_name);
    strcat(attr_name, ".Prio");
    sts = gdh_GetAttributeCharacteristics(
        attr_name, &attrtype, &attrsize, &attroffs, &attrelem);
    if (EVEN(sts))
      return sts;

    t.elem[t.elem_cnt].value_p = &object_ptr->Prio;
    t.elem[t.elem_cnt].type_id = attrtype;
    t.elem[t.elem_cnt].size = attrsize;
    strcpy(t.elem[t.elem_cnt++].format, "%3d");

    // Count
    strcpy(attr_name, object_name);
    strcat(attr_name, ".Count");
    sts = gdh_GetAttributeCharacteristics(
        attr_name, &attrtype, &attrsize, &attroffs, &attrelem);
    if (EVEN(sts))
      return sts;

    t.elem[t.elem_cnt].value_p = &object_ptr->Count;
    t.elem[t.elem_cnt].type_id = attrtype;
    t.elem[t.elem_cnt].size = attrsize;
    strcpy(t.elem[t.elem_cnt++].format, "%10d");

    // ScanTime
    strcpy(attr_name, object_name);
    strcat(attr_name, ".ScanTime");
    sts = gdh_GetAttributeCharacteristics(
        attr_name, &attrtype, &attrsize, &attroffs, &attrelem);
    if (EVEN(sts))
      return sts;

    t.elem[t.elem_cnt].value_p = &object_ptr->ScanTime;
    t.elem[t.elem_cnt].type_id = attrtype;
    t.elem[t.elem_cnt].size = attrsize;
    strcpy(t.elem[t.elem_cnt++].format, "%8.3f");

    // ScanTimeMean
    strcpy(attr_name, object_name);
    strcat(attr_name, ".ScanTimeMean");
    sts = gdh_GetAttributeCharacteristics(
        attr_name, &attrtype, &attrsize, &attroffs, &attrelem);
    if (EVEN(sts))
      return sts;

    t.elem[t.elem_cnt].value_p = &object_ptr->ScanTimeMean;
    t.elem[t.elem_cnt].type_id = attrtype;
    t.elem[t.elem_cnt].size = attrsize;
    strcpy(t.elem[t.elem_cnt++].format, "%8.3f");

    // Coverage
    strcpy(attr_name, object_name);
    strcat(attr_name, ".Coverage");
    sts = gdh_GetAttributeCharacteristics(
        attr_name, &attrtype, &attrsize, &attroffs, &attrelem);
    if (EVEN(sts))
      return sts;

    t.elem[t.elem_cnt].value_p = &object_ptr->Coverage;
    t.elem[t.elem_cnt].type_id = attrtype;
    t.elem[t.elem_cnt].size = attrsize;
    strcpy(t.elem[t.elem_cnt++].format, "%8.3f");

    // Count_1_8
    strcpy(attr_name, object_name);
    strcat(attr_name, ".Count_1_8");
    sts = gdh_GetAttributeCharacteristics(
        attr_name, &attrtype, &attrsize, &attroffs, &attrelem);
    if (EVEN(sts))
      return sts;

    t.elem[t.elem_cnt].value_p = &object_ptr->Count_1_8;
    t.elem[t.elem_cnt].type_id = attrtype;
    t.elem[t.elem_cnt].size = attrsize;
    strcpy(t.elem[t.elem_cnt++].format, "%10d");

    // Count_1_4
    strcpy(attr_name, object_name);
    strcat(attr_name, ".Count_1_4");
    sts = gdh_GetAttributeCharacteristics(
        attr_name, &attrtype, &attrsize, &attroffs, &attrelem);
    if (EVEN(sts))
      return sts;

    t.elem[t.elem_cnt].value_p = &object_ptr->Count_1_4;
    t.elem[t.elem_cnt].type_id = attrtype;
    t.elem[t.elem_cnt].size = attrsize;
    strcpy(t.elem[t.elem_cnt++].format, "%10d");

    // Count_1_2
    strcpy(attr_name, object_name);
    strcat(attr_name, ".Count_1_2");
    sts = gdh_GetAttributeCharacteristics(
        attr_name, &attrtype, &attrsize, &attroffs, &attrelem);
    if (EVEN(sts))
      return sts;

    t.elem[t.elem_cnt].value_p = &object_ptr->Count_1_2;
    t.elem[t.elem_cnt].type_id = attrtype;
    t.elem[t.elem_cnt].size = attrsize;
    strcpy(t.elem[t.elem_cnt++].format, "%10d");

    // Count_1_1
    strcpy(attr_name, object_name);
    strcat(attr_name, ".Count_1_1");
    sts = gdh_GetAttributeCharacteristics(
        attr_name, &attrtype, &attrsize, &attroffs, &attrelem);
    if (EVEN(sts))
      return sts;

    t.elem[t.elem_cnt].value_p = &object_ptr->Count_1_1;
    t.elem[t.elem_cnt].type_id = attrtype;
    t.elem[t.elem_cnt].size = attrsize;
    strcpy(t.elem[t.elem_cnt++].format, "%10d");

    ts.subid[0] = subid;
    ts.subid_cnt = 1;
    new ItemTable(
        brow, this, objid, &t, &ts, -1, 0, 0, 0, NULL, flow_eDest_IntoLast);

    sts = gdh_GetNextObject(objid, &objid);
  }

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
  force_trace_scan();
  return XNAV__SUCCESS;
}

int XNav::show_nethandler()
{
  item_sTableHeader th;
  item_sTable t;
  item_sTableSubid ts;
  int sts;
  pool_sQlink* nl;
  gdb_sNode* np;

  brow_pop();
  brow_SetNodraw(brow->ctx);

  th.table_cnt = 0;
  strcpy(th.title[th.table_cnt++], "Node");
  strcpy(th.title[th.table_cnt++], "Os");
  strcpy(th.title[th.table_cnt++], "Link");
  strcpy(th.title[th.table_cnt++], "UpCount");
  strcpy(th.title[th.table_cnt++], "Time up");
  new ItemTableHeader(brow, this, "Title", &th, NULL, flow_eDest_IntoLast);

  gdb_ScopeLock
  {
    for (nl = pool_Qsucc(&sts, gdbroot->pool, &gdbroot->db->nod_lh);
         nl != &gdbroot->db->nod_lh; nl = pool_Qsucc(&sts, gdbroot->pool, nl)) {
      np = pool_Qitem(nl, gdb_sNode, nod_ll);

      if (streq(np->name, "******"))
        continue;

      t.elem_cnt = 0;

      // Node name
      // strcpy( t.elem[t.elem_cnt].fix_str, np->name);
      // t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;
      if (np == gdbroot->my_node) {
        // Local node
        strcpy(t.elem[t.elem_cnt].fix_str, np->name);
        t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;
      } else {
        t.elem[t.elem_cnt].value_p = np->name;
        t.elem[t.elem_cnt].type_id = pwr_eType_String;
        t.elem[t.elem_cnt].size = sizeof(np->name);
        strcpy(t.elem[t.elem_cnt++].format, "%s");
      }

      // Os
      switch (np->hw) {
      case co_eHW_x86:
        strcpy(t.elem[t.elem_cnt].fix_str, "x86");
        break;
      case co_eHW_x86_64:
        strcpy(t.elem[t.elem_cnt].fix_str, "x86_64");
        break;
      case co_eHW_68k:
        strcpy(t.elem[t.elem_cnt].fix_str, "68k");
        break;
      case co_eHW_PPC:
        strcpy(t.elem[t.elem_cnt].fix_str, "PPC");
        break;
      case co_eHW_ARM:
        strcpy(t.elem[t.elem_cnt].fix_str, "ARM");
        break;
      default:
        strcpy(t.elem[t.elem_cnt].fix_str, "-");
      }
      switch (np->os) {
      case co_eOS_Lynx:
        strcat(t.elem[t.elem_cnt].fix_str, "_Lynx");
        break;
      case co_eOS_Linux:
        strcat(t.elem[t.elem_cnt].fix_str, "_Linux");
        break;
      case co_eOS_MacOS:
        strcat(t.elem[t.elem_cnt].fix_str, "_MacOS");
        break;
      case co_eOS_FreeBSD:
        strcat(t.elem[t.elem_cnt].fix_str, "_FreeBSD");
        break;
      case co_eOS_OpenBSD:
        strcat(t.elem[t.elem_cnt].fix_str, "_OpenBSD");
        break;
      case co_eOS_Cygwin:
        strcat(t.elem[t.elem_cnt].fix_str, "_Cygwin");
        break;
      default:;
      }
      t.elem[t.elem_cnt].fix_str[11] = 0;
      t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

      if (np == gdbroot->my_node) {
        // Local node
        strcpy(t.elem[t.elem_cnt].fix_str, "Local");
        t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;
      } else {
        t.elem[t.elem_cnt].value_p = &np->flags;
        t.elem[t.elem_cnt].type_id = xnav_eType_GdbNodeFlags;
        t.elem[t.elem_cnt].size = sizeof(np->flags.b);
        strcpy(t.elem[t.elem_cnt++].format, "%s");
      }

      // UpCnt
      t.elem[t.elem_cnt].value_p = &np->upcnt;
      t.elem[t.elem_cnt].type_id = pwr_eType_UInt32;
      t.elem[t.elem_cnt].size = sizeof(np->upcnt);
      strcpy(t.elem[t.elem_cnt++].format, "%8d");

      // Time up
      t.elem[t.elem_cnt].value_p = &np->timeup;
      t.elem[t.elem_cnt].type_id = pwr_eType_Time;
      t.elem[t.elem_cnt++].size = sizeof(np->timeup);

      ts.subid_cnt = 0;
      new ItemTable(brow, this, pwr_cNObjid, &t, &ts, -1, 0, 0, 0, NULL,
          flow_eDest_IntoLast);
    }
  }
  gdb_ScopeUnlock;

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
  force_trace_scan();
  return XNAV__SUCCESS;
}

static int xnav_get_nodename(pwr_tNodeId nid, char* nodename)
{
  gdb_sNode* np;
  int sts;

  np = (gdb_sNode*)hash_Search(&sts, gdbroot->nid_ht, &nid);
  if (ODD(sts))
    strcpy(nodename, np->name);
  else
    strcpy(nodename, "Undef");
  return sts;
}

int XNav::show_subsrv()
{
  pool_sQlink* sl;
  sub_sServer* ssrvp;
  item_sTableHeader th;
  int sts;
  ItemTableHeader* item_header;

  brow_pop();
  brow_SetNodraw(brow->ctx);

  th.table_cnt = 0;
  strcpy(th.title[th.table_cnt++], "Subid");
  strcpy(th.title[th.table_cnt++], "Count");
  strcpy(th.title[th.table_cnt++], "Node");
  strcpy(th.title[th.table_cnt++], "Size");
  strcpy(th.title[th.table_cnt++], "Offset");
  strcpy(th.title[th.table_cnt++], "Attribute");
  item_header = new ItemTableHeader(
      brow, this, "Title", &th, NULL, flow_eDest_IntoLast);
  item_header->add_bc(xnav_show_subsrv_scan, NULL);

  gdb_ScopeLock
  {
    for (sl = pool_Qsucc(&sts, gdbroot->pool, &gdbroot->db->subs_lh);
         sl != &gdbroot->db->subs_lh;
         sl = pool_Qsucc(&sts, gdbroot->pool, sl)) {
      ssrvp = pool_Qitem(sl, sub_sServer, subs_ll);

      xnav_show_subsrv_insert(this, ssrvp);
    }
  }
  gdb_ScopeUnlock;

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
  force_trace_scan();
  return XNAV__SUCCESS;
}

static int xnav_show_subsrv_insert(XNav* xnav, sub_sServer* ssrvp)
{
  item_sTable t;
  item_sTableSubid ts;
  ItemTable* item;

  t.elem_cnt = 0;

  // Subid
  t.elem[t.elem_cnt].value_p = &ssrvp->sid;
  t.elem[t.elem_cnt].type_id = pwr_eType_RefId;
  t.elem[t.elem_cnt].size = sizeof(ssrvp->sid);
  strcpy(t.elem[t.elem_cnt++].format, "%8d");

  // Count
  t.elem[t.elem_cnt].value_p = &ssrvp->count;
  t.elem[t.elem_cnt].type_id = pwr_eType_UInt32;
  t.elem[t.elem_cnt].size = sizeof(ssrvp->count);
  strcpy(t.elem[t.elem_cnt++].format, "%8d");

  // Node
  xnav_get_nodename(ssrvp->nid, t.elem[t.elem_cnt].fix_str);
  t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

  // Size
  t.elem[t.elem_cnt].value_p = &ssrvp->aref.Size;
  t.elem[t.elem_cnt].type_id = pwr_eType_UInt32;
  t.elem[t.elem_cnt].size = sizeof(ssrvp->aref.Size);
  strcpy(t.elem[t.elem_cnt++].format, "%8d");

  // Offset
  t.elem[t.elem_cnt].value_p = &ssrvp->aref.Offset;
  t.elem[t.elem_cnt].type_id = pwr_eType_UInt32;
  t.elem[t.elem_cnt].size = sizeof(ssrvp->aref.Offset);
  strcpy(t.elem[t.elem_cnt++].format, "%8d");

  // Attribute
  t.elem[t.elem_cnt].value_p = &ssrvp->aref;
  t.elem[t.elem_cnt].type_id = pwr_eType_AttrRef;
  t.elem[t.elem_cnt++].size = sizeof(ssrvp->aref);

  ts.subid_cnt = 0;
  item = new ItemTable(xnav->brow, xnav, pwr_cNObjid, &t, &ts, -1, 0, 0, 0,
      NULL, flow_eDest_IntoLast);
  item->found = 1;
  return XNAV__SUCCESS;
}

extern "C" void xnav_show_subsrv_scan(XNav* xnav)
{
  brow_tObject* node_list;
  brow_tObject* object_p;
  int node_cnt;
  ItemTable* item = NULL;
  int i;
  pool_sQlink* sl;
  sub_sServer* ssrvp;
  int sts;
  int found;
  int change_detected = 0;

  brow_SetNodraw(xnav->brow->ctx);
  brow_GetObjectList(xnav->brow->ctx, &node_list, &node_cnt);

  // Reset found
  object_p = node_list + 1;
  for (i = 1; i < node_cnt; i++) {
    brow_GetUserData(*object_p, (void**)&item);
    item->found = 0;
    object_p++;
  }

  gdb_ScopeLock
  {
    for (sl = pool_Qsucc(&sts, gdbroot->pool, &gdbroot->db->subs_lh);
         sl != &gdbroot->db->subs_lh;
         sl = pool_Qsucc(&sts, gdbroot->pool, sl)) {
      ssrvp = pool_Qitem(sl, sub_sServer, subs_ll);

      object_p = node_list + 1;
      found = 0;
      for (i = 1; i < node_cnt; i++) {
        brow_GetUserData(*object_p, (void**)&item);
        if (memcmp(item->col.elem[0].value_p, &ssrvp->sid, sizeof(pwr_tSubid))
            == 0) {
          found = 1;
          break;
        }
        object_p++;
      }
      if (!found) {
        xnav_show_subsrv_insert(xnav, ssrvp);
        change_detected = 1;
      } else
        item->found = 1;
    }
  }
  gdb_ScopeUnlock;

  // Remove all that were not found
  object_p = node_list + 1;
  for (i = 1; i < node_cnt; i++) {
    brow_GetUserData(*object_p, (void**)&item);
    if (!item->found) {
      brow_DeleteNode(xnav->brow->ctx, item->node);
      change_detected = 1;
    } else
      object_p++;
  }
  brow_ResetNodraw(xnav->brow->ctx);
  if (change_detected)
    brow_Redraw(xnav->brow->ctx, 0);
}

int XNav::show_subcli()
{
  pool_sQlink* sl;
  pool_sQlink* nl;
  sub_sClient* sclip;
  gdb_sNode* np;
  item_sTableHeader th;
  int sts;
  ItemTableHeader* item_header;
  item_sTable t;
  item_sTableSubid ts;

  brow_pop();
  brow_SetNodraw(brow->ctx);

  t.elem_cnt = 0;
  t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;

  // Local
  strcpy(t.elem[t.elem_cnt].fix_str, "Local:");
  t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

  t.elem[t.elem_cnt].value_p = &gdbroot->my_node->subc_lc;
  t.elem[t.elem_cnt].type_id = pwr_eType_UInt32;
  t.elem[t.elem_cnt].size = sizeof(gdbroot->my_node->subc_lc);
  strcpy(t.elem[t.elem_cnt++].format, "%8d");

  // Remote
  strcpy(t.elem[t.elem_cnt].fix_str, "Remote:");
  t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

  t.elem[t.elem_cnt].value_p = &xnav_subcli_remote_cnt;
  t.elem[t.elem_cnt].type_id = pwr_eType_UInt32;
  t.elem[t.elem_cnt].size = sizeof(xnav_subcli_remote_cnt);
  strcpy(t.elem[t.elem_cnt++].format, "%8d");

  // Unknown
  strcpy(t.elem[t.elem_cnt].fix_str, "Unknown:");
  t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

  t.elem[t.elem_cnt].value_p = &gdbroot->no_node->subc_lc;
  t.elem[t.elem_cnt].type_id = pwr_eType_UInt32;
  t.elem[t.elem_cnt].size = sizeof(gdbroot->no_node->subc_lc);
  strcpy(t.elem[t.elem_cnt++].format, "%8d");

  ts.subid_cnt = 0;
  new ItemTable(
      brow, this, pwr_cNObjid, &t, &ts, -1, 0, 0, 0, NULL, flow_eDest_IntoLast);

  th.table_cnt = 0;
  strcpy(th.title[th.table_cnt++], "Subid");
  strcpy(th.title[th.table_cnt++], "Time");
  strcpy(th.title[th.table_cnt++], "Count");
  strcpy(th.title[th.table_cnt++], "Node");
  strcpy(th.title[th.table_cnt++], "Size");
  strcpy(th.title[th.table_cnt++], "Attribute");
  item_header = new ItemTableHeader(
      brow, this, "Title", &th, NULL, flow_eDest_IntoLast);
  item_header->add_bc(xnav_show_subcli_scan, NULL);

  xnav_subcli_remote_cnt = 0;
  gdb_ScopeLock
  {
    for (nl = pool_Qsucc(&sts, gdbroot->pool, &gdbroot->db->nod_lh);
         nl != &gdbroot->db->nod_lh; nl = pool_Qsucc(&sts, gdbroot->pool, nl)) {
      np = pool_Qitem(nl, gdb_sNode, nod_ll);
      for (sl = pool_Qsucc(&sts, gdbroot->pool, &np->subc_lh);
           sl != &np->subc_lh; sl = pool_Qsucc(&sts, gdbroot->pool, sl)) {
        sclip = pool_Qitem(sl, sub_sClient, subc_ll);
        xnav_show_subcli_insert(this, np, sclip);
      }
      if (!(np == gdbroot->my_node || np == gdbroot->no_node))
        xnav_subcli_remote_cnt += np->subc_lc;
    }
  }
  gdb_ScopeUnlock;

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
  force_trace_scan();
  return XNAV__SUCCESS;
}

static int xnav_show_subcli_insert(
    XNav* xnav, gdb_sNode* np, sub_sClient* sclip)
{
  item_sTable t;
  item_sTableSubid ts;
  ItemTable* item;
  static int zero = 0;
  char astr[80];
  net_sSubData* sdatap;
  int sts;

  t.elem_cnt = 0;

  // Subid
  t.elem[t.elem_cnt].value_p = &sclip->sid;
  t.elem[t.elem_cnt].type_id = pwr_eType_RefId;
  t.elem[t.elem_cnt].size = sizeof(sclip->sid);
  strcpy(t.elem[t.elem_cnt++].format, "%8d");

  // Time
  t.elem[t.elem_cnt].value_p = &sclip->lastupdate;
  t.elem[t.elem_cnt].type_id = xnav_eType_ShortTime;
  t.elem[t.elem_cnt++].size = sizeof(sclip->lastupdate);

  // Count
  t.elem[t.elem_cnt].value_p = &sclip->count;
  t.elem[t.elem_cnt].type_id = pwr_eType_UInt32;
  t.elem[t.elem_cnt].size = sizeof(sclip->count);
  strcpy(t.elem[t.elem_cnt++].format, "%8d");

  // Node
  if (sclip->nid == pwr_cNNodeId)
    strcpy(t.elem[t.elem_cnt].fix_str, "Unknown");
  else
    strcpy(t.elem[t.elem_cnt].fix_str, np->name);
  t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

  // Size
  sdatap = (net_sSubData*)pool_Address(&sts, gdbroot->pool, sclip->subdata);
  if (sdatap == NULL)
    t.elem[t.elem_cnt].value_p = &zero;
  else
    t.elem[t.elem_cnt].value_p = &sdatap->size;
  t.elem[t.elem_cnt].type_id = pwr_eType_UInt16;
  t.elem[t.elem_cnt].size = sizeof(pwr_tUInt16);
  strcpy(t.elem[t.elem_cnt++].format, "%8hd");

  // Name
  if (sclip->sub_by_name)
    strcpy(t.elem[t.elem_cnt].fix_str, sclip->name);
  else {
    if (sclip->aref.Flags.b.Indirect)
      strcpy(astr, "@");
    else
      strcpy(astr, "");
    cdh_ArefToString(
        &astr[strlen(astr)], sizeof(astr) - strlen(astr), &sclip->aref, 1);
    strcpy(t.elem[t.elem_cnt].fix_str, astr);
  }
  t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

  ts.subid_cnt = 0;
  item = new ItemTable(xnav->brow, xnav, pwr_cNObjid, &t, &ts, -1, 0, 0, 0,
      NULL, flow_eDest_IntoLast);
  item->found = 1;
  return XNAV__SUCCESS;
}

extern "C" void xnav_show_subcli_scan(XNav* xnav)
{
  brow_tObject* node_list;
  brow_tObject* object_p;
  int node_cnt;
  ItemTable* item = NULL;
  int i;
  pool_sQlink* sl;
  pool_sQlink* nl;
  sub_sClient* sclip;
  gdb_sNode* np;
  int sts;
  int found;
  int change_detected = 0;

  brow_SetNodraw(xnav->brow->ctx);
  brow_GetObjectList(xnav->brow->ctx, &node_list, &node_cnt);

  // Reset found
  object_p = node_list + 2;
  for (i = 2; i < node_cnt; i++) {
    brow_GetUserData(*object_p, (void**)&item);
    item->found = 0;
    object_p++;
  }

  xnav_subcli_remote_cnt = 0;
  gdb_ScopeLock
  {
    for (nl = pool_Qsucc(&sts, gdbroot->pool, &gdbroot->db->nod_lh);
         nl != &gdbroot->db->nod_lh; nl = pool_Qsucc(&sts, gdbroot->pool, nl)) {
      np = pool_Qitem(nl, gdb_sNode, nod_ll);
      for (sl = pool_Qsucc(&sts, gdbroot->pool, &np->subc_lh);
           sl != &np->subc_lh; sl = pool_Qsucc(&sts, gdbroot->pool, sl)) {
        sclip = pool_Qitem(sl, sub_sClient, subc_ll);

        object_p = node_list + 2;
        found = 0;
        for (i = 1; i < node_cnt; i++) {
          brow_GetUserData(*object_p, (void**)&item);
          if (memcmp(item->col.elem[0].value_p, &sclip->sid, sizeof(pwr_tSubid))
              == 0) {
            found = 1;
            break;
          }
          object_p++;
        }
        if (!found) {
          xnav_show_subcli_insert(xnav, np, sclip);
          change_detected = 1;
        } else
          item->found = 1;
      }
      if (!(np == gdbroot->my_node || np == gdbroot->no_node))
        xnav_subcli_remote_cnt += np->subc_lc;
    }
  }
  gdb_ScopeUnlock;

  // Remove all that were not found
  object_p = node_list + 2;
  for (i = 2; i < node_cnt; i++) {
    brow_GetUserData(*object_p, (void**)&item);
    if (!item->found) {
      brow_DeleteNode(xnav->brow->ctx, item->node);
      change_detected = 1;
    } else
      object_p++;
  }
  brow_ResetNodraw(xnav->brow->ctx);
  if (change_detected)
    brow_Redraw(xnav->brow->ctx, 0);
}

void process_to_name(char* name, pwr_tUInt32 process)
{
  switch (process) {
  case pwr_mIoProcessMask_Plc:
    strcpy(name, "Plc");
    break;
  case pwr_mIoProcessMask_IoComm:
    strcpy(name, "IoComm");
    break;
  case pwr_mIoProcessMask_Profibus:
    strcpy(name, "Profibus");
    break;
  case pwr_mIoProcessMask_User:
    strcpy(name, "User");
    break;
  case pwr_mIoProcessMask_User2:
    strcpy(name, "User2");
    break;
  case pwr_mIoProcessMask_User3:
    strcpy(name, "User3");
    break;
  case pwr_mIoProcessMask_User4:
    strcpy(name, "User4");
    break;
  case pwr_mIoProcessMask_Powerlink:
    strcpy(name, "Powerlink");
    break;
  default:
    sprintf(name, "%4d", process);
  }
}

int XNav::show_device()
{
  item_sTableHeader th;
  item_sTable t;
  item_sTableSubid ts;
  pwr_tTypeId attrtype;
  unsigned int attrsize, attroffs, attrelem;
  pwr_tSubid subid;
  pwr_tOName object_name;
  pwr_tAName attr_name;
  int sts;
  pwr_tObjid rack_objid;
  pwr_tObjid device_objid;
  pwr_sAttrRef attrref;
  pwr_tClassId classid;
  pwr_tUInt32 process;
  pwr_tUInt32 address;
  pwr_tObjid thread_objid;
  char namebuf[80];
  int rack_class_cnt;
  pwr_tClassId* rack_class;
  int i;
  void* attr_ptr;

  brow_pop();
  brow_SetNodraw(brow->ctx);

  th.table_cnt = 0;
  strcpy(th.title[th.table_cnt++], "Device");
  strcpy(th.title[th.table_cnt++], "ErrorCount");
  strcpy(th.title[th.table_cnt++], "Process");
  strcpy(th.title[th.table_cnt++], "PlcThread");
  strcpy(th.title[th.table_cnt++], "Address");
  strcpy(th.title[th.table_cnt++], "Class");
  strcpy(th.title[th.table_cnt++], "");
  strcpy(th.title[th.table_cnt++], "Description");
  new ItemTableHeader(brow, this, "Title", &th, NULL, flow_eDest_IntoLast);

  // Get the rack objects
  sts = io_GetIoTypeClasses(io_eType_Rack, &rack_class, &rack_class_cnt);
  if (EVEN(sts))
    return sts;

  for (i = 0; i < rack_class_cnt; i++) {
    sts = gdh_GetClassList(rack_class[i], &rack_objid);
    while (ODD(sts)) {
      // Get all children
      sts = gdh_GetChild(rack_objid, &device_objid);
      while (ODD(sts)) {
        sts = gdh_ObjidToName(device_objid, object_name, sizeof(object_name),
            cdh_mName_volumeStrict);
        if (EVEN(sts))
          return sts;

        t.elem_cnt = 0;
        ts.subid_cnt = 0;

        // Object name
        xnav_cut_segments(namebuf, object_name, 2);

        strcpy(t.elem[t.elem_cnt].fix_str, namebuf);
        t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

        // ErrorCount
        strcpy(attr_name, object_name);
        strcat(attr_name, ".ErrorCount");
        sts = gdh_GetAttributeCharacteristics(
            attr_name, &attrtype, &attrsize, &attroffs, &attrelem);
        if (EVEN(sts)) {
          strcpy(t.elem[t.elem_cnt].fix_str, "       -");
          t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;
        } else {
          sts = gdh_NameToAttrref(pwr_cNObjid, attr_name, &attrref);
          if (EVEN(sts))
            return sts;

          sts = gdh_DLRefObjectInfoAttrref(&attrref, &attr_ptr, &subid);
          if (EVEN(sts))
            return sts;

          t.elem[t.elem_cnt].value_p = attr_ptr;
          t.elem[t.elem_cnt].type_id = attrtype;
          t.elem[t.elem_cnt].size = attrsize;
          strcpy(t.elem[t.elem_cnt++].format, "%8d");
          ts.subid[ts.subid_cnt++] = subid;
        }

        // Process
        strcpy(attr_name, object_name);
        strcat(attr_name, ".Process");
        sts = gdh_GetObjectInfo(attr_name, (void*)&process, sizeof(process));
        if (ODD(sts))
          process_to_name(t.elem[t.elem_cnt].fix_str, process);
        else {
          process = 0;
          strcpy(t.elem[t.elem_cnt].fix_str, "-");
        }
        t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

        // ThreadObject
        if (!(process & 1)) {
          strcpy(t.elem[t.elem_cnt].fix_str, "-");
          t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;
        } else {
          strcpy(attr_name, object_name);
          strcat(attr_name, ".ThreadObject");
          sts = gdh_GetObjectInfo(
              attr_name, (void*)&thread_objid, sizeof(thread_objid));
          if (ODD(sts)) {
            sts = gdh_ObjidToName(
                thread_objid, namebuf, sizeof(namebuf), cdh_mName_object);
            if (ODD(sts))
              strcpy(t.elem[t.elem_cnt].fix_str, namebuf);
            else
              strcpy(t.elem[t.elem_cnt].fix_str, "-");
          } else
            strcpy(t.elem[t.elem_cnt].fix_str, "-");
          t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;
        }
        // RegAddress
        strcpy(attr_name, object_name);
        strcat(attr_name, ".RegAddress");
        sts = gdh_GetObjectInfo(attr_name, (void*)&address, sizeof(address));
        if (ODD(sts))
          sprintf(t.elem[t.elem_cnt].fix_str, "%d", address);
        else
          strcpy(t.elem[t.elem_cnt].fix_str, "-");
        t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

        // Class name
        sts = gdh_GetObjectClass(device_objid, &classid);
        sts = gdh_ObjidToName(cdh_ClassIdToObjid(classid), namebuf,
            sizeof(namebuf), cdh_mName_object);
        strcpy(t.elem[t.elem_cnt].fix_str, namebuf);
        t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

        t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;

        // Description
        strcpy(attr_name, object_name);
        strcat(attr_name, ".Description");
        sts = gdh_GetAttributeCharacteristics(
            attr_name, &attrtype, &attrsize, &attroffs, &attrelem);
        if (EVEN(sts)) {
          strcpy(t.elem[t.elem_cnt].fix_str, "");
          t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;
        } else {
          sts = gdh_NameToAttrref(pwr_cNObjid, attr_name, &attrref);
          if (EVEN(sts))
            return sts;

          sts = gdh_DLRefObjectInfoAttrref(&attrref, &attr_ptr, &subid);
          if (EVEN(sts))
            return sts;

          t.elem[t.elem_cnt].value_p = attr_ptr;
          t.elem[t.elem_cnt].type_id = attrtype;
          t.elem[t.elem_cnt].size = attrsize;
          strcpy(t.elem[t.elem_cnt++].format, "%s");
          ts.subid[ts.subid_cnt++] = subid;
        }

        new ItemDevice(brow, this, device_objid, &t, &ts, -1, 0, 0, 0, NULL,
            flow_eDest_IntoLast);
        sts = gdh_GetNextSibling(device_objid, &device_objid);
      }
      sts = gdh_GetNextObject(rack_objid, &rack_objid);
    }
  }
  free((char*)rack_class);

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
  force_trace_scan();
  return XNAV__SUCCESS;
}

static void xnav_channel_get_flags(void* cardp, void* chanp, pwr_tCid card_cid,
    pwr_tCid chan_cid, int* conv, int* inv, int* teston)
{
  switch (card_cid) {
  case pwr_cClass_Ssab_DI32D: {
    pwr_sClass_Ssab_BaseDiCard* cp = (pwr_sClass_Ssab_BaseDiCard*)cardp;
    pwr_tMask mask;
    unsigned int chan_idx;

    chan_idx = ((char*)chanp - (char*)cp
                   - pwr_AlignLW(sizeof(pwr_sClass_Ssab_BaseDiCard)))
        / pwr_AlignLW(sizeof(pwr_sClass_ChanDi));
    if (chan_idx < 16) {
      mask = 1 << chan_idx;
      *conv = cp->ConvMask1 & mask ? 1 : 0;
      *inv = cp->InvMask1 & mask ? 1 : 0;
      *teston = 0;
    } else if (chan_idx < 32) {
      mask = 1 << (chan_idx - 16);
      *conv = cp->ConvMask2 & mask ? 1 : 0;
      *inv = cp->InvMask2 & mask ? 1 : 0;
      *teston = 0;
    }
    break;
  }
  case pwr_cClass_Ssab_DO32DKS:
  case pwr_cClass_Ssab_DO32DKS_Stall: {
    pwr_sClass_Ssab_BaseDoCard* cp = (pwr_sClass_Ssab_BaseDoCard*)cardp;
    pwr_tMask mask;
    unsigned int chan_idx;

    chan_idx = ((char*)chanp - (char*)cp
                   - pwr_AlignLW(sizeof(pwr_sClass_Ssab_BaseDoCard)))
        / pwr_AlignLW(sizeof(pwr_sClass_ChanDo));
    if (chan_idx < 16) {
      mask = 1 << chan_idx;
      *conv = 1;
      *inv = cp->InvMask1 & mask ? 1 : 0;
      *teston = cp->TestMask1 & mask ? 1 : 0;
    } else if (chan_idx < 32) {
      mask = 1 << (chan_idx - 16);
      *conv = 1;
      *inv = cp->InvMask2 & mask ? 1 : 0;
      *teston = cp->TestMask2 & mask ? 1 : 0;
    }
    break;
  }
  default: {
    switch (chan_cid) {
    case pwr_cClass_ChanDi: {
      pwr_sClass_ChanDi* cp = (pwr_sClass_ChanDi*)chanp;

      *inv = cp->InvertOn;
      *conv = cp->ConversionOn;
      *teston = 0;
      break;
    }
    case pwr_cClass_ChanDo: {
      pwr_sClass_ChanDo* cp = (pwr_sClass_ChanDo*)chanp;

      *inv = cp->InvertOn;
      *conv = 1;
      *teston = cp->TestOn;
      break;
    }
    case pwr_cClass_ChanD: {
      pwr_sClass_ChanD* cp = (pwr_sClass_ChanD*)chanp;

      *inv = cp->InvertOn;
      *conv = cp->ConversionOn;
      *teston = cp->TestOn;
      break;
    }
    case pwr_cClass_ChanIi: {
      pwr_sClass_ChanIi* cp = (pwr_sClass_ChanIi*)chanp;

      *inv = 0;
      *conv = cp->ConversionOn;
      *teston = 0;
      break;
    }
    case pwr_cClass_ChanIo: {
      pwr_sClass_ChanIo* cp = (pwr_sClass_ChanIo*)chanp;

      *inv = 0;
      *conv = 1;
      *teston = cp->TestOn;
      break;
    }
    case pwr_cClass_ChanAi: {
      pwr_sClass_ChanAi* cp = (pwr_sClass_ChanAi*)chanp;

      *inv = 0;
      *conv = cp->ConversionOn;
      *teston = 0;
      break;
    }
    case pwr_cClass_ChanAit: {
      pwr_sClass_ChanAit* cp = (pwr_sClass_ChanAit*)chanp;

      *inv = 0;
      *conv = cp->ConversionOn;
      *teston = 0;
      break;
    }
    case pwr_cClass_ChanAo: {
      pwr_sClass_ChanAo* cp = (pwr_sClass_ChanAo*)chanp;

      *inv = 0;
      *conv = 1;
      *teston = cp->TestOn;
      break;
    }
    case pwr_cClass_ChanBi: {
      pwr_sClass_ChanBi* cp = (pwr_sClass_ChanBi*)chanp;

      *inv = 0;
      *conv = cp->ConversionOn;
      *teston = 0;
      break;
    }
    case pwr_cClass_ChanBo:
    case pwr_cClass_ChanBiBlob:
    case pwr_cClass_ChanBoBlob:
      *inv = 0;
      *conv = 1;
      *teston = 0;
      break;
    }
  }
  }
}

static void xnav_show_channels_scan(XNav* xnav)
{
  brow_tObject* node_list;
  int node_cnt;
  ItemTable* item;
  int i;
  int conv, inv, teston;
  flow_sAnnotPixmap* pixmap;

  brow_GetObjectList(xnav->brow->ctx, &node_list, &node_cnt);

  for (i = 1; i < node_cnt; i++) {
    brow_GetUserData(node_list[i], (void**)&item);

    if (item->type == xnav_eItemType_Channel) {
      xnav_channel_get_flags(((tab_sChannelFlagsData*)item->col.user)->cardp,
          ((tab_sChannelFlagsData*)item->col.user)->chanp,
          ((tab_sChannelFlagsData*)item->col.user)->card_cid,
          ((tab_sChannelFlagsData*)item->col.user)->chan_cid, &conv, &inv,
          &teston);

      strcpy((char*)item->col.elem[2].value_p, "");
      if (!conv)
        strcat((char*)item->col.elem[2].value_p, "Off ");
      if (inv)
        strcat((char*)item->col.elem[2].value_p, "Inv ");
      if (teston)
        strcat((char*)item->col.elem[2].value_p, "Test ");

      brow_GetAnnotPixmap(node_list[i], 1, &pixmap);
      if (!conv) {
        brow_GetAnnotPixmap(node_list[i], 1, &pixmap);
        if (pixmap != xnav->brow->pixmap_offline)
          brow_SetAnnotPixmap(node_list[i], 1, xnav->brow->pixmap_offline);
      } else if (teston) {
        if (pixmap != xnav->brow->pixmap_teston)
          brow_SetAnnotPixmap(node_list[i], 1, xnav->brow->pixmap_teston);
      } else if (inv) {
        if (pixmap != xnav->brow->pixmap_inverted)
          brow_SetAnnotPixmap(node_list[i], 1, xnav->brow->pixmap_inverted);
      } else {
        if (pixmap == xnav->brow->pixmap_offline
            || pixmap == xnav->brow->pixmap_teston
            || pixmap == xnav->brow->pixmap_inverted)
          brow_RemoveAnnotPixmap(node_list[i], 1);
      }
    }
  }
}

static void xnav_show_channels_close(XNav* xnav)
{
  brow_tObject* node_list;
  int node_cnt;
  ItemTable* item;
  int i;

  brow_GetObjectList(xnav->brow->ctx, &node_list, &node_cnt);

  for (i = 1; i < node_cnt; i++) {
    brow_GetUserData(node_list[i], (void**)&item);
    if (item->type == xnav_eItemType_Channel) {
      free(item->col.elem[2].value_p);
      free(item->col.user);
    }
  }
}

int XNav::show_channels(pwr_tObjid card_objid)
{
  item_sTableHeader th;
  item_sTable t;
  item_sTableSubid ts;
  pwr_tTypeId attrtype;
  unsigned int attrsize, attroffs, attrelem;
  pwr_tSubid subid;
  pwr_tSubid card_subid;
  pwr_tOName object_name;
  pwr_tAName attr_name;
  int sts;
  pwr_tObjid chan_objid;
  pwr_sAttrRef attrref;
  pwr_sAttrRef signal_aref;
  char descr[80];
  char namebuf[80];
  void* attr_ptr;
  ItemChannel* item;
  pwr_tCid chan_cid;
  pwr_tCid card_cid;
  pwr_tAName signal_name;
  int child_found = 0;
  ItemTableHeader* item_header;
  void* cardp;
  void* chanp;
  pwr_tAttrRef aref;

  brow_pop();
  brow_SetNodraw(brow->ctx);

  th.table_cnt = 0;
  strcpy(th.title[th.table_cnt++], "Channel");
  strcpy(th.title[th.table_cnt++], "Value");
  strcpy(th.title[th.table_cnt++], "Flags");
  strcpy(th.title[th.table_cnt++], "Signal");
  strcpy(th.title[th.table_cnt++], "");
  strcpy(th.title[th.table_cnt++], "");
  strcpy(th.title[th.table_cnt++], "");
  strcpy(th.title[th.table_cnt++], "Description");
  item_header = new ItemTableHeader(
      brow, this, "Title", &th, NULL, flow_eDest_IntoLast);
  item_header->add_bc(xnav_show_channels_scan, xnav_show_channels_close);

  sts = gdh_GetObjectClass(card_objid, &card_cid);
  if (EVEN(sts))
    return sts;

  aref = cdh_ObjidToAref(card_objid);
  sts = gdh_DLRefObjectInfoAttrref(&aref, &cardp, &card_subid);
  if (EVEN(sts))
    return sts;

  // Get all children
  sts = gdh_GetChild(card_objid, &chan_objid);
  while (ODD(sts)) {
    child_found = 1;

    t.elem_cnt = 0;
    ts.subid_cnt = 0;

    sts = gdh_ObjidToName(
        chan_objid, object_name, sizeof(object_name), cdh_mName_volumeStrict);
    if (EVEN(sts))
      return sts;

    sts = gdh_GetObjectClass(chan_objid, &chan_cid);
    if (EVEN(sts))
      return sts;

    aref = cdh_ObjidToAref(chan_objid);
    sts = gdh_DLRefObjectInfoAttrref(&aref, &chanp, &subid);
    if (EVEN(sts))
      return sts;

    ts.subid[ts.subid_cnt++] = subid;
    if (card_subid.nid != 0) {
      ts.subid[ts.subid_cnt++] = card_subid;
      card_subid = pwr_cNSubid;
    }

    t.user = calloc(1, sizeof(tab_sChannelFlagsData));
    ((tab_sChannelFlagsData*)t.user)->chanp = chanp;
    ((tab_sChannelFlagsData*)t.user)->cardp = cardp;
    ((tab_sChannelFlagsData*)t.user)->card_cid = card_cid;
    ((tab_sChannelFlagsData*)t.user)->chan_cid = chan_cid;

    // Get connected signal
    strcpy(attr_name, object_name);
    strcat(attr_name, ".SigChanCon");
    sts = gdh_GetObjectInfo(
        attr_name, (void*)&signal_aref, sizeof(signal_aref));
    if (ODD(sts)) {
      sts = gdh_AttrrefToName(
          &signal_aref, signal_name, sizeof(signal_name), cdh_mNName);
      if (EVEN(sts)) {
        signal_aref.Objid = pwr_cNObjid;
        strcpy(signal_name, "-");
      }
    } else
      signal_aref.Objid = pwr_cNObjid;

    // Object name
    xnav_cut_segments(namebuf, object_name, 2);

    strcpy(t.elem[t.elem_cnt].fix_str, namebuf);
    t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

    // Value
    if (cdh_ObjidIsNotNull(signal_aref.Objid)
        && !(chan_cid == pwr_cClass_ChanBi || chan_cid == pwr_cClass_ChanBo
               || chan_cid == pwr_cClass_ChanBiBlob
               || chan_cid == pwr_cClass_ChanBiBlob)) {
      strcpy(attr_name, signal_name);
      switch (chan_cid) {
      case pwr_cClass_ChanDi:
      case pwr_cClass_ChanDo:
      case pwr_cClass_ChanD:
      case pwr_cClass_ChanAi:
      case pwr_cClass_ChanAo:
      case pwr_cClass_ChanIi:
      case pwr_cClass_ChanIo:
        strcat(attr_name, ".ActualValue");
        break;
      case pwr_cClass_ChanCo:
        strcat(attr_name, ".RawValue");
        break;
      }
      sts = gdh_GetAttributeCharacteristics(
          attr_name, &attrtype, &attrsize, &attroffs, &attrelem);
      if (EVEN(sts)) {
        free(t.user);
        return sts;
      }

      sts = gdh_NameToAttrref(pwr_cNObjid, attr_name, &attrref);
      if (EVEN(sts)) {
        free(t.user);
        return sts;
      }

      sts = gdh_DLRefObjectInfoAttrref(&attrref, &attr_ptr, &subid);
      if (EVEN(sts)) {
        free(t.user);
        return sts;
      }

      t.elem[t.elem_cnt].value_p = attr_ptr;
      t.elem[t.elem_cnt].type_id = attrtype;
      t.elem[t.elem_cnt].size = attrsize;

      switch (chan_cid) {
      case pwr_cClass_ChanDi:
      case pwr_cClass_ChanDo:
      case pwr_cClass_ChanD:
      case pwr_cClass_ChanIi:
      case pwr_cClass_ChanIo:
      case pwr_cClass_ChanCo:
        strcpy(t.elem[t.elem_cnt++].format, "%8d");
        break;
      case pwr_cClass_ChanAi:
      case pwr_cClass_ChanAo:
        strcpy(t.elem[t.elem_cnt++].format, "%f");
        break;
      default:
        t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;
      }
      ts.subid[ts.subid_cnt++] = subid;
    } else
      t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;

    // Flags
    t.elem[t.elem_cnt].value_p = calloc(1, sizeof(pwr_tString80));
    t.elem[t.elem_cnt].size = sizeof(pwr_tString80);
    // t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;
    strcpy(t.elem[t.elem_cnt].format, "%s");
    t.elem[t.elem_cnt++].type_id = pwr_eType_String;

    // Signal
    if (cdh_ObjidIsNotNull(signal_aref.Objid)) {
      strcpy(t.elem[t.elem_cnt].fix_str, signal_name);
    } else
      strcpy(t.elem[t.elem_cnt].fix_str, "-");
    t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

    // Description in signal
    t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;
    t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;
    t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;

    if (cdh_ObjidIsNotNull(signal_aref.Objid))
      strcpy(attr_name, signal_name);
    else
      strcpy(attr_name, object_name);
    strcat(attr_name, ".Description");
    sts = gdh_GetObjectInfo(attr_name, (void*)&descr, sizeof(descr));
    if (EVEN(sts)) {
      free(t.user);
      return sts;
    }

    strcpy(t.elem[t.elem_cnt].fix_str, descr);
    t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

    item = new ItemChannel(brow, this, chan_objid, &t, &ts, -1, 0, 0, 1, NULL,
        flow_eDest_IntoLast);
    item->signal_aref = signal_aref;

    sts = gdh_GetNextSibling(chan_objid, &chan_objid);
  }

  // Get all intern channels
  if (!child_found) {
    pwr_tAttrRef card_aref = cdh_ObjidToAref(card_objid);

    sts = show_attr_channels(&card_aref, cardp, &card_subid, card_cid);
    if (EVEN(sts))
      return sts;
  }

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
  force_trace_scan();
  return XNAV__SUCCESS;
}

int XNav::show_attr_channels(pwr_tAttrRef* mod_aref, void* cardp,
    pwr_tSubid* card_subid, pwr_tCid card_cid)
{
  gdh_sAttrDef* bd;
  int rows;
  int i;
  int elem;
  pwr_tCid cid;
  pwr_tAName mod_name;
  int sts;
  item_sTable t;
  item_sTableSubid ts;
  pwr_tTypeId attrtype;
  unsigned int attrsize, attroffs, attrelem;
  pwr_tSubid subid;
  char object_name[450];
  pwr_tAName attr_name;
  pwr_sAttrRef attrref;
  pwr_sAttrRef signal_aref;
  char descr[80];
  char namebuf[80];
  void* attr_ptr;
  ItemChannel* item;
  pwr_tCid chan_cid;
  pwr_tAName signal_name;
  pwr_tAttrRef aref;
  void* chanp;

  sts = gdh_GetAttrRefTid(mod_aref, &cid);
  if (EVEN(sts))
    return sts;

  sts = gdh_AttrrefToName(
      mod_aref, mod_name, sizeof(mod_name), cdh_mName_volumeStrict);
  if (EVEN(sts))
    return sts;

  sts = gdh_GetObjectBodyDef(cid, &bd, &rows, pwr_cNObjid);
  if (EVEN(sts))
    return sts;

  for (i = 0; i < rows; i++) {
    switch (bd[i].attr->Param.TypeRef) {
    case pwr_cClass_ChanAi:
    case pwr_cClass_ChanAit:
    case pwr_cClass_ChanAo:
    case pwr_cClass_ChanDi:
    case pwr_cClass_ChanDo:
    case pwr_cClass_ChanD:
    case pwr_cClass_ChanIi:
    case pwr_cClass_ChanIo:
    case pwr_cClass_ChanCo:
    case pwr_cClass_ChanBo:
    case pwr_cClass_ChanBi:
    case pwr_cClass_ChanBoBlob:
    case pwr_cClass_ChanBiBlob:
      break;
    default:
      if (bd[i].attr->Param.Info.Flags & PWR_MASK_CLASS) {
        // This could be an IO module object, look for channels
        pwr_sAttrRef aref;

        gdh_ArefANameToAref(mod_aref, bd[i].attrName, &aref);

        sts = show_attr_channels(&aref, cardp, card_subid, card_cid);
        if (EVEN(sts))
          return sts;
      }
      continue;
    }

    chan_cid = bd[i].attr->Param.TypeRef;

    if (bd[i].attr->Param.Info.Flags & PWR_MASK_ARRAY)
      elem = bd[i].attr->Param.Info.Elements;
    else
      elem = 1;

    for (int j = 0; j < elem; j++) {
      t.elem_cnt = 0;
      ts.subid_cnt = 0;

      if (elem == 1) {
        strcpy(object_name, mod_name);
        strcat(object_name, ".");
        strcat(object_name, bd[i].attrName);
      } else {
        sprintf(object_name, "%s.%s[%d]", mod_name, bd[i].attrName, j);
      }

      sts = gdh_NameToAttrref(pwr_cNOid, object_name, &aref);
      if (EVEN(sts))
        return sts;

      sts = gdh_DLRefObjectInfoAttrref(&aref, &chanp, &subid);
      if (EVEN(sts))
        return sts;

      ts.subid[ts.subid_cnt++] = subid;
      if (card_subid->nid != 0) {
        ts.subid[ts.subid_cnt++] = *card_subid;
        *card_subid = pwr_cNSubid;
      }

      t.user = calloc(1, sizeof(tab_sChannelFlagsData));
      ((tab_sChannelFlagsData*)t.user)->chanp = chanp;
      ((tab_sChannelFlagsData*)t.user)->cardp = cardp;
      ((tab_sChannelFlagsData*)t.user)->card_cid = card_cid;
      ((tab_sChannelFlagsData*)t.user)->chan_cid = chan_cid;

      // Get connected signal
      strcpy(attr_name, object_name);
      strcat(attr_name, ".SigChanCon");
      sts = gdh_GetObjectInfo(
          attr_name, (void*)&signal_aref, sizeof(signal_aref));
      if (ODD(sts)) {
        sts = gdh_AttrrefToName(
            &signal_aref, signal_name, sizeof(signal_name), cdh_mNName);
        if (EVEN(sts)) {
          signal_aref.Objid = pwr_cNObjid;
          strcpy(signal_name, "-");
        }
      } else
        signal_aref.Objid = pwr_cNObjid;

      // Object name
      xnav_cut_segments(namebuf, object_name, 2);

      strcpy(t.elem[t.elem_cnt].fix_str, namebuf);
      t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

      // Value
      if (cdh_ObjidIsNotNull(signal_aref.Objid)
          && !(chan_cid == pwr_cClass_ChanBi || chan_cid == pwr_cClass_ChanBo
                 || chan_cid == pwr_cClass_ChanBiBlob
                 || chan_cid == pwr_cClass_ChanBiBlob)) {
        strcpy(attr_name, signal_name);
        switch (chan_cid) {
        case pwr_cClass_ChanDi:
        case pwr_cClass_ChanDo:
        case pwr_cClass_ChanD:
        case pwr_cClass_ChanAi:
        case pwr_cClass_ChanAo:
        case pwr_cClass_ChanIi:
        case pwr_cClass_ChanIo:
          strcat(attr_name, ".ActualValue");
          break;
        case pwr_cClass_ChanCo:
          strcat(attr_name, ".RawValue");
          break;
        }
        sts = gdh_GetAttributeCharacteristics(
            attr_name, &attrtype, &attrsize, &attroffs, &attrelem);
        if (EVEN(sts)) {
          free(t.user);
          return sts;
        }

        sts = gdh_NameToAttrref(pwr_cNObjid, attr_name, &attrref);
        if (EVEN(sts)) {
          free(t.user);
          return sts;
        }

        sts = gdh_DLRefObjectInfoAttrref(&attrref, &attr_ptr, &subid);
        if (EVEN(sts)) {
          free(t.user);
          return sts;
        }

        t.elem[t.elem_cnt].value_p = attr_ptr;
        t.elem[t.elem_cnt].type_id = attrtype;
        t.elem[t.elem_cnt].size = attrsize;

        switch (chan_cid) {
        case pwr_cClass_ChanDi:
        case pwr_cClass_ChanDo:
        case pwr_cClass_ChanD:
        case pwr_cClass_ChanIi:
        case pwr_cClass_ChanIo:
        case pwr_cClass_ChanCo:
          strcpy(t.elem[t.elem_cnt++].format, "%8d");
          break;
        case pwr_cClass_ChanAi:
        case pwr_cClass_ChanAo:
          strcpy(t.elem[t.elem_cnt++].format, "%f");
          break;
        }
        ts.subid[ts.subid_cnt++] = subid;
      } else
        t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;

      // Flags
      t.elem[t.elem_cnt].value_p = calloc(1, sizeof(pwr_tString80));
      t.elem[t.elem_cnt].size = sizeof(pwr_tString80);
      strcpy(t.elem[t.elem_cnt].format, "%s");
      t.elem[t.elem_cnt++].type_id = pwr_eType_String;

      // Signal
      if (cdh_ObjidIsNotNull(signal_aref.Objid)) {
        strcpy(t.elem[t.elem_cnt].fix_str, signal_name);
      } else
        strcpy(t.elem[t.elem_cnt].fix_str, "-");
      t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

      // Description in signal
      t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;
      t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;
      t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;

      if (cdh_ObjidIsNotNull(signal_aref.Objid))
        strcpy(attr_name, signal_name);
      else
        strcpy(attr_name, object_name);
      strcat(attr_name, ".Description");
      sts = gdh_GetObjectInfo(attr_name, (void*)&descr, sizeof(descr));
      if (EVEN(sts)) {
        free(t.user);
        return sts;
      }

      strcpy(t.elem[t.elem_cnt].fix_str, descr);
      t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

      item = new ItemChannel(brow, this, mod_aref->Objid, &t, &ts, -1, 0, 0, 1,
          NULL, flow_eDest_IntoLast);
      item->signal_aref = signal_aref;
    }
  }
  free((char*)bd);
  return XNAV__SUCCESS;
}

int XNav::show_object(pwr_tAttrRef* oarp, brow_tNode node)
{
  double node_x, node_y;

  if (cdh_ObjidIsNull(oarp->Objid))
    return 1;

  brow_GetNodePosition(node, &node_x, &node_y);

  if (brow_IsOpen(node) & xnav_mOpen_Attributes) {
    // Attributes is open, close
    brow_SetNodraw(brow->ctx);
    brow_CloseNode(brow->ctx, node);
    brow_ResetOpen(node, xnav_mOpen_Attributes);
    brow_RemoveAnnotPixmap(node, 1);
    brow_ResetNodraw(brow->ctx);
    brow_Redraw(brow->ctx, node_y);
  } else {
    int sts;
    Item* item;
    pwr_tTypeId atype;
    unsigned int asize, aoffset, adim, aflags;

    if (brow_IsOpen(node) & xnav_mOpen_Children
        || brow_IsOpen(node) & xnav_mOpen_Crossref) {
      // Close children first
      brow_SetNodraw(brow->ctx);
      brow_CloseNode(brow->ctx, node);
      brow_ResetOpen(node, xnav_mOpen_Children);
      brow_ResetOpen(node, xnav_mOpen_Crossref);
      brow_SetAnnotPixmap(node, 0, brow->pixmap_map);
      brow_ResetNodraw(brow->ctx);
      brow_Redraw(brow->ctx, node_y);
    }

    sts = gdh_GetAttributeCharAttrref(oarp, &atype, &asize, &aoffset, &adim);

    if (oarp->Flags.b.Object) {
      item = (Item*)new ItemObject(
          brow, oarp->Objid, node, flow_eDest_IntoLast, 0);
    } else {
      pwr_tAName aname;
      pwr_tOName attrname;
      char* s;

      sts = gdh_AttrrefToName(oarp, aname, sizeof(aname), cdh_mNName);
      if (EVEN(sts))
        return sts;

      if ((s = strchr(aname, '.')))
        strcpy(attrname, s + 1);

      aflags = PWR_MASK_CLASS;

      item = (Item*)new ItemAttrObject(brow, oarp->Objid, node,
          flow_eDest_IntoLast, attrname, atype, asize, aflags, 0, 0);
    }
    brow_SetOpen(node, xnav_mOpen_Attributes);
    brow_SetAnnotPixmap(node, 1, brow->pixmap_openattr);

    item->open_attributes(brow, node_x, node_y);
  }
  return 1;
}

int XNav::show_remnode()
{
  item_sTableHeader th;
  item_sTable t;
  item_sTableSubid ts;
  pwr_tOName object_name;
  char id[40];
  char description[80];
  int sts;
  pwr_tObjid objid;
  pwr_tOName namebuf;
  pwr_tCid cid = 0;
  void* object_ptr;

  brow_pop();
  brow_SetNodraw(brow->ctx);

  th.table_cnt = 0;
  strcpy(th.title[th.table_cnt++], "RemNode");
  strcpy(th.title[th.table_cnt++], "");
  strcpy(th.title[th.table_cnt++], "Type");
  strcpy(th.title[th.table_cnt++], "Description");
  new ItemTableHeader(brow, this, "Title", &th, NULL, flow_eDest_IntoLast);

  for (int i = 0; i < 10; i++) {
    switch (i) {
    case 0:
      cid = pwr_cClass_RemnodeUDP;
      break;
    case 1:
      cid = pwr_cClass_RemnodeTCP;
      break;
    case 2:
      cid = pwr_cClass_Remnode3964R;
      break;
    case 3:
      cid = pwr_cClass_RemnodeALCM;
      break;
    case 4:
      cid = pwr_cClass_RemnodeSerial;
      break;
    case 5:
      cid = pwr_cClass_RemnodeModbus;
      break;
    case 6:
      cid = pwr_cClass_RemnodeMQ;
      break;
    case 7:
      cid = pwr_cClass_RemnodeWMQ;
      break;
    case 8:
      cid = pwr_cClass_RemnodeQCom;
      break;
    case 9:
      cid = pwr_cClass_RemnodeRabbitMQ;
      break;
    }

    sts = gdh_GetClassList(cid, &objid);
    while (ODD(sts)) {
      sts = gdh_ObjidToPointer(objid, (void**)&object_ptr);
      if (EVEN(sts))
        return sts;

      sts = gdh_ObjidToName(
          objid, object_name, sizeof(object_name), cdh_mName_volumeStrict);
      if (EVEN(sts))
        return sts;

      switch (i) {
      case 0:
        strncpy(id, ((pwr_sClass_RemnodeUDP*)object_ptr)->Id, sizeof(id));
        strncpy(description, ((pwr_sClass_RemnodeUDP*)object_ptr)->Description,
            sizeof(description));
        break;
      case 1:
        strncpy(id, ((pwr_sClass_RemnodeTCP*)object_ptr)->Id, sizeof(id));
        strncpy(description, ((pwr_sClass_RemnodeTCP*)object_ptr)->Description,
            sizeof(description));
        break;
      case 2:
        strncpy(id, ((pwr_sClass_Remnode3964R*)object_ptr)->Id, sizeof(id));
        strncpy(description,
            ((pwr_sClass_Remnode3964R*)object_ptr)->Description,
            sizeof(description));
        break;
      case 3:
        strncpy(id, ((pwr_sClass_RemnodeALCM*)object_ptr)->Id, sizeof(id));
        strncpy(description, ((pwr_sClass_RemnodeALCM*)object_ptr)->Description,
            sizeof(description));
        break;
      case 4:
        strncpy(id, ((pwr_sClass_RemnodeSerial*)object_ptr)->Id, sizeof(id));
        strncpy(description,
            ((pwr_sClass_RemnodeSerial*)object_ptr)->Description,
            sizeof(description));
        break;
      case 5:
        strncpy(id, ((pwr_sClass_RemnodeModbus*)object_ptr)->Id, sizeof(id));
        strncpy(description,
            ((pwr_sClass_RemnodeModbus*)object_ptr)->Description,
            sizeof(description));
        break;
      case 6:
        strncpy(id, ((pwr_sClass_RemnodeMQ*)object_ptr)->Id, sizeof(id));
        strncpy(description, ((pwr_sClass_RemnodeMQ*)object_ptr)->Description,
            sizeof(description));
        break;
      case 7:
        strncpy(id, ((pwr_sClass_RemnodeWMQ*)object_ptr)->Id, sizeof(id));
        strncpy(description, ((pwr_sClass_RemnodeWMQ*)object_ptr)->Description,
            sizeof(description));
        break;
      case 8:
        strncpy(id, ((pwr_sClass_RemnodeQCom*)object_ptr)->Id, sizeof(id));
        strncpy(description, ((pwr_sClass_RemnodeQCom*)object_ptr)->Description,
            sizeof(description));
        break;
      case 9:
        strncpy(id, ((pwr_sClass_RemnodeRabbitMQ*)object_ptr)->Id, sizeof(id));
        strncpy(description,
            ((pwr_sClass_RemnodeRabbitMQ*)object_ptr)->Description,
            sizeof(description));
        break;
      }

      t.elem_cnt = 0;

      // Object name
      xnav_cut_segments(namebuf, object_name, 2);

      strcpy(t.elem[t.elem_cnt].fix_str, namebuf);
      t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

      t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;

      // Type
      strcpy(t.elem[t.elem_cnt].fix_str, id);
      t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

      // Description
      strcpy(t.elem[t.elem_cnt].fix_str, description);
      t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

      ts.subid_cnt = 0;
      new ItemRemNode(
          brow, this, objid, &t, &ts, -1, 0, 0, 1, NULL, flow_eDest_IntoLast);

      sts = gdh_GetNextObject(objid, &objid);
    }
  }

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
  force_trace_scan();
  return XNAV__SUCCESS;
}

int XNav::show_remtrans(pwr_tObjid remnode_objid)
{
  item_sTableHeader th;
  item_sTable t;
  item_sTableSubid ts;
  pwr_tTypeId attrtype;
  unsigned int attrsize, attroffs, attrelem;
  pwr_tSubid subid;
  pwr_tOName object_name;
  pwr_tAName attr_name;
  int sts;
  pwr_tObjid objid;
  pwr_sAttrRef attrref;
  pwr_sClass_RemTrans* object_ptr;
  pwr_tOName namebuf;
  pwr_tCid cid;

  brow_pop();
  brow_SetNodraw(brow->ctx);

  th.table_cnt = 0;
  strcpy(th.title[th.table_cnt++], "RemTrans");
  strcpy(th.title[th.table_cnt++], "");
  strcpy(th.title[th.table_cnt++], "DataValid");
  strcpy(th.title[th.table_cnt++], "Direction");
  strcpy(th.title[th.table_cnt++], "TransCnt");
  strcpy(th.title[th.table_cnt++], "TransTime");
  strcpy(th.title[th.table_cnt++], "");
  strcpy(th.title[th.table_cnt++], "ErrCount");
  strcpy(th.title[th.table_cnt++], "LastSts");
  new ItemTableHeader(brow, this, "Title", &th, NULL, flow_eDest_IntoLast);

  if (cdh_ObjidIsNull(remnode_objid))
    sts = gdh_GetClassList(pwr_cClass_RemTrans, &objid);
  else
    sts = gdh_GetChild(remnode_objid, &objid);
  while (ODD(sts)) {
    sts = gdh_GetObjectClass(objid, &cid);
    if (EVEN(sts))
      return sts;

    if (cid == pwr_cClass_RemTrans) {
      attrref = cdh_ObjidToAref(objid);
      sts = gdh_DLRefObjectInfoAttrref(
          &attrref, (pwr_tAddress*)&object_ptr, &subid);
      if (EVEN(sts))
        return sts;

      sts = gdh_ObjidToName(
          objid, object_name, sizeof(object_name), cdh_mName_volumeStrict);
      if (EVEN(sts))
        return sts;

      t.elem_cnt = 0;

      // Object name
      xnav_cut_segments(namebuf, object_name, 1);

      strcpy(t.elem[t.elem_cnt].fix_str, namebuf);
      t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

      t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;

      // DataValid
      strcpy(attr_name, object_name);
      strcat(attr_name, ".DataValid");
      sts = gdh_GetAttributeCharacteristics(
          attr_name, &attrtype, &attrsize, &attroffs, &attrelem);
      if (EVEN(sts))
        return sts;

      t.elem[t.elem_cnt].value_p = &object_ptr->DataValid;
      t.elem[t.elem_cnt].type_id = attrtype;
      t.elem[t.elem_cnt].size = attrsize;
      strcpy(t.elem[t.elem_cnt++].format, "%2d");

      // Direction
      switch (object_ptr->Direction) {
      case 1:
        strcpy(t.elem[t.elem_cnt].fix_str, "Rcv");
        break;
      case 2:
        strcpy(t.elem[t.elem_cnt].fix_str, "Snd");
        break;
      }
      t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

      // TransCount
      strcpy(attr_name, object_name);
      strcat(attr_name, ".TransCount");
      sts = gdh_GetAttributeCharacteristics(
          attr_name, &attrtype, &attrsize, &attroffs, &attrelem);
      if (EVEN(sts))
        return sts;

      t.elem[t.elem_cnt].value_p = &object_ptr->TransCount;
      t.elem[t.elem_cnt].type_id = attrtype;
      t.elem[t.elem_cnt].size = attrsize;
      strcpy(t.elem[t.elem_cnt++].format, "%2d");

      // TransTime
      strcpy(attr_name, object_name);
      strcat(attr_name, ".TransTime");
      sts = gdh_GetAttributeCharacteristics(
          attr_name, &attrtype, &attrsize, &attroffs, &attrelem);
      if (EVEN(sts))
        return sts;

      t.elem[t.elem_cnt].value_p = &object_ptr->TransTime;
      t.elem[t.elem_cnt].type_id = attrtype;
      t.elem[t.elem_cnt].size = attrsize;
      strcpy(t.elem[t.elem_cnt++].format, "");

      t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;

      // ErrCount
      strcpy(attr_name, object_name);
      strcat(attr_name, ".ErrCount");
      sts = gdh_GetAttributeCharacteristics(
          attr_name, &attrtype, &attrsize, &attroffs, &attrelem);
      if (EVEN(sts))
        return sts;

      t.elem[t.elem_cnt].value_p = &object_ptr->ErrCount;
      t.elem[t.elem_cnt].type_id = attrtype;
      t.elem[t.elem_cnt].size = attrsize;
      strcpy(t.elem[t.elem_cnt++].format, "%8d");

      // LastSts
      strcpy(attr_name, object_name);
      strcat(attr_name, ".LastSts");
      sts = gdh_GetAttributeCharacteristics(
          attr_name, &attrtype, &attrsize, &attroffs, &attrelem);
      if (EVEN(sts))
        return sts;

      t.elem[t.elem_cnt].value_p = &object_ptr->LastSts;
      t.elem[t.elem_cnt].type_id = attrtype;
      t.elem[t.elem_cnt].size = attrsize;
      strcpy(t.elem[t.elem_cnt++].format, "%8d");

      ts.subid[0] = subid;
      ts.subid_cnt = 1;
      new ItemRemTrans(
          brow, this, objid, &t, &ts, -1, 0, 0, 0, NULL, flow_eDest_IntoLast);
    }
    if (cdh_ObjidIsNull(remnode_objid))
      sts = gdh_GetNextObject(objid, &objid);
    else
      sts = gdh_GetNextSibling(objid, &objid);
  }

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
  force_trace_scan();
  return XNAV__SUCCESS;
}

int XNav::show_plcpgm()
{
  item_sTableHeader th;
  item_sTable t;
  item_sTableSubid ts;
  pwr_tOName object_name;
  pwr_tAName attr_name;
  int sts;
  pwr_tObjid objid;
  pwr_sClass_PlcThread* object_ptr;
  pwr_tObjid thread_objid;
  pwr_tOName namebuf;
  pwr_tObjid parent;
  pwr_tCid cid;

  brow_pop();
  brow_SetNodraw(brow->ctx);

  th.table_cnt = 0;
  strcpy(th.title[th.table_cnt++], "PlcPgm");
  strcpy(th.title[th.table_cnt++], "");
  strcpy(th.title[th.table_cnt++], "");
  strcpy(th.title[th.table_cnt++], "");
  strcpy(th.title[th.table_cnt++], "PlcThread");
  strcpy(th.title[th.table_cnt++], "Description");
  new ItemTableHeader(brow, this, "Title", &th, NULL, flow_eDest_IntoLast);

  sts = gdh_GetClassList(pwr_cClass_plc, &objid);
  while (ODD(sts)) {
    // Don't display template plcpgm in class volumes
    sts = gdh_GetParent(objid, &parent);
    if (ODD(sts)) {
      sts = gdh_GetObjectClass(parent, &cid);
      if (EVEN(sts))
        return sts;

      if (cid == pwr_eClass_ClassDef) {
        sts = gdh_GetNextObject(objid, &objid);
        continue;
      }
    }

    sts = gdh_ObjidToPointer(objid, (void**)&object_ptr);
    if (EVEN(sts))
      return sts;

    sts = gdh_ObjidToName(objid, object_name, sizeof(object_name), cdh_mNName);
    if (EVEN(sts))
      return sts;

    t.elem_cnt = 0;

    // Object name
    strcpy(t.elem[t.elem_cnt].fix_str, object_name);
    t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

    t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;
    t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;
    t.elem[t.elem_cnt++].type_id = xnav_eType_Empty;

    // ThreadObject
    strcpy(attr_name, object_name);
    strcat(attr_name, ".ThreadObject");
    sts = gdh_GetObjectInfo(
        attr_name, (void*)&thread_objid, sizeof(thread_objid));
    if (ODD(sts)) {
      sts = gdh_ObjidToName(
          thread_objid, namebuf, sizeof(namebuf), cdh_mName_object);
      if (ODD(sts))
        strcpy(t.elem[t.elem_cnt].fix_str, namebuf);
      else
        strcpy(t.elem[t.elem_cnt].fix_str, "-");
    } else
      strcpy(t.elem[t.elem_cnt].fix_str, "-");
    t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

    // Description
    strcpy(t.elem[t.elem_cnt].fix_str, object_ptr->Description);
    t.elem[t.elem_cnt++].type_id = xnav_eType_FixStr;

    ts.subid_cnt = 0;
    new ItemPlc(
        brow, this, objid, &t, &ts, -1, 0, 0, 1, NULL, flow_eDest_IntoLast);

    sts = gdh_GetNextObject(objid, &objid);
  }

  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
  force_trace_scan();
  return XNAV__SUCCESS;
}
