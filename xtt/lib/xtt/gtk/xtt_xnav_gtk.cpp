/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* xtt_xnav_gtk.cpp -- Display plant and node hierarchy */

typedef void* Widget;

#include <vector>

#include "co_nav_help.h"
#include "co_cdh.h"
#include "co_dcli.h"
#include "co_error.h"
#include "co_lng.h"
#include "co_msg.h"

#include "cow_login_gtk.h"
#include "cow_xhelp.h"

#include "flow_browwidget_gtk.h"

#include "glow_growapi.h"
#include "glow_curvectx.h"

#include "ge_curve_gtk.h"

#include "xtt_block_gtk.h"
#include "xtt_clog_gtk.h"
#include "xtt_ev_gtk.h"
#include "xtt_fast_gtk.h"
#include "xtt_fileview_gtk.h"
#include "xtt_ge_gtk.h"
#include "xtt_hist_gtk.h"
#include "xtt_item.h"
#include "xtt_keyboard_gtk.h"
#include "xtt_menu.h"
#include "xtt_multiview_gtk.h"
#include "xtt_op_gtk.h"
#include "xtt_sevhist_gtk.h"
#include "xtt_stream_gtk.h"
#include "xtt_tcurve_gtk.h"
#include "xtt_trace_gtk.h"
#include "xtt_trend_gtk.h"
#include "xtt_xatt_gtk.h"
#include "xtt_xattone_gtk.h"
#include "xtt_xcolwind_gtk.h"
#include "xtt_xcrr_gtk.h"
#include "xtt_xnav_gtk.h"

//
// Create the navigator widget
//
XNavGtk::XNavGtk(void* xn_parent_ctx, GtkWidget* xn_parent_wid,
    const char* xn_name, GtkWidget** w, xnav_sStartMenu* root_menu,
    char* xn_opplace_name, int xn_op_close_button, pwr_tStatus* status)
    : XNav(xn_parent_ctx, xn_name, root_menu, xn_opplace_name,
          xn_op_close_button, status),
      parent_wid(xn_parent_wid), clock_cursor(0)
{
  form_widget
      = scrolledbrowwidgetgtk_new(init_brow_base_cb, this, &brow_widget);

  gtk_widget_show_all(brow_widget);

  displayed = 1;

  // Create the root item
  *w = form_widget;

  menu_tree_build(root_menu);
  gbl.load_config(this);

  for (int i = 0; i < XNAV_LOGG_MAX; i++)
    logg[i].init(i, (void*)this);

  wow = new CoWowGtk(parent_wid);
  trace_timerid = wow->timer_new();
  autoack_timerid = wow->timer_new();
  *status = 1;
}

//
//  Delete a nav context
//
XNavGtk::~XNavGtk()
{
  closing_down = 1;

  delete autoack_timerid;
  delete trace_timerid;

  if (mcp) {
    free(mcp);
    mcp = 0;
  }
  menu_tree_free();
  delete (ItemMenu*)root_item;

  for (int i = 0; i < brow_cnt; i++) {
    brow_stack[i]->free_pixmaps();
    if (i != 0)
      brow_DeleteSecondaryCtx(brow_stack[i]->ctx);
    delete brow_stack[i];
  }
  collect_brow->free_pixmaps();
  brow_DeleteSecondaryCtx(collect_brow->ctx);
  delete collect_brow;
  delete brow;
  if (op)
    delete op;
  gtk_widget_destroy(form_widget);
}

void XNavGtk::set_inputfocus()
{
  if (displayed) {
    gtk_widget_grab_focus(brow_widget);
  }
}

void XNavGtk::create_popup_menu(pwr_sAttrRef attrref, xmenu_eItemType item_type,
    xmenu_mUtility caller, unsigned int priv, char* arg, int x, int y)
{
  int x1, y1;

  CoWowGtk::PopupPosition(brow_widget, x + 8, y, &x1, &y1);
  get_popup_menu(attrref, item_type, caller, priv, arg, x1, y1);
}

//
//  Pop xnav window
//
void XNavGtk::pop()
{
  GtkWidget *parent, *top = NULL;

  parent = gtk_widget_get_parent(form_widget);
  while (parent) {
    top = parent;
    parent = gtk_widget_get_parent(parent);
  }
  displayed = 1;
  gtk_window_present(GTK_WINDOW(top));
}

void XNavGtk::set_clock_cursor()
{
  if (!clock_cursor)
    clock_cursor = gdk_cursor_new_for_display(
        gtk_widget_get_display(form_widget), GDK_WATCH);

  gdk_window_set_cursor(form_widget->window, clock_cursor);
  gdk_display_flush(gtk_widget_get_display(form_widget));
}

void XNavGtk::reset_cursor()
{
  gdk_window_set_cursor(form_widget->window, NULL);
}

void XNavGtk::set_transient(void* basewidget)
{
  GtkWidget *parent, *top = NULL;

  parent = gtk_widget_get_parent(form_widget);
  while (parent) {
    top = parent;
    parent = gtk_widget_get_parent(parent);
  }
  gtk_window_set_transient_for(GTK_WINDOW(top), GTK_WINDOW(basewidget));
}

RtTrace* XNavGtk::plctrace_new(pwr_tOid oid, pwr_tStatus* sts)
{
  return new RtTraceGtk(this, form_widget, oid, sts);
}

XAtt* XNavGtk::xatt_new(pwr_tAttrRef* arp, int advanced_user, pwr_tStatus* sts)
{
  return new XAttGtk(form_widget, this, arp, advanced_user, sts);
}

XCrr* XNavGtk::xcrr_new(pwr_tAttrRef* arp, int advanced_user, pwr_tStatus* sts)
{
  return new XCrrGtk(form_widget, this, arp, advanced_user, sts);
}

XColWind* XNavGtk::xcolwind_new(pwr_tAttrRef* ar_list, char* title,
    int advanced_user, int type, pwr_tStatus* sts)
{
  return new XColWindGtk(form_widget, this, ar_list, title, advanced_user,
      (xcolwind_eType)type, sts);
}

Ev* XNavGtk::ev_new(char* eve_name, char* ala_name, char* blk_name,
    pwr_tObjid ev_user, int display_ala, int display_eve, int display_blk,
    int display_return, int display_ack, int ev_beep, pwr_tMask ev_pop_mask,
    int ev_eventname_seg, pwr_tStatus* status)
{
  return new EvGtk(this, parent_wid, eve_name, ala_name, blk_name, ev_user,
      display_ala, display_eve, display_blk, display_return, display_ack,
      ev_beep, ev_pop_mask, ev_eventname_seg, status);
}

Hist* XNavGtk::hist_new(char* title, pwr_tAttrRef* arp, pwr_tStatus* sts)
{
  return new HistGtk(this, parent_wid, title, arp, sts);
}

Block* XNavGtk::block_new(
    pwr_tAttrRef* arp, char* name, unsigned int priv, pwr_tStatus* sts)
{
  return new BlockGtk(this, parent_wid, arp, name, priv, sts);
}

Op* XNavGtk::op_new(char* opplace, pwr_tStatus* sts)
{
  return new OpGtk(this, parent_wid, opplace, sts);
}

XttTrend* XNavGtk::xtttrend_new(char* name, pwr_tAttrRef* objar,
    pwr_tAttrRef* plotgroup, int width, int height, unsigned int options,
    int color_theme, void* basewidget, pwr_tStatus* sts)
{
  GtkWidget* w;

  return new XttTrendGtk(this, parent_wid, name, &w, objar, plotgroup, width,
      height, options, color_theme, basewidget, sts);
}

XttSevHist* XNavGtk::xttsevhist_new(char* name, pwr_tOid* oidv,
    pwr_tOName* anamev, pwr_tOName* onamev, bool* sevhistobjectv,
    sevcli_tCtx scctx, char* filename, int width, int height,
    unsigned int options, int color_theme, time_ePeriod time_range,
    void* basewidget, pwr_tStatus* sts)
{
  GtkWidget* w;

  if (!filename)
    return new XttSevHistGtk(this, parent_wid, name, &w, oidv, anamev, onamev,
        sevhistobjectv, scctx, width, height, options, color_theme, time_range,
        basewidget, sts);
  else
    return new XttSevHistGtk(
        this, parent_wid, name, &w, filename, color_theme, basewidget, sts);
}

XttTCurve* XNavGtk::xtttcurve_new(char* name, pwr_tAttrRef* arefv, int width,
    int height, unsigned int options, int color_theme, void* basewidget,
    pwr_tStatus* sts)
{
  GtkWidget* w;

  return new XttTCurveGtk(this, parent_wid, name, &w, arefv, width, height,
      options, color_theme, basewidget, sts);
}

XttFast* XNavGtk::xttfast_new(char* name, pwr_tAttrRef* objar, int width,
    int height, unsigned int options, char* filename, int color_theme,
    void* basewidget, pwr_tStatus* sts)
{
  GtkWidget* w;

  if (!filename)
    return new XttFastGtk(this, parent_wid, name, &w, objar, width, height,
        options, color_theme, basewidget, sts);
  else
    return new XttFastGtk(
        this, parent_wid, name, &w, filename, color_theme, basewidget, sts);
}

XAttOne* XNavGtk::xattone_new(
    pwr_tAttrRef* objar, char* title, unsigned int priv, pwr_tStatus* sts)
{
  return new XAttOneGtk(parent_wid, this, objar, title, priv, sts);
}

CLog* XNavGtk::clog_new(const char* name, pwr_tStatus* sts)
{
  return new CLogGtk(this, parent_wid, name, sts);
}

XttOTree* XNavGtk::tree_new(const char* title, pwr_tAttrRef* itemlist,
    int itemcnt, unsigned int options,
    pwr_tStatus (*action_cb)(void*, pwr_tAttrRef*))
{
  return new XttOTreeGtk(
      parent_wid, this, title, itemlist, itemcnt, options, action_cb);
}

XttGe* XNavGtk::xnav_ge_new(const char* name, const char* filename,
    int scrollbar, int menu, int navigator, int width, int height, int x, int y,
    double scan_time, const char* object_name, int use_default_access,
    unsigned int access, unsigned int options, void* basewidget,
    double* borders, int color_theme, int dashboard,
    int (*command_cb)(void*, char*, char*, void*),
    int (*get_current_objects_cb)(void*, pwr_sAttrRef**, int**),
    int (*is_authorized_cb)(void*, unsigned int),
    void (*keyboard_cb)(void*, void*, int, int))
{
  return new XttGeGtk(parent_wid, this, name, filename, scrollbar, menu,
      navigator, width, height, x, y, scan_time, object_name,
      use_default_access, access, options, basewidget, borders, color_theme,
      dashboard, command_cb, get_current_objects_cb, is_authorized_cb, keyboard_cb);
}

XttMultiView* XNavGtk::multiview_new(const char* name, pwr_tAttrRef* aref,
    int width, int height, int x, int y, unsigned int options, void* basewidget,
    int color_theme, pwr_tStatus* sts,
    int (*command_cb)(void*, char*, char*, void*),
    int (*get_current_objects_cb)(void*, pwr_sAttrRef**, int**),
    int (*is_authorized_cb)(void*, unsigned int),
    void (*keyboard_cb)(void*, void*, int, int))
{
  return new XttMultiViewGtk(parent_wid, this, name, aref, width, height, x, y,
      options, basewidget, color_theme, sts, command_cb, get_current_objects_cb,
      is_authorized_cb, keyboard_cb);
}

XttStream* XNavGtk::stream_new(const char* name, const char* uri, int width,
    int height, int x, int y, double scan_time, unsigned int options,
    int embedded, pwr_tAttrRef* arp, pwr_tStatus* sts)
{
  return new XttStreamGtk(parent_wid, this, name, uri, width, height, x, y,
      scan_time, options, embedded, arp, sts);
}

GeCurve* XNavGtk::gecurve_new(char* name, char* filename, GeCurveData* data,
    int pos_right, unsigned int options, int color_theme, void* basewidget)
{
  return new GeCurveGtk(this, parent_wid, name, filename, data, pos_right, 0, 0,
      options, color_theme, basewidget);
}

XttFileview* XNavGtk::fileview_new(pwr_tOid oid, char* title, char* dir,
    char* pattern, int type, char* target_attr, char* trigger_attr,
    char* filetype)
{
  return new XttFileviewGtk(this, parent_wid, oid, title, dir, pattern, type,
      target_attr, trigger_attr, filetype);
}

CoLogin* XNavGtk::login_new(const char* name, const char* groupname,
    void (*bc_success)(void*), void (*bc_cancel)(void*), void* basewidget,
    pwr_tStatus* status)
{
  return new CoLoginGtk(this, parent_wid, name, groupname, bc_success,
      bc_cancel, basewidget, status);
}

XttKeyboard* XNavGtk::keyboard_new(const char* name, keyboard_eKeymap keymap,
    keyboard_eType type, int color_theme, pwr_tStatus* sts)
{
  GtkWidget* w;
  return new XttKeyboardGtk(
      this, parent_wid, name, &w, keymap, type, color_theme, sts);
}

void XNavGtk::bell(int time)
{
  gdk_display_beep(gtk_widget_get_display(brow_widget));
}

void XNavGtk::get_popup_menu(pwr_sAttrRef attrref, xmenu_eItemType item_type,
    xmenu_mUtility caller, unsigned int priv, char* arg, int x, int y)
{
  int i;
  GtkWidget* popup;

  get_popup_menu_items(attrref, item_type, caller, priv, arg);

  i = 0;
  popup = build_menu(parent_wid, MENU_POPUP, "", mcp, popup_button_cb,
      (void*)this, (xmenu_sMenuItem*)mcp->ItemList, &i);
  if (!popup)
    return;

  popupmenu_x = x;
  popupmenu_y = y;
  gtk_menu_popup(GTK_MENU(popup), NULL, NULL, menu_position_func, this, 0,
      gtk_get_current_event_time());
}

void XNavGtk::menu_position_func(
    GtkMenu* menu, gint* x, gint* y, gboolean* push_in, gpointer data)
{
  XNavGtk* xnav = (XNavGtk*)data;

  *x = xnav->popupmenu_x;
  *y = xnav->popupmenu_y;
  *push_in = FALSE;
}

GtkWidget* XNavGtk::build_menu(GtkWidget* Parent, int MenuType,
    const char* MenuTitle, void* MenuUserData,
    void (*Callback)(GtkWidget*, gpointer), void* CallbackData,
    xmenu_sMenuItem* Items, int* idx)
{
  GtkWidget *Menu, *W;
  int i;
  unsigned int Level;

  Menu = (GtkWidget*)g_object_new(GTK_TYPE_MENU, NULL);
  g_object_set_data((GObject*)Menu, "userdata", (gpointer)MenuUserData);

  Level = Items[*idx].Level;

  for (; Items[*idx].Level != 0 && Items[*idx].Level >= Level; (*idx)++) {
    switch (Items[*idx].Item) {
    case xmenu_eMenuItem_Ref: {
      if (MenuType == MENU_OPTION) {
        printf("You can't have submenus from option menu items.");
        return NULL;
      }

      i = *idx;
      GtkWidget* sub = gtk_menu_item_new_with_label(
          CoWowGtk::translate_utf8(Items[*idx].Name));
      (*idx)++;
      W = build_menu(Menu, MENU_PULLDOWN, Lng::translate(Items[i].Name),
          MenuUserData, Callback, CallbackData, Items, idx);
      (*idx)--;
      gtk_menu_item_set_submenu(GTK_MENU_ITEM(sub), GTK_WIDGET(W));
      gtk_menu_shell_append(GTK_MENU_SHELL(Menu), sub);
      gtk_widget_show(sub);
      break;
    }
    case xmenu_eMenuItem_Cascade: {
      if (MenuType == MENU_OPTION) {
        printf("You can't have submenus from option menu items.");
        return NULL;
      }

      // Check that the Cascade contains any pushbuttons
      int found = 0;
      unsigned int cascade_level = Items[*idx].Level;
      int cidx;
      for (cidx = *idx + 1;
           Items[cidx].Level != 0 && Items[cidx].Level > cascade_level;
           cidx++) {
        if (Items[cidx].Item == xmenu_eMenuItem_Ref
            || Items[cidx].Item == xmenu_eMenuItem_Button) {
          found = 1;
          break;
        }
      }
      if (found) {
        i = *idx;
        GtkWidget* sub = gtk_menu_item_new_with_label(
            CoWowGtk::translate_utf8(Items[*idx].Name));
        (*idx)++;
        W = build_menu(Menu, MENU_PULLDOWN, Lng::translate(Items[i].Name),
            MenuUserData, Callback, CallbackData, Items, idx);
        (*idx)--;
        gtk_menu_item_set_submenu(GTK_MENU_ITEM(sub), GTK_WIDGET(W));
        gtk_menu_shell_append(GTK_MENU_SHELL(Menu), sub);
        gtk_widget_show(sub);
      } else {
        *idx = cidx - 1;
      }
      break;
    }
    case xmenu_eMenuItem_Separator:
      // Separator
      W = gtk_separator_menu_item_new();
      gtk_menu_shell_append(GTK_MENU_SHELL(Menu), W);
      gtk_widget_show(W);
      break;
    case xmenu_eMenuItem_Button:
      // Pushbutton
      W = gtk_menu_item_new_with_label(
          CoWowGtk::translate_utf8(Items[*idx].Name));
      gtk_widget_set_sensitive(W, Items[*idx].Flags.f.Sensitive);
      g_object_set_data((GObject*)W, "userdata", (gpointer)((long int)*idx));
      if (Callback)
        g_signal_connect(W, "activate", G_CALLBACK(Callback), CallbackData);
      gtk_menu_shell_append(GTK_MENU_SHELL(Menu), W);
      gtk_widget_show(W);
      break;
    default:;
    }
  }

  return Menu;
}

void XNavGtk::popup_button_cb(GtkWidget* w, gpointer data)
{
  XNav* xnav = (XNav*)data;
  int idx;
  pwr_tStatus sts;

  idx = (int)(unsigned long)g_object_get_data((GObject*)w, "userdata");

  xnav->mcp->ChosenItem = idx;
  // xnav->set_clock_cursor();
  sts = CallMenuMethod(xnav->mcp, xnav->mcp->ChosenItem);
  if (EVEN(sts))
    xnav->message('E', XNav::get_message(sts));
  // xnav->reset_cursor();
}

static void xnav_confirm_dialog_ok(void* ctx, void* data)
{
  ((XNav*)ctx)->dialog_ok = 1;
  gtk_main_quit();
}

static void xnav_confirm_dialog_cancel(void* ctx, void* data)
{
  ((XNav*)ctx)->dialog_cancel = 1;
  gtk_main_quit();
}

int XNavGtk::confirm_dialog(char* title, char* text)
{
  dialog_ok = 0;
  dialog_cancel = 0;
  wow->DisplayQuestion(
      this, title, text, xnav_confirm_dialog_ok, xnav_confirm_dialog_cancel, 0);

  gtk_main();

  if (dialog_ok) {
    return 1;
  }
  if (dialog_cancel) {
    return 0;
  }
  return 0;
}
