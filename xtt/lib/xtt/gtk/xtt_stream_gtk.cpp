/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2014 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 */


#if defined PWRE_CONF_GST

#include <string.h>
#include <math.h>
#include "xtt_xnav.h"
  
#include <gtk/gtk.h>
#include <gst/gst.h>
#include <gst/interfaces/xoverlay.h>
  
#include <gdk/gdk.h>
#include <gdk/gdkx.h>

#include "pwr.h"
#include "co_dcli.h"
#include "co_time.h"
#include "xtt_stream_gtk.h"  
#include "rt_xnav_msg.h"
#include "cow_wow_gtk.h"

int XttStreamGtk::gst_initialized = 0;
  
static GstBusSyncReply bus_sync_handler (GstBus * bus, GstMessage * message, 
					 gpointer data)
{
  return GST_BUS_PASS;
#if 0
  XttStreamGtk *strm = (XttStreamGtk *)data;

  printf( "Bus sync handler\n");

  if (GST_MESSAGE_TYPE (message) != GST_MESSAGE_ELEMENT)

  if (!gst_structure_has_name (message->structure, "prepare-xwindow-id"))
    return GST_BUS_PASS;

  strm->overlay = GST_X_OVERLAY (GST_MESSAGE_SRC (message));
  printf( "Overlay: %u\n", strm->overlay);

  GdkWindow *window = gtk_widget_get_window( strm->video_form);
  guintptr window_handle;
  
  if (!gdk_window_ensure_native (window))
    g_error ("Couldn't create native window needed for GstXOverlay!");
  
  window_handle = GDK_WINDOW_XID( window);
  gst_x_overlay_set_xwindow_id( GST_X_OVERLAY (strm->playbin2), window_handle);

  return GST_BUS_DROP;
#endif
}

/* This function is called when the GUI toolkit creates the physical window that will hold the video.
 * At this point we can retrieve its handler (which has a different meaning depending on the windowing system)
 * and pass it to GStreamer through the XOverlay interface. */
void XttStreamGtk::realize_cb( GtkWidget *widget, void *data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  GdkWindow *window = gtk_widget_get_window( strm->video_form);
  guintptr window_handle;
  
  if (!gdk_window_ensure_native (window))
    g_error ("Couldn't create native window needed for GstXOverlay!");
  
  window_handle = GDK_WINDOW_XID( window);
  gst_x_overlay_set_xwindow_id( GST_X_OVERLAY (strm->playbin2), window_handle);
}
  
/* This function is called when the PLAY button is clicked */
void XttStreamGtk::play_cb( GtkButton *button, void *data) 
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  gst_element_set_state( strm->playbin2, GST_STATE_PLAYING);
}
  
/* This function is called when the PAUSE button is clicked */
void XttStreamGtk::pause_cb( GtkButton *button, void *data) 
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  gst_element_set_state( strm->playbin2, GST_STATE_PAUSED);
}
  
/* This function is called when the STOP button is clicked */
void XttStreamGtk::stop_cb( GtkButton *button, void *data) 
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  gst_element_set_state( strm->playbin2, GST_STATE_READY);
}
  
/* This function is called when the main window is closed */
void XttStreamGtk::delete_event_cb (GtkWidget *widget, GdkEvent *event, void *data) 
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  stop_cb( NULL, strm);

  if ( strm->close_cb)
    (strm->close_cb)( strm->parent_ctx, strm);
  delete strm;  
}
  
/* This function is called everytime the video window needs to be redrawn (due to damage/exposure,
 * rescaling, etc). GStreamer takes care of this in the PAUSED and PLAYING states, otherwise,
 * we simply draw a black rectangle to avoid garbage showing up. */
gboolean XttStreamGtk::expose_cb( GtkWidget *widget, GdkEventExpose *event, void *data) 
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  if (strm->state < GST_STATE_PAUSED) {
    GtkAllocation allocation;
    GdkWindow *window = gtk_widget_get_window( widget);
    cairo_t *cr;
    
    /* Cairo is a 2D graphics library which we use here to clean the video window.
     * It is used by GStreamer for other reasons, so it will always be available to us. */
    gtk_widget_get_allocation( widget, &allocation);
    cr = gdk_cairo_create (window);
    cairo_set_source_rgb( cr, 0, 0, 0);
    cairo_rectangle( cr, 0, 0, allocation.width, allocation.height);
    cairo_fill( cr);
    cairo_destroy( cr);
  }
  
  return FALSE;
}
  
/* This function is called when the slider changes its position. We perform a seek to the
 * new position here. */
void XttStreamGtk::slider_cb( GtkRange *range, void *data) 
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  gdouble value = gtk_range_get_value( GTK_RANGE( strm->slider));
  gst_element_seek_simple( strm->playbin2, GST_FORMAT_TIME, GstSeekFlags(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT),
      (gint64)(value * GST_SECOND));
}
  
/* This function is called periodically to refresh the GUI */
void XttStreamGtk::refresh_ui( XttStreamGtk *strm) 
{
  GstFormat fmt = GST_FORMAT_TIME;
  gint64 current = -1;
  
  if ( !(strm->options & strm_mOptions_VideoControlPanel && 
	 strm->options & strm_mOptions_VideoProgressBar))
    return;

  /* We do not want to update anything unless we are in the PAUSED or PLAYING states */
  if (strm->state < GST_STATE_PAUSED)
    return;
  
  /* If we didn't know it yet, query the stream duration */
  if (!GST_CLOCK_TIME_IS_VALID( strm->duration)) {
    if (!gst_element_query_duration( strm->playbin2, &fmt, &strm->duration)) {
      g_printerr( "Could not query current duration.\n");
    } else {
      /* Set the range of the slider to the clip duration, in SECONDS */
      if (GST_CLOCK_TIME_IS_VALID( strm->duration))
	gtk_range_set_range( GTK_RANGE( strm->slider), 0, (gdouble)strm->duration / GST_SECOND);
    }
  }
  
  if (gst_element_query_position( strm->playbin2, &fmt, &current)) {
    /* Block the "value-changed" signal, so the slider_cb function is not called
     * (which would trigger a seek the user has not requested) */
    g_signal_handler_block( strm->slider, strm->slider_update_signal_id);
    /* Set the position of the slider to the current pipeline positoin, in SECONDS */
    gtk_range_set_value( GTK_RANGE( strm->slider), (gdouble)current / GST_SECOND);
    /* Re-enable the signal */
    g_signal_handler_unblock( strm->slider, strm->slider_update_signal_id);
  }

}
  
void XttStreamGtk::refresh( void *data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  refresh_ui( strm);

  strm->timerid->add( strm->scan_time, strm->refresh, data);
}

/* This function is called when new metadata is discovered in the stream */
void XttStreamGtk::tags_cb( GstElement *playbin2, gint stream, void *data) 
{

  /* We are possibly in a GStreamer working thread, so we notify the main
   * thread of this event through a message in the bus */
  gst_element_post_message( playbin2,
    gst_message_new_application( GST_OBJECT( playbin2),
      gst_structure_new( "tags-changed", NULL)));
}
  
/* This function is called when an error message is posted on the bus */
void XttStreamGtk::error_cb( GstBus *bus, GstMessage *msg, void *data) 
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  switch ( GST_MESSAGE_TYPE(msg)) {
  case GST_MESSAGE_ERROR: {

    GError *err;
    gchar *debug_info;
  
    printf( "Message %d\n", GST_MESSAGE_TYPE(data));
    /* Print error details on the screen */
    gst_message_parse_error( msg, &err, &debug_info);
    printf( "Error received from element %s: %s\n", GST_OBJECT_NAME( msg->src), err->message);
    printf( "Debugging information: %s\n", debug_info ? debug_info : "none");
    g_clear_error( &err);
    g_free( debug_info);
    
    /* Set the pipeline to READY (which stops playback) */
    gst_element_set_state( strm->playbin2, GST_STATE_READY);
    break;
  }
  case GST_MESSAGE_BUFFERING: {

    if ( strm->is_live)
      break;

#if 0
    gint percent = 0;

    gst_message_parse_buffering( msg, &percent);   
    // printf( "Buffering %d %%\n", percent);
    // Wait until buffering is complete before start/resume playing
    if ( percent < 100) {
      if ( percent < 50) {
	pwr_tTime current_time;

	time_GetTime( &current_time);
	if ( strm->buftime.tv_sec == 0 && strm->buftime.tv_nsec == 0)
	  strm->buftime = current_time;
	else {
	  pwr_tDeltaTime dt;
	  pwr_tFloat32 fdt;
	  time_Adiff( &dt, &current_time, &strm->buftime);
	  time_DToFloat( &fdt, &dt);
	  printf( "Buffering %d %%  %f\n", percent, fdt);
	  if ( fdt > 5) {	  
	    strm->buftime = pwr_cNTime;
	    gst_element_set_state( strm->playbin2, GST_STATE_PAUSED);	  
	  }
	}
      }
      else
	strm->buftime = pwr_cNTime;
    }
    else {
      strm->buftime = pwr_cNTime;
      gst_element_set_state( strm->playbin2, GST_STATE_PLAYING);
    }
#endif

#if 0
    if ( percent < 100)
      gst_element_set_state( strm->playbin2, GST_STATE_PAUSED);
    else
      gst_element_set_state( strm->playbin2, GST_STATE_PLAYING);
#endif
    break;
  }
  case GST_MESSAGE_CLOCK_LOST: {
    printf( "Clock lost\n");
    // Get a new clock 
    gst_element_set_state( strm->playbin2, GST_STATE_PAUSED);
    gst_element_set_state( strm->playbin2, GST_STATE_PLAYING);
    break;
  }
  case GST_MESSAGE_STATE_CHANGED:
#if 0
    GstState old_state, new_state, pending_state;
    gst_message_parse_state_changed( msg, &old_state, &new_state, &pending_state);
    printf( "State changed %s\n", gst_element_state_get_name( new_state));
#endif
    break;
  default: ;
  }
}
  
/* This function is called when an End-Of-Stream message is posted on the bus.
 * We just set the pipeline to READY (which stops playback) */
void XttStreamGtk::eos_cb( GstBus *bus, GstMessage *msg, void *data) 
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  g_print( "End-Of-Stream reached.\n");
  gst_element_set_state( strm->playbin2, GST_STATE_READY);
}
  
/* This function is called when the pipeline changes states. We use it to
 * keep track of the current state. */
void XttStreamGtk::state_changed_cb( GstBus *bus, GstMessage *msg, void *data) 
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  GstState old_state, new_state, pending_state;
  gst_message_parse_state_changed( msg, &old_state, &new_state, &pending_state);
  if (GST_MESSAGE_SRC( msg) == GST_OBJECT( strm->playbin2)) {
    strm->state = new_state;
    // g_print( "State set to %s\n", gst_element_state_get_name( new_state));
    if (old_state == GST_STATE_READY && new_state == GST_STATE_PAUSED) {
      /* For extra responsiveness, we refresh the GUI as soon as we reach the PAUSED state */
      strm->refresh_ui( strm);
    }
  }
}
  
/* Extract metadata from all the streams and write it to the text widget in the GUI */
static void analyze_streams( void *data) {
  printf( "Analyze stream\n");
#if 0
  XttStreamGtk *strm = (XttStreamGtk *)data;
  gint i;
  GstTagList *tags;
  gchar *str, *total_str;
  guint rate;
  gint n_video, n_audio, n_text;
  GtkTextBuffer *text;
  
  /* Clean current contents of the widget */
  text = gtk_text_view_get_buffer( GTK_TEXT_VIEW( strm->streams_list));
  gtk_text_buffer_set_text( text, "", -1);
  
  /* Read some properties */
  g_object_get( strm->playbin2, "n-video", &n_video, NULL);
  g_object_get( strm->playbin2, "n-audio", &n_audio, NULL);
  g_object_get( strm->playbin2, "n-text", &n_text, NULL);
  
  for (i = 0; i < n_video; i++) {
    tags = NULL;
    /* Retrieve the stream's video tags */
    g_signal_emit_by_name( strm->playbin2, "get-video-tags", i, &tags);
    if (tags) {
      total_str = g_strdup_printf( "video stream %d:\n", i);
      gtk_text_buffer_insert_at_cursor( text, total_str, -1);
      g_free( total_str);
      gst_tag_list_get_string( tags, GST_TAG_VIDEO_CODEC, &str);
      str = 0;
      total_str = g_strdup_printf( "  codec: %s\n", str ? str : "unknown");
      gtk_text_buffer_insert_at_cursor( text, total_str, -1);
      g_free( total_str);
      g_free( str);
      gst_tag_list_free( tags);
    }
  }
  
  for (i = 0; i < n_audio; i++) {
    tags = NULL;
    /* Retrieve the stream's audio tags */
    g_signal_emit_by_name( strm->playbin2, "get-audio-tags", i, &tags);
    if (tags) {
      total_str = g_strdup_printf( "\naudio stream %d:\n", i);
      gtk_text_buffer_insert_at_cursor( text, total_str, -1);
      g_free( total_str);
      if (gst_tag_list_get_string( tags, GST_TAG_AUDIO_CODEC, &str)) {
        total_str = g_strdup_printf( "  codec: %s\n", str);
        gtk_text_buffer_insert_at_cursor( text, total_str, -1);
        g_free( total_str);
        g_free( str);
      }
      if (gst_tag_list_get_string( tags, GST_TAG_LANGUAGE_CODE, &str)) {
        total_str = g_strdup_printf( "  language: %s\n", str);
        gtk_text_buffer_insert_at_cursor( text, total_str, -1);
        g_free( total_str);
        g_free( str);
      }
      if (gst_tag_list_get_uint( tags, GST_TAG_BITRATE, &rate)) {
        total_str = g_strdup_printf( "  bitrate: %d\n", rate);
        gtk_text_buffer_insert_at_cursor( text, total_str, -1);
        g_free( total_str);
      }
      gst_tag_list_free( tags);
    }
  }
  
  for (i = 0; i < n_text; i++) {
    tags = NULL;
    /* Retrieve the stream's subtitle tags */
    g_signal_emit_by_name( strm->playbin2, "get-text-tags", i, &tags);
    if (tags) {
      total_str = g_strdup_printf( "\nsubtitle stream %d:\n", i);
      gtk_text_buffer_insert_at_cursor( text, total_str, -1);
      g_free( total_str);
      if (gst_tag_list_get_string( tags, GST_TAG_LANGUAGE_CODE, &str)) {
        total_str = g_strdup_printf( "  language: %s\n", str);
        gtk_text_buffer_insert_at_cursor( text, total_str, -1);
        g_free( total_str);
        g_free( str);
      }
      gst_tag_list_free( tags);
    }
  }
#endif
}
  
/* This function is called when an "application" message is posted on the bus.
 * Here we retrieve the message posted by the tags_cb callback */
void XttStreamGtk::application_cb( GstBus *bus, GstMessage *msg, void *data) 
{
  if (g_strcmp0( gst_structure_get_name( msg->structure), "tags-changed") == 0) {
    /* If the message is the "tags-changed" (only one we are currently issuing), update
     * the stream info GUI */
    analyze_streams( data);
  }
}

void XttStreamGtk::resize_cb( GtkWidget *w, GtkAllocation *allocation, gpointer data)
{
  XttStream *strm = (XttStream *)data;

  strm->width = allocation->width;
  strm->height = allocation->height;
  if ( strm->width > strm->height * strm->stream_ratio) {
    strm->x_offset = (strm->width - strm->height * strm->stream_ratio) / 2;
    strm->y_offset = 0;
  }
  else {
    strm->x_offset = 0;
    strm->y_offset = (strm->height - ((float)strm->width) / strm->stream_ratio) / 2;
  }
}

gboolean XttStreamGtk::mousebutton_cb( GtkWidget *widget, GdkEvent *event, void *data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;
  GtkAllocation alloc;

#if 0
  GstElement *sink;
  g_object_get( strm->playbin2, "video-sink", &sink, NULL);

  int num = gst_child_proxy_get_children_count( GST_CHILD_PROXY(sink));
  printf( "children %d\n", num);

  GstElement *child = (GstElement *)gst_child_proxy_get_child_by_index( GST_CHILD_PROXY(sink), 0);

  gst_x_overlay_set_render_rectangle(GST_X_OVERLAY(child), 0, 0, 100, 100);
  guint64 w, h;
  g_object_get( child, "window-height", &h, NULL);
  g_object_get( child, "window-width", &w, NULL);
  printf( "Top w %d h %d\n", w, h);
#endif

  // Calculate offset for video image
  gtk_widget_get_allocation(strm->video_form, &alloc);

  if ( alloc.width == 0 || alloc.height == 0 || strm->width == 0 || strm->height == 0)
    return TRUE;

  int offset_x, offset_y;

  if ( (double)alloc.width/alloc.height > (double)strm->width/strm->height) {
    offset_x = (alloc.width - (double)strm->width/strm->height * alloc.height) / 2;
    offset_y = 0;      
  }
  else {
    offset_x = 0;
    offset_y = (alloc.height - (double)strm->height/strm->width * alloc.width) / 2;
  }

  switch( event->type) {
  case GDK_BUTTON_PRESS:
    switch ( event->button.button) {
    case 1:
      time_GetTime( &strm->mb_press_time);
      strm->mb_press_x = event->button.x;
      strm->mb_press_y = event->button.y;
      break;    
    case 3: {
      int x1, y1;
      int x = event->button.x + 8;
      int y = event->button.y;
      CoWowGtk::PopupPosition( strm->video_form, x, y, &x1, &y1);
      strm->action_mb3click( x1, y1);
      if ( strm->ptz_box_displayed) {
	g_object_set( strm->ptz_box, "visible", FALSE, NULL);
	strm->ptz_box_displayed = 0;
      }
  break;
    }
    }
    break;
  case GDK_BUTTON_RELEASE:
    switch ( event->button.button) {
    case 1: {
      pwr_tTime now;
      pwr_tDeltaTime dt;
      pwr_tFloat32 dft;

      time_GetTime( &now);
      time_Adiff( &dt, &now, &strm->mb_press_time);
      dft =  time_DToFloat( &dft, &dt);
      if ( dft < 0.5 && 
	   abs( event->button.x - strm->mb_press_x) < 10 &&
	   abs( event->button.y - strm->mb_press_y) < 10) {
	strm->action_click( event->button.x - offset_x, event->button.y - offset_y);
	if ( strm->ptz_box_displayed) {
	  g_object_set( strm->ptz_box, "visible", FALSE, NULL);
	  strm->ptz_box_displayed = 0;
	}
      }
      else if ( abs( event->button.x - strm->mb_press_x) > 20 &&
		abs( event->button.y - strm->mb_press_y) > 20) {
	int x = min( event->button.x, strm->mb_press_x) - offset_x;
	int y = min( event->button.y, strm->mb_press_y) - offset_y;
	int w = abs( event->button.x - strm->mb_press_x);
	int h = abs( event->button.y - strm->mb_press_y);
	printf( "Mb zoom (%d,%d) rect %d,%d\n", x, y, w, h);
	strm->action_areaselect( x, y, w, h);
	if ( strm->ptz_box_displayed) {
	  g_object_set( strm->ptz_box, "visible", FALSE, NULL);
	  strm->ptz_box_displayed = 0;
	}
      }
      break;
    }
    case 2: {
      int x = min( event->button.x, strm->mb_press_x) - offset_x;
      int y = min( event->button.y, strm->mb_press_y) - offset_y;
      strm->action_mb2click( x, y);
      break;
    }
    }
    break;
  case GDK_SCROLL:
    strm->scroll_timerid->remove();
    strm->scroll_timerid->add( 600, strm->scroll_cb, strm);
    //strm->action_scroll(  event->scroll.direction == GDK_SCROLL_UP ? 1 : 0, 
    //			  event->button.x - offset_x, event->button.y - offset_y);
    strm->scroll_direction = event->scroll.direction == GDK_SCROLL_UP ? 1 : 0;
    strm->scroll_x = event->button.x - offset_x;
    strm->scroll_y = event->button.y - offset_y;
    strm->scroll_cnt++;
    break;
  default: ;
  } 
  return TRUE;
}

void XttStreamGtk::scroll_cb( void *data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;
  strm->action_scroll(  strm->scroll_direction, 
			strm->scroll_x, strm->scroll_y, strm->scroll_cnt);
  strm->scroll_cnt = 0;
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

XttStreamGtk::XttStreamGtk( GtkWidget *st_parent_wid, void *st_parent_ctx, const char *name, const char *st_uri,
			    int width, int height, int x, int y, double scan_time, 
			    unsigned int st_options, int st_embedded, pwr_tAttrRef *st_arp, pwr_tStatus *sts) :
  XttStream( st_parent_ctx, name, st_uri, width, height, x, y, scan_time, st_options, st_embedded, st_arp),
  scroll_cnt(0), ptz_box_displayed(0), is_live(0), buftime(pwr_cNTime), parent_wid(st_parent_wid), ptz_box(0)
{
  GstStateChangeReturn ret;
  GstBus *bus;
  pwr_tFileName fname;
  
  if ( !gst_initialized) {
    // Initialize gstreamer
    int argc = 0;
    char **argv;

    gst_init( &argc, &argv);
    gst_initialized = 1;
  }

  if( width == 0 || height == 0) {
    width = 640;
    height = 480;
  }

  duration = GST_CLOCK_TIME_NONE;
  
  /* Create the elements */
  playbin2 = gst_element_factory_make( "playbin2", "playbin2");
   
  if (!playbin2) {
    g_printerr( "Not all elements could be created.\n");
    *sts = 0;
    return;
  }
  
  /* Set the URI to play, eg "http://192.168.67.248/mjpg/video.mjpg" */
  pwr_tURL luri;
  char *s;
  if ( options & strm_mOptions_HttpBasicAuthentication) {
    if ( strcmp( user, "") != 0 && strcmp( password, "") != 0 && (s = strstr( uri, "://"))) {
      unsigned long int offs = s - (char *)uri + 3;
      strncpy( luri, uri, offs);
      luri[offs] = 0;
      strcat( luri, user);
      strcat( luri, ":");
      strcat( luri, password);
      strcat( luri, "@");
      strcat( luri, &uri[offs]);
    }
    else
      strcpy( luri, uri);
  }
  else if ( options & strm_mOptions_CgiParameterAuthentication)
    snprintf( luri, sizeof(luri), "%s?user=%s&pwd=%s", uri, user, password);
  else
    strcpy( luri, uri);

  g_object_set( playbin2, "uri", luri,  NULL);
  
  /* Connect to interesting signals in playbin2 */
  g_signal_connect( G_OBJECT( playbin2), "video-tags-changed",( GCallback) tags_cb, this);
  g_signal_connect( G_OBJECT( playbin2), "audio-tags-changed",( GCallback) tags_cb, this);
  g_signal_connect( G_OBJECT( playbin2), "text-tags-changed",( GCallback) tags_cb, this);

  if ( !embedded) {
    toplevel = gtk_window_new (GTK_WINDOW_TOPLEVEL);
    g_signal_connect( G_OBJECT(toplevel), "delete-event", G_CALLBACK(delete_event_cb), this);

    char *titleutf8 = g_convert( name, -1, "UTF-8", "ISO8859-1", NULL, NULL, NULL);
    gtk_window_set_title( GTK_WINDOW(toplevel), titleutf8);
    g_free( titleutf8);

    CoWowGtk::SetWindowIcon( toplevel);
  }
  else
    toplevel = parent_wid;

  video_form = gtk_drawing_area_new();
  gtk_widget_set_double_buffered( video_form, FALSE);
  g_signal_connect( video_form, "realize", G_CALLBACK( realize_cb), this);
  g_signal_connect( video_form, "expose_event", G_CALLBACK( expose_cb), this);
  g_signal_connect( video_form, "button_press_event", G_CALLBACK( mousebutton_cb), this);
  g_signal_connect( video_form, "button_release_event", G_CALLBACK( mousebutton_cb), this);
  g_signal_connect( video_form, "scroll_event", G_CALLBACK( mousebutton_cb), this);
  g_signal_connect( video_form, "size_allocate", G_CALLBACK(resize_cb), this);
  
  gtk_widget_add_events( video_form, GDK_BUTTON_PRESS_MASK | 
			 GDK_BUTTON_RELEASE_MASK | GDK_SCROLL_MASK);

  // GtkWidget *controls;
  GtkWidget *hbox = gtk_hbox_new( FALSE, 0);
  if ( options & strm_mOptions_VideoControlPanel) {
    GtkToolbar *controlbuttons;
    controlbuttons = (GtkToolbar *) g_object_new(GTK_TYPE_TOOLBAR, NULL);

    GtkWidget *play_button = gtk_button_new();
    dcli_translate_filename( fname, "$pwr_exe/xtt_play.png");
    gtk_container_add( GTK_CONTAINER(play_button), 
		       gtk_image_new_from_file( fname));
    g_signal_connect( G_OBJECT( play_button), "clicked", G_CALLBACK( play_cb), this);
    gtk_toolbar_append_widget( controlbuttons, play_button,CoWowGtk::translate_utf8("Play"), "");
  
    GtkWidget *pause_button = gtk_button_new();
    dcli_translate_filename( fname, "$pwr_exe/xtt_pause.png");
    gtk_container_add( GTK_CONTAINER(pause_button), 
		       gtk_image_new_from_file( fname));
    g_signal_connect( G_OBJECT( pause_button), "clicked", G_CALLBACK( pause_cb), this);
    gtk_toolbar_append_widget( controlbuttons, pause_button,CoWowGtk::translate_utf8("Pause"), "");
  
    GtkWidget *stop_button = gtk_button_new();
    dcli_translate_filename( fname, "$pwr_exe/xtt_stop.png");
    gtk_container_add( GTK_CONTAINER(stop_button), 
		       gtk_image_new_from_file( fname));
    g_signal_connect( G_OBJECT( stop_button), "clicked", G_CALLBACK( stop_cb), this);
    gtk_toolbar_append_widget( controlbuttons, stop_button,CoWowGtk::translate_utf8("Stop"), "");
  

    gtk_box_pack_start( GTK_BOX( hbox), GTK_WIDGET(controlbuttons), FALSE, FALSE, 2);

    if ( options & strm_mOptions_VideoProgressBar) {
      slider = gtk_hscale_new_with_range( 0, 100, 1);
      gtk_scale_set_draw_value( GTK_SCALE( slider), 0);
      slider_update_signal_id = g_signal_connect( G_OBJECT( slider), "value-changed", G_CALLBACK( slider_cb), this);
      gtk_box_pack_start( GTK_BOX( hbox), slider, TRUE, TRUE, 2);
    }
  }

  tools = gtk_toolbar_new();
  gtk_toolbar_set_style( GTK_TOOLBAR(tools), GTK_TOOLBAR_ICONS);

  GtkWidget *tools_box = gtk_hbox_new( FALSE, 0);
  if ( control_protocol != pwr_eCameraControlEnum_No) {
    dcli_translate_filename( fname, "$pwr_exe/xtt_zoom_in.png");
    GtkToolItem *tools_zoom_in = gtk_tool_button_new( gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_zoom_in, CoWowGtk::translate_utf8("Zoom in"));
    g_signal_connect(tools_zoom_in, "clicked", G_CALLBACK(activate_zoomin), this);
    // g_object_set( tools_zoom_in, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_zoom_in, -1);
    GTK_WIDGET_UNSET_FLAGS( tools_zoom_in, GTK_CAN_FOCUS);

    dcli_translate_filename( fname, "$pwr_exe/xtt_zoom_out.png");
    GtkToolItem *tools_zoom_out = gtk_tool_button_new( gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_zoom_out, CoWowGtk::translate_utf8("Zoom out"));
    g_signal_connect(tools_zoom_out, "clicked", G_CALLBACK(activate_zoomout), this);
    g_object_set( tools_zoom_out, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_zoom_out, -1);

    dcli_translate_filename( fname, "$pwr_exe/xtt_zoom_reset.png");
    GtkToolItem *tools_zoom_reset = gtk_tool_button_new( gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_zoom_reset, CoWowGtk::translate_utf8("Zoom reset"));
    g_signal_connect(tools_zoom_reset, "clicked", G_CALLBACK(activate_zoomreset), this);
    g_object_set( tools_zoom_reset, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_zoom_reset, -1);

    gtk_toolbar_insert( GTK_TOOLBAR(tools), gtk_separator_tool_item_new(), -1);

    dcli_translate_filename( fname, "$pwr_exe/ge_page_left.png");
    GtkToolItem *tools_page_left = gtk_tool_button_new(gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_page_left, CoWowGtk::translate_utf8("Page left"));
    g_signal_connect(tools_page_left, "clicked", G_CALLBACK(activate_page_left), this);
    g_object_set( tools_page_left, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_page_left, -1);

    dcli_translate_filename( fname, "$pwr_exe/ge_scroll_left.png");
    GtkToolItem *tools_scroll_left = gtk_tool_button_new(gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_scroll_left, CoWowGtk::translate_utf8("Left"));
    g_signal_connect(tools_scroll_left, "clicked", G_CALLBACK(activate_scroll_left), this);
    g_object_set( tools_scroll_left, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_scroll_left, -1);

    dcli_translate_filename( fname, "$pwr_exe/ge_scroll_right.png");
    GtkToolItem *tools_scroll_right = gtk_tool_button_new(gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_scroll_right, CoWowGtk::translate_utf8("Right"));
    g_signal_connect(tools_scroll_right, "clicked", G_CALLBACK(activate_scroll_right), this);
    g_object_set( tools_scroll_right, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_scroll_right, -1);

    dcli_translate_filename( fname, "$pwr_exe/ge_page_right.png");
    GtkToolItem *tools_page_right = gtk_tool_button_new(gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_page_right, CoWowGtk::translate_utf8("Page right"));
    g_signal_connect(tools_page_right, "clicked", G_CALLBACK(activate_page_right), this);
    g_object_set( tools_page_right, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_page_right, -1);

    gtk_toolbar_insert( GTK_TOOLBAR(tools), gtk_separator_tool_item_new(), -1);

    dcli_translate_filename( fname, "$pwr_exe/ge_page_down.png");
    GtkToolItem *tools_page_down = gtk_tool_button_new(gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_page_down, CoWowGtk::translate_utf8("Page down"));
    g_signal_connect(tools_page_down, "clicked", G_CALLBACK(activate_page_down), this);
    g_object_set( tools_page_down, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_page_down, -1);

    dcli_translate_filename( fname, "$pwr_exe/ge_scroll_down.png");
    GtkToolItem *tools_scroll_down = gtk_tool_button_new(gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_scroll_down, CoWowGtk::translate_utf8("Down"));
    g_signal_connect(tools_scroll_down, "clicked", G_CALLBACK(activate_scroll_down), this);
    g_object_set( tools_scroll_down, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_scroll_down, -1);

    dcli_translate_filename( fname, "$pwr_exe/ge_scroll_up.png");
    GtkToolItem *tools_scroll_up = gtk_tool_button_new(gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_scroll_up, CoWowGtk::translate_utf8("Up"));
    g_signal_connect(tools_scroll_up, "clicked", G_CALLBACK(activate_scroll_up), this);
    g_object_set( tools_scroll_up, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_scroll_up, -1);

    dcli_translate_filename( fname, "$pwr_exe/ge_page_up.png");
    GtkToolItem *tools_page_up = gtk_tool_button_new(gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_page_up, CoWowGtk::translate_utf8("Page up"));
    g_signal_connect(tools_page_up, "clicked", G_CALLBACK(activate_page_up), this);
    g_object_set( tools_page_up, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_page_up, -1);

    gtk_toolbar_insert( GTK_TOOLBAR(tools), gtk_separator_tool_item_new(), -1);

    char tooltiptext[80];
    pwr_tAttrRef aaref;
    pwr_tStatus lsts;

    lsts = gdh_ArefANameToAref( &aref, "PresetPosition[0].Description", &aaref);
    if ( ODD(lsts))
      lsts = gdh_GetObjectInfoAttrref( &aaref, tooltiptext, sizeof(tooltiptext));
    if ( ODD(lsts) && strcmp( tooltiptext, "") != 0)
      strcpy( tooltiptext, CoWowGtk::convert_utf8(tooltiptext));
    else
      strcpy( tooltiptext, CoWowGtk::translate_utf8("Preset position 1"));
    dcli_translate_filename( fname, "$pwr_exe/xtt_pos1.png");
    GtkToolItem *tools_preset1 = gtk_tool_button_new(gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_preset1, tooltiptext);
    g_signal_connect(tools_preset1, "clicked", G_CALLBACK(activate_preset_position1), this);
    g_object_set( tools_preset1, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_preset1, -1);

    lsts = gdh_ArefANameToAref( &aref, "PresetPosition[1].Description", &aaref);
    if ( ODD(lsts))
      lsts = gdh_GetObjectInfoAttrref( &aaref, tooltiptext, sizeof(tooltiptext));
    if ( ODD(lsts) && strcmp( tooltiptext, "") != 0)
      strcpy( tooltiptext, CoWowGtk::convert_utf8(tooltiptext));
    else
      strcpy( tooltiptext, CoWowGtk::translate_utf8("Preset position 2"));
    dcli_translate_filename( fname, "$pwr_exe/xtt_pos2.png");
    GtkToolItem *tools_preset2 = gtk_tool_button_new(gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_preset2, tooltiptext);
    g_signal_connect(tools_preset2, "clicked", G_CALLBACK(activate_preset_position2), this);
    g_object_set( tools_preset2, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_preset2, -1);

    lsts = gdh_ArefANameToAref( &aref, "PresetPosition[2].Description", &aaref);
    if ( ODD(lsts))
      lsts = gdh_GetObjectInfoAttrref( &aaref, tooltiptext, sizeof(tooltiptext));
    if ( ODD(lsts) && strcmp( tooltiptext, "") != 0)
      strcpy( tooltiptext, CoWowGtk::convert_utf8(tooltiptext));
    else
      strcpy( tooltiptext, CoWowGtk::translate_utf8("Preset position 3"));
    dcli_translate_filename( fname, "$pwr_exe/xtt_pos3.png");
    GtkToolItem *tools_preset3 = gtk_tool_button_new(gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_preset3, tooltiptext);
    g_signal_connect(tools_preset3, "clicked", G_CALLBACK(activate_preset_position3), this);
    g_object_set( tools_preset3, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_preset3, -1);

    lsts = gdh_ArefANameToAref( &aref, "PresetPosition[3].Description", &aaref);
    if ( ODD(lsts))
      lsts = gdh_GetObjectInfoAttrref( &aaref, tooltiptext, sizeof(tooltiptext));
    if ( ODD(lsts) && strcmp( tooltiptext, "") != 0)
      strcpy( tooltiptext, CoWowGtk::convert_utf8(tooltiptext));
    else
      strcpy( tooltiptext, CoWowGtk::translate_utf8("Preset position 4"));
    dcli_translate_filename( fname, "$pwr_exe/xtt_pos4.png");
    GtkToolItem *tools_preset4 = gtk_tool_button_new(gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_preset4, tooltiptext);
    g_signal_connect(tools_preset4, "clicked", G_CALLBACK(activate_preset_position4), this);
    g_object_set( tools_preset4, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_preset4, -1);

    lsts = gdh_ArefANameToAref( &aref, "PresetPosition[4].Description", &aaref);
    if ( ODD(lsts))
      lsts = gdh_GetObjectInfoAttrref( &aaref, tooltiptext, sizeof(tooltiptext));
    if ( ODD(lsts) && strcmp( tooltiptext, "") != 0)
      strcpy( tooltiptext, CoWowGtk::convert_utf8(tooltiptext));
    else
      strcpy( tooltiptext, CoWowGtk::translate_utf8("Preset position 5"));
    dcli_translate_filename( fname, "$pwr_exe/xtt_pos5.png");
    GtkToolItem *tools_preset5 = gtk_tool_button_new(gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_preset5, tooltiptext);
    g_signal_connect(tools_preset5, "clicked", G_CALLBACK(activate_preset_position5), this);
    g_object_set( tools_preset5, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_preset5, -1);

    lsts = gdh_ArefANameToAref( &aref, "PresetPosition[5].Description", &aaref);
    if ( ODD(lsts))
      lsts = gdh_GetObjectInfoAttrref( &aaref, tooltiptext, sizeof(tooltiptext));
    if ( ODD(lsts) && strcmp( tooltiptext, "") != 0)
      strcpy( tooltiptext, CoWowGtk::convert_utf8(tooltiptext));
    else
      strcpy( tooltiptext, CoWowGtk::translate_utf8("Preset position 6"));
    dcli_translate_filename( fname, "$pwr_exe/xtt_pos6.png");
    GtkToolItem *tools_preset6 = gtk_tool_button_new(gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_preset6, tooltiptext);
    g_signal_connect(tools_preset6, "clicked", G_CALLBACK(activate_preset_position6), this);
    g_object_set( tools_preset6, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_preset6, -1);

    lsts = gdh_ArefANameToAref( &aref, "PresetPosition[6].Description", &aaref);
    if ( ODD(lsts))
      lsts = gdh_GetObjectInfoAttrref( &aaref, tooltiptext, sizeof(tooltiptext));
    if ( ODD(lsts) && strcmp( tooltiptext, "") != 0)
      strcpy( tooltiptext, CoWowGtk::convert_utf8(tooltiptext));
    else
      strcpy( tooltiptext, CoWowGtk::translate_utf8("Preset position 7"));
    dcli_translate_filename( fname, "$pwr_exe/xtt_pos7.png");
    GtkToolItem *tools_preset7 = gtk_tool_button_new(gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_preset7, tooltiptext);
    g_signal_connect(tools_preset7, "clicked", G_CALLBACK(activate_preset_position7), this);
    g_object_set( tools_preset7, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_preset7, -1);

    lsts = gdh_ArefANameToAref( &aref, "PresetPosition[7].Description", &aaref);
    if ( ODD(lsts))
      lsts = gdh_GetObjectInfoAttrref( &aaref, tooltiptext, sizeof(tooltiptext));
    if ( ODD(lsts) && strcmp( tooltiptext, "") != 0)
      strcpy( tooltiptext, CoWowGtk::convert_utf8(tooltiptext));
    else
      strcpy( tooltiptext, CoWowGtk::translate_utf8("Preset position 8"));
    dcli_translate_filename( fname, "$pwr_exe/xtt_pos8.png");
    GtkToolItem *tools_preset8 = gtk_tool_button_new(gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_preset8, tooltiptext);
    g_signal_connect(tools_preset8, "clicked", G_CALLBACK(activate_preset_position8), this);
    g_object_set( tools_preset8, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_preset8, -1);

    lsts = gdh_ArefANameToAref( &aref, "PresetPosition[8].Description", &aaref);
    if ( ODD(lsts))
      lsts = gdh_GetObjectInfoAttrref( &aaref, tooltiptext, sizeof(tooltiptext));
    if ( ODD(lsts) && strcmp( tooltiptext, "") != 0)
      strcpy( tooltiptext, CoWowGtk::convert_utf8(tooltiptext));
    else
      strcpy( tooltiptext, CoWowGtk::translate_utf8("Preset position 9"));
    dcli_translate_filename( fname, "$pwr_exe/xtt_pos9.png");
    GtkToolItem *tools_preset9 = gtk_tool_button_new(gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_preset9, tooltiptext);
    g_signal_connect(tools_preset9, "clicked", G_CALLBACK(activate_preset_position9), this);
    g_object_set( tools_preset9, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_preset9, -1);

    lsts = gdh_ArefANameToAref( &aref, "PresetPosition[9].Description", &aaref);
    if ( ODD(lsts))
      lsts = gdh_GetObjectInfoAttrref( &aaref, tooltiptext, sizeof(tooltiptext));
    if ( ODD(lsts) && strcmp( tooltiptext, "") != 0)
      strcpy( tooltiptext, CoWowGtk::convert_utf8(tooltiptext));
    else
      strcpy( tooltiptext, CoWowGtk::translate_utf8("Preset position 10"));
    dcli_translate_filename( fname, "$pwr_exe/xtt_pos10.png");
    GtkToolItem *tools_preset10 = gtk_tool_button_new(gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_preset10, tooltiptext);
    g_signal_connect(tools_preset10, "clicked", G_CALLBACK(activate_preset_position10), this);
    g_object_set( tools_preset10, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_preset10, -1);

    gtk_toolbar_insert( GTK_TOOLBAR(tools), gtk_separator_tool_item_new(), -1);

    dcli_translate_filename( fname, "$pwr_exe/xtt_get_pos.png");
    GtkToolItem *tools_get_position = gtk_tool_button_new(gtk_image_new_from_file( fname), NULL);
    gtk_tool_item_set_tooltip_text( tools_get_position, CoWowGtk::translate_utf8("Get position"));
    g_signal_connect(tools_get_position, "clicked", G_CALLBACK(activate_get_position), this);
    g_object_set( tools_get_position, "can-focus", FALSE, NULL);
    gtk_toolbar_insert( GTK_TOOLBAR(tools), tools_get_position, -1);


    GtkWidget *ptz_pan_label = gtk_label_new("Pan");
    ptz_pan = gtk_label_new("0");
    GtkWidget *ptz_tilt_label = gtk_label_new("Tilt");
    ptz_tilt = gtk_label_new("0");
    GtkWidget *ptz_zoom_label = gtk_label_new("Zoom");
    ptz_zoom = gtk_label_new("0");

    ptz_box = gtk_hbox_new( FALSE, 0);
    gtk_box_pack_start( GTK_BOX( ptz_box), GTK_WIDGET(ptz_pan_label), FALSE, FALSE, 5);
    gtk_box_pack_start( GTK_BOX( ptz_box), GTK_WIDGET(ptz_pan), FALSE, FALSE, 5);
    gtk_box_pack_start( GTK_BOX( ptz_box), GTK_WIDGET(gtk_vseparator_new()), FALSE, FALSE, 5);
    gtk_box_pack_start( GTK_BOX( ptz_box), GTK_WIDGET(ptz_tilt_label), FALSE, FALSE, 5);
    gtk_box_pack_start( GTK_BOX( ptz_box), GTK_WIDGET(ptz_tilt), FALSE, FALSE, 5);
    gtk_box_pack_start( GTK_BOX( ptz_box), GTK_WIDGET(gtk_vseparator_new()), FALSE, FALSE, 5);
    gtk_box_pack_start( GTK_BOX( ptz_box), GTK_WIDGET(ptz_zoom_label), FALSE, FALSE, 5);
    gtk_box_pack_start( GTK_BOX( ptz_box), GTK_WIDGET(ptz_zoom), FALSE, FALSE, 5);

    gtk_box_pack_start( GTK_BOX( tools_box), GTK_WIDGET(tools), TRUE, TRUE, 0);
    gtk_box_pack_start( GTK_BOX( tools_box), ptz_box, FALSE, FALSE, 0);
  }
  else {
    // Empty toolbar
    gtk_widget_set_size_request( tools, -1, 32);
    gtk_box_pack_start( GTK_BOX( tools_box), GTK_WIDGET(tools), TRUE, TRUE, 0);
  }
    
  main_box = gtk_vbox_new( FALSE, 0);
  gtk_box_pack_start( GTK_BOX( main_box), GTK_WIDGET(tools_box), FALSE, FALSE, 0);
  gtk_box_pack_start( GTK_BOX( main_box), video_form, TRUE, TRUE, 0);
  if ( options & strm_mOptions_VideoControlPanel)
    gtk_box_pack_start( GTK_BOX( main_box), GTK_WIDGET(hbox), FALSE, FALSE, 0);

  
  if ( !embedded) {
    gtk_container_add( GTK_CONTAINER( toplevel), main_box);
    gtk_window_set_default_size( GTK_WINDOW( toplevel), width, height);
  
    gtk_widget_show_all( toplevel);
    
    if ( ptz_box)
      g_object_set( ptz_box, "visible", FALSE, NULL);
    if ( !(options & strm_mOptions_CameraControlPanel))
      g_object_set( tools, "visible", FALSE, NULL);
  
    if ( options & strm_mOptions_FullScreen)
      gtk_window_fullscreen( GTK_WINDOW(toplevel));
    else if ( options & strm_mOptions_Maximize)
      gtk_window_maximize( GTK_WINDOW(toplevel)); // TODO
    else if ( options & strm_mOptions_FullMaximize)
      gtk_window_maximize( GTK_WINDOW(toplevel));
    else if ( options & strm_mOptions_Iconify)
      gtk_window_iconify( GTK_WINDOW(toplevel));
  }
  else {
    gtk_widget_set_size_request( main_box, width, height);
    if ( ptz_box)
      g_object_set( ptz_box, "visible", FALSE, NULL);
    if ( (options & strm_mOptions_CameraControlPanel) == 0)
      g_object_set( tools, "visible", FALSE, NULL);
  }

  /* Instruct the bus to emit signals for each received message, and connect to the interesting signals */
  bus = gst_element_get_bus( playbin2);
  gst_bus_add_signal_watch( bus);
  g_signal_connect( G_OBJECT( bus), "message", (GCallback)error_cb, this);
  g_signal_connect( G_OBJECT( bus), "message::eos", (GCallback)eos_cb, this);
  g_signal_connect( G_OBJECT( bus), "message::state-changed", (GCallback)state_changed_cb, this);
  g_signal_connect( G_OBJECT( bus), "message::application", (GCallback)application_cb, this);

  gst_bus_set_sync_handler (bus, (GstBusSyncHandler) bus_sync_handler, this);
  gst_object_unref( bus);
  
  /* Start playing */
  ret = gst_element_set_state( playbin2, GST_STATE_PLAYING);
  if (ret == GST_STATE_CHANGE_FAILURE) {
    g_printerr( "Unable to set the pipeline to the playing state.\n");
    gst_object_unref( playbin2);
    *sts = 0;
    return;
  }
  else if ( ret == GST_STATE_CHANGE_NO_PREROLL) {
    is_live = 1;
  }
  
  wow = new CoWowGtk( toplevel);
  timerid = wow->timer_new();
  scroll_timerid = wow->timer_new();
  timerid->add( scan_time, refresh, this);

  *sts = XNAV__SUCCESS;
}
  
XttStreamGtk::~XttStreamGtk()
{
  timerid->remove();
  scroll_timerid->remove();

  gst_element_set_state( playbin2, GST_STATE_NULL);
  gst_object_unref( playbin2);

  if ( !embedded)
    gtk_widget_destroy( toplevel);
}

void XttStreamGtk::pop()
{
  gtk_window_present( GTK_WINDOW(toplevel));
}

void XttStreamGtk::set_size( int width, int height)
{
  gtk_window_resize( GTK_WINDOW(toplevel), width, height);
}

void XttStreamGtk::setup()
{
  if ( ptz_box)
    g_object_set( ptz_box, "visible", FALSE, NULL);
  if ( !(options & strm_mOptions_CameraControlPanel))
    g_object_set( tools, "visible", FALSE, NULL);
}

void XttStreamGtk::create_popup_menu( int x, int y)
{
  GtkMenu *menu = (GtkMenu *) g_object_new( GTK_TYPE_MENU, NULL);

  GtkWidget *w = gtk_menu_item_new_with_label( CoWowGtk::translate_utf8("Zoom reset"));
  g_signal_connect( w, "activate", 
		    G_CALLBACK(activate_zoomreset), this);
  gtk_menu_shell_append(GTK_MENU_SHELL(menu), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label( CoWowGtk::translate_utf8("Zoom in"));
  g_signal_connect( w, "activate", 
		    G_CALLBACK(activate_zoomin), this);
  gtk_menu_shell_append(GTK_MENU_SHELL(menu), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label( CoWowGtk::translate_utf8("Zoom out"));
  g_signal_connect( w, "activate", 
		    G_CALLBACK(activate_zoomout), this);
  gtk_menu_shell_append(GTK_MENU_SHELL(menu), w);
  gtk_widget_show(w);
 
  GtkWidget *preset_store = gtk_menu_item_new_with_label( CoWowGtk::translate_utf8("Preset store"));
  GtkMenu *menu_preset_store = (GtkMenu *) g_object_new( GTK_TYPE_MENU, NULL);

  w = gtk_menu_item_new_with_label( CoWowGtk::translate_utf8("Position 1"));
  g_signal_connect( w, "activate", 
		    G_CALLBACK(activate_preset_store_pos1), this); 
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_preset_store), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label( CoWowGtk::translate_utf8("Position 2"));
  g_signal_connect( w, "activate", 
		    G_CALLBACK(activate_preset_store_pos2), this); 
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_preset_store), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label( CoWowGtk::translate_utf8("Position 3"));
  g_signal_connect( w, "activate", 
		    G_CALLBACK(activate_preset_store_pos3), this); 
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_preset_store), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label( CoWowGtk::translate_utf8("Position 4"));
  g_signal_connect( w, "activate", 
		    G_CALLBACK(activate_preset_store_pos4), this); 
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_preset_store), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label( CoWowGtk::translate_utf8("Position 5"));
  g_signal_connect( w, "activate", 
		    G_CALLBACK(activate_preset_store_pos5), this); 
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_preset_store), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label( CoWowGtk::translate_utf8("Position 6"));
  g_signal_connect( w, "activate", 
		    G_CALLBACK(activate_preset_store_pos6), this); 
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_preset_store), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label( CoWowGtk::translate_utf8("Position 7"));
  g_signal_connect( w, "activate", 
		    G_CALLBACK(activate_preset_store_pos7), this); 
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_preset_store), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label( CoWowGtk::translate_utf8("Position 8"));
  g_signal_connect( w, "activate", 
		    G_CALLBACK(activate_preset_store_pos8), this); 
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_preset_store), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label( CoWowGtk::translate_utf8("Position 9"));
  g_signal_connect( w, "activate", 
		    G_CALLBACK(activate_preset_store_pos9), this); 
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_preset_store), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label( CoWowGtk::translate_utf8("Position 10"));
  g_signal_connect( w, "activate", 
		    G_CALLBACK(activate_preset_store_pos10), this); 
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_preset_store), w);
  gtk_widget_show(w);

  gtk_menu_item_set_submenu(GTK_MENU_ITEM(preset_store),
			    GTK_WIDGET(menu_preset_store));
  gtk_menu_shell_append(GTK_MENU_SHELL(menu), GTK_WIDGET(preset_store));
  gtk_widget_show(preset_store);

  popupmenu_x = x + 5;
  popupmenu_y = y;
  gtk_menu_popup( menu, NULL, NULL, menu_position_func, 
		  this, 0, gtk_get_current_event_time());
}

void XttStreamGtk::menu_position_func( GtkMenu *menu, gint *x, gint *y, gboolean *push_in,
				       gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  *x = strm->popupmenu_x;
  *y = strm->popupmenu_y;
  *push_in = FALSE;
}

void XttStreamGtk::activate_zoomreset( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->camera_control->zoom_absolute( 0);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_zoomin( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->camera_control->zoom_relative( 5);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_zoomout( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->camera_control->zoom_relative( -5);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_scroll_left( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->camera_control->pan_relative( -3);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_scroll_right( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->camera_control->pan_relative( 3);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_page_left( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->camera_control->pan_relative( -15);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_page_right( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->camera_control->pan_relative( 15);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_scroll_down( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->camera_control->tilt_relative( -3);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_scroll_up( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->camera_control->tilt_relative( 3);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_page_down( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->camera_control->tilt_relative( -15);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_page_up( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->camera_control->tilt_relative( 15);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_preset_position1( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->activate_preset_position(0);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_preset_position2( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->activate_preset_position(1);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_preset_position3( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->activate_preset_position(2);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_preset_position4( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->activate_preset_position(3);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_preset_position5( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->activate_preset_position(4);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_preset_position6( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->activate_preset_position(5);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_preset_position7( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->activate_preset_position(6);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_preset_position8( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->activate_preset_position(7);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_preset_position9( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->activate_preset_position(8);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_preset_position10( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->activate_preset_position(9);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_preset_store_pos1( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->activate_preset_store_pos(0);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_preset_store_pos2( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->activate_preset_store_pos(1);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_preset_store_pos3( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->activate_preset_store_pos(2);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_preset_store_pos4( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->activate_preset_store_pos(3);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_preset_store_pos5( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->activate_preset_store_pos(4);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_preset_store_pos6( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->activate_preset_store_pos(5);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_preset_store_pos7( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->activate_preset_store_pos(6);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_preset_store_pos8( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->activate_preset_store_pos(7);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_preset_store_pos9( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->activate_preset_store_pos(8);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_preset_store_pos10( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;

  strm->activate_preset_store_pos(9);
  if ( strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}
  
void XttStreamGtk::activate_get_position( GtkWidget *w, gpointer data)
{
  XttStreamGtk *strm = (XttStreamGtk *)data;
  double pan, tilt, zoom;
  int sts;
  char pan_str[20], tilt_str[20], zoom_str[20];

  sts = strm->camera_control->get_position( &pan, &tilt, &zoom);
  if ( EVEN(sts)) return;

  sprintf( pan_str, "%6.2f", pan);
  sprintf( tilt_str, "%6.2f", tilt);
  sprintf( zoom_str, "%6.2f", zoom);
  gtk_label_set_text( GTK_LABEL(strm->ptz_pan), pan_str);
  gtk_label_set_text( GTK_LABEL(strm->ptz_tilt), tilt_str);
  gtk_label_set_text( GTK_LABEL(strm->ptz_zoom), zoom_str);

  if ( !strm->ptz_box_displayed) {
    g_object_set( strm->ptz_box, "visible", TRUE, NULL);
    strm->ptz_box_displayed = 1;
  }
}
  
#if 0
int main(int argc, char *argv[]) {
  pwr_tStatus sts;

  /* Initialize GTK */
  gtk_init( &argc, &argv);
  
  /* Initialize GStreamer */
  gst_init( &argc, &argv);
  
  XttStreamGtk *strm = new XttStreamGtk( 0, 0, "Some video", "http://192.168.67.248/mjpg/video.mjpg", 1, 0, 0, 0, 0, 1, 0, &sts);
 
  /* Start the GTK main loop. We will not regain control until gtk_main_quit is called. */
  gtk_main();
  
  delete strm;

  /* Free resources */
  return 0;
}
#endif

#else
// gstreamer not installed
#include <string.h>
#include <gtk/gtk.h>
#include "xtt_stream_gtk.h"  

XttStreamGtk::XttStreamGtk( GtkWidget *st_parent_wid, void *st_parent_ctx, const char *name, const char *st_uri,
			    int width, int height, int x, int y, double scan_time, 
			    unsigned int st_options, int st_embedded, pwr_tAttrRef *arp, pwr_tStatus *sts) :
  XttStream( st_parent_ctx, name, st_uri, width, height, x, y, scan_time, st_options, st_embedded, arp) { *sts = 0;}

XttStreamGtk::~XttStreamGtk() {}

#endif
