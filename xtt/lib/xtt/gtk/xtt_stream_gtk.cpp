/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#if defined PWRE_CONF_GST

#include <math.h>

#include "xtt_xnav.h"

#include <gst/gst.h>
#if GST_CHECK_VERSION(1, 0, 0)
#include <gst/video/videooverlay.h>
#else
#include <gst/interfaces/xoverlay.h>
#endif

#include <gdk/gdk.h>
#include <gdk/gdkx.h>

#include "co_dcli.h"
#include "co_string.h"
#include "co_time.h"

#include "rt_xnav_msg.h"

#include "xtt_stream_gtk.h"

int XttStreamGtk::gst_initialized = 0;

static GstBusSyncReply bus_sync_handler(
    GstBus* bus, GstMessage* message, gpointer data)
{
  return GST_BUS_PASS;
}

/* This function is called when the GUI toolkit creates the physical window that
 * will hold the video.
 * At this point we can retrieve its handler (which has a different meaning
 * depending on the windowing system)
 * and pass it to GStreamer through the XOverlay interface. */
void XttStreamGtk::realize_cb(GtkWidget* widget, void* data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;
  guintptr window_handle;

  GstElement* videosink;
  g_object_get(strm->playbin2, "video-sink", &videosink, NULL);

  GdkWindow* window = gtk_widget_get_window(strm->video_form);

  // if (!gdk_window_ensure_native (window))
  //   g_error ("Couldn't create native window needed for GstXOverlay!");

  window_handle = GDK_WINDOW_XID(window);
#if GST_CHECK_VERSION(1, 0, 0)
  gst_video_overlay_set_window_handle(
      GST_VIDEO_OVERLAY(videosink), window_handle);
#else
  gst_x_overlay_set_xwindow_id(GST_X_OVERLAY(videosink), window_handle);
#endif
}

void XttStreamGtk::source_setup_cb(
    GstElement* playbin2, GstElement* src, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  // Set timeout for connection
  GstElement* source;
  guint tmo = (int)(strm->connection_timeout + 0.5);

  g_object_get(strm->playbin2, "source", &source, NULL);
  g_object_set(source, "timeout", tmo, NULL);

  // If the connections has been down, overlay has to be set again
  GstElement* videosink;
  guintptr window_handle;
  g_object_get(strm->playbin2, "video-sink", &videosink, NULL);
  if (videosink) {
    GdkWindow* window = gtk_widget_get_window(strm->video_form);

    window_handle = GDK_WINDOW_XID(window);
#if GST_CHECK_VERSION(1, 0, 0)
    gst_video_overlay_set_window_handle(
        GST_VIDEO_OVERLAY(videosink), window_handle);
#else
    gst_x_overlay_set_xwindow_id(GST_X_OVERLAY(videosink), window_handle);
#endif
  }
}

/* This function is called when the PLAY button is clicked */
void XttStreamGtk::play_cb(GtkButton* button, void* data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  gst_element_set_state(strm->playbin2, GST_STATE_PLAYING);
}

/* This function is called when the PAUSE button is clicked */
void XttStreamGtk::pause_cb(GtkButton* button, void* data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  gst_element_set_state(strm->playbin2, GST_STATE_PAUSED);
}

/* This function is called when the STOP button is clicked */
void XttStreamGtk::stop_cb(GtkButton* button, void* data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  gst_element_set_state(strm->playbin2, GST_STATE_READY);
}

/* This function is called when the main window is closed */
void XttStreamGtk::delete_event_cb(
    GtkWidget* widget, GdkEvent* event, void* data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  stop_cb(NULL, strm);

  if (strm->close_cb)
    (strm->close_cb)(strm->parent_ctx, strm);
  delete strm;
}

/* This function is called everytime the video window needs to be redrawn (due
 * to damage/exposure,
 * rescaling, etc). GStreamer takes care of this in the PAUSED and PLAYING
 * states, otherwise,
 * we simply draw a black rectangle to avoid garbage showing up. */
gboolean XttStreamGtk::expose_cb(
    GtkWidget* widget, GdkEventExpose* event, void* data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  if (strm->state < GST_STATE_PAUSED) {
    strm->erase_window();
  }

  return FALSE;
}

/* This function is called when the slider changes its position. We perform a
 * seek to the
 * new position here. */
void XttStreamGtk::slider_cb(GtkRange* range, void* data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  gdouble value = gtk_range_get_value(GTK_RANGE(strm->slider));
  gst_element_seek_simple(strm->playbin2, GST_FORMAT_TIME,
      GstSeekFlags(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT),
      (gint64)(value * GST_SECOND));
}

/* This function is called periodically to refresh the GUI */
void XttStreamGtk::refresh_ui(XttStreamGtk* strm)
{
  GstFormat fmt = GST_FORMAT_TIME;
  gint64 current = -1;

  if (!(strm->options & strm_mOptions_VideoControlPanel
          && strm->options & strm_mOptions_VideoProgressBar))
    return;

  /* We do not want to update anything unless we are in the PAUSED or PLAYING
   * states */
  if (strm->state < GST_STATE_PAUSED)
    return;

  /* If we didn't know it yet, query the stream duration */
  if (!GST_CLOCK_TIME_IS_VALID(strm->duration)) {
#if GST_CHECK_VERSION(1, 0, 0)
    if (!gst_element_query_duration(strm->playbin2, fmt, &strm->duration)) {
#else
    if (!gst_element_query_duration(strm->playbin2, &fmt, &strm->duration)) {
#endif
      g_printerr("Could not query current duration.\n");
    } else {
      /* Set the range of the slider to the clip duration, in SECONDS */
      if (GST_CLOCK_TIME_IS_VALID(strm->duration))
        gtk_range_set_range(
            GTK_RANGE(strm->slider), 0, (gdouble)strm->duration / GST_SECOND);
    }
  }

#if GST_CHECK_VERSION(1, 0, 0)
  if (gst_element_query_position(strm->playbin2, fmt, &current)) {
#else
  if (gst_element_query_position(strm->playbin2, &fmt, &current)) {
#endif
    /* Block the "value-changed" signal, so the slider_cb function is not called
     * (which would trigger a seek the user has not requested) */
    g_signal_handler_block(strm->slider, strm->slider_update_signal_id);
    /* Set the position of the slider to the current pipeline positoin, in
     * SECONDS */
    gtk_range_set_value(GTK_RANGE(strm->slider), (gdouble)current / GST_SECOND);
    /* Re-enable the signal */
    g_signal_handler_unblock(strm->slider, strm->slider_update_signal_id);
  }
}

void XttStreamGtk::erase_window()
{
  GtkAllocation allocation;
  GdkWindow* window = gtk_widget_get_window(video_form);
  cairo_t* cr;

  /* Cairo is a 2D graphics library which we use here to clean the video window.
   * It is used by GStreamer for other reasons, so it will always be available
   * to us. */
  gtk_widget_get_allocation(video_form, &allocation);
  cr = gdk_cairo_create(window);
  cairo_set_source_rgb(cr, 0, 0, 0);
  cairo_rectangle(cr, 0, 0, allocation.width, allocation.height);
  cairo_fill(cr);
  cairo_destroy(cr);
}

void XttStreamGtk::refresh(void* data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  refresh_ui(strm);

  strm->timerid->add(strm->scan_time, strm->refresh, data);
}

void XttStreamGtk::reconnect(void* data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  GstState state, async;
  GstStateChangeReturn ch
      = gst_element_get_state(strm->playbin2, &state, &async, 0);

  printf("Try to reconnect %d %d %d\n", state, async, ch);

  if (state == GST_STATE_PLAYING)
    return;

  printf("Adding reconnect\n");
  strm->reconnect_timerid->remove();
  strm->reconnect_timerid->add(
      int(strm->reconnect_time * 1000), reconnect, strm);

  if (strm->no_uri) {
    printf("Reconnect no URI\n");
    strm->no_uri = 0;
    char luri[250];
    char* s;
    if (strm->options & strm_mOptions_HttpBasicAuthentication) {
      if (!streq(strm->user, "") && !streq(strm->password, "")
          && (s = strstr(strm->uri, "://"))) {
        unsigned long int offs = s - (char*)strm->uri + 3;
        strncpy(luri, strm->uri, offs);
        luri[offs] = 0;
        strcat(luri, strm->user);
        strcat(luri, ":");
        strcat(luri, strm->password);
        strcat(luri, "@");
        strcat(luri, &strm->uri[offs]);
      } else
        strcpy(luri, strm->uri);
    } else if (strm->options & strm_mOptions_CgiParameterAuthentication)
      snprintf(luri, sizeof(luri), "%s?user=%s&pwd=%s", strm->uri, strm->user,
          strm->password);
    else
      strcpy(luri, strm->uri);

    g_object_set(strm->playbin2, "uri", luri, NULL);
  } else
    gst_element_set_state(strm->playbin2, GST_STATE_PLAYING);
}

/* This function is called when new metadata is discovered in the stream */
void XttStreamGtk::tags_cb(GstElement* playbin2, gint stream, void* data)
{
  /* We are possibly in a GStreamer working thread, so we notify the main
   * thread of this event through a message in the bus */
  gst_element_post_message(
      playbin2, gst_message_new_application(GST_OBJECT(playbin2),
#if GST_CHECK_VERSION(1, 0, 0)
                    gst_structure_new_empty("tags-changed")));
#else
                    gst_structure_new("tags-changed", NULL)));
#endif
}

/* This function is called when an error message is posted on the bus */
void XttStreamGtk::error_cb(GstBus* bus, GstMessage* msg, void* data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  switch (GST_MESSAGE_TYPE(msg)) {
  case GST_MESSAGE_ERROR: {
    GError* err;
    gchar* debug_info;

    printf("Message %d\n", GST_MESSAGE_TYPE(msg));
    /* Print error details on the screen */
    gst_message_parse_error(msg, &err, &debug_info);
    printf("Error received from element %s: %s\n", GST_OBJECT_NAME(msg->src),
        err->message);
    printf("Debugging information: %s\n", debug_info ? debug_info : "none");

    if (streq(err->message, "No URI set"))
      strm->no_uri = 1;

    g_clear_error(&err);
    g_free(debug_info);

    /* Set the pipeline to READY (which stops playback) */
    gst_element_set_state(strm->playbin2, GST_STATE_READY);

    // Erase window
    strm->erase_window();

    // Try to reconnect
    strm->reconnect_timerid->remove();
    strm->reconnect_timerid->add(
        int(strm->reconnect_time * 1000), reconnect, strm);

    break;
  }
  case GST_MESSAGE_BUFFERING: {
    if (strm->is_live)
      break;

    break;
  }
  case GST_MESSAGE_CLOCK_LOST: {
    printf("Clock lost\n");
    // Get a new clock
    gst_element_set_state(strm->playbin2, GST_STATE_PAUSED);
    gst_element_set_state(strm->playbin2, GST_STATE_PLAYING);
    break;
  }
  case GST_MESSAGE_STATE_CHANGED:
    break;
  default:;
  }
}

/* This function is called when an End-Of-Stream message is posted on the bus.
 * We just set the pipeline to READY (which stops playback) */
void XttStreamGtk::eos_cb(GstBus* bus, GstMessage* msg, void* data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  g_print("End-Of-Stream reached.\n");
  gst_element_set_state(strm->playbin2, GST_STATE_READY);
}

/* This function is called when the pipeline changes states. We use it to
 * keep track of the current state. */
void XttStreamGtk::state_changed_cb(GstBus* bus, GstMessage* msg, void* data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  GstState old_state, new_state, pending_state;
  gst_message_parse_state_changed(msg, &old_state, &new_state, &pending_state);
  if (GST_MESSAGE_SRC(msg) == GST_OBJECT(strm->playbin2)) {
    strm->state = new_state;
    // g_print( "State set to %s\n", gst_element_state_get_name( new_state));
    if (old_state == GST_STATE_READY && new_state == GST_STATE_PAUSED) {
      /* For extra responsiveness, we refresh the GUI as soon as we reach the
       * PAUSED state */
      strm->refresh_ui(strm);
    }
  }
}

/* Extract metadata from all the streams and write it to the text widget in the
 * GUI */
static void analyze_streams(void* data)
{
  printf("Analyze stream\n");
}

/* This function is called when an "application" message is posted on the bus.
 * Here we retrieve the message posted by the tags_cb callback */
void XttStreamGtk::application_cb(GstBus* bus, GstMessage* msg, void* data)
{
#if GST_CHECK_VERSION(1, 0, 0)
  if (g_strcmp0(gst_structure_get_name(gst_message_get_structure(msg)),
          "tags-changed")
      == 0) {
#else
  if (g_strcmp0(gst_structure_get_name(msg->structure), "tags-changed") == 0) {
#endif
    /* If the message is the "tags-changed" (only one we are currently issuing),
     * update
     * the stream info GUI */
    analyze_streams(data);
  }
}

void XttStreamGtk::resize_cb(
    GtkWidget* w, GtkAllocation* allocation, gpointer data)
{
  XttStream* strm = (XttStream*)data;

  strm->width = allocation->width;
  strm->height = allocation->height;
  if (strm->width > strm->height * strm->stream_ratio) {
    strm->x_offset = (strm->width - strm->height * strm->stream_ratio) / 2;
    strm->y_offset = 0;
  } else {
    strm->x_offset = 0;
    strm->y_offset
        = (strm->height - ((float)strm->width) / strm->stream_ratio) / 2;
  }
}

gboolean XttStreamGtk::mousebutton_cb(
    GtkWidget* widget, GdkEvent* event, void* data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;
  GtkAllocation alloc;

  // Calculate offset for video image
  gtk_widget_get_allocation(strm->video_form, &alloc);

  if (alloc.width == 0 || alloc.height == 0 || strm->width == 0
      || strm->height == 0)
    return TRUE;

  int offset_x, offset_y;

  if ((double)alloc.width / alloc.height > (double)strm->width / strm->height) {
    offset_x
        = (alloc.width - (double)strm->width / strm->height * alloc.height) / 2;
    offset_y = 0;
  } else {
    offset_x = 0;
    offset_y
        = (alloc.height - (double)strm->height / strm->width * alloc.width) / 2;
  }

  switch (event->type) {
  case GDK_BUTTON_PRESS:
    switch (event->button.button) {
    case 1:
      time_GetTime(&strm->mb_press_time);
      strm->mb_press_x = event->button.x;
      strm->mb_press_y = event->button.y;
      break;
    case 3: {
      int x1, y1;
      int x = event->button.x + 8;
      int y = event->button.y;
      CoWowGtk::PopupPosition(strm->video_form, x, y, &x1, &y1);
      strm->action_mb3click(x1, y1);
      if (strm->ptz_box_displayed) {
        g_object_set(strm->ptz_box, "visible", FALSE, NULL);
        strm->ptz_box_displayed = 0;
      }
      break;
    }
    }
    break;
  case GDK_BUTTON_RELEASE:
    switch (event->button.button) {
    case 1: {
      pwr_tTime now;
      pwr_tDeltaTime dt;
      pwr_tFloat32 dft;

      time_GetTime(&now);
      time_Adiff(&dt, &now, &strm->mb_press_time);
      dft = time_DToFloat(&dft, &dt);
      if (dft < 0.5 && ABS(event->button.x - strm->mb_press_x) < 10
          && ABS(event->button.y - strm->mb_press_y) < 10) {
        strm->action_click(
            event->button.x - offset_x, event->button.y - offset_y);
        if (strm->ptz_box_displayed) {
          g_object_set(strm->ptz_box, "visible", FALSE, NULL);
          strm->ptz_box_displayed = 0;
        }
      } else if (ABS(event->button.x - strm->mb_press_x) > 20
          && abs(event->button.y - strm->mb_press_y) > 20) {
        int x = MIN(event->button.x, strm->mb_press_x) - offset_x;
        int y = MIN(event->button.y, strm->mb_press_y) - offset_y;
        int w = ABS(event->button.x - strm->mb_press_x);
        int h = ABS(event->button.y - strm->mb_press_y);
        printf("Mb zoom (%d,%d) rect %d,%d\n", x, y, w, h);
        strm->action_areaselect(x, y, w, h);
        if (strm->ptz_box_displayed) {
          g_object_set(strm->ptz_box, "visible", FALSE, NULL);
          strm->ptz_box_displayed = 0;
        }
      }
      break;
    }
    case 2: {
      int x = MIN(event->button.x, strm->mb_press_x) - offset_x;
      int y = MIN(event->button.y, strm->mb_press_y) - offset_y;
      strm->action_mb2click(x, y);
      break;
    }
    }
    break;
  case GDK_SCROLL:
    strm->scroll_timerid->remove();
    strm->scroll_timerid->add(600, strm->scroll_cb, strm);
    // strm->action_scroll(  event->scroll.direction == GDK_SCROLL_UP ? 1 : 0,
    //			  event->button.x - offset_x, event->button.y -
    //offset_y);
    strm->scroll_direction = event->scroll.direction == GDK_SCROLL_UP ? 1 : 0;
    strm->scroll_x = event->button.x - offset_x;
    strm->scroll_y = event->button.y - offset_y;
    strm->scroll_cnt++;
    break;
  default:;
  }
  return TRUE;
}

void XttStreamGtk::scroll_cb(void* data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;
  strm->action_scroll(
      strm->scroll_direction, strm->scroll_x, strm->scroll_y, strm->scroll_cnt);
  strm->scroll_cnt = 0;
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

XttStreamGtk::XttStreamGtk(GtkWidget* st_parent_wid, void* st_parent_ctx,
    const char* name, const char* st_uri, int width, int height, int x, int y,
    double scan_time, unsigned int st_options, int st_embedded,
    pwr_tAttrRef* st_arp, pwr_tStatus* sts)
    : XttStream(st_parent_ctx, name, st_uri, width, height, x, y, scan_time,
          st_options, st_embedded, st_arp),
      scroll_cnt(0), ptz_box_displayed(0), is_live(0), buftime(pwr_cNTime),
      parent_wid(st_parent_wid), ptz_box(0), reconnect_timerid(0), no_uri(0)
{
  GstStateChangeReturn ret;
  GstBus* bus;
  pwr_tFileName fname;

  if (!gst_initialized) {
    // Initialize gstreamer
    int argc = 0;
    char** argv;

    gst_init(&argc, &argv);
    gst_initialized = 1;
  }

  if (width == 0 || height == 0) {
    width = 640;
    height = 480;
  }

  duration = GST_CLOCK_TIME_NONE;

/* Create the elements */
#if GST_CHECK_VERSION(1, 0, 0)
  playbin2 = gst_element_factory_make("playbin", "playbin");
#else
  playbin2 = gst_element_factory_make("playbin2", "playbin2");
#endif

  if (!playbin2) {
    g_printerr("Not all elements could be created.\n");
    *sts = 0;
    return;
  }

  /* Set the URI to play, eg "http://192.168.67.248/mjpg/video.mjpg" */
  char luri[250];
  char* s;
  if (options & strm_mOptions_HttpBasicAuthentication) {
    if (!streq(user, "") && !streq(password, "")
        && (s = strstr(uri, "://"))) {
      unsigned long int offs = s - (char*)uri + 3;
      strncpy(luri, uri, offs);
      luri[offs] = 0;
      strcat(luri, user);
      strcat(luri, ":");
      strcat(luri, password);
      strcat(luri, "@");
      strcat(luri, &uri[offs]);
    } else
      strcpy(luri, uri);
  } else if (options & strm_mOptions_CgiParameterAuthentication)
    snprintf(luri, sizeof(luri), "%s?user=%s&pwd=%s", uri, user, password);
  else
    strcpy(luri, uri);

  g_object_set(playbin2, "uri", luri, NULL);

  /* Connect to interesting signals in playbin2 */
  g_signal_connect(
      G_OBJECT(playbin2), "video-tags-changed", (GCallback)tags_cb, this);
  g_signal_connect(
      G_OBJECT(playbin2), "audio-tags-changed", (GCallback)tags_cb, this);
  g_signal_connect(
      G_OBJECT(playbin2), "text-tags-changed", (GCallback)tags_cb, this);

  // g_signal_connect( G_OBJECT( playbin2), "source-setup",( GCallback)
  // source_setup_cb, this);
  g_signal_connect(
      G_OBJECT(playbin2), "notify::source", (GCallback)source_setup_cb, this);

  if (!embedded) {
    toplevel = gtk_window_new(GTK_WINDOW_TOPLEVEL);
    g_signal_connect(
        G_OBJECT(toplevel), "delete-event", G_CALLBACK(delete_event_cb), this);

    char* titleutf8
        = g_convert(name, -1, "UTF-8", "ISO8859-1", NULL, NULL, NULL);
    gtk_window_set_title(GTK_WINDOW(toplevel), titleutf8);
    g_free(titleutf8);

    CoWowGtk::SetWindowIcon(toplevel);
  } else
    toplevel = parent_wid;

  GstElement* x_overlay = gst_element_factory_make("xvimagesink", "videosink");
  g_object_set(G_OBJECT(playbin2), "video-sink", x_overlay, NULL);

  video_form = gtk_drawing_area_new();
  gtk_widget_set_double_buffered(video_form, FALSE);
  g_signal_connect(video_form, "realize", G_CALLBACK(realize_cb), this);
  g_signal_connect(video_form, "expose_event", G_CALLBACK(expose_cb), this);
  g_signal_connect(
      video_form, "button_press_event", G_CALLBACK(mousebutton_cb), this);
  g_signal_connect(
      video_form, "button_release_event", G_CALLBACK(mousebutton_cb), this);
  g_signal_connect(
      video_form, "scroll_event", G_CALLBACK(mousebutton_cb), this);
  g_signal_connect(video_form, "size_allocate", G_CALLBACK(resize_cb), this);

  gtk_widget_add_events(video_form,
      GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_SCROLL_MASK);

  // GtkWidget *controls;
  GtkWidget* hbox = gtk_hbox_new(FALSE, 0);
  if (options & strm_mOptions_VideoControlPanel) {
    GtkToolbar* controlbuttons;
    controlbuttons = (GtkToolbar*)g_object_new(GTK_TYPE_TOOLBAR, NULL);

    GtkWidget* play_button = gtk_button_new();
    dcli_translate_filename(fname, "$pwr_exe/xtt_play.png");
    gtk_container_add(
        GTK_CONTAINER(play_button), gtk_image_new_from_file(fname));
    g_signal_connect(
        G_OBJECT(play_button), "clicked", G_CALLBACK(play_cb), this);
    gtk_toolbar_append_widget(
        controlbuttons, play_button, CoWowGtk::translate_utf8("Play"), "");

    GtkWidget* pause_button = gtk_button_new();
    dcli_translate_filename(fname, "$pwr_exe/xtt_pause.png");
    gtk_container_add(
        GTK_CONTAINER(pause_button), gtk_image_new_from_file(fname));
    g_signal_connect(
        G_OBJECT(pause_button), "clicked", G_CALLBACK(pause_cb), this);
    gtk_toolbar_append_widget(
        controlbuttons, pause_button, CoWowGtk::translate_utf8("Pause"), "");

    GtkWidget* stop_button = gtk_button_new();
    dcli_translate_filename(fname, "$pwr_exe/xtt_stop.png");
    gtk_container_add(
        GTK_CONTAINER(stop_button), gtk_image_new_from_file(fname));
    g_signal_connect(
        G_OBJECT(stop_button), "clicked", G_CALLBACK(stop_cb), this);
    gtk_toolbar_append_widget(
        controlbuttons, stop_button, CoWowGtk::translate_utf8("Stop"), "");

    gtk_box_pack_start(
        GTK_BOX(hbox), GTK_WIDGET(controlbuttons), FALSE, FALSE, 2);

    if (options & strm_mOptions_VideoProgressBar) {
      slider = gtk_hscale_new_with_range(0, 100, 1);
      gtk_scale_set_draw_value(GTK_SCALE(slider), 0);
      slider_update_signal_id = g_signal_connect(
          G_OBJECT(slider), "value-changed", G_CALLBACK(slider_cb), this);
      gtk_box_pack_start(GTK_BOX(hbox), slider, TRUE, TRUE, 2);
    }
  }

  tools = gtk_toolbar_new();
  gtk_toolbar_set_style(GTK_TOOLBAR(tools), GTK_TOOLBAR_ICONS);

  GtkWidget* tools_box = gtk_hbox_new(FALSE, 0);
  if (control_protocol != pwr_eCameraControlEnum_No) {
    dcli_translate_filename(fname, "$pwr_exe/xtt_zoom_in.png");
    GtkToolItem* tools_zoom_in
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(
        tools_zoom_in, CoWowGtk::translate_utf8("Zoom in"));
    g_signal_connect(
        tools_zoom_in, "clicked", G_CALLBACK(activate_zoomin), this);
    // g_object_set( tools_zoom_in, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_zoom_in, -1);
    GTK_WIDGET_UNSET_FLAGS(tools_zoom_in, GTK_CAN_FOCUS);

    dcli_translate_filename(fname, "$pwr_exe/xtt_zoom_out.png");
    GtkToolItem* tools_zoom_out
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(
        tools_zoom_out, CoWowGtk::translate_utf8("Zoom out"));
    g_signal_connect(
        tools_zoom_out, "clicked", G_CALLBACK(activate_zoomout), this);
    g_object_set(tools_zoom_out, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_zoom_out, -1);

    dcli_translate_filename(fname, "$pwr_exe/xtt_zoom_reset.png");
    GtkToolItem* tools_zoom_reset
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(
        tools_zoom_reset, CoWowGtk::translate_utf8("Zoom reset"));
    g_signal_connect(
        tools_zoom_reset, "clicked", G_CALLBACK(activate_zoomreset), this);
    g_object_set(tools_zoom_reset, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_zoom_reset, -1);

    gtk_toolbar_insert(GTK_TOOLBAR(tools), gtk_separator_tool_item_new(), -1);

    dcli_translate_filename(fname, "$pwr_exe/ge_page_left.png");
    GtkToolItem* tools_page_left
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(
        tools_page_left, CoWowGtk::translate_utf8("Page left"));
    g_signal_connect(
        tools_page_left, "clicked", G_CALLBACK(activate_page_left), this);
    g_object_set(tools_page_left, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_page_left, -1);

    dcli_translate_filename(fname, "$pwr_exe/ge_scroll_left.png");
    GtkToolItem* tools_scroll_left
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(
        tools_scroll_left, CoWowGtk::translate_utf8("Left"));
    g_signal_connect(
        tools_scroll_left, "clicked", G_CALLBACK(activate_scroll_left), this);
    g_object_set(tools_scroll_left, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_scroll_left, -1);

    dcli_translate_filename(fname, "$pwr_exe/ge_scroll_right.png");
    GtkToolItem* tools_scroll_right
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(
        tools_scroll_right, CoWowGtk::translate_utf8("Right"));
    g_signal_connect(
        tools_scroll_right, "clicked", G_CALLBACK(activate_scroll_right), this);
    g_object_set(tools_scroll_right, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_scroll_right, -1);

    dcli_translate_filename(fname, "$pwr_exe/ge_page_right.png");
    GtkToolItem* tools_page_right
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(
        tools_page_right, CoWowGtk::translate_utf8("Page right"));
    g_signal_connect(
        tools_page_right, "clicked", G_CALLBACK(activate_page_right), this);
    g_object_set(tools_page_right, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_page_right, -1);

    gtk_toolbar_insert(GTK_TOOLBAR(tools), gtk_separator_tool_item_new(), -1);

    dcli_translate_filename(fname, "$pwr_exe/ge_page_down.png");
    GtkToolItem* tools_page_down
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(
        tools_page_down, CoWowGtk::translate_utf8("Page down"));
    g_signal_connect(
        tools_page_down, "clicked", G_CALLBACK(activate_page_down), this);
    g_object_set(tools_page_down, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_page_down, -1);

    dcli_translate_filename(fname, "$pwr_exe/ge_scroll_down.png");
    GtkToolItem* tools_scroll_down
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(
        tools_scroll_down, CoWowGtk::translate_utf8("Down"));
    g_signal_connect(
        tools_scroll_down, "clicked", G_CALLBACK(activate_scroll_down), this);
    g_object_set(tools_scroll_down, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_scroll_down, -1);

    dcli_translate_filename(fname, "$pwr_exe/ge_scroll_up.png");
    GtkToolItem* tools_scroll_up
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(
        tools_scroll_up, CoWowGtk::translate_utf8("Up"));
    g_signal_connect(
        tools_scroll_up, "clicked", G_CALLBACK(activate_scroll_up), this);
    g_object_set(tools_scroll_up, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_scroll_up, -1);

    dcli_translate_filename(fname, "$pwr_exe/ge_page_up.png");
    GtkToolItem* tools_page_up
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(
        tools_page_up, CoWowGtk::translate_utf8("Page up"));
    g_signal_connect(
        tools_page_up, "clicked", G_CALLBACK(activate_page_up), this);
    g_object_set(tools_page_up, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_page_up, -1);

    gtk_toolbar_insert(GTK_TOOLBAR(tools), gtk_separator_tool_item_new(), -1);

    char tooltiptext[80];
    pwr_tAttrRef aaref;
    pwr_tStatus lsts;

    lsts = gdh_ArefANameToAref(&aref, "PresetPosition[0].Description", &aaref);
    if (ODD(lsts))
      lsts = gdh_GetObjectInfoAttrref(&aaref, tooltiptext, sizeof(tooltiptext));
    if (ODD(lsts) && !streq(tooltiptext, ""))
      strcpy(tooltiptext, CoWowGtk::convert_utf8(tooltiptext));
    else
      strcpy(tooltiptext, CoWowGtk::translate_utf8("Preset position 1"));
    dcli_translate_filename(fname, "$pwr_exe/xtt_pos1.png");
    GtkToolItem* tools_preset1
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(tools_preset1, tooltiptext);
    g_signal_connect(
        tools_preset1, "clicked", G_CALLBACK(activate_preset_position1), this);
    g_object_set(tools_preset1, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_preset1, -1);

    lsts = gdh_ArefANameToAref(&aref, "PresetPosition[1].Description", &aaref);
    if (ODD(lsts))
      lsts = gdh_GetObjectInfoAttrref(&aaref, tooltiptext, sizeof(tooltiptext));
    if (ODD(lsts) && !streq(tooltiptext, ""))
      strcpy(tooltiptext, CoWowGtk::convert_utf8(tooltiptext));
    else
      strcpy(tooltiptext, CoWowGtk::translate_utf8("Preset position 2"));
    dcli_translate_filename(fname, "$pwr_exe/xtt_pos2.png");
    GtkToolItem* tools_preset2
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(tools_preset2, tooltiptext);
    g_signal_connect(
        tools_preset2, "clicked", G_CALLBACK(activate_preset_position2), this);
    g_object_set(tools_preset2, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_preset2, -1);

    lsts = gdh_ArefANameToAref(&aref, "PresetPosition[2].Description", &aaref);
    if (ODD(lsts))
      lsts = gdh_GetObjectInfoAttrref(&aaref, tooltiptext, sizeof(tooltiptext));
    if (ODD(lsts) && !streq(tooltiptext, ""))
      strcpy(tooltiptext, CoWowGtk::convert_utf8(tooltiptext));
    else
      strcpy(tooltiptext, CoWowGtk::translate_utf8("Preset position 3"));
    dcli_translate_filename(fname, "$pwr_exe/xtt_pos3.png");
    GtkToolItem* tools_preset3
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(tools_preset3, tooltiptext);
    g_signal_connect(
        tools_preset3, "clicked", G_CALLBACK(activate_preset_position3), this);
    g_object_set(tools_preset3, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_preset3, -1);

    lsts = gdh_ArefANameToAref(&aref, "PresetPosition[3].Description", &aaref);
    if (ODD(lsts))
      lsts = gdh_GetObjectInfoAttrref(&aaref, tooltiptext, sizeof(tooltiptext));
    if (ODD(lsts) && !streq(tooltiptext, ""))
      strcpy(tooltiptext, CoWowGtk::convert_utf8(tooltiptext));
    else
      strcpy(tooltiptext, CoWowGtk::translate_utf8("Preset position 4"));
    dcli_translate_filename(fname, "$pwr_exe/xtt_pos4.png");
    GtkToolItem* tools_preset4
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(tools_preset4, tooltiptext);
    g_signal_connect(
        tools_preset4, "clicked", G_CALLBACK(activate_preset_position4), this);
    g_object_set(tools_preset4, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_preset4, -1);

    lsts = gdh_ArefANameToAref(&aref, "PresetPosition[4].Description", &aaref);
    if (ODD(lsts))
      lsts = gdh_GetObjectInfoAttrref(&aaref, tooltiptext, sizeof(tooltiptext));
    if (ODD(lsts) && !streq(tooltiptext, ""))
      strcpy(tooltiptext, CoWowGtk::convert_utf8(tooltiptext));
    else
      strcpy(tooltiptext, CoWowGtk::translate_utf8("Preset position 5"));
    dcli_translate_filename(fname, "$pwr_exe/xtt_pos5.png");
    GtkToolItem* tools_preset5
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(tools_preset5, tooltiptext);
    g_signal_connect(
        tools_preset5, "clicked", G_CALLBACK(activate_preset_position5), this);
    g_object_set(tools_preset5, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_preset5, -1);

    lsts = gdh_ArefANameToAref(&aref, "PresetPosition[5].Description", &aaref);
    if (ODD(lsts))
      lsts = gdh_GetObjectInfoAttrref(&aaref, tooltiptext, sizeof(tooltiptext));
    if (ODD(lsts) && !streq(tooltiptext, ""))
      strcpy(tooltiptext, CoWowGtk::convert_utf8(tooltiptext));
    else
      strcpy(tooltiptext, CoWowGtk::translate_utf8("Preset position 6"));
    dcli_translate_filename(fname, "$pwr_exe/xtt_pos6.png");
    GtkToolItem* tools_preset6
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(tools_preset6, tooltiptext);
    g_signal_connect(
        tools_preset6, "clicked", G_CALLBACK(activate_preset_position6), this);
    g_object_set(tools_preset6, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_preset6, -1);

    lsts = gdh_ArefANameToAref(&aref, "PresetPosition[6].Description", &aaref);
    if (ODD(lsts))
      lsts = gdh_GetObjectInfoAttrref(&aaref, tooltiptext, sizeof(tooltiptext));
    if (ODD(lsts) && !streq(tooltiptext, ""))
      strcpy(tooltiptext, CoWowGtk::convert_utf8(tooltiptext));
    else
      strcpy(tooltiptext, CoWowGtk::translate_utf8("Preset position 7"));
    dcli_translate_filename(fname, "$pwr_exe/xtt_pos7.png");
    GtkToolItem* tools_preset7
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(tools_preset7, tooltiptext);
    g_signal_connect(
        tools_preset7, "clicked", G_CALLBACK(activate_preset_position7), this);
    g_object_set(tools_preset7, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_preset7, -1);

    lsts = gdh_ArefANameToAref(&aref, "PresetPosition[7].Description", &aaref);
    if (ODD(lsts))
      lsts = gdh_GetObjectInfoAttrref(&aaref, tooltiptext, sizeof(tooltiptext));
    if (ODD(lsts) && !streq(tooltiptext, ""))
      strcpy(tooltiptext, CoWowGtk::convert_utf8(tooltiptext));
    else
      strcpy(tooltiptext, CoWowGtk::translate_utf8("Preset position 8"));
    dcli_translate_filename(fname, "$pwr_exe/xtt_pos8.png");
    GtkToolItem* tools_preset8
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(tools_preset8, tooltiptext);
    g_signal_connect(
        tools_preset8, "clicked", G_CALLBACK(activate_preset_position8), this);
    g_object_set(tools_preset8, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_preset8, -1);

    lsts = gdh_ArefANameToAref(&aref, "PresetPosition[8].Description", &aaref);
    if (ODD(lsts))
      lsts = gdh_GetObjectInfoAttrref(&aaref, tooltiptext, sizeof(tooltiptext));
    if (ODD(lsts) && !streq(tooltiptext, ""))
      strcpy(tooltiptext, CoWowGtk::convert_utf8(tooltiptext));
    else
      strcpy(tooltiptext, CoWowGtk::translate_utf8("Preset position 9"));
    dcli_translate_filename(fname, "$pwr_exe/xtt_pos9.png");
    GtkToolItem* tools_preset9
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(tools_preset9, tooltiptext);
    g_signal_connect(
        tools_preset9, "clicked", G_CALLBACK(activate_preset_position9), this);
    g_object_set(tools_preset9, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_preset9, -1);

    lsts = gdh_ArefANameToAref(&aref, "PresetPosition[9].Description", &aaref);
    if (ODD(lsts))
      lsts = gdh_GetObjectInfoAttrref(&aaref, tooltiptext, sizeof(tooltiptext));
    if (ODD(lsts) && !streq(tooltiptext, ""))
      strcpy(tooltiptext, CoWowGtk::convert_utf8(tooltiptext));
    else
      strcpy(tooltiptext, CoWowGtk::translate_utf8("Preset position 10"));
    dcli_translate_filename(fname, "$pwr_exe/xtt_pos10.png");
    GtkToolItem* tools_preset10
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(tools_preset10, tooltiptext);
    g_signal_connect(tools_preset10, "clicked",
        G_CALLBACK(activate_preset_position10), this);
    g_object_set(tools_preset10, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_preset10, -1);

    gtk_toolbar_insert(GTK_TOOLBAR(tools), gtk_separator_tool_item_new(), -1);

    dcli_translate_filename(fname, "$pwr_exe/xtt_get_pos.png");
    GtkToolItem* tools_get_position
        = gtk_tool_button_new(gtk_image_new_from_file(fname), NULL);
    gtk_tool_item_set_tooltip_text(
        tools_get_position, CoWowGtk::translate_utf8("Get position"));
    g_signal_connect(
        tools_get_position, "clicked", G_CALLBACK(activate_get_position), this);
    g_object_set(tools_get_position, "can-focus", FALSE, NULL);
    gtk_toolbar_insert(GTK_TOOLBAR(tools), tools_get_position, -1);

    GtkWidget* ptz_pan_label = gtk_label_new("Pan");
    ptz_pan = gtk_label_new("0");
    GtkWidget* ptz_tilt_label = gtk_label_new("Tilt");
    ptz_tilt = gtk_label_new("0");
    GtkWidget* ptz_zoom_label = gtk_label_new("Zoom");
    ptz_zoom = gtk_label_new("0");

    ptz_box = gtk_hbox_new(FALSE, 0);
    gtk_box_pack_start(
        GTK_BOX(ptz_box), GTK_WIDGET(ptz_pan_label), FALSE, FALSE, 5);
    gtk_box_pack_start(GTK_BOX(ptz_box), GTK_WIDGET(ptz_pan), FALSE, FALSE, 5);
    gtk_box_pack_start(
        GTK_BOX(ptz_box), GTK_WIDGET(gtk_vseparator_new()), FALSE, FALSE, 5);
    gtk_box_pack_start(
        GTK_BOX(ptz_box), GTK_WIDGET(ptz_tilt_label), FALSE, FALSE, 5);
    gtk_box_pack_start(GTK_BOX(ptz_box), GTK_WIDGET(ptz_tilt), FALSE, FALSE, 5);
    gtk_box_pack_start(
        GTK_BOX(ptz_box), GTK_WIDGET(gtk_vseparator_new()), FALSE, FALSE, 5);
    gtk_box_pack_start(
        GTK_BOX(ptz_box), GTK_WIDGET(ptz_zoom_label), FALSE, FALSE, 5);
    gtk_box_pack_start(GTK_BOX(ptz_box), GTK_WIDGET(ptz_zoom), FALSE, FALSE, 5);

    gtk_box_pack_start(GTK_BOX(tools_box), GTK_WIDGET(tools), TRUE, TRUE, 0);
    gtk_box_pack_start(GTK_BOX(tools_box), ptz_box, FALSE, FALSE, 0);
  } else {
    // Empty toolbar
    gtk_widget_set_size_request(tools, -1, 32);
    gtk_box_pack_start(GTK_BOX(tools_box), GTK_WIDGET(tools), TRUE, TRUE, 0);
  }

  main_box = gtk_vbox_new(FALSE, 0);
  gtk_box_pack_start(GTK_BOX(main_box), GTK_WIDGET(tools_box), FALSE, FALSE, 0);
  gtk_box_pack_start(GTK_BOX(main_box), video_form, TRUE, TRUE, 0);
  if (options & strm_mOptions_VideoControlPanel)
    gtk_box_pack_start(GTK_BOX(main_box), GTK_WIDGET(hbox), FALSE, FALSE, 0);

  if (!embedded) {
    gtk_container_add(GTK_CONTAINER(toplevel), main_box);
    gtk_window_set_default_size(GTK_WINDOW(toplevel), width, height);

    gtk_widget_show_all(toplevel);

    if (ptz_box)
      g_object_set(ptz_box, "visible", FALSE, NULL);
    if (!(options & strm_mOptions_CameraControlPanel))
      g_object_set(tools, "visible", FALSE, NULL);

    if (options & strm_mOptions_FullScreen)
      gtk_window_fullscreen(GTK_WINDOW(toplevel));
    else if (options & strm_mOptions_Maximize)
      gtk_window_maximize(GTK_WINDOW(toplevel)); // TODO
    else if (options & strm_mOptions_FullMaximize)
      gtk_window_maximize(GTK_WINDOW(toplevel));
    else if (options & strm_mOptions_Iconify)
      gtk_window_iconify(GTK_WINDOW(toplevel));
  } else {
    gtk_widget_set_size_request(main_box, width, height);
    if (ptz_box)
      g_object_set(ptz_box, "visible", FALSE, NULL);
    if ((options & strm_mOptions_CameraControlPanel) == 0)
      g_object_set(tools, "visible", FALSE, NULL);
  }

  /* Instruct the bus to emit signals for each received message, and connect to
   * the interesting signals */
  bus = gst_element_get_bus(playbin2);
  gst_bus_add_signal_watch(bus);
  g_signal_connect(G_OBJECT(bus), "message", (GCallback)error_cb, this);
  g_signal_connect(G_OBJECT(bus), "message::eos", (GCallback)eos_cb, this);
  g_signal_connect(G_OBJECT(bus), "message::state-changed",
      (GCallback)state_changed_cb, this);
  g_signal_connect(
      G_OBJECT(bus), "message::application", (GCallback)application_cb, this);

#if GST_CHECK_VERSION(1, 0, 0)
  gst_bus_set_sync_handler(bus, (GstBusSyncHandler)bus_sync_handler, this, 0);
#else
  gst_bus_set_sync_handler(bus, (GstBusSyncHandler)bus_sync_handler, this);
#endif
  gst_object_unref(bus);

  /* Start playing */
  ret = gst_element_set_state(playbin2, GST_STATE_PLAYING);
  if (ret == GST_STATE_CHANGE_FAILURE) {
    g_printerr("Unable to set the pipeline to the playing state.\n");
    gst_object_unref(playbin2);
    *sts = 0;
    return;
  } else if (ret == GST_STATE_CHANGE_NO_PREROLL) {
    is_live = 1;
  }

  wow = new CoWowGtk(toplevel);
  timerid = wow->timer_new();
  scroll_timerid = wow->timer_new();
  reconnect_timerid = wow->timer_new();
  timerid->add(scan_time, refresh, this);

  *sts = XNAV__SUCCESS;
}

XttStreamGtk::~XttStreamGtk()
{
  if (timerid)
    timerid->remove();
  if (scroll_timerid)
    scroll_timerid->remove();
  if (reconnect_timerid)
    reconnect_timerid->remove();

  gst_element_set_state(playbin2, GST_STATE_NULL);
  gst_object_unref(playbin2);

  if (!embedded)
    gtk_widget_destroy(toplevel);
}

void XttStreamGtk::pop()
{
  gtk_window_present(GTK_WINDOW(toplevel));
}

void XttStreamGtk::set_size(int width, int height)
{
  gtk_window_resize(GTK_WINDOW(toplevel), width, height);
}

void XttStreamGtk::setup()
{
  if (ptz_box)
    g_object_set(ptz_box, "visible", FALSE, NULL);
  if (!(options & strm_mOptions_CameraControlPanel))
    g_object_set(tools, "visible", FALSE, NULL);
}

void XttStreamGtk::create_popup_menu(int x, int y)
{
  GtkMenu* menu = (GtkMenu*)g_object_new(GTK_TYPE_MENU, NULL);

  GtkWidget* w
      = gtk_menu_item_new_with_label(CoWowGtk::translate_utf8("Zoom reset"));
  g_signal_connect(w, "activate", G_CALLBACK(activate_zoomreset), this);
  gtk_menu_shell_append(GTK_MENU_SHELL(menu), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label(CoWowGtk::translate_utf8("Zoom in"));
  g_signal_connect(w, "activate", G_CALLBACK(activate_zoomin), this);
  gtk_menu_shell_append(GTK_MENU_SHELL(menu), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label(CoWowGtk::translate_utf8("Zoom out"));
  g_signal_connect(w, "activate", G_CALLBACK(activate_zoomout), this);
  gtk_menu_shell_append(GTK_MENU_SHELL(menu), w);
  gtk_widget_show(w);

  GtkWidget* preset_store
      = gtk_menu_item_new_with_label(CoWowGtk::translate_utf8("Preset store"));
  GtkMenu* menu_preset_store = (GtkMenu*)g_object_new(GTK_TYPE_MENU, NULL);

  w = gtk_menu_item_new_with_label(CoWowGtk::translate_utf8("Position 1"));
  g_signal_connect(w, "activate", G_CALLBACK(activate_preset_store_pos1), this);
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_preset_store), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label(CoWowGtk::translate_utf8("Position 2"));
  g_signal_connect(w, "activate", G_CALLBACK(activate_preset_store_pos2), this);
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_preset_store), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label(CoWowGtk::translate_utf8("Position 3"));
  g_signal_connect(w, "activate", G_CALLBACK(activate_preset_store_pos3), this);
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_preset_store), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label(CoWowGtk::translate_utf8("Position 4"));
  g_signal_connect(w, "activate", G_CALLBACK(activate_preset_store_pos4), this);
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_preset_store), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label(CoWowGtk::translate_utf8("Position 5"));
  g_signal_connect(w, "activate", G_CALLBACK(activate_preset_store_pos5), this);
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_preset_store), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label(CoWowGtk::translate_utf8("Position 6"));
  g_signal_connect(w, "activate", G_CALLBACK(activate_preset_store_pos6), this);
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_preset_store), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label(CoWowGtk::translate_utf8("Position 7"));
  g_signal_connect(w, "activate", G_CALLBACK(activate_preset_store_pos7), this);
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_preset_store), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label(CoWowGtk::translate_utf8("Position 8"));
  g_signal_connect(w, "activate", G_CALLBACK(activate_preset_store_pos8), this);
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_preset_store), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label(CoWowGtk::translate_utf8("Position 9"));
  g_signal_connect(w, "activate", G_CALLBACK(activate_preset_store_pos9), this);
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_preset_store), w);
  gtk_widget_show(w);

  w = gtk_menu_item_new_with_label(CoWowGtk::translate_utf8("Position 10"));
  g_signal_connect(
      w, "activate", G_CALLBACK(activate_preset_store_pos10), this);
  gtk_menu_shell_append(GTK_MENU_SHELL(menu_preset_store), w);
  gtk_widget_show(w);

  gtk_menu_item_set_submenu(
      GTK_MENU_ITEM(preset_store), GTK_WIDGET(menu_preset_store));
  gtk_menu_shell_append(GTK_MENU_SHELL(menu), GTK_WIDGET(preset_store));
  gtk_widget_show(preset_store);

  popupmenu_x = x + 5;
  popupmenu_y = y;
  gtk_menu_popup(menu, NULL, NULL, menu_position_func, this, 0,
      gtk_get_current_event_time());
}

void XttStreamGtk::menu_position_func(
    GtkMenu* menu, gint* x, gint* y, gboolean* push_in, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  *x = strm->popupmenu_x;
  *y = strm->popupmenu_y;
  *push_in = FALSE;
}

void XttStreamGtk::activate_zoomreset(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  if (!strm->camera_control)
    return;

  strm->camera_control->zoom_absolute(0);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_zoomin(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  if (!strm->camera_control)
    return;

  strm->camera_control->zoom_relative(5);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_zoomout(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  if (!strm->camera_control)
    return;

  strm->camera_control->zoom_relative(-5);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_scroll_left(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  if (!strm->camera_control)
    return;

  strm->camera_control->pan_relative(-3);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_scroll_right(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  if (!strm->camera_control)
    return;

  strm->camera_control->pan_relative(3);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_page_left(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  if (!strm->camera_control)
    return;

  strm->camera_control->pan_relative(-15);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_page_right(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  if (!strm->camera_control)
    return;

  strm->camera_control->pan_relative(15);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_scroll_down(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  if (!strm->camera_control)
    return;

  strm->camera_control->tilt_relative(-3);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_scroll_up(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  if (!strm->camera_control)
    return;

  strm->camera_control->tilt_relative(3);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_page_down(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  if (!strm->camera_control)
    return;

  strm->camera_control->tilt_relative(-15);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_page_up(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  if (!strm->camera_control)
    return;

  strm->camera_control->tilt_relative(15);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_preset_position1(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  strm->activate_preset_position(0);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_preset_position2(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  strm->activate_preset_position(1);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_preset_position3(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  strm->activate_preset_position(2);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_preset_position4(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  strm->activate_preset_position(3);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_preset_position5(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  strm->activate_preset_position(4);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_preset_position6(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  strm->activate_preset_position(5);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_preset_position7(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  strm->activate_preset_position(6);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_preset_position8(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  strm->activate_preset_position(7);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_preset_position9(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  strm->activate_preset_position(8);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_preset_position10(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  strm->activate_preset_position(9);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_preset_store_pos1(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  strm->activate_preset_store_pos(0);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_preset_store_pos2(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  strm->activate_preset_store_pos(1);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_preset_store_pos3(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  strm->activate_preset_store_pos(2);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_preset_store_pos4(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  strm->activate_preset_store_pos(3);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_preset_store_pos5(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  strm->activate_preset_store_pos(4);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_preset_store_pos6(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  strm->activate_preset_store_pos(5);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_preset_store_pos7(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  strm->activate_preset_store_pos(6);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_preset_store_pos8(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  strm->activate_preset_store_pos(7);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_preset_store_pos9(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  strm->activate_preset_store_pos(8);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_preset_store_pos10(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;

  strm->activate_preset_store_pos(9);
  if (strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", FALSE, NULL);
    strm->ptz_box_displayed = 0;
  }
}

void XttStreamGtk::activate_get_position(GtkWidget* w, gpointer data)
{
  XttStreamGtk* strm = (XttStreamGtk*)data;
  double pan, tilt, zoom;
  int sts;
  char pan_str[20], tilt_str[20], zoom_str[20];

  if (!strm->camera_control)
    return;

  sts = strm->camera_control->get_position(&pan, &tilt, &zoom);
  if (EVEN(sts))
    return;

  sprintf(pan_str, "%6.2f", pan);
  sprintf(tilt_str, "%6.2f", tilt);
  sprintf(zoom_str, "%6.2f", zoom);
  gtk_label_set_text(GTK_LABEL(strm->ptz_pan), pan_str);
  gtk_label_set_text(GTK_LABEL(strm->ptz_tilt), tilt_str);
  gtk_label_set_text(GTK_LABEL(strm->ptz_zoom), zoom_str);

  if (!strm->ptz_box_displayed) {
    g_object_set(strm->ptz_box, "visible", TRUE, NULL);
    strm->ptz_box_displayed = 1;
  }
}

#else
// gstreamer not installed
#include <string.h>
#include "cow_gtk.h"
#include "xtt_stream_gtk.h"

XttStreamGtk::XttStreamGtk(GtkWidget* st_parent_wid, void* st_parent_ctx,
    const char* name, const char* st_uri, int width, int height, int x, int y,
    double scan_time, unsigned int st_options, int st_embedded,
    pwr_tAttrRef* arp, pwr_tStatus* sts)
    : XttStream(st_parent_ctx, name, st_uri, width, height, x, y, scan_time,
          st_options, st_embedded, arp)
{
  *sts = 0;
}

XttStreamGtk::~XttStreamGtk()
{
}

#endif
