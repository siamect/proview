/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

typedef void* Widget;

#include <stdio.h>
#include <stdlib.h>
#include "cow_gtk.h"

#include "rt_gdh_msg.h"
#include "co_cdh.h"
#include "co_string.h"

#include "glow_growapi.h"

#include "ge_graph_gtk.h"

#include "xtt_ge_gtk.h"
#include "xtt_log.h"
#include "xtt_xnav.h"

gboolean XttGeGtk::action_inputfocus(
    GtkWidget* w, GdkEvent* event, gpointer data)
{
  XttGeGtk* ge = (XttGeGtk*)data;

  if (ge->focustimer.disabled())
    return TRUE;

  if (ge->graph)
    ge->graph->set_inputfocus(1);

  ge->focustimer.disable(400);
  return FALSE;
}

void XttGeGtk::iconify(int val)
{
  if (val)
    gtk_window_iconify(GTK_WINDOW(toplevel));
  else
    gtk_window_deiconify(GTK_WINDOW(toplevel));
}

void XttGeGtk::set_below(int val)
{
  gtk_window_set_keep_below(GTK_WINDOW(toplevel), val);
}

void XttGeGtk::set_size(int width, int height)
{
  int default_width;
  int default_height;
  GdkGeometry geometry;
  float rd = 0.05;

  default_width = width + 20;
  default_height = height + 20;
  if (width < 300 || height < 300)
    rd = 0.2;

  // Add menu size
  if (graph->is_dashboard())
    default_height += 10;

  //gtk_window_resize(GTK_WINDOW(toplevel), default_width, default_height);

  // This condition is due to a bug in Reflection X 11.0.5...
  if (!((XNav*)parent_ctx)->gbl.no_graph_ratio) {
    // Note, equal min and max aspect will cause recursive resize on LXDE
    geometry.min_aspect = gdouble(default_width) / default_height * (1.0 - rd);
    geometry.max_aspect = gdouble(default_width) / default_height * (1.0 + rd);
    gtk_window_set_geometry_hints(
        GTK_WINDOW(toplevel), GTK_WIDGET(toplevel), &geometry, GDK_HINT_ASPECT);
  }
  gtk_window_resize(GTK_WINDOW(toplevel), default_width, default_height);
}

void XttGeGtk::menu_setup(int edit)
{
  int sensitive = edit;
  
  //gtk_widget_set_sensitive(file_save, sensitive);
  gtk_widget_set_sensitive(edit_add, sensitive);
  gtk_widget_set_sensitive(edit_delete, sensitive);
  gtk_widget_set_sensitive(edit_copy, sensitive);
  gtk_widget_set_sensitive(edit_paste, sensitive);
  gtk_widget_set_sensitive(edit_connect, sensitive);
  gtk_widget_set_sensitive(edit_merge, sensitive);
  gtk_widget_set_sensitive(edit_cellattributes, sensitive);
  gtk_widget_set_sensitive(edit_graphattributes, sensitive);
}

void XttGeGtk::ge_change_value_cb(void* ge_ctx, void* value_object, char* text)
{
  XttGeGtk* ge = (XttGeGtk*)ge_ctx;

  if (ge->value_input_open) {
    g_object_set(ge->value_dialog, "visible", FALSE, NULL);
    ge->value_input_open = 0;
    return;
  }

  g_object_set(ge->value_dialog, "visible", TRUE, NULL);

  ge->message(' ', "");
  gtk_widget_grab_focus(ge->value_input);

  gint pos = 0;
  gtk_editable_delete_text(GTK_EDITABLE(ge->value_input), 0, -1);
  gtk_editable_insert_text(
      GTK_EDITABLE(ge->value_input), text, strlen(text), &pos);
  gtk_editable_set_position(GTK_EDITABLE(ge->value_input), -1);
  gtk_editable_select_region(GTK_EDITABLE(ge->value_input), 0, -1);

  ge->value_input_open = 1;
  ge->current_value_object = value_object;
}

void XttGeGtk::confirm_cb(void* ge_ctx, void* confirm_object, char* text)
{
  XttGe* ge = (XttGe*)ge_ctx;

  if (ge->confirm_open) {
    g_object_set(((XttGeGtk*)ge)->confirm_widget, "visible", FALSE, NULL);
    ge->confirm_open = 0;
    return;
  }

  ((XttGeGtk*)ge)->create_confirm_dialog();

  ge->message(' ', "");

  char* textutf8 = g_convert(text, -1, "UTF-8", "ISO8859-1", NULL, NULL, NULL);

  gtk_label_set_text(GTK_LABEL(((XttGeGtk*)ge)->confirm_label), textutf8);
  g_free(textutf8);

  ge->confirm_open = 1;
  ge->current_confirm_object = confirm_object;
}

void XttGeGtk::message_dialog_cb(void* ge_ctx, const char* text)
{
  XttGe* ge = (XttGe*)ge_ctx;
  CoWowGtk wow(((XttGeGtk*)ge)->toplevel);
  char title[80];

  strcpy(title, Lng::translate("Message"));
  wow.DisplayError(title, Lng::translate(text), Lng::translatefile_coding());

  // g_object_set( ((XttGeGtk *)ge)->message_dia_widget, "visible", TRUE, NULL);
  // gtk_label_set_text( GTK_LABEL(((XttGeGtk *)ge)->message_dia_label), text);
}

void XttGeGtk::activate_value_input(GtkWidget* w, gpointer data)
{
  XttGe* ge = (XttGe*)data;
  char* text;

  text = gtk_editable_get_chars(GTK_EDITABLE(w), 0, -1);
  if (ge->value_input_open) {
    ge->graph->change_value(ge->current_value_object, text);
    g_object_set(((XttGeGtk*)ge)->value_dialog, "visible", FALSE, NULL);
    ge->value_input_open = 0;
  }
  g_free(text);
}

void XttGeGtk::confirm_reply(int ok)
{
  if (!confirm_open)
    return;

  g_object_set(confirm_widget, "visible", FALSE, NULL);
  confirm_open = 0;
  if (ok)
    graph->confirm_ok(current_confirm_object);
}

void XttGeGtk::activate_confirm_ok(GtkWidget* w, gpointer data)
{
  XttGe* ge = (XttGe*)data;

  g_object_set(((XttGeGtk*)ge)->confirm_widget, "visible", FALSE, NULL);
  ge->confirm_open = 0;
  if (ge->eventlog_cb)
    (ge->eventlog_cb)(ge->parent_ctx, ge, xttlog_eCategory_GeConfirmOk, 0, 0);
  ge->graph->confirm_ok(ge->current_confirm_object);
}

void XttGeGtk::activate_confirm_cancel(GtkWidget* w, gpointer data)
{
  XttGe* ge = (XttGe*)data;

  ge->confirm_open = 0;
  g_object_set(((XttGeGtk*)ge)->confirm_widget, "visible", FALSE, NULL);
  if (ge->eventlog_cb)
    (ge->eventlog_cb)(
        ge->parent_ctx, ge, xttlog_eCategory_GeConfirmCancel, 0, 0);
}

void XttGeGtk::activate_exit(GtkWidget* w, gpointer data)
{
  XttGe* ge = (XttGe*)data;

  if (ge->graph->is_dashboard() && ge->graph->is_modified()) {
    ge->activate_exit_modified();
    return;
  }

  if (ge->options & ge_mOptions_IsMain)
    (ge->close_cb)(ge->parent_ctx, ge);
  else if (!(ge->options & ge_mOptions_Embedded))
    delete ge;
}

void XttGeGtk::activate_edit(GtkWidget* w, gpointer data)
{
  int edit = (int)gtk_check_menu_item_get_active(
      GTK_CHECK_MENU_ITEM(((XttGeGtk*)data)->file_edit));

  ((XttGe *)data)->activate_edit(edit);
  ((XttGeGtk *)data)->menu_setup(edit);
}

void XttGeGtk::activate_open(GtkWidget* w, gpointer data)
{
  ((XttGe *)data)->activate_open();
}

void XttGeGtk::activate_add(GtkWidget* w, gpointer data)
{
  ((XttGe *)data)->activate_add();
}

void XttGeGtk::activate_delete(GtkWidget* w, gpointer data)
{
  ((XttGe *)data)->activate_delete();
}

void XttGeGtk::activate_copy(GtkWidget* w, gpointer data)
{
  ((XttGe *)data)->activate_copy();
}

void XttGeGtk::activate_paste(GtkWidget* w, gpointer data)
{
  ((XttGe *)data)->activate_paste();
}

void XttGeGtk::activate_connect(GtkWidget* w, gpointer data)
{
  ((XttGe *)data)->activate_connect();
}

void XttGeGtk::activate_merge(GtkWidget* w, gpointer data)
{
  ((XttGe *)data)->activate_merge();
}

void XttGeGtk::activate_clear(GtkWidget* w, gpointer data)
{
  ((XttGe *)data)->activate_clear();
}

void XttGeGtk::activate_cellattributes(GtkWidget* w, gpointer data)
{
  ((XttGe *)data)->activate_cellattributes();
}

void XttGeGtk::activate_graphattributes(GtkWidget* w, gpointer data)
{
  ((XttGe *)data)->activate_graphattributes();
}

void XttGeGtk::activate_save(GtkWidget* w, gpointer data)
{
  ((XttGe *)data)->activate_save();
}

void XttGeGtk::activate_saveas(GtkWidget* w, gpointer data)
{
  ((XttGe *)data)->activate_saveas();
}

void XttGeGtk::activate_setcolortheme(GtkWidget* w, gpointer data)
{
  ((XttGe *)data)->activate_setcolortheme();
}

void XttGeGtk::activate_zoom_in(GtkWidget* w, gpointer data)
{
  XttGe* ge = (XttGe*)data;

  ge->graph->zoom(1.2);
}

void XttGeGtk::activate_zoom_out(GtkWidget* w, gpointer data)
{
  XttGe* ge = (XttGe*)data;

  ge->graph->zoom(5.0 / 6);
}

void XttGeGtk::activate_zoom_reset(GtkWidget* w, gpointer data)
{
  XttGe* ge = (XttGe*)data;

  ge->graph->unzoom();
}

void XttGeGtk::activate_help(GtkWidget* w, gpointer data)
{
  XttGe* ge = (XttGe*)data;

  ge->activate_help();
}

void XttGeGtk::action_resize(
    GtkWidget* w, GtkAllocation* allocation, gpointer data)
{
  XttGe* ge = (XttGe*)data;

  if (ge->graph && !ge->scrollbar && !ge->navigator && ge->graph->grow)
    ge->graph->set_default_layout();
}

XttGeGtk::~XttGeGtk()
{
  if (close_cb)
    (close_cb)(parent_ctx, this);
  if (confirm_widget)
    gtk_widget_destroy(confirm_widget);
  if (nav_shell)
    gtk_widget_destroy(nav_shell);
  delete graph;
  if (!(options & ge_mOptions_Embedded))
    gtk_widget_destroy(toplevel);
}

void XttGeGtk::pop()
{
  gtk_window_present(GTK_WINDOW(toplevel));
}

void XttGeGtk::iconify()
{
  gtk_window_iconify(GTK_WINDOW(toplevel));
}

void XttGeGtk::set_title(char *t)
{
  char* titleutf8
      = g_convert(t, -1, "UTF-8", "ISO8859-1", NULL, NULL, NULL);

  gtk_window_set_title(GTK_WINDOW(toplevel), titleutf8);

  g_free(titleutf8);
}

static gint delete_event(GtkWidget* w, GdkEvent* event, gpointer ge)
{
  XttGeGtk::activate_exit(w, ge);

  return TRUE;
}

static void destroy_event(GtkWidget* w, gpointer data)
{
}

static gint nav_delete_event(GtkWidget* w, GdkEvent* event, gpointer ge)
{
  return TRUE;
}

XttGeGtk::XttGeGtk(GtkWidget* xg_parent_wid, void* xg_parent_ctx,
    const char* xg_name, const char* xg_filename, int xg_scrollbar, int xg_menu,
    int xg_navigator, int xg_width, int xg_height, int x, int y,
    double scan_time, const char* object_name, int use_default_access,
    unsigned int access, unsigned int options, void* basewidget,
    double* borders, int color_theme, int dashboard,
    int (*xg_command_cb)(void*, char*, char*, void*),
    int (*xg_get_current_objects_cb)(void*, pwr_sAttrRef**, int**),
    int (*xg_is_authorized_cb)(void*, unsigned int),
    void (*xg_keyboard_cb)(void*, void*, int, int))
    : XttGe(xg_parent_ctx, xg_name, xg_filename, xg_scrollbar, xg_menu,
          xg_navigator, xg_width, xg_height, x, y, scan_time, object_name,
          use_default_access, access, options, color_theme, xg_command_cb,
          xg_get_current_objects_cb, xg_is_authorized_cb, xg_keyboard_cb),
      parent_wid(xg_parent_wid), nav_shell(0), value_dialog(0),
      confirm_widget(0), message_dia_widget(0)
{
  int window_width = 600;
  int window_height = 500;
  GdkGeometry geometry;
  pwr_tStatus sts;
  GtkMenuBar* menu_bar = NULL;
  char title[300];
  int dashboard_reconfigure = 0;

  if (xg_width != 0 && xg_height != 0) {
    window_width = xg_width;
    window_height = xg_height;
  } else {
    sts = Graph::get_dimension(
	filename, "pwrp_exe:", dashboard, &window_width, &window_height);
    if (EVEN(sts)) {
      window_width = 600;
      window_height = 500;
      dashboard_reconfigure = 1;
    }
  }
  str_StrncpyCutOff(title, name, sizeof(title), 1);
  char* titleutf8
      = g_convert(title, -1, "UTF-8", "ISO8859-1", NULL, NULL, NULL);

  // Gtk
  if (!(options & ge_mOptions_Embedded)) {
    toplevel = (GtkWidget*)g_object_new(GTK_TYPE_WINDOW, "default-height",
        window_height, "default-width", window_width, "title", titleutf8, NULL);
    g_free(titleutf8);

    float rd = 0.05;
    if (window_width < 300 || window_height < 300)
      rd = 0.2;

    geometry.min_aspect = gdouble(window_width) / window_height * (1.0 - rd);
    geometry.max_aspect = gdouble(window_width) / window_height * (1.0 + rd);
    gtk_window_set_geometry_hints(
        GTK_WINDOW(toplevel), GTK_WIDGET(toplevel), &geometry, GDK_HINT_ASPECT);

    if (options & ge_mOptions_HideDecorations)
      gtk_window_set_decorated(GTK_WINDOW(toplevel), FALSE);

    if (options & ge_mOptions_Dialog) {
      gtk_window_set_type_hint(
          GTK_WINDOW(toplevel), GDK_WINDOW_TYPE_HINT_DIALOG);
      gtk_widget_set_size_request(
          GTK_WIDGET(toplevel), window_width, window_height);
      gtk_window_set_resizable(GTK_WINDOW(toplevel), FALSE);
    }

    g_signal_connect(toplevel, "delete_event", G_CALLBACK(delete_event), this);
    g_signal_connect(toplevel, "destroy", G_CALLBACK(destroy_event), this);
    g_signal_connect(
        toplevel, "focus-in-event", G_CALLBACK(action_inputfocus), this);

    CoWowGtk::SetWindowIcon(toplevel);

    if (basewidget) {
      gtk_window_set_transient_for(
          GTK_WINDOW(toplevel), GTK_WINDOW(basewidget));
    }
    if (options & ge_mOptions_IsMain)
      CoWow::SetTransient(toplevel);

  } else {
    toplevel = parent_wid;
  }

  if (xg_menu || dashboard) {
    GtkAccelGroup* accel_g
        = (GtkAccelGroup*)g_object_new(GTK_TYPE_ACCEL_GROUP, NULL);
    gtk_window_add_accel_group(GTK_WINDOW(toplevel), accel_g);

    menu_bar = (GtkMenuBar*)g_object_new(GTK_TYPE_MENU_BAR, NULL);

    // File Entry
    GtkMenu* file_menu = (GtkMenu*)g_object_new(GTK_TYPE_MENU, NULL);

    if (dashboard) {
      file_edit = gtk_check_menu_item_new_with_mnemonic(
          CoWowGtk::translate_utf8("_Edit"));
      g_signal_connect(
          file_edit, "activate", G_CALLBACK(activate_edit), this);
      gtk_widget_add_accelerator(file_edit, "activate", accel_g, 'e',
	  GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE);
      gtk_menu_shell_append(GTK_MENU_SHELL(file_menu), file_edit);

      GtkWidget* file_open = gtk_image_menu_item_new_with_mnemonic(
          CoWowGtk::translate_utf8("_Open"));
      g_signal_connect(
          file_open, "activate", G_CALLBACK(activate_open), this);
      gtk_menu_shell_append(GTK_MENU_SHELL(file_menu), file_open);

      GtkWidget* file_save = gtk_image_menu_item_new_with_mnemonic(
          CoWowGtk::translate_utf8("_Save"));
      g_signal_connect(
          file_save, "activate", G_CALLBACK(activate_save), this);
      gtk_widget_add_accelerator(file_save, "activate", accel_g, 's',
	  GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE);
      gtk_menu_shell_append(GTK_MENU_SHELL(file_menu), file_save);

      GtkWidget* file_saveas = gtk_image_menu_item_new_with_mnemonic(
          CoWowGtk::translate_utf8("S_ave as"));
      g_signal_connect(
          file_saveas, "activate", G_CALLBACK(activate_saveas), this);
      gtk_menu_shell_append(GTK_MENU_SHELL(file_menu), file_saveas);

      if (strcmp(title, "PwR Dashboard") == 0) {
	GtkWidget *file_clear = gtk_image_menu_item_new_with_mnemonic(
	    CoWowGtk::translate_utf8("C_lear"));
	g_signal_connect(
            file_clear, "activate", G_CALLBACK(activate_clear), this);
	gtk_menu_shell_append(GTK_MENU_SHELL(file_menu), file_clear);
      }

      GtkWidget* file_setcolortheme = gtk_image_menu_item_new_with_mnemonic(
          CoWowGtk::translate_utf8("S_et Colortheme"));
      g_signal_connect(
          file_setcolortheme, "activate", G_CALLBACK(activate_setcolortheme), this);
      gtk_widget_add_accelerator(file_setcolortheme, "activate", accel_g, 't',
	  GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE);
      gtk_menu_shell_append(GTK_MENU_SHELL(file_menu), file_setcolortheme);
    }

    GtkWidget* file_close
        = gtk_image_menu_item_new_from_stock(GTK_STOCK_CLOSE, accel_g);
    g_signal_connect(file_close, "activate", G_CALLBACK(activate_exit), this);

    gtk_menu_shell_append(GTK_MENU_SHELL(file_menu), file_close);

    GtkWidget* file
        = gtk_menu_item_new_with_mnemonic(CoWowGtk::translate_utf8("_File"));
    gtk_menu_shell_append(GTK_MENU_SHELL(menu_bar), file);
    gtk_menu_item_set_submenu(GTK_MENU_ITEM(file), GTK_WIDGET(file_menu));

    // Edit Entry
    if (dashboard) {
      GtkMenu* edit_menu = (GtkMenu*)g_object_new(GTK_TYPE_MENU, NULL);

      edit_add = gtk_image_menu_item_new_with_mnemonic(
          CoWowGtk::translate_utf8("_Add"));
      g_signal_connect(
          edit_add, "activate", G_CALLBACK(activate_add), this);
      gtk_menu_shell_append(GTK_MENU_SHELL(edit_menu), edit_add);

      edit_delete = gtk_image_menu_item_new_with_mnemonic(
          CoWowGtk::translate_utf8("_Delete"));
      g_signal_connect(
          edit_delete, "activate", G_CALLBACK(activate_delete), this);
      gtk_menu_shell_append(GTK_MENU_SHELL(edit_menu), edit_delete);

      edit_copy = gtk_image_menu_item_new_with_mnemonic(
          CoWowGtk::translate_utf8("_Copy"));
      g_signal_connect(
          edit_copy, "activate", G_CALLBACK(activate_copy), this);
      gtk_widget_add_accelerator(edit_copy, "activate", accel_g, 'c',
	  GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE);
      gtk_menu_shell_append(GTK_MENU_SHELL(edit_menu), edit_copy);

      edit_paste = gtk_image_menu_item_new_with_mnemonic(
          CoWowGtk::translate_utf8("_Paste"));
      g_signal_connect(
          edit_paste, "activate", G_CALLBACK(activate_paste), this);
      gtk_widget_add_accelerator(edit_paste, "activate", accel_g, 'v',
	  GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE);
      gtk_menu_shell_append(GTK_MENU_SHELL(edit_menu), edit_paste);

      edit_connect = gtk_image_menu_item_new_with_mnemonic(
          CoWowGtk::translate_utf8("C_onnect"));
      g_signal_connect(
          edit_connect, "activate", G_CALLBACK(activate_connect), this);
      gtk_menu_shell_append(GTK_MENU_SHELL(edit_menu), edit_connect);

      edit_merge = gtk_image_menu_item_new_with_mnemonic(
          CoWowGtk::translate_utf8("_Merge"));
      g_signal_connect(
          edit_merge, "activate", G_CALLBACK(activate_merge), this);
      gtk_menu_shell_append(GTK_MENU_SHELL(edit_menu), edit_merge);

      edit_cellattributes = gtk_image_menu_item_new_with_mnemonic(
          CoWowGtk::translate_utf8("Cell_Attributes"));
      g_signal_connect(
          edit_cellattributes, "activate", G_CALLBACK(activate_cellattributes), this);
      gtk_menu_shell_append(GTK_MENU_SHELL(edit_menu), edit_cellattributes);

      edit_graphattributes = gtk_image_menu_item_new_with_mnemonic(
          CoWowGtk::translate_utf8("_GraphAttributes"));
      g_signal_connect(
          edit_graphattributes, "activate", G_CALLBACK(activate_graphattributes), this);
      gtk_widget_add_accelerator(edit_cellattributes, "activate", accel_g, 'a',
	  GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE);
      gtk_menu_shell_append(GTK_MENU_SHELL(edit_menu), edit_graphattributes);

      GtkWidget* edit
        = gtk_menu_item_new_with_mnemonic(CoWowGtk::translate_utf8("_Edit"));
      gtk_menu_shell_append(GTK_MENU_SHELL(menu_bar), edit);
      gtk_menu_item_set_submenu(GTK_MENU_ITEM(edit), GTK_WIDGET(edit_menu));
    }

    // View menu
    if (!dashboard) {
      GtkWidget* view_zoom_in
          = gtk_image_menu_item_new_from_stock(GTK_STOCK_ZOOM_IN, NULL);
      g_signal_connect(
          view_zoom_in, "activate", G_CALLBACK(activate_zoom_in), this);
      gtk_widget_add_accelerator(view_zoom_in, "activate", accel_g, 'i',
          GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE);

      GtkWidget* view_zoom_out
          = gtk_image_menu_item_new_from_stock(GTK_STOCK_ZOOM_OUT, NULL);
      g_signal_connect(
          view_zoom_out, "activate", G_CALLBACK(activate_zoom_out), this);
      gtk_widget_add_accelerator(view_zoom_out, "activate", accel_g, 'o',
          GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE);

      GtkWidget* view_zoom_reset
          = gtk_image_menu_item_new_from_stock(GTK_STOCK_ZOOM_100, NULL);
      g_signal_connect(
          view_zoom_reset, "activate", G_CALLBACK(activate_zoom_reset), this);

      GtkMenu* view_menu = (GtkMenu*)g_object_new(GTK_TYPE_MENU, NULL);
      gtk_menu_shell_append(GTK_MENU_SHELL(view_menu), view_zoom_in);
      gtk_menu_shell_append(GTK_MENU_SHELL(view_menu), view_zoom_out);
      gtk_menu_shell_append(GTK_MENU_SHELL(view_menu), view_zoom_reset);

      GtkWidget* view
          = gtk_menu_item_new_with_mnemonic(CoWowGtk::translate_utf8("_View"));
      gtk_menu_shell_append(GTK_MENU_SHELL(menu_bar), view);
      gtk_menu_item_set_submenu(GTK_MENU_ITEM(view), GTK_WIDGET(view_menu));
    }

    // Menu Help
    GtkWidget* help_help
        = gtk_image_menu_item_new_from_stock(GTK_STOCK_HELP, accel_g);
    g_signal_connect(help_help, "activate", G_CALLBACK(activate_help), this);

    GtkMenu* help_menu = (GtkMenu*)g_object_new(GTK_TYPE_MENU, NULL);
    gtk_menu_shell_append(GTK_MENU_SHELL(help_menu), help_help);

    GtkWidget* help
        = gtk_menu_item_new_with_mnemonic(CoWowGtk::translate_utf8("_Help"));
    gtk_menu_shell_append(GTK_MENU_SHELL(menu_bar), help);
    gtk_menu_item_set_submenu(GTK_MENU_ITEM(help), GTK_WIDGET(help_menu));
  }

  graph_form = gtk_vbox_new(FALSE, 0);
  graph = new GraphGtk(this, graph_form, "Plant", &grow_widget, &sts,
      "pwrp_exe:", graph_eMode_Runtime, scrollbar, 1, object_name,
      use_default_access, access, 0, color_theme, dashboard, ge_keyboard_cb);
  // graph->set_scantime( scan_time);
  graph->message_cb = &message_cb;
  graph->close_cb = &graph_close_cb;
  graph->init_cb = &graph_init_cb;
  graph->change_value_cb = &ge_change_value_cb;
  graph->confirm_cb = &confirm_cb;
  graph->message_dialog_cb = &message_dialog_cb;
  graph->command_cb = &ge_command_cb;
  graph->display_in_xnav_cb = &ge_display_in_xnav_cb;
  graph->is_authorized_cb = &ge_is_authorized_cb;
  graph->get_current_objects_cb = &ge_get_current_objects_cb;
  graph->popup_menu_cb = &ge_popup_menu_cb;
  graph->call_method_cb = &ge_call_method_cb;
  graph->sound_cb = &ge_sound_cb;
  graph->eventlog_cb = &ge_eventlog_cb;
  graph->resize_cb = &ge_resize_cb;
  graph->get_rtplant_select_cb = &ge_get_rtplant_select_cb;

  // g_signal_connect( graph_form, "check_resize", G_CALLBACK(action_resize),
  // this);
  g_signal_connect(((GraphGtk*)graph)->grow_widget, "size_allocate",
      G_CALLBACK(action_resize), this);

  if (xg_menu)
    gtk_box_pack_start(
        GTK_BOX(graph_form), GTK_WIDGET(menu_bar), FALSE, FALSE, 0);
  gtk_box_pack_start(
      GTK_BOX(graph_form), GTK_WIDGET(grow_widget), TRUE, TRUE, 0);

  if (!(options & ge_mOptions_Embedded)) {
    gtk_container_add(GTK_CONTAINER(toplevel), graph_form);

    gtk_widget_show_all(toplevel);

    if (navigator) {
      // Create navigator popup
      nav_shell = (GtkWidget*)g_object_new(GTK_TYPE_WINDOW, "default-height",
          200, "default-width", 200, "title", "Navigator", NULL);
      g_signal_connect(
          nav_shell, "delete_event", G_CALLBACK(nav_delete_event), this);

      ((GraphGtk*)graph)->create_navigator(nav_shell);
      gtk_container_add(
          GTK_CONTAINER(nav_shell), ((GraphGtk*)graph)->nav_widget);

      gtk_widget_show_all(nav_shell);
      ((Graph*)graph)->set_nav_background_color();
    }

    if (!(x == 0 && y == 0)) {
      // Set position
      gtk_window_move(GTK_WINDOW(toplevel), x, y);
    }

    if (options & ge_mOptions_FullScreen)
      gtk_window_fullscreen(GTK_WINDOW(toplevel));
    else if (options & ge_mOptions_Maximize)
      gtk_window_maximize(GTK_WINDOW(toplevel)); // TODO
    else if (options & ge_mOptions_FullMaximize)
      gtk_window_maximize(GTK_WINDOW(toplevel));
    else if (options & ge_mOptions_Iconify)
      gtk_window_iconify(GTK_WINDOW(toplevel));
    else if (options & ge_mOptions_Invisible)
      g_object_set(toplevel, "visible", FALSE, NULL);
  } else {
    gtk_widget_set_size_request(graph_form, window_width, window_height);
  }

  if (borders)
    ((Graph*)graph)->set_borders(borders);

  if (streq(filename, "_none_") && xg_width == 0 && xg_height == 0) {
    // Set size from current layout
    double x0, y0, x1, y1, zoom;
    float rd = 0.05;

    grow_GetLayout(graph->grow->ctx, &x0, &y0, &x1, &y1);
    grow_GetZoom(graph->grow->ctx, &zoom);
    window_width = zoom * (x1 - x0);
    window_height = zoom * (y1 - y0);

    if (window_width < 300 || window_height < 300)
      rd = 0.2;

    geometry.min_aspect = gdouble(window_width) / window_height * (1.0 - rd);
    geometry.max_aspect = gdouble(window_width) / window_height * (1.0 + rd);
    gtk_window_set_geometry_hints(
        GTK_WINDOW(toplevel), GTK_WIDGET(toplevel), &geometry, GDK_HINT_ASPECT);

    gtk_widget_set_size_request(toplevel, window_width, window_height);
  }

  if (dashboard) {
    menu_setup(0);
    if (dashboard_reconfigure)
      graph->dashboard_reconfigure();
  }
  wow = new CoWowGtk(parent_wid);
}

static gint confirm_delete_event(GtkWidget* w, GdkEvent* event, gpointer ge)
{
  g_object_set(((XttGeGtk*)ge)->confirm_widget, "visible", FALSE, NULL);
  return TRUE;
}

void XttGeGtk::create_confirm_dialog()
{
  if (confirm_widget) {
    g_object_set(confirm_widget, "visible", TRUE, NULL);
    return;
  }

  // Create a confirm window
  confirm_widget = (GtkWidget*)g_object_new(GTK_TYPE_WINDOW, "default-height",
      150, "default-width", 400, "title", CoWowGtk::translate_utf8("Confirm"),
      NULL);
  g_signal_connect(
      confirm_widget, "delete_event", G_CALLBACK(confirm_delete_event), this);
  confirm_label = gtk_label_new("");
  GtkWidget* confirm_image = (GtkWidget*)g_object_new(GTK_TYPE_IMAGE, "stock",
      GTK_STOCK_DIALOG_QUESTION, "icon-size", GTK_ICON_SIZE_DIALOG, "xalign",
      0.5, "yalign", 1.0, NULL);

  GtkWidget* confirm_ok
      = gtk_button_new_with_label(CoWowGtk::translate_utf8("Yes"));
  gtk_widget_set_size_request(confirm_ok, 70, 25);
  g_signal_connect(
      confirm_ok, "clicked", G_CALLBACK(activate_confirm_ok), this);

  GtkWidget* confirm_cancel
      = gtk_button_new_with_label(CoWowGtk::translate_utf8("No"));
  gtk_widget_set_size_request(confirm_cancel, 70, 25);
  g_signal_connect(
      confirm_cancel, "clicked", G_CALLBACK(activate_confirm_cancel), this);

  GtkWidget* confirm_hboxtext = gtk_hbox_new(FALSE, 0);
  gtk_box_pack_start(
      GTK_BOX(confirm_hboxtext), confirm_image, FALSE, FALSE, 15);
  gtk_box_pack_start(GTK_BOX(confirm_hboxtext), confirm_label, TRUE, TRUE, 15);

  GtkWidget* confirm_hboxbuttons = gtk_hbox_new(TRUE, 40);
  gtk_box_pack_start(GTK_BOX(confirm_hboxbuttons), confirm_ok, FALSE, FALSE, 0);
  gtk_box_pack_end(
      GTK_BOX(confirm_hboxbuttons), confirm_cancel, FALSE, FALSE, 0);

  GtkWidget* confirm_vbox = gtk_vbox_new(FALSE, 0);
  gtk_box_pack_start(GTK_BOX(confirm_vbox), confirm_hboxtext, TRUE, TRUE, 30);
  gtk_box_pack_start(
      GTK_BOX(confirm_vbox), gtk_hseparator_new(), FALSE, FALSE, 0);
  gtk_box_pack_end(
      GTK_BOX(confirm_vbox), confirm_hboxbuttons, FALSE, FALSE, 15);
  gtk_container_add(GTK_CONTAINER(confirm_widget), confirm_vbox);
  gtk_widget_show_all(confirm_widget);
}
