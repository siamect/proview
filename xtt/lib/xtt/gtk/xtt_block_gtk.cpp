/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* xtt_block_gtk.cpp -- Alarm blocking window in xtt. */

#include "pwr_privilege.h"
#include "co_cdh.h"
#include "co_msg.h"
#include "rt_gdh.h"
#include "rt_mh_outunit.h"

#include "cow_wow_gtk.h"

#include "xtt_block_gtk.h"

int BlockGtk::execute()
{
  mh_eEventPrio prio;
  pwr_tStatus sts;

  if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(toggleA)))
    prio = mh_eEventPrio_A;
  else if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(toggleB)))
    prio = mh_eEventPrio_B;
  else if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(toggleC)))
    prio = mh_eEventPrio_C;
  else if (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(toggleD)))
    prio = mh_eEventPrio_D;
  else
    prio = (mh_eEventPrio)0;

  sts = mh_OutunitBlock(oar.Objid, prio);
  if (EVEN(sts)) {
    char msg[80];

    msg_GetMsg(sts, msg, sizeof(msg));
    wow->DisplayError("Block Error", msg);
  }
  return sts;
}

void BlockGtk::update()
{
  pwr_tStatus sts;
  mh_uEventInfo block_level;

  sts = gdh_GetAlarmInfo(
      oar.Objid, NULL, NULL, (pwr_tUInt32*)&block_level, NULL, NULL);
  switch (block_level.Event.Prio) {
  case mh_eEventPrio_A:
    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(toggleA), TRUE);
    break;
  case mh_eEventPrio_B:
    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(toggleB), TRUE);
    break;
  case mh_eEventPrio_C:
    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(toggleC), TRUE);
    break;
  case mh_eEventPrio_D:
    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(toggleD), TRUE);
    break;
  case 0:
    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(toggleNo), TRUE);
    break;
  default:
    break;
  }
}

void BlockGtk::activate_apply(GtkWidget* w, gpointer data)
{
  Block* blk = (Block*)data;

  blk->execute();
}

void BlockGtk::activate_ok(GtkWidget* w, gpointer data)
{
  Block* blk = (Block*)data;
  pwr_tStatus sts;

  sts = blk->execute();
  if (ODD(sts))
    delete blk;
}

void BlockGtk::activate_cancel(GtkWidget* w, gpointer data)
{
  Block* blk = (Block*)data;

  delete blk;
}

BlockGtk::~BlockGtk()
{
  delete wow;
  gtk_widget_destroy(toplevel);
}

static gint delete_event(GtkWidget* w, GdkEvent* event, gpointer data)
{
  BlockGtk::activate_cancel(w, data);
  return TRUE;
}

BlockGtk::BlockGtk(void* b_parent_ctx, GtkWidget* b_parent_wid,
    pwr_sAttrRef* b_oar, char* name, unsigned int priv, pwr_tStatus* sts)
    : Block(b_parent_ctx, b_oar, name, priv, sts), parent_wid(b_parent_wid)
{
  char title[400];
  pwr_tAName aname;

  *sts = gdh_AttrrefToName(&oar, aname, sizeof(aname), cdh_mNName);
  if (EVEN(*sts))
    return;

  strcpy(title, name);
  strcat(title, "    ");
  strcat(title, aname);

  toplevel = (GtkWidget*)g_object_new(GTK_TYPE_WINDOW, "default-height", 300,
      "default-width", 500, "title", title, NULL);
  g_signal_connect(toplevel, "delete_event", G_CALLBACK(delete_event), this);

  CoWowGtk::SetWindowIcon(toplevel);

  GSList* bl_group = NULL;
  toggleA = gtk_radio_button_new_with_label(bl_group, "A Alarm");
  bl_group = gtk_radio_button_get_group(GTK_RADIO_BUTTON(toggleA));
  toggleB = gtk_radio_button_new_with_label(bl_group, "B Alarm");
  bl_group = gtk_radio_button_get_group(GTK_RADIO_BUTTON(toggleB));
  toggleC = gtk_radio_button_new_with_label(bl_group, "C Alarm");
  bl_group = gtk_radio_button_get_group(GTK_RADIO_BUTTON(toggleC));
  toggleD = gtk_radio_button_new_with_label(bl_group, "D Alarm");
  bl_group = gtk_radio_button_get_group(GTK_RADIO_BUTTON(toggleD));
  toggleNo = gtk_radio_button_new_with_label(bl_group, "No Blocking");
  bl_group = gtk_radio_button_get_group(GTK_RADIO_BUTTON(toggleNo));

  GtkWidget* toggle_vbox = gtk_vbox_new(FALSE, 0);
  gtk_box_pack_start(GTK_BOX(toggle_vbox), toggleA, FALSE, FALSE, 7);
  gtk_box_pack_start(GTK_BOX(toggle_vbox), toggleB, FALSE, FALSE, 7);
  gtk_box_pack_start(GTK_BOX(toggle_vbox), toggleC, FALSE, FALSE, 7);
  gtk_box_pack_start(GTK_BOX(toggle_vbox), toggleD, FALSE, FALSE, 7);
  gtk_box_pack_start(GTK_BOX(toggle_vbox), toggleNo, FALSE, FALSE, 7);

  buttonOk = gtk_button_new_with_label("Ok");
  gtk_widget_set_size_request(buttonOk, 70, 25);
  g_signal_connect(buttonOk, "clicked", G_CALLBACK(activate_ok), this);

  buttonApply = gtk_button_new_with_label("Apply");
  gtk_widget_set_size_request(buttonApply, 70, 25);
  g_signal_connect(buttonApply, "clicked", G_CALLBACK(activate_apply), this);

  GtkWidget* buttonCancel = gtk_button_new_with_label("Cancel");
  gtk_widget_set_size_request(buttonCancel, 70, 25);
  g_signal_connect(buttonCancel, "clicked", G_CALLBACK(activate_cancel), this);

  GtkWidget* hboxbuttons = gtk_hbox_new(TRUE, 40);
  gtk_box_pack_start(GTK_BOX(hboxbuttons), buttonOk, FALSE, FALSE, 0);
  gtk_box_pack_start(GTK_BOX(hboxbuttons), buttonApply, FALSE, FALSE, 0);
  gtk_box_pack_end(GTK_BOX(hboxbuttons), buttonCancel, FALSE, FALSE, 0);

  GtkWidget* vbox = gtk_vbox_new(FALSE, 0);
  gtk_box_pack_start(GTK_BOX(vbox), toggle_vbox, FALSE, FALSE, 15);
  gtk_box_pack_start(GTK_BOX(vbox), gtk_hseparator_new(), FALSE, FALSE, 0);
  gtk_box_pack_end(GTK_BOX(vbox), hboxbuttons, FALSE, FALSE, 15);
  gtk_container_add(GTK_CONTAINER(toplevel), vbox);
  gtk_widget_show_all(toplevel);

  if (!(priv & pwr_mPrv_RtEventsBlock || priv & pwr_mPrv_System)) {
    gtk_widget_set_sensitive(buttonOk, FALSE);
    gtk_widget_set_sensitive(buttonApply, FALSE);
    gtk_widget_set_sensitive(toggleA, FALSE);
    gtk_widget_set_sensitive(toggleB, FALSE);
    gtk_widget_set_sensitive(toggleC, FALSE);
    gtk_widget_set_sensitive(toggleD, FALSE);
    gtk_widget_set_sensitive(toggleNo, FALSE);
  }

  wow = new CoWowGtk(parent_wid);

  update();
}
