/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/*
  Interface for global function keys.
  The syntax of the definition file is

  ['Modifier1'] ['Modifier2'] ['Modifier3'] <Key>'key' : 'action'('argument')

  where
    Modifier1,2 and 3 can be Control, Alt or Shift.
    key any key symbol, for example F10.
    action, the name of a registred action function: SetDig, ResetDig, ToggleDig
  or Command.
    argument, argument to the action function (an attribute, or a command)

  Example
    Control <Key>F11 		: ToggleDig(Test-Dv1.ActualValue)
    Shift <Key>F11     		: ToggleDig(Test-Dv2.ActualValue)
    Control Shift <Key>F11 	: ToggleDig(Test-Dv3.ActualValue)
    Alt <Key>F11 		: ToggleDig(Test-Dv4.ActualValue)
    Control Alt <Key>F11 	: ToggleDig(Test-Dv5.ActualValue)
    Control Shift Alt <Key>F11 	: ToggleDig(Test-Dv6.ActualValue)
    <Key>F10 			: SetDig(Test-Dv2.ActualValue)
    <Key>F12 			: Command (open graph gtest)
 */
#if defined OS_LINUX

#include <stdio.h>

#include "co_cdh.h"
#include "co_dcli.h"
#include "co_string.h"

#include "xtt_hotkey_qt.h"

#include <QKeyEvent>
#include <QKeySequence>

HotkeyAction::HotkeyAction(const char* name, void (*action)(char*, void*))
    : m_action(action)
{
  strcpy(m_name, name);
}

HotkeyAction::HotkeyAction(const HotkeyAction& x) : m_action(x.m_action)
{
  strcpy(m_name, x.m_name);
}

HotkeyKey::HotkeyKey(int mod, int key, char* action_name, char* action_arg)
    : m_mod(mod), m_key(key), m_action(0), m_userdata(0)
{
  strcpy(m_action_name, action_name);
  strcpy(m_action_arg, action_arg);
}

HotkeyKey::HotkeyKey(const HotkeyKey& x)
    : m_mod(x.m_mod), m_key(x.m_key), m_action(x.m_action),
      m_userdata(x.m_userdata)
{
  strcpy(m_action_name, x.m_action_name);
  strcpy(m_action_arg, x.m_action_arg);
}

void HotkeyKey::set_action(HotkeyAction* action, void* userdata)
{
  if (streq(m_action_name, action->m_name)) {
    m_action = action->m_action;
    m_userdata = userdata;
  }
}

void XttHotkey::register_action(
    const char* name, void (*action)(char*, void*), void* userdata)
{
  HotkeyAction a(name, action);
  m_actions.push_back(a);

  for (int i = 0; i < (int)m_keys.size(); i++) {
    m_keys[i].set_action(&m_actions[m_actions.size() - 1], userdata);
  }
}

XttHotkey::XttHotkey(const char* filename)
{
  strcpy(m_filename, filename);
  read_file();
}

int XttHotkey::read_file()
{
  FILE* fp;
  char line[200];
  int row = 0;
  char p1[2][200];
  char p2[10][200];
  int i, n;
  char* s;

  dcli_translate_filename(m_filename, m_filename);
  fp = fopen(m_filename, "r");
  if (!fp)
    return 0;

  while (dcli_read_line(line, sizeof(line), fp)) {
    int mod = 0;
    char keystr[20] = "";
    char action_arg[200];
    char action_name[200];

    row++;

    str_trim(line, line);
    if (line[0] == 0 || line[0] == '#')
      continue;

    n = dcli_parse(
        line, ":", "", (char*)p1, sizeof(p1) / sizeof(p1[0]), sizeof(p1[0]), 0);
    if (n != 2) {
      printf("Syntax error, %s, row %d\n", m_filename, row);
      continue;
    }
    str_trim(p1[0], p1[0]);
    str_trim(p1[1], p1[1]);

    n = dcli_parse(p1[0], " 	", "", (char*)p2, sizeof(p2) / sizeof(p2[0]),
        sizeof(p2[0]), 0);
    if (n < 1) {
      printf("Syntax error, %s, row %d\n", m_filename, row);
      continue;
    }
    for (i = 0; i < n; i++) {
      if (str_NoCaseStrcmp(p2[i], "Control") == 0)
        mod |= Qt::ControlModifier;
      else if (str_NoCaseStrcmp(p2[i], "Shift") == 0)
        mod |= Qt::ShiftModifier;
      else if (str_NoCaseStrcmp(p2[i], "Alt") == 0)
        mod |= Qt::AltModifier;
      else if (str_NoCaseStrncmp(p2[i], "<key>", 5) == 0) {
        strcpy(keystr, &p2[i][5]);
        str_trim(keystr, keystr);
      } else {
        printf("Syntax error, %s, row %d\n", m_filename, row);
        break;
      }
    }

    n = dcli_parse(p1[1], "(", "", (char*)p2, sizeof(p2) / sizeof(p2[0]),
        sizeof(p2[0]), 0);
    if (n < 2) {
      printf("Syntax error, %s, row %d\n", m_filename, row);
      continue;
    }
    strcpy(action_name, p2[0]);
    str_trim(action_name, action_name);
    strcpy(action_arg, p2[1]);
    if ((s = strrchr(action_arg, ')')))
      *s = 0;
    else {
      printf("Syntax error, %s, row %d\n", m_filename, row);
      continue;
    }
    QKeySequence seq = QKeySequence(keystr);
    int keycode = seq[0];
    if (!keycode) {
      printf("Syntax error, %s, row %d\n", m_filename, row);
      continue;
    }

    HotkeyKey key(mod, keycode, action_name, action_arg);
    m_keys.push_back(key);
  }

  fclose(fp);

  return 1;
}

int XttHotkey::event_handler(QEvent* event, QObject* data)
{
  XttHotkey* hotkey = (XttHotkey*)data;

  if (event->type() == QEvent::KeyPress) {
    QKeyEvent* e = ((QKeyEvent*)event);
    int key = e->key();

    for (int i = 0; i < (int)hotkey->m_keys.size(); i++) {
      if (hotkey->m_keys[i].m_key == key
          && (hotkey->m_keys[i].m_mod & e->modifiers() & ~Qt::MetaModifier
                 & ~Qt::GroupSwitchModifier)) {
        if (hotkey->m_keys[i].m_action)
          (hotkey->m_keys[i].m_action)(
              hotkey->m_keys[i].m_action_arg, hotkey->m_keys[i].m_userdata);
      }
    }
  }
  return 0;
}

#endif
