/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <stdlib.h>

#include "co_cdh.h"
#include "co_msg.h"
#include "co_string.h"
#include "co_time.h"

#include "rt_gdh.h"
#include "rt_xnav_msg.h"

#include "cow_qt_helpers.h"

#include "glow_growctx.h"
#include "glow_growapi.h"
#include "glow_msg.h"

#include "xtt_ev.h"
#include "xtt_evala_qt.h"
#include "xtt_eveve_qt.h"
#include "xtt_ge_qt.h"
#include "xtt_multiview_qt.h"
#include "xtt_otree.h"
#include "xtt_trend_qt.h"
#include "xtt_sevhist_qt.h"
#include "xtt_stream_qt.h"
#include "xtt_xnav.h"

// TODO: Clean up this mess
// TODO: The Box layout is identical to the Table layout
//       => Use the Table layout for both Box+Table.

void XttMultiViewQtWidget::focusInEvent(QFocusEvent* event)
{
  if (!multiview->focustimer.disabled()) {
    multiview->focustimer.disable(400);
  }
  QWidget::focusInEvent(event);
}

void XttMultiViewQt::set_size(int width, int height)
{
  toplevel->resize(width, height);
}

XttMultiViewQt::~XttMultiViewQt()
{
  if (close_cb) {
    (close_cb)(parent_ctx, this);
  }

  for (unsigned int i = 0; i < views.size(); i++) {
    if (views[i].tag == pwr_eMultiViewContentEnum_AlarmList) {
      delete (EvAlaQt*)views[i].data;
    } else if (views[i].tag == pwr_eMultiViewContentEnum_EventList) {
      delete (EvEveQt*)views[i].data;
    } else if (views[i].tag == pwr_eMultiViewContentEnum_Graph ||
               views[i].tag == pwr_eMultiViewContentEnum_ObjectGraph) {
      delete (XttGeQt*)views[i].data;
    } else if (views[i].tag == pwr_eMultiViewContentEnum_MultiView) {
      delete (XttMultiViewQt*)views[i].data;
    } else if (views[i].tag == pwr_eMultiViewContentEnum_TrendCurve) {
      delete (XttTrendQt*)views[i].data;
    } else if (views[i].tag == pwr_eMultiViewContentEnum_SevHistory) {
      delete (XttSevHistQt*)views[i].data;
    } else if (views[i].tag == pwr_eMultiViewContentEnum_Camera) {
      delete (XttStreamQt*)views[i].data;
    }
  }
}

void XttMultiViewQt::pop()
{
  ::pop(toplevel);
}

void XttMultiViewQtWidget::closeEvent(QCloseEvent* event)
{
  if (multiview->options & ge_mOptions_IsMain) {
    (multiview->close_cb)(multiview->parent_ctx, multiview);
  } else {
    delete multiview;
  }
  QWidget::closeEvent(event);
}

XttMultiViewQt::XttMultiViewQt(void* mv_parent_ctx, const char* mv_name,
    pwr_tAttrRef* mv_aref, int mv_width, int mv_height, int mv_x, int mv_y,
    unsigned int mv_options, void* basewidget, int mv_color_theme,
    pwr_tStatus* sts, int (*mv_command_cb)(void*, char*, char*, void*),
    int (*mv_get_current_objects_cb)(void*, pwr_sAttrRef**, int**),
    int (*mv_is_authorized_cb)(void*, unsigned int),
    void (*mv_keyboard_cb)(void*, void*, int, int))
    : XttMultiView(mv_parent_ctx, mv_name, mv_aref, mv_width, mv_height, mv_x,
          mv_y, mv_options, mv_color_theme, mv_command_cb,
          mv_get_current_objects_cb, mv_is_authorized_cb, mv_keyboard_cb)
{
  pwr_tStatus lsts;
  XNav* xnav = get_xnav();

  pwr_sClass_XttMultiView mv;
  *sts = gdh_GetObjectInfoAttrref(&aref, &mv, sizeof(mv));
  if (EVEN(*sts)) {
    return;
  }

  int window_width, window_height;
  if (mv_width != 0 && mv_height != 0) {
    window_width = mv_width;
    window_height = mv_height;
  } else if (mv.Width != 0 && mv.Height != 0) {
    window_width = mv.Width;
    window_height = mv.Height;
  } else {
    window_width = 600;
    window_height = 500;
  }

  // Qt
  toplevel = new XttMultiViewQtWidget(this);
  toplevel->setMinimumSize(window_width, window_height);
  if (!(options & ge_mOptions_Embedded)) {
    toplevel->setWindowTitle(QString::fromLatin1(mv.Title));
    toplevel->setAttribute(Qt::WA_DeleteOnClose);

    if (mv.Options & pwr_mMultiViewOptionsMask_HideDecorations) {
      toplevel->setWindowFlags(Qt::CustomizeWindowHint);
    }

    if (mv.Options & pwr_mMultiViewOptionsMask_Dialog) {
      toplevel->setWindowFlags(Qt::Dialog);
    }

    CoWowQt::SetWindowIcon(toplevel);
  }

  {
    rows = mv.Rows;
    cols = mv.Columns;
    views = std::vector<View>(rows * cols);
    comp_widget = std::vector<QWidget*>(rows * cols);
    exchange_widget = std::vector<QWidget*>(rows * cols);
    exchange_widget_layout = std::vector<QHBoxLayout*>(rows * cols);

    QHBoxLayout* col_widget_box = new QHBoxLayout();
    QSplitter* col_widget_pane = new QSplitter();
    QGridLayout* col_widget_table = new QGridLayout();

    if (!(mv.Layout == pwr_eMultiViewLayoutEnum_Box ||
        mv.Layout == pwr_eMultiViewLayoutEnum_Fix ||
        mv.Layout == pwr_eMultiViewLayoutEnum_Pane ||
        mv.Layout == pwr_eMultiViewLayoutEnum_Table)) {
      return;
    }

    for (int i = 0; i < cols; i++) {
      QVBoxLayout* row_widget_box = new QVBoxLayout();
      QSplitter* row_widget_pane = new QSplitter(Qt::Vertical);

      for (int j = 0; j < rows; j++) {
        pwr_tFileName graph_name;

        int idx = i * rows + j;
        int w = mv.Action[idx].Width;
        int h = mv.Action[idx].Height;
        bool scrollbar = (mv.Action[idx].Options
                        & pwr_mMultiViewElemOptionsMask_Scrollbars);
        bool menu = (mv.Action[idx].Options
                   & pwr_mMultiViewElemOptionsMask_Menu);
        strcpy(graph_name, mv.Action[idx].Action);
        int type = mv.Action[idx].Type;

        switch (type) { // TODO: Add support for FastCurve
        case pwr_eMultiViewContentEnum_AlarmList: {
          if (xnav->ev) {
            EvAlaQt* ala = (EvAlaQt*)xnav->ev->open_alarmlist_satellite(
                "No title", &lsts, w, h, 0, 0, mv.Action[idx].Object[0].Objid,
                ev_mAlaOptions_Embedded, toplevel);
            if (!ala) {
              continue;
            }
            setDataAndTag(idx, type, ala);
            comp_widget[idx] = ala->get_widget();
          }
          break;
        }
        case pwr_eMultiViewContentEnum_EventList: {
          if (xnav->ev) {
            EvEveQt* eve =  (EvEveQt*)xnav->ev->open_eventlist_satellite(
                "No title", &lsts, w, h, 0, 0, mv.Action[idx].Object[0].Objid,
                ev_mAlaOptions_Embedded, toplevel);
            if (!eve) {
              continue;
            }
            setDataAndTag(idx, type, eve);
            comp_widget[idx] = eve->get_widget();
          }
          break;
        }
        case pwr_eMultiViewContentEnum_Graph:
        case pwr_eMultiViewContentEnum_ObjectGraph: {
          char* objectname_p = 0;
          char objectname[800];
          double borders[4];
          double* bordersp = 0;
          char* s;

          for (int k = 0; k < 4; k++) {
            pwr_tAName oname;

            if (cdh_ObjidIsNull(mv.Action[idx].Object[k].Objid)) {
              break;
            }
            lsts = gdh_AttrrefToName(&mv.Action[idx].Object[k], oname,
                sizeof(oname), cdh_mName_volumeStrict);
            if (EVEN(lsts)) {
              break;
            }

            if (k == 0) {
              strncpy(objectname, oname, sizeof(objectname));
            } else {
              strncat(objectname, ",", sizeof(objectname) - strlen(objectname) - 1);
              strncat(objectname, oname, sizeof(objectname) - strlen(objectname) - 1);
            }
            objectname_p = objectname;
          }

          if (!feqf(mv.Action[idx].Borders[0], 0.0f)
              || !feqf(mv.Action[idx].Borders[1], 0.0f)
              || !feqf(mv.Action[idx].Borders[2], 0.0f)
              || !feqf(mv.Action[idx].Borders[3], 0.0f)) {
            for (int k = 0; k < 4; k++) {
              borders[k] = mv.Action[idx].Borders[k];
            }
            bordersp = borders;
          }

          XttGeQt* ge = new XttGeQt(this, "No title", graph_name, scrollbar,
              menu, 0, w, h, mv_x, mv_y, 1.0, objectname_p, 0, 0,
              ge_mOptions_Embedded, 0, bordersp, color_theme,
              multiview_ge_command_cb, multiview_ge_get_current_objects_cb,
              multiview_ge_is_authorized_cb, multiview_keyboard_cb);
          setDataAndTag(idx, type, ge);

          ge->close_cb = multiview_ge_close_cb;
          ge->help_cb = multiview_ge_help_cb;
          ge->display_in_xnav_cb
              = multiview_ge_display_in_xnav_cb;
          ge->popup_menu_cb = multiview_ge_popup_menu_cb;
          ge->call_method_cb = multiview_ge_call_method_cb;
          ge->sound_cb = multiview_ge_sound_cb;
          ge->eventlog_cb = multiview_ge_eventlog_cb;

          comp_widget[idx] = ge->get_graph_widget();

          recall_buffer[idx].insert(graph_name, objectname_p);

          if ((s = strchr(graph_name, '.'))) {
            *s = 0;
          }
          appl.insert(applist_eType_Graph, views[idx].data,
              pwr_cNObjid, graph_name, objectname_p);

          break;
        }
        case pwr_eMultiViewContentEnum_MultiView: {
          pwr_tAttrRef graph_aref;

          lsts = gdh_NameToAttrref(pwr_cNObjid, graph_name, &graph_aref);
          if (EVEN(lsts)) {
            break;
          }

          XttMultiViewQt* mv = new XttMultiViewQt(this, "No title", &graph_aref,
              w, h, mv_x, mv_y, ge_mOptions_Embedded, 0, color_theme, &lsts,
              multiview_ge_command_cb, multiview_ge_get_current_objects_cb,
              multiview_ge_is_authorized_cb, multiview_keyboard_cb);
          setDataAndTag(idx, type, mv);
          mv->close_cb = multiview_ge_close_cb;
          mv->help_cb = multiview_ge_help_cb;
          mv->display_in_xnav_cb
              = multiview_ge_display_in_xnav_cb;
          mv->popup_menu_cb = multiview_ge_popup_menu_cb;
          mv->call_method_cb = multiview_ge_call_method_cb;
          mv->sound_cb = multiview_ge_sound_cb;
          mv->eventlog_cb = multiview_ge_eventlog_cb;

          comp_widget[idx]
              = (QWidget*)mv->get_widget();

          recall_buffer[idx].insert(graph_name, 0);

          appl.insert(applist_eType_MultiView, views[idx].data,
              &aref, "", NULL);

          break;
        }
        case pwr_eMultiViewContentEnum_TrendCurve: {
          pwr_tCid classid;
          QWidget* widget;
          pwr_tAttrRef arefv[2];

          lsts
              = gdh_GetAttrRefTid(&mv.Action[idx].Object[0], &classid);
          if (EVEN(lsts)) {
            break;
          }

          XttTrendQt* trend;
          if (classid == pwr_cClass_PlotGroup) {
            arefv[0] = mv.Action[idx].Object[0];
            trend = new XttTrendQt(this, (char*)"No title", &widget, 0,
                &(arefv[0]), w, h, (unsigned int)curve_mOptions_Embedded,
                color_theme, 0, sts);
            setDataAndTag(idx, type, trend);
          } else if (classid == pwr_cClass_DsTrend || classid == pwr_cClass_DsTrendCurve) {
            arefv[0] = mv.Action[idx].Object[0];
            memset(&arefv[1], 0, sizeof(arefv[0]));
            trend = new XttTrendQt(this, (char*)"No title", &widget, arefv, 0,
                w, h, (unsigned int)curve_mOptions_Embedded, color_theme, 0,
                sts);
            setDataAndTag(idx, type, trend);
          } else {
            break;
          }
          if (EVEN(*sts)) {
            break;
          }

          trend->close_cb = multiview_trend_close_cb;
          trend->command_cb = multiview_trend_command_cb;
          trend->help_cb = multiview_trend_help_cb;

          comp_widget[idx] = widget;

          appl.insert(applist_eType_Trend, views[idx].data,
              &arefv[0], "", NULL);

          break;
        }
        case pwr_eMultiViewContentEnum_SevHistory: {
          pwr_tOid oidv[11];
          pwr_tOName anamev[11];
          pwr_tOName onamev[11];
          bool sevhistobjectv[11];
          pwr_tAttrRef attr_aref, sevhist_aref;
          pwr_tOid histthread_oid;
          char server_node[40];
          char* s;
          pwr_tAName aname;
          int oid_cnt = 0;
          pwr_tCid classid;

          if (cdh_ObjidIsNull(mv.Action[idx].Object[0].Objid)) {
            break;
          }

          pwr_tAttrRef arefv[2];
          arefv[0] = mv.Action[idx].Object[0];
          memset(&arefv[1], 0, sizeof(arefv[0]));

          lsts = gdh_GetAttrRefTid(&arefv[0], &classid);
          if (EVEN(lsts)) {
            break;
          }

          if (classid == pwr_cClass_PlotGroup) {
            pwr_sClass_PlotGroup plot;
            pwr_tCid cid;

            lsts = gdh_GetObjectInfoAttrref(&(mv.Action[idx].Object[0]), &plot, sizeof(plot));
            if (EVEN(lsts)) {
              break;
            }

            for (int j = 0; j < 20; j++) {
              if (cdh_ObjidIsNull(plot.YObjectName[j].Objid)) {
                break;
              }

              sevhist_aref = plot.YObjectName[j];
              lsts = gdh_GetAttrRefTid(&sevhist_aref, &cid);
              if (EVEN(lsts)) {
                break;
              }

              if (cid == pwr_cClass_SevHist) {
                lsts = gdh_ArefANameToAref(
                    &sevhist_aref, "Attribute", &attr_aref);
                if (EVEN(lsts)) {
                  break;
                }

                lsts = gdh_GetObjectInfoAttrref(
                    &attr_aref, &attr_aref, sizeof(attr_aref));
                if (EVEN(lsts)) {
                  break;
                }

                lsts = gdh_AttrrefToName(
                    &attr_aref, aname, sizeof(aname), cdh_mNName);
                if (EVEN(lsts)) {
                  break;
                }

                s = strchr(aname, '.');
                if (!s) {
                  break;
                }

                *s = 0;
                strcpy(onamev[oid_cnt], aname);
                strcpy(anamev[oid_cnt], s + 1);
                oidv[oid_cnt] = attr_aref.Objid;
                sevhistobjectv[oid_cnt] = false;
                oid_cnt++;
              } else if (cid == pwr_cClass_SevHistObject) {
                lsts = gdh_ArefANameToAref(&sevhist_aref, "Object", &attr_aref);
                if (EVEN(lsts)) {
                  break;
                }

                lsts = gdh_GetObjectInfoAttrref(
                    &attr_aref, &attr_aref, sizeof(attr_aref));
                if (EVEN(lsts)) {
                  break;
                }

                lsts = gdh_AttrrefToName(
                    &attr_aref, aname, sizeof(aname), cdh_mNName);
                if (EVEN(lsts)) {
                  break;
                }

                s = strchr(aname, '.');
                if (!s) {
                  // It is a complete object
                  anamev[oid_cnt][0] = '\0';
                } else {
                  strcpy(anamev[oid_cnt], s + 1);
                  *s = 0;
                }
                strcpy(onamev[oid_cnt], aname);
                oidv[oid_cnt] = attr_aref.Objid;
                sevhistobjectv[oid_cnt] = true;
                oid_cnt++;
              }
            }
          } else if (classid == pwr_cClass_SevHistObject) {
            lsts = gdh_ArefANameToAref(
                &mv.Action[idx].Object[0], "Object", &attr_aref);
            if (EVEN(lsts)) {
              break;
            }

            lsts = gdh_GetObjectInfoAttrref(
                &attr_aref, &attr_aref, sizeof(attr_aref));
            if (EVEN(lsts)) {
              break;
            }

            lsts = gdh_AttrrefToName(
                &attr_aref, aname, sizeof(aname), cdh_mNName);
            if (EVEN(lsts)) {
              break;
            }

            s = strchr(aname, '.');
            if (!s) {
              // It is a complete object
              anamev[oid_cnt][0] = '\0';
            } else {
              strcpy(anamev[oid_cnt], s + 1);
            }
            oidv[oid_cnt] = attr_aref.Objid;
            sevhistobjectv[oid_cnt] = true;
            strcpy(onamev[oid_cnt], "");
            sevhist_aref = mv.Action[idx].Object[0];
            oid_cnt = 1;
          } else if (classid == pwr_cClass_SevHist) {
            lsts = gdh_ArefANameToAref(
                &mv.Action[idx].Object[0], "Attribute", &attr_aref);
            if (EVEN(lsts)) {
              break;
            }

            lsts = gdh_GetObjectInfoAttrref(
                &attr_aref, &attr_aref, sizeof(attr_aref));
            if (EVEN(lsts)) {
              break;
            }

            lsts = gdh_AttrrefToName(
                &attr_aref, aname, sizeof(aname), cdh_mNName);
            if (EVEN(lsts)) {
              break;
            }

            s = strchr(aname, '.');
            if (!s) {
              break;
            }
            *s = 0;

            strcpy(onamev[0], aname);
            strcpy(anamev[0], s + 1);
            oidv[0] = attr_aref.Objid;
            sevhistobjectv[0] = false;
            oid_cnt = 1;
            sevhist_aref = mv.Action[idx].Object[0];
          } else {
            break;
          }

          oidv[oid_cnt] = pwr_cNOid;

          // Get server and connect to server
          lsts = gdh_ArefANameToAref(&sevhist_aref, "ThreadObject", &attr_aref);
          if (EVEN(lsts)) {
            break;
          }

          lsts = gdh_GetObjectInfoAttrref(
              &attr_aref, &histthread_oid, sizeof(histthread_oid));
          if (EVEN(lsts)) {
            break;
          }

          pwr_tAttrRef histthread_aref = cdh_ObjidToAref(histthread_oid);
          lsts
              = gdh_ArefANameToAref(&histthread_aref, "ServerNode", &attr_aref);
          if (EVEN(lsts)) {
            break;
          }

          lsts = gdh_GetObjectInfoAttrref(
              &attr_aref, server_node, sizeof(server_node));
          if (EVEN(lsts)) {
            break;
          }

          if (!xnav->scctx) {
            sevcli_init(&lsts, &xnav->scctx);
            if (EVEN(lsts)) {
              break;
            }
          }
          sevcli_set_servernode(&lsts, xnav->scctx, server_node);
          if (EVEN(lsts)) {
            break;
          }

          QWidget* widget;
          XttSevHistQt* sevhist = new XttSevHistQt(this, (char*)"No title",
              &widget, oidv, anamev, onamev, sevhistobjectv, xnav->scctx, w, h,
              (unsigned int)curve_mOptions_Embedded, color_theme, time_ePeriod_,
              0, sts);
          if (EVEN(*sts)) {
            QString s = "Unable to load history data\n";
            char str1[200];
            msg_GetMsg(*sts, str1, sizeof(str1));
            s += str1;
            comp_widget[idx] = new QLabel(s);
            break;
          }
          setDataAndTag(idx, type, sevhist);

          sevhist->help_cb = multiview_trend_help_cb;
          sevhist->get_select_cb
              = multiview_sevhist_get_select_cb;

          comp_widget[idx] = widget;

          break;
        }
        case pwr_eMultiViewContentEnum_Camera: {
          pwr_sClass_XttCamera xttcamera;
          pwr_tCid cid;

          pwr_tObjid objid = mv.Action[idx].Object[0].Objid;
          if (cdh_ObjidIsNull(objid)) {
            break;
          }

          lsts = gdh_GetObjectClass(objid, &cid);
          if (EVEN(lsts)) {
            break;
          }

          if (cid != pwr_cClass_XttCamera) {
            break;
          }

          pwr_tAttrRef aref = cdh_ObjidToAref(objid);

          lsts = gdh_GetObjectInfoAttrref(
              &aref, (pwr_tAddress)&xttcamera, sizeof(xttcamera));
          if (EVEN(lsts)) {
            break;
          }

          unsigned int options = 0;
          if (xttcamera.Options & pwr_mCameraOptionsMask_FullScreen) {
            options |= strm_mOptions_FullScreen;
          }
          if (xttcamera.Options & pwr_mCameraOptionsMask_Maximize) {
            options |= strm_mOptions_Maximize;
          }
          if (xttcamera.Options & pwr_mCameraOptionsMask_FullMaximize) {
            options |= strm_mOptions_FullMaximize;
          }
          if (xttcamera.Options & pwr_mCameraOptionsMask_Iconify) {
            options |= strm_mOptions_Iconify;
          }
          if (xttcamera.Options & pwr_mCameraOptionsMask_CameraControlPanel) {
            options |= strm_mOptions_CameraControlPanel;
          }
          if (xttcamera.Options
              & pwr_mCameraOptionsMask_HttpBasicAuthentication) {
            options |= strm_mOptions_HttpBasicAuthentication;
          }
          if (xttcamera.Options
              & pwr_mCameraOptionsMask_CgiParameterAuthentication) {
            options |= strm_mOptions_CgiParameterAuthentication;
          }

          XttStreamQt* stream = new XttStreamQt(this, "No title", xttcamera.URL,
              mv.Action[idx].Width, mv.Action[idx].Height, 0, 0, 0, options, 1,
              &aref, sts);
          setDataAndTag(idx, type, stream);

          stream->close_cb = multiview_strm_close_cb;

          comp_widget[idx]
              = (QWidget*)stream->get_widget();

          appl.insert(applist_eType_Stream, views[idx].data, objid,
              xttcamera.Title, xttcamera.URL);

          break;
        }
        default:;
        }

        if (mv.Action[idx].Options
            & pwr_mMultiViewElemOptionsMask_Exchangeable) {
          exchange_widget[idx]
              = layout_to_widget(exchange_widget_layout[idx]);
          if (comp_widget[idx]) {
            add_expanding(exchange_widget_layout[idx],
                comp_widget[idx]);
          }
          switch (mv.Layout) {
          case pwr_eMultiViewLayoutEnum_Box:
            row_widget_box->addWidget(exchange_widget[idx]);
            break;
          case pwr_eMultiViewLayoutEnum_Fix:
            comp_widget[idx]->setMinimumSize(
                mv.Action[idx].Width, mv.Action[idx].Height);
            fixed_put(toplevel, exchange_widget[idx],
                mv.Action[idx].X, mv.Action[idx].Y);
            exchange_widget[idx]->show();
            break;
          case pwr_eMultiViewLayoutEnum_Pane:
            row_widget_pane->addWidget(exchange_widget[idx]);
            break;
          case pwr_eMultiViewLayoutEnum_Table:
            col_widget_table->addWidget(
                exchange_widget[idx], j, i);
            break;
          default:;
          }
        } else {
          if (comp_widget[idx]) {
            switch (mv.Layout) {
            case pwr_eMultiViewLayoutEnum_Box:
              row_widget_box->addWidget(comp_widget[idx]);
              break;
            case pwr_eMultiViewLayoutEnum_Fix:
              comp_widget[idx]->setMinimumSize(
                  mv.Action[idx].Width,
                  mv.Action[idx].Height);
              fixed_put(toplevel, comp_widget[idx],
                  mv.Action[idx].X, mv.Action[idx].Y);
              comp_widget[idx]->show();
              break;
            case pwr_eMultiViewLayoutEnum_Pane:
              row_widget_pane->addWidget(comp_widget[idx]);
              break;
            case pwr_eMultiViewLayoutEnum_Table:
              col_widget_table->addWidget(
                  comp_widget[idx], j, i);
            default:;
            }
          }
        }
        if (mv.Layout == pwr_eMultiViewLayoutEnum_Box
            && ((j + 1) % rows != 0
                   && mv.Options & pwr_mMultiViewOptionsMask_RowSeparators)) {
          row_widget_box->addWidget(separator(QFrame::HLine));
        }
      }

      if (mv.Layout == pwr_eMultiViewLayoutEnum_Box) {
        col_widget_box->addLayout(row_widget_box);
      } else if (mv.Layout == pwr_eMultiViewLayoutEnum_Pane) {
        col_widget_pane->addWidget(row_widget_pane);
      }

      if (mv.Layout == pwr_eMultiViewLayoutEnum_Box
          && (i != cols - 1
                 && mv.Options & pwr_mMultiViewOptionsMask_ColumnSeparators)) {
        col_widget_box->addWidget(separator(QFrame::VLine));
      }
    }

    switch (mv.Layout) {
    case pwr_eMultiViewLayoutEnum_Box:
      toplevel->setLayout(col_widget_box);
      break;
    case pwr_eMultiViewLayoutEnum_Pane: {
      QVBoxLayout *layout = new QVBoxLayout();
      layout->addWidget(col_widget_pane);
      toplevel->setLayout(layout);
      break;
    }
    case pwr_eMultiViewLayoutEnum_Table:
      toplevel->setLayout(col_widget_table);
      break;
    default:
      break;
    }
  }

  if (!(options & ge_mOptions_Embedded)) {
    toplevel->show();

    if (!(mv_x == 0 && mv_y == 0)) {
      // Set position
      toplevel->move(mv_x, mv_y);
    } else if (!(mv.X == 0 && mv.Y == 0)) {
      // Set position from object
      toplevel->move(mv.X, mv.Y);
    }

    for (int i = 0; i < views.size(); i++) {
      if (views[i].tag == pwr_eMultiViewContentEnum_TrendCurve) {
        ((XttTrendQt*) views[i].data)->setup();
      }
      if (views[i].tag == pwr_eMultiViewContentEnum_SevHistory) {
        ((XttSevHistQt*) views[i].data)->setup();
      }
    }

    if (options & ge_mOptions_FullScreen
        || mv.Options & pwr_mMultiViewOptionsMask_FullScreen) {
      toplevel->showFullScreen();
    } else if (options & ge_mOptions_Maximize
        || mv.Options & pwr_mMultiViewOptionsMask_Maximize) {
      toplevel->showMaximized();
    } else if (options & ge_mOptions_FullMaximize
        || mv.Options & pwr_mMultiViewOptionsMask_FullMaximize) {
      toplevel->showMaximized();
    } else if (options & ge_mOptions_Iconify
        || mv.Options & pwr_mMultiViewOptionsMask_Iconify) {
      toplevel->showMinimized();
    } else if (options & ge_mOptions_Invisible) {
      toplevel->setVisible(false);
    }
  }

  *sts = XNAV__SUCCESS;
}

void* XttMultiViewQt::get_widget()
{
  return toplevel;
}

void XttMultiViewQt::setDataAndTag(int idx, int tag, void* data)
{
  views[idx].tag = tag;
  views[idx].data = data;
}

// TODO: Why is this code different from the one in the constructor?
// It would be easier to maintain if they were merged.
int XttMultiViewQt::set_subwindow_source(const char* name, char* source,
    char* object, double* borders, int insert, int cont)
{
  pwr_sClass_XttMultiView mv;
  char comp_name[80];
  char* sub_name;

  pwr_tStatus sts = gdh_GetObjectInfoAttrref(&aref, &mv, sizeof(mv));
  if (EVEN(sts)) {
    return sts;
  }

  strncpy(comp_name, name, sizeof(comp_name));
  if ((sub_name = strchr(comp_name, '.'))) {
    *sub_name = 0;
    sub_name++;
  } else {
    sub_name = 0;
  }

  for (int i = 0; i < cols; i++) {
    for (int j = 0; j < rows; j++) {
      int idx = i * rows + j;
      if (str_NoCaseStrcmp(comp_name, mv.Action[idx].Name) == 0) {
        if (!sub_name) {
          // Replace component
          int w = mv.Action[idx].Width;
          int h = mv.Action[idx].Height;
          bool scrollbar = (mv.Action[idx].Options
                          & pwr_mMultiViewElemOptionsMask_Scrollbars);
          bool menu = (mv.Action[idx].Options
                     & pwr_mMultiViewElemOptionsMask_Menu);
          int type = mv.Action[idx].Type;

          if (!(mv.Action[idx].Options
                  & pwr_mMultiViewElemOptionsMask_Exchangeable)) {
            return 0;
          }

          switch (type) { // TODO: Add support for AlarmList, EventList and FastCurve
          case pwr_eMultiViewContentEnum_Graph:
          case pwr_eMultiViewContentEnum_ObjectGraph: {
            XttGeQt* ge = new XttGeQt(this, "No title", source, scrollbar, menu,
                0, w, h, 0, 0, 1.0, object, 0, 0, ge_mOptions_Embedded, 0,
                borders, color_theme, multiview_ge_command_cb,
                multiview_ge_get_current_objects_cb,
                multiview_ge_is_authorized_cb, multiview_keyboard_cb);

            appl.remove(views[idx].data);
            setDataAndTag(idx, type, ge);

            ge->close_cb = multiview_ge_close_cb;
            ge->help_cb = multiview_ge_help_cb;
            ge->display_in_xnav_cb = multiview_ge_display_in_xnav_cb;
            ge->popup_menu_cb = multiview_ge_popup_menu_cb;
            ge->call_method_cb = multiview_ge_call_method_cb;
            ge->sound_cb = multiview_ge_sound_cb;
            ge->eventlog_cb = multiview_ge_eventlog_cb;

            exchange_widget_layout[idx]->removeWidget(comp_widget[idx]);
            comp_widget[idx] = ge->get_graph_widget();
            exchange_widget_layout[idx]->insertWidget(0, comp_widget[idx]);
            exchange_widget[idx]->show();

            if (insert) {
              recall_buffer[idx].insert(source, object);
            }
            appl.insert(applist_eType_Graph, views[idx].data,
                pwr_cNObjid, source, object);
            break;
          }
          case pwr_eMultiViewContentEnum_MultiView: {
            pwr_tAttrRef source_aref;

            sts = gdh_NameToAttrref(pwr_cNObjid, source, &source_aref);
            if (EVEN(sts)) {
              break;
            }

            XttMultiViewQt* mv = new XttMultiViewQt(this, "No title",
                &source_aref, w, h, 0, 0, ge_mOptions_Embedded, 0, color_theme,
                &sts, multiview_ge_command_cb,
                multiview_ge_get_current_objects_cb,
                multiview_ge_is_authorized_cb, multiview_keyboard_cb);

            appl.remove(views[idx].data);
            setDataAndTag(idx, type, mv);

            mv->close_cb = multiview_ge_close_cb;
            mv->help_cb = multiview_ge_help_cb;
            mv->display_in_xnav_cb = multiview_ge_display_in_xnav_cb;
            mv->popup_menu_cb = multiview_ge_popup_menu_cb;
            mv->call_method_cb = multiview_ge_call_method_cb;
            mv->sound_cb = multiview_ge_sound_cb;
            mv->eventlog_cb = multiview_ge_eventlog_cb;

            exchange_widget_layout[idx]->removeWidget(comp_widget[idx]);
            comp_widget[idx] = (QWidget*)mv->get_widget();
            exchange_widget_layout[idx]->insertWidget(0, comp_widget[idx]);
            exchange_widget[idx]->show();

            if (insert) {
              recall_buffer[idx].insert(source, object);
            }
            appl.insert(applist_eType_MultiView, views[idx].data,
                &source_aref, "", NULL);
            break;
          }
          case pwr_eMultiViewContentEnum_TrendCurve: {
            pwr_tCid classid;
            QWidget* comp_w;
            pwr_tAttrRef arefv[2];
            pwr_tStatus lsts;
            pwr_tAttrRef object_aref;

            lsts = gdh_NameToAttrref(pwr_cNObjid, object, &object_aref);
            if (EVEN(lsts)) {
              break;
            }

            lsts = gdh_GetAttrRefTid(&object_aref, &classid);
            if (EVEN(lsts)) {
              break;
            }

            XttTrendQt* trend;
            if (classid == pwr_cClass_PlotGroup) {
              arefv[0] = object_aref;
              trend = new XttTrendQt(this, (char*)"No title", &comp_w, 0,
                  &(arefv[0]), w, h, (unsigned int)curve_mOptions_Embedded,
                  color_theme, 0, &lsts);
            } else if (classid == pwr_cClass_DsTrend || classid == pwr_cClass_DsTrendCurve) {
              arefv[0] = object_aref;
              memset(&arefv[1], 0, sizeof(arefv[0]));
              trend = new XttTrendQt(this, (char*)"No title", &comp_w, arefv, 0,
                  w, h, (unsigned int)curve_mOptions_Embedded, color_theme, 0,
                  &lsts);
            } else {
              break;
            }
            if (EVEN(lsts)) {
              break;
            }

            appl.remove(views[idx].data);
            setDataAndTag(idx, type, trend);

            trend->close_cb = multiview_trend_close_cb;
            trend->command_cb = multiview_trend_command_cb;
            trend->help_cb = multiview_trend_help_cb;

            exchange_widget_layout[idx]->removeWidget(comp_widget[idx]);
            comp_widget[idx] = comp_w;
            exchange_widget_layout[idx]->insertWidget(0, comp_widget[idx]);
            exchange_widget[idx]->show();
            trend->setup();

            if (insert) {
              recall_buffer[idx].insert(source, object);
            }
            appl.insert(applist_eType_Trend, views[idx].data,
                &arefv[0], "", NULL);

            mv.Action[idx].Object[0] = object_aref;
            break;
          }
          case pwr_eMultiViewContentEnum_SevHistory: {
            pwr_tOid oidv[11];
            pwr_tOName anamev[11];
            pwr_tOName onamev[11];
            bool sevhistobjectv[11];
            pwr_tAttrRef attr_aref, sevhist_aref;
            char* s;
            pwr_tAName aname;
            int oid_cnt = 0;
            pwr_tCid classid;
            pwr_tStatus lsts;
            pwr_tAttrRef arefv[2];
            pwr_tAttrRef object_aref;

            lsts = gdh_NameToAttrref(pwr_cNObjid, object, &object_aref);
            if (EVEN(lsts)) {
              break;
            }

            arefv[0] = object_aref;
            memset(&arefv[1], 0, sizeof(arefv[0]));

            lsts = gdh_GetAttrRefTid(&arefv[0], &classid);
            if (EVEN(lsts)) {
              break;
            }

            if (classid == pwr_cClass_PlotGroup) {
              pwr_sClass_PlotGroup plot;
              pwr_tCid cid;

              lsts = gdh_GetObjectInfoAttrref(&object_aref, &plot, sizeof(plot));
              if (EVEN(lsts)) {
                break;
              }

              for (int j = 0; j < 20; j++) {
                if (cdh_ObjidIsNull(plot.YObjectName[j].Objid)) {
                  break;
                }

                sevhist_aref = plot.YObjectName[j];
                lsts = gdh_GetAttrRefTid(&sevhist_aref, &cid);
                if (EVEN(lsts)) {
                  break;
                }

                if (cid == pwr_cClass_SevHist) {
                  lsts = gdh_ArefANameToAref(
                      &sevhist_aref, "Attribute", &attr_aref);
                  if (EVEN(lsts)) {
                    break;
                  }

                  lsts = gdh_GetObjectInfoAttrref(
                      &attr_aref, &attr_aref, sizeof(attr_aref));
                  if (EVEN(lsts)) {
                    break;
                  }

                  lsts = gdh_AttrrefToName(
                      &attr_aref, aname, sizeof(aname), cdh_mNName);
                  if (EVEN(lsts)) {
                    break;
                  }

                  s = strchr(aname, '.');
                  if (!s) {
                    break;
                  }

                  *s = 0;
                  strcpy(onamev[oid_cnt], aname);
                  strcpy(anamev[oid_cnt], s + 1);
                  oidv[oid_cnt] = attr_aref.Objid;
                  sevhistobjectv[oid_cnt] = false;
                  oid_cnt++;
                } else if (cid == pwr_cClass_SevHistObject) {
                  lsts = gdh_ArefANameToAref(
                      &sevhist_aref, "Object", &attr_aref);
                  if (EVEN(lsts)) {
                    break;
                  }

                  lsts = gdh_GetObjectInfoAttrref(
                      &attr_aref, &attr_aref, sizeof(attr_aref));
                  if (EVEN(lsts)) {
                    break;
                  }

                  lsts = gdh_AttrrefToName(
                      &attr_aref, aname, sizeof(aname), cdh_mNName);
                  if (EVEN(lsts)) {
                    break;
                  }

                  s = strchr(aname, '.');
                  if (!s) {
                    // It is a complete object
                    anamev[oid_cnt][0] = '\0';
                  } else {
                    strcpy(anamev[oid_cnt], s + 1);
                    *s = 0;
                  }
                  strcpy(onamev[oid_cnt], aname);
                  oidv[oid_cnt] = attr_aref.Objid;
                  sevhistobjectv[oid_cnt] = true;
                  oid_cnt++;
                }
              }
            } else if (classid == pwr_cClass_SevHistObject) {
              lsts = gdh_ArefANameToAref(&object_aref, "Object", &attr_aref);
              if (EVEN(lsts)) {
                break;
              }

              lsts = gdh_GetObjectInfoAttrref(
                  &attr_aref, &attr_aref, sizeof(attr_aref));
              if (EVEN(lsts)) {
                break;
              }

              lsts = gdh_AttrrefToName(
                  &attr_aref, aname, sizeof(aname), cdh_mNName);
              if (EVEN(lsts)) {
                break;
              }

              s = strchr(aname, '.');
              if (!s) {
                // It is a complete object
                anamev[oid_cnt][0] = '\0';
              } else {
                strcpy(anamev[oid_cnt], s + 1);
              }
              oidv[oid_cnt] = attr_aref.Objid;
              sevhistobjectv[oid_cnt] = true;
              strcpy(onamev[oid_cnt], "");
              sevhist_aref = object_aref;
              oid_cnt = 1;
            } else if (classid == pwr_cClass_SevHist) {
              lsts = gdh_ArefANameToAref(&object_aref, "Attribute", &attr_aref);
              if (EVEN(lsts)) {
                break;
              }

              lsts = gdh_GetObjectInfoAttrref(
                  &attr_aref, &attr_aref, sizeof(attr_aref));
              if (EVEN(lsts)) {
                break;
              }

              lsts = gdh_AttrrefToName(
                  &attr_aref, aname, sizeof(aname), cdh_mNName);
              if (EVEN(lsts)) {
                break;
              }

              s = strchr(aname, '.');
              if (!s) {
                break;
              }
              *s = 0;

              strcpy(onamev[0], aname);
              strcpy(anamev[0], s + 1);
              oidv[0] = attr_aref.Objid;
              sevhistobjectv[0] = false;
              oid_cnt = 1;
              sevhist_aref = object_aref;
            } else {
              break;
            }

            oidv[oid_cnt] = pwr_cNOid;

            XNav* xnav = get_xnav();

            if (!xnav->scctx) {
              break;
            }

            QWidget* comp_w;
            XttSevHistQt* sevhist = new XttSevHistQt(this, (char*)"No title",
                &comp_w, oidv, anamev, onamev, sevhistobjectv, xnav->scctx, w,
                h, (unsigned int)curve_mOptions_Embedded, color_theme,
                time_ePeriod_, 0, &lsts);
            if (EVEN(lsts)) {
              break;
            }

            appl.remove(views[idx].data);
            setDataAndTag(idx, type, sevhist);

            sevhist->help_cb = multiview_trend_help_cb;
            sevhist->get_select_cb = multiview_sevhist_get_select_cb;

            exchange_widget_layout[idx]->removeWidget(comp_widget[idx]);
            comp_widget[idx] = comp_w;
            exchange_widget_layout[idx]->insertWidget(0, comp_widget[idx]);
            exchange_widget[idx]->show();
            sevhist->setup();

            mv.Action[idx].Object[0] = object_aref;
          }
          case pwr_eMultiViewContentEnum_Camera: {
            pwr_sClass_XttCamera xttcamera;
            pwr_tStatus lsts;
            pwr_tAttrRef object_aref;

            lsts = gdh_NameToAttrref(pwr_cNObjid, object, &object_aref);
            if (EVEN(lsts)) {
              break;
            }

            lsts = gdh_GetObjectInfoAttrref(
                &object_aref, (pwr_tAddress)&xttcamera, sizeof(xttcamera));
            if (EVEN(lsts)) {
              break;
            }


            XttStreamQt* stream = new XttStreamQt(this, "No title",
                xttcamera.URL, w, h, 0, 0, 0, xttcamera.Options, 1,
                &object_aref, &lsts);

            appl.remove(views[idx].data);
            setDataAndTag(idx, type, stream);

            exchange_widget_layout[idx]->removeWidget(comp_widget[idx]);
            comp_widget[idx] = (QWidget*)stream->get_widget();
            exchange_widget_layout[idx]->insertWidget(0, comp_widget[idx]);
            exchange_widget[idx]->show();

            if (insert) {
              recall_buffer[idx].insert(source, object);
            }

            appl.insert(applist_eType_Stream, views[idx].data,
                object_aref.Objid, xttcamera.Title, xttcamera.URL);
            break;
          }
          default:;
          }
        } else {
          // Call set_window in component
          if (views[idx].tag == pwr_eMultiViewContentEnum_Graph ||
              views[idx].tag == pwr_eMultiViewContentEnum_ObjectGraph) {
            ((XttGeQt*) views[idx].data)->set_subwindow_source(
                sub_name, source, object);
          } else if (views[idx].tag == pwr_eMultiViewContentEnum_MultiView) {
            ((XttMultiViewQt*) views[idx].data)->set_subwindow_source(
                sub_name, source, object, borders, insert);
          }
        }
      }
    }
  }
  return cont ? 1 : GLOW__TERMINATED;
}

int XttMultiViewQt::key_pressed(int key)
{
  for (int i = 0; i < views.size(); i++) {
    if (views[i].tag == pwr_eMultiViewContentEnum_Graph ||
        views[i].tag == pwr_eMultiViewContentEnum_ObjectGraph) {
      int sts = ((XttGeQt*) views[i].data)->key_pressed(key);
      if (ODD(sts)) {
        return sts;
      }
    } else if (views[i].tag == pwr_eMultiViewContentEnum_MultiView) {
      int sts = ((XttMultiViewQt*) views[i].data)->key_pressed(key);
      if (ODD(sts)) {
        return sts;
      }
    }
  }
  return 0;
}

void XttMultiViewQt::close_input_all()
{
  for (int i = 0; i < views.size(); i++) {
    if (views[i].tag == pwr_eMultiViewContentEnum_Graph ||
        views[i].tag == pwr_eMultiViewContentEnum_ObjectGraph) {
      ((XttGeQt*) views[i].data)->close_input_all();
    } else if (views[i].tag == pwr_eMultiViewContentEnum_MultiView) {
      ((XttMultiViewQt*) views[i].data)->close_input_all();
    }
  }
}

void XttMultiViewQt::signal_send(char* signalname)
{
  pwr_sClass_XttMultiView mv;
  pwr_tStatus sts = gdh_GetObjectInfoAttrref(&aref, &mv, sizeof(mv));
  if (EVEN(sts)) {
    return;
  }

  for (int i = 0; i < views.size(); i++) {
    // Call signal_send in component
    if (views[i].tag == pwr_eMultiViewContentEnum_Graph ||
        views[i].tag == pwr_eMultiViewContentEnum_ObjectGraph) {
      ((XttGeQt*) views[i].data)->signal_send(signalname);
    } else if (views[i].tag == pwr_eMultiViewContentEnum_MultiView) {
      ((XttMultiViewQt*) views[i].data)->signal_send(signalname);
    }
  }
}
