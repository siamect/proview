/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* co_statusmon_nodelist.cpp -- Status Monitor */

#include <stdlib.h>

#include "co_cdh.h"
#include "co_string.h"
#include "co_syi.h"
#include "co_time.h"

#include "rt_gdh.h"
#include "rt_xnav_msg.h"

#include "cow_statusmon_nodelist.h"
#include "cow_wow.h"
#include "cow_xhelp.h"

Nodelist::Nodelist(void* nodelist_parent_ctx, const char* nodelist_name,
    int nodelist_mode, int nodelist_view_node_descr, pwr_tStatus* status)
    : parent_ctx(nodelist_parent_ctx), nodelistnav(NULL), nodelist_displayed(0),
      help_cb(0), close_cb(0), mode(nodelist_mode),
      view_node_descr(nodelist_view_node_descr)
{
  strcpy(remote_gui, "");
  *status = 1;
}

//
//  Delete nodelist
//
Nodelist::~Nodelist()
{
}

void Nodelist::activate_help()
{
  CoXHelp::dhelp("opg_statusmonitor", 0, navh_eHelpFile_Other,
      "$pwr_lang/man_opg.dat", true);
}

void Nodelist::find_node_cb(void* ctx, pwr_tOid oid)
{
  Nodelist* nodelist = (Nodelist*)ctx;

  if (nodelist->nodelistnav->select_node(oid.oix))
    nodelist->pop();
}

void Nodelist::add_node_ok(
    Nodelist* nodelist, char* node_name, char* description, char* opplace)
{
  nodelist->nodelistnav->add_node(node_name, description, opplace);
}

void Nodelist::activate_add_node()
{
  open_add_input_dialog(
      "Node name", "Description", "Operatorplace", "Add Node", "", add_node_ok);
}

void Nodelist::mod_node_ok(
    Nodelist* nodelist, char* node_name, char* description, char* opplace)
{
  nodelist->nodelistnav->set_node_data(node_name, opplace, description);
}

void Nodelist::activate_modify_node()
{
  static char node_name[80];
  char title[100];
  int sts;
  pwr_tOName opplace;
  char descr[80];

  sts = nodelistnav->get_selected_node(node_name);
  if (EVEN(sts)) {
    nodelistnav->wow->DisplayError("Remove Node", "Select a node");
    return;
  }

  sts = nodelistnav->get_selected_opplace(opplace, descr);
  if (EVEN(sts))
    return;

  sprintf(title, "Modify node %s", node_name);

  open_mod_input_dialog("Node", "Description", "Operatorplace", title,
      node_name, descr, opplace, mod_node_ok);
}

void remove_node_ok(void* ctx, void* data)
{
  Nodelist* nodelist = (Nodelist*)ctx;

  nodelist->nodelistnav->remove_node((char*)data);
}

void Nodelist::activate_remove_node()
{
  static char node_name[80];
  int sts = nodelistnav->get_selected_node(node_name);
  if (EVEN(sts)) {
    nodelistnav->wow->DisplayError("Remove Node", "Select a node");
    return;
  }
  char msg[27 + sizeof(node_name) + 1];
  sprintf(msg, "Do you want to remove node %s", node_name);

  nodelistnav->wow->DisplayQuestion(
      this, "Remove Node", msg, remove_node_ok, NULL, node_name);
}

static void get_display(char* disp)
{
  char display[80] = "";
  char name[80];
  pwr_tStatus sts;

  char* val = getenv("DISPLAY");
  if (val)
    strcpy(display, val);

  if (streq(display, "")) {
    syi_NodeName(&sts, name, sizeof(name));
    strcpy(display, name);
    strcat(display, ":0");
  } else if (display[0] == ':') {
    char tmp[80];

    syi_NodeName(&sts, name, sizeof(name));
    strcpy(tmp, display);
    strcpy(display, name);
    strcat(display, tmp);
  } else if (display[0] == '0' && display[1] == ':') {
    char tmp[80];

    syi_NodeName(&sts, name, sizeof(name));
    strcpy(tmp, display);
    strcpy(display, name);
    strcat(display, &tmp[1]);
  }
  strcpy(disp, display);
}

void Nodelist::activate_open_xtt()
{
  char node_name[80];
  int sts;
  char display[80];

  sts = nodelistnav->get_selected_node(node_name);
  if (EVEN(sts)) {
    nodelistnav->wow->DisplayError("Open Xtt", "Select a node");
    return;
  }

  get_display(display);
  statussrv_XttStart(node_name, "", "", display, remote_gui);
}

void Nodelist::activate_open_opplace()
{
  int sts;
  char node_name[80];
  pwr_tOName opplace;
  char display[80];

  sts = nodelistnav->get_selected_node(node_name);
  if (EVEN(sts)) {
    nodelistnav->wow->DisplayError("Open Xtt", "Select a node");
    return;
  }
  sts = nodelistnav->get_selected_opplace(opplace, 0);

  get_display(display);
  statussrv_XttStart(node_name, opplace, "", display, remote_gui);
}

void Nodelist::activate_open_rtmon()
{
  char node_name[80];
  int sts;
  char display[80];

  sts = nodelistnav->get_selected_node(node_name);
  if (EVEN(sts)) {
    nodelistnav->wow->DisplayError("Open Xtt", "Select a node");
    return;
  }

  get_display(display);
  statussrv_RtMonStart(node_name, "", display, remote_gui);
}

void Nodelist::activate_save()
{
  nodelistnav->save();
}
