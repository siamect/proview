/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* cow_wow.cpp -- useful windows */

#include "co_dcli.h"
#include "co_string.h"

#include "cow_wow.h"

bool CoWow::m_autoremove = false;
bool CoWow::m_printdialog_disable = false;
char CoWow::m_default_printer[80] = "";
void* CoWow::m_transient_wid = 0;

CoWowTimer::CoWowTimer()
{
}

CoWowTimer::~CoWowTimer()
{
}

void CoWowTimer::add(int time, void (*callback)(void* data), void* data)
{
}

void CoWowTimer::remove()
{
}

CoWowRecall::CoWowRecall() : m_current_recall_line(0), m_current_size(0), m_tmp_size(0)
{
  memset(m_recall, 0, sizeof(m_recall));
}

void CoWowRecall::push(const char* src)
{
  if (!streq(src, m_recall[0])) {
    if (m_current_size == 0 || !streq(m_recall[0], "")) {
      for (int i = m_recall_size - 2; i >= 0; i--) {
        strcpy(m_recall[i + 1], m_recall[i]);
      }
      m_current_size++;
      if (m_current_size > m_recall_size) {
        m_current_size = m_recall_size;
      }
    }
    strncpy(m_recall[0], src, m_line_size);
    m_recall[0][m_line_size - 1] = 0;
  }
  resetTmp();
}

void CoWowRecall::resetTmp()
{
  for (int i = 0; i < m_recall_size; i++) {
    strcpy(tmp[i], m_recall[i]);
  }
  m_current_recall_line = 0;
  m_tmp_size = m_current_size;
}

const char* CoWowRecall::popUp(const char* src)
{
  if (m_current_recall_line == 0 && !streq(src, tmp[0])) {
    if (m_tmp_size == 0 || !streq(tmp[0], "")) {
      for (int i = m_recall_size - 2; i >= 0; i--) {
        strcpy(tmp[i + 1], tmp[i]);
      }
      m_tmp_size++;
      if (m_tmp_size > m_recall_size) {
        m_tmp_size = m_recall_size;
      }
    }
    strncpy(tmp[0], src, m_line_size);
    tmp[0][m_line_size - 1] = 0;
  } else {
    strncpy(tmp[m_current_recall_line], src, m_line_size);
  }
  m_current_recall_line++;
  if (m_current_recall_line > m_tmp_size - 1) {
    m_current_recall_line = m_tmp_size - 1;
  }
  return tmp[m_current_recall_line];
}

const char* CoWowRecall::popDown(const char* src)
{
  strncpy(tmp[m_current_recall_line], src, m_line_size);
  if (m_current_recall_line <= 0) {
    return tmp[m_current_recall_line];
  }
  m_current_recall_line--;
  return tmp[m_current_recall_line];
}

CoWow::CoWow()
{
}

CoWow::~CoWow()
{
}

void CoWow::DisplayQuestion(void* ctx, const char* title, const char* text,
    void (*questionbox_ok)(void*, void*),
    void (*questionbox_cancel)(void*, void*), void* data)
{
}

void CoWow::DisplayError(const char* title, const char* text,
    lng_eCoding coding, int modal)
{
}

void CoWow::DisplayText(
    const char* title, const char* text, int width, int height)
{
}

void CoWow::CreateInputDialog(void* ctx, const char* title,
    const char* text, void (*inputdialogbox_ok)(void*, void*, char*),
    void (*inputdialogbox_cancel)(void*, void*), int input_length,
    char* init_text, void* data)
{
}

void* CoWow::CreateList(const char* title, const char* texts,
    int textsize, void(action_cb)(void*, char*, int), void(cancel_cb)(void*),
    void* ctx, int show_apply_button)
{
  return NULL;
}

void CoWow::PopList(void* ctx)
{
}

void CoWow::DeleteList(void* ctx)
{
}

void CoWow::CreateFileSelDia(const char* title, void* parent_ctx,
    void (*file_selected_cb)(void*, char*, wow_eFileSelType),
    wow_eFileSelType file_type, wow_eFileSelAction action)
{
}

int CoWow::CreateModalDialog(const char* title, const char* text,
    const char* button1, const char* button2, const char* button3,
    const char* image)
{
  return wow_eModalDialogReturn_NYI;
}

wow_sModalInputDialog* CoWow::CreateModalInputDialog(const char* title,
    const char* text, const char* button1, const char* button2,
    const char* button3, const char* image, int input_length,
    CoWowRecall* recall)
{
  return 0;
}

void CoWow::Wait(float time)
{
}

int CoWow::HideWarranty()
{
  static int hide = 0;
  int prev = hide;

  hide = 1;
  return prev;
}

#define FILELIST_TEXTSIZE 80

void* CoWow::CreateFileList(const char* title, const char* dir,
    const char* pattern, const char* type, void(action_cb)(void*, char*, int),
    void(cancel_cb)(void*), void* ctx, int show_apply_button)
{
  int sts;
  pwr_tFileName found_file, stype, item;
  char file_spec[260];
  char* s;
  char* texts;
  int i, cnt;

  if (type) {
    if (type[0] != '.') {
      strcpy(stype, ".");
    }
    strncat(stype, type, sizeof(stype) - strlen(stype) - 1);
    sprintf(file_spec, "%s/%s%s", dir, pattern, stype);
  } else
    sprintf(file_spec, "%s/%s", dir, pattern);

  // Count number of items
  cnt = 0;
  sts = dcli_search_file(file_spec, found_file, DCLI_DIR_SEARCH_INIT);
  while (ODD(sts)) {
    cnt++;
    sts = dcli_search_file(file_spec, found_file, DCLI_DIR_SEARCH_NEXT);
  }
  dcli_search_file(file_spec, found_file, DCLI_DIR_SEARCH_END);

  texts = (char*)calloc(cnt + 1, FILELIST_TEXTSIZE);

  i = 0;
  sts = dcli_search_file(file_spec, found_file, DCLI_DIR_SEARCH_INIT);
  while (ODD(sts)) {
    if ((s = strrchr(found_file, '/')))
      strncpy(item, s + 1, sizeof(item));
    else
      strncpy(item, found_file, sizeof(item));

    if (type) {
      if ((s = strstr(item, stype)))
        *s = 0;
    }
    strncpy(&texts[FILELIST_TEXTSIZE * i], item, FILELIST_TEXTSIZE);
    sts = dcli_search_file(file_spec, found_file, DCLI_DIR_SEARCH_NEXT);
    i++;
  }
  dcli_search_file(file_spec, found_file, DCLI_DIR_SEARCH_END);

  return CreateList(title, texts, FILELIST_TEXTSIZE, action_cb, cancel_cb, ctx,
      show_apply_button);
}

int CoWow::DisplayWarranty()
{
  return 0;
}

void CoWow::DisplayLicense()
{
}

CoWowTimer* CoWow::timer_new()
{
  return 0;
}

pwr_tStatus CoWow::CreateMenuItem(
    const char* name, void* menu, int pixmap, int append, void* w)
{
  return 0;
}

pwr_tStatus CoWow::DeleteMenuItem(const char* name, void* menu)
{
  return 0;
}

void CoWow::CreateBrowPrintDialog(const char* title, void* brow_ctx,
    int orientation, double scale, void* parent_widget, pwr_tStatus* sts)
{
  *sts = WOW__NYI;
}

void CoWow::CreateFlowPrintDialog(const char* title, void* flow_ctx,
    int orientation, double scale, void* parent_widget, pwr_tStatus* sts)
{
  *sts = WOW__NYI;
}

void CoWow::SetDefaultPrinter(const char* printer)
{
  strncpy(m_default_printer, printer, sizeof(m_default_printer));
}

void CoWow::DisablePrintDialog()
{
  m_printdialog_disable = true;
}

bool CoWow::PrintDialogIsDisabled()
{
  return m_printdialog_disable;
}

void CoWow::SetAutoRemove(bool on)
{
  m_autoremove = on;
}

void CoWow::SetTransient(void* transient_wid)
{
  m_transient_wid = transient_wid;
}
