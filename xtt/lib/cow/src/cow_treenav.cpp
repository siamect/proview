/* 
 * Proview   Open Source Process Control.
 * Copyright (C) 2005-2017 SSAB EMEA AB.
 *
 * This file is part of Proview.
 *
 * This program is free software; you can redistribute it and/or 
 * modify it under the terms of the GNU General Public License as 
 * published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License 
 * along with Proview. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking Proview statically or dynamically with other modules is
 * making a combined work based on Proview. Thus, the terms and 
 * conditions of the GNU General Public License cover the whole 
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * Proview give you permission to, from the build function in the
 * Proview Configurator, combine Proview with modules generated by the
 * Proview PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every 
 * copy of the combined work is accompanied by a complete copy of 
 * the source code of Proview (the version used to produce the 
 * combined work), being distributed under the terms of the GNU 
 * General Public License plus this exception.
 **/

/* cow_treenav.cpp -- Tree viewer */

#include "glow_std.h"

#include <stdio.h>
#include <stdlib.h>
#include <vector>

#include "pwr.h"
#include "pwr_baseclasses.h"
#include "co_cdh.h"
#include "co_time.h"
#include "co_dcli.h"
#include "flow.h"
#include "flow_browctx.h"
#include "flow_browapi.h"
#include "flow_msg.h"
#include "cow_treenav.h"
#include "cow_tree.h"
#include "rt_gdh.h"

#include "xnav_bitmap_leaf8.h"
#include "xnav_bitmap_leaf10.h"
#include "xnav_bitmap_leaf12.h"
#include "xnav_bitmap_leaf14.h"
#include "xnav_bitmap_leaf16.h"
#include "xnav_bitmap_leaf18.h"
#include "xnav_bitmap_leaf20.h"
#include "xnav_bitmap_leaf24.h"
#include "xnav_bitmap_map8.h"
#include "xnav_bitmap_map10.h"
#include "xnav_bitmap_map12.h"
#include "xnav_bitmap_map14.h"
#include "xnav_bitmap_map16.h"
#include "xnav_bitmap_map18.h"
#include "xnav_bitmap_map20.h"
#include "xnav_bitmap_map24.h"
#include "xnav_bitmap_openmap8.h"
#include "xnav_bitmap_openmap10.h"
#include "xnav_bitmap_openmap12.h"
#include "xnav_bitmap_openmap14.h"
#include "xnav_bitmap_openmap16.h"
#include "xnav_bitmap_openmap18.h"
#include "xnav_bitmap_openmap20.h"
#include "xnav_bitmap_openmap24.h"

void TreeNav::message( char sev, const char *text)
{
  (message_cb)( parent_ctx, sev, text);
}

void TreeNav::print( char *filename)
{
  brow_Print( brow->ctx, filename);
}

//
//  Free pixmaps
//
void TreeNavBrow::free_pixmaps()
{
  brow_FreeAnnotPixmap( ctx, pixmap_leaf);
  brow_FreeAnnotPixmap( ctx, pixmap_map);
  brow_FreeAnnotPixmap( ctx, pixmap_openmap);
}

//
//  Create pixmaps for leaf, closed map and open map
//
void TreeNavBrow::allocate_pixmaps()
{
  flow_sPixmapData pixmap_data;
  int i;
  
  i = 0;
  pixmap_data[i].width =xnav_bitmap_leaf8_width;
  pixmap_data[i].height =xnav_bitmap_leaf8_height;
  pixmap_data[i++].bits = xnav_bitmap_leaf8_bits;
  pixmap_data[i].width =xnav_bitmap_leaf10_width;
  pixmap_data[i].height =xnav_bitmap_leaf10_height;
  pixmap_data[i++].bits = xnav_bitmap_leaf10_bits;
  pixmap_data[i].width =xnav_bitmap_leaf12_width;
  pixmap_data[i].height =xnav_bitmap_leaf12_height;
  pixmap_data[i++].bits = xnav_bitmap_leaf12_bits;
  pixmap_data[i].width =xnav_bitmap_leaf14_width;
  pixmap_data[i].height =xnav_bitmap_leaf14_height;
  pixmap_data[i++].bits = xnav_bitmap_leaf14_bits;
  pixmap_data[i].width =xnav_bitmap_leaf16_width;
  pixmap_data[i].height =xnav_bitmap_leaf16_height;
  pixmap_data[i++].bits = xnav_bitmap_leaf16_bits;
  pixmap_data[i].width =xnav_bitmap_leaf18_width;
  pixmap_data[i].height =xnav_bitmap_leaf18_height;
  pixmap_data[i++].bits = xnav_bitmap_leaf18_bits;
  pixmap_data[i].width =xnav_bitmap_leaf20_width;
  pixmap_data[i].height =xnav_bitmap_leaf20_height;
  pixmap_data[i++].bits = xnav_bitmap_leaf20_bits;
  pixmap_data[i].width =xnav_bitmap_leaf20_width;
  pixmap_data[i].height =xnav_bitmap_leaf20_height;
  pixmap_data[i++].bits = xnav_bitmap_leaf20_bits;
  pixmap_data[i].width =xnav_bitmap_leaf24_width;
  pixmap_data[i].height =xnav_bitmap_leaf24_height;
  pixmap_data[i++].bits = xnav_bitmap_leaf24_bits;
  
  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_leaf);
  
  i = 0;
  pixmap_data[i].width =xnav_bitmap_map8_width;
  pixmap_data[i].height =xnav_bitmap_map8_height;
  pixmap_data[i++].bits = xnav_bitmap_map8_bits;
  pixmap_data[i].width =xnav_bitmap_map10_width;
  pixmap_data[i].height =xnav_bitmap_map10_height;
  pixmap_data[i++].bits = xnav_bitmap_map10_bits;
  pixmap_data[i].width =xnav_bitmap_map12_width;
  pixmap_data[i].height =xnav_bitmap_map12_height;
  pixmap_data[i++].bits = xnav_bitmap_map12_bits;
  pixmap_data[i].width =xnav_bitmap_map14_width;
  pixmap_data[i].height =xnav_bitmap_map14_height;
  pixmap_data[i++].bits = xnav_bitmap_map14_bits;
  pixmap_data[i].width =xnav_bitmap_map16_width;
  pixmap_data[i].height =xnav_bitmap_map16_height;
  pixmap_data[i++].bits = xnav_bitmap_map16_bits;
  pixmap_data[i].width =xnav_bitmap_map18_width;
  pixmap_data[i].height =xnav_bitmap_map18_height;
  pixmap_data[i++].bits = xnav_bitmap_map18_bits;
  pixmap_data[i].width =xnav_bitmap_map20_width;
  pixmap_data[i].height =xnav_bitmap_map20_height;
  pixmap_data[i++].bits = xnav_bitmap_map20_bits;
  pixmap_data[i].width =xnav_bitmap_map20_width;
  pixmap_data[i].height =xnav_bitmap_map20_height;
  pixmap_data[i++].bits = xnav_bitmap_map20_bits;
  pixmap_data[i].width =xnav_bitmap_map24_width;
  pixmap_data[i].height =xnav_bitmap_map24_height;
  pixmap_data[i++].bits = xnav_bitmap_map24_bits;

  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_map);
  
  i = 0;
  pixmap_data[i].width =xnav_bitmap_openmap8_width;
  pixmap_data[i].height =xnav_bitmap_openmap8_height;
  pixmap_data[i++].bits = xnav_bitmap_openmap8_bits;
  pixmap_data[i].width =xnav_bitmap_openmap10_width;
  pixmap_data[i].height =xnav_bitmap_openmap10_height;
  pixmap_data[i++].bits = xnav_bitmap_openmap10_bits;
  pixmap_data[i].width =xnav_bitmap_openmap12_width;
  pixmap_data[i].height =xnav_bitmap_openmap12_height;
  pixmap_data[i++].bits = xnav_bitmap_openmap12_bits;
  pixmap_data[i].width =xnav_bitmap_openmap14_width;
  pixmap_data[i].height =xnav_bitmap_openmap14_height;
  pixmap_data[i++].bits = xnav_bitmap_openmap14_bits;
  pixmap_data[i].width =xnav_bitmap_openmap16_width;
  pixmap_data[i].height =xnav_bitmap_openmap16_height;
  pixmap_data[i++].bits = xnav_bitmap_openmap16_bits;
  pixmap_data[i].width =xnav_bitmap_openmap18_width;
  pixmap_data[i].height =xnav_bitmap_openmap18_height;
  pixmap_data[i++].bits = xnav_bitmap_openmap18_bits;
  pixmap_data[i].width =xnav_bitmap_openmap20_width;
  pixmap_data[i].height =xnav_bitmap_openmap20_height;
  pixmap_data[i++].bits = xnav_bitmap_openmap20_bits;
  pixmap_data[i].width =xnav_bitmap_openmap20_width;
  pixmap_data[i].height =xnav_bitmap_openmap20_height;
  pixmap_data[i++].bits = xnav_bitmap_openmap20_bits;
  pixmap_data[i].width =xnav_bitmap_openmap24_width;
  pixmap_data[i].height =xnav_bitmap_openmap24_height;
  pixmap_data[i++].bits = xnav_bitmap_openmap24_bits;

  brow_AllocAnnotPixmap( ctx, &pixmap_data, &pixmap_openmap);

}


//
// Create the navigator widget
//
TreeNav::TreeNav(
	void *xn_parent_ctx,
	pwr_tAttrRef  *xn_itemlist,
	int xn_item_cnt,
	unsigned int xn_options,
	pwr_tStatus (*xn_get_object_info)(void *, pwr_tAttrRef *, char *, int,  char *, char *, int),
	pwr_tStatus (*xn_get_node_info)(void *, char *, char *, int),
	pwr_tStatus *status) :
	parent_ctx(xn_parent_ctx),
	itemlist(xn_itemlist),item_cnt(xn_item_cnt),
	message_cb(NULL), options(xn_options)
{
  get_object_info = xn_get_object_info;
  get_node_info = xn_get_node_info;
  create_objectlist(xn_itemlist, xn_item_cnt, status);
  *status = 1;
}

//
//  Delete a nav context
//
TreeNav::~TreeNav()
{
}

TreeNavBrow::~TreeNavBrow()
{
  free_pixmaps();
}

//
// Callbacks from brow
//
static int treenav_brow_cb( FlowCtx *ctx, flow_tEvent event)
{
  TreeNav		*treenav;
  TrItemBase 		*item;

  if ( event->event == flow_eEvent_ObjectDeleted) {
    brow_GetUserData( event->object.object, (void **)&item);
    delete item;
    return 1;
  }

  brow_GetCtxUserData( (BrowCtx *)ctx, (void **) &treenav);

  treenav->message( ' ', "");
  switch ( event->event) {
  case flow_eEvent_Key_PageDown: {
    brow_Page( treenav->brow->ctx, 0.8);
    break;
  }
  case flow_eEvent_Key_PageUp: {
    brow_Page( treenav->brow->ctx, -0.8);
    break;
  }
  case flow_eEvent_ScrollDown: {
    brow_Page( treenav->brow->ctx, 0.1);
    break;
  }
  case flow_eEvent_ScrollUp: {
    brow_Page( treenav->brow->ctx, -0.1);
    break;
  }
  case flow_eEvent_Key_Up: {
    brow_tNode	*node_list;
    int		node_count;
    brow_tObject	object;
    int		sts;
      
    brow_GetSelectedNodes( treenav->brow->ctx, &node_list, &node_count);
    if ( !node_count) {
      sts = brow_GetLastVisible( treenav->brow->ctx, &object);
      if ( EVEN(sts)) return 1;
    }
    else {
      if ( !brow_IsVisible( treenav->brow->ctx, node_list[0], flow_eVisible_Partial)) {
	sts = brow_GetLastVisible( treenav->brow->ctx, &object);
	if ( EVEN(sts)) return 1;
      }
      else {
	sts = brow_GetPrevious( treenav->brow->ctx, node_list[0], &object);
	if ( EVEN(sts)) {
	  if ( node_count)
	    free( node_list);
	  return 1;
	}
      }
    }
    brow_SelectClear( treenav->brow->ctx);
    brow_SetInverse( object, 1);
    brow_SelectInsert( treenav->brow->ctx, object);
    if ( !brow_IsVisible( treenav->brow->ctx, object, flow_eVisible_Full))
      brow_CenterObject( treenav->brow->ctx, object, 0.25);
    if ( node_count)
      free( node_list);
    break;
  }
  case flow_eEvent_Key_Down: {
    brow_tNode	*node_list;
    int		node_count;
    brow_tObject	object;
    int		sts;

    brow_GetSelectedNodes( treenav->brow->ctx, &node_list, &node_count);
    if ( !node_count) {
      sts = brow_GetFirstVisible( treenav->brow->ctx, &object);
      if ( EVEN(sts)) return 1;
    }
    else {
      if ( !brow_IsVisible( treenav->brow->ctx, node_list[0], flow_eVisible_Partial)) {
	sts = brow_GetFirstVisible( treenav->brow->ctx, &object);
	if ( EVEN(sts)) return 1;
      }
      else {
	sts = brow_GetNext( treenav->brow->ctx, node_list[0], &object);
	if ( EVEN(sts)) {
	  if ( node_count)
	    free( node_list);
	  return 1;
	}
      }
    }
    brow_SelectClear( treenav->brow->ctx);
    brow_SetInverse( object, 1);
    brow_SelectInsert( treenav->brow->ctx, object);
    if ( !brow_IsVisible( treenav->brow->ctx, object, flow_eVisible_Full))
      brow_CenterObject( treenav->brow->ctx, object, 0.75);
    if ( node_count)
      free( node_list);
    break;
  }
  case flow_eEvent_SelectClear:
    brow_ResetSelectInverse( treenav->brow->ctx);
    break;
  case flow_eEvent_MB1Click: {
    // Select
    double ll_x, ll_y, ur_x, ur_y;
    int sts;

    switch ( event->object.object_type) {
    case flow_eObjectType_Node:
      brow_MeasureNode( event->object.object, &ll_x, &ll_y,
			&ur_x, &ur_y);
      if ( event->object.x < ll_x + 1.0) {
	// Simulate doubleclick
	flow_tEvent doubleclick_event;

	doubleclick_event = (flow_tEvent) calloc( 1, sizeof(*doubleclick_event));
	memcpy( doubleclick_event, event, sizeof(*doubleclick_event));
	doubleclick_event->event = flow_eEvent_MB1DoubleClick;
	sts = treenav_brow_cb( ctx, doubleclick_event);
	free( (char *) doubleclick_event);
	return sts;
      }

      if ( brow_FindSelectedObject( treenav->brow->ctx, event->object.object)) {
	brow_SelectClear( treenav->brow->ctx);
      }
      else {
	brow_SelectClear( treenav->brow->ctx);
	brow_SetInverse( event->object.object, 1);
	brow_SelectInsert( treenav->brow->ctx, event->object.object);
      }
      break;
    default:
      brow_SelectClear( treenav->brow->ctx);
    }
    break;
  }
  case flow_eEvent_Key_Left: {
    brow_tNode	*node_list;
    int		node_count;
    brow_tObject	object;
    int		sts;
    
    brow_GetSelectedNodes( treenav->brow->ctx, &node_list, &node_count);
    if ( !node_count)
      return 1;

    if ( brow_IsOpen( node_list[0]))
      // Close this node
      object = node_list[0];
    else {
      // Close parent
      sts = brow_GetParent( treenav->brow->ctx, node_list[0], &object);
      if ( EVEN(sts)) {
	free( node_list);
	return 1;
      }
    }
    brow_GetUserData( object, (void **)&item);
    item->close( treenav, 0, 0);

    brow_SelectClear( treenav->brow->ctx);
    brow_SetInverse( object, 1);
    brow_SelectInsert( treenav->brow->ctx, object);
    if ( !brow_IsVisible( treenav->brow->ctx, object, flow_eVisible_Full))
      brow_CenterObject( treenav->brow->ctx, object, 0.25);
    free( node_list);
    break;
  }
  case flow_eEvent_Key_Right: {
    brow_tNode	*node_list;
    int		node_count;

    brow_GetSelectedNodes( treenav->brow->ctx, &node_list, &node_count);
    if ( !node_count)
      return 1;

    brow_GetUserData( node_list[0], (void **)&item);
    switch( item->type) {
    case treenav_eItemType_TreeNode:
      ((TrItemNode *)item)->open_children( treenav, 0, 0);
      break;
    default:
      ;
    }
  }
  case flow_eEvent_MB1DoubleClick:
    switch ( event->object.object_type) {
    case flow_eObjectType_Node:
      brow_GetUserData( event->object.object, (void **)&item);
      switch( item->type) {
      case treenav_eItemType_TreeNode: 
	((TrItemNode *)item)->open_children( treenav,
					       event->object.x, event->object.y);
	break;
      default:
	;
      }
      break;
    default:
      ;
    }
    break;
  default:
    ;
  }
  return 1;
}


//
// Create nodeclasses
//
void TreeNavBrow::create_nodeclasses()
{
  allocate_pixmaps();

  // Create common-class

  brow_CreateNodeClass( ctx, "NavigatorDefault", 
		flow_eNodeGroup_Common, &nc_object);
  brow_AddAnnotPixmap( nc_object, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot( nc_object, 2, 0.6, 0,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		0);
  brow_AddAnnot( nc_object, 12, 0.6, 1,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		1);
  brow_AddAnnot( nc_object, 15, 0.6, 2,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		1);
  brow_AddFrame( nc_object, 0, 0, 20, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Create attribute nodeclass

  brow_CreateNodeClass( ctx, "NavigatorAttr", 
		flow_eNodeGroup_Common, &nc_node);
  brow_AddAnnotPixmap( nc_node, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot( nc_node, 2, 0.6, 0,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		0);
  brow_AddAnnot( nc_node, 8, 0.6, 1,
		flow_eDrawType_TextHelvetica, 2, flow_eAnnotType_OneLine, 
		1);
  brow_AddFrame( nc_node, 0, 0, 20, 0.83, flow_eDrawType_LineGray, -1, 1);

}

void TreeNav::show_list()
{
  options |= tree_mOptions_LayoutList;
  options &= ~tree_mOptions_LayoutTree;
  brow_DeleteAll( brow->ctx);
  create_items();
}

void TreeNav::show_tree()
{
  options |= tree_mOptions_LayoutTree;
  options &= ~tree_mOptions_LayoutList;
  brow_DeleteAll( brow->ctx);
  create_items();
}

int TreeNav::create_items()
{
  int i;

  brow_SetNodraw( brow->ctx);

  if ( options & tree_mOptions_LayoutList) {
    for ( i = 0; i < (int)objectlist.size(); i++) {
      new TrItemObject( this, &objectlist[i], NULL, flow_eDest_IntoLast);    
    }
  }
  else {
    for ( int idx = 1; idx; idx = tree[idx].fws) {
      if ( tree[idx].type == treenav_eTreeItemType_Object)
	new TrItemTreeObject( this, &objectlist[tree[idx].idx], idx, NULL, 
				  flow_eDest_IntoLast);
      else
	new TrItemNode( this, tree[idx].sname, tree[idx].descr, idx, NULL, flow_eDest_IntoLast);
    }
  }
  brow_ResetNodraw( brow->ctx);
  brow_Redraw( brow->ctx, 0);
  return 1;
}

void TreeNavBrow::brow_setup()
{
  brow_sAttributes brow_attr;
  unsigned long mask;

  mask = 0;
  mask |= brow_eAttr_indentation;
  brow_attr.indentation = 0.5;
  mask |= brow_eAttr_annotation_space;
  brow_attr.annotation_space = 0.5;
  brow_SetAttributes( ctx, &brow_attr, mask); 
  brow_SetCtxUserData( ctx, treenav);

  brow_EnableEvent( ctx, flow_eEvent_MB1Click, flow_eEventType_CallBack, 
	treenav_brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_MB1DoubleClick, flow_eEventType_CallBack, 
	treenav_brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_SelectClear, flow_eEventType_CallBack, 
	treenav_brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_ObjectDeleted, flow_eEventType_CallBack, 
	treenav_brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_Up, flow_eEventType_CallBack, 
	treenav_brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_Down, flow_eEventType_CallBack, 
	treenav_brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_Right, flow_eEventType_CallBack, 
	treenav_brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_Left, flow_eEventType_CallBack, 
	treenav_brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_PF3, flow_eEventType_CallBack, 
	treenav_brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Radiobutton, flow_eEventType_CallBack, 
	treenav_brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_PageUp, flow_eEventType_CallBack, 
	treenav_brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_Key_PageDown, flow_eEventType_CallBack, 
	treenav_brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_ScrollUp, flow_eEventType_CallBack, 
	treenav_brow_cb);
  brow_EnableEvent( ctx, flow_eEvent_ScrollDown, flow_eEventType_CallBack, 
	treenav_brow_cb);
}

//
// Backcall routine called at creation of the brow widget
// Enable event, create nodeclasses and insert the root objects.
//
int TreeNav::init_brow_cb( FlowCtx *fctx, void *client_data)
{
  TreeNav *treenav = (TreeNav *) client_data;
  BrowCtx *ctx = (BrowCtx *)fctx;

  treenav->brow = new TreeNavBrow( ctx, (void *)treenav);

  treenav->brow->brow_setup();
  treenav->brow->create_nodeclasses();

  treenav->build_tree();

  // Create the root items
  treenav->create_items();

  return 1;
}


int TreeNav::get_select( TrItemBase **item)
{
  brow_tNode	*node_list;
  int		node_count;
      
  brow_GetSelectedNodes( brow->ctx, &node_list, &node_count);

  if ( !node_count)
    return 0;

  brow_GetUserData( node_list[0], (void **)item);
  return 1;
}
  
int TreeNav::get_item( char *name, TreeNav_object **hi)
{      
  for ( int i = 0; i < (int)objectlist.size(); i++) {

    if ( cdh_NoCaseStrcmp( objectlist[i].name, name) == 0) {
      *hi = &objectlist[i];
      return 1;
    }
  }
  return 0;
}
  

//
//  Get zoom
//
void TreeNav::get_zoom( double *zoom_factor)
{
  brow_GetZoom( brow->ctx, zoom_factor);
}

//
//  Zoom
//
void TreeNav::zoom( double zoom_factor)
{
  brow_Zoom( brow->ctx, zoom_factor);
}

//
//  Return to base zoom factor
//
void TreeNav::unzoom()
{
  brow_UnZoom( brow->ctx);
}

TrItemObject::TrItemObject( TreeNav *treenav, TreeNav_object *xitem,
		      brow_tNode dest, flow_eDest dest_code) : 
  TrItemBase( treenav_eItemType_Object), item(*xitem)
{
  type = treenav_eItemType_Object;
  pwr_tAName aname;
  
  brow_CreateNode( treenav->brow->ctx, "LocalItem", treenav->brow->nc_object, 
		   dest, dest_code, (void *) this, 1, &node);

  brow_SetAnnotPixmap( node, 0, treenav->brow->pixmap_leaf);

  strcpy( aname, item.name);
  brow_SetAnnotation( node, 0, aname, strlen(aname));
  brow_SetAnnotation( node, 1, item.cname, strlen(item.cname));
  brow_SetAnnotation( node, 2, item.description, strlen(item.description));
}

int TrItemObject::close( TreeNav *treenav, double x, double y)
{
  double	node_x, node_y;

  brow_GetNodePosition( node, &node_x, &node_y);

  if ( brow_IsOpen( node)) {
    // Close
    brow_SetNodraw( treenav->brow->ctx);
    brow_CloseNode( treenav->brow->ctx, node);
    brow_SetAnnotPixmap( node, 0, treenav->brow->pixmap_leaf);
    brow_ResetOpen( node, treenav_mOpen_All);
    brow_ResetNodraw( treenav->brow->ctx);
    brow_Redraw( treenav->brow->ctx, node_y);
  }
  return 1;
}

TrItemTreeObject::TrItemTreeObject( TreeNav *treenav, TreeNav_object *xitem, int index,
			      brow_tNode dest, flow_eDest dest_code) : 
  TrItemObject(treenav, xitem, dest, dest_code), idx(index)
{
  pwr_tAName aname;
  char *s;

  type = treenav_eItemType_TreeObject;

  if ((s = strrchr( item.name, '.')) || (s = strrchr( item.name, '-')))  
    strcpy( aname, s+1);
  else
    strcpy( aname, item.name);
  brow_SetAnnotation( node, 0, aname, strlen(aname));
}

TrItemNode::TrItemNode( TreeNav *treenav, char *name, char *descr, int index,
			    brow_tNode dest, flow_eDest dest_code) :
  TrItemBase(treenav_eItemType_TreeNode), idx(index)
{
  brow_CreateNode( treenav->brow->ctx, "TreeNode", treenav->brow->nc_node, 
		   dest, dest_code, (void *) this, 1, &node);

  if ( treenav->tree[idx].fch)
    brow_SetAnnotPixmap( node, 0, treenav->brow->pixmap_map);
  else
    brow_SetAnnotPixmap( node, 0, treenav->brow->pixmap_leaf);

  brow_SetAnnotation( node, 0, name, strlen(name));
  if ( descr)
    brow_SetAnnotation( node, 1, descr, strlen(descr));
}

int TrItemNode::open_children( TreeNav *treenav, double x, double y)
{
  double	node_x, node_y;

  brow_GetNodePosition( node, &node_x, &node_y);

  if ( brow_IsOpen( node) & treenav_mOpen_Children) {
    // Attributes is open, close
    brow_SetNodraw( treenav->brow->ctx);
    brow_CloseNode( treenav->brow->ctx, node);
    brow_ResetOpen( node, treenav_mOpen_Children);
    brow_SetAnnotPixmap( node, 0, treenav->brow->pixmap_map);
    // brow_RemoveAnnotPixmap( node, 1);
    brow_ResetNodraw( treenav->brow->ctx);
    brow_Redraw( treenav->brow->ctx, node_y);
  }
  else {

    brow_SetNodraw( treenav->brow->ctx);
    for ( int i = treenav->tree[idx].fch; i; i = treenav->tree[i].fws) {
      if ( treenav->tree[i].deleted)
	continue;

      if ( treenav->tree[i].type == treenav_eTreeItemType_Object)
	new TrItemTreeObject( treenav, &treenav->objectlist[treenav->tree[i].idx], i, node, 
			   flow_eDest_IntoLast);
      else
	new TrItemNode( treenav, treenav->tree[i].sname, treenav->tree[i].descr, i, node, flow_eDest_IntoLast);
    }
    brow_SetOpen( node, treenav_mOpen_Children);
    brow_SetAnnotPixmap( node, 0, treenav->brow->pixmap_openmap);
    brow_ResetNodraw( treenav->brow->ctx);
    brow_Redraw( treenav->brow->ctx, node_y);
  }
  return 1;
}

int TrItemNode::close( TreeNav *treenav, double x, double y)
{
  double	node_x, node_y;

  if ( brow_IsOpen( node) & treenav_mOpen_Children) {
    // Children is open, close
    brow_GetNodePosition( node, &node_x, &node_y);
    brow_SetNodraw( treenav->brow->ctx);
    brow_CloseNode( treenav->brow->ctx, node);
    brow_ResetOpen( node, treenav_mOpen_All);
    brow_SetAnnotPixmap( node, 0, treenav->brow->pixmap_map);
    brow_ResetNodraw( treenav->brow->ctx);
    brow_Redraw( treenav->brow->ctx, node_y);
  }
  return 1;
}

void TreeNav::build_tree()
{
  pwr_tAName aname;

  for ( int i = 0; i < (int)objectlist.size(); i++) {
    TreeNode n;

    strcpy( aname, objectlist[i].name);

    tree_add( aname, i, treenav_eTreeItemType_Object);
  }

}

void TreeNav::tree_add( char *name, int list_index, treenav_eTreeItemType type)
{
  pwr_tObjName name_array[24];
  int seg;

  seg = dcli_parse( name, "-.", "",
		    (char *) name_array, sizeof( name_array)/sizeof( name_array[0]), 
		    sizeof( name_array[0]), 0);

  if ( tree.size() == 0) {
    // First item
    TreeNode n0;
    strcpy( n0.sname, "nonode");
    tree.push_back(n0);
    
    for ( int j = 0; j < seg; j++) {
      TreeNode n;

      n.fth = j;
      tree[j].fch = j + 1;
      strcpy( n.sname, name_array[j]);
      get_descr( name, seg, j, n.descr);
      if ( j == seg -1) {
	n.idx = list_index;
	n.type = type;
      }
      tree.push_back(n);
    }
  }
  else {
    int idx = 1;
    int last = idx;
    for ( int j = 0; j < seg; j++) {
      int found = 0;
      while ( idx) {
	last = idx;
	if ( strcmp( tree[idx].sname, name_array[j]) == 0) {
	  found = 1;
	  break;
	}
	idx = tree[idx].fws;
      }
      if ( !found) {
	TreeNode n;
	strcpy( n.sname, name_array[j]);
	get_descr( name, seg, j, n.descr);
	n.fth = tree[last].fth;
	n.bws = last;   
	tree[last].fws = tree.size();
	if ( j == seg - 1) {
	  n.idx = list_index;
	  n.type = type;
	}
	tree.push_back(n);
	
	for ( int k = j + 1; k < seg; k++) {
	  TreeNode n;

	  n.fth = tree.size() - 1;
	  if ( tree[n.fth].fch == 0)
	    tree[n.fth].fch = tree.size();
	  strcpy( n.sname, name_array[k]);
	  get_descr( name, seg, k, n.descr);
	  if ( k == seg - 1) {
	    n.idx = list_index;
	    n.type = type;
	  }
	  tree.push_back(n);
	}
	break;
      }
      if ( tree[idx].fch == 0) {
	TreeNode n;
	strcpy( n.sname, name_array[j]);
	n.fth = tree[last].fth;
	n.bws = last;   
	tree[last].fws = tree.size();
	if ( j == seg - 1) {
	  n.idx = list_index;
	  n.type = type;
	}
	tree.push_back(n);
	for ( int k = j + 1; k < seg; k++) {
	  TreeNode n;

	  n.fth = tree.size() - 1;
	  if ( tree[n.fth].fch == 0)
	    tree[n.fth].fch = tree.size();
	  strcpy( n.sname, name_array[k]);
	  get_descr( name, seg, k, n.descr);
	  if ( k == seg - 1) {
	    n.idx = list_index;
	    n.type = type;
	  }
	  tree.push_back(n);
	}
	break;
      }
      idx = tree[idx].fch;
      last = idx;
    }
  }
}

void TreeNav::create_objectlist(      pwr_tAttrRef  *xn_itemlist,
	                              int xn_item_cnt,
	                              pwr_tStatus *status)
{
  for ( int i = 0; i < xn_item_cnt; i++) {
    TreeNav_object object;
    pwr_tStatus sts;

    object.aref = xn_itemlist[i];
    sts = (get_object_info)(parent_ctx, &object.aref, object.name, sizeof(object.name), object.cname,
		      object.description, sizeof(object.description));
    if (EVEN(sts)) continue;

    objectlist.push_back(object);
  }

  // Sort
  if ( options & tree_mOptions_AlphaOrder) {
    TreeNav_object tmp;
    for ( unsigned int i = objectlist.size() - 1; i > 0; i--) {
      for ( unsigned int j = 0; j < i; j++) {
	if ( strcmp(objectlist[j].name, objectlist[j+1].name) > 0) {
	  tmp = objectlist[j+1];
	  objectlist[j+1] = objectlist[j];
	  objectlist[j] = tmp;
	}
      }
    }
  }
}

int TreeNav::get_descr( char *name, int seg, int idx, char *descr)
{
  pwr_tAName n;
  char *s, *s1;
  pwr_tStatus sts;
  pwr_tString80 description;

  strncpy( n, name, sizeof(n));
  s = n;
  for ( int m = 0; m <= idx; m++) {
    if ( (s1 = strchr( s, '-')) || (s1 = strchr( s, '.'))) {
      if ( m == idx)
	*s1 = 0;
      else
	s1++;
      s = s1;
    }
    else
      break;
  }

  sts = (get_node_info)( parent_ctx, n, description, sizeof(description));
  strcpy( descr, description);

  return sts;
}