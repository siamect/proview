/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* co_msglist.cpp -- Message list */

#include <string.h>

#include "co_cdh.h"
#include "co_time.h"

#include "cow_msglist.h"

//
//  Free pixmaps
//
void MsgListBrow::free_pixmaps()
{
  brow_FreeAnnotPixmap(ctx, pixmap_morehelp);
}

//
//  Create pixmaps for leaf, closed map and open map
//
void MsgListBrow::allocate_pixmaps()
{
  brow_LoadPBM(ctx, "xnav_bitmap_morehelp", &pixmap_morehelp);
}

//
// Create nodeclasses
//
void MsgListBrow::create_nodeclasses()
{
  allocate_pixmaps();

  // Create common-class

  brow_CreateNodeClass(
      ctx, "EventDefault", flow_eNodeGroup_Common, &nc_default);
  brow_AddAnnotPixmap(nc_default, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot(nc_default, 1.4, 0.6, 0, flow_eDrawType_TextHelveticaBold, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_default, 2.2, 0.6, 1, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_default, 9, 0.6, 2, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddFrame(nc_default, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Nodeclass for Error
  brow_CreateNodeClass(ctx, "Error", flow_eNodeGroup_Common, &nc_error);
  brow_AddAnnotPixmap(nc_error, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddFilledRect(nc_error, 0.8, 0.15, 0.4, 0.4, flow_eDrawType_LineRed);
  brow_AddRect(nc_error, 0.8, 0.15, 0.4, 0.4, flow_eDrawType_Line, 0, 0);
  brow_AddAnnot(nc_error, 1.4, 0.6, 0, flow_eDrawType_TextHelveticaBold, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_error, 2.2, 0.6, 1, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_error, 9, 0.6, 2, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddFrame(nc_error, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Nodeclass for Fatal
  brow_CreateNodeClass(ctx, "Fatal", flow_eNodeGroup_Common, &nc_fatal);
  brow_AddAnnotPixmap(nc_fatal, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddFilledRect(nc_fatal, 0.8, 0.15, 0.4, 0.4, flow_eDrawType_LineRed);
  brow_AddRect(nc_fatal, 0.8, 0.15, 0.4, 0.4, flow_eDrawType_Line, 2, 0);
  brow_AddAnnot(nc_fatal, 1.4, 0.6, 0, flow_eDrawType_TextHelveticaBold, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_fatal, 2.2, 0.6, 1, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_fatal, 9, 0.6, 2, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddFrame(nc_fatal, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Nodeclass for Warning
  brow_CreateNodeClass(ctx, "Warning", flow_eNodeGroup_Common, &nc_warning);
  brow_AddAnnotPixmap(nc_warning, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddFilledRect(nc_warning, 0.8, 0.15, 0.4, 0.4, flow_eDrawType_Yellow);
  brow_AddRect(nc_warning, 0.8, 0.15, 0.4, 0.4, flow_eDrawType_Line, 0, 0);
  brow_AddAnnot(nc_warning, 1.4, 0.6, 0, flow_eDrawType_TextHelveticaBold, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_warning, 2.2, 0.6, 1, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_warning, 9, 0.6, 2, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddFrame(nc_warning, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Nodeclass for Info
  brow_CreateNodeClass(ctx, "Info", flow_eNodeGroup_Common, &nc_info);
  brow_AddAnnotPixmap(nc_info, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  brow_AddFilledRect(nc_info, 0.8, 0.15, 0.4, 0.4, flow_eDrawType_Green);
  brow_AddRect(nc_info, 0.8, 0.15, 0.4, 0.4, flow_eDrawType_Line, 0, 0);
  brow_AddAnnot(nc_info, 1.4, 0.6, 0, flow_eDrawType_TextHelveticaBold, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_info, 2.2, 0.6, 1, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_info, 9, 0.6, 2, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddFrame(nc_info, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);

  // Nodeclass for Success
  brow_CreateNodeClass(ctx, "Success", flow_eNodeGroup_Common, &nc_success);
  brow_AddAnnotPixmap(nc_success, 0, 0.2, 0.1, flow_eDrawType_Line, 2, 0);
  // brow_AddFilledRect( nc_success, 0.8, 0.15, 0.4, 0.4, flow_eDrawType_Green);
  brow_AddRect(nc_success, 0.8, 0.15, 0.4, 0.4, flow_eDrawType_Line, 0, 0);
  brow_AddAnnot(nc_success, 1.4, 0.6, 0, flow_eDrawType_TextHelveticaBold, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_success, 2.2, 0.6, 1, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddAnnot(nc_success, 9, 0.6, 2, flow_eDrawType_TextHelvetica, 2,
      flow_eAnnotType_OneLine, 0);
  brow_AddFrame(nc_success, 0, 0, 35, 0.83, flow_eDrawType_LineGray, -1, 1);
}

void MsgListBrow::brow_setup()
{
  brow_sAttributes brow_attr;
  unsigned long mask;

  mask = 0;
  mask |= brow_eAttr_indentation;
  brow_attr.indentation = 0.5;
  mask |= brow_eAttr_annotation_space;
  brow_attr.annotation_space = 0.5;
  brow_SetAttributes(ctx, &brow_attr, mask);
  brow_SetCtxUserData(ctx, msglist);

  brow_EnableEvent(
      ctx, flow_eEvent_MB1Click, flow_eEventType_CallBack, MsgList::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_MB1DoubleClick, flow_eEventType_CallBack,
      MsgList::brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_MB3Press, flow_eEventType_CallBack, MsgList::brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_MB3Down, flow_eEventType_CallBack, MsgList::brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_SelectClear, flow_eEventType_CallBack, MsgList::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_ObjectDeleted, flow_eEventType_CallBack,
      MsgList::brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_Key_Up, flow_eEventType_CallBack, MsgList::brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_Key_Down, flow_eEventType_CallBack, MsgList::brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_Key_Right, flow_eEventType_CallBack, MsgList::brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_Key_Left, flow_eEventType_CallBack, MsgList::brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_Key_PF3, flow_eEventType_CallBack, MsgList::brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_Key_PageUp, flow_eEventType_CallBack, MsgList::brow_cb);
  brow_EnableEvent(ctx, flow_eEvent_Key_PageDown, flow_eEventType_CallBack,
      MsgList::brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_ScrollUp, flow_eEventType_CallBack, MsgList::brow_cb);
  brow_EnableEvent(
      ctx, flow_eEvent_ScrollDown, flow_eEventType_CallBack, MsgList::brow_cb);
}

//
// Backcall routine called at creation of the brow widget
// Enable event, create nodeclasses and insert the root objects.
//
int MsgList::init_brow_cb(FlowCtx* fctx, void* client_data)
{
  MsgList* msglist = (MsgList*)client_data;
  BrowCtx* ctx = (BrowCtx*)fctx;

  msglist->brow = new MsgListBrow(ctx, (void*)msglist);

  msglist->brow->brow_setup();
  msglist->brow->create_nodeclasses();

  return 1;
}

MsgList::MsgList(void* ev_parent_ctx)
    : parent_ctx(ev_parent_ctx), find_wnav_cb(0), find_plc_cb(0), find_ge_cb(0)
{
}

//
//  Delete ev
//
MsgList::~MsgList()
{
}

MsgListBrow::~MsgListBrow()
{
  free_pixmaps();
}

//
//  Zoom
//
void MsgList::zoom(double zoom_factor)
{
  brow_Zoom(brow->ctx, zoom_factor);
}

//
//  Return to base zoom factor
//
void MsgList::unzoom()
{
  brow_UnZoom(brow->ctx);
}

void MsgList::set_nodraw()
{
  brow_SetNodraw(brow->ctx);
}

void MsgList::reset_nodraw()
{
  brow_ResetNodraw(brow->ctx);
  brow_Redraw(brow->ctx, 0);
}

void MsgList::remove_oldest()
{
  brow_tObject last;

  brow_GetLast(brow->ctx, &last);
  brow_DeleteNode(brow->ctx, last);
}

void MsgList::clear()
{
  brow_DeleteAll(brow->ctx);
}

//
// Callbacks from brow
//
int MsgList::brow_cb(FlowCtx* ctx, flow_tEvent event)
{
  MsgList* msglist;
  ItemMsg* item;

  if (event->event == flow_eEvent_ObjectDeleted) {
    brow_GetUserData(event->object.object, (void**)&item);
    delete item;
    return 1;
  }

  brow_GetCtxUserData((BrowCtx*)ctx, (void**)&msglist);
  switch (event->event) {
  case flow_eEvent_Key_Up: {
    brow_tNode* node_list;
    int node_count;
    brow_tObject object;
    int sts;

    brow_GetSelectedNodes(msglist->brow->ctx, &node_list, &node_count);
    if (!node_count) {
      sts = brow_GetLastVisible(msglist->brow->ctx, &object);
      if (EVEN(sts))
        return 1;
    } else {
      if (!brow_IsVisible(
              msglist->brow->ctx, node_list[0], flow_eVisible_Partial)) {
        sts = brow_GetLastVisible(msglist->brow->ctx, &object);
        if (EVEN(sts))
          return 1;
      } else {
        sts = brow_GetPrevious(msglist->brow->ctx, node_list[0], &object);
        if (EVEN(sts)) {
          if (node_count)
            free(node_list);
          return 1;
        }
      }
    }
    brow_SelectClear(msglist->brow->ctx);
    brow_SetInverse(object, 1);
    brow_SelectInsert(msglist->brow->ctx, object);
    if (!brow_IsVisible(msglist->brow->ctx, object, flow_eVisible_Full))
      brow_CenterObject(msglist->brow->ctx, object, 0.25);
    if (node_count)
      free(node_list);
    break;
  }
  case flow_eEvent_Key_Down: {
    brow_tNode* node_list;
    int node_count;
    brow_tObject object;
    int sts;

    brow_GetSelectedNodes(msglist->brow->ctx, &node_list, &node_count);
    if (!node_count) {
      sts = brow_GetFirstVisible(msglist->brow->ctx, &object);
      if (EVEN(sts))
        return 1;
    } else {
      if (!brow_IsVisible(
              msglist->brow->ctx, node_list[0], flow_eVisible_Partial)) {
        sts = brow_GetFirstVisible(msglist->brow->ctx, &object);
        if (EVEN(sts))
          return 1;
      } else {
        sts = brow_GetNext(msglist->brow->ctx, node_list[0], &object);
        if (EVEN(sts)) {
          if (node_count)
            free(node_list);
          return 1;
        }
      }
    }
    brow_SelectClear(msglist->brow->ctx);
    brow_SetInverse(object, 1);
    brow_SelectInsert(msglist->brow->ctx, object);
    if (!brow_IsVisible(msglist->brow->ctx, object, flow_eVisible_Full))
      brow_CenterObject(msglist->brow->ctx, object, 0.75);
    if (node_count)
      free(node_list);
    break;
  }
  case flow_eEvent_SelectClear:
    brow_ResetSelectInverse(msglist->brow->ctx);
    break;
  case flow_eEvent_MB1Click:
    // Select
    double ll_x, ll_y, ur_x, ur_y;
    int sts;

    switch (event->object.object_type) {
    case flow_eObjectType_Node:
      brow_MeasureNode(event->object.object, &ll_x, &ll_y, &ur_x, &ur_y);
      if (event->object.x < ll_x + 1.0) {
        // Simulate doubleclick
        flow_tEvent doubleclick_event;

        doubleclick_event = (flow_tEvent)calloc(1, sizeof(*doubleclick_event));
        memcpy(doubleclick_event, event, sizeof(*doubleclick_event));
        doubleclick_event->event = flow_eEvent_MB1DoubleClick;
        sts = MsgList::brow_cb(ctx, doubleclick_event);
        free((char*)doubleclick_event);
        return sts;
      }

      if (brow_FindSelectedObject(msglist->brow->ctx, event->object.object)) {
        brow_SelectClear(msglist->brow->ctx);
      } else {
        brow_SelectClear(msglist->brow->ctx);
        brow_SetInverse(event->object.object, 1);
        brow_SelectInsert(msglist->brow->ctx, event->object.object);
      }
      break;
    default:
      brow_SelectClear(msglist->brow->ctx);
    }
    break;
  case flow_eEvent_Key_PageDown: {
    brow_Page(msglist->brow->ctx, 0.95);
    break;
  }
  case flow_eEvent_Key_PageUp: {
    brow_Page(msglist->brow->ctx, -0.95);
    break;
  }
  case flow_eEvent_ScrollDown: {
    brow_Page(msglist->brow->ctx, 0.10);
    break;
  }
  case flow_eEvent_ScrollUp: {
    brow_Page(msglist->brow->ctx, -0.10);
    break;
  }
  case flow_eEvent_Key_Left: {
    brow_tNode* node_list;
    int node_count;
    brow_tObject object;
    int sts;

    brow_GetSelectedNodes(msglist->brow->ctx, &node_list, &node_count);
    if (!node_count)
      return 1;

    if (brow_IsOpen(node_list[0]))
      // Close this node
      object = node_list[0];
    else {
      // Close parent
      sts = brow_GetParent(msglist->brow->ctx, node_list[0], &object);
      if (EVEN(sts)) {
        free(node_list);
        return 1;
      }
    }
    brow_GetUserData(object, (void**)&item);
    switch (item->type) {
    case msglist_eItemType_Msg:
      //	  ((ItemLocal *)item)->close( msglist, 0, 0);
      break;
    default:;
    }
    brow_SelectClear(msglist->brow->ctx);
    brow_SetInverse(object, 1);
    brow_SelectInsert(msglist->brow->ctx, object);
    if (!brow_IsVisible(msglist->brow->ctx, object, flow_eVisible_Full))
      brow_CenterObject(msglist->brow->ctx, object, 0.25);
    free(node_list);
    break;
  }
  case flow_eEvent_Key_Right: {
    brow_tNode* node_list;
    int node_count;

    brow_GetSelectedNodes(msglist->brow->ctx, &node_list, &node_count);
    if (!node_count)
      return 1;

    brow_GetUserData(node_list[0], (void**)&item);
    item->find();
    break;
  }
  case flow_eEvent_MB1DoubleClick:
    switch (event->object.object_type) {
    case flow_eObjectType_Node:
      brow_GetUserData(event->object.object, (void**)&item);
      item->find();
      break;
    default:;
    }
    break;
  default:;
  }
  return 1;
}

ItemMsg::ItemMsg(MsgList* item_msglist, const char* item_name, char* item_text,
    int item_severity, brow_tNode dest, flow_eDest dest_code)
    : msglist(item_msglist), severity(item_severity)
{
  char type_str[8];
  char time_str[40];

  type = msglist_eItemType_Msg;

  strncpy(text, item_text, sizeof(text));
  text[sizeof(text) - 1] = 0;

  // Remove newline at end
  if (text[strlen(text) - 1] == '\n')
    text[strlen(text) - 1] = 0;

  switch (severity) {
  case 'S':
    brow_CreateNode(msglist->brow->ctx, (char*)"Success",
        msglist->brow->nc_success, dest, dest_code, (void*)this, 1, &node);
    strcpy(type_str, "S");
    break;
  case 'I':
    brow_CreateNode(msglist->brow->ctx, (char*)"Info", msglist->brow->nc_info,
        dest, dest_code, (void*)this, 1, &node);
    strcpy(type_str, "I");
    break;
  case 'E':
    brow_CreateNode(msglist->brow->ctx, (char*)"Error", msglist->brow->nc_error,
        dest, dest_code, (void*)this, 1, &node);
    strcpy(type_str, "E");
    break;
  case 'W':
    brow_CreateNode(msglist->brow->ctx, (char*)"Warning",
        msglist->brow->nc_warning, dest, dest_code, (void*)this, 1, &node);
    strcpy(type_str, "W");
    break;
  case 'F':
    brow_CreateNode(msglist->brow->ctx, (char*)"Fatal", msglist->brow->nc_fatal,
        dest, dest_code, (void*)this, 1, &node);
    strcpy(type_str, "F");
    break;
  default:
    brow_CreateNode(msglist->brow->ctx, (char*)"Default",
        msglist->brow->nc_default, dest, dest_code, (void*)this, 1, &node);
    strcpy(type_str, "");
  }

  brow_SetAnnotation(node, 0, type_str, strlen(type_str));
  time_GetTime(&time);
  time_AtoAscii(
      &time, time_eFormat_ComprDateAndTime, time_str, sizeof(time_str));
  time_str[17] = 0;
  brow_SetAnnotation(node, 1, time_str, strlen(time_str));
  brow_SetAnnotation(node, 2, text, strlen(text));

  //  brow_SetAnnotPixmap( node, 0, msglist->brow->pixmap_leaf);
}

ItemMsg::~ItemMsg()
{
}

void ItemMsg::find()
{
}

ItemMsgObject::ItemMsgObject(MsgList* item_msglist, const char* item_name,
    char* item_text, int item_severity, pwr_tOid item_oid, brow_tNode dest,
    flow_eDest dest_code)
    : ItemMsg(
          item_msglist, item_name, item_text, item_severity, dest, dest_code),
      oid(item_oid)
{
  brow_SetAnnotPixmap(node, 0, msglist->brow->pixmap_morehelp);
}

void ItemMsgObject::find()
{
  if (msglist->find_wnav_cb)
    (msglist->find_wnav_cb)(msglist->parent_ctx, oid);
}

ItemMsgObjectPlc::ItemMsgObjectPlc(MsgList* item_msglist, const char* item_name,
    char* item_text, int item_severity, pwr_tOid item_oid, brow_tNode dest,
    flow_eDest dest_code)
    : ItemMsg(
          item_msglist, item_name, item_text, item_severity, dest, dest_code),
      oid(item_oid)
{
  brow_SetAnnotPixmap(node, 0, msglist->brow->pixmap_morehelp);
}

void ItemMsgObjectPlc::find()
{
  if (msglist->find_plc_cb)
    (msglist->find_plc_cb)(msglist->parent_ctx, oid);
}

ItemMsgObjectGe::ItemMsgObjectGe(MsgList* item_msglist, const char* item_name,
    char* item_text, int item_severity, char* item_object, void* item_utility,
    brow_tNode dest, flow_eDest dest_code)
    : ItemMsg(
          item_msglist, item_name, item_text, item_severity, dest, dest_code),
      utility(item_utility)
{
  strncpy(object, item_object, sizeof(object));
  brow_SetAnnotPixmap(node, 0, msglist->brow->pixmap_morehelp);
}

void ItemMsgObjectGe::find()
{
  if (msglist->find_ge_cb)
    (msglist->find_ge_cb)(msglist->parent_ctx, object, utility);
}
