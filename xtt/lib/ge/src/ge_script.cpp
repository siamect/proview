/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* ge_graph_script.cpp
   This module contains ge script functions. */

#include <stdlib.h>

#include "pwr_msg.h"
#include "co_ccm.h"
#include "co_ccm_msg.h"
#include "co_dcli.h"
#include "co_dcli_msg.h"
#include "co_string.h"

#include "ge_graph.h"
#include "ge_script.h"
#include "ge_dyn.h"
#include "ge_msg.h"

static Graph* current_graph;

void Graph::script_store_graph()
{
  current_graph = this;
}

static void graph_get_stored_graph(Graph** graph)
{
  *graph = current_graph;
}

static int graph_gettextextent_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  ccm_sArg* arg_p2; // Textsize
  ccm_sArg* arg_p3; // Font
  ccm_sArg* arg_p4; // Bold
  ccm_sArg* arg_p5; // Width
  ccm_sArg* arg_p6 = NULL; // Height
  ccm_sArg* arg_p7 = NULL; // Descent
  Graph* graph;
  glow_eDrawType draw_type;
  double z_width, z_height, z_descent;
  int textsize;
  glow_eFont font;

  if (arg_count < 5 || arg_count > 7)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;
  arg_p4 = arg_p3->next;
  arg_p5 = arg_p4->next;
  if (arg_count > 5)
    arg_p6 = arg_p5->next;
  if (arg_count > 6)
    arg_p7 = arg_p6->next;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p4->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p5->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_count > 5 && arg_p6->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_count > 6 && arg_p7->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  if (arg_p4->value_int)
    draw_type = glow_eDrawType_TextHelveticaBold;
  else
    draw_type = glow_eDrawType_TextHelvetica;

  switch (arg_p2->value_int) {
  case 0:
    textsize = 0;
    break;
  case 1:
    textsize = 1;
    break;
  case 2:
    textsize = 2;
    break;
  case 3:
    textsize = 4;
    break;
  case 4:
    textsize = 6;
    break;
  case 5:
    textsize = 8;
    break;
  default:
    textsize = 8;
  }
  font = (glow_eFont)arg_p3->value_int;

  grow_GetTextExtent(graph->grow->ctx, arg_list->value_string,
      strlen(arg_list->value_string), draw_type, textsize, font,
      &z_width, &z_height, &z_descent);

  arg_p5->value_float = float(z_width);
  arg_p5->value_returned = 1;

  if (arg_count > 5) {
    arg_p6->value_float = float(z_height);
    arg_p6->value_returned = 1;
  }

  if (arg_count > 6) {
    arg_p7->value_float = float(z_descent);
    arg_p7->value_returned = 1;
  }
  return 1;
}

static int graph_selectadd_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SelectInsert(graph->grow->ctx, (grow_tObject)arg_list->value_int);
  return 1;
}

static int graph_selectclear_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 0)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SelectClear(graph->grow->ctx);
  return 1;
}

static int graph_getcurrentobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 0)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  *return_int = (long int)graph->current_cmd_object;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int graph_setextern_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  int sts;
  grow_tObject nodeclass;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  sts = grow_FindNodeClassByName(
      graph->grow->ctx, arg_list->value_string, &nodeclass);
  if (ODD(sts)) {
    grow_SetNodeClassExtern(nodeclass, 1);
    *return_int = 1;
    *return_decl = CCM_DECL_INT;
  } else {
    *return_int = 0;
    *return_decl = CCM_DECL_INT;
  }
  return 1;
}

static int graph_setexternall_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 0)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetNodeClassExternAll(graph->grow->ctx, 1);
  return 1;
}

static int graph_setintern_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  int sts;
  grow_tObject nodeclass;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  sts = grow_FindNodeClassByName(
      graph->grow->ctx, arg_list->value_string, &nodeclass);
  if (ODD(sts)) {
    grow_SetNodeClassExtern(nodeclass, 0);
    *return_int = 1;
    *return_decl = CCM_DECL_INT;
  } else {
    *return_int = 0;
    *return_decl = CCM_DECL_INT;
  }
  return 1;
}

static int graph_setinternall_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 0)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetNodeClassExternAll(graph->grow->ctx, 0);
  return 1;
}

static int graph_true_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  if (arg_count != 0)
    return CCM__ARGMISM;

  *return_int = 1;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_false_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  if (arg_count != 0)
    return CCM__ARGMISM;

  *return_int = 0;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_setdraw_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  if (arg_list->value_int == 0)
    grow_SetNodraw(graph->grow->ctx);
  else {
    grow_ResetNodraw(graph->grow->ctx);
    grow_Redraw(graph->grow->ctx);
  }

  return 1;
}

static int graph_getfirstobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  grow_tObject first;
  int sts;

  if (arg_count != 0)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  sts = grow_GetFirstObject(graph->grow->ctx, &first);
  if (ODD(sts))
    *return_int = (long int)first;
  else
    *return_int = 0;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int graph_getnextobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  grow_tObject next;
  int sts;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  sts = grow_GetNextObject(
      graph->grow->ctx, (grow_tObject)arg_list->value_int, &next);
  if (ODD(sts))
    *return_int = (long int)next;
  else
    *return_int = 0;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int graph_groupgetfirstobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  grow_tObject first;
  int sts;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  sts = grow_GroupGetFirstObject((grow_tObject)arg_list->value_int, &first);
  if (ODD(sts))
    *return_int = (long int)first;
  else
    *return_int = 0;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int graph_groupgetnextobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  grow_tObject next;
  int sts;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  sts = grow_GroupGetNextObject((grow_tObject)arg_list->value_int,
      (grow_tObject)arg_p2->value_int, &next);
  if (ODD(sts))
    *return_int = (long int)next;
  else
    *return_int = 0;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int graph_dashinsertobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  int sts;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  sts = grow_DashInsertObject((grow_tObject)arg_list->value_int,
      (grow_tObject)arg_p2->value_int);
  *return_int = sts;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int graph_groupselected_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  grow_tObject group;
  char last_group_name[80];
  int sts;

  if (arg_count != 0)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  sts = grow_GroupSelect(graph->grow->ctx, &group, last_group_name);
  if (EVEN(sts)) {
    *return_int = 0;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  GeDyn* dyn = new GeDyn(graph);
  grow_SetUserData(group, (void*)dyn);

  grow_SetModified(graph->grow->ctx, 1);

  *return_int = (ccm_tInt)group;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int graph_getobjecttype_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  int type;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  type = grow_GetObjectType((grow_tObject)arg_list->value_int);
  *return_int = type;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int graph_getobjectclass_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  grow_tNodeClass classid;
  char name[80];

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  *return_decl = CCM_DECL_STRING;

  grow_GetObjectClass((grow_tObject)arg_list->value_int, &classid);
  if (classid != 0) {
    grow_GetNodeClassName(classid, name, sizeof(name));
    strcpy(return_string, name);
  } else
    strcpy(return_string, "");
  return 1;
}

static int graph_getobjectfill_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  *return_int = grow_GetObjectFill((grow_tObject)arg_list->value_int);
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_setobjectfill_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetObjectFill((grow_tObject)arg_list->value_int, arg_p2->value_int);
  return 1;
}

static int graph_getobjectborder_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  *return_int = grow_GetObjectBorder((grow_tObject)arg_list->value_int);
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_setobjectborder_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetObjectBorder((grow_tObject)arg_list->value_int, arg_p2->value_int);
  return 1;
}

static int graph_getobjectgradient_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  *return_int = grow_GetObjectGradient((grow_tObject)arg_list->value_int);
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_setobjectgradient_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetObjectGradient(
      (grow_tObject)arg_list->value_int, (glow_eGradient)arg_p2->value_int);
  return 1;
}

static int graph_getobjectfillcolor_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  *return_int
      = (long int)grow_GetObjectFillColor((grow_tObject)arg_list->value_int);
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_setobjectfillcolor_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetObjectOriginalFillColor(
      (grow_tObject)arg_list->value_int, (glow_eDrawType)arg_p2->value_int);
  return 1;
}

static int graph_getobjectbordercolor_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  *return_int
      = (long int)grow_GetObjectBorderColor((grow_tObject)arg_list->value_int);
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_setobjectbordercolor_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetObjectOriginalBorderColor(
      (grow_tObject)arg_list->value_int, (glow_eDrawType)arg_p2->value_int);
  return 1;
}

static int graph_getobjecttextcolor_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  *return_int
      = (long int)grow_GetObjectTextColor((grow_tObject)arg_list->value_int);
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_setobjecttextcolor_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetObjectOriginalTextColor(
      (grow_tObject)arg_list->value_int, (glow_eDrawType)arg_p2->value_int);
  return 1;
}

static int graph_setobjectbackgroundcolor_func(void* filectx,
    ccm_sArg* arg_list, int arg_count, int* return_decl,
    ccm_tFloat* return_float, ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetObjectOriginalBackgroundColor(
      (grow_tObject)arg_list->value_int, (glow_eDrawType)arg_p2->value_int);
  return 1;
}

static int graph_setobjectlinewidth_func(void* filectx,
    ccm_sArg* arg_list, int arg_count, int* return_decl,
    ccm_tFloat* return_float, ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetObjectLinewidth(
      (grow_tObject)arg_list->value_int, arg_p2->value_int);
  return 1;
}

static int graph_setobjectlinetype_func(void* filectx,
    ccm_sArg* arg_list, int arg_count, int* return_decl,
    ccm_tFloat* return_float, ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetObjectLinetype(
      (grow_tObject)arg_list->value_int, (glow_eLineType) arg_p2->value_int);
  return 1;
}

static int graph_getobjectshadow_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  *return_int = grow_GetObjectShadow((grow_tObject)arg_list->value_int);
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_setobjectshadow_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetObjectShadow((grow_tObject)arg_list->value_int, arg_p2->value_int);
  return 1;
}

static int graph_setcurrentobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  graph->current_cmd_object = (grow_tObject)arg_list->value_int;
  return 1;
}

static int graph_getobjectname_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  char name[80];
  int sts;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

#if 0
  type = grow_GetObjectType((grow_tObject)arg_list->value_int);
  if (type == glow_eObjectType_GrowNode || type == glow_eObjectType_GrowSlider
      || type == glow_eObjectType_GrowGroup
      || type == glow_eObjectType_GrowToolbar) {
    sts = grow_GetObjectName((grow_tObject)arg_list->value_int, name, sizeof(name),
        glow_eName_Object);
    strcpy(return_string, name);
  } else
    strcpy(return_string, "");
#endif
  sts = grow_GetObjectName((grow_tObject)arg_list->value_int, name, sizeof(name),
      glow_eName_Object);
  if (ODD(sts))
    strcpy(return_string, name);    
  else
    strcpy(return_string, "");

  *return_decl = CCM_DECL_STRING;
  return 1;
}

static int graph_setobjectname_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_SetObjectName((grow_tObject)arg_list->value_int, arg_p2->value_string);
  return 1;
}

static int graph_getobjectdyntype_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  int type;
  ccm_sArg* arg_p2; // Dyntype1 return
  ccm_sArg* arg_p3 = NULL; // Dyntype2 return
  ccm_sArg* arg_p4 = NULL; // Actiontype1 return
  ccm_sArg* arg_p5 = NULL; // Actiontype2 return
  GeDyn* dyn;
  grow_tObject o;

  if (arg_count < 2 || arg_count > 5)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  if (arg_count > 2)
    arg_p3 = arg_p2->next;
  if (arg_count > 3)
    arg_p4 = arg_p3->next;
  if (arg_count > 4)
    arg_p5 = arg_p4->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_count > 2 && arg_p3->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_count > 3 && arg_p4->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_count > 4 && arg_p5->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  o = (grow_tObject)arg_list->value_int;
  graph_get_stored_graph(&graph);

  type = grow_GetObjectType(o);
  if (type == glow_eObjectType_GrowNode || type == glow_eObjectType_GrowSlider
      || type == glow_eObjectType_GrowGroup
      || type == glow_eObjectType_GrowToolbar) {
    grow_GetUserData(o, (void**)&dyn);
    arg_p2->value_int = dyn->get_dyntype1(o);
    arg_p2->value_returned = 1;
    if (arg_count > 2) {
      arg_p3->value_int = dyn->get_dyntype2(o);
      arg_p3->value_returned = 1;
    }
    if (arg_count > 3) {
      arg_p4->value_int = dyn->get_actiontype1(o);
      arg_p4->value_returned = 1;
    }
    if (arg_count > 4) {
      arg_p5->value_int = dyn->get_actiontype2(o);
      arg_p5->value_returned = 1;
    }
  } else {
    arg_p2->value_int = 0;
    arg_p2->value_returned = 1;
    if (arg_count > 2) {
      arg_p3->value_int = 0;
      arg_p3->value_returned = 1;
    }
    if (arg_count > 3) {
      arg_p4->value_int = 0;
      arg_p4->value_returned = 1;
    }
    if (arg_count > 4) {
      arg_p5->value_int = 0;
      arg_p5->value_returned = 1;
    }
  }
  return 1;
}

static int graph_getobjecttext_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  int type;
  grow_tObject o;
  char text[K_STRING_SIZE];

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  o = (grow_tObject)arg_list->value_int;
  graph_get_stored_graph(&graph);

  type = grow_GetObjectType(o);
  if (type == glow_eObjectType_GrowText) {
    grow_GetObjectText(o, text, sizeof(text));
    strncpy(return_string, text, sizeof(K_STRING_SIZE));
  } else
    strcpy(return_string, "");

  *return_decl = CCM_DECL_STRING;
  return 1;
}

static int graph_setobjecttext_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  int type;
  grow_tObject o;
  ccm_sArg* arg_p2; // Text

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  o = (grow_tObject)arg_list->value_int;
  graph_get_stored_graph(&graph);

  type = grow_GetObjectType(o);
  if (type == glow_eObjectType_GrowText) {
    grow_SetObjectText(o, arg_p2->value_string);
  }
  return 1;
}

static int graph_findobjectbyname_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  grow_tObject object;
  int sts;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  sts = grow_FindObjectByName(
      graph->grow->ctx, arg_list->value_string, &object);
  if (ODD(sts))
    *return_int = (long int)object;
  else
    *return_int = 0;
  *return_decl = CCM_DECL_INT;

  return 1;
}

static int graph_reload_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  Graph* graph;
  char name[80];

  if (arg_count != 0)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_GetName(graph->grow->ctx, name);
  if (!streq(name, "")) {
    grow_New(graph->grow->ctx);
    graph->open(name);
  }
  return 1;
}

static int graph_rotateselected_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;
  double angle;
  int rotation_point;

  if (arg_count < 1 || arg_count > 2)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  
  if (arg_count > 1) {
    arg_p2 = arg_list->next;
    if (arg_p2->value_decl != CCM_DECL_INT)
      return CCM__ARGMISM;
    rotation_point = arg_p2->value_int;
  }
  else
    rotation_point = glow_eRotationPoint_Center;

  angle = arg_list->value_float;

  graph_get_stored_graph(&graph);

  grow_RotateSelectedObjects(graph->grow->ctx, angle, (glow_eRotationPoint)rotation_point);

  return 1;
}

static int graph_setselecttextsize_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  
  graph_get_stored_graph(&graph);

  grow_SetSelectTextSize(graph->grow->ctx, arg_list->value_int);

  return 1;
}

static int graph_setselecttextfont_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  
  graph_get_stored_graph(&graph);

  grow_SetSelectTextFont(graph->grow->ctx, (glow_eFont)arg_list->value_int);

  return 1;
}

static int graph_setselecttextbold_func(void* filectx, ccm_sArg* arg_list, int arg_count,
    int* return_decl, ccm_tFloat* return_float, ccm_tInt* return_int,
    char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  
  graph_get_stored_graph(&graph);

  grow_SetSelectTextBold(graph->grow->ctx, arg_list->value_int);

  return 1;
}

static int graph_setgraphattribute_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;
  int i, j;
  grow_sAttrInfo* grow_info = 0;
  grow_sAttrInfo* grow_info_sub = NULL;
  grow_sAttrInfo* grow_info_p = NULL;
  int grow_info_cnt;
  char attr_name[80];
  int i_value;
  float f_value;
  double d_value;
  int sts;
  int found;

  char transtab[][32] = { "DynType1", "DynType1", "DynType2", "DynType2",
    "DynActionType1", "Action", "DynColor1", "Color1", "DynColor2", "Color2",
    "DynColor3", "Color3", "DynColor4", "Color4", "DynAttr1", "AnimSequence",
    "DynAttr2", "", "DynAttr3", "", "DynAttr4", "", "Dynamic", "", "" };

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  found = 0;
  for (j = 0; j < 2; j++) {
    if (j == 0) {
      grow_GetSubGraphAttrInfo(
	graph->grow->ctx, (char*)transtab, &grow_info_sub, &grow_info_cnt);
      grow_info_p = grow_info_sub;
    } else {
      grow_GetGraphAttrInfo(graph->grow->ctx, &grow_info, &grow_info_cnt);
      grow_info_p = grow_info;
    }
    for (i = 0; i < grow_info_cnt; i++) {
      // str_ToUpper( attr_name, grow_info_p->name);
      strcpy(attr_name, grow_info_p->name);
      if (str_NoCaseStrcmp(arg_list->value_string, attr_name) == 0) {
	found = 1;
	break;
      }
      grow_info_p++;
    }
    if (found)
      break;
  }
  if (!found) {
    grow_FreeSubGraphAttrInfo(grow_info_sub);
    if (grow_info)
      grow_FreeGraphAttrInfo(grow_info);
    *return_int = GE__NOATTR;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  switch (grow_info_p->type) {
  case glow_eType_Int:
  case glow_eType_Boolean:
    i_value = arg_p2->value_int;
    memcpy(grow_info_p->value_p, (char*)&i_value, sizeof(i_value));
    break;
  case glow_eType_Double:
    f_value = arg_p2->value_float;
    d_value = double(f_value);
    memcpy(grow_info_p->value_p, (char*)&d_value, sizeof(d_value));
    break;
  case glow_eType_String:
    strncpy((char*)grow_info_p->value_p, arg_p2->value_string, grow_info_p->size);
    break;
  case glow_eType_TraceColor:
    grow_info_p->type = glow_eType_Color;
  case glow_eType_Direction:
  case glow_eType_Color:
  case glow_eType_Tone:
  case glow_eType_ToneOrColor:
  case glow_eType_Cycle:
  case glow_eType_MB3Action:
  case ge_eAttrType_AnimSequence:
  case ge_eAttrType_LimitType:
  case glow_eType_Relief:
  case glow_eType_InputFocusMark:
  case ge_eAttrType_ScaleType:
  case glow_eType_Adjustment:
  case glow_eType_Font:
  case ge_eAttrType_CurveDataType:
  case glow_eType_Gradient:
  case glow_eType_HotIndication:
  case glow_eType_AppMotion:
  case glow_eType_AnnotType:
  case ge_eAttrType_OptionMenuType: {
    int value;
    sts = AttrNav::string_to_enum(grow_info_p->type, arg_p2->value_string, &value);
    if (EVEN(sts)) {
      grow_FreeSubGraphAttrInfo(grow_info_sub);
      if (grow_info)
	grow_FreeGraphAttrInfo(grow_info);
      *return_int = GE__SYNTAX;
      *return_decl = CCM_DECL_INT;
      return 1;
    }
    memcpy(grow_info_p->value_p, (char*)&value, sizeof(value));
    break;
  }
  case glow_eType_TextSize: {
    int value;
    sts = AttrNav::string_to_enum(grow_info_p->type, arg_p2->value_string, &value);
    if (EVEN(sts)) {
      grow_FreeSubGraphAttrInfo(grow_info_sub);
      if (grow_info)
	grow_FreeGraphAttrInfo(grow_info);
      *return_int = GE__SYNTAX;
      *return_decl = CCM_DECL_INT;
      return 1;
    }
    memcpy(grow_info_p->value_p, (char*)&value, sizeof(value));
    break;
  }
  case glow_eType_Access:
  case ge_eAttrType_DynType1:
  case ge_eAttrType_DynType2:
  case ge_eAttrType_ActionType1:
  case ge_eAttrType_InputFocus: {
    unsigned int value;
    sts = AttrNav::string_to_mask(grow_info_p->type, arg_p2->value_string, &value);
    if (EVEN(sts)) {
      grow_FreeSubGraphAttrInfo(grow_info_sub);
      if (grow_info)
	grow_FreeGraphAttrInfo(grow_info);
      *return_int = GE__SYNTAX;
      *return_decl = CCM_DECL_INT;
      return 1;
    }
    memcpy(grow_info_p->value_p, (char*)&value, sizeof(value));
    break;
  }
  default:;
  }
  
  grow_FreeSubGraphAttrInfo(grow_info_sub);
  if (grow_info)
    grow_FreeGraphAttrInfo(grow_info);

  *return_int = GE__SUCCESS;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_getgraphattribute_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;
  int i, j;
  grow_sAttrInfo* grow_info = 0;
  grow_sAttrInfo* grow_info_sub = NULL;
  grow_sAttrInfo* grow_info_p = NULL;
  int grow_info_cnt;
  char attr_name[80];
  int i_value;
  double d_value;
  int sts;
  int found;

  char transtab[][32] = { "DynType1", "DynType1", "DynType2", "DynType2",
    "DynActionType1", "Action", "DynColor1", "Color1", "DynColor2", "Color2",
    "DynColor3", "Color3", "DynColor4", "Color4", "DynAttr1", "AnimSequence",
    "DynAttr2", "", "DynAttr3", "", "DynAttr4", "", "Dynamic", "", "" };

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  found = 0;
  for (j = 0; j < 2; j++) {
    if (j == 0) {
      grow_GetSubGraphAttrInfo(
	graph->grow->ctx, (char*)transtab, &grow_info_sub, &grow_info_cnt);
      grow_info_p = grow_info_sub;
    } else {
      grow_GetGraphAttrInfo(graph->grow->ctx, &grow_info, &grow_info_cnt);
      grow_info_p = grow_info;
    }
    for (i = 0; i < grow_info_cnt; i++) {
      // str_ToUpper( attr_name, grow_info_p->name);
      strcpy(attr_name, grow_info_p->name);
      if (str_NoCaseStrcmp(arg_list->value_string, attr_name) == 0) {
	found = 1;
	break;
      }
      grow_info_p++;
    }
    if (found)
      break;
  }
  if (!found) {
    grow_FreeSubGraphAttrInfo(grow_info_sub);
    if (grow_info)
      grow_FreeGraphAttrInfo(grow_info);
    *return_int = GE__NOATTR;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  switch (grow_info_p->type) {
  case glow_eType_Int:
  case glow_eType_Boolean:
    memcpy((char*)&i_value, grow_info_p->value_p, sizeof(i_value));
    i_value = arg_p2->value_int = i_value;
    arg_p2->value_returned = 1;
    arg_p2->value_decl = CCM_DECL_INT;
    break;
  case glow_eType_Double:
    memcpy((char*)&d_value, grow_info_p->value_p, sizeof(d_value));
    arg_p2->value_float = float(d_value);
    arg_p2->value_returned = 1;
    arg_p2->value_decl = CCM_DECL_FLOAT;
    break;
  case glow_eType_String:
    strncpy(arg_p2->value_string, (char*)grow_info_p->value_p, grow_info_p->size);
    break;
  case glow_eType_TraceColor:
    grow_info_p->type = glow_eType_Color;
  case glow_eType_Direction:
  case glow_eType_Color:
  case glow_eType_Tone:
  case glow_eType_ToneOrColor:
  case glow_eType_Cycle:
  case glow_eType_MB3Action:
  case ge_eAttrType_AnimSequence:
  case ge_eAttrType_LimitType:
  case glow_eType_Relief:
  case glow_eType_InputFocusMark:
  case ge_eAttrType_ScaleType:
  case glow_eType_Adjustment:
  case glow_eType_Font:
  case ge_eAttrType_CurveDataType:
  case glow_eType_Gradient:
  case glow_eType_HotIndication:
  case glow_eType_AppMotion:
  case glow_eType_AnnotType:
  case ge_eAttrType_OptionMenuType: {
    int value;
    memcpy((char*)&value, grow_info_p->value_p, sizeof(value));
    arg_p2->value_int = value;
    sts = AttrNav::enum_to_string(grow_info_p->type, value, arg_p2->value_string,
				  sizeof(arg_p2->value_string));
    if (EVEN(sts)) {
      grow_FreeSubGraphAttrInfo(grow_info_sub);
      if (grow_info)
	grow_FreeGraphAttrInfo(grow_info);
      *return_int = GE__SYNTAX;
      *return_decl = CCM_DECL_INT;
      return 1;
    }
    arg_p2->value_returned = 1;
    arg_p2->value_decl = CCM_DECL_STRING;
    break;
  }
  case glow_eType_TextSize: {
    int value;
    sts = AttrNav::string_to_enum(grow_info_p->type, arg_p2->value_string, &value);
    if (EVEN(sts)) {
      grow_FreeSubGraphAttrInfo(grow_info_sub);
      if (grow_info)
	grow_FreeGraphAttrInfo(grow_info);
      *return_int = GE__SYNTAX;
      *return_decl = CCM_DECL_INT;
      return 1;
    }
    memcpy(grow_info_p->value_p, (char*)&value, sizeof(value));
    arg_p2->value_returned = 1;
    arg_p2->value_decl = CCM_DECL_STRING;
    break;
  }
  case glow_eType_Access:
  case ge_eAttrType_DynType1:
  case ge_eAttrType_DynType2:
  case ge_eAttrType_ActionType1:
  case ge_eAttrType_InputFocus: {
    unsigned int value;
    memcpy((char*)&value, grow_info_p->value_p, sizeof(value));
    arg_p2->value_int = value;
    arg_p2->value_returned = 1;
    arg_p2->value_decl = CCM_DECL_INT;
    break;
  }
  default:;
  }
  
  grow_FreeSubGraphAttrInfo(grow_info_sub);
  if (grow_info)
    grow_FreeGraphAttrInfo(grow_info);

  *return_int = GE__SUCCESS;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static void trim_script(char *out, char *in)
{
  char *s = in;
  char *t = out;
  while(*s) {
    if (*s == '\\' && *(s+1) == '\"') {
      *t = '\"';
      s++;
    }
    else if (*s == '\\' && *(s+1) == '\\' && *(s+2) == 'n') {
      *t = '\n';
      s += 2;
    }
    else 
      *t = *s;
    s++;
    t++;
  }
  *t = 0;
}

static int graph_setobjectattribute_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  int type;
  ccm_sArg* arg_p2; // Attribute
  ccm_sArg* arg_p3; // Attribute value
  grow_tObject o;

  if (arg_count != 3)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  o = (grow_tObject)arg_list->value_int;
  if (!o) {
    *return_int = GE__ARG;
    *return_decl = CCM_DECL_INT;
    return 1;
  }
  graph_get_stored_graph(&graph);

  type = grow_GetObjectType(o);
  if (type == glow_eObjectType_GrowNode 
      || type == glow_eObjectType_GrowSlider
      || type == glow_eObjectType_GrowGroup
      || type == glow_eObjectType_GrowToolbar
      || type == glow_eObjectType_GrowTable
      || type == glow_eObjectType_GrowWindow
      || type == glow_eObjectType_GrowFolder 
      || type == glow_eObjectType_GrowBar
      || type == glow_eObjectType_GrowBarArc
      || type == glow_eObjectType_GrowXYCurve
      || type == glow_eObjectType_GrowPie
      || type == glow_eObjectType_GrowBarChart
      || type == glow_eObjectType_GrowAxis
      || type == glow_eObjectType_GrowAxisArc
      || type == glow_eObjectType_GrowTrend 
      || type == glow_eObjectType_GrowRect
      || type == glow_eObjectType_GrowRectRounded
      || type == glow_eObjectType_GrowArc
      || type == glow_eObjectType_GrowLine
      || type == glow_eObjectType_GrowPolyLine
      || type == glow_eObjectType_GrowText
      || type == glow_eObjectType_GrowImage) {
    attr_sItem* itemlist;
    attr_sItem* item_p;
    int item_cnt;
    void* client_data;
    char attr_name[80];
    int i_value;
    float f_value;
    double d_value;
    int i;
    int sts;
    int found;
    GeDyn* dyn;

    graph->get_attr_items(o, &itemlist, &item_cnt, &client_data);

    found = 0;
    item_p = itemlist;
    for (i = 0; i < item_cnt; i++) {
      strcpy(attr_name, item_p->name);
      if (item_p->type == ge_eAttrType_Dyn) {
	if (str_NoCaseStrncmp(arg_p2->value_string, attr_name, strlen(attr_name)) == 0 &&
	    arg_p2->value_string[strlen(attr_name)] == '.') {
	  found = 1;
	  break;
	}
      }
      else {
	if (str_NoCaseStrcmp(arg_p2->value_string, attr_name) == 0) {
	  found = 1;
	  break;
	}
      }
      item_p++;
    }

    if (!found) {
      *return_decl = CCM_DECL_INT;
      *return_int = GE__NOATTR;
      return 1;
    }

    switch (item_p->type) {
    case glow_eType_Int:
    case glow_eType_TraceColor:
    case glow_eType_Boolean:
      if (arg_p3->value_decl != CCM_DECL_INT)
        return CCM__ARGMISM;

      i_value = arg_p3->value_int;
      memcpy(item_p->value, (char*)&i_value, sizeof(i_value));
      break;
    case glow_eType_Float:
      if (arg_p3->value_decl != CCM_DECL_FLOAT)
        return CCM__ARGMISM;

      f_value = arg_p3->value_float;
      memcpy(item_p->value, (char*)&f_value, sizeof(f_value));
      break;
    case glow_eType_Double:
      if (arg_p3->value_decl != CCM_DECL_FLOAT)
        return CCM__ARGMISM;

      d_value = double(arg_p3->value_float);
      memcpy(item_p->value, (char*)&d_value, sizeof(d_value));
      break;
    case glow_eType_String: {
      char str[K_STRING_SIZE];

      if (arg_p3->value_decl != CCM_DECL_STRING)
        return CCM__ARGMISM;
      trim_script(str, arg_p3->value_string);
      strncpy((char*)item_p->value, str, item_p->size);
      break;
    }
    case glow_eType_Direction:
    case glow_eType_HorizDirection:
    case glow_eType_Adjustment:
    case glow_eType_AnnotType:
    case glow_eType_Font:
    case glow_eType_Color:
    case glow_eType_Tone:
    case glow_eType_ToneOrColor:
    case glow_eType_Cycle:
    case glow_eType_MB3Action:
    case glow_eType_InputFocusMark:
    case glow_eType_Relief:
    //case glow_eType_TextSize:
    case glow_eType_Gradient:
    case glow_eType_HotIndication:
    case glow_eType_AppMotion:
    case ge_eAttrType_AnimSequence:
    case ge_eAttrType_LimitType:
    case ge_eAttrType_ScaleType:
    case ge_eAttrType_CurveDataType:
    case ge_eAttrType_OptionMenuType:
    case ge_eAttrType_MethodsMenuType:
    case ge_eAttrType_MethodToolbarType:
    case ge_eAttrType_KeyboardType: {
      int value;

      if (!(arg_p3->value_decl == CCM_DECL_INT
              || arg_p3->value_decl == CCM_DECL_STRING))
        return CCM__ARGMISM;

      if (arg_p3->value_decl == CCM_DECL_INT) {
        value = arg_p3->value_int;
      } else {
        sts = AttrNav::string_to_enum(
            item_p->type, arg_p3->value_string, &value);
        if (EVEN(sts)) {
          *return_int = GE__SYNTAX;
          *return_decl = CCM_DECL_INT;
          return 1;
        }
      }
      memcpy(item_p->value, (char*)&value, sizeof(value));
      break;
    }
    case glow_eType_TextSize: {
      int value;
      char str[40];

      if (!(arg_p3->value_decl == CCM_DECL_INT
              || arg_p3->value_decl == CCM_DECL_STRING))
        return CCM__ARGMISM;

      if (arg_p3->value_decl == CCM_DECL_INT)
        sprintf(str, "%d", (int)arg_p3->value_int);
      else
        strncpy(str, arg_p3->value_string, sizeof(str));

      sts = AttrNav::string_to_enum(item_p->type, str, &value);
      if (EVEN(sts)) {
        *return_int = GE__SYNTAX;
        *return_decl = CCM_DECL_INT;
        return 1;
      }
      memcpy(item_p->value, (char*)&value, sizeof(value));
      break;
    }
    case glow_eType_Access:
    case ge_eAttrType_DynType1:
    case ge_eAttrType_DynType2:
    case ge_eAttrType_ActionType1:
    case ge_eAttrType_ActionType2:
    case ge_eAttrType_InstanceMask:
    case ge_eAttrType_InputFocus: {
      unsigned int value;

      if (!(arg_p3->value_decl == CCM_DECL_INT
              || arg_p3->value_decl == CCM_DECL_STRING))
        return CCM__ARGMISM;

      if (arg_p3->value_decl == CCM_DECL_INT)
        value = arg_p3->value_int;
      else {
        sts = AttrNav::string_to_mask(
            item_p->type, arg_p3->value_string, &value);
        if (EVEN(sts)) {
          return GE__SYNTAX;
        }
      }
      memcpy(item_p->value, (char*)&value, sizeof(value));
      if (item_p->type == ge_eAttrType_DynType1
          || item_p->type == ge_eAttrType_DynType2
          || item_p->type == ge_eAttrType_ActionType1
          || item_p->type == ge_eAttrType_ActionType2) {
        grow_GetUserData(o, (void**)&dyn);
	dyn->update_dyntype(o);
        dyn->update_elements();
      }
      break;
    }
    case ge_eAttrType_Dyn: {
      attr_sItem dyn_itemlist[100];
      attr_sItem *dyn_item_p;
      int dyn_itemlist_cnt = 0;
      int j;
      char *dyn_attr_name;
      int dyn_found;

      dyn = (GeDyn *)item_p->value;
      if (!dyn) {
	dyn = new GeDyn(graph);
	item_p->value = &dyn;
      }
      dyn->get_attributes(0, dyn_itemlist, &dyn_itemlist_cnt);
      dyn_found = 0;
      dyn_attr_name = &arg_p2->value_string[strlen(attr_name)+1];
      dyn_item_p = dyn_itemlist;
      for (j = 0; j < dyn_itemlist_cnt; j++) {
	if (str_NoCaseStrcmp(dyn_attr_name, dyn_item_p->name) == 0) {
	  dyn_found = 1;
	  break;
	}
	dyn_item_p++;
      }
      if (dyn_found) {
	if (arg_p3->value_decl == CCM_DECL_INT) {
	  int value;
	  value = arg_p3->value_int;
	  memcpy(dyn_item_p->value, (char*)&value, sizeof(value));
	  if (dyn_item_p->type == ge_eAttrType_DynType1
	      || dyn_item_p->type == ge_eAttrType_DynType2
	      || dyn_item_p->type == ge_eAttrType_ActionType1
	      || dyn_item_p->type == ge_eAttrType_ActionType2)
	    dyn->update_elements();
	}
	else if (arg_p3->value_decl == CCM_DECL_FLOAT) {
	  float fvalue = arg_p3->value_float;
	  memcpy(dyn_item_p->value, (char*)&fvalue, sizeof(fvalue));
	}
	else if (arg_p3->value_decl == CCM_DECL_STRING) {
	  char str[K_STRING_SIZE];

	  trim_script(str, arg_p3->value_string);
	  strncpy((char *)dyn_item_p->value, str, dyn_item_p->size);
	}
      }
      else {
	dyn_item_p = dyn_itemlist;
	for (j = 0; j < dyn_itemlist_cnt; j++) {
	  if (str_NoCaseStrncmp(dyn_attr_name, dyn_item_p->name, strlen(dyn_item_p->name)) == 0 &&
	    dyn_attr_name[strlen(dyn_item_p->name)] == '.') {
	    dyn_found = 1;
	    break;
	  }
	  dyn_item_p++;
	}

	if (dyn_found) {
	  if (dyn_item_p->type == ge_eAttrType_Dyn) {
	    attr_sItem dyn2_itemlist[100];
	    attr_sItem *dyn2_item_p;
	    int dyn2_itemlist_cnt = 0;
	    int j;
	    char *dyn2_attr_name;
	    int dyn2_found;
	    
	    dyn = (GeDyn *)dyn_item_p->value;
	    if (!dyn) {
	      dyn = new GeDyn(graph);
	      dyn_item_p->value = &dyn;
	    }
	    dyn->get_attributes(0, dyn2_itemlist, &dyn2_itemlist_cnt);
	    dyn2_found = 0;
	    dyn2_attr_name = &dyn_attr_name[strlen(dyn_item_p->name)+1];
	    dyn2_item_p = dyn2_itemlist;
	    for (j = 0; j < dyn2_itemlist_cnt; j++) {
	      if (str_NoCaseStrcmp(dyn2_attr_name, dyn2_item_p->name) == 0) {
		dyn2_found = 1;
		break;
	      }
	      dyn2_item_p++;
	    }
	    if (dyn2_found) {
	      if (arg_p3->value_decl == CCM_DECL_INT) {
		int value;
		value = arg_p3->value_int;
		memcpy(dyn2_item_p->value, (char*)&value, sizeof(value));
		if (dyn2_item_p->type == ge_eAttrType_DynType1
		    || dyn2_item_p->type == ge_eAttrType_DynType2
		    || dyn2_item_p->type == ge_eAttrType_ActionType1
		    || dyn2_item_p->type == ge_eAttrType_ActionType2)
		  dyn->update_elements();
	      }
	      else if (arg_p3->value_decl == CCM_DECL_FLOAT) {
		float fvalue = arg_p3->value_float;
		memcpy(dyn2_item_p->value, (char*)&fvalue, sizeof(fvalue));
	      }
	      else if (arg_p3->value_decl == CCM_DECL_STRING) {
		char str[K_STRING_SIZE];
		
		trim_script(str, arg_p3->value_string);
		strncpy((char *)dyn2_item_p->value, str, dyn2_item_p->size);
	      }
	    }
	  }
	}
      }
    }
    default:;
    }
    grow_UpdateObject(graph->grow->ctx, o, (grow_sAttrInfo*)client_data);
    grow_FreeObjectAttrInfo((grow_sAttrInfo*)client_data);
  }
  *return_int = 1;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_getobjectattribute_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  int type;
  ccm_sArg* arg_p2; // Attribute
  ccm_sArg* arg_p3; // Attribute value
  grow_tObject o;

  if (arg_count != 3)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  o = (grow_tObject)arg_list->value_int;
  graph_get_stored_graph(&graph);

  type = grow_GetObjectType(o);
  if (type == glow_eObjectType_GrowNode 
      || type == glow_eObjectType_GrowSlider
      || type == glow_eObjectType_GrowGroup
      || type == glow_eObjectType_GrowToolbar
      || type == glow_eObjectType_GrowTable
      || type == glow_eObjectType_GrowWindow
      || type == glow_eObjectType_GrowFolder 
      || type == glow_eObjectType_GrowBar
      || type == glow_eObjectType_GrowBarArc
      || type == glow_eObjectType_GrowXYCurve
      || type == glow_eObjectType_GrowPie
      || type == glow_eObjectType_GrowBarChart
      || type == glow_eObjectType_GrowAxis
      || type == glow_eObjectType_GrowAxisArc
      || type == glow_eObjectType_GrowTrend 
      || type == glow_eObjectType_GrowRect
      || type == glow_eObjectType_GrowRectRounded
      || type == glow_eObjectType_GrowArc
      || type == glow_eObjectType_GrowLine
      || type == glow_eObjectType_GrowPolyLine
      || type == glow_eObjectType_GrowText
      || type == glow_eObjectType_GrowImage
      || type == glow_eObjectType_GrowDashCell) {
    attr_sItem* itemlist;
    attr_sItem* item_p;
    int item_cnt;
    void* client_data;
    char attr_name[80];
    pwr_tInt32 i32_value;
    pwr_tInt64 i64_value;
    double d_value;
    float f_value;
    int i;
    int sts;
    int found;

    graph->get_attr_items(o, &itemlist, &item_cnt, &client_data);

    found = 0;
    item_p = itemlist;
    for (i = 0; i < item_cnt; i++) {
      strcpy(attr_name, item_p->name);
      if (item_p->type == ge_eAttrType_Dyn) {
	if (str_NoCaseStrncmp(arg_p2->value_string, attr_name, strlen(attr_name)) == 0) {
	  found = 1;
	  break;
	}
      }
      else {
	if (str_NoCaseStrcmp(arg_p2->value_string, attr_name) == 0) {
	  found = 1;
	  break;
	}
      }
      item_p++;
    }

    if (!found) {
      *return_decl = CCM_DECL_INT;
      *return_int = GE__NOATTR;
      return 1;
    }

    switch (item_p->type) {
    case glow_eType_Int:
    case glow_eType_TraceColor:
    case glow_eType_Boolean:
      if (arg_p3->value_decl != CCM_DECL_INT)
        return CCM__ARGMISM;

      if (item_p->size == 4) {
	memcpy(&i32_value, item_p->value, sizeof(i32_value));
	arg_p3->value_int = i32_value;
      }
      else {
	memcpy(&i64_value, item_p->value, sizeof(i64_value));
	arg_p3->value_int = i64_value;	
      }
      arg_p3->value_returned = 1;
      break;
    case glow_eType_Float:
      if (arg_p3->value_decl != CCM_DECL_FLOAT)
        return CCM__ARGMISM;

      memcpy((char*)&f_value, item_p->value, sizeof(f_value));
      arg_p3->value_float = f_value;
      arg_p3->value_returned = 1;
      break;
    case glow_eType_Double:
      if (arg_p3->value_decl != CCM_DECL_FLOAT)
        return CCM__ARGMISM;

      memcpy((char*)&d_value, item_p->value, sizeof(d_value));
      arg_p3->value_float = (float)d_value;
      arg_p3->value_returned = 1;
      break;
    case glow_eType_String:
      if (arg_p3->value_decl != CCM_DECL_STRING)
        return CCM__ARGMISM;
      strncpy(arg_p3->value_string, (char*)item_p->value,
          MIN(item_p->size, (int)sizeof(arg_p3->value_string)));
      arg_p3->value_returned = 1;
      break;
    case glow_eType_Direction:
    case glow_eType_HorizDirection:
    case glow_eType_Adjustment:
    case glow_eType_AnnotType:
    case glow_eType_Font:
    case glow_eType_Color:
    case glow_eType_Tone:
    case glow_eType_ToneOrColor:
    case glow_eType_Cycle:
    case glow_eType_MB3Action:
    case glow_eType_InputFocusMark:
    case glow_eType_Relief:
    // case glow_eType_TextSize:
    case glow_eType_Gradient:
    case glow_eType_HotIndication:
    case glow_eType_AppMotion:
    case ge_eAttrType_AnimSequence:
    case ge_eAttrType_LimitType:
    case ge_eAttrType_ScaleType:
    case ge_eAttrType_CurveDataType:
    case ge_eAttrType_OptionMenuType:
    case ge_eAttrType_MethodsMenuType:
    case ge_eAttrType_MethodToolbarType:
    case ge_eAttrType_KeyboardType: {
      int value;

      if (!(arg_p3->value_decl == CCM_DECL_INT
              || arg_p3->value_decl == CCM_DECL_STRING))
        return CCM__ARGMISM;

      memcpy((char*)&value, item_p->value, sizeof(value));

      if (arg_p3->value_decl == CCM_DECL_INT) {
        arg_p3->value_int = value;
        arg_p3->value_returned = 1;
      } else {
        sts = AttrNav::enum_to_string(item_p->type, value, arg_p3->value_string,
            sizeof(arg_p3->value_string));
        if (EVEN(sts)) {
          *return_int = GE__SYNTAX;
          *return_decl = CCM_DECL_INT;
          return 1;
        }
        arg_p3->value_returned = 1;
      }
      break;
    }
    case glow_eType_TextSize: {
      int value;
      char str[40];

      if (!(arg_p3->value_decl == CCM_DECL_INT
              || arg_p3->value_decl == CCM_DECL_STRING))
        return CCM__ARGMISM;

      memcpy((char*)&value, item_p->value, sizeof(value));
      sts = AttrNav::enum_to_string(item_p->type, value, str, sizeof(str));
      if (EVEN(sts)) {
        *return_int = GE__SYNTAX;
        *return_decl = CCM_DECL_INT;
        return 1;
      }

      if (arg_p3->value_decl == CCM_DECL_INT)
        sscanf(str, "%d", (int*)&arg_p3->value_int);
      else
        strncpy(arg_p3->value_string, str, sizeof(arg_p3->value_string));
      arg_p3->value_returned = 1;
      break;
    }
    case glow_eType_Access:
    case ge_eAttrType_DynType1:
    case ge_eAttrType_DynType2:
    case ge_eAttrType_ActionType1:
    case ge_eAttrType_ActionType2:
    case ge_eAttrType_InstanceMask:
    case ge_eAttrType_InputFocus: {
      unsigned int value;

      if (arg_p3->value_decl != CCM_DECL_INT)
        return CCM__ARGMISM;

      memcpy((char*)&value, item_p->value, sizeof(value));
      arg_p3->value_int = value;
      arg_p3->value_returned = 1;
      arg_p3->var_decl = arg_p3->value_decl;
      break;
    }
    case ge_eAttrType_Dyn: {
      attr_sItem dyn_itemlist[100];
      attr_sItem *dyn_item_p;
      int dyn_itemlist_cnt = 0;
      int j;
      char *dyn_attr_name;
      int dyn_found;
      GeDyn *dyn;

      dyn = (GeDyn *)item_p->value;
      if (!dyn) {
	dyn = new GeDyn(graph);
	item_p->value = &dyn;
      }
      dyn->get_attributes(0, dyn_itemlist, &dyn_itemlist_cnt);
      dyn_found = 0;
      dyn_attr_name = &arg_p2->value_string[strlen(attr_name)+1];
      dyn_item_p = dyn_itemlist;
      for (j = 0; j < dyn_itemlist_cnt; j++) {
	if (str_NoCaseStrcmp(dyn_attr_name, dyn_item_p->name) == 0) {
	  dyn_found = 1;
	  break;
	}
	dyn_item_p++;
      }
      if (dyn_found) {
	switch (dyn_item_p->type) {
	case glow_eType_Int:
	case glow_eType_TraceColor:
	case glow_eType_Boolean:
	case glow_eType_DynType1:
	case glow_eType_DynType2:
	case glow_eType_ActionType1:
	case glow_eType_ActionType2:
	  if (arg_p3->value_decl != CCM_DECL_INT)
	    return CCM__ARGMISM;

	  if (dyn_item_p->size == 4) {
	    memcpy(&i32_value, dyn_item_p->value, sizeof(i32_value));
	    arg_p3->value_int = i32_value;
	  }
	  else {
	    memcpy(&i64_value, dyn_item_p->value, sizeof(i64_value));
	    arg_p3->value_int = i64_value;	
	  }
	  arg_p3->value_returned = 1;
	  break;
	case glow_eType_Float:
	  if (arg_p3->value_decl != CCM_DECL_FLOAT)
	    return CCM__ARGMISM;
	  
	  memcpy((char*)&f_value, dyn_item_p->value, sizeof(f_value));
	  arg_p3->value_float = f_value;
	  arg_p3->value_returned = 1;
	  break;
	case glow_eType_Double:
	  if (arg_p3->value_decl != CCM_DECL_FLOAT)
	    return CCM__ARGMISM;
	  
	  memcpy((char*)&d_value, dyn_item_p->value, sizeof(d_value));
	  arg_p3->value_float = (float)d_value;
	  arg_p3->value_returned = 1;
	  break;
	case glow_eType_String:
	  if (arg_p3->value_decl != CCM_DECL_STRING)
	    return CCM__ARGMISM;
	  strncpy(arg_p3->value_string, (char*)dyn_item_p->value,
		  MIN(dyn_item_p->size, (int)sizeof(arg_p3->value_string)));
	  arg_p3->value_returned = 1;
	}
      }
    }
    default:;
    }
    grow_FreeObjectAttrInfo((grow_sAttrInfo*)client_data);
  }
  *return_int = 1;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_getrgbcolor_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2; // Red
  ccm_sArg* arg_p3; // Green
  ccm_sArg* arg_p4; // Blue
  double r, g, b;

  if (arg_count != 4)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;
  arg_p4 = arg_p3->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p4->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_GetRgbColor(
      graph->grow->ctx, (glow_eDrawType)arg_list->value_int, &r, &g, &b);

  arg_p2->value_float = (float)r;
  arg_p3->value_float = (float)g;
  arg_p4->value_float = (float)b;
  arg_p2->value_returned = 1;
  arg_p3->value_returned = 1;
  arg_p4->value_returned = 1;

  return 1;
}

static int graph_setrgbcolor_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2; // Red
  ccm_sArg* arg_p3; // Green
  ccm_sArg* arg_p4; // Blue
  double r, g, b;

  if (arg_count != 4)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;
  arg_p4 = arg_p3->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p4->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  r = (double)arg_p2->value_float;
  g = (double)arg_p3->value_float;
  b = (double)arg_p4->value_float;

  grow_SetRgbColor(
      graph->grow->ctx, (glow_eDrawType)arg_list->value_int, r, g, b);
  if (graph->update_colorpalette_cb)
    (graph->update_colorpalette_cb)(graph->parent_ctx);

  return 1;
}

static int graph_measureobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2; // ll_x
  ccm_sArg* arg_p3; // ll_y
  ccm_sArg* arg_p4; // ur_x
  ccm_sArg* arg_p5; // ur_y
  double ll_x, ll_y, ur_x, ur_y;

  if (arg_count != 5)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;
  arg_p4 = arg_p3->next;
  arg_p5 = arg_p4->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p4->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p5->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_MeasureNode(
      (grow_tObject)arg_list->value_int, &ll_x, &ll_y, &ur_x, &ur_y);
  arg_p2->value_float = (float)ll_x;
  arg_p3->value_float = (float)ll_y;
  arg_p4->value_float = (float)ur_x;
  arg_p5->value_float = (float)ur_y;
  arg_p2->value_returned = 1;
  arg_p3->value_returned = 1;
  arg_p4->value_returned = 1;
  arg_p5->value_returned = 1;

  return 1;
}

static int graph_deleteobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  graph_get_stored_graph(&graph);

  grow_DeleteObject(graph->grow->ctx, (grow_tObject)arg_list->value_int);

  return 1;
}

static int graph_setobjectclass_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2; // Class
  int sts;
  grow_tNodeClass nc;
  pwr_tFileName cname;

  if (arg_count != 2)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  sts = grow_FindNodeClassByName(graph->grow->ctx, arg_p2->value_string, &nc);
  if (EVEN(sts)) {
    // Load the subgraph

    strcpy(cname, "$pwrp_exe/");
    strncat(cname, arg_p2->value_string, sizeof(cname) - strlen(cname) - 1);
    strncat(cname, ".pwsg", sizeof(cname) - strlen(cname) - 1);

    sts = grow_OpenSubGraph(graph->grow->ctx, cname);
    if (EVEN(sts)) {
      strcpy(cname, "$pwr_exe/");
      strncat(cname, arg_p2->value_string, sizeof(cname) - strlen(cname) - 1);
      strncat(cname, ".pwsg", sizeof(cname) - strlen(cname) - 1);

      sts = grow_OpenSubGraph(graph->grow->ctx, cname);
    }
  }
  sts = grow_FindNodeClassByName(graph->grow->ctx, arg_p2->value_string, &nc);
  if (EVEN(sts)) {
    *return_int = sts;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  sts = grow_SetObjectClass((grow_tNode)arg_list->value_int, nc);
  *return_int = sts;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_scaleobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2; // scale x
  ccm_sArg* arg_p3; // scale y
  double scalex, scaley;
  glow_eScaleType scale_type;
  grow_tObject oid = (grow_tObject)arg_list->value_int;

  if (oid == 0)
    return 1;

  if (arg_count != 3)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  scalex = (double)arg_p2->value_float;
  scaley = (double)arg_p3->value_float;

  scale_type = glow_eScaleType_LowerLeft;

  grow_StoreTransform(oid);
  grow_SetObjectScale(oid, scalex, scaley, 0, 0, scale_type);

  return 1;
}
static int graph_moveobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2; // scale x
  ccm_sArg* arg_p3; // scale y
  double x0, y0;
  grow_tObject oid = (grow_tObject)arg_list->value_int;

  if (oid == 0)
    return 1;

  if (arg_count != 3)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  x0 = (double)arg_p2->value_float;
  y0 = (double)arg_p3->value_float;

  grow_MoveObject(oid, x0, y0);

  return 1;
}

static int graph_moveabsobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2; // scale x
  ccm_sArg* arg_p3; // scale y
  double x0, y0;
  double ll_x, ll_y, ur_x, ur_y;
  grow_tObject oid = (grow_tObject)arg_list->value_int;

  if (oid == 0)
    return 1;

  if (arg_count != 3)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_MeasureNode(oid, &ll_x, &ll_y, &ur_x, &ur_y);

  x0 = (double)arg_p2->value_float - ll_x;
  y0 = (double)arg_p3->value_float - ll_y;

  grow_MoveObject(oid, x0, y0);

  return 1;
}

static int graph_setbackgroundcolor_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  if (arg_list->value_int < 0 || arg_list->value_int >= glow_eDrawType_CustomColor__) {
    *return_int = GE__SYNTAX;
    *return_decl = CCM_DECL_INT;
    return 1;
  }
  grow_SetBackgroundColor(graph->grow->ctx, (glow_eDrawType)arg_list->value_int);
  *return_int = GE__SUCCESS;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_setcolortheme_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count > 1)
    return CCM__ARGMISM;

  if (arg_count > 0) {
    if (arg_list->value_decl != CCM_DECL_INT)
      return CCM__ARGMISM;
  }

  graph_get_stored_graph(&graph);
  
  if (arg_count > 0)
    graph->update_color_theme(arg_list->value_int);
  else
    grow_SetColorTheme(graph->grow->ctx);
  return 1;
}

static int graph_opengraph_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  char name[80];
  pwr_tFileName filename;
  char *s;
  
  if (arg_count != 1)
    return CCM__ARGMISM;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  strncpy(name, arg_list->value_string, sizeof(name));
  if ((s = strrchr(name, '.')))
    *s = 0;
  str_ToLower(filename, name);
  strcat(filename, ".pwg");

  graph_get_stored_graph(&graph);

  graph->set_name(name);
  graph->open(filename);

  return 1;
}

static int graph_savegraph_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  int sts;
  char *s;
  char name[100];
  char oldname[100];
  pwr_tFileName filename;
    
  if (arg_count > 1)
    return CCM__ARGMISM;

  if (arg_count == 1) {
    if (arg_list->value_decl != CCM_DECL_STRING)
      return CCM__ARGMISM;

    strcpy(name, arg_list->value_string);
    if ((s = strchr(name, '.')))
      *s = 0;		 
  }

  graph_get_stored_graph(&graph);

  if (arg_count == 0)
    graph->get_name(name);
  else {
    graph->get_name(oldname);
    if (!streq(name, oldname) && !streq(oldname, ""))
      // Name changed
      graph->set_java_name("");

    graph->set_name(name);
  }
  str_ToLower(filename, name);
  if (!strrchr(filename, '.'))
    strcat(filename, ".pwg");
  
  sts = graph->save(filename);
  *return_int = sts;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_buildgraph_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  int sts = GE__SUCCESS;
  char name[40];
  pwr_tCmd cmd;

  graph_get_stored_graph(&graph);

  graph->get_name(name);

  if (graph->is_modified())
    sts = GE__NOTSAVED;
  else if (streq(name, ""))
    sts = GE__NONAME;
  else {
    sprintf(cmd, "cp -a $pwrp_pop/%s.pwg $pwrp_exe/", name);
    system(cmd);
    if (sts != 0)
      sts = GE__SHELL;
  }

  *return_int = sts;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_clearall_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 0)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);
  graph->clear_all();
  return 1;
}

static int graph_createrectangle_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;
  ccm_sArg* arg_p3;
  ccm_sArg* arg_p4;

  double x, y, width, height;

  if (arg_count != 4)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;
  arg_p4 = arg_p3->next;

  if (arg_list->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p4->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  x = arg_list->value_float;
  y = arg_p2->value_float;
  width = arg_p3->value_float;
  height = arg_p4->value_float;

  graph_get_stored_graph(&graph);

  grow_CreateGrowRect(graph->grow->ctx, "", x, y, width, height,
		      graph->get_border_drawtype(), graph->linewidth, 0, glow_mDisplayLevel_1,
		      graph->fill, graph->border, graph->shadow, graph->get_fill_drawtype(),
		      NULL, &graph->current_cmd_object);
  grow_SetModified(graph->grow->ctx, 1);

  *return_int = (long int)graph->current_cmd_object;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_createrectrounded_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;
  ccm_sArg* arg_p3;
  ccm_sArg* arg_p4;

  double x, y, width, height;

  if (arg_count != 4)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;
  arg_p4 = arg_p3->next;

  if (arg_list->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p4->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  x = arg_list->value_float;
  y = arg_p2->value_float;
  width = arg_p3->value_float;
  height = arg_p4->value_float;

  graph_get_stored_graph(&graph);

  grow_CreateGrowRectRounded(graph->grow->ctx, "", x, y, width, height,
		      graph->get_border_drawtype(), graph->linewidth, 0, glow_mDisplayLevel_1,
		      graph->fill, graph->border, graph->shadow, graph->get_fill_drawtype(),
		      NULL, &graph->current_cmd_object);
  grow_SetModified(graph->grow->ctx, 1);

  *return_int = (long int)graph->current_cmd_object;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_createarc_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;
  ccm_sArg* arg_p3;
  ccm_sArg* arg_p4;
  ccm_sArg* arg_p5;
  ccm_sArg* arg_p6;

  double x1, y1, x2, y2;
  int angle1, angle2;

  if (arg_count != 6)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;
  arg_p4 = arg_p3->next;
  arg_p5 = arg_p4->next;
  arg_p6 = arg_p5->next;

  if (arg_list->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p4->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p5->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p6->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;

  x1 = arg_list->value_float;
  y1 = arg_p2->value_float;
  x2 = arg_p3->value_float;
  y2 = arg_p4->value_float;
  angle1 = arg_p5->value_int;
  angle2 = arg_p6->value_int;

  graph_get_stored_graph(&graph);

  grow_CreateGrowArc(graph->grow->ctx, "", x1, y1, x2, y2, angle1, angle2,
		     graph->get_border_drawtype(), graph->linewidth, graph->fill,
		     graph->border, graph->shadow, graph->get_fill_drawtype(), NULL,
		     &graph->current_cmd_object);
  grow_SetModified(graph->grow->ctx, 1);

  *return_int = (long int)graph->current_cmd_object;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_createline_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;
  ccm_sArg* arg_p3;
  ccm_sArg* arg_p4;

  double x1, y1, x2, y2;

  if (arg_count != 4)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;
  arg_p4 = arg_p3->next;

  if (arg_list->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p4->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  x1 = arg_list->value_float;
  y1 = arg_p2->value_float;
  x2 = arg_p3->value_float;
  y2 = arg_p4->value_float;

  graph_get_stored_graph(&graph);

  grow_CreateGrowLine(graph->grow->ctx, "", x1, y1, x2, y2,
		      graph->get_border_drawtype(), graph->linewidth, 0, NULL,
		      &graph->current_cmd_object);
  grow_SetModified(graph->grow->ctx, 1);

  *return_int = (long int)graph->current_cmd_object;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_createpolyline_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;
  ccm_sArg* arg_p3;
  ccm_sArg* arg_p4;

  double x1, y1, x2, y2;
  glow_sPoint points[2];
  int point_cnt;

  if (arg_count != 4)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;
  arg_p4 = arg_p3->next;

  if (arg_list->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p4->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  x1 = arg_list->value_float;
  y1 = arg_p2->value_float;
  x2 = arg_p3->value_float;
  y2 = arg_p4->value_float;

  graph_get_stored_graph(&graph);

  points[0].x = x1;
  points[0].y = y1;
  points[1].x = x2;
  points[1].y = y2;
  point_cnt = 2;
  grow_CreateGrowPolyLine(graph->grow->ctx, "", (glow_sPoint*)&points,
			  point_cnt, graph->get_border_drawtype(), graph->linewidth, 0,
			  graph->fill, graph->border, graph->shadow, graph->get_fill_drawtype(),
			  0, NULL, &graph->current_cmd_object);
  grow_SetModified(graph->grow->ctx, 1);

  *return_int = (long int)graph->current_cmd_object;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_polylineadd_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;
  ccm_sArg* arg_p3;

  grow_tObject oid;
  double x, y;
  glow_sPoint points[2];
  int point_cnt;

  if (arg_count != 3)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;

  if (arg_list->value_decl != CCM_DECL_INT)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  oid = (grow_tObject)arg_list->value_int;
  x = arg_p2->value_float;
  y = arg_p3->value_float;

  graph_get_stored_graph(&graph);

  points[0].x = x;
  points[0].y = y;
  point_cnt = 1;
  grow_AddPolyLinePoints(oid, (glow_sPoint*)&points, point_cnt);
  grow_SetModified(graph->grow->ctx, 1);

  return 1;
}

static int graph_createtext_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2; // x
  ccm_sArg* arg_p3; // y
  ccm_sArg* arg_p4; // Size
  ccm_sArg* arg_p5; // Font
  ccm_sArg* arg_p6; // Bold
  ccm_sArg* arg_p7; // Color

  double x, y;
  glow_eDrawType fill_color, border_color, text_color;
  glow_eFont textfont;
  int textbold, textsize;

  if (arg_count < 3 || arg_count > 7)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;

  graph_get_stored_graph(&graph);

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  if (arg_count > 3) {
    arg_p4 = arg_p3->next;
    if (arg_p4->value_decl != CCM_DECL_INT)
      return CCM__ARGMISM;
    textsize = arg_p4->value_int;
  }
  else
    textsize = graph->textsize;

  if (arg_count > 4) {
    arg_p5 = arg_p4->next;
    if (arg_p5->value_decl != CCM_DECL_INT)
      return CCM__ARGMISM;
    textfont = (glow_eFont)arg_p5->value_int;
  }
  else
    textfont = graph->textfont;

  if (arg_count > 5) {
    arg_p6 = arg_p5->next;
    if (arg_p6->value_decl != CCM_DECL_INT)
      return CCM__ARGMISM;
    textbold = arg_p6->value_int;
  }
  else {
    textbold = graph->textbold;
  }

  if (arg_count > 6) {
    arg_p7 = arg_p6->next;
    if (arg_p7->value_decl != CCM_DECL_INT)
      return CCM__ARGMISM;
    text_color = (glow_eDrawType)arg_p7->value_int;
  }
  else {
    if (graph->get_current_colors_cb) 
      (graph->get_current_colors_cb)(
	  graph->parent_ctx, &fill_color, &border_color, &text_color);
    else
      text_color = glow_eDrawType_Line;
  }
 
  x = arg_p2->value_float;
  y = arg_p3->value_float;

  glow_eDrawType drawtype;

  if (textbold)
    drawtype = glow_eDrawType_TextHelveticaBold;
  else
    drawtype = glow_eDrawType_TextHelvetica;

  switch (textsize) {
  case 0:
    textsize = 0;
    break;
  case 1:
    textsize = 1;
    break;
  case 2:
    textsize = 2;
    break;
  case 3:
    textsize = 4;
    break;
  case 4:
    textsize = 6;
    break;
  case 5:
    textsize = 8;
    break;
  default:
    textsize = 8;
  }


  grow_CreateGrowText(graph->grow->ctx, "", arg_list->value_string, x, y, drawtype,
      text_color, textsize, textfont, glow_mDisplayLevel_1, NULL,
      &graph->current_cmd_object);
  grow_SetModified(graph->grow->ctx, 1);

  *return_int = (long int)graph->current_cmd_object;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_createimage_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;
  ccm_sArg* arg_p3;
  ccm_sArg* arg_p4;
  ccm_sArg* arg_p5;
  
  double x1, y1, x2, y2;
  char name[80];
  grow_tNode n1;
  int scale_x, scale_y;
  double sx, sy;
  double ll_x, ll_y, ur_x, ur_y;
    
  if (arg_count < 3 || arg_count > 5)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  x1 = arg_p2->value_float;
  y1 = arg_p3->value_float;

  if (arg_count >= 4) {
    arg_p4 = arg_p3->next;
    if (arg_p4->value_decl != CCM_DECL_FLOAT)
      return CCM__ARGMISM;
    scale_x = 1;
    x2 = arg_p4->value_float;
  }
  else
    scale_x = 0;

  if (arg_count == 5) {
    arg_p5 = arg_p4->next;
    if (arg_p5->value_decl != CCM_DECL_FLOAT)
      return CCM__ARGMISM;
    scale_y = 1;
    y2 = arg_p5->value_float;    
  }
  else
    scale_y = 0;


  graph_get_stored_graph(&graph);

  sprintf(name, "O%d", grow_IncrNextObjectNameNumber(graph->grow->ctx));
  
  grow_CreateGrowImage(graph->grow->ctx, name, arg_list->value_string, x1, y1, NULL, &n1);

  if (scale_x || scale_y) {
    grow_MeasureNode(n1, &ll_x, &ll_y, &ur_x, &ur_y);
    if (scale_x)
      sx = (x2 - x1) / (ur_x - ll_x);
    else
      sx = 1;
    if (scale_y)
      sy = (y2 - y1) / (ur_y - ll_y);
    else
      sy = 1;
    grow_StoreTransform(n1);
    grow_SetObjectScale(n1, sx, sy, x1, y1, glow_eScaleType_LowerLeft);
  }
  graph->current_cmd_object = n1;

  grow_SetModified(graph->grow->ctx, 1);

  *return_int = (long int)graph->current_cmd_object;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_createobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;
  ccm_sArg* arg_p3;
  ccm_sArg* arg_p4;
  ccm_sArg* arg_p5;
  
  double x1, y1, x2, y2;
  char name[80];
  grow_tNodeClass nc;
  grow_tNode n1;
  int scale_x, scale_y;
  double sx, sy;
  double ll_x, ll_y, ur_x, ur_y;
  int sts;
    
  if (arg_count < 3 || arg_count > 5)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;
  if (arg_p3->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  x1 = arg_p2->value_float;
  y1 = arg_p3->value_float;

  if (arg_count >= 4) {
    arg_p4 = arg_p3->next;
    if (arg_p4->value_decl != CCM_DECL_FLOAT)
      return CCM__ARGMISM;
    scale_x = 1;
    x2 = arg_p4->value_float;
  }
  else
    scale_x = 0;

  if (arg_count == 5) {
    arg_p5 = arg_p4->next;
    if (arg_p5->value_decl != CCM_DECL_FLOAT)
      return CCM__ARGMISM;
    scale_y = 1;
    y2 = arg_p5->value_float;    
  }
  else
    scale_y = 0;


  graph_get_stored_graph(&graph);

  sts = grow_FindNodeClassByName(graph->grow->ctx, arg_list->value_string, &nc);
  if (EVEN(sts)) {
    // Load the subgraph
    grow_OpenSubGraphFromName(graph->grow->ctx, arg_list->value_string);
    sts = grow_FindNodeClassByName(graph->grow->ctx, arg_list->value_string, &nc);
  }
  if (EVEN(sts)) {
    *return_int = 0;
    *return_decl = CCM_DECL_INT;
    return 1;
  }

  sprintf(name, "O%d", grow_GetNextObjectNameNumber(graph->grow->ctx));

  if (!grow_IsSliderClass(nc))
    grow_CreateGrowNode(graph->grow->ctx, name, nc, x1, y1, NULL, &n1);
  else
    grow_CreateGrowSlider(graph->grow->ctx, name, nc, x1, y1, NULL, &n1);

  GeDyn* dyn = new GeDyn(graph);
  grow_SetUserData(n1, (void*)dyn);

  grow_MoveNode(n1, x1, y1);
  grow_StoreTransform(n1);
  if (scale_x || scale_y) {
    grow_MeasureNode(n1, &ll_x, &ll_y, &ur_x, &ur_y);
    if (scale_x)
      sx = (x2 - x1) / (ur_x - ll_x);
    else
      sx = 1;
    if (scale_y)
      sy = (y2 - y1) / (ur_y - ll_y);
    else
      sy = 1;
    grow_SetObjectScale(n1, sx, sy, x1, y1, glow_eScaleType_LowerLeft);
  }
  grow_StoreTransform(n1);
  graph->current_cmd_object = n1;

  grow_SetModified(graph->grow->ctx, 1);

  *return_int = (long int)graph->current_cmd_object;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_createbar_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;
  ccm_sArg* arg_p3;
  ccm_sArg* arg_p4;
  ccm_sArg* arg_p5;
  ccm_sArg* arg_p6;
  
  double x1, y1, x2, y2;
  grow_tNode n1;
  int scale_x, scale_y;
  double sx, sy;
  double ll_x, ll_y, ur_x, ur_y;
  int colortheme;
  glow_eDirection direction;
    
  if (arg_count < 2 || arg_count > 6)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_FLOAT )
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  x1 = arg_list->value_float;
  y1 = arg_p2->value_float;

  if (arg_count >= 3) {
    arg_p3 = arg_p2->next;
    if (arg_p3->value_decl != CCM_DECL_FLOAT)
      return CCM__ARGMISM;
    scale_x = 1;
    x2 = arg_p3->value_float;
  }
  else
    scale_x = 0;

  if (arg_count >= 4) {
    arg_p4 = arg_p3->next;
    if (arg_p4->value_decl != CCM_DECL_FLOAT)
      return CCM__ARGMISM;
    scale_y = 1;
    y2 = arg_p4->value_float;    
  }
  else
    scale_y = 0;

  if (arg_count >= 5) {
    arg_p5 = arg_p4->next;
    if (arg_p5->value_decl != CCM_DECL_INT)
      return CCM__ARGMISM;
    colortheme = arg_p5->value_int;
  }
  else
    colortheme = 0;

  if (arg_count == 6) {
    arg_p6 = arg_p5->next;
    if (arg_p6->value_decl != CCM_DECL_INT)
      return CCM__ARGMISM;
    direction = (glow_eDirection)arg_p6->value_int;
  }
  else
    direction = glow_eDirection_Up;


  graph_get_stored_graph(&graph);

  switch (direction) {
  case glow_eDirection_Up:
    graph->create_bar(&n1, x1, y1, colortheme);
    break;
  case glow_eDirection_Down:
    graph->create_bar(&n1, x1, y1, colortheme);
    grow_SelectClear(graph->grow->ctx);
    grow_SelectInsert(graph->grow->ctx, n1);
    grow_RotateSelectedObjects(graph->grow->ctx, 180.0, glow_eRotationPoint_Center);
    grow_SelectClear(graph->grow->ctx);
    grow_StoreTransform(n1);
    break;
  case glow_eDirection_Left:
    // Default bar has width 0.5 and height 5.0
    graph->create_bar(&n1, x1, y1 + 0.5, colortheme);
    grow_SelectClear(graph->grow->ctx);
    grow_SelectInsert(graph->grow->ctx, n1);
    grow_RotateSelectedObjects(graph->grow->ctx, -90.0, glow_eRotationPoint_LowerLeft);
    grow_SelectClear(graph->grow->ctx);
    grow_StoreTransform(n1);
    break;
  case glow_eDirection_Right:
    graph->create_bar(&n1, x1, y1 - 5.0, colortheme);
    grow_SelectClear(graph->grow->ctx);
    grow_SelectInsert(graph->grow->ctx, n1);
    grow_RotateSelectedObjects(graph->grow->ctx, 90.0, glow_eRotationPoint_UpperLeft);
    grow_SelectClear(graph->grow->ctx);
    grow_StoreTransform(n1);
    break;
  default:
    break;
  }

  if (scale_x || scale_y) {
    grow_MeasureNode(n1, &ll_x, &ll_y, &ur_x, &ur_y);
    if (scale_x)
      sx = (x2 - x1) / (ur_x - ll_x);
    else
      sx = 1;
    if (scale_y)
      sy = (y2 - y1) / (ur_y - ll_y);
    else
      sy = 1;
    grow_StoreTransform(n1);
    grow_SetObjectScale(n1, sx, sy, x1, y1, glow_eScaleType_LowerLeft);
  }
  graph->current_cmd_object = n1;

  grow_SetModified(graph->grow->ctx, 1);

  *return_int = (long int)graph->current_cmd_object;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_createbararc_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;
  ccm_sArg* arg_p3;
  ccm_sArg* arg_p4;
  ccm_sArg* arg_p5;
  
  double x1, y1, x2, y2;
  grow_tNode n1;
  int scale_x, scale_y;
  double sx, sy;
  double ll_x, ll_y, ur_x, ur_y;
  int colortheme;
    
  if (arg_count < 2 || arg_count > 5)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_FLOAT )
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  x1 = arg_list->value_float;
  y1 = arg_p2->value_float;

  if (arg_count >= 3) {
    arg_p3 = arg_p2->next;
    if (arg_p3->value_decl != CCM_DECL_FLOAT)
      return CCM__ARGMISM;
    scale_x = 1;
    x2 = arg_p3->value_float;
  }
  else
    scale_x = 0;

  if (arg_count >= 4) {
    arg_p4 = arg_p3->next;
    if (arg_p4->value_decl != CCM_DECL_FLOAT)
      return CCM__ARGMISM;
    scale_y = 1;
    y2 = arg_p4->value_float;    
  }
  else
    scale_y = 0;

  if (arg_count >= 5) {
    arg_p5 = arg_p4->next;
    if (arg_p5->value_decl != CCM_DECL_INT)
      return CCM__ARGMISM;
    colortheme = arg_p5->value_int;
  }
  else
    colortheme = 0;

  graph_get_stored_graph(&graph);

  graph->create_bararc(&n1, x1, y1, colortheme);

  if (scale_x || scale_y) {
    grow_MeasureNode(n1, &ll_x, &ll_y, &ur_x, &ur_y);
    if (scale_x)
      sx = (x2 - x1) / (ur_x - ll_x);
    else
      sx = 1;
    if (scale_y)
      sy = (y2 - y1) / (ur_y - ll_y);
    else
      sy = 1;
    grow_StoreTransform(n1);
    grow_SetObjectScale(n1, sx, sy, x1, y1, glow_eScaleType_LowerLeft);
  }
  graph->current_cmd_object = n1;

  grow_SetModified(graph->grow->ctx, 1);

  *return_int = (long int)graph->current_cmd_object;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_createaxis_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;
  ccm_sArg* arg_p3;
  ccm_sArg* arg_p4;
  ccm_sArg* arg_p5;
  ccm_sArg* arg_p6;
  ccm_sArg* arg_p7;
  
  double x1, y1, x2, y2;
  grow_tNode n1;
  int scale_x, scale_y;
  double sx, sy;
  double ll_x, ll_y, ur_x, ur_y;
  int colortheme;
  int dynamic;
  glow_eDirection direction;
    
  if (arg_count < 2 || arg_count > 7)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_FLOAT )
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  x1 = arg_list->value_float;
  y1 = arg_p2->value_float;

  if (arg_count >= 3) {
    arg_p3 = arg_p2->next;
    if (arg_p3->value_decl != CCM_DECL_FLOAT)
      return CCM__ARGMISM;
    scale_x = 1;
    x2 = arg_p3->value_float;
  }
  else
    scale_x = 0;

  if (arg_count >= 4) {
    arg_p4 = arg_p3->next;
    if (arg_p4->value_decl != CCM_DECL_FLOAT)
      return CCM__ARGMISM;
    scale_y = 1;
    y2 = arg_p4->value_float;    
  }
  else
    scale_y = 0;

  if (arg_count >= 5) {
    arg_p5 = arg_p4->next;
    if (arg_p5->value_decl != CCM_DECL_INT)
      return CCM__ARGMISM;
    colortheme = arg_p5->value_int;
  }
  else
    colortheme = 0;

  if (arg_count >= 6) {
    arg_p6 = arg_p5->next;
    if (arg_p6->value_decl != CCM_DECL_INT)
      return CCM__ARGMISM;
    dynamic = arg_p6->value_int;
  }
  else
    dynamic = 0;

  if (arg_count >= 7) {
    arg_p7 = arg_p6->next;
    if (arg_p7->value_decl != CCM_DECL_INT)
      return CCM__ARGMISM;
    direction = (glow_eDirection)arg_p7->value_int;
  }
  else
    direction = glow_eDirection_Up;


  graph_get_stored_graph(&graph);

  switch (direction) {
  case glow_eDirection_Left:
    graph->create_axis(&n1, x1, y1, dynamic, colortheme);
    break;
  case glow_eDirection_Right:
    graph->create_axis(&n1, x1, y1, dynamic, colortheme);
    grow_SelectClear(graph->grow->ctx);
    grow_SelectInsert(graph->grow->ctx, n1);
    grow_RotateSelectedObjects(graph->grow->ctx, 180.0, glow_eRotationPoint_Center);
    grow_SelectClear(graph->grow->ctx);
    grow_StoreTransform(n1);
    break;
  case glow_eDirection_Down:
    // Default bar has width 1.2 and height 5.0
    graph->create_axis(&n1, x1, y1 + 1.2, dynamic, colortheme);
    grow_SelectClear(graph->grow->ctx);
    grow_SelectInsert(graph->grow->ctx, n1);
    grow_RotateSelectedObjects(graph->grow->ctx, -90.0, glow_eRotationPoint_LowerLeft);
    grow_SelectClear(graph->grow->ctx);
    grow_StoreTransform(n1);
    break;
  case glow_eDirection_Up:
    graph->create_axis(&n1, x1, y1 - 5.0, dynamic, colortheme);
    grow_SelectClear(graph->grow->ctx);
    grow_SelectInsert(graph->grow->ctx, n1);
    grow_RotateSelectedObjects(graph->grow->ctx, 90.0, glow_eRotationPoint_UpperLeft);
    grow_SelectClear(graph->grow->ctx);
    grow_StoreTransform(n1);
    break;
  default:
    break;
  }

  if (scale_x || scale_y) {
    grow_MeasureNode(n1, &ll_x, &ll_y, &ur_x, &ur_y);
    if (scale_x)
      sx = (x2 - x1) / (ur_x - ll_x);
    else
      sx = 1;
    if (scale_y)
      sy = (y2 - y1) / (ur_y - ll_y);
    else
      sy = 1;
    grow_StoreTransform(n1);
    grow_SetObjectScale(n1, sx, sy, x1, y1, glow_eScaleType_LowerLeft);
  }
  graph->current_cmd_object = n1;

  grow_SetModified(graph->grow->ctx, 1);

  *return_int = (long int)graph->current_cmd_object;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_createaxisarc_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;
  ccm_sArg* arg_p3;
  ccm_sArg* arg_p4;
  ccm_sArg* arg_p5;
  ccm_sArg* arg_p6;
  
  double x1, y1, x2, y2;
  grow_tNode n1;
  int scale_x, scale_y;
  double sx, sy;
  double ll_x, ll_y, ur_x, ur_y;
  int colortheme;
  int dynamic;
    
  if (arg_count < 2 || arg_count > 6)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_FLOAT )
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  x1 = arg_list->value_float;
  y1 = arg_p2->value_float;

  if (arg_count >= 3) {
    arg_p3 = arg_p2->next;
    if (arg_p3->value_decl != CCM_DECL_FLOAT)
      return CCM__ARGMISM;
    scale_x = 1;
    x2 = arg_p3->value_float;
  }
  else
    scale_x = 0;

  if (arg_count >= 4) {
    arg_p4 = arg_p3->next;
    if (arg_p4->value_decl != CCM_DECL_FLOAT)
      return CCM__ARGMISM;
    scale_y = 1;
    y2 = arg_p4->value_float;    
  }
  else
    scale_y = 0;

  if (arg_count >= 5) {
    arg_p5 = arg_p4->next;
    if (arg_p5->value_decl != CCM_DECL_INT)
      return CCM__ARGMISM;
    colortheme = arg_p5->value_int;
  }
  else
    colortheme = 0;

  if (arg_count >= 6) {
    arg_p6 = arg_p5->next;
    if (arg_p6->value_decl != CCM_DECL_INT)
      return CCM__ARGMISM;
    dynamic = arg_p6->value_int;
  }
  else
    dynamic = 0;


  graph_get_stored_graph(&graph);

  graph->create_axisarc(&n1, x1, y1, dynamic, colortheme);

  if (scale_x || scale_y) {
    grow_MeasureNode(n1, &ll_x, &ll_y, &ur_x, &ur_y);
    if (scale_x)
      sx = (x2 - x1) / (ur_x - ll_x);
    else
      sx = 1;
    if (scale_y)
      sy = (y2 - y1) / (ur_y - ll_y);
    else
      sy = 1;
    grow_StoreTransform(n1);
    grow_SetObjectScale(n1, sx, sy, x1, y1, glow_eScaleType_LowerLeft);
  }
  graph->current_cmd_object = n1;

  grow_SetModified(graph->grow->ctx, 1);

  *return_int = (long int)graph->current_cmd_object;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_createpie_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;
  ccm_sArg* arg_p3;
  ccm_sArg* arg_p4;
  ccm_sArg* arg_p5;
  
  double x1, y1, x2, y2;
  grow_tNode n1;
  int scale_x, scale_y;
  double sx, sy;
  double ll_x, ll_y, ur_x, ur_y;
  int colortheme;
    
  if (arg_count < 2 || arg_count > 5)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;

  if (arg_list->value_decl != CCM_DECL_FLOAT )
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  x1 = arg_list->value_float;
  y1 = arg_p2->value_float;

  if (arg_count >= 3) {
    arg_p3 = arg_p2->next;
    if (arg_p3->value_decl != CCM_DECL_FLOAT)
      return CCM__ARGMISM;
    scale_x = 1;
    x2 = arg_p3->value_float;
  }
  else
    scale_x = 0;

  if (arg_count >= 4) {
    arg_p4 = arg_p3->next;
    if (arg_p4->value_decl != CCM_DECL_FLOAT)
      return CCM__ARGMISM;
    scale_y = 1;
    y2 = arg_p4->value_float;    
  }
  else
    scale_y = 0;

  if (arg_count >= 5) {
    arg_p5 = arg_p4->next;
    if (arg_p5->value_decl != CCM_DECL_INT)
      return CCM__ARGMISM;
    colortheme = arg_p5->value_int;
  }
  else
    colortheme = 0;

  graph_get_stored_graph(&graph);

  graph->create_pie(&n1, x1, y1, colortheme);

  if (scale_x || scale_y) {
    grow_MeasureNode(n1, &ll_x, &ll_y, &ur_x, &ur_y);
    if (scale_x)
      sx = (x2 - x1) / (ur_x - ll_x);
    else
      sx = 1;
    if (scale_y)
      sy = (y2 - y1) / (ur_y - ll_y);
    else
      sy = 1;
    grow_StoreTransform(n1);
    grow_SetObjectScale(n1, sx, sy, x1, y1, glow_eScaleType_LowerLeft);
  }
  graph->current_cmd_object = n1;

  grow_SetModified(graph->grow->ctx, 1);

  *return_int = (long int)graph->current_cmd_object;
  *return_decl = CCM_DECL_INT;
  return 1;
}

// Common for trend, dstrend, dstrendcurve and fastcurve

static int graph_createtrend(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string, unsigned int dyntype1, 
    unsigned int dyntype2)
{
  Graph* graph;
  ccm_sArg* arg_p2;
  ccm_sArg* arg_p3;
  ccm_sArg* arg_p4;
  ccm_sArg* arg_p5;
  
  double x1, y1, x2, y2;
  grow_tNode n1;
  int scale_x, scale_y;
  double sx, sy;
  double ll_x, ll_y, ur_x, ur_y;
  int colortheme;
    
  if (arg_count < 2 || arg_count > 5)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;

  if (arg_list->value_decl != CCM_DECL_FLOAT )
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  x1 = arg_list->value_float;
  y1 = arg_p2->value_float;

  if (arg_count >= 3) {
    arg_p3 = arg_p2->next;
    if (arg_p3->value_decl != CCM_DECL_FLOAT)
      return CCM__ARGMISM;
    scale_x = 1;
    x2 = arg_p3->value_float;
  }
  else
    scale_x = 0;

  if (arg_count >= 4) {
    arg_p4 = arg_p3->next;
    if (arg_p4->value_decl != CCM_DECL_FLOAT)
      return CCM__ARGMISM;
    scale_y = 1;
    y2 = arg_p4->value_float;    
  }
  else
    scale_y = 0;

  if (arg_count == 5) {
    arg_p5 = arg_p4->next;
    if (arg_p5->value_decl != CCM_DECL_INT)
      return CCM__ARGMISM;
    colortheme = arg_p5->value_int;
  }
  else
    colortheme = 0;


  graph_get_stored_graph(&graph);

  graph->create_trend(&n1, x1, y1, dyntype1, dyntype2, colortheme);

  if (scale_x || scale_y) {
    grow_MeasureNode(n1, &ll_x, &ll_y, &ur_x, &ur_y);
    if (scale_x)
      sx = (x2 - x1) / (ur_x - ll_x);
    else
      sx = 1;
    if (scale_y)
      sy = (y2 - y1) / (ur_y - ll_y);
    else
      sy = 1;
    grow_StoreTransform(n1);
    grow_SetObjectScale(n1, sx, sy, x1, y1, glow_eScaleType_LowerLeft);
  }
  graph->current_cmd_object = n1;

  grow_SetModified(graph->grow->ctx, 1);

  *return_int = (long int)graph->current_cmd_object;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_createtrend_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  return graph_createtrend(filectx, arg_list, arg_count, return_decl, return_float,
      return_int, return_string, ge_mDynType1_Trend, 0);
}

static int graph_createdstrend_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  return graph_createtrend(filectx, arg_list, arg_count, return_decl, return_float,
      return_int, return_string, 0, ge_mDynType2_DsTrend);
}

static int graph_createdstrendcurve_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  return graph_createtrend(filectx, arg_list, arg_count, return_decl, return_float,
      return_int, return_string, 0, ge_mDynType2_DsTrendCurve);
}

static int graph_createfastcurve_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  return graph_createtrend(filectx, arg_list, arg_count, return_decl, return_float,
      return_int, return_string, ge_mDynType1_FastCurve, 0);
}

// Common for xycurve and sevhist

static int graph_createxycurve(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string, unsigned int dyntype1, 
    unsigned int dyntype2)
{
  Graph* graph;
  ccm_sArg* arg_p2;
  ccm_sArg* arg_p3;
  ccm_sArg* arg_p4;
  ccm_sArg* arg_p5;
  
  double x1, y1, x2, y2;
  grow_tNode n1;
  int scale_x, scale_y;
  double sx, sy;
  double ll_x, ll_y, ur_x, ur_y;
  int colortheme;
    
  if (arg_count < 2 || arg_count > 5)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;

  if (arg_list->value_decl != CCM_DECL_FLOAT )
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  x1 = arg_list->value_float;
  y1 = arg_p2->value_float;

  if (arg_count >= 3) {
    arg_p3 = arg_p2->next;
    if (arg_p3->value_decl != CCM_DECL_FLOAT)
      return CCM__ARGMISM;
    scale_x = 1;
    x2 = arg_p3->value_float;
  }
  else
    scale_x = 0;

  if (arg_count >= 4) {
    arg_p4 = arg_p3->next;
    if (arg_p4->value_decl != CCM_DECL_FLOAT)
      return CCM__ARGMISM;
    scale_y = 1;
    y2 = arg_p4->value_float;    
  }
  else
    scale_y = 0;

  if (arg_count == 5) {
    arg_p5 = arg_p4->next;
    if (arg_p5->value_decl != CCM_DECL_INT)
      return CCM__ARGMISM;
    colortheme = arg_p5->value_int;
  }
  else
    colortheme = 0;


  graph_get_stored_graph(&graph);

  graph->create_xycurve(&n1, x1, y1, dyntype1, dyntype2, colortheme);

  if (scale_x || scale_y) {
    grow_MeasureNode(n1, &ll_x, &ll_y, &ur_x, &ur_y);
    if (scale_x)
      sx = (x2 - x1) / (ur_x - ll_x);
    else
      sx = 1;
    if (scale_y)
      sy = (y2 - y1) / (ur_y - ll_y);
    else
      sy = 1;
    grow_StoreTransform(n1);
    grow_SetObjectScale(n1, sx, sy, x1, y1, glow_eScaleType_LowerLeft);
  }
  graph->current_cmd_object = n1;

  grow_SetModified(graph->grow->ctx, 1);

  *return_int = (long int)graph->current_cmd_object;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_createxycurve_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  return graph_createxycurve(filectx, arg_list, arg_count, return_decl, return_float,
      return_int, return_string, ge_mDynType1_XY_Curve, 0);
}

static int graph_createsevhist_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  return graph_createxycurve(filectx, arg_list, arg_count, return_decl, return_float,
      return_int, return_string, 0, ge_mDynType2_SevHist);
}

static int graph_createwindow_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  ccm_sArg* arg_p2;
  ccm_sArg* arg_p3;
  ccm_sArg* arg_p4;
  ccm_sArg* arg_p5;
  
  double x1, y1, x2, y2;
  grow_tNode n1;
  int scale_x, scale_y;
  double sx, sy;
  double ll_x, ll_y, ur_x, ur_y;
  int colortheme;
    
  if (arg_count < 2 || arg_count > 5)
    return CCM__ARGMISM;

  arg_p2 = arg_list->next;
  arg_p3 = arg_p2->next;

  if (arg_list->value_decl != CCM_DECL_FLOAT )
    return CCM__ARGMISM;
  if (arg_p2->value_decl != CCM_DECL_FLOAT)
    return CCM__ARGMISM;

  x1 = arg_list->value_float;
  y1 = arg_p2->value_float;

  if (arg_count >= 3) {
    arg_p3 = arg_p2->next;
    if (arg_p3->value_decl != CCM_DECL_FLOAT)
      return CCM__ARGMISM;
    scale_x = 1;
    x2 = arg_p3->value_float;
  }
  else
    scale_x = 0;

  if (arg_count >= 4) {
    arg_p4 = arg_p3->next;
    if (arg_p4->value_decl != CCM_DECL_FLOAT)
      return CCM__ARGMISM;
    scale_y = 1;
    y2 = arg_p4->value_float;    
  }
  else
    scale_y = 0;

  if (arg_count == 5) {
    arg_p5 = arg_p4->next;
    if (arg_p5->value_decl != CCM_DECL_INT)
      return CCM__ARGMISM;
    colortheme = arg_p5->value_int;
  }
  else
    colortheme = 0;


  graph_get_stored_graph(&graph);

  graph->create_window(&n1, x1, y1);

  if (scale_x || scale_y) {
    grow_MeasureNode(n1, &ll_x, &ll_y, &ur_x, &ur_y);
    if (scale_x)
      sx = (x2 - x1) / (ur_x - ll_x);
    else
      sx = 1;
    if (scale_y)
      sy = (y2 - y1) / (ur_y - ll_y);
    else
      sy = 1;
    grow_StoreTransform(n1);
    grow_SetObjectScale(n1, sx, sy, x1, y1, glow_eScaleType_LowerLeft);
  }
  graph->current_cmd_object = n1;

  grow_SetModified(graph->grow->ctx, 1);

  *return_int = (long int)graph->current_cmd_object;
  *return_decl = CCM_DECL_INT;
  return 1;
}

static int graph_getgraphname_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count != 0)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);
  graph->get_name(return_string);
  *return_decl = CCM_DECL_STRING;

  return 1;
}

static int graph_setgraphname_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;
  char graphname[80];
  char oldname[80];
  char *s;

  if (arg_count != 1)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  if (arg_list->value_decl != CCM_DECL_STRING)
    return CCM__ARGMISM;

  str_ToLower(graphname, arg_list->value_string);
  if ((s = strrchr(graphname, '.')))
    *s = 0;
  graph->get_name(oldname);
  if (!streq(graphname, oldname) && !streq(oldname, ""))
    // Name changed
    graph->set_java_name("");

  graph->set_name(graphname);

  return 1;
}

static int graph_getinstanceobject_func(void* filectx, ccm_sArg* arg_list,
    int arg_count, int* return_decl, ccm_tFloat* return_float,
    ccm_tInt* return_int, char* return_string)
{
  Graph* graph;

  if (arg_count !=  0)
    return CCM__ARGMISM;

  graph_get_stored_graph(&graph);

  grow_GetOwner(graph->grow->ctx, return_string);
  *return_decl = CCM_DECL_STRING;

  return 1;
}

int Graph::script_func_register(void)
{
  int sts;

  sts = ccm_register_function(
     "Ge", "GetTextExtent", graph_gettextextent_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
        "Ge", "GetCurrentObject", graph_getcurrentobject_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "SelectAdd", graph_selectadd_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "SelectClear", graph_selectclear_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "SetExtern", graph_setextern_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "SetIntern", graph_setintern_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "SetExternAll", graph_setexternall_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "SetInternAll", graph_setinternall_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "SetDraw", graph_setdraw_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "IsW1", graph_true_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "IsW2", graph_false_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "GetFirstObject", graph_getfirstobject_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "GetNextObject", graph_getnextobject_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "GroupGetFirstObject", graph_groupgetfirstobject_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "GroupGetNextObject", graph_groupgetnextobject_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "DashInsertObject", graph_dashinsertobject_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "GroupSelected", graph_groupselected_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "GetObjectType", graph_getobjecttype_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "GetObjectClass", graph_getobjectclass_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "GetObjectFill", graph_getobjectfill_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "SetObjectFill", graph_setobjectfill_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "GetObjectBorder", graph_getobjectborder_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "SetObjectBorder", graph_setobjectborder_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "GetObjectGradient", graph_getobjectgradient_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "SetObjectGradient", graph_setobjectgradient_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "GetObjectFillColor", graph_getobjectfillcolor_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "SetObjectFillColor", graph_setobjectfillcolor_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "GetObjectBorderColor", graph_getobjectbordercolor_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "SetObjectBorderColor", graph_setobjectbordercolor_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "GetObjectTextColor", graph_getobjecttextcolor_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "SetObjectTextColor", graph_setobjecttextcolor_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "SetObjectBackgroundColor", graph_setobjectbackgroundcolor_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "SetObjectLineWidth", graph_setobjectlinewidth_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "SetObjectLineType", graph_setobjectlinetype_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "GetObjectShadow", graph_getobjectshadow_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "SetObjectShadow", graph_setobjectshadow_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "SetCurrentObject", graph_setcurrentobject_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "GetObjectName", graph_getobjectname_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "SetObjectName", graph_setobjectname_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "GetObjectDynType", graph_getobjectdyntype_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "GetObjectText", graph_getobjecttext_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "SetObjectText", graph_setobjecttext_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "FindObjectByName", graph_findobjectbyname_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "Reload", graph_reload_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "RotateSelected", graph_rotateselected_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "SetSelectTextSize", graph_setselecttextsize_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "SetSelectTextFont", graph_setselecttextfont_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "SetSelectTextBold", graph_setselecttextbold_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "SetObjectAttribute", graph_setobjectattribute_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "GetGraphAttribute", graph_getgraphattribute_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "SetGraphAttribute", graph_setgraphattribute_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "GetObjectAttribute", graph_getobjectattribute_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "GetRgbColor", graph_getrgbcolor_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "SetRgbColor", graph_setrgbcolor_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "MeasureObject", graph_measureobject_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "DeleteObject", graph_deleteobject_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "SetObjectClass", graph_setobjectclass_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "ScaleObject", graph_scaleobject_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "MoveObject", graph_moveobject_func);
  if (EVEN(sts))
      return sts;
  sts = ccm_register_function(
      "Ge", "MoveAbsObject", graph_moveabsobject_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "GetGraphName", graph_getgraphname_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "SetGraphName", graph_setgraphname_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "SetBackgroundColor", graph_setbackgroundcolor_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "SetColorTheme", graph_setcolortheme_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "OpenGraph", graph_opengraph_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "SaveGraph", graph_savegraph_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "BuildGraph", graph_buildgraph_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "ClearAll", graph_clearall_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "CreateRectangle", graph_createrectangle_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "CreateRectRounded", graph_createrectrounded_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "CreateArc", graph_createarc_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "CreateLine", graph_createline_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "CreatePolyLine", graph_createpolyline_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "PolyLineAdd", graph_polylineadd_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "CreateText", graph_createtext_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "CreateImage", graph_createimage_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "CreateObject", graph_createobject_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "CreateBar", graph_createbar_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "CreateBarArc", graph_createbararc_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "CreateAxis", graph_createaxis_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "CreateAxisArc", graph_createaxisarc_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "CreatePie", graph_createpie_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "CreateTrend", graph_createtrend_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "CreateDsTrend", graph_createdstrend_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "CreateDsTrendCurve", graph_createdstrendcurve_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "CreateFastCurve", graph_createfastcurve_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "CreateXYCurve", graph_createxycurve_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "CreateSevHist", graph_createsevhist_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function("Ge", "CreateWindow", graph_createwindow_func);
  if (EVEN(sts))
    return sts;
  sts = ccm_register_function(
      "Ge", "GetInstanceObject", graph_getinstanceobject_func);
  if (EVEN(sts))
    return sts;
  
  sts = ccm_create_external_var(
      "eObjectType_Rect", CCM_DECL_INT, 0, glow_eObjectType_GrowRect, 0);
  sts = ccm_create_external_var(
      "eObjectType_Line", CCM_DECL_INT, 0, glow_eObjectType_GrowLine, 0);
  sts = ccm_create_external_var(
      "eObjectType_Arc", CCM_DECL_INT, 0, glow_eObjectType_GrowArc, 0);
  sts = ccm_create_external_var("eObjectType_ConPoint", CCM_DECL_INT, 0,
       glow_eObjectType_GrowConPoint, 0);
  sts = ccm_create_external_var(
      "eObjectType_Annot", CCM_DECL_INT, 0, glow_eObjectType_GrowSubAnnot, 0);
  sts = ccm_create_external_var("eObjectType_PolyLine", CCM_DECL_INT, 0,
      glow_eObjectType_GrowPolyLine, 0);
  sts = ccm_create_external_var(
      "eObjectType_SubGraph", CCM_DECL_INT, 0, glow_eObjectType_GrowNode, 0);
  sts = ccm_create_external_var(
      "eObjectType_Text", CCM_DECL_INT, 0, glow_eObjectType_GrowText, 0);
  sts = ccm_create_external_var(
      "eObjectType_Bar", CCM_DECL_INT, 0, glow_eObjectType_GrowBar, 0);
  sts = ccm_create_external_var(
      "eObjectType_Trend", CCM_DECL_INT, 0, glow_eObjectType_GrowTrend, 0);
  sts = ccm_create_external_var(
      "eObjectType_Slider", CCM_DECL_INT, 0, glow_eObjectType_GrowSlider, 0);
  sts = ccm_create_external_var(
      "eObjectType_Image", CCM_DECL_INT, 0, glow_eObjectType_GrowImage, 0);
  sts = ccm_create_external_var(
      "eObjectType_Group", CCM_DECL_INT, 0, glow_eObjectType_GrowGroup, 0);
  sts = ccm_create_external_var(
      "eObjectType_Axis", CCM_DECL_INT, 0, glow_eObjectType_GrowAxis, 0);
  sts = ccm_create_external_var("eObjectType_RectRounded", CCM_DECL_INT, 0,
      glow_eObjectType_GrowRectRounded, 0);
  sts = ccm_create_external_var("eObjectType_ConGlue", CCM_DECL_INT, 0,
      glow_eObjectType_GrowConGlue, 0);
  sts = ccm_create_external_var(
      "eObjectType_Menu", CCM_DECL_INT, 0, glow_eObjectType_GrowMenu, 0);
  sts = ccm_create_external_var(
      "eObjectType_Window", CCM_DECL_INT, 0, glow_eObjectType_GrowWindow, 0);
  sts = ccm_create_external_var(
      "eObjectType_Table", CCM_DECL_INT, 0, glow_eObjectType_GrowTable, 0);
  sts = ccm_create_external_var(
      "eObjectType_Folder", CCM_DECL_INT, 0, glow_eObjectType_GrowFolder, 0);
  sts = ccm_create_external_var("eObjectType_XYCurve", CCM_DECL_INT, 0,
      glow_eObjectType_GrowXYCurve, 0);
  sts = ccm_create_external_var("eObjectType_AxisArc", CCM_DECL_INT, 0,
      glow_eObjectType_GrowAxisArc, 0);
  sts = ccm_create_external_var(
      "eObjectType_Pie", CCM_DECL_INT, 0, glow_eObjectType_GrowPie, 0);
  sts = ccm_create_external_var("eObjectType_BarChart", CCM_DECL_INT, 0,
      glow_eObjectType_GrowBarChart, 0);
  sts = ccm_create_external_var("eObjectType_Toolbar", CCM_DECL_INT, 0,
      glow_eObjectType_GrowToolbar, 0);

  sts = ccm_create_external_var(
      "mDynType1_No", CCM_DECL_INT, 0, ge_mDynType1_No, 0);
  sts = ccm_create_external_var(
      "mDynType1_Inherit", CCM_DECL_INT, 0, ge_mDynType1_Inherit, 0);
  sts = ccm_create_external_var(
      "mDynType1_Tone", CCM_DECL_INT, 0, ge_mDynType1_Tone, 0);
  sts = ccm_create_external_var(
      "mDynType1_DigLowColor", CCM_DECL_INT, 0, ge_mDynType1_DigLowColor, 0);
  sts = ccm_create_external_var(
      "mDynType1_DigColor", CCM_DECL_INT, 0, ge_mDynType1_DigColor, 0);
  sts = ccm_create_external_var(
      "mDynType1_DigError", CCM_DECL_INT, 0, ge_mDynType1_DigError, 0);
  sts = ccm_create_external_var(
      "mDynType1_DigWarning", CCM_DECL_INT, 0, ge_mDynType1_DigWarning, 0);
  sts = ccm_create_external_var(
      "mDynType1_DigFlash", CCM_DECL_INT, 0, ge_mDynType1_DigFlash, 0);
  sts = ccm_create_external_var(
      "mDynType1_Invisible", CCM_DECL_INT, 0, ge_mDynType1_Invisible, 0);
  sts = ccm_create_external_var(
      "mDynType1_DigBorder", CCM_DECL_INT, 0, ge_mDynType1_DigBorder, 0);
  sts = ccm_create_external_var(
      "mDynType1_DigText", CCM_DECL_INT, 0, ge_mDynType1_DigText, 0);
  sts = ccm_create_external_var(
      "mDynType1_Value", CCM_DECL_INT, 0, ge_mDynType1_Value, 0);
  sts = ccm_create_external_var(
      "mDynType1_AnalogColor", CCM_DECL_INT, 0, ge_mDynType1_AnalogColor, 0);
  sts = ccm_create_external_var(
      "mDynType1_Rotate", CCM_DECL_INT, 0, ge_mDynType1_Rotate, 0);
  sts = ccm_create_external_var(
      "mDynType1_Move", CCM_DECL_INT, 0, ge_mDynType1_Move, 0);
  sts = ccm_create_external_var(
      "mDynType1_AnalogShift", CCM_DECL_INT, 0, ge_mDynType1_AnalogShift, 0);
  sts = ccm_create_external_var(
      "mDynType1_DigShift", CCM_DECL_INT, 0, ge_mDynType1_DigShift, 0);
  sts = ccm_create_external_var(
      "mDynType1_Animation", CCM_DECL_INT, 0, ge_mDynType1_Animation, 0);
  sts = ccm_create_external_var(
      "mDynType1_Bar", CCM_DECL_INT, 0, ge_mDynType1_Bar, 0);
  sts = ccm_create_external_var(
      "mDynType1_Trend", CCM_DECL_INT, 0, ge_mDynType1_Trend, 0);
  sts = ccm_create_external_var("mDynType1_SliderBackground", CCM_DECL_INT, 0,
      ge_mDynType1_SliderBackground, 0);
  sts = ccm_create_external_var(
      "mDynType1_Video", CCM_DECL_INT, 0, ge_mDynType1_Video, 0);
  sts = ccm_create_external_var(
      "mDynType1_FillLevel", CCM_DECL_INT, 0, ge_mDynType1_FillLevel, 0);
  sts = ccm_create_external_var(
      "mDynType1_FastCurve", CCM_DECL_INT, 0, ge_mDynType1_FastCurve, 0);
  sts = ccm_create_external_var(
      "mDynType1_AnalogText", CCM_DECL_INT, 0, ge_mDynType1_AnalogText, 0);
  sts = ccm_create_external_var(
      "mDynType1_Table", CCM_DECL_INT, 0, ge_mDynType1_Table, 0);
  sts = ccm_create_external_var(
      "mDynType1_StatusColor", CCM_DECL_INT, 0, ge_mDynType1_StatusColor, 0);
  sts = ccm_create_external_var(
      "mDynType1_HostObject", CCM_DECL_INT, 0, ge_mDynType1_HostObject, 0);
  sts = ccm_create_external_var(
      "mDynType1_DigSound", CCM_DECL_INT, 0, ge_mDynType1_DigSound, 0);
  sts = ccm_create_external_var(
      "mDynType1_XY_Curve", CCM_DECL_INT, 0, ge_mDynType1_XY_Curve, 0);
  sts = ccm_create_external_var(
      "mDynType1_DigCommand", CCM_DECL_INT, 0, ge_mDynType1_DigCommand, 0);
  sts = ccm_create_external_var(
      "mDynType1_Pie", CCM_DECL_INT, 0, ge_mDynType1_Pie, 0);
  sts = ccm_create_external_var(
      "mDynType1_BarChart", CCM_DECL_INT, 0, ge_mDynType1_BarChart, 0);

  sts = ccm_create_external_var(
      "mDynType2_No", CCM_DECL_INT, 0, ge_mDynType2_No, 0);
  sts = ccm_create_external_var(
      "mDynType2_Axis", CCM_DECL_INT, 0, ge_mDynType2_Axis, 0);
  sts = ccm_create_external_var("mDynType2_DigTextColor", CCM_DECL_INT, 0,
      ge_mDynType2_DigTextColor, 0);
  sts = ccm_create_external_var("mDynType2_TimeoutColor", CCM_DECL_INT, 0,
      ge_mDynType2_TimeoutColor, 0);
  sts = ccm_create_external_var("mDynType2_DigFourShift", CCM_DECL_INT, 0,
      ge_mDynType2_DigFourShift, 0);
  sts = ccm_create_external_var("mDynType2_ScrollingText", CCM_DECL_INT, 0,
      ge_mDynType2_ScrollingText, 0);
  sts = ccm_create_external_var("mDynType2_ColorThemeLightness", CCM_DECL_INT,
      0, ge_mDynType2_ColorThemeLightness, 0);
  sts = ccm_create_external_var("mDynType2_DigBackgroundColor", CCM_DECL_INT,
      0, ge_mDynType2_DigBackgroundColor, 0);
  sts = ccm_create_external_var("mDynType2_DigSwap", CCM_DECL_INT,
      0, ge_mDynType2_DigSwap, 0);
  sts = ccm_create_external_var("mDynType2_DigScript", CCM_DECL_INT,
      0, ge_mDynType2_DigScript, 0);
  sts = ccm_create_external_var("mDynType2_RefUpdate", CCM_DECL_INT,
      0, ge_mDynType2_RefUpdate, 0);

  sts = ccm_create_external_var(
      "mActionType1_No", CCM_DECL_INT, 0, ge_mActionType1_No, 0);
  sts = ccm_create_external_var(
      "mActionType1_Inherit", CCM_DECL_INT, 0, ge_mActionType1_Inherit, 0);
  sts = ccm_create_external_var("mActionType1_PopupMenu", CCM_DECL_INT, 0,
      ge_mActionType1_PopupMenu, 0);
  sts = ccm_create_external_var(
      "mActionType1_SetDig", CCM_DECL_INT, 0, ge_mActionType1_SetDig, 0);
  sts = ccm_create_external_var(
      "mActionType1_ResetDig", CCM_DECL_INT, 0, ge_mActionType1_ResetDig, 0);
  sts = ccm_create_external_var("mActionType1_ToggleDig", CCM_DECL_INT, 0,
      ge_mActionType1_ToggleDig, 0);
  sts = ccm_create_external_var(
      "mActionType1_StoDig", CCM_DECL_INT, 0, ge_mActionType1_StoDig, 0);
  sts = ccm_create_external_var(
      "mActionType1_Command", CCM_DECL_INT, 0, ge_mActionType1_Command, 0);
  sts = ccm_create_external_var("mActionType1_CommandDoubleClick",
      CCM_DECL_INT, 0, ge_mActionType1_CommandDoubleClick, 0);
  sts = ccm_create_external_var(
      "mActionType1_Confirm", CCM_DECL_INT, 0, ge_mActionType1_Confirm, 0);
  sts = ccm_create_external_var("mActionType1_IncrAnalog", CCM_DECL_INT, 0,
      ge_mActionType1_IncrAnalog, 0);
  sts = ccm_create_external_var("mActionType1_RadioButton", CCM_DECL_INT, 0,
      ge_mActionType1_RadioButton, 0);
  sts = ccm_create_external_var(
      "mActionType1_Slider", CCM_DECL_INT, 0, ge_mActionType1_Slider, 0);
  sts = ccm_create_external_var("mActionType1_ValueInput", CCM_DECL_INT, 0,
       ge_mActionType1_ValueInput, 0);
  sts = ccm_create_external_var(
      "mActionType1_TipText", CCM_DECL_INT, 0, ge_mActionType1_TipText, 0);
  sts = ccm_create_external_var(
      "mActionType1_Help", CCM_DECL_INT, 0, ge_mActionType1_Help, 0);
  sts = ccm_create_external_var("mActionType1_OpenGraph", CCM_DECL_INT, 0,
      ge_mActionType1_OpenGraph, 0);
  sts = ccm_create_external_var(
      "mActionType1_OpenURL", CCM_DECL_INT, 0, ge_mActionType1_OpenURL, 0);
  sts = ccm_create_external_var("mActionType1_InputFocus", CCM_DECL_INT, 0,
      ge_mActionType1_InputFocus, 0);
  sts = ccm_create_external_var("mActionType1_CloseGraph", CCM_DECL_INT, 0,
     ge_mActionType1_CloseGraph, 0);
  sts = ccm_create_external_var("mActionType1_PulldownMenu", CCM_DECL_INT, 0,
      ge_mActionType1_PulldownMenu, 0);
  sts = ccm_create_external_var("mActionType1_OptionMenu", CCM_DECL_INT, 0,
      ge_mActionType1_OptionMenu, 0);
  sts = ccm_create_external_var(
      "mActionType1_SetValue", CCM_DECL_INT, 0, ge_mActionType1_SetValue, 0);
  sts = ccm_create_external_var("mActionType1_MethodToolbar", CCM_DECL_INT, 0,
      ge_mActionType1_MethodToolbar, 0);
  sts = ccm_create_external_var("mActionType1_MethodPulldownMenu",
       CCM_DECL_INT, 0, ge_mActionType1_MethodPulldownMenu, 0);
  sts = ccm_create_external_var(
      "mActionType1_Script", CCM_DECL_INT, 0, ge_mActionType1_Script, 0);
  sts = ccm_create_external_var(
      "mActionType1_CatchSignal", CCM_DECL_INT, 0, ge_mActionType1_CatchSignal, 0);
  sts = ccm_create_external_var(
      "mActionType1_EmitSignal", CCM_DECL_INT, 0, ge_mActionType1_EmitSignal, 0);

  char varname[40];
  for (int i = 1; i <= 300; i++) {
    sprintf(varname, "eDrawType_Color%d", i);
    sts = ccm_create_external_var(varname, CCM_DECL_INT, 0, i - 1, 0);
  }
  sts = ccm_create_external_var(
      "eDrawType_LineErase", CCM_DECL_INT, 0, 300, 0);
  for (int i = 1; i <= 90; i++) {
    sprintf(varname, "eDrawType_CustomColor%d", i);
    sts = ccm_create_external_var(
        varname, CCM_DECL_INT, 0, 310 + 4 * (i - 1), 0);
  }

  sts = ccm_create_external_var("mAccess_RtRead", CCM_DECL_INT, 0,
      pwr_mAccess_RtRead, 0);
  sts = ccm_create_external_var("mAccess_RtWrite", CCM_DECL_INT, 0,
      pwr_mAccess_RtWrite, 0);
  sts = ccm_create_external_var("mAccess_System", CCM_DECL_INT, 0,
      pwr_mAccess_System, 0);
  sts = ccm_create_external_var("mAccess_Maintenance", CCM_DECL_INT, 0,
      pwr_mAccess_Maintenance, 0);
  sts = ccm_create_external_var("mAccess_Process", CCM_DECL_INT, 0,
      pwr_mAccess_Process, 0);
  sts = ccm_create_external_var("mAccess_Instrument", CCM_DECL_INT, 0,
      pwr_mAccess_Instrument, 0);
  sts = ccm_create_external_var("mAccess_Operator1", CCM_DECL_INT, 0,
      pwr_mAccess_Operator1, 0);
  sts = ccm_create_external_var("mAccess_Operator2", CCM_DECL_INT, 0,
      pwr_mAccess_Operator2, 0);
  sts = ccm_create_external_var("mAccess_Operator3", CCM_DECL_INT, 0,
      pwr_mAccess_Operator3, 0);
  sts = ccm_create_external_var("mAccess_Operator4", CCM_DECL_INT, 0,
      pwr_mAccess_Operator4, 0);
  sts = ccm_create_external_var("mAccess_Operator5", CCM_DECL_INT, 0,
      pwr_mAccess_Operator5, 0);
  sts = ccm_create_external_var("mAccess_Operator6", CCM_DECL_INT, 0,
      pwr_mAccess_Operator6, 0);
  sts = ccm_create_external_var("mAccess_Operator7", CCM_DECL_INT, 0,
      pwr_mAccess_Operator7, 0);
  sts = ccm_create_external_var("mAccess_Operator8", CCM_DECL_INT, 0,
      pwr_mAccess_Operator8, 0);
  sts = ccm_create_external_var("mAccess_Operator9", CCM_DECL_INT, 0,
      pwr_mAccess_Operator9, 0);
  sts = ccm_create_external_var("mAccess_Operator10", CCM_DECL_INT, 0,
      pwr_mAccess_Operator10, 0);
  sts = ccm_create_external_var("mAccess_RtEventsAck", CCM_DECL_INT, 0,
      pwr_mAccess_RtEventsAck, 0);
  sts = ccm_create_external_var("mAccess_RtPlc", CCM_DECL_INT, 0,
      pwr_mAccess_RtPlc, 0);
  sts = ccm_create_external_var("mAccess_RtNavigator", CCM_DECL_INT, 0,
      pwr_mAccess_RtNavigator, 0);
  sts = ccm_create_external_var("mAccess_DevRead", CCM_DECL_INT, 0,
      pwr_mAccess_DevRead, 0);
  sts = ccm_create_external_var("mAccess_DevPlc", CCM_DECL_INT, 0,
      pwr_mAccess_DevPlc, 0);
  sts = ccm_create_external_var("mAccess_DevConfig", CCM_DECL_INT, 0,
      pwr_mAccess_DevConfig, 0);
  sts = ccm_create_external_var("mAccess_DevClass", CCM_DECL_INT, 0,
      pwr_mAccess_DevClass, 0);
  sts = ccm_create_external_var("mAccess_RtEventsBlock", CCM_DECL_INT, 0,
      pwr_mAccess_RtEventsBlock, 0);
  sts = ccm_create_external_var("mAccess_Administrator", CCM_DECL_INT, 0,
      pwr_mAccess_Administrator, 0);
  sts = ccm_create_external_var("mAccess_SevRead", CCM_DECL_INT, 0,
      pwr_mAccess_SevRead, 0);
  sts = ccm_create_external_var("mAccess_SevAdmin", CCM_DECL_INT, 0,
      pwr_mAccess_SevAdmin, 0);
  sts = ccm_create_external_var("mAccess_AllRt", CCM_DECL_INT, 0,
      pwr_mAccess_AllRt, 0);
  sts = ccm_create_external_var("mAccess_RtDefault", CCM_DECL_INT, 0,
      pwr_mAccess_RtDefault, 0);
  sts = ccm_create_external_var("mAccess_AllOperators", CCM_DECL_INT, 0,
      pwr_mAccess_AllOperators, 0);
  sts = ccm_create_external_var("mAccess_AllSev", CCM_DECL_INT, 0,
      pwr_mAccess_AllSev, 0);
  sts = ccm_create_external_var("mAccess_AllPwr", CCM_DECL_INT, 0,
      pwr_mAccess_AllPwr, 0);
  sts = ccm_create_external_var("mAccess_Default", CCM_DECL_INT, 0,
      pwr_mAccess_Default, 0);

  sts = ccm_create_external_var("eFont_Helvetica", CCM_DECL_INT, 0,
      glow_eFont_Helvetica, 0);
  sts = ccm_create_external_var("eFont_Times", CCM_DECL_INT, 0,
      glow_eFont_Times, 0);
  sts = ccm_create_external_var("eFont_NewCenturySchoolbook", CCM_DECL_INT, 0,
      glow_eFont_NewCenturySchoolbook, 0);
  sts = ccm_create_external_var("eFont_Courier", CCM_DECL_INT, 0,
      glow_eFont_Courier, 0);
  sts = ccm_create_external_var("eFont_LucidaSans", CCM_DECL_INT, 0,
      glow_eFont_LucidaSans, 0);

  sts = ccm_create_external_var("eDirection_Center", CCM_DECL_INT, 0,
      glow_eDirection_Center, 0);
  sts = ccm_create_external_var("eDirection_Right", CCM_DECL_INT, 0,
      glow_eDirection_Right, 0);
  sts = ccm_create_external_var("eDirection_Left", CCM_DECL_INT, 0,
      glow_eDirection_Left, 0);
  sts = ccm_create_external_var("eDirection_Up", CCM_DECL_INT, 0,
      glow_eDirection_Up, 0);
  sts = ccm_create_external_var("eDirection_Down", CCM_DECL_INT, 0,
      glow_eDirection_Down, 0);

  return 1;
}

static int ccm_deffilename_func(
    char* outfile, char* infile, void* client_data)
{
  char path[2][40] = {"$pwrp_exe/", "$pwr_exe/"};
  pwr_tFileName fname;
  pwr_tTime t;
  pwr_tStatus sts;
  int found = 0;

  //dcli_get_defaultfilename(infile, outfile, ".ge_com");
  if (strchr(infile, '/') == 0) {
    for (int i = 0; i < sizeof(path)/sizeof(path[0]); i++) {
      strcpy(fname, path[i]);
      strcat(fname, infile);
      if (strchr(fname, '.') == 0)
	strcat(fname, ".ge_com");
      dcli_translate_filename(fname, fname);
      sts = dcli_file_time(fname, &t);
      if (ODD(sts)) {
	found = 1;
	break;
      }	
    }
  }
  if (!found) {
    strcpy(fname, infile);
    if (strchr(fname, '.') == 0)
      strcat(fname, ".ge_com");
    dcli_translate_filename(fname, fname);
  }
  strcpy(outfile, fname);
  return 1;
}

static int ccm_errormessage_func(
    char* msg, int severity, void* client_data)
{
  switch(severity) {
  case msg_eSeverity_Info:
  case msg_eSeverity_Success:
    printf("I %s\n", msg);
    break;
  case msg_eSeverity_Warning:
    printf("W %s\n", msg);
    break;
  case msg_eSeverity_Error:
  case msg_eSeverity_Fatal:
    printf("E %s\n", msg);
    break;
  }
  return 1;
}

int ccm_externcmd_func(char* cmd, void* client_data)
{
  printf("E Syntax error, %s\n", cmd);
  return 1;
}

int Graph::read_scriptfile(char* incommand)
{
  char input_str[160];
  int sts;
  int appl_sts;

  if (!ccm_func_registred) {
    ccm_func_registred = 1;

    script_func_register();
  }

  str_trim(input_str, incommand);
  script_store_graph();
  // Read and execute the script file
  sts = ccm_file_exec(input_str, ccm_externcmd_func,
      ccm_deffilename_func, ccm_errormessage_func, &appl_sts,
      verify, 0, NULL, 0, 0, NULL, (void*)this);
  if (EVEN(sts))
    return sts;

  return 1;
}

int Graph::script_buffer_exec(char *script)
{
  int sts;
  int appl_sts;

  if (!ccm_func_registred) {
    ccm_func_registred = 1;

    script_func_register();

    // Register xtt standard functions ??
    // wccm_register(graph_wccm_get_wbctx_cb, graph_wccm_get_ldhsession_cb, 0);
  }

  script_store_graph();

  // Read and execute the command file
  sts = ccm_buffer_exec(script, ccm_externcmd_func,
      ccm_deffilename_func, ccm_errormessage_func, &appl_sts, verify,
      0, NULL, 0, NULL, (void *)this);
  if (EVEN(sts))
    return sts;
  return 1;
}


//
// Analogous c interface
//

void gsc_MeasureObject(Graph* graph, grow_tObject id, double* ll_x, double* ll_y, 
    double* ur_x, double *ur_y)
{
  grow_MeasureNode(id, ll_x, ll_y, ur_x, ur_y);
} 

void gsc_GetTextExtent(Graph* graph, char* text, int size, glow_eFont font, int bold,
    double *width, double *height, double *descent)
{
  glow_eDrawType draw_type;
  int textsize;

  if (bold)
    draw_type = glow_eDrawType_TextHelveticaBold;
  else
    draw_type = glow_eDrawType_TextHelvetica;

  switch (size) {
  case 0:
    textsize = 0;
    break;
  case 1:
    textsize = 1;
    break;
  case 2:
    textsize = 2;
    break;
  case 3:
    textsize = 4;
    break;
  case 4:
    textsize = 6;
    break;
  case 5:
    textsize = 8;
    break;
  default:
    textsize = 8;
  }

  grow_GetTextExtent(graph->grow->ctx, text, strlen(text), draw_type, 
      textsize, font, width, height, descent);
}

grow_tObject gsc_CreateText(Graph* graph, char *text, double x, double y, int size, 
    glow_eFont font, int bold, glow_eDrawType color)
{
  glow_eDrawType drawtype;
  int textsize;

  if (bold)
    drawtype = glow_eDrawType_TextHelveticaBold;
  else
    drawtype = glow_eDrawType_TextHelvetica;

  switch (size) {
  case 0:
    textsize = 0;
    break;
  case 1:
    textsize = 1;
    break;
  case 2:
    textsize = 2;
    break;
  case 3:
    textsize = 4;
    break;
  case 4:
    textsize = 6;
    break;
  case 5:
    textsize = 8;
    break;
  default:
    textsize = 8;
  }

  grow_CreateGrowText(graph->grow->ctx, "", text, x, y, drawtype,
      color, textsize, font, glow_mDisplayLevel_1, NULL,
      &graph->current_cmd_object);
  grow_SetModified(graph->grow->ctx, 1);

  return graph->current_cmd_object;
}

int gsc_DashInsertObject(Graph* graph, grow_tObject dash, grow_tObject id)
{
  return grow_DashInsertObject(dash, id);
}

grow_tObject gsc_CreateBar(Graph* graph, double x1, double y1, double x2, double y2, 
    int colortheme, glow_eDirection direction)
{
  grow_tNode n1;
  int scale_x, scale_y;
  double sx, sy;
  double ll_x, ll_y, ur_x, ur_y;

  switch (direction) {
  case glow_eDirection_Up:
    graph->create_bar(&n1, x1, y1, colortheme);
    break;
  case glow_eDirection_Down:
    graph->create_bar(&n1, x1, y1, colortheme);
    grow_SelectClear(graph->grow->ctx);
    grow_SelectInsert(graph->grow->ctx, n1);
    grow_RotateSelectedObjects(graph->grow->ctx, 180.0, glow_eRotationPoint_Center);
    grow_SelectClear(graph->grow->ctx);
    grow_StoreTransform(n1);
    break;
  case glow_eDirection_Left:
    // Default bar has width 0.5 and height 5.0
    graph->create_bar(&n1, x1, y1 + 0.5, colortheme);
    grow_SelectClear(graph->grow->ctx);
    grow_SelectInsert(graph->grow->ctx, n1);
    grow_RotateSelectedObjects(graph->grow->ctx, -90.0, glow_eRotationPoint_LowerLeft);
    grow_SelectClear(graph->grow->ctx);
    grow_StoreTransform(n1);
    break;
  case glow_eDirection_Right:
    graph->create_bar(&n1, x1, y1 - 5.0, colortheme);
    grow_SelectClear(graph->grow->ctx);
    grow_SelectInsert(graph->grow->ctx, n1);
    grow_RotateSelectedObjects(graph->grow->ctx, 90.0, glow_eRotationPoint_UpperLeft);
    grow_SelectClear(graph->grow->ctx);
    grow_StoreTransform(n1);
    break;
  default:
    break;
  }

  if (x2 == 0 && y2 == 0)
    scale_x = scale_y = 0;
  else
    scale_x = scale_y = 1;

  if (scale_x || scale_y) {
    grow_MeasureNode(n1, &ll_x, &ll_y, &ur_x, &ur_y);
    if (scale_x)
      sx = (x2 - x1) / (ur_x - ll_x);
    else
      sx = 1;
    if (scale_y)
      sy = (y2 - y1) / (ur_y - ll_y);
    else
      sy = 1;
    grow_StoreTransform(n1);
    grow_SetObjectScale(n1, sx, sy, x1, y1, glow_eScaleType_LowerLeft);
  }
  graph->current_cmd_object = n1;

  grow_SetModified(graph->grow->ctx, 1);

  return graph->current_cmd_object;
}

grow_tObject gsc_CreateBarArc(Graph* graph, double x1, double y1, double x2, double y2, 
    int colortheme)
{
  grow_tNode n1;
  int scale_x, scale_y;
  double sx, sy;
  double ll_x, ll_y, ur_x, ur_y;
    
  graph->create_bararc(&n1, x1, y1, colortheme);

  if (x2 == 0 && y2 == 0)
    scale_x = scale_y = 0;
  else
    scale_x = scale_y = 1;

  if (scale_x || scale_y) {
    grow_MeasureNode(n1, &ll_x, &ll_y, &ur_x, &ur_y);
    if (scale_x)
      sx = (x2 - x1) / (ur_x - ll_x);
    else
      sx = 1;
    if (scale_y)
      sy = (y2 - y1) / (ur_y - ll_y);
    else
      sy = 1;
    grow_StoreTransform(n1);
    grow_SetObjectScale(n1, sx, sy, x1, y1, glow_eScaleType_LowerLeft);
  }
  graph->current_cmd_object = n1;

  grow_SetModified(graph->grow->ctx, 1);

  return graph->current_cmd_object;
}

grow_tObject gsc_CreatePie(Graph* graph, double x1, double y1, double x2, double y2, 
    int colortheme)
{
  grow_tNode n1;
  int scale_x, scale_y;
  double sx, sy;
  double ll_x, ll_y, ur_x, ur_y;
    
  graph->create_pie(&n1, x1, y1, colortheme);

  if (x2 == 0 && y2 == 0)
    scale_x = scale_y = 0;
  else
    scale_x = scale_y = 1;

  if (scale_x || scale_y) {
    grow_MeasureNode(n1, &ll_x, &ll_y, &ur_x, &ur_y);
    if (scale_x)
      sx = (x2 - x1) / (ur_x - ll_x);
    else
      sx = 1;
    if (scale_y)
      sy = (y2 - y1) / (ur_y - ll_y);
    else
      sy = 1;
    grow_StoreTransform(n1);
    grow_SetObjectScale(n1, sx, sy, x1, y1, glow_eScaleType_LowerLeft);
  }
  graph->current_cmd_object = n1;

  grow_SetModified(graph->grow->ctx, 1);

  return graph->current_cmd_object;
}

int gsc_SetObjectAttribute(Graph* graph, grow_tObject id, const char* aname, void* buff, 
    int btype)
{
  int type;
  
  type = grow_GetObjectType(id);
  if (type == glow_eObjectType_GrowNode 
      || type == glow_eObjectType_GrowSlider
      || type == glow_eObjectType_GrowGroup
      || type == glow_eObjectType_GrowToolbar
      || type == glow_eObjectType_GrowTable
      || type == glow_eObjectType_GrowWindow
      || type == glow_eObjectType_GrowFolder 
      || type == glow_eObjectType_GrowBar
      || type == glow_eObjectType_GrowBarArc
      || type == glow_eObjectType_GrowXYCurve
      || type == glow_eObjectType_GrowPie
      || type == glow_eObjectType_GrowBarChart
      || type == glow_eObjectType_GrowAxis
      || type == glow_eObjectType_GrowAxisArc
      || type == glow_eObjectType_GrowTrend 
      || type == glow_eObjectType_GrowRect
      || type == glow_eObjectType_GrowRectRounded
      || type == glow_eObjectType_GrowArc
      || type == glow_eObjectType_GrowLine
      || type == glow_eObjectType_GrowPolyLine
      || type == glow_eObjectType_GrowText
      || type == glow_eObjectType_GrowImage) {
    attr_sItem* itemlist;
    attr_sItem* item_p;
    int item_cnt;
    void* client_data;
    char attr_name[80];
    int i_value;
    float f_value;
    double d_value;
    int i;
    int sts;
    int found;
    GeDyn* dyn;

    graph->get_attr_items(id, &itemlist, &item_cnt, &client_data);

    found = 0;
    item_p = itemlist;
    for (i = 0; i < item_cnt; i++) {
      strcpy(attr_name, item_p->name);
      if (item_p->type == ge_eAttrType_Dyn) {
	if (str_NoCaseStrncmp(aname, attr_name, strlen(attr_name)) == 0 &&
	    aname[strlen(attr_name)] == '.') {
	  found = 1;
	  break;
	}
      }
      else {
	if (str_NoCaseStrcmp(aname, attr_name) == 0) {
	  found = 1;
	  break;
	}
      }
      item_p++;
    }

    if (!found)
      return GE__NOATTR;

    switch (item_p->type) {
    case glow_eType_Int:
    case glow_eType_TraceColor:
    case glow_eType_Boolean:
      i_value = *(int *)buff;
      memcpy(item_p->value, (char*)&i_value, sizeof(i_value));
      break;
    case glow_eType_Float:
      f_value = *(float *)buff;
      memcpy(item_p->value, (char*)&f_value, sizeof(f_value));
      break;
    case glow_eType_Double:
      d_value = *(double *)buff;
      memcpy(item_p->value, (char*)&d_value, sizeof(d_value));
      break;
    case glow_eType_String: {
      char str[K_STRING_SIZE];

      trim_script(str, (char *)buff);
      strncpy((char*)item_p->value, str, item_p->size);
      break;
    }
    case glow_eType_Direction:
    case glow_eType_HorizDirection:
    case glow_eType_Adjustment:
    case glow_eType_AnnotType:
    case glow_eType_Font:
    case glow_eType_Color:
    case glow_eType_Tone:
    case glow_eType_ToneOrColor:
    case glow_eType_Cycle:
    case glow_eType_MB3Action:
    case glow_eType_InputFocusMark:
    case glow_eType_Relief:
    //case glow_eType_TextSize:
    case glow_eType_Gradient:
    case glow_eType_HotIndication:
    case glow_eType_AppMotion:
    case ge_eAttrType_AnimSequence:
    case ge_eAttrType_LimitType:
    case ge_eAttrType_ScaleType:
    case ge_eAttrType_CurveDataType:
    case ge_eAttrType_OptionMenuType:
    case ge_eAttrType_MethodsMenuType:
    case ge_eAttrType_MethodToolbarType:
    case ge_eAttrType_KeyboardType: {
      int value;

      if (btype == CCM_DECL_INT) {
        value = *(int *)buff;
      } else {
       sts = AttrNav::string_to_enum(item_p->type, (char *)buff, &value);
       if (EVEN(sts))
	 return GE__SYNTAX;
      }
      memcpy(item_p->value, (char*)&value, sizeof(value));
      break;
    }
    case glow_eType_TextSize: {
      int value;
      char str[40];

      if (btype == CCM_DECL_INT)
        sprintf(str, "%d", *(int *)buff);
      else
	sprintf(str, "%d", *(int *)buff);

      sts = AttrNav::string_to_enum(item_p->type, str, &value);
      if (EVEN(sts))
        return GE__SYNTAX;

      memcpy(item_p->value, (char*)&value, sizeof(value));
      break;
    }
    case glow_eType_Access:
    case ge_eAttrType_DynType1:
    case ge_eAttrType_DynType2:
    case ge_eAttrType_ActionType1:
    case ge_eAttrType_ActionType2:
    case ge_eAttrType_InstanceMask:
    case ge_eAttrType_InputFocus: {
      unsigned int value;

      if (btype == CCM_DECL_INT)
	value = *(int *)buff;
      else {
        sts = AttrNav::string_to_mask(item_p->type, (char *)buff, &value);
        if (EVEN(sts))
          return GE__SYNTAX;
      }
      memcpy(item_p->value, (char*)&value, sizeof(value));
      if (item_p->type == ge_eAttrType_DynType1
          || item_p->type == ge_eAttrType_DynType2
          || item_p->type == ge_eAttrType_ActionType1
          || item_p->type == ge_eAttrType_ActionType2) {
        grow_GetUserData(id, (void**)&dyn);
	dyn->update_dyntype(id);
        dyn->update_elements();
      }
      break;
    }
    case ge_eAttrType_Dyn: {
      attr_sItem dyn_itemlist[100];
      attr_sItem *dyn_item_p;
      int dyn_itemlist_cnt = 0;
      int j;
      char *dyn_attr_name;
      int dyn_found;

      dyn = (GeDyn *)item_p->value;
      if (!dyn) {
	dyn = new GeDyn(graph);
	item_p->value = &dyn;
      }
      dyn->get_attributes(0, dyn_itemlist, &dyn_itemlist_cnt);
      dyn_found = 0;
      dyn_attr_name = (char *)&aname[strlen(attr_name)+1];
      dyn_item_p = dyn_itemlist;
      for (j = 0; j < dyn_itemlist_cnt; j++) {
	if (str_NoCaseStrcmp(dyn_attr_name, dyn_item_p->name) == 0) {
	  dyn_found = 1;
	  break;
	}
	dyn_item_p++;
      }
      if (dyn_found) {
	if (btype == CCM_DECL_INT) {
	  int value;
	  value = *(int *)buff;
	  memcpy(dyn_item_p->value, (char*)&value, sizeof(value));
	  if (dyn_item_p->type == ge_eAttrType_DynType1
	      || dyn_item_p->type == ge_eAttrType_DynType2
	      || dyn_item_p->type == ge_eAttrType_ActionType1
	      || dyn_item_p->type == ge_eAttrType_ActionType2)
	    dyn->update_elements();
	}
	else if (btype == CCM_DECL_FLOAT) {
	  float fvalue = *(float *)buff;
	  memcpy(dyn_item_p->value, (char*)&fvalue, sizeof(fvalue));
	}
	else if (btype == CCM_DECL_STRING) {
	  char str[K_STRING_SIZE];

	  trim_script(str, (char *)buff);
	  strncpy((char *)dyn_item_p->value, str, dyn_item_p->size);
	}
      }
      else {
	dyn_item_p = dyn_itemlist;
	for (j = 0; j < dyn_itemlist_cnt; j++) {
	  if (str_NoCaseStrncmp(dyn_attr_name, dyn_item_p->name, strlen(dyn_item_p->name)) == 0 &&
	    dyn_attr_name[strlen(dyn_item_p->name)] == '.') {
	    dyn_found = 1;
	    break;
	  }
	  dyn_item_p++;
	}

	if (dyn_found) {
	  if (dyn_item_p->type == ge_eAttrType_Dyn) {
	    attr_sItem dyn2_itemlist[100];
	    attr_sItem *dyn2_item_p;
	    int dyn2_itemlist_cnt = 0;
	    int j;
	    char *dyn2_attr_name;
	    int dyn2_found;
	    
	    dyn = (GeDyn *)dyn_item_p->value;
	    if (!dyn) {
	      dyn = new GeDyn(graph);
	      dyn_item_p->value = &dyn;
	    }
	    dyn->get_attributes(0, dyn2_itemlist, &dyn2_itemlist_cnt);
	    dyn2_found = 0;
	    dyn2_attr_name = &dyn_attr_name[strlen(dyn_item_p->name)+1];
	    dyn2_item_p = dyn2_itemlist;
	    for (j = 0; j < dyn2_itemlist_cnt; j++) {
	      if (str_NoCaseStrcmp(dyn2_attr_name, dyn2_item_p->name) == 0) {
		dyn2_found = 1;
		break;
	      }
	      dyn2_item_p++;
	    }
	    if (dyn2_found) {
	      if (btype == CCM_DECL_INT) {
		int value;
		value = *(int *)buff;
		memcpy(dyn2_item_p->value, (char*)&value, sizeof(value));
		if (dyn2_item_p->type == ge_eAttrType_DynType1
		    || dyn2_item_p->type == ge_eAttrType_DynType2
		    || dyn2_item_p->type == ge_eAttrType_ActionType1
		    || dyn2_item_p->type == ge_eAttrType_ActionType2)
		  dyn->update_elements();
	      }
	      else if (btype == CCM_DECL_FLOAT) {
		float fvalue = *(float *)buff;
		memcpy(dyn2_item_p->value, (char*)&fvalue, sizeof(fvalue));
	      }
	      else if (btype == CCM_DECL_STRING) {
		char str[K_STRING_SIZE];
		
		trim_script(str, (char *)buff);
		strncpy((char *)dyn2_item_p->value, str, dyn2_item_p->size);
	      }
	    }
	  }
	}
      }
    }
    default:;
    }
    grow_UpdateObject(graph->grow->ctx, id, (grow_sAttrInfo*)client_data);
    grow_FreeObjectAttrInfo((grow_sAttrInfo*)client_data);
  }
  return 1;
}

int gsc_GetObjectAttribute(Graph* graph, grow_tObject id, const char* aname, void* buff, 
    int bsize, int btype)
{
  int type;

  type = grow_GetObjectType(id);
  if (type == glow_eObjectType_GrowNode 
      || type == glow_eObjectType_GrowSlider
      || type == glow_eObjectType_GrowGroup
      || type == glow_eObjectType_GrowToolbar
      || type == glow_eObjectType_GrowTable
      || type == glow_eObjectType_GrowWindow
      || type == glow_eObjectType_GrowFolder 
      || type == glow_eObjectType_GrowBar
      || type == glow_eObjectType_GrowBarArc
      || type == glow_eObjectType_GrowXYCurve
      || type == glow_eObjectType_GrowPie
      || type == glow_eObjectType_GrowBarChart
      || type == glow_eObjectType_GrowAxis
      || type == glow_eObjectType_GrowAxisArc
      || type == glow_eObjectType_GrowTrend 
      || type == glow_eObjectType_GrowRect
      || type == glow_eObjectType_GrowRectRounded
      || type == glow_eObjectType_GrowArc
      || type == glow_eObjectType_GrowLine
      || type == glow_eObjectType_GrowPolyLine
      || type == glow_eObjectType_GrowText
      || type == glow_eObjectType_GrowImage
      || type == glow_eObjectType_GrowDashCell) {
    attr_sItem* itemlist;
    attr_sItem* item_p;
    int item_cnt;
    void* client_data;
    char attr_name[80];
    pwr_tInt32 i32_value;
    pwr_tInt64 i64_value;
    double d_value;
    float f_value;
    int i;
    int sts;
    int found;

    graph->get_attr_items(id, &itemlist, &item_cnt, &client_data);

    found = 0;
    item_p = itemlist;
    for (i = 0; i < item_cnt; i++) {
      strcpy(attr_name, item_p->name);
      if (item_p->type == ge_eAttrType_Dyn) {
	if (str_NoCaseStrncmp(aname, attr_name, strlen(attr_name)) == 0) {
	  found = 1;
	  break;
	}
      }
      else {
	if (str_NoCaseStrcmp(aname, attr_name) == 0) {
	  found = 1;
	  break;
	}
      }
      item_p++;
    }

    if (!found)
      return GE__NOATTR;

    switch (item_p->type) {
    case glow_eType_Int:
    case glow_eType_TraceColor:
    case glow_eType_Boolean:
      if (btype != CCM_DECL_INT)
        return CCM__ARGMISM;

      if (item_p->size == 4) {
	if (bsize == 4)
	  memcpy(buff, item_p->value, bsize);
	else if (bsize == 8) {
	  memcpy(&i32_value, item_p->value, sizeof(i32_value));
	  i64_value = i32_value;
	  memcpy(buff, &i64_value, bsize);
	}
      }
      else {
	if (bsize == 8)
	  memcpy(buff, item_p->value, bsize);
	else if (bsize == 4) {
	  memcpy(&i64_value, item_p->value, sizeof(i64_value));
	  i32_value = i64_value;
	  memcpy(buff, &i32_value, bsize);
	}
      }
      break;
    case glow_eType_Float:
      if (btype != CCM_DECL_FLOAT)
        return CCM__ARGMISM;

      if (bsize == 4)
	memcpy(buff, item_p->value, bsize);
      else if (bsize == 8) {
	memcpy(&f_value, item_p->value, sizeof(f_value));
	d_value = f_value;
	memcpy(buff, &d_value, bsize);
      }
      break;
    case glow_eType_Double:
      if (btype != CCM_DECL_FLOAT)
        return CCM__ARGMISM;

      if (bsize == 8)
	memcpy(buff, item_p->value, bsize);
      else if (bsize == 4) {
	memcpy(&d_value, item_p->value, sizeof(d_value));
	f_value = d_value;
	memcpy(buff, &f_value, bsize);
      }
      break;
    case glow_eType_String:
      if (btype != CCM_DECL_STRING)
        return CCM__ARGMISM;
      strncpy((char *)buff, (char*)item_p->value,
          MIN(item_p->size, bsize));
      break;
    case glow_eType_Direction:
    case glow_eType_HorizDirection:
    case glow_eType_Adjustment:
    case glow_eType_AnnotType:
    case glow_eType_Font:
    case glow_eType_Color:
    case glow_eType_Tone:
    case glow_eType_ToneOrColor:
    case glow_eType_Cycle:
    case glow_eType_MB3Action:
    case glow_eType_InputFocusMark:
    case glow_eType_Relief:
    // case glow_eType_TextSize:
    case glow_eType_Gradient:
    case glow_eType_HotIndication:
    case glow_eType_AppMotion:
    case ge_eAttrType_AnimSequence:
    case ge_eAttrType_LimitType:
    case ge_eAttrType_ScaleType:
    case ge_eAttrType_CurveDataType:
    case ge_eAttrType_OptionMenuType:
    case ge_eAttrType_MethodsMenuType:
    case ge_eAttrType_MethodToolbarType:
    case ge_eAttrType_KeyboardType: {
      int value;

      if (!(btype == CCM_DECL_INT
              || btype == CCM_DECL_STRING))
        return CCM__ARGMISM;

      memcpy((char*)&value, item_p->value, sizeof(value));

      if (btype == CCM_DECL_INT) {
	memcpy(buff, &value, bsize);
      } else {
        sts = AttrNav::enum_to_string(item_p->type, value, (char *)buff, bsize);
        if (EVEN(sts))
          return GE__SYNTAX;
      }
      break;
    }
    case glow_eType_TextSize: {
      int value;
      char str[40];

      if (!(btype == CCM_DECL_INT
              || btype == CCM_DECL_STRING))
        return CCM__ARGMISM;

      memcpy((char*)&value, item_p->value, sizeof(value));
      sts = AttrNav::enum_to_string(item_p->type, value, str, sizeof(str));
      if (EVEN(sts))
        return GE__SYNTAX;

      if (btype == CCM_DECL_INT)
        sscanf(str, "%d", (int*)buff);
      else
        strncpy((char *)buff, str, bsize);
      break;
    }
    case glow_eType_Access:
    case ge_eAttrType_DynType1:
    case ge_eAttrType_DynType2:
    case ge_eAttrType_ActionType1:
    case ge_eAttrType_ActionType2:
    case ge_eAttrType_InstanceMask:
    case ge_eAttrType_InputFocus: {
      if (btype != CCM_DECL_INT)
        return CCM__ARGMISM;

      memcpy((char*)buff, item_p->value, bsize);
      break;
    }
    case ge_eAttrType_Dyn: {
      attr_sItem dyn_itemlist[100];
      attr_sItem *dyn_item_p;
      int dyn_itemlist_cnt = 0;
      int j;
      char *dyn_attr_name;
      int dyn_found;
      GeDyn *dyn;

      dyn = (GeDyn *)item_p->value;
      if (!dyn) {
	dyn = new GeDyn(graph);
	item_p->value = &dyn;
      }
      dyn->get_attributes(0, dyn_itemlist, &dyn_itemlist_cnt);
      dyn_found = 0;
      dyn_attr_name = (char *)&aname[strlen(attr_name)+1];
      dyn_item_p = dyn_itemlist;
      for (j = 0; j < dyn_itemlist_cnt; j++) {
	if (str_NoCaseStrcmp(dyn_attr_name, dyn_item_p->name) == 0) {
	  dyn_found = 1;
	  break;
	}
	dyn_item_p++;
      }
      if (dyn_found) {
	switch (dyn_item_p->type) {
	case glow_eType_Int:
	case glow_eType_TraceColor:
	case glow_eType_Boolean:
	case glow_eType_DynType1:
	case glow_eType_DynType2:
	case glow_eType_ActionType1:
	case glow_eType_ActionType2:
	  if (btype != CCM_DECL_INT)
	    return CCM__ARGMISM;

	  if (dyn_item_p->size == 4) {
	    if (bsize == 4)
	      memcpy(buff, dyn_item_p->value, bsize);
	    else if (bsize == 8) {
	      memcpy(&i32_value, dyn_item_p->value, sizeof(i32_value));
	      i64_value = i32_value;
	      memcpy(buff, &i64_value, bsize);
	    }
	  }
	  else {
	    if (bsize == 8)
	      memcpy(buff, dyn_item_p->value, bsize);
	    else if (bsize == 4) {
	      memcpy(&i64_value, dyn_item_p->value, sizeof(i64_value));
	      i32_value = i64_value;
	      memcpy(buff, &i32_value, bsize);
	    }
	  }
	  break;
	case glow_eType_Float:
	  if (btype != CCM_DECL_FLOAT)
	    return CCM__ARGMISM;
	  
	  if (bsize == 4)
	    memcpy(buff, dyn_item_p->value, bsize);
	  else if (bsize == 8) {
	    memcpy(&f_value, dyn_item_p->value, sizeof(f_value));
	    d_value = f_value;
	    memcpy(buff, &d_value, bsize);
	  }
	  break;
	case glow_eType_Double:
	  if (btype != CCM_DECL_FLOAT)
	    return CCM__ARGMISM;
	  
	  if (bsize == 8)
	    memcpy(buff, dyn_item_p->value, bsize);
	  else if (bsize == 4) {
	    memcpy(&d_value, dyn_item_p->value, sizeof(d_value));
	    f_value = d_value;
	    memcpy(buff, &f_value, bsize);
	  }
	  break;
	case glow_eType_String:
	  if (btype != CCM_DECL_STRING)
	    return CCM__ARGMISM;
	  strncpy((char *)buff, (char*)dyn_item_p->value,
		  MIN(dyn_item_p->size, bsize));
	}
      }
    }
    default:;
    }
    grow_FreeObjectAttrInfo((grow_sAttrInfo*)client_data);
  }
  return 1;
}


grow_tObject gsc_CreateObject(Graph* graph, const char *nodeclass, double x1, double y1, 
    double x2, double y2)
{
  char name[80];
  grow_tNodeClass nc;
  grow_tNode n1;
  int scale_x, scale_y;
  double sx, sy;
  double ll_x, ll_y, ur_x, ur_y;
  int sts;

  if (x2 == 0 && y2 == 0)
    scale_x = scale_y = 0;
  else
    scale_x = scale_y = 1;

  sts = grow_FindNodeClassByName(graph->grow->ctx, nodeclass, &nc);
  if (EVEN(sts)) {
    // Load the subgraph
    grow_OpenSubGraphFromName(graph->grow->ctx, nodeclass);
    sts = grow_FindNodeClassByName(graph->grow->ctx, nodeclass, &nc);
  }
  if (EVEN(sts))
    return 0;

  sprintf(name, "O%d", grow_GetNextObjectNameNumber(graph->grow->ctx));

  if (!grow_IsSliderClass(nc))
    grow_CreateGrowNode(graph->grow->ctx, name, nc, x1, y1, NULL, &n1);
  else
    grow_CreateGrowSlider(graph->grow->ctx, name, nc, x1, y1, NULL, &n1);

  GeDyn* dyn = new GeDyn(graph);
  grow_SetUserData(n1, (void*)dyn);

  grow_MoveNode(n1, x1, y1);
  grow_StoreTransform(n1);
  if (scale_x || scale_y) {
    grow_MeasureNode(n1, &ll_x, &ll_y, &ur_x, &ur_y);
    if (scale_x)
      sx = (x2 - x1) / (ur_x - ll_x);
    else
      sx = 1;
    if (scale_y)
      sy = (y2 - y1) / (ur_y - ll_y);
    else
      sy = 1;
    grow_SetObjectScale(n1, sx, sy, x1, y1, glow_eScaleType_LowerLeft);
  }
  grow_StoreTransform(n1);
  graph->current_cmd_object = n1;

  grow_SetModified(graph->grow->ctx, 1);

  return graph->current_cmd_object;
}

void gsc_SetObjectGradient(Graph* graph, grow_tObject id, glow_eGradient gradient)
{
  grow_SetObjectGradient(id, gradient);
}

void gsc_SetObjectShadow(Graph* graph, grow_tObject id, int shadow)
{
  grow_SetObjectShadow(id, shadow);
}

void gsc_SetObjectFillColor(Graph* graph, grow_tObject id, glow_eDrawType color)
{
  grow_SetObjectOriginalFillColor(id, color);
}

void gsc_SetObjectBorderColor(Graph* graph, grow_tObject id, glow_eDrawType color)
{
  grow_SetObjectOriginalBorderColor(id, color);
}

void gsc_SetObjectTextColor(Graph* graph, grow_tObject id, glow_eDrawType color)
{
  grow_SetObjectOriginalTextColor(id, color);
}

void gsc_SetObjectFill(Graph* graph, grow_tObject id, int fill)
{
  grow_SetObjectFill(id, fill);
}

void gsc_SetObjectBorder(Graph* graph, grow_tObject id, int border)
{
  grow_SetObjectBorder(id, border);
}

void gsc_SelectAdd(Graph* graph, grow_tObject id)
{
  grow_SelectInsert(graph->grow->ctx, id);
}

void gsc_SelectClear(Graph* graph)
{
  grow_SelectClear(graph->grow->ctx);
}

void gsc_SetSelectTextSize(Graph *graph, int size)
{
  grow_SetSelectTextSize(graph->grow->ctx, size);
}

void gsc_RotateSelected(Graph *graph, int angle, int rotation_point)
{
  grow_RotateSelectedObjects(graph->grow->ctx, angle, (glow_eRotationPoint)rotation_point);
}

grow_tObject gsc_CreateAxis(Graph *graph, double x1, double y1, double x2, double y2,
    int colortheme, int dynamic, glow_eDirection direction)
{
  grow_tNode n1;
  int scale_x, scale_y;
  double sx, sy;
  double ll_x, ll_y, ur_x, ur_y;
    
  if (x2 == 0 && y2 == 0)
    scale_x = scale_y = 0;
  else
    scale_x = scale_y = 1;

  switch (direction) {
  case glow_eDirection_Left:
    graph->create_axis(&n1, x1, y1, dynamic, colortheme);
    break;
  case glow_eDirection_Right:
    graph->create_axis(&n1, x1, y1, dynamic, colortheme);
    grow_SelectClear(graph->grow->ctx);
    grow_SelectInsert(graph->grow->ctx, n1);
    grow_RotateSelectedObjects(graph->grow->ctx, 180.0, glow_eRotationPoint_Center);
    grow_SelectClear(graph->grow->ctx);
    grow_StoreTransform(n1);
    break;
  case glow_eDirection_Down:
    // Default bar has width 1.0 and height 5.0
    graph->create_axis(&n1, x1, y1 + 1.0, dynamic, colortheme);
    grow_SelectClear(graph->grow->ctx);
    grow_SelectInsert(graph->grow->ctx, n1);
    grow_RotateSelectedObjects(graph->grow->ctx, -90.0, glow_eRotationPoint_LowerLeft);
    grow_SelectClear(graph->grow->ctx);
    grow_StoreTransform(n1);
    break;
  case glow_eDirection_Up:
    graph->create_axis(&n1, x1, y1 - 5.0, dynamic, colortheme);
    grow_SelectClear(graph->grow->ctx);
    grow_SelectInsert(graph->grow->ctx, n1);
    grow_RotateSelectedObjects(graph->grow->ctx, 90.0, glow_eRotationPoint_UpperLeft);
    grow_SelectClear(graph->grow->ctx);
    grow_StoreTransform(n1);
    break;
  default:
    break;
  }

  if (scale_x || scale_y) {
    grow_MeasureNode(n1, &ll_x, &ll_y, &ur_x, &ur_y);
    if (scale_x)
      sx = (x2 - x1) / (ur_x - ll_x);
    else
      sx = 1;
    if (scale_y)
      sy = (y2 - y1) / (ur_y - ll_y);
    else
      sy = 1;
    grow_StoreTransform(n1);
    grow_SetObjectScale(n1, sx, sy, x1, y1, glow_eScaleType_LowerLeft);
  }
  graph->current_cmd_object = n1;

  grow_SetModified(graph->grow->ctx, 1);

  return graph->current_cmd_object;
}

grow_tObject gsc_CreateAxisArc(Graph *graph, double x1, double y1, double x2, double y2,
    int colortheme, int dynamic)
{
  grow_tNode n1;
  int scale_x, scale_y;
  double sx, sy;
  double ll_x, ll_y, ur_x, ur_y;
    
  if (x2 == 0 && y2 == 0)
    scale_x = scale_y = 0;
  else
    scale_x = scale_y = 1;

  graph->create_axisarc(&n1, x1, y1, dynamic, colortheme);

  if (scale_x || scale_y) {
    grow_MeasureNode(n1, &ll_x, &ll_y, &ur_x, &ur_y);
    if (scale_x)
      sx = (x2 - x1) / (ur_x - ll_x);
    else
      sx = 1;
    if (scale_y)
      sy = (y2 - y1) / (ur_y - ll_y);
    else
      sy = 1;
    grow_StoreTransform(n1);
    grow_SetObjectScale(n1, sx, sy, x1, y1, glow_eScaleType_LowerLeft);
  }
  graph->current_cmd_object = n1;

  grow_SetModified(graph->grow->ctx, 1);

  return graph->current_cmd_object;
}

grow_tObject gsc_CreateTrend(Graph *graph, double x1, double y1, double x2, double y2,
    int colortheme)
{
  grow_tNode n1;
  int scale_x, scale_y;
  double sx, sy;
  double ll_x, ll_y, ur_x, ur_y;
    
  graph->create_trend(&n1, x1, y1, ge_mDynType1_Trend, 0, colortheme);

  if (x2 == 0 && y2 == 0)
    scale_x = scale_y = 0;
  else
    scale_x = scale_y = 1;

  if (scale_x || scale_y) {
    grow_MeasureNode(n1, &ll_x, &ll_y, &ur_x, &ur_y);
    if (scale_x)
      sx = (x2 - x1) / (ur_x - ll_x);
    else
      sx = 1;
    if (scale_y)
      sy = (y2 - y1) / (ur_y - ll_y);
    else
      sy = 1;
    grow_StoreTransform(n1);
    grow_SetObjectScale(n1, sx, sy, x1, y1, glow_eScaleType_LowerLeft);
  }
  graph->current_cmd_object = n1;

  grow_SetModified(graph->grow->ctx, 1);

  return graph->current_cmd_object;
}

grow_tObject gsc_CreatePolyLine(Graph *graph, double x1, double y1, double x2, double y2)
{
  glow_sPoint points[2];
  int point_cnt;

  points[0].x = x1;
  points[0].y = y1;
  points[1].x = x2;
  points[1].y = y2;
  point_cnt = 2;
  grow_CreateGrowPolyLine(graph->grow->ctx, "", (glow_sPoint*)&points,
			  point_cnt, graph->get_border_drawtype(), graph->linewidth, 0,
			  graph->fill, graph->border, graph->shadow, graph->get_fill_drawtype(),
			  0, NULL, &graph->current_cmd_object);
  grow_SetModified(graph->grow->ctx, 1);

  return graph->current_cmd_object;
}

void gsc_PolyLineAdd(Graph *graph, grow_tObject oid, double x, double y)
{
  glow_sPoint points[2];
  int point_cnt;

  points[0].x = x;
  points[0].y = y;
  point_cnt = 1;
  grow_AddPolyLinePoints(oid, (glow_sPoint*)&points, point_cnt);
  grow_SetModified(graph->grow->ctx, 1);
}

grow_tObject gsc_CreateArc(Graph *graph, double x1, double y1, double x2, double y2,
    int angle1, int angle2)
{
  grow_CreateGrowArc(graph->grow->ctx, "", x1, y1, x2, y2, angle1, angle2,
		     graph->get_border_drawtype(), graph->linewidth, graph->fill,
		     graph->border, graph->shadow, graph->get_fill_drawtype(), NULL,
		     &graph->current_cmd_object);
  grow_SetModified(graph->grow->ctx, 1);

  return graph->current_cmd_object;
}

grow_tObject gsc_CreateRectangle(Graph *graph, double x1, double y1, double w, double h)
{
  grow_CreateGrowRect(graph->grow->ctx, "", x1, y1, w, h,
		      graph->get_border_drawtype(), graph->linewidth, 0, glow_mDisplayLevel_1,
		      graph->fill,
		      graph->border, graph->shadow, graph->get_fill_drawtype(), NULL,
		      &graph->current_cmd_object);
  grow_SetModified(graph->grow->ctx, 1);

  return graph->current_cmd_object;
}

grow_tObject gsc_CreateLine(Graph *graph, double x1, double y1, double x2, double y2)
{
  grow_CreateGrowLine(graph->grow->ctx, "", x1, y1, x2, y2,
		      graph->get_border_drawtype(), graph->linewidth, 0, NULL,
		      &graph->current_cmd_object);
  grow_SetModified(graph->grow->ctx, 1);

  return graph->current_cmd_object;
}

