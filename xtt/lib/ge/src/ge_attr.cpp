/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* ge_attr.cpp -- Display object attributes */

#include "co_cdh.h"
#include "co_time.h"

#include "flow_browctx.h"

#include "flow_msg.h"

#include "ge_dyn.h"
#include "ge_msg.h"

Attr::~Attr()
{
}

Attr::Attr(void* a_parent_ctx, attr_eType a_type, void* a_object,
    attr_sItem* itemlist, int item_cnt)
    : parent_ctx(a_parent_ctx), type(a_type), embedded(0), input_open(0),
      object(a_object), close_cb(0), redraw_cb(0), get_subgraph_info_cb(0),
      get_dyn_info_cb(0), reconfigure_attr_cb(0), store_cb(0), recall_cb(0),
      set_data_cb(0), get_plant_select_cb(0), get_current_colors_cb(0),
      get_current_color_tone_cb(0), open_value_input_cb(), set_inputfocus_cb(0),
      traverse_inputfocus_cb(0), client_data(0), recall_idx(-1),
      original_data(0)
{
  if (type == attr_eType_ObjectTree)
    embedded = 1;
}

void Attr::store()
{
  if (store_cb)
    (store_cb)(parent_ctx, object);
}

void Attr::recall_next()
{
  int sts = 0;
  GeDyn* old_data = NULL;
  int idx;

  if (recall_idx == -1)
    idx = 0;
  else
    idx = recall_idx + 1;

  if (recall_cb)
    sts = (recall_cb)(parent_ctx, object, idx, &old_data);
  if (ODD(sts)) {
    if (recall_idx == -1 && !original_data) {
      original_data = old_data;
      recall_idx = 0;
    }
    recall_idx = idx;
    reconfigure_attr_c((void*)this);
  }
}

void Attr::recall_prev()
{
  int sts;
  GeDyn* old_p;

  if (recall_idx < 0)
    return;
  recall_idx--;
  if (recall_idx == -1) {
    // Get original data
    if (set_data_cb) {
      (set_data_cb)(parent_ctx, object, original_data);
      Attr::reconfigure_attr_c((void*)this);
      original_data = 0;
    }
  } else {
    if (recall_cb) {
      sts = (recall_cb)(parent_ctx, object, recall_idx, &old_p);
      if (ODD(sts)) {
        Attr::reconfigure_attr_c((void*)this);
        delete old_p;
      } else
        recall_idx++;
    }
  }
}

int Attr::get_plant_select_c(void* attr_ctx, char* value, int size)
{
  Attr* attr = (Attr*)attr_ctx;
  if (attr->get_plant_select_cb)
    return attr->get_plant_select_cb(attr->parent_ctx, value, size);
  return 0;
}

int Attr::get_current_colors_c(void* attr_ctx, glow_eDrawType* fill_color,
    glow_eDrawType* border_color, glow_eDrawType* text_color)
{
  Attr* attr = (Attr*)attr_ctx;
  if (attr->get_current_colors_cb)
    return attr->get_current_colors_cb(
        attr->parent_ctx, fill_color, border_color, text_color);
  return 0;
}

int Attr::get_current_color_tone_c(void* attr_ctx, glow_eDrawType* color_tone)
{
  Attr* attr = (Attr*)attr_ctx;
  if (attr->get_current_color_tone_cb)
    return attr->get_current_color_tone_cb(attr->parent_ctx, color_tone);
  return 0;
}

int Attr::get_subgraph_info_c(
    void* attr_ctx, char* name, attr_sItem** itemlist, int* item_cnt)
{
  Attr* attr = (Attr*)attr_ctx;
  if (attr->get_subgraph_info_cb)
    return attr->get_subgraph_info_cb(
        attr->parent_ctx, name, itemlist, item_cnt);
  return 0;
}

int Attr::get_dyn_info_c(
    void* attr_ctx, GeDyn* dyn, attr_sItem** itemlist, int* item_cnt)
{
  Attr* attr = (Attr*)attr_ctx;
  if (attr->get_dyn_info_cb)
    return attr->get_dyn_info_cb(attr->parent_ctx, dyn, itemlist, item_cnt);
  return 0;
}

void Attr::change_value_c(void* attr)
{
  ((Attr*)attr)->change_value();
}

int Attr::reconfigure_attr_c(void* attr)
{
  return ((Attr*)attr)->reconfigure_attr();
}

void Attr::get_object_list_c(void* attr_ctx, unsigned int type,
    grow_tObject** list, int* list_cnt, grow_tObject* parent, int parent_cnt)
{
  Attr* attr = (Attr*)attr_ctx;
  if (attr->get_object_list_cb)
    attr->get_object_list_cb(
        attr->parent_ctx, type, list, list_cnt, parent, parent_cnt);
}

int Attr::set_inputfocus_c(void* attr_ctx)
{
  Attr* attr = (Attr*)attr_ctx;
  if (attr->set_inputfocus_cb)
    return attr->set_inputfocus_cb(attr->parent_ctx, attr);
  return 0;
}

int Attr::traverse_inputfocus_c(void* attr_ctx)
{
  Attr* attr = (Attr*)attr_ctx;
  if (attr->traverse_inputfocus_cb)
    return attr->traverse_inputfocus_cb(attr->parent_ctx, attr);
  return 0;
}

void Attr::message(void* attr, int popup, char severity, const char* message)
{
  if (popup)
    ((Attr*)attr)->message_popup(severity, message);
  else
    ((Attr*)attr)->message(severity, message);
}

void Attr::refresh_objects(unsigned int type)
{
  attrnav->refresh_objects(type);
}

int Attr::set_attr_value(char* value_str)
{
  int sts;
  grow_tObject id;

  sts = attrnav->set_attr_value(value_str, &id, &client_data);
  if (redraw_cb)
    (redraw_cb)(parent_ctx, this, id, client_data);
  client_data = 0;
  return sts;
}
