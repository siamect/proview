/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* gedyn.cpp -- Display plant and node hiererachy */

#include <math.h>
#include <stdlib.h>

#include <iostream>

#include "co_cdh.h"
#include "co_dcli.h"
#include "co_msg.h"
#include "co_string.h"
#include "co_time.h"

#include "rt_gdh.h"
#include "rt_pwr_msg.h"

#include "glow_msg.h"

#include "ge_dyn.h"
#include "ge_methods.h"
#include "ge_msg.h"

// Until xtt_menu.h i unavailable...
#define xmenu_mUtility_Ge (1 << 5)
#define xmenu_eItemType_Object 1
#define xmenu_eItemType_AttrObject 2
#define xmenu_eItemType_Attribute 3
#define glow_cJBean_Offset 2
//#define glow_cJBean_SizeCorr 2

static int pdummy;

static int get_dig(
    pwr_tBoolean* val, pwr_tBoolean* p, int a_typeid, unsigned int bitmask)
{
  switch (a_typeid) {
  case pwr_eType_Boolean:
    *val = *p;
    break;
  case pwr_eType_Int32:
  case pwr_eType_UInt32:
    *val = *p == 0 ? 0 : 1;
    break;
  case pwr_eType_Int64:
  case pwr_eType_UInt64:
    *val = *(pwr_tUInt64*)p == 0 ? 0 : 1;
    break;
  case graph_eType_Bit:
    *val = ((*p & bitmask) != 0);
    break;
  case pwr_eType_Float32:
    // *val = *(pwr_tFloat32 *)p == 0 ? 0 : 1;
    *val = fabs(*(pwr_tFloat32*)p) > FLT_EPSILON ? 1 : 0;
    break;
  case pwr_eType_Float64:
    // *val = *(pwr_tFloat64 *)p == 0 ? 0 : 1;
    *val = fabs(*(pwr_tFloat64*)p) > DBL_EPSILON ? 1 : 0;
    break;
  case pwr_eType_String:
    *val = *(char*)p == 0 ? 0 : 1;
    break;
  case pwr_eType_Objid:
    *val = cdh_ObjidIsNull(*(pwr_tObjid*)p) ? 0 : 1;
    break;
  default:
    return 0;
  }
  return 1;
}

static int get_bit(char* parsed_name, int attr_type, unsigned int* bitmask)
{
  if (attr_type == graph_eType_Bit) {
    // Get bit number from parsed name
    char* s;
    int bitnum;

    if ((s = strrchr(parsed_name, '['))) {
      sscanf(s + 1, "%d", &bitnum);
      *s = 0;
      if (bitnum >= 0 && bitnum < 32) {
        *bitmask = 1 << bitnum;
        return 1;
      }
    }
  }
  return 0;
}

static int check_format(char* format, int type)
{
  char* s;

  s = strchr(format, '%');
  if (s == 0)
    return 0;
  s++;

  while (*s) {
    if (!(isdigit(*s) || *s == '.' || *s == '-' || *s == '+' || *s == '*'))
      break;
    s++;
  }
  if (*s == 0)
    return 0;

  switch (type) {
  case pwr_eType_Float32:
    if (*s == 'f' || *s == 'F' || *s == 'g' || *s == 'G' || *s == 'e'
        || *s == 'E')
      return 1;
    break;
  case pwr_eType_Float64:
    if (*s == 'f' || *s == 'F' || *s == 'g' || *s == 'G' || *s == 'e'
        || *s == 'E'
        || (*s == 'l' && (*(s + 1) == 'f' || *(s + 1) == 'F' || *(s + 1) == 'g'
                             || *(s + 1) == 'G')))
      return 1;
    break;
  case pwr_eType_String:
  case pwr_eType_Text:
  case pwr_eType_VolumeId:
  case graph_eType_NodeId:
    if (*s == 's')
      return 1;
    break;
  case pwr_eType_Int64:
    if (*s == 'd' || *s == 'i' || *s == 'o' || *s == 'x' || *s == 'X'
        || (*s == 'l' && (*(s + 1) == 'd' || *(s + 1) == 'i' || *(s + 1) == 'o'
                             || *(s + 1) == 'x' || *(s + 1) == 'X'))
        || (*s == 'l' && *(s + 1) == 'l'
               && (*(s + 2) == 'd' || *(s + 2) == 'i' || *(s + 2) == 'o'
                      || *(s + 2) == 'x' || *(s + 2) == 'X')))
      return 1;
    break;
  case pwr_eType_Int32:
    if (*s == 'd' || *s == 'i' || *s == 'o' || *s == 'x' || *s == 'X'
        || (*s == 'l' && (*(s + 1) == 'd' || *(s + 1) == 'i' || *(s + 1) == 'o'
                             || *(s + 1) == 'x' || *(s + 1) == 'X')))
      return 1;
    break;
  case pwr_eType_Int16:
    if (*s == 'd' || *s == 'i' || *s == 'o' || *s == 'x' || *s == 'X'
        || (*s == 'h' && (*(s + 1) == 'd' || *(s + 1) == 'i' || *(s + 1) == 'o'
                             || *(s + 1) == 'x' || *(s + 1) == 'X')))
      return 1;
    break;
  case pwr_eType_Int8:
    if (*s == 'd' || *s == 'i' || *s == 'o' || *s == 'x' || *s == 'X'
        || *s == 'c')
      return 1;
    break;
  case pwr_eType_UInt64:
    if (*s == 'd' || *s == 'u' || *s == 'o' || *s == 'x' || *s == 'X'
        || (*s == 'l' && (*(s + 1) == 'd' || *(s + 1) == 'u' || *(s + 1) == 'o'
                             || *(s + 1) == 'x' || *(s + 1) == 'X'))
        || (*s == 'l' && *(s + 1) == 'l'
               && (*(s + 2) == 'd' || *(s + 2) == 'u' || *(s + 2) == 'o'
                      || *(s + 2) == 'x' || *(s + 2) == 'X')))
      return 1;
    break;
  case pwr_eType_Boolean:
  case pwr_eType_UInt32:
    if (*s == 'd' || *s == 'u' || *s == 'o' || *s == 'x' || *s == 'X'
        || (*s == 'l' && (*(s + 1) == 'd' || *(s + 1) == 'u' || *(s + 1) == 'o'
                             || *(s + 1) == 'x' || *(s + 1) == 'X')))
      return 1;
    break;
  case pwr_eType_UInt16:
    if (*s == 'd' || *s == 'u' || *s == 'o' || *s == 'x' || *s == 'X'
        || (*s == 'h' && (*(s + 1) == 'd' || *(s + 1) == 'u' || *(s + 1) == 'o'
                             || *(s + 1) == 'x' || *(s + 1) == 'X')))
      return 1;
    break;
  case pwr_eType_Char:
  case pwr_eType_UInt8:
    if (*s == 'd' || *s == 'u' || *s == 'o' || *s == 'x' || *s == 'X'
        || *s == 'c')
      return 1;
    break;
  case pwr_eType_Time:
  case pwr_eType_DeltaTime:
    if (*s == 't')
      return 1;
    break;
  case pwr_eType_Objid:
  case pwr_eType_AttrRef:
  case pwr_eType_DataRef:
    if (*s == 'o' || *s == 's')
      return 1;
    break;
  case pwr_eType_Status:
  case pwr_eType_NetStatus:
    if (*s == 'm' || *s == 'd' || *s == 'u' || str_StartsWith(s, "hd")
        || str_StartsWith(s, "hu"))
      return 1;
    break;
  case pwr_eType_Enum:
    if (*s == 's' || *s == 'd' || *s == 'u' || *s == 'o' || *s == 'x'
        || *s == 'X'
        || (*s == 'l' && (*(s + 1) == 'd' || *(s + 1) == 'u' || *(s + 1) == 'o'
                             || *(s + 1) == 'x' || *(s + 1) == 'X')))
      return 1;
    break;
  case pwr_eType_Mask:
    if (*s == 'b' || *s == 'd' || *s == 'u' || *s == 'o' || *s == 'x'
        || *s == 'X'
        || (*s == 'l' && (*(s + 1) == 'd' || *(s + 1) == 'u' || *(s + 1) == 'o'
                             || *(s + 1) == 'x' || *(s + 1) == 'X')))
      return 1;
    break;
  default:;
  }
  return 0;
}

static void set_curve_default_color(
    int instance, glow_eDrawType* curve_color, glow_eDrawType* fill_color)
{
  if (*curve_color == glow_eDrawType_Inherit) {
    switch (instance) {
    case ge_mInstance_1:
      *curve_color = glow_eDrawType_Color145; // OrangeHigh5
      break;
    case ge_mInstance_2:
      *curve_color = glow_eDrawType_Color295; // GreenHigh5
      break;
    case ge_mInstance_3:
      *curve_color = glow_eDrawType_Color235; // BlueHigh5
      break;
    case ge_mInstance_4:
      *curve_color = glow_eDrawType_Color115; // YellowHigh5
      break;
    case ge_mInstance_5:
      *curve_color = glow_eDrawType_Color175; // RedHigh5
      break;
    case ge_mInstance_6:
      *curve_color = glow_eDrawType_Color205; // MagentaHigh5
      break;
    case ge_mInstance_7:
      *curve_color = glow_eDrawType_Color85; // YellowGreenHigh5
      break;
    case ge_mInstance_8:
      *curve_color = glow_eDrawType_Color265; // SeaBlueHigh5
      break;
    default:;
    }
  }
  if (*fill_color == glow_eDrawType_Inherit) {
    switch (instance) {
    case ge_mInstance_1:
      *fill_color = glow_eDrawType_Color139; // OrangeMedium9
      break;
    case ge_mInstance_2:
      *fill_color = glow_eDrawType_Color289; // GreenMedium9
      break;
    case ge_mInstance_3:
      *fill_color = glow_eDrawType_Color229; // BlueMedium9
      break;
    case ge_mInstance_4:
      *fill_color = glow_eDrawType_Color109; // YellowMedium9
      break;
    case ge_mInstance_5:
      *fill_color = glow_eDrawType_Color169; // RedMedium9
      break;
    case ge_mInstance_6:
      *fill_color = glow_eDrawType_Color199; // MagentaMedium9
      break;
    case ge_mInstance_7:
      *fill_color = glow_eDrawType_Color79; // YellowGreenMedium9
      break;
    case ge_mInstance_8:
      *fill_color = glow_eDrawType_Color259; // SeaBlueMedium9
      break;
    default:;
    }
  }
}

static int dyn_get_typeid(char* format)
{
  // Guess the type of the annot variable...
  if (strchr(format, 'f'))
    return pwr_eType_Float32;
  if (strchr(format, 'd'))
    return pwr_eType_Int32;
  if (strchr(format, 's'))
    return pwr_eType_String;
  if (strchr(format, 'o'))
    return pwr_eType_Objid;
  if (strchr(format, 'm'))
    return pwr_eType_Status;
  return pwr_eType_Int32;
}

GeDyn::GeDyn(Graph* d_graph, ge_eDynAttr d_attr_editor)
    : elements(0), graph(d_graph), ignore_color(false), reset_color(false),
      ignore_bgcolor(false), reset_bgcolor(false), ignore_invisible(false),
      reset_invisible(false), dyn_type1(ge_mDynType1_Inherit),
      dyn_type2(ge_mDynType2_No), total_dyn_type1(ge_mDynType1_Inherit),
      total_dyn_type2(ge_mDynType2_No), action_type1(ge_mActionType1_Inherit),
      action_type2(ge_mActionType2_No),
      total_action_type1(ge_mActionType1_Inherit),
      total_action_type2(ge_mActionType2_No), access(glow_mAccess_RtDefault),
      cycle(glow_eCycle_Inherit), attr_editor(d_attr_editor)
{
  strcpy(recursive_hostobject, "");
}

// Replace " to \"
char* GeDyn::cmd_cnv(char* instr)
{
  static char outstr[200];
  char* in;
  char* out = outstr;

  for (in = instr; *in != 0; in++) {
    if (*in == '"')
      *out++ = '\\';
    *out++ = *in;
  }
  *out = *in;
  return outstr;
}

int GeDyn::instance_to_number(int instance)
{
  int inst = 1;
  unsigned int m = instance;
  while (m > 1) {
    m = m >> 1;
    inst++;
  }
  return inst;
}

void GeDyn::replace_attribute(
    char* attribute, int attr_size, char* from, char* to, int* cnt, int strict)
{
  char str[200];
  char tmp[200];
  char* s;
  int offs;

  strncpy(str, attribute, sizeof(str));
  if (!strict)
    str_ToLower(str, str);
  s = strstr(str, from);
  if (s) {
    offs = (int)(s - str);
    strcpy(tmp, &attribute[offs] + strlen(from));
    strncpy(&attribute[offs], to, attr_size - offs);
    attribute[attr_size - 1] = 0;
    strncat(attribute, tmp, attr_size - strlen(attribute));

    (*cnt)++;
  }
}

GeDyn::GeDyn(const GeDyn& x)
    : elements(0), graph(x.graph), dyn_type1(x.dyn_type1),
      dyn_type2(x.dyn_type2), total_dyn_type1(x.total_dyn_type1),
      total_dyn_type2(x.total_dyn_type2), action_type1(x.action_type1),
      action_type2(x.action_type2), total_action_type1(x.total_action_type1),
      total_action_type2(x.total_action_type2), access(x.access),
      cycle(x.cycle), attr_editor(x.attr_editor)
{
  GeDynElem *elem, *e;

  strcpy(recursive_hostobject, x.recursive_hostobject);

  for (elem = x.elements; elem; elem = elem->next) {
    e = 0;
    switch (elem->dyn_type1) {
    case ge_mDynType1_DigLowColor:
      e = new GeDigLowColor((const GeDigLowColor&)*elem);
      break;
    case ge_mDynType1_DigColor:
      e = new GeDigColor((const GeDigColor&)*elem);
      break;
    case ge_mDynType1_DigError:
      e = new GeDigError((const GeDigError&)*elem);
      break;
    case ge_mDynType1_DigWarning:
      e = new GeDigWarning((const GeDigWarning&)*elem);
      break;
    case ge_mDynType1_DigFlash:
      e = new GeDigFlash((const GeDigFlash&)*elem);
      break;
    case ge_mDynType1_Invisible:
      e = new GeInvisible((const GeInvisible&)*elem);
      break;
    case ge_mDynType1_DigBorder:
      e = new GeDigBorder((const GeDigBorder&)*elem);
      break;
    case ge_mDynType1_DigText:
      e = new GeDigText((const GeDigText&)*elem);
      break;
    case ge_mDynType1_Value:
      e = new GeValue((const GeValue&)*elem);
      break;
    case ge_mDynType1_AnalogColor:
      e = new GeAnalogColor((const GeAnalogColor&)*elem);
      break;
    case ge_mDynType1_Rotate:
      e = new GeRotate((const GeRotate&)*elem);
      break;
    case ge_mDynType1_Move:
      e = new GeMove((const GeMove&)*elem);
      break;
    case ge_mDynType1_DigShift:
      e = new GeDigShift((const GeDigShift&)*elem);
      break;
    case ge_mDynType1_AnalogShift:
      e = new GeAnalogShift((const GeAnalogShift&)*elem);
      break;
    case ge_mDynType1_Video:
      e = new GeVideo((const GeVideo&)*elem);
      break;
    case ge_mDynType1_Animation:
      e = new GeAnimation((const GeAnimation&)*elem);
      break;
    case ge_mDynType1_Bar:
      e = new GeBar((const GeBar&)*elem);
      break;
    case ge_mDynType1_Trend:
      e = new GeTrend((const GeTrend&)*elem);
      break;
    case ge_mDynType1_FillLevel:
      e = new GeFillLevel((const GeFillLevel&)*elem);
      break;
    case ge_mDynType1_FastCurve:
      e = new GeFastCurve((const GeFastCurve&)*elem);
      break;
    case ge_mDynType1_AnalogText:
      e = new GeAnalogText((const GeAnalogText&)*elem);
      break;
    case ge_mDynType1_Table:
      e = new GeTable((const GeTable&)*elem);
      break;
    case ge_mDynType1_StatusColor:
      e = new GeStatusColor((const GeStatusColor&)*elem);
      break;
    case ge_mDynType1_HostObject:
      e = new GeHostObject((const GeHostObject&)*elem);
      break;
    case ge_mDynType1_DigSound:
      e = new GeDigSound((const GeDigSound&)*elem);
      break;
    case ge_mDynType1_XY_Curve:
      e = new GeXY_Curve((const GeXY_Curve&)*elem);
      break;
    case ge_mDynType1_DigCommand:
      e = new GeDigCommand((const GeDigCommand&)*elem);
      break;
    case ge_mDynType1_Pie:
      e = new GePie((const GePie&)*elem);
      break;
    case ge_mDynType1_BarChart:
      e = new GeBarChart((const GeBarChart&)*elem);
      break;
    default:;
    }
    switch (elem->dyn_type2) {
    case ge_mDynType2_Axis:
      e = new GeAxis((const GeAxis&)*elem);
      break;
    case ge_mDynType2_DigTextColor:
      e = new GeDigTextColor((const GeDigTextColor&)*elem);
      break;
    case ge_mDynType2_TimeoutColor:
      e = new GeTimeoutColor((const GeTimeoutColor&)*elem);
      break;
    case ge_mDynType2_DigFourShift:
      e = new GeDigFourShift((const GeDigFourShift&)*elem);
      break;
    case ge_mDynType2_ScrollingText:
      e = new GeScrollingText((const GeScrollingText&)*elem);
      break;
    case ge_mDynType2_ColorThemeLightness:
      e = new GeColorThemeLightness((const GeColorThemeLightness&)*elem);
      break;
    case ge_mDynType2_DigBackgroundColor:
      e = new GeDigBackgroundColor((const GeDigBackgroundColor&)*elem);
      break;
    case ge_mDynType2_DigSwap:
      e = new GeDigSwap((const GeDigSwap&)*elem);
      break;
    case ge_mDynType2_DigScript:
      e = new GeDigScript((const GeDigScript&)*elem);
      break;
    case ge_mDynType2_RefUpdate:
      e = new GeRefUpdate((const GeRefUpdate&)*elem);
      break;
    case ge_mDynType2_DsTrend:
      e = new GeDsTrend((const GeDsTrend&)*elem);
      break;
    case ge_mDynType2_DsTrendCurve:
      e = new GeDsTrendCurve((const GeDsTrendCurve&)*elem);
      break;
    case ge_mDynType2_SevHist:
      e = new GeSevHist((const GeSevHist&)*elem);
      break;
    default:;
    }
    switch (elem->action_type1) {
    case ge_mActionType1_PopupMenu:
      e = new GePopupMenu((const GePopupMenu&)*elem);
      break;
    case ge_mActionType1_SetDig:
      e = new GeSetDig((const GeSetDig&)*elem);
      break;
    case ge_mActionType1_ResetDig:
      e = new GeResetDig((const GeResetDig&)*elem);
      break;
    case ge_mActionType1_ToggleDig:
      e = new GeToggleDig((const GeToggleDig&)*elem);
      break;
    case ge_mActionType1_StoDig:
      e = new GeStoDig((const GeStoDig&)*elem);
      break;
    case ge_mActionType1_Command:
      e = new GeCommand((const GeCommand&)*elem);
      break;
    case ge_mActionType1_CommandDoubleClick:
      e = new GeCommandDoubleClick((const GeCommandDoubleClick&)*elem);
      break;
    case ge_mActionType1_Confirm:
      e = new GeConfirm((const GeConfirm&)*elem);
      break;
    case ge_mActionType1_IncrAnalog:
      e = new GeIncrAnalog((const GeIncrAnalog&)*elem);
      break;
    case ge_mActionType1_RadioButton:
      e = new GeRadioButton((const GeRadioButton&)*elem);
      break;
    case ge_mActionType1_Slider:
      e = new GeSlider((const GeSlider&)*elem);
      break;
    case ge_mActionType1_ValueInput:
      e = new GeValueInput((const GeValueInput&)*elem);
      break;
    case ge_mActionType1_TipText:
      e = new GeTipText((const GeTipText&)*elem);
      break;
    case ge_mActionType1_Help:
      e = new GeHelp((const GeHelp&)*elem);
      break;
    case ge_mActionType1_OpenGraph:
      e = new GeOpenGraph((const GeOpenGraph&)*elem);
      break;
    case ge_mActionType1_OpenURL:
      e = new GeOpenURL((const GeOpenURL&)*elem);
      break;
    case ge_mActionType1_InputFocus:
      e = new GeInputFocus((const GeInputFocus&)*elem);
      break;
    case ge_mActionType1_CloseGraph:
      e = new GeCloseGraph((const GeCloseGraph&)*elem);
      break;
    case ge_mActionType1_PulldownMenu:
      e = new GePulldownMenu((const GePulldownMenu&)*elem);
      break;
    case ge_mActionType1_OptionMenu:
      e = new GeOptionMenu((const GeOptionMenu&)*elem);
      break;
    case ge_mActionType1_SetValue:
      e = new GeSetValue((const GeSetValue&)*elem);
      break;
    case ge_mActionType1_MethodToolbar:
      e = new GeMethodToolbar((const GeMethodToolbar&)*elem);
      break;
    case ge_mActionType1_MethodPulldownMenu:
      e = new GeMethodPulldownMenu((const GeMethodPulldownMenu&)*elem);
      break;
    case ge_mActionType1_Script:
      e = new GeScript((const GeScript&)*elem);
      break;
    case ge_mActionType1_CatchSignal:
      e = new GeCatchSignal((const GeCatchSignal&)*elem);
      break;
    case ge_mActionType1_EmitSignal:
      e = new GeEmitSignal((const GeEmitSignal&)*elem);
      break;
    default:;
    }
    switch (elem->action_type2) {
    default:;
    }
    if (e)
      insert_element(e);
  }

  // update_elements();
}

GeDyn::~GeDyn()
{
  GeDynElem *elem, *next;

  for (elem = elements; elem; elem = next) {
    next = elem->next;
    delete elem;
  }
}

void GeDyn::save(std::ofstream& fp)
{
  fp << int(ge_eSave_Dyn) << '\n';
  fp << int(ge_eSave_Dyn_dyn_type1) << FSPACE << int(dyn_type1) << '\n';
  fp << int(ge_eSave_Dyn_dyn_type2) << FSPACE << int(dyn_type2) << '\n';
  fp << int(ge_eSave_Dyn_action_type1) << FSPACE << int(action_type1) << '\n';
  fp << int(ge_eSave_Dyn_action_type2) << FSPACE << int(action_type2) << '\n';
  fp << int(ge_eSave_Dyn_access) << FSPACE << int(access) << '\n';
  fp << int(ge_eSave_Dyn_cycle) << FSPACE << int(cycle) << '\n';

  for (GeDynElem* elem = elements; elem; elem = elem->next) {
    elem->save(fp);
  }
  fp << int(ge_eSave_End) << '\n';
}

void GeDyn::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  int tmp;
  char dummy[40];
  GeDynElem* e;
  int errcnt = 0;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeDyn: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    e = 0;
    switch (type) {
    case ge_eSave_Dyn:
      break;
    case ge_eSave_Dyn_dyn_type1:
      fp >> tmp;
      dyn_type1 = (ge_mDynType1)tmp;
      break;
    case ge_eSave_Dyn_dyn_type2:
      fp >> tmp;
      dyn_type2 = (ge_mDynType2)tmp;
      break;
    case ge_eSave_Dyn_action_type1:
      fp >> tmp;
      action_type1 = (ge_mActionType1)tmp;
      break;
    case ge_eSave_Dyn_action_type2:
      fp >> tmp;
      action_type2 = (ge_mActionType2)tmp;
      break;
    case ge_eSave_Dyn_access:
      fp >> tmp;
      access = (glow_mAccess)tmp;
      break;
    case ge_eSave_Dyn_cycle:
      fp >> tmp;
      cycle = (glow_eCycle)tmp;
      break;
    case ge_eSave_DigLowColor:
      e = (GeDynElem*)new GeDigLowColor(this);
      break;
    case ge_eSave_DigColor:
      e = (GeDynElem*)new GeDigColor(this);
      break;
    case ge_eSave_DigWarning:
      e = (GeDynElem*)new GeDigWarning(this);
      break;
    case ge_eSave_DigError:
      e = (GeDynElem*)new GeDigError(this);
      break;
    case ge_eSave_DigFlash:
      e = (GeDynElem*)new GeDigFlash(this);
      break;
    case ge_eSave_Invisible:
      e = (GeDynElem*)new GeInvisible(this);
      break;
    case ge_eSave_DigBorder:
      e = (GeDynElem*)new GeDigBorder(this);
      break;
    case ge_eSave_DigText:
      e = (GeDynElem*)new GeDigText(this);
      break;
    case ge_eSave_Value:
      e = (GeDynElem*)new GeValue(this);
      break;
    case ge_eSave_ValueInput:
      e = (GeDynElem*)new GeValueInput(this);
      break;
    case ge_eSave_AnalogColor:
      e = (GeDynElem*)new GeAnalogColor(this);
      break;
    case ge_eSave_Rotate:
      e = (GeDynElem*)new GeRotate(this);
      break;
    case ge_eSave_Move:
      e = (GeDynElem*)new GeMove(this);
      break;
    case ge_eSave_AnalogShift:
      e = (GeDynElem*)new GeAnalogShift(this);
      break;
    case ge_eSave_DigShift:
      e = (GeDynElem*)new GeDigShift(this);
      break;
    case ge_eSave_DigFourShift:
      e = (GeDynElem*)new GeDigFourShift(this);
      break;
    case ge_eSave_ScrollingText:
      e = (GeDynElem*)new GeScrollingText(this);
      break;
    case ge_eSave_ColorThemeLightness:
      e = (GeDynElem*)new GeColorThemeLightness(this);
      break;
    case ge_eSave_DigBackgroundColor:
      e = (GeDynElem*)new GeDigBackgroundColor(this);
      break;
    case ge_eSave_DigSwap:
      e = (GeDynElem*)new GeDigSwap(this);
      break;
    case ge_eSave_DigScript:
      e = (GeDynElem*)new GeDigScript(this);
      break;
    case ge_eSave_RefUpdate:
      e = (GeDynElem*)new GeRefUpdate(this);
      break;
    case ge_eSave_Animation:
      e = (GeDynElem*)new GeAnimation(this);
      break;
    case ge_eSave_Video:
      e = (GeDynElem*)new GeVideo(this);
      break;
    case ge_eSave_Bar:
      e = (GeDynElem*)new GeBar(this);
      break;
    case ge_eSave_Trend:
      e = (GeDynElem*)new GeTrend(this);
      break;
    case ge_eSave_FillLevel:
      e = (GeDynElem*)new GeFillLevel(this);
      break;
    case ge_eSave_FastCurve:
      e = (GeDynElem*)new GeFastCurve(this);
      break;
    case ge_eSave_AnalogText:
      e = (GeDynElem*)new GeAnalogText(this);
      break;
    case ge_eSave_Table:
      e = (GeDynElem*)new GeTable(this);
      break;
    case ge_eSave_StatusColor:
      e = (GeDynElem*)new GeStatusColor(this);
      break;
    case ge_eSave_Pie:
      e = (GeDynElem*)new GePie(this);
      break;
    case ge_eSave_BarChart:
      e = (GeDynElem*)new GeBarChart(this);
      break;
    case ge_eSave_Axis:
      e = (GeDynElem*)new GeAxis(this);
      break;
    case ge_eSave_DigTextColor:
      e = (GeDynElem*)new GeDigTextColor(this);
      break;
    case ge_eSave_TimeoutColor:
      e = (GeDynElem*)new GeTimeoutColor(this);
      break;
    case ge_eSave_HostObject:
      e = (GeDynElem*)new GeHostObject(this);
      break;
    case ge_eSave_DigSound:
      e = (GeDynElem*)new GeDigSound(this);
      break;
    case ge_eSave_XY_Curve:
      e = (GeDynElem*)new GeXY_Curve(this);
      break;
    case ge_eSave_DsTrend:
      e = (GeDynElem*)new GeDsTrend(this);
      break;
    case ge_eSave_DsTrendCurve:
      e = (GeDynElem*)new GeDsTrendCurve(this);
      break;
    case ge_eSave_SevHist:
      e = (GeDynElem*)new GeSevHist(this);
      break;
    case ge_eSave_DigCommand:
      e = (GeDynElem*)new GeDigCommand(this);
      break;
    case ge_eSave_PopupMenu:
      e = (GeDynElem*)new GePopupMenu(this);
      break;
    case ge_eSave_SetDig:
      e = (GeDynElem*)new GeSetDig(this);
      break;
    case ge_eSave_ResetDig:
      e = (GeDynElem*)new GeResetDig(this);
      break;
    case ge_eSave_ToggleDig:
      e = (GeDynElem*)new GeToggleDig(this);
      break;
    case ge_eSave_StoDig:
      e = (GeDynElem*)new GeStoDig(this);
      break;
    case ge_eSave_Command:
      e = (GeDynElem*)new GeCommand(this);
      break;
    case ge_eSave_CommandDC:
      e = (GeDynElem*)new GeCommandDoubleClick(this);
      break;
    case ge_eSave_Confirm:
      e = (GeDynElem*)new GeConfirm(this);
      break;
    case ge_eSave_IncrAnalog:
      e = (GeDynElem*)new GeIncrAnalog(this);
      break;
    case ge_eSave_RadioButton:
      e = (GeDynElem*)new GeRadioButton(this);
      break;
    case ge_eSave_Slider:
      e = (GeDynElem*)new GeSlider(this);
      break;
    case ge_eSave_TipText:
      e = (GeDynElem*)new GeTipText(this);
      break;
    case ge_eSave_Help:
      e = (GeDynElem*)new GeHelp(this);
      break;
    case ge_eSave_OpenGraph:
      e = (GeDynElem*)new GeOpenGraph(this);
      break;
    case ge_eSave_OpenURL:
      e = (GeDynElem*)new GeOpenURL(this);
      break;
    case ge_eSave_InputFocus:
      e = (GeDynElem*)new GeInputFocus(this);
      break;
    case ge_eSave_CloseGraph:
      e = (GeDynElem*)new GeCloseGraph(this);
      break;
    case ge_eSave_PulldownMenu:
      e = (GeDynElem*)new GePulldownMenu(this);
      break;
    case ge_eSave_OptionMenu:
      e = (GeDynElem*)new GeOptionMenu(this);
      break;
    case ge_eSave_SetValue:
      e = (GeDynElem*)new GeSetValue(this);
      break;
    case ge_eSave_MethodToolbar:
      e = (GeDynElem*)new GeMethodToolbar(this);
      break;
    case ge_eSave_MethodPulldownMenu:
      e = (GeDynElem*)new GeMethodPulldownMenu(this);
      break;
    case ge_eSave_Script:
      e = (GeDynElem*)new GeScript(this);
      break;
    case ge_eSave_CatchSignal:
      e = (GeDynElem*)new GeCatchSignal(this);
      break;
    case ge_eSave_EmitSignal:
      e = (GeDynElem*)new GeEmitSignal(this);
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeDyn:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
      errcnt++;
      if (errcnt > 20)
        exit(0);
    }
    if (e) {
      insert_element(e);
      e->open(fp);
    }
    if (end_found)
      break;
  }
}

void GeDyn::update_dyntype(grow_tObject object)
{
  total_dyn_type1 = get_dyntype1(object);
  total_dyn_type2 = get_dyntype2(object);
  total_action_type1 = get_actiontype1(object);
  total_action_type2 = get_actiontype2(object);
}

ge_mDynType1 GeDyn::get_dyntype1(grow_tObject object)
{
  if (object && dyn_type1 & ge_mDynType1_Inherit) {
    if (grow_GetObjectType(object) == glow_eObjectType_GrowNode
        || grow_GetObjectType(object) == glow_eObjectType_GrowSlider
        || grow_GetObjectType(object) == glow_eObjectType_GrowGroup) {
      int inherit_dyn_type1;
      int inherit_dyn_type2;
      int inherit_action_type1;
      int inherit_action_type2;

      grow_GetObjectClassDynType(object, &inherit_dyn_type1, &inherit_dyn_type2,
          &inherit_action_type1, &inherit_action_type2);
      return (ge_mDynType1)(
          (dyn_type1 & ~ge_mDynType1_Inherit) | inherit_dyn_type1);
    }
  }
  return dyn_type1;
}

ge_mDynType2 GeDyn::get_dyntype2(grow_tObject object)
{
  if (object && dyn_type1 & ge_mDynType1_Inherit) {
    if (grow_GetObjectType(object) == glow_eObjectType_GrowNode
        || grow_GetObjectType(object) == glow_eObjectType_GrowSlider
        || grow_GetObjectType(object) == glow_eObjectType_GrowGroup) {
      int inherit_dyn_type1;
      int inherit_dyn_type2;
      int inherit_action_type1;
      int inherit_action_type2;

      grow_GetObjectClassDynType(object, &inherit_dyn_type1, &inherit_dyn_type2,
          &inherit_action_type1, &inherit_action_type2);
      return (ge_mDynType2)(dyn_type2 | inherit_dyn_type2);
    }
  }
  return dyn_type2;
}

ge_mActionType1 GeDyn::get_actiontype1(grow_tObject object)
{
  if (object && action_type1 & ge_mActionType1_Inherit) {
    if (grow_GetObjectType(object) == glow_eObjectType_GrowNode
        || grow_GetObjectType(object) == glow_eObjectType_GrowSlider
        || grow_GetObjectType(object) == glow_eObjectType_GrowGroup) {
      int inherit_dyn_type1;
      int inherit_dyn_type2;
      int inherit_action_type1;
      int inherit_action_type2;

      grow_GetObjectClassDynType(object, &inherit_dyn_type1, &inherit_dyn_type2,
          &inherit_action_type1, &inherit_action_type2);
      return (ge_mActionType1)(
          (action_type1 & ~ge_mActionType1_Inherit) | inherit_action_type1);
    }
  }
  return action_type1;
}

ge_mActionType2 GeDyn::get_actiontype2(grow_tObject object)
{
  if (object && action_type1 & ge_mActionType1_Inherit) {
    if (grow_GetObjectType(object) == glow_eObjectType_GrowNode
        || grow_GetObjectType(object) == glow_eObjectType_GrowSlider
        || grow_GetObjectType(object) == glow_eObjectType_GrowGroup) {
      int inherit_dyn_type1;
      int inherit_dyn_type2;
      int inherit_action_type1;
      int inherit_action_type2;

      grow_GetObjectClassDynType(object, &inherit_dyn_type1, &inherit_dyn_type2,
          &inherit_action_type1, &inherit_action_type2);
      return (ge_mActionType2)(action_type2 | inherit_action_type2);
    }
  }
  return action_type2;
}

void GeDyn::unset_inherit(grow_tObject object)
{
  dyn_type1 = get_dyntype1(object);
  action_type1 = get_actiontype1(object);
}

glow_eDrawType GeDyn::get_color1(grow_tObject object, glow_eDrawType color)
{
  if (color == glow_eDrawType_Inherit) {
    glow_eDrawType color1;
    glow_eDrawType color2;

    grow_GetObjectClassTraceColor(object, &color1, &color2);
    return color1;
  }
  return color;
}

glow_eDrawType GeDyn::get_color2(grow_tObject object, glow_eDrawType color)
{
  if (color == glow_eDrawType_Inherit) {
    glow_eDrawType color1;
    glow_eDrawType color2;

    grow_GetObjectClassTraceColor(object, &color1, &color2);
    return color2;
  }
  return color;
}

void GeDyn::get_attributes(
    grow_tObject object, attr_sItem* itemlist, int* item_count)
{
  attr_sItem* attrinfo;
  int i;

  total_dyn_type1 = get_dyntype1(object);
  total_dyn_type2 = get_dyntype2(object);
  total_action_type1 = get_actiontype1(object);
  total_action_type2 = get_actiontype2(object);
  display_access = false;

  update_elements();

  attrinfo = itemlist;

  i = *item_count;

  for (GeDynElem* elem = elements; elem; elem = elem->next)
    elem->get_attributes(itemlist, &i);

  if (display_access) {
    strcpy(attrinfo[i].name, "Access");
    attrinfo[i].value = &access;
    attrinfo[i].type = glow_eType_Access;
    attrinfo[i++].size = sizeof(access);
  }

  if (attr_editor != ge_eDynAttr_Menu) {
    strcpy(attrinfo[i].name, "Cycle");
    attrinfo[i].value = &cycle;
    attrinfo[i].type = glow_eType_Cycle;
    attrinfo[i++].size = sizeof(cycle);

    strcpy(attrinfo[i].name, "DynType1");
    attrinfo[i].value = &dyn_type1;
    if (total_dyn_type1 & ge_mDynType1_Tone)
      attrinfo[i].type = ge_eAttrType_DynTypeTone;
    else
      attrinfo[i].type = ge_eAttrType_DynType1;
    if (total_dyn_type1 & ge_mDynType1_Bar
        || total_dyn_type1 & ge_mDynType1_Trend
        || total_dyn_type1 & ge_mDynType1_Table
        || total_dyn_type1 & ge_mDynType1_FastCurve
        || total_dyn_type1 & ge_mDynType1_XY_Curve)
      attrinfo[i].noedit = 1;
    attrinfo[i].mask = ~(ge_mDynType1_Bar | ge_mDynType1_Trend
        | ge_mDynType1_Table | ge_mDynType1_FastCurve | ge_mDynType1_XY_Curve
        | ge_mDynType1_SliderBackground);
    attrinfo[i++].size = sizeof(dyn_type1);

    strcpy(attrinfo[i].name, "DynType2");
    attrinfo[i].value = &dyn_type2;
    attrinfo[i].type = ge_eAttrType_DynType2;
    attrinfo[i++].size = sizeof(dyn_type2);
  } else {
    strcpy(attrinfo[i].name, "DynType1");
    attrinfo[i].value = &dyn_type1;
    attrinfo[i].type = ge_eAttrType_DynType1;
    attrinfo[i].mask = ge_mDynType1_Invisible;
    attrinfo[i++].size = sizeof(dyn_type1);
  }

  strcpy(attrinfo[i].name, "Action");
  attrinfo[i].value = &action_type1;
  attrinfo[i].type = ge_eAttrType_ActionType1;
  attrinfo[i].mask = ~ge_mActionType1_Slider;
  attrinfo[i++].size = sizeof(action_type1);

  *item_count = i;
}

void GeDyn::get_transtab(grow_tObject object, char** tt)
{
  int sts;
  static char transtab[][32] = { "SubGraph", "SubGraph", "Dynamic", "", "" };

  total_dyn_type1 = get_dyntype1(object);
  total_dyn_type2 = get_dyntype2(object);
  total_action_type1 = get_actiontype1(object);
  total_action_type2 = get_actiontype2(object);

  update_elements();
  *tt = 0;
  for (GeDynElem* elem = elements; elem; elem = elem->next) {
    sts = elem->get_transtab(tt);
    if (!sts)
      return;
  }
  if (!*tt)
    *tt = (char*)transtab;
}

void GeDyn::set_attribute(
    grow_tObject object, const char* attr_name, int second)
{
  int cnt = second + 1;

  total_dyn_type1 = get_dyntype1(object);
  total_dyn_type2 = get_dyntype2(object);
  total_action_type1 = get_actiontype1(object);
  total_action_type2 = get_actiontype2(object);

  update_elements();

  for (GeDynElem* elem = elements; elem; elem = elem->next) {
    elem->set_attribute(object, attr_name, &cnt);
    if (!cnt)
      break;
  }
  if (cnt)
    graph->message('E', "Nothing to connect for this object");
}

void GeDyn::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  for (GeDynElem* elem = elements; elem; elem = elem->next)
    elem->replace_attribute(from, to, cnt, strict);
}

void GeDyn::set_color(grow_tObject object, glow_eDrawType color)
{
  int sts = 0;

  total_dyn_type1 = get_dyntype1(object);
  total_dyn_type2 = get_dyntype2(object);
  total_action_type1 = get_actiontype1(object);
  total_action_type2 = get_actiontype2(object);

  update_elements();

  for (GeDynElem* elem = elements; elem; elem = elem->next) {
    sts = elem->set_color(object, color);
    if (sts)
      break;
  }
  if (!sts)
    graph->message('E', "No color to set for this object");
}

void GeDyn::set_access(glow_mAccess acc)
{
  access = acc;
}

void GeDyn::set_dyn(ge_mDynType1 type1, ge_mDynType2 type2,
    ge_mActionType1 action1, ge_mActionType2 action2)
{
  dyn_type1 = type1;
  dyn_type2 = type2;
  action_type1 = action1;
  action_type2 = action2;
  update_elements();
}

void GeDyn::set_command(const char* cmd)
{
  for (GeDynElem* elem = elements; elem; elem = elem->next) {
    if (elem->action_type1 == ge_mActionType1_Command) {
      strncpy(((GeCommand*)elem)->command, cmd,
          sizeof(((GeCommand*)elem)->command));
      ((GeCommand*)elem)->command[sizeof(((GeCommand*)elem)->command) - 1] = 0;
      break;
    }
  }
}

void GeDyn::set_hostobject(char* hostobject)
{
  for (GeDynElem* elem = elements; elem; elem = elem->next) {
    if (elem->dyn_type1 == ge_mDynType1_HostObject) {
      strncpy(((GeHostObject*)elem)->hostobject, hostobject,
          sizeof(((GeHostObject*)elem)->hostobject));
      break;
    }
  }
}

void GeDyn::get_hostobject(char* hostobject)
{
  bool found = false;

  for (GeDynElem* elem = elements; elem; elem = elem->next) {
    if (elem->dyn_type1 == ge_mDynType1_HostObject) {
      strcpy(hostobject, ((GeHostObject*)elem)->hostobject);
      found = true;
      break;
    }
  }
  if (!found && !streq(recursive_hostobject, ""))
    strcpy(hostobject, recursive_hostobject);
}

// Replace " by \"
char* GeDyn::printstr(char* str)
{
  char *s, *t;
  static char res[256];

  for (s = str, t = res; *s; s++, t++) {
    if (*s == '"')
      *t++ = '\\';
    *t = *s;
  }
  *t = 0;
  return res;
}

graph_eDatabase GeDyn::parse_attr_name(char* name, char* parsed_name,
    int* inverted, int* type, int* size, int* elem, graph_mParseOpt options)
{
  char* s;

  if ((total_dyn_type1 & ge_mDynType1_HostObject
          || !streq(recursive_hostobject, ""))
      && (s = strstr(name, "$hostobject"))) {
    // Replace string $hostobject with host object
    pwr_tAName hostobject;
    pwr_tAName n;

    get_hostobject(hostobject);
    strncpy(n, name, s - name);
    strcpy(&n[s - name], hostobject);
    strcat(n, s + strlen("$hostobject"));

    return graph->parse_attr_name(
        n, parsed_name, inverted, type, size, elem, options);
  }
  return graph->parse_attr_name(
      name, parsed_name, inverted, type, size, elem, options);
}
void GeDyn::set_value_input(
    const char* format, double min_value, double max_value)
{
  for (GeDynElem* elem = elements; elem; elem = elem->next) {
    if (elem->action_type1 == ge_mActionType1_ValueInput) {
      GeValueInput* e = (GeValueInput*)elem;
      if (!e->value_element) {
        for (GeDynElem* elem2 = elements; elem2; elem2 = elem2->next) {
          if (elem2->dyn_type1 == ge_mDynType1_Value) {
            e->value_element = (GeValue*)elem2;
            e->annot_typeid = e->value_element->annot_typeid;
            e->annot_size = e->value_element->annot_size;
            break;
          }
        }
        if (!e->value_element)
          return;
      }
      strcpy(e->value_element->format, format);
      e->min_value = min_value;
      e->max_value = max_value;
      break;
    }
  }
}

int GeDyn::get_attr_typeid()
{
  for (GeDynElem* elem = elements; elem; elem = elem->next) {
    if (elem->dyn_type1 == ge_mDynType1_Value)
      return ((GeValue*)elem)->annot_typeid;
  }
  return 0;
}

int* GeDyn::ref_slider_disabled()
{
  for (GeDynElem* elem = elements; elem; elem = elem->next) {
    if (elem->action_type1 == ge_mActionType1_Slider)
      return &((GeSlider*)elem)->slider_disabled;
  }
  return 0;
}

int GeDyn::get_slider_disabled()
{
  for (GeDynElem* elem = elements; elem; elem = elem->next) {
    if (elem->action_type1 == ge_mActionType1_Slider)
      return ((GeSlider*)elem)->slider_disabled;
  }
  return 0;
}

int* GeDyn::ref_trend_hold()
{
  for (GeDynElem* elem = elements; elem; elem = elem->next) {
    if (elem->dyn_type1 == ge_mDynType1_Trend)
      return &((GeTrend*)elem)->trend_hold;
  }
  return 0;
}

double* GeDyn::ref_trend_scantime()
{
  for (GeDynElem* elem = elements; elem; elem = elem->next) {
    if (elem->dyn_type1 == ge_mDynType1_Trend)
      return &((GeTrend*)elem)->scan_time;
  }
  return 0;
}

void* GeDyn::get_p()
{
  for (GeDynElem* elem = elements; elem; elem = elem->next) {
    if (elem->dyn_type1 == ge_mDynType1_DigLowColor)
      return ((GeDigLowColor*)elem)->p;
    else if (elem->dyn_type1 == ge_mDynType1_Value)
      return ((GeValue*)elem)->p;
  }
  return 0;
}

void GeDyn::set_p(grow_tObject object, void* p)
{
  for (GeDynElem* elem = elements; elem; elem = elem->next) {
    if (elem->dyn_type1 == ge_mDynType1_Value) {
      glow_sTraceData* data;
      grow_GetTraceAttr(object, &data);
      data->p = p;
      grow_SetTraceAttr(object, data);

      ((GeValue*)elem)->p = p;
      break;
    } else if (elem->dyn_type1 == ge_mDynType1_DigLowColor) {
      glow_sTraceData* data;
      grow_GetTraceAttr(object, &data);
      data->p = p;
      grow_SetTraceAttr(object, data);

      ((GeDigLowColor*)elem)->p = (pwr_tBoolean*)p;
      break;
    }
  }
}

void GeDyn::update()
{
  for (GeDynElem* elem = elements; elem; elem = elem->next)
    elem->update();
}

void GeDyn::update_elements()
{
  GeDynElem *elem, *prev, *next;

  // Remove
  prev = 0;
  elem = elements;
  while (elem) {
    if ((elem->dyn_type1 && !(elem->dyn_type1 & total_dyn_type1))
        || (elem->action_type1 && !(elem->action_type1 & total_action_type1))
        || (elem->dyn_type2 && !(elem->dyn_type2 & total_dyn_type2))
        || (elem->action_type2 && !(elem->action_type2 & total_action_type2))) {
      // Type is not valid, remove element
      if (!prev)
        elements = elem->next;
      else
        prev->next = elem->next;
      next = elem->next;
      delete elem;
      elem = next;
    } else if (elem->instance != ge_mInstance_1) {
      // Check if instance is valid
      GeDynElem* mask_elem = elem;
      while (mask_elem) {
        if (mask_elem->instance == ge_mInstance_1)
          break;
        mask_elem = mask_elem->next;
      }
      if (mask_elem && !(mask_elem->instance_mask & elem->instance)) {
        // Instance is not valid, remove element
        if (!prev)
          elements = elem->next;
        else
          prev->next = elem->next;
        next = elem->next;
        delete elem;
        elem = next;
      } else {
        prev = elem;
        elem = elem->next;
      }
    } else {
      prev = elem;
      elem = elem->next;
    }
  }

  // Insert new
  int mask;
  bool found;
  GeDynElem* e;
  int i_mask;
  bool i_found;
  GeDynElem* i_elem;

  mask = 1;
  for (int i = 0; i < 32; i++) {
    if (mask & total_dyn_type1) {
      found = false;
      for (elem = elements; elem; elem = elem->next) {
        if (elem->dyn_type1 == mask && elem->instance == ge_mInstance_1) {
          found = true;

          if (elem->instance_mask > ge_mInstance_1) {
            // Check instance
            i_mask = ge_mInstance_1;
            for (int j = 0; j < 32; j++) {
              i_found = false;
              for (i_elem = elements; i_elem; i_elem = i_elem->next) {
                if (i_elem->dyn_type1 == mask
                    && i_elem->instance & elem->instance_mask
                    && i_elem->instance == i_mask) {
                  i_found = true;
                  break;
                }
              }
              if (!i_found && i_mask & elem->instance_mask) {
                e = create_dyn1_element(mask, i_mask);
                if (e)
                  insert_element(e);
              }
              i_mask = i_mask << 1;
            }
          }
          break;
        }
      }
      if (!found) {
        // Create this element
        e = create_dyn1_element(mask, ge_mInstance_1);
        if (e)
          insert_element(e);
      }
    }
    mask = mask << 1;
  }

  mask = 1;
  for (int i = 0; i < 32; i++) {
    if (mask & total_dyn_type2) {
      found = false;
      for (elem = elements; elem; elem = elem->next) {
        if (elem->dyn_type2 == mask && elem->instance == ge_mInstance_1) {
          found = true;

          if (elem->instance_mask > ge_mInstance_1) {
            // Check instance
            i_mask = ge_mInstance_1;
            for (int j = 0; j < 32; j++) {
              i_found = false;
              for (i_elem = elements; i_elem; i_elem = i_elem->next) {
                if (i_elem->dyn_type2 == mask
                    && i_elem->instance & elem->instance_mask
                    && i_elem->instance == i_mask) {
                  i_found = true;
                  break;
                }
              }
              if (!i_found && i_mask & elem->instance_mask) {
                e = create_dyn2_element(mask, i_mask);
                if (e)
                  insert_element(e);
              }
              i_mask = i_mask << 1;
            }
          }
          break;
        }
      }
      if (!found) {
        // Create this element
        e = create_dyn2_element(mask, ge_mInstance_1);
        if (e)
          insert_element(e);
      }
    }
    mask = mask << 1;
  }

  mask = 1;
  for (int i = 0; i < 32; i++) {
    if (mask & total_action_type1) {
      found = false;
      for (elem = elements; elem; elem = elem->next) {
        if (elem->action_type1 == mask && elem->instance == ge_mInstance_1) {
          found = true;

          if (elem->instance_mask > ge_mInstance_1) {
            // Check instance
            i_mask = ge_mInstance_1;
            for (int j = 0; j < 32; j++) {
              i_found = false;
              for (i_elem = elements; i_elem; i_elem = i_elem->next) {
                if (i_elem->action_type1 == mask
                    && i_elem->instance & elem->instance_mask
                    && i_elem->instance == i_mask) {
                  i_found = true;
                  break;
                }
              }
              if (!i_found && i_mask & elem->instance_mask) {
                e = create_action1_element(mask, i_mask);
                if (e)
                  insert_element(e);
              }
              i_mask = i_mask << 1;
            }
          }
          break;
        }
      }
      if (!found) {
        // Create this element
        e = create_action1_element(mask, ge_mInstance_1);
        if (e)
          insert_element(e);
      }
    }
    mask = mask << 1;
  }

  mask = 1;
  for (int i = 0; i < 32; i++) {
    if (mask & total_action_type2) {
      found = false;
      for (elem = elements; elem; elem = elem->next) {
        if (elem->action_type2 == mask && elem->instance == ge_mInstance_1) {
          found = true;

          if (elem->instance_mask > ge_mInstance_1) {
            // Check instance
            i_mask = ge_mInstance_1;
            for (int j = 0; j < 32; j++) {
              i_found = false;
              for (i_elem = elements; i_elem; i_elem = i_elem->next) {
                if (i_elem->action_type2 == mask
                    && i_elem->instance & elem->instance_mask
                    && i_elem->instance == i_mask) {
                  i_found = true;
                  break;
                }
              }
              if (!i_found && i_mask & elem->instance_mask) {
                e = create_action2_element(mask, i_mask);
                if (e)
                  insert_element(e);
              }
              i_mask = i_mask << 1;
            }
          }
          break;
        }
      }
      if (!found) {
        // Create this element
        e = create_action2_element(mask, ge_mInstance_1);
        if (e)
          insert_element(e);
      }
    }
    mask = mask << 1;
  }

  // Update PulldownMenu items
  for (elem = elements; elem; elem = elem->next) {
    if (elem->action_type1 == ge_mActionType1_PulldownMenu) {
      GePulldownMenu* pm = (GePulldownMenu*)elem;
      for (int i = 0; i < 32; i++) {
        if (pm->items_dyn[i]) {
          pm->items_dyn[i]->total_dyn_type1 = pm->items_dyn[i]->dyn_type1;
          pm->items_dyn[i]->total_dyn_type2 = pm->items_dyn[i]->dyn_type2;
          pm->items_dyn[i]->total_action_type1 = pm->items_dyn[i]->action_type1;
          pm->items_dyn[i]->total_action_type2 = pm->items_dyn[i]->action_type2;
          pm->items_dyn[i]->update_elements();
        }
      }
    }
  }
}

GeDynElem* GeDyn::create_action1_element(int mask, int instance)
{
  GeDynElem* e = 0;

  switch (mask) {
  case ge_mActionType1_PopupMenu:
    e = (GeDynElem*)new GePopupMenu(this);
    break;
  case ge_mActionType1_SetDig:
    e = (GeDynElem*)new GeSetDig(this, (ge_mInstance)instance);
    break;
  case ge_mActionType1_ResetDig:
    e = (GeDynElem*)new GeResetDig(this, (ge_mInstance)instance);
    break;
  case ge_mActionType1_ToggleDig:
    e = (GeDynElem*)new GeToggleDig(this);
    break;
  case ge_mActionType1_StoDig:
    e = (GeDynElem*)new GeStoDig(this);
    break;
  case ge_mActionType1_Command:
    e = (GeDynElem*)new GeCommand(this);
    break;
  case ge_mActionType1_CommandDoubleClick:
    e = (GeDynElem*)new GeCommandDoubleClick(this);
    break;
  case ge_mActionType1_Confirm:
    e = (GeDynElem*)new GeConfirm(this);
    break;
  case ge_mActionType1_IncrAnalog:
    e = (GeDynElem*)new GeIncrAnalog(this);
    break;
  case ge_mActionType1_RadioButton:
    e = (GeDynElem*)new GeRadioButton(this);
    break;
  case ge_mActionType1_Slider:
    e = (GeDynElem*)new GeSlider(this);
    break;
  case ge_mActionType1_ValueInput:
    e = (GeDynElem*)new GeValueInput(this);
    break;
  case ge_mActionType1_TipText:
    e = (GeDynElem*)new GeTipText(this);
    break;
  case ge_mActionType1_Help:
    e = (GeDynElem*)new GeHelp(this);
    break;
  case ge_mActionType1_OpenGraph:
    e = (GeDynElem*)new GeOpenGraph(this);
    break;
  case ge_mActionType1_OpenURL:
    e = (GeDynElem*)new GeOpenURL(this);
    break;
  case ge_mActionType1_InputFocus:
    e = (GeDynElem*)new GeInputFocus(this);
    break;
  case ge_mActionType1_CloseGraph:
    e = (GeDynElem*)new GeCloseGraph(this);
    break;
  case ge_mActionType1_PulldownMenu:
    e = (GeDynElem*)new GePulldownMenu(this);
    break;
  case ge_mActionType1_OptionMenu:
    e = (GeDynElem*)new GeOptionMenu(this);
    break;
  case ge_mActionType1_SetValue:
    e = (GeDynElem*)new GeSetValue(this, (ge_mInstance)instance);
    break;
  case ge_mActionType1_MethodToolbar:
    e = (GeDynElem*)new GeMethodToolbar(this, (ge_mInstance)instance);
    break;
  case ge_mActionType1_MethodPulldownMenu:
    e = (GeDynElem*)new GeMethodPulldownMenu(this);
    break;
  case ge_mActionType1_Script:
    e = (GeDynElem*)new GeScript(this);
    break;
  case ge_mActionType1_CatchSignal:
    e = (GeDynElem*)new GeCatchSignal(this);
    break;
  case ge_mActionType1_EmitSignal:
    e = (GeDynElem*)new GeEmitSignal(this);
    break;
  default:;
  }
  return e;
}

GeDynElem* GeDyn::create_action2_element(int mask, int instance)
{
  GeDynElem* e = 0;

  switch (mask) {
  default:;
  }
  return e;
}

GeDynElem* GeDyn::create_dyn1_element(int mask, int instance)
{
  GeDynElem* e = 0;

  switch (mask) {
  case ge_mDynType1_DigLowColor:
    e = (GeDynElem*)new GeDigLowColor(this);
    break;
  case ge_mDynType1_DigColor:
    e = (GeDynElem*)new GeDigColor(this, (ge_mInstance)instance);
    break;
  case ge_mDynType1_DigWarning:
    e = (GeDynElem*)new GeDigWarning(this);
    break;
  case ge_mDynType1_DigError:
    e = (GeDynElem*)new GeDigError(this);
    break;
  case ge_mDynType1_DigFlash:
    e = (GeDynElem*)new GeDigFlash(this);
    break;
  case ge_mDynType1_Invisible:
    e = (GeDynElem*)new GeInvisible(this, (ge_mInstance)instance);
    break;
  case ge_mDynType1_DigBorder:
    e = (GeDynElem*)new GeDigBorder(this);
    break;
  case ge_mDynType1_DigText:
    e = (GeDynElem*)new GeDigText(this, (ge_mInstance)instance);
    break;
  case ge_mDynType1_Value:
    e = (GeDynElem*)new GeValue(this, (ge_mInstance)instance);
    break;
  case ge_mDynType1_AnalogColor:
    e = (GeDynElem*)new GeAnalogColor(this, (ge_mInstance)instance);
    break;
  case ge_mDynType1_Rotate:
    e = (GeDynElem*)new GeRotate(this);
    break;
  case ge_mDynType1_Move:
    e = (GeDynElem*)new GeMove(this);
    break;
  case ge_mDynType1_AnalogShift:
    e = (GeDynElem*)new GeAnalogShift(this);
    break;
  case ge_mDynType1_DigShift:
    e = (GeDynElem*)new GeDigShift(this);
    break;
  case ge_mDynType1_Animation:
    e = (GeDynElem*)new GeAnimation(this);
    break;
  case ge_mDynType1_Video:
    e = (GeDynElem*)new GeVideo(this);
    break;
  case ge_mDynType1_Bar:
    e = (GeDynElem*)new GeBar(this);
    break;
  case ge_mDynType1_Trend:
    e = (GeDynElem*)new GeTrend(this);
    break;
  case ge_mDynType1_FillLevel:
    e = (GeDynElem*)new GeFillLevel(this);
    break;
  case ge_mDynType1_FastCurve:
    e = (GeDynElem*)new GeFastCurve(this);
    break;
  case ge_mDynType1_AnalogText:
    e = (GeDynElem*)new GeAnalogText(this);
    break;
  case ge_mDynType1_Table:
    e = (GeDynElem*)new GeTable(this);
    break;
  case ge_mDynType1_StatusColor:
    e = (GeDynElem*)new GeStatusColor(this);
    break;
  case ge_mDynType1_Pie:
    e = (GeDynElem*)new GePie(this);
    break;
  case ge_mDynType1_BarChart:
    e = (GeDynElem*)new GeBarChart(this);
    break;
  case ge_mDynType1_HostObject:
    e = (GeDynElem*)new GeHostObject(this);
    break;
  case ge_mDynType1_DigSound:
    e = (GeDynElem*)new GeDigSound(this, (ge_mInstance)instance);
    break;
  case ge_mDynType1_XY_Curve:
    e = (GeDynElem*)new GeXY_Curve(this, (ge_mInstance)instance);
    break;
  case ge_mDynType1_DigCommand:
    e = (GeDynElem*)new GeDigCommand(this, (ge_mInstance)instance);
    break;
  default:;
  }
  return e;
}

GeDynElem* GeDyn::create_dyn2_element(int mask, int instance)
{
  GeDynElem* e = 0;

  switch (mask) {
  case ge_mDynType2_Axis:
    e = (GeDynElem*)new GeAxis(this);
    break;
  case ge_mDynType2_DigTextColor:
    e = (GeDynElem*)new GeDigTextColor(this);
    break;
  case ge_mDynType2_TimeoutColor:
    e = (GeDynElem*)new GeTimeoutColor(this);
    break;
  case ge_mDynType2_DigFourShift:
    e = (GeDynElem*)new GeDigFourShift(this);
    break;
  case ge_mDynType2_ScrollingText:
    e = (GeDynElem*)new GeScrollingText(this);
    break;
  case ge_mDynType2_ColorThemeLightness:
    e = (GeDynElem*)new GeColorThemeLightness(this);
    break;
  case ge_mDynType2_DigBackgroundColor:
    e = (GeDynElem*)new GeDigBackgroundColor(this, (ge_mInstance)instance);
    break;
  case ge_mDynType2_DigSwap:
    e = (GeDynElem*)new GeDigSwap(this, (ge_mInstance)instance);
    break;
  case ge_mDynType2_DigScript:
    e = (GeDynElem*)new GeDigScript(this, (ge_mInstance)instance);
    break;
  case ge_mDynType2_RefUpdate:
    e = (GeDynElem*)new GeRefUpdate(this, (ge_mInstance)instance);
    break;
  case ge_mDynType2_DsTrend:
    e = (GeDynElem*)new GeDsTrend(this);
    break;
  case ge_mDynType2_DsTrendCurve:
    e = (GeDynElem*)new GeDsTrendCurve(this);
    break;
  case ge_mDynType2_SevHist:
    e = (GeDynElem*)new GeSevHist(this);
    break;
  default:;
  }
  return e;
}

GeDynElem* GeDyn::copy_element(GeDynElem& x)
{
  GeDynElem* e = 0;

  if (x.action_type1) {
    switch (x.action_type1) {
    case ge_mActionType1_PopupMenu:
      e = (GeDynElem*)new GePopupMenu((GePopupMenu&)x);
      break;
    case ge_mActionType1_SetDig:
      e = (GeDynElem*)new GeSetDig((GeSetDig&)x);
      break;
    case ge_mActionType1_ResetDig:
      e = (GeDynElem*)new GeResetDig((GeResetDig&)x);
      break;
    case ge_mActionType1_ToggleDig:
      e = (GeDynElem*)new GeToggleDig((GeToggleDig&)x);
      break;
    case ge_mActionType1_StoDig:
      e = (GeDynElem*)new GeStoDig((GeStoDig&)x);
      break;
    case ge_mActionType1_Command:
      e = (GeDynElem*)new GeCommand((GeCommand&)x);
      break;
    case ge_mActionType1_CommandDoubleClick:
      e = (GeDynElem*)new GeCommandDoubleClick((GeCommandDoubleClick&)x);
      break;
    case ge_mActionType1_Confirm:
      e = (GeDynElem*)new GeConfirm((GeConfirm&)x);
      break;
    case ge_mActionType1_IncrAnalog:
      e = (GeDynElem*)new GeIncrAnalog((GeIncrAnalog&)x);
      break;
    case ge_mActionType1_RadioButton:
      e = (GeDynElem*)new GeRadioButton((GeRadioButton&)x);
      break;
    case ge_mActionType1_Slider:
      e = (GeDynElem*)new GeSlider((GeSlider&)x);
      break;
    case ge_mActionType1_ValueInput:
      e = (GeDynElem*)new GeValueInput((GeValueInput&)x);
      break;
    case ge_mActionType1_TipText:
      e = (GeDynElem*)new GeTipText((GeTipText&)x);
      break;
    case ge_mActionType1_Help:
      e = (GeDynElem*)new GeHelp((GeHelp&)x);
      break;
    case ge_mActionType1_OpenGraph:
      e = (GeDynElem*)new GeOpenGraph((GeOpenGraph&)x);
      break;
    case ge_mActionType1_OpenURL:
      e = (GeDynElem*)new GeOpenURL((GeOpenURL&)x);
      break;
    case ge_mActionType1_InputFocus:
      e = (GeDynElem*)new GeInputFocus((GeInputFocus&)x);
      break;
    case ge_mActionType1_CloseGraph:
      e = (GeDynElem*)new GeCloseGraph((GeCloseGraph&)x);
      break;
    case ge_mActionType1_PulldownMenu:
      e = (GeDynElem*)new GePulldownMenu((GePulldownMenu&)x);
      break;
    case ge_mActionType1_OptionMenu:
      e = (GeDynElem*)new GeOptionMenu((GeOptionMenu&)x);
      break;
    case ge_mActionType1_SetValue:
      e = (GeDynElem*)new GeSetValue((GeSetValue&)x);
      break;
    case ge_mActionType1_MethodToolbar:
      e = (GeDynElem*)new GeMethodToolbar((GeMethodToolbar&)x);
      break;
    case ge_mActionType1_MethodPulldownMenu:
      e = (GeDynElem*)new GeMethodPulldownMenu((GeMethodPulldownMenu&)x);
      break;
    case ge_mActionType1_Script:
      e = (GeDynElem*)new GeScript((GeScript&)x);
      break;
    case ge_mActionType1_CatchSignal:
      e = (GeDynElem*)new GeCatchSignal((GeCatchSignal&)x);
      break;
    case ge_mActionType1_EmitSignal:
      e = (GeDynElem*)new GeEmitSignal((GeEmitSignal&)x);
      break;
    default:;
    }
  } else if (x.action_type2) {
    switch (x.action_type2) {
    default:;
    }
  } else if (x.dyn_type1) {
    switch (x.dyn_type1) {
    case ge_mDynType1_DigLowColor:
      e = (GeDynElem*)new GeDigLowColor((GeDigLowColor&)x);
      break;
    case ge_mDynType1_DigColor:
      e = (GeDynElem*)new GeDigColor((GeDigColor&)x);
      break;
    case ge_mDynType1_DigWarning:
      e = (GeDynElem*)new GeDigWarning((GeDigWarning&)x);
      break;
    case ge_mDynType1_DigError:
      e = (GeDynElem*)new GeDigError((GeDigError&)x);
      break;
    case ge_mDynType1_DigFlash:
      e = (GeDynElem*)new GeDigFlash((GeDigFlash&)x);
      break;
    case ge_mDynType1_Invisible:
      e = (GeDynElem*)new GeInvisible((GeInvisible&)x);
      break;
    case ge_mDynType1_DigBorder:
      e = (GeDynElem*)new GeDigBorder((GeDigBorder&)x);
      break;
    case ge_mDynType1_DigText:
      e = (GeDynElem*)new GeDigText((GeDigText&)x);
      break;
    case ge_mDynType1_Value:
      e = (GeDynElem*)new GeValue((GeValue&)x);
      break;
    case ge_mDynType1_AnalogColor:
      e = (GeDynElem*)new GeAnalogColor((GeAnalogColor&)x);
      break;
    case ge_mDynType1_Rotate:
      e = (GeDynElem*)new GeRotate((GeRotate&)x);
      break;
    case ge_mDynType1_Move:
      e = (GeDynElem*)new GeMove((GeMove&)x);
      break;
    case ge_mDynType1_AnalogShift:
      e = (GeDynElem*)new GeAnalogShift((GeAnalogShift&)x);
      break;
    case ge_mDynType1_DigShift:
      e = (GeDynElem*)new GeDigShift((GeDigShift&)x);
      break;
    case ge_mDynType1_Animation:
      e = (GeDynElem*)new GeAnimation((GeAnimation&)x);
      break;
    case ge_mDynType1_Video:
      e = (GeDynElem*)new GeVideo((GeVideo&)x);
      break;
    case ge_mDynType1_Bar:
      e = (GeDynElem*)new GeBar((GeBar&)x);
      break;
    case ge_mDynType1_Trend:
      e = (GeDynElem*)new GeTrend((GeTrend&)x);
      break;
    case ge_mDynType1_XY_Curve:
      e = (GeDynElem*)new GeXY_Curve((GeXY_Curve&)x);
      break;
    case ge_mDynType1_DigCommand:
      e = (GeDynElem*)new GeDigCommand((GeDigCommand&)x);
      break;
    case ge_mDynType1_FillLevel:
      e = (GeDynElem*)new GeFillLevel((GeFillLevel&)x);
      break;
    case ge_mDynType1_FastCurve:
      e = (GeDynElem*)new GeFastCurve((GeFastCurve&)x);
      break;
    case ge_mDynType1_AnalogText:
      e = (GeDynElem*)new GeAnalogText((GeAnalogText&)x);
      break;
    case ge_mDynType1_Table:
      e = (GeDynElem*)new GeTable((GeTable&)x);
      break;
    case ge_mDynType1_StatusColor:
      e = (GeDynElem*)new GeStatusColor((GeStatusColor&)x);
      break;
    case ge_mDynType1_Pie:
      e = (GeDynElem*)new GePie((GePie&)x);
      break;
    case ge_mDynType1_BarChart:
      e = (GeDynElem*)new GeBarChart((GeBarChart&)x);
      break;
    case ge_mDynType1_HostObject:
      e = (GeDynElem*)new GeHostObject((GeHostObject&)x);
      break;
    case ge_mDynType1_DigSound:
      e = (GeDynElem*)new GeDigSound((GeDigSound&)x);
      break;
    default:;
    }
  } else if (x.dyn_type2) {
    switch (x.dyn_type2) {
    case ge_mDynType2_Axis:
      e = (GeDynElem*)new GeAxis((GeAxis&)x);
      break;
    case ge_mDynType2_DigTextColor:
      e = (GeDynElem*)new GeDigTextColor((GeDigTextColor&)x);
      break;
    case ge_mDynType2_TimeoutColor:
      e = (GeDynElem*)new GeTimeoutColor((GeTimeoutColor&)x);
      break;
    case ge_mDynType2_DigFourShift:
      e = (GeDynElem*)new GeDigFourShift((GeDigFourShift&)x);
      break;
    case ge_mDynType2_ScrollingText:
      e = (GeDynElem*)new GeScrollingText((GeScrollingText&)x);
      break;
    case ge_mDynType2_ColorThemeLightness:
      e = (GeDynElem*)new GeColorThemeLightness((GeColorThemeLightness&)x);
      break;
    case ge_mDynType2_DigBackgroundColor:
      e = (GeDynElem*)new GeDigBackgroundColor((GeDigBackgroundColor&)x);
      break;
    case ge_mDynType2_DigSwap:
      e = (GeDynElem*)new GeDigSwap((GeDigSwap&)x);
      break;
    case ge_mDynType2_DigScript:
      e = (GeDynElem*)new GeDigScript((GeDigScript&)x);
      break;
    case ge_mDynType2_RefUpdate:
      e = (GeDynElem*)new GeRefUpdate((GeRefUpdate&)x);
      break;
    case ge_mDynType2_DsTrend:
      e = (GeDynElem*)new GeDsTrend((GeDsTrend&)x);
      break;
    case ge_mDynType2_DsTrendCurve:
      e = (GeDynElem*)new GeDsTrendCurve((GeDsTrendCurve&)x);
      break;
    case ge_mDynType2_SevHist:
      e = (GeDynElem*)new GeSevHist((GeSevHist&)x);
      break;
    default:;
    }
  }

  if (e)
    e->dyn = this;
  return e;
}

void GeDyn::insert_element(GeDynElem* e)
{
  GeDynElem *elem, *prev;

  e->dyn = this;
  elem = elements;
  prev = 0;
  while (elem) {
    if (elem->prio > e->prio)
      break;
    if (elem->prio == e->prio
        && (unsigned int)elem->instance < (unsigned int)e->instance)
      break;
    prev = elem;
    elem = elem->next;
  }
  if (prev) {
    e->next = prev->next;
    prev->next = e;
  } else {
    e->next = elements;
    elements = e;
  }
}

void GeDyn::merge(GeDyn& x)
{
  GeDynElem *elem, *xelem, *prev, *next;
  GeDynElem* e;

  dyn_type1 = (ge_mDynType1)(dyn_type1 | x.dyn_type1);
  total_dyn_type1 = (ge_mDynType1)(total_dyn_type1 | x.total_dyn_type1);
  action_type1 = (ge_mActionType1)(action_type1 | x.action_type1);
  total_action_type1
      = (ge_mActionType1)(total_action_type1 | x.total_action_type1);

  for (xelem = x.elements; xelem; xelem = xelem->next) {
    prev = 0;
    for (elem = elements; elem; elem = elem->next) {
      if (elem->dyn_type1 == xelem->dyn_type1
          && elem->dyn_type2 == xelem->dyn_type2
          && elem->action_type1 == xelem->action_type1
          && elem->action_type2 == xelem->action_type2
          && elem->instance == xelem->instance) {
        // Element exists in both, use element in x, i.e. remove current element
        if (!prev)
          elements = elem->next;
        else
          prev->next = elem->next;
        next = elem->next;
        delete elem;
        elem = next;
        break;
      }
      prev = elem;
    }
    // Insert copy of x element
    e = copy_element(*xelem);
    if (e)
      insert_element(e);
  }
}

int GeDyn::disconnect(grow_tObject object)
{
  for (GeDynElem* elem = elements; elem; elem = elem->next)
    elem->disconnect(object);
  return 1;
}

int GeDyn::connect(grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int inherit_dyn_type1;
  int inherit_dyn_type2;
  int inherit_action_type1;
  int inherit_action_type2;

  if (grow_GetObjectType(object) == glow_eObjectType_GrowBar
      || grow_GetObjectType(object) == glow_eObjectType_GrowBarArc
      || grow_GetObjectType(object) == glow_eObjectType_GrowTable
      || grow_GetObjectType(object) == glow_eObjectType_GrowWindow
      || grow_GetObjectType(object) == glow_eObjectType_GrowXYCurve
      || grow_GetObjectType(object) == glow_eObjectType_GrowTrend
      || grow_GetObjectType(object) == glow_eObjectType_GrowPie
      || grow_GetObjectType(object) == glow_eObjectType_GrowBarChart
      || grow_GetObjectType(object) == glow_eObjectType_GrowAxis
      || grow_GetObjectType(object) == glow_eObjectType_GrowAxisArc
      || grow_GetObjectType(object) == glow_eObjectType_GrowToolbar) {
    if (cycle == glow_eCycle_Inherit)
      cycle = glow_eCycle_Slow;
    if (dyn_type1 & ge_mDynType1_Inherit)
      dyn_type1 = ge_mDynType1(dyn_type1 & ~ge_mDynType1_Inherit);
    if (action_type1 & ge_mActionType1_Inherit)
      action_type1 = ge_mActionType1(action_type1 & ~ge_mActionType1_Inherit);
  }

  if (dyn_type1 & ge_mDynType1_Inherit) {
    grow_GetObjectClassDynType(object, &inherit_dyn_type1, &inherit_dyn_type2,
        &inherit_action_type1, &inherit_action_type2);
    total_dyn_type1 = ge_mDynType1(dyn_type1 | inherit_dyn_type1);
    total_dyn_type2 = ge_mDynType2(dyn_type2 | inherit_dyn_type2);
  } else {
    total_dyn_type1 = dyn_type1;
    total_dyn_type2 = dyn_type2;
  }

  if (action_type1 & ge_mActionType1_Inherit) {
    grow_GetObjectClassDynType(object, &inherit_dyn_type1, &inherit_dyn_type2,
        &inherit_action_type1, &inherit_action_type2);
    total_action_type1 = ge_mActionType1(action_type1 | inherit_action_type1);
    total_action_type2 = ge_mActionType2(action_type2 | inherit_action_type2);
  } else {
    total_action_type1 = action_type1;
    total_action_type2 = action_type2;
  }

  if (cycle == glow_eCycle_Inherit)
    grow_GetObjectClassCycle(object, &cycle);

  for (GeDynElem* elem = elements; elem; elem = elem->next)
    elem->connect(object, trace_data, now);
  return 1;
}

int GeDyn::scan(grow_tObject object)
{
  int sts;

  reset_color = false;
  ignore_color = false;
  reset_bgcolor = false;
  ignore_bgcolor = false;
  reset_invisible = false;

  ignore_invisible = false;
  reset_text_a1 = false;
  ignore_text_a1 = false;
  for (GeDynElem* elem = elements; elem; elem = elem->next) {
    sts = elem->scan(object);
    if (sts == GE__NO_PROPAGATE || sts == GLOW__TERMINATED
        || sts == GLOW__SUBTERMINATED || sts == GLOW__SWAPTERMINATED)
      return sts;
  }
  return 1;
}

int GeDyn::action(grow_tObject object, glow_tEvent event)
{
  int sts;

  for (GeDynElem* elem = elements; elem; elem = elem->next) {
    sts = elem->action(object, event);
    if (sts == GE__NO_PROPAGATE || sts == GLOW__TERMINATED
        || sts == GLOW__SUBTERMINATED || sts == GLOW__SWAPTERMINATED)
      return sts;
  }
  return 1;
}

int GeDyn::confirmed_action(grow_tObject object, glow_tEvent event)
{
  int sts;

  total_action_type1
      = (ge_mActionType1)(total_action_type1 & ~ge_mActionType1_Confirm);

  for (GeDynElem* elem = elements; elem; elem = elem->next) {
    sts = elem->action(object, event);
    if (sts == GE__NO_PROPAGATE || sts == GLOW__TERMINATED
        || sts == GLOW__SUBTERMINATED || sts == GLOW__SWAPTERMINATED)
      return sts;
  }

  total_action_type1
      = (ge_mActionType1)(total_action_type1 | ge_mActionType1_Confirm);
  return 1;
}

int GeDyn::change_value(grow_tObject object, char* text)
{
  for (GeDynElem* elem = elements; elem; elem = elem->next)
    elem->change_value(object, text);
  return 1;
}

void GeDyn::export_java(grow_tObject object, std::ofstream& fp, char* var_name)
{
  int inherit_dyn_type1, inherit_action_type1;
  int inherit_dyn_type2, inherit_action_type2;

  if (grow_GetObjectType(object) == glow_eObjectType_GrowBar
      || grow_GetObjectType(object) == glow_eObjectType_GrowBarArc
      || grow_GetObjectType(object) == glow_eObjectType_GrowTable
      || grow_GetObjectType(object) == glow_eObjectType_GrowWindow
      || grow_GetObjectType(object) == glow_eObjectType_GrowXYCurve
      || grow_GetObjectType(object) == glow_eObjectType_GrowTrend) {
    if (cycle == glow_eCycle_Inherit)
      cycle = glow_eCycle_Slow;
    if (dyn_type1 & ge_mDynType1_Inherit)
      dyn_type1 = ge_mDynType1(dyn_type1 & ~ge_mDynType1_Inherit);
    if (action_type1 & ge_mActionType1_Inherit)
      action_type1 = ge_mActionType1(action_type1 & ~ge_mActionType1_Inherit);
  }

  if (dyn_type1 & ge_mDynType1_Inherit) {
    grow_GetObjectClassDynType(object, &inherit_dyn_type1, &inherit_dyn_type2,
        &inherit_action_type1, &inherit_action_type2);
    total_dyn_type1 = ge_mDynType1(dyn_type1 | inherit_dyn_type1);
    total_dyn_type2 = ge_mDynType2(dyn_type2 | inherit_dyn_type2);
  } else {
    total_dyn_type1 = dyn_type1;
    total_dyn_type2 = dyn_type2;
  }

  if (action_type1 & ge_mActionType1_Inherit) {
    grow_GetObjectClassDynType(object, &inherit_dyn_type1, &inherit_dyn_type2,
        &inherit_action_type1, &inherit_action_type2);
    total_action_type1 = ge_mActionType1(
        (action_type1 | inherit_action_type1) & ~ge_mActionType1_Inherit);
    total_action_type2 = ge_mActionType2(action_type2 | inherit_action_type2);
  } else {
    total_action_type1 = action_type1;
    total_action_type2 = action_type2;
  }

  fp << "    " << var_name << ".dd.setDynType1(" << total_dyn_type1 << ");"
     << '\n'
     << "    " << var_name << ".dd.setActionType1(" << total_action_type1
     << ");\n";
  if (total_action_type1)
    fp << "    " << var_name << ".dd.setAccess(" << access << ");\n";

  if (elements) {
    fp << "    " << var_name << ".dd.setElements(new GeDynElemIfc[] {\n";
    bool first = true;
    int sts = 0;
    for (GeDynElem* elem = elements; elem; elem = elem->next) {
      sts = elem->export_java(object, fp, first, var_name);
      if (sts)
        first = false;
    }
    fp << "      });\n";
  }
}

void GeDyn::export_java_object(
    grow_tObject object, std::ofstream& fp, char* var_name)
{
  fp << "    new GeDyn(" << var_name << "," << dyn_type1 << "," << action_type1
     << "," << access << ","
     << "new GeDynElemIfc[] {\n";

  bool first = true;
  int sts = 0;
  for (GeDynElem* elem = elements; elem; elem = elem->next) {
    sts = elem->export_java(object, fp, first, var_name);
    if (sts)
      first = false;
  }
  fp << "      }),\n";
}

int GeDyn::syntax_check(grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int sts;

  for (GeDynElem* elem = elements; elem; elem = elem->next) {
    sts = elem->syntax_check(object, error_cnt, warning_cnt);
    if (EVEN(sts))
      return sts;
  }
  return 1;
}

void GeDyn::syntax_check_attribute(grow_tObject object, const char* text,
    char* attribute, int optional, int* types, graph_eDatabase* databases,
    int* error_cnt, int* warning_cnt)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;
  pwr_eType a_type;
  graph_eDatabase db;
  int inverted;
  unsigned int bitmask;
  static pwr_eType equiv_int_types[] = { pwr_eType_Boolean, pwr_eType_Int32,
    pwr_eType_UInt32, pwr_eType_Enum, pwr_eType_Mask, pwr_eType_DisableAttr,
    pwr_eType_Status, (pwr_eType)graph_eType_Bit };

  if (strstr(attribute, "$node") || strstr(attribute, "$NODE")
      || strstr(attribute, "$header") || strstr(attribute, "$HEADER"))
    return;

  db = parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, "")) {
    if (!optional) {
      char msg[200];
      sprintf(msg, "%s is missing", text);
      graph->syntax_msg('E', object, msg);
      (*error_cnt)++;
    }
    return;
  }

  if (parsed_name[0] == '&' && parsed_name[1] == '(') {
    // Can't check references
    pwr_tAName refname;
    char* s;

    strcpy(refname, &parsed_name[2]);
    s = strchr(refname, ')');
    if (!s) {
      graph->syntax_msg('E', object, "Syntax error in reference");
      (*error_cnt)++;
      return;
    }
    *s = 0;

    sts = graph->check_ldh_object(refname, &a_type);
    if (EVEN(sts)) {
      char msg[420];
      sprintf(msg, "%s \"%s\" not found", text, refname);
      graph->syntax_msg('W', object, msg);
      (*warning_cnt)++;
    }

    if (!(a_type == pwr_eType_Objid || a_type == pwr_eType_AttrRef)) {
      char msg[300];
      sprintf(msg, "%s reference type should be Objid or AttrRef", text);
      graph->syntax_msg('E', object, msg);
      (*error_cnt)++;
    }
    return;
  }

  if (attr_type == graph_eType_Bit) {
    sts = get_bit(parsed_name, attr_type, &bitmask);
    if (EVEN(sts)) {
      graph->syntax_msg('E', object, "Bit number out of range");
      (*error_cnt)++;
    }
  }

  // Check type
  int found = 0;
  for (int i = 0; types[i] != 0; i++) {
    if (types[i] == attr_type) {
      found = 1;
      break;
    }
  }
  if (!found) {
    char msg[200];
    sprintf(msg, "%s type not supported", text);
    graph->syntax_msg('E', object, msg);
    (*error_cnt)++;
  }

  // Check database
  found = 0;
  for (int i = 0; databases[i] != graph_eDatabase__; i++) {
    if (databases[i] == db) {
      found = 1;
      break;
    }
  }
  if (!found) {
    char msg[200];
    sprintf(msg, "%s database not supported", text);
    graph->syntax_msg('E', object, msg);
    (*error_cnt)++;
  }

  switch (db) {
  case graph_eDatabase_Local:
    break;
  case graph_eDatabase_Gdh:
    if (!streq(parsed_name, "")) {
      sts = graph->check_ldh_object(parsed_name, &a_type);
      if (EVEN(sts)) {
        char msg[420];
        sprintf(msg, "%s \"%s\" not found", text, parsed_name);
        graph->syntax_msg('W', object, msg);
        (*warning_cnt)++;
      } else {
        if (a_type != (pwr_eType)attr_type) {
          // Allow some equivalent types
          int eq1 = 0;
          int eq2 = 0;
          for (unsigned int i = 0;
               i < sizeof(equiv_int_types) / sizeof(equiv_int_types[0]); i++) {
            if (a_type == equiv_int_types[i])
              eq1 = 1;
            if ((pwr_eType)attr_type == equiv_int_types[i])
              eq2 = 1;
          }
          if (!(eq1 && eq2)) {
            char msg[430];
            sprintf(msg, "%s type is not correct \"%s\"", text, parsed_name);
            graph->syntax_msg('E', object, msg);
            (*error_cnt)++;
          }
        }
      }
    }
    break;
  default:;
  }
  return;
}

int GeDynElem::disconnect(grow_tObject object)
{
  return 1;
}

int GeDynElem::get_transtab(char** tt)
{
  static char transtab[][32] = { "SubGraph", "SubGraph", "Dynamic", "", "" };

  *tt = (char*)transtab;
  return 1;
}

GeDigLowColor::GeDigLowColor(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_DigLowColor, ge_mDynType2_No,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_DigLowColor),
      color(glow_eDrawType_Inherit), bitmask(0)
{
  strcpy(attribute, "");
}

GeDigLowColor::GeDigLowColor(const GeDigLowColor& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      color(x.color)
{
  strcpy(attribute, x.attribute);
}

void GeDigLowColor::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    strcpy(attrinfo[i].name, "DigLowTone.Attribute");
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    strcpy(attrinfo[i].name, "DigLowTone.Tone");
    attrinfo[i].value = &color;
    attrinfo[i].type = glow_eType_ToneOrColor;
    attrinfo[i++].size = sizeof(color);
  } else {
    strcpy(attrinfo[i].name, "DigLowColor.Attribute");
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    strcpy(attrinfo[i].name, "DigLowColor.Color");
    attrinfo[i].value = &color;
    attrinfo[i].type = glow_eType_Color;
    attrinfo[i++].size = sizeof(color);
  }
  *item_count = i;
}

void GeDigLowColor::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    if (dyn->total_dyn_type1 & ge_mDynType1_Tone)
      snprintf(msg, sizeof(msg), "DigLowTone.Attribute = %s", attr_name);
    else
      snprintf(msg, sizeof(msg), "DigLowColor.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeDigLowColor::replace_attribute(
    char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

int GeDigLowColor::set_color(grow_tObject object, glow_eDrawType color)
{
  char msg[200];

  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    this->color = glow_eDrawType(color / 30);
    snprintf(msg, sizeof(msg), "DigLowTone.Tone = %s",
        grow_ColorToneToName(this->color));
  } else {
    this->color = color;
    snprintf(msg, sizeof(msg), "DigLowColor.Color = %s",
        grow_ColorToName(this->color));
  }
  msg[sizeof(msg) - 1] = 0;
  dyn->graph->message('I', msg);
  return 1;
}

void GeDigLowColor::save(std::ofstream& fp)
{
  fp << int(ge_eSave_DigLowColor) << '\n';
  fp << int(ge_eSave_DigLowColor_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_DigLowColor_color) << FSPACE << int(color) << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeDigLowColor::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  int tmp;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeDigLowColor: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_DigLowColor:
      break;
    case ge_eSave_DigLowColor_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_DigLowColor_color:
      fp >> tmp;
      color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeDigLowColor:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeDigLowColor::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;

  color = dyn->get_color1(object, color);
  if (color < 0 || color >= glow_eDrawType__) {
    printf("** Color out of range, %s\n", attribute);
    p = 0;
    return 0;
  }

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  a_typeid = attr_type;
  get_bit(parsed_name, attr_type, &bitmask);

  switch (db) {
  case graph_eDatabase_Local:
    p = (pwr_tBoolean*)dyn->graph->localdb_ref_or_create(
        parsed_name, attr_type);
    break;
  case graph_eDatabase_Gdh:
    sts = dyn->graph->ref_object_info(
        dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
    if (EVEN(sts))
      return sts;
    break;
  default:;
  }

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeDigLowColor::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeDigLowColor::scan(grow_tObject object)
{
  if (!p || dyn->ignore_color)
    return 1;

  pwr_tBoolean val = *p;

  if (!get_dig(&val, p, a_typeid, bitmask))
    return 1;

  if (inverted)
    val = !val;

  if (!first_scan) {
    if (old_value == val && !dyn->reset_color)
      // No change since last time
      return 1;
  } else
    first_scan = false;

  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    if (!val) {
      if (color >= (glow_eDrawType)glow_eDrawTone__)
        grow_SetObjectFillColor(object, color);
      else
        grow_SetObjectColorTone(object, (glow_eDrawTone)color);
    } else {
      if (color >= (glow_eDrawType)glow_eDrawTone__)
        grow_ResetObjectFillColor(object);
      grow_ResetObjectColorTone(object);
    }
  } else {
    if (!val)
      grow_SetObjectFillColor(object, color);
    else
      grow_ResetObjectFillColor(object);
  }
  old_value = val;

  return 1;
}

void GeDigLowColor::reset(grow_tObject object)
{
  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    if (color >= (glow_eDrawType)glow_eDrawTone__)
      grow_SetObjectFillColor(object, color);
    else
      grow_SetObjectColorTone(object, (glow_eDrawTone)color);
  } else
    grow_SetObjectFillColor(object, color);

  old_value = 0;
}

int GeDigLowColor::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  glow_eDrawType jcolor = dyn->get_color1(object, color);
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynDigLowColor(" << var_name << ".dd, \"" << attribute << "\","
     << jcolor << ")\n";
  return 1;
}

int GeDigLowColor::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  glow_eDrawType tcolor = dyn->get_color1(object, color);
  if (tcolor < 0 || tcolor >= glow_eDrawType__) {
    dyn->graph->syntax_msg('E', object, "Color out or range");
    (*error_cnt)++;
  }

  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    pwr_eType_Int64, pwr_eType_UInt64, graph_eType_Bit, pwr_eType_Float32,
    pwr_eType_Float64, pwr_eType_String, 0 };
  graph_eDatabase databases[]
      = { graph_eDatabase_Local, graph_eDatabase_Gdh, graph_eDatabase__ };
  dyn->syntax_check_attribute(object, "DigLowColor.Attribute", attribute, 0,
      types, databases, error_cnt, warning_cnt);

  return 1;
}

GeDigColor::GeDigColor(GeDyn* e_dyn, ge_mInstance e_instance)
    : GeDynElem(e_dyn, ge_mDynType1_DigColor, ge_mDynType2_No,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_DigColor),
      color(glow_eDrawType_Inherit), bitmask(0)
{
  strcpy(attribute, "");
  instance = e_instance;
}

GeDigColor::GeDigColor(const GeDigColor& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      color(x.color)
{
  strcpy(attribute, x.attribute);
  instance = x.instance;
  instance_mask = x.instance_mask;
}

void GeDigColor::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    if (instance == ge_mInstance_1) {
      strcpy(attrinfo[i].name, "DigTone.Attribute");
      attrinfo[i].value = attribute;
      attrinfo[i].type = glow_eType_String;
      attrinfo[i++].size = sizeof(attribute);

      strcpy(attrinfo[i].name, "DigTone.Tone");
      attrinfo[i].value = &color;
      attrinfo[i].type = glow_eType_ToneOrColor;
      attrinfo[i++].size = sizeof(color);

      strcpy(attrinfo[i].name, "DigTone.Instances");
      attrinfo[i].value = &instance_mask;
      attrinfo[i].type = ge_eAttrType_InstanceMask;
      attrinfo[i++].size = sizeof(instance_mask);
    } else {
      // Get instance number
      int inst = 1;
      unsigned int m = instance;
      while (m > 1) {
        m = m >> 1;
        inst++;
      }

      sprintf(attrinfo[i].name, "DigTone%d.Attribute", inst);
      attrinfo[i].value = attribute;
      attrinfo[i].type = glow_eType_String;
      attrinfo[i++].size = sizeof(attribute);

      sprintf(attrinfo[i].name, "DigTone%d.Tone", inst);
      attrinfo[i].value = &color;
      attrinfo[i].type = glow_eType_ToneOrColor;
      attrinfo[i++].size = sizeof(color);
    }
  } else {
    if (instance == ge_mInstance_1) {
      strcpy(attrinfo[i].name, "DigColor.Attribute");
      attrinfo[i].value = attribute;
      attrinfo[i].type = glow_eType_String;
      attrinfo[i++].size = sizeof(attribute);

      strcpy(attrinfo[i].name, "DigColor.Color");
      attrinfo[i].value = &color;
      attrinfo[i].type = glow_eType_Color;
      attrinfo[i++].size = sizeof(color);

      strcpy(attrinfo[i].name, "DigColor.Instances");
      attrinfo[i].value = &instance_mask;
      attrinfo[i].type = ge_eAttrType_InstanceMask;
      attrinfo[i++].size = sizeof(instance_mask);
    } else {
      // Get instance number
      int inst = 1;
      unsigned int m = instance;
      while (m > 1) {
        m = m >> 1;
        inst++;
      }

      sprintf(attrinfo[i].name, "DigColor%d.Attribute", inst);
      attrinfo[i].value = attribute;
      attrinfo[i].type = glow_eType_String;
      attrinfo[i++].size = sizeof(attribute);

      sprintf(attrinfo[i].name, "DigColor%d.Color", inst);
      attrinfo[i].value = &color;
      attrinfo[i].type = glow_eType_Color;
      attrinfo[i++].size = sizeof(color);
    }
  }
  *item_count = i;
}

void GeDigColor::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    if (instance == ge_mInstance_1) {
      if (dyn->total_dyn_type1 & ge_mDynType1_Tone)
        snprintf(msg, sizeof(msg), "DigTone.Attribute = %s", attr_name);
      else
        snprintf(msg, sizeof(msg), "DigColor.Attribute = %s", attr_name);
    } else {
      if (dyn->total_dyn_type1 & ge_mDynType1_Tone)
        snprintf(msg, sizeof(msg), "DigTone%d.Attribute = %s",
            GeDyn::instance_to_number(instance), attr_name);
      else
        snprintf(msg, sizeof(msg), "DigColor%d.Attribute = %s",
            GeDyn::instance_to_number(instance), attr_name);
    }
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeDigColor::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

int GeDigColor::set_color(grow_tObject object, glow_eDrawType color)
{
  char msg[200];

  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    this->color = glow_eDrawType(color / 30);
    if (instance == ge_mInstance_1)
      snprintf(msg, sizeof(msg), "DigTone.Tone = %s",
          grow_ColorToneToName(this->color));
    else
      snprintf(msg, sizeof(msg), "DigTone%d.Tone = %s",
          GeDyn::instance_to_number(instance),
          grow_ColorToneToName(this->color));
  } else {
    this->color = color;
    if (instance == ge_mInstance_1)
      snprintf(msg, sizeof(msg), "DigColor.Color = %s",
          grow_ColorToName(this->color));
    else
      snprintf(msg, sizeof(msg), "DigColor%d.Color = %s",
          GeDyn::instance_to_number(instance), grow_ColorToName(this->color));
  }
  msg[sizeof(msg) - 1] = 0;
  dyn->graph->message('I', msg);
  return 1;
}

void GeDigColor::save(std::ofstream& fp)
{
  fp << int(ge_eSave_DigColor) << '\n';
  fp << int(ge_eSave_DigColor_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_DigColor_color) << FSPACE << int(color) << '\n';
  fp << int(ge_eSave_DigColor_instance) << FSPACE << int(instance) << '\n';
  fp << int(ge_eSave_DigColor_instance_mask) << FSPACE << int(instance_mask)
     << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeDigColor::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  int tmp;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeDigColor: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_DigColor:
      break;
    case ge_eSave_DigColor_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_DigColor_color:
      fp >> tmp;
      color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_DigColor_instance:
      fp >> tmp;
      instance = (ge_mInstance)tmp;
      break;
    case ge_eSave_DigColor_instance_mask:
      fp >> tmp;
      instance_mask = (ge_mInstance)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeDigColor:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeDigColor::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;

  color = dyn->get_color2(object, color);
  if (color < 0 || color >= glow_eDrawType__) {
    printf("** Color out of range, %s\n", attribute);
    p = 0;
    return 0;
  }

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  get_bit(parsed_name, attr_type, &bitmask);

  switch (db) {
  case graph_eDatabase_Local:
    p = (pwr_tBoolean*)dyn->graph->localdb_ref_or_create(
        parsed_name, attr_type);
    break;
  case graph_eDatabase_Gdh:
    sts = dyn->graph->ref_object_info(
	dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
    if (EVEN(sts))
      return sts;
    break;
  default:;
  }
  a_typeid = attr_type;

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeDigColor::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeDigColor::scan(grow_tObject object)
{
  if (!p || dyn->ignore_color)
    return 1;

  pwr_tBoolean val = *p;

  if (!get_dig(&val, p, a_typeid, bitmask))
    return 1;

  if (inverted)
    val = !val;

  if (!first_scan) {
    if (old_value == val && !dyn->reset_color) {
      // No change since last time
      if (val)
        dyn->ignore_color = true;
      return 1;
    }
  } else
    first_scan = false;

  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    if (val) {
      if (color >= (glow_eDrawType)glow_eDrawTone__) {
        if (dyn->reset_color)
          grow_ResetObjectFillColor(object); // Previous color might be a tone
        grow_SetObjectFillColor(object, color);
      } else
        grow_SetObjectColorTone(object, (glow_eDrawTone)color);
      dyn->ignore_color = true;
    } else {
      if (color >= (glow_eDrawType)glow_eDrawTone__)
        grow_ResetObjectFillColor(object);
      grow_ResetObjectColorTone(object);
      dyn->reset_color = true;
    }
  } else {
    if (val) {
      grow_SetObjectFillColor(object, color);
      dyn->ignore_color = true;
    } else {
      grow_ResetObjectFillColor(object);
      dyn->reset_color = true;
    }
  }
  old_value = val;

  return 1;
}

void GeDigColor::reset(grow_tObject object)
{
  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    if (color >= (glow_eDrawType)glow_eDrawTone__)
      grow_ResetObjectFillColor(object);
    grow_ResetObjectColorTone(object);
  } else
    grow_ResetObjectFillColor(object);

  old_value = 0;
}

int GeDigColor::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  glow_eDrawType jcolor = dyn->get_color2(object, color);
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynDigColor(" << var_name << ".dd, \"" << attribute << "\","
     << jcolor << ")\n";
  return 1;
}

int GeDigColor::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  char name[40];

  if (instance == 1)
    strcpy(name, "DigColor.Attribute");
  else
    sprintf(name, "DigColor%d.Attribute", GeDyn::instance_to_number(instance));

  glow_eDrawType tcolor = dyn->get_color1(object, color);
  if (tcolor < 0 || tcolor >= glow_eDrawType__) {
    dyn->graph->syntax_msg('E', object, "Color out or range");
    (*error_cnt)++;
  }

  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    pwr_eType_Int64, pwr_eType_UInt64, graph_eType_Bit, pwr_eType_Float32,
    pwr_eType_Float64, pwr_eType_String, 0 };
  graph_eDatabase databases[]
      = { graph_eDatabase_Local, graph_eDatabase_Gdh, graph_eDatabase__ };
  dyn->syntax_check_attribute(
      object, name, attribute, 0, types, databases, error_cnt, warning_cnt);

  return 1;
}

GeDigWarning::GeDigWarning(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_DigWarning, ge_mDynType2_No,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_DigWarning),
      use_colortheme(0), bitmask(0)
{
  strcpy(attribute, "");
}

GeDigWarning::GeDigWarning(const GeDigWarning& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      use_colortheme(x.use_colortheme)
{
  strcpy(attribute, x.attribute);
}

void GeDigWarning::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "DigWarning.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  strcpy(attrinfo[i].name, "DigWarning.UseColorTheme");
  attrinfo[i].value = &use_colortheme;
  attrinfo[i].type = glow_eType_Int;
  attrinfo[i++].size = sizeof(use_colortheme);

  *item_count = i;
}

void GeDigWarning::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "DigWaring.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeDigWarning::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeDigWarning::save(std::ofstream& fp)
{
  fp << int(ge_eSave_DigWarning) << '\n';
  fp << int(ge_eSave_DigWarning_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_DigWarning_use_colortheme) << FSPACE << use_colortheme
     << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeDigWarning::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeDigWarning: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_DigWarning:
      break;
    case ge_eSave_DigWarning_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_DigWarning_use_colortheme:
      fp >> use_colortheme;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeDigWarning:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeDigWarning::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  a_typeid = attr_type;
  get_bit(parsed_name, attr_type, &bitmask);

  sts = dyn->graph->ref_object_info(
      dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
  if (EVEN(sts))
    return sts;

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeDigWarning::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeDigWarning::scan(grow_tObject object)
{
  if (!p || dyn->ignore_color)
    return 1;

  pwr_tBoolean val = *p;

  if (!get_dig(&val, p, a_typeid, bitmask))
    return 1;

  if (inverted)
    val = !val;

  if (!first_scan) {
    if (old_value == val && !dyn->reset_color) {
      // No change since last time
      if (val)
        dyn->ignore_color = true;
      return 1;
    }
  } else
    first_scan = false;

  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    if (val) {
      grow_SetObjectColorTone(object, glow_eDrawTone_Yellow);
      dyn->ignore_color = true;
    } else {
      grow_ResetObjectColorTone(object);
      dyn->reset_color = true;
    }
  } else {
    if (val) {
      grow_SetObjectFillColor(object, use_colortheme
              ? glow_eDrawType_CustomColor41
              : glow_eDrawType_ColorYellow);
      dyn->ignore_color = true;
    } else {
      grow_ResetObjectFillColor(object);
      dyn->reset_color = true;
    }
  }
  old_value = val;

  return 1;
}

int GeDigWarning::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynDigWarning(" << var_name << ".dd, \"" << attribute << "\")"
     << '\n';
  return 1;
}

int GeDigWarning::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    pwr_eType_Int64, pwr_eType_UInt64, graph_eType_Bit, pwr_eType_Float32,
    pwr_eType_Float64, pwr_eType_String, 0 };
  graph_eDatabase databases[]
      = { graph_eDatabase_Local, graph_eDatabase_Gdh, graph_eDatabase__ };

  dyn->syntax_check_attribute(object, "DigWarning.Attribute", attribute, 0,
      types, databases, error_cnt, warning_cnt);

  return 1;
}

GeDigError::GeDigError(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_DigError, ge_mDynType2_No,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_DigError),
      use_colortheme(0), bitmask(0)
{
  strcpy(attribute, "");
}

GeDigError::GeDigError(const GeDigError& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      use_colortheme(x.use_colortheme)
{
  strcpy(attribute, x.attribute);
}

void GeDigError::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "DigError.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  strcpy(attrinfo[i].name, "DigError.UseColorTheme");
  attrinfo[i].value = &use_colortheme;
  attrinfo[i].type = glow_eType_Int;
  attrinfo[i++].size = sizeof(use_colortheme);

  *item_count = i;
}

void GeDigError::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "DigError.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeDigError::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeDigError::save(std::ofstream& fp)
{
  fp << int(ge_eSave_DigError) << '\n';
  fp << int(ge_eSave_DigError_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_DigError_use_colortheme) << FSPACE << use_colortheme
     << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeDigError::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeDigError: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_DigError:
      break;
    case ge_eSave_DigError_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_DigError_use_colortheme:
      fp >> use_colortheme;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeDigError:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeDigError::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  a_typeid = attr_type;
  get_bit(parsed_name, attr_type, &bitmask);

  sts = dyn->graph->ref_object_info(
      dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
  if (EVEN(sts))
    return sts;

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeDigError::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeDigError::scan(grow_tObject object)
{
  if (!p || dyn->ignore_color)
    return 1;

  pwr_tBoolean val = *p;

  if (!get_dig(&val, p, a_typeid, bitmask))
    return 1;

  if (inverted)
    val = !val;

  if (!first_scan) {
    if (old_value == val && !dyn->reset_color) {
      // No change since last time
      if (val)
        dyn->ignore_color = true;
      return 1;
    }
  } else
    first_scan = false;

  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    if (val) {
      grow_SetObjectColorTone(object, glow_eDrawTone_Red);
      dyn->ignore_color = true;
    } else {
      grow_ResetObjectColorTone(object);
      dyn->reset_color = true;
    }
  } else {
    if (val) {
      grow_SetObjectFillColor(object, use_colortheme
              ? glow_eDrawType_CustomColor11
              : glow_eDrawType_ColorRed);
      dyn->ignore_color = true;
    } else {
      grow_ResetObjectFillColor(object);
      dyn->reset_color = true;
    }
  }
  old_value = val;

  return 1;
}

int GeDigError::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynDigError(" << var_name << ".dd, \"" << attribute << "\")"
     << '\n';
  return 1;
}

int GeDigError::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    pwr_eType_Int64, pwr_eType_UInt64, graph_eType_Bit, pwr_eType_Float32,
    pwr_eType_Float64, pwr_eType_String, 0 };
  graph_eDatabase databases[]
      = { graph_eDatabase_Local, graph_eDatabase_Gdh, graph_eDatabase__ };

  dyn->syntax_check_attribute(object, "DigError.Attribute", attribute, 0, types,
      databases, error_cnt, warning_cnt);

  return 1;
}

GeDigFlash::GeDigFlash(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_DigFlash, ge_mDynType2_No,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_DigFlash),
      color(glow_eDrawType_Inherit), color2(glow_eDrawType_Inherit), on(true)
{
  strcpy(attribute, "");
}

GeDigFlash::GeDigFlash(const GeDigFlash& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      color(x.color), color2(x.color2), on(x.on)
{
  strcpy(attribute, x.attribute);
}

void GeDigFlash::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    strcpy(attrinfo[i].name, "DigFlash.Attribute");
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    strcpy(attrinfo[i].name, "DigFlash.Tone");
    attrinfo[i].value = &color;
    attrinfo[i].type = glow_eType_ToneOrColor;
    attrinfo[i++].size = sizeof(color);

    strcpy(attrinfo[i].name, "DigFlash.Tone2");
    attrinfo[i].value = &color2;
    attrinfo[i].type = glow_eType_ToneOrColor;
    attrinfo[i++].size = sizeof(color2);
  } else {
    strcpy(attrinfo[i].name, "DigFlash.Attribute");
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    strcpy(attrinfo[i].name, "DigFlash.Color");
    attrinfo[i].value = &color;
    attrinfo[i].type = glow_eType_Color;
    attrinfo[i++].size = sizeof(color);

    strcpy(attrinfo[i].name, "DigFlash.Color2");
    attrinfo[i].value = &color2;
    attrinfo[i].type = glow_eType_Color;
    attrinfo[i++].size = sizeof(color2);
  }
  *item_count = i;
}

void GeDigFlash::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "DigFlash.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeDigFlash::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

int GeDigFlash::set_color(grow_tObject object, glow_eDrawType color)
{
  char msg[200];

  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    this->color = glow_eDrawType(color / 30);
    snprintf(msg, sizeof(msg), "DigFlash.Tone = %s",
        grow_ColorToneToName(this->color));
  } else {
    this->color = color;
    snprintf(
        msg, sizeof(msg), "DigFlash.Color = %s", grow_ColorToName(this->color));
  }
  msg[sizeof(msg) - 1] = 0;
  dyn->graph->message('I', msg);
  return 1;
}

void GeDigFlash::save(std::ofstream& fp)
{
  fp << int(ge_eSave_DigFlash) << '\n';
  fp << int(ge_eSave_DigFlash_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_DigFlash_color) << FSPACE << int(color) << '\n';
  fp << int(ge_eSave_DigFlash_color2) << FSPACE << int(color2) << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeDigFlash::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  int tmp;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeDigFlash: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_DigFlash:
      break;
    case ge_eSave_DigFlash_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_DigFlash_color:
      fp >> tmp;
      color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_DigFlash_color2:
      fp >> tmp;
      color2 = (glow_eDrawType)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeDigFlash:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeDigFlash::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;

  color = dyn->get_color1(object, color);
  if (color < 0 || color >= glow_eDrawType__) {
    printf("** Color out of range, %s\n", attribute);
    p = 0;
    return 0;
  }

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  get_bit(parsed_name, attr_type, &bitmask);

  a_typeid = attr_type;

  sts = dyn->graph->ref_object_info(
      dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
  if (EVEN(sts))
    return sts;

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeDigFlash::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeDigFlash::scan(grow_tObject object)
{
  if (!p || dyn->ignore_color)
    return 1;

  pwr_tBoolean val;

  if (!get_dig(&val, p, a_typeid, bitmask))
    return 1;

  if (inverted)
    val = !val;

  if (!first_scan) {
    if (old_value == val && !dyn->reset_color) {
      // No change since last time
      if (!val)
        return 1;
    }
  } else
    first_scan = false;

  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    if (val) {
      if (on) {
        if (color >= (glow_eDrawType)glow_eDrawTone__)
          grow_SetObjectFillColor(object, color);
        else
          grow_SetObjectColorTone(object, (glow_eDrawTone)color);
        dyn->ignore_color = true;
      } else {
        if (color2 == glow_eDrawType_Inherit) {
          if (color >= (glow_eDrawType)glow_eDrawTone__)
            grow_ResetObjectFillColor(object);
          grow_ResetObjectColorTone(object);
          dyn->reset_color = true;
        } else {
          if (color >= (glow_eDrawType)glow_eDrawTone__)
            grow_SetObjectFillColor(object, color2);
          else
            grow_SetObjectColorTone(object, (glow_eDrawTone)color2);
          dyn->ignore_color = true;
        }
      }
      on = on ? false : true;
    } else {
      if (color >= (glow_eDrawType)glow_eDrawTone__)
        grow_ResetObjectFillColor(object);
      grow_ResetObjectColorTone(object);
      dyn->reset_color = true;
    }
  } else {
    if (val) {
      if (on) {
        grow_SetObjectFillColor(object, color);
        dyn->ignore_color = true;
      } else {
        if (color2 == glow_eDrawType_Inherit) {
          grow_ResetObjectFillColor(object);
          dyn->reset_color = true;
        } else {
          grow_SetObjectFillColor(object, color2);
          dyn->ignore_color = true;
        }
      }
      on = on ? false : true;
    } else {
      grow_ResetObjectFillColor(object);
      dyn->reset_color = true;
    }
  }
  old_value = val;

  return 1;
}

int GeDigFlash::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  glow_eDrawType jcolor = dyn->get_color1(object, color);

  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynDigFlash(" << var_name << ".dd, \"" << attribute << "\","
     << jcolor << "," << color2 << ")\n";
  return 1;
}

int GeDigFlash::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  glow_eDrawType tcolor = dyn->get_color1(object, color);
  if (tcolor < 0 || tcolor >= glow_eDrawType__) {
    dyn->graph->syntax_msg('E', object, "Color out or range");
    (*error_cnt)++;
  }

  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    pwr_eType_Int64, pwr_eType_UInt64, graph_eType_Bit, pwr_eType_Float32,
    pwr_eType_Float64, pwr_eType_String, 0 };
  graph_eDatabase databases[]
      = { graph_eDatabase_Local, graph_eDatabase_Gdh, graph_eDatabase__ };

  dyn->syntax_check_attribute(object, "DigFlash.Attribute", attribute, 0, types,
      databases, error_cnt, warning_cnt);

  return 1;
}

GeInvisible::GeInvisible(GeDyn* e_dyn, ge_mInstance e_instance)
    : GeDynElem(e_dyn, ge_mDynType1_Invisible, ge_mDynType2_No,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_Invisible),
      dimmed(0), bitmask(0)
{
  strcpy(attribute, "");
  instance = e_instance;
}

GeInvisible::GeInvisible(const GeInvisible& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      dimmed(x.dimmed)
{
  strcpy(attribute, x.attribute);
  instance = x.instance;
  instance_mask = x.instance_mask;
}

void GeInvisible::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  if (instance == ge_mInstance_1) {
    strcpy(attrinfo[i].name, "Invisible.Attribute");
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    strcpy(attrinfo[i].name, "Invisible.Dimmed");
    attrinfo[i].value = &dimmed;
    attrinfo[i].type = glow_eType_Boolean;
    attrinfo[i++].size = sizeof(dimmed);

    strcpy(attrinfo[i].name, "Invisible.Instances");
    attrinfo[i].value = &instance_mask;
    attrinfo[i].type = ge_eAttrType_InstanceMask;
    attrinfo[i++].size = sizeof(instance_mask);
  } else {
    // Get instance number
    int inst = 1;
    unsigned int m = instance;
    while (m > 1) {
      m = m >> 1;
      inst++;
    }

    sprintf(attrinfo[i].name, "Invisible%d.Attribute", inst);
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    sprintf(attrinfo[i].name, "Invisible%d.Dimmed", inst);
    attrinfo[i].value = &dimmed;
    attrinfo[i].type = glow_eType_Boolean;
    attrinfo[i++].size = sizeof(dimmed);
  }
  *item_count = i;
}

void GeInvisible::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    if (instance == ge_mInstance_1)
      snprintf(msg, sizeof(msg), "Invisible.Attribute = %s", attr_name);
    else
      snprintf(msg, sizeof(msg), "Invisible%d.Attribute = %s",
          GeDyn::instance_to_number(instance), attr_name);

    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeInvisible::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeInvisible::save(std::ofstream& fp)
{
  fp << int(ge_eSave_Invisible) << '\n';
  fp << int(ge_eSave_Invisible_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_Invisible_dimmed) << FSPACE << dimmed << '\n';
  fp << int(ge_eSave_Invisible_instance) << FSPACE << int(instance) << '\n';
  fp << int(ge_eSave_Invisible_instance_mask) << FSPACE << int(instance_mask)
     << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeInvisible::open(std::ifstream& fp)
{
  int type = 0;
  int tmp;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeInvisible: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_Invisible:
      break;
    case ge_eSave_Invisible_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_Invisible_dimmed:
      fp >> dimmed;
      break;
    case ge_eSave_Invisible_instance:
      fp >> tmp;
      instance = (ge_mInstance)tmp;
      break;
    case ge_eSave_Invisible_instance_mask:
      fp >> tmp;
      instance_mask = (ge_mInstance)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeInvisible:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeInvisible::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  get_bit(parsed_name, attr_type, &bitmask);

  if (str_NoCaseStrncmp(parsed_name, "$cmd(", 5) == 0) {
    char cmd[400], command[400];
    char* s;
    pwr_tStatus sts;
    static pwr_tBoolean val_false = 0;
    static pwr_tBoolean val_true = 1;

    strcpy(command, &parsed_name[5]);

    if ((s = strrchr(command, ')')))
      *s = 0;

    dyn->graph->get_command(command, cmd, dyn);

    sts = (dyn->graph->command_cb)(dyn->graph->parent_ctx, cmd, 0);
    if (ODD(sts))
      p = &val_false;
    else
      p = &val_true;
    db = graph_eDatabase_User;
    a_typeid = pwr_eType_Boolean;
  } else {
    switch (db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(
          dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
      if (EVEN(sts))
        return sts;
      break;
    case graph_eDatabase_Local:
      p = (pwr_tBoolean*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      break;
    case graph_eDatabase_Ccm:
      sts = dyn->graph->ccm_ref_variable(parsed_name, attr_type, (void**)&p);
      if (EVEN(sts))
        return sts;
      break;
    default:;
    }

    a_typeid = attr_type;
  }

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeInvisible::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeInvisible::scan(grow_tObject object)
{
  if (!p || dyn->ignore_invisible)
    return 1;

  pwr_tBoolean val = *p;

  if (!get_dig(&val, p, a_typeid, bitmask))
    return 1;

  if (a_typeid == pwr_eType_String)
    val = !val;

  if (inverted)
    val = !val;

  if (!first_scan) {
    if (old_value == val && !dyn->reset_invisible) {
      // No change since last time
      if (val)
        dyn->ignore_invisible = true;
      return 1;
    }
  } else
    first_scan = false;

  if (!val) {
    grow_SetObjectVisibility(object, glow_eVis_Visible);
    dyn->reset_color = true;
    dyn->reset_invisible = true;
  } else {
    if (dimmed)
      grow_SetObjectVisibility(object, glow_eVis_Dimmed);
    else
      grow_SetObjectVisibility(object, glow_eVis_Invisible);
    dyn->ignore_color = true;
    dyn->ignore_invisible = true;
  }
  old_value = val;

  return 1;
}

int GeInvisible::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynInvisible(" << var_name << ".dd, \""
     << GeDyn::printstr(attribute) << "\"," << dimmed << ")\n";
  return 1;
}

int GeInvisible::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    pwr_eType_Int64, pwr_eType_UInt64, graph_eType_Bit, pwr_eType_Float32,
    pwr_eType_Float64, pwr_eType_String, 0 };
  graph_eDatabase databases[]
      = { graph_eDatabase_Local, graph_eDatabase_Gdh, graph_eDatabase__ };

  dyn->syntax_check_attribute(object, "Invisible.Attribute", attribute, 0,
      types, databases, error_cnt, warning_cnt);

  return 1;
}

GeDigTextColor::GeDigTextColor(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_DigTextColor,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_DigTextColor),
      color(glow_eDrawType_Inherit)
{
  strcpy(attribute, "");
}

GeDigTextColor::GeDigTextColor(const GeDigTextColor& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      color(x.color)
{
  strcpy(attribute, x.attribute);
}

void GeDigTextColor::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "DigTextColor.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  strcpy(attrinfo[i].name, "DigTextColor.Color");
  attrinfo[i].value = &color;
  attrinfo[i].type = glow_eType_Color;
  attrinfo[i++].size = sizeof(color);

  *item_count = i;
}

void GeDigTextColor::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "DigTextColor.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeDigTextColor::replace_attribute(
    char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeDigTextColor::save(std::ofstream& fp)
{
  fp << int(ge_eSave_DigTextColor) << '\n';
  fp << int(ge_eSave_DigTextColor_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_DigTextColor_color) << FSPACE << int(color) << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeDigTextColor::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  int tmp;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeDigTextColor: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_DigTextColor:
      break;
    case ge_eSave_DigTextColor_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_DigTextColor_color:
      fp >> tmp;
      color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeDigTextColor:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeDigTextColor::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;

  color = dyn->get_color1(object, color);
  if (color < 0 || color >= glow_eDrawType__) {
    printf("** Color out of range, %s\n", attribute);
    p = 0;
    return 0;
  }

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  get_bit(parsed_name, attr_type, &bitmask);
  a_typeid = attr_type;

  sts = dyn->graph->ref_object_info(
      dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
  if (EVEN(sts))
    return sts;

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeDigTextColor::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeDigTextColor::scan(grow_tObject object)
{
  if (!p)
    return 1;

  pwr_tBoolean val = *p;

  if (!get_dig(&val, p, a_typeid, bitmask))
    return 1;

  if (inverted)
    val = !val;

  if (!first_scan) {
    if (old_value == val) {
      // No change since last time
      return 1;
    }
  } else
    first_scan = false;

  if (val) {
    grow_SetObjectTextColor(object, color);
  } else {
    grow_ResetObjectTextColor(object);
  }
  old_value = val;
  return 1;
}

int GeDigTextColor::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  return 1;
}

int GeDigTextColor::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  glow_eDrawType tcolor = dyn->get_color1(object, color);
  if (tcolor < 0 || tcolor >= glow_eDrawType__) {
    dyn->graph->syntax_msg('E', object, "Color out or range");
    (*error_cnt)++;
  }

  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    pwr_eType_Int64, pwr_eType_UInt64, graph_eType_Bit, pwr_eType_Float32,
    pwr_eType_Float64, pwr_eType_String, 0 };
  graph_eDatabase databases[]
      = { graph_eDatabase_Local, graph_eDatabase_Gdh, graph_eDatabase__ };

  dyn->syntax_check_attribute(object, "DigTextColor.Attribute", attribute, 0,
      types, databases, error_cnt, warning_cnt);

  return 1;
}

GeDigBorder::GeDigBorder(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_DigBorder, ge_mDynType2_No,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_DigBorder),
      color(glow_eDrawType_Inherit)
{
  strcpy(attribute, "");
}

GeDigBorder::GeDigBorder(const GeDigBorder& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      color(x.color)
{
  strcpy(attribute, x.attribute);
}

void GeDigBorder::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "DigBorder.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  strcpy(attrinfo[i].name, "DigBorder.LowColor");
  attrinfo[i].value = &color;
  attrinfo[i].type = glow_eType_Color;
  attrinfo[i++].size = sizeof(color);

  *item_count = i;
}

void GeDigBorder::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "DigBorder.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeDigBorder::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeDigBorder::save(std::ofstream& fp)
{
  fp << int(ge_eSave_DigBorder) << '\n';
  fp << int(ge_eSave_DigBorder_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_DigBorder_color) << FSPACE << int(color) << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeDigBorder::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  int tmp;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeDigBorder: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_DigBorder:
      break;
    case ge_eSave_DigBorder_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_DigBorder_color:
      fp >> tmp;
      color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeDigBorder:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeDigBorder::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;

  color = dyn->get_color1(object, color);
  if (color < 0 || color >= glow_eDrawType__) {
    printf("** Color out of range, %s\n", attribute);
    p = 0;
    return 0;
  }

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  get_bit(parsed_name, attr_type, &bitmask);
  a_typeid = attr_type;

  sts = dyn->graph->ref_object_info(
      dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
  if (EVEN(sts))
    return sts;

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeDigBorder::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeDigBorder::scan(grow_tObject object)
{
  if (!p)
    return 1;

  pwr_tBoolean val = *p;

  if (!get_dig(&val, p, a_typeid, bitmask))
    return 1;

  if (inverted)
    val = !val;

  if (!first_scan) {
    if (old_value == val) {
      // No change since last time
      return 1;
    }
  } else
    first_scan = false;

  if (!val) {
    grow_SetObjectBorderColor(object, color);
  } else {
    grow_ResetObjectBorderColor(object);
  }
  old_value = val;
  return 1;
}

int GeDigBorder::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  glow_eDrawType jcolor = dyn->get_color1(object, color);

  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynDigBorder(" << var_name << ".dd, \"" << attribute << "\","
     << jcolor << ")\n";
  return 1;
}

int GeDigBorder::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  glow_eDrawType tcolor = dyn->get_color1(object, color);
  if (tcolor < 0 || tcolor >= glow_eDrawType__) {
    dyn->graph->syntax_msg('E', object, "Color out or range");
    (*error_cnt)++;
  }

  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    pwr_eType_Int64, pwr_eType_UInt64, graph_eType_Bit, pwr_eType_Float32,
    pwr_eType_Float64, pwr_eType_String, 0 };
  graph_eDatabase databases[]
      = { graph_eDatabase_Local, graph_eDatabase_Gdh, graph_eDatabase__ };

  dyn->syntax_check_attribute(object, "DigBorder.Attribute", attribute, 0,
      types, databases, error_cnt, warning_cnt);

  return 1;
}

GeDigText::GeDigText(GeDyn* e_dyn, ge_mInstance e_instance)
    : GeDynElem(e_dyn, ge_mDynType1_DigText, ge_mDynType2_No,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_DigText)
{
  strcpy(attribute, "");
  strcpy(low_text, "");
  instance = e_instance;
}

GeDigText::GeDigText(const GeDigText& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio)
{
  strcpy(attribute, x.attribute);
  strcpy(low_text, x.low_text);
  instance = x.instance;
  instance_mask = x.instance_mask;
}

void GeDigText::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  if (instance == ge_mInstance_1) {
    strcpy(attrinfo[i].name, "DigText.Attribute");
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    strcpy(attrinfo[i].name, "DigText.LowText");
    attrinfo[i].value = low_text;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(low_text);

    strcpy(attrinfo[i].name, "DigText.Instances");
    attrinfo[i].value = &instance_mask;
    attrinfo[i].type = ge_eAttrType_InstanceMask;
    attrinfo[i++].size = sizeof(instance_mask);
  } else {
    // Get instance number
    int inst = 1;
    unsigned int m = instance;
    while (m > 1) {
      m = m >> 1;
      inst++;
    }

    sprintf(attrinfo[i].name, "DigText%d.Attribute", inst);
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    sprintf(attrinfo[i].name, "DigText%d.HighText", inst);
    attrinfo[i].value = low_text;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(low_text);
  }

  *item_count = i;
}

int GeDigText::get_transtab(char** tt)
{
  static char transtab[][32]
      = { "SubGraph", "SubGraph", "A1", "Text", "Dynamic", "", "" };

  *tt = (char*)transtab;
  return 0;
}

void GeDigText::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    if (instance == ge_mInstance_1) {
      snprintf(msg, sizeof(msg), "DigText.Attribute = %s", attr_name);
    } else {
      snprintf(msg, sizeof(msg), "DigText%d.Attribute = %s",
          GeDyn::instance_to_number(instance), attr_name);
    }
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeDigText::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeDigText::save(std::ofstream& fp)
{
  fp << int(ge_eSave_DigText) << '\n';
  fp << int(ge_eSave_DigText_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_DigText_low_text) << FSPACE << low_text << '\n';
  fp << int(ge_eSave_DigText_instance) << FSPACE << int(instance) << '\n';
  fp << int(ge_eSave_DigText_instance_mask) << FSPACE << int(instance_mask)
     << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeDigText::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  int tmp;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeDigText: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_DigText:
      break;
    case ge_eSave_DigText_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_DigText_low_text:
      fp.get();
      fp.getline(low_text, sizeof(low_text));
      break;
    case ge_eSave_DigText_instance:
      fp >> tmp;
      instance = (ge_mInstance)tmp;
      break;
    case ge_eSave_DigText_instance_mask:
      fp >> tmp;
      instance_mask = (ge_mInstance)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeDigText:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeDigText::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  get_bit(parsed_name, attr_type, &bitmask);
  a_typeid = attr_type;

  sts = dyn->graph->ref_object_info(
      dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
  if (EVEN(sts))
    return sts;

  trace_data->p = &pdummy;
  grow_GetAnnotation(object, 1, high_text, sizeof(high_text));
  first_scan = true;
  return 1;
}

int GeDigText::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeDigText::scan(grow_tObject object)
{
  if (!p || dyn->ignore_text_a1)
    return 1;

  pwr_tBoolean val = *p;

  if (!get_dig(&val, p, a_typeid, bitmask))
    return 1;

  if (inverted)
    val = !val;

  if (instance == ge_mInstance_1) {
    // Write low_text on low signal
    if (!first_scan) {
      if (old_value == val && !dyn->reset_text_a1) {
        // No change since last time
        return 1;
      }
    } else
      first_scan = false;

    if (!val) {
      grow_SetAnnotation(object, 1, low_text, strlen(low_text));
      dyn->reset_text_a1 = true;
    } else {
      grow_SetAnnotation(object, 1, high_text, strlen(high_text));
    }
  } else {
    // Instance > 1, write low_text on high signal
    if (!first_scan) {
      if (old_value == val && !dyn->reset_text_a1) {
        // No change since last time
        if (val)
          dyn->ignore_text_a1 = true;
        return 1;
      }
    } else
      first_scan = false;

    if (val) {
      grow_SetAnnotation(object, 1, low_text, strlen(low_text));
      dyn->ignore_text_a1 = true;
    } else {
      grow_SetAnnotation(object, 1, high_text, strlen(high_text));
      dyn->reset_text_a1 = true;
    }
  }
  old_value = val;
  return 1;
}

int GeDigText::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynDigText(" << var_name << ".dd, \"" << attribute << "\",\""
     << low_text << "\")\n";
  return 1;
}

int GeDigText::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int sts;

  sts = grow_CheckObjectAnnotation(object, 1);
  if (EVEN(sts)) {
    dyn->graph->syntax_msg(
        'E', object, "DigText, no annotation number 1 for this object");
    (*error_cnt)++;
  } else if (instance_mask == ge_mInstance_1) {
    grow_GetAnnotation(object, 1, high_text, sizeof(high_text));
    if (streq(high_text, "") && streq(low_text, "")) {
      dyn->graph->syntax_msg(
          'E', object, "DigText, low and high text is missing");
      (*error_cnt)++;
    }
  }

  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    pwr_eType_Int64, pwr_eType_UInt64, graph_eType_Bit, pwr_eType_Float32,
    pwr_eType_Float64, pwr_eType_String, 0 };
  graph_eDatabase databases[]
      = { graph_eDatabase_Local, graph_eDatabase_Gdh, graph_eDatabase__ };

  dyn->syntax_check_attribute(object, "DigText.Attribute", attribute, 0, types,
      databases, error_cnt, warning_cnt);

  return 1;
}

GeValue::GeValue(GeDyn* e_dyn, ge_mInstance e_instance)
    : GeDynElem(e_dyn, ge_mDynType1_Value, ge_mDynType2_No, ge_mActionType1_No,
          ge_mActionType2_No, ge_eDynPrio_Value),
      zero_blank(0), decimals_decr(0), annot_typeid(0), annot_size(0), tid(0),
      update_open(0)
{
  strcpy(attribute, "");
  strcpy(format, "");
  strcpy(decimals_attr, "");
  instance = e_instance;
  memset(old_value, 0, sizeof(old_value));
}

GeValue::GeValue(const GeValue& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      zero_blank(x.zero_blank), decimals_decr(x.decimals_decr),
      update_open(x.update_open)
{
  strcpy(attribute, x.attribute);
  strcpy(format, x.format);
  strcpy(decimals_attr, x.decimals_attr);
  instance = x.instance;
  instance_mask = x.instance_mask;
  memset(old_value, 0, sizeof(old_value));
}

void GeValue::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  if (instance == ge_mInstance_1) {
    strcpy(attrinfo[i].name, "Value.Attribute");
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    strcpy(attrinfo[i].name, "Value.Format");
    attrinfo[i].value = format;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(format);

    strcpy(attrinfo[i].name, "Value.ZeroBlank");
    attrinfo[i].value = &zero_blank;
    attrinfo[i].type = glow_eType_Int;
    attrinfo[i++].size = sizeof(zero_blank);

    strcpy(attrinfo[i].name, "Value.DecimalsAttr");
    attrinfo[i].value = decimals_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(decimals_attr);

    strcpy(attrinfo[i].name, "Value.DecimalsDecrease");
    attrinfo[i].value = &decimals_decr;
    attrinfo[i].type = glow_eType_Int;
    attrinfo[i++].size = sizeof(decimals_decr);

    strcpy(attrinfo[i].name, "Value.Instances");
    attrinfo[i].value = &instance_mask;
    attrinfo[i].type = ge_eAttrType_InstanceMask;
    attrinfo[i++].size = sizeof(instance_mask);
  } else {
    // Get instance number
    int inst = 1;
    unsigned int m = instance;
    while (m > 1) {
      m = m >> 1;
      inst++;
    }

    sprintf(attrinfo[i].name, "Value[%d].Attribute", inst);
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    sprintf(attrinfo[i].name, "Value[%d].Format", inst);
    attrinfo[i].value = format;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(format);

    sprintf(attrinfo[i].name, "Value[%d].ZeroBlank", inst);
    attrinfo[i].value = &zero_blank;
    attrinfo[i].type = glow_eType_Int;
    attrinfo[i++].size = sizeof(zero_blank);

    sprintf(attrinfo[i].name, "Value[%d].DecimalsAttr", inst);
    attrinfo[i].value = decimals_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(decimals_attr);

    sprintf(attrinfo[i].name, "Value[%d].DecimalsDecrease", inst);
    attrinfo[i].value = &decimals_decr;
    attrinfo[i].type = glow_eType_Int;
    attrinfo[i++].size = sizeof(decimals_decr);
  }
  *item_count = i;
}

int GeValue::get_transtab(char** tt)
{
  static char transtab[][32]
      = { "SubGraph", "SubGraph", "A1", "", "Dynamic", "", "" };

  *tt = (char*)transtab;
  return 0;
}

void GeValue::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    if (instance == ge_mInstance_1) {
      strncpy(attribute, attr_name, sizeof(attribute));
      snprintf(msg, sizeof(msg), "Value.Attribute = %s", attr_name);
      msg[sizeof(msg) - 1] = 0;
      dyn->graph->message('I', msg);
    }
  }
}

void GeValue::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
  GeDyn::replace_attribute(
      decimals_attr, sizeof(decimals_attr), from, to, cnt, strict);
}

void GeValue::save(std::ofstream& fp)
{
  fp << int(ge_eSave_Value) << '\n';
  fp << int(ge_eSave_Value_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_Value_format) << FSPACE << format << '\n';
  fp << int(ge_eSave_Value_instance) << FSPACE << int(instance) << '\n';
  fp << int(ge_eSave_Value_instance_mask) << FSPACE << int(instance_mask)
     << '\n';
  fp << int(ge_eSave_Value_zero_blank) << FSPACE << int(zero_blank) << '\n';
  fp << int(ge_eSave_Value_decimals_attr) << FSPACE << decimals_attr << '\n';
  fp << int(ge_eSave_Value_decimals_decr) << FSPACE << decimals_decr << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeValue::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeValue: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_Value:
      break;
    case ge_eSave_Value_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_Value_format:
      fp.get();
      fp.getline(format, sizeof(format));
      break;
    case ge_eSave_Value_instance:
      fp >> tmp;
      instance = (ge_mInstance)tmp;
      break;
    case ge_eSave_Value_instance_mask:
      fp >> tmp;
      instance_mask = (ge_mInstance)tmp;
      break;
    case ge_eSave_Value_zero_blank:
      fp >> zero_blank;
      break;
    case ge_eSave_Value_decimals_attr:
      fp.get();
      fp.getline(decimals_attr, sizeof(decimals_attr));
      break;
    case ge_eSave_Value_decimals_decr:
      fp >> decimals_decr;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeValue:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

static int read_decimals(GeDyn* dyn, char* attr, int decr, char* format)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;
  int inverted;
  char* s;
  pwr_tInt32 decimals;

  dyn->parse_attr_name(attr, parsed_name, &inverted, &attr_type, &attr_size);
  switch (attr_type) {
  case pwr_eType_Int32:
  case pwr_eType_UInt32:
  case pwr_eType_Enum:
  case pwr_eType_Mask:
    break;
  default:
    return 0;
  }

  sts = gdh_GetObjectInfo(parsed_name, &decimals, sizeof(decimals));
  if (EVEN(sts))
    return sts;

  decimals -= decr;
  if (decimals < 0)
    decimals = 0;
  if (decimals >= 10)
    return 0;

  // Print format, of replace digit between . and f
  s = strchr(format, 'f');
  if (s == 0)
    sprintf(format, "%%.%df", decimals);
  else {
    if (*(s - 2) != '.')
      sprintf(format, "%%.%df", decimals);
    else
      *(s - 1) = 48 + decimals;
  }
  return 1;
}

int GeValue::connect(grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;
  int inverted;

  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  size = attr_size;
  switch (db) {
  case graph_eDatabase_Gdh:
    if (attr_type == pwr_eType__)
      printf("Warning GeValue::connect, type is missing in  %s\n", attribute);

    switch (attr_type) {
    case pwr_eType_Enum:
    case pwr_eType_Mask: {
      // Get attribute tid
      pwr_sAttrRef ar;
      pwr_tAName aname;

      if (parsed_name[0] == '&') {
        sts = dyn->graph->get_reference_name(parsed_name, aname);
        if (EVEN(sts))
          return sts;
      } else
        strcpy(aname, parsed_name);

      sts = gdh_NameToAttrref(pwr_cNObjid, aname, &ar);
      if (EVEN(sts))
        break;
      sts = gdh_GetAttrRefTid(&ar, &tid);
      break;
    }
    default:;
    }

    sts = dyn->graph->ref_object_info(
        dyn->cycle, parsed_name, &p, &subid, attr_size, object, now);
    if (EVEN(sts))
      return sts;
    if (attr_type != 0)
      annot_typeid = attr_type;
    else
      annot_typeid = dyn_get_typeid(format);

    if (!check_format(format, annot_typeid)) {
      char name[80];

      grow_GetObjectName(object, name, sizeof(name), glow_eName_Object);
      printf("** GeValue: Suspicious format \"%s\" (%s, %s)\n", format, name,
          attribute);
    }
    break;
  case graph_eDatabase_Local:
    p = dyn->graph->localdb_ref_or_create(parsed_name, attr_type);
    annot_typeid = attr_type;
    if (attr_type == pwr_eType_String)
      annot_size = 80;
    else
      annot_size = 4;
  case graph_eDatabase_User:
    annot_typeid = attr_type;
    if (attr_type == pwr_eType_String)
      annot_size = 80;
    else
      annot_size = 4;
    break;
  case graph_eDatabase_Ccm:
    sts = dyn->graph->ccm_ref_variable(parsed_name, attr_type, &p);
    if (EVEN(sts))
      return sts;
    annot_typeid = attr_type;
    annot_size = attr_size;
    break;
  default:;
  }

  if (!streq(decimals_attr, "")) {
    read_decimals(dyn, decimals_attr, decimals_decr, format);
  }

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeValue::disconnect(grow_tObject object)
{
  int annot_num = GeDyn::instance_to_number(instance);

  if (grow_AnnotationInputIsOpen(object, annot_num)) {
    grow_CloseAnnotationInput(object, annot_num);
    grow_SetObjectInputFocus(object, 0, glow_eEvent_Null);
  }

  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeValue::scan(grow_tObject object)
{
  char buf[120];
  int len = 0;

  if (!p)
    return 1;

  if (db == graph_eDatabase_Gdh && annot_typeid == pwr_eType_NetStatus) {
    pwr_tTime t;
    pwr_tStatus sts;
    pwr_tBoolean old;

    gdh_GetSubscriptionOldness(subid, &old, &t, &sts);
    if (old)
      *(pwr_tNetStatus*)p = PWR__NETTIMEOUT;
  }

  switch (annot_typeid) {
  case pwr_eType_Float32: {
    pwr_tFloat32 val = *(pwr_tFloat32*)p;

    if (!first_scan) {
      if (memcmp(&old_value, &val, size) == 0)
        // No change since last time
        return 1;
    } else
      first_scan = false;

    if (zero_blank && fabsf(val) < FLT_EPSILON) {
      buf[0] = 0;
      len = 0;
    } else
      len = sprintf(buf, format, val);
    memcpy(&old_value, &val, MIN(size, (int)sizeof(old_value)));
    break;
  }
  case pwr_eType_Int32:
  case pwr_eType_UInt32: {
    pwr_tInt32 val = *(pwr_tInt32*)p;

    if (!first_scan) {
      if (memcmp(&old_value, &val, size) == 0)
        // No change since last time
        return 1;
    } else
      first_scan = false;

    if (zero_blank && val == 0) {
      buf[0] = 0;
      len = 0;
    } else
      len = sprintf(buf, format, val);
    memcpy(&old_value, &val, MIN(size, (int)sizeof(old_value)));
    break;
  }
  case pwr_eType_NetStatus:
    if (db == graph_eDatabase_Gdh) {
      pwr_tTime t;
      pwr_tStatus sts;
      pwr_tBoolean old;

      gdh_GetSubscriptionOldness(subid, &old, &t, &sts);
      if (old)
        *(pwr_tNetStatus*)p = PWR__NETTIMEOUT;
    }
  // No break
  case pwr_eType_Status: {
    pwr_tStatus val = *(pwr_tStatus*)p;

    if (!first_scan) {
      if (memcmp(&old_value, &val, size) == 0)
        // No change since last time
        return 1;
    } else
      first_scan = false;

    if (val == 0) {
      strcpy(buf, "");
      len = 0;
      break;
    }
    switch (format[1]) {
    case '1':
      // Format %1m: Write only the text
      msg_GetText(val, buf, sizeof(buf));
      break;
    default:
      msg_GetMsg(val, buf, sizeof(buf));
    }
    if (zero_blank && val == 0) {
      buf[0] = 0;
      len = 0;
    } else
      len = strlen(buf);
    memcpy(&old_value, &val, MIN(size, (int)sizeof(old_value)));
    break;
  }
  case pwr_eType_String:
  case pwr_eType_Text:
    if (!first_scan) {
      if (strncmp(old_value, (char*)p, size) == 0)
        // No change since last time
        return 1;
    } else
      first_scan = false;

    memcpy(&old_value, p, MIN(size, (int)sizeof(old_value)));

    len = snprintf(buf, sizeof(buf), format, (char*)p);
    break;
  case pwr_eType_Objid: {
    int sts;
    char name[120];
    pwr_tObjid objid = *(pwr_tObjid*)p;

    if (!first_scan) {
      if (memcmp(&old_value, &objid, size) == 0)
        // No change since last time
        return 1;
    } else
      first_scan = false;

    switch (format[1]) {
    case '1':
      // Format %1o, write path
      sts = gdh_ObjidToName(objid, name, sizeof(name), cdh_mName_pathStrict);
      break;
    case '2':
      // Format %2o, write volume and path
      sts = gdh_ObjidToName(objid, name, sizeof(name), cdh_mName_volumeStrict);
      break;
    default:
      sts = gdh_ObjidToName(objid, name, sizeof(name), cdh_mName_object);
    }
    if (EVEN(sts))
      strcpy(name, "");

    if (zero_blank && cdh_ObjidIsNull(objid)) {
      buf[0] = 0;
      len = 0;
    } else
      len = snprintf(buf, sizeof(buf), "%s", name);
    memcpy(&old_value, &objid, MIN(size, (int)sizeof(old_value)));
    break;
  }
  case pwr_eType_AttrRef: {
    int sts;
    char name[120];
    pwr_sAttrRef aref = *(pwr_sAttrRef*)p;

    if (!first_scan) {
      if (memcmp(&old_value, &aref, size) == 0)
        // No change since last time
        return 1;
    } else
      first_scan = false;

    if (cdh_ObjidIsNull(aref.Objid))
      strcpy(name, "");
    else {
      switch (format[1]) {
      case '1':
        // Format %1o, write path
        sts = gdh_AttrrefToName(
            &aref, name, sizeof(name), cdh_mName_pathStrict);
        break;
      case '2':
        // Format %2o, write volume and path
        sts = gdh_AttrrefToName(
            &aref, name, sizeof(name), cdh_mName_volumeStrict);
        break;
      default:
        sts = gdh_AttrrefToName(
            &aref, name, sizeof(name), cdh_mName_object | cdh_mName_attribute);
      }
      if (EVEN(sts))
        strcpy(name, "");
    }
    len = snprintf(buf, sizeof(buf), "%s", name);
    memcpy(&old_value, &aref, MIN(size, (int)sizeof(old_value)));
    break;
  }
  case pwr_eType_DataRef: {
    int sts;
    char name[120];
    pwr_tDataRef dataref = *(pwr_tDataRef*)p;

    if (!first_scan) {
      if (memcmp(&old_value, &dataref, size) == 0)
        // No change since last time
        return 1;
    } else
      first_scan = false;

    if (cdh_ObjidIsNull(dataref.Aref.Objid))
      strcpy(name, "");
    else {
      switch (format[1]) {
      case '1':
        // Format %1o, write path
        sts = gdh_AttrrefToName(
            &dataref.Aref, name, sizeof(name), cdh_mName_pathStrict);
        break;
      case '2':
        // Format %2o, write volume and path
        sts = gdh_AttrrefToName(
            &dataref.Aref, name, sizeof(name), cdh_mName_volumeStrict);
        break;
      default:
        sts = gdh_AttrrefToName(&dataref.Aref, name, sizeof(name),
            cdh_mName_object | cdh_mName_attribute);
      }
      if (EVEN(sts))
        strcpy(name, "");
    }
    len = snprintf(buf, sizeof(buf), "%s", name);
    memcpy(&old_value, &dataref, MIN(size, (int)sizeof(old_value)));
    break;
  }
  case pwr_eType_VolumeId: {
    pwr_tVolumeId vid = *(pwr_tVolumeId*)p;

    if (!first_scan) {
      if (memcmp(&old_value, &vid, size) == 0)
        // No change since last time
        return 1;
    } else
      first_scan = false;

    *buf = 0;
    cdh_VolumeIdToString(buf, sizeof(buf), vid, 0, 0);
    len = strlen(buf);
    memcpy(&old_value, &vid, sizeof(vid));
    break;
  }
  case graph_eType_NodeId: {
    pwr_tNodeId nid = *(pwr_tNodeId*)p;

    if (!first_scan) {
      if (memcmp(&old_value, &nid, size) == 0)
        // No change since last time
        return 1;
    } else
      first_scan = false;

    *buf = 0;
    if (nid != 0)
      strcpy(buf, qcom_NodeName(nid));
    if (*buf == 0)
      cdh_VolumeIdToString(buf, sizeof(buf), nid, 0, 0);
    len = strlen(buf);
    memcpy(&old_value, &nid, sizeof(nid));
    break;
  }
  case pwr_eType_Time: {
    int sts;
    char timstr[40];
    pwr_tTime val = *(pwr_tTime*)p;

    if (!first_scan) {
      if (memcmp(&old_value, &val, size) == 0)
        // No change since last time
        return 1;
    } else
      first_scan = false;

    switch (format[1]) {
    case '1':
      // Format %1t, only time, no hundredth
      sts = time_AtoAscii(&val, time_eFormat_Time, timstr, sizeof(timstr));
      timstr[8] = 0;
      break;
    case '2':
      // Format %2t, only time, with hundredth
      sts = time_AtoAscii(&val, time_eFormat_Time, timstr, sizeof(timstr));
      break;
    case '3':
      // Format %3t, compressed date and time, no hundredth
      sts = time_AtoAscii(
          &val, time_eFormat_ComprDateAndTime, timstr, sizeof(timstr));
      timstr[17] = 0;
      break;
    case '4':
      // Format %4t, date only
      sts = time_AtoAscii(
          &val, time_eFormat_DateAndTime, timstr, sizeof(timstr));
      timstr[11] = 0;
      break;
    case '5':
      // Format %5t, compressed date only
      sts = time_AtoAscii(
          &val, time_eFormat_ComprDateAndTime, timstr, sizeof(timstr));
      timstr[8] = 0;
      break;
    case '6':
      // Format %6t, 01:00:00 30/01/87
      sts = time_AtoAscii(
          &val, time_eFormat_TimeAndDate, timstr, sizeof(timstr));
      timstr[17] = 0;
      break;
    default:
      sts = time_AtoAscii(
          &val, time_eFormat_DateAndTime, timstr, sizeof(timstr));
    }
    if (EVEN(sts))
      strcpy(timstr, "-");
    if (zero_blank && val.tv_sec == 0 && val.tv_nsec == 0) {
      buf[0] = 0;
      len = 0;
    } else
      len = sprintf(buf, "%s", timstr);
    memcpy(&old_value, &val, MIN(size, (int)sizeof(old_value)));
    break;
  }
  case pwr_eType_DeltaTime: {
    int sts;
    char timstr[40];
    pwr_tDeltaTime val = *(pwr_tDeltaTime*)p;

    if (!first_scan) {
      if (memcmp(&old_value, &val, size) == 0)
        // No change since last time
        return 1;
    } else
      first_scan = false;

    switch (format[1]) {
    case '1':
      // Format %1t, only time, no hundredth
      sts = time_DtoAscii(&val, 0, timstr, sizeof(timstr));
      break;
    default:
      sts = time_DtoAscii(&val, 1, timstr, sizeof(timstr));
    }
    if (EVEN(sts))
      strcpy(timstr, "-");
    if (zero_blank && val.tv_sec == 0 && val.tv_nsec == 0) {
      buf[0] = 0;
      len = 0;
    } else
      len = sprintf(buf, "%s", timstr);
    memcpy(&old_value, &val, MIN(size, (int)sizeof(old_value)));
    break;
  }
  case pwr_eType_Enum: {
    int sts;
    bool converted = false;
    pwr_tInt32 val = *(pwr_tInt32*)p;

    if (!first_scan) {
      if (memcmp(&old_value, &val, size) == 0)
        // No change since last time
        return 1;
    } else
      first_scan = false;

    switch (format[strlen(format) - 1]) {
    case 's': {
      // Format %s, convert enum to string
      gdh_sValueDef* valuedef;
      int rows;

      sts = gdh_GetEnumValueDef(tid, &valuedef, &rows);
      if (EVEN(sts))
        break;

      for (int i = 0; i < rows; i++) {
        if (valuedef[i].Value->Value == val) {
          strcpy(buf, valuedef[i].Value->Text);
          len = strlen(buf);
          converted = true;
          break;
        }
      }
      free((char*)valuedef);
      break;
    }
    default:;
    }
    if (!converted) {
      sts = cdh_AttrValueToString(
          (pwr_eType)annot_typeid, &val, buf, sizeof(buf));
      if (EVEN(sts))
        sprintf(buf, "Invalid type");
      len = strlen(buf);
    }
    memcpy(&old_value, &val, MIN(size, (int)sizeof(old_value)));
    break;
  }
  case pwr_eType_Mask: {
    pwr_tUInt32 val = *(pwr_tUInt32*)p;

    if (!first_scan) {
      if (memcmp(&old_value, &val, size) == 0)
        // No change since last time
        return 1;
    } else
      first_scan = false;

    switch (format[strlen(format) - 1]) {
    case 'b':
      if (str_StartsWith(&format[1], "16"))
        cdh_MaskToBinaryString(val, 16, buf);
      else
        cdh_MaskToBinaryString(val, 32, buf);
      len = strlen(buf);
      break;
    default: {
      int sts;
      sts = cdh_AttrValueToString(
          (pwr_eType)annot_typeid, &val, buf, sizeof(buf));
      if (EVEN(sts))
        sprintf(buf, "Invalid type");
      len = strlen(buf);
    }
    }
    memcpy(&old_value, &val, MIN(size, (int)sizeof(old_value)));
    break;
  }
  default: {
    int sts;

    if (!first_scan) {
      if (memcmp(&old_value, p, size) == 0)
        // No change since last time
        return 1;
    } else
      first_scan = false;

    memcpy(&old_value, p, MIN(size, (int)sizeof(old_value)));

    sts = cdh_AttrValueToString((pwr_eType)annot_typeid, p, buf, sizeof(buf));
    if (EVEN(sts))
      sprintf(buf, "Invalid type");
    len = strlen(buf);
  }
  }
  int annot_num = GeDyn::instance_to_number(instance);
  // if ( annot_num == 1)
  // grow_SetAnnotationBrief( object, annot_num, buf, len);
  if (update_open)
    grow_SetAnnotationInput(object, annot_num, buf, len);
  else
    grow_SetAnnotation(object, annot_num, buf, len);
  return 1;
}

void GeValue::reset(grow_tObject object)
{
  int annot_num = GeDyn::instance_to_number(instance);

  grow_SetAnnotation(object, annot_num, "", 0);
  memset(&old_value, 0, sizeof(old_value));
}

int GeValue::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynValue(" << var_name << ".dd, \"" << attribute << "\",\""
     << format << "\")\n";
  return 1;
}

int GeValue::syntax_check(grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int sts;
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int inverted;
  char name[20];
  char atext[40];
  int annot_num;

  annot_num = GeDyn::instance_to_number(instance);
  if (annot_num == 1)
    strcpy(name, "Value");
  else
    sprintf(name, "Value[%d]", annot_num);

  sts = grow_CheckObjectAnnotation(object, annot_num);
  if (EVEN(sts)) {
    char msg[200];

    sprintf(msg, "%s, no annotation number %d", name, annot_num);
    dyn->graph->syntax_msg('E', object, msg);
    (*error_cnt)++;
  }

  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    pwr_eType_Int64, pwr_eType_UInt64, graph_eType_Bit, pwr_eType_Float32,
    pwr_eType_Float64, pwr_eType_String, pwr_eType_NetStatus, pwr_eType_Status,
    pwr_eType_Text, pwr_eType_Objid, pwr_eType_AttrRef, pwr_eType_DataRef,
    pwr_eType_Time, pwr_eType_DeltaTime, pwr_eType_Enum, pwr_eType_Mask,
    pwr_eType_Char, pwr_eType_Int8, pwr_eType_Int16, pwr_eType_UInt8,
    pwr_eType_UInt16, pwr_eType_ProString, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Local, graph_eDatabase_Gdh,
    graph_eDatabase_User, graph_eDatabase_Ccm, graph_eDatabase__ };

  sprintf(atext, "%s.Attribute", name);
  dyn->syntax_check_attribute(
      object, atext, attribute, 0, types, databases, error_cnt, warning_cnt);

  dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);

  if (streq(format, "")) {
    char msg[200];

    sprintf(msg, "%s.Format, format is missing", name);
    dyn->graph->syntax_msg('E', object, msg);
    (*error_cnt)++;
  } else if (!check_format(format, attr_type)) {
    char msg[200];

    sprintf(msg, "%s.Format, erroneous format \"%s\"", name, format);
    dyn->graph->syntax_msg('E', object, msg);
    (*warning_cnt)++;
  }

  return 1;
}

GeValueInput::GeValueInput(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No,
          ge_mActionType1_ValueInput, ge_mActionType2_No,
          ge_eDynPrio_ValueInput),
      min_value(0), max_value(0), clear(0), popup(0), unselect(0),
      escape_store(0), keyboard_type(graph_eKeyboard_Standard), update_open(0),
      value_element(0)
{
  strcpy(minvalue_attr, "");
  strcpy(maxvalue_attr, "");
}

GeValueInput::GeValueInput(const GeValueInput& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      min_value(x.min_value), max_value(x.max_value), clear(x.clear),
      popup(x.popup), unselect(x.unselect), escape_store(x.escape_store),
      keyboard_type(x.keyboard_type), update_open(x.update_open)
{
  strcpy(minvalue_attr, x.minvalue_attr);
  strcpy(maxvalue_attr, x.maxvalue_attr);
}

void GeValueInput::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "ValueInput.MinValue");
  attrinfo[i].value = &min_value;
  attrinfo[i].type = glow_eType_Double;
  attrinfo[i++].size = sizeof(min_value);

  strcpy(attrinfo[i].name, "ValueInput.MaxValue");
  attrinfo[i].value = &max_value;
  attrinfo[i].type = glow_eType_Double;
  attrinfo[i++].size = sizeof(max_value);

  strcpy(attrinfo[i].name, "ValueInput.Clear");
  attrinfo[i].value = &clear;
  attrinfo[i].type = glow_eType_Boolean;
  attrinfo[i++].size = sizeof(clear);

  strcpy(attrinfo[i].name, "ValueInput.Popup");
  attrinfo[i].value = &popup;
  attrinfo[i].type = glow_eType_Boolean;
  attrinfo[i++].size = sizeof(popup);

  strcpy(attrinfo[i].name, "ValueInput.Unselect");
  attrinfo[i].value = &unselect;
  attrinfo[i].type = glow_eType_Boolean;
  attrinfo[i++].size = sizeof(unselect);

  strcpy(attrinfo[i].name, "ValueInput.EscapeStore");
  attrinfo[i].value = &escape_store;
  attrinfo[i].type = glow_eType_Boolean;
  attrinfo[i++].size = sizeof(escape_store);

  strcpy(attrinfo[i].name, "ValueInput.MinValueAttr");
  attrinfo[i].value = minvalue_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(minvalue_attr);

  strcpy(attrinfo[i].name, "ValueInput.MaxValueAttr");
  attrinfo[i].value = maxvalue_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(maxvalue_attr);

  strcpy(attrinfo[i].name, "ValueInput.KeyboardType");
  attrinfo[i].value = &keyboard_type;
  attrinfo[i].type = ge_eAttrType_KeyboardType;
  attrinfo[i++].size = sizeof(keyboard_type);

  strcpy(attrinfo[i].name, "ValueInput.UpdateOpen");
  attrinfo[i].value = &update_open;
  attrinfo[i].type = glow_eType_Boolean;
  attrinfo[i++].size = sizeof(update_open);

  dyn->display_access = true;
  *item_count = i;
}

void GeValueInput::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(
      minvalue_attr, sizeof(minvalue_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      maxvalue_attr, sizeof(maxvalue_attr), from, to, cnt, strict);
}

void GeValueInput::save(std::ofstream& fp)
{
  fp << int(ge_eSave_ValueInput) << '\n';
  fp << int(ge_eSave_ValueInput_min_value) << FSPACE << min_value << '\n';
  fp << int(ge_eSave_ValueInput_max_value) << FSPACE << max_value << '\n';
  fp << int(ge_eSave_ValueInput_clear) << FSPACE << clear << '\n';
  fp << int(ge_eSave_ValueInput_popup) << FSPACE << popup << '\n';
  fp << int(ge_eSave_ValueInput_unselect) << FSPACE << unselect << '\n';
  fp << int(ge_eSave_ValueInput_minvalue_attr) << FSPACE << minvalue_attr
     << '\n';
  fp << int(ge_eSave_ValueInput_maxvalue_attr) << FSPACE << maxvalue_attr
     << '\n';
  fp << int(ge_eSave_ValueInput_escape_store) << FSPACE << escape_store << '\n';
  fp << int(ge_eSave_ValueInput_keyboard_type) << FSPACE << (int)keyboard_type
     << '\n';
  fp << int(ge_eSave_ValueInput_update_open) << FSPACE << update_open << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeValueInput::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeValueInput: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_ValueInput:
      break;
    case ge_eSave_ValueInput_min_value:
      fp >> min_value;
      break;
    case ge_eSave_ValueInput_max_value:
      fp >> max_value;
      break;
    case ge_eSave_ValueInput_clear:
      fp >> clear;
      break;
    case ge_eSave_ValueInput_popup:
      fp >> popup;
      break;
    case ge_eSave_ValueInput_unselect:
      fp >> unselect;
      break;
    case ge_eSave_ValueInput_minvalue_attr:
      fp.get();
      fp.getline(minvalue_attr, sizeof(minvalue_attr));
      break;
    case ge_eSave_ValueInput_maxvalue_attr:
      fp.get();
      fp.getline(maxvalue_attr, sizeof(maxvalue_attr));
      break;
    case ge_eSave_ValueInput_escape_store:
      fp >> escape_store;
      break;
    case ge_eSave_ValueInput_keyboard_type:
      fp >> tmp;
      keyboard_type = (graph_eKeyboard)tmp;
      break;
    case ge_eSave_ValueInput_update_open:
      fp >> update_open;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeValueInput:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeValueInput::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  // Get the Value element
  annot_typeid = annot_size = 0;
  value_element = 0;
  for (GeDynElem* elem = dyn->elements; elem; elem = elem->next) {
    if (elem->dyn_type1 == ge_mDynType1_Value) {
      value_element = (GeValue*)elem;
      annot_typeid = value_element->annot_typeid;
      annot_size = value_element->annot_size;
      value_element->update_open = update_open;
      break;
    }
  }

  return 1;
}

int GeValueInput::disconnect(grow_tObject object)
{
  return 1;
}

int GeValueInput::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;
  if (!value_element)
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetClickSensitivity(dyn->graph->grow->ctx, glow_mSensitivity_MB1Click);
    break;
  case glow_eEvent_MB1Click:
    if (!(dyn->total_action_type1 & ge_mActionType1_InputFocus)) {
      grow_SetObjectInputFocus(object, 1, event->event);
      dyn->graph->set_inputfocus(1);
    }
    break;
  case glow_eEvent_AnnotationInput: {
    int sts;

    sts = change_value(object, event->annot_input.text);
    if (ODD(sts)) {
      grow_CloseAnnotationInput(object, 1);
      grow_SetObjectInputFocus(object, 0, event->event);
      if (dyn->total_action_type1 & ge_mActionType1_InputFocus)
        // Trigger a tab event, this is ugly but it works...
        event->event = glow_eEvent_Key_Tab;
    }
    break;
  }
  case glow_eEvent_InputFocusGained: {
    if (!popup) {
      if (!grow_AnnotationInputIsOpen(object, 1)) {
        // grow_CloseAnnotationInputAll( dyn->graph->grow->ctx);

        if (clear)
          grow_SetAnnotationBrief(object, 1, "", 0);
        grow_OpenAnnotationInput(object, 1);
        if (unselect)
          grow_SetAnnotationSelection(object, 0);
      }
      if (dyn->graph->keyboard_cb)
        (dyn->graph->keyboard_cb)(
            dyn->graph->parent_ctx, keyboard_mAction_Open, keyboard_type);
    } else {
      if (dyn->graph->change_value_cb) {
        char str[80] = "";

        if (!clear)
          grow_GetAnnotation(object, 1, str, sizeof(str));
        (dyn->graph->change_value_cb)(dyn->graph->parent_ctx, object, str);
      }
    }
    break;
  }
  case glow_eEvent_InputFocusLost: {
    if (escape_store) {
      pwr_tStatus sts;
      char str[200];

      grow_GetAnnotation(object, 1, str, sizeof(str));
      sts = change_value(object, str);
    }
    grow_CloseAnnotationInput(object, 1);
    value_element->first_scan = 1;

    if (dyn->graph->keyboard_cb)
      (dyn->graph->keyboard_cb)(
          dyn->graph->parent_ctx, keyboard_mAction_Close, 0);

    break;
  }
  case glow_eEvent_Key_Escape:
    if (grow_AnnotationInputIsOpen(object, 1)) {
      grow_CloseAnnotationInputAll(dyn->graph->grow->ctx);
      grow_SetObjectInputFocus(object, 0, event->event);

      if (dyn->graph->keyboard_cb)
        (dyn->graph->keyboard_cb)(dyn->graph->parent_ctx,
            keyboard_mAction_Close | keyboard_mAction_ResetInput, 0);
    }
    break;
  default:;
  }
  return 1;
}

int GeValueInput::change_value(grow_tObject object, char* text)
{
  char buf[200];
  int sts;
  pwr_tAName parsed_name;
  int inverted;
  int attr_type, attr_size;
  graph_eDatabase db;

  db = dyn->parse_attr_name(
      value_element->attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (parsed_name[0] == '&')
    dyn->graph->get_reference_name(parsed_name, parsed_name);

  if (!annot_size) {
    pwr_sAttrRef ar;
    pwr_tTypeId a_type_id;
    unsigned int a_size;
    unsigned int a_offset;
    unsigned int a_dim;

    sts = gdh_NameToAttrref(pwr_cNObjid, parsed_name, &ar);
    if (EVEN(sts))
      return sts;
    sts = gdh_GetAttributeCharAttrref(
        &ar, &a_type_id, &a_size, &a_offset, &a_dim);
    if (EVEN(sts))
      return sts;
    annot_typeid = a_type_id;
    annot_size = a_size;
  }
  if (value_element->zero_blank && streq(text, ""))
    sts = graph_attr_string_to_value(
        annot_typeid, "0", (void*)&buf, sizeof(buf), sizeof(buf));
  else {
    if (annot_typeid == pwr_eType_String)
      sts = graph_attr_string_to_value(
          annot_typeid, text, (void*)&buf, sizeof(buf), annot_size);
    else
      sts = graph_attr_string_to_value(
          annot_typeid, text, (void*)&buf, sizeof(buf), sizeof(buf));
  }
  if (EVEN(sts)) {
    if (dyn->graph->message_dialog_cb) {
      char msg[80];
      if (sts == GE__STRINGTOLONG)
        strcpy(msg, "Input string too long");
      else if (sts == GE__OBJNOTFOUND)
        strcpy(msg, "Object not found");
      else
        strcpy(msg, "Input syntax error");
      (dyn->graph->message_dialog_cb)(dyn->graph->parent_ctx, msg);
    }
    return sts;
  }

  if (!streq(minvalue_attr, "")) {
    pwr_tAName pname;

    dyn->parse_attr_name(
        minvalue_attr, pname, &inverted, &attr_type, &attr_size);
    if (attr_type == pwr_eType_Float32) {
      pwr_tFloat32 minval;

      sts = gdh_GetObjectInfo(pname, &minval, sizeof(minval));
      if (EVEN(sts))
        return sts;
      min_value = minval;
    }
  }
  if (!streq(maxvalue_attr, "")) {
    pwr_tAName pname;

    dyn->parse_attr_name(
        maxvalue_attr, pname, &inverted, &attr_type, &attr_size);
    if (attr_type == pwr_eType_Float32) {
      pwr_tFloat32 maxval;

      sts = gdh_GetObjectInfo(pname, &maxval, sizeof(maxval));
      if (EVEN(sts))
        return sts;
      max_value = maxval;
    }
  }

  if (!(feq(max_value, 0.0) && feq(min_value, 0.0))) {
    // Max value is supplied
    int max_exceeded = 0;

    switch (annot_typeid) {
    case pwr_eType_Float32:
      if (double(*(pwr_tFloat32*)buf) > max_value)
        max_exceeded = 1;
      break;
    case pwr_eType_Float64:
      if (double(*(pwr_tFloat64*)buf) > max_value)
        max_exceeded = 1;
      break;
    case pwr_eType_Int64:
      if (double(*(pwr_tInt64*)buf) > max_value)
        max_exceeded = 1;
      break;
    case pwr_eType_UInt64:
      if (double(*(pwr_tUInt64*)buf) > max_value)
        max_exceeded = 1;
      break;
    case pwr_eType_Int32:
      if (double(*(pwr_tInt32*)buf) > max_value)
        max_exceeded = 1;
      break;
    case pwr_eType_UInt32:
      if (double(*(pwr_tUInt32*)buf) > max_value)
        max_exceeded = 1;
      break;
    case pwr_eType_Int16:
      if (double(*(pwr_tInt16*)buf) > max_value)
        max_exceeded = 1;
      break;
    case pwr_eType_UInt16:
      if (double(*(pwr_tUInt16*)buf) > max_value)
        max_exceeded = 1;
      break;
    case pwr_eType_Int8:
      if (double(*(pwr_tInt8*)buf) > max_value)
        max_exceeded = 1;
      break;
    case pwr_eType_UInt8:
      if (double(*(pwr_tUInt8*)buf) > max_value)
        max_exceeded = 1;
      break;
    case pwr_eType_DeltaTime:
      if (feq(double(((pwr_tDeltaTime*)buf)->tv_sec), max_value)
          && ((pwr_tDeltaTime*)buf)->tv_nsec > 0)
        max_exceeded = 1;
      else if (double(((pwr_tDeltaTime*)buf)->tv_sec) > max_value)
        max_exceeded = 1;
      break;
    }
    if (max_exceeded) {
      if (dyn->graph->message_dialog_cb)
        (dyn->graph->message_dialog_cb)(
            dyn->graph->parent_ctx, "Maxvalue exceeded");
      return 0;
    }

    int min_exceeded = 0;
    switch (annot_typeid) {
    case pwr_eType_Float32:
      if (double(*(pwr_tFloat32*)buf) < min_value)
        min_exceeded = 1;
      break;
    case pwr_eType_Float64:
      if (double(*(pwr_tFloat64*)buf) < min_value)
        min_exceeded = 1;
      break;
    case pwr_eType_Int64:
      if (double(*(pwr_tInt64*)buf) < min_value)
        min_exceeded = 1;
      break;
    case pwr_eType_UInt64:
      if (double(*(pwr_tUInt64*)buf) < min_value)
        min_exceeded = 1;
      break;
    case pwr_eType_Int32:
      if (double(*(pwr_tInt32*)buf) < min_value)
        min_exceeded = 1;
      break;
    case pwr_eType_UInt32:
      if (double(*(pwr_tUInt32*)buf) < min_value)
        min_exceeded = 1;
      break;
    case pwr_eType_Int16:
      if (double(*(pwr_tInt16*)buf) < min_value)
        min_exceeded = 1;
      break;
    case pwr_eType_UInt16:
      if (double(*(pwr_tUInt16*)buf) < min_value)
        min_exceeded = 1;
      break;
    case pwr_eType_Int8:
      if (double(*(pwr_tInt8*)buf) < min_value)
        min_exceeded = 1;
      break;
    case pwr_eType_UInt8:
      if (double(*(pwr_tUInt8*)buf) < min_value)
        min_exceeded = 1;
      break;
    case pwr_eType_DeltaTime:
      if (double(((pwr_tDeltaTime*)buf)->tv_sec) < min_value)
        min_exceeded = 1;
      break;
    }
    if (min_exceeded) {
      if (dyn->graph->message_dialog_cb)
        (dyn->graph->message_dialog_cb)(
            dyn->graph->parent_ctx, "Value below minvalue");
      return 0;
    }
  }

  if (db == graph_eDatabase_Local)
    sts = dyn->graph->localdb_set_value(parsed_name, &buf, annot_size);
  else if (db == graph_eDatabase_Ccm)
    sts = dyn->graph->ccm_set_variable(parsed_name, annot_typeid, &buf);
  else
    sts = gdh_SetObjectInfo(parsed_name, &buf, annot_size);
  if (EVEN(sts))
    printf("AnnotationInput error: %s\n", value_element->attribute);
  return 1;
}

int GeValueInput::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  int class_dyn_type1, class_action_type1;
  int class_dyn_type2, class_action_type2;

  // Check that nodeclass is a valueinput, otherwise this will not be a
  // GeTextField
  grow_GetObjectClassDynType(object, &class_dyn_type1, &class_dyn_type2,
      &class_action_type1, &class_action_type2);
  if (!(class_action_type1 & ge_mActionType1_ValueInput))
    return 1;

  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynValueInput(" << var_name << ".dd, " << min_value << ","
     << max_value << ",";
  if (streq(minvalue_attr, ""))
    fp << "null,";
  else
    fp << "\"" << minvalue_attr << "\",";
  if (streq(maxvalue_attr, ""))
    fp << "null)\n";
  else
    fp << "\"" << maxvalue_attr << "\")\n";
  return 1;
}

int GeValueInput::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[]
      = { pwr_eType_Int8, pwr_eType_Int16, pwr_eType_Int32, pwr_eType_Int64,
          pwr_eType_UInt8, pwr_eType_UInt16, pwr_eType_UInt32, pwr_eType_UInt64,
          pwr_eType_Float32, pwr_eType_Float64, pwr_eType_DeltaTime, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase__ };

  dyn->syntax_check_attribute(object, "ValueInput.MinValueAttr", minvalue_attr,
      1, types, databases, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "ValueInput.MaxValueAttr", maxvalue_attr,
      1, types, databases, error_cnt, warning_cnt);
  return 1;
}

GeAnalogColor::GeAnalogColor(GeDyn* e_dyn, ge_mInstance e_instance)
    : GeDynElem(e_dyn, ge_mDynType1_AnalogColor, ge_mDynType2_No,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_AnalogColor),
      limit(0), limit_type(ge_eLimitType_Gt), color(glow_eDrawType_Inherit),
      border(0), common_attr(1), old_state(false), p(0), old_value(FLT_INI),
      e(0)
{
  strcpy(attribute, "");
  instance = e_instance;
}

GeAnalogColor::GeAnalogColor(const GeAnalogColor& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      limit(x.limit), limit_type(x.limit_type), color(x.color),
      border(x.border), common_attr(x.common_attr), old_state(false), p(0),
      old_value(FLT_INI), e(0)
{
  strcpy(attribute, x.attribute);
  instance = x.instance;
  instance_mask = x.instance_mask;
}

void GeAnalogColor::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;
  GeDynElem* elem;
  GeAnalogColor* e;
  bool found = false;

  // Get attribute for instance 1
  if (instance == ge_mInstance_1)
    e = this;
  else {
    for (elem = dyn->elements; elem; elem = elem->next) {
      if (elem->dyn_type1 == ge_mDynType1_AnalogColor
          && elem->instance == ge_mInstance_1) {
        found = true;
        break;
      }
    }
    if (!found)
      return;

    e = (GeAnalogColor*)elem;
  }

  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    if (instance == ge_mInstance_1) {
      strcpy(attrinfo[i].name, "AnalogTone.Limit");
      attrinfo[i].value = &limit;
      attrinfo[i].type = glow_eType_Double;
      attrinfo[i++].size = sizeof(limit);

      strcpy(attrinfo[i].name, "AnalogTone.Tone");
      attrinfo[i].value = &color;
      attrinfo[i].type = glow_eType_ToneOrColor;
      attrinfo[i++].size = sizeof(limit_type);

      strcpy(attrinfo[i].name, "AnalogTone.LimitType");
      attrinfo[i].value = &limit_type;
      attrinfo[i].type = ge_eAttrType_LimitType;
      attrinfo[i++].size = sizeof(limit_type);

      strcpy(attrinfo[i].name, "AnalogTone.Attribute");
      attrinfo[i].value = attribute;
      attrinfo[i].type = glow_eType_String;
      attrinfo[i++].size = sizeof(attribute);

      strcpy(attrinfo[i].name, "AnalogTone.Border");
      attrinfo[i].value = &border;
      attrinfo[i].type = glow_eType_Boolean;
      attrinfo[i++].size = sizeof(border);

      strcpy(attrinfo[i].name, "AnalogTone.CommonAttribute");
      attrinfo[i].value = &common_attr;
      attrinfo[i].type = glow_eType_Boolean;
      attrinfo[i++].size = sizeof(common_attr);

      strcpy(attrinfo[i].name, "AnalogTone.Instances");
      attrinfo[i].value = &instance_mask;
      attrinfo[i].type = ge_eAttrType_InstanceMask;
      attrinfo[i++].size = sizeof(instance_mask);
    } else {
      // Get instance number
      int inst = 1;
      unsigned int m = instance;
      while (m > 1) {
        m = m >> 1;
        inst++;
      }

      if (!e->common_attr) {
        strcpy(attrinfo[i].name, "AnalogTone.Attribute");
        attrinfo[i].value = attribute;
        attrinfo[i].type = glow_eType_String;
        attrinfo[i++].size = sizeof(attribute);
      }

      sprintf(attrinfo[i].name, "AnalogTone%d.Limit", inst);
      attrinfo[i].value = &limit;
      attrinfo[i].type = glow_eType_Double;
      attrinfo[i++].size = sizeof(limit);

      sprintf(attrinfo[i].name, "AnalogTone%d.Tone", inst);
      attrinfo[i].value = &color;
      attrinfo[i].type = glow_eType_ToneOrColor;
      attrinfo[i++].size = sizeof(limit_type);

      sprintf(attrinfo[i].name, "AnalogTone%d.LimitType", inst);
      attrinfo[i].value = &limit_type;
      attrinfo[i].type = ge_eAttrType_LimitType;
      attrinfo[i++].size = sizeof(limit_type);
    }
  } else {
    if (instance == ge_mInstance_1) {
      strcpy(attrinfo[i].name, "AnalogColor.Limit");
      attrinfo[i].value = &limit;
      attrinfo[i].type = glow_eType_Double;
      attrinfo[i++].size = sizeof(limit);

      strcpy(attrinfo[i].name, "AnalogColor.Color");
      attrinfo[i].value = &color;
      attrinfo[i].type = glow_eType_Color;
      attrinfo[i++].size = sizeof(limit_type);

      strcpy(attrinfo[i].name, "AnalogColor.LimitType");
      attrinfo[i].value = &limit_type;
      attrinfo[i].type = ge_eAttrType_LimitType;
      attrinfo[i++].size = sizeof(limit_type);

      strcpy(attrinfo[i].name, "AnalogColor.Attribute");
      attrinfo[i].value = attribute;
      attrinfo[i].type = glow_eType_String;
      attrinfo[i++].size = sizeof(attribute);

      strcpy(attrinfo[i].name, "AnalogColor.Border");
      attrinfo[i].value = &border;
      attrinfo[i].type = glow_eType_Boolean;
      attrinfo[i++].size = sizeof(border);

      strcpy(attrinfo[i].name, "AnalogColor.CommonAttribute");
      attrinfo[i].value = &common_attr;
      attrinfo[i].type = glow_eType_Boolean;
      attrinfo[i++].size = sizeof(common_attr);

      strcpy(attrinfo[i].name, "AnalogColor.Instances");
      attrinfo[i].value = &instance_mask;
      attrinfo[i].type = ge_eAttrType_InstanceMask;
      attrinfo[i++].size = sizeof(instance_mask);
    } else {
      // Get instance number
      int inst = 1;
      unsigned int m = instance;
      while (m > 1) {
        m = m >> 1;
        inst++;
      }

      if (!e->common_attr) {
	sprintf(attrinfo[i].name, "AnalogColor%d.Attribute", inst);
        attrinfo[i].value = attribute;
        attrinfo[i].type = glow_eType_String;
        attrinfo[i++].size = sizeof(attribute);
      }
      sprintf(attrinfo[i].name, "AnalogColor%d.Limit", inst);
      attrinfo[i].value = &limit;
      attrinfo[i].type = glow_eType_Double;
      attrinfo[i++].size = sizeof(limit);

      sprintf(attrinfo[i].name, "AnalogColor%d.Color", inst);
      attrinfo[i].value = &color;
      attrinfo[i].type = glow_eType_Color;
      attrinfo[i++].size = sizeof(limit_type);

      sprintf(attrinfo[i].name, "AnalogColor%d.LimitType", inst);
      attrinfo[i].value = &limit_type;
      attrinfo[i].type = ge_eAttrType_LimitType;
      attrinfo[i++].size = sizeof(limit_type);

      sprintf(attrinfo[i].name, "AnalogColor%d.Border", inst);
      attrinfo[i].value = &border;
      attrinfo[i].type = glow_eType_Boolean;
      attrinfo[i++].size = sizeof(border);
    }
  }
  *item_count = i;
}

void GeAnalogColor::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    GeDynElem* elem;
    GeAnalogColor* e;
    bool found = false;

    // Set attribute for instance 1
    if (instance == ge_mInstance_1)
      e = this;
    else {
      for (elem = dyn->elements; elem; elem = elem->next) {
        if (elem->dyn_type1 == ge_mDynType1_AnalogColor
            && elem->instance == ge_mInstance_1) {
          found = true;
          break;
        }
      }
      if (!found)
        return;
      e = (GeAnalogColor*)elem;
    }

    char msg[200];

    strncpy(e->attribute, attr_name, sizeof(attribute));
    if (dyn->total_dyn_type1 & ge_mDynType1_Tone)
      snprintf(msg, sizeof(msg), "AnalogTone.Attribute = %s", attr_name);
    else
      snprintf(msg, sizeof(msg), "AnalogColor.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeAnalogColor::replace_attribute(
    char* from, char* to, int* cnt, int strict)
{
  GeDynElem* elem;
  GeAnalogColor* e;
  bool found = false;

  // Get instance 1
  if (instance == ge_mInstance_1)
    e = this;
  else {
    for (elem = dyn->elements; elem; elem = elem->next) {
      if (elem->dyn_type1 == ge_mDynType1_AnalogColor
          && elem->instance == ge_mInstance_1) {
        found = true;
        break;
      }
    }
    if (!found)
      return;
    e = (GeAnalogColor*)elem;
  }

  if (e->common_attr) {
    if (instance == ge_mInstance_1)
      GeDyn::replace_attribute(
          attribute, sizeof(attribute), from, to, cnt, strict);
  } else
    GeDyn::replace_attribute(
        attribute, sizeof(attribute), from, to, cnt, strict);
}

int GeAnalogColor::set_color(grow_tObject object, glow_eDrawType color)
{
  char msg[200];

  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    this->color = glow_eDrawType(color / 30);
    if (instance == ge_mInstance_1)
      snprintf(msg, sizeof(msg), "AnalogTone.Tone = %s",
          grow_ColorToneToName(this->color));
    else
      snprintf(msg, sizeof(msg), "AnalogTone%d.Tone = %s",
          GeDyn::instance_to_number(instance),
          grow_ColorToneToName(this->color));
  } else {
    this->color = color;
    if (instance == ge_mInstance_1)
      snprintf(msg, sizeof(msg), "AnalogColor.Color = %s",
          grow_ColorToName(this->color));
    else
      snprintf(msg, sizeof(msg), "AnalogColor%d.Color = %s",
          GeDyn::instance_to_number(instance), grow_ColorToName(this->color));
  }
  msg[sizeof(msg) - 1] = 0;
  dyn->graph->message('I', msg);
  return 1;
}

void GeAnalogColor::save(std::ofstream& fp)
{
  fp << int(ge_eSave_AnalogColor) << '\n';
  fp << int(ge_eSave_AnalogColor_attribute) << FSPACE << attribute << '\n';
  fp.precision(9);
  fp << int(ge_eSave_AnalogColor_limit) << FSPACE << limit << '\n';
  fp.precision(6);
  fp << int(ge_eSave_AnalogColor_limit_type) << FSPACE << (int)limit_type
     << '\n';
  fp << int(ge_eSave_AnalogColor_color) << FSPACE << (int)color << '\n';
  fp << int(ge_eSave_AnalogColor_instance) << FSPACE << int(instance) << '\n';
  fp << int(ge_eSave_AnalogColor_instance_mask) << FSPACE << int(instance_mask)
     << '\n';
  fp << int(ge_eSave_AnalogColor_border) << FSPACE << border << '\n';
  fp << int(ge_eSave_AnalogColor_common_attr) << FSPACE << common_attr << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeAnalogColor::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeAnalogcolor: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_AnalogColor:
      break;
    case ge_eSave_AnalogColor_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_AnalogColor_limit:
      fp >> limit;
      break;
    case ge_eSave_AnalogColor_limit_type:
      fp >> tmp;
      limit_type = (ge_eLimitType)tmp;
      break;
    case ge_eSave_AnalogColor_color:
      fp >> tmp;
      color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_AnalogColor_instance:
      fp >> tmp;
      instance = (ge_mInstance)tmp;
      break;
    case ge_eSave_AnalogColor_instance_mask:
      fp >> tmp;
      instance_mask = (ge_mInstance)tmp;
      break;
    case ge_eSave_AnalogColor_border:
      fp >> tmp;
      border = (int)tmp;
      break;
    case ge_eSave_AnalogColor_common_attr:
      fp >> common_attr;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeAnalogColor:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeAnalogColor::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  pwr_tAName parsed_name;
  int inverted;
  int sts;
  bool found = false;
  GeDynElem* elem;

  color = dyn->get_color1(object, color);
  if (color < 0 || color >= glow_eDrawType__) {
    printf("** Color out of range, %s\n", attribute);
    return 0;
  }

  // Get instance 1
  if (instance == ge_mInstance_1)
    e = this;
  else {
    for (elem = dyn->elements; elem; elem = elem->next) {
      if (elem->dyn_type1 == ge_mDynType1_AnalogColor
          && elem->instance == ge_mInstance_1) {
        found = true;
        break;
      }
    }
    if (!found)
      return 1;
    e = (GeAnalogColor*)elem;
  }

  if (!e->common_attr || instance == ge_mInstance_1) {
    size = 4;
    db = dyn->parse_attr_name(attribute, parsed_name, &inverted, &type, &size);
    if (streq(parsed_name, ""))
      return 1;

    switch (type) {
    case pwr_eType_Float32:
    case pwr_eType_Int32:
    case pwr_eType_UInt32:
      break;
    default:
      return 1;
    }

    sts = dyn->graph->ref_object_info(
        dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
    if (EVEN(sts))
      return sts;

    trace_data->p = &pdummy;
  } else {
    type = e->type;
    size = e->size;
    p = e->p;
  }
  first_scan = true;
  return 1;
}

int GeAnalogColor::disconnect(grow_tObject object)
{
  if ((!e->common_attr || instance == ge_mInstance_1) && p
      && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeAnalogColor::scan(grow_tObject object)
{
  if (!p && instance != ge_mInstance_1) {
    p = e->p;
    type = e->type;
    size = e->size;
  }
  if (!p || dyn->ignore_color)
    return 1;

  bool state = false;

  switch (type) {
  case pwr_eType_Float32: {
    pwr_tFloat32 val = *(pwr_tFloat32*)p;
    if (!first_scan) {
      if (!dyn->reset_color && fabs(old_value - val) < FLT_EPSILON) {
        // No change since last time
        if (old_state)
          dyn->ignore_color = true;
        return 1;
      }
    } else
      first_scan = false;

    switch (limit_type) {
    case ge_eLimitType_Gt:
      state = val > limit;
      break;
    case ge_eLimitType_Ge:
      state = val >= (limit - FLT_EPSILON);
      break;
    case ge_eLimitType_Lt:
      state = val < limit;
      break;
    case ge_eLimitType_Le:
      state = val <= (limit + FLT_EPSILON);
      break;
    case ge_eLimitType_Eq:
      state = fabs(val - limit) < FLT_EPSILON;
      break;
    }

    memcpy(&old_value, &val, size);
    break;
  }
  case pwr_eType_Int32:
  case pwr_eType_UInt32: {
    pwr_tInt32 val = *(pwr_tInt32*)p;

    if (!first_scan) {
      if (!dyn->reset_color && memcmp(&old_value, &val, size) == 0) {
        // No change since last time
        if (old_state)
          dyn->ignore_color = true;
        return 1;
      }
    } else
      first_scan = false;

    switch (limit_type) {
    case ge_eLimitType_Gt:
      state = val > limit;
      break;
    case ge_eLimitType_Ge:
      state = val >= limit;
      break;
    case ge_eLimitType_Lt:
      state = val < limit;
      break;
    case ge_eLimitType_Le:
      state = val <= limit;
      break;
    case ge_eLimitType_Eq:
      state = feq((double)val, limit);
      break;
    }

    memcpy(&old_value, &val, size);
    break;
  }
  default:;
  }

  bool set_color = false;
  bool reset_color = false;

  if (first_scan || state != old_state || dyn->reset_color) {
    if (state) {
      set_color = true;
      dyn->ignore_color = true;
    } else {
      reset_color = true;
      dyn->reset_color = true;
    }
    old_state = state;
  } else if (state)
    dyn->ignore_color = true;

  if (!set_color && !reset_color) {
    return 1;
  }
  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    if (set_color) {
      if (color >= (glow_eDrawType)glow_eDrawTone__) {
        if (!border)
          grow_SetObjectFillColor(object, color);
        else
          grow_SetObjectBorderColor(object, color);
      } else
        grow_SetObjectColorTone(object, (glow_eDrawTone)color);
      dyn->ignore_color = true;
    } else {
      if (color >= (glow_eDrawType)glow_eDrawTone__) {
        if (!border)
          grow_ResetObjectFillColor(object);
        else
          grow_ResetObjectBorderColor(object);
      }
      grow_ResetObjectColorTone(object);
      dyn->reset_color = true;
    }
  } else {
    if (set_color) {
      if (!border)
        grow_SetObjectFillColor(object, color);
      else
        grow_SetObjectBorderColor(object, color);
      dyn->ignore_color = true;
    } else {
      if (!border)
        grow_ResetObjectFillColor(object);
      else
        grow_ResetObjectBorderColor(object);
      dyn->reset_color = true;
    }
  }

  return 1;
}

int GeAnalogColor::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynAnalogColor(" << var_name << ".dd, \"" << attribute << "\","
     << limit << "," << limit_type << "," << color << ")\n";
  return 1;
}

int GeAnalogColor::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  glow_eDrawType tcolor = dyn->get_color1(object, color);
  if (tcolor < 0 || tcolor >= glow_eDrawType__) {
    dyn->graph->syntax_msg('E', object, "AnalogColor, Color out or range");
    (*error_cnt)++;
  }

  if (instance == ge_mInstance_1) {
    int types[] = { pwr_eType_Int32, pwr_eType_UInt32, pwr_eType_Float32, 0 };
    graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase__ };
    dyn->syntax_check_attribute(object, "AnalogColor.Attribute", attribute, 0,
        types, databases, error_cnt, warning_cnt);
  }
  return 1;
}

GeRotate::GeRotate(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_Rotate, ge_mDynType2_No, ge_mActionType1_No,
          ge_mActionType2_No, ge_eDynPrio_Rotate),
      x0(0), y0(0), factor(1), offset(0), min_angle(0), max_angle(0)
{
  strcpy(attribute, "");
}

GeRotate::GeRotate(const GeRotate& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      x0(x.x0), y0(x.y0), factor(x.factor), offset(x.offset), min_angle(x.min_angle),
      max_angle(x.max_angle)
{
  strcpy(attribute, x.attribute);
}

void GeRotate::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "Rotate.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  strcpy(attrinfo[i].name, "Rotate.x0");
  attrinfo[i].value = &x0;
  attrinfo[i].type = glow_eType_Double;
  attrinfo[i++].size = sizeof(x0);

  strcpy(attrinfo[i].name, "Rotate.y0");
  attrinfo[i].value = &y0;
  attrinfo[i].type = glow_eType_Double;
  attrinfo[i++].size = sizeof(y0);

  strcpy(attrinfo[i].name, "Rotate.Factor");
  attrinfo[i].value = &factor;
  attrinfo[i].type = glow_eType_Double;
  attrinfo[i++].size = sizeof(factor);

  strcpy(attrinfo[i].name, "Rotate.Offset");
  attrinfo[i].value = &offset;
  attrinfo[i].type = glow_eType_Double;
  attrinfo[i++].size = sizeof(offset);

  strcpy(attrinfo[i].name, "Rotate.MinAngle");
  attrinfo[i].value = &min_angle;
  attrinfo[i].type = glow_eType_Double;
  attrinfo[i++].size = sizeof(min_angle);

  strcpy(attrinfo[i].name, "Rotate.MaxAngle");
  attrinfo[i].value = &max_angle;
  attrinfo[i].type = glow_eType_Double;
  attrinfo[i++].size = sizeof(max_angle);

  *item_count = i;
}

void GeRotate::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "Rotate.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeRotate::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeRotate::save(std::ofstream& fp)
{
  fp << int(ge_eSave_Rotate) << '\n';
  fp << int(ge_eSave_Rotate_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_Rotate_x0) << FSPACE << x0 << '\n';
  fp << int(ge_eSave_Rotate_y0) << FSPACE << y0 << '\n';
  fp << int(ge_eSave_Rotate_factor) << FSPACE << factor << '\n';
  fp << int(ge_eSave_Rotate_offset) << FSPACE << offset << '\n';
  fp << int(ge_eSave_Rotate_min_angle) << FSPACE << min_angle << '\n';
  fp << int(ge_eSave_Rotate_max_angle) << FSPACE << max_angle << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeRotate::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeRotate: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_Rotate:
      break;
    case ge_eSave_Rotate_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_Rotate_x0:
      fp >> x0;
      break;
    case ge_eSave_Rotate_y0:
      fp >> y0;
      break;
    case ge_eSave_Rotate_factor:
      fp >> factor;
      break;
    case ge_eSave_Rotate_offset:
      fp >> offset;
      break;
    case ge_eSave_Rotate_min_angle:
      fp >> min_angle;
      break;
    case ge_eSave_Rotate_max_angle:
      fp >> max_angle;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeRotate:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeRotate::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int inverted;
  int sts;

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  sts = dyn->graph->ref_object_info(
      dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
  if (EVEN(sts))
    return sts;

  trace_data->p = &pdummy;
  first_scan = true;
  if (!grow_TransformIsStored(object))
    grow_StoreTransform(object);

  if (!feq(x0, 0.0) || !feq(y0, 0.0))
    rotation_point = glow_eRotationPoint_FixPoint;
  else
    rotation_point = glow_eRotationPoint_Zero;

  return 1;
}

int GeRotate::disconnect(grow_tObject object)
{
  if (p) {
    grow_SetObjectRotation(object, 0, x0, y0, rotation_point);
    grow_RevertTransform(object);
  }
    
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeRotate::scan(grow_tObject object)
{
  if (!p)
    return 1;
  pwr_tFloat32 val = *p;

  if (!first_scan) {
    if (fabs(old_value - val) < FLT_EPSILON)
      // No change since last time
      return 1;
  } else
    first_scan = false;

  double value = val * factor + offset;
  if (min_angle != 0 && max_angle != 0) {
    if (value < min_angle)
      value = min_angle;
    else if (value > max_angle)
      value = max_angle;
  }

  grow_SetObjectRotation(object, value, x0, y0, rotation_point);
  old_value = val;
  return 1;
}

int GeRotate::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  double x1, x2, y1, y2;
  double rotation_x, rotation_y;

  if (!feq(x0, 0.0) || !feq(y0, 0.0)) {
    rotation_x = x0;
    rotation_y = y0;

    grow_ToPixel(dyn->graph->grow->ctx, rotation_x, rotation_y, &rotation_x,
        &rotation_y);
    grow_MeasureJavaBean(dyn->graph->grow->ctx, &x2, &x1, &y2, &y1);

    rotation_x -= x1 - glow_cJBean_Offset;
    rotation_y -= y1 - glow_cJBean_Offset;
  } else {
    // Zero point for nodeclass is rotation point
    grow_GetNodeClassOrigo(object, &rotation_x, &rotation_y);
    grow_MeasureNode(object, &x1, &y1, &x2, &y2);
    rotation_x += x1;
    rotation_y += y1;

    grow_ToPixel(dyn->graph->grow->ctx, rotation_x, rotation_y, &rotation_x,
        &rotation_y);

    grow_MeasureJavaBean(dyn->graph->grow->ctx, &x2, &x1, &y2, &y1);

    rotation_x -= x1 - glow_cJBean_Offset;
    rotation_y -= y1 - glow_cJBean_Offset;
  }

  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynRotate(" << var_name << ".dd, \"" << attribute << "\","
     << rotation_x << "," << rotation_y << "," << factor << ")\n";
  return 1;
}

int GeRotate::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Float32, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase__ };
  dyn->syntax_check_attribute(object, "Rotate.Attribute", attribute, 0, types,
      databases, error_cnt, warning_cnt);

  return 1;
}

GeMove::GeMove(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_Move, ge_mDynType2_No, ge_mActionType1_No,
          ge_mActionType2_No, ge_eDynPrio_Move),
      x_offset(0), y_offset(0), x_factor(1), y_factor(0), scale_x_factor(1),
      scale_y_factor(0), scale_type(glow_eScaleType_LowerLeft)
{
  strcpy(move_x_attribute, "");
  strcpy(move_y_attribute, "");
  strcpy(scale_x_attribute, "");
  strcpy(scale_y_attribute, "");
}

GeMove::GeMove(const GeMove& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      x_offset(x.x_offset), y_offset(x.y_offset), x_factor(x.x_factor),
      y_factor(x.y_factor), scale_x_factor(x.scale_x_factor),
      scale_y_factor(x.scale_y_factor), scale_type(x.scale_type)
{
  strcpy(move_x_attribute, x.move_x_attribute);
  strcpy(move_y_attribute, x.move_y_attribute);
  strcpy(scale_x_attribute, x.scale_x_attribute);
  strcpy(scale_y_attribute, x.scale_y_attribute);
}

void GeMove::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "Move.XAttribute");
  attrinfo[i].value = move_x_attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(move_x_attribute);

  strcpy(attrinfo[i].name, "Move.YAttribute");
  attrinfo[i].value = move_y_attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(move_y_attribute);

  strcpy(attrinfo[i].name, "Move.XOffset");
  attrinfo[i].value = &x_offset;
  attrinfo[i].type = glow_eType_Double;
  attrinfo[i++].size = sizeof(x_offset);

  strcpy(attrinfo[i].name, "Move.YOffset");
  attrinfo[i].value = &y_offset;
  attrinfo[i].type = glow_eType_Double;
  attrinfo[i++].size = sizeof(y_offset);

  strcpy(attrinfo[i].name, "Move.XFactor");
  attrinfo[i].value = &x_factor;
  attrinfo[i].type = glow_eType_Double;
  attrinfo[i++].size = sizeof(x_factor);

  strcpy(attrinfo[i].name, "Move.YFactor");
  attrinfo[i].value = &y_factor;
  attrinfo[i].type = glow_eType_Double;
  attrinfo[i++].size = sizeof(y_factor);

  strcpy(attrinfo[i].name, "Move.ScaleXAttribute");
  attrinfo[i].value = scale_x_attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(scale_x_attribute);

  strcpy(attrinfo[i].name, "Move.ScaleYAttribute");
  attrinfo[i].value = scale_y_attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(scale_y_attribute);

  strcpy(attrinfo[i].name, "Move.ScaleXFactor");
  attrinfo[i].value = &scale_x_factor;
  attrinfo[i].type = glow_eType_Double;
  attrinfo[i++].size = sizeof(scale_x_factor);

  strcpy(attrinfo[i].name, "Move.ScaleYFactor");
  attrinfo[i].value = &scale_y_factor;
  attrinfo[i].type = glow_eType_Double;
  attrinfo[i++].size = sizeof(scale_x_factor);

  strcpy(attrinfo[i].name, "Move.ScaleType");
  attrinfo[i].value = &scale_type;
  attrinfo[i].type = ge_eAttrType_ScaleType;
  attrinfo[i++].size = sizeof(scale_type);

  *item_count = i;
}

void GeMove::set_attribute(grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(move_x_attribute, attr_name, sizeof(move_x_attribute));
    snprintf(msg, sizeof(msg), "Move.XAttribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  } else if (*cnt == 1) {
    char msg[200];

    strncpy(move_y_attribute, attr_name, sizeof(move_y_attribute));
    snprintf(msg, sizeof(msg), "Move.YAttribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
    (*cnt)--;
  }
}

void GeMove::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(
      move_x_attribute, sizeof(move_x_attribute), from, to, cnt, strict);
  GeDyn::replace_attribute(
      move_y_attribute, sizeof(move_y_attribute), from, to, cnt, strict);
  GeDyn::replace_attribute(
      scale_x_attribute, sizeof(scale_x_attribute), from, to, cnt, strict);
  GeDyn::replace_attribute(
      scale_y_attribute, sizeof(scale_y_attribute), from, to, cnt, strict);
}

void GeMove::save(std::ofstream& fp)
{
  fp << int(ge_eSave_Move) << '\n';
  fp << int(ge_eSave_Move_move_x_attribute) << FSPACE << move_x_attribute
     << '\n';
  fp << int(ge_eSave_Move_move_y_attribute) << FSPACE << move_y_attribute
     << '\n';
  fp << int(ge_eSave_Move_scale_x_attribute) << FSPACE << scale_x_attribute
     << '\n';
  fp << int(ge_eSave_Move_scale_y_attribute) << FSPACE << scale_y_attribute
     << '\n';
  fp << int(ge_eSave_Move_x_offset) << FSPACE << x_offset << '\n';
  fp << int(ge_eSave_Move_y_offset) << FSPACE << y_offset << '\n';
  fp << int(ge_eSave_Move_x_factor) << FSPACE << x_factor << '\n';
  fp << int(ge_eSave_Move_y_factor) << FSPACE << y_factor << '\n';
  fp << int(ge_eSave_Move_scale_x_factor) << FSPACE << scale_x_factor << '\n';
  fp << int(ge_eSave_Move_scale_y_factor) << FSPACE << scale_y_factor << '\n';
  fp << int(ge_eSave_Move_scale_type) << FSPACE << scale_type << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeMove::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeMove: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_Move:
      break;
    case ge_eSave_Move_move_x_attribute:
      fp.get();
      fp.getline(move_x_attribute, sizeof(move_x_attribute));
      break;
    case ge_eSave_Move_move_y_attribute:
      fp.get();
      fp.getline(move_y_attribute, sizeof(move_y_attribute));
      break;
    case ge_eSave_Move_scale_x_attribute:
      fp.get();
      fp.getline(scale_x_attribute, sizeof(scale_x_attribute));
      break;
    case ge_eSave_Move_scale_y_attribute:
      fp.get();
      fp.getline(scale_y_attribute, sizeof(scale_y_attribute));
      break;
    case ge_eSave_Move_x_offset:
      fp >> x_offset;
      break;
    case ge_eSave_Move_y_offset:
      fp >> y_offset;
      break;
    case ge_eSave_Move_x_factor:
      fp >> x_factor;
      break;
    case ge_eSave_Move_y_factor:
      fp >> y_factor;
      break;
    case ge_eSave_Move_scale_x_factor:
      fp >> scale_x_factor;
      break;
    case ge_eSave_Move_scale_y_factor:
      fp >> scale_y_factor;
      break;
    case ge_eSave_Move_scale_type:
      fp >> tmp;
      scale_type = (glow_eScaleType)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeMove:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
  if (feq(y_factor, 0.0))
    y_factor = x_factor;
  if (feq(scale_y_factor, 0.0))
    scale_y_factor = scale_x_factor;
}

int GeMove::connect(grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  pwr_tAName parsed_name;
  int inverted;
  int sts;
  double ur_x, ur_y;

  move_x_p = 0;
  move_y_p = 0;
  scale_x_p = 0;
  scale_y_p = 0;

  move_x_size = 4;
  move_x_type = pwr_eType_Float32;
  move_x_db = dyn->parse_attr_name(
      move_x_attribute, parsed_name, &inverted, &move_x_type, &move_x_size);
  if (!streq(parsed_name, "")) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&move_x_p, &move_x_subid, move_x_size, object, now);
    if (EVEN(sts))
      return sts;
  }
  move_y_size = 4;
  move_y_type = pwr_eType_Float32;
  move_y_db = dyn->parse_attr_name(
      move_y_attribute, parsed_name, &inverted, &move_y_type, &move_y_size);
  if (!streq(parsed_name, "")) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&move_y_p, &move_y_subid, move_y_size, object, now);
    if (EVEN(sts))
      return sts;
  }
  scale_x_size = 4;
  scale_x_type = pwr_eType_Float32;
  scale_x_db = dyn->parse_attr_name(
      scale_x_attribute, parsed_name, &inverted, &scale_x_type, &scale_x_size);
  if (!streq(parsed_name, "")) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&scale_x_p, &scale_x_subid, scale_x_size, object, now);
    if (EVEN(sts))
      return sts;
  }
  scale_y_size = 4;
  scale_y_type = pwr_eType_Float32;
  scale_y_db = dyn->parse_attr_name(
      scale_y_attribute, parsed_name, &inverted, &scale_y_type, &scale_y_size);
  if (!streq(parsed_name, "")) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&scale_y_p, &scale_y_subid, scale_y_size, object, now);
    if (EVEN(sts))
      return sts;
  }
  trace_data->p = &pdummy;

  first_scan = true;
  if (!grow_TransformIsStored(object)) {
    grow_StoreTransform(object);
    grow_MeasureNode(object, &x_orig, &y_orig, &ur_x, &ur_y);
    width_orig = ur_x - x_orig;
    height_orig = ur_y - y_orig;
  } else {
    grow_RevertTransform(object);
    grow_GetObjectBorder(object);
    grow_MeasureNode(object, &x_orig, &y_orig, &ur_x, &ur_y);
    width_orig = ur_x - x_orig;
    height_orig = ur_y - y_orig;
  }
  return 1;
}

int GeMove::disconnect(grow_tObject object)
{
  if (move_x_p && move_x_db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(move_x_subid);
  if (move_y_p && move_y_db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(move_y_subid);
  if (scale_x_p && scale_x_db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(scale_x_subid);
  if (scale_y_p && scale_y_db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(scale_y_subid);
  move_x_p = move_y_p = scale_x_p = scale_y_p = 0;

  return 1;
}

int GeMove::scan(grow_tObject object)
{
  bool update = false;

  if (!first_scan) {
    if (move_x_p && memcmp(&move_x_old_value, move_x_p, move_x_size) != 0)
      update = true;
    else if (move_y_p && memcmp(&move_y_old_value, move_y_p, move_y_size) != 0)
      update = true;
    else if (scale_x_p
        && memcmp(&scale_x_old_value, scale_x_p, scale_x_size) != 0)
      update = true;
    else if (scale_y_p
        && memcmp(&scale_y_old_value, scale_y_p, scale_y_size) != 0)
      update = true;
    if (!update)
      return 1;
  } else
    first_scan = false;

  double move_x, move_y, scale_x, scale_y;

  if (scale_x_p || scale_y_p) {
    if (scale_x_p) {
      switch (scale_x_type) {
      case pwr_eType_Float32:
        scale_x = *scale_x_p * scale_x_factor;
        break;
      case pwr_eType_Float64:
        scale_x = *(pwr_tFloat64*)scale_x_p * scale_x_factor;
        break;
      case pwr_eType_Int32:
        scale_x = *(pwr_tInt32*)scale_x_p * scale_x_factor;
        break;
      case pwr_eType_UInt32:
        scale_x = *(pwr_tUInt32*)scale_x_p * scale_x_factor;
        break;
      default:
        scale_x = 1;
      }
    } else
      scale_x = 1;

    if (scale_y_p) {
      switch (scale_y_type) {
      case pwr_eType_Float32:
        scale_y = *scale_y_p * scale_y_factor;
        break;
      case pwr_eType_Float64:
        scale_y = *(pwr_tFloat64*)scale_y_p * scale_y_factor;
        break;
      case pwr_eType_Int32:
        scale_y = *(pwr_tInt32*)scale_y_p * scale_y_factor;
        break;
      case pwr_eType_UInt32:
        scale_y = *(pwr_tUInt32*)scale_y_p * scale_y_factor;
        break;
      default:
        scale_y = 1;
      }
    } else
      scale_y = 1;

    if (!(move_x_p || move_y_p))
      grow_SetObjectScale(object, scale_x, scale_y, 0, 0, scale_type);
    if (scale_x_p)
      memcpy(&scale_x_old_value, scale_x_p, scale_x_size);
    if (scale_y_p)
      memcpy(&scale_y_old_value, scale_y_p, scale_y_size);

    if (move_x_p || move_y_p) {
      if (move_x_p) {
        double scale_offs = 0;
        // Adjust position for different scaletypes
        switch (scale_type) {
        case glow_eScaleType_LowerRight:
        case glow_eScaleType_UpperRight:
          scale_offs = width_orig * (1 - scale_x);
          break;
        case glow_eScaleType_Center:
          scale_offs = width_orig * (1 - scale_x) / 2;
          break;
        default:;
        }
        switch (move_x_type) {
        case pwr_eType_Float32:
          move_x = x_orig + scale_offs + (*move_x_p - x_offset) * x_factor;
          break;
        case pwr_eType_Float64:
          move_x = x_orig + scale_offs
              + (*(pwr_tFloat64*)move_x_p - x_offset) * x_factor;
          break;
        case pwr_eType_Int32:
          move_x = x_orig + scale_offs
              + (*(pwr_tInt32*)move_x_p - x_offset) * x_factor;
          break;
        case pwr_eType_UInt32:
          move_x = x_orig + scale_offs
              + (*(pwr_tUInt32*)move_x_p - x_offset) * x_factor;
          break;
        default:
          move_x = x_orig + scale_offs;
        }
      } else
        move_x = x_orig;

      if (move_y_p) {
        double scale_offs = 0;
        // Adjust position for different scaletypes
        switch (scale_type) {
        case glow_eScaleType_UpperRight:
        case glow_eScaleType_UpperLeft:
          scale_offs = height_orig * (1 - scale_y);
          break;
        case glow_eScaleType_Center:
          scale_offs = height_orig * (1 - scale_y) / 2;
          break;
        default:;
        }

        switch (move_y_type) {
        case pwr_eType_Float32:
          move_y = y_orig + scale_offs + (*move_y_p - y_offset) * y_factor;
          break;
        case pwr_eType_Float64:
          move_y = y_orig + scale_offs
              + (*(pwr_tFloat64*)move_y_p - y_offset) * y_factor;
          break;
        case pwr_eType_Int32:
          move_y = y_orig + scale_offs
              + (*(pwr_tInt32*)move_y_p - y_offset) * y_factor;
          break;
        case pwr_eType_UInt32:
          move_y = y_orig + scale_offs
              + (*(pwr_tUInt32*)move_y_p - y_offset) * y_factor;
          break;
        default:
          move_y = y_orig + scale_offs;
        }
      } else
        move_y = y_orig;

      if (fabs(scale_x) < DBL_EPSILON)
        scale_x = 10e-5;
      if (fabs(scale_y) < DBL_EPSILON)
        scale_y = 10e-5;

      grow_SetObjectScalePos(
          object, move_x, move_y, scale_x, scale_y, 0, 0, scale_type);
      if (move_x_p)
        memcpy(&move_x_old_value, move_x_p, move_x_size);
      if (move_y_p)
        memcpy(&move_y_old_value, move_y_p, move_y_size);
    }
  } else {
    if (move_x_p) {
      switch (move_x_type) {
      case pwr_eType_Float32:
        move_x = (*move_x_p - x_offset) * x_factor;
        break;
      case pwr_eType_Float64:
        move_x = (*(pwr_tFloat64*)move_x_p - x_offset) * x_factor;
        break;
      case pwr_eType_Int32:
        move_x = (*(pwr_tInt32*)move_x_p - x_offset) * x_factor;
        break;
      case pwr_eType_UInt32:
        move_x = (*(pwr_tUInt32*)move_x_p - x_offset) * x_factor;
        break;
      default:
        move_x = 0;
      }
    } else
      move_x = 0;

    if (move_y_p) {
      switch (move_y_type) {
      case pwr_eType_Float32:
        move_y = (*move_y_p - y_offset) * y_factor;
        break;
      case pwr_eType_Float64:
        move_y = (*(pwr_tFloat64*)move_y_p - y_offset) * y_factor;
        break;
      case pwr_eType_Int32:
        move_y = (*(pwr_tInt32*)move_y_p - y_offset) * y_factor;
        break;
      case pwr_eType_UInt32:
        move_y = (*(pwr_tUInt32*)move_y_p - y_offset) * y_factor;
        break;
      default:
        move_y = 0;
      }
    } else
      move_y = 0;

    grow_SetObjectPosition(object, move_x, move_y);

    if (move_x_p)
      memcpy(&move_x_old_value, move_x_p, move_x_size);
    if (move_y_p)
      memcpy(&move_y_old_value, move_y_p, move_y_size);
  }
  return 1;
}

int GeMove::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  double zoom_factor;

  grow_GetZoom(dyn->graph->grow->ctx, &zoom_factor);

  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynMove(" << var_name << ".dd, \"" << move_x_attribute << "\",\""
     << move_y_attribute << "\",\"" << scale_x_attribute << "\",\""
     << scale_y_attribute << "\"," << x_offset << "," << y_offset << ","
     << x_factor * zoom_factor << "," << y_factor * zoom_factor << ","
     << scale_x_factor << "," << scale_y_factor << ")\n";
  return 1;
}

int GeMove::syntax_check(grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Int32, pwr_eType_UInt32, pwr_eType_Float32,
    pwr_eType_Float64, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase__ };
  dyn->syntax_check_attribute(object, "Move.XAttribute", move_x_attribute, 1,
      types, databases, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "Move.YAttribute", move_y_attribute, 1,
      types, databases, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "Move.ScaleXAttribute", scale_x_attribute,
      1, types, databases, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "Move.ScaleYAttribute", scale_y_attribute,
      1, types, databases, error_cnt, warning_cnt);

  if (streq(move_x_attribute, "") && streq(move_y_attribute, "")
      && streq(scale_x_attribute, "")
      && streq(scale_y_attribute, "")) {
    dyn->graph->syntax_msg('E', object, "Move, no attribute");
    (*error_cnt)++;
  }

  return 1;
}

GeAnalogShift::GeAnalogShift(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_AnalogShift, ge_mDynType2_No,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_AnalogShift),
      old_value(FLT_INI)
{
  strcpy(attribute, "");
}

GeAnalogShift::GeAnalogShift(const GeAnalogShift& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      old_value(FLT_INI)
{
  strcpy(attribute, x.attribute);
}

void GeAnalogShift::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "AnalogShift.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  *item_count = i;
}

void GeAnalogShift::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "AnalogShift.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeAnalogShift::replace_attribute(
    char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeAnalogShift::save(std::ofstream& fp)
{
  fp << int(ge_eSave_AnalogShift) << '\n';
  fp << int(ge_eSave_AnalogShift_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeAnalogShift::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeAnalogShift: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_AnalogShift:
      break;
    case ge_eSave_AnalogShift_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeAnalogShift:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeAnalogShift::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  pwr_tAName parsed_name;
  int inverted;
  int sts;

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(attribute, parsed_name, &inverted, &type, &size);
  if (streq(parsed_name, ""))
    return 1;

  switch (type) {
  case pwr_eType_Float32:
  case pwr_eType_Int32:
  case pwr_eType_UInt32:
  case pwr_eType_Enum:
    break;
  default:
    return 1;
  }

  sts = dyn->graph->ref_object_info(
      dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
  if (EVEN(sts))
    return sts;

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeAnalogShift::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeAnalogShift::scan(grow_tObject object)
{
  if (!p)
    return 1;

  if (!first_scan) {
    switch (type) {
    case pwr_eType_Float32:
      if (fabs(old_value - *p) < FLT_EPSILON)
        return 1;
      break;
    default:
      if (memcmp(&old_value, p, size) == 0)
        return 1;
    }
  } else
    first_scan = false;

  int index;

  switch (type) {
  case pwr_eType_Float32: {
    pwr_tFloat32 val = *p;

    if (!first_scan) {
      if (fabs(old_value - val) < FLT_EPSILON)
        return 1;
    } else
      first_scan = false;

    index = int(val + 0.5);
    old_value = val;
    break;
  }
  default: {
    pwr_tInt32 val = *(pwr_tInt32*)p;
    if (!first_scan) {
      if (memcmp(&old_value, &val, size) == 0)
        return 1;
    } else
      first_scan = false;

    index = val;
    memcpy(&old_value, &val, size);
  }
  }

  grow_SetObjectNodeClassByIndex(object, index);
  return 1;
}

int GeAnalogShift::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynAnalogShift(" << var_name << ".dd, \"" << attribute << "\")"
     << '\n';
  return 1;
}

int GeAnalogShift::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Int32, pwr_eType_UInt32, pwr_eType_Float32,
    pwr_eType_Enum, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase__ };
  dyn->syntax_check_attribute(object, "AnalogShift.Attribute", attribute, 0,
      types, databases, error_cnt, warning_cnt);

  return 1;
}

GeDigShift::GeDigShift(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_DigShift, ge_mDynType2_No,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_DigShift)
{
  strcpy(attribute, "");
}

GeDigShift::GeDigShift(const GeDigShift& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio)
{
  strcpy(attribute, x.attribute);
}

void GeDigShift::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "DigShift.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  *item_count = i;
}

void GeDigShift::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "DigShift.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeDigShift::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeDigShift::save(std::ofstream& fp)
{
  fp << int(ge_eSave_DigShift) << '\n';
  fp << int(ge_eSave_DigShift_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeDigShift::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeDigShift: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_DigShift:
      break;
    case ge_eSave_DigShift_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeDigShift:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeDigShift::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  get_bit(parsed_name, attr_type, &bitmask);
  a_typeid = attr_type;

  switch (db) {
  case graph_eDatabase_Gdh:
    sts = dyn->graph->ref_object_info(
        dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
    if (EVEN(sts))
      return sts;
    break;
  case graph_eDatabase_Ccm:
    sts = dyn->graph->ccm_ref_variable(parsed_name, attr_type, (void**)&p);
    if (EVEN(sts))
      return sts;
    break;
  default:;
  }

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeDigShift::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeDigShift::scan(grow_tObject object)
{
  if (!p)
    return 1;

  pwr_tBoolean val;

  if (!get_dig(&val, p, a_typeid, bitmask))
    return 1;

  if (inverted)
    val = !val;

  if (!first_scan) {
    if (old_value == val) {
      // No change since last time
      return 1;
    }
  } else
    first_scan = false;

  if (val) {
    grow_SetObjectLastNodeClass(object);
  } else {
    grow_SetObjectFirstNodeClass(object);
  }
  old_value = val;

  return 1;
}

int GeDigShift::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynDigShift(" << var_name << ".dd, \"" << attribute << "\")"
     << '\n';
  return 1;
}

int GeDigShift::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    pwr_eType_Int64, pwr_eType_UInt64, graph_eType_Bit, pwr_eType_Float32,
    pwr_eType_Float64, pwr_eType_String, 0 };
  graph_eDatabase databases[]
      = { graph_eDatabase_Ccm, graph_eDatabase_Gdh, graph_eDatabase__ };
  dyn->syntax_check_attribute(object, "DigShift.Attribute", attribute, 0, types,
      databases, error_cnt, warning_cnt);

  return 1;
}

GeDigFourShift::GeDigFourShift(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_DigFourShift,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_DigFourShift)
{
  strcpy(attribute1, "");
  strcpy(attribute2, "");
  strcpy(attribute3, "");
}

GeDigFourShift::GeDigFourShift(const GeDigFourShift& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio)
{
  strcpy(attribute1, x.attribute1);
  strcpy(attribute2, x.attribute2);
  strcpy(attribute3, x.attribute3);
}

void GeDigFourShift::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "DigFourShift.Attribute1");
  attrinfo[i].value = attribute1;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute1);

  strcpy(attrinfo[i].name, "DigFourShift.Attribute2");
  attrinfo[i].value = attribute2;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute2);

  strcpy(attrinfo[i].name, "DigFourShift.Attribute3");
  attrinfo[i].value = attribute3;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute3);

  *item_count = i;
}

void GeDigFourShift::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute1, attr_name, sizeof(attribute1));
    snprintf(msg, sizeof(msg), "DigFourShift.Attribute1 = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeDigFourShift::replace_attribute(
    char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(
      attribute1, sizeof(attribute1), from, to, cnt, strict);
  GeDyn::replace_attribute(
      attribute2, sizeof(attribute2), from, to, cnt, strict);
  GeDyn::replace_attribute(
      attribute3, sizeof(attribute3), from, to, cnt, strict);
}

void GeDigFourShift::save(std::ofstream& fp)
{
  fp << int(ge_eSave_DigFourShift) << '\n';
  fp << int(ge_eSave_DigFourShift_attribute1) << FSPACE << attribute1 << '\n';
  fp << int(ge_eSave_DigFourShift_attribute2) << FSPACE << attribute2 << '\n';
  fp << int(ge_eSave_DigFourShift_attribute3) << FSPACE << attribute3 << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeDigFourShift::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeDigFourShift: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_DigFourShift:
      break;
    case ge_eSave_DigFourShift_attribute1:
      fp.get();
      fp.getline(attribute1, sizeof(attribute1));
      break;
    case ge_eSave_DigFourShift_attribute2:
      fp.get();
      fp.getline(attribute2, sizeof(attribute2));
      break;
    case ge_eSave_DigFourShift_attribute3:
      fp.get();
      fp.getline(attribute3, sizeof(attribute3));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeDigFourShift:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeDigFourShift::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;

  size1 = 4;
  p1 = 0;
  db1 = dyn->parse_attr_name(
      attribute1, parsed_name, &inverted1, &attr_type, &attr_size);
  if (!streq(parsed_name, "")) {
    get_bit(parsed_name, attr_type, &bitmask1);
    a_typeid1 = attr_type;

    switch (db1) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(
          dyn->cycle, parsed_name, (void**)&p1, &subid1, size1, object, now);
      if (EVEN(sts))
        return sts;
      break;
    case graph_eDatabase_Ccm:
      sts = dyn->graph->ccm_ref_variable(parsed_name, attr_type, (void**)&p1);
      if (EVEN(sts))
        return sts;
      break;
    default:;
    }
  }

  size2 = 4;
  p2 = 0;
  db2 = dyn->parse_attr_name(
      attribute2, parsed_name, &inverted2, &attr_type, &attr_size);
  if (!streq(parsed_name, "")) {
    get_bit(parsed_name, attr_type, &bitmask2);
    a_typeid2 = attr_type;

    switch (db2) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(
          dyn->cycle, parsed_name, (void**)&p2, &subid2, size2, object, now);
      if (EVEN(sts))
        return sts;
      break;
    case graph_eDatabase_Ccm:
      sts = dyn->graph->ccm_ref_variable(parsed_name, attr_type, (void**)&p2);
      if (EVEN(sts))
        return sts;
      break;
    default:;
    }
  }

  size3 = 4;
  p3 = 0;
  db3 = dyn->parse_attr_name(
      attribute3, parsed_name, &inverted3, &attr_type, &attr_size);
  if (!streq(parsed_name, "")) {
    get_bit(parsed_name, attr_type, &bitmask3);
    a_typeid3 = attr_type;

    switch (db3) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(
          dyn->cycle, parsed_name, (void**)&p3, &subid3, size3, object, now);
      if (EVEN(sts))
        return sts;
      break;
    case graph_eDatabase_Ccm:
      sts = dyn->graph->ccm_ref_variable(parsed_name, attr_type, (void**)&p3);
      if (EVEN(sts))
        return sts;
      break;
    default:;
    }
  }

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeDigFourShift::disconnect(grow_tObject object)
{
  if (p1 && db1 == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid1);
  if (p2 && db2 == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid2);
  if (p3 && db3 == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid3);
  p1 = 0;
  p2 = 0;
  p3 = 0;
  return 1;
}

int GeDigFourShift::scan(grow_tObject object)
{
  pwr_tBoolean val1, val2, val3;

  if (!(p1 || p2 || p3))
    return 1;

  if (p1) {
    if (!get_dig(&val1, p1, a_typeid1, bitmask1))
      return 1;

    if (inverted1)
      val1 = !val1;
  } else
    val1 = 0;

  if (p2) {
    if (!get_dig(&val2, p2, a_typeid2, bitmask2))
      return 1;

    if (inverted2)
      val2 = !val2;
  } else
    val2 = 0;

  if (p3) {
    if (!get_dig(&val3, p3, a_typeid3, bitmask3))
      return 1;

    if (inverted3)
      val3 = !val3;
  } else
    val3 = 0;

  if (!first_scan) {
    if (old_value1 == val1 && old_value2 == val2 && old_value3 == val3) {
      // No change since last time
      return 1;
    }
  } else
    first_scan = false;

  if (val3)
    grow_SetObjectNodeClassByIndex(object, 2);
  else if (val2)
    grow_SetObjectNodeClassByIndex(object, 1);
  else if (val1)
    grow_SetObjectFirstNodeClass(object);
  else
    grow_SetObjectLastNodeClass(object);

  old_value1 = val1;
  old_value2 = val2;
  old_value3 = val3;

  return 1;
}

int GeDigFourShift::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  return 1;
}

int GeDigFourShift::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    pwr_eType_Int64, pwr_eType_UInt64, graph_eType_Bit, pwr_eType_Float32,
    pwr_eType_Float64, pwr_eType_String, 0 };
  graph_eDatabase databases[]
      = { graph_eDatabase_Ccm, graph_eDatabase_Gdh, graph_eDatabase__ };
  dyn->syntax_check_attribute(object, "DigFourShift.Attribute1", attribute1, 1,
      types, databases, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "DigFourShift.Attribute2", attribute2, 1,
      types, databases, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "DigFourShift.Attribute3", attribute3, 1,
      types, databases, error_cnt, warning_cnt);

  if (streq(attribute1, "") && streq(attribute2, "")
      && streq(attribute3, "")) {
    dyn->graph->syntax_msg('E', object, "DigFourShift, no attribute");
    (*error_cnt)++;
  }

  return 1;
}

GeScrollingText::GeScrollingText(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_ScrollingText,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_ScrollingText),
      direction(glow_eDirection_Right), speed(2), bounce(0), offset(0), tsize(0)
{
  strcpy(attribute, "");
}

GeScrollingText::GeScrollingText(const GeScrollingText& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      direction(x.direction), speed(x.speed), bounce(x.bounce), offset(0),
      tsize(0)
{
  strcpy(attribute, x.attribute);
}

void GeScrollingText::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "ScrollingText.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  strcpy(attrinfo[i].name, "ScrollingText.Direction");
  attrinfo[i].value = &direction;
  attrinfo[i].type = glow_eType_Direction;
  attrinfo[i++].size = sizeof(direction);

  strcpy(attrinfo[i].name, "ScrollingText.Speed");
  attrinfo[i].value = &speed;
  attrinfo[i].type = glow_eType_Double;
  attrinfo[i++].size = sizeof(speed);

  strcpy(attrinfo[i].name, "ScrollingText.Bounce");
  attrinfo[i].value = &bounce;
  attrinfo[i].type = glow_eType_Boolean;
  attrinfo[i++].size = sizeof(bounce);

  *item_count = i;
}

void GeScrollingText::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "ScrollingText.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeScrollingText::replace_attribute(
    char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeScrollingText::save(std::ofstream& fp)
{
  fp << int(ge_eSave_ScrollingText) << '\n';
  fp << int(ge_eSave_ScrollingText_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_ScrollingText_direction) << FSPACE << int(direction)
     << '\n';
  fp << int(ge_eSave_ScrollingText_speed) << FSPACE << speed << '\n';
  fp << int(ge_eSave_ScrollingText_bounce) << FSPACE << bounce << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeScrollingText::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeScrollingText: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_ScrollingText:
      break;
    case ge_eSave_ScrollingText_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_ScrollingText_direction:
      fp >> tmp;
      direction = (glow_eDirection)tmp;
      break;
    case ge_eSave_ScrollingText_speed:
      fp >> speed;
      break;
    case ge_eSave_ScrollingText_bounce:
      fp >> bounce;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeScrollingText:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeScrollingText::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size, inverted;
  pwr_tAName parsed_name;
  int sts;
  double ll_x, ll_y, ur_x, ur_y;

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "")) {
    switch (db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(
          dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
      if (EVEN(sts))
        return sts;
      break;
    case graph_eDatabase_Ccm:
      sts = dyn->graph->ccm_ref_variable(parsed_name, attr_type, (void**)&p);
      if (EVEN(sts))
        return sts;
      break;
    default:;
    }
  }

  grow_MeasureNode(object, &ll_x, &ll_y, &ur_x, &ur_y);
  switch (direction) {
  case glow_eDirection_Left:
  case glow_eDirection_Right:
    osize = ur_x - ll_x;
    break;
  default:
    osize = ur_y - ll_y;
  }

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeScrollingText::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  return 1;
}

int GeScrollingText::scan(grow_tObject object)
{
  double width, height;
  grow_GetAnnotationTextExtent(object, 1, &width, &height);

  switch (direction) {
  case glow_eDirection_Left: {
    offset -= speed * dyn->graph->animation_scan_time;
    if (bounce) {
      if (width < osize) {
        if (offset < 0) {
          offset = -offset;
          direction = glow_eDirection_Right;
        }
      } else {
        if (offset < osize - width) {
          offset += (osize - width) - offset;
          direction = glow_eDirection_Right;
        }
      }
    } else {
      if (offset < -width)
        offset = osize;
    }
    grow_SetAnnotationTextOffset(object, 1, offset, 0);
    break;
  }
  case glow_eDirection_Right: {
    offset += speed * dyn->graph->animation_scan_time;
    if (bounce) {
      if (width < osize) {
        if (offset > osize - width) {
          offset -= offset - (osize - width);
          direction = glow_eDirection_Left;
        }
      } else {
        if (offset > 0) {
          offset = -offset;
          direction = glow_eDirection_Left;
        }
      }
    } else {
      if (offset > osize)
        offset = -width;
    }
    grow_SetAnnotationTextOffset(object, 1, offset, 0);
    break;
  }
  case glow_eDirection_Up: {
    offset += speed * dyn->graph->animation_scan_time;
    if (bounce) {
      if (offset > osize - height) {
        offset -= offset - (osize - height);
        direction = glow_eDirection_Down;
      }
    } else {
      if (offset > osize)
        offset = -height;
    }
    grow_SetAnnotationTextOffset(object, 1, 0, offset);
    break;
  }
  case glow_eDirection_Down: {
    offset -= speed * dyn->graph->animation_scan_time;
    if (bounce) {
      if (offset < 0) {
        offset = -offset;
        direction = glow_eDirection_Up;
      }
    } else {
      if (offset < -height)
        offset = osize;
    }
    grow_SetAnnotationTextOffset(object, 1, 0, offset);
    break;
  }
  default:;
  }

  if (!first_scan) {
    if (strncmp(old_value, (char*)p, size) == 0)
      // No change since last time
      return 1;
  } else
    first_scan = false;

  memcpy(&old_value, p, MIN(size, (int)sizeof(old_value)));

  grow_SetAnnotation(object, 1, (char*)p, strlen((char*)p));

  return 1;
}

int GeScrollingText::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  return 1;
}

int GeScrollingText::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_String, pwr_eType_Text, 0 };
  graph_eDatabase databases[]
      = { graph_eDatabase_Ccm, graph_eDatabase_Gdh, graph_eDatabase__ };
  dyn->syntax_check_attribute(object, "ScrollingText.Attribute", attribute, 0,
      types, databases, error_cnt, warning_cnt);

  return 1;
}

void GeColorThemeLightness::get_attributes(
    attr_sItem* attrinfo, int* item_count)
{
}

void GeColorThemeLightness::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
}

void GeColorThemeLightness::replace_attribute(
    char* from, char* to, int* cnt, int strict)
{
}

void GeColorThemeLightness::save(std::ofstream& fp)
{
  fp << int(ge_eSave_ColorThemeLightness) << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeColorThemeLightness::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeColorThemeLightness: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_ColorThemeLightness:
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeColorThemeLightness:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeColorThemeLightness::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  trace_data->p = &pdummy;
  return 1;
}

int GeColorThemeLightness::disconnect(grow_tObject object)
{
  return 1;
}

int GeColorThemeLightness::scan(grow_tObject object)
{
  grow_SetObjectColorThemeLightness(object);
  return 1;
}

int GeColorThemeLightness::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  return 1;
}

GeDigBackgroundColor::GeDigBackgroundColor(
    GeDyn* e_dyn, ge_mInstance e_instance)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_DigBackgroundColor,
          ge_mActionType1_No, ge_mActionType2_No,
          ge_eDynPrio_DigBackgroundColor),
      color(glow_eDrawType_Inherit), bitmask(0)
{
  strcpy(attribute, "");
  instance = e_instance;
}

GeDigBackgroundColor::GeDigBackgroundColor(const GeDigBackgroundColor& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      color(x.color)
{
  strcpy(attribute, x.attribute);
  instance = x.instance;
  instance_mask = x.instance_mask;
}

void GeDigBackgroundColor::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  if (instance == ge_mInstance_1) {
    strcpy(attrinfo[i].name, "DigBackgroundColor.Attribute");
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    strcpy(attrinfo[i].name, "DigBackgroundColor.Color");
    attrinfo[i].value = &color;
    attrinfo[i].type = glow_eType_Color;
    attrinfo[i++].size = sizeof(color);

    strcpy(attrinfo[i].name, "DigBackgroundColor.Instances");
    attrinfo[i].value = &instance_mask;
    attrinfo[i].type = ge_eAttrType_InstanceMask;
    attrinfo[i++].size = sizeof(instance_mask);
  } else {
    // Get instance number
    int inst = 1;
    unsigned int m = instance;
    while (m > 1) {
      m = m >> 1;
      inst++;
    }

    sprintf(attrinfo[i].name, "DigBackgroundColor%d.Attribute", inst);
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    sprintf(attrinfo[i].name, "DigBackgroundColor%d.Color", inst);
    attrinfo[i].value = &color;
    attrinfo[i].type = glow_eType_Color;
    attrinfo[i++].size = sizeof(color);
  }
  *item_count = i;
}

void GeDigBackgroundColor::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    if (instance == ge_mInstance_1) {
      snprintf(
          msg, sizeof(msg), "DigBackgroundColor.Attribute = %s", attr_name);
    } else {
      snprintf(msg, sizeof(msg), "DigBackgroundColor%d.Attribute = %s",
          GeDyn::instance_to_number(instance), attr_name);
    }
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeDigBackgroundColor::replace_attribute(
    char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

int GeDigBackgroundColor::set_color(grow_tObject object, glow_eDrawType color)
{
  char msg[200];

  this->color = color;
  if (instance == ge_mInstance_1)
    snprintf(msg, sizeof(msg), "DigBackgroundColor.Color = %s",
        grow_ColorToName(this->color));
  else
    snprintf(msg, sizeof(msg), "DigBackgroundColor%d.Color = %s",
        GeDyn::instance_to_number(instance), grow_ColorToName(this->color));

  msg[sizeof(msg) - 1] = 0;
  dyn->graph->message('I', msg);
  return 1;
}

void GeDigBackgroundColor::save(std::ofstream& fp)
{
  fp << int(ge_eSave_DigBackgroundColor) << '\n';
  fp << int(ge_eSave_DigBackgroundColor_attribute) << FSPACE << attribute
     << '\n';
  fp << int(ge_eSave_DigBackgroundColor_color) << FSPACE << int(color) << '\n';
  fp << int(ge_eSave_DigBackgroundColor_instance) << FSPACE << int(instance)
     << '\n';
  fp << int(ge_eSave_DigBackgroundColor_instance_mask) << FSPACE
     << int(instance_mask) << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeDigBackgroundColor::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  int tmp;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeDigBackgroundColor: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_DigBackgroundColor:
      break;
    case ge_eSave_DigBackgroundColor_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_DigBackgroundColor_color:
      fp >> tmp;
      color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_DigBackgroundColor_instance:
      fp >> tmp;
      instance = (ge_mInstance)tmp;
      break;
    case ge_eSave_DigBackgroundColor_instance_mask:
      fp >> tmp;
      instance_mask = (ge_mInstance)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeDigBackgroundColor:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeDigBackgroundColor::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;

  color = dyn->get_color2(object, color);
  if (color < 0 || color >= glow_eDrawType__) {
    printf("** Color out of range, %s\n", attribute);
    p = 0;
    return 0;
  }

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  get_bit(parsed_name, attr_type, &bitmask);

  sts = dyn->graph->ref_object_info(
      dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
  a_typeid = attr_type;

  if (EVEN(sts))
    return sts;

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeDigBackgroundColor::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeDigBackgroundColor::scan(grow_tObject object)
{
  if (!p || dyn->ignore_bgcolor)
    return 1;

  pwr_tBoolean val = *p;

  if (!get_dig(&val, p, a_typeid, bitmask))
    return 1;

  if (inverted)
    val = !val;

  if (!first_scan) {
    if (old_value == val && !dyn->reset_bgcolor) {
      // No change since last time
      if (val)
        dyn->ignore_bgcolor = true;
      return 1;
    }
  } else
    first_scan = false;

  if (val) {
    grow_SetObjectBackgroundColor(object, color);
    dyn->ignore_bgcolor = true;
  } else {
    grow_ResetObjectBackgroundColor(object);
    dyn->reset_bgcolor = true;
  }
  old_value = val;

  return 1;
}

int GeDigBackgroundColor::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  return 1;
}

int GeDigBackgroundColor::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  char name[40];

  if (instance == 1)
    strcpy(name, "DigBackgroundColor.Attribute");
  else
    sprintf(name, "DigBackgroundColor%d.Attribute",
        GeDyn::instance_to_number(instance));

  glow_eDrawType tcolor = dyn->get_color1(object, color);
  if (tcolor < 0 || tcolor >= glow_eDrawType__) {
    dyn->graph->syntax_msg('E', object, "Color out or range");
    (*error_cnt)++;
  }

  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    pwr_eType_Int64, pwr_eType_UInt64, graph_eType_Bit, pwr_eType_Float32,
    pwr_eType_Float64, pwr_eType_String, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase__ };
  dyn->syntax_check_attribute(
      object, name, attribute, 0, types, databases, error_cnt, warning_cnt);

  return 1;
}

GeDigSwap::GeDigSwap(GeDyn* e_dyn, ge_mInstance e_instance)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_DigSwap,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_DigSwap),
      reset_value(0), bitmask(0), since_reset(0)
{
  strcpy(attribute, "");
}

GeDigSwap::GeDigSwap(const GeDigSwap& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      reset_value(x.reset_value), since_reset(x.since_reset)
{
  strcpy(attribute, x.attribute);
}

void GeDigSwap::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "DigSwap.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  strcpy(attrinfo[i].name, "DigSwap.ResetValue");
  attrinfo[i].value = &reset_value;
  attrinfo[i].type = glow_eType_Boolean;
  attrinfo[i++].size = sizeof(reset_value);

  *item_count = i;
}

void GeDigSwap::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    if (instance == ge_mInstance_1) {
      snprintf(msg, sizeof(msg), "DigSwap.Attribute = %s", attr_name);
    } else {
      snprintf(msg, sizeof(msg), "DigSwap%d.Attribute = %s",
          GeDyn::instance_to_number(instance), attr_name);
    }
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeDigSwap::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeDigSwap::save(std::ofstream& fp)
{
  fp << int(ge_eSave_DigSwap) << '\n';
  fp << int(ge_eSave_DigSwap_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_DigSwap_reset_value) << FSPACE << reset_value << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeDigSwap::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeDigSwap: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_DigSwap:
      break;
    case ge_eSave_DigSwap_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_DigSwap_reset_value:
      fp >> reset_value;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeDigSwap:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeDigSwap::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts = 0;

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  get_bit(parsed_name, attr_type, &bitmask);

  switch (db) {
  case graph_eDatabase_Gdh:
    sts = dyn->graph->ref_object_info(
        dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
    if (EVEN(sts))
      return sts;
    break;
  case graph_eDatabase_Local:
    p = (pwr_tBoolean*)dyn->graph->localdb_ref_or_create(
        parsed_name, attr_type);
    sts = 1;
    break;
  default:;
  }
  a_typeid = attr_type;

  if (EVEN(sts))
    return sts;

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeDigSwap::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeDigSwap::scan(grow_tObject object)
{
  pwr_tBoolean val = *p;

  if (!get_dig(&val, p, a_typeid, bitmask))
    return 1;

  if (first_scan) {
    old_value = val;
    first_scan = 0;
    return 1;
  }

  if (inverted)
    val = !val;

  if (reset_value) {
    if (since_reset < 100)
      since_reset++;
    if (since_reset < 3)
      return 1;
  } else {
    if (old_value == val)
      // No change since last time
      return 1;
  }

  if (val) {
    if (reset_value) {
      int attr_type, attr_size;
      pwr_tAName parsed_name;
      pwr_tStatus sts;

      since_reset = 0;
      dyn->parse_attr_name(
          attribute, parsed_name, &inverted, &attr_type, &attr_size);
      switch (attr_type) {
      case pwr_eType_Boolean: {
        pwr_tBoolean ivalue = 0;
        switch (db) {
        case graph_eDatabase_Local: {
          sts = dyn->graph->localdb_set_value(
              parsed_name, &ivalue, sizeof(ivalue));
          if (EVEN(sts))
            printf("DigSwap error: %s\n", attribute);
          break;
        }
        case graph_eDatabase_Gdh:
          sts = gdh_SetObjectInfo(parsed_name, &ivalue, sizeof(ivalue));
          break;
        default:;
        }
        break;
      }
      default:;
      }
    }

    dyn->graph->swap(0);
    dyn->graph->swap(1);
    grow_Redraw(dyn->graph->grow->ctx);
    old_value = val;
    return GLOW__SWAPTERMINATED;
  }
  old_value = val;

  return 1;
}

int GeDigSwap::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  return 1;
}

int GeDigSwap::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    pwr_eType_Int64, pwr_eType_UInt64, graph_eType_Bit, pwr_eType_Float32,
    pwr_eType_Float64, pwr_eType_String, 0 };
  graph_eDatabase databases[]
      = { graph_eDatabase_Gdh, graph_eDatabase_Local, graph_eDatabase__ };
  dyn->syntax_check_attribute(object, "DigSwap.Attribute", attribute, 0, types,
      databases, error_cnt, warning_cnt);

  return 1;
}

GeAnimation::GeAnimation(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_Animation, ge_mDynType2_No,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_Animation),
      sequence(ge_eAnimSequence_Inherit)
{
  strcpy(attribute, "");
}

GeAnimation::GeAnimation(const GeAnimation& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      sequence(x.sequence)
{
  strcpy(attribute, x.attribute);
}

void GeAnimation::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "Animation.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  strcpy(attrinfo[i].name, "Animation.Sequence");
  attrinfo[i].value = (void*)&sequence;
  attrinfo[i].type = ge_eAttrType_AnimSequence;
  attrinfo[i++].size = sizeof(sequence);

  *item_count = i;
}

void GeAnimation::save(std::ofstream& fp)
{
  fp << int(ge_eSave_Animation) << '\n';
  fp << int(ge_eSave_Animation_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_Animation_sequence) << FSPACE << int(sequence) << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeAnimation::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "Animation.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeAnimation::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeAnimation::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  int tmp;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeAnimation: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_Animation:
      break;
    case ge_eSave_Animation_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_Animation_sequence:
      fp >> tmp;
      sequence = (ge_eAnimSequence)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeAnimation:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeAnimation::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;
  int attr2;

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  get_bit(parsed_name, attr_type, &bitmask);
  a_typeid = attr_type;

  sts = dyn->graph->ref_object_info(
      dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
  if (EVEN(sts))
    return sts;

  trace_data->p = &pdummy;
  first_scan = true;

  if (sequence == ge_eAnimSequence_Inherit)
    grow_GetObjectClassDynAttr(object, (int*)&sequence, &attr2);

  return 1;
}

int GeAnimation::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeAnimation::scan(grow_tObject object)
{
  int max_count;
  int sts;

  if (!p)
    return 1;

  pwr_tBoolean val;

  if (!get_dig(&val, p, a_typeid, bitmask))
    return 1;

  if (inverted)
    val = !val;

  if (first_scan) {
    animation_count = 0;
    animation_direction = 0;
    first_scan = false;
    if (sequence == ge_eAnimSequence_Dig) {
      if (val)
        grow_SetObjectLastNodeClass(object);
      old_value = val;
    }
  }

  if (sequence == ge_eAnimSequence_Dig) {
    if (old_value != val) {
      // Start animation
      if (val) {
        animation_count = 0;
        animation_direction = 1;
      } else if (!val) {
        animation_direction = 2;
        animation_count = 0;
      }
    }

    if (animation_direction != 0) {
      grow_GetObjectAnimationCount(object, &max_count);
      animation_count++;
      if (animation_count >= max_count) {
        // Shift nodeclass
        if (animation_direction == 1) {
          // Shift forward

          sts = grow_SetObjectNextNodeClass(object);
          if (EVEN(sts)) {
            // End of animation
            animation_count = 0;
            animation_direction = 0;
          }
          animation_count = 0;
        } else {
          // Shift backward

          sts = grow_SetObjectPrevNodeClass(object);
          if (EVEN(sts)) {
            // End of animation
            animation_count = 0;
            animation_direction = 0;
          }
          animation_count = 0;
        }
      }
    }
  } else {
    if (val) {
      if (animation_direction == 0) {
        // Animation has been stopped
        animation_count = 0;
        animation_direction = 1;
      }

      grow_GetObjectAnimationCount(object, &max_count);
      animation_count++;
      if (animation_count >= max_count) {
        // Shift nodeclass
        if (animation_direction == 1) {
          // Shift forward

          sts = grow_SetObjectNextNodeClass(object);
          if (EVEN(sts)) {
            if (sequence == ge_eAnimSequence_Cycle) {
              // Start from the beginning again
              grow_SetObjectNodeClassByIndex(object, 1);
            } else {
              // Change direction
              animation_direction = 2;
              sts = grow_SetObjectPrevNodeClass(object);
            }
          }
          animation_count = 0;
        } else {
          // Shift backward

          sts = grow_SetObjectPrevNodeClass(object);
          if (EVEN(sts)) {
            // Change direction
            animation_direction = 1;
            sts = grow_SetObjectNextNodeClass(object);
          }
          animation_count = 0;
        }
      }
    } else {
      if (animation_direction != 0) {
        // Stop and reset animation
        animation_direction = 0;
        grow_SetObjectFirstNodeClass(object);
      }
    }
  }
  old_value = val;
  return 1;
}

int GeAnimation::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  int seq, attr2;

  if (sequence == ge_eAnimSequence_Inherit)
    grow_GetObjectClassDynAttr(object, &seq, &attr2);
  else
    seq = (int)sequence;

  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynAnimation(" << var_name << ".dd, \"" << attribute << "\","
     << seq << ")\n";
  return 1;
}

int GeAnimation::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    pwr_eType_Int64, pwr_eType_UInt64, graph_eType_Bit, pwr_eType_Float32,
    pwr_eType_Float64, pwr_eType_String, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase__ };
  dyn->syntax_check_attribute(object, "Animation.Attribute", attribute, 0,
      types, databases, error_cnt, warning_cnt);

  return 1;
}

void GeVideo::save(std::ofstream& fp)
{
  fp << int(ge_eSave_Video) << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeVideo::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeVideo: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_Video:
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeVideo:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeVideo::connect(grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  trace_data->p = (void*)1;
  return 1;
}

int GeVideo::disconnect(grow_tObject object)
{
  return 1;
}

int GeVideo::scan(grow_tObject object)
{
  grow_tObject* objectlist;
  int object_cnt;

  grow_GetGroupObjectList(object, &objectlist, &object_cnt);

  for (int i = 0; i < object_cnt; i++) {
    if (grow_GetObjectType(objectlist[i]) == glow_eObjectType_GrowImage) {
      grow_ImageUpdate(objectlist[i]);
      break;
    }
  }
  return 1;
}

int GeVideo::syntax_check(grow_tObject object, int* error_cnt, int* warning_cnt)
{
  grow_tObject* objectlist;
  int object_cnt;

  if (grow_GetObjectType(object) != glow_eObjectType_GrowGroup) {
    dyn->graph->syntax_msg('E', object, "Video, object isn't a group");
    (*error_cnt)++;
    return 1;
  }

  // Find image
  grow_GetGroupObjectList(object, &objectlist, &object_cnt);

  int found = 0;
  for (int i = 0; i < object_cnt; i++) {
    if (grow_GetObjectType(objectlist[i]) == glow_eObjectType_GrowImage) {
      found = 1;
      break;
    }
  }
  if (!found) {
    dyn->graph->syntax_msg('E', object, "Video, no image found in group");
    (*error_cnt)++;
  }
  return 1;
}

GeBar::GeBar(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_Bar, ge_mDynType2_No, ge_mActionType1_No,
          ge_mActionType2_No, ge_eDynPrio_Bar),
      min_value_p(0), max_value_p(0), old_min_value(0), old_max_value(0)
{
  strcpy(attribute, "");
  strcpy(minvalue_attr, "");
  strcpy(maxvalue_attr, "");
}

GeBar::GeBar(const GeBar& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      min_value_p(0), max_value_p(0), old_min_value(0), old_max_value(0)
{
  strcpy(attribute, x.attribute);
  strcpy(minvalue_attr, x.minvalue_attr);
  strcpy(maxvalue_attr, x.maxvalue_attr);
}

void GeBar::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "Bar.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  strcpy(attrinfo[i].name, "Bar.MinValueAttr");
  attrinfo[i].value = minvalue_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(minvalue_attr);

  strcpy(attrinfo[i].name, "Bar.MaxValueAttr");
  attrinfo[i].value = maxvalue_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(maxvalue_attr);

  *item_count = i;
}

void GeBar::set_attribute(grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "Bar.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeBar::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeBar::save(std::ofstream& fp)
{
  fp << int(ge_eSave_Bar) << '\n';
  fp << int(ge_eSave_Bar_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_Bar_minvalue_attr) << FSPACE << minvalue_attr << '\n';
  fp << int(ge_eSave_Bar_maxvalue_attr) << FSPACE << maxvalue_attr << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeBar::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeBar: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_Bar:
      break;
    case ge_eSave_Bar_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_Bar_minvalue_attr:
      fp.get();
      fp.getline(minvalue_attr, sizeof(minvalue_attr));
      break;
    case ge_eSave_Bar_maxvalue_attr:
      fp.get();
      fp.getline(maxvalue_attr, sizeof(maxvalue_attr));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeBar:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeBar::connect(grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;
  int inverted;

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  switch (db) {
  case graph_eDatabase_Gdh:
    sts = dyn->graph->ref_object_info(
        dyn->cycle, parsed_name, (void**)&p, &subid, attr_size, object, now);
    if (EVEN(sts))
      return sts;
    bar_typeid = attr_type;
    break;
  case graph_eDatabase_Local:
    p = (pwr_tFloat32*)dyn->graph->localdb_ref_or_create(
        parsed_name, attr_type);
    bar_typeid = attr_type;
  case graph_eDatabase_User:
    bar_typeid = attr_type;
    break;
  default:;
  }

  min_value_p = 0;
  min_value_db = dyn->parse_attr_name(
      minvalue_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    switch (min_value_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&min_value_p, &min_value_subid, attr_size, object, now);
      break;
    case graph_eDatabase_Local:
      min_value_p = (pwr_tFloat32*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      break;
    default:;
    }
  }

  max_value_p = 0;
  max_value_db = dyn->parse_attr_name(
      maxvalue_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    switch (min_value_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&max_value_p, &max_value_subid, attr_size, object, now);
      break;
    case graph_eDatabase_Local:
      max_value_p = (pwr_tFloat32*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      break;
    default:;
    }
  }

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeBar::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;

  if (min_value_p && min_value_db == graph_eDatabase_Gdh) {
    gdh_UnrefObjectInfo(min_value_subid);
    min_value_p = 0;
  }
  if (max_value_p && max_value_db == graph_eDatabase_Gdh) {
    gdh_UnrefObjectInfo(max_value_subid);
    max_value_p = 0;
  }
  return 1;
}

int GeBar::scan(grow_tObject object)
{
  if (!p)
    return 1;

  if (max_value_p || min_value_p) {
    bool update = false;

    pwr_tFloat32 maxval;
    pwr_tFloat32 minval;
    if (max_value_p) {
      maxval = *max_value_p;
      if (!feqf(maxval, old_max_value))
	update = true;
    }
    if (min_value_p) {
      minval = *min_value_p;
      if (!feqf(minval, old_min_value))
	update = true;
    }
    if (update) {
      double minvald, maxvald;
      grow_GetBarRange(object, &minvald, &maxvald);

      if (!min_value_p)
	minval = minvald;
      if (!max_value_p)
	maxval = maxvald;

      if (fabsf(maxval - minval) > FLT_EPSILON) {
        grow_SetBarRange(object, minval, maxval);
      }
      old_min_value = minval;
      old_max_value = maxval;
    }
  }

  if (!first_scan) {
    if (memcmp(&old_value, p, size) == 0)
      // No change since last time
      return 1;
  } else
    first_scan = false;

  switch (bar_typeid) {
  case pwr_eType_Float32: {
    pwr_tFloat32 val = *(pwr_tFloat32*)p;
    grow_SetBarValue(object, double(val));
    memcpy(&old_value, &val, size);
    break;
  }
  case pwr_eType_UInt32: {
    pwr_tUInt32 val = *(pwr_tUInt32*)p;
    grow_SetBarValue(object, double(val));
    memcpy(&old_value, &val, size);
    break;
  }
  case pwr_eType_Int32: {
    pwr_tInt32 val = *(pwr_tInt32*)p;
    grow_SetBarValue(object, double(val));
    memcpy(&old_value, &val, size);
    break;
  }
  default:;
  }
  return 1;
}

int GeBar::syntax_check(grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Int32, pwr_eType_UInt32, pwr_eType_Float32, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase_Local,
    graph_eDatabase_User, graph_eDatabase__ };
  dyn->syntax_check_attribute(object, "Bar.Attribute", attribute, 0, types,
      databases, error_cnt, warning_cnt);

  return 1;
}

GeTrend::GeTrend(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_Trend, ge_mDynType2_No, ge_mActionType1_No,
          ge_mActionType2_No, ge_eDynPrio_Trend),
      min_value1_p(0), max_value1_p(0), old_min_value1(0), old_max_value1(0),
      min_value2_p(0), max_value2_p(0), old_min_value2(0), old_max_value2(0),
      hold_p(0), timerange_p(0), old_timerange(0),
      mark1_color(glow_eDrawType_Inherit), mark2_color(glow_eDrawType_Inherit)
{
  strcpy(attribute1, "");
  strcpy(attribute2, "");
  strcpy(minvalue_attr1, "");
  strcpy(maxvalue_attr1, "");
  strcpy(minvalue_attr2, "");
  strcpy(maxvalue_attr2, "");
  strcpy(hold_attr, "");
  strcpy(timerange_attr, "");
  strcpy(mark1_attr, "");
  strcpy(mark2_attr, "");
}

GeTrend::GeTrend(const GeTrend& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      mark1_color(x.mark1_color), mark2_color(x.mark2_color)
{
  strcpy(attribute1, x.attribute1);
  strcpy(attribute2, x.attribute2);
  strcpy(minvalue_attr1, x.minvalue_attr1);
  strcpy(maxvalue_attr1, x.maxvalue_attr1);
  strcpy(minvalue_attr2, x.minvalue_attr2);
  strcpy(maxvalue_attr2, x.maxvalue_attr2);
  strcpy(hold_attr, x.hold_attr);
  strcpy(timerange_attr, x.timerange_attr);
  strcpy(mark1_attr, x.mark1_attr);
  strcpy(mark2_attr, x.mark2_attr);
}

void GeTrend::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "Trend.Attribute1");
  attrinfo[i].value = attribute1;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute1);

  strcpy(attrinfo[i].name, "Trend.Attribute2");
  attrinfo[i].value = attribute2;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute2);

  strcpy(attrinfo[i].name, "Trend.MinValueAttr1");
  attrinfo[i].value = minvalue_attr1;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(minvalue_attr1);

  strcpy(attrinfo[i].name, "Trend.MaxValueAttr1");
  attrinfo[i].value = maxvalue_attr1;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(maxvalue_attr1);

  strcpy(attrinfo[i].name, "Trend.MinValueAttr2");
  attrinfo[i].value = minvalue_attr2;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(minvalue_attr2);

  strcpy(attrinfo[i].name, "Trend.MaxValueAttr2");
  attrinfo[i].value = maxvalue_attr2;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(maxvalue_attr2);

  strcpy(attrinfo[i].name, "Trend.HoldAttr");
  attrinfo[i].value = hold_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(hold_attr);

  strcpy(attrinfo[i].name, "Trend.TimeRangeAttr");
  attrinfo[i].value = timerange_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(timerange_attr);

  strcpy(attrinfo[i].name, "Trend.Mark1Attr");
  attrinfo[i].value = mark1_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(mark1_attr);

  strcpy(attrinfo[i].name, "Trend.Mark2Attr");
  attrinfo[i].value = mark2_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(mark2_attr);

  strcpy(attrinfo[i].name, "Trend.Mark1Color");
  attrinfo[i].value = &mark1_color;
  attrinfo[i].type = glow_eType_Color;
  attrinfo[i++].size = sizeof(mark1_color);

  strcpy(attrinfo[i].name, "Trend.Mark2Color");
  attrinfo[i].value = &mark2_color;
  attrinfo[i].type = glow_eType_Color;
  attrinfo[i++].size = sizeof(mark2_color);

  *item_count = i;
}

void GeTrend::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute1, attr_name, sizeof(attribute1));
    snprintf(msg, sizeof(msg), "Trend.Attribute1 = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  } else if (*cnt == 1) {
    char msg[200];

    strncpy(attribute2, attr_name, sizeof(attribute2));
    snprintf(msg, sizeof(msg), "Trend.YAttribute2 = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
    (*cnt)--;
  }
}

void GeTrend::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(
      attribute1, sizeof(attribute1), from, to, cnt, strict);
  GeDyn::replace_attribute(
      attribute2, sizeof(attribute2), from, to, cnt, strict);
  GeDyn::replace_attribute(
      minvalue_attr1, sizeof(minvalue_attr1), from, to, cnt, strict);
  GeDyn::replace_attribute(
      maxvalue_attr1, sizeof(maxvalue_attr1), from, to, cnt, strict);
  GeDyn::replace_attribute(
      minvalue_attr2, sizeof(minvalue_attr2), from, to, cnt, strict);
  GeDyn::replace_attribute(
      maxvalue_attr2, sizeof(maxvalue_attr2), from, to, cnt, strict);
  GeDyn::replace_attribute(hold_attr, sizeof(hold_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      timerange_attr, sizeof(timerange_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      mark1_attr, sizeof(mark1_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      mark2_attr, sizeof(mark2_attr), from, to, cnt, strict);
}

void GeTrend::save(std::ofstream& fp)
{
  fp << int(ge_eSave_Trend) << '\n';
  fp << int(ge_eSave_Trend_attribute1) << FSPACE << attribute1 << '\n';
  fp << int(ge_eSave_Trend_attribute2) << FSPACE << attribute2 << '\n';
  fp << int(ge_eSave_Trend_minvalue_attr1) << FSPACE << minvalue_attr1 << '\n';
  fp << int(ge_eSave_Trend_maxvalue_attr1) << FSPACE << maxvalue_attr1 << '\n';
  fp << int(ge_eSave_Trend_minvalue_attr2) << FSPACE << minvalue_attr2 << '\n';
  fp << int(ge_eSave_Trend_maxvalue_attr2) << FSPACE << maxvalue_attr2 << '\n';
  fp << int(ge_eSave_Trend_hold_attr) << FSPACE << hold_attr << '\n';
  fp << int(ge_eSave_Trend_timerange_attr) << FSPACE << timerange_attr << '\n';
  fp << int(ge_eSave_Trend_mark1_attr) << FSPACE << mark1_attr << '\n';
  fp << int(ge_eSave_Trend_mark2_attr) << FSPACE << mark2_attr << '\n';
  fp << int(ge_eSave_Trend_mark1_color) << FSPACE << (int)mark1_color << '\n';
  fp << int(ge_eSave_Trend_mark2_color) << FSPACE << (int)mark2_color << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeTrend::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeTrend: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_Trend:
      break;
    case ge_eSave_Trend_attribute1:
      fp.get();
      fp.getline(attribute1, sizeof(attribute1));
      break;
    case ge_eSave_Trend_attribute2:
      fp.get();
      fp.getline(attribute2, sizeof(attribute2));
      break;
    case ge_eSave_Trend_minvalue_attr1:
      fp.get();
      fp.getline(minvalue_attr1, sizeof(minvalue_attr1));
      break;
    case ge_eSave_Trend_maxvalue_attr1:
      fp.get();
      fp.getline(maxvalue_attr1, sizeof(maxvalue_attr1));
      break;
    case ge_eSave_Trend_minvalue_attr2:
      fp.get();
      fp.getline(minvalue_attr2, sizeof(minvalue_attr2));
      break;
    case ge_eSave_Trend_maxvalue_attr2:
      fp.get();
      fp.getline(maxvalue_attr2, sizeof(maxvalue_attr2));
      break;
    case ge_eSave_Trend_hold_attr:
      fp.get();
      fp.getline(hold_attr, sizeof(hold_attr));
      break;
    case ge_eSave_Trend_timerange_attr:
      fp.get();
      fp.getline(timerange_attr, sizeof(timerange_attr));
      break;
    case ge_eSave_Trend_mark1_attr:
      fp.get();
      fp.getline(mark1_attr, sizeof(mark1_attr));
      break;
    case ge_eSave_Trend_mark2_attr:
      fp.get();
      fp.getline(mark2_attr, sizeof(mark2_attr));
      break;
    case ge_eSave_Trend_mark1_color:
      fp >> tmp;
      mark1_color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_Trend_mark2_color:
      fp >> tmp;
      mark2_color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeTrend:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeTrend::connect(grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;
  int inverted;
  int attr_cnt = 0;

  size1 = 4;
  p1 = 0;
  db1 = dyn->parse_attr_name(
      attribute1, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "")) {
    switch (db1) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name, (void**)&p1,
          &subid1, attr_size, object, now);
      if (EVEN(sts))
        return sts;
      trend_typeid1 = attr_type;
      break;
    case graph_eDatabase_Local:
      p1 = (pwr_tFloat32*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      trend_typeid1 = attr_type;
    case graph_eDatabase_User:
      trend_typeid1 = attr_type;
      break;
    default:;
    }
    attr_cnt++;
  }
  size2 = 4;
  p2 = 0;
  db2 = dyn->parse_attr_name(
      attribute2, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "")) {
    switch (db2) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name, (void**)&p2,
          &subid2, attr_size, object, now);
      if (EVEN(sts))
        return sts;
      trend_typeid2 = attr_type;
      break;
    case graph_eDatabase_Local:
      p2 = (pwr_tFloat32*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      trend_typeid2 = attr_type;
    case graph_eDatabase_User:
      trend_typeid2 = attr_type;
      break;
    default:;
    }
    attr_cnt++;
  }
  no_of_points = grow_GetTrendNoOfPoints(object);
  grow_GetTrendScanTime(object, &scan_time);
  acc_time = scan_time;
  trend_hold = 0;

  min_value1_p = 0;
  min_value1_db = dyn->parse_attr_name(
      minvalue_attr1, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    switch (min_value1_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&min_value1_p, &min_value_subid1, attr_size, object, now);
      break;
    case graph_eDatabase_Local:
      min_value1_p = (pwr_tFloat32*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      break;
    default:;
    }
  }
  max_value1_p = 0;
  max_value1_db = dyn->parse_attr_name(
      maxvalue_attr1, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    switch (max_value1_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&max_value1_p, &max_value_subid1, attr_size, object, now);
      break;
    case graph_eDatabase_Local:
      max_value1_p = (pwr_tFloat32*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      break;
    default:;
    }
  }
  min_value2_p = 0;
  dyn->parse_attr_name(
      minvalue_attr2, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&min_value2_p, &min_value_subid2, attr_size, object, now);
  }
  max_value2_p = 0;
  dyn->parse_attr_name(
      maxvalue_attr2, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&max_value2_p, &max_value_subid2, attr_size, object, now);
  }

  hold_p = 0;
  hold_db = dyn->parse_attr_name(
      hold_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Boolean) {
    switch (hold_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&hold_p, &hold_subid, attr_size, object, now);
      if (EVEN(sts))
        return sts;
      break;
    case graph_eDatabase_Local:
      hold_p = (pwr_tBoolean*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      break;
    default:;
    }
  }

  timerange_p = 0;
  timerange_db = dyn->parse_attr_name(
      timerange_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    switch (timerange_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&timerange_p, &timerange_subid, attr_size, object, now);
      if (EVEN(sts))
        return sts;
      break;
    case graph_eDatabase_Local:
      timerange_p = (pwr_tFloat32*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      if (feqf(*timerange_p, 0.0f))
        *timerange_p = scan_time * no_of_points;
      break;
    default:;
    }
    orig_graph_scan_time = dyn->graph->scan_time;
    orig_graph_fast_scan_time = dyn->graph->fast_scan_time;
    orig_graph_animation_scan_time = dyn->graph->animation_scan_time;
  }

  mark1_p = 0;
  dyn->parse_attr_name(
      mark1_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name, (void**)&mark1_p,
        &mark1_subid, attr_size, object, now);
  }

  mark2_p = 0;
  dyn->parse_attr_name(
      mark2_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name, (void**)&mark2_p,
        &mark2_subid, attr_size, object, now);
  }

  grow_SetTrendNoOfCurves(object, attr_cnt);
  if (mark1_color != glow_eDrawType_Inherit
      || mark2_color != glow_eDrawType_Inherit)
    grow_SetTrendMarkColor(object, mark1_color, mark2_color);
  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeTrend::disconnect(grow_tObject object)
{
  if (p1 && db1 == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid1);
  p1 = 0;
  if (p2 && db2 == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid2);
  p2 = 0;
  if (min_value1_p && min_value1_db == graph_eDatabase_Gdh) {
    gdh_UnrefObjectInfo(min_value_subid1);
    min_value1_p = 0;
  }
  if (max_value1_p && max_value1_db == graph_eDatabase_Gdh) {
    gdh_UnrefObjectInfo(max_value_subid1);
    max_value1_p = 0;
  }
  if (min_value2_p) {
    gdh_UnrefObjectInfo(min_value_subid2);
    min_value2_p = 0;
  }
  if (max_value2_p) {
    gdh_UnrefObjectInfo(max_value_subid2);
    max_value2_p = 0;
  }
  if (hold_p && hold_db == graph_eDatabase_Gdh) {
    gdh_UnrefObjectInfo(hold_subid);
    hold_p = 0;
  }
  if (timerange_p && timerange_db == graph_eDatabase_Gdh) {
    gdh_UnrefObjectInfo(timerange_subid);
    timerange_p = 0;
  }
  if (mark1_p) {
    gdh_UnrefObjectInfo(mark1_subid);
    mark1_p = 0;
  }
  if (mark2_p) {
    gdh_UnrefObjectInfo(mark2_subid);
    mark1_p = 0;
  }
  return 1;
}

int GeTrend::scan(grow_tObject object)
{
  if (!p1 && !p2)
    return 1;
  if (hold_p)
    trend_hold = *hold_p;
  if (trend_hold)
    return 1;

  if (max_value1_p || min_value1_p) {
    bool update = false;

    pwr_tFloat32 maxval;
    pwr_tFloat32 minval;
    if (max_value1_p) {
      maxval = *max_value1_p;
      if (!feqf(maxval, old_max_value1))
	update = true;
    }
    if (min_value1_p) {
      minval = *min_value1_p;
      if (!feqf(minval, old_min_value1))
	update = true;
    }
    if (update) {
      double minvald, maxvald;
      grow_GetTrendRangeY(object, 0, &minvald, &maxvald);

      if (!min_value1_p)
	minval = minvald;
      if (!max_value1_p)
	maxval = maxvald;

      if (fabsf(maxval - minval) > FLT_EPSILON) {
        grow_SetTrendRangeY(object, 0, minval, maxval);
      }
      old_min_value1 = minval;
      old_max_value1 = maxval;
    }
  }

  if (max_value2_p || min_value2_p) {
    bool update = false;

    pwr_tFloat32 maxval;
    pwr_tFloat32 minval;
    if (max_value2_p) {
      maxval = *max_value2_p;
      if (!feqf(maxval, old_max_value2))
	update = true;
    }
    if (min_value2_p) {
      minval = *min_value2_p;
      if (!feqf(minval, old_min_value2))
	update = true;
    }
    if (update) {
      double minvald, maxvald;
      grow_GetTrendRangeY(object, 1, &minvald, &maxvald);

      if (!min_value2_p)
	minval = minvald;
      if (!max_value2_p)
	maxval = maxvald;

      if (fabsf(maxval - minval) > FLT_EPSILON) {
        grow_SetTrendRangeY(object, 1, minval, maxval);
      }
      old_min_value2 = minval;
      old_max_value2 = maxval;
    }
  }

  if (timerange_p) {
    if (fabsf(*timerange_p - old_timerange) > FLT_EPSILON) {
      double dt = *timerange_p / no_of_points;
      if (dt >= 0.001) {
        grow_SetTrendScanTime(object, dt);
        scan_time = dt;
        if (dyn->cycle == glow_eCycle_Slow) {
          if (dyn->graph->scan_time > scan_time)
            dyn->graph->scan_time = scan_time;
          else {
            if (scan_time > orig_graph_scan_time)
              dyn->graph->scan_time = orig_graph_scan_time;
            else
              dyn->graph->scan_time = scan_time;
          }
          if (dyn->graph->fast_scan_time > scan_time)
            dyn->graph->fast_scan_time = scan_time;
          else {
            if (scan_time > orig_graph_fast_scan_time)
              dyn->graph->fast_scan_time = orig_graph_fast_scan_time;
            else
              dyn->graph->fast_scan_time = scan_time;
          }
          if (dyn->graph->animation_scan_time > scan_time)
            dyn->graph->animation_scan_time = scan_time;
          else {
            if (scan_time > orig_graph_animation_scan_time)
              dyn->graph->animation_scan_time = orig_graph_animation_scan_time;
            else
              dyn->graph->animation_scan_time = scan_time;
          }
        } else {
          // Fast cycle
          if (dyn->graph->fast_scan_time > scan_time)
            dyn->graph->fast_scan_time = scan_time;
          else {
            if (scan_time > orig_graph_fast_scan_time)
              dyn->graph->fast_scan_time = orig_graph_fast_scan_time;
            else
              dyn->graph->fast_scan_time = scan_time;
          }
          if (dyn->graph->animation_scan_time > scan_time)
            dyn->graph->animation_scan_time = scan_time;
          else {
            if (scan_time > orig_graph_animation_scan_time)
              dyn->graph->animation_scan_time = orig_graph_animation_scan_time;
            else
              dyn->graph->animation_scan_time = scan_time;
          }
        }
      }
      old_timerange = *timerange_p;
    }
  }

  if (mark1_p && (first_scan || fabsf(*mark1_p - old_mark1) > FLT_EPSILON)) {
    grow_SetTrendYMark1(object, *mark1_p);
    old_mark1 = *mark1_p;
  }
  if (mark2_p && (first_scan || fabsf(*mark2_p - old_mark2) > FLT_EPSILON)) {
    grow_SetTrendYMark2(object, *mark2_p);
    old_mark2 = *mark2_p;
  }

  if (first_scan)
    first_scan = false;

  if (dyn->cycle == glow_eCycle_Slow)
    acc_time += dyn->graph->scan_time;
  else
    acc_time += dyn->graph->fast_scan_time;

  if (acc_time + DBL_EPSILON >= scan_time) {
    if (p1) {
      switch (trend_typeid1) {
      case pwr_eType_Boolean:
        grow_AddTrendValue(object, double(*(pwr_tBoolean*)p1), 0);
        break;
      case pwr_eType_Float32:
        grow_AddTrendValue(object, double(*(pwr_tFloat32*)p1), 0);
        break;
      case pwr_eType_Int32:
        grow_AddTrendValue(object, double(*(pwr_tInt32*)p1), 0);
        break;
      case pwr_eType_UInt32:
        grow_AddTrendValue(object, double(*(pwr_tUInt32*)p1), 0);
        break;
      default:;
      }
    }
    if (p2) {
      switch (trend_typeid2) {
      case pwr_eType_Boolean:
        grow_AddTrendValue(object, double(*(pwr_tBoolean*)p2), 1);
        break;
      case pwr_eType_Float32:
        grow_AddTrendValue(object, double(*(pwr_tFloat32*)p2), 1);
        break;
      case pwr_eType_Int32:
        grow_AddTrendValue(object, double(*(pwr_tInt32*)p2), 1);
        break;
      case pwr_eType_UInt32:
        grow_AddTrendValue(object, double(*(pwr_tUInt32*)p2), 1);
        break;
      default:;
      }
    }
    acc_time = 0;
  }
  return 1;
}

int GeTrend::syntax_check(grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    pwr_eType_Float32, 0 };
  int types2[] = { pwr_eType_Float32, 0 };
  int types3[] = { pwr_eType_Boolean, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase_Local,
    graph_eDatabase_User, graph_eDatabase__ };
  graph_eDatabase databases2[]
      = { graph_eDatabase_Gdh, graph_eDatabase_Local, graph_eDatabase__ };
  graph_eDatabase databases3[] = { graph_eDatabase_Gdh, graph_eDatabase__ };
  dyn->syntax_check_attribute(object, "Trend.Attribute1", attribute1, 1, types,
      databases, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "Trend.Attribute2", attribute2, 1, types,
      databases, error_cnt, warning_cnt);

  dyn->syntax_check_attribute(object, "Trend.MinValueAttr1", minvalue_attr1, 1,
      types2, databases2, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "Trend.MaxValueAttr1", maxvalue_attr1, 1,
      types2, databases2, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "Trend.MinValueAttr2", minvalue_attr2, 1,
      types2, databases2, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "Trend.MaxValueAttr2", maxvalue_attr2, 1,
      types2, databases2, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "Trend.HoldAttr", hold_attr, 1, types3,
      databases2, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "Trend.TimeRangeAttr", timerange_attr, 1,
      types2, databases2, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "Trend.Mark1Attr", mark1_attr, 1, types2,
      databases3, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "Trend.Mark2Attr", mark2_attr, 1, types2,
      databases3, error_cnt, warning_cnt);

  if (streq(attribute1, "") && streq(attribute2, "")) {
    dyn->graph->syntax_msg('E', object, "Trend, no attribute");
    (*error_cnt)++;
  }

  return 1;
}

// XY_Curve
GeXY_Curve::GeXY_Curve(GeDyn* e_dyn, ge_mInstance e_instance)
    : GeDynElem(e_dyn, ge_mDynType1_XY_Curve, ge_mDynType2_No,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_XY_Curve),
      y_min_value(0), y_max_value(100), x_min_value(0), x_max_value(100),
      noofpoints(100), datatype(0), curve_color(glow_eDrawType_Inherit),
      fill_color(glow_eDrawType_Inherit), horizontal_padding(0), update_p(0),
      old_update(0), noofpoints_p(0), old_noofpoints(0), y_min_value_p(0),
      y_max_value_p(0), x_min_value_p(0), x_max_value_p(0), old_y_min_value(0),
      old_y_max_value(0), old_x_min_value(0), old_x_max_value(0), x_mark1_p(0),
      x_mark2_p(0), y_mark1_p(0), y_mark2_p(0), old_x_mark1(0), old_x_mark2(0),
      old_y_mark1(0), old_y_mark2(0), mark1_color(glow_eDrawType_Inherit),
      mark2_color(glow_eDrawType_Inherit)
{
  instance = e_instance;
  strcpy(x_attr, "");
  strcpy(y_attr, "");
  strcpy(y_minvalue_attr, "");
  strcpy(y_maxvalue_attr, "");
  strcpy(x_minvalue_attr, "");
  strcpy(x_maxvalue_attr, "");
  strcpy(noofpoints_attr, "");
  strcpy(update_attr, "");
  strcpy(hold_attr, "");
  strcpy(x_mark1_attr, "");
  strcpy(x_mark2_attr, "");
  strcpy(y_mark1_attr, "");
  strcpy(y_mark2_attr, "");
}

GeXY_Curve::GeXY_Curve(const GeXY_Curve& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      y_min_value(x.y_min_value), y_max_value(x.y_max_value),
      x_min_value(x.x_min_value), x_max_value(x.x_max_value),
      noofpoints(x.noofpoints), datatype(x.datatype),
      curve_color(x.curve_color), fill_color(x.fill_color),
      horizontal_padding(x.horizontal_padding), mark1_color(x.mark1_color),
      mark2_color(x.mark2_color)
{
  instance = x.instance;
  instance_mask = x.instance_mask;
  strcpy(x_attr, x.x_attr);
  strcpy(y_attr, x.y_attr);
  strcpy(y_minvalue_attr, x.y_minvalue_attr);
  strcpy(y_maxvalue_attr, x.y_maxvalue_attr);
  strcpy(x_minvalue_attr, x.x_minvalue_attr);
  strcpy(x_maxvalue_attr, x.x_maxvalue_attr);
  strcpy(noofpoints_attr, x.noofpoints_attr);
  strcpy(update_attr, x.update_attr);
  strcpy(hold_attr, x.hold_attr);
  strcpy(x_mark1_attr, x.x_mark1_attr);
  strcpy(x_mark2_attr, x.x_mark2_attr);
  strcpy(y_mark1_attr, x.y_mark1_attr);
  strcpy(y_mark2_attr, x.y_mark2_attr);
}

void GeXY_Curve::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  if (instance == ge_mInstance_1) {
    strcpy(attrinfo[i].name, "XY_Curve.DataType");
    attrinfo[i].value = &datatype;
    attrinfo[i].type = ge_eAttrType_CurveDataType;
    attrinfo[i++].size = sizeof(datatype);

    strcpy(attrinfo[i].name, "XY_Curve.XAttr");
    attrinfo[i].value = x_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(x_attr);

    strcpy(attrinfo[i].name, "XY_Curve.YAttr");
    attrinfo[i].value = y_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(y_attr);

    strcpy(attrinfo[i].name, "XY_Curve.UpdateAttr");
    attrinfo[i].value = update_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(update_attr);

    strcpy(attrinfo[i].name, "XY_Curve.HoldAttr");
    attrinfo[i].value = hold_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(hold_attr);

    strcpy(attrinfo[i].name, "XY_Curve.XMinValue");
    attrinfo[i].value = &x_min_value;
    attrinfo[i].type = glow_eType_Double;
    attrinfo[i++].size = sizeof(x_min_value);

    strcpy(attrinfo[i].name, "XY_Curve.XMaxValue");
    attrinfo[i].value = &x_max_value;
    attrinfo[i].type = glow_eType_Double;
    attrinfo[i++].size = sizeof(x_max_value);

    strcpy(attrinfo[i].name, "XY_Curve.YMinValue");
    attrinfo[i].value = &y_min_value;
    attrinfo[i].type = glow_eType_Double;
    attrinfo[i++].size = sizeof(y_min_value);

    strcpy(attrinfo[i].name, "XY_Curve.YMaxValue");
    attrinfo[i].value = &y_max_value;
    attrinfo[i].type = glow_eType_Double;
    attrinfo[i++].size = sizeof(y_max_value);

    strcpy(attrinfo[i].name, "XY_Curve.XMinValueAttr");
    attrinfo[i].value = x_minvalue_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(x_minvalue_attr);

    strcpy(attrinfo[i].name, "XY_Curve.XMaxValueAttr");
    attrinfo[i].value = x_maxvalue_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(x_maxvalue_attr);

    strcpy(attrinfo[i].name, "XY_Curve.YMinValueAttr");
    attrinfo[i].value = y_minvalue_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(y_minvalue_attr);

    strcpy(attrinfo[i].name, "XY_Curve.YMaxValueAttr");
    attrinfo[i].value = y_maxvalue_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(y_maxvalue_attr);

    strcpy(attrinfo[i].name, "XY_Curve.NoOfPointsAttr");
    attrinfo[i].value = noofpoints_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(noofpoints_attr);

    strcpy(attrinfo[i].name, "XY_Curve.CurveColor");
    attrinfo[i].value = &curve_color;
    attrinfo[i].type = glow_eType_Color;
    attrinfo[i++].size = sizeof(curve_color);

    strcpy(attrinfo[i].name, "XY_Curve.FillColor");
    attrinfo[i].value = &fill_color;
    attrinfo[i].type = glow_eType_Color;
    attrinfo[i++].size = sizeof(fill_color);

    strcpy(attrinfo[i].name, "XY_Curve.HorizontalPadding");
    attrinfo[i].value = &horizontal_padding;
    attrinfo[i].type = glow_eType_Boolean;
    attrinfo[i++].size = sizeof(horizontal_padding);

    strcpy(attrinfo[i].name, "XY_Curve.XMark1Attr");
    attrinfo[i].value = x_mark1_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(x_mark1_attr);

    strcpy(attrinfo[i].name, "XY_Curve.XMark2Attr");
    attrinfo[i].value = x_mark2_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(x_mark2_attr);

    strcpy(attrinfo[i].name, "XY_Curve.YMark1Attr");
    attrinfo[i].value = y_mark1_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(y_mark1_attr);

    strcpy(attrinfo[i].name, "XY_Curve.YMark2Attr");
    attrinfo[i].value = y_mark2_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(y_mark2_attr);

    strcpy(attrinfo[i].name, "XY_Curve.Mark1Color");
    attrinfo[i].value = &mark1_color;
    attrinfo[i].type = glow_eType_Color;
    attrinfo[i++].size = sizeof(mark1_color);

    strcpy(attrinfo[i].name, "XY_Curve.Mark2Color");
    attrinfo[i].value = &mark2_color;
    attrinfo[i].type = glow_eType_Color;
    attrinfo[i++].size = sizeof(mark2_color);

    strcpy(attrinfo[i].name, "XY_Curve.Instances");
    attrinfo[i].value = &instance_mask;
    attrinfo[i].type = ge_eAttrType_InstanceMask;
    attrinfo[i].mask = 1023;
    attrinfo[i++].size = sizeof(instance_mask);
  } else {
    // Get instance number
    int inst = 1;
    unsigned int m = instance;
    while (m > 1) {
      m = m >> 1;
      inst++;
    }

    sprintf(attrinfo[i].name, "XY_Curve%d.DataType", inst);
    attrinfo[i].value = &datatype;
    attrinfo[i].type = ge_eAttrType_CurveDataType;
    attrinfo[i++].size = sizeof(datatype);

    sprintf(attrinfo[i].name, "XY_Curve%d.XAttr", inst);
    attrinfo[i].value = x_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(x_attr);

    sprintf(attrinfo[i].name, "XY_Curve%d.YAttr", inst);
    attrinfo[i].value = y_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(y_attr);

    sprintf(attrinfo[i].name, "XY_Curve%d.UpdateAttr", inst);
    attrinfo[i].value = update_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(update_attr);

    sprintf(attrinfo[i].name, "XY_Curve%d.HoldAttr", inst);
    attrinfo[i].value = hold_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(hold_attr);

    sprintf(attrinfo[i].name, "XY_Curve%d.XMinValue", inst);
    attrinfo[i].value = &x_min_value;
    attrinfo[i].type = glow_eType_Double;
    attrinfo[i++].size = sizeof(x_min_value);

    sprintf(attrinfo[i].name, "XY_Curve%d.XMaxValue", inst);
    attrinfo[i].value = &x_max_value;
    attrinfo[i].type = glow_eType_Double;
    attrinfo[i++].size = sizeof(x_max_value);

    sprintf(attrinfo[i].name, "XY_Curve%d.YMinValue", inst);
    attrinfo[i].value = &y_min_value;
    attrinfo[i].type = glow_eType_Double;
    attrinfo[i++].size = sizeof(y_min_value);

    sprintf(attrinfo[i].name, "XY_Curve%d.YMaxValue", inst);
    attrinfo[i].value = &y_max_value;
    attrinfo[i].type = glow_eType_Double;
    attrinfo[i++].size = sizeof(y_max_value);

    sprintf(attrinfo[i].name, "XY_Curve%d.XMinValueAttr", inst);
    attrinfo[i].value = x_minvalue_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(x_minvalue_attr);

    sprintf(attrinfo[i].name, "XY_Curve%d.XMaxValueAttr", inst);
    attrinfo[i].value = x_maxvalue_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(x_maxvalue_attr);

    sprintf(attrinfo[i].name, "XY_Curve%d.YMinValueAttr", inst);
    attrinfo[i].value = y_minvalue_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(y_minvalue_attr);

    sprintf(attrinfo[i].name, "XY_Curve%d.YMaxValueAttr", inst);
    attrinfo[i].value = y_maxvalue_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(y_maxvalue_attr);

    sprintf(attrinfo[i].name, "XY_Curve%d.NoOfPointsAttr", inst);
    attrinfo[i].value = noofpoints_attr;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(noofpoints_attr);

    sprintf(attrinfo[i].name, "XY_Curve%d.CurveColor", inst);
    attrinfo[i].value = &curve_color;
    attrinfo[i].type = glow_eType_Color;
    attrinfo[i++].size = sizeof(curve_color);

    sprintf(attrinfo[i].name, "XY_Curve%d.FillColor", inst);
    attrinfo[i].value = &fill_color;
    attrinfo[i].type = glow_eType_Color;
    attrinfo[i++].size = sizeof(fill_color);

    sprintf(attrinfo[i].name, "XY_Curve%d.HorizontalPadding", inst);
    attrinfo[i].value = &horizontal_padding;
    attrinfo[i].type = glow_eType_Boolean;
    attrinfo[i++].size = sizeof(horizontal_padding);
  }
  *item_count = i;
}

void GeXY_Curve::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(x_attr, attr_name, sizeof(x_attr));
    snprintf(msg, sizeof(msg), "XY_Curve.XAttr = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  } else if (*cnt == 1) {
    char msg[200];

    strncpy(y_attr, attr_name, sizeof(y_attr));
    snprintf(msg, sizeof(msg), "XY_Curve.YAttr = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
    (*cnt)--;
  }
}

void GeXY_Curve::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(x_attr, sizeof(x_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(y_attr, sizeof(y_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      update_attr, sizeof(update_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      update_attr, sizeof(hold_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      noofpoints_attr, sizeof(noofpoints_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      y_minvalue_attr, sizeof(y_minvalue_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      y_maxvalue_attr, sizeof(y_maxvalue_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      x_minvalue_attr, sizeof(x_minvalue_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      x_maxvalue_attr, sizeof(x_maxvalue_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      x_mark1_attr, sizeof(x_mark1_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      x_mark2_attr, sizeof(x_mark2_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      y_mark1_attr, sizeof(y_mark1_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      y_mark2_attr, sizeof(y_mark2_attr), from, to, cnt, strict);
}

void GeXY_Curve::save(std::ofstream& fp)
{
  fp << int(ge_eSave_XY_Curve) << '\n';
  fp << int(ge_eSave_XY_Curve_x_attr) << FSPACE << x_attr << '\n';
  fp << int(ge_eSave_XY_Curve_y_attr) << FSPACE << y_attr << '\n';
  fp << int(ge_eSave_XY_Curve_y_minvalue_attr) << FSPACE << y_minvalue_attr
     << '\n';
  fp << int(ge_eSave_XY_Curve_y_maxvalue_attr) << FSPACE << y_maxvalue_attr
     << '\n';
  fp << int(ge_eSave_XY_Curve_x_minvalue_attr) << FSPACE << x_minvalue_attr
     << '\n';
  fp << int(ge_eSave_XY_Curve_x_maxvalue_attr) << FSPACE << x_maxvalue_attr
     << '\n';
  fp << int(ge_eSave_XY_Curve_noofpoints_attr) << FSPACE << noofpoints_attr
     << '\n';
  fp << int(ge_eSave_XY_Curve_update_attr) << FSPACE << update_attr << '\n';
  fp << int(ge_eSave_XY_Curve_hold_attr) << FSPACE << hold_attr << '\n';
  fp << int(ge_eSave_XY_Curve_y_min_value) << FSPACE << y_min_value << '\n';
  fp << int(ge_eSave_XY_Curve_y_max_value) << FSPACE << y_max_value << '\n';
  fp << int(ge_eSave_XY_Curve_x_min_value) << FSPACE << x_min_value << '\n';
  fp << int(ge_eSave_XY_Curve_x_max_value) << FSPACE << x_max_value << '\n';
  fp << int(ge_eSave_XY_Curve_datatype) << FSPACE << datatype << '\n';
  fp << int(ge_eSave_XY_Curve_instance) << FSPACE << int(instance) << '\n';
  fp << int(ge_eSave_XY_Curve_instance_mask) << FSPACE << int(instance_mask)
     << '\n';
  fp << int(ge_eSave_XY_Curve_curve_color) << FSPACE << int(curve_color)
     << '\n';
  fp << int(ge_eSave_XY_Curve_fill_color) << FSPACE << int(fill_color) << '\n';
  fp << int(ge_eSave_XY_Curve_horizontal_padding) << FSPACE
     << horizontal_padding << '\n';
  fp << int(ge_eSave_XY_Curve_x_mark1_attr) << FSPACE << x_mark1_attr << '\n';
  fp << int(ge_eSave_XY_Curve_x_mark2_attr) << FSPACE << x_mark2_attr << '\n';
  fp << int(ge_eSave_XY_Curve_y_mark1_attr) << FSPACE << y_mark1_attr << '\n';
  fp << int(ge_eSave_XY_Curve_y_mark2_attr) << FSPACE << y_mark2_attr << '\n';
  fp << int(ge_eSave_XY_Curve_mark1_color) << FSPACE << int(mark1_color)
     << '\n';
  fp << int(ge_eSave_XY_Curve_mark2_color) << FSPACE << int(mark2_color)
     << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeXY_Curve::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  int tmp;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeXY_Curve: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_XY_Curve:
      break;
    case ge_eSave_XY_Curve_x_attr:
      fp.get();
      fp.getline(x_attr, sizeof(x_attr));
      break;
    case ge_eSave_XY_Curve_y_attr:
      fp.get();
      fp.getline(y_attr, sizeof(y_attr));
      break;
    case ge_eSave_XY_Curve_y_minvalue_attr:
      fp.get();
      fp.getline(y_minvalue_attr, sizeof(y_minvalue_attr));
      break;
    case ge_eSave_XY_Curve_y_maxvalue_attr:
      fp.get();
      fp.getline(y_maxvalue_attr, sizeof(y_maxvalue_attr));
      break;
    case ge_eSave_XY_Curve_x_minvalue_attr:
      fp.get();
      fp.getline(x_minvalue_attr, sizeof(x_minvalue_attr));
      break;
    case ge_eSave_XY_Curve_x_maxvalue_attr:
      fp.get();
      fp.getline(x_maxvalue_attr, sizeof(x_maxvalue_attr));
      break;
    case ge_eSave_XY_Curve_noofpoints_attr:
      fp.get();
      fp.getline(noofpoints_attr, sizeof(noofpoints_attr));
      break;
    case ge_eSave_XY_Curve_update_attr:
      fp.get();
      fp.getline(update_attr, sizeof(update_attr));
      break;
    case ge_eSave_XY_Curve_hold_attr:
      fp.get();
      fp.getline(hold_attr, sizeof(hold_attr));
      break;
    case ge_eSave_XY_Curve_y_min_value:
      fp >> y_min_value;
      break;
    case ge_eSave_XY_Curve_y_max_value:
      fp >> y_max_value;
      break;
    case ge_eSave_XY_Curve_x_min_value:
      fp >> x_min_value;
      break;
    case ge_eSave_XY_Curve_x_max_value:
      fp >> x_max_value;
      break;
    case ge_eSave_XY_Curve_datatype:
      fp >> datatype;
      break;
    case ge_eSave_XY_Curve_instance:
      fp >> tmp;
      instance = (ge_mInstance)tmp;
      break;
    case ge_eSave_XY_Curve_instance_mask:
      fp >> tmp;
      instance_mask = (ge_mInstance)tmp;
      break;
    case ge_eSave_XY_Curve_curve_color:
      fp >> tmp;
      curve_color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_XY_Curve_fill_color:
      fp >> tmp;
      fill_color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_XY_Curve_horizontal_padding:
      fp >> horizontal_padding;
      break;
    case ge_eSave_XY_Curve_x_mark1_attr:
      fp.get();
      fp.getline(x_mark1_attr, sizeof(x_mark1_attr));
      break;
    case ge_eSave_XY_Curve_x_mark2_attr:
      fp.get();
      fp.getline(x_mark2_attr, sizeof(x_mark2_attr));
      break;
    case ge_eSave_XY_Curve_y_mark1_attr:
      fp.get();
      fp.getline(y_mark1_attr, sizeof(y_mark1_attr));
      break;
    case ge_eSave_XY_Curve_y_mark2_attr:
      fp.get();
      fp.getline(y_mark2_attr, sizeof(y_mark2_attr));
      break;
    case ge_eSave_XY_Curve_mark1_color:
      fp >> tmp;
      mark1_color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_XY_Curve_mark2_color:
      fp >> tmp;
      mark2_color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeXY_Curve:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeXY_Curve::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;
  int inverted;

  update_p = 0;
  dyn->parse_attr_name(
      update_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "")) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&update_p, &update_subid, attr_size, object, now);
    if (EVEN(sts))
      return sts;
  }

  hold_p = 0;
  hold_db = dyn->parse_attr_name(
      hold_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "")) {
    switch (hold_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&hold_p, &hold_subid, attr_size, object, now);
      if (EVEN(sts))
        return sts;
      break;
    case graph_eDatabase_Local:
      hold_p = (pwr_tBoolean*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      break;
    default:;
    }
  }

  noofpoints_p = 0;
  dyn->parse_attr_name(
      noofpoints_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "")
      && (attr_type == pwr_eType_Int32 || attr_type == pwr_eType_UInt32)) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&noofpoints_p, &noofpoints_subid, attr_size, object, now);
  }

  x_min_value_p = 0;
  dyn->parse_attr_name(
      x_minvalue_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&x_min_value_p, &x_min_value_subid, attr_size, object, now);
  }
  x_max_value_p = 0;
  dyn->parse_attr_name(
      x_maxvalue_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&x_max_value_p, &x_max_value_subid, attr_size, object, now);
  }

  y_min_value_p = 0;
  dyn->parse_attr_name(
      y_minvalue_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&y_min_value_p, &y_min_value_subid, attr_size, object, now);
  }
  y_max_value_p = 0;
  dyn->parse_attr_name(
      y_maxvalue_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&y_max_value_p, &y_max_value_subid, attr_size, object, now);
  }

  x_mark1_p = 0;
  dyn->parse_attr_name(
      x_mark1_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&x_mark1_p, &x_mark1_subid, attr_size, object, now);
  }

  x_mark2_p = 0;
  dyn->parse_attr_name(
      x_mark2_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&x_mark2_p, &x_mark2_subid, attr_size, object, now);
  }

  y_mark1_p = 0;
  dyn->parse_attr_name(
      y_mark1_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&y_mark1_p, &y_mark1_subid, attr_size, object, now);
  }

  y_mark2_p = 0;
  dyn->parse_attr_name(
      y_mark2_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&y_mark2_p, &y_mark2_subid, attr_size, object, now);
  }

  trace_data->p = &pdummy;
  first_scan = true;

  // Get curve number
  curve_number = 0;
  unsigned int m = instance;
  while (m) {
    m = m >> 1;
    curve_number++;
  }

  // Get number of curves
  if (instance == ge_mInstance_1) {
    unsigned int m = instance_mask;
    int noofcurves = 0;
    while (m) {
      m = m >> 1;
      noofcurves++;
    }
    grow_SetXYCurveNoOfCurves(object, noofcurves);
  }

  // Set default colors
  set_curve_default_color(instance, &curve_color, &fill_color);
  grow_SetXYCurveCurveColor(object, curve_number - 1, curve_color, fill_color);
  if (mark1_color != glow_eDrawType_Inherit
      || mark2_color != glow_eDrawType_Inherit)
    grow_SetXYCurveMarkColor(object, mark1_color, mark2_color);
  noofpoints = grow_GetTrendNoOfPoints(object);

  return 1;
}

int GeXY_Curve::disconnect(grow_tObject object)
{
  if (update_p) {
    gdh_UnrefObjectInfo(update_subid);
    update_p = 0;
  }
  if (hold_p) {
    gdh_UnrefObjectInfo(hold_subid);
    hold_p = 0;
  }
  if (noofpoints_p) {
    gdh_UnrefObjectInfo(noofpoints_subid);
    noofpoints_p = 0;
  }
  if (x_min_value_p) {
    gdh_UnrefObjectInfo(x_min_value_subid);
    x_min_value_p = 0;
  }
  if (x_max_value_p) {
    gdh_UnrefObjectInfo(x_max_value_subid);
    x_max_value_p = 0;
  }
  if (y_min_value_p) {
    gdh_UnrefObjectInfo(y_min_value_subid);
    y_min_value_p = 0;
  }
  if (y_max_value_p) {
    gdh_UnrefObjectInfo(y_max_value_subid);
    y_max_value_p = 0;
  }
  if (x_mark1_p) {
    gdh_UnrefObjectInfo(x_mark1_subid);
    x_mark1_p = 0;
  }
  if (x_mark2_p) {
    gdh_UnrefObjectInfo(x_mark2_subid);
    x_mark1_p = 0;
  }
  if (y_mark1_p) {
    gdh_UnrefObjectInfo(y_mark1_subid);
    y_mark1_p = 0;
  }
  if (y_mark2_p) {
    gdh_UnrefObjectInfo(y_mark2_subid);
    y_mark1_p = 0;
  }
  return 1;
}

int GeXY_Curve::scan(grow_tObject object)
{
  bool redraw = false;

  if (hold_p && !first_scan && *hold_p)
    return 1;

  if (!update_p)
    // Update every scan...
    redraw = true;

  if (first_scan && !(x_max_value_p && x_min_value_p)
      && fabs(x_max_value - x_min_value) > DBL_EPSILON)
    grow_SetXYCurveRangeX(object, curve_number - 1, x_min_value, x_max_value);
  if (first_scan && !(y_max_value_p && y_min_value_p)
      && fabs(y_max_value - y_min_value) > DBL_EPSILON)
    grow_SetXYCurveRangeY(object, curve_number - 1, y_min_value, y_max_value);

  if (x_max_value_p && x_min_value_p
      && (!feqf(*x_max_value_p, old_x_max_value)
             || !feqf(*x_min_value_p, old_x_min_value))) {
    if (fabsf(*x_max_value_p - *x_min_value_p) > FLT_EPSILON) {
      grow_SetXYCurveRangeX(object, curve_number - 1, double(*x_min_value_p),
          double(*x_max_value_p));
      redraw = true;
    }
    old_x_min_value = *x_min_value_p;
    old_x_max_value = *x_max_value_p;
    x_min_value = *x_min_value_p;
    x_max_value = *x_max_value_p;
  }

  if (y_max_value_p && y_min_value_p
      && (!feqf(*y_max_value_p, old_y_max_value)
             || !feqf(*y_min_value_p, old_y_min_value))) {
    if (fabsf(*y_max_value_p - *y_min_value_p) > FLT_EPSILON) {
      grow_SetXYCurveRangeY(object, curve_number - 1, double(*y_min_value_p),
          double(*y_max_value_p));
      redraw = true;
    }
    old_y_min_value = *y_min_value_p;
    old_y_max_value = *y_max_value_p;
    y_min_value = *y_min_value_p;
    y_max_value = *y_max_value_p;
  }

  if (x_mark1_p
      && (first_scan || fabsf(*x_mark1_p - old_x_mark1) > FLT_EPSILON)) {
    grow_SetXYCurveXMark1(object, *x_mark1_p);
    old_x_mark1 = *x_mark1_p;
  }
  if (x_mark2_p
      && (first_scan || fabsf(*x_mark2_p - old_x_mark2) > FLT_EPSILON)) {
    grow_SetXYCurveXMark2(object, *x_mark2_p);
    old_x_mark2 = *x_mark2_p;
  }
  if (y_mark1_p
      && (first_scan || fabsf(*y_mark1_p - old_y_mark1) > FLT_EPSILON)) {
    grow_SetXYCurveYMark1(object, *y_mark1_p);
    old_y_mark1 = *y_mark1_p;
  }
  if (y_mark2_p
      && (first_scan || fabsf(*y_mark2_p - old_y_mark2) > FLT_EPSILON)) {
    grow_SetXYCurveYMark2(object, *y_mark2_p);
    old_y_mark2 = *y_mark2_p;
  }

  if (noofpoints_p && *noofpoints_p != old_noofpoints) {
    redraw = true;
    old_noofpoints = *noofpoints_p;
  }

  if (update_p) {
    if (*update_p && !old_update)
      redraw = true;
    old_update = *update_p;
  }

  if (first_scan || redraw) {
    int attr_type_x;
    int attr_type_y = 0;
    int attr_size;
    int attr_elem;
    pwr_tAName parsed_name;
    int sts;
    int inverted;
    void* x_value = 0;
    void* y_value = 0;
    double* x_trendvalue;
    double* y_trendvalue;
    int no_of_points;
    int j;

    if (noofpoints_p)
      no_of_points = MIN(noofpoints, *noofpoints_p);
    else
      no_of_points = noofpoints;

    if (!no_of_points)
      return 1;

    if (x_attr[0] == '&') {
      // Attribute starting with '&' indicates reference
      pwr_tAName refname;
      dyn->parse_attr_name(
          x_attr, refname, &inverted, &attr_type_x, &attr_size, &attr_elem);
      sts = dyn->graph->get_reference_name(refname, parsed_name);
      if (EVEN(sts))
        return 1;
    } else {
      dyn->parse_attr_name(
          x_attr, parsed_name, &inverted, &attr_type_x, &attr_size, &attr_elem);
    }
    if (attr_elem == 0)
      return 1;

    x_value = calloc(MAX(attr_elem, no_of_points), attr_size / attr_elem);

    sts = gdh_GetObjectInfo(parsed_name, x_value, attr_size);
    if (EVEN(sts))
      return 1;

    switch (datatype) {
    case ge_eCurveDataType_XYArrays:
      if (y_attr[0] == '&') {
        // Attribute starting with '&' indicates reference
        pwr_tAName refname;
        dyn->parse_attr_name(
            y_attr, refname, &inverted, &attr_type_y, &attr_size, &attr_elem);
        sts = dyn->graph->get_reference_name(refname, parsed_name);
        if (EVEN(sts))
          return 1;
      } else {
        dyn->parse_attr_name(y_attr, parsed_name, &inverted, &attr_type_y,
            &attr_size, &attr_elem);
      }
      y_value = calloc(MAX(attr_elem, no_of_points), attr_size / attr_elem);
      sts = gdh_GetObjectInfo(parsed_name, y_value, attr_size);
      if (EVEN(sts))
        return 1;
      break;
    case ge_eCurveDataType_TableObject:
      no_of_points = (int)(((pwr_tFloat32*)x_value)[0] + FLT_EPSILON);
      no_of_points = MIN(noofpoints, no_of_points);
    default:;
    }

    if (horizontal_padding)
      no_of_points += 2;

    x_trendvalue = (double*)malloc(no_of_points * sizeof(double));
    y_trendvalue = (double*)malloc(no_of_points * sizeof(double));

    switch (datatype) {
    case ge_eCurveDataType_XYArrays:
      for (int i = 0; i < no_of_points; i++) {
        if (horizontal_padding) {
          if (i == 0)
            j = 0;
          else if (i == no_of_points - 1)
            j = i - 2;
          else
            j = i - 1;
        } else
          j = i;

        switch (attr_type_x) {
        case pwr_eType_Float32:
          x_trendvalue[i] = ((pwr_tFloat32*)x_value)[j];
          break;
        case pwr_eType_Float64:
          x_trendvalue[i] = ((pwr_tFloat64*)x_value)[j];
          break;
        case pwr_eType_Int32:
          x_trendvalue[i] = ((pwr_tInt32*)x_value)[j];
          break;
        case pwr_eType_Int16:
          x_trendvalue[i] = ((pwr_tInt16*)x_value)[j];
          break;
        case pwr_eType_Int8:
          x_trendvalue[i] = ((pwr_tInt8*)x_value)[j];
          break;
        case pwr_eType_UInt32:
          x_trendvalue[i] = ((pwr_tUInt32*)x_value)[j];
          break;
        case pwr_eType_UInt16:
          x_trendvalue[i] = ((pwr_tUInt16*)x_value)[j];
          break;
        case pwr_eType_UInt8:
          x_trendvalue[i] = ((pwr_tUInt8*)x_value)[j];
          break;
        default:;
        }
        switch (attr_type_y) {
        case pwr_eType_Float32:
          y_trendvalue[i] = ((pwr_tFloat32*)y_value)[j];
          break;
        case pwr_eType_Float64:
          y_trendvalue[i] = ((pwr_tFloat64*)y_value)[j];
          break;
        case pwr_eType_Int32:
          y_trendvalue[i] = ((pwr_tInt32*)y_value)[j];
          break;
        case pwr_eType_Int16:
          y_trendvalue[i] = ((pwr_tInt16*)y_value)[j];
          break;
        case pwr_eType_Int8:
          y_trendvalue[i] = ((pwr_tInt8*)y_value)[j];
          break;
        case pwr_eType_UInt32:
          y_trendvalue[i] = ((pwr_tUInt32*)y_value)[j];
          break;
        case pwr_eType_UInt16:
          y_trendvalue[i] = ((pwr_tUInt16*)y_value)[j];
          break;
        case pwr_eType_UInt8:
          y_trendvalue[i] = ((pwr_tUInt8*)y_value)[j];
          break;
        default:;
        }
      }
      if (horizontal_padding) {
        x_trendvalue[0] = x_min_value;
        x_trendvalue[no_of_points - 1] = x_max_value;
      }
      free(y_value);
      free(x_value);
      break;
    case ge_eCurveDataType_PointArray:
      for (int i = 0; i < no_of_points; i++) {
        if (horizontal_padding) {
          if (i == 0)
            j = 0;
          else if (i == no_of_points - 1)
            j = i - 2;
          else
            j = i - 1;
        } else
          j = i;

        switch (attr_type_x) {
        case pwr_eType_Float32:
          x_trendvalue[i] = ((pwr_tFloat32*)x_value)[2 * j];
          y_trendvalue[i] = ((pwr_tFloat32*)x_value)[2 * j + 1];
          break;
        case pwr_eType_Float64:
          x_trendvalue[i] = ((pwr_tFloat64*)x_value)[2 * j];
          y_trendvalue[i] = ((pwr_tFloat64*)x_value)[2 * j + 1];
          break;
        case pwr_eType_Int32:
          x_trendvalue[i] = ((pwr_tInt32*)x_value)[2 * j];
          y_trendvalue[i] = ((pwr_tInt32*)x_value)[2 * j + 1];
          break;
        case pwr_eType_Int16:
          x_trendvalue[i] = ((pwr_tInt16*)x_value)[2 * j];
          y_trendvalue[i] = ((pwr_tInt16*)x_value)[2 * j + 1];
          break;
        case pwr_eType_Int8:
          x_trendvalue[i] = ((pwr_tInt8*)x_value)[2 * j];
          y_trendvalue[i] = ((pwr_tInt8*)x_value)[2 * j + 1];
          break;
        case pwr_eType_UInt32:
          x_trendvalue[i] = ((pwr_tUInt32*)x_value)[2 * j];
          y_trendvalue[i] = ((pwr_tUInt32*)x_value)[2 * j + 1];
          break;
        case pwr_eType_UInt16:
          x_trendvalue[i] = ((pwr_tUInt16*)x_value)[2 * j];
          y_trendvalue[i] = ((pwr_tUInt16*)x_value)[2 * j + 1];
          break;
        case pwr_eType_UInt8:
          x_trendvalue[i] = ((pwr_tUInt8*)x_value)[2 * j];
          y_trendvalue[i] = ((pwr_tUInt8*)x_value)[2 * j + 1];
          break;
        default:;
        }
      }
      if (horizontal_padding) {
        x_trendvalue[0] = x_min_value;
        x_trendvalue[no_of_points - 1] = x_max_value;
      }
      free(x_value);
      break;
    case ge_eCurveDataType_TableObject:
      for (int i = 0; i < no_of_points; i++) {
        if (horizontal_padding) {
          if (i == 0)
            j = 0;
          else if (i == no_of_points - 1)
            j = i - 2;
          else
            j = i - 1;
        } else
          j = i;

        switch (attr_type_x) {
        case pwr_eType_Float32:
          x_trendvalue[i] = ((pwr_tFloat32*)x_value)[2 * j + 1];
          y_trendvalue[i] = ((pwr_tFloat32*)x_value)[2 * j + 2];
          break;
        default:;
        }
      }
      if (horizontal_padding) {
        x_trendvalue[0] = x_min_value;
        x_trendvalue[no_of_points - 1] = x_max_value;
      }
      free(x_value);
      break;
    }

    grow_SetXYCurveData(
        object, y_trendvalue, x_trendvalue, curve_number - 1, no_of_points);
    free(y_trendvalue);
    free(x_trendvalue);
  }

  if (first_scan)
    first_scan = false;

  return 1;
}

int GeXY_Curve::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  glow_eDrawType ccolor = curve_color;
  glow_eDrawType fcolor = fill_color;
  noofpoints = grow_GetTrendNoOfPoints(object);
  int fill_curve = grow_GetTrendFillCurve(object);

  set_curve_default_color(instance, &ccolor, &fcolor);

  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynXYCurve(" << var_name << ".dd, \"" << x_attr << "\",\""
     << y_attr << "\",\"" << y_minvalue_attr << "\",\"" << y_maxvalue_attr
     << "\",\"" << x_minvalue_attr << "\",\"" << x_maxvalue_attr << "\",\""
     << noofpoints_attr << "\",\"" << update_attr << "\"," << y_min_value << ","
     << y_max_value << "," << x_min_value << "," << x_max_value << ","
     << noofpoints << "," << (int)datatype << "," << (int)ccolor << ","
     << (int)fcolor << "," << fill_curve << ")\n";
  return 1;
}

int GeXY_Curve::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  char name[40];
  char atext[60];

  if (instance == 1)
    strcpy(name, "XY_Curve");
  else
    sprintf(name, "XY_Curve%d", GeDyn::instance_to_number(instance));

  int types[] = { pwr_eType_Int8, pwr_eType_Int16, pwr_eType_Int32,
    pwr_eType_UInt8, pwr_eType_UInt16, pwr_eType_UInt32, pwr_eType_Float32, 0 };
  int types1[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32, 0 };
  int types2[] = { pwr_eType_Int32, pwr_eType_UInt32, 0 };
  int types3[] = { pwr_eType_Float32, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase__ };

  sprintf(atext, "%s.UpdateAttr", name);
  dyn->syntax_check_attribute(
      object, atext, update_attr, 1, types1, databases, error_cnt, warning_cnt);
  sprintf(atext, "%s.NoOfPointsAttr", name);
  dyn->syntax_check_attribute(object, atext, noofpoints_attr, 1, types2,
      databases, error_cnt, warning_cnt);
  sprintf(atext, "%s.XMinValueAttr", name);
  dyn->syntax_check_attribute(object, atext, x_minvalue_attr, 1, types3,
      databases, error_cnt, warning_cnt);
  sprintf(atext, "%s.XMaxValueAttr", name);
  dyn->syntax_check_attribute(object, atext, x_maxvalue_attr, 1, types3,
      databases, error_cnt, warning_cnt);
  sprintf(atext, "%s.YMinValueAttr", name);
  dyn->syntax_check_attribute(object, atext, y_minvalue_attr, 1, types3,
      databases, error_cnt, warning_cnt);
  sprintf(atext, "%s.YMaxValueAttr", name);
  dyn->syntax_check_attribute(object, atext, y_maxvalue_attr, 1, types3,
      databases, error_cnt, warning_cnt);
  sprintf(atext, "%s.XMark1Attr", name);
  dyn->syntax_check_attribute(object, atext, x_mark1_attr, 1, types3, databases,
      error_cnt, warning_cnt);
  sprintf(atext, "%s.XMark2Attr", name);
  dyn->syntax_check_attribute(object, atext, x_mark2_attr, 1, types3, databases,
      error_cnt, warning_cnt);
  sprintf(atext, "%s.YMark1Attr", name);
  dyn->syntax_check_attribute(object, atext, y_mark1_attr, 1, types3, databases,
      error_cnt, warning_cnt);
  sprintf(atext, "%s.YMark2Attr", name);
  dyn->syntax_check_attribute(object, atext, y_mark2_attr, 1, types3, databases,
      error_cnt, warning_cnt);
  sprintf(atext, "%s.XAttr", name);
  dyn->syntax_check_attribute(
      object, atext, x_attr, 0, types, databases, error_cnt, warning_cnt);
  if (datatype == ge_eCurveDataType_XYArrays) {
    sprintf(atext, "%s.YAttr", name);
    dyn->syntax_check_attribute(
        object, atext, y_attr, 0, types, databases, error_cnt, warning_cnt);
  } else if (!streq(y_attr, "")) {
    dyn->graph->syntax_msg(
        'W', object, "XY_Curve.YAttr not used for this DataType");
    (*warning_cnt)++;
  }
  return 1;
}

GeTable::GeTable(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_Table, ge_mDynType2_No, ge_mActionType1_No,
          ge_mActionType2_No, ge_eDynPrio_Table)
{
  memset(attribute, 0, sizeof(attribute));
  memset(format, 0, sizeof(format));
  memset(sel_attribute, 0, sizeof(sel_attribute));
  memset(old_value, 0, sizeof(old_value));
  memset(is_headerref, 0, sizeof(is_headerref));
  memset(headerref_p, 0, sizeof(headerref_p));
  memset(sel_elements, 0, sizeof(sel_elements));
  memset(bitmask, 0, sizeof(bitmask));
}

GeTable::GeTable(const GeTable& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio)
{
  memcpy(attribute, x.attribute, sizeof(attribute));
  memcpy(format, x.format, sizeof(format));
  memcpy(sel_attribute, x.sel_attribute, sizeof(sel_attribute));
  memset(is_headerref, 0, sizeof(is_headerref));
  memset(headerref_p, 0, sizeof(headerref_p));
}

void GeTable::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "Column1.Attribute");
  attrinfo[i].value = attribute[0];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute[0]);

  strcpy(attrinfo[i].name, "Column1.Format");
  attrinfo[i].value = format[0];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(format[0]);

  strcpy(attrinfo[i].name, "Column1.SelectAttribute");
  attrinfo[i].value = sel_attribute[0];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(sel_attribute[0]);

  strcpy(attrinfo[i].name, "Column2.Attribute");
  attrinfo[i].value = attribute[1];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute[0]);

  strcpy(attrinfo[i].name, "Column2.Format");
  attrinfo[i].value = format[1];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(format[0]);

  strcpy(attrinfo[i].name, "Column2.SelectAttribute");
  attrinfo[i].value = sel_attribute[1];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(sel_attribute[0]);

  strcpy(attrinfo[i].name, "Column3.Attribute");
  attrinfo[i].value = attribute[2];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute[0]);

  strcpy(attrinfo[i].name, "Column3.Format");
  attrinfo[i].value = format[2];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(format[0]);

  strcpy(attrinfo[i].name, "Column3.SelectAttribute");
  attrinfo[i].value = sel_attribute[2];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(sel_attribute[0]);

  strcpy(attrinfo[i].name, "Column4.Attribute");
  attrinfo[i].value = attribute[3];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute[0]);

  strcpy(attrinfo[i].name, "Column4.Format");
  attrinfo[i].value = format[3];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(format[0]);

  strcpy(attrinfo[i].name, "Column4.SelectAttribute");
  attrinfo[i].value = sel_attribute[3];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(sel_attribute[0]);

  strcpy(attrinfo[i].name, "Column5.Attribute");
  attrinfo[i].value = attribute[4];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute[0]);

  strcpy(attrinfo[i].name, "Column5.Format");
  attrinfo[i].value = format[4];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(format[0]);

  strcpy(attrinfo[i].name, "Column5.SelectAttribute");
  attrinfo[i].value = sel_attribute[4];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(sel_attribute[0]);

  strcpy(attrinfo[i].name, "Column6.Attribute");
  attrinfo[i].value = attribute[5];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute[0]);

  strcpy(attrinfo[i].name, "Column6.Format");
  attrinfo[i].value = format[5];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(format[0]);

  strcpy(attrinfo[i].name, "Column6.SelectAttribute");
  attrinfo[i].value = sel_attribute[5];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(sel_attribute[0]);

  strcpy(attrinfo[i].name, "Column7.Attribute");
  attrinfo[i].value = attribute[6];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute[0]);

  strcpy(attrinfo[i].name, "Column7.Format");
  attrinfo[i].value = format[6];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(format[0]);

  strcpy(attrinfo[i].name, "Column7.SelectAttribute");
  attrinfo[i].value = sel_attribute[6];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(sel_attribute[0]);

  strcpy(attrinfo[i].name, "Column8.Attribute");
  attrinfo[i].value = attribute[7];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute[0]);

  strcpy(attrinfo[i].name, "Column8.Format");
  attrinfo[i].value = format[7];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(format[0]);

  strcpy(attrinfo[i].name, "Column8.SelectAttribute");
  attrinfo[i].value = sel_attribute[7];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(sel_attribute[0]);

  strcpy(attrinfo[i].name, "Column9.Attribute");
  attrinfo[i].value = attribute[8];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute[0]);

  strcpy(attrinfo[i].name, "Column9.Format");
  attrinfo[i].value = format[8];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(format[0]);

  strcpy(attrinfo[i].name, "Column9.SelectAttribute");
  attrinfo[i].value = sel_attribute[8];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(sel_attribute[0]);

  strcpy(attrinfo[i].name, "Column10.Attribute");
  attrinfo[i].value = attribute[9];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute[0]);

  strcpy(attrinfo[i].name, "Column10.Format");
  attrinfo[i].value = format[9];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(format[0]);

  strcpy(attrinfo[i].name, "Column10.SelectAttribute");
  attrinfo[i].value = sel_attribute[9];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(sel_attribute[0]);

  strcpy(attrinfo[i].name, "Column11.Attribute");
  attrinfo[i].value = attribute[10];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute[0]);

  strcpy(attrinfo[i].name, "Column11.Format");
  attrinfo[i].value = format[10];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(format[0]);

  strcpy(attrinfo[i].name, "Column11.SelectAttribute");
  attrinfo[i].value = sel_attribute[10];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(sel_attribute[0]);

  strcpy(attrinfo[i].name, "Column12.Attribute");
  attrinfo[i].value = attribute[11];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute[0]);

  strcpy(attrinfo[i].name, "Column12.Format");
  attrinfo[i].value = format[11];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(format[0]);

  strcpy(attrinfo[i].name, "Column12.SelectAttribute");
  attrinfo[i].value = sel_attribute[11];
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(sel_attribute[0]);

  *item_count = i;
}

void GeTable::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute[0], attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "Column1.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeTable::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  for (int i = 0; i < TABLE_MAX_COL; i++)
    GeDyn::replace_attribute(
        attribute[i], sizeof(attribute[0]), from, to, cnt, strict);
}

void GeTable::save(std::ofstream& fp)
{
  fp << int(ge_eSave_Table) << '\n';
  for (int i = 0; i < TABLE_MAX_COL; i++) {
    fp << int(ge_eSave_Table_attribute1) + 3 * i << FSPACE << attribute[i]
       << '\n';
    fp << int(ge_eSave_Table_format1) + 3 * i << FSPACE << format[i] << '\n';
    fp << int(ge_eSave_Table_sel_attribute1) + 3 * i << FSPACE
       << sel_attribute[i] << '\n';
  }
  fp << int(ge_eSave_End) << '\n';
}

void GeTable::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeTable: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_Table:
      break;
    case ge_eSave_Table_attribute1:
      fp.get();
      fp.getline(attribute[0], sizeof(attribute[0]));
      break;
    case ge_eSave_Table_format1:
      fp.get();
      fp.getline(format[0], sizeof(format[0]));
      break;
    case ge_eSave_Table_sel_attribute1:
      fp.get();
      fp.getline(sel_attribute[0], sizeof(sel_attribute[0]));
      break;
    case ge_eSave_Table_attribute2:
      fp.get();
      fp.getline(attribute[1], sizeof(attribute[0]));
      break;
    case ge_eSave_Table_format2:
      fp.get();
      fp.getline(format[1], sizeof(format[0]));
      break;
    case ge_eSave_Table_sel_attribute2:
      fp.get();
      fp.getline(sel_attribute[1], sizeof(sel_attribute[0]));
      break;
    case ge_eSave_Table_attribute3:
      fp.get();
      fp.getline(attribute[2], sizeof(attribute[0]));
      break;
    case ge_eSave_Table_format3:
      fp.get();
      fp.getline(format[2], sizeof(format[0]));
      break;
    case ge_eSave_Table_sel_attribute3:
      fp.get();
      fp.getline(sel_attribute[2], sizeof(sel_attribute[0]));
      break;
    case ge_eSave_Table_attribute4:
      fp.get();
      fp.getline(attribute[3], sizeof(attribute[0]));
      break;
    case ge_eSave_Table_format4:
      fp.get();
      fp.getline(format[3], sizeof(format[0]));
      break;
    case ge_eSave_Table_sel_attribute4:
      fp.get();
      fp.getline(sel_attribute[3], sizeof(sel_attribute[0]));
      break;
    case ge_eSave_Table_attribute5:
      fp.get();
      fp.getline(attribute[4], sizeof(attribute[0]));
      break;
    case ge_eSave_Table_format5:
      fp.get();
      fp.getline(format[4], sizeof(format[0]));
      break;
    case ge_eSave_Table_sel_attribute5:
      fp.get();
      fp.getline(sel_attribute[4], sizeof(sel_attribute[0]));
      break;
    case ge_eSave_Table_attribute6:
      fp.get();
      fp.getline(attribute[5], sizeof(attribute[0]));
      break;
    case ge_eSave_Table_format6:
      fp.get();
      fp.getline(format[5], sizeof(format[0]));
      break;
    case ge_eSave_Table_sel_attribute6:
      fp.get();
      fp.getline(sel_attribute[5], sizeof(sel_attribute[0]));
      break;
    case ge_eSave_Table_attribute7:
      fp.get();
      fp.getline(attribute[6], sizeof(attribute[0]));
      break;
    case ge_eSave_Table_format7:
      fp.get();
      fp.getline(format[6], sizeof(format[0]));
      break;
    case ge_eSave_Table_sel_attribute7:
      fp.get();
      fp.getline(sel_attribute[6], sizeof(sel_attribute[0]));
      break;
    case ge_eSave_Table_attribute8:
      fp.get();
      fp.getline(attribute[7], sizeof(attribute[0]));
      break;
    case ge_eSave_Table_format8:
      fp.get();
      fp.getline(format[7], sizeof(format[0]));
      break;
    case ge_eSave_Table_sel_attribute8:
      fp.get();
      fp.getline(sel_attribute[7], sizeof(sel_attribute[0]));
      break;
    case ge_eSave_Table_attribute9:
      fp.get();
      fp.getline(attribute[8], sizeof(attribute[0]));
      break;
    case ge_eSave_Table_format9:
      fp.get();
      fp.getline(format[8], sizeof(format[0]));
      break;
    case ge_eSave_Table_sel_attribute9:
      fp.get();
      fp.getline(sel_attribute[8], sizeof(sel_attribute[0]));
      break;
    case ge_eSave_Table_attribute10:
      fp.get();
      fp.getline(attribute[9], sizeof(attribute[0]));
      break;
    case ge_eSave_Table_format10:
      fp.get();
      fp.getline(format[9], sizeof(format[0]));
      break;
    case ge_eSave_Table_sel_attribute10:
      fp.get();
      fp.getline(sel_attribute[9], sizeof(sel_attribute[0]));
      break;
    case ge_eSave_Table_attribute11:
      fp.get();
      fp.getline(attribute[10], sizeof(attribute[0]));
      break;
    case ge_eSave_Table_format11:
      fp.get();
      fp.getline(format[10], sizeof(format[0]));
      break;
    case ge_eSave_Table_sel_attribute11:
      fp.get();
      fp.getline(sel_attribute[10], sizeof(sel_attribute[0]));
      break;
    case ge_eSave_Table_attribute12:
      fp.get();
      fp.getline(attribute[11], sizeof(attribute[0]));
      break;
    case ge_eSave_Table_format12:
      fp.get();
      fp.getline(format[11], sizeof(format[0]));
      break;
    case ge_eSave_Table_sel_attribute12:
      fp.get();
      fp.getline(sel_attribute[11], sizeof(sel_attribute[0]));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeTable:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeTable::connect(grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type;
  int attr_size;
  pwr_tAName parsed_name;
  int sts;
  int inverted;
  glow_sTableInfo info;

  grow_GetTableInfo(object, &info);
  columns = info.columns;
  rows = info.rows;

  for (int i = 0; i < columns; i++) {
    p[i] = 0;
    db[i] = dyn->parse_attr_name(attribute[i], (char*)parsed_name, &inverted,
        &attr_type, &size[i], &elements[i]);
    if (streq(parsed_name, ""))
      continue;

    if (!elements[i])
      continue;

    if (attr_type == graph_eType_Bit)
      get_bit(parsed_name, attr_type, &bitmask[i]);

    size[i] = size[i] / elements[i];
    int col_size = size[i] * MIN(rows, elements[i]);

    elements[i] = MIN(elements[i], rows);

    if (!str_StartsWith(parsed_name, "$header.")) {
      switch (db[i]) {
      case graph_eDatabase_Gdh:
        sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
            (void**)&p[i], &subid[i], col_size, object, now);
        if (EVEN(sts))
          return sts;
        type_id[i] = attr_type;
        break;
      default:;
      }
    } else {
      int h_attr_type;
      int h_attr_size;
      pwr_tAName h_parsed_name;
      int h_inverted;
      int h_elements;
      pwr_tObjid* objid_value;
      pwr_tOName name;

      // Replace $header with the object in the header column
      is_headerref[i] = 1;
      elements[i] = elements[0];
      type_id[i] = attr_type;
      headerref_p[i] = (char**)calloc(elements[i], sizeof(char*));
      headerref_subid[i] = (pwr_tSubid*)calloc(elements[i], sizeof(pwr_tSubid));

      dyn->parse_attr_name(attribute[0], (char*)h_parsed_name, &h_inverted,
          &h_attr_type, &h_attr_size, &h_elements);
      objid_value = (pwr_tObjid*)calloc(h_elements, sizeof(pwr_tObjid));
      sts = gdh_GetObjectInfo(
          h_parsed_name, objid_value, h_elements * sizeof(pwr_tObjid));
      if (EVEN(sts))
        continue;

      for (int j = 0; j < elements[i]; j++) {
        if (cdh_ObjidIsNotNull(objid_value[j])) {
          sts = gdh_ObjidToName(
              objid_value[j], name, sizeof(name), cdh_mName_volumeStrict);
          if (EVEN(sts))
            continue;

          strcat(name, &parsed_name[7]);
          type_id[i] = attr_type;
          sts = dyn->graph->ref_object_info(dyn->cycle, name,
              (void**)&headerref_p[i][j], &headerref_subid[i][j], size[i],
              object, now);
          if (EVEN(sts))
            return sts;
        }
      }
    }

    switch (type_id[i]) {
    case pwr_eType_String:
      info.column_size[i] = size[i];
      break;
    case pwr_eType_Status:
    case pwr_eType_NetStatus:
      info.column_size[i] = 80;
      break;
    case pwr_eType_Time:
    case pwr_eType_DeltaTime:
      info.column_size[i] = 25;
      break;
    case pwr_eType_Objid:
      switch (format[i][1]) {
      case '1':
      case '2':
        info.column_size[i] = 200;
        break;
      default:
        info.column_size[i] = 40;
      }
      break;
    case pwr_eType_AttrRef:
      switch (format[i][1]) {
      case '1':
      case '2':
        info.column_size[i] = 400;
        break;
      default:
        info.column_size[i] = 80;
      }
      break;
    default:
      info.column_size[i] = 10;
    }

    old_value[i] = (char*)calloc(elements[i], size[i]);

    // Connect select array
    sel_p[i] = 0;
    sel_db[i] = dyn->parse_attr_name(sel_attribute[i], (char*)parsed_name,
        &inverted, &attr_type, &attr_size, &sel_elements[i]);
    if (streq(parsed_name, ""))
      continue;

    if (sel_elements[i] > elements[i])
      sel_elements[i] = elements[i];
    if (attr_type != pwr_eType_Boolean || !sel_elements[i])
      continue;

    switch (sel_db[i]) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&sel_p[i], &sel_subid[i],
          sel_elements[i] * sizeof(pwr_tBoolean), object, now);
      if (EVEN(sts))
        return sts;
      break;
    default:;
    }
  }

  grow_SetTableInfo(object, &info);

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeTable::disconnect(grow_tObject object)
{
  for (int i = 0; i < columns; i++) {
    if (p[i] && db[i] == graph_eDatabase_Gdh)
      gdh_UnrefObjectInfo(subid[i]);
    p[i] = 0;
    if (old_value[i]) {
      free(old_value[i]);
      old_value[i] = 0;
    }

    if (sel_p[i] && sel_db[i] == graph_eDatabase_Gdh)
      gdh_UnrefObjectInfo(sel_subid[i]);
    sel_p[i] = 0;

    if (is_headerref[i]) {
      for (int j = 0; j < elements[i]; j++) {
        if (headerref_p[i][j])
          gdh_UnrefObjectInfo(headerref_subid[i][j]);
      }
      free(headerref_p[i]);
      free(headerref_subid[i]);
    }
  }
  return 1;
}

int GeTable::scan(grow_tObject object)
{
  if (!p[0])
    return 1;

  int i, j, offs;
  char buf[256];
  int len;

  grow_SetDeferedRedraw(dyn->graph->grow->ctx);
  for (i = 0; i < columns; i++) {
    if (is_headerref[i]) {
      for (j = 0; j < elements[i]; j++) {
        if (!headerref_p[i][j])
          continue;

        offs = j * size[i];
        if (!first_scan) {
          if (memcmp(old_value[i] + offs, headerref_p[i][j], size[i]) == 0)
            // No change since last time
            continue;
        }

        switch (type_id[i]) {
        case pwr_eType_Float32:
          len = sprintf(buf, format[i], *(pwr_tFloat32*)headerref_p[i][j]);
          break;
        case pwr_eType_Int32:
        case pwr_eType_UInt32:
          len = sprintf(buf, format[i], *(pwr_tInt32*)headerref_p[i][j]);
          break;
        case pwr_eType_Int16:
        case pwr_eType_UInt16:
          len = sprintf(buf, format[i], *(pwr_tInt16*)headerref_p[i][j]);
          break;
        case pwr_eType_Status:
        case pwr_eType_NetStatus:
          if (*(pwr_tStatus*)headerref_p[i][j] == 0) {
            strcpy(buf, "");
            len = 0;
            break;
          }
          switch (format[i][1]) {
          case '1':
            // Format %1m: Write only the text
            msg_GetText(*(pwr_tStatus*)headerref_p[i][j], buf, sizeof(buf));
            break;
          default:
            msg_GetMsg(*(pwr_tStatus*)headerref_p[i][j], buf, sizeof(buf));
          }
          len = strlen(buf);
          break;
        case pwr_eType_String:
          len = sprintf(buf, format[i], (char*)headerref_p[i][j]);
          break;
        case pwr_eType_Objid: {
          int sts;
          pwr_tOName name;
          pwr_tObjid objid = *(pwr_tObjid*)headerref_p[i][j];

          switch (format[i][1]) {
          case '1':
            // Format %1o, write path
            sts = gdh_ObjidToName(
                objid, name, sizeof(name), cdh_mName_pathStrict);
            break;
          case '2':
            // Format %2o, write volume and path
            sts = gdh_ObjidToName(
                objid, name, sizeof(name), cdh_mName_volumeStrict);
            break;
          default:
            sts = gdh_ObjidToName(objid, name, sizeof(name), cdh_mName_object);
          }
          if (EVEN(sts))
            strcpy(name, "");
          len = sprintf(buf, "%s", name);
          break;
        }
        case pwr_eType_Time: {
          int sts;
          char timstr[40];

          if (memcmp(headerref_p[i][j], &pwr_cNTime, sizeof(pwr_tTime)) == 0)
            strcpy(timstr, "");
          else {
            switch (format[i][1]) {
            case '1':
              // Format %1t, only time, no hundredth
              sts = time_AtoAscii((pwr_tTime*)headerref_p[i][j],
                  time_eFormat_Time, timstr, sizeof(timstr));
              timstr[8] = 0;
              break;
            case '2':
              // Format %2t, only time, with hundredth
              sts = time_AtoAscii((pwr_tTime*)headerref_p[i][j],
                  time_eFormat_Time, timstr, sizeof(timstr));
              break;
            case '3':
              // Format %3t, compressed date and time, no hundredth
              sts = time_AtoAscii((pwr_tTime*)headerref_p[i][j],
                  time_eFormat_ComprDateAndTime, timstr, sizeof(timstr));
              timstr[17] = 0;
              break;
            case '4':
              // Format %4t, date only
              sts = time_AtoAscii((pwr_tTime*)headerref_p[i][j],
                  time_eFormat_DateAndTime, timstr, sizeof(timstr));
              timstr[11] = 0;
              break;
            case '5':
              // Format %5t, compressed date only
              sts = time_AtoAscii((pwr_tTime*)headerref_p[i][j],
                  time_eFormat_ComprDateAndTime, timstr, sizeof(timstr));
              timstr[8] = 0;
              break;
            case '6':
              // Format %6t, 01:00:00 30/01/87
              sts = time_AtoAscii((pwr_tTime*)headerref_p[i][j],
                  time_eFormat_TimeAndDate, timstr, sizeof(timstr));
              timstr[17] = 0;
              break;
            default:
              sts = time_AtoAscii((pwr_tTime*)headerref_p[i][j],
                  time_eFormat_DateAndTime, timstr, sizeof(timstr));
            }
            if (EVEN(sts))
              strcpy(timstr, "-");
          }
          len = sprintf(buf, "%s", timstr);
          break;
        }
        case pwr_eType_DeltaTime: {
          int sts;
          char timstr[40];

          switch (format[i][1]) {
          case '1':
            // Format %1t, only time, no hundredth
            sts = time_DtoAscii(
                (pwr_tDeltaTime*)headerref_p[i][j], 0, timstr, sizeof(timstr));
            break;
          default:
            sts = time_DtoAscii(
                (pwr_tDeltaTime*)headerref_p[i][j], 1, timstr, sizeof(timstr));
          }
          if (EVEN(sts))
            strcpy(timstr, "-");
          len = sprintf(buf, "%s", timstr);
          break;
        }
        case graph_eType_Bit:
          if (*(pwr_tMask*)headerref_p[i][j] & bitmask[i])
            strcpy(buf, "1");
          else
            strcpy(buf, "0");
          len = 1;
          break;
        default: {
          int sts;
          sts = cdh_AttrValueToString(
              (pwr_eType)type_id[i], headerref_p[i][j], buf, sizeof(buf));
          if (EVEN(sts))
            sprintf(buf, "Invalid type");
          len = strlen(buf);
        }
        }

        grow_SetCellValue(object, i, j, buf);
        memcpy(old_value[i] + offs, headerref_p[i][j], size[i]);
      }
    } else {
      if (!p[i])
        continue;
      for (j = 0; j < elements[i]; j++) {
        offs = j * size[i];
        if (!first_scan) {
          if (memcmp(old_value[i] + offs, p[i] + offs, size[i]) == 0)
            // No change since last time
            continue;
        }

        switch (type_id[i]) {
        case pwr_eType_Float32:
          len = sprintf(buf, format[i], *(pwr_tFloat32*)(p[i] + offs));
          break;
        case pwr_eType_Boolean:
        case pwr_eType_Int32:
        case pwr_eType_UInt32:
          len = sprintf(buf, format[i], *(pwr_tInt32*)(p[i] + offs));
          break;
        case pwr_eType_String:
          len = sprintf(buf, format[i], (char*)(p[i] + offs));
          break;
        case pwr_eType_Objid: {
          int sts;
          pwr_tOName name;
          pwr_tObjid objid = *(pwr_tObjid*)(p[i] + offs);
          switch (format[i][1]) {
          case '1':
            // Format %1o, write path
            sts = gdh_ObjidToName(
                objid, name, sizeof(name), cdh_mName_pathStrict);
            break;
          case '2':
            // Format %2o, write volume and path
            sts = gdh_ObjidToName(
                objid, name, sizeof(name), cdh_mName_volumeStrict);
            break;
          default:
            sts = gdh_ObjidToName(objid, name, sizeof(name), cdh_mName_object);
          }
          if (EVEN(sts))
            strcpy(name, "");
          len = sprintf(buf, "%s", name);
          break;
        }
        case pwr_eType_AttrRef: {
          int sts;
          pwr_tOName name;
          pwr_tAttrRef aref = *(pwr_tAttrRef*)(p[i] + offs);

          if (cdh_ObjidIsNull(aref.Objid))
            strcpy(name, "");
          else {
            switch (format[i][1]) {
            case '1':
              // Format %1o, write path
              sts = gdh_AttrrefToName(
                  &aref, name, sizeof(name), cdh_mName_pathStrict);
              break;
            case '2':
              // Format %2o, write volume and path
              sts = gdh_AttrrefToName(
                  &aref, name, sizeof(name), cdh_mName_volumeStrict);
              break;
            default:
              sts = gdh_AttrrefToName(&aref, name, sizeof(name),
                  cdh_mName_object | cdh_mName_attribute);
            }
            if (EVEN(sts))
              strcpy(name, "");
          }
          len = sprintf(buf, "%s", name);
          break;
        }
        case pwr_eType_Time: {
          int sts;
          char timstr[40];

          if (memcmp(p[i] + offs, &pwr_cNTime, sizeof(pwr_tTime)) == 0)
            strcpy(timstr, "");
          else {
            switch (format[i][1]) {
            case '1':
              // Format %1t, only time, no hundredth
              sts = time_AtoAscii((pwr_tTime*)(p[i] + offs), time_eFormat_Time,
                  timstr, sizeof(timstr));
              timstr[8] = 0;
              break;
            case '2':
              // Format %2t, only time, with hundredth
              sts = time_AtoAscii((pwr_tTime*)(p[i] + offs), time_eFormat_Time,
                  timstr, sizeof(timstr));
              break;
            case '3':
              // Format %3t, compressed date and time, no hundredth
              sts = time_AtoAscii((pwr_tTime*)(p[i] + offs),
                  time_eFormat_ComprDateAndTime, timstr, sizeof(timstr));
              timstr[17] = 0;
              break;
            case '4':
              // Format %4t, date only
              sts = time_AtoAscii((pwr_tTime*)p[i] + offs,
                  time_eFormat_DateAndTime, timstr, sizeof(timstr));
              timstr[11] = 0;
              break;
            case '5':
              // Format %5t, compressed date only
              sts = time_AtoAscii((pwr_tTime*)p[i] + offs,
                  time_eFormat_ComprDateAndTime, timstr, sizeof(timstr));
              timstr[8] = 0;
              break;
            case '6':
              // Format %6t, 01:00:00 30/01/87
              sts = time_AtoAscii((pwr_tTime*)p[i] + offs,
                  time_eFormat_TimeAndDate, timstr, sizeof(timstr));
              timstr[17] = 0;
              break;
            default:
              sts = time_AtoAscii((pwr_tTime*)(p[i] + offs),
                  time_eFormat_DateAndTime, timstr, sizeof(timstr));
            }
            if (EVEN(sts))
              strcpy(timstr, "-");
          }
          len = sprintf(buf, "%s", timstr);
          break;
        }
        case pwr_eType_DeltaTime: {
          int sts;
          char timstr[40];

          switch (format[i][1]) {
          case '1':
            // Format %1t, only time, no hundredth
            sts = time_DtoAscii(
                (pwr_tDeltaTime*)(p[i] + offs), 0, timstr, sizeof(timstr));
            break;
          default:
            sts = time_DtoAscii(
                (pwr_tDeltaTime*)(p[i] + offs), 1, timstr, sizeof(timstr));
          }
          if (EVEN(sts))
            strcpy(timstr, "-");
          len = sprintf(buf, "%s", timstr);
          break;
        }
        case graph_eType_Bit:
          if (*(pwr_tMask*)(p[i] + offs) & bitmask[i])
            strcpy(buf, "1");
          else
            strcpy(buf, "0");
          len = 1;
          break;
        default: {
          int sts;
          sts = cdh_AttrValueToString(
              (pwr_eType)type_id[i], p[i] + offs, buf, sizeof(buf));
          if (EVEN(sts))
            sprintf(buf, "Invalid type");
          len = strlen(buf);
        }
        }

        grow_SetCellValue(object, i, j, buf);
        memcpy(old_value[i] + offs, p[i] + offs, size[i]);
      }
    }
  }

  // Examine select array
  int sel_found = 0;
  for (i = 0; i < columns; i++) {
    if (!sel_p[i])
      continue;
    for (j = 0; j < sel_elements[i]; j++) {
      if (sel_p[i][j]) {
        sel_found = 1;
        grow_SetSelectedCell(object, i, j);
      }
    }
  }
  if (!sel_found)
    grow_SetSelectedCell(object, -1, -1);
  grow_RedrawDefered(dyn->graph->grow->ctx);
  if (first_scan)
    first_scan = false;
  return 1;
}

int GeTable::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetClickSensitivity(dyn->graph->grow->ctx, glow_mSensitivity_MB1Click);
    break;
  case glow_eEvent_MB1Up:
    break;
  case glow_eEvent_MB1Click: {
    int column, row;
    pwr_tBoolean value;
    int sts;
    pwr_tAName parsed_name;
    int inverted;
    int attr_type, attr_size;
    graph_eDatabase db;

    if (event->any.type != glow_eEventType_Table)
      break;

    sts = grow_GetSelectedCell(object, &column, &row);
    if (ODD(sts) && sel_p[column]) {
      // Reset previously selected
      db = dyn->parse_attr_name(sel_attribute[column], parsed_name, &inverted,
          &attr_type, &attr_size);
      value = 0;
      sprintf(&parsed_name[strlen(parsed_name)], "[%d]", row);
      sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
      if (EVEN(sts))
        printf("Table error: %s\n", parsed_name);
    }
    if (sel_p[event->table.column]
        && !(event->table.column == column && event->table.row == row)) {
      // Set new selected, if not same as previous selected
      db = dyn->parse_attr_name(sel_attribute[event->table.column], parsed_name,
          &inverted, &attr_type, &attr_size);
      value = 1;
      sprintf(&parsed_name[strlen(parsed_name)], "[%d]", event->table.row);
      sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
      if (EVEN(sts))
        printf("Table error: %s\n", parsed_name);
      else
        grow_SetSelectedCell(object, event->table.column, event->table.row);
    }
    break;
  }
  case glow_eEvent_Key_Up:
  case glow_eEvent_Key_Down:
  case glow_eEvent_Key_Left:
  case glow_eEvent_Key_Right: {
    int column, row, new_column = 0, new_row = 0;
    pwr_tBoolean value;
    int sts;
    pwr_tAName parsed_name;
    int inverted;
    int attr_type, attr_size;
    graph_eDatabase db;

    sts = grow_GetSelectedCell(object, &column, &row);

    switch (event->event) {
    case glow_eEvent_Key_Up:
      if (EVEN(sts))
        return GE__NO_PROPAGATE;
      new_row = row - 1;
      new_column = column;
      if (new_row < 0)
        return GE__NO_PROPAGATE;
      break;
    case glow_eEvent_Key_Down:
      if (EVEN(sts)) {
        column = 0;
        row = -1;
      }
      new_row = row + 1;
      new_column = column;
      if (new_row >= sel_elements[new_column])
        return GE__NO_PROPAGATE;
      break;
    case glow_eEvent_Key_Left:
      if (EVEN(sts))
        return GE__NO_PROPAGATE;
      new_row = row;
      new_column = column - 1;
      if (new_column < 0 || !sel_p[new_column])
        return GE__NO_PROPAGATE;
      break;
    case glow_eEvent_Key_Right:
      if (EVEN(sts)) {
        column = -1;
        row = 0;
      }
      new_row = row;
      new_column = column + 1;
      if (new_column >= columns || !sel_p[new_column])
        return GE__NO_PROPAGATE;
      break;
    default:;
    }

    if (ODD(sts) && sel_p[column]) {
      db = dyn->parse_attr_name(sel_attribute[column], parsed_name, &inverted,
          &attr_type, &attr_size);
      value = 0;
      sprintf(&parsed_name[strlen(parsed_name)], "[%d]", row);
      sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
      if (EVEN(sts))
        printf("Table error: %s\n", parsed_name);
    }
    if (sel_p[new_column]) {
      db = dyn->parse_attr_name(sel_attribute[new_column], parsed_name,
          &inverted, &attr_type, &attr_size);
      value = 1;
      sprintf(&parsed_name[strlen(parsed_name)], "[%d]", new_row);
      sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
      if (EVEN(sts))
        printf("Table error: %s\n", parsed_name);
      else {
        grow_SetSelectedCell(object, new_column, new_row);
        grow_TableMakeCellVisible(object, new_column, new_row);
      }
    }
    return GE__NO_PROPAGATE;
  }
  case glow_eEvent_MB3Press: {
    int sts;
    pwr_tAName parsed_name;
    int inverted;
    int attr_type, attr_size;
    pwr_sAttrRef attrref;
    char name[80];
    int x, y;

    if (event->any.type != glow_eEventType_Table)
      break;

    if (type_id[event->table.column] == pwr_eType_Objid) {
      dyn->parse_attr_name(attribute[event->table.column], parsed_name,
          &inverted, &attr_type, &attr_size);

      sprintf(&parsed_name[strlen(parsed_name)], "[%d]", event->table.row);
      memset(&attrref, 0, sizeof(attrref));
      sts = gdh_GetObjectInfo(
          parsed_name, &attrref.Objid, sizeof(attrref.Objid));
      if (EVEN(sts))
        break;
      if (cdh_ObjidIsNull(attrref.Objid))
        break;

      if (dyn->graph->popup_menu_cb) {
        // Display popup menu
        grow_GetName(dyn->graph->grow->ctx, name);

        dyn->graph->popup_position(
            event->any.x_pixel + 8, event->any.y_pixel, &x, &y);
        (dyn->graph->popup_menu_cb)(dyn->graph->parent_ctx, attrref,
            xmenu_eItemType_Object, xmenu_mUtility_Ge, name, x, y);
      }
    }
    break;
  }
  default:;
  }
  return 1;
}

int GeTable::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  glow_sTableInfo info;

  grow_GetTableInfo(object, &info);
  columns = info.columns;
  rows = info.rows;

  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynTable(" << var_name << ".dd, new String[] {";
  for (int i = 0; i < columns; i++) {
    if (i != 0)
      fp << ",";
    fp << "\"" << attribute[i] << "\"";
  }
  fp << "}, new String[] {";
  for (int i = 0; i < columns; i++) {
    if (i != 0)
      fp << ",";
    fp << "\"" << format[i] << "\"";
  }
  fp << "}, new String[] {";
  for (int i = 0; i < columns; i++) {
    if (i != 0)
      fp << ",";
    fp << "\"" << sel_attribute[i] << "\"";
  }
  fp << "}," << rows << "," << columns << ")\n";
  return 1;
}

int GeTable::syntax_check(grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int inverted;
  char atext[40];

  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    pwr_eType_Int64, pwr_eType_UInt64, graph_eType_Bit, pwr_eType_Float32,
    pwr_eType_Float64, pwr_eType_String, pwr_eType_NetStatus, pwr_eType_Status,
    pwr_eType_Text, pwr_eType_Objid, pwr_eType_AttrRef, pwr_eType_DataRef,
    pwr_eType_Time, pwr_eType_DeltaTime, pwr_eType_Enum, pwr_eType_Mask, 0 };
  int types1[] = { pwr_eType_Boolean, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase__ };

  for (int i = 0; i < TABLE_MAX_COL; i++) {
    sprintf(atext, "Column%d.Attribute", i + 1);
    dyn->syntax_check_attribute(object, atext, attribute[i], i == 0 ? 0 : 1,
        types, databases, error_cnt, warning_cnt);

    sprintf(atext, "Column%d.SelectAttribute", i + 1);
    dyn->syntax_check_attribute(object, atext, sel_attribute[i], 1, types1,
        databases, error_cnt, warning_cnt);

    // Check format

    if (!streq(attribute[i], "")) {
      dyn->parse_attr_name(
          attribute[i], parsed_name, &inverted, &attr_type, &attr_size);

      if (streq(format[i], "")) {
        char msg[200];

        sprintf(msg, "Column%d.Format, format is missing", i + 1);
        dyn->graph->syntax_msg('E', object, msg);
        (*error_cnt)++;
      }

      else if (!check_format(format[i], attr_type)) {
        char msg[200];

        sprintf(
            msg, "Column%d.Format, erroneous format \"%s\"", i + 1, format[i]);
        dyn->graph->syntax_msg('E', object, msg);
        (*warning_cnt)++;
      }
    }
  }
  return 1;
}

GeStatusColor::GeStatusColor(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_StatusColor, ge_mDynType2_No,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_StatusColor),
      nostatus_color(glow_eDrawType_Inherit), use_colortheme(0), on(true)
{
  strcpy(attribute, "");
}

GeStatusColor::GeStatusColor(const GeStatusColor& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      nostatus_color(x.nostatus_color), use_colortheme(x.use_colortheme)
{
  strcpy(attribute, x.attribute);
}

void GeStatusColor::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    strcpy(attrinfo[i].name, "StatusTone.Attribute");
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    strcpy(attrinfo[i].name, "StatusTone.NoStatusTone");
    attrinfo[i].value = &nostatus_color;
    attrinfo[i].type = glow_eType_ToneOrColor;
    attrinfo[i++].size = sizeof(nostatus_color);
  } else {
    strcpy(attrinfo[i].name, "StatusColor.Attribute");
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    strcpy(attrinfo[i].name, "StatusColor.NoStatusColor");
    attrinfo[i].value = &nostatus_color;
    attrinfo[i].type = glow_eType_Color;
    attrinfo[i++].size = sizeof(nostatus_color);

    strcpy(attrinfo[i].name, "StatusColor.UseColorTheme");
    attrinfo[i].value = &use_colortheme;
    attrinfo[i].type = glow_eType_Int;
    attrinfo[i++].size = sizeof(use_colortheme);
  }
  *item_count = i;
}

void GeStatusColor::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    if (dyn->total_dyn_type1 & ge_mDynType1_Tone)
      snprintf(msg, sizeof(msg), "StatusTone.Attribute = %s", attr_name);
    else
      snprintf(msg, sizeof(msg), "StatusColor.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeStatusColor::replace_attribute(
    char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

int GeStatusColor::set_color(grow_tObject object, glow_eDrawType color)
{
  char msg[200];

  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    this->nostatus_color = glow_eDrawType(color / 30);
    snprintf(msg, sizeof(msg), "StatusTone.NoStatusTone = %s",
        grow_ColorToneToName(this->nostatus_color));
  } else {
    this->nostatus_color = color;
    snprintf(msg, sizeof(msg), "StatusColor.NoStatusColor = %s",
        grow_ColorToName(this->nostatus_color));
  }
  msg[sizeof(msg) - 1] = 0;
  dyn->graph->message('I', msg);
  return 1;
}

void GeStatusColor::save(std::ofstream& fp)
{
  fp << int(ge_eSave_StatusColor) << '\n';
  fp << int(ge_eSave_StatusColor_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_StatusColor_nostatus_color) << FSPACE
     << int(nostatus_color) << '\n';
  fp << int(ge_eSave_StatusColor_use_colortheme) << FSPACE << use_colortheme
     << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeStatusColor::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  int tmp;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeStatusColor: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_StatusColor:
      break;
    case ge_eSave_StatusColor_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_StatusColor_nostatus_color:
      fp >> tmp;
      nostatus_color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_StatusColor_use_colortheme:
      fp >> use_colortheme;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeStatusColor:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeStatusColor::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_size;
  pwr_tAName parsed_name;
  int sts;
  int inverted;

  nostatus_color = dyn->get_color1(object, nostatus_color);
  if (nostatus_color < 0 || nostatus_color >= glow_eDrawType__) {
    printf("** Color out of range, %s\n", attribute);
    p = 0;
    return 0;
  }

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  sts = dyn->graph->ref_object_info(
      dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
  if (EVEN(sts))
    return sts;

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeStatusColor::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeStatusColor::scan(grow_tObject object)
{
  if (!p)
    return 1;

  if (db == graph_eDatabase_Gdh && attr_type == pwr_eType_NetStatus) {
    pwr_tTime t;
    pwr_tStatus sts;
    pwr_tBoolean old;

    gdh_GetSubscriptionOldness(subid, &old, &t, &sts);
    if (old)
      *p = PWR__NETTIMEOUT;
  }

  if (dyn->ignore_color)
    return 1;

  if (!first_scan && old_status != ge_ePwrStatus_Fatal) {
    if (old_value == *p && !dyn->reset_color)
      // No change since last time
      return 1;
  }

  old_value = *p;

  ge_ePwrStatus value;
  if (*p == pwr_cNStatus)
    value = ge_ePwrStatus_No;
  else {
    switch (*p & 7) {
    case 3:
    case 1:
      value = ge_ePwrStatus_Success;
      break;
    case 0:
      value = ge_ePwrStatus_Warning;
      break;
    case 2:
      value = ge_ePwrStatus_Error;
      break;
    case 4:
      value = ge_ePwrStatus_Fatal;
      break;
    default:
      value = ge_ePwrStatus_No;
    }
  }
  if (!first_scan && old_status == value && old_status != ge_ePwrStatus_Fatal)
    return 1;
  else
    first_scan = false;

  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    switch (value) {
    case ge_ePwrStatus_No:
      if (nostatus_color >= (glow_eDrawType)glow_eDrawTone__)
        grow_SetObjectFillColor(object, nostatus_color);
      else
        grow_SetObjectColorTone(object, (glow_eDrawTone)nostatus_color);
      break;
    case ge_ePwrStatus_Success:
      if (nostatus_color >= (glow_eDrawType)glow_eDrawTone__)
        grow_ResetObjectFillColor(object);
      grow_ResetObjectColorTone(object);
      break;
    case ge_ePwrStatus_Warning:
      grow_SetObjectColorTone(object, glow_eDrawTone_Yellow);
      break;
    case ge_ePwrStatus_Error:
      grow_SetObjectColorTone(object, glow_eDrawTone_Red);
      break;
    case ge_ePwrStatus_Fatal:
      on = !on;
      if (on)
        grow_SetObjectColorTone(object, glow_eDrawTone_Red);
      else {
        if (nostatus_color >= (glow_eDrawType)glow_eDrawTone__)
          grow_SetObjectFillColor(object, nostatus_color);
        else
          grow_SetObjectColorTone(object, (glow_eDrawTone)nostatus_color);
      }
      break;
    }
  } else {
    switch (value) {
    case ge_ePwrStatus_No:
      grow_SetObjectFillColor(object, nostatus_color);
      break;
    case ge_ePwrStatus_Success:
      grow_ResetObjectFillColor(object);
      break;
    case ge_ePwrStatus_Warning:
      grow_SetObjectFillColor(object, use_colortheme
              ? glow_eDrawType_CustomColor41
              : glow_eDrawType_ColorYellow);
      break;
    case ge_ePwrStatus_Error:
      grow_SetObjectFillColor(object, use_colortheme
              ? glow_eDrawType_CustomColor11
              : glow_eDrawType_ColorRed);
      break;
    case ge_ePwrStatus_Fatal:
      on = !on;
      if (on)
        grow_SetObjectFillColor(object, use_colortheme
                ? glow_eDrawType_CustomColor11
                : glow_eDrawType_ColorRed);
      else
        grow_SetObjectFillColor(object, nostatus_color);
      break;
    }
  }
  old_status = value;
  return 1;
}

int GeStatusColor::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  glow_eDrawType jcolor = dyn->get_color1(object, nostatus_color);
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynStatusColor(" << var_name << ".dd, \"" << attribute << "\","
     << jcolor << ")\n";
  return 1;
}

int GeStatusColor::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  glow_eDrawType tcolor = dyn->get_color1(object, nostatus_color);
  if (tcolor < 0 || tcolor >= glow_eDrawType__) {
    dyn->graph->syntax_msg('E', object, "Color out or range");
    (*error_cnt)++;
  }

  int types[] = { pwr_eType_Status, pwr_eType_NetStatus, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase__ };
  dyn->syntax_check_attribute(object, "StatusColor.Attribute", attribute, 0,
      types, databases, error_cnt, warning_cnt);

  return 1;
}

GePie::GePie(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_Pie, ge_mDynType2_No, ge_mActionType1_No,
          ge_mActionType2_No, ge_eDynPrio_Pie),
      sectors(0), min_value(0), max_value(0), fix_range(0)
{
  for (int i = 0; i < PIE_MAX_SECTORS; i++)
    strcpy(attribute[i], "");
}

GePie::GePie(const GePie& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      sectors(x.sectors), min_value(x.min_value), max_value(x.max_value),
      fix_range(x.fix_range)
{
  for (int i = 0; i < PIE_MAX_SECTORS; i++)
    strcpy(attribute[i], x.attribute[i]);
}

void GePie::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  for (int j = 0; j < PIE_MAX_SECTORS; j++) {
    sprintf(attrinfo[i].name, "Pie.Attribute%d", j+1);
    attrinfo[i].value = attribute[j];
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute[0]);
  }

  strcpy(attrinfo[i].name, "Pie.FixRange");
  attrinfo[i].value = &fix_range;
  attrinfo[i].type = glow_eType_Boolean;
  attrinfo[i++].size = sizeof(fix_range);

  *item_count = i;
}

void GePie::set_attribute(grow_tObject object, const char* attr_name, int* cnt)
{
  char msg[200];

  strncpy(attribute[0], attr_name, sizeof(attribute[0]));
  snprintf(msg, sizeof(msg), "Pie.Attribute = %s", attr_name);
  msg[sizeof(msg) - 1] = 0;
  dyn->graph->message('I', msg);
}

void GePie::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  for (int i = 0; i < PIE_MAX_SECTORS; i++)
    GeDyn::replace_attribute(
        attribute[i], sizeof(attribute[0]), from, to, cnt, strict);
}

void GePie::save(std::ofstream& fp)
{
  fp << int(ge_eSave_Pie) << '\n';
  fp << int(ge_eSave_Pie_fix_range) << FSPACE << fix_range << '\n';
  for (int i = 0; i < PIE_MAX_SECTORS; i++)
    fp << int(ge_eSave_Pie_attribute1) + i << FSPACE << attribute[i] << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GePie::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GePie: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_Pie:
      break;
    case ge_eSave_Pie_fix_range:
      fp >> fix_range;
      break;
    case ge_eSave_Pie_attribute1:
      fp.get();
      fp.getline(attribute[0], sizeof(attribute[0]));
      break;
    case ge_eSave_Pie_attribute2:
      fp.get();
      fp.getline(attribute[1], sizeof(attribute[0]));
      break;
    case ge_eSave_Pie_attribute3:
      fp.get();
      fp.getline(attribute[2], sizeof(attribute[0]));
      break;
    case ge_eSave_Pie_attribute4:
      fp.get();
      fp.getline(attribute[3], sizeof(attribute[0]));
      break;
    case ge_eSave_Pie_attribute5:
      fp.get();
      fp.getline(attribute[4], sizeof(attribute[0]));
      break;
    case ge_eSave_Pie_attribute6:
      fp.get();
      fp.getline(attribute[5], sizeof(attribute[0]));
      break;
    case ge_eSave_Pie_attribute7:
      fp.get();
      fp.getline(attribute[6], sizeof(attribute[0]));
      break;
    case ge_eSave_Pie_attribute8:
      fp.get();
      fp.getline(attribute[7], sizeof(attribute[0]));
      break;
    case ge_eSave_Pie_attribute9:
      fp.get();
      fp.getline(attribute[8], sizeof(attribute[0]));
      break;
    case ge_eSave_Pie_attribute10:
      fp.get();
      fp.getline(attribute[9], sizeof(attribute[0]));
      break;
    case ge_eSave_Pie_attribute11:
      fp.get();
      fp.getline(attribute[10], sizeof(attribute[0]));
      break;
    case ge_eSave_Pie_attribute12:
      fp.get();
      fp.getline(attribute[11], sizeof(attribute[0]));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GePie:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GePie::connect(grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  pwr_tAName parsed_name;
  int inverted;
  int sts;
  int atype;
  int asize;

  grow_GetPieConf(object, &sectors, &min_value, &max_value);
  if (sectors >= PIE_MAX_SECTORS)
    sectors = PIE_MAX_SECTORS;

  for (int i = 0; i < sectors; i++) {
    dyn->parse_attr_name(attribute[i], parsed_name, &inverted, &atype, &asize);
    if (streq(parsed_name, ""))
      continue;

    if (i == 0) {
      attr_type = atype;
      size = asize;

      switch (atype) {
      case pwr_eType_Float32:
      case pwr_eType_Int32:
        break;
      default:
        return 1;
      }
    } else {
      if (attr_type != atype || size != asize)
        continue;
    }

    sts = dyn->graph->ref_object_info(
        dyn->cycle, parsed_name, (void**)&p[i], &subid[i], asize, object, now);
    if (EVEN(sts))
      return sts;

    trace_data->p = &pdummy;
  }

  first_scan = true;
  return 1;
}

int GePie::disconnect(grow_tObject object)
{
  for (int i = 0; i < sectors; i++) {
    gdh_UnrefObjectInfo(subid[i]);
    p[i] = 0;
  }
  return 1;
}

int GePie::scan(grow_tObject object)
{
  int i;

  switch (attr_type) {
  case pwr_eType_Float32: {
    pwr_tFloat32 val[PIE_MAX_SECTORS];
    for (i = 0; i < sectors; i++) {
      if (p[i] == 0)
	return 1;
      val[i] = *p[i];
    }
    if (!first_scan) {
      int update = 0;
      for (i = 0; i < sectors; i++) {
        if (fabs(old_value[i] - val[i]) > FLT_EPSILON) {
          update = 1;
          break;
        }
      }
      if (!update)
        return 1;
    } else
      first_scan = false;

    if (fabs(max_value - min_value) < FLT_EPSILON)
      return 1;

    double dval[PIE_MAX_SECTORS];
    if (fix_range || sectors == 1) {
      for (i = 0; i < sectors; i++)
        dval[i] = val[i] - min_value;
    } else {
      double sum = 0;
      for (i = 0; i < sectors; i++)
        sum += val[i] - min_value;
      for (i = 0; i < sectors; i++) {
        if (fabs(sum) < DBL_EPSILON)
          dval[i] = 0;
        else
          dval[i] = (val[i] - min_value) / sum * (max_value - min_value);
      }
    }

    grow_SetPieValues(object, dval);
    memcpy(&old_value, &val, size * sectors);
    break;
  }
  case pwr_eType_Int32: {
    break;
  }
  default:;
  }
  return 1;
}

int GePie::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  return 1;
}

int GePie::syntax_check(grow_tObject object, int* error_cnt, int* warning_cnt)
{
  char atext[40];

  int types[] = { pwr_eType_Int32, pwr_eType_Float32, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase__ };

  for (int i = 0; i < PIE_MAX_SECTORS; i++) {
    sprintf(atext, "Pie.Attribute%d", i+1);
    dyn->syntax_check_attribute(object, atext, attribute[i], i == 0 ? 0 : 1,
        types, databases, error_cnt, warning_cnt);
  }
  return 1;
}

GeBarChart::GeBarChart(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_BarChart, ge_mDynType2_No,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_BarChart),
      bars(0), barsegments(0), min_value(0), max_value(0), fix_range(0),
      value(0), old_value(0)
{
  for (int i = 0; i < BARCHART_MAX_BARSEGMENTS; i++) {
    strcpy(attribute[i], "");
    p[i] = 0;
  }
}

GeBarChart::GeBarChart(const GeBarChart& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      bars(x.bars), barsegments(x.barsegments), min_value(x.min_value),
      max_value(x.max_value), fix_range(x.fix_range), value(0), old_value(0)
{
  for (int i = 0; i < BARCHART_MAX_BARSEGMENTS; i++) {
    strcpy(attribute[i], x.attribute[i]);
    p[i] = 0;
  }
}

void GeBarChart::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  for (int j = 0; j < BARCHART_MAX_BARSEGMENTS; j++) {
    sprintf(attrinfo[i].name, "BarChart.Attribute%d", j);
    attrinfo[i].value = attribute[j];
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute[0]);
  }

  strcpy(attrinfo[i].name, "BarChart.FixRange");
  attrinfo[i].value = &fix_range;
  attrinfo[i].type = glow_eType_Boolean;
  attrinfo[i++].size = sizeof(fix_range);

  *item_count = i;
}

void GeBarChart::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  char msg[200];

  strncpy(attribute[0], attr_name, sizeof(attribute[0]));
  snprintf(msg, sizeof(msg), "BarChart.Attribute = %s", attr_name);
  msg[sizeof(msg) - 1] = 0;
  dyn->graph->message('I', msg);
}

void GeBarChart::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  for (int i = 0; i < BARCHART_MAX_BARSEGMENTS; i++)
    GeDyn::replace_attribute(
        attribute[i], sizeof(attribute[0]), from, to, cnt, strict);
}

void GeBarChart::save(std::ofstream& fp)
{
  fp << int(ge_eSave_BarChart) << '\n';
  fp << int(ge_eSave_BarChart_fix_range) << FSPACE << fix_range << '\n';
  for (int i = 0; i < BARCHART_MAX_BARSEGMENTS; i++)
    fp << int(ge_eSave_BarChart_attribute1) + i << FSPACE << attribute[i]
       << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeBarChart::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeBarChart: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_BarChart:
      break;
    case ge_eSave_BarChart_fix_range:
      fp >> fix_range;
      break;
    case ge_eSave_BarChart_attribute1:
      fp.get();
      fp.getline(attribute[0], sizeof(attribute[0]));
      break;
    case ge_eSave_BarChart_attribute2:
      fp.get();
      fp.getline(attribute[1], sizeof(attribute[0]));
      break;
    case ge_eSave_BarChart_attribute3:
      fp.get();
      fp.getline(attribute[2], sizeof(attribute[0]));
      break;
    case ge_eSave_BarChart_attribute4:
      fp.get();
      fp.getline(attribute[3], sizeof(attribute[0]));
      break;
    case ge_eSave_BarChart_attribute5:
      fp.get();
      fp.getline(attribute[4], sizeof(attribute[0]));
      break;
    case ge_eSave_BarChart_attribute6:
      fp.get();
      fp.getline(attribute[5], sizeof(attribute[0]));
      break;
    case ge_eSave_BarChart_attribute7:
      fp.get();
      fp.getline(attribute[6], sizeof(attribute[0]));
      break;
    case ge_eSave_BarChart_attribute8:
      fp.get();
      fp.getline(attribute[7], sizeof(attribute[0]));
      break;
    case ge_eSave_BarChart_attribute9:
      fp.get();
      fp.getline(attribute[8], sizeof(attribute[0]));
      break;
    case ge_eSave_BarChart_attribute10:
      fp.get();
      fp.getline(attribute[9], sizeof(attribute[0]));
      break;
    case ge_eSave_BarChart_attribute11:
      fp.get();
      fp.getline(attribute[10], sizeof(attribute[0]));
      break;
    case ge_eSave_BarChart_attribute12:
      fp.get();
      fp.getline(attribute[11], sizeof(attribute[0]));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeBarChart:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeBarChart::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  pwr_tAName parsed_name;
  int inverted;
  int sts;
  int atype;
  int asize;
  int elements;

  grow_GetBarChartConf(object, &bars, &barsegments, &min_value, &max_value);
  if (barsegments >= BARCHART_MAX_BARSEGMENTS)
    barsegments = BARCHART_MAX_BARSEGMENTS;

  for (int i = 0; i < barsegments; i++) {
    dyn->parse_attr_name(
        attribute[i], parsed_name, &inverted, &atype, &asize, &elements);
    if (streq(parsed_name, ""))
      continue;

    if (!elements)
      continue;

    asize = asize / elements;
    bars = MIN(bars, elements);

    if (i == 0) {
      attr_type = atype;

      switch (atype) {
      case pwr_eType_Float32:
      case pwr_eType_Int32:
        break;
      default:
        return 1;
      }
    } else {
      if (attr_type != atype)
        continue;
    }

    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name, (void**)&p[i],
        &subid[i], bars * asize, object, now);
    if (EVEN(sts))
      return sts;

    trace_data->p = &pdummy;
  }

  size = barsegments * bars * sizeof(pwr_tFloat32);
  value = (pwr_tFloat32*)calloc(1, size);
  old_value = (pwr_tFloat32*)calloc(1, size);

  first_scan = true;
  return 1;
}

int GeBarChart::disconnect(grow_tObject object)
{
  for (int i = 0; i < barsegments; i++) {
    gdh_UnrefObjectInfo(subid[i]);
    p[i] = 0;
  }
  return 1;
}

int GeBarChart::scan(grow_tObject object)
{
  int i;

  switch (attr_type) {
  case pwr_eType_Float32: {
    for (i = 0; i < barsegments; i++) {
      if (p[i])
        memcpy(&value[i * bars], p[i], bars * sizeof(pwr_tFloat32));
    }
    if (!first_scan) {
      if (memcmp(value, old_value, size) == 0)
        return 1;
    } else
      first_scan = false;

    if (fabs(max_value - min_value) < FLT_EPSILON)
      return 1;

    pwr_tFloat32* valp[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

    for (i = 0; i < barsegments; i++)
      valp[i] = &value[i * bars];
    grow_SetBarChartValues(object, valp[0], valp[1], valp[2], valp[3], valp[4],
        valp[5], valp[6], valp[7], valp[8], valp[9], valp[10], valp[11]);
    memcpy(old_value, value, size);
    break;
  }
  case pwr_eType_Int32: {
    break;
  }
  default:;
  }
  return 1;
}

int GeBarChart::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  return 1;
}

int GeBarChart::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  char atext[40];

  int types[] = { pwr_eType_Int32, pwr_eType_Float32, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase__ };

  for (int i = 0; i < BARCHART_MAX_BARSEGMENTS; i++) {
    sprintf(atext, "BarChart.Attribute%d", i);
    dyn->syntax_check_attribute(object, atext, attribute[i], i == 0 ? 0 : 1,
        types, databases, error_cnt, warning_cnt);
  }
  return 1;
}

GeAxis::GeAxis(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_Axis, ge_mActionType1_No,
          ge_mActionType2_No, ge_eDynPrio_Axis),
      min_value(0), max_value(100), keep_settings(0), imin_value(0),
      imax_value(0), min_value_p(0), max_value_p(0), imin_value_p(0),
      imax_value_p(0), attr_type(0)
{
  strcpy(minvalue_attr, "");
  strcpy(maxvalue_attr, "");
}

GeAxis::GeAxis(const GeAxis& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      min_value(x.min_value), max_value(x.max_value),
      keep_settings(x.keep_settings), min_value_p(0), max_value_p(0),
      imin_value_p(0), imax_value_p(0)
{
  strcpy(minvalue_attr, x.minvalue_attr);
  strcpy(maxvalue_attr, x.maxvalue_attr);
}

void GeAxis::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "Axis.MinValueAttr");
  attrinfo[i].value = minvalue_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(minvalue_attr);

  strcpy(attrinfo[i].name, "Axis.MaxValueAttr");
  attrinfo[i].value = maxvalue_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(maxvalue_attr);

  strcpy(attrinfo[i].name, "Axis.KeepSettings");
  attrinfo[i].value = &keep_settings;
  attrinfo[i].type = glow_eType_Int;
  attrinfo[i++].size = sizeof(keep_settings);

  *item_count = i;
}

void GeAxis::set_attribute(grow_tObject object, const char* attr_name, int* cnt)
{
}

void GeAxis::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(
      minvalue_attr, sizeof(minvalue_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      maxvalue_attr, sizeof(maxvalue_attr), from, to, cnt, strict);
}

void GeAxis::save(std::ofstream& fp)
{
  fp << int(ge_eSave_Axis) << '\n';
  fp << int(ge_eSave_Axis_minvalue_attr) << FSPACE << minvalue_attr << '\n';
  fp << int(ge_eSave_Axis_maxvalue_attr) << FSPACE << maxvalue_attr << '\n';
  fp << int(ge_eSave_Axis_keep_settings) << FSPACE << keep_settings << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeAxis::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeAxis: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_Axis:
      break;
    case ge_eSave_Axis_minvalue_attr:
      fp.get();
      fp.getline(minvalue_attr, sizeof(minvalue_attr));
      break;
    case ge_eSave_Axis_maxvalue_attr:
      fp.get();
      fp.getline(maxvalue_attr, sizeof(maxvalue_attr));
      break;
    case ge_eSave_Axis_keep_settings:
      fp >> keep_settings;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeAxis:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeAxis::connect(grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  pwr_tAName parsed_name;
  int attr_size;
  int sts;
  int inverted;
  int attr_type_min, attr_type_max;
  int min_found = 0;
  int max_found = 0;
  int db;
  glow_sAxisInfo info;

  grow_GetAxisInfo( object, &info);
  min_value = info.min_value;
  max_value = info.max_value;

  imin_value = (int)(min_value + (min_value >= 0 ? 1 : -1) * 0.5);
  imax_value = (int)(max_value + (max_value >= 0 ? 1 : -1) * 0.5);
  min_value_p = 0;
  imin_value_p = 0;

  db = dyn->parse_attr_name(
      minvalue_attr, parsed_name, &inverted, &attr_type_min, &attr_size);
  if (!streq(parsed_name, "")) {
    switch (attr_type_min) {
    case pwr_eType_Float32:
      switch (db) {
      case graph_eDatabase_Gdh:
        sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
            (void**)&min_value_p, &min_value_subid, attr_size, object, now);
        break;
      case graph_eDatabase_Local:
        min_value_p = (pwr_tFloat32*)dyn->graph->localdb_ref_or_create(
            parsed_name, attr_type_min);
      default:;
      }
      min_found = 1;
      break;
    case pwr_eType_Int32:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&imin_value_p, &min_value_subid, attr_size, object, now);
      min_found = 1;
      break;
    case pwr_eType_Time:
    case pwr_eType_DeltaTime:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&tmin_value_p, &min_value_subid, attr_size, object, now);
      min_found = 1;
      break;
    default:;
    }
  }

  max_value_p = 0;
  imax_value_p = 0;
  db = dyn->parse_attr_name(
      maxvalue_attr, parsed_name, &inverted, &attr_type_max, &attr_size);
  if (!streq(parsed_name, "")) {
    switch (attr_type_max) {
    case pwr_eType_Float32:
      switch (db) {
      case graph_eDatabase_Gdh:
        sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
            (void**)&max_value_p, &max_value_subid, attr_size, object, now);
      case graph_eDatabase_Local:
        max_value_p = (pwr_tFloat32*)dyn->graph->localdb_ref_or_create(
            parsed_name, attr_type_max);
      default:;
      }
      max_found = 1;
      break;
    case pwr_eType_Int32:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&imax_value_p, &max_value_subid, attr_size, object, now);
      max_found = 1;
      break;
    case pwr_eType_Time:
    case pwr_eType_DeltaTime:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&tmax_value_p, &max_value_subid, attr_size, object, now);
      max_found = 1;
      break;
    default:;
    }
  }
  if (min_found && max_found) {
    if (attr_type_min != attr_type_max)
      attr_type = 0;
    else
      attr_type = attr_type_max;
  } else if (max_found)
    attr_type = attr_type_max;
  else if (min_found)
    attr_type = attr_type_min;

  trace_data->p = &pdummy;
  first_scan = true;

  return 1;
}

int GeAxis::disconnect(grow_tObject object)
{
  if (min_value_p || imin_value_p) {
    gdh_UnrefObjectInfo(min_value_subid);
    min_value_p = 0;
  }
  if (max_value_p || imax_value_p) {
    gdh_UnrefObjectInfo(max_value_subid);
    max_value_p = 0;
  }
  return 1;
}

int GeAxis::scan(grow_tObject object)
{
  switch (attr_type) {
  case pwr_eType_Float32: {
    if (!(max_value_p || min_value_p))
      return 1;

    if (!(first_scan || (max_value_p && (!feqf(*max_value_p, max_value)))
            || (min_value_p && (!feqf(*min_value_p, min_value))))) {
      return 1;
    }
    if (first_scan)
      first_scan = 0;

    if (min_value_p)
      min_value = *min_value_p;
    if (max_value_p)
      max_value = *max_value_p;

    if (feqf(max_value, min_value))
      return 1;

    grow_SetAxisRange(object, min_value, max_value, keep_settings);
    break;
  }
  case pwr_eType_Int32: {
    if (!(imax_value_p || imin_value_p))
      return 1;

    if (!(first_scan || (imax_value_p && (*imax_value_p != imax_value))
            || (imin_value_p && (*imin_value_p != imin_value)))) {
      return 1;
    }
    if (first_scan)
      first_scan = 0;

    if (imin_value_p)
      imin_value = *imin_value_p;
    if (imax_value_p)
      imax_value = *imax_value_p;

    if (imax_value == imin_value)
      return 1;

    grow_SetAxisRange(
        object, (double)imin_value, (double)imax_value, keep_settings);
    break;
  }
  case pwr_eType_Time:
  case pwr_eType_DeltaTime: {
    if (!(tmax_value_p || tmin_value_p))
      return 1;

    if (!(first_scan || (tmax_value_p && (tmax_value_p->tv_sec != imax_value))
            || (tmin_value_p && (tmin_value_p->tv_sec != imin_value)))) {
      return 1;
    }
    if (first_scan)
      first_scan = 0;

    if (tmin_value_p)
      imin_value = tmin_value_p->tv_sec;
    if (tmax_value_p)
      imax_value = tmax_value_p->tv_sec;

    if (imax_value == imin_value)
      return 1;

    grow_SetAxisRange(
        object, (double)imin_value, (double)imax_value, keep_settings);
    break;
  }
  default:;
  }
  return 1;
}

int GeAxis::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  return 1;
}

int GeAxis::syntax_check(grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Int32, pwr_eType_Float32, 0 };
  graph_eDatabase databases[]
      = { graph_eDatabase_Gdh, graph_eDatabase_Local, graph_eDatabase__ };

  dyn->syntax_check_attribute(object, "Axis.MinValueAttr", minvalue_attr, 1,
      types, databases, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "Axis.MaxValueAttr", maxvalue_attr, 1,
      types, databases, error_cnt, warning_cnt);
  return 1;
}

void GeTimeoutColor::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "TimeoutColor.Time");
  attrinfo[i].value = &time;
  attrinfo[i].type = glow_eType_Double;
  attrinfo[i++].size = sizeof(time);

  strcpy(attrinfo[i].name, "TimeoutColor.Color");
  attrinfo[i].value = &color;
  attrinfo[i].type = glow_eType_Color;
  attrinfo[i++].size = sizeof(color);

  *item_count = i;
}

void GeTimeoutColor::save(std::ofstream& fp)
{
  fp << int(ge_eSave_TimeoutColor) << '\n';
  fp << int(ge_eSave_TimeoutColor_time) << FSPACE << time << '\n';
  fp << int(ge_eSave_TimeoutColor_color) << FSPACE << int(color) << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeTimeoutColor::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  int tmp;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeTimeoutColor: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_TimeoutColor:
      break;
    case ge_eSave_TimeoutColor_time:
      fp >> time;
      break;
    case ge_eSave_TimeoutColor_color:
      fp >> tmp;
      color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeTimeoutColor:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeTimeoutColor::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  color = dyn->get_color1(object, color);
  if (color < 0 || color >= glow_eDrawType__) {
    printf("** Color out of range, TimeoutColor\n");
    return 0;
  }

  time_FloatToD(&dtime, time);

  trace_data->p = &pdummy;
  first_scan = true;
  init_done = false;

  double scan_time;
  switch (dyn->cycle) {
  case glow_eCycle_Slow:
    scan_time = dyn->graph->scan_time;
    break;
  case glow_eCycle_Fast:
    scan_time = dyn->graph->fast_scan_time;
    break;
  default:
    scan_time = 1;
  }
  scan_interval = (int)(time / scan_time / 2);
  if (scan_interval < 1)
    scan_interval = 1;
  interval_cnt = 0;
  return 1;
}

int GeTimeoutColor::disconnect(grow_tObject object)
{
  subid = pwr_cNSubid;
  return 1;
}

int GeTimeoutColor::scan(grow_tObject object)
{
  if ((init_done && subid.nid == 0 && subid.rix == 0) || dyn->ignore_color)
    return 1;

  interval_cnt++;
  if (interval_cnt < scan_interval)
    return 1;
  interval_cnt = 0;

  if (!init_done) {
    // Get subid from other dyn element
    for (GeDynElem* elem = dyn->elements; elem; elem = elem->next) {
      if (elem == this)
        continue;

      switch (elem->dyn_type1) {
      case ge_mDynType1_DigLowColor:
        subid = ((GeDigLowColor*)elem)->subid;
        break;
      case ge_mDynType1_DigColor:
        subid = ((GeDigColor*)elem)->subid;
        break;
      case ge_mDynType1_DigError:
        subid = ((GeDigError*)elem)->subid;
        break;
      case ge_mDynType1_DigWarning:
        subid = ((GeDigWarning*)elem)->subid;
        break;
      case ge_mDynType1_DigFlash:
        subid = ((GeDigFlash*)elem)->subid;
        break;
      case ge_mDynType1_Invisible:
        subid = ((GeInvisible*)elem)->subid;
        break;
      case ge_mDynType1_DigBorder:
        subid = ((GeDigBorder*)elem)->subid;
        break;
      case ge_mDynType1_DigText:
        subid = ((GeDigText*)elem)->subid;
        break;
      case ge_mDynType1_Value:
        subid = ((GeValue*)elem)->subid;
        break;
      case ge_mDynType1_AnalogColor:
        subid = ((GeAnalogColor*)elem)->subid;
        break;
      case ge_mDynType1_Rotate:
        subid = ((GeRotate*)elem)->subid;
        break;
      case ge_mDynType1_Move:
        if (((GeMove*)elem)->move_x_p)
          subid = ((GeMove*)elem)->move_x_subid;
        else if (((GeMove*)elem)->move_x_p)
          subid = ((GeMove*)elem)->move_y_subid;
        else if (((GeMove*)elem)->scale_x_p)
          subid = ((GeMove*)elem)->scale_x_subid;
        else if (((GeMove*)elem)->scale_y_p)
          subid = ((GeMove*)elem)->scale_y_subid;
        break;
      case ge_mDynType1_DigShift:
        subid = ((GeDigShift*)elem)->subid;
        break;
      case ge_mDynType1_AnalogShift:
        subid = ((GeAnalogShift*)elem)->subid;
        break;
      case ge_mDynType1_Video:
        break;
      case ge_mDynType1_Animation:
        subid = ((GeAnimation*)elem)->subid;
        break;
      case ge_mDynType1_Bar:
        subid = ((GeBar*)elem)->subid;
        break;
      case ge_mDynType1_Trend:
        if (((GeTrend*)elem)->p1)
          subid = ((GeTrend*)elem)->subid1;
        else if (((GeTrend*)elem)->p2)
          subid = ((GeTrend*)elem)->subid2;
        break;
      case ge_mDynType1_FillLevel:
        subid = ((GeFillLevel*)elem)->subid;
        break;
      case ge_mDynType1_FastCurve:
        subid = ((GeFastCurve*)elem)->subid;
        break;
      case ge_mDynType1_AnalogText:
        subid = ((GeAnalogText*)elem)->subid;
        break;
      case ge_mDynType1_Table:
        break;
      case ge_mDynType1_StatusColor:
        subid = ((GeStatusColor*)elem)->subid;
        break;
      case ge_mDynType1_HostObject:
        break;
      case ge_mDynType1_DigSound:
        subid = ((GeDigSound*)elem)->subid;
        break;
      case ge_mDynType1_XY_Curve:
        if (((GeXY_Curve*)elem)->update_p)
          subid = ((GeXY_Curve*)elem)->update_subid;
        else if (((GeXY_Curve*)elem)->noofpoints_p)
          subid = ((GeXY_Curve*)elem)->noofpoints_subid;
        break;
      case ge_mDynType1_DigCommand:
        subid = ((GeDigCommand*)elem)->subid;
        break;
      case ge_mDynType1_Pie:
        subid = ((GePie*)elem)->subid[0];
        break;
      case ge_mDynType1_BarChart:
        subid = ((GeBarChart*)elem)->subid[0];
        break;
      default:;
      }
      switch (elem->dyn_type2) {
      case ge_mDynType2_Axis:
        if (((GeAxis*)elem)->min_value_p)
          subid = ((GeAxis*)elem)->min_value_subid;
        else if (((GeAxis*)elem)->max_value_p)
          subid = ((GeAxis*)elem)->max_value_subid;
        break;
      case ge_mDynType2_DigTextColor:
        subid = ((GeDigTextColor*)elem)->subid;
        break;
      case ge_mDynType2_DigFourShift:
        if (((GeDigFourShift*)elem)->p1)
          subid = ((GeDigFourShift*)elem)->subid1;
        else if (((GeDigFourShift*)elem)->p2)
          subid = ((GeDigFourShift*)elem)->subid2;
        else if (((GeDigFourShift*)elem)->p3)
          subid = ((GeDigFourShift*)elem)->subid3;
        break;
      case ge_mDynType2_TimeoutColor:
        break;
      case ge_mDynType2_DigBackgroundColor:
        subid = ((GeDigBackgroundColor*)elem)->subid;
        break;
      case ge_mDynType2_DigSwap:
        subid = ((GeDigSwap*)elem)->subid;
        break;
      default:;
      }

      if (!(subid.nid == 0 && subid.rix == 0))
        break;
    }
    init_done = true;
    return 1;
  }

  pwr_tBoolean val;
  pwr_tTime last_update, current_time, timeout_time;
  pwr_tStatus sts;

  sts = gdh_GetSubscriptionOldness(subid, 0, &last_update, 0);
  if (EVEN(sts))
    return 1;

  time_Aadd(&timeout_time, &last_update, &dtime);
  time_GetTime(&current_time);

  if (time_Acomp(&current_time, &timeout_time) >= 0)
    val = 1;
  else
    val = 0;

  if (!first_scan) {
    if (old_value == val) {
      // No change since last time
      return 1;
    }
  } else
    first_scan = false;

  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    if (val) {
      if (color >= (glow_eDrawType)glow_eDrawTone__) {
        if (dyn->reset_color)
          grow_ResetObjectFillColor(object); // Previous color might be a tone
        grow_SetObjectFillColor(object, color);
      } else
        grow_SetObjectColorTone(object, (glow_eDrawTone)color);
      dyn->ignore_color = true;
    } else {
      if (color >= (glow_eDrawType)glow_eDrawTone__)
        grow_ResetObjectFillColor(object);
      grow_ResetObjectColorTone(object);
      dyn->reset_color = true;
    }
  } else {
    if (val) {
      grow_SetObjectFillColor(object, color);
      dyn->ignore_color = true;
    } else {
      grow_ResetObjectFillColor(object);
      dyn->reset_color = true;
    }
  }

  old_value = val;
  return 1;
}

int GeTimeoutColor::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  // Check of there is any other element that can be checked for timeout
  int found = 0;
  for (GeDynElem* elem = dyn->elements; elem; elem = elem->next) {
    if (elem == this)
      continue;

    switch (elem->dyn_type1) {
    case ge_mDynType1_DigLowColor:
    case ge_mDynType1_DigColor:
    case ge_mDynType1_DigError:
    case ge_mDynType1_DigWarning:
    case ge_mDynType1_DigFlash:
    case ge_mDynType1_Invisible:
    case ge_mDynType1_DigBorder:
    case ge_mDynType1_DigText:
    case ge_mDynType1_Value:
    case ge_mDynType1_AnalogColor:
    case ge_mDynType1_Rotate:
    case ge_mDynType1_Move:
    case ge_mDynType1_DigShift:
    case ge_mDynType1_AnalogShift:
    case ge_mDynType1_Animation:
    case ge_mDynType1_Bar:
    case ge_mDynType1_Trend:
    case ge_mDynType1_FillLevel:
    case ge_mDynType1_FastCurve:
    case ge_mDynType1_AnalogText:
    case ge_mDynType1_StatusColor:
    case ge_mDynType1_DigSound:
    case ge_mDynType1_XY_Curve:
    case ge_mDynType1_DigCommand:
    case ge_mDynType1_Pie:
    case ge_mDynType1_BarChart:
      found = 1;
      break;
    default:;
    }
    switch (elem->dyn_type2) {
    case ge_mDynType2_Axis:
    case ge_mDynType2_DigTextColor:
    case ge_mDynType2_DigFourShift:
    case ge_mDynType2_DigBackgroundColor:
    case ge_mDynType2_DigSwap:
      found = 1;
      break;
    default:;
    }
    if (found)
      break;
  }
  if (!found) {
    dyn->graph->syntax_msg(
        'E', object, "TimeoutColor, no attribute to supervise found");
    (*error_cnt)++;
  }

  glow_eDrawType tcolor = dyn->get_color1(object, color);
  if (tcolor < 0 || tcolor >= glow_eDrawType__) {
    dyn->graph->syntax_msg('E', object, "Color out or range");
    (*error_cnt)++;
  }

  if (fabs(time) < FLT_EPSILON) {
    dyn->graph->syntax_msg('E', object, "TimeoutColor.Time is zero");
    (*error_cnt)++;
  }

  return 1;
}

GeHostObject::GeHostObject(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_HostObject, ge_mDynType2_No,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_HostObject)
{
  strcpy(hostobject, "");
}

GeHostObject::GeHostObject(const GeHostObject& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio)
{
  strcpy(hostobject, x.hostobject);
}

void GeHostObject::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "HostObject.Object");
  attrinfo[i].value = hostobject;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(hostobject);
  *item_count = i;
}

void GeHostObject::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char* s;

    strncpy(hostobject, attr_name, sizeof(hostobject));
    if ((s = strrchr(hostobject, '.')))
      *s = 0;

    char msg[20 + sizeof(hostobject) + 1];
    snprintf(msg, sizeof(msg), "HostObject.Object = %s", hostobject);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeHostObject::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(
      hostobject, sizeof(hostobject), from, to, cnt, strict);
}

void GeHostObject::save(std::ofstream& fp)
{
  fp << int(ge_eSave_HostObject) << '\n';
  fp << int(ge_eSave_HostObject_object) << FSPACE << hostobject << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeHostObject::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeHostObject: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_HostObject:
      break;
    case ge_eSave_HostObject_object:
      fp.get();
      fp.getline(hostobject, sizeof(hostobject));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeHostObject:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeHostObject::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  if (grow_GetObjectRecursiveTrace(object)) {
    grow_tObject *objectlist, *object_p;
    int object_cnt;
    grow_tNodeClass nodeclass;

    grow_GetObjectClass(object, &nodeclass);
    grow_GetNodeClassObjectList(nodeclass, &objectlist, &object_cnt);
    object_p = objectlist;
    for (int i = 0; i < object_cnt; i++) {
      if (grow_GetObjectType(*object_p) == glow_eObjectType_GrowNode
          || grow_GetObjectType(*object_p) == glow_eObjectType_GrowGroup) {
        GeDyn* gm_dyn;

        grow_GetUserData(*object_p, (void**)&gm_dyn);
        strncpy(gm_dyn->recursive_hostobject, hostobject,
            sizeof(gm_dyn->recursive_hostobject));
      }
      object_p++;
    }
  }
  return 1;
}

int GeHostObject::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  GeDyn* nodeclass_dyn;

  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynHostObject(" << var_name << ".dd, \"" << hostobject << "\")"
     << '\n';

  grow_GetObjectClassUserData(object, (void**)&nodeclass_dyn);
  for (GeDynElem* elem = nodeclass_dyn->elements; elem; elem = elem->next)
    elem->export_java(object, fp, false, var_name);

  return 1;
}

int GeHostObject::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int sts;
  pwr_eType a_type;
  static GeDyn* current_dyn = 0;

  if (current_dyn == dyn)
    return 1;

  if (streq(hostobject, "")) {
    dyn->graph->syntax_msg('W', object, "HostObject.Object is missing");
    (*warning_cnt)++;
    return 1;
  }
  sts = dyn->graph->check_ldh_object(hostobject, &a_type);
  if (EVEN(sts)) {
    char msg[440];
    sprintf(msg, "HostObject.Object \"%s\" not found", hostobject);
    dyn->graph->syntax_msg('W', object, msg);
    (*warning_cnt)++;
  }

  // Check host object dynamics
  GeDyn *nodeclass_dyn, *hostobject_dyn;

  grow_GetObjectClassUserData(object, (void**)&nodeclass_dyn);
  if (nodeclass_dyn) {
    hostobject_dyn = new GeDyn(*nodeclass_dyn);
    hostobject_dyn->merge(*dyn);

    hostobject_dyn->set_hostobject(hostobject);
    if (!(hostobject_dyn->total_dyn_type1 & ge_mDynType1_HostObject))
      hostobject_dyn->total_dyn_type1 = (ge_mDynType1)(
          hostobject_dyn->total_dyn_type1 | ge_mDynType1_HostObject);

    current_dyn = hostobject_dyn; // Avoid recursion
    hostobject_dyn->syntax_check(object, error_cnt, warning_cnt);

    delete hostobject_dyn;
  }

  return 1;
}

GeDigSound::GeDigSound(GeDyn* e_dyn, ge_mInstance e_instance)
    : GeDynElem(e_dyn, ge_mDynType1_DigSound, ge_mDynType2_No,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_DigSound),
      level(0), interval(10), time_since_last(0)
{
  strcpy(attribute, "");
  strcpy(soundobject, "");
  instance = e_instance;
}

GeDigSound::GeDigSound(const GeDigSound& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      level(x.level), interval(x.interval), time_since_last(0)
{
  strcpy(attribute, x.attribute);
  strcpy(soundobject, x.soundobject);
}

void GeDigSound::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  if (instance == ge_mInstance_1) {
    strcpy(attrinfo[i].name, "DigSound.Attribute");
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    strcpy(attrinfo[i].name, "DigSound.SoundObject");
    attrinfo[i].value = soundobject;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(soundobject);

    strcpy(attrinfo[i].name, "DigSound.Level");
    attrinfo[i].value = &level;
    attrinfo[i].type = glow_eType_Boolean;
    attrinfo[i++].size = sizeof(level);

    strcpy(attrinfo[i].name, "DigSound.Interval");
    attrinfo[i].value = &interval;
    attrinfo[i].type = glow_eType_Double;
    attrinfo[i++].size = sizeof(interval);

    strcpy(attrinfo[i].name, "DigSound.Instances");
    attrinfo[i].value = &instance_mask;
    attrinfo[i].type = ge_eAttrType_InstanceMask;
    attrinfo[i++].size = sizeof(instance_mask);
  } else {
    // Get instance number
    int inst = 1;
    unsigned int m = instance;
    while (m > 1) {
      m = m >> 1;
      inst++;
    }

    sprintf(attrinfo[i].name, "DigSound%d.Attribute", inst);
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    sprintf(attrinfo[i].name, "DigSound%d.SoundObject", inst);
    attrinfo[i].value = soundobject;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(soundobject);

    sprintf(attrinfo[i].name, "DigSound%d.Level", inst);
    attrinfo[i].value = &level;
    attrinfo[i].type = glow_eType_Boolean;
    attrinfo[i++].size = sizeof(level);

    sprintf(attrinfo[i].name, "DigSound%d.Interval", inst);
    attrinfo[i].value = &interval;
    attrinfo[i].type = glow_eType_Double;
    attrinfo[i++].size = sizeof(interval);
  }

  *item_count = i;
}

void GeDigSound::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    if (instance == ge_mInstance_1) {
      snprintf(msg, sizeof(msg), "DigSound.Attribute = %s", attr_name);
    } else {
      snprintf(msg, sizeof(msg), "DigSound%d.Attribute = %s",
          GeDyn::instance_to_number(instance), attr_name);
    }
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeDigSound::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeDigSound::save(std::ofstream& fp)
{
  fp << int(ge_eSave_DigSound) << '\n';
  fp << int(ge_eSave_DigSound_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_DigSound_soundobject) << FSPACE << soundobject << '\n';
  fp << int(ge_eSave_DigSound_level) << FSPACE << level << '\n';
  fp << int(ge_eSave_DigSound_interval) << FSPACE << interval << '\n';
  fp << int(ge_eSave_DigSound_instance) << FSPACE << int(instance) << '\n';
  fp << int(ge_eSave_DigSound_instance_mask) << FSPACE << int(instance_mask)
     << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeDigSound::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  int tmp;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeDigSound: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_DigSound:
      break;
    case ge_eSave_DigSound_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_DigSound_soundobject:
      fp.get();
      fp.getline(soundobject, sizeof(soundobject));
      break;
    case ge_eSave_DigSound_level:
      fp >> level;
      break;
    case ge_eSave_DigSound_interval:
      fp >> interval;
      break;
    case ge_eSave_DigSound_instance:
      fp >> tmp;
      instance = (ge_mInstance)tmp;
      break;
    case ge_eSave_DigSound_instance_mask:
      fp >> tmp;
      instance_mask = (ge_mInstance)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeDigSound:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeDigSound::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  pwr_tStatus sts;

  p = 0;

  // Check soundobject
  sts = gdh_NameToAttrref(pwr_cNObjid, soundobject, &soundaref);
  if (EVEN(sts))
    return 1;

  size = 4;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  get_bit(parsed_name, attr_type, &bitmask);
  a_typeid = attr_type;

  sts = dyn->graph->ref_object_info(
      dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
  if (EVEN(sts))
    return sts;

  trace_data->p = &pdummy;
  first_scan = true;

  return 1;
}

int GeDigSound::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;

  return 1;
}

int GeDigSound::scan(grow_tObject object)
{
  if (!p)
    return 1;

  pwr_tBoolean val;

  if (!get_dig(&val, p, a_typeid, bitmask))
    return 1;

  if (inverted)
    val = !val;

  if (!first_scan) {
    if (old_value == *p && !level) {
      // No change since last time
      return 1;
    }
  } else
    first_scan = false;

  if (!level) {
    // Sound on positive edge
    if (val && !old_value)
      dyn->graph->sound(&soundaref);
  } else {
    if (val) {
      if (time_since_last >= interval)
        time_since_last = 0;
      if (feq(time_since_last, 0.0))
        dyn->graph->sound(&soundaref);

      time_since_last += dyn->graph->scan_time;
    } else
      time_since_last = 0;
  }
  old_value = val;

  return 1;
}

int GeDigSound::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int sts;
  pwr_eType a_type;

  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    pwr_eType_Int64, pwr_eType_UInt64, graph_eType_Bit, pwr_eType_Float32,
    pwr_eType_Float64, pwr_eType_String, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase__ };

  dyn->syntax_check_attribute(object, "DigSound.Attribute", attribute, 0, types,
      databases, error_cnt, warning_cnt);

  if (streq(soundobject, "")) {
    dyn->graph->syntax_msg('W', object, "DigSound.SoundObject is missing");
    (*warning_cnt)++;
  } else {
    sts = dyn->graph->check_ldh_object(soundobject, &a_type);
    if (EVEN(sts)) {
      char msg[440];
      sprintf(msg, "DigSound.SoundObject \"%s\" not found", soundobject);
      dyn->graph->syntax_msg('W', object, msg);
      (*warning_cnt)++;
    } else {
      if (!(a_type == pwr_cClass_Sound || a_type == pwr_cClass_SoundSequence)) {
        dyn->graph->syntax_msg(
            'E', object, "DigSound.SoundObject is of wrong class");
        (*error_cnt)++;
      }
    }
  }
  return 1;
}

GeFillLevel::GeFillLevel(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_FillLevel, ge_mDynType2_No,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_FillLevel),
      color(glow_eDrawType_Inherit), direction(glow_eDirection_Down),
      min_value(0), max_value(100), limits_found(false), min_value_p(0),
      max_value_p(0)
{
  strcpy(attribute, "");
  strcpy(minvalue_attr, "");
  strcpy(maxvalue_attr, "");
}

GeFillLevel::GeFillLevel(const GeFillLevel& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      color(x.color), direction(x.direction), min_value(x.min_value),
      max_value(x.max_value), min_value_p(0), max_value_p(0)
{
  strcpy(attribute, x.attribute);
  strcpy(minvalue_attr, x.minvalue_attr);
  strcpy(maxvalue_attr, x.maxvalue_attr);
}

void GeFillLevel::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "FillLevel.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    strcpy(attrinfo[i].name, "FillLevel.BackgroundTone");
    attrinfo[i].value = &color;
    attrinfo[i].type = glow_eType_ToneOrColor;
    attrinfo[i++].size = sizeof(color);
  } else {
    strcpy(attrinfo[i].name, "FillLevel.BackgroundColor");
    attrinfo[i].value = &color;
    attrinfo[i].type = glow_eType_Color;
    attrinfo[i++].size = sizeof(color);
  }
  strcpy(attrinfo[i].name, "FillLevel.Direction");
  attrinfo[i].value = &direction;
  attrinfo[i].type = glow_eType_Direction;
  attrinfo[i++].size = sizeof(direction);

  strcpy(attrinfo[i].name, "FillLevel.MinValue");
  attrinfo[i].value = &min_value;
  attrinfo[i].type = glow_eType_Float;
  attrinfo[i++].size = sizeof(min_value);

  strcpy(attrinfo[i].name, "FillLevel.MaxValue");
  attrinfo[i].value = &max_value;
  attrinfo[i].type = glow_eType_Float;
  attrinfo[i++].size = sizeof(max_value);

  strcpy(attrinfo[i].name, "FillLevel.MinValueAttr");
  attrinfo[i].value = minvalue_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(minvalue_attr);

  strcpy(attrinfo[i].name, "FillLevel.MaxValueAttr");
  attrinfo[i].value = maxvalue_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(maxvalue_attr);

  *item_count = i;
}

void GeFillLevel::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "FillLevel.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeFillLevel::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeFillLevel::save(std::ofstream& fp)
{
  fp << int(ge_eSave_FillLevel) << '\n';
  fp << int(ge_eSave_FillLevel_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_FillLevel_color) << FSPACE << int(color) << '\n';
  fp << int(ge_eSave_FillLevel_direction) << FSPACE << int(direction) << '\n';
  fp << int(ge_eSave_FillLevel_max_value) << FSPACE << max_value << '\n';
  fp << int(ge_eSave_FillLevel_min_value) << FSPACE << min_value << '\n';
  fp << int(ge_eSave_FillLevel_minvalue_attr) << FSPACE << minvalue_attr
     << '\n';
  fp << int(ge_eSave_FillLevel_maxvalue_attr) << FSPACE << maxvalue_attr
     << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeFillLevel::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  int tmp;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeFillLevel: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_FillLevel:
      break;
    case ge_eSave_FillLevel_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_FillLevel_color:
      fp >> tmp;
      color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_FillLevel_direction:
      fp >> tmp;
      direction = (glow_eDirection)tmp;
      break;
    case ge_eSave_FillLevel_max_value:
      fp >> max_value;
      break;
    case ge_eSave_FillLevel_min_value:
      fp >> min_value;
      break;
    case ge_eSave_FillLevel_minvalue_attr:
      fp.get();
      fp.getline(minvalue_attr, sizeof(minvalue_attr));
      break;
    case ge_eSave_FillLevel_maxvalue_attr:
      fp.get();
      fp.getline(maxvalue_attr, sizeof(maxvalue_attr));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeFillLevel:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeFillLevel::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;
  int inverted;
  glow_eDirection dir;

  color = dyn->get_color2(object, color);
  if (color < 0 || color >= glow_eDrawType__) {
    printf("** Color out of range, %s\n", attribute);
    p = 0;
    return 0;
  }

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  sts = dyn->graph->ref_object_info(
      dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
  if (EVEN(sts))
    return sts;

  trace_data->p = &pdummy;
  first_scan = true;

  if (dyn->total_dyn_type1 & ge_mDynType1_Tone) {
    if (color >= (glow_eDrawType)glow_eDrawTone__)
      grow_SetObjectLevelFillColor(object, color);
    else
      grow_SetObjectLevelColorTone(object, (glow_eDrawTone)color);
  } else
    grow_SetObjectLevelFillColor(object, color);

  sts = grow_GetObjectLimits(object, &limit_min, &limit_max, &dir);
  if (ODD(sts)) {
    limits_found = true;
    direction = dir;
  }
  grow_SetObjectLevelDirection(object, direction);

  min_value_p = 0;
  dyn->parse_attr_name(
      minvalue_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&min_value_p, &min_value_subid, attr_size, object, now);
  }

  max_value_p = 0;
  dyn->parse_attr_name(
      maxvalue_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&max_value_p, &max_value_subid, attr_size, object, now);
  }
  return 1;
}

int GeFillLevel::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;

  if (min_value_p) {
    gdh_UnrefObjectInfo(min_value_subid);
    min_value_p = 0;
  }
  if (max_value_p) {
    gdh_UnrefObjectInfo(max_value_subid);
    max_value_p = 0;
  }
  return 1;
}

int GeFillLevel::scan(grow_tObject object)
{
  if (!p)
    return 1;

  if (min_value_p && !feqf(*min_value_p, min_value)) {
    min_value = *min_value_p;
    first_scan = 1;
  }
  if (max_value_p && !feqf(*max_value_p, max_value)) {
    max_value = *max_value_p;
    first_scan = 1;
  }

  if (!first_scan) {
    if (fabs(old_value - *p) < FLT_EPSILON)
      // No change since last time
      return 1;
  } else
    first_scan = false;

  if (feqf(max_value, min_value))
    return 1;

  double value = 0.0;
  if (!limits_found)
    value = (*p - min_value) / (max_value - min_value);
  else {
    double ll_x, ll_y, ur_x, ur_y;

    grow_MeasureNode(object, &ll_x, &ll_y, &ur_x, &ur_y);

    switch (direction) {
    case glow_eDirection_Right:
      value = ((*p - min_value) / (max_value - min_value)
                      * (limit_max - limit_min)
                  + (limit_min - ll_x))
          / (ur_x - ll_x);
      break;
    case glow_eDirection_Left:
      value = ((*p - min_value) / (max_value - min_value)
                      * (limit_max - limit_min)
                  + (ur_x - limit_max))
          / (ur_x - ll_x);
      break;
    case glow_eDirection_Up:
      value = ((*p - min_value) / (max_value - min_value)
                      * (limit_max - limit_min)
                  + (limit_min - ll_y))
          / (ur_y - ll_y);
      break;
    case glow_eDirection_Down:
      value = ((*p - min_value) / (max_value - min_value)
                      * (limit_max - limit_min)
                  + (ur_y - limit_max))
          / (ur_y - ll_y);
      break;
    default:;
    }
  }
  grow_SetObjectFillLevel(object, value);
  old_value = *p;
  return 1;
}

int GeFillLevel::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  glow_eDrawType jcolor = dyn->get_color2(object, color);
  int sts;
  double min_limit, max_limit;
  glow_eDirection dir;

  sts = grow_GetObjectLimitsPixel(object, &min_limit, &max_limit, &dir);
  if (EVEN(sts)) {
    min_limit = max_limit = 0;
    dir = direction;
  } else if (!(feq(min_limit, 0.0) && feq(max_limit, 0.0))) {
    min_limit += glow_cJBean_Offset;
    max_limit += glow_cJBean_Offset;
  }

  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynFillLevel(" << var_name << ".dd, \"" << attribute << "\","
     << jcolor << "," << dir << "," << min_value << "," << max_value << ","
     << min_limit << "," << max_limit << ",";
  if (streq(minvalue_attr, ""))
    fp << "null,";
  else
    fp << "\"" << minvalue_attr << "\",";
  if (streq(maxvalue_attr, ""))
    fp << "null)\n";
  else
    fp << "\"" << maxvalue_attr << "\")\n";

  return 1;
}

int GeFillLevel::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  glow_eDrawType tcolor = dyn->get_color2(object, color);
  if (tcolor < 0 || tcolor >= glow_eDrawType__) {
    dyn->graph->syntax_msg('E', object, "Color out or range");
    (*error_cnt)++;
  }

  int types[] = { pwr_eType_Float32, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase__ };

  dyn->syntax_check_attribute(object, "FillLevel.Attribute", attribute, 0,
      types, databases, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "FillLevel.MinValueAttr", minvalue_attr,
      1, types, databases, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "FillLevel.MaxValueAttr", maxvalue_attr,
      1, types, databases, error_cnt, warning_cnt);
  return 1;
}

GeDigCommand::GeDigCommand(GeDyn* e_dyn, ge_mInstance e_instance)
    : GeDynElem(e_dyn, ge_mDynType1_DigCommand, ge_mDynType2_No,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_DigCommand),
      level(0)
{
  strcpy(attribute, "");
  strcpy(command, "");
  instance = e_instance;
}

GeDigCommand::GeDigCommand(const GeDigCommand& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      level(x.level)
{
  strcpy(attribute, x.attribute);
  strcpy(command, x.command);
  instance = x.instance;
  instance_mask = x.instance_mask;
}

void GeDigCommand::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  if (instance == ge_mInstance_1) {
    strcpy(attrinfo[i].name, "DigCommand.Attribute");
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    strcpy(attrinfo[i].name, "DigCommand.Level");
    attrinfo[i].value = &level;
    attrinfo[i].type = glow_eType_Boolean;
    attrinfo[i++].size = sizeof(level);

    strcpy(attrinfo[i].name, "DigCommand.Command");
    attrinfo[i].value = command;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(command);

    strcpy(attrinfo[i].name, "DigCommand.Instances");
    attrinfo[i].value = &instance_mask;
    attrinfo[i].type = ge_eAttrType_InstanceMask;
    attrinfo[i++].size = sizeof(instance_mask);
  } else {
    // Get instance number
    int inst = 1;
    unsigned int m = instance;
    while (m > 1) {
      m = m >> 1;
      inst++;
    }

    sprintf(attrinfo[i].name, "DigCommand%d.Attribute", inst);
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    sprintf(attrinfo[i].name, "DigCommand%d.Level", inst);
    attrinfo[i].value = &level;
    attrinfo[i].type = glow_eType_Boolean;
    attrinfo[i++].size = sizeof(level);

    sprintf(attrinfo[i].name, "DigCommand%d.Command", inst);
    attrinfo[i].value = command;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(command);
  }
  *item_count = i;
}

void GeDigCommand::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    if (instance == ge_mInstance_1) {
      snprintf(msg, sizeof(msg), "DigCommand.Attribute = %s", attr_name);
    } else {
      snprintf(msg, sizeof(msg), "DigCommand%d.Attribute = %s",
          GeDyn::instance_to_number(instance), attr_name);
    }
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeDigCommand::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeDigCommand::save(std::ofstream& fp)
{
  fp << int(ge_eSave_DigCommand) << '\n';
  fp << int(ge_eSave_DigCommand_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_DigCommand_command) << FSPACE << command << '\n';
  fp << int(ge_eSave_DigCommand_level) << FSPACE << level << '\n';
  fp << int(ge_eSave_DigCommand_instance) << FSPACE << int(instance) << '\n';
  fp << int(ge_eSave_DigCommand_instance_mask) << FSPACE << int(instance_mask)
     << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeDigCommand::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  int tmp;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeDigCommand: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_DigCommand:
      break;
    case ge_eSave_DigCommand_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_DigCommand_command:
      fp.get();
      fp.getline(command, sizeof(command));
      break;
    case ge_eSave_DigCommand_level:
      fp >> level;
      break;
    case ge_eSave_DigCommand_instance:
      fp >> tmp;
      instance = (ge_mInstance)tmp;
      break;
    case ge_eSave_DigCommand_instance_mask:
      fp >> tmp;
      instance_mask = (ge_mInstance)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeDigCommand:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeDigCommand::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  get_bit(parsed_name, attr_type, &bitmask);
  a_typeid = attr_type;

  sts = dyn->graph->ref_object_info(
      dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);

  if (EVEN(sts))
    return sts;

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeDigCommand::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeDigCommand::scan(grow_tObject object)
{
  int sts = 1;

  if (!p)
    return 1;

  pwr_tBoolean val;

  if (!get_dig(&val, p, a_typeid, bitmask))
    return 1;

  if (inverted)
    val = !val;

  if (first_scan) {
    old_value = val;
    first_scan = false;
    return 1;
  }

  if ((!level && val && !old_value) || (level && val)) {
    if (dyn->graph->command_cb) {
      char cmd[400];

      dyn->graph->get_command(command, cmd, dyn);
      sts = (dyn->graph->command_cb)(dyn->graph->parent_ctx, cmd, 0);
      return sts;
    }
  }
  old_value = val;

  return sts;
}

int GeDigCommand::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  return 1;
}

int GeDigCommand::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    pwr_eType_Int64, pwr_eType_UInt64, graph_eType_Bit, pwr_eType_Float32,
    pwr_eType_Float64, pwr_eType_String, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase__ };

  dyn->syntax_check_attribute(object, "DigCommand.Attribute", attribute, 0,
      types, databases, error_cnt, warning_cnt);

  if (streq(command, "")) {
    dyn->graph->syntax_msg('E', object, "DigCommand.Command is missing");
    (*error_cnt)++;
  }
  return 1;
}

GeDigScript::GeDigScript(GeDyn* e_dyn, ge_mInstance e_instance)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_DigScript,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_DigScript),
      script_len(0), level(0)
{
  strcpy(attribute, "");
  strcpy(script, "");
  instance = e_instance;
}

GeDigScript::GeDigScript(const GeDigScript& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      script_len(x.script_len), level(x.level)
{
  strcpy(attribute, x.attribute);
  strcpy(script, x.script);
  instance = x.instance;
  instance_mask = x.instance_mask;
}

void GeDigScript::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "DigScript.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  strcpy(attrinfo[i].name, "DigScript.Level");
  attrinfo[i].value = &level;
  attrinfo[i].type = glow_eType_Boolean;
  attrinfo[i++].size = sizeof(level);

  strcpy(attrinfo[i].name, "DigScript.Script");
  attrinfo[i].value = script;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i].multiline = 1;
  attrinfo[i++].size = sizeof(script);

  *item_count = i;
}

void GeDigScript::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "DigScript.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeDigScript::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeDigScript::save(std::ofstream& fp)
{
  fp << int(ge_eSave_DigScript) << '\n';
  fp << int(ge_eSave_DigScript_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_DigScript_level) << FSPACE << level << '\n';
  fp << int(ge_eSave_DigScript_script_len) << FSPACE << script_len << '\n';
  fp << int(ge_eSave_DigScript_script) << '\n';
  fp << "\"";
  for (char* s = script; *s; s++) {
    if (*s == '"')
      fp << "\\";
    fp << *s;
  }
  fp << '\n' << "\"\n";
  fp << int(ge_eSave_End) << '\n';
}

void GeDigScript::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[200];
  char c;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeDigScript: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_DigScript:
      break;
    case ge_eSave_DigScript_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_DigScript_level:
      fp >> level;
      break;
    case ge_eSave_DigScript_script_len:
      fp >> script_len;
      break;
    case ge_eSave_DigScript_script: {
      fp.getline(dummy, sizeof(dummy));
      fp.get();
      int j = 0;
      while (1) {
        if (j > (int)sizeof(script))
          break;
        if ((c = fp.get()) == '"') {
          if (script[j - 1] == '\\')
            j--;
          else {
            script[j] = 0;
            break;
          }
        }
        script[j++] = c;
      }
      script[sizeof(script) - 1] = 0;
      break;
    }
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeDigScript:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeDigScript::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  get_bit(parsed_name, attr_type, &bitmask);
  a_typeid = attr_type;

  switch (db) {
  case graph_eDatabase_Local:
    p = (pwr_tBoolean*)dyn->graph->localdb_ref_or_create(
        parsed_name, attr_type);
    break;
  case graph_eDatabase_Gdh:
    sts = dyn->graph->ref_object_info(
        dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
    if (EVEN(sts))
      return sts;
    break;
  default:;
  }

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeDigScript::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeDigScript::scan(grow_tObject object)
{
  int sts = 1;

  if (!p)
    return 1;

  pwr_tBoolean val;

  if (!get_dig(&val, p, a_typeid, bitmask))
    return 1;

  if (inverted)
    val = !val;

  if (first_scan) {
    old_value = val;
    first_scan = false;
    return 1;
  }

  if ((!level && val && !old_value) || (level && val)) {
    if (dyn->graph->command_cb) {
      sts = (dyn->graph->command_cb)(dyn->graph->parent_ctx, 0, script);
    }
  }
  old_value = val;

  return sts;
}

int GeDigScript::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  return 1;
}

int GeDigScript::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    pwr_eType_Int64, pwr_eType_UInt64, graph_eType_Bit, pwr_eType_Float32,
    pwr_eType_Float64, pwr_eType_String, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase__ };

  dyn->syntax_check_attribute(object, "DigScript.Attribute", attribute, 0,
      types, databases, error_cnt, warning_cnt);

  if (streq(script, "")) {
    dyn->graph->syntax_msg('E', object, "DigScript.Script is missing");
    (*error_cnt)++;
  }
  return 1;
}

GeRefUpdate::GeRefUpdate(GeDyn* e_dyn, ge_mInstance e_instance)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_RefUpdate,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_RefUpdate),
      whole_graph(0), ref_cnt(0), idx_ref_cnt(0)
{
  instance = e_instance;
  strcpy(attribute, "");
}

GeRefUpdate::GeRefUpdate(const GeRefUpdate& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      whole_graph(x.whole_graph), ref_cnt(x.ref_cnt), idx_ref_cnt(x.idx_ref_cnt)
{
  instance = x.instance;
  instance_mask = x.instance_mask;
  strcpy(attribute, x.attribute);
}

void GeRefUpdate::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "RefUpdate.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  strcpy(attrinfo[i].name, "RefUpdate.WholeGraph");
  attrinfo[i].value = &whole_graph;
  attrinfo[i].type = glow_eType_Boolean;
  attrinfo[i++].size = sizeof(whole_graph);

  *item_count = i;
}

void GeRefUpdate::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "RefUpdate.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeRefUpdate::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeRefUpdate::save(std::ofstream& fp)
{
  fp << int(ge_eSave_RefUpdate) << '\n';
  fp << int(ge_eSave_RefUpdate_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_RefUpdate_whole_graph) << FSPACE << whole_graph << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeRefUpdate::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[200];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeRefUpdate: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_RefUpdate:
      break;
    case ge_eSave_RefUpdate_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_RefUpdate_whole_graph:
      fp >> whole_graph;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeRefUpdate:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeRefUpdate::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int sts;
  pwr_tAName attr;

  for (int i = 0; i < 2; i++)
    p[i] = 0;
  for (int i = 0; i < 2; i++)
    idx_p[i] = 0;
  status = GE__SUCCESS;

  if (streq(attribute, "")) {
    // Find a reference attribute
    for (GeDynElem* elem = dyn->elements; elem; elem = elem->next) {
      if (elem == this)
        continue;
      if (elem->dyn_type1 == ge_mDynType1_DigColor) {
        strcpy(attr, ((GeDigColor*)elem)->attribute);
        if (attr[0] == '&' && attr[1] == '(') {
          strcpy(attribute, attr);
          break;
        }
      }
    }
  }
  if (!streq(attribute, "")) {
    int attr_type, attr_size;
    pwr_tAName parsed_name;
    int inverted;
    int db;
    pwr_tAName ref_name[2];
    pwr_tAName idx_ref_name[2];

    db = dyn->parse_attr_name(attribute, parsed_name, &inverted, &attr_type,
        &attr_size, 0, graph_mParseOpt_KeepIndex);
    if (streq(parsed_name, ""))
      return 1;

    sts = dyn->graph->get_refupdate(parsed_name, ref_name, ref_tid, ref_size,
        &ref_cnt, idx_ref_name, idx_ref_tid, idx_ref_size, &idx_ref_cnt, dyn);
    if (EVEN(sts))
      status = sts;

    for (int i = 0; i < ref_cnt; i++) {
      sts = dyn->graph->ref_object_info(dyn->cycle, ref_name[i], (void**)&p[i],
          &subid[i], ref_size[i], object, now);
      if (EVEN(sts))
        status = sts;
    }
    for (int i = 0; i < idx_ref_cnt; i++) {
      sts = dyn->graph->ref_object_info(dyn->cycle, idx_ref_name[i],
          (void**)&idx_p[i], &idx_subid[i], idx_ref_size[i], object, now);
      if (EVEN(sts))
        status = sts;
    }
  }

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeRefUpdate::connect(grow_tObject object, int level)
{
  if (!streq(attribute, "")) {
    int attr_type, attr_size;
    pwr_tAName parsed_name;
    int inverted;
    int db;
    pwr_tAName ref_name[2];
    pwr_tAName idx_ref_name[2];
    pwr_tStatus sts;

    status = GE__SUCCESS;
    db = dyn->parse_attr_name(attribute, parsed_name, &inverted, &attr_type,
        &attr_size, 0, graph_mParseOpt_KeepIndex);
    if (streq(parsed_name, ""))
      return 1;

    dyn->graph->get_refupdate(parsed_name, ref_name, ref_tid, ref_size,
        &ref_cnt, idx_ref_name, idx_ref_tid, idx_ref_size, &idx_ref_cnt, dyn);

    for (int i = level; i < ref_cnt; i++) {
      p[i] = 0;
      sts = dyn->graph->ref_object_info(dyn->cycle, ref_name[i], (void**)&p[i],
          &subid[i], ref_size[i], object, true);
      if (EVEN(sts))
        status = sts;
    }
    for (int i = 0; i < idx_ref_cnt; i++) {
      idx_p[i] = 0;
      sts = dyn->graph->ref_object_info(dyn->cycle, idx_ref_name[i],
          (void**)&idx_p[i], &idx_subid[i], idx_ref_size[i], object, true);
      if (EVEN(sts))
        status = sts;
    }
  }
  // first_scan = true;
  return 1;
}

int GeRefUpdate::disconnect(grow_tObject object)
{
  for (int i = 0; i < ref_cnt; i++) {
    if (p[i])
      gdh_UnrefObjectInfo(subid[i]);
    p[i] = 0;
  }
  for (int i = 0; i < idx_ref_cnt; i++) {
    if (idx_p[i])
      gdh_UnrefObjectInfo(idx_subid[i]);
    idx_p[i] = 0;
  }
  return 1;
}

int GeRefUpdate::disconnect(int level)
{
  for (int i = level; i < ref_cnt; i++) {
    if (p[i])
      gdh_UnrefObjectInfo(subid[i]);
    p[i] = 0;
  }
  for (int i = 0; i < idx_ref_cnt; i++) {
    if (idx_p[i])
      gdh_UnrefObjectInfo(idx_subid[i]);
    idx_p[i] = 0;
  }
  return 1;
}

int GeRefUpdate::scan(grow_tObject object)
{
  pwr_tStatus sts;
  bool update = false;
  int level = 0;

  for (int i = 0; i < idx_ref_cnt; i++) {
    if (!idx_p[i]) {
      if (first_scan && i == idx_ref_cnt - 1 && ref_cnt == 0)
        first_scan = false;
      continue;
    }

    if (first_scan) {
      idx_old_value[i] = *idx_p[i];
      if (i == idx_ref_cnt - 1 && ref_cnt == 0)
        first_scan = false;
      continue;
    }

    if (memcmp(idx_p[i], &idx_old_value[i], sizeof(pwr_tAttrRef)) != 0) {
      update = true;
      break;
    }
  }
  for (int i = 0; i < ref_cnt; i++) {
    if (!p[i]) {
      if (first_scan && i == ref_cnt - 1)
        first_scan = false;
      continue;
    }

    if (first_scan) {
      old_value[i] = *p[i];
      if (i == ref_cnt - 1)
        first_scan = false;
      continue;
    }

    if (memcmp(p[i], &old_value[i], sizeof(pwr_tAttrRef)) != 0) {
      update = true;
      level = i;
      break;
    }
  }

  if (update) {
    glow_sTraceData td;

    for (int i = 0; i < ref_cnt; i++)
      old_value[i] = *p[i];
    for (int i = 0; i < idx_ref_cnt; i++)
      idx_old_value[i] = *idx_p[i];

    if (whole_graph) {
      dyn->graph->swap(0);
      dyn->graph->swap(1);
      grow_Redraw(dyn->graph->grow->ctx);
      // old_value[i] = *p[i];
      return GLOW__SWAPTERMINATED;
    }

    for (GeDynElem* elem = dyn->elements; elem; elem = elem->next) {
      if (elem == this)
        continue;
      elem->disconnect(object);
      sts = elem->connect(object, &td, true);
      if (EVEN(sts))
        elem->reset(object);
    }
    if (idx_ref_cnt > 0 || level < ref_cnt - 1) {
      disconnect(level + 1);
      connect(object, level + 1);

      for (int i = 0; i < ref_cnt; i++)
        old_value[i] = *p[i];
      for (int i = 0; i < idx_ref_cnt; i++)
        idx_old_value[i] = *idx_p[i];
    }
  }
  return 1;
}

int GeRefUpdate::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  return 1;
}

int GeRefUpdate::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  if (!streq(attribute, "")) {
    int types[] = { pwr_eType_Objid, pwr_eType_AttrRef, 0 };
    graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase__ };

    dyn->syntax_check_attribute(object, "RefUpdate.Attribute", attribute, 0,
        types, databases, error_cnt, warning_cnt);
  }
  return 1;
}

GePopupMenu::GePopupMenu(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No,
          ge_mActionType1_PopupMenu, ge_mActionType2_No, ge_eDynPrio_PopupMenu)
{
  strcpy(ref_object, "");
}

GePopupMenu::GePopupMenu(const GePopupMenu& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio)
{
  strcpy(ref_object, x.ref_object);
}

void GePopupMenu::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "PopupMenu.ReferenceObject");
  attrinfo[i].value = ref_object;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(ref_object);

  dyn->display_access = true;
  *item_count = i;
}

void GePopupMenu::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char* s;

    strncpy(ref_object, attr_name, sizeof(ref_object));
    if ((s = strchr(ref_object, '.')))
      *s = 0;

    char msg[28 + sizeof(ref_object) + 1];
    snprintf(msg, sizeof(msg), "PopupMenu.ReferenceObject = %s", ref_object);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GePopupMenu::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(
      ref_object, sizeof(ref_object), from, to, cnt, strict);
}

void GePopupMenu::save(std::ofstream& fp)
{
  fp << int(ge_eSave_PopupMenu) << '\n';
  fp << int(ge_eSave_PopupMenu_ref_object) << FSPACE << ref_object << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GePopupMenu::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GePopupMenu: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_PopupMenu:
      break;
    case ge_eSave_PopupMenu_ref_object:
      fp.get();
      fp.getline(ref_object, sizeof(ref_object));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GePopupMenu:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GePopupMenu::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB3Press: {
    int sts;
    pwr_tAName parsed_name;
    int inverted;
    int attr_type, attr_size;
    pwr_sAttrRef attrref;
    char name[80];
    int x, y;
    int reference = 0;

    dyn->parse_attr_name(
        ref_object, parsed_name, &inverted, &attr_type, &attr_size);
    if (parsed_name[0] == '&') {
      // Refobject starting with '&' indicates reference
      pwr_tAName refname;
      strncpy(refname, parsed_name, sizeof(refname));
      sts = dyn->graph->get_reference_name(refname, parsed_name);
      if (EVEN(sts))
        break;
    } else {
      if (inverted) // Old syntax for reference
        reference = 1;
    }
    if (reference) {
      // The ref_object is an objid-attribute that contains the object
      switch (attr_type) {
      case pwr_eType_AttrRef: {
        pwr_tAttrRef aref;

        sts = gdh_GetObjectInfo(parsed_name, &aref, sizeof(aref));
        if (EVEN(sts))
          break;
        if (cdh_ObjidIsNull(aref.Objid))
          break;
        attrref = aref;
        break;
      }
      case pwr_eType_DataRef: {
        pwr_tDataRef dataref;

        sts = gdh_GetObjectInfo(parsed_name, &dataref, sizeof(dataref));
        if (EVEN(sts))
          break;
        if (cdh_ObjidIsNull(dataref.Aref.Objid))
          break;
        attrref = dataref.Aref;
        break;
      }
      default: {
        pwr_tOid oid;

        sts = gdh_GetObjectInfo(parsed_name, &oid, sizeof(oid));
        if (EVEN(sts))
          break;
        if (cdh_ObjidIsNull(oid))
          break;
        attrref = cdh_ObjidToAref(oid);
      }
      }
    } else {
      sts = gdh_NameToAttrref(pwr_cNObjid, parsed_name, &attrref);
      if (EVEN(sts))
        break;
    }
    if (dyn->graph->popup_menu_cb) {
      // Display popup menu
      grow_GetName(dyn->graph->grow->ctx, name);

      int item_type = xmenu_eItemType_Attribute;
      if (attrref.Flags.b.Object)
        item_type = xmenu_eItemType_Object;
      else if (attrref.Flags.b.ObjectAttr)
        item_type = xmenu_eItemType_AttrObject;

      dyn->graph->popup_position(
          event->any.x_pixel + 8, event->any.y_pixel, &x, &y);
      (dyn->graph->popup_menu_cb)(dyn->graph->parent_ctx, attrref, item_type,
          xmenu_mUtility_Ge, name, x, y);
    }
    break;
  }
  case glow_eEvent_Key_CtrlAscii: {
    char method[40];
    char filter[40];

    switch (event->key.ascii) {
    case 1:
      strcpy(method, "$Object-OpenObject");
      strcpy(filter, "$Object-OpenObjectFilter");
      break;
    case 7:
      strcpy(method, "$Object-OpenObjectGraph");
      strcpy(filter, "$Object-OpenObjectGraphFilter");
      break;
    case 18:
      strcpy(method, "$Object-OpenCrossref");
      strcpy(filter, "$Object-OpenCrossrefFilter");
      break;
    case 4:
      strcpy(method, "$Object-RtNavigator");
      strcpy(filter, "$Object-RtNavigatorFilter");
      break;
    case 12:
      strcpy(method, "$Object-OpenTrace");
      strcpy(filter, "$Object-OpenTraceFilter");
      break;
    case 8:
      strcpy(method, "$Object-Help");
      strcpy(filter, "$Object-HelpFilter");
      break;
    case 10:
      strcpy(method, "$Object-HelpClass");
      strcpy(filter, "$Object-HelpClassFilter");
      break;
    default:
      return 1;
    }

    if (dyn->graph->call_method_cb) {
      int sts;
      pwr_tAName parsed_name;
      int inverted;
      int attr_type, attr_size;
      char* s;
      pwr_sAttrRef attrref;
      pwr_tOid oid;

      dyn->parse_attr_name(
          ref_object, parsed_name, &inverted, &attr_type, &attr_size);
      if (inverted) {
        // The ref_object is an objid-attribute that containts the object
        memset(&attrref, 0, sizeof(attrref));
        sts = gdh_GetObjectInfo(
            parsed_name, &attrref.Objid, sizeof(attrref.Objid));
        if (EVEN(sts))
          break;
        if (cdh_ObjidIsNull(attrref.Objid))
          break;
      } else {
        if ((s = strrchr(parsed_name, '.')))
          *s = 0;

        sts = gdh_NameToObjid(parsed_name, &oid);
        if (EVEN(sts))
          break;

        attrref = cdh_ObjidToAref(oid);
      }
      (dyn->graph->call_method_cb)(dyn->graph->parent_ctx, method, filter,
          attrref, xmenu_eItemType_Object, xmenu_mUtility_Ge, NULL);
    }
    break;
  }
  default:;
  }
  return 1;
}

int GePopupMenu::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynPopupMenu(" << var_name << ".dd, \"" << ref_object << "\")"
     << '\n';
  return 1;
}

int GePopupMenu::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int sts;
  pwr_tAName parsed_name;
  int inverted;
  int attr_type, attr_size;
  pwr_eType a_type;

  if (streq(ref_object, "")) {
    dyn->graph->syntax_msg('W', object, "PopupMenu.ReferenceObject is missing");
    (*warning_cnt)++;
  } else {
    if (ref_object[0] == '&') {
      // Refobject starting with '&' indicates reference

      sts = dyn->graph->check_ldh_object(&ref_object[1], &a_type);
      if (EVEN(sts)) {
        char msg[440];
        sprintf(msg, "PopupMenu.ReferenceObject \"%s\" not found", ref_object);
        dyn->graph->syntax_msg('W', object, msg);
        (*warning_cnt)++;
      } else if (!(a_type == pwr_eType_Objid || a_type == pwr_eType_AttrRef
                     || a_type == pwr_eType_DataRef)) {
        char msg[440];
        sprintf(msg, "PopupMenu.ReferenceObject \"%s\" type error", ref_object);
        dyn->graph->syntax_msg('W', object, msg);
        (*warning_cnt)++;
      }
      return 1;
    } else {
      dyn->parse_attr_name(
          ref_object, parsed_name, &inverted, &attr_type, &attr_size);
      if (inverted)
        return 1;

      sts = dyn->graph->check_ldh_object(parsed_name, &a_type);
      if (EVEN(sts)) {
        char msg[440];
        sprintf(msg, "PopupMenu.ReferenceObject \"%s\" not found", ref_object);
        dyn->graph->syntax_msg('W', object, msg);
        (*warning_cnt)++;
      }
    }
  }
  return 1;
}

GeSetDig::GeSetDig(GeDyn* e_dyn, ge_mInstance e_instance)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No, ge_mActionType1_SetDig,
          ge_mActionType2_No, ge_eDynPrio_SetDig)
{
  strcpy(attribute, "");
  instance = e_instance;
}

GeSetDig::GeSetDig(const GeSetDig& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio)
{
  strcpy(attribute, x.attribute);
  instance = x.instance, instance_mask = x.instance_mask;
}

void GeSetDig::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  if (instance == ge_mInstance_1) {
    strcpy(attrinfo[i].name, "SetDig.Attribute");
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    strcpy(attrinfo[i].name, "SetDig.Instances");
    attrinfo[i].value = &instance_mask;
    attrinfo[i].type = ge_eAttrType_InstanceMask;
    attrinfo[i++].size = sizeof(instance_mask);
  } else {
    // Get instance number
    int inst = 1;
    unsigned int m = instance;
    while (m > 1) {
      m = m >> 1;
      inst++;
    }

    sprintf(attrinfo[i].name, "SetDig%d.Attribute", inst);
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);
  }

  dyn->display_access = true;
  *item_count = i;
}

int GeSetDig::get_transtab(char** tt)
{
  static char transtab[][32]
      = { "SubGraph", "SubGraph", "A1", "Text", "Dynamic", "", "" };

  *tt = (char*)transtab;
  return 0;
}

void GeSetDig::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    if (instance == ge_mInstance_1)
      snprintf(msg, sizeof(msg), "SetDig.Attribute = %s", attr_name);
    else
      snprintf(msg, sizeof(msg), "SetDig%d.Attribute = %s",
          GeDyn::instance_to_number(instance), attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeSetDig::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeSetDig::save(std::ofstream& fp)
{
  fp << int(ge_eSave_SetDig) << '\n';
  fp << int(ge_eSave_SetDig_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_SetDig_instance) << FSPACE << int(instance) << '\n';
  fp << int(ge_eSave_SetDig_instance_mask) << FSPACE << int(instance_mask)
     << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeSetDig::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeSetDig: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_SetDig:
      break;
    case ge_eSave_SetDig_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_SetDig_instance:
      fp >> tmp;
      instance = (ge_mInstance)tmp;
      break;
    case ge_eSave_SetDig_instance_mask:
      fp >> tmp;
      instance_mask = (ge_mInstance)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeSetDig:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeSetDig::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetClickSensitivity(dyn->graph->grow->ctx, glow_mSensitivity_MB1Click);
    grow_SetObjectColorInverse(object, 1);
    break;
  case glow_eEvent_MB1Up:
    grow_SetObjectColorInverse(object, 0);
    break;
  case glow_eEvent_Key_Return:
  case glow_eEvent_MB1Click: {
    int sts;
    pwr_tAName parsed_name;
    int inverted;
    int attr_type, attr_size;
    graph_eDatabase db;

    if (dyn->total_action_type1 & ge_mActionType1_Confirm)
      break;

    db = dyn->parse_attr_name(
        attribute, parsed_name, &inverted, &attr_type, &attr_size);
    if (parsed_name[0] == '&')
      dyn->graph->get_reference_name(parsed_name, parsed_name);

    switch (db) {
    case graph_eDatabase_Local: {
      pwr_tBoolean value = 1;

      sts = dyn->graph->localdb_set_value(parsed_name, &value, sizeof(value));
      if (EVEN(sts))
        printf("SetDig error: %s\n", attribute);
      break;
    }
    case graph_eDatabase_Gdh:
      switch (attr_type) {
      case pwr_eType_Boolean: {
        pwr_tBoolean value = 1;

        sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
        if (EVEN(sts))
          printf("SetDig error: %s\n", attribute);
        break;
      }
      case pwr_eType_Int32:
      case pwr_eType_UInt32: {
        pwr_tInt32 value = 1;

        sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
        if (EVEN(sts))
          printf("SetDig error: %s\n", attribute);
        break;
      }
      case graph_eType_Bit: {
        // Get bit number from parsed name
        pwr_tUInt32 value = 1;
        char* s;
        int bitnum = 0;

        if ((s = strrchr(parsed_name, '['))) {
          sscanf(s + 1, "%d", &bitnum);
          *s = 0;
          if (!(bitnum >= 0 && bitnum < 32))
            break;
        }

        sts = gdh_GetObjectInfo(parsed_name, &value, sizeof(value));
        if (EVEN(sts)) {
          printf("SetDig error: %s\n", attribute);
          break;
        }
        value |= (1 << bitnum);

        sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
        if (EVEN(sts))
          printf("SetDig error: %s\n", attribute);

        break;
      }
      default:;
      }
      break;
    case graph_eDatabase_Ccm: {
      pwr_tBoolean value = 1;

      sts = dyn->graph->ccm_set_variable(parsed_name, attr_type, &value);
      if (EVEN(sts))
        printf("SetDig error: %s\n", attribute);
      break;
    }
    default:;
    }
    break;
  }
  default:;
  }
  return 1;
}

int GeSetDig::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynSetDig(" << var_name << ".dd, \"" << attribute << "\")"
     << '\n';
  return 1;
}

int GeSetDig::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    graph_eType_Bit, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Local, graph_eDatabase_Gdh,
    graph_eDatabase_Ccm, graph_eDatabase__ };
  dyn->syntax_check_attribute(object, "SetDig.Attribute", attribute, 0, types,
      databases, error_cnt, warning_cnt);

  return 1;
}

GeResetDig::GeResetDig(GeDyn* e_dyn, ge_mInstance e_instance)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No,
          ge_mActionType1_ResetDig, ge_mActionType2_No, ge_eDynPrio_ResetDig)
{
  strcpy(attribute, "");
  instance = e_instance;
}

GeResetDig::GeResetDig(const GeResetDig& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio)
{
  strcpy(attribute, x.attribute);
  instance = x.instance;
  instance_mask = x.instance_mask;
}

void GeResetDig::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  if (instance == ge_mInstance_1) {
    strcpy(attrinfo[i].name, "ResetDig.Attribute");
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    strcpy(attrinfo[i].name, "ResetDig.Instances");
    attrinfo[i].value = &instance_mask;
    attrinfo[i].type = ge_eAttrType_InstanceMask;
    attrinfo[i++].size = sizeof(instance_mask);
  } else {
    // Get instance number
    int inst = 1;
    unsigned int m = instance;
    while (m > 1) {
      m = m >> 1;
      inst++;
    }

    sprintf(attrinfo[i].name, "ResetDig%d.Attribute", inst);
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);
  }

  dyn->display_access = true;
  *item_count = i;
}

int GeResetDig::get_transtab(char** tt)
{
  static char transtab[][32]
      = { "SubGraph", "SubGraph", "A1", "Text", "Dynamic", "", "" };

  *tt = (char*)transtab;
  return 0;
}

void GeResetDig::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    if (instance == ge_mInstance_1)
      snprintf(msg, sizeof(msg), "ResetDig.Attribute = %s", attr_name);
    else
      snprintf(msg, sizeof(msg), "ResetDig%d.Attribute = %s",
          GeDyn::instance_to_number(instance), attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeResetDig::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeResetDig::save(std::ofstream& fp)
{
  fp << int(ge_eSave_ResetDig) << '\n';
  fp << int(ge_eSave_ResetDig_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_ResetDig_instance) << FSPACE << int(instance) << '\n';
  fp << int(ge_eSave_ResetDig_instance_mask) << FSPACE << int(instance_mask)
     << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeResetDig::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeResetDig: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_ResetDig:
      break;
    case ge_eSave_ResetDig_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    case ge_eSave_ResetDig_instance:
      fp >> tmp;
      instance = (ge_mInstance)tmp;
      break;
    case ge_eSave_ResetDig_instance_mask:
      fp >> tmp;
      instance_mask = (ge_mInstance)tmp;
      break;
    default:
      std::cout << "GeResetDig:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeResetDig::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetClickSensitivity(dyn->graph->grow->ctx, glow_mSensitivity_MB1Click);
    grow_SetObjectColorInverse(object, 1);
    break;
  case glow_eEvent_MB1Up:
    grow_SetObjectColorInverse(object, 0);
    break;
  case glow_eEvent_Key_Return:
  case glow_eEvent_MB1Click: {
    int sts;
    pwr_tAName parsed_name;
    int inverted;
    int attr_type, attr_size;

    if (dyn->total_action_type1 & ge_mActionType1_Confirm)
      break;

    dyn->parse_attr_name(
        attribute, parsed_name, &inverted, &attr_type, &attr_size);
    if (parsed_name[0] == '&')
      dyn->graph->get_reference_name(parsed_name, parsed_name);

    switch (attr_type) {
    case pwr_eType_Boolean: {
      pwr_tBoolean value = 0;

      sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
      if (EVEN(sts))
        printf("SetDig error: %s\n", attribute);
      break;
    }
    case pwr_eType_Int32:
    case pwr_eType_UInt32: {
      pwr_tInt32 value = 0;

      sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
      if (EVEN(sts))
        printf("SetDig error: %s\n", attribute);
      break;
    }
    case graph_eType_Bit: {
      // Get bit number from parsed name
      pwr_tUInt32 value = 0;
      char* s;
      int bitnum = 0;

      if ((s = strrchr(parsed_name, '['))) {
        sscanf(s + 1, "%d", &bitnum);
        *s = 0;
        if (!(bitnum >= 0 && bitnum < 32))
          break;
      }

      sts = gdh_GetObjectInfo(parsed_name, &value, sizeof(value));
      if (EVEN(sts)) {
        printf("ResetDig error: %s\n", attribute);
        break;
      }
      value &= ~(1 << bitnum);

      sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
      if (EVEN(sts))
        printf("ResetDig error: %s\n", attribute);

      break;
    }
    default:;
    }

    break;
  }
  default:;
  }
  return 1;
}

int GeResetDig::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynResetDig(" << var_name << ".dd, \"" << attribute << "\")"
     << '\n';
  return 1;
}

int GeResetDig::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    graph_eType_Bit, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Local, graph_eDatabase_Gdh,
    graph_eDatabase_Ccm, graph_eDatabase__ };
  dyn->syntax_check_attribute(object, "ResetDig.Attribute", attribute, 0, types,
      databases, error_cnt, warning_cnt);

  return 1;
}

GeToggleDig::GeToggleDig(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No,
          ge_mActionType1_ToggleDig, ge_mActionType2_No, ge_eDynPrio_ToggleDig)
{
  strcpy(attribute, "");
}

GeToggleDig::GeToggleDig(const GeToggleDig& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio)
{
  strcpy(attribute, x.attribute);
}

void GeToggleDig::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "ToggleDig.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  dyn->display_access = true;
  *item_count = i;
}

int GeToggleDig::get_transtab(char** tt)
{
  static char transtab[][32]
      = { "SubGraph", "SubGraph", "A1", "Text", "Dynamic", "", "" };

  *tt = (char*)transtab;
  return 0;
}

void GeToggleDig::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "ToggleDig.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeToggleDig::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeToggleDig::save(std::ofstream& fp)
{
  fp << int(ge_eSave_ToggleDig) << '\n';
  fp << int(ge_eSave_ToggleDig_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeToggleDig::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeToggleDig: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_ToggleDig:
      break;
    case ge_eSave_ToggleDig_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeToggleDig:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeToggleDig::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetClickSensitivity(dyn->graph->grow->ctx, glow_mSensitivity_MB1Click);
    grow_SetObjectColorInverse(object, 1);
    break;
  case glow_eEvent_MB1Up:
    grow_SetObjectColorInverse(object, 0);
    break;
  case glow_eEvent_Key_Return:
  case glow_eEvent_MB1Click: {
    int sts;
    pwr_tAName parsed_name;
    int inverted;
    int attr_type, attr_size;
    graph_eDatabase db;

    if (dyn->total_action_type1 & ge_mActionType1_Confirm)
      break;

    db = dyn->parse_attr_name(
        attribute, parsed_name, &inverted, &attr_type, &attr_size);
    if (parsed_name[0] == '&')
      dyn->graph->get_reference_name(parsed_name, parsed_name);

    switch (db) {
    case graph_eDatabase_Gdh: {
      switch (attr_type) {
      case pwr_eType_Boolean: {
        pwr_tBoolean value;

        sts = gdh_GetObjectInfo(parsed_name, &value, sizeof(value));
        if (EVEN(sts))
          printf("ToggleDig error: %s\n", attribute);

        value = !value;
        sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
        if (EVEN(sts))
          printf("ToggleDig error: %s\n", attribute);
        break;
      }
      case pwr_eType_Int32: {
      case pwr_eType_UInt32:
        pwr_tInt32 value;

        sts = gdh_GetObjectInfo(parsed_name, &value, sizeof(value));
        if (EVEN(sts))
          printf("ToggleDig error: %s\n", attribute);

        value = value ? 0 : 1;
        sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
        if (EVEN(sts))
          printf("ToggleDig error: %s\n", attribute);
        break;
      }
      case graph_eType_Bit: {
        // Get bit number from parsed name
        pwr_tUInt32 value;
        char* s;
        int bitnum = 0;

        if ((s = strrchr(parsed_name, '['))) {
          sscanf(s + 1, "%d", &bitnum);
          *s = 0;
          if (!(bitnum >= 0 && bitnum < 32))
            break;
        }

        sts = gdh_GetObjectInfo(parsed_name, &value, sizeof(value));
        if (EVEN(sts)) {
          printf("ToggleDig error: %s\n", attribute);
          break;
        }

        if (value & (1 << bitnum))
          value &= ~(1 << bitnum);
        else
          value |= (1 << bitnum);

        sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
        if (EVEN(sts))
          printf("ToggleDig error: %s\n", attribute);

        break;
      }
      default:;
      }

      break;
    }
    case graph_eDatabase_Local: {
      sts = dyn->graph->localdb_toggle_value(parsed_name);
      if (EVEN(sts))
        printf("ToggleDig error: %s\n", attribute);

      break;
    }
    case graph_eDatabase_Ccm: {
      pwr_tBoolean value;

      sts = dyn->graph->ccm_get_variable(parsed_name, attr_type, &value);
      if (EVEN(sts))
        printf("ToggleDig error: %s\n", attribute);

      value = !value;
      sts = dyn->graph->ccm_set_variable(parsed_name, attr_type, &value);
      if (EVEN(sts))
        printf("ToggleDig error: %s\n", attribute);
      break;
    }
    default:;
    }

    break;
  }
  default:;
  }
  return 1;
}

int GeToggleDig::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynToggleDig(" << var_name << ".dd, \"" << attribute << "\")"
     << '\n';
  return 1;
}

int GeToggleDig::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    graph_eType_Bit, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Local, graph_eDatabase_Gdh,
    graph_eDatabase_Ccm, graph_eDatabase__ };
  dyn->syntax_check_attribute(object, "SetToggle.Attribute", attribute, 0,
      types, databases, error_cnt, warning_cnt);

  return 1;
}

GeStoDig::GeStoDig(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No, ge_mActionType1_StoDig,
          ge_mActionType2_No, ge_eDynPrio_StoDig)
{
  strcpy(attribute, "");
}

GeStoDig::GeStoDig(const GeStoDig& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio)
{
  strcpy(attribute, x.attribute);
}

void GeStoDig::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "StoDig.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  dyn->display_access = true;
  *item_count = i;
}

int GeStoDig::get_transtab(char** tt)
{
  static char transtab[][32]
      = { "SubGraph", "SubGraph", "A1", "Text", "Dynamic", "", "" };

  *tt = (char*)transtab;
  return 0;
}

void GeStoDig::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "StoDig.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeStoDig::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeStoDig::save(std::ofstream& fp)
{
  fp << int(ge_eSave_StoDig) << '\n';
  fp << int(ge_eSave_StoDig_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeStoDig::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeStoDig: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_StoDig:
      break;
    case ge_eSave_StoDig_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeStoDig:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeStoDig::action(grow_tObject object, glow_tEvent event)
{
  pwr_tBoolean value = 0;
  int sts;
  pwr_tAName parsed_name;
  int inverted;
  int attr_type, attr_size;

  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetObjectColorInverse(object, 1);
    value = 1;
    dyn->parse_attr_name(
        attribute, parsed_name, &inverted, &attr_type, &attr_size);
    if (parsed_name[0] == '&')
      dyn->graph->get_reference_name(parsed_name, parsed_name);

    sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
    if (EVEN(sts)) {
      printf("StoDig error: %s\n", attribute);
      break;
    }
    break;
  case glow_eEvent_MB1Up:
    grow_SetObjectColorInverse(object, 0);
    value = 0;
    dyn->parse_attr_name(
        attribute, parsed_name, &inverted, &attr_type, &attr_size);
    if (parsed_name[0] == '&')
      dyn->graph->get_reference_name(parsed_name, parsed_name);
    sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
    if (EVEN(sts))
      break;

    break;
  default:;
  }
  return 1;
}

int GeStoDig::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynStoDig(" << var_name << ".dd, \"" << attribute << "\")"
     << '\n';
  return 1;
}

int GeStoDig::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_UInt32,
    graph_eType_Bit, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Local, graph_eDatabase_Gdh,
    graph_eDatabase_Ccm, graph_eDatabase__ };
  dyn->syntax_check_attribute(object, "StoDig.Attribute", attribute, 0, types,
      databases, error_cnt, warning_cnt);

  return 1;
}

GeCommand::GeCommand(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No,
          ge_mActionType1_Command, ge_mActionType2_No, ge_eDynPrio_Command)
{
  strcpy(command, "");
}

GeCommand::GeCommand(const GeCommand& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio)
{
  strcpy(command, x.command);
}

void GeCommand::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "Command.Command");
  attrinfo[i].value = command;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(command);

  dyn->display_access = true;
  *item_count = i;
}

int GeCommand::get_transtab(char** tt)
{
  static char transtab[][32]
      = { "SubGraph", "SubGraph", "A1", "Text", "Dynamic", "", "" };

  *tt = (char*)transtab;
  return 0;
}

void GeCommand::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(command, sizeof(command), from, to, cnt, strict);
}

void GeCommand::save(std::ofstream& fp)
{
  fp << int(ge_eSave_Command) << '\n';
  fp << int(ge_eSave_Command_command) << FSPACE << command << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeCommand::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeCommand: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_Command:
      break;
    case ge_eSave_Command_command:
      fp.get();
      fp.getline(command, sizeof(command));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeCommand:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeCommand::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetClickSensitivity(dyn->graph->grow->ctx, glow_mSensitivity_MB1Click);
    grow_SetObjectColorInverse(object, 1);
    break;
  case glow_eEvent_MB1Up:
    grow_SetObjectColorInverse(object, 0);
    break;
  case glow_eEvent_Key_Return:
  case glow_eEvent_MB1Click:
    if (dyn->total_action_type1 & ge_mActionType1_Confirm)
      break;

    if (dyn->graph->command_cb) {
      char cmd[400];
      int sts;

      dyn->graph->get_command(command, cmd, dyn);
      sts = (dyn->graph->command_cb)(dyn->graph->parent_ctx, cmd, 0);
      return sts;
    }
    break;
  default:;
  }
  return 1;
}

int GeCommand::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynCommand(" << var_name << ".dd, \"" << GeDyn::cmd_cnv(command)
     << "\")\n";
  return 1;
}

int GeCommand::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  if (streq(command, "")) {
    dyn->graph->syntax_msg('E', object, "Command.Command is missing");
    (*error_cnt)++;
  }
  return 1;
}

GeCommandDoubleClick::GeCommandDoubleClick(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No,
          ge_mActionType1_CommandDoubleClick, ge_mActionType2_No,
          ge_eDynPrio_CommandDoubleClick)
{
  strcpy(command, "");
}

GeCommandDoubleClick::GeCommandDoubleClick(const GeCommandDoubleClick& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio)
{
  strcpy(command, x.command);
}

void GeCommandDoubleClick::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "CommandDoubleClick.Command");
  attrinfo[i].value = command;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(command);

  dyn->display_access = true;
  *item_count = i;
}

int GeCommandDoubleClick::get_transtab(char** tt)
{
  static char transtab[][32]
      = { "SubGraph", "SubGraph", "A1", "Text", "Dynamic", "", "" };

  *tt = (char*)transtab;
  return 0;
}

void GeCommandDoubleClick::replace_attribute(
    char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(command, sizeof(command), from, to, cnt, strict);
}

void GeCommandDoubleClick::save(std::ofstream& fp)
{
  fp << int(ge_eSave_CommandDC) << '\n';
  fp << int(ge_eSave_CommandDC_command) << FSPACE << command << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeCommandDoubleClick::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeCommandDoubleClick: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_CommandDC:
      break;
    case ge_eSave_CommandDC_command:
      fp.get();
      fp.getline(command, sizeof(command));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeCommandDC:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeCommandDoubleClick::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetClickSensitivity(dyn->graph->grow->ctx,
        glow_mSensitivity_MB1Click | glow_mSensitivity_MB1DoubleClick);
    grow_SetObjectColorInverse(object, 1);
    break;
  case glow_eEvent_MB1Up:
    grow_SetObjectColorInverse(object, 0);
    break;
  case glow_eEvent_MB1DoubleClick:
    if (dyn->graph->command_cb) {
      char cmd[400];

      dyn->graph->get_command(command, cmd, dyn);
      (dyn->graph->command_cb)(dyn->graph->parent_ctx, cmd, 0);
    }
    break;
  default:;
  }
  return 1;
}

int GeCommandDoubleClick::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  if (streq(command, "")) {
    dyn->graph->syntax_msg(
        'E', object, "CommandDoubleClick.Command is missing");
    (*error_cnt)++;
  }
  return 1;
}

GeScript::GeScript(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No, ge_mActionType1_Script,
          ge_mActionType2_No, ge_eDynPrio_Script)
{
  strcpy(script, "");
}

GeScript::GeScript(const GeScript& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      script_len(x.script_len)
{
  strncpy(script, x.script, sizeof(script));
}

void GeScript::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "Script.Script");
  attrinfo[i].value = script;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i].multiline = 1;
  attrinfo[i++].size = sizeof(script);

  dyn->display_access = true;
  *item_count = i;
}

int GeScript::get_transtab(char** tt)
{
  static char transtab[][32]
      = { "SubGraph", "SubGraph", "A1", "Text", "Dynamic", "", "" };

  *tt = (char*)transtab;
  return 0;
}

void GeScript::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(script, sizeof(script), from, to, cnt, strict);
}

void GeScript::save(std::ofstream& fp)
{
  fp << int(ge_eSave_Script) << '\n';
  fp << int(ge_eSave_Script_script_len) << FSPACE << script_len << '\n';
  fp << int(ge_eSave_Script_script) << '\n';
  fp << "\"";
  for (char* s = script; *s; s++) {
    if (*s == '"')
      fp << "\\";
    fp << *s;
  }
  fp << '\n' << "\"\n";
  fp << int(ge_eSave_End) << '\n';
}

void GeScript::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[200];
  char c;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeScript: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_Script:
      break;
    case ge_eSave_Script_script_len:
      fp >> script_len;
      break;
    case ge_eSave_Script_script: {
      fp.getline(dummy, sizeof(dummy));
      fp.get();
      int j = 0;
      while (1) {
        if (j > (int)sizeof(script))
          break;
        if ((c = fp.get()) == '"') {
          if (script[j - 1] == '\\')
            j--;
          else {
            script[j] = 0;
            break;
          }
        }
        script[j++] = c;
      }
      script[sizeof(script) - 1] = 0;
      break;
    }
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeScript:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeScript::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetClickSensitivity(dyn->graph->grow->ctx, glow_mSensitivity_MB1Click);
    grow_SetObjectColorInverse(object, 1);
    break;
  case glow_eEvent_MB1Up:
    grow_SetObjectColorInverse(object, 0);
    break;
  case glow_eEvent_Key_Return:
  case glow_eEvent_MB1Click:
    if (dyn->total_action_type1 & ge_mActionType1_Confirm)
      break;

    if (dyn->graph->command_cb) {
      int sts;

      // dyn->graph->get_command( command, cmd, dyn);
      sts = (dyn->graph->command_cb)(dyn->graph->parent_ctx, 0, script);
      return sts;
    }
    break;
  default:;
  }
  return 1;
}

int GeScript::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  if (streq(script, "")) {
    dyn->graph->syntax_msg('E', object, "Script.Script is missing");
    (*error_cnt)++;
  }
  return 1;
}

GeConfirm::GeConfirm(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No,
          ge_mActionType1_Confirm, ge_mActionType2_No, ge_eDynPrio_Confirm),
      on_set(0), on_reset(0)
{
  strcpy(text, "");
}

GeConfirm::GeConfirm(const GeConfirm& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      on_set(x.on_set), on_reset(x.on_reset)
{
  strcpy(text, x.text);
}

void GeConfirm::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "Confirm.Text");
  attrinfo[i].value = text;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(text);

  strcpy(attrinfo[i].name, "Confirm.OnSet");
  attrinfo[i].value = &on_set;
  attrinfo[i].type = glow_eType_Boolean;
  attrinfo[i++].size = sizeof(on_set);

  strcpy(attrinfo[i].name, "Confirm.OnReset");
  attrinfo[i].value = &on_reset;
  attrinfo[i].type = glow_eType_Boolean;
  attrinfo[i++].size = sizeof(on_reset);

  dyn->display_access = true;
  *item_count = i;
}

void GeConfirm::save(std::ofstream& fp)
{
  fp << int(ge_eSave_Confirm) << '\n';
  fp << int(ge_eSave_Confirm_text) << FSPACE << text << '\n';
  fp << int(ge_eSave_Confirm_on_set) << FSPACE << on_set << '\n';
  fp << int(ge_eSave_Confirm_on_reset) << FSPACE << on_reset << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeConfirm::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeConfirm: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_Confirm:
      break;
    case ge_eSave_Confirm_text:
      fp.get();
      fp.getline(text, sizeof(text));
      break;
    case ge_eSave_Confirm_on_set:
      fp >> on_set;
      break;
    case ge_eSave_Confirm_on_reset:
      fp >> on_reset;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeConfirm:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeConfirm::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  if (!(dyn->total_action_type1 & ge_mActionType1_Confirm))
    return 1;

  switch (event->event) {
  case glow_eEvent_Key_Return:
  case glow_eEvent_MB1Click: {
    if (dyn->total_action_type1 & ge_mActionType1_ValueInput)
      return 1;

    int skip = 0;
    if (((on_set && !on_reset) || (on_reset && !on_set))
        && dyn->total_action_type1 & ge_mActionType1_ToggleDig) {
      for (GeDynElem* elem = dyn->elements; elem; elem = elem->next) {
        if (elem->action_type1 == ge_mActionType1_ToggleDig) {
          pwr_tAName parsed_name;
          int inverted;
          int attr_type, attr_size;
          graph_eDatabase db;
          pwr_tBoolean value;
          pwr_tStatus sts;

          db = dyn->parse_attr_name(((GeToggleDig*)elem)->attribute,
              parsed_name, &inverted, &attr_type, &attr_size);
          if (parsed_name[0] == '&')
            dyn->graph->get_reference_name(parsed_name, parsed_name);

          switch (db) {
          case graph_eDatabase_Gdh: {
            sts = gdh_GetObjectInfo(parsed_name, &value, sizeof(value));
            if (EVEN(sts)) {
              printf("Confirm error: %s\n", parsed_name);
              break;
            }
            if ((on_set && value == 1) || (on_reset && value == 0))
              skip = 1;
            break;
          }
          default:;
          }
          break;
        }
      }
    }
    if (skip) {
      dyn->confirmed_action(object, event);
      return 1;
    }

    if (dyn->graph->confirm_cb) {
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(text, text);
      (dyn->graph->confirm_cb)(dyn->graph->parent_ctx, object, text);
    }
    break;
  }
  default:;
  }
  return 1;
}

int GeConfirm::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynConfirm(" << var_name << ".dd, \"" << text << "\")\n";
  return 1;
}

int GeConfirm::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  if (streq(text, "")) {
    dyn->graph->syntax_msg('E', object, "Confirm.Text is missing");
    (*error_cnt)++;
  }
  return 1;
}

GeIncrAnalog::GeIncrAnalog(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No,
          ge_mActionType1_IncrAnalog, ge_mActionType2_No,
          ge_eDynPrio_IncrAnalog),
      increment(1), min_value(0), max_value(0)
{
  strcpy(attribute, "");
}

GeIncrAnalog::GeIncrAnalog(const GeIncrAnalog& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      increment(x.increment), min_value(x.min_value), max_value(x.max_value)
{
  strcpy(attribute, x.attribute);
}

void GeIncrAnalog::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "IncrAnalog.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  strcpy(attrinfo[i].name, "IncrAnalog.Increment");
  attrinfo[i].value = &increment;
  attrinfo[i].type = glow_eType_Double;
  attrinfo[i++].size = sizeof(increment);

  strcpy(attrinfo[i].name, "IncrAnalog.MinValue");
  attrinfo[i].value = &min_value;
  attrinfo[i].type = glow_eType_Double;
  attrinfo[i++].size = sizeof(min_value);

  strcpy(attrinfo[i].name, "IncrAnalog.MaxValue");
  attrinfo[i].value = &max_value;
  attrinfo[i].type = glow_eType_Double;
  attrinfo[i++].size = sizeof(max_value);

  dyn->display_access = true;
  *item_count = i;
}

void GeIncrAnalog::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "IncrAnalog.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeIncrAnalog::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeIncrAnalog::save(std::ofstream& fp)
{
  fp << int(ge_eSave_IncrAnalog) << '\n';
  fp << int(ge_eSave_IncrAnalog_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_IncrAnalog_increment) << FSPACE << increment << '\n';
  fp << int(ge_eSave_IncrAnalog_min_value) << FSPACE << min_value << '\n';
  fp << int(ge_eSave_IncrAnalog_max_value) << FSPACE << max_value << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeIncrAnalog::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeIncrAnalog: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_IncrAnalog:
      break;
    case ge_eSave_IncrAnalog_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_IncrAnalog_increment:
      fp >> increment;
      break;
    case ge_eSave_IncrAnalog_min_value:
      fp >> min_value;
      break;
    case ge_eSave_IncrAnalog_max_value:
      fp >> max_value;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeIncrAnalog:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeIncrAnalog::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetClickSensitivity(dyn->graph->grow->ctx, glow_mSensitivity_MB1Click);
    grow_SetObjectColorInverse(object, 1);
    break;
  case glow_eEvent_MB1Up:
    grow_SetObjectColorInverse(object, 0);
    break;
  case glow_eEvent_Key_Return:
  case glow_eEvent_MB1Click: {
    int sts;
    pwr_tAName parsed_name;
    int inverted;
    int attr_type, attr_size;

    dyn->parse_attr_name(
        attribute, parsed_name, &inverted, &attr_type, &attr_size);
    if (parsed_name[0] == '&')
      dyn->graph->get_reference_name(parsed_name, parsed_name);

    switch (attr_type) {
    case pwr_eType_Int32: {
      pwr_tInt32 value;
      sts = gdh_GetObjectInfo(parsed_name, &value, sizeof(value));
      if (EVEN(sts)) {
        printf("IncrAnalog error: %s\n", attribute);
        break;
      }

      value += int(increment > 0 ? increment + 0.5 : increment - 0.5);
      if (!(feq(min_value, 0.0) && feq(max_value, 0.0))) {
        value = MAX(
            value, int(min_value > 0 ? min_value + 0.5 : min_value - 0.5));
        value = MIN(
            value, int(max_value > 0 ? max_value + 0.5 : max_value - 0.5));
      }
      sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
      if (EVEN(sts))
        printf("IncrAnalog error: %s\n", attribute);
      break;
    }
    default: {
      pwr_tFloat32 value;
      sts = gdh_GetObjectInfo(parsed_name, &value, sizeof(value));
      if (EVEN(sts)) {
        printf("IncrAnalog error: %s\n", attribute);
        break;
      }

      value += increment;
      if (!(feq(min_value, 0.0) && feq(max_value, 0.0))) {
        value = MAX(value, min_value);
        value = MIN(value, max_value);
      }
      sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
      if (EVEN(sts))
        printf("IncrAnalog error: %s\n", attribute);
    }
    }
    break;
  }
  default:;
  }
  return 1;
}

int GeIncrAnalog::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynIncrAnalog(" << var_name << ".dd, \"" << attribute << "\","
     << increment << "," << min_value << "," << max_value << ")\n";
  return 1;
}

int GeIncrAnalog::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Int32, pwr_eType_UInt32, pwr_eType_Float32, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase__ };
  dyn->syntax_check_attribute(object, "IncrAnalog.Attribute", attribute, 0,
      types, databases, error_cnt, warning_cnt);
  return 1;
}

GeRadioButton::GeRadioButton(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No,
          ge_mActionType1_RadioButton, ge_mActionType2_No,
          ge_eDynPrio_RadioButton)
{
  strcpy(attribute, "");
}

GeRadioButton::GeRadioButton(const GeRadioButton& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio)
{
  strcpy(attribute, x.attribute);
}

void GeRadioButton::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "RadioButton.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  dyn->display_access = true;
  *item_count = i;
}

void GeRadioButton::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "RadioButton.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeRadioButton::replace_attribute(
    char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeRadioButton::save(std::ofstream& fp)
{
  fp << int(ge_eSave_RadioButton) << '\n';
  fp << int(ge_eSave_RadioButton_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeRadioButton::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeRadioButton: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_RadioButton:
      break;
    case ge_eSave_RadioButton_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeRadioButton:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeRadioButton::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  switch (db) {
  case graph_eDatabase_Gdh:
    sts = dyn->graph->ref_object_info(
        dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
    if (EVEN(sts))
      return sts;
    break;
  case graph_eDatabase_Ccm:
    sts = dyn->graph->ccm_ref_variable(parsed_name, attr_type, (void**)&p);
    if (EVEN(sts))
      return sts;
    break;
  default:;
  }

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeRadioButton::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;
  return 1;
}

int GeRadioButton::scan(grow_tObject object)
{
  if (!p)
    return 1;

  if (!first_scan) {
    if (old_value == *p) {
      // No change since last time
      return 1;
    }
  } else
    first_scan = false;

  if ((!inverted && *p) || (inverted && !*p)) {
    grow_SetObjectLastNodeClass(object);
  } else {
    grow_SetObjectFirstNodeClass(object);
  }
  old_value = *p;
  return 1;
}

int GeRadioButton::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetClickSensitivity(dyn->graph->grow->ctx, glow_mSensitivity_MB1Click);
    grow_SetObjectColorInverse(object, 1);
    break;
  case glow_eEvent_MB1Up:
    grow_SetObjectColorInverse(object, 0);
    break;
  case glow_eEvent_MB1Click: {
    grow_tObject group;
    grow_tObject *objectlist, *object_p;
    int object_cnt;
    int sts;
    pwr_tAName parsed_name;
    int inverted;
    int attr_type, attr_size;
    pwr_tBoolean value;

    if (dyn->total_action_type1 & ge_mActionType1_Confirm)
      break;

    sts = grow_GetObjectGroup(dyn->graph->grow->ctx, object, &group);
    if (EVEN(sts))
      break;

    grow_GetGroupObjectList(group, &objectlist, &object_cnt);
    object_p = objectlist;
    for (int i = 0; i < object_cnt; i++) {
      if (*object_p != event->object.object
          && grow_GetObjectType(*object_p) == glow_eObjectType_GrowNode) {
        value = 0;

        GeDyn* gm_dyn;

        grow_GetUserData(*object_p, (void**)&gm_dyn);
        if (gm_dyn->total_action_type1 & ge_mActionType1_RadioButton) {
          for (GeDynElem* elem = gm_dyn->elements; elem; elem = elem->next) {
            if (elem->action_type1 == ge_mActionType1_RadioButton) {
              dyn->parse_attr_name(((GeRadioButton*)elem)->attribute,
                  parsed_name, &inverted, &attr_type, &attr_size);
              if (parsed_name[0] == '&')
                dyn->graph->get_reference_name(parsed_name, parsed_name);

              switch (db) {
              case graph_eDatabase_Gdh:
                sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
                break;
              case graph_eDatabase_Ccm:
                sts = dyn->graph->ccm_set_variable(
                    parsed_name, attr_type, &value);
                break;
              default:;
              }
            }
          }
        }
      }
      object_p++;
    }

    value = 1;

    dyn->parse_attr_name(
        attribute, parsed_name, &inverted, &attr_type, &attr_size);
    switch (db) {
    case graph_eDatabase_Gdh:
      sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
      break;
    case graph_eDatabase_Ccm:
      sts = dyn->graph->ccm_set_variable(parsed_name, attr_type, &value);
      break;
    default:;
    }
    if (EVEN(sts))
      printf("RadioButton error: %s\n", attribute);
    break;
  }
  default:;
  }
  return 1;
}

int GeRadioButton::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynRadioButton(" << var_name << ".dd, \"" << attribute << "\")"
     << '\n';
  return 1;
}

int GeRadioButton::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  grow_tObject group;
  int sts;

  int types[] = { pwr_eType_Boolean, 0 };
  graph_eDatabase databases[]
      = { graph_eDatabase_Local, graph_eDatabase_Gdh, graph_eDatabase__ };
  dyn->syntax_check_attribute(object, "RadioButton.Attribute", attribute, 0,
      types, databases, error_cnt, warning_cnt);

  sts = grow_GetObjectGroup(dyn->graph->grow->ctx, object, &group);
  if (EVEN(sts)) {
    dyn->graph->syntax_msg('E', object, "RadioButton is not member of a group");
    (*error_cnt)++;
  }

  return 1;
}

GeTipText::GeTipText(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No,
          ge_mActionType1_TipText, ge_mActionType2_No, ge_eDynPrio_TipText)
{
  strcpy(text, "");
}

GeTipText::GeTipText(const GeTipText& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio)
{
  strcpy(text, x.text);
}

void GeTipText::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "ToolTip.Text");
  attrinfo[i].value = text;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(text);
  *item_count = i;
}

void GeTipText::save(std::ofstream& fp)
{
  fp << int(ge_eSave_TipText) << '\n';
  fp << int(ge_eSave_TipText_text) << FSPACE << text << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeTipText::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeTipText: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_TipText:
      break;
    case ge_eSave_TipText_text:
      fp.get();
      fp.getline(text, sizeof(text));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(text, text);
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeTipText:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeTipText::action(grow_tObject object, glow_tEvent event)
{
  switch (event->event) {
  case glow_eEvent_TipText: {
    if (streq(text, "")) {
      pwr_tAName attr;
      char value[80];
      pwr_tAName parsed_name;
      int inverted;
      int attr_type, attr_size;
      int sts;
      int found = 0;

      // Fetch text from Description for popup menu object
      if (dyn->total_action_type1 & ge_mActionType1_PopupMenu) {
        for (GeDynElem* elem = dyn->elements; elem; elem = elem->next) {
          if (elem->action_type1 == ge_mActionType1_PopupMenu) {
            strncpy(attr, ((GePopupMenu*)elem)->ref_object, sizeof(attr));
            strncat(attr, ".Description", sizeof(attr) - strlen(attr) - 1);
            found = 1;
            break;
          }
        }
      } else if (dyn->total_dyn_type1 & ge_mDynType1_HostObject) {
        for (GeDynElem* elem = dyn->elements; elem; elem = elem->next) {
          if (elem->dyn_type1 == ge_mDynType1_HostObject) {
            strncpy(attr, ((GeHostObject*)elem)->hostobject, sizeof(attr));
            strncat(attr, ".Description", sizeof(attr) - strlen(attr) - 1);
            found = 1;
            break;
          }
        }
      }
      if (found) {
        dyn->parse_attr_name(
            attr, parsed_name, &inverted, &attr_type, &attr_size);
        sts = gdh_GetObjectInfo(parsed_name, value, sizeof(value));
        if (EVEN(sts))
          printf("ToolTip error: %s\n", attr);

        grow_SetTipText(dyn->graph->grow->ctx, event->object.object, value,
            event->any.x_pixel, event->any.y_pixel);
      }
    } else if (text[0] == '&') {
      char value[80];
      pwr_tAName parsed_name;
      int inverted;
      int attr_type, attr_size;
      int sts;

      dyn->parse_attr_name(
          &text[1], parsed_name, &inverted, &attr_type, &attr_size);
      sts = gdh_GetObjectInfo(parsed_name, value, sizeof(value));
      if (EVEN(sts))
        printf("ToolTip error: %s\n", text);

      grow_SetTipText(dyn->graph->grow->ctx, event->object.object, value,
          event->any.x_pixel, event->any.y_pixel);
    } else {
      grow_SetTipText(dyn->graph->grow->ctx, event->object.object, text,
          event->any.x_pixel, event->any.y_pixel);
    }
    break;
  }
  default:;
  }
  return 1;
}

int GeTipText::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  if (grow_GetTranslate(dyn->graph->grow->ctx))
    fp << "new GeDynTipText(" << var_name << ".dd, JopLang.transl(\"" << text
       << "\"))\n";
  else
    fp << "new GeDynTipText(" << var_name << ".dd, \"" << text << "\")\n";
  return 1;
}

int GeTipText::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  if (streq(text, "")) {
    dyn->graph->syntax_msg('E', object, "ToolTip.Text is missing");
    (*error_cnt)++;
  }
  return 1;
}

GeHelp::GeHelp(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No, ge_mActionType1_Help,
          ge_mActionType2_No, ge_eDynPrio_Help)
{
  strcpy(topic, "");
  strcpy(bookmark, "");
}

GeHelp::GeHelp(const GeHelp& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio)
{
  strcpy(topic, x.topic);
  strcpy(bookmark, x.bookmark);
}

void GeHelp::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "Help.Topic");
  attrinfo[i].value = topic;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(topic);

  strcpy(attrinfo[i].name, "Help.Bookmark");
  attrinfo[i].value = bookmark;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(bookmark);

  dyn->display_access = true;
  *item_count = i;
}

int GeHelp::get_transtab(char** tt)
{
  static char transtab[][32]
      = { "SubGraph", "SubGraph", "A1", "Text", "Dynamic", "", "" };

  *tt = (char*)transtab;
  return 0;
}

void GeHelp::save(std::ofstream& fp)
{
  fp << int(ge_eSave_Help) << '\n';
  fp << int(ge_eSave_Help_topic) << FSPACE << topic << '\n';
  fp << int(ge_eSave_Help_bookmark) << FSPACE << bookmark << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeHelp::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeHelp: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_Help:
      break;
    case ge_eSave_Help_topic:
      fp.get();
      fp.getline(topic, sizeof(topic));
      break;
    case ge_eSave_Help_bookmark:
      fp.get();
      fp.getline(bookmark, sizeof(bookmark));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeHelp:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeHelp::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetClickSensitivity(dyn->graph->grow->ctx, glow_mSensitivity_MB1Click);
    grow_SetObjectColorInverse(object, 1);
    break;
  case glow_eEvent_MB1Up:
    grow_SetObjectColorInverse(object, 0);
    break;
  case glow_eEvent_Key_Return:
  case glow_eEvent_MB1Click:
    if (dyn->total_action_type1 & ge_mActionType1_Confirm)
      break;

    if (dyn->graph->command_cb) {
      char command[400];
      char cmd[400];

      if (!streq(bookmark, ""))
        sprintf(command, "help %s /bookmark=%s", topic, bookmark);
      else
        sprintf(command, "help %s", topic);
      dyn->graph->get_command(command, cmd, dyn);
      (dyn->graph->command_cb)(dyn->graph->parent_ctx, cmd, 0);
    }
    break;
  default:;
  }
  return 1;
}

int GeHelp::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  char command[200];

  if (!streq(bookmark, ""))
    sprintf(command, "help %s /bookmark=%s", topic, bookmark);
  else
    sprintf(command, "help %s", topic);

  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynCommand(" << var_name << ".dd, \"" << GeDyn::cmd_cnv(command)
     << "\")\n";
  return 1;
}

int GeHelp::syntax_check(grow_tObject object, int* error_cnt, int* warning_cnt)
{
  if (streq(topic, "")) {
    dyn->graph->syntax_msg('E', object, "Help.Topic is missing");
    (*error_cnt)++;
  }
  return 1;
}

GeOpenGraph::GeOpenGraph(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No,
          ge_mActionType1_OpenGraph, ge_mActionType2_No, ge_eDynPrio_OpenGraph)
{
  strcpy(graph_object, "");
}

GeOpenGraph::GeOpenGraph(const GeOpenGraph& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio)
{
  strcpy(graph_object, x.graph_object);
}

void GeOpenGraph::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "OpenGraph.GraphObject");
  attrinfo[i].value = graph_object;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(graph_object);

  dyn->display_access = true;
  *item_count = i;
}

int GeOpenGraph::get_transtab(char** tt)
{
  static char transtab[][32]
      = { "SubGraph", "SubGraph", "A1", "Text", "Dynamic", "", "" };

  *tt = (char*)transtab;
  return 0;
}

void GeOpenGraph::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];
    char* s;

    strncpy(graph_object, attr_name, sizeof(graph_object));
    if ((s = strrchr(graph_object, '.')))
      *s = 0;
    snprintf(msg, sizeof(msg), "OpenGraph.GraphObject = %s", graph_object);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeOpenGraph::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(
      graph_object, sizeof(graph_object), from, to, cnt, strict);
}

void GeOpenGraph::save(std::ofstream& fp)
{
  fp << int(ge_eSave_OpenGraph) << '\n';
  fp << int(ge_eSave_OpenGraph_graph_object) << FSPACE << graph_object << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeOpenGraph::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeOpenGraph: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_OpenGraph:
      break;
    case ge_eSave_OpenGraph_graph_object:
      fp.get();
      fp.getline(graph_object, sizeof(graph_object));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeOpenGraph:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeOpenGraph::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetClickSensitivity(dyn->graph->grow->ctx, glow_mSensitivity_MB1Click);
    grow_SetObjectColorInverse(object, 1);
    break;
  case glow_eEvent_MB1Up:
    grow_SetObjectColorInverse(object, 0);
    break;
  case glow_eEvent_Key_Return:
  case glow_eEvent_MB1Click:
    if (dyn->total_action_type1 & ge_mActionType1_Confirm)
      break;

    if (dyn->graph->command_cb) {
      char command[430];
      char cmd[400] = "";

      if (!streq(graph_object, ""))
        sprintf(command, "open graph/object=%s", graph_object);
      else {
        // Open classgraph for popup menu object
        if (dyn->total_action_type1 & ge_mActionType1_PopupMenu) {
          for (GeDynElem* elem = dyn->elements; elem; elem = elem->next) {
            if (elem->action_type1 == ge_mActionType1_PopupMenu) {
              sprintf(command, "open graph/class/instance=%s",
                  ((GePopupMenu*)elem)->ref_object);
              break;
            }
          }
        } else if (dyn->total_dyn_type1 & ge_mDynType1_HostObject) {
          for (GeDynElem* elem = dyn->elements; elem; elem = elem->next) {
            if (elem->dyn_type1 == ge_mDynType1_HostObject) {
              sprintf(command, "open graph/class/instance=%s",
                  ((GeHostObject*)elem)->hostobject);
              break;
            }
          }
        }
      }
      if (!streq(command, "")) {
        dyn->graph->get_command(command, cmd, dyn);
        (dyn->graph->command_cb)(dyn->graph->parent_ctx, cmd, 0);
      }
    }
    break;
  default:;
  }
  return 1;
}

int GeOpenGraph::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  char command[200];

  sprintf(command, "open graph /object=%s", graph_object);

  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynCommand(" << var_name << ".dd, \"" << GeDyn::cmd_cnv(command)
     << "\")\n";
  return 1;
}

int GeOpenGraph::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int sts;
  pwr_eType a_type;

  if (!streq(graph_object, "")) {
    sts = dyn->graph->check_ldh_object(graph_object, &a_type);
    if (EVEN(sts)) {
      char msg[300];
      sprintf(msg, "OpenGraph.GraphObject \"%s\" not found", graph_object);
      dyn->graph->syntax_msg('W', object, msg);
      (*warning_cnt)++;
    } else {
      if (a_type != pwr_cClass_XttGraph) {
        dyn->graph->syntax_msg(
            'E', object, "OpenGraph.GraphObject is of wrong class");
        (*error_cnt)++;
      }
    }
  } else {
    int found = 0;
    // For HostObject and PopupMenu object is fetched from these dynamics
    for (GeDynElem* elem = dyn->elements; elem; elem = elem->next) {
      if (elem->dyn_type1 == ge_mDynType1_HostObject
          || elem->action_type1 == ge_mActionType1_PopupMenu) {
        found = 1;
        break;
      }
    }
    if (!found) {
      dyn->graph->syntax_msg('W', object, "OpenGraph.GraphObject is missing");
      (*warning_cnt)++;
    }
  }
  return 1;
}

GeOpenURL::GeOpenURL(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No,
          ge_mActionType1_OpenURL, ge_mActionType2_No, ge_eDynPrio_OpenURL)
{
  strcpy(url, "");
}

GeOpenURL::GeOpenURL(const GeOpenURL& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio)
{
  strcpy(url, x.url);
}

void GeOpenURL::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "OpenURL.URL");
  attrinfo[i].value = url;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(url);

  dyn->display_access = true;
  *item_count = i;
}

int GeOpenURL::get_transtab(char** tt)
{
  static char transtab[][32]
      = { "SubGraph", "SubGraph", "A1", "Text", "Dynamic", "", "" };

  *tt = (char*)transtab;
  return 0;
}

void GeOpenURL::save(std::ofstream& fp)
{
  fp << int(ge_eSave_OpenURL) << '\n';
  fp << int(ge_eSave_OpenURL_url) << FSPACE << url << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeOpenURL::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeOpenURL: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_OpenURL:
      break;
    case ge_eSave_OpenURL_url:
      fp.get();
      fp.getline(url, sizeof(url));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeOpenURL:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeOpenURL::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetClickSensitivity(dyn->graph->grow->ctx, glow_mSensitivity_MB1Click);
    grow_SetObjectColorInverse(object, 1);
    break;
  case glow_eEvent_MB1Up:
    grow_SetObjectColorInverse(object, 0);
    break;
  case glow_eEvent_Key_Return:
  case glow_eEvent_MB1Click:
    if (dyn->total_action_type1 & ge_mActionType1_Confirm)
      break;

    if (dyn->graph->command_cb) {
      char command[400];
      char cmd[400];

      sprintf(command, "open url \"%s\"", url);
      dyn->graph->get_command(command, cmd, dyn);
      (dyn->graph->command_cb)(dyn->graph->parent_ctx, cmd, 0);
    }
    break;
  default:;
  }
  return 1;
}

int GeOpenURL::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  char command[220];
  sprintf(command, "open url \"%s\"", url);

  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynCommand(" << var_name << ".dd, \"" << GeDyn::cmd_cnv(command)
     << "\")\n";
  return 1;
}

int GeOpenURL::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  if (streq(url, "")) {
    dyn->graph->syntax_msg('W', object, "OpenURL.URL is missing");
    (*warning_cnt)++;
  }
  return 1;
}

GeInputFocus::GeInputFocus(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No,
          ge_mActionType1_InputFocus, ge_mActionType2_No,
          ge_eDynPrio_InputFocus),
      initial_focus(0), prev_tab(0)
{
  strcpy(next_horizontal, "");
  strcpy(next_vertical, "");
  strcpy(next_tab, "");
}

GeInputFocus::GeInputFocus(const GeInputFocus& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      initial_focus(x.initial_focus), prev_tab(0)
{
  strcpy(next_horizontal, x.next_horizontal);
  strcpy(next_vertical, x.next_vertical);
  strcpy(next_tab, x.next_tab);
}

void GeInputFocus::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "InputFocus.InitialFocus");
  attrinfo[i].value = &initial_focus;
  attrinfo[i].type = ge_eAttrType_InputFocus;
  attrinfo[i++].size = sizeof(initial_focus);

  strcpy(attrinfo[i].name, "InputFocus.NextHorizontal");
  attrinfo[i].value = next_horizontal;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(next_horizontal);

  strcpy(attrinfo[i].name, "InputFocus.NextVertical");
  attrinfo[i].value = next_vertical;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(next_vertical);

  strcpy(attrinfo[i].name, "InputFocus.NextTab");
  attrinfo[i].value = next_tab;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(next_tab);

  *item_count = i;
}

void GeInputFocus::save(std::ofstream& fp)
{
  fp << int(ge_eSave_InputFocus) << '\n';
  fp << int(ge_eSave_InputFocus_initial_focus) << FSPACE << initial_focus
     << '\n';
  fp << int(ge_eSave_InputFocus_next_horizontal) << FSPACE << next_horizontal
     << '\n';
  fp << int(ge_eSave_InputFocus_next_vertical) << FSPACE << next_vertical
     << '\n';
  fp << int(ge_eSave_InputFocus_next_tab) << FSPACE << next_tab << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeInputFocus::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeInputFocus: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_InputFocus:
      break;
    case ge_eSave_InputFocus_initial_focus:
      fp >> initial_focus;
      break;
    case ge_eSave_InputFocus_next_horizontal:
      fp.get();
      fp.getline(next_horizontal, sizeof(next_horizontal));
      break;
    case ge_eSave_InputFocus_next_vertical:
      fp.get();
      fp.getline(next_vertical, sizeof(next_vertical));
      break;
    case ge_eSave_InputFocus_next_tab:
      fp.get();
      fp.getline(next_tab, sizeof(next_tab));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeInputFocus:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeInputFocus::action(grow_tObject object, glow_tEvent event)
{
  int sts;
  grow_tObject next = NULL;
  int found;
  GeDyn* next_dyn;
  GeInputFocus* next_inputfocus;

  switch (event->event) {
  case glow_eEvent_MB1Click:
    grow_SetObjectInputFocus(object, 1, event->event);
    dyn->graph->set_inputfocus(1);
    break;
  case glow_eEvent_InputFocusInit:
    if (initial_focus & ge_mInputFocus_InitialFocus) {
      grow_SetObjectInputFocus(object, 1, event->event);
      if (dyn->graph->keyboard_cb) {
        // Get keyboard type from ValueInput
        graph_eKeyboard keyboard_type = graph_eKeyboard_Standard;
        for (GeDynElem* elem = dyn->elements; elem; elem = elem->next) {
          if (elem->action_type1 == ge_mActionType1_ValueInput) {
            keyboard_type = ((GeValueInput*)elem)->keyboard_type;
            break;
          }
        }
        (dyn->graph->keyboard_cb)(
            dyn->graph->parent_ctx, keyboard_mAction_Open, keyboard_type);
      }
    }
    break;
  case glow_eEvent_Key_Right:
    if (event->object.object_type != glow_eObjectType_NoObject) {
      found = 0;
      next_inputfocus = this;
      int objcnt = 0;
      while (!found) {
        if (!streq(next_inputfocus->next_horizontal, "")) {
          sts = grow_FindObjectByName(
              dyn->graph->grow->ctx, next_inputfocus->next_horizontal, &next);
          if (EVEN(sts))
            break;

          // Check that this object can handle input focus
          grow_GetUserData(next, (void**)&next_dyn);
          if (next_dyn->total_action_type1 & ge_mActionType1_InputFocus) {
            for (GeDynElem* elem = next_dyn->elements; elem;
                 elem = elem->next) {
              if (elem->action_type1 == ge_mActionType1_InputFocus) {
                next_inputfocus = (GeInputFocus*)elem;
                found = 1;
                break;
              }
            }
            if (found && grow_GetObjectVisibility(next) != glow_eVis_Visible)
              found = 0;
          }
        } else if (!streq(next_inputfocus->next_tab, "")) {
          sts = grow_FindObjectByName(
              dyn->graph->grow->ctx, next_inputfocus->next_tab, &next);
          if (EVEN(sts))
            break;

          // Check that this object can handle input focus
          grow_GetUserData(next, (void**)&next_dyn);
          if (next_dyn->total_action_type1 & ge_mActionType1_InputFocus) {
            for (GeDynElem* elem = next_dyn->elements; elem;
                 elem = elem->next) {
              if (elem->action_type1 == ge_mActionType1_InputFocus) {
                next_inputfocus = (GeInputFocus*)elem;
                found = 1;
                break;
              }
            }
            if (found && grow_GetObjectVisibility(next) != glow_eVis_Visible)
              found = 0;
          }
        }
        objcnt++;
        if (next_inputfocus == this || objcnt > 50)
          break;
      }

      if (found)
        grow_SetObjectInputFocus(next, 1, event->event);
      else
        grow_SetObjectInputFocus(object, 0, event->event);
    } else {
      // No current object with input focus, check initial mask
      if (initial_focus & ge_mInputFocus_FirstHorizontal)
        grow_SetObjectInputFocus(object, 1, event->event);
    }
    break;
  case glow_eEvent_Key_Left:
    if (event->object.object_type != glow_eObjectType_NoObject) {
      char name[80];
      grow_tObject *objectlist, *object_p;
      int object_cnt;
      int i;
      GeDyn* gm_dyn;
      grow_tObject prev = NULL;

      grow_GetObjectName(object, name, sizeof(name), glow_eName_Object);

      // Find object that has this object as next_horizontal
      grow_GetObjectList(dyn->graph->grow->ctx, &objectlist, &object_cnt);
      object_p = objectlist;
      found = 0;
      for (i = 0; i < object_cnt; i++) {
        if (grow_GetObjectType(*object_p) == glow_eObjectType_GrowNode
            || grow_GetObjectType(*object_p) == glow_eObjectType_GrowSlider
            || grow_GetObjectType(*object_p) == glow_eObjectType_GrowGroup) {
          grow_GetUserData(*object_p, (void**)&gm_dyn);
          if (gm_dyn->total_action_type1 & ge_mActionType1_InputFocus) {
            for (GeDynElem* elem = gm_dyn->elements; elem; elem = elem->next) {
              if (elem->action_type1 == ge_mActionType1_InputFocus) {
                if (streq(((GeInputFocus*)elem)->next_horizontal, name)) {
                  found = 1;
                  prev = *object_p;
                  break;
                }
              }
            }
          }
        }
        if (found)
          break;
        object_p++;
      }

      if (found) {
        // Check that this object can handle input focus
        GeDyn* prev_dyn;
        grow_GetUserData(prev, (void**)&prev_dyn);
        if (prev_dyn->total_action_type1 & ge_mActionType1_InputFocus)
          grow_SetObjectInputFocus(prev, 1, event->event);
        else
          grow_SetObjectInputFocus(object, 0, event->event);
      }
    } else {
      // No current object with input focus, check initial mask
      if (initial_focus & ge_mInputFocus_LastHorizontal)
        grow_SetObjectInputFocus(object, 1, event->event);
    }
    break;

  case glow_eEvent_Key_Down:
    if (event->object.object_type != glow_eObjectType_NoObject) {
      found = 0;
      if (!streq(next_vertical, "")) {
        sts = grow_FindObjectByName(
            dyn->graph->grow->ctx, next_vertical, &next);
        if (ODD(sts)) {
          // Check that this object can handle input focus
          GeDyn* next_dyn;
          grow_GetUserData(next, (void**)&next_dyn);
          if (next_dyn->total_action_type1 & ge_mActionType1_InputFocus)
            found = 1;
        }
      } else if (!streq(next_tab, "")) {
        sts = grow_FindObjectByName(dyn->graph->grow->ctx, next_tab, &next);
        if (ODD(sts)) {
          // Check that this object can handle input focus
          GeDyn* next_dyn;
          grow_GetUserData(next, (void**)&next_dyn);
          if (next_dyn->total_action_type1 & ge_mActionType1_InputFocus)
            found = 1;
        }
      }

      if (found)
        grow_SetObjectInputFocus(next, 1, event->event);
      else
        grow_SetObjectInputFocus(object, 0, event->event);
    } else {
      // No current object with input focus, check initial mask
      if (initial_focus & ge_mInputFocus_FirstVertical)
        grow_SetObjectInputFocus(object, 1, event->event);
    }
    break;
  case glow_eEvent_Key_Up:
    if (event->object.object_type != glow_eObjectType_NoObject) {
      char name[80];
      grow_tObject *objectlist, *object_p;
      int object_cnt;
      int i;
      GeDyn* gm_dyn;
      grow_tObject prev = NULL;
      int found;

      grow_GetObjectName(object, name, sizeof(name), glow_eName_Object);

      // Find object that has this object as next_vertical
      grow_GetObjectList(dyn->graph->grow->ctx, &objectlist, &object_cnt);
      object_p = objectlist;
      found = 0;
      for (i = 0; i < object_cnt; i++) {
        if (grow_GetObjectType(*object_p) == glow_eObjectType_GrowNode
            || grow_GetObjectType(*object_p) == glow_eObjectType_GrowSlider
            || grow_GetObjectType(*object_p) == glow_eObjectType_GrowGroup) {
          grow_GetUserData(*object_p, (void**)&gm_dyn);
          if (gm_dyn->total_action_type1 & ge_mActionType1_InputFocus) {
            for (GeDynElem* elem = gm_dyn->elements; elem; elem = elem->next) {
              if (elem->action_type1 == ge_mActionType1_InputFocus) {
                if (streq(((GeInputFocus*)elem)->next_vertical, name)) {
                  found = 1;
                  prev = *object_p;
                  break;
                }
              }
            }
          }
        }
        if (found)
          break;
        object_p++;
      }

      if (found) {
        // Check that this object can handle input focus
        GeDyn* prev_dyn;
        grow_GetUserData(prev, (void**)&prev_dyn);
        if (prev_dyn->total_action_type1 & ge_mActionType1_InputFocus)
          grow_SetObjectInputFocus(prev, 1, event->event);
        else
          grow_SetObjectInputFocus(object, 0, event->event);
      }
    } else {
      // No current object with input focus, check initial mask
      if (initial_focus & ge_mInputFocus_LastVertical)
        grow_SetObjectInputFocus(object, 1, event->event);
    }
    break;

  case glow_eEvent_Key_Tab:
    if (event->object.object_type != glow_eObjectType_NoObject) {
      found = 0;
      next_inputfocus = this;
      int objcnt = 0;
      while (!found) {
        if (!streq(next_inputfocus->next_tab, "")) {
          sts = grow_FindObjectByName(
              dyn->graph->grow->ctx, next_inputfocus->next_tab, &next);
          if (EVEN(sts))
            break;

          // Check that this object can handle input focus
          grow_GetUserData(next, (void**)&next_dyn);
          if (next_dyn->total_action_type1 & ge_mActionType1_InputFocus) {
            for (GeDynElem* elem = next_dyn->elements; elem;
                 elem = elem->next) {
              if (elem->action_type1 == ge_mActionType1_InputFocus) {
                next_inputfocus = (GeInputFocus*)elem;
                found = 1;
                break;
              }
            }
            if (found && grow_GetObjectVisibility(next) != glow_eVis_Visible)
              found = 0;
          }
        }
        objcnt++;
        if (next_inputfocus == this || objcnt > 50)
          break;
      }
      if (found) {
        grow_SetObjectInputFocus(next, 1, event->event);
        next_inputfocus->prev_tab = object;
      } else
        grow_SetObjectInputFocus(object, 0, event->event);
    } else {
      // No current object with input focus, check initial mask
      if (initial_focus & ge_mInputFocus_FirstTab)
        grow_SetObjectInputFocus(object, 1, event->event);
    }
    break;

  case glow_eEvent_Key_ShiftTab:
    if (event->object.object_type != glow_eObjectType_NoObject) {
      if (prev_tab) {
        GeDyn* prev_dyn;
        grow_GetUserData(prev_tab, (void**)&prev_dyn);
        if (prev_dyn->total_action_type1 & ge_mActionType1_InputFocus)
          grow_SetObjectInputFocus(prev_tab, 1, event->event);
        else
          grow_SetObjectInputFocus(object, 0, event->event);
      }
    }
    break;

  case glow_eEvent_Key_Escape:
    if (event->object.object_type != glow_eObjectType_NoObject) {
      grow_SetObjectInputFocus(object, 0, event->event);
    }
    break;

  default:;
  }
  return 1;
}

int GeInputFocus::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  grow_tObject next;
  int sts;

  if (!streq(next_horizontal, "")) {
    sts = grow_FindObjectByName(dyn->graph->grow->ctx, next_horizontal, &next);
    if (EVEN(sts)) {
      dyn->graph->syntax_msg(
          'E', object, "InputFocus.NextHorizontal, object not found");
      (*error_cnt)++;
    }
  }
  if (!streq(next_vertical, "")) {
    sts = grow_FindObjectByName(dyn->graph->grow->ctx, next_vertical, &next);
    if (EVEN(sts)) {
      dyn->graph->syntax_msg(
          'E', object, "InputFocus.NextVertical, object not found");
      (*error_cnt)++;
    }
  }
  if (!streq(next_tab, "")) {
    sts = grow_FindObjectByName(dyn->graph->grow->ctx, next_tab, &next);
    if (EVEN(sts)) {
      dyn->graph->syntax_msg(
          'E', object, "InputFocus.NextTab, object not found");
      (*error_cnt)++;
    }
  }
  if (initial_focus == 0 && streq(next_horizontal, "")
      && streq(next_vertical, "") && streq(next_tab, "")) {
    dyn->graph->syntax_msg('E', object, "InputFocus, no action found");
    (*error_cnt)++;
  }
  return 1;
}
void GeCloseGraph::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  dyn->display_access = true;
  *item_count = i;
}

void GeCloseGraph::save(std::ofstream& fp)
{
  fp << int(ge_eSave_CloseGraph) << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeCloseGraph::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeCloseGraph: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_CloseGraph:
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeCloseGraph:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeCloseGraph::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetClickSensitivity(dyn->graph->grow->ctx, glow_mSensitivity_MB1Click);
    grow_SetObjectColorInverse(object, 1);
    break;
  case glow_eEvent_MB1Up:
    grow_SetObjectColorInverse(object, 0);
    break;
  case glow_eEvent_MB1Click:
  case glow_eEvent_Key_Return:
    if (dyn->total_action_type1 & ge_mActionType1_Confirm)
      break;

    if (dyn->graph->close_cb) {
      (dyn->graph->close_cb)(dyn->graph->parent_ctx);
      return GLOW__TERMINATED;
    }
    break;
  default:;
  }
  return 1;
}

int GeCloseGraph::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynCloseGraph(" << var_name << ".dd)\n";
  return 1;
}

GeSlider::GeSlider(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No, ge_mActionType1_Slider,
          ge_mActionType2_No, ge_eDynPrio_Slider),
      min_value_p(0), max_value_p(0), old_min_value(0), old_max_value(0),
      insensitive_p(0)
{
  strcpy(attribute, "");
  strcpy(minvalue_attr, "");
  strcpy(maxvalue_attr, "");
  strcpy(insensitive_attr, "");
  strcpy(release_attr, "");
}

GeSlider::GeSlider(const GeSlider& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      min_value_p(0), max_value_p(0), old_min_value(0), old_max_value(0),
      insensitive_p(0)
{
  strcpy(attribute, x.attribute);
  strcpy(minvalue_attr, x.minvalue_attr);
  strcpy(maxvalue_attr, x.maxvalue_attr);
  strcpy(insensitive_attr, x.insensitive_attr);
  strcpy(release_attr, x.release_attr);
}

void GeSlider::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "Slider.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  strcpy(attrinfo[i].name, "Slider.MinValueAttr");
  attrinfo[i].value = minvalue_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(minvalue_attr);

  strcpy(attrinfo[i].name, "Slider.MaxValueAttr");
  attrinfo[i].value = maxvalue_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(maxvalue_attr);

  strcpy(attrinfo[i].name, "Slider.InsensitiveAttr");
  attrinfo[i].value = insensitive_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(insensitive_attr);

  strcpy(attrinfo[i].name, "Slider.ReleaseAttr");
  attrinfo[i].value = release_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(release_attr);

  dyn->display_access = true;
  *item_count = i;
}

void GeSlider::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "Slider.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeSlider::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
  GeDyn::replace_attribute(
      minvalue_attr, sizeof(minvalue_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      maxvalue_attr, sizeof(maxvalue_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      insensitive_attr, sizeof(insensitive_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      release_attr, sizeof(release_attr), from, to, cnt, strict);
}

void GeSlider::save(std::ofstream& fp)
{
  fp << int(ge_eSave_Slider) << '\n';
  fp << int(ge_eSave_Slider_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_Slider_minvalue_attr) << FSPACE << minvalue_attr << '\n';
  fp << int(ge_eSave_Slider_maxvalue_attr) << FSPACE << maxvalue_attr << '\n';
  fp << int(ge_eSave_Slider_insensitive_attr) << FSPACE << insensitive_attr
     << '\n';
  fp << int(ge_eSave_Slider_release_attr) << FSPACE << release_attr << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeSlider::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeSlider: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_Slider:
      break;
    case ge_eSave_Slider_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_Slider_minvalue_attr:
      fp.get();
      fp.getline(minvalue_attr, sizeof(minvalue_attr));
      break;
    case ge_eSave_Slider_maxvalue_attr:
      fp.get();
      fp.getline(maxvalue_attr, sizeof(maxvalue_attr));
      break;
    case ge_eSave_Slider_insensitive_attr:
      fp.get();
      fp.getline(insensitive_attr, sizeof(insensitive_attr));
      break;
    case ge_eSave_Slider_release_attr:
      fp.get();
      fp.getline(release_attr, sizeof(release_attr));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeSlider:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeSlider::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int inverted;
  pwr_tAName parsed_name;
  int sts;
  int a_type, a_size;

  size = 4;
  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &size);
  if (streq(parsed_name, ""))
    return 1;

  switch (attr_type) {
  case pwr_eType_Float32:
  case pwr_eType_Int32:
  case pwr_eType_Boolean:
    break;
  default:
    return 1;
  }
  sts = dyn->graph->ref_object_info(
      dyn->cycle, parsed_name, (void**)&p, &subid, size, object, now);
  if (EVEN(sts))
    return sts;

  trace_data->p = &pdummy;
  first_scan = true;
  slider_disabled = 0;

  // Get min and max position from sider background
  double max_value, min_value, max_pos, min_pos;
  glow_eDirection direction;
  double ll_x, ll_y, ur_x, ur_y;
  grow_tObject background;
  double origo;

  if (!grow_TransformIsStored(object)) {
    grow_StoreTransform(object);
    grow_MeasureNode(object, &ll_x, &ll_y, &ur_x, &ur_y);
    grow_GetSliderInfo(
        object, &direction, &max_value, &min_value, &max_pos, &min_pos);
    sts = grow_GetBackgroundObjectLimits(dyn->graph->grow->ctx,
        (glow_eTraceType)ge_mDynType1_SliderBackground, (ll_x + ur_x) / 2,
        (ll_y + ur_y) / 2, &background, &min_pos, &max_pos, &direction);
    if (ODD(sts)) {
      grow_GetSliderOrigo(object, direction, &origo);

      switch (direction) {
      case glow_eDirection_Down:
        grow_SetSliderInfo(object, direction, max_value, min_value,
            max_pos - origo, min_pos - origo);

        grow_MoveNode(object, ll_x, min_pos - origo);
        break;
      case glow_eDirection_Up:
        grow_SetSliderInfo(object, direction, max_value, min_value,
            max_pos - (ur_y - ll_y - origo), min_pos - (ur_y - ll_y - origo));
        grow_MoveNode(object, ll_x, min_pos - (ur_y - ll_y - origo));
        break;
      case glow_eDirection_Left:
        grow_SetSliderInfo(object, direction, max_value, min_value,
            max_pos - (ur_x - ll_x - origo), min_pos - (ur_x - ll_x - origo));
        grow_MoveNode(object, min_pos - (ur_x - ll_x - origo), ll_y);
        break;
      case glow_eDirection_Right:
        grow_SetSliderInfo(object, direction, max_value, min_value,
            max_pos - origo, min_pos - origo);

        grow_MoveNode(object, min_pos - origo, ll_y);
        break;
      default:;
      }
    }
    grow_StoreTransform(object);
  }

  min_value_p = 0;
  min_value_db = dyn->parse_attr_name(
      minvalue_attr, parsed_name, &inverted, &a_type, &a_size);
  if (!streq(parsed_name, "") && a_type == pwr_eType_Float32) {
    switch (min_value_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&min_value_p, &min_value_subid, a_size, object, now);
      break;
    case graph_eDatabase_Local:
      min_value_p = (pwr_tFloat32*)dyn->graph->localdb_ref_or_create(
          parsed_name, a_type);
      break;
    default:;
    }
  }

  max_value_p = 0;
  max_value_db = dyn->parse_attr_name(
      maxvalue_attr, parsed_name, &inverted, &a_type, &a_size);
  if (!streq(parsed_name, "") && a_type == pwr_eType_Float32) {
    switch (max_value_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&max_value_p, &max_value_subid, a_size, object, now);
      break;
    case graph_eDatabase_Local:
      max_value_p = (pwr_tFloat32*)dyn->graph->localdb_ref_or_create(
          parsed_name, a_type);
      break;
    default:;
    }
  }

  insensitive_p = 0;
  insensitive_db = dyn->parse_attr_name(
      insensitive_attr, parsed_name, &insensitive_inverted, &a_type, &a_size);
  if (!streq(parsed_name, "") && a_type == pwr_eType_Boolean) {
    switch (insensitive_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&insensitive_p, &insensitive_subid, a_size, object, now);
      break;
    case graph_eDatabase_Local:
      insensitive_p = (pwr_tBoolean*)dyn->graph->localdb_ref_or_create(
          parsed_name, a_type);
      break;
    default:;
    }
  }
  return 1;
}

int GeSlider::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;

  if (min_value_p && min_value_db == graph_eDatabase_Gdh) {
    gdh_UnrefObjectInfo(min_value_subid);
    min_value_p = 0;
  }
  if (max_value_p && max_value_db == graph_eDatabase_Gdh) {
    gdh_UnrefObjectInfo(max_value_subid);
    max_value_p = 0;
  }
  if (insensitive_p && insensitive_db == graph_eDatabase_Gdh) {
    gdh_UnrefObjectInfo(insensitive_subid);
    insensitive_p = 0;
  }
  return 1;
}

int GeSlider::scan(grow_tObject object)
{
  double max_value, min_value, max_pos, min_pos;
  glow_eDirection direction;

  if (!p)
    return 1;

  if (insensitive_p) {
    if (insensitive_inverted)
      slider_disabled = !*insensitive_p;
    else
      slider_disabled = *insensitive_p;
  }

  if (max_value_p && min_value_p
      && (!feqf(*max_value_p, old_max_value) || !feqf(*min_value_p, old_min_value))) {
    if (fabsf(*max_value_p - *min_value_p) > FLT_EPSILON) {
      first_scan = 1;
    }
    old_min_value = *min_value_p;
    old_max_value = *max_value_p;
  }

  if (!first_scan) {
    switch (attr_type) {
    case pwr_eType_Float32:
      if (fabs(old_value - *p) < FLT_EPSILON)
        // No change since last time
        return 1;
      break;
    case pwr_eType_Int32:
      if (*(pwr_tInt32*)p == old_ivalue)
        return 1;
      break;
    case pwr_eType_Boolean:
      if (*(pwr_tBoolean*)p == (pwr_tBoolean)old_ivalue)
        return 1;
      break;
    default:;
    }
  } else
    first_scan = 0;

  grow_GetSliderInfo(
      object, &direction, &max_value, &min_value, &max_pos, &min_pos);
  if (max_value_p && min_value_p && !feqf(*max_value_p, *min_value_p)) {
    max_value = *max_value_p;
    min_value = *min_value_p;
  }
  if (!feq(min_pos, max_pos)) {
    if (dyn->graph->current_slider != object && !feq(max_value, min_value)) {
      float value;
      double pos_x, pos_y;

      switch (attr_type) {
      case pwr_eType_Float32:
        value = *p;
        break;
      case pwr_eType_Boolean:
        value = (*(pwr_tBoolean*)p) ? 1 : 0;
        break;
      default:
        value = (float)(*(pwr_tInt32*)p);
        break;
      }

      switch (direction) {
      case glow_eDirection_Down:
        pos_y = (max_value - value) / (max_value - min_value)
            * (max_pos - min_pos);
        if (pos_y < 0)
          pos_y = 0;
        else if (pos_y > max_pos - min_pos)
          pos_y = max_pos - min_pos;
        pos_x = 0;
        break;
      case glow_eDirection_Right:
        pos_x = max_pos - min_pos
            - (value - min_value) / (max_value - min_value)
                * (max_pos - min_pos);
        if (pos_x < 0)
          pos_x = 0;
        else if (pos_x > max_pos - min_pos)
          pos_x = max_pos - min_pos;
        pos_y = 0;
        break;
      case glow_eDirection_Left:
        pos_x = max_pos - min_pos
            - (max_value - value) / (max_value - min_value)
                * (max_pos - min_pos);
        if (pos_x < 0)
          pos_x = 0;
        else if (pos_x > max_pos - min_pos)
          pos_x = max_pos - min_pos;
        pos_y = 0;
        break;
      default: // Up
        pos_y = (value - min_value) / (max_value - min_value)
            * (max_pos - min_pos);
        if (pos_y < 0)
          pos_y = 0;
        else if (pos_y > max_pos - min_pos)
          pos_y = max_pos - min_pos;
        pos_x = 0;
      }
      grow_SetObjectPosition(object, pos_x, pos_y);
    }
  }

  switch (attr_type) {
  case pwr_eType_Float32:
    old_value = *p;
    break;
  case pwr_eType_Int32:
    old_ivalue = *(pwr_tInt32*)p;
    break;
  case pwr_eType_Boolean:
    old_ivalue = *(pwr_tBoolean*)p;
    break;
  default:;
  }
  return 1;
}

int GeSlider::action(grow_tObject object, glow_tEvent event)
{
  if (insensitive_p) {
    if ((insensitive_inverted && !*insensitive_p)
        || (!insensitive_inverted && *insensitive_p))
      return 1;
  }

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetClickSensitivity(dyn->graph->grow->ctx, glow_mSensitivity_MB1Press);
    break;
  case glow_eEvent_SliderMoveEnd: {
    pwr_tAName parsed_name;
    int inverted;
    int attr_type, attr_size;
    pwr_tBoolean val = 1;
    pwr_tStatus sts;

    if (!streq(release_attr, "")) {
      dyn->parse_attr_name(
          release_attr, parsed_name, &inverted, &attr_type, &attr_size);
      switch (attr_type) {
      case pwr_eType_Boolean: {
        sts = gdh_SetObjectInfo(parsed_name, &val, sizeof(val));
        break;
      }
      default:;
      }
    }
    break;
  }
  case glow_eEvent_SliderMoveStart: {
    double max_value, min_value, max_pos, min_pos;
    glow_eDirection direction;

    if (!dyn->graph->is_authorized(dyn->access) || slider_disabled) {
      grow_SetMoveRestrictions(
          dyn->graph->grow->ctx, glow_eMoveRestriction_Disable, 0, 0, NULL);
      dyn->graph->current_slider = NULL;
      break;
    }
    grow_GetSliderInfo(
        object, &direction, &max_value, &min_value, &max_pos, &min_pos);
    if (direction == glow_eDirection_Right || direction == glow_eDirection_Left)
      grow_SetMoveRestrictions(dyn->graph->grow->ctx,
          glow_eMoveRestriction_HorizontalSlider, max_pos, min_pos,
          event->object.object);
    else
      grow_SetMoveRestrictions(dyn->graph->grow->ctx,
          glow_eMoveRestriction_VerticalSlider, max_pos, min_pos,
          event->object.object);

    dyn->graph->current_slider = object;
    break;
  }
  case glow_eEvent_SliderMoved: {
    double max_value, min_value, max_pos, min_pos;
    glow_eDirection direction;
    float value;
    int sts;
    double ll_x, ll_y, ur_x, ur_y;
    pwr_tAName parsed_name;
    int inverted;
    int attr_type, attr_size;

    grow_GetSliderInfo(
        object, &direction, &max_value, &min_value, &max_pos, &min_pos);
    if (!feq(min_pos, max_pos)) {
      if (max_value_p && min_value_p && !feqf(*max_value_p, *min_value_p)) {
        max_value = *max_value_p;
        min_value = *min_value_p;
      }
      grow_MeasureNode(object, &ll_x, &ll_y, &ur_x, &ur_y);

      switch (direction) {
      case glow_eDirection_Down:
        value = float(
            (max_pos - ll_y) / (max_pos - min_pos) * (max_value - min_value)
            + min_value);
        break;
      case glow_eDirection_Right:
        value = float(
            (max_pos - ll_x) / (max_pos - min_pos) * (max_value - min_value)
            + min_value);
        break;
      case glow_eDirection_Left:
        value = float(
            (ll_x - min_pos) / (max_pos - min_pos) * (max_value - min_value)
            + min_value);
        break;
      default:
        value = float(
            (ll_y - min_pos) / (max_pos - min_pos) * (max_value - min_value)
            + min_value);
      }
      if (value > max_value)
        value = max_value;
      if (value < min_value)
        value = min_value;

      dyn->parse_attr_name(
          attribute, parsed_name, &inverted, &attr_type, &attr_size);
      switch (attr_type) {
      case pwr_eType_Float32:
        sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
        old_value = value;
        break;
      case pwr_eType_Boolean: {
        pwr_tBoolean ivalue = (pwr_tBoolean)(value > 0.5 ? 1 : 0);
        sts = gdh_SetObjectInfo(parsed_name, &ivalue, sizeof(ivalue));
        break;
      }
      default: {
        pwr_tInt32 ivalue = (pwr_tInt32)(value > 0 ? value + 0.5 : value - 0.5);
        sts = gdh_SetObjectInfo(parsed_name, &ivalue, sizeof(ivalue));
      }
      }
      if (EVEN(sts))
        printf("Slider error: %s\n", attribute);
    }
    break;
  }
  default:;
  }
  return 1;
}

int GeSlider::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  double dim_x0, dim_x1, dim_y0, dim_y1;
  double min_pos, max_pos, min_value, max_value;
  glow_eDirection direction;
  grow_MeasureJavaBean(
      dyn->graph->grow->ctx, &dim_x1, &dim_x0, &dim_y1, &dim_y0);
  grow_GetSliderInfo(
      object, &direction, &max_value, &min_value, &max_pos, &min_pos);
  grow_GetSliderInfoPixel(
      object, &direction, &max_pos, &min_pos, ge_mDynType1_SliderBackground);

  switch (direction) {
  case glow_eDirection_Left:
  case glow_eDirection_Right:
    min_pos += -dim_x0 + glow_cJBean_Offset /*+ glow_cJBean_SizeCorr/2*/;
    max_pos += -dim_x0 + glow_cJBean_Offset /*+ glow_cJBean_SizeCorr/2*/;
    break;
  default:
    min_pos += -dim_y0 + glow_cJBean_Offset /*+ glow_cJBean_SizeCorr/2*/;
    max_pos += -dim_y0 + glow_cJBean_Offset /*+ glow_cJBean_SizeCorr/2*/;
  }

  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynSlider(" << var_name << ".dd, \"" << attribute << "\","
     << min_value << "," << max_value << "," << direction << "," << min_pos
     << "," << max_pos << ",";
  if (streq(minvalue_attr, ""))
    fp << "null,";
  else
    fp << "\"" << minvalue_attr << "\",";
  if (streq(maxvalue_attr, ""))
    fp << "null,";
  else
    fp << "\"" << maxvalue_attr << "\",";
  if (streq(insensitive_attr, ""))
    fp << "null,";
  else
    fp << "\"" << insensitive_attr << "\",";
  fp << dim_x1 - dim_x0 /* + 2 * glow_cJBean_Offset*/ << ","
     << dim_y1 - dim_y0 /* + 2 * glow_cJBean_Offset */ << ")\n";
  return 1;
}

int GeSlider::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Boolean, pwr_eType_Int32, pwr_eType_Float32, 0 };
  int types2[] = { pwr_eType_Float32, 0 };
  int types3[] = { pwr_eType_Boolean, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase__ };
  graph_eDatabase databases2[]
      = { graph_eDatabase_Local, graph_eDatabase_Gdh, graph_eDatabase__ };

  dyn->syntax_check_attribute(object, "Slider.Attribute", attribute, 0, types,
      databases, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "Slider.MinValueAttr", minvalue_attr, 1,
      types2, databases2, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "Slider.MaxValueAttr", maxvalue_attr, 1,
      types2, databases2, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "Slider.InsensitiveAttr",
      insensitive_attr, 1, types3, databases2, error_cnt, warning_cnt);
  dyn->syntax_check_attribute(object, "Slider.ReleaseAttr", release_attr, 1,
      types3, databases, error_cnt, warning_cnt);
  return 1;
}

GeFastCurve::GeFastCurve(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_FastCurve, ge_mDynType2_No,
          ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_FastCurve),
      curve_index1(0), curve_index2(0)
{
  strcpy(fast_object, "");
}

GeFastCurve::GeFastCurve(const GeFastCurve& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      curve_index1(x.curve_index1), curve_index2(x.curve_index2)
{
  strcpy(fast_object, x.fast_object);
}

void GeFastCurve::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "FastCurve.FastObject");
  attrinfo[i].value = fast_object;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(fast_object);

  strcpy(attrinfo[i].name, "FastCurve.CurveIndex1");
  attrinfo[i].value = &curve_index1;
  attrinfo[i].type = glow_eType_Int;
  attrinfo[i++].size = sizeof(curve_index1);

  strcpy(attrinfo[i].name, "FastCurve.CurveIndex2");
  attrinfo[i].value = &curve_index2;
  attrinfo[i].type = glow_eType_Int;
  attrinfo[i++].size = sizeof(curve_index2);

  *item_count = i;
}

void GeFastCurve::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char* s;

    strncpy(fast_object, attr_name, sizeof(fast_object));
    if ((s = strchr(fast_object, '.')))
      *s = 0;

    char msg[23 + sizeof(fast_object) +1];
    snprintf(msg, sizeof(msg), "FastCurve.FastObject = %s", fast_object);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeFastCurve::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(
      fast_object, sizeof(fast_object), from, to, cnt, strict);
}

void GeFastCurve::save(std::ofstream& fp)
{
  fp << int(ge_eSave_FastCurve) << '\n';
  fp << int(ge_eSave_FastCurve_fast_object) << FSPACE << fast_object << '\n';
  fp << int(ge_eSave_FastCurve_curve_index1) << FSPACE << curve_index1 << '\n';
  fp << int(ge_eSave_FastCurve_curve_index2) << FSPACE << curve_index2 << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeFastCurve::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeFastCurve: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_FastCurve:
      break;
    case ge_eSave_FastCurve_fast_object:
      fp.get();
      fp.getline(fast_object, sizeof(fast_object));
      break;
    case ge_eSave_FastCurve_curve_index1:
      fp >> curve_index1;
      break;
    case ge_eSave_FastCurve_curve_index2:
      fp >> curve_index2;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeFastCurve:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeFastCurve::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;
  int inverted;
  pwr_tAName attr_name;
  pwr_sClass_DsFastCurve fp;
  int i;

  dyn->parse_attr_name(
      fast_object, parsed_name, &inverted, &attr_type, &attr_size);
  sts = gdh_GetObjectInfo(parsed_name, &fp, sizeof(fp));
  if (EVEN(sts))
    return 1;

  max_points = fp.NoOfPoints;
  fast_function = fp.Function;

  if (fast_function & fast_mFunction_BeforeTrigg) {
    strcpy(attr_name, parsed_name);
    strcat(attr_name, ".TriggIndex");
    gdh_NameToAttrref(pwr_cNObjid, attr_name, &trigg_index_attr);

    strcpy(attr_name, parsed_name);
    strcat(attr_name, ".FirstIndex");
    gdh_NameToAttrref(pwr_cNObjid, attr_name, &first_index_attr);

    strcpy(attr_name, parsed_name);
    strcat(attr_name, ".LastIndex");
    gdh_NameToAttrref(pwr_cNObjid, attr_name, &last_index_attr);
  }

  // Subscribe to object
  strcpy(attr_name, parsed_name);
  strcat(attr_name, ".New");
  sts = dyn->graph->ref_object_info(dyn->cycle, attr_name, (void**)&new_p,
      &subid, sizeof(pwr_tBoolean), object, now);
  if (EVEN(sts))
    return sts;

  memcpy(&time_buff, &fp.TimeBuffer, sizeof(time_buff));

  fast_cnt = 0;
  if (curve_index1 == 0 && curve_index2 == 0) {
    for (i = 0; i < FAST_CURVES; i++) {
      if (fp.CurveValid[i]) {
        memcpy(&buff[fast_cnt], &fp.Buffers[i], sizeof(buff[0]));
        type[fast_cnt] = (pwr_eType)fp.AttributeType[i];
        fast_idx[i] = fast_cnt + 1;
        curve_idx[fast_cnt + 1] = i;
        fast_cnt++;
      }
    }
  } else {
    if (curve_index1 >= 0 && curve_index1 < FAST_CURVES
        && fp.CurveValid[curve_index1]) {
      i = curve_index1;
      memcpy(&buff[fast_cnt], &fp.Buffers[i], sizeof(buff[0]));
      type[fast_cnt] = (pwr_eType)fp.AttributeType[i];
      fast_idx[i] = fast_cnt + 1;
      curve_idx[fast_cnt + 1] = i;
      fast_cnt++;
    }
    if (curve_index2 >= 1 && curve_index2 < FAST_CURVES
        && fp.CurveValid[curve_index2]) {
      i = curve_index2;
      memcpy(&buff[fast_cnt], &fp.Buffers[i], sizeof(buff[0]));
      type[fast_cnt] = (pwr_eType)fp.AttributeType[i];
      fast_idx[i] = fast_cnt + 1;
      curve_idx[fast_cnt + 1] = i;
      fast_cnt++;
    }
  }

  for (i = 0; i < fast_cnt; i++) {
    switch (type[i]) {
    case pwr_eType_Float32:
    case pwr_eType_Int32:
    case pwr_eType_UInt32:
      element_size[i] = 4;
      break;
    case pwr_eType_Float64:
      element_size[i] = 8;
      break;
    case pwr_eType_Int16:
    case pwr_eType_UInt16:
      element_size[i] = 2;
      break;
    case pwr_eType_Int8:
    case pwr_eType_UInt8:
      element_size[i] = 1;
      break;
    default:
      element_size[i] = 4;
    }
  }

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeFastCurve::disconnect(grow_tObject object)
{
  if (new_p)
    gdh_UnrefObjectInfo(subid);
  new_p = 0;
  return 1;
}

int GeFastCurve::scan(grow_tObject object)
{
  if (!new_p)
    return 1;

  int i, j, k;
  pwr_tStatus sts;
  int trigg_index, first_index = 0, last_index = 0;
  double* data[DYN_FAST_MAX];

  // Check if any new value
  if ((*new_p && !old_new) || first_scan) {
    // Update curves
    if (fast_function & fast_mFunction_BeforeTrigg) {
      // Get first, last and trigg index
      sts = gdh_GetObjectInfoAttrref(
          &trigg_index_attr, &trigg_index, sizeof(trigg_index));
      if (EVEN(sts))
        return sts;
      sts = gdh_GetObjectInfoAttrref(
          &first_index_attr, &first_index, sizeof(first_index));
      if (EVEN(sts))
        return sts;
      sts = gdh_GetObjectInfoAttrref(
          &last_index_attr, &last_index, sizeof(last_index));
      if (EVEN(sts))
        return sts;

      // Read into temporary buffer
      pwr_tFloat32* tmp = (pwr_tFloat32*)calloc(max_points, 4);
      data[0] = (double*)calloc(max_points, 8);
      sts = gdh_GetObjectInfoAttrref(&time_buff, tmp, max_points * 4);
      if (EVEN(sts))
        return sts;

      k = first_index;
      for (j = 0; j < max_points; j++) {
        if (k >= max_points)
          k = 0;
        data[0][j] = tmp[k] - tmp[trigg_index];
        if (k == last_index)
          break;
        k++;
      }
      // If to few points, fill with dummy data
      for (; j < max_points; j++) {
        data[0][j] = tmp[k] - tmp[trigg_index];
      }
      free(tmp);
    } else {
      pwr_tFloat32* tmp = (pwr_tFloat32*)calloc(max_points, 4);
      data[0] = (double*)calloc(max_points, 8);
      sts = gdh_GetObjectInfoAttrref(&time_buff, tmp, max_points * 4);
      if (EVEN(sts))
        return sts;

      for (j = 0; j < max_points; j++)
        data[0][j] = tmp[j];
      free(tmp);
    }
    for (i = 0; i < fast_cnt; i++) {
      if (fast_function & fast_mFunction_BeforeTrigg) {
        // Read into temporary buffer
        void* tmp = calloc(max_points, element_size[i]);
        data[i + 1] = (double*)calloc(max_points, 8);
        sts = gdh_GetObjectInfoAttrref(
            &buff[i], tmp, max_points * element_size[i]);
        if (EVEN(sts))
          return sts;

        k = first_index;
        for (j = 0; j < max_points; j++) {
          if (k >= max_points)
            k = 0;
          switch (type[i]) {
          case pwr_eType_Float32:
            data[i + 1][j] = ((pwr_tFloat32*)tmp)[k];
            break;
          case pwr_eType_Float64:
            data[i + 1][j] = ((pwr_tFloat64*)tmp)[k];
            break;
          case pwr_eType_Int64:
            data[i + 1][j] = ((pwr_tInt64*)tmp)[k];
            break;
          case pwr_eType_UInt64:
            data[i + 1][j] = ((pwr_tUInt64*)tmp)[k];
            break;
          case pwr_eType_Int32:
            data[i + 1][j] = ((pwr_tInt32*)tmp)[k];
            break;
          case pwr_eType_UInt32:
            data[i + 1][j] = ((pwr_tUInt32*)tmp)[k];
            break;
          case pwr_eType_Int16:
            data[i + 1][j] = ((pwr_tUInt16*)tmp)[k];
            break;
          case pwr_eType_UInt16:
            data[i + 1][j] = ((pwr_tUInt16*)tmp)[k];
            break;
          case pwr_eType_Int8:
            data[i + 1][j] = ((pwr_tInt8*)tmp)[k];
            break;
          case pwr_eType_UInt8:
            data[i + 1][j] = ((pwr_tUInt8*)tmp)[k];
            break;
          default:;
          }
          if (k == last_index)
            break;
          k++;
        }
        // If to few points, fill with 0
        for (; j < max_points; j++) {
          switch (type[i]) {
          case pwr_eType_Float32:
            data[i + 1][j] = ((pwr_tFloat32*)tmp)[k];
            break;
          case pwr_eType_Float64:
            data[i + 1][j] = ((pwr_tFloat64*)tmp)[k];
            break;
          case pwr_eType_Int64:
            data[i + 1][j] = ((pwr_tInt32*)tmp)[k];
            break;
          case pwr_eType_UInt64:
            data[i + 1][j] = ((pwr_tUInt32*)tmp)[k];
            break;
          case pwr_eType_Int32:
            data[i + 1][j] = ((pwr_tInt32*)tmp)[k];
            break;
          case pwr_eType_UInt32:
            data[i + 1][j] = ((pwr_tUInt32*)tmp)[k];
            break;
          case pwr_eType_Int16:
            data[i + 1][j] = ((pwr_tInt16*)tmp)[k];
            break;
          case pwr_eType_UInt16:
            data[i + 1][j] = ((pwr_tInt16*)tmp)[k];
            break;
          case pwr_eType_Int8:
            data[i + 1][j] = ((pwr_tInt8*)tmp)[k];
            break;
          case pwr_eType_UInt8:
            data[i + 1][j] = ((pwr_tUInt8*)tmp)[k];
            break;
          default:;
          }
        }
        free(tmp);
      } else {
        void* tmp = calloc(max_points, element_size[i]);
        data[i + 1] = (double*)calloc(max_points, 8);
        sts = gdh_GetObjectInfoAttrref(
            &buff[i], tmp, max_points * element_size[i]);
        if (EVEN(sts))
          return sts;

        for (j = 0; j < max_points; j++) {
          switch (type[i]) {
          case pwr_eType_Float32:
            data[i + 1][j] = ((pwr_tFloat32*)tmp)[j];
            break;
          case pwr_eType_Float64:
            data[i + 1][j] = ((pwr_tFloat64*)tmp)[j];
            break;
          case pwr_eType_Int64:
            data[i + 1][j] = ((pwr_tInt32*)tmp)[j];
            break;
          case pwr_eType_UInt64:
            data[i + 1][j] = ((pwr_tUInt32*)tmp)[j];
            break;
          case pwr_eType_Int32:
            data[i + 1][j] = ((pwr_tInt32*)tmp)[j];
            break;
          case pwr_eType_UInt32:
            data[i + 1][j] = ((pwr_tUInt32*)tmp)[j];
            break;
          case pwr_eType_Int16:
            data[i + 1][j] = ((pwr_tInt16*)tmp)[j];
            break;
          case pwr_eType_UInt16:
            data[i + 1][j] = ((pwr_tInt16*)tmp)[j];
            break;
          case pwr_eType_Int8:
            data[i + 1][j] = ((pwr_tInt8*)tmp)[j];
            break;
          case pwr_eType_UInt8:
            data[i + 1][j] = ((pwr_tUInt8*)tmp)[j];
            break;
          default:;
          }
        }
        free(tmp);
      }
    }
    grow_SetTrendData(object, data, MIN(fast_cnt + 1, 3), max_points);
    for (i = 0; i < fast_cnt; i++)
      free(data[i]);
    first_scan = 0;
  }
  old_new = *new_p;

  return 1;
}

int GeFastCurve::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int sts;
  pwr_eType a_type;

  if (streq(fast_object, "")) {
    dyn->graph->syntax_msg('W', object, "FastCurve.FastObject is missing");
    (*warning_cnt)++;
  } else {
    sts = dyn->graph->check_ldh_object(fast_object, &a_type);
    if (EVEN(sts)) {
      char msg[440];
      sprintf(msg, "FastCurve.FastObject \"%s\" not found", fast_object);
      dyn->graph->syntax_msg('W', object, msg);
      (*warning_cnt)++;
    } else {
      if (a_type != pwr_cClass_DsFastCurve) {
        dyn->graph->syntax_msg(
            'E', object, "FastCurve.FastObject is of wrong class");
        (*error_cnt)++;
      }
    }
  }
  return 1;
}

GeDsTrend::GeDsTrend(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_DsTrend,
		ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_DsTrend),
      min_value1_p(0), max_value1_p(0), old_min_value1(0), old_max_value1(0),
      min_value2_p(0), max_value2_p(0), old_min_value2(0), old_max_value2(0),
      hold_p(0),
      mark1_color(glow_eDrawType_Inherit), mark2_color(glow_eDrawType_Inherit)
{
  strcpy(dstrend_object1, "");
  strcpy(dstrend_object2, "");
  strcpy(minvalue_attr1, "");
  strcpy(maxvalue_attr1, "");
  strcpy(minvalue_attr2, "");
  strcpy(maxvalue_attr2, "");
  strcpy(hold_attr, "");
  strcpy(mark1_attr, "");
  strcpy(mark2_attr, "");
}

GeDsTrend::GeDsTrend(const GeDsTrend& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
		x.prio),
      mark1_color(x.mark1_color), mark2_color(x.mark2_color)

{
  strcpy(dstrend_object1, x.dstrend_object1);
  strcpy(dstrend_object2, x.dstrend_object2);
  strcpy(minvalue_attr1, x.minvalue_attr1);
  strcpy(maxvalue_attr1, x.maxvalue_attr1);
  strcpy(minvalue_attr2, x.minvalue_attr2);
  strcpy(maxvalue_attr2, x.maxvalue_attr2);
  strcpy(hold_attr, x.hold_attr);
  strcpy(mark1_attr, x.mark1_attr);
  strcpy(mark2_attr, x.mark2_attr);
}

void GeDsTrend::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "DsTrend.Object1");
  attrinfo[i].value = dstrend_object1;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(dstrend_object1);

  strcpy(attrinfo[i].name, "DsTrend.Object2");
  attrinfo[i].value = dstrend_object2;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(dstrend_object2);

  strcpy(attrinfo[i].name, "DsTrend.MinValueAttr1");
  attrinfo[i].value = minvalue_attr1;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(minvalue_attr1);

  strcpy(attrinfo[i].name, "DsTrend.MaxValueAttr1");
  attrinfo[i].value = maxvalue_attr1;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(maxvalue_attr1);

  strcpy(attrinfo[i].name, "DsTrend.MinValueAttr2");
  attrinfo[i].value = minvalue_attr2;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(minvalue_attr2);

  strcpy(attrinfo[i].name, "DsTrend.MaxValueAttr2");
  attrinfo[i].value = maxvalue_attr2;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(maxvalue_attr2);

  strcpy(attrinfo[i].name, "DsTrend.HoldAttr");
  attrinfo[i].value = hold_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(hold_attr);

  strcpy(attrinfo[i].name, "DsTrend.Mark1Attr");
  attrinfo[i].value = mark1_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(mark1_attr);

  strcpy(attrinfo[i].name, "DsTrend.Mark2Attr");
  attrinfo[i].value = mark2_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(mark2_attr);

  strcpy(attrinfo[i].name, "DsTrend.Mark1Color");
  attrinfo[i].value = &mark1_color;
  attrinfo[i].type = glow_eType_Color;
  attrinfo[i++].size = sizeof(mark1_color);

  strcpy(attrinfo[i].name, "DsTrend.Mark2Color");
  attrinfo[i].value = &mark2_color;
  attrinfo[i].type = glow_eType_Color;
  attrinfo[i++].size = sizeof(mark2_color);

  *item_count = i;
}

void GeDsTrend::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char* s;

    strncpy(dstrend_object1, attr_name, sizeof(dstrend_object1));
    if ((s = strchr(dstrend_object1, '.')))
      *s = 0;

    char msg[23 + sizeof(dstrend_object1) +1];
    snprintf(msg, sizeof(msg), "DsTrend.Object1 = %s", dstrend_object1);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeDsTrend::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(
      dstrend_object1, sizeof(dstrend_object1), from, to, cnt, strict);
  GeDyn::replace_attribute(
      dstrend_object2, sizeof(dstrend_object2), from, to, cnt, strict);
  GeDyn::replace_attribute(
      minvalue_attr1, sizeof(minvalue_attr1), from, to, cnt, strict);
  GeDyn::replace_attribute(
      maxvalue_attr1, sizeof(maxvalue_attr1), from, to, cnt, strict);
  GeDyn::replace_attribute(
      minvalue_attr2, sizeof(minvalue_attr2), from, to, cnt, strict);
  GeDyn::replace_attribute(
      maxvalue_attr2, sizeof(maxvalue_attr2), from, to, cnt, strict);
  GeDyn::replace_attribute(hold_attr, sizeof(hold_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      mark1_attr, sizeof(mark1_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      mark2_attr, sizeof(mark2_attr), from, to, cnt, strict);
}

void GeDsTrend::save(std::ofstream& fp)
{
  fp << int(ge_eSave_DsTrend) << '\n';
  fp << int(ge_eSave_DsTrend_dstrend_object1) << FSPACE << dstrend_object1 << '\n';
  fp << int(ge_eSave_DsTrend_dstrend_object2) << FSPACE << dstrend_object2 << '\n';
  fp << int(ge_eSave_DsTrend_minvalue_attr1) << FSPACE << minvalue_attr1 << '\n';
  fp << int(ge_eSave_DsTrend_maxvalue_attr1) << FSPACE << maxvalue_attr1 << '\n';
  fp << int(ge_eSave_DsTrend_minvalue_attr2) << FSPACE << minvalue_attr2 << '\n';
  fp << int(ge_eSave_DsTrend_maxvalue_attr2) << FSPACE << maxvalue_attr2 << '\n';
  fp << int(ge_eSave_DsTrend_hold_attr) << FSPACE << hold_attr << '\n';
  fp << int(ge_eSave_DsTrend_mark1_attr) << FSPACE << mark1_attr << '\n';
  fp << int(ge_eSave_DsTrend_mark2_attr) << FSPACE << mark2_attr << '\n';
  fp << int(ge_eSave_DsTrend_mark1_color) << FSPACE << (int)mark1_color << '\n';
  fp << int(ge_eSave_DsTrend_mark2_color) << FSPACE << (int)mark2_color << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeDsTrend::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeDsTrend: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_DsTrend:
      break;
    case ge_eSave_DsTrend_dstrend_object1:
      fp.get();
      fp.getline(dstrend_object1, sizeof(dstrend_object1));
      break;
    case ge_eSave_DsTrend_dstrend_object2:
      fp.get();
      fp.getline(dstrend_object2, sizeof(dstrend_object2));
      break;
    case ge_eSave_DsTrend_minvalue_attr1:
      fp.get();
      fp.getline(minvalue_attr1, sizeof(minvalue_attr1));
      break;
    case ge_eSave_DsTrend_maxvalue_attr1:
      fp.get();
      fp.getline(maxvalue_attr1, sizeof(maxvalue_attr1));
      break;
    case ge_eSave_DsTrend_minvalue_attr2:
      fp.get();
      fp.getline(minvalue_attr2, sizeof(minvalue_attr2));
      break;
    case ge_eSave_DsTrend_maxvalue_attr2:
      fp.get();
      fp.getline(maxvalue_attr2, sizeof(maxvalue_attr2));
      break;
    case ge_eSave_DsTrend_hold_attr:
      fp.get();
      fp.getline(hold_attr, sizeof(hold_attr));
      break;
    case ge_eSave_DsTrend_mark1_attr:
      fp.get();
      fp.getline(mark1_attr, sizeof(mark1_attr));
      break;
    case ge_eSave_DsTrend_mark2_attr:
      fp.get();
      fp.getline(mark2_attr, sizeof(mark2_attr));
      break;
    case ge_eSave_DsTrend_mark1_color:
      fp >> tmp;
      mark1_color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_DsTrend_mark2_color:
      fp >> tmp;
      mark2_color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeDsTrend:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeDsTrend::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  pwr_tStatus sts;
  pwr_sClass_DsTrend tp[2];
  int time;
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int inverted;

  // Get current status of the trend objects
  dstrend_cnt = 0;
  for (int i = 0; i < 2; i++) {
    pwr_tOName oname;

    if (i == 0)
      strcpy(oname, dstrend_object1);
    else
      strcpy(oname, dstrend_object2);
    if (strcmp(oname, "") == 0)
      continue;
  
    sts = gdh_NameToAttrref(pwr_cNOid, oname, &dstrend_aref[i]);
    if (EVEN(sts))
      return sts;
      
    sts = gdh_GetObjectInfoAttrref(&dstrend_aref[i], &tp[i], sizeof(tp[0]));
    if (EVEN(sts))
      return sts;
    dstrend_cnt++;
  }

  if (dstrend_cnt == 0)
    return 0;

  min_value1_p = 0;
  min_value1_db = dyn->parse_attr_name(
      minvalue_attr1, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    switch (min_value1_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&min_value1_p, &min_value_subid1, attr_size, object, now);
      break;
    case graph_eDatabase_Local:
      min_value1_p = (pwr_tFloat32*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      break;
    default:;
    }
  }
  max_value1_p = 0;
  max_value1_db = dyn->parse_attr_name(
      maxvalue_attr1, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    switch (max_value1_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&max_value1_p, &max_value_subid1, attr_size, object, now);
      break;
    case graph_eDatabase_Local:
      max_value1_p = (pwr_tFloat32*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      break;
    default:;
    }
  }
  min_value2_p = 0;
  dyn->parse_attr_name(
      minvalue_attr2, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&min_value2_p, &min_value_subid2, attr_size, object, now);
  }
  max_value2_p = 0;
  dyn->parse_attr_name(
      maxvalue_attr2, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&max_value2_p, &max_value_subid2, attr_size, object, now);
  }

  trend_hold = 0;
  hold_p = 0;
  hold_db = dyn->parse_attr_name(
      hold_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Boolean) {
    switch (hold_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&hold_p, &hold_subid, attr_size, object, now);
      if (EVEN(sts))
        return sts;
      break;
    case graph_eDatabase_Local:
      hold_p = (pwr_tBoolean*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      break;
    default:;
    }
  }

  mark1_p = 0;
  dyn->parse_attr_name(
      mark1_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name, (void**)&mark1_p,
        &mark1_subid, attr_size, object, now);
  }

  mark2_p = 0;
  dyn->parse_attr_name(
      mark2_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name, (void**)&mark2_p,
        &mark2_subid, attr_size, object, now);
  }

  if (mark1_color != glow_eDrawType_Inherit
      || mark2_color != glow_eDrawType_Inherit)
    grow_SetTrendMarkColor(object, mark1_color, mark2_color);


  // Calculate number of points
  max_time = 0;
  min_interval = 100000;
  for (int i = 0; i < dstrend_cnt; i++) {
    time = tp[i].Multiple * tp[i].ScanTime * tp[i].NoOfBuffers
      * tp[i].NoOfSample;
    if (time > max_time)
      max_time = time;
    
    if ((int)(tp[i].Multiple * tp[i].ScanTime) < min_interval) {
      min_interval = tp[i].Multiple * tp[i].ScanTime;
      min_interval_idx = i;
    }
  }

  if (min_interval == 0)
    return 0;

  max_points = max_time / min_interval;

  for (int i = 0; i < dstrend_cnt; i++) {
    interval[i] = tp[i].Multiple * tp[i].ScanTime / min_interval;
  }

  grow_SetTrendNoOfCurves(object, dstrend_cnt);

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeDsTrend::disconnect(grow_tObject object)
{
  if (min_value1_p && min_value1_db == graph_eDatabase_Gdh) {
    gdh_UnrefObjectInfo(min_value_subid1);
    min_value1_p = 0;
  }
  if (max_value1_p && max_value1_db == graph_eDatabase_Gdh) {
    gdh_UnrefObjectInfo(max_value_subid1);
    max_value1_p = 0;
  }
  if (min_value2_p) {
    gdh_UnrefObjectInfo(min_value_subid2);
    min_value2_p = 0;
  }
  if (max_value2_p) {
    gdh_UnrefObjectInfo(max_value_subid2);
    max_value2_p = 0;
  }
  if (hold_p && hold_db == graph_eDatabase_Gdh) {
    gdh_UnrefObjectInfo(hold_subid);
    hold_p = 0;
  }
  if (mark1_p) {
    gdh_UnrefObjectInfo(mark1_subid);
    mark1_p = 0;
  }
  if (mark2_p) {
    gdh_UnrefObjectInfo(mark2_subid);
    mark1_p = 0;
  }
  return 1;
}

int GeDsTrend::scan(grow_tObject object)
{
  if (!dstrend_cnt)
    return 0;

  pwr_tStatus sts;
  int i, j, k;
  int write_buffer;
  int idx;
  int values;
  int trend_buff_size = 478;
  pwr_sClass_DsTrend tp[2];
  double *data[3];
  int start_idx;
  int new_curve = 0;

  if (hold_p)
    trend_hold = *hold_p;

  if (max_value1_p || min_value1_p) {
    bool update = false;

    pwr_tFloat32 maxval;
    pwr_tFloat32 minval;
    if (max_value1_p) {
      maxval = *max_value1_p;
      if (!feqf(maxval, old_max_value1))
	update = true;
    }
    if (min_value1_p) {
      minval = *min_value1_p;
      if (!feqf(minval, old_min_value1))
	update = true;
    }
    if (update) {
      double minvald, maxvald;
      grow_GetTrendRangeY(object, 0, &minvald, &maxvald);

      if (!min_value1_p)
	minval = minvald;
      if (!max_value1_p)
	maxval = maxvald;

      if (fabsf(maxval - minval) > FLT_EPSILON) {
        grow_SetTrendRangeY(object, 0, minval, maxval);
	new_curve = 1;
      }
      old_min_value1 = minval;
      old_max_value1 = maxval;
    }
  }

  if (max_value2_p || min_value2_p) {
    bool update = false;

    pwr_tFloat32 maxval;
    pwr_tFloat32 minval;
    if (max_value2_p) {
      maxval = *max_value2_p;
      if (!feqf(maxval, old_max_value2))
	update = true;
    }
    if (min_value2_p) {
      minval = *min_value2_p;
      if (!feqf(minval, old_min_value2))
	update = true;
    }
    if (update) {
      double minvald, maxvald;
      grow_GetTrendRangeY(object, 1, &minvald, &maxvald);

      if (!min_value2_p)
	minval = minvald;
      if (!max_value2_p)
	maxval = maxvald;

      if (fabsf(maxval - minval) > FLT_EPSILON) {
        grow_SetTrendRangeY(object, 1, minval, maxval);
	new_curve = 1;
      }
      old_min_value2 = minval;
      old_max_value2 = maxval;
    }
  }

  if (mark1_p && (first_scan || fabsf(*mark1_p - old_mark1) > FLT_EPSILON)) {
    grow_SetTrendYMark1(object, *mark1_p);
    old_mark1 = *mark1_p;
  }
  if (mark2_p && (first_scan || fabsf(*mark2_p - old_mark2) > FLT_EPSILON)) {
    grow_SetTrendYMark2(object, *mark2_p);
    old_mark2 = *mark2_p;
  }

  if (first_scan) {
    first_scan = false;
    new_curve = 1;
  }

  if (trend_hold)
    return 1;

  for (i = 0; i < dstrend_cnt; i++) {
    sts = gdh_GetObjectInfoAttrref(&dstrend_aref[i], &tp[i], sizeof(tp[0]));
    if (EVEN(sts))
      return sts;
  }

  if (new_curve) {
    // Draw whole curve
    data[0] = (double*)calloc(1, 8 * max_points);
    for (j = 0; j < max_points; j++)
      data[0][max_points-j-1] = (double)j / max_points * 100;

    for (i = 0; i < dstrend_cnt; i++) {
      data[i+1] = (double*)calloc(1, 8 * max_points);

      int write_buffer = (int)tp[i].WriteBuffer;
      start_idx = write_buffer * trend_buff_size / 2
	+ int(tp[i].NextWriteIndex[write_buffer]);
      if (start_idx == 0) {
	start_idx = tp[i].NoOfSample - 1 + trend_buff_size / 2;
	write_buffer = 1;
      } else if (start_idx == trend_buff_size / 2) {
	start_idx = tp[i].NoOfSample - 1;
	write_buffer = 0;
      } else
	start_idx--;
      
      int idx = 0;
      for (j = start_idx; j >= write_buffer * trend_buff_size / 2; j--) {
	for (k = 0; k < interval[i]; k++) {
	  data[i+1][idx] = tp[i].DataBuffer[j];
	  idx++;
	}
      }
      for (j = tp[i].NoOfSample - 1 + (!write_buffer) * trend_buff_size / 2;
	   j >= (!write_buffer) * trend_buff_size / 2; j--) {
	for (k = 0; k < interval[i]; k++) {
	  data[i+1][idx] = tp[i].DataBuffer[j];
	  idx++;
	}
      }
      if (start_idx
	  != (int)tp[i].NoOfSample - 1 + write_buffer * trend_buff_size / 2) {
	for (j = tp[i].NoOfSample - 1 + write_buffer * trend_buff_size / 2;
	     j > start_idx; j--) {
	  for (k = 0; k < interval[i]; k++) {
	    data[i+1][idx] = tp[i].DataBuffer[j];
	    idx++;
	  }
	}
      }
      last_buffer[i] = tp[i].WriteBuffer;
      last_next_index[i] = tp[i].NextWriteIndex[last_buffer[i]];
    }

    grow_SetTrendData(object, data, dstrend_cnt + 1, max_points);

    free(data[0]);
    for (i = 0; i < dstrend_cnt; i++)
      free(data[i+1]);
  }
  else {
    // Check if any new value
    i = min_interval_idx;
    if (tp[i].NextWriteIndex[tp[i].WriteBuffer]
	!= last_next_index[i]) {
      values = tp[i].NextWriteIndex[tp[i].WriteBuffer]
	- last_next_index[i];
      if (values < 0)
	values = values + tp[i].NoOfSample;
      
      last_next_index[i]
	= tp[i].NextWriteIndex[tp[i].WriteBuffer];
      
      if (values > 2)
	grow_SetNodraw(dyn->graph->grow->ctx);
      for (k = 0; k < values; k++) {
	// Add new points
	for (i = 0; i < dstrend_cnt; i++) {
	  // Insert new value
	  write_buffer = tp[i].WriteBuffer;
	  idx = write_buffer * trend_buff_size / 2
	    + int(tp[i].NextWriteIndex[write_buffer])
	    - (values - 1 - k);
	  if (idx == 0 || idx == trend_buff_size / 2)
	    idx = tp[i].NoOfSample - 1
	      + (!write_buffer) * trend_buff_size / 2;
	  else
	    idx--;
	  
	  grow_AddTrendValue(object, double(tp[i].DataBuffer[idx]), i);
	}
      }
      if (values > 2)
	grow_ResetNodraw(dyn->graph->grow->ctx);
    }
  }
  
  return 1;
}

int GeDsTrend::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int sts;
  pwr_eType a_type;

  if (streq(dstrend_object1, "")) {
    dyn->graph->syntax_msg('W', object, "DsTrend.Object1 is missing");
    (*warning_cnt)++;
  } else {
    sts = dyn->graph->check_ldh_object(dstrend_object1, &a_type);
    if (EVEN(sts)) {
      char msg[440];
      sprintf(msg, "DsTrend.Object1 \"%s\" not found", dstrend_object1);
      dyn->graph->syntax_msg('W', object, msg);
      (*warning_cnt)++;
    } else {
      if (a_type != pwr_cClass_DsTrend) {
        dyn->graph->syntax_msg(
            'E', object, "DsTrend.Object1 is of wrong class");
        (*error_cnt)++;
      }
    }
  }
  if (!streq(dstrend_object2, "")) {
    sts = dyn->graph->check_ldh_object(dstrend_object2, &a_type);
    if (EVEN(sts)) {
      char msg[440];
      sprintf(msg, "DsTrend.Object2 \"%s\" not found", dstrend_object2);
      dyn->graph->syntax_msg('W', object, msg);
      (*warning_cnt)++;
    } else {
      if (a_type != pwr_cClass_DsTrend) {
        dyn->graph->syntax_msg(
            'E', object, "DsTrend.Object2 is of wrong class");
        (*error_cnt)++;
      }
    }
  }
  return 1;
}

GeDsTrendCurve::GeDsTrendCurve(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_DsTrendCurve,
		ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_DsTrendCurve),
      min_value1_p(0), max_value1_p(0), old_min_value1(0), old_max_value1(0),
      min_value2_p(0), max_value2_p(0), old_min_value2(0), old_max_value2(0),
      hold_p(0),
      mark1_color(glow_eDrawType_Inherit), mark2_color(glow_eDrawType_Inherit)
{
  strcpy(dstrend_object, "");
  strcpy(minvalue_attr1, "");
  strcpy(maxvalue_attr1, "");
  strcpy(minvalue_attr2, "");
  strcpy(maxvalue_attr2, "");
  strcpy(hold_attr, "");
  strcpy(mark1_attr, "");
  strcpy(mark2_attr, "");
}

GeDsTrendCurve::GeDsTrendCurve(const GeDsTrendCurve& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
		x.prio),
      mark1_color(x.mark1_color), mark2_color(x.mark2_color)

{
  strcpy(dstrend_object, x.dstrend_object);
  strcpy(minvalue_attr1, x.minvalue_attr1);
  strcpy(maxvalue_attr1, x.maxvalue_attr1);
  strcpy(minvalue_attr2, x.minvalue_attr2);
  strcpy(maxvalue_attr2, x.maxvalue_attr2);
  strcpy(hold_attr, x.hold_attr);
  strcpy(mark1_attr, x.mark1_attr);
  strcpy(mark2_attr, x.mark2_attr);
}

void GeDsTrendCurve::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "DsTrendCurve.Object");
  attrinfo[i].value = dstrend_object;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(dstrend_object);

  strcpy(attrinfo[i].name, "DsTrendCurve.MinValueAttr1");
  attrinfo[i].value = minvalue_attr1;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(minvalue_attr1);

  strcpy(attrinfo[i].name, "DsTrendCurve.MaxValueAttr1");
  attrinfo[i].value = maxvalue_attr1;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(maxvalue_attr1);

  strcpy(attrinfo[i].name, "DsTrendCurve.MinValueAttr2");
  attrinfo[i].value = minvalue_attr2;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(minvalue_attr2);

  strcpy(attrinfo[i].name, "DsTrendCurve.MaxValueAttr2");
  attrinfo[i].value = maxvalue_attr2;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(maxvalue_attr2);

  strcpy(attrinfo[i].name, "DsTrendCurve.HoldAttr");
  attrinfo[i].value = hold_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(hold_attr);

  strcpy(attrinfo[i].name, "DsTrendCurve.Mark1Attr");
  attrinfo[i].value = mark1_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(mark1_attr);

  strcpy(attrinfo[i].name, "DsTrendCurve.Mark2Attr");
  attrinfo[i].value = mark2_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(mark2_attr);

  strcpy(attrinfo[i].name, "DsTrendCurve.Mark1Color");
  attrinfo[i].value = &mark1_color;
  attrinfo[i].type = glow_eType_Color;
  attrinfo[i++].size = sizeof(mark1_color);

  strcpy(attrinfo[i].name, "DsTrendCurve.Mark2Color");
  attrinfo[i].value = &mark2_color;
  attrinfo[i].type = glow_eType_Color;
  attrinfo[i++].size = sizeof(mark2_color);

  *item_count = i;
}

void GeDsTrendCurve::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char* s;

    strncpy(dstrend_object, attr_name, sizeof(dstrend_object));
    if ((s = strchr(dstrend_object, '.')))
      *s = 0;

    char msg[23 + sizeof(dstrend_object) +1];
    snprintf(msg, sizeof(msg), "DsTrendCurve.Object = %s", dstrend_object);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeDsTrendCurve::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(
      dstrend_object, sizeof(dstrend_object), from, to, cnt, strict);
  GeDyn::replace_attribute(
      minvalue_attr1, sizeof(minvalue_attr1), from, to, cnt, strict);
  GeDyn::replace_attribute(
      maxvalue_attr1, sizeof(maxvalue_attr1), from, to, cnt, strict);
  GeDyn::replace_attribute(
      minvalue_attr2, sizeof(minvalue_attr2), from, to, cnt, strict);
  GeDyn::replace_attribute(
      maxvalue_attr2, sizeof(maxvalue_attr2), from, to, cnt, strict);
  GeDyn::replace_attribute(hold_attr, sizeof(hold_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      mark1_attr, sizeof(mark1_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      mark2_attr, sizeof(mark2_attr), from, to, cnt, strict);
}

void GeDsTrendCurve::save(std::ofstream& fp)
{
  fp << int(ge_eSave_DsTrendCurve) << '\n';
  fp << int(ge_eSave_DsTrendCurve_dstrend_object) << FSPACE << dstrend_object << '\n';
  fp << int(ge_eSave_DsTrendCurve_minvalue_attr1) << FSPACE << minvalue_attr1 << '\n';
  fp << int(ge_eSave_DsTrendCurve_maxvalue_attr1) << FSPACE << maxvalue_attr1 << '\n';
  fp << int(ge_eSave_DsTrendCurve_minvalue_attr2) << FSPACE << minvalue_attr2 << '\n';
  fp << int(ge_eSave_DsTrendCurve_maxvalue_attr2) << FSPACE << maxvalue_attr2 << '\n';
  fp << int(ge_eSave_DsTrendCurve_hold_attr) << FSPACE << hold_attr << '\n';
  fp << int(ge_eSave_DsTrendCurve_mark1_attr) << FSPACE << mark1_attr << '\n';
  fp << int(ge_eSave_DsTrendCurve_mark2_attr) << FSPACE << mark2_attr << '\n';
  fp << int(ge_eSave_DsTrendCurve_mark1_color) << FSPACE << (int)mark1_color << '\n';
  fp << int(ge_eSave_DsTrendCurve_mark2_color) << FSPACE << (int)mark2_color << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeDsTrendCurve::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeDsTrendCurve: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_DsTrendCurve:
      break;
    case ge_eSave_DsTrendCurve_dstrend_object:
      fp.get();
      fp.getline(dstrend_object, sizeof(dstrend_object));
      break;
    case ge_eSave_DsTrendCurve_minvalue_attr1:
      fp.get();
      fp.getline(minvalue_attr1, sizeof(minvalue_attr1));
      break;
    case ge_eSave_DsTrendCurve_maxvalue_attr1:
      fp.get();
      fp.getline(maxvalue_attr1, sizeof(maxvalue_attr1));
      break;
    case ge_eSave_DsTrendCurve_minvalue_attr2:
      fp.get();
      fp.getline(minvalue_attr2, sizeof(minvalue_attr2));
      break;
    case ge_eSave_DsTrendCurve_maxvalue_attr2:
      fp.get();
      fp.getline(maxvalue_attr2, sizeof(maxvalue_attr2));
      break;
    case ge_eSave_DsTrendCurve_hold_attr:
      fp.get();
      fp.getline(hold_attr, sizeof(hold_attr));
      break;
    case ge_eSave_DsTrendCurve_mark1_attr:
      fp.get();
      fp.getline(mark1_attr, sizeof(mark1_attr));
      break;
    case ge_eSave_DsTrendCurve_mark2_attr:
      fp.get();
      fp.getline(mark2_attr, sizeof(mark2_attr));
      break;
    case ge_eSave_DsTrendCurve_mark1_color:
      fp >> tmp;
      mark1_color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_DsTrendCurve_mark2_color:
      fp >> tmp;
      mark2_color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeDsTrendCurve:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeDsTrendCurve::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  pwr_tStatus sts;
  pwr_sClass_DsTrendCurve tcp;
  pwr_tAName object_name[2];
  int i;
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int inverted;

  // Get current status of the trend objects
  dstrend_cnt = 0;
  sts = gdh_NameToAttrref(pwr_cNOid, dstrend_object, &dstrend_aref);
  if (EVEN(sts))
    return sts;
     
  sts = gdh_GetObjectInfoAttrref(&dstrend_aref, &tcp, sizeof(tcp));
  if (EVEN(sts))
    return sts;

  i = 0;
  for (int j = 0; j < 10; j++) {
    if (cdh_ObjidIsNotNull(tcp.Attribute[j].Objid)
	&& cdh_ObjidIsNotNull(tcp.Buffers[j].Objid)) {
      sts = gdh_AttrrefToName(&tcp.Buffers[j], object_name[i],
			       sizeof(object_name[0]), cdh_mNName);
      if (EVEN(sts))
	return sts;

      sts = gdh_AttrrefToName(&tcp.Attribute[j], object_name[i],
			       sizeof(object_name[0]), cdh_mNName);
      if (EVEN(sts))
	return sts;

      element_size[i]
	= cdh_TypeToSize((pwr_eType)tcp.AttributeType[j]);
      element_type[i] = (pwr_eType)tcp.AttributeType[j];
      cb_info[i].resolution = tcp.DisplayResolution;
      if (cb_info[i].resolution <= 0)
	cb_info[i].resolution = 1;
      cb_info[i].samples = tcp.DisplayTime / tcp.ScanTime
	/ cb_info[i].resolution;
      cb_info[i].bufsize = cb_info[i].samples * element_size[i];
      cb_info[i].bufp = (char*)calloc(1, cb_info[i].bufsize);
      cb_info[i].circ_aref = tcp.Buffers[j];
      
      i++;
      dstrend_cnt++;
    }
    if (dstrend_cnt == 2)
      break;
  }

  if (dstrend_cnt == 0)
    return 0;

  min_value1_p = 0;
  min_value1_db = dyn->parse_attr_name(
      minvalue_attr1, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    switch (min_value1_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&min_value1_p, &min_value_subid1, attr_size, object, now);
      break;
    case graph_eDatabase_Local:
      min_value1_p = (pwr_tFloat32*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      break;
    default:;
    }
  }
  max_value1_p = 0;
  max_value1_db = dyn->parse_attr_name(
      maxvalue_attr1, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    switch (max_value1_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&max_value1_p, &max_value_subid1, attr_size, object, now);
      break;
    case graph_eDatabase_Local:
      max_value1_p = (pwr_tFloat32*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      break;
    default:;
    }
  }
  min_value2_p = 0;
  dyn->parse_attr_name(
      minvalue_attr2, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&min_value2_p, &min_value_subid2, attr_size, object, now);
  }
  max_value2_p = 0;
  dyn->parse_attr_name(
      maxvalue_attr2, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&max_value2_p, &max_value_subid2, attr_size, object, now);
  }

  trend_hold = 0;
  hold_p = 0;
  hold_db = dyn->parse_attr_name(
      hold_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Boolean) {
    switch (hold_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&hold_p, &hold_subid, attr_size, object, now);
      if (EVEN(sts))
        return sts;
      break;
    case graph_eDatabase_Local:
      hold_p = (pwr_tBoolean*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      break;
    default:;
    }
  }

  mark1_p = 0;
  dyn->parse_attr_name(
      mark1_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name, (void**)&mark1_p,
        &mark1_subid, attr_size, object, now);
  }

  mark2_p = 0;
  dyn->parse_attr_name(
      mark2_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name, (void**)&mark2_p,
        &mark2_subid, attr_size, object, now);
  }

  if (mark1_color != glow_eDrawType_Inherit
      || mark2_color != glow_eDrawType_Inherit)
    grow_SetTrendMarkColor(object, mark1_color, mark2_color);

  grow_SetTrendNoOfCurves(object, dstrend_cnt);

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeDsTrendCurve::disconnect(grow_tObject object)
{
  if (min_value1_p && min_value1_db == graph_eDatabase_Gdh) {
    gdh_UnrefObjectInfo(min_value_subid1);
    min_value1_p = 0;
  }
  if (max_value1_p && max_value1_db == graph_eDatabase_Gdh) {
    gdh_UnrefObjectInfo(max_value_subid1);
    max_value1_p = 0;
  }
  if (min_value2_p) {
    gdh_UnrefObjectInfo(min_value_subid2);
    min_value2_p = 0;
  }
  if (max_value2_p) {
    gdh_UnrefObjectInfo(max_value_subid2);
    max_value2_p = 0;
  }
  if (hold_p && hold_db == graph_eDatabase_Gdh) {
    gdh_UnrefObjectInfo(hold_subid);
    hold_p = 0;
  }
  if (mark1_p) {
    gdh_UnrefObjectInfo(mark1_subid);
    mark1_p = 0;
  }
  if (mark2_p) {
    gdh_UnrefObjectInfo(mark2_subid);
    mark1_p = 0;
  }
  return 1;
}

int GeDsTrendCurve::scan(grow_tObject object)
{
  if (!dstrend_cnt)
    return 0;

  pwr_tStatus sts;
  int i, j;
  double *data[3];
  int new_curve = 0;
  unsigned int size;
  unsigned int actual_data_size[2];

  if (hold_p)
    trend_hold = *hold_p;

  if (max_value1_p || min_value1_p) {
    bool update = false;

    pwr_tFloat32 maxval;
    pwr_tFloat32 minval;
    if (max_value1_p) {
      maxval = *max_value1_p;
      if (!feqf(maxval, old_max_value1))
	update = true;
    }
    if (min_value1_p) {
      minval = *min_value1_p;
      if (!feqf(minval, old_min_value1))
	update = true;
    }
    if (update) {
      double minvald, maxvald;
      grow_GetTrendRangeY(object, 0, &minvald, &maxvald);

      if (!min_value1_p)
	minval = minvald;
      if (!max_value1_p)
	maxval = maxvald;

      if (fabsf(maxval - minval) > FLT_EPSILON) {
        grow_SetTrendRangeY(object, 0, minval, maxval);
	new_curve = 1;
      }
      old_min_value1 = minval;
      old_max_value1 = maxval;
    }
  }

  if (max_value2_p || min_value2_p) {
    bool update = false;

    pwr_tFloat32 maxval;
    pwr_tFloat32 minval;
    if (max_value2_p) {
      maxval = *max_value2_p;
      if (!feqf(maxval, old_max_value2))
	update = true;
    }
    if (min_value2_p) {
      minval = *min_value2_p;
      if (!feqf(minval, old_min_value2))
	update = true;
    }
    if (update) {
      double minvald, maxvald;
      grow_GetTrendRangeY(object, 1, &minvald, &maxvald);

      if (!min_value2_p)
	minval = minvald;
      if (!max_value2_p)
	maxval = maxvald;

      if (fabsf(maxval - minval) > FLT_EPSILON) {
        grow_SetTrendRangeY(object, 1, minval, maxval);
	new_curve = 1;
      }
      old_min_value2 = minval;
      old_max_value2 = maxval;
    }
  }

  if (mark1_p && (first_scan || fabsf(*mark1_p - old_mark1) > FLT_EPSILON)) {
    grow_SetTrendYMark1(object, *mark1_p);
    old_mark1 = *mark1_p;
  }
  if (mark2_p && (first_scan || fabsf(*mark2_p - old_mark2) > FLT_EPSILON)) {
    grow_SetTrendYMark2(object, *mark2_p);
    old_mark2 = *mark2_p;
  }

  if (first_scan) {
    first_scan = false;
    new_curve = 1;
  }

  if (trend_hold)
    return 1;

  if (new_curve) {
    // Draw whole curve
    
    max_points = 0;
    for (i = 0; i < dstrend_cnt; i++) 
      max_points = MAX(max_points, cb_info[i].samples);

    for (i = 0; i < dstrend_cnt; i++) {
      sts = cbuf_GetCircBuffInfo(&cb_info[i], 1);
      if (EVEN(sts))
	continue;

      actual_data_size[i] = cb_info[i].size;
      if (actual_data_size[i] > cb_info[i].bufsize)
	printf("** Sample size error !!!\n");

      data[0] = (double*)calloc(1, 8 * max_points);
      for (j = 0; j < max_points; j++)
	data[0][max_points-j-1] = (double)j / max_points * 100;

      data[i+1] = (double*)calloc(1, 8 * max_points);
      for (unsigned int j = 0; j < actual_data_size[i]; j++)
	data[i+1][j] = *(pwr_tFloat32*)((char*)cb_info[i].bufp
	     + (actual_data_size[i] - j - 1) * sizeof(pwr_tFloat32));
    }

    grow_SetTrendData(object, data, dstrend_cnt + 1, max_points);

    free(data[0]);
    for (i = 0; i < dstrend_cnt; i++)
      free(data[i+1]);
  }
  else {
    // Check if any new value
    sts = cbuf_UpdateCircBuffInfo(cb_info, dstrend_cnt);
    if (EVEN(sts))
      return sts;

    for (i = 0; i < dstrend_cnt; i++) {
      size = cb_info[i].size;
      if (size > 0) {
        // Shift data
	if (size > 2)
	  grow_SetNodraw(dyn->graph->grow->ctx);

        for (j = 0; j < (int)size; j++) {
	  float value = *(pwr_tFloat32*)((char*)cb_info[i].bufp
					 + j * sizeof(pwr_tFloat32));
	  grow_AddTrendValue(object, double(value), i);
        }

	if (size > 2)
	  grow_ResetNodraw(dyn->graph->grow->ctx);
      }
    }
  }
  
  return 1;
}

int GeDsTrendCurve::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int sts;
  pwr_eType a_type;

  if (streq(dstrend_object, "")) {
    dyn->graph->syntax_msg('W', object, "DsTrendCurve.Object is missing");
    (*warning_cnt)++;
  } else {
    sts = dyn->graph->check_ldh_object(dstrend_object, &a_type);
    if (EVEN(sts)) {
      char msg[440];
      sprintf(msg, "DsTrendCurve.Object \"%s\" not found", dstrend_object);
      dyn->graph->syntax_msg('W', object, msg);
      (*warning_cnt)++;
    } else {
      if (a_type != pwr_cClass_DsTrendCurve) {
        dyn->graph->syntax_msg(
            'E', object, "DsTrendCurve.Object is of wrong class");
        (*error_cnt)++;
      }
    }
  }
  return 1;
}

GeSevHist::GeSevHist(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_SevHist,
		ge_mActionType1_No, ge_mActionType2_No, ge_eDynPrio_SevHist),
      timerange(0), updatetime(0), sevhist_cnt(0),
      min_value1_p(0), max_value1_p(0), old_min_value1(0), old_max_value1(0),
      min_value2_p(0), max_value2_p(0), old_min_value2(0), old_max_value2(0),
      timerange_p(0), hold_p(0), update_p(0), old_update(0),
      mark1_color(glow_eDrawType_Inherit), mark2_color(glow_eDrawType_Inherit),
      acc_time(0)
{
  strcpy(sevhist_object1, "");
  strcpy(sevhist_object2, "");
  strcpy(attribute1, "");
  strcpy(attribute2, "");
  strcpy(server, "");
  strcpy(minvalue_attr1, "");
  strcpy(maxvalue_attr1, "");
  strcpy(minvalue_attr2, "");
  strcpy(maxvalue_attr2, "");
  strcpy(hold_attr, "");
  strcpy(update_attr, "");
  strcpy(mark1_attr, "");
  strcpy(mark2_attr, "");
  strcpy(timerange_attr, "");
}

GeSevHist::GeSevHist(const GeSevHist& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
		x.prio), timerange(x.timerange), updatetime(x.updatetime),
      mark1_color(x.mark1_color), mark2_color(x.mark2_color)

{
  strcpy(sevhist_object1, x.sevhist_object1);
  strcpy(sevhist_object2, x.sevhist_object2);
  strcpy(attribute1, x.attribute1);
  strcpy(attribute2, x.attribute2);
  strcpy(server, x.server);
  strcpy(timerange_attr, x.timerange_attr);
  strcpy(minvalue_attr1, x.minvalue_attr1);
  strcpy(maxvalue_attr1, x.maxvalue_attr1);
  strcpy(minvalue_attr2, x.minvalue_attr2);
  strcpy(maxvalue_attr2, x.maxvalue_attr2);
  strcpy(hold_attr, x.hold_attr);
  strcpy(update_attr, x.update_attr);
  strcpy(update_attr, x.update_attr);
  strcpy(mark1_attr, x.mark1_attr);
  strcpy(mark2_attr, x.mark2_attr);
}

void GeSevHist::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "SevHist.Object1");
  attrinfo[i].value = sevhist_object1;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(sevhist_object1);

  strcpy(attrinfo[i].name, "SevHist.Object2");
  attrinfo[i].value = sevhist_object2;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(sevhist_object2);

  strcpy(attrinfo[i].name, "SevHist.Attribute1");
  attrinfo[i].value = attribute1;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute1);

  strcpy(attrinfo[i].name, "SevHist.Attribute2");
  attrinfo[i].value = attribute2;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute2);

  strcpy(attrinfo[i].name, "SevHist.Server");
  attrinfo[i].value = server;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(server);

  strcpy(attrinfo[i].name, "SevHist.TimeRange");
  attrinfo[i].value = &timerange;
  attrinfo[i].type = glow_eType_Float;
  attrinfo[i++].size = sizeof(timerange);

  strcpy(attrinfo[i].name, "SevHist.TimeRangeAttr");
  attrinfo[i].value = timerange_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(timerange_attr);

  strcpy(attrinfo[i].name, "SevHist.MinValueAttr1");
  attrinfo[i].value = minvalue_attr1;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(minvalue_attr1);

  strcpy(attrinfo[i].name, "SevHist.MaxValueAttr1");
  attrinfo[i].value = maxvalue_attr1;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(maxvalue_attr1);

  strcpy(attrinfo[i].name, "SevHist.MinValueAttr2");
  attrinfo[i].value = minvalue_attr2;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(minvalue_attr2);

  strcpy(attrinfo[i].name, "SevHist.MaxValueAttr2");
  attrinfo[i].value = maxvalue_attr2;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(maxvalue_attr2);

  strcpy(attrinfo[i].name, "SevHist.HoldAttr");
  attrinfo[i].value = hold_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(hold_attr);

  strcpy(attrinfo[i].name, "SevHist.UpdateAttr");
  attrinfo[i].value = update_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(update_attr);

  strcpy(attrinfo[i].name, "SevHist.UpdateTime");
  attrinfo[i].value = &updatetime;
  attrinfo[i].type = glow_eType_Float;
  attrinfo[i++].size = sizeof(updatetime);

  strcpy(attrinfo[i].name, "SevHist.Mark1Attr");
  attrinfo[i].value = mark1_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(mark1_attr);

  strcpy(attrinfo[i].name, "SevHist.Mark2Attr");
  attrinfo[i].value = mark2_attr;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(mark2_attr);

  strcpy(attrinfo[i].name, "SevHist.Mark1Color");
  attrinfo[i].value = &mark1_color;
  attrinfo[i].type = glow_eType_Color;
  attrinfo[i++].size = sizeof(mark1_color);

  strcpy(attrinfo[i].name, "SevHist.Mark2Color");
  attrinfo[i].value = &mark2_color;
  attrinfo[i].type = glow_eType_Color;
  attrinfo[i++].size = sizeof(mark2_color);

  *item_count = i;
}

void GeSevHist::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    strncpy(attribute1, attr_name, sizeof(attribute1));

    char msg[23 + sizeof(attribute1) +1];
    snprintf(msg, sizeof(msg), "SevHist.Attribute1 = %s", attribute1);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeSevHist::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(
      sevhist_object1, sizeof(sevhist_object1), from, to, cnt, strict);
  GeDyn::replace_attribute(
      sevhist_object2, sizeof(sevhist_object2), from, to, cnt, strict);
  GeDyn::replace_attribute(
      attribute1, sizeof(attribute1), from, to, cnt, strict);
  GeDyn::replace_attribute(
      attribute2, sizeof(attribute2), from, to, cnt, strict);
  GeDyn::replace_attribute(
      server, sizeof(server), from, to, cnt, strict);
  GeDyn::replace_attribute(
      timerange_attr, sizeof(timerange_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      minvalue_attr1, sizeof(minvalue_attr1), from, to, cnt, strict);
  GeDyn::replace_attribute(
      maxvalue_attr1, sizeof(maxvalue_attr1), from, to, cnt, strict);
  GeDyn::replace_attribute(
      minvalue_attr2, sizeof(minvalue_attr2), from, to, cnt, strict);
  GeDyn::replace_attribute(
      maxvalue_attr2, sizeof(maxvalue_attr2), from, to, cnt, strict);
  GeDyn::replace_attribute(hold_attr, sizeof(hold_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(update_attr, sizeof(update_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      mark1_attr, sizeof(mark1_attr), from, to, cnt, strict);
  GeDyn::replace_attribute(
      mark2_attr, sizeof(mark2_attr), from, to, cnt, strict);
}

void GeSevHist::save(std::ofstream& fp)
{
  fp << int(ge_eSave_SevHist) << '\n';
  fp << int(ge_eSave_SevHist_sevhist_object1) << FSPACE << sevhist_object1 << '\n';
  fp << int(ge_eSave_SevHist_sevhist_object2) << FSPACE << sevhist_object2 << '\n';
  fp << int(ge_eSave_SevHist_attribute1) << FSPACE << attribute1 << '\n';
  fp << int(ge_eSave_SevHist_attribute2) << FSPACE << attribute2 << '\n';
  fp << int(ge_eSave_SevHist_timerange) << FSPACE << timerange << '\n';
  fp << int(ge_eSave_SevHist_timerange_attr) << FSPACE << timerange_attr << '\n';
  fp << int(ge_eSave_SevHist_server) << FSPACE << server << '\n';
  fp << int(ge_eSave_SevHist_minvalue_attr1) << FSPACE << minvalue_attr1 << '\n';
  fp << int(ge_eSave_SevHist_maxvalue_attr1) << FSPACE << maxvalue_attr1 << '\n';
  fp << int(ge_eSave_SevHist_minvalue_attr2) << FSPACE << minvalue_attr2 << '\n';
  fp << int(ge_eSave_SevHist_maxvalue_attr2) << FSPACE << maxvalue_attr2 << '\n';
  fp << int(ge_eSave_SevHist_hold_attr) << FSPACE << hold_attr << '\n';
  fp << int(ge_eSave_SevHist_update_attr) << FSPACE << update_attr << '\n';
  fp << int(ge_eSave_SevHist_updatetime) << FSPACE << updatetime << '\n';
  fp << int(ge_eSave_SevHist_mark1_attr) << FSPACE << mark1_attr << '\n';
  fp << int(ge_eSave_SevHist_mark2_attr) << FSPACE << mark2_attr << '\n';
  fp << int(ge_eSave_SevHist_mark1_color) << FSPACE << (int)mark1_color << '\n';
  fp << int(ge_eSave_SevHist_mark2_color) << FSPACE << (int)mark2_color << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeSevHist::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeSevHist: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_SevHist:
      break;
    case ge_eSave_SevHist_sevhist_object1:
      fp.get();
      fp.getline(sevhist_object1, sizeof(sevhist_object1));
      break;
    case ge_eSave_SevHist_sevhist_object2:
      fp.get();
      fp.getline(sevhist_object2, sizeof(sevhist_object2));
      break;
    case ge_eSave_SevHist_attribute1:
      fp.get();
      fp.getline(attribute1, sizeof(attribute1));
      break;
    case ge_eSave_SevHist_attribute2:
      fp.get();
      fp.getline(attribute2, sizeof(attribute2));
      break;
    case ge_eSave_SevHist_server:
      fp.get();
      fp.getline(server, sizeof(server));
      break;
    case ge_eSave_SevHist_timerange:
      fp >> timerange;
      break;
    case ge_eSave_SevHist_timerange_attr:
      fp.get();
      fp.getline(timerange_attr, sizeof(timerange_attr));
      break;
    case ge_eSave_SevHist_minvalue_attr1:
      fp.get();
      fp.getline(minvalue_attr1, sizeof(minvalue_attr1));
      break;
    case ge_eSave_SevHist_maxvalue_attr1:
      fp.get();
      fp.getline(maxvalue_attr1, sizeof(maxvalue_attr1));
      break;
    case ge_eSave_SevHist_minvalue_attr2:
      fp.get();
      fp.getline(minvalue_attr2, sizeof(minvalue_attr2));
      break;
    case ge_eSave_SevHist_maxvalue_attr2:
      fp.get();
      fp.getline(maxvalue_attr2, sizeof(maxvalue_attr2));
      break;
    case ge_eSave_SevHist_hold_attr:
      fp.get();
      fp.getline(hold_attr, sizeof(hold_attr));
      break;
    case ge_eSave_SevHist_update_attr:
      fp.get();
      fp.getline(update_attr, sizeof(update_attr));
      break;
    case ge_eSave_SevHist_updatetime:
      fp >> updatetime;
      break;
    case ge_eSave_SevHist_mark1_attr:
      fp.get();
      fp.getline(mark1_attr, sizeof(mark1_attr));
      break;
    case ge_eSave_SevHist_mark2_attr:
      fp.get();
      fp.getline(mark2_attr, sizeof(mark2_attr));
      break;
    case ge_eSave_SevHist_mark1_color:
      fp >> tmp;
      mark1_color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_SevHist_mark2_color:
      fp >> tmp;
      mark2_color = (glow_eDrawType)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeSevHist:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeSevHist::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  pwr_tStatus sts;
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int inverted;
  char *s;

  scctx = sevcli_get_stored_ctx();
  if (!scctx) {
    sevcli_init(&sts, &scctx);
    if (EVEN(sts))
      return sts;
    sevcli_store_ctx(scctx);
  }

  if (strcmp(sevhist_object1, "") != 0) {
    pwr_tAttrRef sevhist_aref;
    pwr_tAttrRef thread_aref;
    pwr_tAttrRef aref;
    pwr_tAttrRef attr_aref;
    pwr_tAName aname;
    pwr_tCid cid;
    pwr_tOid thread_oid;
    char *np;
    char *s;
    int server_found = 0;

    for (int i = 0; i < 2; i++) {
      if (i == 0)
	np = sevhist_object1;
      else
	np = sevhist_object2;

      if (strcmp(np, "") == 0)
	continue;

      sts = gdh_NameToAttrref(pwr_cNObjid, np, &sevhist_aref);
      if (EVEN(sts))
	return sts;

      sts = gdh_GetAttrRefTid(&sevhist_aref, &cid);
      if (EVEN(sts))
        return sts;

      if (cid != pwr_cClass_SevHist)
	continue;

      if (!server_found) {

        sts = gdh_ArefANameToAref(&sevhist_aref, "ThreadObject", &aref);
        if (EVEN(sts))
          return sts;

        sts = gdh_GetObjectInfoAttrref(&aref, &thread_oid, sizeof(thread_oid));
        if (EVEN(sts))
          return sts;

	thread_aref = cdh_ObjidToAref(thread_oid);
	sts = gdh_ArefANameToAref(&thread_aref, "ServerNode", &aref);
	if (EVEN(sts)) 
	  return sts;

	sts = gdh_GetObjectInfoAttrref(&aref, server, sizeof(server));
	if (EVEN(sts))
	  return sts;    

	server_found = 1;
      }

      sts = gdh_ArefANameToAref(&sevhist_aref, "Attribute", &aref);
      if (EVEN(sts))
	return sts;
    
      sts = gdh_GetObjectInfoAttrref(&aref, &attr_aref, sizeof(attr_aref));
      if (EVEN(sts))
	return sts;    

      sts = gdh_AttrrefToName(&attr_aref, aname, sizeof(aname), cdh_mNName);
      if (EVEN(sts))
	return sts;

      s = strchr(aname, '.');
      if (!s)
	return 0;

      oidv[sevhist_cnt] = attr_aref.Objid;
      strcpy(anamev[sevhist_cnt], s+1);
      sevhist_cnt++;
    }
  }
  else {
    memset(oidv, 0, sizeof(oidv));
    if (strcmp(server, "") == 0)
      return 0;
    if (strcmp(attribute1, "") != 0) {
      strncpy(anamev[sevhist_cnt], attribute1, sizeof(anamev[0]));
      if ((s = strchr(anamev[sevhist_cnt], '#')))
	*s = 0;
      sevhist_cnt++;
    }
    if (strcmp(attribute2, "") != 0) {
      strncpy(anamev[sevhist_cnt], attribute2, sizeof(anamev[0]));
      if ((s = strchr(anamev[sevhist_cnt], '#')))
	*s = 0;
      sevhist_cnt++;
    }
  }

  if (sevhist_cnt == 0)
    return 0;

  min_value1_p = 0;
  min_value1_db = dyn->parse_attr_name(
      minvalue_attr1, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    switch (min_value1_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&min_value1_p, &min_value_subid1, attr_size, object, now);
      break;
    case graph_eDatabase_Local:
      min_value1_p = (pwr_tFloat32*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      break;
    default:;
    }
  }
  max_value1_p = 0;
  max_value1_db = dyn->parse_attr_name(
      maxvalue_attr1, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    switch (max_value1_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&max_value1_p, &max_value_subid1, attr_size, object, now);
      break;
    case graph_eDatabase_Local:
      max_value1_p = (pwr_tFloat32*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      break;
    default:;
    }
  }
  min_value2_p = 0;
  dyn->parse_attr_name(
      minvalue_attr2, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&min_value2_p, &min_value_subid2, attr_size, object, now);
  }
  max_value2_p = 0;
  dyn->parse_attr_name(
      maxvalue_attr2, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
        (void**)&max_value2_p, &max_value_subid2, attr_size, object, now);
  }

  timerange_p = 0;
  timerange_db = dyn->parse_attr_name(
      timerange_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    switch (timerange_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&timerange_p, &timerange_subid, attr_size, object, now);
      break;
    case graph_eDatabase_Local:
      timerange_p = (pwr_tFloat32*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      break;
    default:;
    }
  }

  trend_hold = 0;
  hold_p = 0;
  hold_db = dyn->parse_attr_name(
      hold_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Boolean) {
    switch (hold_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&hold_p, &hold_subid, attr_size, object, now);
      if (EVEN(sts))
        return sts;
      break;
    case graph_eDatabase_Local:
      hold_p = (pwr_tBoolean*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      break;
    default:;
    }
  }

  old_update = 0;
  update_p = 0;
  update_db = dyn->parse_attr_name(
      update_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Boolean) {
    switch (update_db) {
    case graph_eDatabase_Gdh:
      sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
          (void**)&update_p, &update_subid, attr_size, object, now);
      if (EVEN(sts))
        return sts;
      break;
    case graph_eDatabase_Local:
      update_p = (pwr_tBoolean*)dyn->graph->localdb_ref_or_create(
          parsed_name, attr_type);
      break;
    default:;
    }
  }

  mark1_p = 0;
  dyn->parse_attr_name(
      mark1_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name, (void**)&mark1_p,
        &mark1_subid, attr_size, object, now);
  }

  mark2_p = 0;
  dyn->parse_attr_name(
      mark2_attr, parsed_name, &inverted, &attr_type, &attr_size);
  if (!streq(parsed_name, "") && attr_type == pwr_eType_Float32) {
    sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name, (void**)&mark2_p,
        &mark2_subid, attr_size, object, now);
  }

  if (mark1_color != glow_eDrawType_Inherit
      || mark2_color != glow_eDrawType_Inherit)
    grow_SetXYCurveMarkColor(object, mark1_color, mark2_color);

  max_points = grow_GetXYCurveNoOfPoints(object);
  grow_SetXYCurveNoOfCurves(object, sevhist_cnt);
  direction = grow_GetTrendDirection(object);

  time_Float64ToD(&dt_timerange, timerange);
  for (int i = 0; i < sevhist_cnt; i++)
    grow_SetXYCurveRangeX(object, i, timerange, 0);

  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeSevHist::disconnect(grow_tObject object)
{
  if (min_value1_p && min_value1_db == graph_eDatabase_Gdh) {
    gdh_UnrefObjectInfo(min_value_subid1);
    min_value1_p = 0;
  }
  if (max_value1_p && max_value1_db == graph_eDatabase_Gdh) {
    gdh_UnrefObjectInfo(max_value_subid1);
    max_value1_p = 0;
  }
  if (min_value2_p) {
    gdh_UnrefObjectInfo(min_value_subid2);
    min_value2_p = 0;
  }
  if (max_value2_p) {
    gdh_UnrefObjectInfo(max_value_subid2);
    max_value2_p = 0;
  }
  if (hold_p && hold_db == graph_eDatabase_Gdh) {
    gdh_UnrefObjectInfo(hold_subid);
    hold_p = 0;
  }
  if (mark1_p) {
    gdh_UnrefObjectInfo(mark1_subid);
    mark1_p = 0;
  }
  if (mark2_p) {
    gdh_UnrefObjectInfo(mark2_subid);
    mark1_p = 0;
  }
  return 1;
}

int GeSevHist::scan(grow_tObject object)
{
  if (!sevhist_cnt)
    return 0;

  pwr_tStatus sts;
  int i, k;
  int new_curve = 0;

  if (hold_p)
    trend_hold = *hold_p;

  if (max_value1_p || min_value1_p) {
    bool update = false;

    pwr_tFloat32 maxval;
    pwr_tFloat32 minval;
    if (max_value1_p) {
      maxval = *max_value1_p;
      if (!feqf(maxval, old_max_value1))
	update = true;
    }
    if (min_value1_p) {
      minval = *min_value1_p;
      if (!feqf(minval, old_min_value1))
	update = true;
    }
    if (update) {
      double minvald, maxvald;
      grow_GetXYCurveRangeY(object, 0, &minvald, &maxvald);

      if (!min_value1_p)
	minval = minvald;
      if (!max_value1_p)
	maxval = maxvald;

      if (fabsf(maxval - minval) > FLT_EPSILON) {
        grow_SetXYCurveRangeY(object, 0, minval, maxval);
	new_curve = 1;
      }
      old_min_value1 = minval;
      old_max_value1 = maxval;
    }
  }

  if (max_value2_p || min_value2_p) {
    bool update = false;

    pwr_tFloat32 maxval;
    pwr_tFloat32 minval;
    if (max_value2_p) {
      maxval = *max_value2_p;
      if (!feqf(maxval, old_max_value2))
	update = true;
    }
    if (min_value2_p) {
      minval = *min_value2_p;
      if (!feqf(minval, old_min_value2))
	update = true;
    }
    if (update) {
      double minvald, maxvald;
      grow_GetXYCurveRangeY(object, 1, &minvald, &maxvald);

      if (!min_value2_p)
	minval = minvald;
      if (!max_value2_p)
	maxval = maxvald;

      if (fabsf(maxval - minval) > FLT_EPSILON) {
        grow_SetXYCurveRangeY(object, 1, minval, maxval);
	new_curve = 1;
      }
      old_min_value2 = minval;
      old_max_value2 = maxval;
    }
  }

  if (mark1_p && (first_scan || fabsf(*mark1_p - old_mark1) > FLT_EPSILON)) {
    grow_SetXYCurveYMark1(object, *mark1_p);
    old_mark1 = *mark1_p;
  }
  if (mark2_p && (first_scan || fabsf(*mark2_p - old_mark2) > FLT_EPSILON)) {
    grow_SetXYCurveYMark2(object, *mark2_p);
    old_mark2 = *mark2_p;
  }

  if (timerange_p && (fabsf(*timerange_p - timerange) > FLT_EPSILON)) {
    timerange = *timerange_p;
    time_Float64ToD(&dt_timerange, timerange);
    for (int i = 0; i < sevhist_cnt; i++)
      grow_SetXYCurveRangeX(object, i, timerange, 0);
    new_curve = 1;
  }

  if (first_scan) {
    first_scan = false;
    new_curve = 1;
  }

  if (trend_hold)
    return 1;

  if (update_p) {
    if (*update_p && !old_update)
      new_curve = 1;
    old_update = *update_p;
  }

  if (updatetime != 0) {
    if (dyn->cycle == glow_eCycle_Slow)
      acc_time += dyn->graph->scan_time;
    else
      acc_time += dyn->graph->fast_scan_time;

    if (acc_time + DBL_EPSILON >= updatetime) {
      new_curve = 1;
      acc_time = 0;
    }
  }

  if (new_curve) {
    pwr_tTime* tbuf;
    void* vbuf;
    int rows;
    pwr_eType vtype;
    unsigned int vsize;
    pwr_tTime from, to;
    pwr_tDeltaTime diff;
    double time;
    double *tdata, *vdata;
    int points;

    time_GetTime(&to);
    time_Asub(&from, &to, &dt_timerange);

    sevcli_set_servernode(&sts, scctx, server);
    if (EVEN(sts))
      return sts;

    // Draw whole curve
    for (i = 0; i < sevhist_cnt; i++) {
      sevcli_get_itemdata(&sts, scctx, oidv[i], anamev[i], from, to, max_points, &tbuf,
			  &vbuf, &rows, &vtype, &vsize);
      if (EVEN(sts))
	  continue;

      switch (vtype) {
      case pwr_eType_Int32:
      case pwr_eType_Float32:
	tdata = (double*)calloc(1, 8 * rows);
	vdata = (double*)calloc(1, 8 * rows);
	break;
      case pwr_eType_Boolean:
	tdata = (double*)calloc(1, 8 * rows * 2);
	vdata = (double*)calloc(1, 8 * rows * 2);
	break;
      default:
	return 0;
      }

      points = 0;
      for (k = 0; k < rows; k++) {
	time_Adiff(&diff, &to, &tbuf[k]);
	time_DToFloat64(&time, &diff);

  	switch (vtype) {
	case pwr_eType_Int32:
	  vdata[k] = ((pwr_tInt32*)vbuf)[k];
	  tdata[k] = time;
	  points++;
	  break;
	case pwr_eType_Float32:
	  vdata[k] = ((pwr_tFloat32*)vbuf)[k];	  
	  tdata[k] = time;
	  points++;
	  break;
	case pwr_eType_Boolean:
	  if (k == 0) {
	    vdata[points] = ((pwr_tBoolean*)vbuf)[k];
	    tdata[points++] = time;
	  }
	  else if (((pwr_tBoolean*)vbuf)[k] != ((pwr_tBoolean*)vbuf)[k-1]) {
	    vdata[points] = ((pwr_tBoolean*)vbuf)[k-1];	  
	    tdata[points++] = time;
	    vdata[points] = ((pwr_tBoolean*)vbuf)[k];
	    tdata[points++] = time;
	  }
	  else if (k == rows - 1) {
	    vdata[points] = ((pwr_tBoolean*)vbuf)[k];
	    tdata[points++] = time;
	  }
	  break;
	default:
	  return 0;
	}
      }
      if (direction == glow_eHorizDirection_Right) {
	for (k = 0; k < points; k++)
	  tdata[k] = timerange - tdata[k];
      }
      grow_SetXYCurveData(object, vdata, tdata, i, points);
      free(tdata);
      free(vdata);
      free(tbuf);
      free(vbuf);
    }
  }
  
  return 1;
}

int GeSevHist::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int sts;
  pwr_eType a_type;

  if (streq(sevhist_object1, "") && streq(attribute1, "")) {
    dyn->graph->syntax_msg('W', object, "SevHist.Object1 or SevHist.Attribute1 is missing");
    (*warning_cnt)++;
  }

  if (streq(server, "") && !streq(attribute1, "")) {
    dyn->graph->syntax_msg('W', object, "SevHist.Attribute1 set but SevHist.Server is missing");
    (*warning_cnt)++;
  }

  if (!streq(sevhist_object1, "")) {
    sts = dyn->graph->check_ldh_object(sevhist_object1, &a_type);
    if (EVEN(sts)) {
      char msg[440];
      sprintf(msg, "SevHist.Object1 \"%s\" not found", sevhist_object1);
      dyn->graph->syntax_msg('W', object, msg);
      (*warning_cnt)++;
    } else {
      if (a_type != pwr_cClass_SevHist) {
        dyn->graph->syntax_msg(
            'E', object, "SevHist.Object1 is of wrong class");
        (*error_cnt)++;
      }
    }
  }

  if (!streq(sevhist_object2, "")) {
    sts = dyn->graph->check_ldh_object(sevhist_object2, &a_type);
    if (EVEN(sts)) {
      char msg[440];
      sprintf(msg, "SevHist.Object2 \"%s\" not found", sevhist_object2);
      dyn->graph->syntax_msg('W', object, msg);
      (*warning_cnt)++;
    } else {
      if (a_type != pwr_cClass_SevHist) {
        dyn->graph->syntax_msg(
            'E', object, "SevHist.Object2 is of wrong class");
        (*error_cnt)++;
      }
    }
  }

  if (!streq(attribute1, "")) {
    sts = dyn->graph->check_ldh_object(attribute1, &a_type);
    if (EVEN(sts)) {
      char msg[440];
      sprintf(msg, "SevHist.Attribute1 \"%s\" not found", attribute1);
      dyn->graph->syntax_msg('W', object, msg);
      (*warning_cnt)++;
    }
  }

  if (!streq(attribute2, "")) {
    sts = dyn->graph->check_ldh_object(attribute2, &a_type);
    if (EVEN(sts)) {
      char msg[440];
      sprintf(msg, "SevHist.Attribute2 \"%s\" not found", attribute2);
      dyn->graph->syntax_msg('W', object, msg);
      (*warning_cnt)++;
    }
  }
  return 1;
}

GePulldownMenu::GePulldownMenu(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No,
          ge_mActionType1_PulldownMenu, ge_mActionType2_No,
          ge_eDynPrio_PulldownMenu),
      button_mask(1), menu_object(0)
{
  memset(items_dyn, 0, sizeof(items_dyn));
  memset(items_text, 0, sizeof(items_text));
  memset(&focus_gained_time, 0, sizeof(focus_gained_time));
  items_dyn[0] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
}

GePulldownMenu::GePulldownMenu(const GePulldownMenu& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      button_mask(x.button_mask), menu_object(0)
{
  memset(items_dyn, 0, sizeof(items_dyn));
  memset(&focus_gained_time, 0, sizeof(focus_gained_time));
  memcpy(items_text, x.items_text, sizeof(items_text));
  for (int i = 0; i < 32; i++) {
    if (x.items_dyn[i])
      items_dyn[i] = new GeDyn(*x.items_dyn[i]);
  }
}

GePulldownMenu::~GePulldownMenu()
{
  for (int i = 0; i < 32; i++) {
    if (items_dyn[i])
      delete items_dyn[i];
  }
}

void GePulldownMenu::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  int b_mask = ge_mInstance_1;
  for (int j = 0; j < 32; j++) {
    if (b_mask & button_mask && !items_dyn[j]) {
      items_dyn[j] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
    }
    b_mask = b_mask << 1;
  }

  strcpy(attrinfo[i].name, "PulldownMenu.ItemMask");
  attrinfo[i].value = &button_mask;
  attrinfo[i].type = ge_eAttrType_InstanceMask;
  attrinfo[i++].size = sizeof(button_mask);

  b_mask = ge_mInstance_1;
  for (int j = 0; j < 32; j++) {
    if (b_mask & button_mask) {
      sprintf(attrinfo[i].name, "PulldownMenu.ItemText%d", j + 1);
      attrinfo[i].value = items_text[j];
      attrinfo[i].type = glow_eType_String;
      attrinfo[i++].size = sizeof(items_text[0]);

      sprintf(attrinfo[i].name, "PulldownMenu.ItemDyn%d", j + 1);
      attrinfo[i].value = items_dyn[j];
      attrinfo[i].type = ge_eAttrType_Dyn;
      attrinfo[i++].size = 0;
    }
    b_mask = b_mask << 1;
  }
  dyn->display_access = true;
  *item_count = i;
}

int GePulldownMenu::get_transtab(char** tt)
{
  static char transtab[][32]
      = { "SubGraph", "SubGraph", "A1", "Text", "Dynamic", "", "" };

  *tt = (char*)transtab;
  return 0;
}

void GePulldownMenu::save(std::ofstream& fp)
{
  int b_mask = ge_mInstance_1;

  fp << int(ge_eSave_PulldownMenu) << '\n';
  fp << int(ge_eSave_PulldownMenu_button_mask) << FSPACE << int(button_mask)
     << '\n';
  b_mask = ge_mInstance_1;
  for (int j = 0; j < 32; j++) {
    if (b_mask & button_mask) {
      fp << int(ge_eSave_PulldownMenu_items_text0 + j) << FSPACE
         << items_text[j] << '\n';
      fp << int(ge_eSave_PulldownMenu_items_dyn0 + j) << '\n';
      if (items_dyn[j])
        items_dyn[j]->save(fp);
    }
    b_mask = b_mask << 1;
  }
  fp << int(ge_eSave_End) << '\n';
}

void GePulldownMenu::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GePulldownMenu: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_PulldownMenu:
      break;
    case ge_eSave_PulldownMenu_button_mask:
      fp >> tmp;
      button_mask = (ge_mInstance)tmp;
      break;
    case ge_eSave_PulldownMenu_items_text0:
      fp.get();
      fp.getline(items_text[0], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[0], items_text[0]);
      break;
    case ge_eSave_PulldownMenu_items_text1:
      fp.get();
      fp.getline(items_text[1], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[1], items_text[1]);
      break;
    case ge_eSave_PulldownMenu_items_text2:
      fp.get();
      fp.getline(items_text[2], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[2], items_text[2]);
      break;
    case ge_eSave_PulldownMenu_items_text3:
      fp.get();
      fp.getline(items_text[3], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[3], items_text[3]);
      break;
    case ge_eSave_PulldownMenu_items_text4:
      fp.get();
      fp.getline(items_text[4], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[4], items_text[4]);
      break;
    case ge_eSave_PulldownMenu_items_text5:
      fp.get();
      fp.getline(items_text[5], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[5], items_text[5]);
      break;
    case ge_eSave_PulldownMenu_items_text6:
      fp.get();
      fp.getline(items_text[6], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[6], items_text[6]);
      break;
    case ge_eSave_PulldownMenu_items_text7:
      fp.get();
      fp.getline(items_text[7], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[7], items_text[7]);
      break;
    case ge_eSave_PulldownMenu_items_text8:
      fp.get();
      fp.getline(items_text[8], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[8], items_text[8]);
      break;
    case ge_eSave_PulldownMenu_items_text9:
      fp.get();
      fp.getline(items_text[9], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[9], items_text[9]);
      break;
    case ge_eSave_PulldownMenu_items_text10:
      fp.get();
      fp.getline(items_text[10], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[10], items_text[10]);
      break;
    case ge_eSave_PulldownMenu_items_text11:
      fp.get();
      fp.getline(items_text[11], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[11], items_text[11]);
      break;
    case ge_eSave_PulldownMenu_items_text12:
      fp.get();
      fp.getline(items_text[12], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[12], items_text[12]);
      break;
    case ge_eSave_PulldownMenu_items_text13:
      fp.get();
      fp.getline(items_text[13], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[13], items_text[13]);
      break;
    case ge_eSave_PulldownMenu_items_text14:
      fp.get();
      fp.getline(items_text[14], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[14], items_text[14]);
      break;
    case ge_eSave_PulldownMenu_items_text15:
      fp.get();
      fp.getline(items_text[15], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[15], items_text[15]);
      break;
    case ge_eSave_PulldownMenu_items_text16:
      fp.get();
      fp.getline(items_text[16], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[16], items_text[16]);
      break;
    case ge_eSave_PulldownMenu_items_text17:
      fp.get();
      fp.getline(items_text[17], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[17], items_text[17]);
      break;
    case ge_eSave_PulldownMenu_items_text18:
      fp.get();
      fp.getline(items_text[18], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[18], items_text[18]);
      break;
    case ge_eSave_PulldownMenu_items_text19:
      fp.get();
      fp.getline(items_text[19], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[19], items_text[19]);
      break;
    case ge_eSave_PulldownMenu_items_text20:
      fp.get();
      fp.getline(items_text[20], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[20], items_text[20]);
      break;
    case ge_eSave_PulldownMenu_items_text21:
      fp.get();
      fp.getline(items_text[21], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[21], items_text[21]);
      break;
    case ge_eSave_PulldownMenu_items_text22:
      fp.get();
      fp.getline(items_text[22], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[22], items_text[22]);
      break;
    case ge_eSave_PulldownMenu_items_text23:
      fp.get();
      fp.getline(items_text[23], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[23], items_text[23]);
      break;
    case ge_eSave_PulldownMenu_items_text24:
      fp.get();
      fp.getline(items_text[24], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[24], items_text[24]);
      break;
    case ge_eSave_PulldownMenu_items_text25:
      fp.get();
      fp.getline(items_text[25], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[25], items_text[25]);
      break;
    case ge_eSave_PulldownMenu_items_text26:
      fp.get();
      fp.getline(items_text[26], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[26], items_text[26]);
      break;
    case ge_eSave_PulldownMenu_items_text27:
      fp.get();
      fp.getline(items_text[27], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[27], items_text[27]);
      break;
    case ge_eSave_PulldownMenu_items_text28:
      fp.get();
      fp.getline(items_text[28], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[28], items_text[28]);
      break;
    case ge_eSave_PulldownMenu_items_text29:
      fp.get();
      fp.getline(items_text[29], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[29], items_text[29]);
      break;
    case ge_eSave_PulldownMenu_items_text30:
      fp.get();
      fp.getline(items_text[30], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[30], items_text[30]);
      break;
    case ge_eSave_PulldownMenu_items_text31:
      fp.get();
      fp.getline(items_text[31], sizeof(items_text[0]));
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        Lng::translate(items_text[31], items_text[31]);
      break;
    case ge_eSave_PulldownMenu_items_dyn0:
      items_dyn[0]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn1:
      if (!items_dyn[1])
        items_dyn[1] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[1]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn2:
      if (!items_dyn[2])
        items_dyn[2] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[2]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn3:
      if (!items_dyn[3])
        items_dyn[3] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[3]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn4:
      if (!items_dyn[4])
        items_dyn[4] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[4]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn5:
      if (!items_dyn[5])
        items_dyn[5] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[5]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn6:
      if (!items_dyn[6])
        items_dyn[6] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[6]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn7:
      if (!items_dyn[7])
        items_dyn[7] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[7]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn8:
      if (!items_dyn[8])
        items_dyn[8] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[8]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn9:
      if (!items_dyn[9])
        items_dyn[9] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[9]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn10:
      if (!items_dyn[10])
        items_dyn[10] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[10]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn11:
      if (!items_dyn[11])
        items_dyn[11] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[11]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn12:
      if (!items_dyn[12])
        items_dyn[12] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[12]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn13:
      if (!items_dyn[13])
        items_dyn[13] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[13]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn14:
      if (!items_dyn[14])
        items_dyn[14] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[14]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn15:
      if (!items_dyn[15])
        items_dyn[15] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[15]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn16:
      if (!items_dyn[16])
        items_dyn[16] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[16]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn17:
      if (!items_dyn[17])
        items_dyn[17] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[17]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn18:
      if (!items_dyn[18])
        items_dyn[18] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[18]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn19:
      if (!items_dyn[19])
        items_dyn[19] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[19]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn20:
      if (!items_dyn[20])
        items_dyn[20] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[20]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn21:
      if (!items_dyn[21])
        items_dyn[21] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[21]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn22:
      if (!items_dyn[22])
        items_dyn[22] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[22]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn23:
      if (!items_dyn[23])
        items_dyn[23] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[23]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn24:
      if (!items_dyn[24])
        items_dyn[24] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[24]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn25:
      if (!items_dyn[25])
        items_dyn[25] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[25]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn26:
      if (!items_dyn[26])
        items_dyn[26] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[26]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn27:
      if (!items_dyn[27])
        items_dyn[27] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[27]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn28:
      if (!items_dyn[28])
        items_dyn[28] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[28]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn29:
      if (!items_dyn[29])
        items_dyn[29] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[29]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn30:
      if (!items_dyn[30])
        items_dyn[30] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[30]->open(fp);
      break;
    case ge_eSave_PulldownMenu_items_dyn31:
      if (!items_dyn[31])
        items_dyn[31] = new GeDyn(dyn->graph, ge_eDynAttr_Menu);
      items_dyn[31]->open(fp);
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GePulldownMenu:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GePulldownMenu::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetClickSensitivity(dyn->graph->grow->ctx, glow_mSensitivity_MB1Click);
    break;
  case glow_eEvent_MB1Up:
    break;
  case glow_eEvent_Key_Up:
    if (!menu_object)
      break;
    if (grow_GetMenuInputFocus(menu_object)) {
      grow_MenuShiftCurrentItem(menu_object, -1);
      return GE__NO_PROPAGATE;
    } else {
      int sts;
      for (int j = 0; j < 32; j++) {
        if (items_dyn[j]
            && items_dyn[j]->action_type1 & ge_mActionType1_PulldownMenu) {
          sts = items_dyn[j]->action(0, event);
          if (sts == GE__NO_PROPAGATE)
            return sts;
        }
      }
    }
    break;
  case glow_eEvent_Key_Down:
    if (!menu_object)
      break;
    if (grow_GetMenuInputFocus(menu_object)) {
      grow_MenuShiftCurrentItem(menu_object, 1);
      return GE__NO_PROPAGATE;
    } else {
      int sts;
      for (int j = 0; j < 32; j++) {
        if (items_dyn[j]
            && items_dyn[j]->action_type1 & ge_mActionType1_PulldownMenu) {
          sts = items_dyn[j]->action(0, event);
          if (sts == GE__NO_PROPAGATE)
            return sts;
        }
      }
    }
    break;
  case glow_eEvent_Key_Right:
    if (!menu_object)
      break;

    if (grow_GetMenuInputFocus(menu_object)) {
      int item, sts;
      sts = grow_MenuGetCurrentItem(menu_object, &item);
      if (EVEN(sts))
        break;

      if (items_dyn[item]
          && items_dyn[item]->action_type1 & ge_mActionType1_PulldownMenu) {
        // Send create menu event
        glow_sEvent e;
        e.event = glow_eEvent_MenuCreate;
        e.menu.item = item;
        e.menu.object = menu_object;
        grow_GetSubmenuPosition(menu_object, item, &e.menu.x, &e.menu.y);
        action(object, &e);
        return GE__NO_PROPAGATE;
      }
    } else {
      int sts;
      for (int j = 0; j < 32; j++) {
        if (items_dyn[j]
            && items_dyn[j]->action_type1 & ge_mActionType1_PulldownMenu) {
          sts = items_dyn[j]->action(0, event);
          if (sts == GE__NO_PROPAGATE)
            return sts;
        }
      }
    }
    break;
  case glow_eEvent_Key_Left:
    if (!menu_object)
      break;

    if (!object && grow_GetMenuInputFocus(menu_object)) {
      // Delete this and all child menues
      glow_sEvent e;
      e.event = glow_eEvent_MenuDelete;
      e.menu.object = 0;
      for (int j = 0; j < 32; j++) {
        if (items_dyn[j]
            && items_dyn[j]->action_type1 & ge_mActionType1_PulldownMenu)
          items_dyn[j]->action(0, &e);
      }

      grow_DeleteObject(dyn->graph->grow->ctx, menu_object);
      menu_object = 0;
      return GE__NO_PROPAGATE;
    } else {
      int sts;
      for (int j = 0; j < 32; j++) {
        if (items_dyn[j]
            && items_dyn[j]->action_type1 & ge_mActionType1_PulldownMenu) {
          sts = items_dyn[j]->action(0, event);
          if (sts == GE__NO_PROPAGATE)
            return sts;
        }
      }
    }
    break;
  case glow_eEvent_Key_Return:
    if (!menu_object)
      break;

    if (grow_GetMenuInputFocus(menu_object)) {
      // Send menu activated event
      int sts;
      glow_sEvent e;
      e.event = glow_eEvent_MenuActivated;
      e.menu.object = menu_object;
      sts = grow_MenuGetCurrentItem(menu_object, &e.menu.item);
      if (EVEN(sts))
        break;

      int close_graph = 0;
      if (items_dyn[e.menu.item]
          && items_dyn[e.menu.item]->action_type1 & ge_mActionType1_CloseGraph)
        close_graph = 1;

      action(object, &e);

      if (!close_graph) {
        // Close any open menu
        Graph* graph = dyn->graph;
        glow_sEvent e;
        grow_tObject* objectlist;
        int object_cnt, cnt;
        int i;

        e.event = glow_eEvent_MenuDelete;
        e.any.type = glow_eEventType_Menu;
        e.menu.object = 0;

        grow_GetObjectList(graph->grow->ctx, &objectlist, &object_cnt);
        for (i = 0; i < object_cnt; i++) {
          if (grow_GetObjectType(objectlist[i]) == glow_eObjectType_GrowNode
              || grow_GetObjectType(objectlist[i])
                  == glow_eObjectType_GrowGroup) {
            grow_GetUserData(objectlist[i], (void**)&dyn);
            dyn->action(objectlist[i], &e);
            grow_GetObjectList(graph->grow->ctx, &objectlist, &cnt);
            if (cnt != object_cnt)
              // Something is deleted
              break;
          }
        }
        return GE__NO_PROPAGATE;
      }
    } else {
      for (int j = 0; j < 32; j++) {
        if (items_dyn[j]
            && items_dyn[j]->action_type1 & ge_mActionType1_PulldownMenu)
          items_dyn[j]->action(object, event);
      }
    }
    break;

  case glow_eEvent_InputFocusGained:
    if (menu_object)
      break;
    time_GetTime(&focus_gained_time);
  case glow_eEvent_MB1Click:
    if (event->event == glow_eEvent_MB1Click) {
      pwr_tTime now;
      time_GetTime(&now);
      if (ABS((int)(now.tv_sec - focus_gained_time.tv_sec)) < 2)
        break;
    }
    if (menu_object) {
      // Close, delete this menu and all childmenues
      for (int j = 0; j < 32; j++) {
        if (items_dyn[j]
            && items_dyn[j]->action_type1 & ge_mActionType1_PulldownMenu)
          items_dyn[j]->action(0, event);
      }

      grow_DeleteObject(dyn->graph->grow->ctx, menu_object);
      menu_object = 0;
    } else if (object) {
      double ll_x, ll_y, ur_x, ur_y;
      glow_sMenuInfo info;

      int b_mask = 1;
      for (int i = 0; i < 32; i++) {
        if (b_mask & button_mask) {
          info.item[i].occupied = true;
          strcpy(info.item[i].text, items_text[i]);

          // Check access
          if (items_dyn[i]->action_type1 & ge_mActionType1_PulldownMenu)
            info.item[i].type = glow_eMenuItem_PulldownMenu;
          else {
            // Check access
            if (dyn->graph->is_authorized(items_dyn[i]->access)) {
              info.item[i].type = glow_eMenuItem_Button;
              if (items_dyn[i]->dyn_type1 & ge_mDynType1_Invisible) {
                int attr_type, attr_size;
                int inverted;
                pwr_tAName parsed_name;
                int sts;
                GeInvisible* invis_element = 0;
                pwr_tCmd cmd, command;
                char* s;
                pwr_tBoolean value;

                for (GeDynElem* elem = items_dyn[i]->elements; elem;
                     elem = elem->next) {
                  if (elem->dyn_type1 == ge_mDynType1_Invisible) {
                    invis_element = (GeInvisible*)elem;
                    break;
                  }
                }
                if (invis_element) {
                  dyn->parse_attr_name(invis_element->attribute, parsed_name,
                      &inverted, &attr_type, &attr_size);

                  if (str_NoCaseStrncmp(parsed_name, "$cmd(", 5) == 0) {
                    strcpy(command, &parsed_name[5]);

                    if ((s = strrchr(command, ')')))
                      *s = 0;

                    dyn->graph->get_command(command, cmd, dyn);

                    sts = (dyn->graph->command_cb)(
                        dyn->graph->parent_ctx, cmd, 0);
                    if (EVEN(sts))
                      info.item[i].type = glow_eMenuItem_ButtonDisabled;
                  } else {
                    sts = gdh_GetObjectInfo(parsed_name, &value, sizeof(value));
                    if (ODD(sts)) {
                      if ((!inverted && value) || (inverted && !value)) {
                        if (invis_element->dimmed)
                          info.item[i].type = glow_eMenuItem_ButtonDisabled;
                        else
                          info.item[i].occupied = false;
                      }
                    }
                  }
                }
              }
            } else
              info.item[i].type = glow_eMenuItem_ButtonDisabled;
          }
        } else
          info.item[i].occupied = false;
        b_mask = b_mask << 1;
      }

      // Get fillcolor, and textattributes from object
      glow_eDrawType text_drawtype, text_color, bg_color;
      int text_size;
      int sts;
      double scale;
      glow_eFont text_font;
      glow_eAnnotType annot_type;

      sts = grow_GetObjectAnnotInfo(object, 1, &text_size, &text_drawtype,
          &text_color, &bg_color, &scale, &text_font, &annot_type);
      if (EVEN(sts)) {
        text_size = 2;
        text_drawtype = glow_eDrawType_TextHelveticaBold;
        text_font = glow_eFont_Helvetica;
        text_color = glow_eDrawType_Line;
        bg_color = glow_eDrawType_LightGray;
      } else if (bg_color == glow_eDrawType_No
          || bg_color == glow_eDrawType_Inherit)
        bg_color = glow_eDrawType_LightGray;

      grow_MeasureNode(object, &ll_x, &ll_y, &ur_x, &ur_y);
      grow_CreateGrowMenu(dyn->graph->grow->ctx, "__Menu", &info, ll_x, ur_y,
          ur_x - ll_x, glow_eDrawType_Line, 0, 1, 1, bg_color, text_size,
          text_drawtype, text_color, glow_eDrawType_MediumGray, text_font, 0,
          &menu_object);
      grow_SetObjectScale(
          menu_object, scale, scale, 0, 0, glow_eScaleType_LowerLeft);
      grow_SetMenuInputFocus(menu_object, 1);
    }
    break;
  case glow_eEvent_MenuActivated:
    if (!menu_object)
      break;
    if (event->menu.object == menu_object) {
      if (items_dyn[event->menu.item]) {
        glow_sEvent e;
        e.event = glow_eEvent_MB1Click;
        return items_dyn[event->menu.item]->action(event->menu.object, &e);
      }
    } else {
      for (int j = 0; j < 32; j++) {
        if (items_dyn[j]
            && items_dyn[j]->action_type1 & ge_mActionType1_PulldownMenu)
          items_dyn[j]->action(0, event);
      }
    }
    break;
  case glow_eEvent_MenuCreate:
    if (object && !(grow_GetObjectType(object) == glow_eObjectType_GrowMenu)) {
      // Parent menu, call submenues
      if (event->menu.object == menu_object) {
        // Call specified item to create the menu
        // send menu_object as object arg to pass parent menu
        if (items_dyn[event->menu.item])
          items_dyn[event->menu.item]->action(menu_object, event);
      } else {
        // Send event to all child menu items
        for (int j = 0; j < 32; j++) {
          if (items_dyn[j]
              && items_dyn[j]->action_type1 & ge_mActionType1_PulldownMenu)
            items_dyn[j]->action(0, event);
        }
      }
    } else {
      // A submenu
      if (object) {
        // Create this menu
        glow_sMenuInfo info;

        int b_mask = 1;
        for (int i = 0; i < 32; i++) {
          if (b_mask & button_mask) {
            info.item[i].occupied = true;
            strcpy(info.item[i].text, items_text[i]);
            if (items_dyn[i]->action_type1 & ge_mActionType1_PulldownMenu)
              info.item[i].type = glow_eMenuItem_PulldownMenu;
            else {
              // Check access
              if (dyn->graph->is_authorized(items_dyn[i]->access))
                info.item[i].type = glow_eMenuItem_Button;
              else
                info.item[i].type = glow_eMenuItem_ButtonDisabled;
            }
          } else
            info.item[i].occupied = false;
          b_mask = b_mask << 1;
        }

        glow_eDrawType text_drawtype, text_color, bg_color, text_color_disabled;
        int tsize;
        glow_eFont text_font;

        grow_GetMenuChar(object, &tsize, &bg_color, &text_drawtype, &text_color,
            &text_color_disabled, &text_font);

        grow_CreateGrowMenu(dyn->graph->grow->ctx, "__Menu", &info,
            event->menu.x, event->menu.y, 0, glow_eDrawType_Line, 0, 1, 1,
            bg_color, tsize, text_drawtype, text_color, text_color_disabled,
            text_font, object, &menu_object);
        grow_SetMenuInputFocus(object, 0);
        grow_SetMenuInputFocus(menu_object, 1);
      } else {
        if (menu_object == event->menu.object) {
          // Call specified item to create the menu
          // send menu_object as object arg to pass parent menu
          if (items_dyn[event->menu.item])
            items_dyn[event->menu.item]->action(menu_object, event);
        } else {
          // Send event to child menu items
          for (int j = 0; j < 32; j++) {
            if (items_dyn[j]
                && items_dyn[j]->action_type1 & ge_mActionType1_PulldownMenu)
              items_dyn[j]->action(0, event);
          }
        }
      }
    }
    break;
  case glow_eEvent_InputFocusLost: {
    // Delete this and all child menues
    glow_sEvent e;
    e.event = glow_eEvent_MenuDelete;
    e.menu.object = 0;

    for (int j = 0; j < 32; j++) {
      if (items_dyn[j]
          && items_dyn[j]->action_type1 & ge_mActionType1_PulldownMenu)
        items_dyn[j]->action(0, &e);
    }
    grow_DeleteObject(dyn->graph->grow->ctx, menu_object);
    menu_object = 0;
    break;
  }
  case glow_eEvent_MenuDelete:
    if (menu_object == 0)
      break;
    if (event->menu.object == 0) {
      // Delete this and all child menues
      for (int j = 0; j < 32; j++) {
        if (items_dyn[j]
            && items_dyn[j]->action_type1 & ge_mActionType1_PulldownMenu)
          items_dyn[j]->action(0, event);
      }
      grow_DeleteObject(dyn->graph->grow->ctx, menu_object);
      menu_object = 0;
    } else {
      if (event->menu.object == menu_object) {
        // Delete this and all child menues
        event->menu.object = 0;
        for (int j = 0; j < 32; j++) {
          if (items_dyn[j]
              && items_dyn[j]->action_type1 & ge_mActionType1_PulldownMenu)
            items_dyn[j]->action(0, event);
        }
        event->menu.object = menu_object;

        grow_DeleteObject(dyn->graph->grow->ctx, menu_object);
        menu_object = 0;
      } else {
        for (int j = 0; j < 32; j++) {
          if (items_dyn[j]
              && items_dyn[j]->action_type1 & ge_mActionType1_PulldownMenu)
            items_dyn[j]->action(0, event);
        }
      }
    }
    break;
  default:;
  }
  return 1;
}

int GePulldownMenu::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynPulldownMenu(" << var_name << ".dd, new String[] {\n"
     << "        ";
  int b_mask = 1;
  for (int i = 0; i < 32; i++) {
    if (b_mask & button_mask) {
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        fp << "JopLang.transl(\"" << items_text[i] << "\")";
      else
        fp << "\"" << items_text[i] << "\"";
    } else
      fp << "null";
    if (i != 31)
      fp << ",";
    b_mask = b_mask << 1;
  }
  fp << "},\n"
     << "        new GeDyn[] {\n"
     << "        ";
  b_mask = 1;
  for (int i = 0; i < 32; i++) {
    if (b_mask & button_mask)
      items_dyn[i]->export_java_object(object, fp, var_name);
    else {
      fp << "null";
      if (i != 31)
        fp << ",";
    }
    b_mask = b_mask << 1;
  }
  fp << '\n' << "      })\n";
  return 1;
}

GeOptionMenu::GeOptionMenu(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No,
          ge_mActionType1_OptionMenu, ge_mActionType2_No,
          ge_eDynPrio_OptionMenu),
      button_mask(1), menu_object(0), optionmenu_type(ge_eOptionMenuType_Static)
{
  strcpy(attribute, "");
  strcpy(text_attribute, "");
  strcpy(size_attribute, "");
  strcpy(update_attribute, "");
  for (int i = 0; i < 32; i++)
    items_enum[i] = i;
  memset(items_text, 0, sizeof(items_text));
  memset(&focus_gained_time, 0, sizeof(focus_gained_time));
}

GeOptionMenu::GeOptionMenu(const GeOptionMenu& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      button_mask(x.button_mask), menu_object(0),
      optionmenu_type(x.optionmenu_type)
{
  memset(&focus_gained_time, 0, sizeof(focus_gained_time));
  strcpy(attribute, x.attribute);
  strcpy(text_attribute, x.text_attribute);
  strcpy(size_attribute, x.size_attribute);
  strcpy(update_attribute, x.update_attribute);
  memcpy(items_text, x.items_text, sizeof(items_text));
  for (int i = 0; i < 32; i++) {
    items_enum[i] = x.items_enum[i];
  }
}

void GeOptionMenu::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "OptionMenu.Type");
  attrinfo[i].value = &optionmenu_type;
  attrinfo[i].type = ge_eAttrType_OptionMenuType;
  attrinfo[i++].size = sizeof(optionmenu_type);

  strcpy(attrinfo[i].name, "OptionMenu.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  if (optionmenu_type == ge_eOptionMenuType_Dynamic) {
    strcpy(attrinfo[i].name, "OptionMenu.TextAttribute");
    attrinfo[i].value = text_attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(text_attribute);

    strcpy(attrinfo[i].name, "OptionMenu.SizeAttribute");
    attrinfo[i].value = size_attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(size_attribute);

    strcpy(attrinfo[i].name, "OptionMenu.UpdateAttribute");
    attrinfo[i].value = update_attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(update_attribute);
  } else {
    strcpy(attrinfo[i].name, "OptionMenu.ItemMask");
    attrinfo[i].value = &button_mask;
    attrinfo[i].type = ge_eAttrType_InstanceMask;
    attrinfo[i++].size = sizeof(button_mask);

    int b_mask = ge_mInstance_1;
    for (int j = 0; j < 32; j++) {
      if (b_mask & button_mask) {
        sprintf(attrinfo[i].name, "OptionMenu.ItemText%d", j + 1);
        attrinfo[i].value = items_text[j];
        attrinfo[i].type = glow_eType_String;
        attrinfo[i++].size = sizeof(items_text[0]);

        sprintf(attrinfo[i].name, "OptionMenu.ItemEnum%d", j + 1);
        attrinfo[i].value = &items_enum[j];
        attrinfo[i].type = glow_eType_Int;
        attrinfo[i++].size = sizeof(items_enum[0]);
      }
      b_mask = b_mask << 1;
    }
  }
  dyn->display_access = true;
  *item_count = i;
}

int GeOptionMenu::get_transtab(char** tt)
{
  static char transtab[][32]
      = { "SubGraph", "SubGraph", "A1", "", "Dynamic", "", "" };

  *tt = (char*)transtab;
  return 0;
}

void GeOptionMenu::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "OptionMenu.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeOptionMenu::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeOptionMenu::save(std::ofstream& fp)
{
  fp << int(ge_eSave_OptionMenu) << '\n';
  fp << int(ge_eSave_OptionMenu_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_OptionMenu_text_attribute) << FSPACE << text_attribute
     << '\n';
  fp << int(ge_eSave_OptionMenu_size_attribute) << FSPACE << size_attribute
     << '\n';
  fp << int(ge_eSave_OptionMenu_update_attribute) << FSPACE << update_attribute
     << '\n';
  fp << int(ge_eSave_OptionMenu_optionmenu_type) << FSPACE << optionmenu_type
     << '\n';
  fp << int(ge_eSave_OptionMenu_button_mask) << FSPACE << int(button_mask)
     << '\n';
  int b_mask = ge_mInstance_1;
  for (int j = 0; j < 32; j++) {
    if (b_mask & button_mask) {
      fp << int(ge_eSave_OptionMenu_items_text0 + j) << FSPACE << items_text[j]
         << '\n';
      fp << int(ge_eSave_OptionMenu_items_enum0 + j) << FSPACE << items_enum[j]
         << '\n';
    }
    b_mask = b_mask << 1;
  }
  fp << int(ge_eSave_End) << '\n';
}

void GeOptionMenu::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeOptionMenu: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_OptionMenu:
      break;
    case ge_eSave_OptionMenu_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_OptionMenu_text_attribute:
      fp.get();
      fp.getline(text_attribute, sizeof(text_attribute));
      break;
    case ge_eSave_OptionMenu_size_attribute:
      fp.get();
      fp.getline(size_attribute, sizeof(size_attribute));
      break;
    case ge_eSave_OptionMenu_update_attribute:
      fp.get();
      fp.getline(update_attribute, sizeof(update_attribute));
      break;
    case ge_eSave_OptionMenu_optionmenu_type:
      fp >> tmp;
      optionmenu_type = (ge_eOptionMenuType)tmp;
      break;
    case ge_eSave_OptionMenu_button_mask:
      fp >> tmp;
      button_mask = (ge_mInstance)tmp;
      break;
    case ge_eSave_OptionMenu_items_text0:
      fp.get();
      fp.getline(items_text[0], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text1:
      fp.get();
      fp.getline(items_text[1], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text2:
      fp.get();
      fp.getline(items_text[2], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text3:
      fp.get();
      fp.getline(items_text[3], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text4:
      fp.get();
      fp.getline(items_text[4], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text5:
      fp.get();
      fp.getline(items_text[5], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text6:
      fp.get();
      fp.getline(items_text[6], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text7:
      fp.get();
      fp.getline(items_text[7], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text8:
      fp.get();
      fp.getline(items_text[8], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text9:
      fp.get();
      fp.getline(items_text[9], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text10:
      fp.get();
      fp.getline(items_text[10], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text11:
      fp.get();
      fp.getline(items_text[11], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text12:
      fp.get();
      fp.getline(items_text[12], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text13:
      fp.get();
      fp.getline(items_text[13], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text14:
      fp.get();
      fp.getline(items_text[14], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text15:
      fp.get();
      fp.getline(items_text[15], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text16:
      fp.get();
      fp.getline(items_text[16], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text17:
      fp.get();
      fp.getline(items_text[17], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text18:
      fp.get();
      fp.getline(items_text[18], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text19:
      fp.get();
      fp.getline(items_text[19], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text20:
      fp.get();
      fp.getline(items_text[20], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text21:
      fp.get();
      fp.getline(items_text[21], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text22:
      fp.get();
      fp.getline(items_text[22], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text23:
      fp.get();
      fp.getline(items_text[23], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text24:
      fp.get();
      fp.getline(items_text[24], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text25:
      fp.get();
      fp.getline(items_text[25], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text26:
      fp.get();
      fp.getline(items_text[26], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text27:
      fp.get();
      fp.getline(items_text[27], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text28:
      fp.get();
      fp.getline(items_text[28], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text29:
      fp.get();
      fp.getline(items_text[29], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text30:
      fp.get();
      fp.getline(items_text[30], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_text31:
      fp.get();
      fp.getline(items_text[31], sizeof(items_text[0]));
      break;
    case ge_eSave_OptionMenu_items_enum0:
      fp >> items_enum[0];
      break;
    case ge_eSave_OptionMenu_items_enum1:
      fp >> items_enum[1];
      break;
    case ge_eSave_OptionMenu_items_enum2:
      fp >> items_enum[2];
      break;
    case ge_eSave_OptionMenu_items_enum3:
      fp >> items_enum[3];
      break;
    case ge_eSave_OptionMenu_items_enum4:
      fp >> items_enum[4];
      break;
    case ge_eSave_OptionMenu_items_enum5:
      fp >> items_enum[5];
      break;
    case ge_eSave_OptionMenu_items_enum6:
      fp >> items_enum[6];
      break;
    case ge_eSave_OptionMenu_items_enum7:
      fp >> items_enum[7];
      break;
    case ge_eSave_OptionMenu_items_enum8:
      fp >> items_enum[8];
      break;
    case ge_eSave_OptionMenu_items_enum9:
      fp >> items_enum[9];
      break;
    case ge_eSave_OptionMenu_items_enum10:
      fp >> items_enum[10];
      break;
    case ge_eSave_OptionMenu_items_enum11:
      fp >> items_enum[11];
      break;
    case ge_eSave_OptionMenu_items_enum12:
      fp >> items_enum[12];
      break;
    case ge_eSave_OptionMenu_items_enum13:
      fp >> items_enum[13];
      break;
    case ge_eSave_OptionMenu_items_enum14:
      fp >> items_enum[14];
      break;
    case ge_eSave_OptionMenu_items_enum15:
      fp >> items_enum[15];
      break;
    case ge_eSave_OptionMenu_items_enum16:
      fp >> items_enum[16];
      break;
    case ge_eSave_OptionMenu_items_enum17:
      fp >> items_enum[17];
      break;
    case ge_eSave_OptionMenu_items_enum18:
      fp >> items_enum[18];
      break;
    case ge_eSave_OptionMenu_items_enum19:
      fp >> items_enum[19];
      break;
    case ge_eSave_OptionMenu_items_enum20:
      fp >> items_enum[20];
      break;
    case ge_eSave_OptionMenu_items_enum21:
      fp >> items_enum[21];
      break;
    case ge_eSave_OptionMenu_items_enum22:
      fp >> items_enum[22];
      break;
    case ge_eSave_OptionMenu_items_enum23:
      fp >> items_enum[23];
      break;
    case ge_eSave_OptionMenu_items_enum24:
      fp >> items_enum[24];
      break;
    case ge_eSave_OptionMenu_items_enum25:
      fp >> items_enum[25];
      break;
    case ge_eSave_OptionMenu_items_enum26:
      fp >> items_enum[26];
      break;
    case ge_eSave_OptionMenu_items_enum27:
      fp >> items_enum[27];
      break;
    case ge_eSave_OptionMenu_items_enum28:
      fp >> items_enum[28];
      break;
    case ge_eSave_OptionMenu_items_enum29:
      fp >> items_enum[29];
      break;
    case ge_eSave_OptionMenu_items_enum30:
      fp >> items_enum[30];
      break;
    case ge_eSave_OptionMenu_items_enum31:
      fp >> items_enum[31];
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeOptionMenu:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeOptionMenu::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int attr_type, attr_size;
  pwr_tAName parsed_name;
  int sts;
  int inverted;

  p = 0;
  db = dyn->parse_attr_name(
      attribute, parsed_name, &inverted, &attr_type, &attr_size);
  if (streq(parsed_name, ""))
    return 1;

  size = attr_size;
  switch (db) {
  case graph_eDatabase_Gdh:
    sts = dyn->graph->ref_object_info(
        dyn->cycle, parsed_name, &p, &subid, attr_size, object, now);
    if (EVEN(sts))
      return sts;
    if (attr_type != 0)
      type_id = attr_type;
    else
      type_id = pwr_eType_Int32;
    break;
  case graph_eDatabase_Local:
    p = dyn->graph->localdb_ref_or_create(parsed_name, attr_type);
    type_id = attr_type;
  case graph_eDatabase_User:
    type_id = attr_type;
    break;
  case graph_eDatabase_Ccm:
    sts = dyn->graph->ccm_ref_variable(parsed_name, attr_type, &p);
    type_id = attr_type;
  default:;
  }

  switch (type_id) {
  case pwr_eType_Float32:
    size = sizeof(pwr_tFloat32);
    break;
  case pwr_eType_Int64:
    size = sizeof(pwr_tInt64);
    break;
  case pwr_eType_UInt64:
    size = sizeof(pwr_tUInt64);
    break;
  case pwr_eType_Int32:
    size = sizeof(pwr_tInt32);
    break;
  case pwr_eType_UInt32:
    size = sizeof(pwr_tUInt32);
    break;
  case pwr_eType_Int16:
    size = sizeof(pwr_tInt16);
    break;
  case pwr_eType_UInt16:
    size = sizeof(pwr_tUInt16);
    break;
  case pwr_eType_Int8:
    size = sizeof(pwr_tInt8);
    break;
  case pwr_eType_UInt8:
    size = sizeof(pwr_tUInt8);
    break;
  case pwr_eType_Float64:
    size = sizeof(pwr_tFloat64);
    break;
  default:
    return 1;
  }

  update_p = 0;
  if (optionmenu_type == ge_eOptionMenuType_Dynamic) {
    if (!streq(text_attribute, "") && !streq(update_attribute, "")) {
      db = dyn->parse_attr_name(
          update_attribute, parsed_name, &inverted, &attr_type, &attr_size);
      if (!streq(parsed_name, "")) {
        sts = dyn->graph->ref_object_info(dyn->cycle, parsed_name,
            (void**)&update_p, &update_subid, attr_size, object, now);
        if (EVEN(sts))
          return sts;
      }
    }

    // Reset item_enum
    for (int i = 0; i < 32; i++)
      items_enum[i] = i;
  }
  trace_data->p = &pdummy;
  first_scan = true;
  return 1;
}

int GeOptionMenu::disconnect(grow_tObject object)
{
  if (p && db == graph_eDatabase_Gdh)
    gdh_UnrefObjectInfo(subid);
  p = 0;

  if (update_p)
    gdh_UnrefObjectInfo(update_subid);

  return 1;
}

int GeOptionMenu::scan(grow_tObject object)
{
  if (!p)
    return 1;

  int update_texts = 0;
  if (!first_scan) {
    if (update_p) {
      if (*update_p == old_update_value && memcmp(&old_value, p, size) == 0)
        // No change since last time
        return 1;
    } else {
      if (memcmp(&old_value, p, size) == 0)
        // No change since last time
        return 1;
    }
    if (update_p && !old_update_value)
      update_texts = 1;
  } else {
    if (update_p)
      update_texts = 1;
  }

  unsigned int enum_value;

  if (update_texts) {
    pwr_tAName pname;
    int attr_type, attr_size;
    int sts;
    int inverted;

    dyn->parse_attr_name(
        size_attribute, pname, &inverted, &attr_type, &attr_size);

    sts = gdh_GetObjectInfo(pname, &text_size, sizeof(text_size));
    if (EVEN(sts))
      return sts;

    if (text_size > 32)
      return 0;

    dyn->parse_attr_name(
        text_attribute, pname, &inverted, &attr_type, &attr_size);

    sts = gdh_GetObjectInfo(
        pname, items_text, text_size * sizeof(pwr_tString80));
    if (EVEN(sts))
      return sts;
  }

  if ((first_scan || update_texts)
      && grow_GetTranslate(dyn->graph->grow->ctx)) {
    for (int i = 0; i < 32; i++) {
      if (!streq(items_text[i], ""))
        Lng::translate(items_text[i], items_text[i]);
    }
  }

  if (first_scan)
    first_scan = false;

  switch (type_id) {
  case pwr_eType_Float32:
    enum_value
        = (unsigned int)(*(pwr_tFloat32*)p > 0 ? *(pwr_tFloat32*)p + 0.5
                                               : *(pwr_tFloat32*)p - 0.5);
    break;
  case pwr_eType_Int64:
    enum_value = (unsigned int)*(pwr_tInt64*)p;
    break;
  case pwr_eType_UInt64:
    enum_value = (unsigned int)*(pwr_tUInt64*)p;
    break;
  case pwr_eType_Int32:
    enum_value = (unsigned int)*(pwr_tInt32*)p;
    break;
  case pwr_eType_UInt32:
    enum_value = (unsigned int)*(pwr_tUInt32*)p;
    break;
  case pwr_eType_Int16:
    enum_value = (unsigned int)*(pwr_tInt16*)p;
    break;
  case pwr_eType_UInt16:
    enum_value = (unsigned int)*(pwr_tUInt16*)p;
    break;
  case pwr_eType_Int8:
    enum_value = (unsigned int)*(pwr_tInt8*)p;
    break;
  case pwr_eType_UInt8:
    enum_value = (unsigned int)*(pwr_tUInt8*)p;
    break;
  case pwr_eType_Float64:
    enum_value = (unsigned int)*(pwr_tFloat64*)p;
    break;
  default:
    return 1;
  }

  if (!update_p) {
    int found = 0;
    for (int i = 0; i < 32; i++) {
      if (items_enum[i] == enum_value) {
        grow_SetAnnotation(object, 1, items_text[i], strlen(items_text[i]));
        found = 1;
        break;
      }
    }
    if (!found)
      grow_SetAnnotation(object, 1, "", 0);
  } else {
    if ((unsigned int)enum_value < text_size) {
      int len = MIN(strlen(items_text[enum_value]), sizeof(pwr_tString80));
      grow_SetAnnotation(object, 1, items_text[enum_value], len);
    } else
      grow_SetAnnotation(object, 1, "", 0);
    old_update_value = *update_p;
  }

  memcpy(&old_value, p, MIN(size, (int)sizeof(old_value)));
  return 1;
}

int GeOptionMenu::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetClickSensitivity(dyn->graph->grow->ctx, glow_mSensitivity_MB1Click);
    break;
  case glow_eEvent_MB1Up:
    break;
  case glow_eEvent_Key_Up:
    if (!menu_object)
      break;
    grow_MenuShiftCurrentItem(menu_object, -1);
    return GE__NO_PROPAGATE;
  case glow_eEvent_Key_Down:
    if (!menu_object) {
      // Create a menu by triggering a click event
      glow_sEvent e;

      e.event = glow_eEvent_MB1Click;
      e.object.object = object, dyn->action(object, &e);
      return GE__NO_PROPAGATE;
    }
    grow_MenuShiftCurrentItem(menu_object, 1);
    return GE__NO_PROPAGATE;
  case glow_eEvent_Key_Return:
    if (!menu_object) {
      // Open menu, simulate a MB1 click event
      glow_sEvent e;
      e.event = glow_eEvent_MB1Click;
      e.object.object = object;
      action(object, &e);
    } else {
      // Activate current item, simulate an activated event
      int sts;
      glow_sEvent e;

      e.event = glow_eEvent_MenuActivated;
      e.menu.object = menu_object;

      sts = grow_MenuGetCurrentItem(menu_object, &e.menu.item);
      if (EVEN(sts))
        break;

      action(object, &e);

      // Close
      grow_DeleteObject(dyn->graph->grow->ctx, menu_object);
      menu_object = 0;

      // Trigger a tab event
      e.event = glow_eEvent_Key_Tab;
      e.object.object = object, dyn->action(object, &e);
    }
    break;
  case glow_eEvent_InputFocusGained:
    if (menu_object)
      break;
    time_GetTime(&focus_gained_time);
    break;
  case glow_eEvent_MB1Click:
    // if ( event->event == glow_eEvent_MB1Click) {
    //  pwr_tTime now;
    //  time_GetTime( &now);
    //  if ( ABS(now.tv_sec - focus_gained_time.tv_sec) < 2)
    //	break;
    //}
    if (menu_object) {
      // Close, delete this menu
      grow_DeleteObject(dyn->graph->grow->ctx, menu_object);
      menu_object = 0;
    } else {
      double ll_x, ll_y, ur_x, ur_y;
      glow_sMenuInfo info;

      if (!update_p) {
        int b_mask = 1;
        for (int i = 0; i < 32; i++) {
          if (b_mask & button_mask) {
            info.item[i].occupied = true;
            strcpy(info.item[i].text, items_text[i]);

            // Check access
            info.item[i].type = glow_eMenuItem_Button;
          } else
            info.item[i].occupied = false;
          b_mask = b_mask << 1;
        }
      } else {
        for (unsigned int i = 0; i < 32; i++) {
          if (i < text_size) {
            strncpy(
                info.item[i].text, items_text[i], sizeof(info.item[0].text));
            info.item[i].type = glow_eMenuItem_Button;
            info.item[i].occupied = true;
          } else
            info.item[i].occupied = false;
        }
      }

      // Get fillcolor, and textattributes from object
      glow_eDrawType text_drawtype, text_color, bg_color;
      int tsize;
      int sts;
      double scale;
      glow_eFont text_font;
      glow_eAnnotType annot_type;

      sts = grow_GetObjectAnnotInfo(object, 1, &tsize, &text_drawtype,
          &text_color, &bg_color, &scale, &text_font, &annot_type);
      if (EVEN(sts)) {
        tsize = 2;
        text_drawtype = glow_eDrawType_TextHelveticaBold;
        text_color = glow_eDrawType_Line;
        bg_color = glow_eDrawType_LightGray;
      } else if (bg_color == glow_eDrawType_No
          || bg_color == glow_eDrawType_Inherit)
        bg_color = glow_eDrawType_LightGray;

      grow_MeasureNode(object, &ll_x, &ll_y, &ur_x, &ur_y);
      grow_CreateGrowMenu(dyn->graph->grow->ctx, "__Menu", &info, ll_x, ur_y,
          ur_x - ll_x, glow_eDrawType_Line, 0, 1, 1, bg_color, tsize,
          text_drawtype, text_color, glow_eDrawType_MediumGray, text_font, 0,
          &menu_object);
      grow_SetObjectScale(
          menu_object, scale, scale, 0, 0, glow_eScaleType_LowerLeft);
    }
    break;
  case glow_eEvent_MenuActivated:
    if (menu_object == 0)
      break;
    if (event->menu.object == menu_object) {
      // Set enum value to attribute
      int sts = 0;
      pwr_tAName parsed_name;
      int inverted;
      int attr_type, attr_size;

      dyn->parse_attr_name(
          attribute, parsed_name, &inverted, &attr_type, &attr_size);
      if (parsed_name[0] == '&')
	// Attribute starting with '&' indicates reference
	dyn->graph->get_reference_name(parsed_name, parsed_name);

      switch (db) {
      case graph_eDatabase_Gdh:
        switch (type_id) {
        case pwr_eType_Float32: {
          pwr_tFloat32 value = items_enum[event->menu.item];
          sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
          break;
        }
        case pwr_eType_Int32: {
          pwr_tInt32 value = items_enum[event->menu.item];
          sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
          break;
        }
        case pwr_eType_UInt32: {
          pwr_tUInt32 value = items_enum[event->menu.item];
          sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
          break;
        }
        case pwr_eType_Int16: {
          pwr_tInt16 value = items_enum[event->menu.item];
          sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
          break;
        }
        case pwr_eType_UInt16: {
          pwr_tUInt16 value = items_enum[event->menu.item];
          sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
          break;
        }
        case pwr_eType_Int8: {
          pwr_tInt8 value = items_enum[event->menu.item];
          sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
          break;
        }
        case pwr_eType_UInt8: {
          pwr_tUInt8 value = items_enum[event->menu.item];
          sts = gdh_SetObjectInfo(parsed_name, &value, sizeof(value));
          break;
        }
        default:
          sts = 0;
        }
        break;
      case graph_eDatabase_Ccm: {
        pwr_tInt32 value = items_enum[event->menu.item];
        sts = dyn->graph->ccm_set_variable(parsed_name, type_id, &value);
        break;
      }
      default:;
      }

      if (EVEN(sts))
        printf("Option menu error: %s\n", attribute);
    }
    break;
  case glow_eEvent_MenuCreate:
    break;
  case glow_eEvent_InputFocusLost: {
    // Delete this menu
    grow_DeleteObject(dyn->graph->grow->ctx, menu_object);
    menu_object = 0;
    break;
  }
  case glow_eEvent_MenuDelete:
    if (menu_object == 0)
      break;
    if (event->menu.object == 0 || event->menu.object == menu_object) {
      // Delete this menu
      grow_DeleteObject(dyn->graph->grow->ctx, menu_object);
      menu_object = 0;
    }
    break;
  default:;
  }
  return 1;
}

int GeOptionMenu::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynOptionMenu(" << var_name << ".dd, \"" << attribute
     << "\", new String[] {\n"
     << "        ";
  int b_mask = 1;
  for (int i = 0; i < 32; i++) {
    if (b_mask & button_mask) {
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        fp << "JopLang.transl(\"" << items_text[i] << "\")";
      else
        fp << "\"" << items_text[i] << "\"";
    } else
      fp << "null";
    if (i != 31)
      fp << ",";
    b_mask = b_mask << 1;
  }
  fp << "},\n"
     << "        new int[] {\n"
     << "        ";
  b_mask = 1;
  for (int i = 0; i < 32; i++) {
    if (b_mask & button_mask)
      fp << items_enum[i];
    else
      fp << "0";
    if (i != 31)
      fp << ",";
    b_mask = b_mask << 1;
  }
  fp << '\n' << "      })\n";
  return 1;
}

int GeOptionMenu::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Int8, pwr_eType_UInt8, pwr_eType_Int16,
    pwr_eType_UInt16, pwr_eType_Int32, pwr_eType_UInt32, pwr_eType_Int64,
    pwr_eType_UInt64, pwr_eType_Float32, pwr_eType_Float64, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Gdh, graph_eDatabase_Local,
    graph_eDatabase_User, graph_eDatabase_Ccm, graph_eDatabase__ };

  dyn->syntax_check_attribute(object, "OptionMenu.Attribute", attribute, 0,
      types, databases, error_cnt, warning_cnt);

  if (optionmenu_type == ge_eOptionMenuType_Dynamic) {
    int types2[] = { pwr_eType_String, 0 };
    int types3[] = { pwr_eType_Int32, pwr_eType_UInt32, 0 };
    int types4[] = { pwr_eType_Boolean, 0 };
    graph_eDatabase databases2[] = { graph_eDatabase_Gdh, graph_eDatabase__ };

    dyn->syntax_check_attribute(object, "OptionMenu.TextAttribute",
        text_attribute, 0, types2, databases2, error_cnt, warning_cnt);
    dyn->syntax_check_attribute(object, "OptionMenu.SizeAttribute",
        size_attribute, 0, types3, databases2, error_cnt, warning_cnt);
    dyn->syntax_check_attribute(object, "OptionMenu.UpdateAttribute",
        update_attribute, 0, types4, databases2, error_cnt, warning_cnt);
  }
  return 1;
}

void GeAnalogText::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "AnalogText.Attribute");
  attrinfo[i].value = attribute;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(attribute);

  strcpy(attrinfo[i].name, "AnalogText.TextMask");
  attrinfo[i].value = &button_mask;
  attrinfo[i].type = ge_eAttrType_InstanceMask;
  attrinfo[i++].size = sizeof(button_mask);

  int b_mask = ge_mInstance_1;
  for (int j = 0; j < 32; j++) {
    if (b_mask & button_mask) {
      sprintf(attrinfo[i].name, "AnalogText.Text%d", j + 1);
      attrinfo[i].value = items_text[j];
      attrinfo[i].type = glow_eType_String;
      attrinfo[i++].size = sizeof(items_text[0]);

      sprintf(attrinfo[i].name, "AnalogText.Enum%d", j + 1);
      attrinfo[i].value = &items_enum[j];
      attrinfo[i].type = glow_eType_Int;
      attrinfo[i++].size = sizeof(items_enum[0]);
    }
    b_mask = b_mask << 1;
  }
  dyn->display_access = true;
  *item_count = i;
}

void GeAnalogText::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "AnalogText.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeAnalogText::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeAnalogText::save(std::ofstream& fp)
{
  fp << int(ge_eSave_AnalogText) << '\n';
  fp << int(ge_eSave_AnalogText_super) << '\n';
  GeOptionMenu::save(fp);
  fp << int(ge_eSave_End) << '\n';
}

void GeAnalogText::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeAnalogText: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_AnalogText:
      break;
    case ge_eSave_AnalogText_super:
      GeOptionMenu::open(fp);
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeAnalogText:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeAnalogText::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynAnalogText(" << var_name << ".dd, \"" << attribute
     << "\", new String[] {\n"
     << "        ";
  int b_mask = 1;
  for (int i = 0; i < 32; i++) {
    if (b_mask & button_mask)
      fp << "\"" << items_text[i] << "\"";
    else
      fp << "null";
    if (i != 31)
      fp << ",";
    b_mask = b_mask << 1;
  }
  fp << "},\n"
     << "        new int[] {\n"
     << "        ";
  b_mask = 1;
  for (int i = 0; i < 32; i++) {
    if (b_mask & button_mask)
      fp << (int)items_enum[i];
    else
      fp << "0";
    if (i != 31)
      fp << ",";
    b_mask = b_mask << 1;
  }
  fp << '\n' << "      })\n";
  return 1;
}

GeSetValue::GeSetValue(GeDyn* e_dyn, ge_mInstance e_instance)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No,
          ge_mActionType1_SetValue, ge_mActionType2_No, ge_eDynPrio_SetValue)
{
  strcpy(attribute, "");
  strcpy(value, "");
  instance = e_instance;
}

GeSetValue::GeSetValue(const GeSetValue& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio)
{
  strcpy(attribute, x.attribute);
  strcpy(value, x.value);
  instance = x.instance, instance_mask = x.instance_mask;
}

void GeSetValue::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  if (instance == ge_mInstance_1) {
    strcpy(attrinfo[i].name, "SetValue.Attribute");
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    strcpy(attrinfo[i].name, "SetValue.Value");
    attrinfo[i].value = value;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(value);

    strcpy(attrinfo[i].name, "SetValue.Instances");
    attrinfo[i].value = &instance_mask;
    attrinfo[i].type = ge_eAttrType_InstanceMask;
    attrinfo[i++].size = sizeof(instance_mask);
  } else {
    // Get instance number
    int inst = 1;
    unsigned int m = instance;
    while (m > 1) {
      m = m >> 1;
      inst++;
    }

    sprintf(attrinfo[i].name, "SetValue%d.Attribute", inst);
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);

    sprintf(attrinfo[i].name, "SetValue%d.Value", inst);
    attrinfo[i].value = value;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(value);
  }

  dyn->display_access = true;
  *item_count = i;
}

void GeSetValue::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    if (instance == ge_mInstance_1)
      snprintf(msg, sizeof(msg), "SetValue.Attribute = %s", attr_name);
    else
      snprintf(msg, sizeof(msg), "SetValue%d.Attribute = %s",
          GeDyn::instance_to_number(instance), attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeSetValue::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeSetValue::save(std::ofstream& fp)
{
  fp << int(ge_eSave_SetValue) << '\n';
  fp << int(ge_eSave_SetValue_attribute) << FSPACE << attribute << '\n';
  fp << int(ge_eSave_SetValue_value) << FSPACE << value << '\n';
  fp << int(ge_eSave_SetValue_instance) << FSPACE << int(instance) << '\n';
  fp << int(ge_eSave_SetValue_instance_mask) << FSPACE << int(instance_mask)
     << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeSetValue::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeSetValue: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_SetValue:
      break;
    case ge_eSave_SetValue_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case ge_eSave_SetValue_value:
      fp.get();
      fp.getline(value, sizeof(value));
      break;
    case ge_eSave_SetValue_instance:
      fp >> tmp;
      instance = (ge_mInstance)tmp;
      break;
    case ge_eSave_SetValue_instance_mask:
      fp >> tmp;
      instance_mask = (ge_mInstance)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeSetValue:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeSetValue::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetClickSensitivity(dyn->graph->grow->ctx, glow_mSensitivity_MB1Click);
    grow_SetObjectColorInverse(object, 1);
    break;
  case glow_eEvent_MB1Up:
    grow_SetObjectColorInverse(object, 0);
    break;
  case glow_eEvent_Key_Return:
  case glow_eEvent_MB1Click: {
    int sts;
    pwr_tAName parsed_name;
    int inverted;
    int attr_type, attr_size;
    graph_eDatabase db;
    char buf[200];

    if (dyn->total_action_type1 & ge_mActionType1_Confirm)
      break;

    db = dyn->parse_attr_name(
        attribute, parsed_name, &inverted, &attr_type, &attr_size);
    if (parsed_name[0] == '&')
      // Attribute starting with '&' indicates reference
      dyn->graph->get_reference_name(parsed_name, parsed_name);

    sts = graph_attr_string_to_value(
        attr_type, value, (void*)&buf, sizeof(buf), sizeof(buf));
    if (EVEN(sts)) {
      printf("SetValue error: %s\n", attribute);
      return 1;
    }

    switch (db) {
    case graph_eDatabase_Local: {
      sts = dyn->graph->localdb_set_value(parsed_name, buf, attr_size);
      if (EVEN(sts))
        printf("SetValue error: %s\n", attribute);
      break;
    }
    case graph_eDatabase_Gdh:
      sts = gdh_SetObjectInfo(parsed_name, buf, attr_size);
      if (EVEN(sts))
        printf("SetValue error: %s\n", attribute);
      break;
    case graph_eDatabase_Ccm: {
      sts = dyn->graph->ccm_set_variable(parsed_name, attr_type, buf);
      if (EVEN(sts))
        printf("SetValue error: %s\n", attribute);
      break;
    }
    default:;
    }
    break;
  }
  default:;
  }
  return 1;
}

int GeSetValue::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  if (first)
    fp << "      ";
  else
    fp << "      ,";
  fp << "new GeDynSetValue(" << var_name << ".dd, \"" << attribute << "\",\""
     << value << "\")\n";
  return 1;
}

int GeSetValue::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int types[] = { pwr_eType_Boolean, pwr_eType_Float32, pwr_eType_Float64,
    pwr_eType_Char, pwr_eType_Int8, pwr_eType_Int16, pwr_eType_Int32,
    pwr_eType_Int64, pwr_eType_UInt8, pwr_eType_UInt16, pwr_eType_UInt32,
    pwr_eType_UInt64, pwr_eType_String, pwr_eType_Objid, pwr_eType_ClassId,
    pwr_eType_TypeId, pwr_eType_ObjectIx, pwr_eType_VolumeId,
    graph_eType_NodeId, pwr_eType_RefId, pwr_eType_AttrRef, pwr_eType_Time,
    pwr_eType_DeltaTime, pwr_eType_Enum, pwr_eType_Mask, 0 };
  graph_eDatabase databases[] = { graph_eDatabase_Local, graph_eDatabase_Gdh,
    graph_eDatabase_Ccm, graph_eDatabase__ };
  dyn->syntax_check_attribute(object, "SetValue.Attribute", attribute, 0, types,
      databases, error_cnt, warning_cnt);

  return 1;
}

GeMethodToolbar::GeMethodToolbar(GeDyn* e_dyn, ge_mInstance e_instance)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No,
          ge_mActionType1_MethodToolbar, ge_mActionType2_No,
          ge_eDynPrio_MethodToolbar),
      toolbar_type(ge_eMethodToolbarType_Object)
{
  strcpy(method_object, "");
  instance = e_instance;
}

GeMethodToolbar::GeMethodToolbar(const GeMethodToolbar& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      toolbar_type(x.toolbar_type)
{
  strcpy(method_object, x.method_object);
  instance = x.instance, instance_mask = x.instance_mask;
}

void GeMethodToolbar::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "MethodToolbar.Object");
  attrinfo[i].value = method_object;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(method_object);

  strcpy(attrinfo[i].name, "MethodToolbar.ToolbarType");
  attrinfo[i].value = &toolbar_type;
  attrinfo[i].type = ge_eAttrType_MethodToolbarType;
  attrinfo[i++].size = sizeof(toolbar_type);

  dyn->display_access = true;
  *item_count = i;
}

void GeMethodToolbar::set_attribute(
    grow_tObject object, const char* attr_name, int* cnt)
{
  (*cnt)--;
  if (*cnt == 0) {
    char msg[200];

    strncpy(method_object, attr_name, sizeof(method_object));
    snprintf(msg, sizeof(msg), "MethodToolbar.Object = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dyn->graph->message('I', msg);
  }
}

void GeMethodToolbar::replace_attribute(
    char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(
      method_object, sizeof(method_object), from, to, cnt, strict);
}

void GeMethodToolbar::save(std::ofstream& fp)
{
  fp << int(ge_eSave_MethodToolbar) << '\n';
  fp << int(ge_eSave_MethodToolbar_method_object) << FSPACE << method_object
     << '\n';
  fp << int(ge_eSave_MethodToolbar_toolbar_type) << FSPACE << (int)toolbar_type
     << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeMethodToolbar::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeMethodToolbar: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_MethodToolbar:
      break;
    case ge_eSave_MethodToolbar_method_object:
      fp.get();
      fp.getline(method_object, sizeof(method_object));
      break;
    case ge_eSave_MethodToolbar_toolbar_type:
      fp >> tmp;
      toolbar_type = (ge_eMethodToolbarType)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeMethodToolbar:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

static int methods_command_cb(char* command, void* udata)
{
  GeDyn* dyn = (GeDyn*)udata;
  pwr_tCmd cmd;

  dyn->graph->get_command(command, cmd, dyn);
  return (dyn->graph->command_cb)(dyn->graph->parent_ctx, cmd, 0);
}

int GeMethodToolbar::connect(
    grow_tObject object, glow_sTraceData* trace_data, bool now)
{
  int sts;
  pwr_tAName parsed_name;
  int inverted;
  int attr_type, attr_size;
  graph_eDatabase db;
  pwr_sClass_XttMethodsMask xm_mask;
  int mask_store = 0;

  db = dyn->parse_attr_name(
      method_object, parsed_name, &inverted, &attr_type, &attr_size);

  sts = GeMethods::get_xm_mask(
      0, parsed_name, &xm_mask, &mask_store, methods_command_cb, dyn);

  unsigned int opmask = xm_mask.OpMethods;
  unsigned int mntmask = xm_mask.MntMethods;
  unsigned int insensitive_opmask = 0;
  unsigned int insensitive_mntmask = 0;

  opmask &= ~pwr_mXttOpMethodsMask_OpenObjectGraph;
  if (!dyn->graph->is_authorized(
          pwr_mAccess_RtEventsBlock | pwr_mAccess_System))
    insensitive_opmask |= pwr_mXttOpMethodsMask_BlockEvents;
  if (!dyn->graph->is_authorized(pwr_mAccess_AllOperators | pwr_mAccess_System
          | pwr_mAccess_RtWrite | pwr_mAccess_Maintenance | pwr_mAccess_Process
          | pwr_mAccess_Instrument))
    insensitive_opmask |= pwr_mXttOpMethodsMask_Note;
  if (!dyn->graph->is_authorized(pwr_mAccess_RtNavigator | pwr_mAccess_System))
    insensitive_mntmask |= pwr_mXttMntMethodsMask_RtNavigator;
  if (!dyn->graph->is_authorized(pwr_mAccess_RtPlc | pwr_mAccess_System))
    insensitive_mntmask |= pwr_mXttMntMethodsMask_OpenTrace;

  if (toolbar_type == ge_eMethodToolbarType_Simulate)
    opmask = 0;

  grow_ToolbarConfigure(object, (char*)GeMethods::op_subgraph,
      (char*)GeMethods::mnt_subgraph, GeMethods::opmeth_size,
      GeMethods::mntmeth_size, opmask, mntmask, insensitive_opmask,
      insensitive_mntmask);

  if (mask_store) {
    strcat(parsed_name, ".XttMethodsMask");
    sts = gdh_SetObjectInfo(parsed_name, &xm_mask, sizeof(xm_mask));
    if (EVEN(sts))
      printf("Set mask error %s\n", parsed_name);
  }

  return 1;
}

int GeMethodToolbar::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    break;
  case glow_eEvent_MB1Up:
    break;
  case glow_eEvent_TipText: {
    pwr_tString80 text;
    int sts;

    if (event->toolbar.category == 1) {
      sts = 0;
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        sts = Lng::translate(GeMethods::op_tooltip[event->toolbar.idx], text);
      if (EVEN(sts))
        strcpy(text, GeMethods::op_tooltip[event->toolbar.idx]);
    } else {
      sts = 0;
      if (grow_GetTranslate(dyn->graph->grow->ctx))
        sts = Lng::translate(GeMethods::mnt_tooltip[event->toolbar.idx], text);
      if (EVEN(sts))
        strcpy(text, GeMethods::mnt_tooltip[event->toolbar.idx]);
    }
    grow_SetTipText(dyn->graph->grow->ctx, event->toolbar.object, text,
        event->any.x_pixel, event->any.y_pixel);

    break;
  }
  case glow_eEvent_Key_Return:
  case glow_eEvent_MB1Click: {
    int sts;
    pwr_tCmd cmd;
    char command[512];

    if (event->toolbar.category == 1) {
      sprintf(command, "call method/function=\"%s\"/object=%s",
          GeMethods::op_method[event->toolbar.idx], method_object);
    } else {
      sprintf(command, "call method/function=\"%s\"/object=%s",
          GeMethods::mnt_method[event->toolbar.idx], method_object);
    }

    dyn->graph->get_command(command, cmd, dyn);
    sts = (dyn->graph->command_cb)(dyn->graph->parent_ctx, cmd, 0);

    break;
  }
  default:;
  }
  return 1;
}

int GeMethodToolbar::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  return 1;
}

int GeMethodToolbar::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int sts;
  pwr_eType a_type;

  if (streq(method_object, "")) {
    dyn->graph->syntax_msg('E', object, "MethodToolbar.Object is missing");
    (*warning_cnt)++;
  } else {
    sts = dyn->graph->check_ldh_object(method_object, &a_type);
    if (EVEN(sts)) {
      char msg[440];
      sprintf(msg, "MethodToolbar.Object \"%s\" not found", method_object);
      dyn->graph->syntax_msg('W', object, msg);
      (*warning_cnt)++;
    }
  }
  return 1;
}

GeMethodPulldownMenu::GeMethodPulldownMenu(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No,
          ge_mActionType1_MethodPulldownMenu, ge_mActionType2_No,
          ge_eDynPrio_MethodPulldownMenu),
      menu_type(ge_eMethodsMenuType_Object), menu_object(0)
{
  strcpy(method_object, "");
}

GeMethodPulldownMenu::GeMethodPulldownMenu(const GeMethodPulldownMenu& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      menu_type(x.menu_type), menu_object(0)
{
  strcpy(method_object, x.method_object);
  instance = x.instance, instance_mask = x.instance_mask;
}

void GeMethodPulldownMenu::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "MethodPulldownMenu.Object");
  attrinfo[i].value = method_object;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(method_object);

  strcpy(attrinfo[i].name, "MethodPulldownMenu.MenuType");
  attrinfo[i].value = &menu_type;
  attrinfo[i].type = ge_eAttrType_MethodsMenuType;
  attrinfo[i++].size = sizeof(menu_type);

  dyn->display_access = true;
  *item_count = i;
}

void GeMethodPulldownMenu::save(std::ofstream& fp)
{
  fp << int(ge_eSave_MethodPulldownMenu) << '\n';
  fp << int(ge_eSave_MethodPulldownMenu_method_object) << FSPACE
     << method_object << '\n';
  fp << int(ge_eSave_MethodPulldownMenu_menu_type) << FSPACE << menu_type
     << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeMethodPulldownMenu::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeMethodPulldownMenu: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_MethodPulldownMenu:
      break;
    case ge_eSave_MethodPulldownMenu_method_object:
      fp.get();
      fp.getline(method_object, sizeof(method_object));
      break;
    case ge_eSave_MethodPulldownMenu_menu_type:
      fp >> tmp;
      menu_type = (ge_eMethodsMenuType)tmp;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeMethodPulldownMenu:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeMethodPulldownMenu::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetClickSensitivity(dyn->graph->grow->ctx, glow_mSensitivity_MB1Click);
    break;
  case glow_eEvent_MB1Up:
    break;
  case glow_eEvent_Key_Up:
    if (!menu_object)
      break;
    if (grow_GetMenuInputFocus(menu_object)) {
      grow_MenuShiftCurrentItem(menu_object, -1);
      return GE__NO_PROPAGATE;
    }
    break;
  case glow_eEvent_Key_Down:
    if (!menu_object)
      break;
    if (grow_GetMenuInputFocus(menu_object)) {
      grow_MenuShiftCurrentItem(menu_object, 1);
      return GE__NO_PROPAGATE;
    }
    break;
  case glow_eEvent_Key_Right:
    if (!menu_object)
      break;

    if (grow_GetMenuInputFocus(menu_object)) {
    } else {
    }
    break;
  case glow_eEvent_Key_Left:
    break;
  case glow_eEvent_Key_Return:
    if (!menu_object)
      break;

    if (grow_GetMenuInputFocus(menu_object)) {
      // Send menu activated event
      int sts;
      glow_sEvent e;
      e.event = glow_eEvent_MenuActivated;
      e.menu.object = menu_object;
      sts = grow_MenuGetCurrentItem(menu_object, &e.menu.item);
      if (EVEN(sts))
        break;

      action(object, &e);

      // Close any open menu
      Graph* graph = dyn->graph;
      grow_tObject* objectlist;
      int object_cnt, cnt;
      int i;

      e.event = glow_eEvent_MenuDelete;
      e.any.type = glow_eEventType_Menu;
      e.menu.object = 0;

      grow_GetObjectList(graph->grow->ctx, &objectlist, &object_cnt);
      for (i = 0; i < object_cnt; i++) {
        if (grow_GetObjectType(objectlist[i]) == glow_eObjectType_GrowNode
            || grow_GetObjectType(objectlist[i])
                == glow_eObjectType_GrowGroup) {
          grow_GetUserData(objectlist[i], (void**)&dyn);
          dyn->action(objectlist[i], &e);
          grow_GetObjectList(graph->grow->ctx, &objectlist, &cnt);
          if (cnt != object_cnt)
            // Something is deleted
            break;
        }
      }
      return GE__NO_PROPAGATE;
    }
    break;

  case glow_eEvent_InputFocusGained:
    if (menu_object)
      break;
    time_GetTime(&focus_gained_time);
  case glow_eEvent_MB1Click:
    if (event->event == glow_eEvent_MB1Click) {
      pwr_tTime now;
      time_GetTime(&now);
      if (ABS((int)(now.tv_sec - focus_gained_time.tv_sec)) < 2)
        break;
    }
    if (menu_object) {
      // Close, delete this menu
      grow_DeleteObject(dyn->graph->grow->ctx, menu_object);
      menu_object = 0;
    } else if (object) {
      double ll_x, ll_y, ur_x, ur_y;
      glow_sMenuInfo info;

      int sts;
      pwr_tAName parsed_name, xm_name;
      int inverted;
      int attr_type, attr_size;
      graph_eDatabase db;
      pwr_sClass_XttMethodsMask xm_mask;
      int mask_store = 0;

      db = dyn->parse_attr_name(
          method_object, parsed_name, &inverted, &attr_type, &attr_size);

      sts = GeMethods::get_xm_mask(
          0, parsed_name, &xm_mask, &mask_store, methods_command_cb, dyn);

      strcpy(xm_name, parsed_name);
      strcat(xm_name, ".XttMethodsMask");

      opmask = xm_mask.OpMethods;
      mntmask = xm_mask.MntMethods;
      unsigned int insensitive_opmask = 0;
      unsigned int insensitive_mntmask = 0;

      opmask &= ~pwr_mXttOpMethodsMask_OpenObjectGraph;
      if (!dyn->graph->is_authorized(
              pwr_mAccess_RtEventsBlock | pwr_mAccess_System))
        insensitive_opmask |= pwr_mXttOpMethodsMask_BlockEvents;
      if (!dyn->graph->is_authorized(pwr_mAccess_AllOperators
              | pwr_mAccess_System | pwr_mAccess_RtWrite
              | pwr_mAccess_Maintenance | pwr_mAccess_Process
              | pwr_mAccess_Instrument))
        insensitive_opmask |= pwr_mXttOpMethodsMask_Note;
      if (!dyn->graph->is_authorized(
              pwr_mAccess_RtNavigator | pwr_mAccess_System))
        insensitive_mntmask |= pwr_mXttMntMethodsMask_RtNavigator;
      if (!dyn->graph->is_authorized(pwr_mAccess_RtPlc | pwr_mAccess_System))
        insensitive_mntmask |= pwr_mXttMntMethodsMask_OpenTrace;

      int menu_idx = 0;
      for (int i = 0; i < (int)(sizeof(info.item) / sizeof(info.item[0])); i++)
        info.item[i].occupied = false;

      for (int i = 0; i < GeMethods::opmeth_size; i++) {
        if (menu_idx >= (int)(sizeof(info.item) / sizeof(info.item[0])))
          break;

        if (streq(GeMethods::op_name[i], ""))
          continue;

        if (menu_type == ge_eMethodsMenuType_Help
            && !(GeMethods::op_helpmask & (1 << i)))
          continue;
        if (menu_type == ge_eMethodsMenuType_Simulate)
          continue;

        if (opmask & (1 << i)) {
          info.item[menu_idx].type = glow_eMenuItem_Button;
          sts = 0;
          if (grow_GetTranslate(dyn->graph->grow->ctx))
            sts = Lng::translate(
                GeMethods::op_name[i], info.item[menu_idx].text);
          if (EVEN(sts))
            strcpy(info.item[menu_idx].text, GeMethods::op_name[i]);
          info.item[menu_idx].occupied = true;
          if (insensitive_opmask & (1 << i))
            info.item[menu_idx].type = glow_eMenuItem_ButtonDisabled;
          menu_idx++;
        }
      }
      for (int i = 0; i < GeMethods::mntmeth_size; i++) {
        if (menu_idx >= (int)(sizeof(info.item) / sizeof(info.item[0])))
          break;

        if (streq(GeMethods::mnt_name[i], ""))
          continue;

        if (menu_type == ge_eMethodsMenuType_Help
            && !(GeMethods::mnt_helpmask & (1 << i)))
          continue;

        if (mntmask & (1 << i)) {
          info.item[menu_idx].type = glow_eMenuItem_Button;
          sts = 0;
          if (grow_GetTranslate(dyn->graph->grow->ctx))
            sts = Lng::translate(
                GeMethods::mnt_name[i], info.item[menu_idx].text);
          if (EVEN(sts))
            strcpy(info.item[menu_idx].text, GeMethods::mnt_name[i]);
          info.item[menu_idx].occupied = true;
          if (insensitive_mntmask & (1 << i))
            info.item[menu_idx].type = glow_eMenuItem_ButtonDisabled;
          menu_idx++;
        }
      }

      // Get fillcolor, and textattributes from object
      glow_eDrawType text_drawtype, text_color, bg_color;
      int text_size;
      double scale;
      glow_eFont text_font;
      glow_eAnnotType annot_type;

      sts = grow_GetObjectAnnotInfo(object, 1, &text_size, &text_drawtype,
          &text_color, &bg_color, &scale, &text_font, &annot_type);
      if (EVEN(sts)) {
        text_size = 2;
        text_drawtype = glow_eDrawType_TextHelveticaBold;
        text_font = glow_eFont_Helvetica;
        text_color = glow_eDrawType_Line;
        bg_color = glow_eDrawType_LightGray;
      } else if (bg_color == glow_eDrawType_No
          || bg_color == glow_eDrawType_Inherit)
        bg_color = glow_eDrawType_LightGray;

      grow_MeasureNode(object, &ll_x, &ll_y, &ur_x, &ur_y);
      grow_CreateGrowMenu(dyn->graph->grow->ctx, "__Menu", &info, ll_x, ur_y,
          ur_x - ll_x, glow_eDrawType_Line, 0, 1, 1, bg_color, text_size,
          text_drawtype, text_color, glow_eDrawType_MediumGray, text_font, 0,
          &menu_object);
      grow_SetObjectScale(
          menu_object, scale, scale, 0, 0, glow_eScaleType_LowerLeft);
      grow_SetMenuInputFocus(menu_object, 1);

      if (mask_store) {
        sts = gdh_SetObjectInfo(xm_name, &xm_mask, sizeof(xm_mask));
        if (EVEN(sts))
          printf("Set mask error %s\n", parsed_name);
      }
    }
    break;
  case glow_eEvent_MenuActivated: {
    if (!menu_object)
      break;

    int sts;
    pwr_tCmd cmd;
    char command[512];
    int idx = 0;
    int found = 0;

    for (int i = 0; i < GeMethods::opmeth_size; i++) {
      if (menu_type == ge_eMethodsMenuType_Help
          && !(GeMethods::op_helpmask & (1 << i)))
        continue;
      if (menu_type == ge_eMethodsMenuType_Simulate)
        continue;

      if (opmask & (1 << i))
        idx++;
      if (event->menu.item + 1 == idx) {
        sprintf(command, "call method/function=\"%s\"/object=%s",
            GeMethods::op_method[i], method_object);
        dyn->graph->get_command(command, cmd, dyn);
        sts = (dyn->graph->command_cb)(dyn->graph->parent_ctx, cmd, 0);
        found = 1;
        break;
      }
    }

    if (!found) {
      for (int i = 0; i < GeMethods::mntmeth_size; i++) {
        if (menu_type == ge_eMethodsMenuType_Help
            && !(GeMethods::mnt_helpmask & (1 << i)))
          continue;

        if (mntmask & (1 << i))
          idx++;
        if (event->menu.item + 1 == idx) {
          sprintf(command, "call method/function=\"%s\"/object=%s",
              GeMethods::mnt_method[i], method_object);
          dyn->graph->get_command(command, cmd, dyn);
          sts = (dyn->graph->command_cb)(dyn->graph->parent_ctx, cmd, 0);
          found = 1;
          break;
        }
      }
    }

    break;
  }
  case glow_eEvent_MenuCreate:
    break;
  case glow_eEvent_InputFocusLost: {
    // Delete this and all child menues
    glow_sEvent e;
    e.event = glow_eEvent_MenuDelete;
    e.menu.object = 0;

    grow_DeleteObject(dyn->graph->grow->ctx, menu_object);
    menu_object = 0;
    break;
  }
  case glow_eEvent_MenuDelete:
    if (menu_object == 0)
      break;
    if (event->menu.object == 0) {
      // Delete this menu
      grow_DeleteObject(dyn->graph->grow->ctx, menu_object);
      menu_object = 0;
    } else {
      if (event->menu.object == menu_object) {
        // Delete this and all child menues
        event->menu.object = menu_object;

        grow_DeleteObject(dyn->graph->grow->ctx, menu_object);
        menu_object = 0;
      }
    }
    break;
  default:;
  }
  return 1;
}

int GeMethodPulldownMenu::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  return 1;
}

int GeMethodPulldownMenu::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  int sts;
  pwr_eType a_type;

  if (streq(method_object, "")) {
    dyn->graph->syntax_msg('E', object, "MethodPulldownMenu.Object is missing");
    (*warning_cnt)++;
  } else {
    sts = dyn->graph->check_ldh_object(method_object, &a_type);
    if (EVEN(sts)) {
      char msg[440];
      sprintf(msg, "MethodPulldownMenu.Object \"%s\" not found", method_object);
      dyn->graph->syntax_msg('W', object, msg);
      (*warning_cnt)++;
    }
  }
  return 1;
}

GeCatchSignal::GeCatchSignal(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No,
          ge_mActionType1_CatchSignal, ge_mActionType2_No,
          ge_eDynPrio_CatchSignal)
{
  strcpy(signal_name, "");
}

GeCatchSignal::GeCatchSignal(const GeCatchSignal& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio)
{
  strcpy(signal_name, x.signal_name);
}

void GeCatchSignal::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "CatchSignal.SignalName");
  attrinfo[i].value = signal_name;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(signal_name);

  dyn->display_access = true;
  *item_count = i;
}

void GeCatchSignal::save(std::ofstream& fp)
{
  fp << int(ge_eSave_CatchSignal) << '\n';
  fp << int(ge_eSave_CatchSignal_signal_name) << FSPACE << signal_name << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeCatchSignal::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeCatchSignal: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_CatchSignal:
      break;
    case ge_eSave_CatchSignal_signal_name:
      fp.get();
      fp.getline(signal_name, sizeof(signal_name));
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeCatchSignal:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeCatchSignal::action(grow_tObject object, glow_tEvent event)
{
  pwr_tStatus sts;

  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_Signal: {
    if (!streq(event->signal.signal_name, signal_name))
      break;

    // Emit a click event
    glow_sEvent e;
    e.event = glow_eEvent_MB1Click;
    e.object.object = object;
    sts = dyn->action(object, &e);
    if (sts == GE__NO_PROPAGATE || sts == GLOW__TERMINATED
        || sts == GLOW__SUBTERMINATED || sts == GLOW__SWAPTERMINATED)
      return sts;
    break;
  }
  default:;
  }
  return 1;
}

int GeCatchSignal::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  return 1;
}

int GeCatchSignal::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  if (streq(signal_name, "")) {
    dyn->graph->syntax_msg('E', object, "CatchSignal.SignalName is missing");
    (*warning_cnt)++;
  }
  return 1;
}

GeEmitSignal::GeEmitSignal(GeDyn* e_dyn)
    : GeDynElem(e_dyn, ge_mDynType1_No, ge_mDynType2_No,
          ge_mActionType1_EmitSignal, ge_mActionType2_No,
          ge_eDynPrio_EmitSignal),
      global(0)
{
  strcpy(signal_name, "");
}

GeEmitSignal::GeEmitSignal(const GeEmitSignal& x)
    : GeDynElem(x.dyn, x.dyn_type1, x.dyn_type2, x.action_type1, x.action_type2,
          x.prio),
      global(x.global)
{
  strcpy(signal_name, x.signal_name);
}

void GeEmitSignal::get_attributes(attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;

  strcpy(attrinfo[i].name, "EmitSignal.SignalName");
  attrinfo[i].value = signal_name;
  attrinfo[i].type = glow_eType_String;
  attrinfo[i++].size = sizeof(signal_name);
  strcpy(attrinfo[i].name, "EmitSignal.Global");
  attrinfo[i].value = &global;
  attrinfo[i].type = glow_eType_Int;
  attrinfo[i++].size = sizeof(global);

  dyn->display_access = true;
  *item_count = i;
}

void GeEmitSignal::save(std::ofstream& fp)
{
  fp << int(ge_eSave_EmitSignal) << '\n';
  fp << int(ge_eSave_EmitSignal_signal_name) << FSPACE << signal_name << '\n';
  fp << int(ge_eSave_EmitSignal_global) << FSPACE << global << '\n';
  fp << int(ge_eSave_End) << '\n';
}

void GeEmitSignal::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeEmitSignal: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case ge_eSave_EmitSignal:
      break;
    case ge_eSave_EmitSignal_signal_name:
      fp.get();
      fp.getline(signal_name, sizeof(signal_name));
      break;
    case ge_eSave_EmitSignal_global:
      fp >> global;
      break;
    case ge_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeEmitSignal:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

int GeEmitSignal::action(grow_tObject object, glow_tEvent event)
{
  if (!dyn->graph->is_authorized(dyn->access))
    return 1;

  switch (event->event) {
  case glow_eEvent_MB1Down:
    grow_SetClickSensitivity(dyn->graph->grow->ctx, glow_mSensitivity_MB1Click);
    grow_SetObjectColorInverse(object, 1);
    break;
  case glow_eEvent_MB1Up:
    grow_SetObjectColorInverse(object, 0);
    break;
  case glow_eEvent_Key_Return:
  case glow_eEvent_MB1Click: {
    if (global) {
      pwr_tCmd command, cmd;
      int sts;

      sprintf(command, "emit signal/signalname=%s", signal_name);
      dyn->graph->get_command(command, cmd, dyn);
      sts = (dyn->graph->command_cb)(dyn->graph->parent_ctx, cmd, 0);
    } else {
      dyn->graph->signal_send(signal_name);
    }
    break;
  }
  default:;
  }
  return 1;
}

int GeEmitSignal::export_java(
    grow_tObject object, std::ofstream& fp, bool first, char* var_name)
{
  return 1;
}

int GeEmitSignal::syntax_check(
    grow_tObject object, int* error_cnt, int* warning_cnt)
{
  if (streq(signal_name, "")) {
    dyn->graph->syntax_msg('E', object, "EmitSignal.SignalName is missing");
    (*warning_cnt)++;
  }
  return 1;
}
