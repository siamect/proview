/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <stdlib.h>

#include "co_ccm.h"
#include "co_cdh.h"
#include "co_dcli.h"
#include "co_msg.h"
#include "co_string.h"
#include "co_time.h"

#include "rt_gdh.h"

#include "cow_msgwindow.h"

#include "glow_msg.h"

#include "ge_dyn.h"
#include "ge_methods.h"
#include "ge_dashboard.h"
#include "ge_msg.h"

typedef struct {
  char TypeStr[20];
  pwr_eType Type;
  int Size;
} graph_sTypeStr;

static const graph_sTypeStr graph_type_table[]
    = { { "Boolean", pwr_eType_Boolean, sizeof(pwr_tBoolean) },
        { "Float32", pwr_eType_Float32, sizeof(pwr_tFloat32) },
        { "Float64", pwr_eType_Float64, sizeof(pwr_tFloat64) },
        { "Char", pwr_eType_Char, sizeof(pwr_tChar) },
        { "Int8", pwr_eType_Int8, sizeof(pwr_tInt8) },
        { "Int16", pwr_eType_Int16, sizeof(pwr_tInt16) },
        { "Int32", pwr_eType_Int32, sizeof(pwr_tInt32) },
        { "Int64", pwr_eType_Int64, sizeof(pwr_tInt64) },
        { "UInt8", pwr_eType_UInt8, sizeof(pwr_tUInt8) },
        { "UInt16", pwr_eType_UInt16, sizeof(pwr_tUInt16) },
        { "UInt32", pwr_eType_UInt32, sizeof(pwr_tUInt32) },
        { "UInt64", pwr_eType_UInt64, sizeof(pwr_tUInt64) },
        { "Objid", pwr_eType_Objid, sizeof(pwr_tObjid) },
        { "Time", pwr_eType_Time, sizeof(pwr_tTime) },
        { "DeltaTime", pwr_eType_DeltaTime, sizeof(pwr_tDeltaTime) },
        { "AttrRef", pwr_eType_AttrRef, sizeof(pwr_sAttrRef) },
        { "Status", pwr_eType_Status, sizeof(pwr_tStatus) },
        { "NetStatus", pwr_eType_NetStatus, sizeof(pwr_tNetStatus) },
        { "Enum", pwr_eType_Enum, sizeof(pwr_tEnum) },
        { "Mask", pwr_eType_Mask, sizeof(pwr_tMask) },
        { "DataRef", pwr_eType_DataRef, sizeof(pwr_tDataRef) },
        { "VolumeId", pwr_eType_VolumeId, sizeof(pwr_tVolumeId) },
        { "NodeId", (pwr_eType)graph_eType_NodeId, sizeof(pwr_tVolumeId) },
        { "Bit", (pwr_eType)graph_eType_Bit, sizeof(pwr_tBit) } };

static char null_str[] = "";

// static int graph_init_grow_cb( GrowCtx *ctx, void *client_data);
// static void graph_attr_redraw_cb( Attr *attrctx);
// static void graph_attr_close_cb( Attr *attrctx);
// static int graph_attr_set_data_cb( void *g, grow_tObject object, GeDyn
// *data);
static void graph_graphattr_redraw_cb(
    void* ctx, void* attrctx, brow_tObject o, void* info);
static void graph_graphattr_close_cb(
    void* ctx, void* attrctx, brow_tObject o, void* info, int keep);
static int graph_trace_disconnect_bc(grow_tObject object);
static int graph_trace_scan_bc(grow_tObject object, void* p);
static int graph_trace_connect_bc(
    grow_tObject object, glow_sTraceData* trace_data);
static int graph_trace_ctrl_bc(int type, void* data);
static int graph_trace_grow_cb(GlowCtx* ctx, glow_tEvent event);
// static int graph_get_subgraph_info_cb( void *g, char *name, attr_sItem
// **itemlist, int *itemlist_cnt);
// static int graph_get_dyn_info_cb( void *g, GeDyn *dyn, attr_sItem **itemlist,
// int *itemlist_cnt);
// static int graph_reconfigure_attr_cb( void *g, grow_tObject object,
// attr_sItem **itemlist, int *itemlist_cnt, void **client_data);
// static int graph_get_plant_select_cb( void *g, char *value, int size);
// static int graph_get_current_colors_cb( void *g, glow_eDrawType *fill_color,
// glow_eDrawType *border_color, glow_eDrawType *text_color);
// static int graph_get_current_color_tone_cb( void *g, glow_eDrawType
// *color_tone);
static int graph_grow_cb(GlowCtx* ctx, glow_tEvent event);
static void graph_free_dyn(grow_tObject object);

void Graph::message(pwr_tStatus sts)
{
  char msg[80];

  msg_GetMsg(sts, msg, sizeof(msg));
  message('I', msg);
}

void Graph::message(char sev, const char* text)
{
  if (message_cb)
    (message_cb)(parent_ctx, sev, text);

  if (scriptmode && !streq(text, ""))
    printf("GE-%c-Message, %s\n", sev, text);
}

//
// Create the navigator widget
//
Graph::Graph(void* xn_parent_ctx, const char* xn_name,
    const char* xn_default_path, graph_eMode graph_mode, int xn_gdh_init_done,
    const char* xn_object_name, int xn_use_default_access,
    unsigned int xn_default_access, unsigned int xn_options, int xn_color_theme,
    int xn_dashboard, void (*xn_keyboard_cb)(void*, int, int))
    : attr_list(0, NULL), parent_ctx(xn_parent_ctx), grow(0), grow_cnt(0),
      ldhses(0), journal(0), message_cb(NULL), get_current_subgraph_cb(NULL),
      close_cb(NULL), get_current_colors_cb(NULL), set_current_colors_cb(NULL),
      init_cb(NULL), cursor_motion_cb(NULL), change_text_cb(NULL),
      change_value_cb(NULL), confirm_cb(NULL), load_graph_cb(NULL),
      get_plant_select_cb(NULL), display_in_xnav_cb(NULL),
      message_dialog_cb(NULL), is_authorized_cb(NULL), traverse_focus_cb(NULL),
      set_focus_cb(NULL), get_ldhses_cb(NULL), check_ldh_object_cb(0),
      get_current_objects_cb(NULL), popup_menu_cb(NULL), call_method_cb(NULL),
      sound_cb(0), create_modal_dialog_cb(0), eventlog_cb(0),
      update_colorpalette_cb(0), keyboard_cb(xn_keyboard_cb),
      refresh_objects_cb(0), resize_cb(0), get_rtplant_select_cb(NULL), 
      linewidth(1), linetype(glow_eLineType_Solid),
      textsize(2), textbold(0), textfont(glow_eFont_Helvetica), border_color(1),
      fill_color(1), fill(0), border(1), shadow(0), grid_size_x(1),
      grid_size_y(1), con_type(glow_eConType_Routed),
      con_corner(glow_eCorner_Rounded),
      conpoint_direction(glow_eDirection_Center), current_polyline(0),
      current_slider(0), trace_started(0), gdh_init_done(xn_gdh_init_done),
      arglist_cnt(0), corner_round_amount(0.5), mode(graph_mode),
      scan_time(0.5), fast_scan_time(0.5), animation_scan_time(0.5),
      closing_down(0), current_mb1_down(0), slow_scan_cnt(0), fast_scan_cnt(0),
      displayed(0), ccm_func_registred(0), verify(0), scriptmode(0),
      current_cmd_object(0), graph_object_data(0), graph_object_scan(0),
      graph_object_close(0), local_db(0),
      use_default_access(xn_use_default_access),
      default_access(xn_default_access), keep_mode(false), subgraph_dyn(0),
      was_subgraph(0), disable_log(1), pending_borders(0),
      color_theme(xn_color_theme), syntax_instance(0), connect_now(false),
      dashboard(xn_dashboard)
{
  str_StrncpyCutOff(name, xn_name, sizeof(name), 1);
  strcpy(default_path, xn_default_path);
  memset(arglist_stack, 0, sizeof(arglist_stack));
  for (unsigned int i = 0; i < sizeof(object_name) / sizeof(object_name[0]);
       i++)
    strcpy(object_name[i], "");
  if (xn_object_name) {
    if (strchr(xn_object_name, ',') != 0)
      dcli_parse(xn_object_name, ",", "", (char*)object_name,
          sizeof(object_name) / sizeof(object_name[0]), sizeof(object_name[0]),
          0);
    else
      strcpy(object_name[0], xn_object_name);
  }
  strcpy(filename, "");
  strcpy(systemname, "");

  // Create journal file
  if (mode == graph_eMode_Development
      && !(xn_options & graph_mOption_IgnoreJournal)) {
    int sts;

    journal = new GraphJournal(this, &sts);
  }

  char color_theme_file[80];
  sprintf(color_theme_file, "pwr_colortheme%d", color_theme);
  grow_SetDefaultColorTheme(color_theme_file);
}

//
//  Destructor
//
Graph::~Graph()
{
  if (journal)
    delete journal;
}

GraphGrow::~GraphGrow()
{
}
//
//  Print
//
void Graph::print(char* filename)
{
  grow_Print(grow->ctx, filename, 0, 0, 1);
}

//
//  Export to image file
//
int Graph::export_image(char* filename)
{
  return grow_ExportImage(grow->ctx, filename);
}

//
//  Rotate
//
void Graph::rotate(double angle)
{
  journal_store(journal_eAction_AntePropertiesSelect, 0);

  grow_RotateSelectedObjects(grow->ctx, angle, glow_eRotationPoint_Center);

  journal_store(journal_eAction_PostPropertiesSelect, 0);
}

//
//  Push
//
void Graph::push_select()
{
  journal_store(journal_eAction_PushSelect, 0);

  grow_PushSelectedObjects(grow->ctx);

  refresh_objects(attr_mRefresh_Objects);
}

//
//  Pop
//
void Graph::pop_select()
{
  journal_store(journal_eAction_PopSelect, 0);

  grow_PopSelectedObjects(grow->ctx);

  refresh_objects(attr_mRefresh_Objects);
}

//! Scale selected objects.
/*! \param scalex	Scale factor in x direction. */
/*! \param scaley	Scale factor in y direction. */
void Graph::scale(double scalex, double scaley)
{
  switch (grow_GetMoveRestrictions(grow->ctx)) {
  case glow_eMoveRestriction_Horizontal:
    grow_SetSelectScale(grow->ctx, scalex, 1, glow_eScaleType_UpperLeft);
    break;
  case glow_eMoveRestriction_Vertical:
    grow_SetSelectScale(grow->ctx, 1, scaley, glow_eScaleType_UpperLeft);
    break;
  default:
    grow_SetSelectScale(grow->ctx, scalex, scaley, glow_eScaleType_UpperLeft);
  }
}

void Graph::set_move_restriction(glow_eMoveRestriction restriction)
{
  grow_SetMoveRestrictions(grow->ctx, restriction, 0, 0, NULL);
}

void Graph::set_scale_equal(int equal)
{
  grow_SetScaleEqual(grow->ctx, equal);
}

void Graph::align_select(glow_eAlignDirection direction)
{
  journal_store(journal_eAction_AntePropertiesSelect, 0);

  grow_AlignSelect(grow->ctx, direction);

  journal_store(journal_eAction_PostPropertiesSelect, 0);
}

void Graph::equidistance_select(glow_eAlignDirection direction)
{
  journal_store(journal_eAction_AntePropertiesSelect, 0);

  grow_EquiDistanceSelect(grow->ctx, direction);

  journal_store(journal_eAction_PostPropertiesSelect, 0);
}

void Graph::set_default_layout()
{
  grow_SetDefaultLayout(grow->ctx);
}

void Graph::delete_select()
{
  grow_tObject* sel_list;
  int sel_count;

  if (grow_GetPasteActive(grow->ctx))
    return;

  journal_store(journal_eAction_DeleteSelect, 0);

  grow_GetSelectList(grow->ctx, &sel_list, &sel_count);
  while (sel_count) {
    grow_DeleteObject(grow->ctx, *sel_list);
    grow_GetSelectList(grow->ctx, &sel_list, &sel_count);
  }
  grow_SetModified(grow->ctx, 1);
}

//
//  Cut
//
void Graph::cut()
{
  journal_store(journal_eAction_DeleteSelect, 0);

  grow_Cut(grow->ctx);

  refresh_objects(attr_mRefresh_Objects);
}

//
//  Copy
//
void Graph::copy()
{
  grow_Copy(grow->ctx);
}

//
//  Paste
//
void Graph::paste()
{
  grow_Paste(grow->ctx);
}

//
//  Store/Restore geometry
//
void Graph::store_geometry()
{
  grow_StoreGeometry(grow->ctx);
}
void Graph::restore_geometry()
{
  grow_RestoreGeometry(grow->ctx);
}

//
//  Get next subgraph
//
void Graph::get_next_subgraph(char* next)
{
  grow_GetNextSubgraph(grow->ctx, next);
}

//
//  Set next subgraph
//
void Graph::set_next_subgraph(const char* next)
{
  grow_SetNextSubgraph(grow->ctx, next);
}

//
//  Get name
//
void Graph::get_name(char* name)
{
  grow_GetName(grow->ctx, name);
}

//
//  Set name
//
void Graph::set_name(char* name)
{
  grow_SetName(grow->ctx, name);
  grow_SetModified(grow->ctx, 1);
}
//
//  Get java name
//
int Graph::get_java_name(char* name)
{
  return grow_GetJavaName(grow->ctx, name);
}

//
//  Set java name
//
void Graph::set_java_name(const char* name)
{
  char current_name[80];

  grow_GetJavaName(grow->ctx, current_name);
  if (!streq(current_name, name)) {
    grow_SetJavaName(grow->ctx, name);
    grow_SetModified(grow->ctx, 1);
  }
}

//
//  Is java application
//
int Graph::is_javaapplication()
{
  return grow_IsJavaApplication(grow->ctx);
}

//
//  Is java applet
//
int Graph::is_javaapplet()
{
  return grow_IsJavaApplet(grow->ctx);
}

//
//  Clear all and reset
//
void Graph::clear_all()
{
  Attr* attrctx;
  int sts;

  sts = attr_list.get_first((void**)&attrctx);
  while (sts) {
    delete attrctx;
    attr_list.remove((void*)attrctx);
    sts = attr_list.get_first((void**)&attrctx);
  }
  grow_New(grow->ctx);
}

//
//  Remove all objects
//
void Graph::delete_all()
{
  grow_DeleteAll(grow->ctx);
  grow_Redraw(grow->ctx);
}

//
//  Get filename
//
void Graph::get_filename(char* inname, char* outname)
{
  pwr_tFileName fname;

  // Add default directory
  if (!strchr(inname, ':') && !strchr(inname, '/')) {
    strcpy(fname, default_path);
    strcat(fname, inname);
  } else
    strcpy(fname, inname);
  if (dashboard)
    dcli_get_defaultfilename(fname, fname, ".pwd");
  else
    dcli_get_defaultfilename(fname, fname, ".pwg");
  dcli_translate_filename(outname, fname);
}

void Graph::get_filename(char* inname, const char* def_path, int dashboard, char* outname)
{
  pwr_tFileName fname;

  // Add default directory
  if (!strchr(inname, ':') && !strchr(inname, '/')) {
    strcpy(fname, def_path);
    strcat(fname, inname);
  } else
    strcpy(fname, inname);
  if (dashboard)
    dcli_get_defaultfilename(fname, fname, ".pwd");
  else
    dcli_get_defaultfilename(fname, fname, ".pwg");
  dcli_translate_filename(outname, fname);
}

//
//  Save
//
int Graph::save(char* filename)
{
  pwr_tFileName fname;
  int grow_version, graph_version;
  int sts;

  grow_GetVersion(grow->ctx, &grow_version, &graph_version);
  if (graph_version < 4500) {
    // Needs to be converted
    message('E', "Unable to save, graph needs conversion");
    return GE__NEEDCONV;
  }

  get_filename(filename, fname);

  sts = grow_Save(grow->ctx, fname);
  if (EVEN(sts))
    return sts;
  grow_SetModified(grow->ctx, 0);

  if (journal)
    journal->clear(fname);

  return 1;
}

//
//  Save as subgraph
//
int Graph::save_subgraph(char* filename)
{
  pwr_tFileName fname;
  int grow_version, graph_version;
  int sts;

  grow_GetVersion(grow->ctx, &grow_version, &graph_version);
  if (graph_version < 4500) {
    // Needs to be converted
    message('E', "Unable to save, graph needs conversion");
    return GE__NEEDCONV;
  }

  get_filename(filename, fname);
  sts = grow_SaveSubGraph(grow->ctx, fname);
  return sts;
}

//
//  Open
//
int Graph::open(char* filename)
{
  int sts = GE__SUCCESS;
  pwr_tFileName fname;
  int grow_version, graph_version;

  if (trace_started)
    close_trace(0);

  grow->grow_setup();

  // Set temporary language translation on class graphs
  // if ( !streq( object_name, ""))
  grow_EnableEvent(grow->ctx, glow_eEvent_Translate, glow_eEventType_CallBack,
      graph_grow_cb);

  if (!streq(object_name[0], ""))
    grow_SetOwner(grow->ctx, object_name[0]);

  if (!streq(filename, "_none_.pwg")) {
    get_filename(filename, fname);
    sts = grow_Open(grow->ctx, fname);
    if (EVEN(sts)) {
      if (is_dashboard())
	dashboard_init();
      else {
	char tmp[512];
	snprintf(tmp, sizeof(tmp), "Unable to open file \"%s\"", fname);
	message('E', tmp);	
      }
    }
  }

  grow_SetModified(grow->ctx, 0);
  strcpy(this->filename, filename);

  grow_GetVersion(grow->ctx, &grow_version, &graph_version);
  if (graph_version < 4500) {
    // Needs to be converted
    message('E', "Old version, graph needs conversion");
  }

  // Update grid
  grow_sAttributes grow_attr;
  unsigned long mask;

  mask = grow_eAttr_grid_size_x | grow_eAttr_grid_size_y | grow_eAttr_grid_on;
  grow_GetAttributes(grow->ctx, &grow_attr, mask);
  grid_size_y = grow_attr.grid_size_y;
  grid_size_x = grow_attr.grid_size_x;
  grid = grow_attr.grid_on;

  was_subgraph = is_subgraph();

  refresh_objects(attr_mRefresh_Objects);

  return sts;
}

//
//  Open subgraph
//
void Graph::open_subgraph(char* filename)
{
  pwr_tFileName fname;

  dcli_translate_filename(fname, filename);
  grow_OpenSubGraph(grow->ctx, fname);
}

//
//  Set subgraph path
//
void Graph::set_subgraph_path(int path_cnt, char* path)
{
  grow_SetPath(grow->ctx, path_cnt, path);
}

void Graph::dashboard_init()
{
  grow_sAttributes grow_attr;
  unsigned long mask;

  update_color_theme(1);
  grow_SetBackgroundColor(grow->ctx, glow_eDrawType_CustomColor1);
  mask = grow_eAttr_double_buffer_on;
  grow_attr.double_buffer_on = 1;
  grow_SetAttributes(grow->ctx, &grow_attr, mask);
}

// Called when GraphAttributes is modified
void Graph::dashboard_reconfigure()
{
  double cell_width, cell_height;
  int columns, rows;
  int width, height;
  double zoom_factor;

  grow_GetDashboardInfo(grow->ctx, &cell_width, &cell_height, &columns, &rows);

  grow_GetZoom(grow->ctx, &zoom_factor);
  width = int(cell_width * columns * zoom_factor);
  height = int(cell_height * rows * zoom_factor);

  grow_SetGraphBorders(grow->ctx, 0, 0, cell_width * columns, 
		       cell_height * rows);
  if (resize_cb)
    (resize_cb)(parent_ctx, width, height);
}

int Graph::dashboard_is_full()
{
  double x, y;
  int sts;

  sts = grow_GetDashboardNextFree(grow->ctx, 0, 0, 1, 1, &x, &y);
  return EVEN(sts) ? 1 : 0;
}

//
//  Zoom
//
void Graph::zoom(double zoom_factor)
{
  grow_Zoom(grow->ctx, zoom_factor);
}

//
//  Return to base zoom factor
//
void Graph::unzoom()
{
  grow_UnZoom(grow->ctx);
}

//
//  Return to base zoom factor
//
void Graph::set_borders(double* borders)
{
  if (grow)
    grow_SetLayout(grow->ctx, borders[0], borders[1], borders[2], borders[3]);
  else {
    pending_borders = (double*)calloc(4, sizeof(double));
    memcpy(pending_borders, borders, 4 * sizeof(double));
  }
}

//
//  Return to base zoom factor
//
void Graph::set_mode(grow_eMode mode, bool keep)
{
  if (mode == grow_eMode_EditPolyLine) {
    grow_tObject* sel_list;
    int sel_count;

    grow_GetSelectList(grow->ctx, &sel_list, &sel_count);
    if (!(sel_count == 1
            && grow_GetObjectType(*sel_list)
                == glow_eObjectType_GrowPolyLine)) {
      message('E', "Select one polyline object");
      return;
    }
  }
  grow_SetMode(grow->ctx, mode);
  keep_mode = keep;

  if (mode == grow_eMode_EditPolyLine || mode == grow_eMode_Scale) {
    journal_store(journal_eAction_AntePropertiesSelect, 0);
  }
}

void Graph::update_color_theme(int ct)
{
  char color_theme_file[80];
  int sts;

  sprintf(color_theme_file, "pwr_colortheme%d", ct);

  sts = grow_ReadCustomColorFile(grow->base_ctx(), color_theme_file);
  if (EVEN(sts))
    return;

  grow_SetDefaultColorTheme(color_theme_file);

  color_theme = ct;

  if (update_colorpalette_cb)
    (update_colorpalette_cb)(parent_ctx);
}

void Graph::flip(glow_eFlipDirection dir)
{
  journal_store(journal_eAction_AntePropertiesSelect, 0);

  grow_FlipSelectedObjects(grow->ctx, dir);

  journal_store(journal_eAction_PostPropertiesSelect, 0);
}

int Graph::get_default_size(int* width, int* height)
{
  return grow_GetDefaultWindowSize(grow->ctx, width, height);
}

int Graph::group_select(grow_tObject* object, char* last_group)
{
  grow_tObject group;
  char last_group_name[80];
  int sts;
  GeDyn* data;

  journal_store(journal_eAction_AnteGroupSelect, 0);

  sts = grow_GroupSelect(grow->ctx, &group, last_group_name);
  if (EVEN(sts))
    return sts;

  GeDyn* dyn = new GeDyn(this);
  grow_SetUserData(group, (void*)dyn);

  grow_SetModified(grow->ctx, 1);

  if (!streq(last_group_name, "")) {
    // Try to recover dynamics
    sts = recall.get(&data, last_group_name);
    if (ODD(sts)) {
      delete data;
      *object = group;
      strcpy(last_group, last_group_name);
      return GE__RECALLDATA_FOUND;
    }
  }

  refresh_objects(attr_mRefresh_Objects);

  journal_store(journal_eAction_PostGroupSelect, group);

  return 1;
}

int Graph::set_recall_data(grow_tObject object, char* name)
{
  int sts;
  GeDyn* data;

  sts = recall.get(&data, name);
  if (EVEN(sts))
    return sts;

  grow_SetUserData(object, (void*)data);
  return 1;
}

int Graph::ungroup_select(int force)
{
  grow_tObject* sel_list;
  int sel_count;
  int i;
  GeDyn* dyn;
  char name[80];
  int sts;

  if (!force) {
    grow_GetSelectList(grow->ctx, &sel_list, &sel_count);
    for (i = 0; i < sel_count; i++) {
      if (grow_GetObjectType(sel_list[i]) == glow_eObjectType_GrowGroup) {
        grow_GetUserData(sel_list[i], (void**)&dyn);
        if (dyn->get_dyntype1(sel_list[i]) || dyn->get_actiontype1(sel_list[i])
            || dyn->get_dyntype2(sel_list[i])
            || dyn->get_actiontype2(sel_list[i]))
          return GE__GROUPDYNDATA;
      }
    }
  } else {
    grow_GetSelectList(grow->ctx, &sel_list, &sel_count);
    for (i = 0; i < sel_count; i++) {
      if (grow_GetObjectType(sel_list[i]) == glow_eObjectType_GrowGroup) {
        grow_GetObjectName(sel_list[i], name, sizeof(name), glow_eName_Object);
        grow_GetUserData(sel_list[i], (void**)&dyn);
        if (dyn->get_dyntype1(sel_list[i]) || dyn->get_actiontype1(sel_list[i])
            || dyn->get_dyntype2(sel_list[i])
            || dyn->get_actiontype2(sel_list[i]))
          recall.insert(dyn, name, sel_list[i]);
      }
    }
  }
  grow_SetModified(grow->ctx, 1);

  journal_store(journal_eAction_UngroupSelect, 0);

  sts = grow_UngroupSelect(grow->ctx);

  refresh_objects(attr_mRefresh_Objects);

  return sts;
}

void Graph::set_gridsize(double gridsize)
{
  grow_sAttributes grow_attr;
  unsigned long mask;

  grid_size_x = gridsize;
  grid_size_y = gridsize;
  mask = 0;
  mask |= grow_eAttr_grid_size_x;
  grow_attr.grid_size_y = grid_size_x;
  mask |= grow_eAttr_grid_size_y;
  grow_attr.grid_size_x = grid_size_y;
  grow_SetAttributes(grow->ctx, &grow_attr, mask);
  grow_Redraw(grow->ctx);
}

void Graph::set_grid(int grid_on)
{
  grow_sAttributes grow_attr;
  unsigned long mask;

  grid = grid_on;
  mask = 0;
  mask |= grow_eAttr_grid_on;
  grow_attr.grid_on = grid_on;
  grow_SetAttributes(grow->ctx, &grow_attr, mask);
}

int Graph::get_conclass(glow_eDrawType drawtype, int linewidth,
    glow_eConType contype, glow_eCorner corner, double round_amount,
    grow_tConClass* cc)
{
  char name[80];
  int sts;
  int r_amount;

  if (corner != glow_eCorner_Rounded)
    r_amount = 0;
  else
    r_amount = int(10.0 * round_amount + 0.1);

  sprintf(name, "cc_%d_%d_%d_%d", contype, linewidth, drawtype, r_amount);

  sts = grow_FindConClassByName(grow->ctx, name, cc);
  if (EVEN(sts)) {
    // Create the conclass
    grow_CreateConClass(grow->ctx, name, contype, corner, drawtype, linewidth,
        0.4 * linewidth, 0.6 * linewidth, round_amount, glow_eConGroup_Common,
        cc);
  }
  return 1;
}

void Graph::change_text(grow_tObject object, char* text)
{
  // Check that object exist
  if (!grow_FindObject(grow->ctx, object))
    return;

  if (grow_GetObjectType(object) != glow_eObjectType_GrowText)
    return;

  journal_store(journal_eAction_AntePropertiesObject, object);

  grow_SetObjectText(object, text);
  grow_SetModified(grow->ctx, 1);

  journal_store(journal_eAction_PostPropertiesObject, object);
}

void Graph::change_name(grow_tObject object, char* name)
{
  // Check that object exist
  if (!grow_FindObject(grow->ctx, object))
    return;

  journal_store(journal_eAction_AnteRename, object);

  grow_SetObjectName(object, name);
  grow_SetModified(grow->ctx, 1);

  journal_store(journal_eAction_PostRename, object);
}

void Graph::change_select_text()
{
  grow_tObject* sel_list;
  int sel_count;
  char text[200];

  grow_GetSelectList(grow->ctx, &sel_list, &sel_count);
  if (sel_count == 1
      && grow_GetObjectType(*sel_list) == glow_eObjectType_GrowText) {
    if (change_text_cb) {
      journal_store(journal_eAction_AntePropertiesSelect, 0);

      grow_GetObjectText(*sel_list, text, sizeof(text));
      (change_text_cb)(parent_ctx, *sel_list, text);

      journal_store(journal_eAction_PostPropertiesSelect, 0);
    }
  } else
    message('E', "Select one text object");
}

void Graph::change_select_name()
{
  grow_tObject* sel_list;
  int sel_count;
  char name[80];

  grow_GetSelectList(grow->ctx, &sel_list, &sel_count);
  if (sel_count == 1) {
    if (change_name_cb) {
      grow_GetObjectName(*sel_list, name, sizeof(name), glow_eName_Object);
      (change_name_cb)(parent_ctx, *sel_list, name);
    }
  } else
    message('E', "Select one object");
}

void Graph::change_value(grow_tObject object, char* text)
{
  // Check that object exist
  if (!grow_FindObject(grow->ctx, object))
    return;

  GeDyn* dyn;

  grow_GetUserData(object, (void**)&dyn);
  if (dyn->action_type1 & ge_mActionType1_Confirm) {
    glow_sEvent event;

    event.event = glow_eEvent_MB1Click;

    // Trigger the confirm action
    dyn->total_action_type1 = ge_mActionType1(
        dyn->total_action_type1 & ~ge_mActionType1_ValueInput);
    strncpy(confirm_text, text, sizeof(confirm_text));
    dyn->action(object, &event);
    dyn->total_action_type1
        = ge_mActionType1(dyn->total_action_type1 | ge_mActionType1_ValueInput);
  } else {
    dyn->change_value(object, text);

    // Send a Key_Tab event
    glow_sEvent event;

    event.event = glow_eEvent_Key_Tab;
    event.object.object = object;
    event.object.object_type = grow_GetObjectType(object);
    dyn->action(object, &event);
  }
}

void Graph::set_select_text_color()
{
  journal_store(journal_eAction_AntePropertiesSelect, 0);

  grow_DisableHighlight(grow->ctx);
  grow_SetSelectOrigTextColor(grow->ctx, get_text_drawtype());

  journal_store(journal_eAction_PostPropertiesSelect, 0);
}

void Graph::set_select_fill_color()
{
  glow_eDrawType drawtype = get_fill_drawtype();

  journal_store(journal_eAction_AntePropertiesSelect, 0);

  grow_DisableHighlight(grow->ctx);
  grow_SetSelectOrigFillColor(grow->ctx, drawtype);

  if (grow_AnySelectIsCon(grow->ctx)) {
    grow_tConClass cc;
    int i;
    grow_tCon *conlist, *con_ptr;
    int con_cnt;
    glow_eDrawType con_drawtype;
    int con_linewidth;
    glow_eConType con_contype;
    glow_eCorner con_corner;
    double con_corner_round_amount;

    grow_GetSelectedCons(grow->ctx, &conlist, &con_cnt);
    con_ptr = conlist;
    for (i = 0; i < con_cnt; i++) {
      grow_GetConAttributes(*con_ptr, &con_drawtype, &con_linewidth,
          &con_contype, &con_corner, &con_corner_round_amount);
      get_conclass(drawtype, con_linewidth, con_contype, con_corner,
          con_corner_round_amount, &cc);
      grow_ChangeConConClass(*con_ptr, cc);
      con_ptr++;
    }
    if (con_cnt)
      free((char*)conlist);
  }
  journal_store(journal_eAction_PostPropertiesSelect, 0);
}

void Graph::set_select_border_color()
{
  glow_eDrawType drawtype = get_border_drawtype();

  journal_store(journal_eAction_AntePropertiesSelect, 0);

  grow_DisableHighlight(grow->ctx);
  grow_SetSelectOrigBorderColor(grow->ctx, drawtype);

  journal_store(journal_eAction_PostPropertiesSelect, 0);
}

void Graph::set_select_color_tone(glow_eDrawTone tone)
{
  journal_store(journal_eAction_AntePropertiesSelect, 0);

  grow_DisableHighlight(grow->ctx);
  grow_SetSelectOrigColorTone(grow->ctx, tone);
  if (tone == glow_eDrawTone_No)
    // Reset the fillcolor also
    grow_SetSelectOrigFillColor(grow->ctx, glow_eDrawType_No);

  journal_store(journal_eAction_PostPropertiesSelect, 0);
}

void Graph::set_select_background_color(glow_eDrawType color)
{
  journal_store(journal_eAction_AntePropertiesSelect, 0);

  grow_DisableHighlight(grow->ctx);
  grow_SetSelectOrigBackgroundColor(grow->ctx, color);

  journal_store(journal_eAction_PostPropertiesSelect, 0);
}

void Graph::incr_select_color_lightness(int lightness)
{
  grow_DisableHighlight(grow->ctx);
  grow_IncrSelectOrigColLightness(grow->ctx, lightness);
}

void Graph::incr_select_color_intensity(int intensity)
{
  grow_DisableHighlight(grow->ctx);
  grow_IncrSelectOrigColIntensity(grow->ctx, intensity);
}

void Graph::incr_select_color_shift(int shift)
{
  grow_DisableHighlight(grow->ctx);
  grow_IncrSelectOrigColorShift(grow->ctx, shift);
}

void Graph::set_select_linewidth(int width)
{
  linewidth = width;

  journal_store(journal_eAction_AntePropertiesSelect, 0);

  grow_DisableHighlight(grow->ctx);
  grow_SetSelectLineWidth(grow->ctx, width);

  if (grow_AnySelectIsCon(grow->ctx)) {
    grow_tConClass cc;
    int i;
    grow_tCon *conlist, *con_ptr;
    int con_cnt;
    glow_eDrawType con_drawtype;
    int con_linewidth;
    glow_eConType con_contype;
    glow_eCorner con_corner;
    double con_corner_round_amount;

    grow_GetSelectedCons(grow->ctx, &conlist, &con_cnt);
    con_ptr = conlist;
    for (i = 0; i < con_cnt; i++) {
      grow_GetConAttributes(*con_ptr, &con_drawtype, &con_linewidth,
          &con_contype, &con_corner, &con_corner_round_amount);
      get_conclass(con_drawtype, width, con_contype, con_corner,
          con_corner_round_amount, &cc);
      grow_ChangeConConClass(*con_ptr, cc);
      con_ptr++;
    }
    if (con_cnt)
      free((char*)conlist);
  }

  journal_store(journal_eAction_PostPropertiesSelect, 0);
}

void Graph::set_select_linetype(glow_eLineType type)
{
  linetype = type;

  journal_store(journal_eAction_AntePropertiesSelect, 0);

  grow_DisableHighlight(grow->ctx);
  grow_SetSelectLineType(grow->ctx, type);

  journal_store(journal_eAction_PostPropertiesSelect, 0);
}

void Graph::set_select_fill(int fill)
{
  journal_store(journal_eAction_AntePropertiesSelect, 0);

  grow_SetSelectFill(grow->ctx, fill);

  journal_store(journal_eAction_PostPropertiesSelect, 0);
}

void Graph::set_select_border(int border)
{
  journal_store(journal_eAction_AntePropertiesSelect, 0);

  grow_SetSelectBorder(grow->ctx, border);

  journal_store(journal_eAction_PostPropertiesSelect, 0);
}

void Graph::set_select_shadow(int border)
{
  journal_store(journal_eAction_AntePropertiesSelect, 0);

  grow_SetSelectShadow(grow->ctx, shadow);

  journal_store(journal_eAction_PostPropertiesSelect, 0);
}

void Graph::set_select_gradient(glow_eGradient gradient)
{
  journal_store(journal_eAction_AntePropertiesSelect, 0);

  grow_SetSelectGradient(grow->ctx, gradient);

  journal_store(journal_eAction_PostPropertiesSelect, 0);
}

void Graph::set_select_textsize(int size)
{
  int textsize = 0;

  switch (size) {
  case 0:
    textsize = 0;
    break;
  case 1:
    textsize = 1;
    break;
  case 2:
    textsize = 2;
    break;
  case 3:
    textsize = 4;
    break;
  case 4:
    textsize = 6;
    break;
  case 5:
    textsize = 8;
    break;
  }

  journal_store(journal_eAction_AntePropertiesSelect, 0);

  grow_SetSelectTextSize(grow->ctx, textsize);

  journal_store(journal_eAction_PostPropertiesSelect, 0);
}

void Graph::set_select_textbold(int bold)
{
  journal_store(journal_eAction_AntePropertiesSelect, 0);

  grow_SetSelectTextBold(grow->ctx, bold);

  journal_store(journal_eAction_PostPropertiesSelect, 0);
}

void Graph::set_select_textfont(glow_eFont font)
{
  journal_store(journal_eAction_AntePropertiesSelect, 0);

  grow_SetSelectTextFont(grow->ctx, font);

  journal_store(journal_eAction_PostPropertiesSelect, 0);
}

void Graph::set_background_color()
{
  glow_eDrawType fill_color, border_color, text_color;

  if (get_current_colors_cb) {
    (get_current_colors_cb)(
        parent_ctx, &fill_color, &border_color, &text_color);
    grow_SetBackgroundColor(grow->ctx, fill_color);
  }
}

void Graph::set_nav_background_color()
{
  glow_eDrawType color;

  grow_GetBackgroundColor(grow->ctx, &color);
  grow_SetBackgroundColor(grow->ctx, color);
}

int Graph::set_custom_color(
    glow_eDrawType color, double red, double green, double blue)
{
  return grow_SetCustomColor(grow->ctx, color, red, green, blue);
}

void* Graph::get_custom_colors()
{
  return grow_GetCustomColors(grow->ctx);
}

void Graph::set_default_background_color()
{
  grow_SetBackgroundColor(grow->ctx, glow_eDrawType_Color32);
}

void Graph::set_show_grid(int show)
{
  grow_SetShowGrid(grow->ctx, show);
}

int Graph::get_show_grid()
{
  return grow_GetShowGrid(grow->ctx);
}

glow_eDrawType Graph::get_border_drawtype()
{
  glow_eDrawType fill_color, text_color, border_color = glow_eDrawType_Line;

  if (get_current_colors_cb)
    (get_current_colors_cb)(
        parent_ctx, &fill_color, &border_color, &text_color);

  return border_color;
}

glow_eDrawType Graph::get_fill_drawtype()
{
  glow_eDrawType border_color, text_color,
      fill_color = glow_eDrawType_LightGray;

  if (get_current_colors_cb)
    (get_current_colors_cb)(
        parent_ctx, &fill_color, &border_color, &text_color);

  return fill_color;
}

glow_eDrawType Graph::get_text_drawtype()
{
  glow_eDrawType fill_color, border_color, text_color = glow_eDrawType_Line;

  if (get_current_colors_cb)
    (get_current_colors_cb)(
        parent_ctx, &fill_color, &border_color, &text_color);

  return text_color;
}

void Graph::select_clear()
{
  grow_SelectClear(grow->ctx);
}

void Graph::select_all_cons()
{
  grow_tObject *objectlist, *object_p;
  int object_cnt;
  int i;

  grow_SelectClear(grow->ctx);
  grow_GetObjectList(grow->ctx, &objectlist, &object_cnt);
  object_p = objectlist;
  for (i = 0; i < object_cnt; i++) {
    if (grow_GetObjectType(*object_p) == glow_eObjectType_Con) {
      grow_SetHighlight(*object_p, 1);
      grow_SelectInsert(grow->ctx, *object_p);
    }
    object_p++;
  }
}

void Graph::select_all_objects()
{
  grow_tObject *objectlist, *object_p;
  int object_cnt;
  int i;

  grow_SelectClear(grow->ctx);
  grow_GetObjectList(grow->ctx, &objectlist, &object_cnt);
  object_p = objectlist;
  for (i = 0; i < object_cnt; i++) {
    if (grow_GetObjectType(*object_p) != glow_eObjectType_Con) {
      grow_SetHighlight(*object_p, 1);
      grow_SelectInsert(grow->ctx, *object_p);
    }
    object_p++;
  }
  refresh_objects(attr_mRefresh_Select);
}

void Graph::select_object(grow_tObject o)
{
  grow_SelectClear(grow->ctx);
  grow_SetHighlight(o, 1);
  grow_SelectInsert(grow->ctx, o);
}

void Graph::add_select_object(grow_tObject o, int select)
{
  if (select) {
    grow_SetHighlight(o, 1);
    grow_SelectInsert(grow->ctx, o);
  } else {
    grow_SetHighlight(o, 0);
    grow_SelectRemove(grow->ctx, o);
  }
}

void Graph::select_nextobject(glow_eDirection dir)
{
  grow_tObject sel, next;
  int sts;

  sts = get_selected_object(&sel);
  if (EVEN(sts))
    sel = 0;
  else {
    if (grow_GetObjectType(sel) == glow_eObjectType_Con) {
      message('E', "Select an object");
      return;
    }
  }

  if (!sel || !grow_IsVisible(grow->ctx, sel, glow_eVisible_Partial)) {
    sts = grow_GetNextObjectPosition(grow->ctx, 0, dir, &next);
    if (EVEN(sts)) {
      message('E', "Unable to find visible object");
      return;
    }
    grow_SelectClear(grow->ctx);
    grow_SetHighlight(next, 1);
    grow_SelectInsert(grow->ctx, next);
  } else {
    sts = grow_GetNextObjectPosition(grow->ctx, sel, dir, &next);
    if (EVEN(sts)) {
      message('E', "Unable to find next object");
      return;
    }

    grow_SelectClear(grow->ctx);
    grow_SetHighlight(next, 1);
    grow_SelectInsert(grow->ctx, next);
    if (!grow_IsVisible(grow->ctx, next, glow_eVisible_Partial))
      grow_CenterObject(grow->ctx, next);
  }
  refresh_objects(attr_mRefresh_Select);
}

int Graph::get_selected_object(grow_tObject* object)
{
  grow_tObject* sel_list;
  int sel_count;

  grow_GetSelectList(grow->ctx, &sel_list, &sel_count);

  if (sel_count == 0)
    return GE__NOSELECT;

  if (grow_GetObjectType(*sel_list) == glow_eObjectType_Con)
    return GE__NOSELECT;

  if (sel_count > 1)
    return GE__MANYSELECT;

  *object = *sel_list;

  return GE__SUCCESS;
}

int Graph::is_subgraph()
{
  return grow_IsSubGraph(grow->ctx);
}

int Graph::is_authorized(unsigned int access)
{
  if (is_authorized_cb) {
    if (use_default_access && (access & pwr_mAccess_Default))
      return (is_authorized_cb)(parent_ctx, default_access);
    else
      return (is_authorized_cb)(parent_ctx, access);
  }
  return 1;
}

int Graph::get_attr_items(grow_tObject object, attr_sItem** itemlist,
    int* item_cnt, void** client_data)
{
  static attr_sItem items[200];
  int i;
  grow_sAttrInfo *grow_info = NULL, *grow_info_p;
  int grow_info_cnt = 0;

  memset(items, 0, sizeof(items));
  if (grow_GetObjectType(object) == glow_eObjectType_GrowNode
      || grow_GetObjectType(object) == glow_eObjectType_GrowGroup
      || grow_GetObjectType(object) == glow_eObjectType_GrowToolbar) {
    GeDyn* dyn;
    char* transtab;
    grow_GetUserData(object, (void**)&dyn);

    dyn->get_transtab(object, &transtab);
    if (transtab)
      grow_GetObjectAttrInfo(
          object, (char*)transtab, &grow_info, &grow_info_cnt);

    *itemlist = items;
    *item_cnt = 0;

    grow_info_p = grow_info;
    for (i = *item_cnt; i < grow_info_cnt + *item_cnt; i++) {
      items[i].value = grow_info_p->value_p;
      strcpy(items[i].name, grow_info_p->name);
      items[i].type = grow_info_p->type;
      items[i].size = grow_info_p->size;
      items[i].minlimit = 0;
      items[i].maxlimit = 0;
      items[i].noedit = grow_info_p->no_edit;
      items[i].multiline = grow_info_p->multiline;
      items[i].input_validation_cb = grow_info_p->input_validation_cb;
      items[i].validation_ctx = grow_info_p->validation_ctx;
      grow_info_p++;
    }

    *client_data = (void*)grow_info;

    *item_cnt = grow_info_cnt;
    dyn->get_attributes(object, items, item_cnt);

    return 1;

  } else if (grow_GetObjectType(object) == glow_eObjectType_GrowBar) {
    char transtab[][32] = { "MaxValue", "Bar.MaxValue", "MinValue",
      "Bar.MinValue", "BarValue", "Bar.Value", "BarColor", "Bar.BarColor",
      "BarBorderColor", "Bar.BorderColor", "BarBorderWidth", "Bar.BorderWidth",
      "Dynamic", "Dynamic", "" };
    GeDyn* dyn;

    grow_GetObjectAttrInfo(object, (char*)transtab, &grow_info, &grow_info_cnt);

    grow_GetUserData(object, (void**)&dyn);

    *item_cnt = 0;
    dyn->get_attributes(object, items, item_cnt);

    *client_data = 0;
  } else if (grow_GetObjectType(object) == glow_eObjectType_GrowBarArc) {
    char transtab[][32] = { "MaxValue", "BarArc.MaxValue", "MinValue",
      "BarArc.MinValue", "Angle1", "BarArc.Angle1", "Angle2", "BarArc.Angle2",
      "BarWidth", "BarArc.BarWidth", "BarDirection", "BarArc.Direction",
      "BarValue", "BarArc.Value", "BarColor", "BarArc.BarColor",
      "BarBorderColor", "BarArc.BorderColor", "BarBorderWidth", "BarArc.BorderWidth",
      "Dynamic", "Dynamic", "" };
    GeDyn* dyn;

    grow_GetObjectAttrInfo(object, (char*)transtab, &grow_info, &grow_info_cnt);

    grow_GetUserData(object, (void**)&dyn);

    *item_cnt = 0;
    dyn->get_attributes(object, items, item_cnt);

    *client_data = 0;
  } else if (grow_GetObjectType(object) == glow_eObjectType_GrowWindow) {
    char transtab[][32] = { "FileName", "Window.FileName", "WindowScale",
      "Window.Scale", "VerticalScrollbar", "Window.VerticalScrollbar",
      "HorizontalScrollbar", "Window.HorizontalScrollbar", "ScrollbarWidth",
      "Window.ScrollbarWidth", "ScrollbarColor", "Window.ScrollbarColor",
      "ScrollbarBgColor", "Window.ScrollbarBgColor", "Owner", "Window.Object",
      "" };
    GeDyn* dyn;

    grow_GetObjectAttrInfo(object, (char*)transtab, &grow_info, &grow_info_cnt);

    grow_GetUserData(object, (void**)&dyn);

    *item_cnt = 0;
    dyn->get_attributes(object, items, item_cnt);

    *client_data = 0;
  } else if (grow_GetObjectType(object) == glow_eObjectType_GrowTable) {
    char transtab[][32] = { "Rows", "Table.Rows", "Columns", "Table.Columns",
      "RowHeight", "Table.RowHeight", "HeaderRow", "Table.HeaderRow",
      "HeaderColumn", "Table.HeaderColumn", "HeaderRowHeight",
      "Table.HeaderRowHeight", "HeaderTextSize", "Table.HeaderTextSize",
      "HeaderTextBold", "Table.HeaderTextBold", "HeaderTextBold",
      "Table.HeaderTextBold", "HeaderTextColor", "Table.HeaderTextColor", 
      "SelectColor", "Table.SelectColor", "Options",
      "Table.Options", "VerticalScrollbar", "Table.VerticalScrollbar",
      "HorizontalScrollbar", "Table.HorizontalScrollbar", "ScrollbarWidth",
      "Table.ScrollbarWidth", "ScrollbarColor", "Table.ScrollbarColor",
      "ScrollbarBgColor", "Table.ScrollbarBgColor", "ColumnWidth1",
      "Column1.Width", "ColumnAdjustment1", "Column1.Adjustment", "HeaderText1",
      "Column1.HeaderText", "ColumnWidth2", "Column2.Width",
      "ColumnAdjustment2", "Column2.Adjustment", "HeaderText2",
      "Column2.HeaderText", "ColumnWidth3", "Column3.Width",
      "ColumnAdjustment3", "Column3.Adjustment", "HeaderText3",
      "Column3.HeaderText", "ColumnWidth4", "Column4.Width",
      "ColumnAdjustment4", "Column4.Adjustment", "HeaderText4",
      "Column4.HeaderText", "ColumnWidth5", "Column5.Width",
      "ColumnAdjustment5", "Column5.Adjustment", "HeaderText5",
      "Column5.HeaderText", "ColumnWidth6", "Column6.Width",
      "ColumnAdjustment6", "Column6.Adjustment", "HeaderText6",
      "Column6.HeaderText", "ColumnWidth7", "Column7.Width",
      "ColumnAdjustment7", "Column7.Adjustment", "HeaderText7",
      "Column7.HeaderText", "ColumnWidth8", "Column8.Width",
      "ColumnAdjustment8", "Column8.Adjustment", "HeaderText8",
      "Column8.HeaderText", "ColumnWidth9", "Column9.Width",
      "ColumnAdjustment9", "Column9.Adjustment", "HeaderText9",
      "Column9.HeaderText", "ColumnWidth10", "Column10.Width",
      "ColumnAdjustment10", "Column10.Adjustment", "HeaderText10",
      "Column10.HeaderText", "ColumnWidth11", "Column11.Width",
      "ColumnAdjustment11", "Column11.Adjustment", "HeaderText11",
      "Column11.HeaderText", "ColumnWidth12", "Column12.Width",
      "ColumnAdjustment12", "Column12.Adjustment", "HeaderText12",
      "Column12.HeaderText", "" };
    GeDyn* dyn;

    grow_GetObjectAttrInfo(object, (char*)transtab, &grow_info, &grow_info_cnt);

    grow_GetUserData(object, (void**)&dyn);

    *item_cnt = 0;
    dyn->get_attributes(object, items, item_cnt);

    *client_data = 0;
  } else if (grow_GetObjectType(object) == glow_eObjectType_GrowFolder) {
    char transtab[][32] = { "Folders", "Folder.NumberOfFolders",
      "ColorSelected", "Folder.ColorSelected", "ColorUnselected",
      "Folder.ColorUnselected", "HeaderHeight", "Folder.HeaderHeight",
      "FileName1", "Folder1.FileName", "Text1", "Folder1.Text", "Scale1",
      "Folder1.Scale", "VerticalScrollbar1", "Folder1.VerticalScrollbar",
      "HorizontalScrollbar1", "Folder1.HorizontalScrollbar", "Owner1",
      "Folder1.Object", "FileName2", "Folder2.FileName", "Text2",
      "Folder2.Text", "Scale2", "Folder2.Scale", "VerticalScrollbar2",
      "Folder2.VerticalScrollbar", "HorizontalScrollbar2",
      "Folder2.HorizontalScrollbar", "Owner2", "Folder2.Object", "FileName3",
      "Folder3.FileName", "Text3", "Folder3.Text", "Scale3", "Folder3.Scale",
      "VerticalScrollbar3", "Folder3.VerticalScrollbar", "HorizontalScrollbar3",
      "Folder3.HorizontalScrollbar", "Owner3", "Folder3.Object", "FileName4",
      "Folder4.FileName", "Text4", "Folder4.Text", "Scale4", "Folder4.Scale",
      "VerticalScrollbar4", "Folder4.VerticalScrollbar", "HorizontalScrollbar4",
      "Folder4.HorizontalScrollbar", "Owner4", "Folder4.Object", "FileName5",
      "Folder5.FileName", "Text5", "Folder5.Text", "Scale5", "Folder5.Scale",
      "VerticalScrollbar5", "Folder5.VerticalScrollbar", "HorizontalScrollbar5",
      "Folder5.HorizontalScrollbar", "Owner5", "Folder5.Object", "FileName6",
      "Folder6.FileName", "Text6", "Folder6.Text", "Scale6", "Folder6.Scale",
      "VerticalScrollbar6", "Folder6.VerticalScrollbar", "HorizontalScrollbar6",
      "Folder6.HorizontalScrollbar", "Owner6", "Folder6.Object", "FileName7",
      "Folder7.FileName", "Text7", "Folder7.Text", "Scale7", "Folder7.Scale",
      "VerticalScrollbar7", "Folder7.VerticalScrollbar", "HorizontalScrollbar7",
      "Folder7.HorizontalScrollbar", "Owner7", "Folder7.Object", "FileName8",
      "Folder8.FileName", "Text8", "Folder8.Text", "Scale8", "Folder8.Scale",
      "VerticalScrollbar8", "Folder8.VerticalScrollbar", "HorizontalScrollbar8",
      "Folder8.HorizontalScrollbar", "Owner8", "Folder8.Object", "FileName9",
      "Folder9.FileName", "Text9", "Folder9.Text", "Scale9", "Folder9.Scale",
      "VerticalScrollbar9", "Folder9.VerticalScrollbar", "HorizontalScrollbar9",
      "Folder9.HorizontalScrollbar", "Owner9", "Folder9.Object", "FileName10",
      "Folder10.FileName", "Text10", "Folder10.Text", "Scale10",
      "Folder10.Scale", "VerticalScrollbar10", "Folder10.VerticalScrollbar",
      "HorizontalScrollbar10", "Folder10.HorizontalScrollbar", "Owner10",
      "Folder10.Object", "FileName11", "Folder11.FileName", "Text11",
      "Folder11.Text", "Scale11", "Folder11.Scale", "VerticalScrollbar11",
      "Folder11.VerticalScrollbar", "HorizontalScrollbar11",
      "Folder11.HorizontalScrollbar", "Owner11", "Folder11.Object",
      "FileName12", "Folder12.FileName", "Text12", "Folder12.Text", "Scale12",
      "Folder12.Scale", "VerticalScrollbar12", "Folder12.VerticalScrollbar",
      "HorizontalScrollbar12", "Folder12.HorizontalScrollbar", "Owner12",
      "Folder12.Object", "" };
    GeDyn* dyn;

    grow_GetObjectAttrInfo(object, (char*)transtab, &grow_info, &grow_info_cnt);

    grow_GetUserData(object, (void**)&dyn);

    *item_cnt = 0;
    dyn->get_attributes(object, items, item_cnt);

    *client_data = 0;
  } else if (grow_GetObjectType(object) == glow_eObjectType_GrowTrend
      || grow_GetObjectType(object) == glow_eObjectType_GrowXYCurve) {
    GeDyn* dyn;

    grow_GetUserData(object, (void**)&dyn);

    if (dyn->dyn_type1 & ge_mDynType1_FastCurve) {
      char transtab[][32] = { "NoOfPoints", "FastCurve.NoOfPoints", "ScanTime",
        "", "CurveWidth", "FastCurve.CurveLineWidth", "FillCurve",
        "FastCurve.FillCurve", "HorizontalLines", "FastCurve.HorizontalLines",
        "VerticalLines", "FastCurve.VerticalLines", "MaxValue1",
        "FastCurve.MaxValue1", "MinValue1", "FastCurve.MinValue1",
        "CurveColor1", "FastCurve.CurveColor1", "CurveFillColor1",
        "FastCurve.CurveFillColor1", "MaxValue2", "FastCurve.MaxValue2",
        "MinValue2", "FastCurve.MinValue2", "CurveColor2",
        "FastCurve.CurveColor2", "CurveFillColor2", "FastCurve.CurveFillColor2",
	"Direction", "", "Dynamic", "", "" };
      grow_GetObjectAttrInfo(
          object, (char*)transtab, &grow_info, &grow_info_cnt);

      *item_cnt = 0;
      dyn->get_attributes(object, items, item_cnt);
    } else if (dyn->dyn_type2 & ge_mDynType2_DsTrend) {
      char transtab[][32] = { "NoOfPoints", "DsTrend.NoOfPoints", "ScanTime",
        "DsTrend.ScanTime", "CurveWidth", "DsTrend.CurveLineWidth", "FillCurve",
        "DsTrend.FillCurve", "HorizontalLines", "DsTrend.HorizontalLines",
        "VerticalLines", "DsTrend.VerticalLines", "MaxValue1",
        "DsTrend.MaxValue1", "MinValue1", "DsTrend.MinValue1",
        "CurveColor1", "DsTrend.CurveColor1", "CurveFillColor1",
        "DsTrend.CurveFillColor1", "MaxValue2", "DsTrend.MaxValue2",
        "MinValue2", "DsTrend.MinValue2", "CurveColor2",
        "DsTrend.CurveColor2", "CurveFillColor2", "DsTrend.CurveFillColor2",
	"Direction", "DsTrend.Direction", "Dynamic", "", "" };
      grow_GetObjectAttrInfo(
          object, (char*)transtab, &grow_info, &grow_info_cnt);

      *item_cnt = 0;
      dyn->get_attributes(object, items, item_cnt);
    } else if (dyn->dyn_type2 & ge_mDynType2_DsTrendCurve) {
      char transtab[][32] = { "NoOfPoints", "DsTrendCurve.NoOfPoints", "ScanTime",
        "DsTrendCurve.ScanTime", "CurveWidth", "DsTrendCurve.CurveLineWidth", "FillCurve",
        "DsTrendCurve.FillCurve", "HorizontalLines", "DsTrendCurve.HorizontalLines",
        "VerticalLines", "DsTrendCurve.VerticalLines", "MaxValue1",
        "DsTrendCurve.MaxValue1", "MinValue1", "DsTrendCurve.MinValue1",
        "CurveColor1", "DsTrendCurve.CurveColor1", "CurveFillColor1",
        "DsTrendCurve.CurveFillColor1", "MaxValue2", "DsTrendCurve.MaxValue2",
        "MinValue2", "DsTrendCurve.MinValue2", "CurveColor2",
        "DsTrendCurve.CurveColor2", "CurveFillColor2", "DsTrendCurve.CurveFillColor2",
	"Direction", "DsTrendCurve.Direction", "Dynamic", "", "" };
      grow_GetObjectAttrInfo(
          object, (char*)transtab, &grow_info, &grow_info_cnt);

      *item_cnt = 0;
      dyn->get_attributes(object, items, item_cnt);
    } else if (dyn->dyn_type1 & ge_mDynType1_XY_Curve) {
      char transtab[][32] = { "NoOfPoints", "XY_Curve.NoOfPoints", "ScanTime",
        "", "CurveWidth", "XY_Curve.CurveLineWidth", "FillCurve",
        "XY_Curve.FillCurve", "HorizontalLines", "XY_Curve.HorizontalLines",
        "VerticalLines", "XY_Curve.VerticalLines", "MaxValue1", "", "MinValue1",
        "", "CurveColor1", "", "CurveFillColor1", "", "MaxValue2", "",
        "MinValue2", "", "CurveColor2", "", "CurveFillColor2", "",
	"Direction", "",  "Dynamic",
        "", "" };
      grow_GetObjectAttrInfo(
          object, (char*)transtab, &grow_info, &grow_info_cnt);

      *item_cnt = 0;
      dyn->get_attributes(object, items, item_cnt);
    } else if (dyn->dyn_type2 & ge_mDynType2_SevHist) {
      char transtab[][32] = { "NoOfPoints", "SevHist.MaxPoints", "ScanTime",
        "", "CurveWidth", "SevHist.CurveLineWidth", "FillCurve",
        "SevHist.FillCurve", "HorizontalLines", "SevHist.HorizontalLines",
        "VerticalLines", "SevHist.VerticalLines", "MaxValue1", "SevHist.MaxValue1", 
	"MinValue1", "SevHist.MinValue1", "CurveColor1", "SevHist.CurveColor1", 
        "CurveFillColor1", "SevHist.CurveFillColor1", "MaxValue2", "SevHist.MaxValue2",
        "MinValue2", "SevHist.MinValue2", "CurveColor2", "SevHist.CurveColor2", 
	"CurveFillColor2", "SevHist.CurveFillColor2", "Direction", "SevHist.Direction",
        "Dynamic",
        "", "" };
      grow_GetObjectAttrInfo(
          object, (char*)transtab, &grow_info, &grow_info_cnt);

      *item_cnt = 0;
      dyn->get_attributes(object, items, item_cnt);
    } else {
      char transtab[][32] = { "NoOfPoints", "Trend.NoOfPoints", "ScanTime",
        "Trend.ScanTime", "CurveWidth", "Trend.CurveLineWidth", "FillCurve",
        "Trend.FillCurve", "HorizontalLines", "Trend.HorizontalLines",
        "VerticalLines", "Trend.VerticalLines", "MaxValue1", "Trend.MaxValue1",
        "MinValue1", "Trend.MinValue1", "CurveColor1", "Trend.CurveColor1",
        "CurveFillColor1", "Trend.CurveFillColor1", "MaxValue2",
        "Trend.MaxValue2", "MinValue2", "Trend.MinValue2", "CurveColor2",
        "Trend.CurveColor2", "CurveFillColor2", "Trend.CurveFillColor2",
	"Direction", "Trend.Direction", "Dynamic", "", "" };
      grow_GetObjectAttrInfo(
          object, (char*)transtab, &grow_info, &grow_info_cnt);

      *item_cnt = 0;
      dyn->get_attributes(object, items, item_cnt);
    }
    *client_data = 0;
  } else if (grow_GetObjectType(object) == glow_eObjectType_GrowAxis) {
    GeDyn* dyn;

    grow_GetUserData(object, (void**)&dyn);

    if (!dyn) {
      char transtab[][32] = { "MaxValue", "MaxValue", "MinValue", "MinValue",
        "Lines", "Lines", "LongQuotient", "LongQuotient", "ValueQuotient",
        "ValueQuotient", "Format", "Format", "Dynamic", "", "" };

      grow_GetObjectAttrInfo(
          object, (char*)transtab, &grow_info, &grow_info_cnt);
      *item_cnt = 0;
    } else {
      char transtab[][32] = { "MaxValue", "Axis.MaxValue", "MinValue",
        "Axis.MinValue", "Lines", "Axis.Lines", "LongQuotient",
        "Axis.LongQuotient", "ValueQuotient", "Axis.ValueQuotient", "Format",
        "Axis.Format", "Dynamic", "", "" };
      grow_GetObjectAttrInfo(
          object, (char*)transtab, &grow_info, &grow_info_cnt);
      *item_cnt = 0;
      dyn->get_attributes(object, items, item_cnt);
    }
  } else if (grow_GetObjectType(object) == glow_eObjectType_GrowAxisArc) {
    GeDyn* dyn;

    grow_GetUserData(object, (void**)&dyn);

    if (!dyn) {
      char transtab[][32]
          = { "Angle1", "Angle1", "Angle2", "Angle2", "LineLength",
              "LineLength", "MaxValue", "MaxValue", "MinValue", "MinValue",
              "Lines", "Lines", "LongQuotient", "LongQuotient", "ValueQuotient",
              "ValueQuotient", "Format", "Format", "Dynamic", "", "" };
      grow_GetObjectAttrInfo(
          object, (char*)transtab, &grow_info, &grow_info_cnt);
      *item_cnt = 0;
    } else {
      char transtab[][32] = { "Angle1", "Axis.Angle1", "Angle2", "Axis.Angle2",
        "LineLength", "Axis.LineLength", "MaxValue", "Axis.MaxValue",
        "MinValue", "Axis.MinValue", "Lines", "Axis.Lines", "LongQuotient",
        "Axis.LongQuotient", "ValueQuotient", "Axis.ValueQuotient", "Format",
        "Axis.Format", "Dynamic", "", "" };

      grow_GetObjectAttrInfo(
          object, (char*)transtab, &grow_info, &grow_info_cnt);
      *item_cnt = 0;
      dyn->get_attributes(object, items, item_cnt);
    }
  } else if (grow_GetObjectType(object) == glow_eObjectType_GrowPie) {
    char transtab[][32] = { "Angle1", "Pie.Angle1", "Angle2", "Pie.Angle2",
      "Sectors", "Pie.Sectors", "MinValue", "Pie.MinValue", "MaxValue",
      "Pie.MaxValue", "SectorColor1", "Pie.SectorColor1", "SectorColor2",
      "Pie.SectorColor2", "SectorColor3", "Pie.SectorColor3", "SectorColor4",
      "Pie.SectorColor4", "SectorColor5", "Pie.SectorColor5", "SectorColor6",
      "Pie.SectorColor6", "SectorColor7", "Pie.SectorColor7", "SectorColor8",
      "Pie.SectorColor8", "SectorColor9", "Pie.SectorColor9", "SectorColor10",
      "Pie.SectorColor10", "SectorColor11", "Pie.SectorColor11",
      "SectorColor12", "Pie.SectorColor12", "ShadowWidth", "Pie.ShadowWidth",
      "ShadowContrast", "Pie.ShadowContrast", "GradientContrast",
      "Pie.GradientContrast", "Gradient", "Pie.Gradient", "Relief",
      "Pie.Relief", "Dynamic", "Dynamic", "" };
    GeDyn* dyn;

    grow_GetObjectAttrInfo(object, (char*)transtab, &grow_info, &grow_info_cnt);

    grow_GetUserData(object, (void**)&dyn);

    *item_cnt = 0;
    dyn->get_attributes(object, items, item_cnt);

    *client_data = 0;
  } else if (grow_GetObjectType(object) == glow_eObjectType_GrowBarChart) {
    char transtab[][32] = { "Bars", "BarChart.Bars", "BarSegments",
      "BarChart.BarSegments", "MinValue", "BarChart.MinValue", "MaxValue",
      "BarChart.MaxValue", "SectorColor1", "BarChart.BarColor1", "BarColor2",
      "BarChart.BarColor2", "BarColor3", "BarChart.BarColor3", "BarColor4",
      "BarChart.BarColor4", "BarColor5", "BarChart.BarColor5", "BarColor6",
      "BarChart.BarColor6", "BarColor7", "BarChart.BarColor7", "BarColor8",
      "BarChart.BarColor8", "BarColor9", "BarChart.BarColor9", "BarColor10",
      "BarChart.BarColor10", "BarColor11", "BarChart.BarColor11", "BarColor12",
      "BarChart.BarColor12", "ShadowWidth", "BarChart.ShadowWidth",
      "ShadowContrast", "BarChart.ShadowContrast", "GradientContrast",
      "BarChart.GradientContrast", "Gradient", "BarChart.Gradient", "Relief",
      "BarChart.Relief", "Dynamic", "Dynamic", "" };
    GeDyn* dyn;

    grow_GetObjectAttrInfo(object, (char*)transtab, &grow_info, &grow_info_cnt);

    grow_GetUserData(object, (void**)&dyn);

    *item_cnt = 0;
    dyn->get_attributes(object, items, item_cnt);

    *client_data = 0;
  } else if (grow_GetObjectType(object) == glow_eObjectType_GrowSlider) {
    char transtab[][32] = { "SubGraph", "SubGraph", "Direction",
      "Slider.Direction", "MaxValue", "Slider.MaxValue", "MinValue",
      "Slider.MinValue", "MaxPos", "Slider.MaxPosition", "MinPos",
      "Slider.MinPosition", "Dynamic", "", "" };
    GeDyn* dyn;

    grow_GetObjectAttrInfo(object, (char*)transtab, &grow_info, &grow_info_cnt);

    grow_GetUserData(object, (void**)&dyn);

    grow_info_p = grow_info;
    *item_cnt = 0;
    for (i = *item_cnt; i < grow_info_cnt + *item_cnt; i++) {
      items[i].value = grow_info_p->value_p;
      strcpy(items[i].name, grow_info_p->name);
      items[i].type = grow_info_p->type;
      items[i].size = grow_info_p->size;
      items[i].minlimit = 0;
      items[i].maxlimit = 0;
      items[i].noedit = grow_info_p->no_edit;
      items[i].multiline = grow_info_p->multiline;
      grow_info_p++;
    }

    *item_cnt = grow_info_cnt;
    dyn->get_attributes(object, items, item_cnt);

    *itemlist = items;
    *client_data = (void*)grow_info;

    return 1;
  } else if (grow_GetObjectType(object) == glow_eObjectType_GrowDashCell) {
    GeDash* dash;

    grow_GetUserData(object, (void**)&dash);

    char transtab[][32] = { "CellRows", "Dash.CellRows", "CellColumns",
      "Dash.CellColumns", "", "" };
    GeDyn* dyn;

    grow_GetObjectAttrInfo(object, (char*)transtab, &grow_info, &grow_info_cnt);

    grow_GetUserData(object, (void**)&dyn);

    grow_info_p = grow_info;
    *item_cnt = 0;
    for (i = *item_cnt; i < grow_info_cnt + *item_cnt; i++) {
      items[i].value = grow_info_p->value_p;
      strcpy(items[i].name, grow_info_p->name);
      items[i].type = grow_info_p->type;
      items[i].size = grow_info_p->size;
      items[i].minlimit = 0;
      items[i].maxlimit = 0;
      items[i].noedit = grow_info_p->no_edit;
      items[i].multiline = grow_info_p->multiline;
      grow_info_p++;
    }

    *item_cnt = grow_info_cnt;
    dash->get_attributes(object, items, item_cnt);

    *itemlist = items;
    *client_data = (void*)grow_info;
    return 1;
  } else {
    grow_GetObjectAttrInfo(object, NULL, &grow_info, &grow_info_cnt);
    *item_cnt = 0;
  }

  grow_info_p = grow_info;
  for (i = *item_cnt; i < grow_info_cnt + *item_cnt; i++) {
    items[i].value = grow_info_p->value_p;
    strcpy(items[i].name, grow_info_p->name);
    items[i].type = grow_info_p->type;
    items[i].size = grow_info_p->size;
    items[i].minlimit = grow_info_p->minlimit;
    items[i].maxlimit = grow_info_p->maxlimit;
    items[i].noedit = grow_info_p->no_edit;
    items[i].multiline = grow_info_p->multiline;
    items[i].input_validation_cb = grow_info_p->input_validation_cb;
    items[i].validation_ctx = grow_info_p->validation_ctx;
    grow_info_p++;
  }

  *itemlist = items;
  *item_cnt += grow_info_cnt;
  *client_data = (void*)grow_info;

  return 1;
}

int Graph::edit_attributes(grow_tObject object)
{
  attr_sItem* itemlist;
  int item_cnt;
  Attr* attr;
  void* client_data;

  get_attr_items(object, &itemlist, &item_cnt, &client_data);

  attr = attr_new(this, attr_eType_Attributes, object, itemlist, item_cnt);
  attr->client_data = client_data;
  attr->close_cb = graph_attr_close_cb;
  attr->redraw_cb = graph_attr_redraw_cb;
  attr->get_subgraph_info_cb = &graph_get_subgraph_info_cb;
  attr->get_dyn_info_cb = &graph_get_dyn_info_cb;
  attr->reconfigure_attr_cb = &graph_reconfigure_attr_cb;
  attr->store_cb = &graph_attr_store_cb;
  attr->recall_cb = &graph_attr_recall_cb;
  attr->set_data_cb = &graph_attr_set_data_cb;
  attr->get_plant_select_cb = &graph_get_plant_select_cb;
  attr->get_current_colors_cb = &graph_get_current_colors_cb;
  attr->get_current_color_tone_cb = &graph_get_current_color_tone_cb;
  attr_list.insert((void*)object, (void*)attr);
  grow_SetModified(grow->ctx, 1);

  journal_store(journal_eAction_AntePropertiesObject, object);

  return 1;
}

int Graph::graph_get_plant_select_cb(void* g, char* value, int size)
{
  Graph* graph = (Graph*)g;

  if (graph->get_plant_select_cb)
    return (graph->get_plant_select_cb)(graph->parent_ctx, value, size);
  return 0;
}

int Graph::graph_get_current_colors_cb(void* g, glow_eDrawType* fill_color,
    glow_eDrawType* border_color, glow_eDrawType* text_color)
{
  Graph* graph = (Graph*)g;

  if (graph->get_current_colors_cb) {
    (graph->get_current_colors_cb)(
        graph->parent_ctx, fill_color, border_color, text_color);
    return 1;
  }
  return 0;
}

int Graph::graph_get_current_color_tone_cb(void* g, glow_eDrawType* color_tone)
{
  Graph* graph = (Graph*)g;

  if (graph->get_current_color_tone_cb) {
    (graph->get_current_color_tone_cb)(graph->parent_ctx, color_tone);
    return 1;
  }
  return 0;
}

int Graph::graph_reconfigure_attr_cb(void* g, grow_tObject object,
    attr_sItem** itemlist, int* itemlist_cnt, void** client_data)
{
  Graph* graph = (Graph*)g;

  if (object) {
    if (grow_GetObjectType(object) == glow_eObjectType_GrowDashCell) {
      grow_FreeObjectAttrInfo(*(grow_sAttrInfo**)client_data);
      return graph->get_attr_items(object, itemlist, itemlist_cnt, client_data);
    } else {
      // Object attributes
      grow_FreeObjectAttrInfo(*(grow_sAttrInfo**)client_data);
      return graph->get_attr_items(object, itemlist, itemlist_cnt, client_data);
    }
  } else {
    if (graph->was_subgraph)
      grow_FreeSubGraphAttrInfo(*(grow_sAttrInfo**)client_data);
    else
      grow_FreeGraphAttrInfo(*(grow_sAttrInfo**)client_data);

    if (graph->is_subgraph()) {
      // Subgraph attributes
      return graph->get_subgraph_attr_items(
          itemlist, itemlist_cnt, client_data);
    } else {
      // Graph attributes
      return graph->get_graph_attr_items(itemlist, itemlist_cnt, client_data);
    }
  }
}

void Graph::graph_attr_store_cb(void* g, grow_tObject object)
{
  Graph* graph = (Graph*)g;
  GeDyn* dyn;

  grow_GetUserData(object, (void**)&dyn);
  if (dyn)
    graph->recall.insert(dyn, "", object);
}

int Graph::graph_attr_recall_cb(
    void* g, grow_tObject object, int idx, GeDyn** old_dyn)
{
  Graph* graph = (Graph*)g;
  GeDyn* dyn;
  int sts;

  if (grow_GetObjectType(object) == glow_eObjectType_GrowNode
      || grow_GetObjectType(object) == glow_eObjectType_GrowSlider
      || grow_GetObjectType(object) == glow_eObjectType_GrowGroup
      || grow_GetObjectType(object) == glow_eObjectType_GrowWindow
      || grow_GetObjectType(object) == glow_eObjectType_GrowTrend
      || grow_GetObjectType(object) == glow_eObjectType_GrowXYCurve
      || grow_GetObjectType(object) == glow_eObjectType_GrowTable
      || grow_GetObjectType(object) == glow_eObjectType_GrowBar
      || grow_GetObjectType(object) == glow_eObjectType_GrowBarArc
      || grow_GetObjectType(object) == glow_eObjectType_GrowPie
      || grow_GetObjectType(object) == glow_eObjectType_GrowBarChart
      || grow_GetObjectType(object) == glow_eObjectType_GrowAxis
      || grow_GetObjectType(object) == glow_eObjectType_GrowAxisArc) {
    sts = graph->recall.get(&dyn, idx);
    if (ODD(sts)) {
      grow_GetUserData(object, (void**)old_dyn);
      grow_SetUserData(object, (void*)dyn);
    }
    return sts;
  } else
    return 0;
}

int Graph::graph_attr_set_data_cb(void* g, grow_tObject object, GeDyn* data)
{
  grow_SetUserData(object, (void*)data);
  return 1;
}

int Graph::graph_get_dyn_info_cb(
    void* g, GeDyn* dyn, attr_sItem** itemlist, int* itemlist_cnt)
{
  static attr_sItem items[100];

  memset(items, 0, sizeof(items));
  *itemlist = items;
  *itemlist_cnt = 0;

  dyn->get_attributes(0, items, itemlist_cnt);
  return 1;
}

int Graph::graph_get_subgraph_info_cb(
    void* g, char* name, attr_sItem** itemlist, int* itemlist_cnt)
{
  Graph* graph = (Graph*)g;
  static attr_sItem items[100];
  int i;
  grow_sAttrInfo *grow_info, *grow_info_p;
  int grow_info_cnt;
  int sts;
  grow_tObject object;
  int dyn_type1;
  int dyn_type2;
  int dyn_action_type1;
  int dyn_action_type2;
  int item_cnt;

  sts = grow_FindNodeClassByName(graph->grow->ctx, name, &object);
  if (EVEN(sts))
    return sts;

  grow_GetObjectAttrInfo(object, NULL, &grow_info, &grow_info_cnt);
  grow_GetNodeClassDynType(
      object, &dyn_type1, &dyn_type2, &dyn_action_type1, &dyn_action_type2);

  grow_info_p = grow_info;
  for (i = 0; i < grow_info_cnt; i++) {
    items[i].value = grow_info_p->value_p;
    strcpy(items[i].name, grow_info_p->name);
    if (grow_info_p->type == glow_eType_TraceColor) {
      if (dyn_type1 & ge_mDynType1_Tone)
        items[i].type = glow_eType_ToneOrColor;
      else
        items[i].type = glow_eType_Color;
    } else
      items[i].type = grow_info_p->type;
    items[i].size = grow_info_p->size;
    items[i].minlimit = 0;
    items[i].maxlimit = 0;
    items[i].noedit = 1;
    items[i].multiline = grow_info_p->multiline;
    grow_info_p++;
  }

  GeDyn* dyn;
  grow_GetUserData(object, (void**)&dyn);

  item_cnt = 0;
  if (dyn && dyn_type1 & ge_mDynType1_HostObject) {
    dyn->get_attributes(0, &items[grow_info_cnt], &item_cnt);

    // Add "HostObject." to hostobjects items
    for (i = grow_info_cnt; i < grow_info_cnt + item_cnt; i++) {
      char n[80];
      strcpy(n, "HostObject.");
      strcat(n, items[i].name);
      strcpy(items[i].name, n);
      items[i].noedit = 1;
    }
  }

  grow_FreeObjectAttrInfo(grow_info);

  *itemlist = items;
  *itemlist_cnt = grow_info_cnt + item_cnt;
  return 1;
}

void Graph::graph_get_object_list_cb(void* g, unsigned int type,
    grow_tObject** list, int* list_cnt, grow_tObject* parent, int parent_cnt)
{
  Graph* graph = (Graph*)g;

  if (!graph->grow) {
    *list_cnt = 0;
    return;
  }

  switch (type) {
  case attr_eList_Objects:
    grow_GetObjectList(graph->grow->ctx, list, list_cnt);
    break;
  case attr_eList_Group:
    grow_GetGroupObjectList(*parent, list, list_cnt);
    break;
  case attr_eList_Select:
    grow_GetSelectList(graph->grow->ctx, list, list_cnt);
    break;
  default:
    *list_cnt = 0;
  }
}

int Graph::get_subgraph_attr_items(
    attr_sItem** itemlist, int* item_cnt, void** client_data)
{
  static attr_sItem items[100];
  int i;
  grow_sAttrInfo *grow_info, *grow_info_p;
  int grow_info_cnt;
  int dyn_type1;
  int dyn_type2;
  int dyn_action_type1;
  int dyn_action_type2;
  char transtab[][32] = { "DynType1", "DynType1", "DynType2", "DynType2",
    "DynActionType1", "Action", "DynColor1", "Color1", "DynColor2", "Color2",
    "DynColor3", "Color3", "DynColor4", "Color4", "DynAttr1", "AnimSequence",
    "DynAttr2", "", "DynAttr3", "", "DynAttr4", "", "Dynamic", "", "" };

  grow_GetSubGraphAttrInfo(
      grow->ctx, (char*)transtab, &grow_info, &grow_info_cnt);
  grow_GetSubGraphDynType(
      grow->ctx, &dyn_type1, &dyn_type2, &dyn_action_type1, &dyn_action_type2);

  // Create dyn if change from graph to subgraph
  if (!was_subgraph) {
    subgraph_dyn = new GeDyn(0);
    was_subgraph = 1;
  }

  memset(items, 0, sizeof(items));
  *item_cnt = 0;
  if (subgraph_dyn && dyn_type1 & ge_mDynType1_HostObject) {
    subgraph_dyn->get_attributes(0, items, item_cnt);

    // Add "HostObject." to hostobjects items
    for (i = 0; i < *item_cnt; i++) {
      char n[80];
      strcpy(n, "HostObject.");
      strcat(n, items[i].name);
      strcpy(items[i].name, n);
    }
  }

  grow_info_p = grow_info;
  for (i = *item_cnt; i < grow_info_cnt + *item_cnt; i++) {
    items[i].value = grow_info_p->value_p;
    strcpy(items[i].name, grow_info_p->name);

    if (grow_info_p->type == glow_eType_TraceColor) {
      if (dyn_type1 & ge_mDynType1_Tone)
        items[i].type = glow_eType_ToneOrColor;
      else
        items[i].type = glow_eType_Color;
    } else if (grow_info_p->type == glow_eType_DynType1)
      items[i].type = ge_eAttrType_DynType1;
    else if (grow_info_p->type == glow_eType_DynType2)
      items[i].type = ge_eAttrType_DynType2;
    else if (grow_info_p->type == glow_eType_ActionType1)
      items[i].type = ge_eAttrType_ActionType1;
    else if (grow_info_p->type == glow_eType_ActionType2)
      items[i].type = ge_eAttrType_ActionType2;
    else
      items[i].type = grow_info_p->type;
    if (streq(grow_info_p->name, "AnimSequence"))
      items[i].type = ge_eAttrType_AnimSequence;
    items[i].size = grow_info_p->size;
    items[i].minlimit = 0;
    items[i].maxlimit = 0;
    items[i].noedit = 0;
    items[i].multiline = grow_info_p->multiline;
    grow_info_p++;
  }
  *itemlist = items;
  *item_cnt = i;
  *client_data = (void*)grow_info;
  return 1;
}

int Graph::edit_subgraph_attributes()
{
  attr_sItem* items;
  int item_cnt;
  void* client_data;
  Attr* attr;

  get_subgraph_attr_items(&items, &item_cnt, &client_data);
  attr = attr_new(this, attr_eType_Attributes, NULL, items, item_cnt);

  attr->client_data = client_data;
  attr->close_cb = graph_graphattr_close_cb;
  attr->redraw_cb = graph_graphattr_redraw_cb;
  attr->reconfigure_attr_cb = &graph_reconfigure_attr_cb;
  attr_list.insert(0, (void*)attr);
  grow_SetModified(grow->ctx, 1);
  was_subgraph = is_subgraph();
  return 1;
}

int Graph::get_graph_attr_items(
    attr_sItem** itemlist, int* item_cnt, void** client_data)
{
  static attr_sItem items[100];
  int i;
  grow_sAttrInfo *grow_info, *grow_info_p;
  int grow_info_cnt;

  // Delete dyn if change from subgraph to graph
  if (was_subgraph) {
    delete subgraph_dyn;
    subgraph_dyn = 0;
    was_subgraph = 0;
  }

  grow_GetGraphAttrInfo(grow->ctx, &grow_info, &grow_info_cnt);

  grow_info_p = grow_info;
  for (i = 0; i < grow_info_cnt; i++) {
    items[i].value = grow_info_p->value_p;
    strcpy(items[i].name, grow_info_p->name);
    items[i].type = grow_info_p->type;
    items[i].size = grow_info_p->size;
    items[i].minlimit = 0;
    items[i].maxlimit = 0;
    items[i].noedit = 0;
    items[i].multiline = grow_info_p->multiline;
    grow_info_p++;
  }
  *itemlist = items;
  *item_cnt = grow_info_cnt;
  *client_data = (void*)grow_info;
  return 1;
}

int Graph::edit_graph_attributes()
{
  attr_sItem* items;
  int item_cnt;
  void* client_data;
  Attr* attr;

  get_graph_attr_items(&items, &item_cnt, &client_data);
  attr = attr_new(this, attr_eType_Attributes, NULL, items, item_cnt);
  attr->client_data = client_data;
  attr->close_cb = graph_graphattr_close_cb;
  attr->redraw_cb = graph_graphattr_redraw_cb;
  attr->reconfigure_attr_cb = &graph_reconfigure_attr_cb;
  attr_list.insert(0, (void*)attr);
  grow_SetModified(grow->ctx, 1);
  was_subgraph = is_subgraph();
  return 1;
}

void Graph::reset_mode(bool select_clear, bool keep)
{
  if (grow_Mode(grow->ctx) == grow_eMode_PolyLine && current_polyline) {
    if (fill)
      grow_SetObjectFill(current_polyline, 1);
    if (shadow)
      grow_SetObjectShadow(current_polyline, 1);

    journal_store(journal_eAction_CreateObject, current_polyline);
  } else if (grow_Mode(grow->ctx) == grow_eMode_EditPolyLine
      || grow_Mode(grow->ctx) == grow_eMode_Scale) {
    journal_store(journal_eAction_PostPropertiesSelect, 0);
  }

  grow_PolylineEnd(grow->ctx);
  current_polyline = 0;
  grow_SetMode(grow->ctx, grow_eMode_Edit);
  grow_EnableHighlight(grow->ctx);
  // grow_SelectClear( grow->ctx);
  grow_SetMoveRestrictions(grow->ctx, glow_eMoveRestriction_No, 0, 0, NULL);
  grow_SetScaleEqual(grow->ctx, 0);
  keep_mode = keep;
  if (select_clear) {
    grow_SelectClear(grow->ctx);
    refresh_objects(attr_mRefresh_Select);
  }
}
//
// Callbacks from grow
//
static int graph_grow_cb(GlowCtx* ctx, glow_tEvent event)
{
  Graph* graph;

  grow_GetCtxUserData((GrowCtx*)ctx, (void**)&graph);

  if (event->event == glow_eEvent_ObjectDeleted)
    graph_free_dyn(event->object.object);

  if (!graph || graph->closing_down)
    return 1;

  if (event->event != glow_eEvent_CursorMotion)
    graph->message(' ', null_str);

  if (graph->trace_started) {
    return graph_trace_grow_cb(ctx, event);
  }

  if (event->any.type == glow_eEventType_CreateCon) {
    grow_tConClass cc;
    grow_tCon con;
    char name[80];

    if (!event->con_create.dest_object) {
      // Create a ConGlue object
      grow_tObject t1;
      double x, y;
      glow_eDirection dir;
      double margin = 1;

      // Select direction
      grow_GetNodeConPoint(event->con_create.source_object,
          event->con_create.source_conpoint, &x, &y, &dir);
      if (event->con_create.y < y + margin) {
        if (event->con_create.x > x + margin)
          event->con_create.dest_conpoint = 3;
        else if (event->con_create.x < x - margin)
          event->con_create.dest_conpoint = 1;
        else
          event->con_create.dest_conpoint = 2;
      } else {
        if (event->con_create.x > x + margin)
          event->con_create.dest_conpoint = 3;
        else if (event->con_create.x < x - margin)
          event->con_create.dest_conpoint = 1;
        else
          event->con_create.dest_conpoint = 0;
      }
      sprintf(name, "O%d", grow_IncrNextObjectNameNumber(graph->grow->ctx));
      grow_CreateGrowConGlue(graph->grow->ctx, name, event->con_create.x,
          event->con_create.y, &t1);
      event->con_create.dest_object = t1;
    }

    graph->get_conclass(graph->get_fill_drawtype(), graph->linewidth,
        graph->con_type, graph->con_corner, graph->corner_round_amount, &cc);
    sprintf(name, "C%d", grow_IncrNextObjectNameNumber(graph->grow->ctx));
    grow_CreateCon(graph->grow->ctx, "", cc, event->con_create.source_object,
        event->con_create.dest_object, event->con_create.source_conpoint,
        event->con_create.dest_conpoint, NULL, &con, 0, NULL, NULL,
        graph->border, graph->shadow);
    grow_SetModified(graph->grow->ctx, 1);
    return 1;
  }
  switch (event->event) {
  case glow_eEvent_CreateGrowObject:
    // Create some object
    switch (event->create_grow_object.mode) {
    case grow_eMode_Rect: {
      grow_tObject r1;
      char name[80];

      sprintf(name, "O%d", grow_IncrNextObjectNameNumber(graph->grow->ctx));

      grow_CreateGrowRect(graph->grow->ctx, name, event->create_grow_object.x,
          event->create_grow_object.y,
          event->create_grow_object.x2 - event->create_grow_object.x,
          event->create_grow_object.y2 - event->create_grow_object.y,
          graph->get_border_drawtype(), graph->linewidth, 0,
          glow_mDisplayLevel_1, graph->fill, graph->border, graph->shadow,
          graph->get_fill_drawtype(), NULL, &r1);
      grow_SetModified(graph->grow->ctx, 1);
      if (!graph->keep_mode)
        grow_SetMode(graph->grow->ctx, grow_eMode_Edit);

      graph->journal_store(journal_eAction_CreateObject, r1);

      break;
    }
    case grow_eMode_RectRounded: {
      grow_tObject r1;
      char name[80];

      sprintf(name, "O%d", grow_IncrNextObjectNameNumber(graph->grow->ctx));

      grow_CreateGrowRectRounded(graph->grow->ctx, name,
          event->create_grow_object.x, event->create_grow_object.y,
          event->create_grow_object.x2 - event->create_grow_object.x,
          event->create_grow_object.y2 - event->create_grow_object.y,
          graph->get_border_drawtype(), graph->linewidth, 0,
          glow_mDisplayLevel_1, graph->fill, graph->border, graph->shadow,
          graph->get_fill_drawtype(), NULL, &r1);
      grow_SetModified(graph->grow->ctx, 1);
      if (!graph->keep_mode)
        grow_SetMode(graph->grow->ctx, grow_eMode_Edit);

      graph->journal_store(journal_eAction_CreateObject, r1);

      break;
    }
    case grow_eMode_Line: {
      grow_tObject l1;
      char name[80];

      sprintf(name, "O%d", grow_IncrNextObjectNameNumber(graph->grow->ctx));

      grow_CreateGrowLine(graph->grow->ctx, name, event->create_grow_object.x,
          event->create_grow_object.y, event->create_grow_object.x2,
          event->create_grow_object.y2, graph->get_border_drawtype(),
          graph->linewidth, 0, NULL, &l1);
      grow_SetModified(graph->grow->ctx, 1);
      if (graph->linetype != glow_eLineType_Solid)
        grow_SetObjectLinetype(l1, graph->linetype);

      if (!graph->keep_mode)
        grow_SetMode(graph->grow->ctx, grow_eMode_Edit);

      graph->journal_store(journal_eAction_CreateObject, l1);

      break;
    }
    case grow_eMode_PolyLine: {
      glow_sPoint points[2];
      int point_cnt;
      char name[80];

      if (event->create_grow_object.first_line) {
        sprintf(name, "O%d", grow_IncrNextObjectNameNumber(graph->grow->ctx));

        points[0].x = event->create_grow_object.x2;
        points[0].y = event->create_grow_object.y2;
        points[1].x = event->create_grow_object.x;
        points[1].y = event->create_grow_object.y;
        point_cnt = 2;
        grow_CreateGrowPolyLine(graph->grow->ctx, name, (glow_sPoint*)&points,
            point_cnt, graph->get_border_drawtype(), graph->linewidth, 0, 0,
            graph->border, 0, graph->get_fill_drawtype(), 0, NULL,
            &graph->current_polyline);
      } else {
        points[0].x = event->create_grow_object.x;
        points[0].y = event->create_grow_object.y;
        point_cnt = 1;
        grow_AddPolyLinePoints(
            graph->current_polyline, (glow_sPoint*)&points, point_cnt);
      }
      grow_SetModified(graph->grow->ctx, 1);
      break;
    }
    case grow_eMode_Circle: {
      grow_tObject a1;
      char name[80];

      sprintf(name, "O%d", grow_IncrNextObjectNameNumber(graph->grow->ctx));

      grow_CreateGrowArc(graph->grow->ctx, name, event->create_grow_object.x,
          event->create_grow_object.y, event->create_grow_object.x2,
          event->create_grow_object.y2, 0, 360, graph->get_border_drawtype(),
          graph->linewidth, graph->fill, graph->border, graph->shadow,
          graph->get_fill_drawtype(), NULL, &a1);
      grow_SetModified(graph->grow->ctx, 1);
      if (!graph->keep_mode)
        grow_SetMode(graph->grow->ctx, grow_eMode_Edit);

      graph->journal_store(journal_eAction_CreateObject, a1);

      break;
    }
    }
    graph->refresh_objects(attr_mRefresh_Objects);
    break;
  case glow_eEvent_SelectClear:
    grow_ResetSelectHighlight(graph->grow->ctx);
    break;
  case glow_eEvent_ObjectDeleted: {
    if (graph->current_polyline
        && event->object.object == graph->current_polyline) {
      grow_PolylineEnd(graph->grow->ctx);
      graph->current_polyline = 0;
    }
    grow_SetModified(graph->grow->ctx, 1);

    Attr* attrctx;
    if (graph->attr_list.find(event->object.object, (void**)&attrctx)) {
      delete attrctx;
      graph->attr_list.remove((void*)attrctx);
    }
    break;
  }
  case glow_eEvent_MB3Click:
    graph->reset_mode(true, false);

    if (graph->cursor_motion_cb)
      (graph->cursor_motion_cb)(graph->parent_ctx, event->any.x, event->any.y);
    break;
  case glow_eEvent_MB1DoubleClick:
    if (event->object.object_type != glow_eObjectType_NoObject
        && event->object.object_type != glow_eObjectType_Con) {
      graph->edit_attributes(event->object.object);
    }
    break;
  case glow_eEvent_MB2DoubleClick:
    if (grow_GetPasteActive(graph->grow->ctx))
      break;

    if (event->object.object_type != glow_eObjectType_NoObject) {
      graph->journal_store(journal_eAction_DeleteObject, event->object.object);

      grow_DeleteObject(graph->grow->ctx, event->object.object);
      grow_SetModified(graph->grow->ctx, 1);
    } else {
      graph->delete_select();
    }
    graph->refresh_objects(attr_mRefresh_Objects);
    break;
  case glow_eEvent_MB2Click: {
    char sub_name[80] = "graph";
    pwr_tFileName filename;
    char name[80];
    grow_tNodeClass nc;
    grow_tNode n1;
    int sts;
    char dev[80], dir[80], file[80], type[32];
    int version;
    GeDyn* dyn;

    // Create subgraph object
    if (!graph->get_current_subgraph_cb)
      break;

    sts = (graph->get_current_subgraph_cb)(
        graph->parent_ctx, sub_name, filename);
    if (EVEN(sts)) {
      graph->message('E', "Select a SubGraph");
      break;
    }
    dcli_parse_filename(filename, dev, dir, file, type, &version);
    str_ToLower(sub_name, file);
    if (streq(type, ".pwsg")) {
      sts = grow_FindNodeClassByName(graph->grow->ctx, sub_name, &nc);
      if (EVEN(sts)) {
        // Load the subgraph
        grow_OpenSubGraph(graph->grow->ctx, filename);
      }
      sts = grow_FindNodeClassByName(graph->grow->ctx, sub_name, &nc);
      if (EVEN(sts)) {
        graph->message('E', "Unable to open subgraph");
        break;
      }

      grow_GetUserData(nc, (void**)&dyn);
      if (!dyn) {
        // Old version nodeclass without dyn, create dyn
        GeDyn* dyn = new GeDyn(graph);
        grow_SetUserData(nc, (void*)dyn);
      }

      sprintf(name, "O%d", grow_IncrNextObjectNameNumber(graph->grow->ctx));

      if (!grow_IsSliderClass(nc))
        grow_CreateGrowNode(
            graph->grow->ctx, name, nc, event->any.x, event->any.y, NULL, &n1);
      else
        grow_CreateGrowSlider(
            graph->grow->ctx, name, nc, event->any.x, event->any.y, NULL, &n1);

      if (graph->shadow)
        grow_SetObjectShadow(n1, 1);

      GeDyn* dyn = new GeDyn(graph);
      grow_SetUserData(n1, (void*)dyn);
      if (grow_IsSliderClass(nc))
        dyn->action_type1
            = ge_mActionType1(dyn->action_type1 | ge_mActionType1_Slider);

      graph->journal_store(journal_eAction_CreateObject, n1);
    } else if (streq(type, ".gif") || streq(type, ".jpg")
        || streq(type, ".svg") || streq(type, ".png")) {
      grow_tObject i1;
      char name[80];

      sprintf(name, "O%d", grow_IncrNextObjectNameNumber(graph->grow->ctx));

      if (str_StartsWith(dir, "jpwr/")) {
        strcpy(filename, dir);
        strcat(filename, file);
        strcat(filename, type);
      } else {
        strcpy(filename, file);
        strcat(filename, type);
      }
      grow_CreateGrowImage(graph->grow->ctx, name, filename,
          event->create_grow_object.x, event->create_grow_object.y, NULL, &i1);

      graph->journal_store(journal_eAction_CreateObject, i1);
    } else if (streq(type, ".component")) {
      if (streq(sub_name, "pwr_trend")) {
        grow_tObject t1;
        graph->create_trend(&t1, event->create_grow_object.x,
			    event->create_grow_object.y, (unsigned int)ge_mDynType1_Trend, 0, 0);

        graph->journal_store(journal_eAction_CreateObject, t1);

      } else if (streq(sub_name, "pwrct_trend")) {
        grow_tObject t1;
        graph->create_trend(&t1, event->create_grow_object.x,
	    event->create_grow_object.y, (unsigned int)ge_mDynType1_Trend, 0, 1);

        graph->journal_store(journal_eAction_CreateObject, t1);

      } else if (streq(sub_name, "pwr_fastcurve")) {
        grow_tObject t1;
        graph->create_trend(&t1, event->create_grow_object.x,
	    event->create_grow_object.y, (unsigned int)ge_mDynType1_FastCurve, 0,
            0);

        graph->journal_store(journal_eAction_CreateObject, t1);
      } else if (streq(sub_name, "pwr_dstrend")) {
        grow_tObject t1;
        graph->create_trend(&t1, event->create_grow_object.x,
	    event->create_grow_object.y, 0, (unsigned int)ge_mDynType2_DsTrend,
	    0);

        graph->journal_store(journal_eAction_CreateObject, t1);
      } else if (streq(sub_name, "pwr_dstrendcurve")) {
        grow_tObject t1;
        graph->create_trend(&t1, event->create_grow_object.x,
	    event->create_grow_object.y, 0, (unsigned int)ge_mDynType2_DsTrendCurve,
	    0);

        graph->journal_store(journal_eAction_CreateObject, t1);
      } else if (streq(sub_name, "pwr_xycurve")) {
        grow_tObject t1;
        graph->create_xycurve(&t1, event->create_grow_object.x,
	    event->create_grow_object.y, (unsigned int)ge_mDynType1_XY_Curve, 0, 0);

        graph->journal_store(journal_eAction_CreateObject, t1);
      } else if (streq(sub_name, "pwr_sevhist")) {
        grow_tObject t1;
        graph->create_xycurve(&t1, event->create_grow_object.x,
	    event->create_grow_object.y, 0, (unsigned int)ge_mDynType2_SevHist, 0);

        graph->journal_store(journal_eAction_CreateObject, t1);
      } else if (streq(sub_name, "pwr_bar")) {
        grow_tObject t1;
        graph->create_bar(
            &t1, event->create_grow_object.x, event->create_grow_object.y, 0);

        graph->journal_store(journal_eAction_CreateObject, t1);
      } else if (streq(sub_name, "pwr_bararc")) {
        grow_tObject t1;
        graph->create_bararc(
            &t1, event->create_grow_object.x, event->create_grow_object.y, 0);

        graph->journal_store(journal_eAction_CreateObject, t1);
      } else if (streq(sub_name, "pwrct_bar")) {
        grow_tObject t1;
        graph->create_bar(
            &t1, event->create_grow_object.x, event->create_grow_object.y, 1);

        graph->journal_store(journal_eAction_CreateObject, t1);
      } else if (streq(sub_name, "pwr_window")) {
        grow_tObject t1;
        graph->create_window(
            &t1, event->create_grow_object.x, event->create_grow_object.y);

        graph->journal_store(journal_eAction_CreateObject, t1);
      } else if (streq(sub_name, "pwr_table")) {
        grow_tObject t1;
        graph->create_table(
            &t1, event->create_grow_object.x, event->create_grow_object.y);

        graph->journal_store(journal_eAction_CreateObject, t1);
      } else if (streq(sub_name, "pwr_folder")) {
        grow_tObject t1;
        graph->create_folder(
            &t1, event->create_grow_object.x, event->create_grow_object.y);

        graph->journal_store(journal_eAction_CreateObject, t1);
      } else if (streq(sub_name, "pwr_axis")) {
        grow_tObject t1;
        graph->create_axis(&t1, event->create_grow_object.x,
            event->create_grow_object.y, 0, 0);
      } else if (streq(sub_name, "pwrct_axis")) {
        grow_tObject t1;
        graph->create_axis(&t1, event->create_grow_object.x,
            event->create_grow_object.y, 0, 1);
      } else if (streq(sub_name, "pwr_dynamicaxis")) {
        grow_tObject t1;
        graph->create_axis(&t1, event->create_grow_object.x,
            event->create_grow_object.y, 1, 0);
      } else if (streq(sub_name, "pwrct_dynamicaxis")) {
        grow_tObject t1;
        graph->create_axis(&t1, event->create_grow_object.x,
            event->create_grow_object.y, 1, 1);
      } else if (streq(sub_name, "pwr_axisarc")) {
        grow_tObject t1;
        graph->create_axisarc(&t1, event->create_grow_object.x,
            event->create_grow_object.y, 0, 0);
      } else if (streq(sub_name, "pwrct_axisarc")) {
        grow_tObject t1;
        graph->create_axisarc(&t1, event->create_grow_object.x,
            event->create_grow_object.y, 0, 1);
      } else if (streq(sub_name, "pwr_dynamicaxisarc")) {
        grow_tObject t1;
        graph->create_axisarc(&t1, event->create_grow_object.x,
            event->create_grow_object.y, 1, 0);
      } else if (streq(sub_name, "pwrct_dynamicaxisarc")) {
        grow_tObject t1;
        graph->create_axisarc(&t1, event->create_grow_object.x,
            event->create_grow_object.y, 1, 1);
      } else if (streq(sub_name, "pwr_pie")) {
        grow_tObject t1;
        graph->create_pie(
	    &t1, event->create_grow_object.x, event->create_grow_object.y, 0);
      } else if (streq(sub_name, "pwr_barchart")) {
        grow_tObject t1;
        graph->create_barchart(
            &t1, event->create_grow_object.x, event->create_grow_object.y);
      } else if (streq(sub_name, "pwr_methodtoolbar")) {
        grow_tObject t1;
        graph->create_toolbar(
            &t1, event->create_grow_object.x, event->create_grow_object.y);

        graph->journal_store(journal_eAction_CreateObject, t1);
      } else if (streq(sub_name, "pwr_dashcell")) {
        grow_tObject t1;
        graph->create_dashcell(
            &t1, event->create_grow_object.x, event->create_grow_object.y, 0);
	GeDash* dash = new GeDash(graph);
	grow_SetUserData(t1, (void*)dash);

        graph->journal_store(journal_eAction_CreateObject, t1);
      } else if (streq(sub_name, "pwr_conglue")) {
        grow_tObject t1;

        sprintf(name, "O%d", grow_IncrNextObjectNameNumber(graph->grow->ctx));
        grow_CreateGrowConGlue(graph->grow->ctx, name,
            event->create_grow_object.x, event->create_grow_object.y, &t1);

        graph->journal_store(journal_eAction_CreateObject, t1);
      }
    }
    grow_SetModified(graph->grow->ctx, 1);
    graph->refresh_objects(attr_mRefresh_Objects);
    break;
  }
  case glow_eEvent_MB1Click:
    // Create object or select

    if (graph->set_focus_cb)
      (graph->set_focus_cb)(graph->parent_ctx, graph);

    switch (grow_Mode(graph->grow->ctx)) {
    case grow_eMode_ConPoint: {
      grow_tObject cp1;
      char name[80];

      sprintf(name, "O%d", grow_IncrNextObjectNameNumber(graph->grow->ctx));

      grow_CreateGrowConPoint(graph->grow->ctx, name,
          event->create_grow_object.x, event->create_grow_object.y,
          grow_GetNextConPointNumber(graph->grow->ctx),
          graph->conpoint_direction, NULL, &cp1);
      grow_SetModified(graph->grow->ctx, 1);
      if (!graph->keep_mode)
        grow_SetMode(graph->grow->ctx, grow_eMode_Edit);

      graph->refresh_objects(attr_mRefresh_Objects);
      break;
    }
    case grow_eMode_Annot: {
      grow_tObject a1;
      glow_eDrawType drawtype;
      int textsize = 0;
      char name[80];

      sprintf(name, "O%d", grow_IncrNextObjectNameNumber(graph->grow->ctx));

      if (graph->textbold)
        drawtype = glow_eDrawType_TextHelveticaBold;
      else
        drawtype = glow_eDrawType_TextHelvetica;

      switch (graph->textsize) {
      case 0:
        textsize = 0;
        break;
      case 1:
        textsize = 1;
        break;
      case 2:
        textsize = 2;
        break;
      case 3:
        textsize = 4;
        break;
      case 4:
        textsize = 6;
        break;
      case 5:
        textsize = 8;
        break;
      }
      grow_CreateGrowAnnot(graph->grow->ctx, name, event->create_grow_object.x,
          event->create_grow_object.y, 1, drawtype, graph->get_text_drawtype(),
          textsize, glow_eAnnotType_OneLine, 0, glow_mDisplayLevel_1, NULL,
          &a1);
      grow_SetModified(graph->grow->ctx, 1);
      if (!graph->keep_mode)
        grow_SetMode(graph->grow->ctx, grow_eMode_Edit);

      graph->refresh_objects(attr_mRefresh_Objects);
      break;
    }
    case grow_eMode_Text: {
      grow_tObject t1;
      glow_eDrawType drawtype;
      int textsize = 0;
      char name[80];

      sprintf(name, "O%d", grow_IncrNextObjectNameNumber(graph->grow->ctx));

      if (graph->textbold)
        drawtype = glow_eDrawType_TextHelveticaBold;
      else
        drawtype = glow_eDrawType_TextHelvetica;

      switch (graph->textsize) {
      case 0:
        textsize = 0;
        break;
      case 1:
        textsize = 1;
        break;
      case 2:
        textsize = 2;
        break;
      case 3:
        textsize = 4;
        break;
      case 4:
        textsize = 6;
        break;
      case 5:
        textsize = 8;
        break;
      }
      grow_CreateGrowText(graph->grow->ctx, name, "",
          event->create_grow_object.x, event->create_grow_object.y, drawtype,
          graph->get_text_drawtype(), textsize, graph->textfont,
          glow_mDisplayLevel_1, NULL, &t1);
      if (graph->change_text_cb)
        (graph->change_text_cb)(graph->parent_ctx, t1, "");
      grow_SetModified(graph->grow->ctx, 1);
      if (!graph->keep_mode)
        grow_SetMode(graph->grow->ctx, grow_eMode_Edit);

      graph->journal_store(journal_eAction_CreateObject, t1);

      graph->refresh_objects(attr_mRefresh_Objects);
      break;
    }
    case grow_eMode_Edit: {
      // Select
      if (event->object.object_type == glow_eObjectType_NoObject)
        grow_SelectClear(graph->grow->ctx);
      else {
        if (grow_FindSelectedObject(graph->grow->ctx, event->object.object)) {
          grow_SelectClear(graph->grow->ctx);
        } else {
          grow_SelectClear(graph->grow->ctx);
          grow_SetHighlight(event->object.object, 1);
          grow_SelectInsert(graph->grow->ctx, event->object.object);
        }
      }

      graph->refresh_objects(attr_mRefresh_Select);
      break;
    }
    case grow_eMode_Scale:
      grow_SetMode(graph->grow->ctx, grow_eMode_Edit);
      grow_SelectClear(graph->grow->ctx);
      break;
    default:;
    }
    break;
  case glow_eEvent_MB1ClickShift:
    /* Select */

    if (graph->set_focus_cb)
      (graph->set_focus_cb)(graph->parent_ctx, graph);

    if (event->object.object_type != glow_eObjectType_NoObject) {
      if (grow_FindSelectedObject(graph->grow->ctx, event->object.object)) {
        grow_SetHighlight(event->object.object, 0);
        grow_SelectRemove(graph->grow->ctx, event->object.object);
      } else {
        grow_SetHighlight(event->object.object, 1);
        grow_SelectInsert(graph->grow->ctx, event->object.object);
      }

      graph->refresh_objects(attr_mRefresh_Select);
    }
    break;
  case glow_eEvent_MB1Press:
    /* Select region */
    grow_SetSelectHighlight(graph->grow->ctx);

    graph->refresh_objects(attr_mRefresh_Select);
    break;
  case glow_eEvent_MB1PressShift:
    /* Select region */
    grow_SetSelectHighlight(graph->grow->ctx);

    graph->refresh_objects(attr_mRefresh_Select);
    break;
  case glow_eEvent_PasteSequenceStart: {
    grow_tObject* move_list;
    int move_count;
    int i;

    grow_GetMoveList(graph->grow->ctx, &move_list, &move_count);
    for (i = 0; i < move_count; i++) {
      switch (grow_GetObjectType(move_list[i])) {
      case glow_eObjectType_Con:
        grow_SetObjectName(move_list[i], graph->get_next_object_name("C", ""));
        break;
      case glow_eObjectType_GrowGroup:
        grow_SetObjectName(
            move_list[i], graph->get_next_object_name("Grp", "_"));
        break;
      default:
        grow_SetObjectName(move_list[i], graph->get_next_object_name("O", ""));
        break;
      }
    }
    grow_SetModified(graph->grow->ctx, 1);
    graph->journal_store(journal_eAction_AntePaste, 0);
    break;
  }
  case glow_eEvent_PasteSequenceEnd: {
    graph->journal_store(journal_eAction_PostPaste, 0);

    graph->refresh_objects(attr_mRefresh_Objects);
    break;
  }
  case glow_eEvent_GrowDynamics:
    graph->exec_dynamic(event->dynamics.object, event->dynamics.code,
        event->dynamics.dynamic_type);
    break;
  case glow_eEvent_CursorMotion:
    if (graph->cursor_motion_cb)
      (graph->cursor_motion_cb)(graph->parent_ctx, event->any.x, event->any.y);
    break;
  case glow_eEvent_MB1DoubleClickCtrl:
  case glow_eEvent_MB1DoubleClickShiftCtrl: {
    pwr_tAName attr_name;
    pwr_tTypeId type;
    int sts;

    if (event->object.object_type != glow_eObjectType_NoObject) {
      if (graph->get_rtplant_select_cb) {
        sts = (graph->get_rtplant_select_cb)(graph->parent_ctx, attr_name,
	    sizeof(attr_name), &type);
	if (EVEN(sts)) {
	  graph->message('E', "Select an object in the Navigator");
	  break;
	}
	if (event->event == glow_eEvent_MB1DoubleClickShiftCtrl)
	  sts = graph->dashboard_connect(event->object.object, 1, attr_name, type);
	else
	  sts = graph->dashboard_connect(event->object.object, 0, attr_name, type);
	if (EVEN(sts)) {
	  graph->message('E', "Unable to connect");
	  break;
	}	
      } else if (graph->get_plant_select_cb) {
	sts = (graph->get_plant_select_cb)(
	    graph->parent_ctx, attr_name, sizeof(attr_name));
	if (EVEN(sts)) {
	  graph->message('E', "Select an object in the Plant palette");
	  break;
	}

	graph->connect(event->object.object, attr_name,
            event->event == glow_eEvent_MB1DoubleClickShiftCtrl);
	grow_SetModified(graph->grow->ctx, 1);
      }
    }
    break;
  }
  case glow_eEvent_MB1DoubleClickShift: {
    if (event->object.object_type != glow_eObjectType_NoObject
        && (grow_GetObjectType(event->object.object)
                   == glow_eObjectType_GrowNode
               || grow_GetObjectType(event->object.object)
                   == glow_eObjectType_GrowGroup)) {
      glow_eDrawType color;
      GeDyn* dyn;

      grow_GetUserData(event->object.object, (void**)&dyn);

      color = graph->get_fill_drawtype();
      dyn->set_color(event->object.object, color);
    }
    break;
  }
  case glow_eEvent_Key_Tab: {
    if (graph->traverse_focus_cb)
      (graph->traverse_focus_cb)(graph->parent_ctx, graph);
    break;
  }
  case glow_eEvent_Map: {
    graph->displayed = 1;
    break;
  }
  case glow_eEvent_Translate: {
    char new_text[200];
    int sts;

    sts = Lng::translate(event->translate.text, new_text);
    if (sts)
      event->translate.new_text = new_text;
    return sts;
  }
  case glow_eEvent_ScrollUp: {
    grow_Scroll(graph->grow->ctx, 0, 0.05);
    break;
  }
  case glow_eEvent_ScrollDown: {
    grow_Scroll(graph->grow->ctx, 0, -0.05);
    break;
  }
  case glow_eEvent_AnteUndo: {
    if (event->object.object)
      graph->journal_store(
          journal_eAction_AntePropertiesObject, event->object.object);
    else
      graph->journal_store(journal_eAction_AntePropertiesSelect, 0);
    break;
  }
  case glow_eEvent_PostUndo: {
    if (event->object.object)
      graph->journal_store(
          journal_eAction_PostPropertiesObject, event->object.object);
    else
      graph->journal_store(journal_eAction_PostPropertiesSelect, 0);
    break;
  }
  default:;
  }
  return 1;
}

void graph_eventlog_cb(void* ctx, void* data, unsigned int size)
{
  Graph* graph;

  grow_GetCtxUserData((GrowCtx*)ctx, (void**)&graph);

  if (graph && graph->eventlog_cb)
    (graph->eventlog_cb)(graph->parent_ctx, data, size);
}

void graph_keyboard_cb(void* ctx, int action, int type)
{
  Graph* graph = (Graph*)ctx;

  if (graph && graph->keyboard_cb)
    (graph->keyboard_cb)(graph->parent_ctx, action, type);
}

void graph_userdata_save_cb(void* f, void* object, glow_eUserdataCbType utype)
{
  std::ofstream* fp = (std::ofstream*)f;

  switch (utype) {
  case glow_eUserdataCbType_Node:
  case glow_eUserdataCbType_NodeClass: {

    if (grow_GetObjectType(object) == glow_eObjectType_GrowDashCell) {
      GeDash* dash;

      grow_GetUserData(object, (void**)&dash);
      dash->save(*fp);
    } else {
      GeDyn* dyn;

      grow_GetUserData(object, (void**)&dyn);
      dyn->save(*fp);
    }
    break;
  }
  case glow_eUserdataCbType_Ctx: {
    Graph* graph;

    grow_GetCtxUserData((GrowCtx*)object, (void**)&graph);

    if (graph->is_subgraph()) {
      if (graph->subgraph_dyn)
        graph->subgraph_dyn->save(*fp);
      else
        *fp << int(ge_eSave_End) << '\n';
    }
    break;
  }
  }
}

static void graph_scriptexec_cb(void *ctx, char *filename)
{
  Graph* graph;
  int ctx_popped = 0;

  grow_GetCtxUserData((GrowCtx*)ctx, (void**)&graph);

  if (ctx != graph->grow->ctx) {
    graph->grow->pop((GrowCtx*)ctx);
    ctx_popped = 1;
  }

  graph->read_scriptfile(&filename[1]);
  graph->set_modified(0);

  if (ctx_popped)
    graph->grow->push();    
}

static void graph_userdata_open_cb(void* f, void* object, glow_eUserdataCbType utype)
{
  std::ifstream* fp = (std::ifstream*)f;
  Graph* graph;

  switch (utype) {
  case glow_eUserdataCbType_Node:
  case glow_eUserdataCbType_NodeClass: {
    if (grow_GetObjectType(object) == glow_eObjectType_GrowDashCell) {
      GeDash* dash;

      grow_GetCtxUserData(grow_GetCtx(object), (void**)&graph);

      grow_GetUserData(object, (void**)&dash);
      if (dash)
	delete dash;

      dash = new GeDash(graph);
      grow_SetUserData(object, (void*)dash);
      
      dash->open(*fp);
    } else {
      GeDyn* dyn;

      grow_GetCtxUserData(grow_GetCtx(object), (void**)&graph);

      grow_GetUserData(object, (void**)&dyn);
      if (dyn)
	delete dyn;

      dyn = new GeDyn(graph);
      grow_SetUserData(object, (void*)dyn);
      
      dyn->open(*fp);
    }
    break;
  }
  case glow_eUserdataCbType_Ctx: {
    grow_GetCtxUserData((GrowCtx*)object, (void**)&graph);

    if (graph->is_subgraph()) {
      graph->subgraph_dyn = new GeDyn(graph);
      graph->subgraph_dyn->open(*fp);
    }
    break;
  }
  }
}

void graph_userdata_copy_cb(
    void* object, void* old_data, void** new_data, glow_eUserdataCbType utype)
{
  switch (utype) {
  case glow_eUserdataCbType_NodeClass:
  case glow_eUserdataCbType_Node: {
    if (grow_GetObjectType(object) == glow_eObjectType_GrowDashCell) {
      if (!old_data) {
	*new_data = 0;
	break;
      }

      GeDash* dash = (GeDash*)old_data;
      GeDash* new_dash = new GeDash(*dash);

      *new_data = (void*)new_dash;
    } else {
      if (!old_data) {
	*new_data = 0;
	break;
      }

      GeDyn* dyn = (GeDyn*)old_data;
      GeDyn* new_dyn = new GeDyn(*dyn);

      *new_data = (void*)new_dyn;
    }
    break;
  }
  case glow_eUserdataCbType_Ctx:
    break;
  }
}

GraphGbl::GraphGbl()
{
  strcpy(version, graph_cVersion);
}

int GraphGbl::load_config(void* graph)
{
  return 1;
}

GraphRef::GraphRef(pwr_tAName name, pwr_tRefId* id, int size, glow_eCycle cycle,
    grow_tObject object, void** data)
    : m_id(id), m_size(size), m_cycle(cycle), m_object(object), m_data(data)
{
  strcpy(m_name, name);
}

int Graph::grow_pop()
{
  return 1;
}

int Graph::grow_push()
{
  return 1;
}

int Graph::grow_push_all()
{
  while (grow_push())
    ;
  return 1;
}

void GraphGrow::grow_setup()
{
  grow_sAttributes grow_attr;
  unsigned long mask;

  mask = 0;
  mask |= grow_eAttr_grid_on;
  grow_attr.grid_on = 0;
  mask |= grow_eAttr_grid_size_x;
  grow_attr.grid_size_y = 1;
  mask |= grow_eAttr_grid_size_y;
  grow_attr.grid_size_x = 1;
  mask |= grow_eAttr_select_policy;
  grow_attr.select_policy = glow_eSelectPolicy_Surround;
  mask |= grow_eAttr_default_hot_mode;
  if (((Graph*)graph)->mode == graph_eMode_Development)
    grow_attr.default_hot_mode = glow_eHotMode_SingleObject;
  else
    grow_attr.default_hot_mode = glow_eHotMode_TraceAction;
  mask |= grow_eAttr_grafcet_con_delta;
  grow_attr.grafcet_con_delta = 0.6;
  mask |= grow_eAttr_enable_bg_pixmap;
  if (((Graph*)graph)->mode == graph_eMode_Development)
    grow_attr.enable_bg_pixmap = 0;
  else
    grow_attr.enable_bg_pixmap = 1;
  mask |= grow_eAttr_double_buffer_on;
  mask |= grow_eAttr_environment;
  if (((Graph*)graph)->mode == graph_eMode_Development) {
    grow_attr.double_buffer_on = 1;
    grow_attr.environment = glow_eEnv_Development;
  } else {
    grow_attr.double_buffer_on = 0;
    grow_attr.environment = glow_eEnv_Runtime;
  }
  if (((Graph*)graph)->dashboard) {
    mask |= grow_eAttr_color_theme;
    strcpy(grow_attr.color_theme, "$default");
  }
  mask |= grow_eAttr_dashboard;
  grow_attr.dashboard = ((Graph*)graph)->dashboard;
  grow_SetAttributes(ctx, &grow_attr, mask);
  grow_SetCtxUserData(ctx, graph);
  grow_SetMoveRestrictions(ctx, glow_eMoveRestriction_No, 0, 0, NULL);

  grow_DisableEventAll(ctx);
  grow_EnableEvent(
      ctx, glow_eEvent_MB1DoubleClick, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MB2DoubleClick, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(ctx, glow_eEvent_MB1DoubleClickCtrl,
      glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(ctx, glow_eEvent_MB1DoubleClickShiftCtrl,
      glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(ctx, glow_eEvent_MB1DoubleClickShift,
      glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MB1Click, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MB1ClickShift, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_SelectClear, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_ObjectDeleted, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MB1Press, glow_eEventType_RegionSelect, graph_grow_cb);
  grow_EnableEvent(ctx, glow_eEvent_MB1PressShift,
      glow_eEventType_RegionAddSelect, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MB2Press, glow_eEventType_CreateCon, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MB1Press, glow_eEventType_MoveNode, graph_grow_cb);
  grow_EnableEvent(ctx, glow_eEvent_CreateGrowObject, glow_eEventType_CallBack,
      graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MB3Click, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MB2Click, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(ctx, glow_eEvent_PasteSequenceStart,
      glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(ctx, glow_eEvent_PasteSequenceEnd, glow_eEventType_CallBack,
      graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_GrowDynamics, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_CursorMotion, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_Map, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_Key_Tab, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_ScrollUp, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_ScrollDown, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_AnteUndo, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_PostUndo, glow_eEventType_CallBack, graph_grow_cb);

  grow_RegisterUserDataCallbacks(ctx, graph_userdata_save_cb,
      graph_userdata_open_cb, graph_userdata_copy_cb);
  grow_RegisterScriptExecCallback(ctx, graph_scriptexec_cb);
}

void GraphGrow::grow_trace_setup()
{
  grow_sAttributes grow_attr;
  unsigned long mask;

  if (Lng::translatefile_coding() == lng_eCoding_UTF_8)
    grow_SetTextCoding(ctx, glow_eTextCoding_UTF_8);

  mask = 0;
  mask |= grow_eAttr_grid_on;
  grow_attr.grid_on = 0;
  mask |= grow_eAttr_grid_size_x;
  grow_attr.grid_size_y = 1;
  mask |= grow_eAttr_grid_size_y;
  grow_attr.grid_size_x = 1;
  mask |= grow_eAttr_select_policy;
  grow_attr.select_policy = glow_eSelectPolicy_Surround;
  mask |= grow_eAttr_default_hot_mode;
  if (((Graph*)graph)->mode == graph_eMode_Development)
    grow_attr.default_hot_mode = glow_eHotMode_SingleObject;
  else
    grow_attr.default_hot_mode = glow_eHotMode_TraceAction;
  mask |= grow_eAttr_grafcet_con_delta;
  grow_attr.grafcet_con_delta = 0.6;
  mask |= grow_eAttr_enable_bg_pixmap;
  if (((Graph*)graph)->mode == graph_eMode_Development)
    grow_attr.enable_bg_pixmap = 0;
  else
    grow_attr.enable_bg_pixmap = 1;
  mask |= grow_eAttr_double_buffer_on;
  if (((Graph*)graph)->mode == graph_eMode_Development)
    grow_attr.double_buffer_on = 1;
  else
    grow_attr.double_buffer_on = 0;
  grow_SetAttributes(ctx, &grow_attr, mask);
  grow_SetCtxUserData(ctx, graph);
  grow_SetMoveRestrictions(ctx, glow_eMoveRestriction_Disable, 0, 0, NULL);

  grow_DisableEventAll(ctx);
  grow_EnableEvent(
      ctx, glow_eEvent_MB1DoubleClick, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MB2DoubleClick, glow_eEventType_CallBack, graph_grow_cb);
  if (((Graph*)graph)->dashboard)
    grow_EnableEvent(ctx, glow_eEvent_MB1DoubleClickCtrl,
        glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MB1Click, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MB1ClickShift, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_SelectClear, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_ObjectDeleted, glow_eEventType_CallBack, graph_grow_cb);
  // grow_EnableEvent( ctx, glow_eEvent_MB1Press, glow_eEventType_RegionSelect,
  //	graph_grow_cb);
  // grow_EnableEvent( ctx, glow_eEvent_MB1PressShift,
  // glow_eEventType_RegionAddSelect,
  //	graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MB1Press, glow_eEventType_MoveNode, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MB3Click, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MB3Press, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MB2Click, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_GrowDynamics, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_CursorMotion, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_SliderMoved, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(ctx, glow_eEvent_SliderMoveStart, glow_eEventType_CallBack,
      graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_SliderMoveEnd, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(ctx, glow_eEvent_AnnotationInput, glow_eEventType_CallBack,
      graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_InputFocusLost, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(ctx, glow_eEvent_InputFocusGained, glow_eEventType_CallBack,
      graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_InputFocusInit, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_HotRequest, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MB1Down, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MB1Up, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MB3Down, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_TipText, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_Key_Tab, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_Key_ShiftTab, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_Key_Escape, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_Key_Return, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_Key_Left, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_Key_Right, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_Key_Up, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_Key_Down, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_Key_CtrlAscii, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MenuActivated, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MenuCreate, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_MenuDelete, glow_eEventType_CallBack, graph_grow_cb);
  grow_EnableEvent(
      ctx, glow_eEvent_Signal, glow_eEventType_CallBack, graph_grow_cb);

  grow_RegisterEventLogCallback(ctx, graph_eventlog_cb);
}

//
// Backcall routine called at creation of the grow widget
// Enable event, create nodeclasses and insert the root objects.
//
int graph_init_grow_base_cb(GlowCtx* fctx, void* client_data)
{
  Graph* graph = (Graph*)client_data;
  GrowCtx* ctx = (GrowCtx*)fctx;
  // GrowCtx *secondary_ctx;

  graph->grow = new GraphGrow(ctx, (void*)graph);
  graph->grow_stack[0] = new GraphGrow(ctx, (void*)graph);
  graph->grow_cnt++;

  graph->grow->grow_setup();

  graph->grow_stack[0] = graph->grow;

  // grow_CreateSecondaryCtx( graph->grow_stack[0]->ctx, &secondary_ctx,
  //      graph_init_grow_cb, (void *)graph, glow_eCtxType_Grow);

  if (graph->init_cb)
    (graph->init_cb)(graph->parent_ctx);

  if (graph->pending_borders) {
    grow_SetLayout(graph->grow->ctx, graph->pending_borders[0],
        graph->pending_borders[1], graph->pending_borders[2],
        graph->pending_borders[3]);
    free(graph->pending_borders);
    graph->pending_borders = 0;
  }

  return 1;
}

void Graph::graph_attr_redraw_cb(
    void* gctx, void* attrctx, grow_tObject object, void* info)
{
  Graph* graph = (Graph*)gctx;

  if (info) {
    grow_UpdateObject(graph->grow->ctx, object, (grow_sAttrInfo*)info);

    if (grow_GetObjectType(object) == glow_eObjectType_GrowDashCell) {
      GeDash* dash;

      grow_GetUserData(object, (void**)&dash);
      // dash->update(object);
    }
  }
}

static void graph_graphattr_redraw_cb(
    void* gctx, void* attrctx, grow_tObject object, void* info)
{
  Graph* graph = (Graph*)gctx;
  if (graph->is_subgraph()) {
    char* argnames;
    int* argtypes;
    int* arg_cnt;
    char* code;
    int size;

    grow_UpdateSubGraph(graph->grow->ctx, (grow_sAttrInfo*)info);

    grow_GetSubGraphDynamic(graph->grow->ctx, &code, &size);
    if (size) {
      grow_RefSubGraphArgNames(
          graph->grow->ctx, &argnames, &argtypes, &arg_cnt);
      graph->get_argnames(code, argnames, argtypes, arg_cnt);
    }
  } else {
    grow_UpdateGraph(graph->grow->ctx, (grow_sAttrInfo*)info);
  }
}

void Graph::graph_attr_close_cb(
    void* gctx, void* attrctx, grow_tObject object, void* info, int keep)
{
  Graph* graph = (Graph*)gctx;

  if (grow_GetObjectType(object) == glow_eObjectType_GrowDashCell) {
    if (info)
      grow_UpdateObject(graph->grow->ctx, object, (grow_sAttrInfo*)info);

    graph->attr_list.remove(attrctx);
    grow_FreeObjectAttrInfo((grow_sAttrInfo*)info);

    GeDash* dash;

    grow_GetUserData(object, (void**)&dash);
    dash->update(object);

    // graph->journal_store(journal_eAction_PostPropertiesObject, object);
  } else {
    if (info)
      grow_UpdateObject(graph->grow->ctx, object, (grow_sAttrInfo*)info);

    graph->attr_list.remove(attrctx);
    grow_FreeObjectAttrInfo((grow_sAttrInfo*)info);

    graph->journal_store(journal_eAction_PostPropertiesObject, object);
  }
  if (!keep)
    delete (Attr*)attrctx;
}

static void graph_graphattr_close_cb(
    void* gctx, void* attrctx, grow_tObject object, void* info, int keep)
{
  Graph* graph = (Graph*)gctx;

  if (graph->is_subgraph())
    grow_FreeSubGraphAttrInfo((grow_sAttrInfo*)info);
  else
    grow_FreeGraphAttrInfo((grow_sAttrInfo*)info);

  graph->attr_list.remove(attrctx);
  if (!keep)
    delete (Attr*)attrctx;

  if (graph->is_dashboard())
    graph->dashboard_reconfigure();
}

int Graph::is_modified()
{
  return grow_GetModified(grow->ctx);
}

int Graph::init_trace()
{
  int sts;

  if (grow_GetModified(grow->ctx) && mode != graph_eMode_Runtime) {
    message('E', "Session is not saved");
    return 0;
  }

  if (!gdh_init_done) {
    sts = gdh_Init("ge");
    if (EVEN(sts))
      return sts;
  }

  if (!trace_started) {
    grow_GetScanTime(
        grow->ctx, &scan_time, &fast_scan_time, &animation_scan_time);
    if (fast_scan_time < animation_scan_time)
      fast_scan_time = animation_scan_time;
    if (scan_time < animation_scan_time)
      scan_time = animation_scan_time;

    // Set subscription defaults
    int dt = int(scan_time * 1000);
    int tmo = int(MAX(2 * dt / 100, 25));
    sts = gdh_SetSubscriptionDefaults(dt, tmo);

    grow->grow_trace_setup();

    // Look for object graph
    if (!streq(object_name[0], ""))
      init_object_graph(0);

    sts = grow_TraceInit(grow->ctx, graph_trace_connect_bc,
        graph_trace_disconnect_bc, graph_trace_scan_bc, graph_trace_ctrl_bc);

    // Look for object graph
    if (!streq(object_name[0], ""))
      init_object_graph(1);

    trace_started = 1;
    current_mb1_down = 0;

    trace_scan(this);
    grow_InputFocusInitEvent(grow->ctx);
  }
  return 1;
}

void Graph::close_trace(int reload)
{
  char graphname[80];

  if (trace_started) {
    trace_timer_remove();

    grow_TraceClose(grow->ctx);

    if (graph_object_close)
      (graph_object_close)(this);

    trace_started = 0;

    if (reload) {
      grow->grow_setup();

      // Refresh the graph by loading it from file

      if (load_graph_cb) {
        get_name(graphname);
        (load_graph_cb)(parent_ctx, graphname);
      }
    }
  }
}

void Graph::trace_scan(Graph* graph)
{
  int time = int(graph->animation_scan_time * 1000);

  if (graph->trace_started) {
    if (graph->graph_object_scan)
      (graph->graph_object_scan)(graph);

    grow_TraceScan(graph->grow->ctx);

    graph->slow_scan_cnt++;
    if (graph->slow_scan_cnt
        >= int(graph->scan_time / graph->animation_scan_time + 0.5))
      graph->slow_scan_cnt = 0;

    graph->fast_scan_cnt++;
    if (graph->fast_scan_cnt
        >= int(graph->fast_scan_time / graph->animation_scan_time + 0.5))
      graph->fast_scan_cnt = 0;

    graph->trace_timer_add(time);
  }
}

static int graph_trace_connect_bc(
    grow_tObject object, glow_sTraceData* trace_data)
{
  GeDyn* dyn;
  int dyn_type1;
  int dyn_type2;
  int dyn_action_type1;
  int dyn_action_type2;

  GrowCtx* ctx;
  Graph* graph;
  int ctx_popped = 0;

  if (!trace_data) {
    // Everything is connected
    grow_GetCtxUserData((GrowCtx*)object, (void**)&graph);
    graph->ref_object_info_all();
    return 1;
  }

  // Check if new ctx
  ctx = grow_GetCtx(object);
  grow_GetCtxUserData((GrowCtx*)ctx, (void**)&graph);
  if (ctx != graph->grow->ctx) {
    graph->grow->pop(ctx);
    ctx_popped = 1;
  }

  grow_GetUserData(object, (void**)&dyn);
  if (!dyn) {
    if (ctx_popped)
      graph->grow->push();
    return 1;
  }

  // Get Dyn from nodeclass if dyn_type1 is HostObject
  grow_GetObjectClassDynType(
      object, &dyn_type1, &dyn_type2, &dyn_action_type1, &dyn_action_type2);
  if (dyn_type1 & ge_mDynType1_HostObject
      && (dyn->dyn_type1 & ge_mDynType1_Inherit
             || dyn->dyn_type1 & ge_mDynType1_HostObject)) {
    GeDyn* nodeclass_dyn;
    GeDyn* old_dyn;
    pwr_tAName hostobject;

    grow_GetObjectClassUserData(object, (void**)&nodeclass_dyn);
    if (nodeclass_dyn) {
      old_dyn = dyn;
      dyn = new GeDyn(*nodeclass_dyn);
      old_dyn->get_hostobject(hostobject);
      dyn->merge(*old_dyn);
      if (old_dyn->cycle != glow_eCycle_Inherit)
        dyn->cycle = old_dyn->cycle;
      if (!(old_dyn->action_type1 == ge_mActionType1_Inherit
              && old_dyn->action_type2 == 0))
        dyn->access = old_dyn->access;
      grow_SetUserData(object, (void*)dyn);

      delete old_dyn;
    }
  }

  dyn->connect(object, trace_data, graph->connect_now);

  if (ctx_popped)
    graph->grow->push();
  return 1;
}

static int graph_trace_disconnect_bc(grow_tObject object)
{
  GeDyn* dyn;

  grow_GetUserData(object, (void**)&dyn);
  if (!dyn)
    return 1;

  dyn->disconnect(object);

  return 1;
}

static int graph_trace_ctrl_bc(int type, void* data)
{
  switch (type) {
  case glow_eTraceCtrl_CtxPop: {
    Graph* graph;

    grow_GetCtxUserData((GrowCtx*)data, (void**)&graph);
    graph->grow->pop((GrowCtx*)data);
    break;
  }
  case glow_eTraceCtrl_CtxPush: {
    Graph* graph;

    grow_GetCtxUserData((GrowCtx*)data, (void**)&graph);
    graph->grow->push();
    break;
  }
  default:;
  }
  return 1;
}

static int graph_trace_scan_bc(grow_tObject object, void* p)
{
  GeDyn* dyn;
  int sts;

  grow_GetUserData(object, (void**)&dyn);
  if (!dyn)
    return 1;

  if (dyn->cycle == glow_eCycle_Inherit)
    return 1;
  if (dyn->cycle == glow_eCycle_Slow && dyn->graph->slow_scan_cnt != 0
      && !(dyn->total_dyn_type1 & ge_mDynType1_Animation
             || dyn->total_dyn_type2 & ge_mDynType2_ScrollingText))
    return 1;
  if (dyn->cycle == glow_eCycle_Fast && dyn->graph->fast_scan_cnt != 0
      && !(dyn->total_dyn_type1 & ge_mDynType1_Animation
             || dyn->total_dyn_type2 & ge_mDynType2_ScrollingText))
    return 1;

  sts = dyn->scan(object);
  if (sts == GLOW__TERMINATED || sts == GLOW__SUBTERMINATED
      || sts == GLOW__SWAPTERMINATED)
    return sts;

  return 1;
}

//
// Callbacks from grow
//
static int graph_trace_grow_cb(GlowCtx* ctx, glow_tEvent event)
{
  Graph* graph;
  int ctx_popped = 0;

  grow_GetCtxUserData((GrowCtx*)ctx, (void**)&graph);
  graph->message(' ', null_str);

  if (ctx != graph->grow->ctx) {
    graph->grow->pop((GrowCtx*)ctx);
    ctx_popped = 1;
  }
  switch (event->event) {
  case glow_eEvent_ObjectDeleted:
    break;
  case glow_eEvent_MB1Down: {
    if (event->object.object_type != glow_eObjectType_NoObject
        && (grow_GetObjectType(event->object.object)
                   == glow_eObjectType_GrowNode
               || grow_GetObjectType(event->object.object)
                   == glow_eObjectType_GrowGroup
               || grow_GetObjectType(event->object.object)
                   == glow_eObjectType_GrowSlider
               || grow_GetObjectType(event->object.object)
                   == glow_eObjectType_GrowWindow
               || grow_GetObjectType(event->object.object)
                   == glow_eObjectType_GrowTrend
               || grow_GetObjectType(event->object.object)
                   == glow_eObjectType_GrowXYCurve
               || grow_GetObjectType(event->object.object)
                   == glow_eObjectType_GrowTable
               || grow_GetObjectType(event->object.object)
                   == glow_eObjectType_GrowBar
               || grow_GetObjectType(event->object.object)
                   == glow_eObjectType_GrowBarArc
               || grow_GetObjectType(event->object.object)
                   == glow_eObjectType_GrowPie
               || grow_GetObjectType(event->object.object)
                   == glow_eObjectType_GrowBarChart
               || grow_GetObjectType(event->object.object)
                   == glow_eObjectType_GrowAxis
               || grow_GetObjectType(event->object.object)
                   == glow_eObjectType_GrowAxisArc)) {
      GeDyn* dyn;

      grow_GetUserData(event->object.object, (void**)&dyn);
      if (dyn) {
        dyn->action(event->object.object, event);
        graph->current_mb1_down = event->object.object;
      }
    }
    break;
  }
  case glow_eEvent_MB1Up: {
    if (!graph->current_mb1_down)
      break;
    if (grow_GetObjectType(graph->current_mb1_down) == glow_eObjectType_GrowNode
        || grow_GetObjectType(graph->current_mb1_down)
            == glow_eObjectType_GrowSlider
        || grow_GetObjectType(graph->current_mb1_down)
            == glow_eObjectType_GrowGroup
        || grow_GetObjectType(graph->current_mb1_down)
            == glow_eObjectType_GrowWindow
        || grow_GetObjectType(graph->current_mb1_down)
            == glow_eObjectType_GrowTrend
        || grow_GetObjectType(graph->current_mb1_down)
            == glow_eObjectType_GrowXYCurve
        || grow_GetObjectType(graph->current_mb1_down)
            == glow_eObjectType_GrowTable
        || grow_GetObjectType(graph->current_mb1_down)
            == glow_eObjectType_GrowBar
        || grow_GetObjectType(graph->current_mb1_down)
            == glow_eObjectType_GrowBarArc
        || grow_GetObjectType(graph->current_mb1_down)
            == glow_eObjectType_GrowPie
        || grow_GetObjectType(graph->current_mb1_down)
            == glow_eObjectType_GrowBarChart
        || grow_GetObjectType(graph->current_mb1_down)
            == glow_eObjectType_GrowAxis
        || grow_GetObjectType(graph->current_mb1_down)
            == glow_eObjectType_GrowAxisArc) {
      GeDyn* dyn;

      grow_GetUserData(graph->current_mb1_down, (void**)&dyn);
      if (dyn) {
        dyn->action(graph->current_mb1_down, event);
        graph->current_mb1_down = 0;
      }
    }
    break;
  }
  case glow_eEvent_MB3Down: {
    if (graph->mode == graph_eMode_Runtime) {
      switch (grow_GetMB3Action(graph->grow->ctx)) {
      case glow_eMB3Action_Close:
        grow_SetClickSensitivity(graph->grow->ctx, glow_mSensitivity_MB3Click);
        break;
      case glow_eMB3Action_PopupMenu:
        grow_SetClickSensitivity(graph->grow->ctx, glow_mSensitivity_MB3Press);
        break;
      default:;
      }
    }
    break;
  }
  case glow_eEvent_HotRequest: {
    if (grow_GetObjectType(event->object.object) == glow_eObjectType_GrowNode
        || grow_GetObjectType(event->object.object)
            == glow_eObjectType_GrowSlider
        || grow_GetObjectType(event->object.object)
            == glow_eObjectType_GrowGroup
        || grow_GetObjectType(event->object.object)
            == glow_eObjectType_GrowToolbar) {
      GeDyn* dyn;

      grow_GetUserData(event->object.object, (void**)&dyn);
      if (grow_GetObjectType(event->object.object)
          == glow_eObjectType_GrowSlider) {
        if (dyn->get_slider_disabled()) {
          if (ctx_popped)
            graph->grow->push();
          return 0;
        }
      }
      if (graph->is_authorized(dyn->access)
          && dyn->get_actiontype1(event->object.object)
              & ~ge_mActionType1_Inherit) {
        if (dyn->get_actiontype1(event->object.object)
            & ~ge_mActionType1_PopupMenu) {
          if (ctx_popped)
            graph->grow->push();
          return int(glow_mHotType_CursorCrossHair);
        } else {
          if (ctx_popped)
            graph->grow->push();
          return int(glow_mHotType_CursorHand);
        }
      } else {
        if (ctx_popped)
          graph->grow->push();
        return 0;
      }
    } else {
      if (ctx_popped)
        graph->grow->push();
      return 0;
    }
  }
  case glow_eEvent_TipText: {
    if (grow_GetObjectType(event->object.object) == glow_eObjectType_GrowNode
        || grow_GetObjectType(event->object.object)
            == glow_eObjectType_GrowSlider
        || grow_GetObjectType(event->object.object)
            == glow_eObjectType_GrowGroup
        || grow_GetObjectType(event->object.object)
            == glow_eObjectType_GrowToolbar) {
      GeDyn* dyn;

      grow_GetUserData(event->object.object, (void**)&dyn);
      dyn->action(event->object.object, event);
    }
    break;
  }
  case glow_eEvent_SliderMoveEnd: {
    GeDyn* dyn;

    grow_GetUserData(event->object.object, (void**)&dyn);
    dyn->action(event->object.object, event);

    grow_SetMoveRestrictions(
        graph->grow->ctx, glow_eMoveRestriction_Disable, 0, 0, NULL);
    graph->current_slider = NULL;
    break;
  }
  case glow_eEvent_SliderMoveStart: {
    GeDyn* dyn;

    grow_GetUserData(event->object.object, (void**)&dyn);
    dyn->action(event->object.object, event);

    break;
  }
  case glow_eEvent_SliderMoved: {
    GeDyn* dyn;

    grow_GetUserData(event->object.object, (void**)&dyn);
    dyn->action(event->object.object, event);
    break;
  }
  case glow_eEvent_MB3Click: {
    if (graph->mode == graph_eMode_Runtime) {
      switch (grow_GetMB3Action(graph->grow->ctx)) {
      case glow_eMB3Action_Close:
      case glow_eMB3Action_Both:
        // Close
        if (graph->close_cb) {
          if ((graph->close_cb)(graph->parent_ctx))
            return GLOW__TERMINATED;
        }
        break;
      default:;
      }
    }
    break;
  }
  case glow_eEvent_MB3Press: {
    if (event->any.type == glow_eEventType_Table) {
      switch (grow_GetMB3Action(graph->grow->ctx)) {
      case glow_eMB3Action_PopupMenu:
      case glow_eMB3Action_Both: {
        GeDyn* dyn;

        grow_GetUserData(event->table.object, (void**)&dyn);
        dyn->action(event->table.object, event);
        break;
      }
      default:;
      }
      break;
    }

    if (event->object.object_type == glow_eObjectType_NoObject)
      break;
    if (!(grow_GetObjectType(event->object.object) == glow_eObjectType_GrowNode
            || grow_GetObjectType(event->object.object)
                == glow_eObjectType_GrowGroup
            || grow_GetObjectType(event->object.object)
                == glow_eObjectType_GrowToolbar
            || grow_GetObjectType(event->object.object)
                == glow_eObjectType_GrowWindow
            || grow_GetObjectType(event->object.object)
                == glow_eObjectType_GrowBar
            || grow_GetObjectType(event->object.object)
                == glow_eObjectType_GrowBarArc
            || grow_GetObjectType(event->object.object)
                == glow_eObjectType_GrowTable
            || grow_GetObjectType(event->object.object)
                == glow_eObjectType_GrowXYCurve
            || grow_GetObjectType(event->object.object)
                == glow_eObjectType_GrowTrend
            || grow_GetObjectType(event->object.object)
                == glow_eObjectType_GrowPie
            || grow_GetObjectType(event->object.object)
                == glow_eObjectType_GrowBarChart
            || grow_GetObjectType(event->object.object)
                == glow_eObjectType_GrowAxis
            || grow_GetObjectType(event->object.object)
                == glow_eObjectType_GrowAxisArc))
      break;
    if (graph->mode != graph_eMode_Runtime)
      break;

    switch (grow_GetMB3Action(graph->grow->ctx)) {
    case glow_eMB3Action_PopupMenu:
    case glow_eMB3Action_Both: {
      GeDyn* dyn;

      grow_GetUserData(event->object.object, (void**)&dyn);
      if (dyn)
        dyn->action(event->object.object, event);
      break;
    }
    default:;
    }
    break;
  }
  case glow_eEvent_MB1Click: {
    GeDyn* dyn;
    int sts;

    if (event->any.type == glow_eEventType_Table) {
      grow_GetUserData(event->table.object, (void**)&dyn);
      dyn->action(event->table.object, event);
      break;
    }
    if (event->any.type == glow_eEventType_Toolbar) {
      grow_GetUserData(event->toolbar.object, (void**)&dyn);
      dyn->action(event->toolbar.object, event);
      break;
    }

    if (event->object.object_type == glow_eObjectType_NoObject
        || grow_GetObjectType(event->object.object)
            != glow_eObjectType_GrowMenu) {
      // Close any open menu, if not click in menu
      glow_sEvent e;
      grow_tObject* objectlist;
      int object_cnt, cnt;
      int i;

      e.event = glow_eEvent_MenuDelete;
      e.any.type = glow_eEventType_Menu;
      e.menu.object = 0;

      grow_GetObjectList(graph->grow->ctx, &objectlist, &object_cnt);
      for (i = 0; i < object_cnt; i++) {
        if ((grow_GetObjectType(objectlist[i]) == glow_eObjectType_GrowNode
                || grow_GetObjectType(objectlist[i])
                    == glow_eObjectType_GrowGroup)
            && (event->object.object_type == glow_eObjectType_NoObject
                   || objectlist[i] != event->object.object)) {
          grow_GetUserData(objectlist[i], (void**)&dyn);
          dyn->action(objectlist[i], &e);
          grow_GetObjectList(graph->grow->ctx, &objectlist, &cnt);
          if (cnt != object_cnt)
            // Something is deleted
            break;
        }
      }
    }

    if (event->object.object_type == glow_eObjectType_NoObject)
      break;
    if (grow_GetObjectType(event->object.object) == glow_eObjectType_GrowNode
        || grow_GetObjectType(event->object.object)
            == glow_eObjectType_GrowGroup
        || grow_GetObjectType(event->object.object)
            == glow_eObjectType_GrowToolbar
        || grow_GetObjectType(event->object.object)
            == glow_eObjectType_GrowWindow
        || grow_GetObjectType(event->object.object) == glow_eObjectType_GrowBar
        || grow_GetObjectType(event->object.object) == glow_eObjectType_GrowBarArc
        || grow_GetObjectType(event->object.object)
            == glow_eObjectType_GrowTable
        || grow_GetObjectType(event->object.object)
            == glow_eObjectType_GrowXYCurve
        || grow_GetObjectType(event->object.object)
            == glow_eObjectType_GrowTrend
        || grow_GetObjectType(event->object.object) == glow_eObjectType_GrowPie
        || grow_GetObjectType(event->object.object)
            == glow_eObjectType_GrowBarChart
        || grow_GetObjectType(event->object.object) == glow_eObjectType_GrowAxis
        || grow_GetObjectType(event->object.object)
            == glow_eObjectType_GrowAxisArc) {
      grow_GetUserData(event->object.object, (void**)&dyn);
      if (dyn) {
        sts = dyn->action(event->object.object, event);
        if (sts == GLOW__TERMINATED)
          return sts;
        else if (sts == GLOW__SUBTERMINATED || sts == GLOW__SWAPTERMINATED) {
          if (ctx_popped)
            graph->grow->push();
          return sts;
        }
      }
    }
    break;
  }
  case glow_eEvent_MB1DoubleClick: {
    if (event->object.object_type == glow_eObjectType_NoObject)
      break;
    if (grow_GetObjectType(event->object.object) == glow_eObjectType_GrowNode
        || grow_GetObjectType(event->object.object)
            == glow_eObjectType_GrowGroup) {
      GeDyn* dyn;

      grow_GetUserData(event->object.object, (void**)&dyn);
      dyn->action(event->object.object, event);
    }
    break;
  }
  case glow_eEvent_MB1DoubleClickCtrl: {
    break;
  }
  case glow_eEvent_AnnotationInput: {
    GeDyn* dyn;

    grow_GetUserData(event->annot_input.object, (void**)&dyn);
    dyn->action(event->annot_input.object, event);

    break;
  }
  case glow_eEvent_InputFocusLost:
  case glow_eEvent_InputFocusGained: {
    GeDyn* dyn;

    grow_GetUserData(event->object.object, (void**)&dyn);
    dyn->action(event->object.object, event);

    break;
  }
  case glow_eEvent_Key_Left:
  case glow_eEvent_Key_Right:
  case glow_eEvent_Key_Up:
  case glow_eEvent_Key_Down:
  case glow_eEvent_Key_Return: {
    GeDyn* dyn;

    if (!(event->object.object_type == glow_eObjectType_NoObject)) {
      grow_GetUserData(event->object.object, (void**)&dyn);
      dyn->action(event->object.object, event);
    }
    break;
  }
  case glow_eEvent_Key_Tab:
  case glow_eEvent_Key_ShiftTab:
  case glow_eEvent_Key_Escape:
  case glow_eEvent_InputFocusInit: {
    GeDyn* dyn;

    if (event->object.object_type == glow_eObjectType_NoObject) {
      grow_tObject* objectlist;
      int object_cnt;
      int new_object_cnt;
      int i;

      grow_GetObjectList(graph->grow->ctx, &objectlist, &object_cnt);
      for (i = 0; i < object_cnt; i++) {
        if (grow_GetObjectType(objectlist[i]) == glow_eObjectType_GrowNode
            || grow_GetObjectType(objectlist[i]) == glow_eObjectType_GrowSlider
            || grow_GetObjectType(objectlist[i]) == glow_eObjectType_GrowGroup
            || grow_GetObjectType(objectlist[i]) == glow_eObjectType_GrowToolbar
            || grow_GetObjectType(objectlist[i])
                == glow_eObjectType_GrowWindow) {
          grow_GetUserData(objectlist[i], (void**)&dyn);
          dyn->action(objectlist[i], event);

          // Check if anything is deleted
          grow_GetObjectList(graph->grow->ctx, &objectlist, &new_object_cnt);
          if (new_object_cnt != object_cnt)
            break;
        }
      }
    } else {
      grow_GetUserData(event->object.object, (void**)&dyn);
      dyn->action(event->object.object, event);
    }
    break;
  }

  case glow_eEvent_Key_CtrlAscii: {
    if (event->key.ascii == 23) {
      // Ctrl W, close graph
      if (graph->close_cb) {
        if ((graph->close_cb)(graph->parent_ctx))
          return GLOW__TERMINATED;
      }
    }
    if (event->object.object_type != glow_eObjectType_NoObject) {
      GeDyn* dyn;

      grow_GetUserData(event->object.object, (void**)&dyn);
      dyn->action(event->object.object, event);
    }
    break;
  }

  case glow_eEvent_MenuActivated:
  case glow_eEvent_MenuCreate:
  case glow_eEvent_MenuDelete: {
    grow_tObject* objectlist;
    int object_cnt;
    int new_object_cnt;
    int i;
    GeDyn* dyn;
    int sts;

    grow_GetObjectList(graph->grow->ctx, &objectlist, &object_cnt);
    for (i = 0; i < object_cnt; i++) {
      if (grow_GetObjectType(objectlist[i]) == glow_eObjectType_GrowNode
          || grow_GetObjectType(objectlist[i]) == glow_eObjectType_GrowGroup
          || grow_GetObjectType(objectlist[i]) == glow_eObjectType_GrowToolbar
          || grow_GetObjectType(objectlist[i]) == glow_eObjectType_GrowDashCell) {

	if (grow_GetObjectType(objectlist[i]) != glow_eObjectType_GrowDashCell) {
	  grow_GetUserData(objectlist[i], (void**)&dyn);
	  sts = dyn->action(objectlist[i], event);
	  if (sts == GLOW__TERMINATED)
	    return sts;
	}

	if (grow_GetObjectType(objectlist[i]) == glow_eObjectType_GrowGroup ||
	    grow_GetObjectType(objectlist[i]) == glow_eObjectType_GrowDashCell) {
	  grow_tObject* gobjectlist;
	  int gobject_cnt, gnew_object_cnt;
	  int j;

	  grow_GetGroupObjectList(objectlist[i], &gobjectlist, &gobject_cnt);

	  for (j = 0; j < gobject_cnt; j++) {
	    if (grow_GetObjectType(gobjectlist[j]) == glow_eObjectType_GrowNode
		|| grow_GetObjectType(gobjectlist[j]) == glow_eObjectType_GrowGroup
		|| grow_GetObjectType(gobjectlist[j])
		== glow_eObjectType_GrowToolbar) {
	      grow_GetUserData(gobjectlist[j], (void**)&dyn);
	      sts = dyn->action(gobjectlist[j], event);
	      if (sts == GLOW__TERMINATED)
		return sts;

	      // Check if anything is deleted
	      grow_GetGroupObjectList(objectlist[i], &gobjectlist, &gnew_object_cnt);
	      if (gnew_object_cnt != gobject_cnt)
		break;
	    }
	  }
	}

        // Check if anything is deleted
        grow_GetObjectList(graph->grow->ctx, &objectlist, &new_object_cnt);
        if (new_object_cnt != object_cnt)
	  break;
      }
    }
    break;
  }

  case glow_eEvent_Translate: {
    char new_text[200];
    int sts;

    sts = Lng::translate(event->translate.text, new_text);
    if (sts)
      event->translate.new_text = new_text;
    if (ctx_popped)
      graph->grow->push();
    return sts;
  }
  case glow_eEvent_GrowDynamics:
    graph->exec_dynamic(event->dynamics.object, event->dynamics.code,
        event->dynamics.dynamic_type);
    break;
  case glow_eEvent_Signal: {
    if (event->signal.object_type == glow_eObjectType_NoObject)
      break;
    if (grow_GetObjectType(event->signal.object) == glow_eObjectType_GrowNode
        || grow_GetObjectType(event->signal.object)
            == glow_eObjectType_GrowGroup) {
      GeDyn* dyn;
      int sts;

      grow_GetUserData(event->signal.object, (void**)&dyn);
      sts = dyn->action(event->signal.object, event);
      if (sts == GLOW__TERMINATED)
        return GLOW__NO_PROPAGATE;
      else if (sts == GLOW__SUBTERMINATED || sts == GLOW__SWAPTERMINATED) {
        if (ctx_popped)
          graph->grow->push();
        return GLOW__NO_PROPAGATE;
      }
    }
    break;
  }
  default:;
  }

  if (ctx_popped)
    graph->grow->push();
  return 1;
}

void Graph::confirm_ok(grow_tObject object)
{
  GeDyn* dyn;
  glow_sEvent event;

  grow_GetUserData(object, (void**)&dyn);
  event.event = glow_eEvent_MB1Click;
  if (dyn->total_action_type1 & ge_mActionType1_ValueInput)
    dyn->change_value(object, confirm_text);
  else
    dyn->confirmed_action(object, &event);
}

void Graph::connect(grow_tObject object, char* attr_name, int second)
{
  GeDyn* dyn;
  char* s;
  pwr_tAName name;

  if ((s = strstr(attr_name, "-Template.")) != 0) {
    // This is a class graph, replace the template object with '$object'

    strcpy(name, "$object.");
    strcat(name, s + strlen("-Template."));
  } else
    strcpy(name, attr_name);

  if (grow_GetObjectType(object) == glow_eObjectType_GrowDashCell) {
    GeDash* dash;

    grow_GetUserData(object, (void**)&dash);
    if (dash)
      dash->set_attribute(object, name, second);
    else
      message('E', "No dynamics for this object");
  } else {  
    grow_GetUserData(object, (void**)&dyn);
    if (dyn)
      dyn->set_attribute(object, name, second);
    else
      message('E', "No dynamics for this object");
  }
}

int Graph::set_object_focus(const char* name, int empty)
{
  int dyn_type1;
  int action_type1;
  int sts;
  grow_tObject object;
  GeDyn* dyn;

  if (!name) {
    // Remove focus
    grow_ResetInputFocusAll(grow->ctx);
  } else {
    // Set focus
    if (!change_value_cb)
      return 0;

    sts = grow_FindObjectByName(grow->base_ctx(), name, &object);
    if (EVEN(sts))
      return GE__OBJNOTFOUND;

    grow_GetUserData(object, (void**)&dyn);
    if (!dyn)
      return 0;

    dyn_type1 = dyn->get_dyntype1(object);
    action_type1 = dyn->get_actiontype1(object);

    if (!is_authorized(dyn->access))
      return GE__NOACCESS;

    if (action_type1 & ge_mActionType1_InputFocus
        || action_type1 & ge_mActionType1_ValueInput)
      grow_SetObjectInputFocus(object, 1, glow_eEvent_Null);
  }
  return GE__SUCCESS;
}

int Graph::set_folder_index(const char* name, int idx)
{
  int sts;
  grow_tObject object;

  sts = grow_FindObjectByName(grow->ctx, name, &object);
  if (EVEN(sts))
    return GE__OBJNOTFOUND;

  if (grow_GetObjectType(object) != glow_eObjectType_GrowFolder)
    return 0;

  return grow_SetFolderIndex(object, idx);
}

int Graph::set_subwindow_source(const char* name, char* source, char* owner)
{
  int sts;
  grow_tObject object;
  GrowCtx* ctx;
  bool remove_self = false;

  ctx = grow->ctx;
  grow->push(); // If command executed from a subwindow

  sts = grow_FindObjectByName(grow->ctx, name, &object);
  if (EVEN(sts))
    return GE__OBJNOTFOUND;

  if (grow_GetObjectType(object) != glow_eObjectType_GrowWindow)
    return 0;

  if ( grow_GetWindowCtx(object) == ctx)
    remove_self = true;

  grow_EnableEvent(grow->ctx, glow_eEvent_Translate, glow_eEventType_CallBack,
      graph_grow_cb);

  sts = grow_SetWindowSource(object, source, owner);

  grow_DisableEvent(grow->ctx, glow_eEvent_Translate);

  if (ctx != grow->ctx) {
    if ( remove_self)
      ctx = 0; // Should not be used!!
    grow->pop(ctx);
  }

  if (remove_self)
    return GLOW__SUBTERMINATED;
  return 1;
}

int Graph::sound(pwr_tAttrRef* aref)
{
  if (sound_cb)
    (sound_cb)(parent_ctx, aref);
  return 1;
}

int Graph::export_plcfo(char* filename)
{
  return grow_ExportFlow(grow->ctx, filename);
}

void Graph::get_command(char* in, char* out, GeDyn* dyn)
{
  char *s, *t0;
  char* s0 = in;
  char str[500];
  bool object_found = false;

  pwr_tAName oname[4];
  if (grow->stack_cnt == 0) {
    for (int i = 0; i < 4; i++)
      strcpy(oname[i], object_name[i]);
  } else {
    grow_GetOwner(grow->ctx, oname[0]);

    if (!streq(object_name[0], "")) {
      pwr_tOName n;
      t0 = n;
      s0 = oname[0];
      while ((s = strstr(s0, "$object"))) {
        strncpy(t0, s0, s - s0);
        t0 += s - s0;
        strcpy(t0, object_name[0]);
        t0 += strlen(object_name[0]);
        s0 = s + strlen("$object");
      }
      str_Strcpy(t0, s0);
      strcpy(oname[0], n);
    }
    for (int i = 1; i < 4; i++)
      strcpy(oname[i], object_name[i]);
  }
  s0 = in;
  if (dyn && (dyn->total_dyn_type1 & ge_mDynType1_HostObject
                 || !streq(dyn->recursive_hostobject, ""))) {
    pwr_tAName hostobject;

    dyn->get_hostobject(hostobject);

    t0 = str;
    s0 = in;
    while ((s = strstr(s0, "$hostobject"))) {
      str_Strncpy(t0, s0, s - s0);
      t0 += s - s0;
      strcpy(t0, hostobject);
      t0 += strlen(hostobject);
      s0 = s + strlen("$hostobject");
    }
    str_Strcpy(t0, s0);

    if (streq(oname[0], "")) {
      strcpy(out, str);
    }
    s0 = str;
  } else if (streq(oname[0], "")) {
    str_Strcpy(out, in);
  }

  if (!streq(oname[0], "")) {
    t0 = out;
    while ((s = strstr(s0, "$object"))) {
      int idx;
      object_found = true;
      char* sidx = s + strlen("$object");
      switch (*sidx) {
      case '2':
        idx = 1;
        break;
      case '3':
        idx = 2;
        break;
      case '4':
        idx = 3;
        break;
      default:
        idx = 0;
      }

      str_Strncpy(t0, s0, s - s0);
      t0 += s - s0;
      strcpy(t0, oname[idx]);
      t0 += strlen(oname[idx]);
      s0 = s + strlen("$object") + (idx > 0 ? 1 : 0);
    }
    str_Strcpy(t0, s0);

    t0 = out;
  }
  if ((s = strchr(out, '&')) && *(s + 1) == '(') {
    // Replace attribute in parenthesis with its value
    if (*(s + 2) == '&' && *(s + 3) == '(') {
      pwr_tAName refname;
      pwr_sAttrRef aref;
      pwr_tStatus sts;
      char *start, *end, *start2;
      pwr_tTid atid;
      pwr_tUInt32 asize;

      start = s;
      strcpy(refname, s + 4);
      if ((s = strchr(refname, ')')) == 0)
        return;

      *s = 0;
      end = start + strlen(refname) + 5;
      start2 = s + 1;
      sts = gdh_GetObjectInfo(refname, &aref, sizeof(aref));
      if (EVEN(sts))
        return;

      sts = gdh_AttrrefToName(&aref, str, sizeof(str), cdh_mName_volumeStrict);
      if (EVEN(sts))
        return;

      if ((s = strchr(start2, ')')) == 0)
        return;

      *s = 0;
      end = start2 + strlen(start2) + 1;
      strncat(str, start2, sizeof(str) - strlen(str) - 1);
      strcpy(refname, str);

      sts = gdh_GetAttributeCharacteristics(refname, &atid, &asize, 0, 0);
      if (EVEN(sts))
        return;

      switch (atid) {
      case pwr_eType_AttrRef: {
        pwr_tAttrRef aref;

        sts = gdh_GetObjectInfo(refname, &aref, sizeof(aref));
        if (EVEN(sts))
          return;

        sts = gdh_AttrrefToName(
            &aref, str, sizeof(str), cdh_mName_volumeStrict);
        if (EVEN(sts))
          return;
        break;
      }
      case pwr_eType_Objid: {
        pwr_tOid oid;

        sts = gdh_GetObjectInfo(refname, &oid, sizeof(oid));
        if (EVEN(sts))
          return;

        sts = gdh_ObjidToName(oid, str, sizeof(str), cdh_mName_volumeStrict);
        if (EVEN(sts))
          return;
        break;
      }
      case pwr_eType_String: {
        sts = gdh_GetObjectInfo(refname, str, sizeof(str));
        if (EVEN(sts))
          return;

        break;
      }
      default:
        return;
      }
      strcat(str, end);
      strcpy(start, str);
    } else {
      pwr_tAName refname;
      pwr_tStatus sts;
      char *start, *end;
      pwr_tTid atid;
      pwr_tUInt32 asize;

      start = s;
      strcpy(refname, s + 2);
      if ((s = strchr(refname, ')')) == 0)
        return;

      *s = 0;
      end = start + strlen(refname) + 3;

      sts = gdh_GetAttributeCharacteristics(refname, &atid, &asize, 0, 0);
      if (EVEN(sts))
        return;

      switch (atid) {
      case pwr_eType_AttrRef: {
        pwr_tAttrRef aref;

        sts = gdh_GetObjectInfo(refname, &aref, sizeof(aref));
        if (EVEN(sts))
          return;

        sts = gdh_AttrrefToName(
            &aref, str, sizeof(str), cdh_mName_volumeStrict);
        if (EVEN(sts))
          return;
        break;
      }
      case pwr_eType_Objid: {
        pwr_tOid oid;

        sts = gdh_GetObjectInfo(refname, &oid, sizeof(oid));
        if (EVEN(sts))
          return;

        sts = gdh_ObjidToName(oid, str, sizeof(str), cdh_mName_volumeStrict);
        if (EVEN(sts))
          return;
        break;
      }
      case pwr_eType_String: {
        sts = gdh_GetObjectInfo(refname, str, sizeof(str));
        if (EVEN(sts))
          return;

        break;
      }
      default:
        return;
      }

      strcat(str, end);
      strcpy(start, str);
    }
  }

  // Translate index variable
  for (int i = 0; i < 2; i++) {
    if ((s = strstr(out, "[&("))) {
      int idx;
      pwr_tAName iname, rest;
      pwr_tStatus sts;
      int len;
      char* s1;

      s++;
      strcpy(iname, s + 2);
      s1 = strchr(iname, ')');
      strncpy(rest, s1 + 1, sizeof(rest));
      if (s1) {
        *s1 = 0;
        sts = gdh_GetObjectInfo(iname, &idx, sizeof(idx));
        if (ODD(sts) && idx >= 0 && idx <= 100) {
          len = sprintf(s, "%d", idx);
          strcpy(s + len, rest);
        }
      } else
        break;
    } else
      break;
  }

  if (object_found) {
    for (int i = 0; i < 4; i++) {
      // Remove attribute before
      if ((s = strstr(out, ".<"))) {
        pwr_tAName rest;

        strcpy(rest, s + 2);
        for (s--; s >= out; s--) {
          if (*s == '.') {
            strcpy(s, rest);
            break;
          }
        }
      } else
        break;
      if (s == out)
        break;
    }

    for (int i = 0; i < 4; i++) {
      // Remove segment name before
      if ((s = strstr(out, "-<"))) {
        pwr_tAName rest;

        strcpy(rest, s + 2);
        for (s--; s >= out; s--) {
          if (*s == '-') {
            strcpy(s, rest);
            break;
          }
        }
      } else
        break;
      if (s == out)
        break;
    }
  }
}

int Graph::get_refupdate(char* in, pwr_tAName ref[], pwr_tTid ref_tid[],
    int ref_size[], int* ref_cnt, pwr_tAName idx_ref[], pwr_tTid idx_ref_tid[],
    int idx_ref_size[], int* idx_ref_cnt, GeDyn* dyn)
{
  char *s, *t0;
  char* s0 = in;
  char str[500];
  bool object_found = false;
  char out[512];

  *ref_cnt = 0;
  *idx_ref_cnt = 0;

  pwr_tAName oname[4];
  if (grow->stack_cnt == 0) {
    for (int i = 0; i < 4; i++)
      strcpy(oname[i], object_name[i]);
  } else {
    grow_GetOwner(grow->ctx, oname[0]);

    if (!streq(object_name[0], "")) {
      pwr_tOName n;
      t0 = n;
      s0 = oname[0];
      while ((s = strstr(s0, "$object"))) {
        strncpy(t0, s0, s - s0);
        t0 += s - s0;
        strcpy(t0, object_name[0]);
        t0 += strlen(object_name[0]);
        s0 = s + strlen("$object");
      }
      str_Strcpy(t0, s0);
      strcpy(oname[0], n);
    }
    for (int i = 1; i < 4; i++)
      strcpy(oname[i], object_name[i]);
  }
  s0 = in;
  if (dyn && (dyn->total_dyn_type1 & ge_mDynType1_HostObject
                 || !streq(dyn->recursive_hostobject, ""))) {
    pwr_tAName hostobject;

    dyn->get_hostobject(hostobject);

    t0 = str;
    s0 = in;
    while ((s = strstr(s0, "$hostobject"))) {
      str_Strncpy(t0, s0, s - s0);
      t0 += s - s0;
      strcpy(t0, hostobject);
      t0 += strlen(hostobject);
      s0 = s + strlen("$hostobject");
    }
    str_Strcpy(t0, s0);

    if (streq(oname[0], "")) {
      strcpy(out, str);
    }
    s0 = str;
  } else if (streq(oname[0], "")) {
    str_Strcpy(out, in);
  }

  if (!streq(oname[0], "")) {
    t0 = out;
    while ((s = strstr(s0, "$object"))) {
      int idx;
      object_found = true;
      char* sidx = s + strlen("$object");
      switch (*sidx) {
      case '2':
        idx = 1;
        break;
      case '3':
        idx = 2;
        break;
      case '4':
        idx = 3;
        break;
      default:
        idx = 0;
      }

      str_Strncpy(t0, s0, s - s0);
      t0 += s - s0;
      strcpy(t0, oname[idx]);
      t0 += strlen(oname[idx]);
      s0 = s + strlen("$object") + (idx > 0 ? 1 : 0);
    }
    str_Strcpy(t0, s0);

    t0 = out;
  }

  // Get index variables and replace
  for (int i = 0; i < 2; i++) {
    if ((s = strstr(out, "[&("))) {
      int idx;
      pwr_tAName iname, rest;
      pwr_tStatus sts;
      int len;
      char* s1;

      s++;
      strcpy(iname, s + 2);
      s1 = strchr(iname, ')');
      strncpy(rest, s1 + 1, sizeof(rest));
      if (!s1)
        return GE__SYNTAX;
      *s1 = 0;

      sts = gdh_GetObjectInfo(iname, &idx, sizeof(idx));
      if (ODD(sts) && idx >= 0 && idx <= 100) {
        len = sprintf(s, "%d", idx);
        strcpy(s + len, rest);
      }
      strcpy(idx_ref[*idx_ref_cnt], iname);
      idx_ref_size[*ref_cnt] = sizeof(pwr_tInt32);
      idx_ref_tid[*ref_cnt] = pwr_eType_Int32;
      (*idx_ref_cnt)++;
    } else
      break;
  }

  // Get references
  if ((s = strchr(out, '&')) && *(s + 1) == '(') {
    // Replace attribute in parenthesis with its value
    if (*(s + 2) == '&' && *(s + 3) == '(') {
      pwr_tAName refname;
      pwr_tStatus sts;
      char *start, *end, *start2;
      pwr_tTid atid;
      pwr_tUInt32 asize;

      start = s;
      strcpy(refname, s + 4);
      if ((s = strchr(refname, ')')) == 0)
        return GE__SYNTAX;

      *s = 0;

      sts = gdh_GetAttributeCharacteristics(refname, &atid, &asize, 0, 0);
      if (EVEN(sts))
        return sts;

      strcpy(ref[*ref_cnt], refname);
      ref_tid[*ref_cnt] = atid;
      ref_size[*ref_cnt] = asize;
      (*ref_cnt)++;

      end = start + strlen(refname) + 5;
      start2 = s + 1;
      switch (atid) {
      case pwr_eType_AttrRef: {
        pwr_tAttrRef aref;

        sts = gdh_GetObjectInfo(refname, &aref, sizeof(aref));
        if (EVEN(sts))
          return sts;

        sts = gdh_AttrrefToName(
            &aref, str, sizeof(str), cdh_mName_volumeStrict);
        if (EVEN(sts))
          return sts;
        break;
      }
      case pwr_eType_DataRef: {
        pwr_tDataRef dref;

        sts = gdh_GetObjectInfo(refname, &dref, sizeof(dref));
        if (EVEN(sts))
          return sts;

        sts = gdh_AttrrefToName(
            &dref.Aref, str, sizeof(str), cdh_mName_volumeStrict);
        if (EVEN(sts))
          return sts;
        break;
      }
      case pwr_eType_Objid: {
        pwr_tOid oid;

        sts = gdh_GetObjectInfo(refname, &oid, sizeof(oid));
        if (EVEN(sts))
          return sts;

        sts = gdh_ObjidToName(oid, str, sizeof(str), cdh_mName_volumeStrict);
        if (EVEN(sts))
          return sts;
        break;
      }
      default:
        return GE__NOREF;
      }

      if ((s = strchr(start2, ')')) == 0)
        return GE__SYNTAX;

      *s = 0;
      end = start2 + strlen(start2) + 1;
      strncat(str, start2, sizeof(str) - strlen(str) - 1);
      strcpy(refname, str);

      sts = gdh_GetAttributeCharacteristics(refname, &atid, &asize, 0, 0);
      if (EVEN(sts))
        return sts;

      strcpy(ref[*ref_cnt], refname);
      ref_tid[*ref_cnt] = atid;
      ref_size[*ref_cnt] = asize;
      (*ref_cnt)++;

    } else {
      pwr_tAName refname;
      pwr_tStatus sts;
      char *start, *end;
      pwr_tTid atid;
      pwr_tUInt32 asize;

      start = s;
      strcpy(refname, s + 2);
      if ((s = strchr(refname, ')')) == 0)
        return GE__SYNTAX;

      *s = 0;
      end = start + strlen(refname) + 3;

      sts = gdh_GetAttributeCharacteristics(refname, &atid, &asize, 0, 0);
      if (EVEN(sts))
        return sts;

      strcpy(ref[*ref_cnt], refname);
      ref_size[*ref_cnt] = asize;
      ref_tid[*ref_cnt] = atid;
      (*ref_cnt)++;
    }
  }

  return GE__SUCCESS;
}

graph_eDatabase Graph::parse_attr_name(char* name, char* parsed_name,
    int* inverted, int* type, int* size, int* elem, graph_mParseOpt options)
{
  pwr_tAName str;
  pwr_tAName str1;
  char *s, *s1;
  int elements = 0;

  str_trim(str, name);

  if ((s = strstr(str, "$user"))) {
    if ((s = strchr(str, '#'))) {
      if (streq(s, "##Float32")) {
        *type = pwr_eType_Float32;
        *size = sizeof(pwr_tFloat32);
      } else if (streq(s, "##Float64")) {
        *type = pwr_eType_Float64;
        *size = sizeof(pwr_tFloat64);
      } else if (streq(s, "##Int32")) {
        *type = pwr_eType_Int32;
        *size = sizeof(pwr_tInt32);
      } else if (streq(s, "##Boolean")) {
        *type = pwr_eType_Boolean;
        *size = sizeof(pwr_tBoolean);
      } else {
        *type = pwr_eType_String;
        *size = 80;
      }
      *s = 0;
    }
    if (str[0] == '!') {
      *inverted = 1;
      str_trim(str, &str[1]);
    } else
      *inverted = 0;
    strcpy(parsed_name, str);

    return graph_eDatabase_User;
  }
  if ((s = strstr(str, "$local."))) {
    strcpy(parsed_name, s + strlen("$local."));
    if ((s = strchr(parsed_name, '#'))) {
      if (streq(s, "##Float32")) {
        *type = pwr_eType_Float32;
        *size = sizeof(pwr_tFloat32);
      } else if (streq(s, "##Float64")) {
        *type = pwr_eType_Float64;
        *size = sizeof(pwr_tFloat64);
      } else if (streq(s, "##Int32")) {
        *type = pwr_eType_Int32;
        *size = sizeof(pwr_tInt32);
      } else if (streq(s, "##Boolean")) {
        *type = pwr_eType_Boolean;
        *size = sizeof(pwr_tBoolean);
      } else {
        *type = pwr_eType_String;
        *size = 80;
      }
      *s = 0;
    }
    if (str[0] == '!') {
      *inverted = 1;
      str_trim(str, &str[1]);
    } else
      *inverted = 0;

    if (grow->stack_cnt) {
      // Add suffix to make name unique for subwindow context
      char owner[256];

      grow_GetOwner(grow->ctx, owner);
      if (!streq(owner, "")) {
        strcat(parsed_name, "-");
        strcat(parsed_name, owner);
      }
    }

    return graph_eDatabase_Local;
  }
  if ((s = strstr(str, "$ccm."))) {
    strcpy(parsed_name, s + strlen("$ccm."));
    if ((s = strchr(parsed_name, '#'))) {
      if (streq(s, "##Float32")) {
        *type = pwr_eType_Float32;
        *size = sizeof(pwr_tFloat32);
      } else if (streq(s, "##Int32")) {
        *type = pwr_eType_Int32;
        *size = sizeof(pwr_tInt32);
      } else if (streq(s, "##Boolean")) {
        *type = pwr_eType_Boolean;
        *size = sizeof(pwr_tBoolean);
      } else {
        *type = pwr_eType_String;
        *size = 400;
      }
      *s = 0;
    }
    if (str[0] == '!') {
      *inverted = 1;
      str_trim(str, &str[1]);
    } else
      *inverted = 0;

    return graph_eDatabase_Ccm;
  }

  for (int i = 0; i < 4; i++) {
    if ((s = strstr(str, "$object"))) {
      pwr_tAName oname[4];
      for (int i = 1; i < 4; i++)
        strcpy(oname[i], object_name[i]);
      if (grow->stack_cnt == 0)
        strcpy(oname[0], object_name[0]);
      else {
        grow_GetOwner(grow->ctx, oname[0]);

        // Replace $object in oname (one level only)
        char* s1;
        if ((s1 = strstr(oname[0], "$object"))) {
          strcpy(str1, s1 + strlen("$object"));
          strcpy(s1, object_name[0]);
          strcat(oname[0], str1);
        }
      }

      int idx;
      char* sidx = s + strlen("$object");
      switch (*sidx) {
      case '2':
        idx = 1;
        break;
      case '3':
        idx = 2;
        break;
      case '4':
        idx = 3;
        break;
      default:
        idx = 0;
      }
      strcpy(str1, s + strlen("$object") + (idx > 0 ? 1 : 0));
      strcpy(s, oname[idx]);
      strcat(str, str1);
    } else
      break;
  }

  if (!(options & graph_mParseOpt_KeepIndex)) {
    // Translate index variable
    for (int i = 0; i < 2; i++) {
      if ((s = strstr(str, "[&("))) {
        int idx;
        pwr_tAName iname, rest;
        pwr_tStatus sts;
        int len;

        s++;
        strcpy(iname, s + 2);
        s1 = strchr(iname, ')');
        strncpy(rest, s1 + 1, sizeof(rest));
        if (s1) {
          *s1 = 0;
          sts = gdh_GetObjectInfo(iname, &idx, sizeof(idx));
          if (ODD(sts) && idx >= 0 && idx <= 100) {
            len = sprintf(s, "%d", idx);
            strcpy(s + len, rest);
          }
        } else
          break;
      } else
        break;
    }
  }

  for (int i = 0; i < 4; i++) {
    // Remove attribute before
    if ((s = strstr(str, ".<"))) {
      pwr_tAName rest;

      strcpy(rest, s + 2);
      for (s--; s >= str; s--) {
        if (*s == '.') {
          strcpy(s, rest);
          break;
        }
      }
    } else
      break;
    if (s == str)
      break;
  }

  for (int i = 0; i < 4; i++) {
    // Remove segment name before
    if ((s = strstr(str, "-<"))) {
      pwr_tAName rest;

      strcpy(rest, s + 2);
      for (s--; s >= str; s--) {
        if (*s == '-') {
          strcpy(s, rest);
          break;
        }
      }
    } else
      break;
    if (s == str)
      break;
  }

  if (((s = strstr(str, "$node")) || (s = strstr(str, "$NODE")))
      && mode != graph_eMode_Development) {
    char nodename[80];
    pwr_tOid oid;
    pwr_tStatus sts;

    if (!streq(object_name[0], "")) {
      sts = gdh_NameToObjid(object_name[0], &oid);
      if (ODD(sts))
        sts = gdh_GetNodeObject(oid.vid, &oid);
    } else
      sts = gdh_GetNodeObject(0, &oid);
    if (ODD(sts)) {
      sts = gdh_ObjidToName(
          oid, nodename, sizeof(nodename), cdh_mName_pathStrict);
      if (ODD(sts)) {
        strcpy(str1, s + strlen("$node"));
        strcpy(s, nodename);
        strcat(str, str1);
      }
    }
  }

  if ((s = strstr(str, "##")))
    string_to_type(s + 2, (pwr_eType*)type, size, &elements);
  else {
    *type = pwr_eType__;
    *size = 0;
  }

  if ((s = strchr(str, '#'))) {
    *s = 0;
    if ((s1 = strchr(s + 1, '[')))
      strcat(str, s1);
  }

  if (str[0] == '!') {
    *inverted = 1;
    str_trim(str, &str[1]);
    strcpy(parsed_name, str);
  } else {
    *inverted = 0;
    strcpy(parsed_name, str);
  }
  if (elem)
    *elem = elements;
  return graph_eDatabase_Gdh;
}

int Graph::type_to_string(pwr_eType type, char* type_buf, int* size)
{
  int i;

  for (i = 0; i < int(sizeof(graph_type_table) / sizeof(graph_type_table[0]));
       i++) {
    if (graph_type_table[i].Type == type) {
      strcpy(type_buf, graph_type_table[i].TypeStr);
      if (size)
        *size = graph_type_table[i].Size;
      return 1;
    }
  }

  if (type == pwr_eType_String) {
    strcpy(type_buf, "String");
    if (size)
      *size = 1; /* This is not the real size */
    return 1;
  }
  return 0;
}

void Graph::string_to_type(
    char* type_str, pwr_eType* type, int* size, int* elements)
{
  int i;
  int found;
  char str[80];
  char table_str[20];
  char *s, *s1;
  str_ToUpper(str, type_str);

  // Check if there is a array size
  if ((s = strchr(str, '#'))) {
    if (!(s1 = strchr(s + 1, '[')))
      *elements = atoi(s + 1);
    else
      *elements = 1;
    *s = 0;
  } else
    *elements = 1;

  // Default to float
  *type = (pwr_eType)0;
  *size = 4;

  found = 0;
  for (i = 0; i < int(sizeof(graph_type_table) / sizeof(graph_type_table[0]));
       i++) {
    str_ToUpper(table_str, (char*)graph_type_table[i].TypeStr);
    if (streq(table_str, str)) {
      *size = graph_type_table[i].Size;
      *type = graph_type_table[i].Type;
      found = 1;
      break;
    }
  }

  if (!found && str_StartsWith(str, "STRING")) {
    *type = pwr_eType_String;
    if (*(str + 6) == 0)
      *size = 80;
    else
      *size = atoi(str + 6);
  } else if (!found && str_StartsWith(str, "TEXT")) {
    *type = pwr_eType_Text;
    if (*(str + 4) == 0)
      *size = 80;
    else
      *size = atoi(str + 4);
  } else if (!found && str_StartsWith(str, "BIT")) {
    *type = (pwr_eType)graph_eType_Bit;
    *size = 4;
  }

  if (*elements > 1)
    *size *= *elements;
}

void Graph::get_systemname(char* name)
{
  strcpy(name, systemname);
}

void Graph::set_systemname(char* name)
{
  strcpy(systemname, name);
}

int Graph::ccm_ref_variable(char* name, int type, void** data)
{
  int ccm_type;
  int sts;

  switch (type) {
  case pwr_eType_UInt32:
  case pwr_eType_Int32:
  case pwr_eType_Boolean:
    ccm_type = CCM_DECL_INT;
    break;
  case pwr_eType_Float32:
    ccm_type = CCM_DECL_FLOAT;
    break;
  case pwr_eType_String:
    ccm_type = CCM_DECL_STRING;
    break;
  default:
    return 0;
  }

  sts = ccm_ref_external_var(name, ccm_type, data);
  return sts;
}

int Graph::ccm_set_variable(char* name, int type, void* data)
{
  int ccm_type;
  int sts;

  switch (type) {
  case pwr_eType_UInt32:
  case pwr_eType_Int32:
  case pwr_eType_Boolean:
    ccm_type = CCM_DECL_INT;
    sts = ccm_set_external_var(name, ccm_type, 0, *(int*)data, 0);
    return sts;
  case pwr_eType_Float32:
    ccm_type = CCM_DECL_FLOAT;
    sts = ccm_set_external_var(name, ccm_type, *(float*)data, 0, 0);
    return sts;
  case pwr_eType_String:
    ccm_type = CCM_DECL_STRING;
    sts = ccm_set_external_var(name, ccm_type, 0, 0, (char*)data);
    return sts;
  default:
    return 0;
  }
}

int Graph::ccm_get_variable(char* name, int type, void* data)
{
  int ccm_type;
  int sts;

  switch (type) {
  case pwr_eType_UInt32:
  case pwr_eType_Int32:
  case pwr_eType_Boolean:
    ccm_type = CCM_DECL_INT;
    sts = ccm_get_external_var(name, ccm_type, 0, (ccm_tInt*)data, 0);
    return sts;
  case pwr_eType_Float32:
    ccm_type = CCM_DECL_FLOAT;
    sts = ccm_get_external_var(name, ccm_type, (ccm_tFloat*)data, 0, 0);
    return sts;
  case pwr_eType_String:
    ccm_type = CCM_DECL_STRING;
    sts = ccm_get_external_var(name, ccm_type, 0, 0, (char*)data);
    return sts;
  default:
    return 0;
  }
}

int Graph::get_reference_name(char* name, char* tname)
{
  pwr_tStatus sts;

  if (name[0] == '&') {
    // Name contains a reference, get the reference
    pwr_tAName refname;
    pwr_tAName aname;
    pwr_tAName refattrname = "";
    char* s;
    pwr_tTypeId atid;
    pwr_tUInt32 asize, aoffs, aelem;

    if (name[1] == '(') {
      strcpy(refname, &name[2]);
      if ((s = strrchr(refname, ')'))) {
        *s = 0;
        strcpy(refattrname, s + 1);
      }
    } else
      strcpy(refname, &name[1]);

    if (refname[0] == '&') {
      sts = get_reference_name(refname, refname);
      if (EVEN(sts))
        return sts;
    }

    sts = gdh_GetAttributeCharacteristics(
        refname, &atid, &asize, &aoffs, &aelem);
    if (EVEN(sts))
      return sts;

    if (asize == sizeof(pwr_tOid)) {
      // Reference is an objid
      pwr_tOid oid;

      sts = gdh_GetObjectInfo(refname, &oid, sizeof(oid));
      if (EVEN(sts))
        return sts;

      sts = gdh_ObjidToName(oid, aname, sizeof(aname), cdh_mName_volumeStrict);
      if (EVEN(sts))
        return sts;
    } else if (asize == sizeof(pwr_tDataRef)) {
      // Reference is an dataref
      pwr_tDataRef dataref;

      sts = gdh_GetObjectInfo(refname, &dataref, sizeof(dataref));
      if (EVEN(sts))
        return sts;

      sts = gdh_AttrrefToName(
          &dataref.Aref, aname, sizeof(aname), cdh_mName_volumeStrict);
      if (EVEN(sts))
        return sts;
    } else {
      // Reference is an attrref

      pwr_sAttrRef aref;
      sts = gdh_GetObjectInfo(refname, &aref, sizeof(aref));
      if (EVEN(sts))
        return sts;

      sts = gdh_AttrrefToName(
          &aref, aname, sizeof(aname), cdh_mName_volumeStrict);
      if (EVEN(sts))
        return sts;
    }
    strcat(aname, refattrname);
    strcpy(tname, aname);
  } else
    strcpy(tname, name);

  return 1;
}

int Graph::ref_object_info(glow_eCycle cycle, char* name, void** data,
    pwr_tSubid* subid, unsigned int size, grow_tObject object, bool now)
{
  pwr_tAName aname;
  pwr_tStatus sts;

  if (name[0] == '&') {
    sts = get_reference_name(name, aname);
    if (EVEN(sts))
      return sts;
  } else
    strcpy(aname, name);

  if (!now) {
    GraphRef gr(aname, subid, size, cycle, object, data);
    reflist.push_back(gr);
  } else {
    int dt;

    if (cycle == glow_eCycle_Fast)
      dt = int(fast_scan_time * 1000);
    else
      dt = int(scan_time * 1000);
    int tmo = int(MAX(2 * dt / 100, 25));
    gdh_SetSubscriptionDefaults(dt, tmo);

    return gdh_RefObjectInfo(aname, data, subid, size);
  }
  return GE__SUCCESS;
}

int Graph::ref_object_info_all()
{
  pwr_tStatus sts;
  int dt;
  int refcount[2] = { 0, 0 };
  glow_eCycle cycle[2] = { glow_eCycle_Slow, glow_eCycle_Fast };

  for (unsigned int i = 0; i < reflist.size(); i++) {
    if (reflist[i].m_cycle == cycle[0])
      refcount[0]++;
    else
      refcount[1]++;
  }

  for (int j = 0; j < 2; j++) {
    if (!refcount[j])
      continue;

    gdh_sObjRef* oref = (gdh_sObjRef*)calloc(refcount[j], sizeof(gdh_sObjRef));
    pwr_tRefId* refid = (pwr_tRefId*)calloc(refcount[j], sizeof(pwr_tRefId));

    int refcnt = 0;
    for (unsigned int i = 0; i < reflist.size(); i++) {
      if (reflist[i].m_cycle == cycle[j]) {
        strcpy(oref[refcnt].fullname, reflist[i].m_name);
        oref[refcnt].bufsize = reflist[i].m_size;
        refcnt++;
      }
    }
    if (cycle[j] == glow_eCycle_Fast)
      dt = int(fast_scan_time * 1000);
    else
      dt = int(scan_time * 1000);
    int tmo = int(MAX(2 * dt / 100, 25));
    gdh_SetSubscriptionDefaults(dt, tmo);

    sts = gdh_RefObjectInfoList(refcnt, oref, refid);
    if (EVEN(sts)) {
      printf("** Link error for local object\n");
    }

    refcnt = 0;
    for (unsigned int i = 0; i < reflist.size(); i++) {
      if (reflist[i].m_cycle == cycle[j]) {
        *reflist[i].m_data = oref[refcnt].adrs;
        *reflist[i].m_id = refid[refcnt];
        if (EVEN(sts) && cdh_RefIdIsNull(refid[refcnt])) {
          char oname[80] = "";
          if (reflist[i].m_object != 0)
            grow_GetObjectName(
                reflist[i].m_object, oname, sizeof(oname), glow_eName_Path);
          printf("** %s, %s\n", oname, reflist[i].m_name);
        }
        refcnt++;
      }
    }
    free(oref);
    free(refid);
  }
  reflist.clear();

  return GE__SUCCESS;
}

void Graph::create_trend(grow_tObject* object, double x, double y,
			 unsigned int dyn_type1, unsigned int dyn_type2, int colortheme)
{
  double width = 7;
  double height = 5;
  GeDyn* dyn;
  glow_sTrendInfo info;
  glow_eDrawType fcolor, bcolor;

  if (colortheme) {
    fcolor = glow_eCtColor_DiagramFillcolor;
    bcolor = glow_eCtColor_DiagramBordercolor;
  } else {
    fcolor = glow_eDrawType_Color40;
    bcolor = glow_eDrawType_Color37;
  }

  grow_CreateGrowTrend(grow->ctx, get_next_object_name("O", ""), x, y, width,
      height, bcolor, 1, glow_mDisplayLevel_1, 1, 1, fcolor, NULL, object);
  dyn = new GeDyn(this);
  dyn->dyn_type1 = dyn->total_dyn_type1 = (ge_mDynType1)dyn_type1;
  dyn->dyn_type2 = dyn->total_dyn_type2 = (ge_mDynType2)dyn_type2;
  dyn->update_elements();
  grow_SetUserData(*object, (void*)dyn);

  info.no_of_points = 100;
  info.scan_time = 0.5;
  info.fill_curve = 0;
  info.curve_width = 1;
  info.horizontal_lines = 4;
  info.vertical_lines = 4;
  info.y_min_value[0] = 0;
  info.y_min_value[1] = 0;
  info.y_max_value[0] = 100;
  info.y_max_value[1] = 100;
  if (colortheme) {
    info.curve_drawtype[0] = glow_eCtColor_DiagramCurveColor;
    info.curve_drawtype[1] = glow_eCtColor_OrangeCurve;
    info.curve_fill_drawtype[0] = glow_eCtColor_BarBarColor;
    info.curve_fill_drawtype[1] = glow_eCtColor_OrangeBar;
    info.mark1_color = glow_eCtColor_YellowCurve;
    info.mark2_color = glow_eCtColor_RedCurve;
  } else {
    info.curve_drawtype[0] = glow_eDrawType_Color145;
    info.curve_drawtype[1] = glow_eDrawType_Color295;
    info.curve_fill_drawtype[0] = glow_eDrawType_Color139;
    info.curve_fill_drawtype[1] = glow_eDrawType_Color289;
    info.mark1_color = glow_eDrawType_ColorYellow;
    info.mark2_color = glow_eDrawType_ColorRed;
  }
  grow_SetTrendInfo(*object, &info);

  grow_Redraw(grow->ctx);
}

void Graph::create_xycurve(
    grow_tObject* object, double x, double y, unsigned int dyn_type1, unsigned int dyn_type2, int colortheme)
{
  double width = 7;
  double height = 5;
  GeDyn* dyn;
  glow_sTrendInfo info;
  glow_eDrawType fcolor, bcolor;

  if (colortheme) {
    fcolor = glow_eCtColor_DiagramFillcolor;
    bcolor = glow_eCtColor_DiagramBordercolor;
  } else {
    fcolor = glow_eDrawType_Color40;
    bcolor = glow_eDrawType_Color37;
  }

  grow_CreateGrowXYCurve(grow->ctx, get_next_object_name("O", ""), x, y, width,
      height, bcolor, 1, glow_mDisplayLevel_1, 1, 1,
      fcolor, NULL, object);
  dyn = new GeDyn(this);
  dyn->dyn_type1 = dyn->total_dyn_type1 = (ge_mDynType1)dyn_type1;
  dyn->dyn_type2 = dyn->total_dyn_type2 = (ge_mDynType2)dyn_type2;
  dyn->update_elements();
  grow_SetUserData(*object, (void*)dyn);

  info.no_of_points = 100;
  info.scan_time = 0.5;
  info.fill_curve = 0;
  info.curve_width = 1;
  info.horizontal_lines = 4;
  info.vertical_lines = 4;
  info.y_min_value[0] = 0;
  info.y_min_value[1] = 0;
  info.y_max_value[0] = 100;
  info.y_max_value[1] = 100;
  if (colortheme) {
    info.curve_drawtype[0] = glow_eCtColor_DiagramCurveColor;
    info.curve_drawtype[1] = glow_eCtColor_OrangeCurve;
    info.curve_fill_drawtype[0] = glow_eCtColor_BarBarColor;
    info.curve_fill_drawtype[1] = glow_eCtColor_OrangeBar;
    info.mark1_color = glow_eCtColor_YellowCurve;
    info.mark2_color = glow_eCtColor_RedCurve;
  }
  else {
    info.curve_drawtype[0] = glow_eDrawType_Color145;
    info.curve_drawtype[1] = glow_eDrawType_Color295;
    info.curve_fill_drawtype[0] = glow_eDrawType_Color139;
    info.curve_fill_drawtype[1] = glow_eDrawType_Color289;
    info.mark1_color = glow_eDrawType_ColorYellow;
    info.mark2_color = glow_eDrawType_ColorRed;
  }
  grow_SetTrendInfo(*object, &info);

  grow_Redraw(grow->ctx);
}

void Graph::create_bar(grow_tObject* object, double x, double y, int colortheme)
{
  double width = 0.5;
  double height = 5;
  GeDyn* dyn;
  glow_sBarInfo info;
  glow_eDrawType backgroundcolor, barcolor, barbordercolor;

  if (colortheme) {
    backgroundcolor = glow_eCtColor_BarBackgroundColor;
    barcolor = glow_eCtColor_BarBarColor;
    barbordercolor = glow_eCtColor_BarBarLimitColor;
  } else {
    backgroundcolor = glow_eDrawType_Color40;
    barcolor = glow_eDrawType_Color147;
    barbordercolor = glow_eDrawType_Color145;
  }

  grow_CreateGrowBar(grow->ctx, get_next_object_name("O", ""), x, y, width,
      height, glow_eDrawType_Line, 1, glow_mDisplayLevel_1, 1, 1,
      backgroundcolor, NULL, object);
  dyn = new GeDyn(this);
  dyn->dyn_type1 = dyn->total_dyn_type1 = ge_mDynType1_Bar;
  dyn->update_elements();
  grow_SetUserData(*object, (void*)dyn);

  info.bar_drawtype = barcolor;
  info.bar_bordercolor = barbordercolor;
  info.bar_borderwidth = 1;
  info.max_value = 100;
  info.min_value = 0;
  grow_SetBarInfo(*object, &info);
  grow_Redraw(grow->ctx);
}

void Graph::create_bararc(grow_tObject* object, double x, double y, int colortheme)
{
  double width = 5;
  double height = 5;
  double bar_width = 1;
  GeDyn* dyn;
  glow_sBarInfo info;
  glow_eDrawType backgroundcolor, barcolor, barbordercolor;

  if (colortheme) {
    backgroundcolor = glow_eCtColor_BarBackgroundColor;
    barcolor = glow_eCtColor_BarBarColor;
    barbordercolor = glow_eCtColor_BarBarLimitColor;
  } else {
    backgroundcolor = glow_eDrawType_Color40;
    barcolor = glow_eDrawType_Color147;
    barbordercolor = glow_eDrawType_Color145;
  }

  grow_CreateGrowBarArc(grow->ctx, get_next_object_name("O", ""), x, y, x + width,
			y + height, 0, 360, bar_width, glow_eDrawType_Line, 1, 1,
			backgroundcolor, NULL, object);
  dyn = new GeDyn(this);
  dyn->dyn_type1 = dyn->total_dyn_type1 = ge_mDynType1_Bar;
  dyn->update_elements();
  grow_SetUserData(*object, (void*)dyn);

  info.bar_drawtype = barcolor;
  info.bar_bordercolor = barbordercolor;
  info.bar_borderwidth = 1;
  info.max_value = 100;
  info.min_value = 0;
  grow_SetBarArcInfo(*object, &info);
  grow_Redraw(grow->ctx);
}

void Graph::create_window(grow_tObject* object, double x, double y)
{
  double width = 8;
  double height = 6;
  GeDyn* dyn;

  grow_CreateGrowWindow(grow->ctx, get_next_object_name("O", ""), x, y, width,
      height, glow_eDrawType_Line, 1, glow_mDisplayLevel_1, NULL, object);
  dyn = new GeDyn(this);
  dyn->update_elements();
  grow_SetUserData(*object, (void*)dyn);

  grow_Redraw(grow->ctx);
}

void Graph::create_table(grow_tObject* object, double x, double y)
{
  double width = 8;
  double height = 6;
  GeDyn* dyn;

  grow_CreateGrowTable(grow->ctx, get_next_object_name("O", ""), x, y, width,
      height, glow_eDrawType_Line, 1, 1, glow_eDrawType_Color33,
      glow_mDisplayLevel_1, NULL, object);
  dyn = new GeDyn(this);
  dyn->dyn_type1 = dyn->total_dyn_type1 = ge_mDynType1_Table;
  dyn->update_elements();
  grow_SetUserData(*object, (void*)dyn);

  grow_Redraw(grow->ctx);
}

void Graph::create_folder(grow_tObject* object, double x, double y)
{
  double width = 8;
  double height = 6;
  GeDyn* dyn;

  grow_CreateGrowFolder(grow->ctx, get_next_object_name("O", ""), x, y, width,
      height, glow_eDrawType_Line, 1, glow_eDrawType_Color22,
      glow_eDrawType_Color25, glow_mDisplayLevel_1, NULL, object);
  dyn = new GeDyn(this);
  dyn->update_elements();
  grow_SetUserData(*object, (void*)dyn);

  grow_Redraw(grow->ctx);
}

void Graph::create_toolbar(grow_tObject* object, double x, double y)
{
  GeDyn* dyn;

  grow_CreateGrowToolbar(grow->ctx, "mbtoolbar", "mbtoolbar",
      (char*)GeMethods::op_subgraph, (char*)GeMethods::mnt_subgraph,
      GeMethods::opmeth_size, GeMethods::mntmeth_size, x, y, NULL, object);
  dyn = new GeDyn(this);
  dyn->action_type1 = dyn->total_action_type1 = ge_mActionType1_MethodToolbar;
  dyn->update_elements();
  grow_SetUserData(*object, (void*)dyn);

  grow_Redraw(grow->ctx);
}

void Graph::create_axis(
    grow_tObject* object, double x, double y, int dynamic, int colortheme)
{
  double width = 1.2;
  double height = 5;
  glow_sAxisInfo info;
  glow_eDrawType bcolor;

  if (colortheme)
    bcolor = glow_eCtColor_AxisBordercolor;
  else
    bcolor = glow_eDrawType_Line;

  grow_CreateGrowAxis(grow->ctx, get_next_object_name("O", ""), x, y, x + width,
      y + height, bcolor, 1, 1, glow_eDrawType_TextHelvetica, NULL, object);

  if (dynamic) {
    GeDyn* dyn;

    dyn = new GeDyn(this);
    dyn->dyn_type2 = dyn->total_dyn_type2 = ge_mDynType2_Axis;
    dyn->update_elements();
    grow_SetUserData(*object, (void*)dyn);
  }

  info.max_value = 100;
  info.min_value = 0;
  info.lines = 11;
  info.longquotient = 2;
  info.valuequotient = 2;
  strcpy(info.format, "%3.0f");
  grow_SetAxisInfo(*object, &info);
  grow_Redraw(grow->ctx);

  if (colortheme) {
    grow_SetObjectOriginalTextColor(
        *object, glow_eCtColor_BackgroundTextAndLines);
    // grow_SetObjectTextFont( *object, glow_eFont_LucidaSans);
  }
}

void Graph::create_axisarc(
    grow_tObject* object, double x, double y, int dynamic, int colortheme)
{
  double width = 5;
  double height = 5;
  glow_sAxisInfo info;
  glow_eDrawType bcolor;

  if (colortheme)
    bcolor = glow_eCtColor_AxisBordercolor;
  else
    bcolor = glow_eDrawType_Line;

  grow_CreateGrowAxisArc(grow->ctx, get_next_object_name("O", ""), x, y,
      x + width, y + height, 0, 180, bcolor, 1, 1, glow_eDrawType_TextHelvetica,
      NULL, object);

  if (dynamic) {
    GeDyn* dyn;

    dyn = new GeDyn(this);
    dyn->dyn_type2 = dyn->total_dyn_type2 = ge_mDynType2_Axis;
    dyn->update_elements();
    grow_SetUserData(*object, (void*)dyn);
  }

  info.max_value = 100;
  info.min_value = 0;
  info.lines = 11;
  info.longquotient = 2;
  info.valuequotient = 2;
  strcpy(info.format, "%3.0f");
  grow_SetAxisInfo(*object, &info);
  grow_Redraw(grow->ctx);

  if (colortheme) {
    grow_SetObjectOriginalTextColor(
        *object, glow_eCtColor_BackgroundTextAndLines);
    // grow_SetObjectTextFont( *object, glow_eFont_LucidaSans);
  }
}

void Graph::create_pie(grow_tObject* object, double x, double y, int colortheme)
{
  GeDyn* dyn;
  double width = 5;
  double height = 5;
  glow_eDrawType color[12] = { glow_eDrawType_Color115, glow_eDrawType_Color145,
    glow_eDrawType_Color175, glow_eDrawType_Color205, glow_eDrawType_Color235,
    glow_eDrawType_Color265, glow_eDrawType_Color295, glow_eDrawType_Color105,
    glow_eDrawType_Color135, glow_eDrawType_Color165, glow_eDrawType_Color195,
    glow_eDrawType_Color225 };
  double values[12] = { 8.333, 8.333, 8.333, 8.333, 8.333, 8.333, 8.333, 8.333,
    8.333, 8.333, 8.333, 8.333 };

  glow_eDrawType backgroundcolor, bordercolor;

  if (colortheme) {
    backgroundcolor = glow_eCtColor_BarBackgroundColor;
    bordercolor = glow_eDrawType_Line;
    color[0] = glow_eCtColor_BlueIndicator;
    color[1] = glow_eCtColor_OrangeIndicator;
    color[2] = glow_eCtColor_GreenIndicator;
    color[3] = glow_eCtColor_MagentaIndicator;
    color[4] = glow_eCtColor_YellowIndicator;
    color[5] = glow_eCtColor_RedIndicator;
  } else {
    backgroundcolor = glow_eDrawType_Color38;
    bordercolor = glow_eDrawType_Line;
  }

  grow_CreateGrowPie(grow->ctx, get_next_object_name("O", ""), x, y, x + width,
      y + height, 0, 360, bordercolor, 1, 1, 0, backgroundcolor,
      NULL, object);

  grow_SetPieConf(*object, 12, 0, 100, color);
  grow_SetPieValues(*object, values);
  dyn = new GeDyn(this);
  dyn->dyn_type1 = dyn->total_dyn_type1 = ge_mDynType1_Pie;
  dyn->update_elements();
  grow_SetUserData(*object, (void*)dyn);
  grow_Redraw(grow->ctx);
}

void Graph::create_barchart(grow_tObject* object, double x, double y)
{
  GeDyn* dyn;
  double width = 7;
  double height = 5;
  glow_eDrawType color[12] = { glow_eDrawType_Color115, glow_eDrawType_Color145,
    glow_eDrawType_Color175, glow_eDrawType_Color205, glow_eDrawType_Color235,
    glow_eDrawType_Color265, glow_eDrawType_Color295, glow_eDrawType_Color105,
    glow_eDrawType_Color135, glow_eDrawType_Color165, glow_eDrawType_Color195,
    glow_eDrawType_Color225 };

  grow_CreateGrowBarChart(grow->ctx, get_next_object_name("O", ""), x, y, width,
      height, glow_eDrawType_Line, 1, 1, 0, glow_eDrawType_Color40, NULL,
      object);

  grow_SetBarChartConf(
      *object, 12, 10, 0, 100, 4, 4, glow_eDrawType_Color37, color);
  dyn = new GeDyn(this);
  dyn->dyn_type1 = dyn->total_dyn_type1 = ge_mDynType1_BarChart;
  dyn->update_elements();
  grow_SetUserData(*object, (void*)dyn);
  grow_Redraw(grow->ctx);
}

int Graph::create_dashcell_next(grow_tObject *o, int colortheme, int select, char *attr, pwr_tTypeId atype)
{
  int sts;
  double x, y;
  char typestr[80];
  int size;
  pwr_tAName text;
  char *s;

  sts = grow_GetDashboardNextFree(grow->ctx, 0, 0, 1, 1, &x, &y);
  if (EVEN(sts))
    return sts;
  create_dashcell(o, x, y, colortheme);
  GeDash* dash = new GeDash(this);
  grow_SetUserData(*o, (void*)dash);

  if (attr) {
    if ((s = strrchr(attr, '-')))
      strcpy(text, s+1);
    else
      strcpy(text, attr);
    if (atype != 0) {
      if ((s = strrchr(text, '.')))
	*s = 0;
    }
    switch (atype) {
    case pwr_eType_Float32:
      dash->type = ge_eDashType_Bar;
      strcpy(dash->title, text);
      dash->update(*o);
      strcpy(((GeDashAnalog *)dash->elem[0])->attribute, attr);
      strcat(((GeDashAnalog *)dash->elem[0])->attribute, "##Float32");
      strcpy(((GeDashAnalog *)dash->elem[0])->text, text);
      strcpy(((GeDashAnalog *)dash->elem[0])->format, "%5.2f");
      ((GeDashAnalog *)dash->elem[0])->min_value = 0;
      ((GeDashAnalog *)dash->elem[0])->max_value = 100;
      dash->update(*o);
      break;
    case pwr_eType_Int16:
    case pwr_eType_UInt16:
    case pwr_eType_Int32:
    case pwr_eType_UInt32:
    case pwr_eType_Int64:
    case pwr_eType_UInt64:
      type_to_string((pwr_eType)atype, typestr, &size);
      dash->type = ge_eDashType_Bar;
      strcpy(dash->title, text);
      dash->update(*o);
      strcpy(((GeDashAnalog *)dash->elem[0])->attribute, attr);
      strcat(((GeDashAnalog *)dash->elem[0])->attribute, "##");
      strcat(((GeDashAnalog *)dash->elem[0])->attribute, typestr);
      strcpy(((GeDashAnalog *)dash->elem[0])->text, text);
      strcpy(((GeDashAnalog *)dash->elem[0])->format, "%d");
      ((GeDashAnalog *)dash->elem[0])->min_value = 0;
      ((GeDashAnalog *)dash->elem[0])->max_value = 100;
      dash->update(o);
      break;
    case pwr_eType_Boolean:
      dash->type = ge_eDashType_Indicator;
      strcpy(dash->title, text);
      dash->update(*o);
      strcpy(((GeDashDigital *)dash->elem[0])->attribute, attr);
      strcat(((GeDashDigital *)dash->elem[0])->attribute, "##Boolean");
      strcpy(((GeDashDigital *)dash->elem[0])->text, text);
      dash->update(*o);
      break;
    case 0:
      dash->type = ge_eDashType_ObjectGraph;
      strcpy(dash->title, text);
      dash->update(*o);
      strcpy(((GeDashObject *)dash->elem[0])->object, attr);
      strcpy(((GeDashObject *)dash->elem[0])->text, text);
      dash->update(*o);
    default:
      ;
    }
    if (mode == graph_eMode_Runtime) {
      connect_now = true;
      sts = grow_TraceInitObject(grow->ctx, *o);
      connect_now = false;
    }
  }
  if (select && mode == graph_eMode_Development) {
    grow_SelectClear(grow->ctx);
    grow_SetHighlight(*o, 1);
    grow_SelectInsert(grow->ctx, *o);
  }

  return 1;
}

int Graph::merge_dashcells()
{
  grow_tObject* sel_list;
  grow_tObject* sellist;
  int sel_count;
  GeDash **dashlist;
  int elements = 0;

  grow_GetSelectList(grow->ctx, &sel_list, &sel_count);
  if (sel_count <= 1)
    return GE__SELECTTWO;
  
  dashlist = (GeDash **)calloc(sel_count, sizeof(*dashlist));
  sellist = (grow_tObject *)calloc(sel_count, sizeof(grow_tObject));
  memcpy(sellist, sel_list, sel_count * sizeof(grow_tObject));

  for (int i = 0; i < sel_count; i++) {
    if (grow_GetObjectType(sellist[i]) != glow_eObjectType_GrowDashCell) {
      free(dashlist);
      free(sellist);
      return GE__INVALIDOBJECT;
    }
    grow_GetUserData(sellist[i], (void**)&dashlist[i]);
    elements += dashlist[i]->elements;
  }

  if (elements > dashlist[0]->max_elements()) {
    free(dashlist);
    free(sellist);
    return GE__ELEMSIZE;
  }

  for (int i = 1; i < sel_count; i++) {
    if (dashlist[i]->get_attr_type() != dashlist[0]->get_attr_type()) {
      free(dashlist);
      free(sellist);
      return GE__INVALIDOBJECT;
    }
  }

  for (int i = 1; i < sel_count; i++) {
    dashlist[0]->merge(sellist[0], dashlist[i]);
    grow_DeleteObject(grow->ctx, sellist[i]);
  }

  free(dashlist);
  free(sellist);
  grow_SetModified(grow->ctx, 1);
  return GE__SUCCESS;
}

int Graph::dashboard_connect(grow_tObject o, int idx, char* attr, pwr_tTypeId atype)
{
  GeDash* dash;
  int sts;

  if (grow_GetObjectType(o) != glow_eObjectType_GrowDashCell)
    return 0;

  grow_GetUserData(o, (void**)&dash);

  sts = dash->connect(o, idx, attr, atype);
  return sts;
}

void Graph::create_dashcell(grow_tObject* object, double x, double y, int colortheme)
{
  double width;
  double height;
  int columns, rows;
  GeDyn* dyn;
  glow_eDrawType bordercolor;

  if (colortheme)
    bordercolor = glow_eCtColor_LineDelimiter;
  else
    bordercolor = glow_eDrawType_Line;

  grow_GetDashboardInfo(grow->ctx, &width, &height, &columns, &rows);
  grow_CreateGrowDashCell(grow->ctx, get_next_object_name("O", ""), x, y, width,
      height, bordercolor, NULL, object);
  dyn = new GeDyn(this);
  dyn->dyn_type1 = dyn->total_dyn_type1 = ge_mDynType1_Bar;
  dyn->update_elements();
  grow_SetUserData(*object, (void*)dyn);
  grow_Redraw(grow->ctx);
  grow_SetModified(grow->ctx, 1);
}

int Graph::create_node_floating(double x, double y)
{
  char sub_name[80] = "graph";
  pwr_tFileName filename;
  char name[80];
  grow_tNodeClass nc;
  grow_tNode n1;
  int sts;
  char dev[80], dir[80], file[80], type[32];
  int version;
  GeDyn* dyn;

  // Create subgraph object
  sts = (get_current_subgraph_cb)(parent_ctx, sub_name, filename);
  if (EVEN(sts)) {
    message('E', "Select a SubGraph");
    return sts;
  }
  dcli_parse_filename(filename, dev, dir, file, type, &version);
  str_ToLower(sub_name, file);
  if (streq(type, ".pwsg")) {
    sts = grow_FindNodeClassByName(grow->ctx, sub_name, &nc);
    if (EVEN(sts)) {
      // Load the subgraph
      grow_OpenSubGraph(grow->ctx, filename);
    }
    sts = grow_FindNodeClassByName(grow->ctx, sub_name, &nc);
    if (EVEN(sts)) {
      message('E', "Unable to open subgraph");
      return sts;
    }

    grow_GetUserData(nc, (void**)&dyn);
    if (!dyn) {
      // Old version nodeclass without dyn, create dyn
      GeDyn* dyn = new GeDyn(this);
      grow_SetUserData(nc, (void*)dyn);
    }

    sprintf(name, "O%d", grow_IncrNextObjectNameNumber(grow->ctx));

    grow_PasteClear(grow->ctx);

    grow_CreatePasteNode(grow->ctx, name, nc, x, y, NULL, &n1);

    if (shadow)
      grow_SetObjectShadow(n1, 1);

    GeDyn* dyn = new GeDyn(this);
    grow_SetUserData(n1, (void*)dyn);
    if (grow_IsSliderClass(nc))
      dyn->action_type1
          = ge_mActionType1(dyn->action_type1 | ge_mActionType1_Slider);

    grow_Paste(grow->ctx);
    // grow_SetSelectHighlight( grow->ctx);
  }
  return 1;
}

void Graph::swap(int mode)
{
  if (mode == 0) {
    // Swap starting
    if (trace_started) {
      trace_timer_remove();
      grow_TraceClose(grow->ctx);
      trace_started = 0;
    }
  } else if (mode == 1) {
    // Swap done
    if (!trace_started) {
      grow_TraceInit(grow->ctx, graph_trace_connect_bc,
          graph_trace_disconnect_bc, graph_trace_scan_bc, graph_trace_ctrl_bc);
      trace_started = 1;
      trace_scan(this);
    }
  }
}

int Graph::get_dimension(
    char* filename, const char* def_path, int dashboard, int* width, int* height)
{
  pwr_tFileName fname;

  get_filename(filename, def_path, dashboard, fname);
  return grow_GetDimension(fname, width, height);
}

int Graph::get_colortheme_colors(char* file, double** colors, int* size)
{
  return grow_GetColorThemeColors(file, colors, size);
}

int Graph::search_object(char* name)
{
  int sts;
  grow_tObject object;

  grow_SelectClear(grow->ctx);

  sts = grow_FindObjectByName(grow->ctx, name, &object);
  if (EVEN(sts))
    return sts;

  grow_SelectClear(grow->ctx);
  grow_SetHighlight(object, 1);
  grow_SelectInsert(grow->ctx, object);
  if (!grow_IsVisible(grow->ctx, object, glow_eVisible_Partial))
    grow_CenterObject(grow->ctx, object);

  return 1;
}

char* Graph::get_next_object_name(const char* prefix, const char* suffix)
{
  static char name[32];
  int sts = 0;

  while (EVEN(sts)) {
    sprintf(name, "%s%d%s", prefix, grow_IncrNextObjectNameNumber(grow->ctx),
        suffix);
    sts = grow_CheckObjectName(grow->ctx, name);
  }
  return name;
}

void Graph::set_text_coding(lng_eCoding coding)
{
  glow_eTextCoding c;

  switch (coding) {
  case lng_eCoding_ISO8859_1:
    c = glow_eTextCoding_ISO8859_1;
    break;
  case lng_eCoding_UTF_8:
    c = glow_eTextCoding_UTF_8;
    break;
  }

  grow_SetTextCoding(grow->base_ctx(), c);
}

int Graph::key_pressed(int key)
{
  return grow_KeyPressed(grow->ctx, key);
}

void Graph::close_input_all()
{
  grow_CloseAnnotationInputAll(grow->ctx);
  grow_ResetInputFocusAll(grow->ctx);
}

int Graph::get_object_name(unsigned int idx, int size, char* name)
{
  if (idx >= sizeof(object_name) / sizeof(object_name[0]))
    return 0;
  strncpy(name, object_name[idx], size);
  return 1;
}

void Graph::signal_send(char* signalname)
{
  grow_SignalSend(grow->ctx, signalname);
}

static void graph_free_dyn(grow_tObject object)
{
  if (grow_GetObjectType(object) == glow_eObjectType_GrowNode
      || grow_GetObjectType(object) == glow_eObjectType_GrowSlider
      || grow_GetObjectType(object) == glow_eObjectType_GrowGroup
      || grow_GetObjectType(object) == glow_eObjectType_GrowToolbar
      || grow_GetObjectType(object) == glow_eObjectType_GrowWindow
      || grow_GetObjectType(object) == glow_eObjectType_GrowTrend
      || grow_GetObjectType(object) == glow_eObjectType_GrowXYCurve
      || grow_GetObjectType(object) == glow_eObjectType_GrowTable
      || grow_GetObjectType(object) == glow_eObjectType_GrowBar
      || grow_GetObjectType(object) == glow_eObjectType_GrowBarArc
      || grow_GetObjectType(object) == glow_eObjectType_GrowPie
      || grow_GetObjectType(object) == glow_eObjectType_GrowBarChart
      || grow_GetObjectType(object) == glow_eObjectType_GrowAxis
      || grow_GetObjectType(object) == glow_eObjectType_GrowAxisArc
      || grow_GetObjectType(object) == glow_eObjectType_NodeClass) {
    GeDyn* dyn;

    grow_GetUserData(object, (void**)&dyn);
    if (dyn)
      delete dyn;
  }
  else if (grow_GetObjectType(object) == glow_eObjectType_GrowDashCell) {
    GeDash* dash;

    grow_GetUserData(object, (void**)&dash);
    if (dash)
      delete dash;
  }
}

void Graph::refresh_objects(unsigned int type)
{
  if (refresh_objects_cb)
    (refresh_objects_cb)(parent_ctx, type);
}

void Graph::syntax_check(char* instance)
{
  int error_cnt = 0;
  int warning_cnt = 0;
  int sts;
  grow_tObject* objectlist;
  int object_cnt;
  int severity;
  char name[80];

  syntax_instance = instance;
  if (instance)
    strncpy(object_name[0], instance, sizeof(object_name[0]));

  grow_GetObjectList(grow->ctx, &objectlist, &object_cnt);
  sts = syntax_check_list(objectlist, object_cnt, &error_cnt, &warning_cnt);

  get_name(name);

  if (error_cnt || warning_cnt) {
    char msg[200];

    severity = 'E';
    if (error_cnt == 0)
      severity = 'W';

    sprintf(msg, "Ge syntax check %s, %d errors and %d warnings", name,
        error_cnt, warning_cnt);

    MsgWindow::message(severity, msg);
  } else {
    char msg[200];

    sprintf(msg, "Successful syntax control %s", name);
    message('I', msg);
  }
  syntax_instance = 0;
  if (instance)
    strcpy(object_name[0], "");
}

int Graph::syntax_check_list(
    grow_tObject* list, int list_cnt, int* error_cnt, int* warning_cnt)
{
  GeDyn* dyn;
  grow_tObject* grouplist;
  int group_cnt;
  int sts;

  for (int i = 0; i < list_cnt; i++) {
    switch (grow_GetObjectType(list[i])) {
    case glow_eObjectType_GrowNode:
    case glow_eObjectType_GrowSlider:
    case glow_eObjectType_GrowToolbar:
    case glow_eObjectType_GrowTrend:
    case glow_eObjectType_GrowXYCurve:
    case glow_eObjectType_GrowTable:
    case glow_eObjectType_GrowBar:
    case glow_eObjectType_GrowPie:
    case glow_eObjectType_GrowBarChart:
    case glow_eObjectType_GrowAxis:
    case glow_eObjectType_GrowAxisArc:

      grow_GetUserData(list[i], (void**)&dyn);
      if (!dyn)
        break;

      sts = dyn->syntax_check(list[i], error_cnt, warning_cnt);

      break;
    case glow_eObjectType_GrowGroup:
      grow_GetUserData(list[i], (void**)&dyn);
      sts = dyn->syntax_check(list[i], error_cnt, warning_cnt);

      grow_GetGroupObjectList(list[i], &grouplist, &group_cnt);
      sts = syntax_check_list(grouplist, group_cnt, error_cnt, warning_cnt);
      break;
    default:;
    }
  }
  return 1;
}

void Graph::syntax_msg(int severity, grow_tObject object, const char* msg)
{
  char name[80];

  grow_GetObjectName(object, name, sizeof(name), glow_eName_Path);

  printf("%c %-20s %s\n", severity, name, msg);
  MsgWindow::message(
      severity, msg, "   in object ", name, name, parent_ctx, msgw_eRow_Ge);
}

int Graph::check_ldh_object(char* name, pwr_eType* type)
{
  if (check_ldh_object_cb)
    return (check_ldh_object_cb)(parent_ctx, name, type);
  return 1;
}

void GraphApplList::insert(void* key, void* ctx)
{
  GraphApplList* appl_p = new GraphApplList(key, ctx);
  if (next)
    next->prev = appl_p;
  appl_p->next = next;
  next = appl_p;
}

void GraphApplList::remove(void* ctx)
{
  GraphApplList* appl_p;

  for (appl_p = next; appl_p; appl_p = appl_p->next) {
    if (appl_p->ctx == ctx) {
      if (!appl_p->prev) {
        next = appl_p->next;
        if (appl_p->next)
          appl_p->next->prev = NULL;
      } else {
        appl_p->prev->next = appl_p->next;
        if (appl_p->next)
          appl_p->next->prev = appl_p->prev;
      }
      delete appl_p;
      break;
    }
  }
}

int GraphApplList::find(void* key, void** ctx)
{
  GraphApplList* appl_p;

  for (appl_p = next; appl_p; appl_p = appl_p->next) {
    if (appl_p->key == key) {
      *ctx = appl_p->ctx;
      return 1;
    }
  }
  return 0;
}

int GraphApplList::get_first(void** ctx)
{
  if (next) {
    *ctx = next->ctx;
    return 1;
  } else
    return 0;
}

//
// Convert attribute string to value
//
int graph_attr_string_to_value(int type_id, const char* value_str,
    void* buffer_ptr, int buff_size, int attr_size)
{
  int sts;
  char s[100];

  switch (type_id) {
  case pwr_eType_Boolean: {
    if (sscanf(value_str, "%d%s", (pwr_tBoolean*)buffer_ptr, s) != 1)
      return GE__INPUT_SYNTAX;
    if (*(pwr_tBoolean*)buffer_ptr > 1)
      return GE__INPUT_SYNTAX;
    break;
  }
  case pwr_eType_Float32: {
    if (sscanf(value_str, "%f%s", (float*)buffer_ptr, s) != 1) {
      char val[40];
      char* sp;
      strncpy(val, value_str, sizeof(val));
      if ((sp = strchr(val, ',')) == 0)
        return GE__INPUT_SYNTAX;

      *sp = '.';
      if (sscanf(val, "%f%s", (float*)buffer_ptr, s) != 1)
        return GE__INPUT_SYNTAX;
    }
    break;
  }
  case pwr_eType_Float64: {
    pwr_tFloat32 f;
    pwr_tFloat64 d;
    if (sscanf(value_str, "%f%s", &f, s) != 1) {
      char val[40];
      char* sp;
      strncpy(val, value_str, sizeof(val));
      if ((sp = strchr(val, ',')) == 0)
        return GE__INPUT_SYNTAX;

      *sp = '.';
      if (sscanf(val, "%f%s", (float*)buffer_ptr, s) != 1)
        return GE__INPUT_SYNTAX;
    }
    d = f;
    memcpy(buffer_ptr, (char*)&d, sizeof(d));

    break;
  }
  case pwr_eType_Char: {
    if (sscanf(value_str, "%c%s", (char*)buffer_ptr, s) != 1)
      return GE__INPUT_SYNTAX;
    break;
  }
  case pwr_eType_Int8: {
    pwr_tInt8 i8;
    pwr_tInt16 i16;
    if (sscanf(value_str, "%hd%s", &i16, s) != 1)
      return GE__INPUT_SYNTAX;
    i8 = i16;
    memcpy(buffer_ptr, (char*)&i8, sizeof(i8));
    break;
  }
  case pwr_eType_Int16: {
    if (sscanf(value_str, "%hd%s", (short*)buffer_ptr, s) != 1)
      return GE__INPUT_SYNTAX;
    break;
  }
  case pwr_eType_Int32:
  case pwr_eType_Enum: {
    if (sscanf(value_str, "%d%s", (int*)buffer_ptr, s) != 1)
      return GE__INPUT_SYNTAX;
    break;
  }
  case pwr_eType_Int64: {
    if (sscanf(value_str, pwr_dFormatInt64 "%s", (pwr_tInt64*)buffer_ptr, s)
        != 1)
      return GE__INPUT_SYNTAX;
    break;
  }
  case pwr_eType_UInt8: {
    pwr_tUInt8 i8;
    pwr_tUInt16 i16;
    if (sscanf(value_str, "%hu%s", &i16, s) != 1)
      return GE__INPUT_SYNTAX;
    i8 = i16;
    memcpy(buffer_ptr, (char*)&i8, sizeof(i8));
    break;
  }
  case pwr_eType_UInt16: {
    if (sscanf(value_str, "%hu%s", (unsigned short*)buffer_ptr, s) != 1)
      return GE__INPUT_SYNTAX;
    break;
  }
  case pwr_eType_UInt32:
  case pwr_eType_Mask: {
    if (sscanf(value_str, "%lu%s", (unsigned long*)buffer_ptr, s) != 1)
      return GE__INPUT_SYNTAX;
    break;
  }
  case pwr_eType_UInt64: {
    if (sscanf(value_str, pwr_dFormatUInt64 "%s", (pwr_tUInt64*)buffer_ptr, s)
        != 1)
      return GE__INPUT_SYNTAX;
    break;
  }
  case pwr_eType_String: {
    if ((int)strlen(value_str) >= attr_size)
      return GE__STRINGTOLONG;
    strncpy((char*)buffer_ptr, value_str, MIN(attr_size, buff_size));
    break;
  }
  case pwr_eType_ObjDId: {
    pwr_tObjid objid;

    sts = gdh_NameToObjid(value_str, &objid);
    if (EVEN(sts))
      return GE__OBJNOTFOUND;
    memcpy(buffer_ptr, &objid, sizeof(objid));
    break;
  }
  case pwr_eType_ClassId: {
    pwr_tClassId classid;
    pwr_tObjid objid;

    sts = gdh_NameToObjid(value_str, &objid);
    if (EVEN(sts))
      return GE__OBJNOTFOUND;
    classid = cdh_ClassObjidToId(objid);
    memcpy(buffer_ptr, (char*)&classid, sizeof(classid));
    break;
  }
  case pwr_eType_TypeId: {
    pwr_tTypeId val_typeid;
    pwr_tObjid objid;

    sts = gdh_NameToObjid(value_str, &objid);
    if (EVEN(sts))
      return GE__OBJNOTFOUND;
    val_typeid = cdh_TypeObjidToId(objid);
    memcpy(buffer_ptr, (char*)&val_typeid, sizeof(val_typeid));
    break;
  }
  case pwr_eType_ObjectIx: {
    pwr_tObjectIx objectix;

    sts = cdh_StringToObjectIx(value_str, &objectix);
    if (EVEN(sts))
      return GE__OBJNOTFOUND;
    memcpy(buffer_ptr, (char*)&objectix, sizeof(objectix));
    break;
  }
  case pwr_eType_VolumeId: {
    pwr_tVolumeId volumeid;

    sts = cdh_StringToVolumeId(value_str, &volumeid);
    if (EVEN(sts))
      return GE__OBJNOTFOUND;
    memcpy(buffer_ptr, (char*)&volumeid, sizeof(volumeid));
    break;
  }
  case pwr_eType_RefId: {
    pwr_tRefId subid;

    sts = cdh_StringToSubid(value_str, &subid);
    if (EVEN(sts))
      return GE__OBJNOTFOUND;
    memcpy(buffer_ptr, (char*)&subid, sizeof(subid));
    break;
  }
  case pwr_eType_AttrRef: {
    pwr_sAttrRef attrref;

    sts = gdh_NameToAttrref(pwr_cNObjid, value_str, &attrref);
    if (EVEN(sts))
      return GE__OBJNOTFOUND;
    memcpy(buffer_ptr, &attrref, sizeof(attrref));
    break;
  }
  case pwr_eType_Time: {
    pwr_tTime time;

    sts = time_AsciiToA(value_str, &time);
    if (EVEN(sts))
      return GE__INPUT_SYNTAX;
    memcpy(buffer_ptr, (char*)&time, sizeof(time));
    break;
  }
  case pwr_eType_DeltaTime: {
    pwr_tDeltaTime deltatime;

    sts = time_AsciiToD(value_str, &deltatime);
    if (EVEN(sts))
      return GE__INPUT_SYNTAX;
    memcpy(buffer_ptr, (char*)&deltatime, sizeof(deltatime));
    break;
  }
  }
  return 1;
}

GraphRecallBuff::GraphRecallBuff() : cnt(0), size(RECALL_BUFF_SIZE)
{
  memset(key, 0, sizeof(key));
}

GraphRecallBuff::~GraphRecallBuff()
{
  for (int i = 0; i < cnt; i++)
    delete buff[i];
}
void GraphRecallBuff::insert(
    GeDyn* data, const char* data_key, grow_tObject object)
{
  int i;
  char new_key[80];

  if (!data_key)
    strcpy(new_key, "");
  else
    strcpy(new_key, data_key);

  if (cnt == size)
    delete buff[size - 1];
  for (i = cnt; i > 0; i--) {
    buff[i] = buff[i - 1];
    strcpy(key[i], key[i - 1]);
  }
  buff[0] = new GeDyn(*data);
  buff[0]->unset_inherit(object);
  strcpy(key[0], new_key);
  cnt++;
  if (cnt > size)
    cnt = size;
}

int GraphRecallBuff::get(GeDyn** data, int idx)
{
  if (idx >= cnt)
    return 0;
  *data = new GeDyn(*buff[idx]);
  return 1;
}

int GraphRecallBuff::get(GeDyn** data, char* k)
{
  for (int i = 0; i < cnt; i++) {
    if (streq(k, key[i])) {
      *data = new GeDyn(*buff[i]);
      return 1;
    }
  }
  return 0;
}
