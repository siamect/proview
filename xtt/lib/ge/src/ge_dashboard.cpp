/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2020 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* gedashboard.cpp -- Display dashboard */

#include <math.h>
#include <stdlib.h>

#include <iostream>

#include "co_cdh.h"
#include "co_dcli.h"
#include "co_msg.h"
#include "co_string.h"
#include "co_time.h"

#include "rt_gdh.h"
#include "glow_msg.h"
#include "ge_msg.h"
#include "ge_dashboard.h"
#include "ge_dyn.h"
#include "ge_script.h"

static void dabo_bar(GeDash *dash, grow_tObject g);
static void dabo_bararc(GeDash *dash, grow_tObject g);
static void dabo_trend(GeDash *dash, grow_tObject g);
static void dabo_ind(GeDash *dash, grow_tObject g);
static void dabo_digtrend(GeDash *dash, grow_tObject g);
static void dabo_gauge(GeDash *dash, grow_tObject g);
static void dabo_gauge2(GeDash *dash, grow_tObject g);
static void dabo_pie(GeDash *dash, grow_tObject g);
static void dabo_slider(GeDash *dash, grow_tObject g);

typedef struct {
  ge_eDashAttr attr_type;
  unsigned int dash_mask;
  unsigned int elem_mask;
  unsigned int max_elem;
  char script[80];
  void (*sfunc)(GeDash*, grow_tObject);
  char name[40];
} sTypeInfo;

// dash_mask: Title 1, TimeRange 2, Direction 4, Elements 8
// analog mask: Attribute 1, Text 2, Format 4, MinValue 8, MaxValue 16
// digital mask: Attribute 1, Text 2, Color 4, Flash 8
static sTypeInfo type_info[] = {
  {ge_eDashAttr_No, 7, 0, 0, "", 0, ""},
  {ge_eDashAttr_No, 7, 0, 0, "", 0, ""},
  {ge_eDashAttr_Object, 15, 15, 1, "dash_objectgraph", 0, "ObjectGraph"},
  {ge_eDashAttr_Analog, 13, 31, 3, "dabo_bar", dabo_bar, "Bar"},
  {ge_eDashAttr_Analog, 13, 31, 1, "dabo_bararc", dabo_bararc, "BarArc"},
  {ge_eDashAttr_Analog, 15, 27, 2, "dabo_trend", dabo_trend, "Trend"},
  {ge_eDashAttr_Analog, 13, 31, 3, "dabo_gauge", dabo_gauge, "Gauge"},
  {ge_eDashAttr_Analog, 13, 31, 3, "dabo_gauge2", dabo_gauge2, "Gauge2"},
  {ge_eDashAttr_Analog, 13, 31, 3, "dabo_slider", dabo_slider, "Slider"},
  {ge_eDashAttr_Analog, 13, 31, 6, "dabo_pie", dabo_pie, "Pie"},
  {ge_eDashAttr_Digital, 9, 15, 5, "dabo_ind", dabo_ind, "Indicator"},
  {ge_eDashAttr_Digital, 15, 3, 5, "dabo_digtrend", dabo_digtrend, "DigitalTrend"}
};

//! Copy constructor for GeDash
GeDash::GeDash(const GeDash& x) : graph(x.graph), type(x.type),
    time_range(x.time_range), direction(x.direction),
    elements(x.elements), old_type(x.old_type), old_rows(x.old_rows), 
    old_columns(x.old_columns), old_elements(x.old_elements) {
  memset(elem, 0, sizeof(elem));
  strcpy(title, x.title);
  switch (type_info[type].attr_type) {
  case ge_eDashAttr_Analog:
    for (int i = 0; i < elements; i++) {
      elem[i] = (GeDashElem *)new GeDashAnalog(*(GeDashAnalog *)x.elem[i]);
      elem[i]->dash = this;
    }
    break;
  case ge_eDashAttr_Digital:
    for (int i = 0; i < elements; i++) {
      elem[i] = (GeDashElem *)new GeDashDigital(*(GeDashDigital *)x.elem[i]);
      elem[i]->dash = this;
    }
    break;
  case ge_eDashAttr_Object:
    for (int i = 0; i < elements; i++) {
      elem[i] = (GeDashElem *)new GeDashObject(*(GeDashObject *)x.elem[i]);
      elem[i]->dash = this;
    }
    break;
  case ge_eDashAttr_No:
    break;
  default:
    ;
  }
}

GeDash::~GeDash()
{
  for (int j = 0; j < elements; j++)
    delete elem[j];
}

ge_eDashAttr GeDash::get_attr_type()
{
  return type_info[type].attr_type;
}

int GeDash::max_elements()
{
  return type_info[type].max_elem;
}

void GeDash::get_attributes(grow_tObject o, attr_sItem* attrinfo, int* item_count)
{
  int i = *item_count;
  unsigned int mask = 1;
  unsigned int dash_mask = type_info[type].dash_mask;

  strcpy(attrinfo[i].name, "Dash.Type");
  attrinfo[i].value = &type;
  attrinfo[i].type = ge_eAttrType_DashType;
  attrinfo[i++].size = sizeof(type);

  if (dash_mask & mask) {
    strcpy(attrinfo[i].name, "Dash.Title");
    attrinfo[i].value = title;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(title);
  }
  mask = mask << 1;
  if (dash_mask & mask) {
    strcpy(attrinfo[i].name, "Dash.TimeRange");
    attrinfo[i].value = &time_range;
    attrinfo[i].type = glow_eType_Double;
    attrinfo[i++].size = sizeof(time_range);
  }
  mask = mask << 1;
  if (dash_mask & mask) {
    strcpy(attrinfo[i].name, "Dash.Direction");
    attrinfo[i].value = &direction;
    attrinfo[i].type = glow_eType_Direction;
    attrinfo[i++].size = sizeof(direction);
  }
  mask = mask << 1;
  if (dash_mask & mask) {
    strcpy(attrinfo[i].name, "Dash.Elements");
    attrinfo[i].value = &elements;
    attrinfo[i].type = ge_eAttrType_DashElements;
    attrinfo[i].minlimit = 0;
    attrinfo[i].maxlimit = DASH_MAX_ELEM;
    attrinfo[i++].size = sizeof(elements);
  }
  if (type == ge_eDashType_UserDefined) {
    strcpy(attrinfo[i].name, "Dash.Script");
    attrinfo[i].value = script;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(script);

    strcpy(attrinfo[i].name, "Dash.AttributeType");
    attrinfo[i].value = &attr_type;
    attrinfo[i].type = glow_eType_Int;
    attrinfo[i++].size = sizeof(attr_type);
  }

  update_elem(o);
  for (int j = 0; j < elements; j++)
    elem[j]->get_attributes(attrinfo, &i, type_info[type].name, 
	type_info[type].elem_mask, j);

  *item_count = i;
}

void GeDash::set_attribute(grow_tObject object, const char* attr_name, int second)
{
  for (int j = 0; j < elements; j++)
    elem[j]->set_attribute(object, attr_name, second);
}

void GeDash::replace_attribute(char* from, char* to, int* cnt, int strict)
{
  for (int j = 0; j < elements; j++)
    elem[j]->replace_attribute(from, to, cnt, strict);
}

void GeDash::update_elem(grow_tObject o)
{
  if (elements > type_info[type].max_elem)
    elements = type_info[type].max_elem;
  if (elements != old_elements) {
    switch (type_info[type].attr_type) {
    case ge_eDashAttr_Analog:
      if (elements > old_elements) {
	for (int j = old_elements; j < elements; j++)
	  elem[j] = new GeDashAnalog(this);
      }
      else {
	for (int j = elements; j < old_elements; j++)
	  delete elem[j];
      }
      break;
    case ge_eDashAttr_Digital:
      if (elements > old_elements) {
	for (int j = old_elements; j < elements; j++)
	  elem[j] = new GeDashDigital(this);
      }
      else {
	for (int j = elements; j < old_elements; j++)
	  delete elem[j];
      }
      break;
    case ge_eDashAttr_Object:
      if (elements > old_elements) {
	for (int j = old_elements; j < elements; j++)
	  elem[j] = new GeDashObject(this);
      }
      else {
	for (int j = elements; j < old_elements; j++)
	  delete elem[j];
      }
      break;
    default:
      for (int j = 0; j < elements; j++)
	elem[j] = 0;
    }
    old_elements = elements;
    new_type = 1;
  }

  if (type_info[type].attr_type != type_info[old_type].attr_type) {
    GeDashElem *oldelem[DASH_MAX_ELEM];

    for (int j = 0; j < elements; j++)
      oldelem[j] = elem[j];

    switch (type_info[type].attr_type) {
    case ge_eDashAttr_No:
      for (int j = 0; j < elements; j++)
	elem[j] = 0;
      elements = 0;
      break;
    case ge_eDashAttr_Analog:
      switch (type_info[old_type].attr_type) {
      default:
	for (int j = 0; j < elements; j++)
	  elem[j] = 0;
	elements = 1;
	for (int j = 0; j < elements; j++)
	  elem[j] = new GeDashAnalog(this);
      }
      break;
    case ge_eDashAttr_Digital:
      switch (type_info[old_type].attr_type) {
      default:
	for (int j = 0; j < elements; j++)
	  elem[j] = 0;
	elements = 1;
	for (int j = 0; j < elements; j++)
	  elem[j] = new GeDashDigital(this);
      }
      break;
    case ge_eDashAttr_Object:
      switch (type_info[old_type].attr_type) {
      default:
	for (int j = 0; j < elements; j++)
	  elem[j] = 0;
	elements = 1;
	for (int j = 0; j < elements; j++)
	  elem[j] = new GeDashObject(this);
      }
      break;
    default:
      for (int j = 0; j < elements; j++)
	elem[j] = 0;
      elements = 0;
    }     
    for (int j = 0; j < old_elements; j++)
      delete oldelem[j];
    old_elements = elements;

    new_type = 1;
  }
  old_type = type;
}

void GeDash::update(grow_tObject o)
{
  pwr_tStatus sts;
  char script[1000];
  double ll_x, ll_y, ur_x, ur_y;

  grow_MeasureNode(o, &ll_x, &ll_y, &ur_x, &ur_y);

  update_elem(o);
  grow_GroupClear(o);
    
  if (elements) {
    if (type_info[type].sfunc)
      (type_info[type].sfunc)(this, o);
    else {
      elem[0]->get_script(o, script);
      sts = graph->script_buffer_exec(script);
    }
    graph->set_modified(1);
  }
}

int GeDash::connect(grow_tObject o, int idx, char* attr, pwr_tTypeId atype)
{
  char typestr[80];
  int size;
  pwr_tAName text;
  char *s;

  if ((s = strrchr(attr, '-')))
    strcpy(text, s+1);
  else
    strcpy(text, attr);
  if ((s = strrchr(text, '.')))
    *s = 0;
    
  if (elements < idx + 1)
    elements = idx + 1;
      
  switch (atype) {
  case pwr_eType_Float32:
    if (type_info[type].attr_type != ge_eDashAttr_Analog)
      type = ge_eDashType_Bar;
    update(o);
    strcpy(title, text);
    strcpy(((GeDashAnalog *)elem[idx])->attribute, attr);
    strcat(((GeDashAnalog *)elem[idx])->attribute, "##Float32");
    strcpy(((GeDashAnalog *)elem[idx])->text, text);
    if (strcmp(((GeDashAnalog *)elem[idx])->format, "") == 0)
      strcpy(((GeDashAnalog *)elem[idx])->format, "%5.2f");
    if (((GeDashAnalog *)elem[idx])->min_value == 0 &&
	((GeDashAnalog *)elem[idx])->max_value == 0) {
      ((GeDashAnalog *)elem[idx])->min_value = 0;
      ((GeDashAnalog *)elem[idx])->max_value = 100;
    }
    update(o);
    break;
  case pwr_eType_Int16:
  case pwr_eType_UInt16:
  case pwr_eType_Int32:
  case pwr_eType_UInt32:
  case pwr_eType_Int64:
  case pwr_eType_UInt64:
    graph->type_to_string((pwr_eType)atype, typestr, &size);
    if (type_info[type].attr_type != ge_eDashAttr_Analog)
      type = ge_eDashType_Bar;
    update(o);
    strcpy(title, text);
    strcpy(((GeDashAnalog *)elem[idx])->attribute, attr);
    strcat(((GeDashAnalog *)elem[idx])->attribute, "##");
    strcat(((GeDashAnalog *)elem[idx])->attribute, typestr);
    strcpy(((GeDashAnalog *)elem[idx])->text, text);
    if (strcmp(((GeDashAnalog *)elem[idx])->format, "") == 0)
      strcpy(((GeDashAnalog *)elem[idx])->format, "%d");
    if (((GeDashAnalog *)elem[idx])->min_value == 0 &&
	((GeDashAnalog *)elem[idx])->max_value == 0) {
      ((GeDashAnalog *)elem[idx])->min_value = 0;
      ((GeDashAnalog *)elem[idx])->max_value = 100;
    }
    update(o);
    break;
  case pwr_eType_Boolean:
    if (type_info[type].attr_type != ge_eDashAttr_Digital)
      type = ge_eDashType_Indicator;
    strcpy(title, text);
    update(o);
    strcpy(((GeDashDigital *)elem[idx])->attribute, attr);
    strcat(((GeDashDigital *)elem[idx])->attribute, "##Boolean");
    strcpy(((GeDashDigital *)elem[idx])->text, text);
    update(o);
    break;
  case 0:
    if (type_info[type].attr_type != ge_eDashAttr_Object)
      type = ge_eDashType_ObjectGraph;
    strcpy(title, text);
    update(o);
    strcpy(((GeDashObject *)elem[idx])->object, attr);
    strcpy(((GeDashObject *)elem[idx])->text, text);
    update(o);
    break;
  default:
    ;
  }
  return GE__SUCCESS;
}

void GeDash::save(std::ofstream& fp)
{
  fp << int(dash_eSave_Dash) << '\n';
  fp << int(dash_eSave_Dash_type) << FSPACE << int(type) << '\n';
  fp << int(dash_eSave_Dash_attr_type) << FSPACE << int(attr_type) << '\n';
  fp << int(dash_eSave_Dash_title) << FSPACE << title << '\n';
  fp << int(dash_eSave_Dash_time_range) << FSPACE << time_range << '\n';
  fp << int(dash_eSave_Dash_direction) << FSPACE << direction << '\n';
  fp << int(dash_eSave_Dash_script) << FSPACE << script << '\n';
  fp << int(dash_eSave_Dash_elements) << FSPACE << elements << '\n';
  for (int j = 0; j < elements; j++)
    elem[j]->save(fp);
  fp << int(dash_eSave_End) << '\n';
}

void GeDash::open(std::ifstream& fp)
{
  int stype = 0;
  int end_found = 0;
  int tmp;
  char dummy[40];
  GeDashElem* e;
  int errcnt = 0;
  int elem_cnt = 0;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error GeDash: \"%d %s\"\n", stype, dummy);
    }

    fp >> stype;

    e = 0;
    switch (stype) {
    case dash_eSave_Dash:
      break;
    case dash_eSave_Dash_type:
      fp >> tmp;
      type = (ge_eDashType)tmp;
      break;
    case dash_eSave_Dash_attr_type:
      fp >> tmp;
      attr_type = (ge_eDashAttr)tmp;
      break;
    case dash_eSave_Dash_title:
      fp.get();
      fp.getline(title, sizeof(title));
      break;
    case dash_eSave_Dash_time_range:
      fp >> time_range;
      break;
    case dash_eSave_Dash_direction:
      fp >> tmp;
      direction = (glow_eDirection)tmp;
      break;
    case dash_eSave_Dash_script:
      fp.get();
      fp.getline(script, sizeof(script));
      break;
    case dash_eSave_Dash_elements:
      fp >> elements;
      break;
    case dash_eSave_Analog:
      e = (GeDashElem*)new GeDashAnalog(this);
      break;
    case dash_eSave_Digital:
      e = (GeDashElem*)new GeDashDigital(this);
      break;
    case dash_eSave_Object:
      e = (GeDashElem*)new GeDashObject(this);
      break;
    case dash_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "GeDash:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
      errcnt++;
      if (errcnt > 20)
        exit(0);
    }
    if (e) {
      elem[elem_cnt] = e;
      elem[elem_cnt]->open(fp);
      elem_cnt++;
    }
    if (end_found)
      break;
  }
  old_type = type;
  strcpy(old_title, title);
  old_elements = elements;
}


//
// Analog
//

void GeDashAnalog::get_script(grow_tObject o, char *script)
{
  switch (dash->elements) {
  case 1:
    sprintf(script, "\
#include <%s.ge_com>\n\
main()\n\
%s(%llu,%u,\"%s\",%f,%d,\"%s\",\"%s\",\"%s\",%f,%f,\"\",\"\",\"\",0,0,\"\",\"\",\"\",0,0);\n\
endmain\n\
", 
	    type_info[dash->type].script, type_info[dash->type].script, (long long unsigned)o, 
	    dash->elements, dash->title, dash->time_range, dash->direction, attribute, 
	    text, format,  min_value, max_value);
    break;
  case 2:
    sprintf(script, "\
#include <%s.ge_com>\n\
main()\n\
%s(%llu,%u,\"%s\",%f,%d,\"%s\",\"%s\",\"%s\",%f,%f,\"%s\",\"%s\",\"%s\",%f,%f,\"\",\"\",\"\",0,0);\n\
endmain\n\
", 
	    type_info[dash->type].script, type_info[dash->type].script, (long long unsigned)o, 
	    dash->elements, dash->title, dash->time_range, dash->direction,
	    attribute, text, format, min_value, max_value,
	    ((GeDashAnalog *)dash->elem[1])->attribute, 
	    ((GeDashAnalog *)dash->elem[1])->text, 
	    ((GeDashAnalog *)dash->elem[1])->format, 
	    ((GeDashAnalog *)dash->elem[1])->min_value, 
	    ((GeDashAnalog *)dash->elem[1])->max_value);
    break;
  case 3:
    sprintf(script, "\
#include <%s.ge_com>\n\
main()\n\
%s(%llu,%u,\"%s\",%f,%d,\"%s\",\"%s\",\"%s\",%f,%f,\"%s\",\"%s\",\"%s\",%f,%f,\"%s\",\"%s\",\"%s\",%f,%f);\n\
endmain\n\
", 
	    type_info[dash->type].script, type_info[dash->type].script, (long long unsigned)o, 
	    dash->elements, dash->title, dash->time_range, dash->direction,
	    attribute, text, format, min_value, max_value,
	    ((GeDashAnalog *)dash->elem[1])->attribute, 
	    ((GeDashAnalog *)dash->elem[1])->text, 
	    ((GeDashAnalog *)dash->elem[1])->format, 
	    ((GeDashAnalog *)dash->elem[1])->min_value, 
	    ((GeDashAnalog *)dash->elem[1])->max_value,    
	    ((GeDashAnalog *)dash->elem[2])->attribute, 
	    ((GeDashAnalog *)dash->elem[2])->text,
	    ((GeDashAnalog *)dash->elem[2])->format, 
	    ((GeDashAnalog *)dash->elem[2])->min_value, 
	    ((GeDashAnalog *)dash->elem[2])->max_value);    
    break;
  default: ;
  }
}

void GeDashAnalog::get_attributes(attr_sItem* attrinfo, int* item_count, 
    char *name, unsigned int elem_mask, int num)
{
  int i = *item_count;
  unsigned int mask = 1;
  
  if (elem_mask & mask) {
    strcpy(attrinfo[i].name, name);
    if (num)
      sprintf(&attrinfo[i].name[strlen(attrinfo[i].name)], "%d", num+1);
    strcat(attrinfo[i].name, ".Attribute");
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);
  }
  mask = mask << 1;
  if (elem_mask & mask) {
    strcpy(attrinfo[i].name, name);
    if (num)
      sprintf(&attrinfo[i].name[strlen(attrinfo[i].name)], "%d", num+1);
    strcat(attrinfo[i].name, ".Text");
    attrinfo[i].value = text;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(text);
  }
  mask = mask << 1;
  if (elem_mask & mask) {
    strcpy(attrinfo[i].name, name);
    if (num)
      sprintf(&attrinfo[i].name[strlen(attrinfo[i].name)], "%d", num+1);
    strcat(attrinfo[i].name, ".Format");
    attrinfo[i].value = format;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(format);
  }
  mask = mask << 1;
  if (elem_mask & mask) {
    strcpy(attrinfo[i].name, name);
    if (num)
      sprintf(&attrinfo[i].name[strlen(attrinfo[i].name)], "%d", num+1);
    strcat(attrinfo[i].name, ".MinValue");
    attrinfo[i].value = &min_value;
    attrinfo[i].type = glow_eType_Double;
    attrinfo[i++].size = sizeof(min_value);
  }
  mask = mask << 1;
  if (elem_mask & mask) {    
    strcpy(attrinfo[i].name, name);
    if (num)
      sprintf(&attrinfo[i].name[strlen(attrinfo[i].name)], "%d", num+1);
    strcat(attrinfo[i].name, ".MaxValue");
    attrinfo[i].value = &max_value;
    attrinfo[i].type = glow_eType_Double;
    attrinfo[i++].size = sizeof(max_value);
  }
  *item_count = i;
}

void GeDashAnalog::set_attribute(
    grow_tObject object, const char* attr_name, int second)
{
  if (!second) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "Analog.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dash->graph->message('I', msg);
  }
}

void GeDashAnalog::replace_attribute(
    char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeDashAnalog::save(std::ofstream& fp)
{
  fp << int(dash_eSave_Analog) << '\n';
  fp << int(dash_eSave_Analog_attribute) << FSPACE << attribute << '\n';
  fp << int(dash_eSave_Analog_text) << FSPACE << text << '\n';
  fp << int(dash_eSave_Analog_format) << FSPACE << format << '\n';
  fp << int(dash_eSave_Analog_min_value) << FSPACE << min_value << '\n';
  fp << int(dash_eSave_Analog_max_value) << FSPACE << max_value << '\n';
  fp << int(dash_eSave_End) << '\n';
}

void GeDashAnalog::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error DashAnalog: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case dash_eSave_Analog:
      break;
    case dash_eSave_Analog_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case dash_eSave_Analog_text:
      fp.get();
      fp.getline(text, sizeof(text));
      break;
    case dash_eSave_Analog_format:
      fp.get();
      fp.getline(format, sizeof(format));
      break;
    case dash_eSave_Analog_min_value:
      fp >> min_value;
      break;
    case dash_eSave_Analog_max_value:
      fp >> max_value;
      break;
    case dash_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "DashAnalog:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

//
// Digital
//

void GeDashDigital::get_script(grow_tObject o, char *script)
{
  switch (dash->elements) {
  case 1:
    sprintf(script, "\
#include <%s.ge_com>\n\
main()\n\
verify(1);\n\
%s(%llu,%u,\"%s\",%f,%d,\"%s\",\"%s\",%d,%d,\"\",\"\",0,0,\"\",\"\",0,0,\"\",\"\",0,0,\"\",\"\",0,0);\n\
endmain\n\
", 
	    type_info[dash->type].script, type_info[dash->type].script, (long long unsigned)o, 
	    dash->elements, dash->title, dash->time_range, dash->direction, attribute, text, color, flash);
    break;
  case 2:
    sprintf(script, "\
#include <%s.ge_com>\n\
main()\n\
%s(%llu,%u,\"%s\",%f,%d,\"%s\",\"%s\",%d,%d,\"%s\",\"%s\",%d,%d,\"\",\"\",0,0,\"\",\"\",0,0,\"\",\"\",0,0);\n\
endmain\n\
", 
	    type_info[dash->type].script, type_info[dash->type].script, (long long unsigned)o, 
	    dash->elements, dash->title, dash->time_range, dash->direction, attribute, text, color, flash,
	    ((GeDashDigital *)dash->elem[1])->attribute, 
	    ((GeDashDigital *)dash->elem[1])->text,
	    ((GeDashDigital *)dash->elem[1])->color,
	    ((GeDashDigital *)dash->elem[1])->flash);
    break;
  case 3:
    sprintf(script, "\
#include <%s.ge_com>\n\
main()\n\
%s(%llu,%u,\"%s\",%f,%d,\"%s\",\"%s\",%d,%d,\"%s\",\"%s\",%d,%d,\"%s\",\"%s\",%d,%d,\"\",\"\",0,0,\"\",\"\",0,0);\n\
endmain\n\
", 
	    type_info[dash->type].script, type_info[dash->type].script, (long long unsigned)o, 
	    dash->elements, dash->title, dash->time_range, dash->direction, attribute, text, color, flash,
	    ((GeDashDigital *)dash->elem[1])->attribute, 
	    ((GeDashDigital *)dash->elem[1])->text,
	    ((GeDashDigital *)dash->elem[1])->color,
	    ((GeDashDigital *)dash->elem[1])->flash,
	    ((GeDashDigital *)dash->elem[2])->attribute, 
	    ((GeDashDigital *)dash->elem[2])->text,
	    ((GeDashDigital *)dash->elem[2])->color,
	    ((GeDashDigital *)dash->elem[2])->flash);
    break;
  case 4:
    sprintf(script, "\
#include <%s.ge_com>\n\
main()\n\
%s(%llu,%u,\"%s\",%f,%d,\"%s\",\"%s\",%d,%d,\"%s\",\"%s\",%d,%d,\"%s\",\"%s\",%d,%d,\"%s\",\"%s\",%d,%d,\"\",\"\",0,0);\n\
endmain\n\
", 
	    type_info[dash->type].script, type_info[dash->type].script, (long long unsigned)o, 
	    dash->elements, dash->title, dash->time_range, dash->direction, attribute, text, color, flash, 
	    ((GeDashDigital *)dash->elem[1])->attribute, 
	    ((GeDashDigital *)dash->elem[1])->text,
	    ((GeDashDigital *)dash->elem[1])->color,
	    ((GeDashDigital *)dash->elem[1])->flash,
	    ((GeDashDigital *)dash->elem[2])->attribute, 
	    ((GeDashDigital *)dash->elem[2])->text,
	    ((GeDashDigital *)dash->elem[2])->color,
	    ((GeDashDigital *)dash->elem[2])->flash,
	    ((GeDashDigital *)dash->elem[3])->attribute, 
	    ((GeDashDigital *)dash->elem[3])->text,
	    ((GeDashDigital *)dash->elem[3])->color,
	    ((GeDashDigital *)dash->elem[3])->flash);
    break;
  case 5:
    sprintf(script, "\
#include <%s.ge_com>\n\
main()\n\
%s(%llu,%u,\"%s\",%f,%d,\"%s\",\"%s\",%d,%d,\"%s\",\"%s\",%d,%d,\"%s\",\"%s\",%d,%d,\"%s\",\"%s\",%d,%d,\"%s\",\"%s\",%d,%d);\n\
endmain\n\
", 
	    type_info[dash->type].script, type_info[dash->type].script, (long long unsigned)o, 
	    dash->elements, dash->title, dash->time_range, dash->direction, attribute, text, color, flash, 
	    ((GeDashDigital *)dash->elem[1])->attribute, 
	    ((GeDashDigital *)dash->elem[1])->text,
	    ((GeDashDigital *)dash->elem[1])->color,
	    ((GeDashDigital *)dash->elem[1])->flash,
	    ((GeDashDigital *)dash->elem[2])->attribute, 
	    ((GeDashDigital *)dash->elem[2])->text,
	    ((GeDashDigital *)dash->elem[2])->color,
	    ((GeDashDigital *)dash->elem[2])->flash,
	    ((GeDashDigital *)dash->elem[3])->attribute, 
	    ((GeDashDigital *)dash->elem[3])->text,
	    ((GeDashDigital *)dash->elem[3])->color,
	    ((GeDashDigital *)dash->elem[3])->flash,
	    ((GeDashDigital *)dash->elem[4])->attribute, 
	    ((GeDashDigital *)dash->elem[4])->text,
	    ((GeDashDigital *)dash->elem[4])->color,
	    ((GeDashDigital *)dash->elem[4])->flash);
    break;
  default:
    ;
  }
}

void GeDashDigital::get_attributes(attr_sItem* attrinfo, int* item_count, 
    char *name, unsigned int elem_mask, int num)
{
  int i = *item_count;
  unsigned int mask = 1;
  
  if (elem_mask & mask) {
    strcpy(attrinfo[i].name, name);
    if (num)
      sprintf(&attrinfo[i].name[strlen(attrinfo[i].name)], "%d", num+1);
    strcat(attrinfo[i].name, ".Attribute");
    attrinfo[i].value = attribute;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(attribute);
  }
  mask = mask << 1;
  if (elem_mask & mask) {
    strcpy(attrinfo[i].name, name);
    if (num)
      sprintf(&attrinfo[i].name[strlen(attrinfo[i].name)], "%d", num+1);
    strcat(attrinfo[i].name, ".Text");
    attrinfo[i].value = text;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(text);
  }
  mask = mask << 1;
  if (elem_mask & mask) {
    strcpy(attrinfo[i].name, name);
    if (num)
      sprintf(&attrinfo[i].name[strlen(attrinfo[i].name)], "%d", num+1);
    strcat(attrinfo[i].name, ".Color");
    attrinfo[i].value = &color;
    attrinfo[i].type = ge_eAttrType_IndicatorColor;
    attrinfo[i++].size = sizeof(color);
  }
  if (elem_mask & mask) {
    strcpy(attrinfo[i].name, name);
    if (num)
      sprintf(&attrinfo[i].name[strlen(attrinfo[i].name)], "%d", num+1);
    strcat(attrinfo[i].name, ".Flash");
    attrinfo[i].value = &flash;
    attrinfo[i].type = glow_eType_Boolean;
    attrinfo[i++].size = sizeof(flash);
  }
  *item_count = i;
}

void GeDashDigital::set_attribute(
    grow_tObject object, const char* attr_name, int second)
{
  if (!second) {
    char msg[200];

    strncpy(attribute, attr_name, sizeof(attribute));
    snprintf(msg, sizeof(msg), "Digital.Attribute = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dash->graph->message('I', msg);
  }
}

void GeDashDigital::replace_attribute(
    char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(attribute, sizeof(attribute), from, to, cnt, strict);
}

void GeDashDigital::save(std::ofstream& fp)
{
  fp << int(dash_eSave_Digital) << '\n';
  fp << int(dash_eSave_Digital_attribute) << FSPACE << attribute << '\n';
  fp << int(dash_eSave_Digital_text) << FSPACE << text << '\n';
  fp << int(dash_eSave_Digital_color) << FSPACE << color << '\n';
  fp << int(dash_eSave_Digital_flash) << FSPACE << flash << '\n';
  fp << int(dash_eSave_End) << '\n';
}

void GeDashDigital::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];
  int tmp;

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error DashDigital: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case dash_eSave_Digital:
      break;
    case dash_eSave_Digital_attribute:
      fp.get();
      fp.getline(attribute, sizeof(attribute));
      break;
    case dash_eSave_Digital_text:
      fp.get();
      fp.getline(text, sizeof(text));
      break;
    case dash_eSave_Digital_color:
      fp >> tmp;
      color = (glow_eDrawType)tmp;
      break;
    case dash_eSave_Digital_flash:
      fp >> flash;
      break;
    case dash_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "DashDigital:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

//
// Object
//

void GeDashObject::get_script(grow_tObject o, char *script)
{
  switch (dash->elements) {
  case 1:
    sprintf(script, "\
#include <%s>\n\
main()\n\
%s(%llu,%u,\"%s\",%f,%d,\"%s\",\"%s\",%f,%f);\n\
endmain\n\
", 
	    script_filename(), type_info[dash->type].script, (long long unsigned)o, 
	    dash->elements, dash->title, dash->time_range, dash->direction, object, text,
	    min_value, max_value);
    break;
  default:
    ;
  }
}

void GeDashObject::get_attributes(attr_sItem* attrinfo, int* item_count, 
    char *name, unsigned int elem_mask, int num)
{
  int i = *item_count;
  unsigned int mask = 1;
  
  if (elem_mask & mask) {
    strcpy(attrinfo[i].name, name);
    if (num)
      sprintf(&attrinfo[i].name[strlen(attrinfo[i].name)], "%d", num+1);
    strcat(attrinfo[i].name, ".Object");
    attrinfo[i].value = object;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(object);
  }
  mask = mask << 1;
  if (elem_mask & mask) {
    strcpy(attrinfo[i].name, name);
    if (num)
      sprintf(&attrinfo[i].name[strlen(attrinfo[i].name)], "%d", num+1);
    strcat(attrinfo[i].name, ".Text");
    attrinfo[i].value = text;
    attrinfo[i].type = glow_eType_String;
    attrinfo[i++].size = sizeof(text);
  }
  mask = mask << 1;
  if (elem_mask & mask) {
    strcpy(attrinfo[i].name, name);
    if (num)
      sprintf(&attrinfo[i].name[strlen(attrinfo[i].name)], "%d", num+1);
    strcat(attrinfo[i].name, ".MinValue");
    attrinfo[i].value = &min_value;
    attrinfo[i].type = glow_eType_Double;
    attrinfo[i++].size = sizeof(min_value);
  }
  mask = mask << 1;
  if (elem_mask & mask) {    
    strcpy(attrinfo[i].name, name);
    if (num)
      sprintf(&attrinfo[i].name[strlen(attrinfo[i].name)], "%d", num+1);
    strcat(attrinfo[i].name, ".MaxValue");
    attrinfo[i].value = &max_value;
    attrinfo[i].type = glow_eType_Double;
    attrinfo[i++].size = sizeof(max_value);
  }
  *item_count = i;
}

void GeDashObject::set_attribute(
    grow_tObject o, const char* attr_name, int second)
{
  if (!second) {
    char msg[200];

    strncpy(object, attr_name, sizeof(object));
    snprintf(msg, sizeof(msg), "Object.Object = %s", attr_name);
    msg[sizeof(msg) - 1] = 0;
    dash->graph->message('I', msg);
  }
}

void GeDashObject::replace_attribute(
    char* from, char* to, int* cnt, int strict)
{
  GeDyn::replace_attribute(object, sizeof(object), from, to, cnt, strict);
}

void GeDashObject::save(std::ofstream& fp)
{
  fp << int(dash_eSave_Object) << '\n';
  fp << int(dash_eSave_Object_object) << FSPACE << object << '\n';
  fp << int(dash_eSave_Object_min_value) << FSPACE << min_value << '\n';
  fp << int(dash_eSave_Object_max_value) << FSPACE << max_value << '\n';
  fp << int(dash_eSave_Object_text) << FSPACE << text << '\n';
  fp << int(dash_eSave_End) << '\n';
}

void GeDashObject::open(std::ifstream& fp)
{
  int type = 0;
  int end_found = 0;
  char dummy[40];

  for (;;) {
    if (!fp.good()) {
      fp.clear();
      fp.getline(dummy, sizeof(dummy));
      printf("** Read error DashObject: \"%d %s\"\n", type, dummy);
    }

    fp >> type;

    switch (type) {
    case dash_eSave_Object:
      break;
    case dash_eSave_Object_object:
      fp.get();
      fp.getline(object, sizeof(object));
      break;
    case dash_eSave_Object_text:
      fp.get();
      fp.getline(text, sizeof(text));
      break;
    case dash_eSave_Object_min_value:
      fp >> min_value;
      break;
    case dash_eSave_Object_max_value:
      fp >> max_value;
      break;
    case dash_eSave_End:
      end_found = 1;
      break;
    default:
      std::cout << "DashObject:open syntax error\n";
      fp.getline(dummy, sizeof(dummy));
    }
    if (end_found)
      break;
  }
}

char* GeDashObject::script_filename()
{
  static pwr_tFileName fname;
  pwr_tAttrRef aref;
  pwr_tCid cid;
  pwr_tObjName cname;
  pwr_tTime time;
  pwr_tOid coid;
  pwr_tStatus sts;

  strcpy(fname, "");

  sts = gdh_NameToAttrref(pwr_cNObjid, object, &aref);
  if (EVEN(sts))
    return fname;

  sts = gdh_GetAttrRefTid(&aref, &cid);
  if (EVEN(sts))
    return fname;

  coid = cdh_ClassIdToObjid(cid);
  sts = gdh_ObjidToName(coid, cname, sizeof(cname), cdh_mName_object);
  if (EVEN(sts))
    return fname;

  sprintf(fname, "$pwrp_exe/dash_%s.ge_com", cdh_Low(cname));
  dcli_translate_filename(fname, fname);
  sts = dcli_file_time(fname, &time);
  if (EVEN(sts)) {
    sprintf(fname, "$pwr_exe/dash_c_%s.ge_com", cdh_Low(cname));
    dcli_translate_filename(fname, fname);
    sts = dcli_file_time(fname, &time);
  }
  if (EVEN(sts))
    strcpy(fname, "");
  return fname;
}

//
// Cell drawing functions
//

static void dabo_bar(GeDash *dash, grow_tObject g)
{
  double x1;
  double y1;
  double x2;
  double y2;
  double twidth;
  grow_tObject id;
  double gx1;
  double gx2;
  double gy1;
  double gy2;
  double gw;
  double gh;
  double tx;
  double ty;
  glow_eDirection direction;
  double theight, tdescent;
  GeDashAnalog *elem1, *elem2, *elem3;

  elem1 = (GeDashAnalog *)dash->elem[0];
  elem2 = (GeDashAnalog *)dash->elem[1];
  elem3 = (GeDashAnalog *)dash->elem[2];

  gsc_MeasureObject(dash->graph, g, &gx1, &gy1, &gx2, &gy2); 
  gw = gx2 - gx1;
  gh = gy2 - gy1;

  gsc_GetTextExtent(dash->graph, dash->title, 3, glow_eFont_LucidaSans, 0, &twidth, 
      &theight, &tdescent);
  x2 = (gx1 + gx2)/2 - twidth/2;
  y2 = gy1 + 1;
  id = gsc_CreateText(dash->graph, dash->title, x2, y2, 3, glow_eFont_LucidaSans, 0, 
      glow_eDrawType_CustomColor5);
  gsc_DashInsertObject(dash->graph, g, id);

  direction = dash->direction;
  if (direction == 0)
    direction = glow_eDirection_Down;

  if (direction == glow_eDirection_Down || direction == glow_eDirection_Up) {
    x1 = gx1 + 0.6;
    y1 = gy1 + 1.5;
    x2 = x1 + gw * 0.2 / dash->elements;
    y2 = gy2 - 0.4;
  } else {
    x1 = gx1 + 0.6;
    y1 = gy1 + 1.5;
    y2 = y1 + gh * 0.2 / dash->elements;
    x2 = gx2 - 0.4;
  }
  if (direction == glow_eDirection_Up)
    direction = glow_eDirection_Down;
  else if (direction == 0 || direction == glow_eDirection_Down)
    direction = glow_eDirection_Up;

  id = gsc_CreateBar(dash->graph, x1, y1, x2, y2, 1, direction);
  gsc_SetObjectAttribute(dash->graph, id, "Bar.Attribute", elem1->attribute, CCM_DECL_STRING);
  gsc_SetObjectAttribute(dash->graph, id, "Bar.MaxValue", &elem1->max_value, CCM_DECL_FLOAT);
  gsc_SetObjectAttribute(dash->graph, id, "Bar.MinValue", &elem1->min_value, CCM_DECL_FLOAT);
  gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Fast", CCM_DECL_STRING);
  gsc_SetObjectGradient(dash->graph, id, (glow_eGradient)2);
  gsc_DashInsertObject(dash->graph, g, id);

  if (dash->elements > 1) {
    if (direction == glow_eDirection_Down || direction == glow_eDirection_Up) {
      x1 = x2;
      y1 = gy1 + 1.5;
      x2 = x1 + gw * 0.2 / dash->elements;
      y2 = gy2 - 0.4;
    } else {
      y1 = y2;
      x1 = gx1 + 0.6;
      y2 = y1 + gh * 0.2 / dash->elements;
      x2 = gx2 - 0.4;
    }
    id = gsc_CreateBar(dash->graph, x1, y1, x2, y2, 1, direction);
    gsc_SetObjectAttribute(dash->graph, id, "Bar.Attribute", elem2->attribute, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Bar.MaxValue", &elem2->max_value, CCM_DECL_FLOAT);
    gsc_SetObjectAttribute(dash->graph, id, "Bar.MinValue", &elem2->min_value, CCM_DECL_FLOAT);
    gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Fast", CCM_DECL_STRING);
    gsc_SetObjectGradient(dash->graph, id, (glow_eGradient)2);
    gsc_DashInsertObject(dash->graph, g, id);
  }

  if (dash->elements > 2) {
    if (direction == glow_eDirection_Down || direction == glow_eDirection_Up) {
      x1 = x2;
      y1 = gy1 + 1.5;
      x2 = x1 + gw * 0.2 / dash->elements;
      y2 = gy2 - 0.4;
    } else {
      y1 = y2;
      x1 = gx1 + 0.6;
      y2 = y1 + gh * 0.2 / dash->elements;
      x2 = gx2 - 0.4;
    }
    id = gsc_CreateBar(dash->graph, x1, y1, x2, y2, 1, direction);
    gsc_SetObjectAttribute(dash->graph, id, "Bar.Attribute", elem3->attribute, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Bar.MaxValue", &elem3->max_value, CCM_DECL_FLOAT);
    gsc_SetObjectAttribute(dash->graph, id, "Bar.MinValue", &elem3->min_value, CCM_DECL_FLOAT);
    gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Fast", CCM_DECL_STRING);
    gsc_SetObjectGradient(dash->graph, id, (glow_eGradient)2);
    gsc_DashInsertObject(dash->graph, g, id);
  }

  if (direction == glow_eDirection_Down || direction == glow_eDirection_Up) {
    x1 = x2;
    x2 = x2 + 1.2;
    id = gsc_CreateAxis(dash->graph, x1, y1, x2, y2, 1, 0, glow_eDirection_Right);
  } else {
    y1 = y2 + 0.17;
    y2 = y1 + 0.7;
    id = gsc_CreateAxis(dash->graph, x1, y1, x2, y2, 1, 0, glow_eDirection_Down);
  }
  if (direction == glow_eDirection_Down || direction == glow_eDirection_Left) {
    gsc_SetObjectAttribute(dash->graph, id, "MaxValue", &elem1->max_value, CCM_DECL_FLOAT);
    gsc_SetObjectAttribute(dash->graph, id, "MinValue", &elem1->min_value, CCM_DECL_FLOAT);
  } else {
    gsc_SetObjectAttribute(dash->graph, id, "MaxValue", &elem1->min_value, CCM_DECL_FLOAT);
    gsc_SetObjectAttribute(dash->graph, id, "MinValue", &elem1->max_value, CCM_DECL_FLOAT);
  }
  int val = 5;
  gsc_SetObjectAttribute(dash->graph, id, "Lines", &val, CCM_DECL_INT);
  val = 2;
  gsc_SetObjectAttribute(dash->graph, id, "LongQuotient", &val, CCM_DECL_INT);
  gsc_SetObjectAttribute(dash->graph, id, "ValueQuotient", &val, CCM_DECL_INT);
  gsc_DashInsertObject(dash->graph, g, id);

  if (direction == glow_eDirection_Down || direction == glow_eDirection_Up) {
    x1 = gx1 + 0.45 * gw;
    y1 = (gy1 + gy2 + 1.5) / 2 - gh *0.35 - 0.1;
    x2 = x1 + 0.45 * gw;
    y2 = y1 + gh / 5.5;
  } else {
    x1 = gx1 + 0.65 * gw;
    y1 = y2 + 0.0;
    x2 = x1 + 0.30 * gw;
    y2 = y1 + gh / 8;

    tx = gx1 + 0.6;
    ty = y1 + 0.6;
    id = gsc_CreateText(dash->graph, elem1->text, tx, ty, 2, glow_eFont_LucidaSans, 0, 
	 glow_eDrawType_CustomColor5);
    gsc_DashInsertObject(dash->graph, g, id);
  }
  id = gsc_CreateObject(dash->graph, "pwrct_valuemediumcenter", x1, y1, x2, y2);
  val = 0;
  gsc_SetObjectAttribute(dash->graph, id, "Action", &val, CCM_DECL_INT);
  gsc_SetObjectAttribute(dash->graph, id, "Value.Attribute", elem1->attribute, CCM_DECL_STRING);
  gsc_SetObjectAttribute(dash->graph, id, "Value.Format", elem1->format, CCM_DECL_STRING);
  gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Slow", CCM_DECL_STRING);
  gsc_DashInsertObject(dash->graph, g, id);

  if (dash->elements > 1) {
    if (direction == glow_eDirection_Down || direction == glow_eDirection_Up) {
      y1 = y2 + 0.2;
      y2 = y1 + gh / 5.5;
    } else {
      y1 = y2;
      y2 = y1 + gh / 8;

      ty = y1 + 0.6;
      id = gsc_CreateText(dash->graph, elem2->text, tx, ty, 2, glow_eFont_LucidaSans, 0, 
	  glow_eDrawType_CustomColor5);
      gsc_DashInsertObject(dash->graph, g, id);
    }
    id = gsc_CreateObject(dash->graph, "pwrct_valuemediumcenter", x1, y1, x2, y2);
    val = 0;
    gsc_SetObjectAttribute(dash->graph, id, "Action", &val, CCM_DECL_INT);
    gsc_SetObjectAttribute(dash->graph, id, "Value.Attribute", elem2->attribute, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Value.Format", elem2->format, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Slow", CCM_DECL_STRING);
    gsc_DashInsertObject(dash->graph, g, id);
  }

  if (dash->elements > 2) {
    if (direction == glow_eDirection_Down || direction == glow_eDirection_Up) {
      y1 = y2 + 0.2;
      y2 = y1 + gh / 5.5;
    } else {
      y1 = y2;
      y2 = y1 + gh / 8;

      ty = y1 + 0.6;
      id = gsc_CreateText(dash->graph, elem3->text, tx, ty, 2, glow_eFont_LucidaSans, 0, 
          glow_eDrawType_CustomColor5);
      gsc_DashInsertObject(dash->graph, g, id);
    }
    id = gsc_CreateObject(dash->graph, "pwrct_valuemediumcenter", x1, y1, x2, y2);
    val = 0;
    gsc_SetObjectAttribute(dash->graph, id, "Action", &val, CCM_DECL_INT);
    gsc_SetObjectAttribute(dash->graph, id, "Value.Attribute", elem3->attribute, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Value.Format", elem3->format, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Slow", CCM_DECL_STRING);
    gsc_DashInsertObject(dash->graph, g, id);
  }
}

static void dabo_bararc(GeDash *dash, grow_tObject g)
{
  double x1;
  double y1;
  double x2;
  double y2;
  double twidth;
  double theight;
  double tdescent;
  grow_tObject id;
  double gx1;
  double gx2;
  double gy1;
  double gy2;
  double gw;
  double gh;
  double barwidth;
  int ival;
  GeDashAnalog *elem1;

  elem1 = (GeDashAnalog *)dash->elem[0];
    
  gsc_MeasureObject(dash->graph, g, &gx1, &gy1, &gx2, &gy2); 
  gw = gx2 - gx1;
  gh = gy2 - gy1;

  gsc_GetTextExtent(dash->graph, dash->title, 3, glow_eFont_LucidaSans, 0, &twidth, &theight, &tdescent);
  x2 = (gx1 + gx2)/2 - twidth/2;
  y2 = gy1 + 1;
  id = gsc_CreateText(dash->graph, dash->title, x2, y2, 3, glow_eFont_LucidaSans, 0, glow_eDrawType_CustomColor5);
  gsc_DashInsertObject(dash->graph, g, id);

  x1 = gx1 + 0.4;
  y1 = gy1 + 1.5;
  x2 = gx2 - 0.4;
  y2 = gy2;
  id = gsc_CreateBarArc(dash->graph, x1, y1, x2, y2, 1);
  gsc_SetObjectAttribute(dash->graph, id, "Bar.Attribute", &elem1->attribute, CCM_DECL_STRING);
  gsc_SetObjectAttribute(dash->graph, id, "BarArc.MaxValue", &elem1->max_value, CCM_DECL_FLOAT);
  gsc_SetObjectAttribute(dash->graph, id, "BarArc.MinValue", &elem1->min_value, CCM_DECL_FLOAT);
  ival = -45;
  gsc_SetObjectAttribute(dash->graph, id, "BarArc.Angle1", &ival, CCM_DECL_INT);
  ival = 270;
  gsc_SetObjectAttribute(dash->graph, id, "BarArc.Angle2", &ival, CCM_DECL_INT);
  barwidth = (gw - 0.8) / 8;
  gsc_SetObjectAttribute(dash->graph, id, "BarArc.BarWidth", &barwidth, CCM_DECL_FLOAT);
  gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void *)"Fast", CCM_DECL_STRING);
  gsc_SetObjectGradient(dash->graph, id, (glow_eGradient)2);
  if (dash->direction == glow_eDirection_Up || dash->direction == glow_eDirection_Right) {
    ival = 1;
    gsc_SetObjectAttribute(dash->graph, id, "BarArc.Direction", &ival, CCM_DECL_INT);
  }

  gsc_DashInsertObject(dash->graph, g, id);

  x1 = gx1 + 0.4 + barwidth;
  y1 = gy1 + 1.5 + (gh - 1.5 - 0.4/gw*gh) / 8;
  x2 = gx2 - 0.4 - barwidth;
  y2 = gy2 - (gh - 1.5 - 0.4/gw*gh) / 8;
  id = gsc_CreateAxisArc(dash->graph, x1, y1, x2, y2, 1, 0);
  if (dash->direction == glow_eDirection_Up || dash->direction == glow_eDirection_Right) {
    gsc_SetObjectAttribute(dash->graph, id, "MaxValue", &elem1->min_value, CCM_DECL_FLOAT);
    gsc_SetObjectAttribute(dash->graph, id, "MinValue", &elem1->max_value, CCM_DECL_FLOAT);
  } else {
    gsc_SetObjectAttribute(dash->graph, id, "MaxValue", &elem1->max_value, CCM_DECL_FLOAT);
    gsc_SetObjectAttribute(dash->graph, id, "MinValue", &elem1->min_value, CCM_DECL_FLOAT);
  }
  ival = -45;
  gsc_SetObjectAttribute(dash->graph, id, "Angle1", &ival, CCM_DECL_INT);
  ival = 270;
  gsc_SetObjectAttribute(dash->graph, id, "Angle2", &ival, CCM_DECL_INT);
  ival = 5;
  gsc_SetObjectAttribute(dash->graph, id, "Lines", &ival, CCM_DECL_INT);
  ival = 1;
  gsc_SetObjectAttribute(dash->graph, id, "LongQuotient", &ival, CCM_DECL_INT);
  ival = 4;
  gsc_SetObjectAttribute(dash->graph, id, "ValueQuotient", &ival, CCM_DECL_INT);
  gsc_DashInsertObject(dash->graph, g, id);

  x1 = gx1 + 0.28 * gw;
  y1 = (gy1 + gy2 + 1.5) / 2 - gh / 10 - 0.1;
  x2 = gx1 + 0.72 * gw;
  y2 = y1 + gh / 5;
  id = gsc_CreateObject(dash->graph, "pwrct_valuemediumcenter", x1, y1, x2, y2);
  ival = 0;
  gsc_SetObjectAttribute(dash->graph, id, "Action", &ival, CCM_DECL_INT);
  gsc_SetObjectAttribute(dash->graph, id, "Value.Attribute", elem1->attribute, CCM_DECL_STRING);
  gsc_SetObjectAttribute(dash->graph, id, "Value.Format", elem1->format, CCM_DECL_STRING);
  gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void *)"Slow", CCM_DECL_STRING);
  gsc_DashInsertObject(dash->graph, g, id);
}

static void dabo_trend(GeDash *dash, grow_tObject g)
{
  double x1;
  double y1;
  double x2;
  double y2;
  double twidth, theight, tdescent;
  grow_tObject id;
  double gx1;
  double gx2;
  double gy1;
  double gy2;
  double gw;
  double gh;
  double scantime;
  int ival;
  GeDashAnalog *elem1, *elem2;

  elem1 = (GeDashAnalog *)dash->elem[0];
  elem2 = (GeDashAnalog *)dash->elem[1];
    
  gsc_MeasureObject(dash->graph, g, &gx1, &gy1, &gx2, &gy2); 
  gw = gx2 - gx1;
  gh = gy2 - gy1;

  gsc_GetTextExtent(dash->graph, dash->title, 3, glow_eFont_LucidaSans, 0, &twidth, &theight, &tdescent);
  x2 = (gx1 + gx2)/2 - twidth/2;
  y2 = gy1 + 1;
  id = gsc_CreateText(dash->graph, dash->title, x2, y2, 3, glow_eFont_LucidaSans, 0, glow_eDrawType_CustomColor5);
  gsc_DashInsertObject(dash->graph, g, id);

  if (dash->time_range != 0)
    scantime = dash->time_range / 100.0;
  else
    scantime = 0.5;

  x1 = gx2 - 2.2;
  y1 = gy1 + 0.5;
  x2 = x1 + 1.6;
  y2 = y1 + 0.8;
  id = gsc_CreateObject(dash->graph, "pwrct_buttonsmalltoggle", x1, y1, x2, y2);
  gsc_SetObjectAttribute(dash->graph, id, "Text", (void*)"Hold", CCM_DECL_STRING);
  ival = ge_mDynType1_DigColor;
  gsc_SetObjectAttribute(dash->graph, id, "DynType1", &ival, CCM_DECL_INT);
  gsc_SetObjectAttribute(dash->graph, id, "ToggleDig.Attribute", (void*)"$local.TrendHold##Boolean", CCM_DECL_STRING);
  gsc_SetObjectAttribute(dash->graph, id, "DigColor.Attribute", (void*)"$local.TrendHold##Boolean", CCM_DECL_STRING);
  ival = glow_eDrawType_CustomColor35;
  gsc_SetObjectAttribute(dash->graph, id, "DigColor.Color", &ival, CCM_DECL_INT);
  gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Fast", CCM_DECL_STRING);
  gsc_DashInsertObject(dash->graph, g, id);

  x1 = gx1 + 1.3;
  y1 = gy1 + 1.5;
  x2 = gx2 - 0.6;
  y2 = gy2 - 0.3;
  id = gsc_CreateTrend(dash->graph, x1, y1, x2, y2, 1);
  if (dash->direction == glow_eDirection_Right) {
    ival = glow_eDirection_Right;
    gsc_SetObjectAttribute(dash->graph, id, "Trend.Direction", &ival, CCM_DECL_INT);
  }
  gsc_SetObjectAttribute(dash->graph, id, "Trend.Attribute1", elem1->attribute, CCM_DECL_STRING);
  gsc_SetObjectAttribute(dash->graph, id, "Trend.MaxValue1", &elem1->max_value, CCM_DECL_FLOAT);
  gsc_SetObjectAttribute(dash->graph, id, "Trend.MinValue1", &elem1->min_value, CCM_DECL_FLOAT);
  if (dash->elements > 1) {
    gsc_SetObjectAttribute(dash->graph, id, "Trend.Attribute2", elem2->attribute, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Trend.MaxValue2", &elem2->max_value, CCM_DECL_FLOAT);
    gsc_SetObjectAttribute(dash->graph, id, "Trend.MinValue2", &elem2->min_value, CCM_DECL_FLOAT);
    ival = glow_eDrawType_CustomColor27;
    gsc_SetObjectAttribute(dash->graph, id, "Trend.CurveColor2", &ival, CCM_DECL_INT);
  }
  gsc_SetObjectAttribute(dash->graph, id, "Trend.ScanTime", &scantime, CCM_DECL_FLOAT);
  gsc_SetObjectAttribute(dash->graph, id, "Trend.HoldAttr", (void*)"$local.TrendHold##Boolean", CCM_DECL_STRING);
  gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Fast", CCM_DECL_STRING);
  gsc_DashInsertObject(dash->graph, g, id);

  x1 = gx1 + 0.1;
  y1 = gy1 + 1.5;
  x2 = x1 + 1.2;
  y2 = gy2 - 0.3;
  id = gsc_CreateAxis(dash->graph, x1, y1, x2, y2, 1, 0, glow_eDirection_Left);
  gsc_SetObjectAttribute(dash->graph, id, "MaxValue", &elem1->max_value, CCM_DECL_FLOAT);
  gsc_SetObjectAttribute(dash->graph, id, "MinValue", &elem1->min_value, CCM_DECL_FLOAT);
  gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Fast", CCM_DECL_STRING);
  ival = 11;
  gsc_SetObjectAttribute(dash->graph, id, "Lines", &ival, CCM_DECL_INT);
  ival = 2;
  gsc_SetObjectAttribute(dash->graph, id, "LongQuotient", &ival, CCM_DECL_INT);
  ival = 2;
  gsc_SetObjectAttribute(dash->graph, id, "ValueQuotient", &ival, CCM_DECL_INT);
  gsc_DashInsertObject(dash->graph, g, id);
}

static void dabo_ind(GeDash *dash, grow_tObject g)
{
  double x1;
  double y1;
  double x2;
  double y2;
  double twidth;
  double theight;
  double tdescent;
  int tsize;
  double tx;
  double ty;
  grow_tObject id;
  double gx1;
  double gx2;
  double gy1;
  double gy2;
  double gw;
  double gh;    
  int ival;
  GeDashDigital *elem1, *elem2, *elem3, *elem4, *elem5;

  elem1 = (GeDashDigital *)dash->elem[0];
  elem2 = (GeDashDigital *)dash->elem[1];
  elem3 = (GeDashDigital *)dash->elem[2];
  elem4 = (GeDashDigital *)dash->elem[3];
  elem5 = (GeDashDigital *)dash->elem[4];

  gsc_MeasureObject(dash->graph, g, &gx1, &gy1, &gx2, &gy2); 
  gw = gx2 - gx1;
  gh = gy2 - gy1;

  tsize = 2;

  gsc_GetTextExtent(dash->graph, dash->title, 3, glow_eFont_LucidaSans, 0, &twidth, &theight, &tdescent);
  x2 = (gx1 + gx2)/2 - twidth/2;
  y2 = gy1 + 1;
  id = gsc_CreateText(dash->graph, dash->title, x2, y2, 3, glow_eFont_LucidaSans, 0, glow_eDrawType_CustomColor5);
  gsc_DashInsertObject(dash->graph, g, id);

  x1 = gx1 + 0.5;
  y1 = gy1 + 1.3;
  id = gsc_CreateObject(dash->graph, "pwrct_indsquaregreen", x1, y1, 0, 0);
  if (elem1->flash) {
    gsc_SetObjectFillColor(dash->graph, id, glow_eDrawType_CustomColor17);
    ival = ge_mDynType1_DigFlash;
    gsc_SetObjectAttribute(dash->graph, id, "DynType1", &ival, CCM_DECL_INT);
    gsc_SetObjectAttribute(dash->graph, id, "DigFlash.Attribute", elem1->attribute, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "DigFlash.Color", &elem1->color, CCM_DECL_INT);
  } else {
    gsc_SetObjectFillColor(dash->graph, id, elem1->color);
    gsc_SetObjectAttribute(dash->graph, id, "DigLowColor.Attribute", elem1->attribute, CCM_DECL_STRING);
  }
  gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void *)"Fast", CCM_DECL_STRING);
  gsc_DashInsertObject(dash->graph, g, id);

  tx = gx1 + 1.5;
  ty = gy1 + 1.9;
  id = gsc_CreateText(dash->graph, elem1->text, tx, ty, tsize, glow_eFont_LucidaSans, 0, glow_eDrawType_CustomColor5);
  gsc_DashInsertObject(dash->graph, g, id);
 
  if (dash->elements > 1) {
    y1 += 0.9;
    id = gsc_CreateObject(dash->graph, "pwrct_indsquaregreen", x1, y1, 0, 0);
    if (elem2->flash) {
      gsc_SetObjectFillColor(dash->graph, id, glow_eDrawType_CustomColor17);
      ival = ge_mDynType1_DigFlash;
      gsc_SetObjectAttribute(dash->graph, id, "DynType1", &ival, CCM_DECL_INT);
      gsc_SetObjectAttribute(dash->graph, id, "DigFlash.Attribute", elem2->attribute, CCM_DECL_STRING);
      gsc_SetObjectAttribute(dash->graph, id, "DigFlash.Color", &elem2->color, CCM_DECL_INT);
    } else {
      gsc_SetObjectFillColor(dash->graph, id, elem2->color);
      gsc_SetObjectAttribute(dash->graph, id, "DigLowColor.Attribute", elem2->attribute, CCM_DECL_STRING);
    }
    gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void *)"Fast", CCM_DECL_STRING);
    gsc_DashInsertObject(dash->graph, g, id);

    ty += 0.9;
    id = gsc_CreateText(dash->graph, elem2->text, tx, ty, tsize, glow_eFont_LucidaSans, 0, glow_eDrawType_CustomColor5);
    gsc_DashInsertObject(dash->graph, g, id);
  }
 
  if (dash->elements > 2) {
    y1 += 0.9;
    id = gsc_CreateObject(dash->graph, "pwrct_indsquaregreen", x1, y1, 0, 0);
    if (elem3->flash) {
      gsc_SetObjectFillColor(dash->graph, id, glow_eDrawType_CustomColor17);
      ival = ge_mDynType1_DigFlash;
      gsc_SetObjectAttribute(dash->graph, id, "DynType1", &ival, CCM_DECL_INT);
      gsc_SetObjectAttribute(dash->graph, id, "DigFlash.Attribute", elem3->attribute, CCM_DECL_STRING);
      gsc_SetObjectAttribute(dash->graph, id, "DigFlash.Color", &elem3->color, CCM_DECL_INT);
    } else {
      gsc_SetObjectFillColor(dash->graph, id, elem3->color);
      gsc_SetObjectAttribute(dash->graph, id, "DigLowColor.Attribute", elem3->attribute, CCM_DECL_STRING);
    }
    gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void *)"Fast", CCM_DECL_STRING);
    gsc_DashInsertObject(dash->graph, g, id);

    ty += 0.9;
    id = gsc_CreateText(dash->graph, elem3->text, tx, ty, tsize, glow_eFont_LucidaSans, 0, glow_eDrawType_CustomColor5);
    gsc_DashInsertObject(dash->graph, g, id);
  }
 
  if (dash->elements > 3) {
    y1 += 0.9;
    id = gsc_CreateObject(dash->graph, "pwrct_indsquaregreen", x1, y1, 0, 0);
    if (elem4->flash) {
      gsc_SetObjectFillColor(dash->graph, id, glow_eDrawType_CustomColor17);
      ival = ge_mDynType1_DigFlash;
      gsc_SetObjectAttribute(dash->graph, id, "DynType1", &ival, CCM_DECL_INT);
      gsc_SetObjectAttribute(dash->graph, id, "DigFlash.Attribute", elem4->attribute, CCM_DECL_STRING);
      gsc_SetObjectAttribute(dash->graph, id, "DigFlash.Color", &elem4->color, CCM_DECL_INT);
    } else {
      gsc_SetObjectFillColor(dash->graph, id, elem4->color);
      gsc_SetObjectAttribute(dash->graph, id, "DigLowColor.Attribute", elem4->attribute, CCM_DECL_STRING);
    }
    gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void *)"Fast", CCM_DECL_STRING);
    gsc_DashInsertObject(dash->graph, g, id);

    ty += 0.9;
    id = gsc_CreateText(dash->graph, elem4->text, tx, ty, tsize, glow_eFont_LucidaSans, 0, glow_eDrawType_CustomColor5);
    gsc_DashInsertObject(dash->graph, g, id);
  }
 
  if (dash->elements > 4) {
    y1 += 0.9;
    id = gsc_CreateObject(dash->graph, "pwrct_indsquaregreen", x1, y1, 0, 0);
    if (elem5->flash) {
      gsc_SetObjectFillColor(dash->graph, id, glow_eDrawType_CustomColor17);
      ival = ge_mDynType1_DigFlash;
      gsc_SetObjectAttribute(dash->graph, id, "DynType1", &ival, CCM_DECL_INT);
      gsc_SetObjectAttribute(dash->graph, id, "DigFlash.Attribute", elem5->attribute, CCM_DECL_STRING);
      gsc_SetObjectAttribute(dash->graph, id, "DigFlash.Color", &elem5->color, CCM_DECL_INT);
    } else {
      gsc_SetObjectFillColor(dash->graph, id, elem5->color);
      gsc_SetObjectAttribute(dash->graph, id, "DigLowColor.Attribute", elem5->attribute, CCM_DECL_STRING);
    }
    gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void *)"Fast", CCM_DECL_STRING);
    gsc_DashInsertObject(dash->graph, g, id);

    ty += 0.9;
    id = gsc_CreateText(dash->graph, elem5->text, tx, ty, tsize, glow_eFont_LucidaSans, 0, glow_eDrawType_CustomColor5);
    gsc_DashInsertObject(dash->graph, g, id);
  }
}

static void dabo_digtrend(GeDash *dash, grow_tObject g)
{
  double x1;
  double y1;
  double x2;
  double y2;
  double tx;
  double ty;
  double twidth;
  double theight;
  double tdescent;
  int tsize;
  grow_tObject id;
  double gx1;
  double gx2;
  double gy1;
  double gy2;
  double gw;
  double gh;
  double scantime;
  int ival;
  double fval;
  GeDashDigital *elem1, *elem2, *elem3, *elem4, *elem5;

  elem1 = (GeDashDigital *)dash->elem[0];
  elem2 = (GeDashDigital *)dash->elem[1];
  elem3 = (GeDashDigital *)dash->elem[2];
  elem4 = (GeDashDigital *)dash->elem[3];
  elem5 = (GeDashDigital *)dash->elem[4];
    
  gsc_MeasureObject(dash->graph, g, &gx1, &gy1, &gx2, &gy2); 
  gw = gx2 - gx1;
  gh = gy2 - gy1;

  if (gh < 7) {
    tsize = 0;
    gsc_GetTextExtent(dash->graph, (char*)"ABCD", tsize, glow_eFont_LucidaSans, 0, &twidth, &theight, &tdescent);
    theight = theight * 0.9;
  } else {
    tsize = 2;
    gsc_GetTextExtent(dash->graph, (char*)"ABCD", tsize, glow_eFont_LucidaSans, 0, &twidth, &theight, &tdescent);
    theight = theight * 1.1;
  }

  gsc_GetTextExtent(dash->graph, dash->title, 3, glow_eFont_LucidaSans, 0, &twidth, &theight, &tdescent);
  x2 = (gx1 + gx2)/2 - twidth/2;
  y2 = gy1 + 1;
  id = gsc_CreateText(dash->graph, dash->title, x2, y2, 3, glow_eFont_LucidaSans, 0, glow_eDrawType_CustomColor5);
  gsc_DashInsertObject(dash->graph, g, id);

  gh -= 1.5;

  if (dash->time_range != 0)
    scantime = dash->time_range / 100.0;
  else
    scantime = 0.5;

  x1 = gx2 - 2.1;
  y1 = gy2 - gh *2 / 3 - 1.1;
  x2 = x1 + 1.6;
  y2 = y1 + 0.8;
  id = gsc_CreateObject(dash->graph, "pwrct_buttonsmalltoggle", x1, y1, x2, y2);
  gsc_SetObjectAttribute(dash->graph, id, "Text", (void *)"Hold", CCM_DECL_STRING);
  ival = ge_mDynType1_DigColor;
  gsc_SetObjectAttribute(dash->graph, id, "DynType1", &ival, CCM_DECL_INT);
  gsc_SetObjectAttribute(dash->graph, id, "ToggleDig.Attribute", (void*)"$local.DigTrendHold##Boolean", CCM_DECL_STRING);
  gsc_SetObjectAttribute(dash->graph, id, "DigColor.Attribute", (void*)"$local.DigTrendHold##Boolean", CCM_DECL_STRING);
  ival = glow_eDrawType_CustomColor35;
  gsc_SetObjectAttribute(dash->graph, id, "DigColor.Color", &ival, CCM_DECL_INT);
  gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Fast", CCM_DECL_STRING);
  gsc_DashInsertObject(dash->graph, g, id);

  x1 = gx1 + 0.5;
  x2 = gx1 + gw - 0.5;
  y1 = gy2 - gh *2 / 3;
  y2 = y1 + gh / 8;
  id = gsc_CreateTrend(dash->graph, x1, y1, x2, y2, 1);
  if (dash->direction == glow_eDirection_Right) {
    ival =  glow_eDirection_Right;
    gsc_SetObjectAttribute(dash->graph, id, "Trend.Direction", &ival, CCM_DECL_INT);
  }
  gsc_SetObjectAttribute(dash->graph, id, "Trend.Attribute1", elem1->attribute, CCM_DECL_STRING);
  gsc_SetObjectAttribute(dash->graph, id, "Trend.HoldAttr", (void*)"$local.DigTrendHold##Boolean", CCM_DECL_STRING);
  fval = 1.3;
  gsc_SetObjectAttribute(dash->graph, id, "Trend.MaxValue1", &fval, CCM_DECL_FLOAT);
  fval = -0.1;
  gsc_SetObjectAttribute(dash->graph, id, "Trend.MinValue1", &fval, CCM_DECL_FLOAT);
  ival = 0;
  gsc_SetObjectAttribute(dash->graph, id, "Trend.HorizontalLines", &ival, CCM_DECL_INT);
  gsc_SetObjectAttribute(dash->graph, id, "Trend.ScanTime", &scantime, CCM_DECL_FLOAT);
  gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Fast", CCM_DECL_STRING);
  gsc_DashInsertObject(dash->graph, g, id);

  tx = gx1 + 0.5;
  ty = gy2 - gh * 2 / 3 - theight * dash->elements + 0.3;
  id = gsc_CreateText(dash->graph, elem1->text, tx, ty, tsize, glow_eFont_LucidaSans, 0, glow_eDrawType_CustomColor5);
  gsc_DashInsertObject(dash->graph, g, id);
 
  if (dash->elements > 1) {
    y1 = y2;
    y2 = y1 + gh / 8;
    id = gsc_CreateTrend(dash->graph, x1, y1, x2, y2, 1);
    if (dash->direction == glow_eDirection_Right) {
      ival = glow_eDirection_Right;
      gsc_SetObjectAttribute(dash->graph, id, "Trend.Direction", &ival, CCM_DECL_INT);
    }
    gsc_SetObjectAttribute(dash->graph, id, "Trend.Attribute1", elem2->attribute, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Trend.HoldAttr", (void*)"$local.DigTrendHold##Boolean", CCM_DECL_STRING);
    fval = 1.3;
    gsc_SetObjectAttribute(dash->graph, id, "Trend.MaxValue1", &fval, CCM_DECL_FLOAT);
    fval = -0.1;
    gsc_SetObjectAttribute(dash->graph, id, "Trend.MinValue1", &fval, CCM_DECL_FLOAT);
    ival = 0;
    gsc_SetObjectAttribute(dash->graph, id, "Trend.HorizontalLines", &ival, CCM_DECL_INT);
    gsc_SetObjectAttribute(dash->graph, id, "Trend.ScanTime", &scantime, CCM_DECL_FLOAT);
    gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Fast", CCM_DECL_STRING);
    gsc_DashInsertObject(dash->graph, g, id);

    ty += theight;
    id = gsc_CreateText(dash->graph, elem2->text, tx, ty, tsize, glow_eFont_LucidaSans, 0, glow_eDrawType_CustomColor5);
    gsc_DashInsertObject(dash->graph, g, id);
  }
 
  if (dash->elements > 2) {
    y1 = y2;
    y2 = y1 + gh / 8;
    id = gsc_CreateTrend(dash->graph, x1, y1, x2, y2, 1);
    if (dash->direction == glow_eDirection_Right) {
      ival = glow_eDirection_Right;
      gsc_SetObjectAttribute(dash->graph, id, "Trend.Direction", &ival, CCM_DECL_INT);
    }
    gsc_SetObjectAttribute(dash->graph, id, "Trend.Attribute1", elem3->attribute, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Trend.HoldAttr", (void*)"$local.DigTrendHold##Boolean", CCM_DECL_STRING);
    fval = 1.3;
    gsc_SetObjectAttribute(dash->graph, id, "Trend.MaxValue1", &fval, CCM_DECL_FLOAT);
    fval = -0.1;
    gsc_SetObjectAttribute(dash->graph, id, "Trend.MinValue1", &fval, CCM_DECL_FLOAT);
    ival = 0;
    gsc_SetObjectAttribute(dash->graph, id, "Trend.HorizontalLines", &ival, CCM_DECL_INT);
    gsc_SetObjectAttribute(dash->graph, id, "Trend.ScanTime", &scantime, CCM_DECL_FLOAT);
    gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Fast", CCM_DECL_STRING);
    gsc_DashInsertObject(dash->graph, g, id);

    ty += theight;
    id = gsc_CreateText(dash->graph, elem3->text, tx, ty, tsize, glow_eFont_LucidaSans, 0, glow_eDrawType_CustomColor5);
    gsc_DashInsertObject(dash->graph, g, id);
  }
 
  if (dash->elements > 3) {
    y1 = y2;
    y2 = y1 + gh / 8;
    id = gsc_CreateTrend(dash->graph, x1, y1, x2, y2, 1);
    if (dash->direction == glow_eDirection_Right) {
      ival = glow_eDirection_Right;
      gsc_SetObjectAttribute(dash->graph, id, "Trend.Direction", &ival, CCM_DECL_INT);
    }
    gsc_SetObjectAttribute(dash->graph, id, "Trend.Attribute1", elem4->attribute, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Trend.HoldAttr", (void*)"$local.DigTrendHold##Boolean", CCM_DECL_STRING);
    fval = 1.3;
    gsc_SetObjectAttribute(dash->graph, id, "Trend.MaxValue1", &fval, CCM_DECL_FLOAT);
    fval = -0.1;
    gsc_SetObjectAttribute(dash->graph, id, "Trend.MinValue1", &fval, CCM_DECL_FLOAT);
    ival = 0;
    gsc_SetObjectAttribute(dash->graph, id, "Trend.HorizontalLines", &ival, CCM_DECL_INT);
    gsc_SetObjectAttribute(dash->graph, id, "Trend.ScanTime", &scantime, CCM_DECL_FLOAT);
    gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Fast", CCM_DECL_STRING);
    gsc_DashInsertObject(dash->graph, g, id);

    ty += theight;
    id = gsc_CreateText(dash->graph, elem4->text, tx, ty, tsize, glow_eFont_LucidaSans, 0, glow_eDrawType_CustomColor5);
    gsc_DashInsertObject(dash->graph, g, id);
  }
 
  if (dash->elements > 4) {
    y1 = y2;
    y2 = y1 + gh / 8;
    id = gsc_CreateTrend(dash->graph, x1, y1, x2, y2, 1);
    if (dash->direction == glow_eDirection_Right) {
      ival = glow_eDirection_Right;
      gsc_SetObjectAttribute(dash->graph, id, "Trend.Direction", &ival, CCM_DECL_INT);
    }
    gsc_SetObjectAttribute(dash->graph, id, "Trend.Attribute1", elem5->attribute, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Trend.HoldAttr", (void*)"$local.DigTrendHold##Boolean", CCM_DECL_STRING);
    fval = 1.3;
    gsc_SetObjectAttribute(dash->graph, id, "Trend.MaxValue1", &fval, CCM_DECL_FLOAT);
    fval = -0.1;
    gsc_SetObjectAttribute(dash->graph, id, "Trend.MinValue1", &fval, CCM_DECL_FLOAT);
    ival = 0;
    gsc_SetObjectAttribute(dash->graph, id, "Trend.HorizontalLines", &ival, CCM_DECL_INT);
    gsc_SetObjectAttribute(dash->graph, id, "Trend.ScanTime", &scantime, CCM_DECL_FLOAT);
    gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Fast", CCM_DECL_STRING);
    gsc_DashInsertObject(dash->graph, g, id);

    ty += theight;
    id = gsc_CreateText(dash->graph, elem5->text, tx, ty, tsize, glow_eFont_LucidaSans, 0, glow_eDrawType_CustomColor5);
    gsc_DashInsertObject(dash->graph, g, id);
  }
} 

static void dabo_gauge(GeDash *dash, grow_tObject g)
{
  double x1;
  double y1;
  double x2;
  double y2;
  double y0;
  double twidth, theight, tdescent;
  double vheight;
  grow_tObject id;
  double gx1;
  double gx2;
  double gy1;
  double gy2;
  double gw;
  double gh;
  double rfact;
  double roffset;
  double awidth;
  int cols;
  int ival;
  double fval;
  GeDashAnalog *elem1, *elem2, *elem3;

  elem1 = (GeDashAnalog *)dash->elem[0];
  elem2 = (GeDashAnalog *)dash->elem[1];
  elem3 = (GeDashAnalog *)dash->elem[2];
    
  gsc_GetObjectAttribute(dash->graph, g, "Dash.CellColumns", &cols, sizeof(cols), CCM_DECL_INT);
  
  gsc_MeasureObject(dash->graph, g, &gx1, &gy1, &gx2, &gy2);
  gw = gx2 - gx1;
  gh = gy2 - gy1;

  if (strcmp(dash->title, "") != 0) {
    gsc_GetTextExtent(dash->graph, dash->title, 3, glow_eFont_LucidaSans, 0, &twidth, &theight, &tdescent);
    x2 = (gx1 + gx2)/2 - twidth/2;
    y2 = gy1 + 1;
    id = gsc_CreateText(dash->graph, dash->title, x2, y2, 3, glow_eFont_LucidaSans, 0, glow_eDrawType_CustomColor5);
    gsc_DashInsertObject(dash->graph, g, id);
  }

  gh -= 1.5;
  y0 = gy1 + 1.3 + 0.05 * gh;

  if (gw * 1.2 < gh)
    awidth = gw * 1.2;
  else
    awidth = gh * 2;

  // Top shadow
  x1 = (gx1 + gx2) / 2 - awidth / 2 - 0.2;
  y1 = y0 - 0.2;
  x2 = x1 + awidth + 0.4;
  y2 = y1 + awidth + 0.4;
  id = gsc_CreateArc(dash->graph, x1, y1, x2, y2, 44, 92);
  gsc_SetObjectFill(dash->graph, id, 1);
  gsc_SetObjectBorder(dash->graph, id, 0);
  gsc_SetObjectFillColor(dash->graph, id, glow_eDrawType_CustomColor1);
  ival = 1;
  gsc_SetObjectAttribute(dash->graph, id, "fill_eq_shadow", &ival, CCM_DECL_INT);
  gsc_SetObjectAttribute(dash->graph, id, "fixcolor", &ival, CCM_DECL_INT);
  gsc_DashInsertObject(dash->graph, g, id);

  // Display
  x1 = (gx1 + gx2) / 2 - awidth / 2;
  y1 = y0;
  x2 = x1 + awidth;
  y2 = y1 + awidth;
  id = gsc_CreateArc(dash->graph, x1, y1, x2, y2, 45, 90);
  gsc_SetObjectFill(dash->graph, id, 1);
  gsc_SetObjectFillColor(dash->graph, id, glow_eDrawType_CustomColor21);
  gsc_DashInsertObject(dash->graph, g, id);

  // Needle
  x1 = gx1 + gw / 2 - gw * 0.01;
  y1 = y0;
  x2 = x1 + gw * 0.02;
  y2 = y1 + awidth / 2;
  id = gsc_CreateObject(dash->graph, "pwr_needle2", x1, y1, x2, y2);	
  gsc_SetObjectFillColor(dash->graph, id, glow_eDrawType_CustomColor23);
  gsc_SetObjectAttribute(dash->graph, id, "Rotate.Attribute", elem1->attribute, CCM_DECL_STRING);
  gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Fast", CCM_DECL_STRING);
  rfact = 90.0 / (elem1->max_value - elem1->min_value);
  roffset = -(elem1->max_value + elem1->min_value) * rfact / 2.0;
  gsc_SetObjectAttribute(dash->graph, id, "Rotate.Factor", &rfact, CCM_DECL_FLOAT);
  gsc_SetObjectAttribute(dash->graph, id, "Rotate.Offset", &roffset, CCM_DECL_FLOAT);
  fval = -45.0;
  gsc_SetObjectAttribute(dash->graph, id, "Rotate.MinAngle", &fval, CCM_DECL_FLOAT);
  fval = 45.0;
  gsc_SetObjectAttribute(dash->graph, id, "Rotate.MaxAngle", &fval, CCM_DECL_FLOAT);
  gsc_SetObjectShadow(dash->graph, id, 1);
  gsc_DashInsertObject(dash->graph, g, id);

  // Needle element 2
  if (dash->elements > 1) {
    x1 = gx1 + gw / 2 - gw * 0.01;
    y1 = y0;
    x2 = x1 + gw * 0.02;
    y2 = y1 + awidth / 2;
    id = gsc_CreateObject(dash->graph, "pwr_needle2", x1, y1, x2, y2);	
    gsc_SetObjectFillColor(dash->graph, id, glow_eDrawType_CustomColor87);
    gsc_SetObjectAttribute(dash->graph, id, "Rotate.Attribute", elem2->attribute, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Fast", CCM_DECL_STRING);
    rfact = 90.0 / (elem2->max_value - elem2->min_value);
    roffset = -(elem2->max_value + elem2->min_value) * rfact / 2.0;
    gsc_SetObjectAttribute(dash->graph, id, "Rotate.Factor", &rfact, CCM_DECL_FLOAT);
    gsc_SetObjectAttribute(dash->graph, id, "Rotate.Offset", &roffset, CCM_DECL_FLOAT);
    fval = -45.0;
    gsc_SetObjectAttribute(dash->graph, id, "Rotate.MinAngle", &fval, CCM_DECL_FLOAT);
    fval = 45.0;
    gsc_SetObjectAttribute(dash->graph, id, "Rotate.MaxAngle", &fval, CCM_DECL_FLOAT);
    gsc_SetObjectShadow(dash->graph, id, 1);
    gsc_DashInsertObject(dash->graph, g, id);
  }

  // Needle element 3
  if (dash->elements > 2) {
    x1 = gx1 + gw / 2 - gw * 0.01;
    y1 = y0;
    x2 = x1 + gw * 0.02;
    y2 = y0 + awidth / 2;
    id = gsc_CreateObject(dash->graph, "pwr_needle2", x1, y1, x2, y2);	
    gsc_SetObjectFillColor(dash->graph, id, glow_eDrawType_CustomColor73);
    gsc_SetObjectAttribute(dash->graph, id, "Rotate.Attribute", elem3->attribute, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Fast", CCM_DECL_STRING);
    rfact = 90.0 / (elem3->max_value - elem3->min_value);
    roffset = -(elem3->max_value + elem3->min_value) * rfact / 2.0;
    gsc_SetObjectAttribute(dash->graph, id, "Rotate.Factor", &rfact, CCM_DECL_FLOAT);
    gsc_SetObjectAttribute(dash->graph, id, "Rotate.Offset", &roffset, CCM_DECL_FLOAT);
    fval = -45.0;
    gsc_SetObjectAttribute(dash->graph, id, "Rotate.MinAngle", &fval, CCM_DECL_FLOAT);
    fval = 45.0;
    gsc_SetObjectAttribute(dash->graph, id, "Rotate.MaxAngle", &fval, CCM_DECL_FLOAT);
    gsc_SetObjectShadow(dash->graph, id, 1);
    gsc_DashInsertObject(dash->graph, g, id);
  }

  // Lower light arc
  x1 = (gx1 + gx2) / 2 - awidth / 4;
  y1 = y0 + awidth / 4;
  x2 = x1 + awidth / 2;
  y2 = y1 + awidth / 2;
  id = gsc_CreateArc(dash->graph, x1, y1, x2, y2, 43, 94);
  gsc_SetObjectFill(dash->graph, id, 1);
  gsc_SetObjectBorder(dash->graph, id, 0);
  gsc_SetObjectFillColor(dash->graph, id, glow_eDrawType_CustomColor1);
  ival = 1;
  gsc_SetObjectAttribute(dash->graph, id, "fill_eq_light", &ival, CCM_DECL_INT);
  gsc_SetObjectAttribute(dash->graph, id, "fixcolor", &ival, CCM_DECL_INT);
  gsc_DashInsertObject(dash->graph, g, id);

  // Lower line arc
  x1 = (gx1 + gx2) / 2 - awidth / 4;
  y1 = y0 + awidth / 4;
  x2 = x1 + awidth / 2;
  y2 = y1 + awidth / 2;
  id = gsc_CreateArc(dash->graph, x1, y1, x2, y2, 45, 90);
  gsc_DashInsertObject(dash->graph, g, id);

  // Lower background arc
  x1 = (gx1 + gx2) / 2 - awidth / 4 + 0.2;
  y1 = y0 + awidth / 4 + 0.2;
  x2 = x1 + awidth / 2 - 0.4;
  y2 = y1 + awidth / 2 - 0.4;
  id = gsc_CreateArc(dash->graph, x1, y1, x2, y2, 20, 140);
  gsc_SetObjectFill(dash->graph, id, 1);
  gsc_SetObjectBorder(dash->graph, id, 0);
  gsc_SetObjectFillColor(dash->graph, id, glow_eDrawType_CustomColor1);
  gsc_DashInsertObject(dash->graph, g, id);

  // Right light line
  x1 = (gx1 + gx2) / 2 - awidth / 4 * cos(45.0 * M_PI/180);
  y1 = y0 + awidth / 2  - awidth / 4 * sin(45.0 * M_PI/180);
  x2 = (gx1 + gx2) / 2 - awidth / 2 * cos(45.0 * M_PI/180);
  y2 = y0 + awidth / 2 - awidth / 2 * sin(45.0 * M_PI/180);
  id = gsc_CreatePolyLine(dash->graph, x1, y1, x2, y2);
  x2 -= 0.4;
  gsc_PolyLineAdd(dash->graph, id, x2, y2);
  x2 = x1;
  y2 = y1 + 0.4;
  gsc_PolyLineAdd(dash->graph, id, x2, y2);
  gsc_PolyLineAdd(dash->graph, id, x1, y1);
  gsc_SetObjectFill(dash->graph, id, 1);
  gsc_SetObjectBorder(dash->graph, id, 0);
  gsc_SetObjectFillColor(dash->graph, id, glow_eDrawType_CustomColor1);
  ival = 1;
  gsc_SetObjectAttribute(dash->graph, id, "fill_eq_light", &ival, CCM_DECL_INT);
  gsc_SetObjectAttribute(dash->graph, id, "fixcolor", &ival, CCM_DECL_INT);
  gsc_DashInsertObject(dash->graph, g, id);

  // Right line
  x1 = (gx1 + gx2) / 2 - awidth / 4 * cos(45.0 * M_PI/180);
  y1 = y0 + awidth / 2 - awidth / 4 * sin(45.0 * M_PI/180);
  x2 = (gx1 + gx2) / 2 - awidth / 2 * cos(45.0 * M_PI/180);
  y2 = y0 + awidth / 2 - awidth / 2 * sin(45.0 * M_PI/180);
  id = gsc_CreateLine(dash->graph, x1, y1, x2, y2);
  gsc_DashInsertObject(dash->graph, g, id);

  // Left shadow line
  x1 = (gx1 + gx2) / 2 + awidth / 4 * cos(45.0 * M_PI/180);
  y1 = y0 + awidth / 2 - awidth / 4 * sin(45.0 * M_PI/180);
  x2 = (gx1 + gx2) / 2 + awidth / 2 * cos(45.0 * M_PI/180);
  y2 = y0 + awidth / 2 - awidth / 2 * sin(45.0 * M_PI/180);
  id = gsc_CreatePolyLine(dash->graph, x1, y1, x2, y2);
  x2 += 0.4;
  gsc_PolyLineAdd(dash->graph, id, x2, y2);
  x2 = x1;
  y2 = y1 + 0.4;
  gsc_PolyLineAdd(dash->graph, id, x2, y2);
  gsc_PolyLineAdd(dash->graph, id, x1, y1);
  gsc_SetObjectFill(dash->graph, id, 1);
  gsc_SetObjectBorder(dash->graph, id, 0);
  gsc_SetObjectFillColor(dash->graph, id, glow_eDrawType_CustomColor1);
  ival = 1;
  gsc_SetObjectAttribute(dash->graph, id, "fill_eq_light", &ival, CCM_DECL_INT);
  gsc_SetObjectAttribute(dash->graph, id, "fixcolor", &ival, CCM_DECL_INT);
  gsc_DashInsertObject(dash->graph, g, id);

  // Left line
  x1 = (gx1 + gx2) / 2 + awidth / 4 * cos(45.0 * M_PI/180);
  y1 = y0 + awidth / 2 - awidth / 4 * sin(45.0 * M_PI/180);
  x2 = (gx1 + gx2) / 2 + awidth / 2 * cos(45.0 * M_PI/180);
  y2 = y0 + awidth / 2 - awidth / 2 * sin(45.0 * M_PI/180);
  id = gsc_CreateLine(dash->graph, x1, y1, x2, y2);
  gsc_DashInsertObject(dash->graph, g, id);

  // Axis
  x1 = (gx1 + gx2) / 2 - awidth / 2;
  y1 = y0;
  x2 = x1 + awidth;
  y2 = y1 + awidth;
  id = gsc_CreateAxisArc(dash->graph, x1, y1, x2, y2, 1, 0);
  gsc_SetObjectBorderColor(dash->graph, id, glow_eDrawType_CustomColor77);
  gsc_SetObjectTextColor(dash->graph, id, glow_eDrawType_CustomColor23);
  gsc_SetObjectAttribute(dash->graph, id, "MinValue", &elem1->max_value, CCM_DECL_FLOAT);
  gsc_SetObjectAttribute(dash->graph, id, "MaxValue", &elem1->min_value, CCM_DECL_FLOAT);
  ival = 45;
  gsc_SetObjectAttribute(dash->graph, id, "Angle1", &ival, CCM_DECL_INT);
  ival = 90;
  gsc_SetObjectAttribute(dash->graph, id, "Angle2", &ival, CCM_DECL_INT);
  ival = 5;
  gsc_SetObjectAttribute(dash->graph, id, "Lines", &ival, CCM_DECL_INT);
  ival = 4;
  gsc_SetObjectAttribute(dash->graph, id, "LongQuotient", &ival, CCM_DECL_INT);
  ival = 2;
  gsc_SetObjectAttribute(dash->graph, id, "ValueQuotient", &ival, CCM_DECL_INT);
  gsc_SelectClear(dash->graph);
  gsc_SelectAdd(dash->graph, id);
  if (cols == 1) {
    fval = 0.08;
    gsc_SetObjectAttribute(dash->graph, id, "LineLength", &fval, CCM_DECL_FLOAT);
    gsc_SetSelectTextSize(dash->graph, 1);
  } else {
    fval = 0.06;
    gsc_SetObjectAttribute(dash->graph, id, "LineLength", &fval, CCM_DECL_FLOAT);
    gsc_SetSelectTextSize(dash->graph, 4);
  }
  gsc_SelectClear(dash->graph);
  gsc_DashInsertObject(dash->graph, g, id);

  vheight = awidth / 6;
  if (vheight > gh / 4.5)
    vheight = gh / 4.5;

  y2 = (gy2 + y0 + awidth/2) / 2 + vheight / 2;
  if (y2 > gy2 - 0.1)
    y2 = gy2 - 0.1;

  x1 = gx1 + 0.28 * gw;
  y1 = y2 - vheight;
  x2 = gx1 + 0.72 * gw;
  id = gsc_CreateObject(dash->graph, "pwrct_valuemediumcenter", x1, y1, x2, y2);
  ival = 0;
  gsc_SetObjectAttribute(dash->graph, id, "Action", &ival, CCM_DECL_INT);
  gsc_SetObjectAttribute(dash->graph, id, "Value.Attribute", elem1->attribute, CCM_DECL_STRING);
  gsc_SetObjectAttribute(dash->graph, id, "Value.Format", elem1->format, CCM_DECL_STRING);
  gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Slow", CCM_DECL_STRING);
  gsc_DashInsertObject(dash->graph, g, id);
}

static void dabo_gauge2(GeDash *dash, grow_tObject g)
{
  double x1;
  double y1;
  double x2;
  double y2;
  double y0;
  double twidth, theight, tdescent;
  grow_tObject id;
  double gx1;
  double gx2;
  double gy1;
  double gy2;
  double gw;
  double gh;
  double rfact;
  double roffset;
  double awidth;
  int cols;
  int ival;
  double fval;
  GeDashAnalog *elem1, *elem2, *elem3;

  elem1 = (GeDashAnalog *)dash->elem[0];
  elem2 = (GeDashAnalog *)dash->elem[1];
  elem3 = (GeDashAnalog *)dash->elem[2];
    
  gsc_GetObjectAttribute(dash->graph, g, "Dash.CellColumns", &cols, sizeof(cols), CCM_DECL_INT);

  gsc_MeasureObject(dash->graph, g, &gx1, &gy1, &gx2, &gy2);
  gw = gx2 - gx1;
  gh = gy2 - gy1;

  if (strcmp(dash->title, "") != 0) {
    gsc_GetTextExtent(dash->graph, dash->title, 3, glow_eFont_LucidaSans, 0, &twidth, &theight, &tdescent);
    x2 = (gx1 + gx2)/2 - twidth/2;
    y2 = gy1 + 1;
    id = gsc_CreateText(dash->graph, dash->title, x2, y2, 3, glow_eFont_LucidaSans, 0, glow_eDrawType_CustomColor5);
    gsc_DashInsertObject(dash->graph, g, id);

    gh -= 1.5;
    y0 = gy1 + 1.3 + 0.05 * gh;

    if (gw < gh)
      awidth = gw * 0.8;
    else
      awidth = gh * 0.8;
  } else {
    y0 = gy1 + 0.05 *gh;
    if (gw < gh)
      awidth = gw * 0.7;
    else
      awidth = gh * 0.7;
  }


  // Outer shadow
  x1 = (gx1 + gx2) / 2 - awidth / 2 - 0.2;
  y1 = y0 - 0.2;
  x2 = x1 + awidth + 0.4;
  y2 = y1 + awidth + 0.4;
  id = gsc_CreateArc(dash->graph, x1, y1, x2, y2, 0, 360);
  gsc_SetObjectFill(dash->graph, id, 1);
  gsc_SetObjectBorder(dash->graph, id, 0);
  gsc_SetObjectFillColor(dash->graph, id, glow_eDrawType_CustomColor1);
  ival = 12;
  gsc_SetObjectAttribute(dash->graph, id, "gradient", &ival, CCM_DECL_INT);
  gsc_DashInsertObject(dash->graph, g, id);

  // Display
  x1 = (gx1 + gx2) / 2 - awidth / 2;
  y1 = y0;
  x2 = x1 + awidth;
  y2 = y1 + awidth;
  id = gsc_CreateArc(dash->graph, x1, y1, x2, y2, 0, 360);
  gsc_SetObjectFill(dash->graph, id, 1);
  gsc_SetObjectBorder(dash->graph, id, 0);
  gsc_SetObjectFillColor(dash->graph, id, glow_eDrawType_CustomColor21);
  gsc_DashInsertObject(dash->graph, g, id);

  // Needle
  x1 = (gx1 + gx2) / 2 - gw * 0.01;
  y1 = y0;
  x2 = x1 + gw * 0.02;
  y2 = y1 + awidth / 2;
  id = gsc_CreateObject(dash->graph, "pwr_needle2", x1, y1, x2, y2);	
  gsc_SetObjectFillColor(dash->graph, id, glow_eDrawType_CustomColor23);
  gsc_SetObjectAttribute(dash->graph, id, "Rotate.Attribute", elem1->attribute, CCM_DECL_STRING);
  gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Fast", CCM_DECL_STRING);
  rfact = 280.0 / (elem1->max_value - elem1->min_value);
  roffset = -(elem1->max_value + elem1->min_value) * rfact / 2.0;
  gsc_SetObjectAttribute(dash->graph, id, "Rotate.Factor", &rfact, CCM_DECL_FLOAT);
  gsc_SetObjectAttribute(dash->graph, id, "Rotate.Offset", &roffset, CCM_DECL_FLOAT);
  fval = -140.0;
  gsc_SetObjectAttribute(dash->graph, id, "Rotate.MinAngle", &fval, CCM_DECL_FLOAT);
  fval = 140.0;
  gsc_SetObjectAttribute(dash->graph, id, "Rotate.MaxAngle", &fval, CCM_DECL_FLOAT);
  gsc_SetObjectShadow(dash->graph, id, 1);
  gsc_DashInsertObject(dash->graph, g, id);

  // Needle element 2
  if (dash->elements > 1) {
    x1 = (gx1 + gx2) / 2 - gw * 0.01;
    y1 = y0;
    x2 = x1 + gw * 0.02;
    y2 = y1 + awidth / 2;
    id = gsc_CreateObject(dash->graph, "pwr_needle2", x1, y1, x2, y2);	
    gsc_SetObjectFillColor(dash->graph, id, glow_eDrawType_CustomColor87);
    gsc_SetObjectAttribute(dash->graph, id, "Rotate.Attribute", elem1->attribute, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Fast", CCM_DECL_STRING);
    rfact = 280.0 / (elem2->max_value - elem2->min_value);
    roffset = -(elem2->max_value + elem2->min_value) * rfact / 2.0;
    gsc_SetObjectAttribute(dash->graph, id, "Rotate.Factor", &rfact, CCM_DECL_FLOAT);
    gsc_SetObjectAttribute(dash->graph, id, "Rotate.Offset", &roffset, CCM_DECL_FLOAT);
    fval = -140.0;
    gsc_SetObjectAttribute(dash->graph, id, "Rotate.MinAngle", &fval, CCM_DECL_FLOAT);
    fval = 140.0;
    gsc_SetObjectAttribute(dash->graph, id, "Rotate.MaxAngle", &fval, CCM_DECL_FLOAT);
    gsc_SetObjectShadow(dash->graph, id, 1);
    gsc_DashInsertObject(dash->graph, g, id);
  }

  // Needle element 3
  if (dash->elements > 2) {
    x1 = (gx1 + gx2) / 2 - gw * 0.01;
    y1 = y0;
    x2 = x1 + gw * 0.02;
    y2 = y1 + awidth / 2;
    id = gsc_CreateObject(dash->graph, "pwr_needle2", x1, y1, x2, y2);	
    gsc_SetObjectFillColor(dash->graph, id, glow_eDrawType_CustomColor73);
    gsc_SetObjectAttribute(dash->graph, id, "Rotate.Attribute", elem3->attribute, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Fast", CCM_DECL_STRING);
    rfact = 280.0 / (elem3->max_value - elem3->min_value);
    roffset = -(elem3->max_value + elem3->min_value) * rfact / 2.0;
    gsc_SetObjectAttribute(dash->graph, id, "Rotate.Factor", &rfact, CCM_DECL_FLOAT);
    gsc_SetObjectAttribute(dash->graph, id, "Rotate.Offset", &roffset, CCM_DECL_FLOAT);
    fval = -140.0;
    gsc_SetObjectAttribute(dash->graph, id, "Rotate.MinAngle", &fval, CCM_DECL_FLOAT);
    fval = 140.0;
    gsc_SetObjectAttribute(dash->graph, id, "Rotate.MaxAngle", &fval, CCM_DECL_FLOAT);
    gsc_SetObjectShadow(dash->graph, id, 1);
    gsc_DashInsertObject(dash->graph, g, id);
  }

  // Center arc
  // Display
  x1 = (gx1 + gx2) / 2 - awidth / 8;
  y1 = y0 + awidth / 2 - awidth / 8;
  x2 = x1 + awidth/4;
  y2 = y1 + awidth/4;
  id = gsc_CreateArc(dash->graph, x1, y1, x2, y2, 0, 360);
  gsc_SetObjectFill(dash->graph, id, 1);
  gsc_SetObjectBorder(dash->graph, id, 0);
  gsc_SetObjectFillColor(dash->graph, id, glow_eDrawType_CustomColor52);
  ival = 12;
  gsc_SetObjectAttribute(dash->graph, id, "gradient", &ival, CCM_DECL_INT);
  ival = 2;
  gsc_SetObjectAttribute(dash->graph, id, "gradient_contrast", &ival, CCM_DECL_INT);
  gsc_SetObjectShadow(dash->graph, id, 1);
  gsc_DashInsertObject(dash->graph, g, id);

  // Lower border
  x1 = (gx1 + gx2) / 2 - awidth / 2;
  y1 = y0;
  x2 = x1 + awidth;
  y2 = y1 + awidth;
  id = gsc_CreateArc(dash->graph, x1, y1, x2, y2, -130, 80);
  gsc_SetObjectBorder(dash->graph, id, 1);
  gsc_SetObjectBorderColor(dash->graph, id, glow_eDrawType_CustomColor4);
  gsc_DashInsertObject(dash->graph, g, id);

  // Axis
  x1 = (gx1 + gx2) / 2 - awidth / 2;
  y1 = y0;
  x2 = x1 + awidth;
  y2 = y1 + awidth;
  id = gsc_CreateAxisArc(dash->graph, x1, y1, x2, y2, 1, 0);
  gsc_SetObjectBorderColor(dash->graph, id, glow_eDrawType_CustomColor77);
  gsc_SetObjectTextColor(dash->graph, id, glow_eDrawType_CustomColor23);
  gsc_SetObjectAttribute(dash->graph, id, "MinValue", &elem1->max_value, CCM_DECL_FLOAT);
  gsc_SetObjectAttribute(dash->graph, id, "MaxValue", &elem1->min_value, CCM_DECL_FLOAT);
  ival = -50;
  gsc_SetObjectAttribute(dash->graph, id, "Angle1", &ival, CCM_DECL_INT);
  ival = 280;
  gsc_SetObjectAttribute(dash->graph, id, "Angle2", &ival, CCM_DECL_INT);
  ival = 11;
  gsc_SetObjectAttribute(dash->graph, id, "Lines", &ival, CCM_DECL_INT);
  ival = 4;
  gsc_SetObjectAttribute(dash->graph, id, "LongQuotient", &ival, CCM_DECL_INT);
  ival = 2;
  gsc_SetObjectAttribute(dash->graph, id, "ValueQuotient", &ival, CCM_DECL_INT);
  gsc_SelectClear(dash->graph);
  gsc_SelectAdd(dash->graph, id);
  if (cols == 1) {
    fval = 0.08;
    gsc_SetObjectAttribute(dash->graph, id, "LineLength", &fval, CCM_DECL_FLOAT);
    gsc_SetSelectTextSize(dash->graph, 1);
  } else {
    fval = 0.08;
    gsc_SetObjectAttribute(dash->graph, id, "LineLength", &fval, CCM_DECL_FLOAT);
    gsc_SetSelectTextSize(dash->graph, 4);
  }
  gsc_SelectClear(dash->graph);
  gsc_DashInsertObject(dash->graph, g, id);

  // Value field
  y2 = (gy2 + y0 + awidth) / 2 + awidth / 8;
  if (y2 > gy2 - 0.1)
    y2 = gy2 - 0.1;

  x1 = gx1 + 0.28 * gw;
  y1 = y2 - awidth / 4;
  x2 = gx1 + 0.72 * gw;
  id = gsc_CreateObject(dash->graph, "pwrct_valuemediumcenter", x1, y1, x2, y2);
  ival = 0;
  gsc_SetObjectAttribute(dash->graph, id, "Action", &ival, CCM_DECL_INT);
  gsc_SetObjectAttribute(dash->graph, id, "Value.Attribute", elem1->attribute, CCM_DECL_STRING);
  gsc_SetObjectAttribute(dash->graph, id, "Value.Format", elem1->format, CCM_DECL_STRING);
  gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Slow", CCM_DECL_STRING);
  gsc_DashInsertObject(dash->graph, g, id);
}


static void dabo_slider(GeDash *dash, grow_tObject g)
{
  double x1;
  double y1;
  double x2;
  double y2;
  double twidth, theight, tdescent;
  grow_tObject id;
  double gx1;
  double gx2;
  double gy1;
  double gy2;
  double gw;
  double gh;
  double vwidth;
  int vertical = 0;
  int i = 1;
  GeDashAnalog *elem1, *elem2, *elem3;

  elem1 = (GeDashAnalog *)dash->elem[0];
  elem2 = (GeDashAnalog *)dash->elem[1];
  elem3 = (GeDashAnalog *)dash->elem[2];
    
  gsc_MeasureObject(dash->graph, g, &gx1, &gy1, &gx2, &gy2); 
  gw = gx2 - gx1;
  gh = gy2 - gy1;

  gsc_GetTextExtent(dash->graph, dash->title, 3, glow_eFont_LucidaSans, 0, &twidth, &theight, &tdescent);
  x2 = (gx1 + gx2)/2 - twidth/2;
  y2 = gy1 + 1;
  id = gsc_CreateText(dash->graph, dash->title, x2, y2, 3, glow_eFont_LucidaSans, 0, glow_eDrawType_CustomColor5);
  gsc_DashInsertObject(dash->graph, g, id);

  if (dash->direction == glow_eDirection_Up || dash->direction == glow_eDirection_Down)
    vertical = 1;

  if (vertical) {
    x1 = gx1 + 0.2 + 1.0 * (i - 1);
    y1 = gy1 + 1.5;
    x2 = x1 + 1.0;
    y2 = gy2 - 0.2;
  } else {
    x2 = gx1 + 0.2;
    y2 = gy2 - 0.2 - (dash->elements - i);
    x1 = x2 - 1.0;
    y1 = y2 - gw + 0.4;
  }
  id = gsc_CreateObject(dash->graph, "pwrct_sliderbackground1_4", x1, y1, x2, y2);
  gsc_SetObjectShadow(dash->graph, id, 1);
  if (!vertical) {
    gsc_SelectClear(dash->graph);
    gsc_SelectAdd(dash->graph, id);
    gsc_RotateSelected(dash->graph, 90.0, 2);
    gsc_SelectClear(dash->graph); 
  }
  gsc_DashInsertObject(dash->graph, g, id);

  if (vertical) {
    x1 = gx1 + 0.2 + 1.0 * (i - 1);
    y1 = gy1 + 2.5;
    x2 = x1 + 0.95;
    y2 = y1 + 0.8;
  } else {
    x2 = gx1 + 2.2;
    y2 = gy2 - 0.3 - (dash->elements - i);
    x1 = x2 - 0.8;
    y1 = y2 - 1.0;
  }
  id = gsc_CreateObject(dash->graph, "pwrct_slider4", x1, y1, x2, y2);
  gsc_SetObjectAttribute(dash->graph, id, "Slider.Attribute", elem1->attribute, CCM_DECL_STRING);
  gsc_SetObjectAttribute(dash->graph, id, "Slider.MaxValue", &elem1->max_value, CCM_DECL_FLOAT);
  gsc_SetObjectAttribute(dash->graph, id, "Slider.MinValue", &elem1->min_value, CCM_DECL_FLOAT);
  gsc_SetObjectShadow(dash->graph, id, 1);
  if (!vertical) {
    gsc_SelectClear(dash->graph);
    gsc_SelectAdd(dash->graph, id);
    gsc_RotateSelected(dash->graph, 90.0, 2);
    gsc_SelectClear(dash->graph); 
  }
  gsc_DashInsertObject(dash->graph, g, id);

  vwidth = gw / 3 - 0.2;
  if (vwidth > 3)
    vwidth = 3;

  if (vertical) {
    x1 = gx1 + 1.0 * (dash->elements) + 0.9;
    y1 = gy1 + 1.5 + 1.2 *(i - 1);    
  } else {
    x1 = gx1 + gw / 2 - vwidth / 2;
    if (dash->elements == 2)
      x1 = x1 - vwidth * 0.5 - 0.1 + (i - 1) * (vwidth + 0.1);
    if (dash->elements == 3)
      x1 = x1 - vwidth - 0.1 + (i - 1) * (vwidth + 0.1);
    y1 = gy1 + 1.5;
  }
  x2 = x1 + vwidth;
  y2 = y1 + 1.1;
  id = gsc_CreateObject(dash->graph, "pwrct_valuemediumcenter", x1, y1, x2, y2);
  gsc_SetObjectAttribute(dash->graph, id, "Value.Attribute", elem1->attribute, CCM_DECL_STRING);
  gsc_SetObjectAttribute(dash->graph, id, "Value.Format", elem1->format, CCM_DECL_STRING);
  gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Slow", CCM_DECL_STRING);
  gsc_DashInsertObject(dash->graph, g, id);

  if (dash->elements > 1) {
    i++;
    if (vertical) {
      x1 = gx1 + 0.2 + 1.0 * (i - 1);
      y1 = gy1 + 1.5;
      x2 = x1 + 1.0;
      y2 = gy2 - 0.2;
    } else {
      x2 = gx1 + 0.2;
      y2 = gy2 - 0.2 - (dash->elements - i);
      x1 = x2 - 1.0;
      y1 = y2 - gw + 0.4;
    }
    id = gsc_CreateObject(dash->graph, "pwrct_sliderbackground1_4", x1, y1, x2, y2);
    gsc_SetObjectShadow(dash->graph, id, 1);
    if (!vertical) {
      gsc_SelectClear(dash->graph);
      gsc_SelectAdd(dash->graph, id);
      gsc_RotateSelected(dash->graph, 90.0, 2);
      gsc_SelectClear(dash->graph); 
    }
    gsc_DashInsertObject(dash->graph, g, id);

    if (vertical) {
      x1 = gx1 + 0.2 + 1.0 * (i - 1);
      y1 = gy1 + 2.5;
      x2 = x1 + 0.95;
      y2 = y1 + 0.8;
    } else {
      x2 = gx1 + 2.2;
      y2 = gy2 - 0.3 - (dash->elements - i);
      x1 = x2 - 0.8;
      y1 = y2 - 1.0;
    }
    id = gsc_CreateObject(dash->graph, "pwrct_slider4", x1, y1, x2, y2);
    gsc_SetObjectAttribute(dash->graph, id, "Slider.Attribute", elem2->attribute, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Slider.MaxValue", &elem2->max_value, CCM_DECL_FLOAT);
    gsc_SetObjectAttribute(dash->graph, id, "Slider.MinValue", &elem2->min_value, CCM_DECL_FLOAT);
    gsc_SetObjectShadow(dash->graph, id, 1);
    if (!vertical) {
      gsc_SelectClear(dash->graph);
      gsc_SelectAdd(dash->graph, id);
      gsc_RotateSelected(dash->graph, 90.0, 2);
      gsc_SelectClear(dash->graph); 
    }
    gsc_DashInsertObject(dash->graph, g, id);

    if (vertical) {
      x1 = gx1 + 1.0 * (dash->elements) + 0.9;
      y1 = gy1 + 1.5 + 1.2 *(i - 1);    
    } else {
      x1 = gx1 + gw / 2 - vwidth / 2;
      if (dash->elements == 2)
        x1 = x1 - vwidth * 0.5 - 0.1 + (i - 1) * (vwidth + 0.1);
      if (dash->elements == 3)
        x1 = x1 - vwidth - 0.1 + (i - 1) * (vwidth + 0.1);
      y1 = gy1 + 1.5;
    }
    x2 = x1 + vwidth;
    y2 = y1 + 1.1;
    id = gsc_CreateObject(dash->graph, "pwrct_valuemediumcenter", x1, y1, x2, y2);
    gsc_SetObjectAttribute(dash->graph, id, "Value.Attribute", elem2->attribute, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Value.Format", elem2->format, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Slow", CCM_DECL_STRING);
    gsc_DashInsertObject(dash->graph, g, id);
  }

  if (dash->elements > 2) {
    i++;
    if (vertical) {
      x1 = gx1 + 0.2 + 1.0 * (i - 1);
      y1 = gy1 + 1.5;
      x2 = x1 + 1.0;
      y2 = gy2 - 0.2;
    } else {
      x2 = gx1 + 0.2;
      y2 = gy2 - 0.2 - (dash->elements - i);
      x1 = x2 - 1.0;
      y1 = y2 - gw + 0.4;
    }
    id = gsc_CreateObject(dash->graph, "pwrct_sliderbackground1_4", x1, y1, x2, y2);
    gsc_SetObjectShadow(dash->graph, id, 1);
    if (!vertical) {
      gsc_SelectClear(dash->graph);
      gsc_SelectAdd(dash->graph, id);
      gsc_RotateSelected(dash->graph, 90.0, 2);
      gsc_SelectClear(dash->graph); 
    }
    gsc_DashInsertObject(dash->graph, g, id);

    if (vertical) {
      x1 = gx1 + 0.2 + 1.0 * (i - 1);
      y1 = gy1 + 2.5;
      x2 = x1 + 0.95;
      y2 = y1 + 0.8;
    } else {
      x2 = gx1 + 2.2;
      y2 = gy2 - 0.3 - (dash->elements - i);
      x1 = x2 - 0.8;
      y1 = y2 - 1.0;
    }
    id = gsc_CreateObject(dash->graph, "pwrct_slider4", x1, y1, x2, y2);
    gsc_SetObjectAttribute(dash->graph, id, "Slider.Attribute", elem3->attribute, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Slider.MaxValue", &elem3->max_value, CCM_DECL_FLOAT);
    gsc_SetObjectAttribute(dash->graph, id, "Slider.MinValue", &elem3->min_value, CCM_DECL_FLOAT);
    gsc_SetObjectShadow(dash->graph, id, 1);
    if (!vertical) {
      gsc_SelectClear(dash->graph);
      gsc_SelectAdd(dash->graph, id);
      gsc_RotateSelected(dash->graph, 90.0, 2);
      gsc_SelectClear(dash->graph); 
    }
    gsc_DashInsertObject(dash->graph, g, id);

    if (vertical) {
      x1 = gx1 + 1.0 * (dash->elements) + 0.9;
      y1 = gy1 + 1.5 + 1.2 *(i - 1);    
    } else {
      x1 = gx1 + gw / 2 - vwidth / 2;
      if (dash->elements == 2)
        x1 = x1 - vwidth * 0.5 - 0.1 + (i - 1) * (vwidth + 0.1);
      if (dash->elements == 3)
        x1 = x1 - vwidth - 0.1 + (i - 1) * (vwidth + 0.1);
    }
    y1 = gy1 + 1.5;
    x2 = x1 + vwidth;
    y2 = y1 + 1.1;
    id = gsc_CreateObject(dash->graph, "pwrct_valuemediumcenter", x1, y1, x2, y2);
    gsc_SetObjectAttribute(dash->graph, id, "Value.Attribute", elem3->attribute, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Value.Format", elem3->format, CCM_DECL_STRING);
    gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Slow", CCM_DECL_STRING);
    gsc_DashInsertObject(dash->graph, g, id);
  }
}

static void dabo_pie(GeDash *dash, grow_tObject g)
{
  double x1;
  double y1;
  double x2;
  double y2;
  double y0;
  double twidth, theight, tdescent;
  grow_tObject id;
  double gx1;
  double gx2;
  double gy1;
  double gy2;
  double gw;
  double gh;
  double tx;
  double ty;
  int tsize;
  glow_eDrawType tcolor;
  double awidth;
  int cols;
  double min;
  double max;
  int i;
  char name[80];
  int ival;
    
  gsc_GetObjectAttribute(dash->graph, g, "Dash.CellColumns", &cols, sizeof(cols), CCM_DECL_INT);

  gsc_MeasureObject(dash->graph, g, &gx1, &gy1, &gx2, &gy2);
  gw = gx2 - gx1;
  gh = gy2 - gy1;

  if (strcmp(dash->title, "") != 0) {
    gsc_GetTextExtent(dash->graph, dash->title, 3, glow_eFont_LucidaSans, 0, &twidth,
	&theight, &tdescent);
    x2 = (gx1 + gx2)/2 - twidth/2;
    y2 = gy1 + 1;
    id = gsc_CreateText(dash->graph, dash->title, x2, y2, 3, glow_eFont_LucidaSans, 0, 
        glow_eDrawType_CustomColor5);
    gsc_DashInsertObject(dash->graph, g, id);

    gh -= 1.5;
    y0 = gy1 + 1.3 + 0.05 * gh;

    if (gw < gh)
      awidth = gw * 0.8;
    else
      awidth = gh * 0.8;
  } else {
    y0 = gy1 + 0.05 *gh;
    if (gw < gh)
      awidth = gw * 0.7;
    else
      awidth = gh * 0.7;
  }

  // Texts
  tsize = 2;

  x1 = gx1 + 0.5;
  y1 = gy1 + 1.5;
  x2 = 0.5;
  y2 = 0.5;
  for (i = 0; i < dash->elements; i++) {
    switch (i) {
    case 0:
      tcolor = glow_eDrawType_CustomColor56;
      break;
    case 1:
      tcolor = glow_eDrawType_CustomColor71;
      break;
    case 2:
      tcolor = glow_eDrawType_CustomColor26;
      break;
    case 3:
      tcolor = glow_eDrawType_CustomColor86;
      break;
    case 4:
      tcolor = glow_eDrawType_CustomColor41;
      break;
    case 5:
      tcolor = glow_eDrawType_CustomColor11;
      break;
    }
    id = gsc_CreateRectangle(dash->graph, x1, y1, x2, y2);
    gsc_SetObjectFill(dash->graph, id, 1);
    gsc_SetObjectBorder(dash->graph, id, 0);
    gsc_SetObjectFillColor(dash->graph, id, tcolor);
    gsc_DashInsertObject(dash->graph, g, id);

    tx = x1 + 0.8;
    ty = y1 + 0.45;
    id = gsc_CreateText(dash->graph, ((GeDashAnalog *)dash->elem[i])->text, tx, ty, tsize, 
        glow_eFont_LucidaSans, 0, glow_eDrawType_CustomColor5);
    gsc_DashInsertObject(dash->graph, g, id);

    y1 += 0.8;
  }

  // Pie
  min = 0;
  max = 0;

  x1 = gx2 - gw * 0.2 - awidth;
  if (x1 < (gx1 + gx2) / 2 - awidth / 2)
    x1 = (gx1 + gx2) / 2 - awidth / 2;
  y1 = gy2 - awidth * 1.1;
  x2 = x1 + awidth;
  y2 = y1 + awidth;
  id = gsc_CreatePie(dash->graph, x1, y1, x2, y2, 1);
  gsc_SetObjectAttribute(dash->graph, id, "Pie.Sectors", &dash->elements, CCM_DECL_INT);
  ival = 1;
  gsc_SetObjectAttribute(dash->graph, id, "Pie.FixRange", &ival, CCM_DECL_INT);
  for (i = 0; i < dash->elements; i++) {
    sprintf(name, "Pie.Attribute%d", i + 1);
    gsc_SetObjectAttribute(dash->graph, id, name, ((GeDashAnalog *)dash->elem[i])->attribute,
	CCM_DECL_STRING);
    min += ((GeDashAnalog *)dash->elem[i])->min_value;
    max += ((GeDashAnalog *)dash->elem[i])->max_value;
  }
  gsc_SetObjectAttribute(dash->graph, id, "Pie.MinValue", &min, CCM_DECL_FLOAT);
  gsc_SetObjectAttribute(dash->graph, id, "Pie.MaxValue", &max, CCM_DECL_FLOAT);
  gsc_SetObjectAttribute(dash->graph, id, "Cycle", (void*)"Fast", CCM_DECL_STRING);
  gsc_SetObjectGradient(dash->graph, id, (glow_eGradient)2);
  gsc_SetObjectShadow(dash->graph, id, 1);
  gsc_DashInsertObject(dash->graph, g, id);
}
