/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2019 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

#include <iconv.h>

#include "co_error.h"
#include "co_dcli.h"
#include "co_string.h"
#include "co_time.h"

#include "rt_gdh.h"
#include "rt_aproc.h"
#include "rt_ini_event.h"
#include "rt_videomgm.h"
#include "rt_pwr_msg.h"
#include "rt_qcom_msg.h"
#include "rt_vmgm_msg.h"

static int log = 0;

int XttVideoMgmAimetis::init()
{
  int sts;

  sts = authorize(m_op->User, m_op->Password);
  if (EVEN(sts))
    return sts;
  sts = get_panels();
  if (EVEN(sts))
    return sts;
  sts = get_cameras();
  if (EVEN(sts))
    return sts;

  // Set default panel
  sts = display_panel(m_op->DefaultPanel);
  m_op->PanelArraySelect[m_op->DefaultPanel] = 1;
  m_panel_select_old[m_op->DefaultPanel] = 1;

  return 1;
}

static char* UTF8toISO8859(char* text)
{
  int len = strlen(text);
  iconv_t cd = iconv_open("ISO_8859-1", "UTF-8");

  char* in_buf = text;
  size_t in_left = len;
  char* output = (char*)calloc(1, len + 1);
  char* out_buf = output;
  size_t out_left = len;

  do {
    if (iconv(cd, &in_buf, &in_left, &out_buf, &out_left) == (size_t)-1) {
      perror("iconv failed!");
      *output = 0;
      return output;
    }
  } while (in_left > 0 && out_left > 0);

  *out_buf = 0;
  return output;
}

int XttVideoMgmAimetis::check_session()
{
  pwr_tTime current;
  pwr_tDeltaTime timeout = { 300, 0 };
  pwr_tDeltaTime dt;
  int sts = 1;

  // Check that current session hasn't timed out
  time_GetTime(&current);
  time_Adiff_NE(&dt, &current, &m_last_auth);
  if (time_Dcomp(&dt, &timeout) == 1)
    sts = authorize(m_op->User, m_op->Password);

  return sts;
}

int XttVideoMgmAimetis::authorize(char* user, char* password)
{
  pwr_tCmd cmd;
  pwr_tFileName fname;
  int sts;

  sprintf(fname, "/tmp/videomgm%d.txt", ++m_fix);

  sprintf(cmd,
      "curl -s -S \"%s/Session\" -X POST -H \"Content-type: application/json\" \
-d \"{'user':'%s','pwd':'%s'}\" > %s",
      m_addr, user, password, fname);

  if (log)
    printf("Authorize\n%s\n", cmd);
  system(cmd);

  std::ifstream fp;
  for (int i = 0; i < 100; i++) {
    struct timespec t = { 0, 10000000 };
    nanosleep(&t, 0);

    fp.open(fname);
    if (fp)
      break;
  }

  if (!fp) {
    errh_Error("Authorization message failed");
    m_op->Status = VMGM__NOREPLY;
    return 0;
  }

  sts = Json::get_attribute_value(
      fp, "Data/Token", m_auth_token, sizeof(m_auth_token));
  fp.close();

  // Remove file
  sprintf(cmd, "rm %s", fname);
  system(cmd);

  time_GetTime(&m_last_auth);

  m_op->Status = VMGM__SUCCESS;
  return sts;
}

int XttVideoMgmAimetis::get_panels()
{
  pwr_tCmd cmd;
  pwr_tFileName fname;
  int sts;

  check_session();

  sprintf(fname, "/tmp/videomgm%d.txt", ++m_fix);

  sprintf(cmd, "curl -s -S \"%s/Panel\" -H \"authtoken :%s\" > %s", m_addr,
      m_auth_token, fname);

  if (log)
    printf("Get panel\n%s\n", cmd);
  system(cmd);

  std::ifstream fp;
  for (int i = 0; i < 100; i++) {
    struct timespec t = { 0, 10000000 };
    nanosleep(&t, 0);

    fp.open(fname);
    if (fp)
      break;
  }

  if (!fp) {
    errh_Error("Get panels message failed");
    m_op->Status = VMGM__NOREPLY;
    return 0;
  }

  char attr_name[80];
  char panel_name[80];
  char value[20];

  // sts = Json::get_attribute_value( fp, "xxxx", value, sizeof(value) );

  for (int i = 0; i < 10; i++) {
    VideoMgmPanel panel;
    sprintf(attr_name, "Data[%d]/PanelGuid", i);
    sts = Json::get_attribute_value(fp, attr_name, panel.id, sizeof(panel.id));
    if (EVEN(sts))
      break;
    sprintf(attr_name, "Data[%d]/PanelName", i);
    sts = Json::get_attribute_value(
        fp, attr_name, panel_name, sizeof(panel_name));
    if (EVEN(sts))
      break;

    char* textiso = UTF8toISO8859(panel_name);
    strncpy(panel.name, textiso, sizeof(panel.name));
    free(textiso);

    sprintf(attr_name, "Data[%d]/PanelWidth", i);
    sts = Json::get_attribute_value(fp, attr_name, value, sizeof(value));
    if (EVEN(sts))
      break;
    sscanf(value, "%d", &panel.width);
    sprintf(attr_name, "Data[%d]/PanelHeight", i);
    sts = Json::get_attribute_value(fp, attr_name, value, sizeof(value));
    if (EVEN(sts))
      break;
    sscanf(value, "%d", &panel.height);

    m_panel.push_back(panel);

    for (int j = 0; j < 25; j++) {
      VideoMgmCell cell;
      sprintf(attr_name, "Data[%d]/Cells[%d]/PanelCellId", i, j);
      sts = Json::get_attribute_value(fp, attr_name, cell.id, sizeof(cell.id));
      if (EVEN(sts))
        break;
      sprintf(attr_name, "Data[%d]/Cells[%d]/CameraId", i, j);
      sts = Json::get_attribute_value(
          fp, attr_name, cell.cameraid, sizeof(cell.cameraid));
      if (EVEN(sts))
        break;

      m_panel[i].cell.push_back(cell);
    }
    fp.close();
    fp.open(fname);
  }
  fp.close();

  // Remove file
  sprintf(cmd, "rm %s", fname);
  system(cmd);

  if (log) {
    for (unsigned int i = 0; i < m_panel.size(); i++) {
      printf("%d Name %s, id %s width %d height %d\n", i, m_panel[i].name,
          m_panel[i].id, m_panel[i].width, m_panel[i].height);
      for (unsigned int j = 0; j < m_panel[i].cell.size(); j++) {
        printf("%d Id %s CameraId %s\n", j, m_panel[i].cell[j].id,
            m_panel[i].cell[j].cameraid);
      }
    }
  }

  m_op->Status = VMGM__SUCCESS;
  return 1;
}

int XttVideoMgmAimetis::get_cameras()
{
  pwr_tCmd cmd;
  pwr_tFileName fname;
  int sts;

  check_session();

  sprintf(fname, "/tmp/videomgm%d.txt", ++m_fix);

  sprintf(cmd, "curl -s -S \"%s/Camera\" -H \"authtoken :%s\" > %s", m_addr,
      m_auth_token, fname);

  if (log)
    printf("Get camera\n%s\n", cmd);
  system(cmd);

  std::ifstream fp;
  for (int i = 0; i < 100; i++) {
    struct timespec t = { 0, 10000000 };
    nanosleep(&t, 0);

    fp.open(fname);
    if (fp)
      break;
  }

  if (!fp) {
    errh_Error("Get cameras message failed");
    m_op->Status = VMGM__NOREPLY;
    return 0;
  }

  char attr_name[80];
  char camera_name[80];

  for (int i = 0; i < 25; i++) {
    VideoMgmCamera camera;
    sprintf(attr_name, "Data[%d]/Id", i);
    sts = Json::get_attribute_value(
        fp, attr_name, camera.id, sizeof(camera.id));
    if (EVEN(sts))
      break;
    sprintf(attr_name, "Data[%d]/Name", i);
    sts = Json::get_attribute_value(
        fp, attr_name, camera_name, sizeof(camera_name));
    if (EVEN(sts))
      break;

    char* textiso = UTF8toISO8859(camera_name);
    strncpy(camera.name, textiso, sizeof(camera.name));
    free(textiso);

    sprintf(attr_name, "Data[%d]/Model", i);
    sts = Json::get_attribute_value(
        fp, attr_name, camera.model, sizeof(camera.model));
    if (EVEN(sts))
      break;
    sprintf(attr_name, "Data[%d]/Username", i);
    sts = Json::get_attribute_value(
        fp, attr_name, camera.username, sizeof(camera.username));
    if (EVEN(sts))
      break;
    sprintf(attr_name, "Data[%d]/Password", i);
    sts = Json::get_attribute_value(
        fp, attr_name, camera.password, sizeof(camera.password));
    if (EVEN(sts))
      break;

    m_camera.push_back(camera);
  }

  fp.close();

  // Remove file
  sprintf(cmd, "rm %s", fname);
  system(cmd);

  if (log) {
    for (unsigned int i = 0; i < m_camera.size(); i++)
      printf("%d Name %s, id %s model %s username %s passw %s\n", i,
          m_camera[i].name, m_camera[i].id, m_camera[i].model,
          m_camera[i].username, m_camera[i].password);
  }
  m_op->Status = VMGM__SUCCESS;
  return 1;
}

int XttVideoMgmAimetis::get_camera_image(int idx, const char* jpgfile)
{
  pwr_tCmd cmd;
  pwr_tFileName fname;
  char* decoding_table;
  static char encoding_table[] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',
    'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
    'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1',
    '2', '3', '4', '5', '6', '7', '8', '9', '+', '/' };

  check_session();

  sprintf(fname, "/tmp/videomgm%d.txt", ++m_fix);

  sprintf(cmd, "curl -s -S \"%s/Camera/%s/Jpeg\" -H \"authtoken :%s\" > %s",
      m_addr, m_camera[idx].id, m_auth_token, fname);

  if (log)
    printf("Get camera jpeg\n%s\n", cmd);
  system(cmd);

  std::ifstream fp;
  for (int i = 0; i < 100; i++) {
    struct timespec t = { 0, 10000000 };
    nanosleep(&t, 0);

    fp.open(fname);
    if (fp)
      break;
  }

  if (!fp) {
    errh_Error("Get camera image message failed");
    m_op->Status = VMGM__NOREPLY;
    return 0;
  }

  decoding_table = (char*)malloc(256);

  for (int i = 0; i < 64; i++)
    decoding_table[(unsigned char)encoding_table[i]] = i;

  std::ofstream fpo(jpgfile);
  if (!fpo) {
    printf("** Unable to open jpg-file %s\n", jpgfile);
  }

  // Decode base64 and store to jpeg-file
  char c1 = 0;
  char c2, c3, c4;
  char prevc;
  int store = 0;

  while (fp.good()) {
    prevc = c1;
    c1 = fp.get();
    if (c1 == '"' && prevc == ':') {
      store = 1;
      continue;
    }
    if (store) {
      if (c1 == '"')
        break;

      c2 = fp.get();
      c3 = fp.get();
      c4 = fp.get();
      if (!fp.good())
        break;

      uint32_t sextet_a = c1 == '=' ? 0 : decoding_table[(int)c1];
      uint32_t sextet_b = c2 == '=' ? 0 : decoding_table[(int)c2];
      uint32_t sextet_c = c3 == '=' ? 0 : decoding_table[(int)c3];
      uint32_t sextet_d = c4 == '=' ? 0 : decoding_table[(int)c4];

      uint32_t triple = (sextet_a << 3 * 6) + (sextet_b << 2 * 6)
          + (sextet_c << 1 * 6) + (sextet_d << 0 * 6);

      unsigned char oc1 = (triple >> 2 * 8) & 0xFF;
      unsigned char oc2 = (triple >> 1 * 8) & 0xFF;
      unsigned char oc3 = (triple >> 0 * 8) & 0xFF;

      fpo.put(oc1);
      fpo.put(oc2);
      fpo.put(oc3);
      // printf( "%x", c);
    }
  }
  fp.close();
  fpo.close();

  // Remove file
  sprintf(cmd, "rm %s", fname);
  system(cmd);

  free(decoding_table);

  m_op->Status = VMGM__SUCCESS;
  return 1;
}

int XttVideoMgmAimetis::assign_camera(
    int panel_idx, int cell_idx, int camera_idx)
{
  char cmd[400];
  pwr_tFileName fname;

  check_session();

  sprintf(fname, "/tmp/videomgm%d.txt", ++m_fix);

  sprintf(cmd,
      "curl -s -S \"%s/Panel/%s/Cell/%d/Camera/%s\" -H \"authtoken :%s\" > %s",
      m_addr, m_panel[panel_idx].id, cell_idx, m_camera[camera_idx].id,
      m_auth_token, fname);

  if (log)
    printf("Assign camera\n%s\n", cmd);
  system(cmd);

  std::ifstream fp;
  for (int i = 0; i < 100; i++) {
    struct timespec t = { 0, 10000000 };
    nanosleep(&t, 0);

    fp.open(fname);
    if (fp)
      break;
  }

  if (!fp) {
    errh_Error("Assign camera message failed");
    m_op->Status = VMGM__NOREPLY;
    return 0;
  }

  fp.close();

  // Remove file
  sprintf(cmd, "rm %s", fname);
  system(cmd);

  // Change in panel array
  strcpy(m_panel[panel_idx].cell[cell_idx].cameraid, m_camera[camera_idx].id);
  m_op->CellCameraIdx[cell_idx] = camera_idx;
  m_cell_camera_idx_old[cell_idx] = camera_idx;

  m_op->Status = VMGM__SUCCESS;
  return 1;
}

int XttVideoMgmAimetis::set_camera_fullscreen(int camera_idx)
{
  char cmd[400];
  pwr_tFileName fname;

  if (m_op->CurrentPanel == -1) {
    // Return to current last panel first
    display_panel(m_op->LastPanel);
  }

  check_session();

  sprintf(fname, "/tmp/videomgm%d.txt", ++m_fix);

  sprintf(cmd,
      "curl -s -S \"%s/Camera/%s/Fullscreen\" -H \"authtoken :%s\" > %s",
      m_addr, m_camera[camera_idx].id, m_auth_token, fname);

  if (log)
    printf("Set camera fullscreen: \n%s\n", cmd);
  system(cmd);

  std::ifstream fp;
  for (int i = 0; i < 100; i++) {
    struct timespec t = { 0, 10000000 };
    nanosleep(&t, 0);

    fp.open(fname);
    if (fp)
      break;
  }

  if (!fp) {
    errh_Error("Set camera fullscreen message failed");
    m_op->Status = VMGM__NOREPLY;
    return 0;
  }

  fp.close();

  // Remove file
  sprintf(cmd, "rm %s", fname);
  system(cmd);

  m_op->CurrentCamera = camera_idx;
  m_current_camera_old = camera_idx;
  m_op->CameraFullscreen = 1;
  m_op->CurrentPanel = -1;
  m_current_panel_old = -1;
  m_op->Rows = 0;
  m_op->Columns = 0;
  configure_layout();

  m_op->Status = VMGM__SUCCESS;
  return 1;
}

int XttVideoMgmAimetis::display_panel(int panel_idx)
{
  char cmd[400];
  pwr_tFileName fname;

  if (panel_idx < 0 || panel_idx >= (int)m_panel.size())
    return 0;

  check_session();

  sprintf(fname, "/tmp/videomgm%d.txt", ++m_fix);

  sprintf(cmd,
      "curl -s -S \"%s/Panel/%s/Show\" -X GET -H \"authtoken: %s\" > %s",
      m_addr, m_panel[panel_idx].id, m_auth_token, fname);

  if (log)
    printf("Display panel: \n%s\n", cmd);
  system(cmd);

  std::ifstream fp;
  for (int i = 0; i < 100; i++) {
    struct timespec t = { 0, 10000000 };
    nanosleep(&t, 0);

    fp.open(fname);
    if (fp)
      break;
  }

  if (!fp) {
    errh_Error("Display panel message failed");
    m_op->Status = VMGM__NOREPLY;
    return 0;
  }

  fp.close();

  // Remove file
  sprintf(cmd, "rm %s", fname);
  system(cmd);

  if (panel_idx != m_op->LastPanel) {
    // Reload panel configuration
    m_panel.clear();
    get_panels();
  }

  m_op->CurrentPanel = panel_idx;
  m_current_panel_old = panel_idx;
  m_op->CameraFullscreen = 0;
  m_op->LastPanel = panel_idx;
  m_op->CurrentCamera = -1;
  m_current_camera_old = -1;
  m_op->Rows = m_panel[panel_idx].height;
  m_op->Columns = m_panel[panel_idx].width;
  configure_layout();

  // Fill in current cell camera idx
  int idx = 0;
  for (int i = 0; i < m_op->Rows; i++) {
    for (int j = 0; j < m_op->Columns; j++) {
      idx = i * m_op->Columns + j;
      if (idx
          > int(sizeof(m_op->CellCameraIdx) / sizeof(m_op->CellCameraIdx[0])))
        break;

      int found = 0;
      for (unsigned int k = 0; k < m_camera.size(); k++) {
        if (strcmp(m_camera[k].id, m_panel[panel_idx].cell[idx].cameraid)
            == 0) {
          m_op->CellCameraIdx[idx] = k;
          m_cell_camera_idx_old[idx] = k;
          found = 1;
          break;
        }
      }
      if (!found) {
        m_op->CellCameraIdx[idx] = -1;
        m_cell_camera_idx_old[idx] = -1;
      }
    }
  }
  for (int i = idx + 1;
       i < int(sizeof(m_op->CellCameraIdx) / sizeof(m_op->CellCameraIdx[0]));
       i++) {
    m_op->CellCameraIdx[i] = -1;
    m_cell_camera_idx_old[i] = -1;
  }

  m_op->Status = VMGM__SUCCESS;
  return 1;
}

int XttVideoMgmAimetis::create_panel(char* name)
{
  char cmd[4000];
  pwr_tFileName fname;
  int pix = m_op->CurrentPanel;
  int cix;

  if (pix < 0 || pix >= (int)m_panel.size())
    return 0;

  check_session();

  sprintf(fname, "/tmp/videomgm%d.txt", ++m_fix);

  sprintf(cmd, "curl -s -S \"%s/Panel\" -X POST -H \"authtoken: %s\" "
               "-H \"Content-Type: application/json\" -d "
               "\"{'PanelName':'%s','PanelWidth':%d,'PanelHeight':%d,'Cells':[",
      m_addr, m_auth_token, name, m_panel[pix].width, m_panel[pix].height);

  for (unsigned int i = 0; i < m_panel[pix].cell.size(); i++) {
    // Find camera name for this cell
    cix = 0;
    for (unsigned int j = 0; j < m_camera.size(); j++) {
      if (streq(m_panel[pix].cell[i].cameraid, m_camera[j].id)) {
        cix = j;
        break;
      }
    }
    sprintf(&cmd[strlen(cmd)],
        "{'CoordX':0,'CoordY':0,'CameraId':'%s','CameraName':'%s'}",
        m_camera[cix].id, m_camera[cix].name);
    if (i != m_panel[pix].cell.size() - 1)
      sprintf(&cmd[strlen(cmd)], ",");
  }

  sprintf(&cmd[strlen(cmd)], "]}\" > %s", fname);

  if (log)
    printf("Create panel: \n%s\n", cmd);
  system(cmd);

  std::ifstream fp;
  for (int i = 0; i < 100; i++) {
    struct timespec t = { 0, 10000000 };
    nanosleep(&t, 0);

    fp.open(fname);
    if (fp)
      break;
  }

  if (!fp) {
    errh_Error("Create panel message failed");
    m_op->Status = VMGM__NOREPLY;
    return 0;
  }

  fp.close();

  // Remove file
  sprintf(cmd, "rm %s", fname);
  system(cmd);

  // Reload panel configuration
  m_panel.clear();
  get_panels();

  // Update array
  unsigned int i;
  for (i = 0; i < m_panel.size(); i++)
    strncpy(m_op->PanelArray[i], m_panel[i].name, sizeof(m_op->PanelArray[0]));
  for (; i < sizeof(m_op->PanelArray) / sizeof(m_op->PanelArray[0]); i++)
    strcpy(m_op->PanelArray[i], "");

  m_op->Status = VMGM__SUCCESS;
  return 1;
}

int XttVideoMgmAimetis::delete_panel(char* name)
{
  char cmd[400];
  pwr_tFileName fname;
  int pix = -1;

  // Get panel index
  for (unsigned int i = 0; i < m_panel.size(); i++) {
    if (streq(name, m_panel[i].name)) {
      pix = i;
      break;
    }
  }

  if (pix == -1)
    return 0;

  check_session();

  sprintf(fname, "/tmp/videomgm%d.txt", ++m_fix);

  sprintf(cmd, "curl -s -S \"%s/Panel/%s\" -X DELETE -H \"authtoken: %s\" > %s",
      m_addr, m_panel[pix].id, m_auth_token, fname);

  if (log)
    printf("Delete panel: \n%s\n", cmd);
  system(cmd);

  std::ifstream fp;
  for (int i = 0; i < 100; i++) {
    struct timespec t = { 0, 10000000 };
    nanosleep(&t, 0);

    fp.open(fname);
    if (fp)
      break;
  }

  if (!fp) {
    errh_Error("Delete panel message failed");
    m_op->Status = VMGM__NOREPLY;
    return 0;
  }

  fp.close();

  // Remove file
  sprintf(cmd, "rm %s", fname);
  system(cmd);

  // Reload panel configuration
  m_panel.clear();
  get_panels();

  // Update array
  unsigned int i;
  for (i = 0; i < m_panel.size(); i++)
    strncpy(m_op->PanelArray[i], m_panel[i].name, sizeof(m_op->PanelArray[0]));
  for (; i < sizeof(m_op->PanelArray) / sizeof(m_op->PanelArray[0]); i++)
    strcpy(m_op->PanelArray[i], "");

  m_op->Status = VMGM__SUCCESS;
  return 1;
}

typedef enum {
  json_eState_Start,
  json_eState_ExpectAttr,
  json_eState_Attr,
  json_eState_ExpectValue,
  json_eState_Value,
  json_eState_Par,
  json_eState_ExpectEndPar,
  json_eState_Vector,
  json_eState_ExpectEndVector,
  json_eState_End
} json_eState;

int Json::get_attribute_value(
    std::ifstream& fp, const char* attribute, char* value, int value_size)
{
  char c = 0;
  char prevc;
  int char_cnt = 0;
  int state[50];
  int state_level = 0;
  int attr_level = 0;
  int vector_level = 0;
  char current_attr[200][10];
  int current_attr_idx[10];
  int current_attr_invect[10];
  char current_value[200];
  int len;
  char input_attr[10][80];
  int input_attr_idx[10];
  int input_attr_num;
  char* s;

  state[0] = json_eState_Start;

  memset(&current_attr_invect, 0, sizeof(current_attr_invect));
  for (int i = 0; i < 10; i++)
    current_attr_idx[i] = -1;

  input_attr_num = dcli_parse(attribute, "/", "", (char*)input_attr,
      sizeof(input_attr) / sizeof(input_attr[0]), sizeof(input_attr[0]), 0);
  for (int i = 0; i < input_attr_num; i++) {
    if ((s = strchr(input_attr[i], '[')) != 0) {
      sscanf(s + 1, "%d", &input_attr_idx[i]);
      *s = 0;
    } else
      input_attr_idx[i] = -1;
  }

  fp.seekg(0);
  while (fp.good()) {
    prevc = c;
    c = fp.get();
    char_cnt++;

    switch (state[state_level]) {
    case json_eState_Start:
      if (c == '{') {
        state[state_level] = json_eState_ExpectEndPar;
        state_level++;
        state[state_level] = json_eState_ExpectAttr;
      }
      break;
    case json_eState_ExpectAttr:
      if (c == '{') {
        if (current_attr_invect[attr_level])
          current_attr_idx[attr_level]++;
        state[state_level] = json_eState_ExpectEndPar;
        state_level++;
        attr_level++;
        state[state_level] = json_eState_ExpectAttr;
      } else if (c == '}') {
        state_level--;
        if (state[state_level] != json_eState_ExpectEndPar) {
          printf("json: Parenthesis mismatch, char %d\n", char_cnt);
          return 0;
        }
        if (attr_level == 0) {
          state[state_level] = json_eState_End;
          break;
        }
        attr_level--;
      } else if (c == ']') {
        state_level--;
        if (state[state_level] != json_eState_ExpectEndVector) {
          printf("json: std::vector mismatch, char %d\n", char_cnt);
          return 0;
        }
        vector_level--;
        if (!current_attr_invect[attr_level]) {
          printf("json: std::vector attribute mismatch, char %d\n", char_cnt);
          current_attr_invect[attr_level] = 0;
        }

        current_attr_idx[attr_level] = -1;
        state[state_level] = json_eState_ExpectAttr;
        strcpy(current_attr[attr_level], "");
      } else if (c == '"') {
        state[state_level] = json_eState_Attr;
        strcpy(current_attr[attr_level], "");
      }
      break;
    case json_eState_Attr:
      if (c == '"') {
        state[state_level] = json_eState_ExpectValue;
      } else {
        len = strlen(current_attr[attr_level]);
        current_attr[attr_level][len] = c;
        current_attr[attr_level][len + 1] = 0;
      }
      break;
    case json_eState_ExpectValue:
      if (c == ':') {
        state[state_level] = json_eState_Value;
        strcpy(current_value, "");
      }
      break;
    case json_eState_Value:
      if (c == '{' && streq(current_value, "")) {
        state[state_level] = json_eState_ExpectEndPar;
        state_level++;
        attr_level++;
        state[state_level] = json_eState_ExpectAttr;
        strcpy(current_attr[attr_level], "");
      } else if (c == '[' && streq(current_value, "")) {
        state[state_level] = json_eState_ExpectEndVector;
        state_level++;
        vector_level++;
        // current_attr_idx[attr_level]++;
        state[state_level] = json_eState_ExpectAttr;
        strcpy(current_attr[attr_level + 1], "");
        current_attr_invect[attr_level] = 1;
      } else if (c == ',' || c == '}') {
        if (c == '}') {
          state_level--;
          if (state[state_level] != json_eState_ExpectEndPar) {
            printf("json: Parenthesis mismatch, char %d\n", char_cnt);
            return 0;
          }
          attr_level--;
        }
        state[state_level] = json_eState_ExpectAttr;
        if (current_value[0] == '"') {
          char tmp[200];
          strncpy(tmp, &current_value[1], sizeof(tmp));
          strncpy(current_value, tmp, sizeof(current_value));
        }
        if (current_value[strlen(current_value) - 1] == '"')
          current_value[strlen(current_value) - 1] = 0;

        // printf( "Value found \"%s\"\n", current_value);
        if (input_attr_num == attr_level + 1) {
          int match = 1;
          for (int j = 0; j < input_attr_num; j++) {
            if (!streq(current_attr[j], input_attr[j])) {
              match = 0;
              break;
            }
            if (current_attr_idx[j] != input_attr_idx[j]) {
              match = 0;
              break;
            }
          }
          if (match) {
            strncpy(value, current_value, value_size);
            return 1;
          }
        }
      } else {
        len = strlen(current_value);
        current_value[len] = c;
        current_value[len + 1] = 0;
      }
      break;
    }
  }
  // No match
  return 0;
}

XttVideoMgm::XttVideoMgm() : m_camera_cnt(0), m_scantime(0.5), m_op(0)
{
}

XttVideoMgm::~XttVideoMgm()
{
}

int XttVideoMgm::cinit()
{
  unsigned int i;

  memset(&m_op->PanelArraySelect, 0, sizeof(m_op->PanelArraySelect));
  memset(&m_op->CameraArraySelect, 0, sizeof(m_op->CameraArraySelect));

  init();

  for (i = 0; i < m_panel.size(); i++)
    strncpy(m_op->PanelArray[i], m_panel[i].name, sizeof(m_op->PanelArray[0]));
  for (; i < sizeof(m_op->PanelArray) / sizeof(m_op->PanelArray[0]); i++)
    strcpy(m_op->PanelArray[i], "");

  for (i = 0; i < m_camera.size(); i++)
    strncpy(
        m_op->CameraArray[i], m_camera[i].name, sizeof(m_op->CameraArray[0]));
  for (; i < sizeof(m_op->CameraArray) / sizeof(m_op->CameraArray[0]); i++)
    strcpy(m_op->CameraArray[i], "");

  m_op->NoOfCameras = m_camera.size();

  for (i = 0; i < sizeof(m_panel_select_old) / sizeof(m_panel_select_old[0]);
       i++)
    m_panel_select_old[i] = m_op->PanelArraySelect[i];

  for (i = 0; i < sizeof(m_camera_select_old) / sizeof(m_camera_select_old[0]);
       i++)
    m_camera_select_old[i] = m_op->CameraArraySelect[i];

  return 1;
}

void XttVideoMgm::cscan()
{
  // Detect any new panel selection
  for (unsigned int i = 0;
       i < sizeof(m_panel_select_old) / sizeof(m_panel_select_old[0]); i++) {
    if (m_panel_select_old[i] != m_op->PanelArraySelect[i]) {
      if (m_op->PanelArraySelect[i]) {
        // Panel selected
        display_panel(i);

        // Reset camera select
        for (unsigned int j = 0;
             j < sizeof(m_camera_select_old) / sizeof(m_camera_select_old[0]);
             j++) {
          m_camera_select_old[j] = 0;
          m_op->CameraArraySelect[j] = 0;
        }
      }
    }
    m_panel_select_old[i] = m_op->PanelArraySelect[i];
  }

  // Detect any new camera selection
  for (unsigned int i = 0;
       i < sizeof(m_camera_select_old) / sizeof(m_camera_select_old[0]); i++) {
    if (m_camera_select_old[i] != m_op->CameraArraySelect[i]) {
      if (m_op->CameraArraySelect[i]) {
        // Camera selected
        set_camera_fullscreen(i);

        // Reset panel select
        for (unsigned int j = 0;
             j < sizeof(m_panel_select_old) / sizeof(m_panel_select_old[0]);
             j++) {
          m_panel_select_old[j] = 0;
          m_op->PanelArraySelect[j] = 0;
        }
      }
    }
    m_camera_select_old[i] = m_op->CameraArraySelect[i];
  }

  // Check request to display last displayed panel
  if (m_op->DisplayLastPanel) {
    display_panel(m_op->LastPanel);
    m_op->DisplayLastPanel = 0;
  }

  // Check request to display camera fullscreen
  for (unsigned int i = 0;
       i < sizeof(m_op->CellExpand) / sizeof(m_op->CellExpand[0]); i++) {
    if (m_op->CellExpand[i]) {
      set_camera_fullscreen(m_op->CellCameraIdx[i]);
      m_op->CellExpand[i] = 0;
    }
  }

  // Check request to change camera in cell
  if (m_op->CurrentPanel >= 0 && m_op->CurrentPanel < (int)m_panel.size()) {
    int camera_assigned = 0;
    for (int i = 0; i < m_op->Rows; i++) {
      for (int j = 0; j < m_op->Columns; j++) {
        int idx = i * m_op->Columns + j;
        if (idx
            > int(sizeof(m_op->CellCameraIdx) / sizeof(m_op->CellCameraIdx[0])))
          break;
        if (m_op->CellCameraIdx[idx] != m_cell_camera_idx_old[idx]) {
          assign_camera(m_op->CurrentPanel, idx, m_op->CellCameraIdx[idx]);
          m_cell_camera_idx_old[idx] = m_op->CellCameraIdx[idx];
          camera_assigned = 1;
          break;
        }
      }
      if (camera_assigned)
        break;
    }
  }

  // Request to set panel by changing current panel
  if (m_op->CurrentPanel != m_current_panel_old) {
    if (m_op->CurrentPanel >= 0 && m_op->CurrentPanel < (int)m_panel.size()) {
      display_panel(m_op->CurrentPanel);
      // Reset any selected panel
      for (unsigned int i = 0; i
           < sizeof(m_op->PanelArraySelect) / sizeof(m_op->PanelArraySelect[0]);
           i++)
        m_op->PanelArraySelect[i] = m_panel_select_old[i] = 0;
      m_op->PanelArraySelect[m_op->CurrentPanel] = 1;
      m_panel_select_old[m_op->CurrentPanel] = 1;
    } else
      m_op->CurrentPanel = m_current_panel_old;
  }

  // Request to set camera by changing current camera
  if (m_op->CurrentCamera != m_current_camera_old) {
    if (m_op->CurrentCamera >= 0
        && m_op->CurrentCamera < (int)m_camera.size()) {
      set_camera_fullscreen(m_op->CurrentCamera);
      // Reset selected camera
      for (unsigned int i = 0; i < sizeof(m_op->CameraArraySelect)
               / sizeof(m_op->CameraArraySelect[0]);
           i++)
        m_op->CameraArraySelect[i] = m_camera_select_old[i] = 0;
    } else
      m_op->CurrentCamera = m_current_camera_old;
  }

  if (m_op->CreatePanel) {
    if (!streq(m_op->PanelName, "")) {
      create_panel(m_op->PanelName);
      strcpy(m_op->PanelName, "");
      m_op->CreatePanel = 0;
    }
  }
  if (m_op->DeletePanel) {
    if (!streq(m_op->PanelName, "")) {
      delete_panel(m_op->PanelName);
      strcpy(m_op->PanelName, "");
      m_op->DeletePanel = 0;
    }
  }
}

#define MGM_WIDTH 40.5
#define MGM_HEIGHT 25.5
#define MGM_LINEWIDTH 0.5

void XttVideoMgm::configure_layout()
{
  int i, j;
  int rows = m_op->Rows;
  int cols = m_op->Columns;
  int idx;

  if (m_op->CameraFullscreen) {
    // Hide lines and cells
    for (i = 0; i < 4; i++)
      m_op->VertLineX[i] = 0;

    for (i = 0; i < 4; i++)
      m_op->HorizLineY[i] = 0;

    for (i = 0; i < 20; i++) {
      m_op->CellY[i] = 0;
      m_op->CellX[i] = MGM_WIDTH + 5;
    }
  } else {
    if (rows < 1)
      rows = 1;
    if (rows > 4)
      rows = 4;

    if (cols < 1)
      cols = 1;
    if (cols > 4)
      cols = 4;

    // Horizontal lines
    for (i = 0; i < rows - 1; i++)
      m_op->HorizLineY[i]
          = MGM_HEIGHT / rows * (i + 1) - MGM_LINEWIDTH / 2 + MGM_LINEWIDTH / 2;
    for (; i < 4; i++)
      m_op->HorizLineY[i] = 0;

    // Vertical lines
    for (i = 0; i < cols - 1; i++)
      m_op->VertLineX[i]
          = MGM_WIDTH / cols * (i + 1) - MGM_LINEWIDTH / 2 + MGM_LINEWIDTH / 2;
    for (; i < 4; i++)
      m_op->VertLineX[i] = 0;

    // Cells
    for (i = 0; i < rows; i++) {
      for (j = 0; j < cols; j++) {
        idx = i * cols + j;
        m_op->CellY[idx] = MGM_HEIGHT / rows * i;
        m_op->CellX[idx] = MGM_WIDTH / cols * j;
      }
    }
    for (i = rows * cols; i < 20; i++) {
      m_op->CellY[i] = 0;
      m_op->CellX[i] = MGM_WIDTH + 5;
    }
  }
}

int XttVideoMgm::init()
{
  return 0;
}

int XttVideoMgm::authorize(char* user, char* password)
{
  return 0;
}

int XttVideoMgm::get_panels()
{
  return 0;
}

int XttVideoMgm::get_cameras()
{
  return 0;
}

int XttVideoMgm::get_camera_image(int idx, const char* jpgfile)
{
  return 0;
}

int XttVideoMgm::assign_camera(int panel_idx, int cell_idx, int camera_idx)
{
  return 0;
}

int XttVideoMgm::set_camera_fullscreen(int camera_idx)
{
  return 0;
}

int XttVideoMgm::display_panel(int panel_idx)
{
  return 0;
}

int XttVideoMgm::create_panel(char* name)
{
  return 0;
}

int XttVideoMgm::delete_panel(char* name)
{
  return 0;
}

void init(qcom_sQid* qid)
{
  qcom_sQid qini;
  qcom_sQattr qAttr;
  pwr_tStatus sts;

  sts = gdh_Init("pwr_videomgm");
  if (EVEN(sts)) {
    errh_Fatal("gdh_Init, %m", sts);
    exit(sts);
  }

  errh_Init("pwr_fast", errh_eAnix_videomgm);
  errh_SetStatus(PWR__SRVSTARTUP);

  if (!qcom_Init(&sts, 0, "pwr_videomgm")) {
    errh_Fatal("qcom_Init, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  qAttr.type = qcom_eQtype_private;
  qAttr.quota = 100;
  if (!qcom_CreateQ(&sts, qid, &qAttr, "events")) {
    errh_Fatal("qcom_CreateQ, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  qini = qcom_cQini;
  if (!qcom_Bind(&sts, qid, &qini)) {
    errh_Fatal("qcom_Bind(Qini), %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(-1);
  }
}

int main(int argc, char* argv[])
{
  VideoMgmServer srv;
  pwr_tStatus sts;
  int tmo = 0;
  char mp[2000];
  qcom_sQid qid = qcom_cNQid;
  qcom_sGet get;
  int swap = 0;
  bool first_scan = true;

  init(&qid);

  try {
    srv.open();
  } catch (co_error& e) {
    errh_Error((char*)e.what().c_str());
    errh_Fatal("xtt_videomgm aborting");
    errh_SetStatus(PWR__SRVTERM);
    exit(0);
  }

  aproc_TimeStamp(srv.scantime(), 5);
  errh_SetStatus(PWR__SRUN);

  first_scan = true;
  for (;;) {
    if (first_scan) {
      tmo = (int)(srv.scantime() * 1000 - 1);
    }

    get.maxSize = sizeof(mp);
    get.data = mp;
    qcom_Get(&sts, &qid, &get, tmo);
    if (sts == QCOM__TMO || sts == QCOM__QEMPTY) {
      if (!swap)
        srv.scan();
    } else {
      ini_mEvent new_event;
      qcom_sEvent* ep = (qcom_sEvent*)get.data;

      new_event.m = ep->mask;
      if (new_event.b.oldPlcStop && !swap) {
        errh_SetStatus(PWR__SRVRESTART);
        swap = 1;
        srv.close();
      } else if (new_event.b.swapDone && swap) {
        swap = 0;
        srv.open();
        errh_SetStatus(PWR__SRUN);
      } else if (new_event.b.terminate) {
        exit(0);
      }
    }
    first_scan = false;
  }
}

void VideoMgmServer::close()
{
  for (unsigned int i = 0; i < m_mgmvect.size(); i++) {
    gdh_DLUnrefObjectInfo(m_mgmvect[i]->m_dlid);
    delete m_mgmvect[i];
  }

  m_mgmvect.clear();
}

void VideoMgmServer::open()
{
  pwr_tStatus sts;
  pwr_tAttrRef aref;
  pwr_sClass_XttVideoMgm* op;
  pwr_tDlid dlid;
  pwr_sClass_VideoMgmServer* serverp;
  pwr_tOid oid;

  // Get server object
  sts = gdh_GetClassList(pwr_cClass_VideoMgmServer, &oid);
  if (EVEN(sts)) {
    errh_Fatal("No configuration, %m", sts);
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  sts = gdh_ObjidToPointer(oid, (void**)&serverp);
  if (EVEN(sts)) {
    errh_SetStatus(PWR__SRVTERM);
    exit(sts);
  }

  aproc_RegisterObject(oid);

  m_scantime = serverp->Scantime;

  // Get all XttVideoMgm objects
  for (sts = gdh_GetClassListAttrRef(pwr_cClass_XttVideoMgm, &aref); ODD(sts);
       sts = gdh_GetNextAttrRef(pwr_cClass_XttVideoMgm, &aref, &aref)) {
    sts = gdh_DLRefObjectInfoAttrref(&aref, (void**)&op, &dlid);
    if (EVEN(sts))
      exit(sts);

    switch (op->Type) {
    case 0: {
      // Type is Aimetis Thin Client
      XttVideoMgmAimetis* mgm;

      mgm = new XttVideoMgmAimetis(op->URL);
      mgm->m_op = op;
      mgm->m_dlid = dlid;
      mgm->cinit();
      m_mgmvect.push_back(mgm);
      serverp->VideoMgmObjects[m_mgmvect.size() - 1] = aref.Objid;
      break;
    }
    default:
      errh_Error("Unknown vms type");
    }
  }
}

void VideoMgmServer::scan()
{
  aproc_TimeStamp(scantime(), 5);

  for (unsigned int i = 0; i < m_mgmvect.size(); i++)
    m_mgmvect[i]->cscan();
}
