/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/* rt_xtt.cpp -- Display plant and node hiererachy */

#include <stdlib.h>

#include <iostream>

#include "pwr_systemclasses.h"
#include "pwr_sevclasses.h"

#include "co_cdh.h"
#include "co_dcli.h"
#include "co_string.h"
#include "co_syi.h"

#include "cow_wow.h"
#include "cow_xhelp.h"

#include "rt_gdh_msg.h"
#include "rt_ini_event.h"
#include "rt_qcom_msg.h"
#include "rt_xtt_main.h"

#include "xtt_item.h"
#include "xtt_methodtoolbar.h"
#include "xtt_op.h"
#include "xtt_trace.h"
#include "xtt_url.h"

// Static variables
Xtt* Xtt::hot_xtt = 0;

xnav_sStartMenu Xtt::alarm_menu[]
    = { { "Alarm List", xnav_eItemType_Command, menu_ePixmap_List,
            (void*)"show alarm" },
        { "Event List", xnav_eItemType_Command, menu_ePixmap_List,
            (void*)"show event" },
        { "Blocked Alarms", xnav_eItemType_Command, menu_ePixmap_List,
            (void*)"show block" },
        { "Historical List", xnav_eItemType_Command, menu_ePixmap_List,
            (void*)"show hist" },
        { "", 0, 0, NULL } };

xnav_sStartMenu Xtt::nethandler_menu[] = {
  { "Link", xnav_eItemType_Command, menu_ePixmap_Map, (void*)"show link" },
  { "Subscription Client", xnav_eItemType_Command, menu_ePixmap_Map,
      (void*)"show subcli" },
  { "Subscription Server", xnav_eItemType_Command, menu_ePixmap_Map,
      (void*)"show subsrv" },
  { "", 0, 0, NULL }
};
xnav_sStartMenu Xtt::communication_menu[]
    = { { "RemNode", xnav_eItemType_Command, menu_ePixmap_Map,
            (void*)"show remnode" },
        { "RemTrans", xnav_eItemType_Command, menu_ePixmap_Map,
            (void*)"show remtrans" },
        { "", 0, 0, NULL } };
xnav_sStartMenu Xtt::logging_menu[]
    = { { "Logging entry 1", xnav_eItemType_Command, menu_ePixmap_Map,
            (void*)"show logging/entry=1" },
        { "Logging entry 2", xnav_eItemType_Command, menu_ePixmap_Map,
            (void*)"show logging/entry=2" },
        { "Logging entry 3", xnav_eItemType_Command, menu_ePixmap_Map,
            (void*)"show logging/entry=3" },
        { "Logging entry 4", xnav_eItemType_Command, menu_ePixmap_Map,
            (void*)"show logging/entry=4" },
        { "Logging entry 5", xnav_eItemType_Command, menu_ePixmap_Map,
            (void*)"show logging/entry=5" },
        { "Logging entry 6", xnav_eItemType_Command, menu_ePixmap_Map,
            (void*)"show logging/entry=6" },
        { "Logging entry 7", xnav_eItemType_Command, menu_ePixmap_Map,
            (void*)"show logging/entry=7" },
        { "Logging entry 8", xnav_eItemType_Command, menu_ePixmap_Map,
            (void*)"show logging/entry=8" },
        { "Logging entry 9", xnav_eItemType_Command, menu_ePixmap_Map,
            (void*)"show logging/entry=9" },
        { "Logging entry 10", xnav_eItemType_Command, menu_ePixmap_Map,
            (void*)"show logging/entry=10" },
        { "", 0, 0, NULL } };
xnav_sStartMenu Xtt::system_menu[] = { { "Nethandler", xnav_eItemType_Menu,
                                           menu_ePixmap_Map,
                                           (void*)&Xtt::nethandler_menu },
  { "Communication", xnav_eItemType_Menu, menu_ePixmap_Map,
      (void*)&Xtt::communication_menu },
  { "Device", xnav_eItemType_Command, menu_ePixmap_Map, (void*)"show device" },
  { "PlcThread", xnav_eItemType_Command, menu_ePixmap_Map,
      (void*)"show plcthread" },
  { "PlcPgm", xnav_eItemType_Command, menu_ePixmap_Map, (void*)"show plcpgm" },
  { "Logging", xnav_eItemType_Menu, menu_ePixmap_Map,
      (void*)&Xtt::logging_menu },
  { "System Messages", xnav_eItemType_Command, menu_ePixmap_List,
      (void*)"open consolelog" },
  { "System Status", xnav_eItemType_Command, menu_ePixmap_Map,
      (void*)"show nodeinfo" },
  { "Nodes", xnav_eItemType_Command, menu_ePixmap_Map,
      (void*)"show nodeobjects" },
  { "Volumes", xnav_eItemType_Command, menu_ePixmap_Map,
      (void*)"show volumes" },
  { "History", xnav_eItemType_Command, menu_ePixmap_Map,
      (void*)"show history" },
  { "", 0, 0, NULL } };
xnav_sStartMenu Xtt::root_menu[] = { { "Database", xnav_eItemType_Command,
                                         menu_ePixmap_Map,
                                         (void*)"show database" },
  { "Alarm", xnav_eItemType_Menu, menu_ePixmap_Map, (void*)&Xtt::alarm_menu },
  { "Store", xnav_eItemType_Command, menu_ePixmap_Map, (void*)"show file" },
  { "System", xnav_eItemType_Menu, menu_ePixmap_Map, (void*)&Xtt::system_menu },
  { "Close", xnav_eItemType_Command, menu_ePixmap_Leaf, (void*)"exit" },
  { "", 0, 0, NULL } };

static void usage()
{
  std::cout << "Usage: rt_xtt -saqc -l lang -u user -f flavor opplace\n\n"
            << "	Argument OpPlace object.\n\n"
            << "	-l  Language (sv_se, zh_cn etc).\n"
            << "	-u  Use opplace with the same name as the user.\n"
            << "	-s  Show a selection list of OpPlace objects.\n"
            << "	-a  Connect to audio device.\n"
            << "	-q  Hide license information.\n"
            << "	-n  Network optimized.\n"
            << "	-c  Add close button to operator window.\n\n";
}

void Xtt::hotkey_activate_command(char* cmdp)
{
  pwr_tCmd cmd;

  strcpy(cmd, cmdp);
  if (xnav)
    xnav->command(cmd);
}

void Xtt::hotkey_activate_toggledig(char* namep)
{
  pwr_tBoolean value;
  pwr_tAName name;
  int sts;

  str_trim(name, namep);
  if (!strchr(name, '.'))
    strcat(name, ".ActualValue");

  sts = gdh_GetObjectInfo(name, &value, sizeof(value));
  if (EVEN(sts)) {
    printf("rt_xtt hotkey: ToggleDig. Can't get %s\n", name);
    return;
  }

  value = !value;
  sts = gdh_SetObjectInfo(name, &value, sizeof(value));
  if (EVEN(sts))
    printf("rt_xtt hotkey: ToggleDig. Can't get %s\n", name);
}

void Xtt::hotkey_activate_setdig(char* namep)
{
  pwr_tBoolean value = 1;
  pwr_tAName name;
  int sts;

  str_trim(name, namep);
  if (!strchr(name, '.'))
    strcat(name, ".ActualValue");

  sts = gdh_SetObjectInfo(name, &value, sizeof(value));
  if (EVEN(sts))
    printf("rt_xtt hotkey: SetDig. Can't get %s\n", name);
}

void Xtt::hotkey_activate_resetdig(char* namep)
{
  pwr_tBoolean value = 0;
  pwr_tAName name;
  int sts;

  str_trim(name, namep);
  if (!strchr(name, '.'))
    strcat(name, ".ActualValue");

  sts = gdh_SetObjectInfo(name, &value, sizeof(value));
  if (EVEN(sts))
    printf("rt_xtt hotkey: SetDig. Can't get %s\n", name);
}

void Xtt::hotkey_activate_setvalue(char* namep, char *valuep)
{
  pwr_tAName name;
  pwr_tStatus sts;
  pwr_tTypeId tid;
  pwr_tUInt32 size;
  char value[80];

  str_trim(name, namep);
  if (!strchr(name, '.'))
    strcat(name, ".ActualValue");

  sts = gdh_GetAttributeCharacteristics(name, &tid, &size, 0, 0);
  if (EVEN(sts)) {
    printf("rt_xtt hotkey: SetValue. Can't get %s\n", name);
    return;
  }

  sts = gdh_AttrStringToValue(tid, valuep, value, sizeof(value), size); 
  if (EVEN(sts)) {
    printf("rt_xtt hotkey: SetValue. Can't convert value %s\n", name);
    return;
  }

  sts = gdh_SetObjectInfo(name, value, size);
  if (EVEN(sts))
    printf("rt_xtt hotkey: SetValue. Can't get %s\n", name);
}

void Xtt::open_URL_cb(void* ctx, char* url)
{
  xnav_open_URL(url);
}

void Xtt::qcom_events(void* data)
{
  Xtt* xtt = (Xtt*)data;
  char mp[2000];
  qcom_sGet get;
  static int swap = 0;
  pwr_tStatus sts = 1;

  while (ODD(sts)) {
    get.maxSize = sizeof(mp);
    get.data = mp;
    qcom_Get(&sts, &xtt->queid, &get, 0);
    if (!(sts == QCOM__TMO || sts == QCOM__QEMPTY)) {
      ini_mEvent new_event;
      qcom_sEvent* ep = (qcom_sEvent*)get.data;

      new_event.m = ep->mask;
      if (new_event.b.oldPlcStop && !swap) {
        swap = 1;
        xtt->xnav->swap(0);
      } else if (new_event.b.swapDone && swap) {
        swap = 0;
        xtt->xnav->swap(1);
      } else if (new_event.b.terminate) {
        delete xtt->xnav;
        exit(0);
      }
    }
  }
  xtt->timerid->add(1000, qcom_events, xtt);
}

void Xtt::findregex_ok(Xtt* xtt, char* search_str)
{
  int sts;

  sts = xtt->xnav->search(search_str, 1);
  if (EVEN(sts))
    xtt->message('E', xtt->xnav->get_message(sts));
}

void Xtt::find_ok(Xtt* xtt, char* search_str)
{
  int sts;

  sts = xtt->xnav->search(search_str, 0);
  if (EVEN(sts))
    xtt->message('E', xtt->xnav->get_message(sts));
}

void Xtt::xtt_message_cb(void* ctx, char severity, const char* msg)
{
  ((Xtt*)ctx)->message(severity, msg);
}

void Xtt::close_ok(void* ctx, void* data)
{
  Xtt* xtt = (Xtt*)ctx;

  delete xtt;
  exit(0);
}

void Xtt::change_value(void* ctx)
{
  Xtt* xtt = (Xtt*)ctx;

  xtt->open_change_value();
}

void Xtt::selection_changed(void* ctx)
{
  Xtt* xtt = (Xtt*)ctx;

  xtt->methodtoolbar->set_sensitive();
}

//
//  Callbackfunctions from menu entries
//
void Xtt::activate_print()
{
  print();
}

void Xtt::activate_find()
{
  open_input_dialog("Search string", "Find object", "", &find_ok);
}

void Xtt::activate_findregex()
{
  open_input_dialog(
      "Search string", "Find regular expression", "", &findregex_ok);
}

void Xtt::activate_findnext()
{
  int sts;

  sts = xnav->search_next();
  if (EVEN(sts))
    message('E', xnav->get_message(sts));
}

void Xtt::activate_collapse()
{
  xnav->brow_push_all();
}

void Xtt::activate_openobject()
{
  int sts;
  int is_attr;
  pwr_sAttrRef attrref;

  sts = xnav->get_select(&attrref, &is_attr);
  if (ODD(sts))
    xnav->open_object(&attrref);
}

void Xtt::activate_openplc()
{
  xnav->start_trace_selected();
}

void Xtt::activate_opengraph()
{
  int sts;
  pwr_tClassId classid;
  pwr_tAName name;
  pwr_tAName vname;
  pwr_tFileName filename;
  int is_attr;
  pwr_sAttrRef attrref;
  char cmd[1080];

  sts = xnav->get_select(&attrref, &is_attr);
  if (EVEN(sts)) {
    // If collect brow open collect graph
    if (xnav->brow->ctx == xnav->collect_brow->ctx) {
      sprintf(cmd, "open graph /collect");
      xnav->command(cmd);
    }
    return;
  }

  sts = gdh_AttrrefToName(&attrref, name, sizeof(name), cdh_mNName);
  if (EVEN(sts))
    return;

  sts = gdh_AttrrefToName(
      &attrref, vname, sizeof(vname), cdh_mName_volumeStrict);
  if (EVEN(sts))
    return;

  sts = gdh_GetAttrRefTid(&attrref, &classid);
  if (EVEN(sts))
    return;

  if (cdh_tidIsCid(classid)) {
    switch (classid) {
    case pwr_cClass_PlantHier:
      // Open default graph
      sprintf(cmd, "call meth /meth=Graph /object=%s", vname);
      xnav->command(cmd);
      return;
    case pwr_cClass_XttMultiView:
      // Open multiview
      sprintf(cmd, "open mult /name=%s", vname);
      xnav->command(cmd);
      return;
    case pwr_cClass_XttCamera:
      // Open video
      sprintf(cmd, "open camera /obj=%s", vname);
      xnav->command(cmd);
      return;
    case pwr_cClass_DsTrend:
    case pwr_cClass_DsTrendCurve:
      // Open trend
      sprintf(cmd, "open trend /name=%s /title=\"%s\"", vname, name);
      xnav->command(cmd);
      return;
    case pwr_cClass_DsFast:
    case pwr_cClass_DsFastCurve:
      // Open fast
      sprintf(cmd, "open fast /name=%s /title=\"%s\"", vname, name);
      xnav->command(cmd);
      return;
    case pwr_cClass_SevHist:
    case pwr_cClass_SevHistObject:
    case pwr_cClass_SevItemInt32:
    case pwr_cClass_SevItemFloat32:
    case pwr_cClass_SevItemBoolean:
    case pwr_cClass_SevPlotGroup:
      // Open history
      sprintf(cmd, "open history /name=%s /title=\"%s\"", vname, name);
      xnav->command(cmd);
      return;
    case pwr_cClass_PlotGroup: {
#if 0
      pwr_tAName aname;
      pwr_tAttrRef yo;

      strcpy( aname, vname);
      strcat( aname, ".YObjectName[0]");

      sts = gdh_GetObjectInfo( aname, (void *)&yo, sizeof(yo));
      if ( ODD(sts) && cdh_ObjidIsNotNull( yo.Objid)) {
	sts = gdh_GetAttrRefTid( &yo, &classid);
	if ( EVEN(sts)) return;

	switch ( classid) {
	case pwr_cClass_DsTrend:
	case pwr_cClass_DsTrendCurve:
	  // Open trend
	  sprintf( cmd, "open trend /name=%s /title=\"%s\"", vname, name);
	  xnav->command( cmd);
	  return;
	case pwr_cClass_DsFast:
	case pwr_cClass_DsFastCurve:
	  // Open fast
	  sprintf( cmd, "open fast /name=%s /title=\"%s\"", vname, name);
	  xnav->command( cmd);
	  return;
	case pwr_cClass_SevHist:
	case pwr_cClass_SevHistObject:
	  // Open history
	  sprintf( cmd, "open history /name=%s /title=\"%s\"", vname, name);
	  xnav->command( cmd);
	  return;
	}
	return;
      }
      return;
#endif
      sprintf(cmd, "open plotgroup /name=%s /title=\"%s\"", name, name);
      xnav->command(cmd);
      return;
    }
    default:
      sprintf(cmd, "open graph /class/inst=%s/name=\"%s\"", vname, name);
      xnav->command(cmd);
      return;
    }
  } else {
    switch (classid) {
    case pwr_eType_Float32:
      sprintf(filename, "pwr_exe:pwr_t_float32.pwg");
      break;
    case pwr_eType_Int32:
      sprintf(filename, "pwr_exe:pwr_t_int32.pwg");
      break;
    case pwr_eType_UInt32:
      sprintf(filename, "pwr_exe:pwr_t_uint32.pwg");
      break;
    case pwr_eType_Boolean:
      sprintf(filename, "pwr_exe:pwr_t_boolean.pwg");
      break;
    default:
      message('E', "No graph for this attribute type");
      return;
    }
    sprintf(cmd, "open graph %s/inst=%s/name=\"%s\"", filename, vname, name);
    xnav->command(cmd);
  }
}

void Xtt::activate_collect_insert()
{
  pwr_sAttrRef attrref;
  int is_attr;
  int sts;

  sts = xnav->get_select(&attrref, &is_attr);
  if (ODD(sts))
    xnav->collect_insert(&attrref);
}

void Xtt::activate_dashboard_insert()
{
  pwr_sAttrRef attrref;
  int is_attr;
  int sts;

  sts = xnav->get_select(&attrref, &is_attr);
  if (ODD(sts))
    xnav->dashboard_insert(&attrref);
}

void Xtt::activate_advanceduser()
{
  char cmd[80];

  strcpy(cmd, "set advanceduser");
  xnav->command(cmd);
}

void Xtt::activate_zoom_in()
{
  double zoom_factor;

  xnav->get_zoom(&zoom_factor);
  if (zoom_factor > 40)
    return;

  xnav->zoom(1.18);
}

void Xtt::activate_zoom_out()
{
  double zoom_factor;

  xnav->get_zoom(&zoom_factor);
  if (zoom_factor < 15)
    return;

  xnav->zoom(1.0 / 1.18);
}

void Xtt::activate_method(char* method, char* filter)
{
  int sts;
  int is_attr;
  pwr_sAttrRef aref;
  xmenu_eItemType menu_type;

  sts = xnav->get_select(&aref, &is_attr);

  if (aref.Flags.b.Object)
    menu_type = xmenu_eItemType_Object;
  else if (aref.Flags.b.ObjectAttr)
    menu_type = xmenu_eItemType_AttrObject;
  else
    menu_type = xmenu_eItemType_Attribute;

  if (ODD(sts))
    xnav->call_method(
        method, filter, aref, menu_type, xmenu_mUtility_XNav, xnav->priv, 0);
}

void Xtt::activate_help()
{
  CoXHelp::dhelp("overview", "", navh_eHelpFile_Base, NULL, 0);
}

void Xtt::activate_help_project()
{
  CoXHelp::dhelp("index", "", navh_eHelpFile_Project, NULL, 0);
}

void Xtt::activate_help_navigator()
{
  CoXHelp::dhelp(
      "opg_navigator", "", navh_eHelpFile_Other, "$pwr_lang/man_opg.dat", 0);
}

void Xtt::activate_help_proview()
{
  CoXHelp::dhelp(
      "version", "", navh_eHelpFile_Other, "$pwr_load/xtt_version_help.dat", 0);
}

Xtt::Xtt(int* argc, char** argv[], int* return_sts)
    : root_item(0), input_open(0), command_open(0), india_ok_cb(0),
      queid(qcom_cNQid), quiet(0), attach_audio(0), select_opplace(0),
      op_close_button(0), no_advanceduser(0), network_optimized(0)
{
  pwr_tStatus sts;
  int i;
  int opplace_found = 0;
  int default_opplace = 0;
  pwr_tObjid op_objid;
  qcom_sQattr qAttr;
  qcom_sQid qini;
  char language[20] = "";
  pwr_sClass_OpPlace* opp = NULL;
  static char display[80];
  static char display_opt[20] = "--display";

  if (*argc > 1 && streq((*argv)[1], "-m")) {
    XNav::print_methods();
    exit(0);
  }

  *return_sts = XNAV__SUCCESS;

  strcpy(opplace_str, "");
  hot_xtt = this;

  errh_Init("rt_xtt", errh_eNAnix);

  sts = gdh_Init("rt_xtt");
  if (EVEN(sts)) {
    *return_sts = sts;
    return;
  }

  if (!qcom_Init(&sts, 0, "rt_xtt")) {
    *return_sts = sts;
    return;
  }

  qAttr.type = qcom_eQtype_private;
  qAttr.quota = 100;
  if (!qcom_CreateQ(&sts, &queid, &qAttr, "events")) {
    *return_sts = sts;
    return;
  }

  qini = qcom_cQini;
  if (!qcom_Bind(&sts, &queid, &qini)) {
    *return_sts = sts;
    return;
  }

  // Set language
  pwr_tClassId op_class;
  for (i = 1; i < *argc; i++) {
    if ((*argv)[i][0] == '-') {
      int i_incr = 0;
      for (int j = 1; (*argv)[i][j] != 0 && (*argv)[i][j] != ' '
           && (*argv)[i][j] != '	';
           j++) {
        switch ((*argv)[i][j]) {
        case 'q':
          quiet = 1;
          break;
        case 'a':
          attach_audio = 1;
          break;
        case 's':
          select_opplace = 1;
          break;
        case 'h':
          usage();
          exit(0);
        case 'c':
          op_close_button = 1;
          break;
        case 'd':
          no_advanceduser = 1;
          break;
        case 'n':
          network_optimized = 1;
          break;
        case 'l':
          if (i + 1 >= *argc
              || !((*argv)[i][j + 1] == ' ' || (*argv)[i][j + 1] != '	')) {
            usage();
            exit(0);
          }
          strncpy(language, (*argv)[i + 1], sizeof(language));
          i++;
          i_incr = 1;
          break;
        case 'u': {
          if (i + 1 >= *argc
              || !((*argv)[i][j + 1] == ' ' || (*argv)[i][j + 1] != '	')) {
            usage();
            exit(0);
          }
          char oname[80];

          strcpy(opplace_str, (*argv)[i + 1]);

          sts = gdh_GetClassList(pwr_cClass_OpPlace, &op_objid);
          while (ODD(sts)) {
            sts = gdh_ObjidToName(
                op_objid, oname, sizeof(oname), cdh_mName_object);
            if (ODD(sts) && str_NoCaseStrcmp(oname, opplace_str) == 0) {
              sts = gdh_ObjidToName(op_objid, opplace_str, sizeof(opplace_str),
                  cdh_mName_volumeStrict);
              opplace_found = 1;
              break;
            }
            sts = gdh_GetNextObject(op_objid, &op_objid);
          }
          if (!opplace_found) {
            printf("** Unable to find opplace\n");
            exit(sts);
          }
          i_incr = 1;
          i++;
          break;
        }
        case '-':
          // Possible arg to gtk
          if (streq((*argv)[i], "--display")) {
            // Gtk arg with parameter
            i++;
            i_incr = 1;
          } else if (streq((*argv)[i], "--sync")) {
            // Gtk arg without parameter
            i_incr = 1;
          }
          break;
        default:
          usage();
          exit(0);
        }
        if (i_incr)
          break;
      }
    } else {
      // Opplace argument
      strcpy(opplace_str, (*argv)[i]);

      if (strchr(opplace_str, '-') == 0) {
        char oname[80];

        sts = gdh_GetClassList(pwr_cClass_OpPlace, &op_objid);
        while (ODD(sts)) {
          sts = gdh_ObjidToName(
              op_objid, oname, sizeof(oname), cdh_mName_object);
          if (ODD(sts) && str_NoCaseStrcmp(oname, opplace_str) == 0) {
            sts = gdh_ObjidToName(op_objid, opplace_str, sizeof(opplace_str),
                cdh_mName_volumeStrict);
            opplace_found = 1;
            break;
          }
          sts = gdh_GetNextObject(op_objid, &op_objid);
        }
        if (!opplace_found) {
          printf("** Unable to find opplace\n");
          exit(sts);
        }
      } else {
        sts = gdh_NameToObjid(opplace_str, &op_objid);
        if (EVEN(sts)) {
          printf("** Unable to find opplace\n");
          exit(sts);
        }

        sts = gdh_GetObjectClass(op_objid, &op_class);
        if (EVEN(sts))
          exit(sts);

        if (op_class != pwr_cClass_OpPlace) {
          printf("** Error in opplace object class\n");
          exit(sts);
        }
        opplace_found = 1;
      }
    }
  }

  if (network_optimized)
    XttMethodToolbar::disable();

  if (select_opplace) {
    // Check if there is only one single opplace
    pwr_tOName fullname;
    pwr_tStatus sts;
    pwr_tOid oid;

    int i = 0;
    for (sts = gdh_GetClassList(pwr_cClass_OpPlace, &oid); ODD(sts);
         sts = gdh_GetNextObject(oid, &oid)) {
      sts = gdh_ObjidToName(
          oid, fullname, sizeof(fullname), cdh_mName_volumeStrict);
      if (EVEN(sts))
        continue;

      i++;
    }
    if (i == 1) {
      strcpy(opplace_str, fullname);
      opplace_found = 1;
    }
  }
  if (!opplace_found) {
    // Look for default opplace
    pwr_tOid oid;
    pwr_tOName name;

    for (sts = gdh_GetClassList(pwr_cClass_OpPlace, &oid); ODD(sts);
         sts = gdh_GetNextObject(oid, &oid)) {
      pwr_sClass_OpPlace* opp;

      sts = gdh_ObjidToPointer(oid, (void**)&opp);
      if (ODD(sts) && opp->IsDefaultOp) {
        sts = gdh_ObjidToName(oid, name, sizeof(name), cdh_mName_volumeStrict);
        if (EVEN(sts))
          exit(sts);

        strcpy(opplace_str, name);
        opplace_found = 1;
        default_opplace = 1;
        break;
      }
    }
    if (default_opplace) {
      sts = gdh_NameToPointer(opplace_str, (void**)&opp);
      if (EVEN(sts))
        exit(sts);

      if (streq(opp->UserName, "")) {
        // Ignore
        printf("** No UserName supplied in default opplace, ignored\n");
        strcpy(opplace_str, "");
        opplace_found = 0;
        default_opplace = 0;
      }
    }
  }

  if (opplace_found) {
    char opsys_user[40];

    sts = gdh_NameToPointer(opplace_str, (void**)&opp);
    if (EVEN(sts))
      exit(sts);

    if (!streq(opp->DedicatedOpsysUser, "")) {
      int duser_cnt;
      char duser_array[10][40];
      int found = 0;

      sts = syi_UserName(opsys_user, sizeof(opsys_user));
      if (EVEN(sts))
        exit(sts);

      duser_cnt = dcli_parse(opp->DedicatedOpsysUser, ",", "",
          (char*)duser_array, sizeof(duser_array) / sizeof(duser_array[0]),
          sizeof(duser_array[0]), 0);

      for (int i = 0; i < duser_cnt; i++) {
        str_trim(duser_array[i], duser_array[i]);
        if (streq(duser_array[i], opsys_user)) {
          found = 1;
          break;
        }
      }
      if (!found) {
        if (!default_opplace) {
          printf("Operator place is dedicated for another user\n");
          exit(0);
        } else {
          strcpy(opplace_str, "");
          opplace_found = 0;
        }
      }
    }
  }
  if (opplace_found) {
    if (streq(language, "")) {
      switch (opp->Language) {
      case pwr_eLanguageEnum_Swedish:
        strcpy(language, "sv_se");
        break;
      case pwr_eLanguageEnum_German:
        strcpy(language, "de_de");
        break;
      case pwr_eLanguageEnum_French:
        strcpy(language, "fr_fr");
        break;
      default:
        strcpy(language, "");
      }
    }
    if (!streq(opp->Display, "")) {
      strncpy(display, opp->Display, sizeof(display));
      char** argv1 = (char**)calloc(*argc + 3, sizeof(*argv1));
      for (int i = 0; i < *argc; i++)
        argv1[i] = (*argv)[i];
      argv1[*argc] = display_opt;
      argv1[*argc + 1] = display;
      argv1[*argc + 2] = 0;
      (*argc) += 2;
      *argv = argv1;
    }
    if (opp->OpWindLayout & pwr_mOpWindLayoutMask_HideLicenseWindow)
      quiet = 1;

    if (opp->AttachAudio)
      attach_audio = 1;

    if (!(opp->Options & pwr_mOpPlaceOptionsMask_EnablePrintDialog))
      CoWow::DisablePrintDialog();
    if (!streq(opp->Printer, ""))
      CoWow::SetDefaultPrinter(opp->Printer);
  }

  if (quiet)
    CoWow::HideWarranty();

  if (!streq(language, ""))
    Lng::set(language);
}

Xtt::~Xtt()
{
}

void Xtt::message(char severity, const char* msg)
{
}

void Xtt::open_input_dialog(const char* text, const char* title,
    const char* init_text, void (*ok_cb)(Xtt*, char*))
{
}

void Xtt::set_prompt(const char* prompt)
{
}

void Xtt::open_change_value()
{
}

void Xtt::print()
{
}

void Xtt::opplace_selected_cb(void* ctx, char* text, int ok_pressed)
{
  Xtt* xtt = (Xtt*)ctx;
  pwr_tCmd cmd;

  sprintf(cmd, "open operator %s", text);
  if (xtt->op_close_button)
    strcat(cmd, " /closebutton");
  xtt->xnav->command(cmd);
  if (xtt->xnav->op)
    xtt->xnav->op->set_color_theme(xtt->xnav->gbl.color_theme);
  // xtt->xnav->load_ev_from_opplace();
}

void Xtt::list_opplace()
{
  pwr_tOName texts[20];
  pwr_tStatus sts;
  pwr_tOid oid;
  pwr_tVid root_vid;

  gdh_GetRootVolume(&root_vid);

  int i = 0;
  for (sts = gdh_GetClassList(pwr_cClass_OpPlace, &oid); ODD(sts);
       sts = gdh_GetNextObject(oid, &oid)) {
    if (oid.vid == root_vid)
      sts = gdh_ObjidToName(oid, texts[i], sizeof(texts[0]), cdh_mNName);
    else
      sts = gdh_ObjidToName(
          oid, texts[i], sizeof(texts[0]), cdh_mName_volumeStrict);
    if (EVEN(sts))
      continue;

    i++;
    if (i == (int)(sizeof(texts) / sizeof(texts[0]) - 2))
      break;
  }
  strcpy(texts[i], "");

  if (i == 0) {
    printf("No opplace objects found\n");
    exit(0);
  }

  if (i == 1) {
    // Only one opplace found, open it
    pwr_tCmd cmd;

    sprintf(cmd, "open operator %s", texts[0]);
    if (op_close_button)
      strcat(cmd, " /closebutton");
    xnav->command(cmd);
  } else
    // Select oplace from list
    wow->CreateList("Select Operator Place", (char*)texts, sizeof(pwr_tOName),
        opplace_selected_cb, 0, this);
}

int Xtt::xnav_get_select(void* ctx, pwr_tAttrRef* attrref, int* is_attr)
{
  return ((XNav*)ctx)->get_select(attrref, is_attr);
}
