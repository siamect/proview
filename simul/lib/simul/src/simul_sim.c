/*
 * ProviewR   Open Source Process Control.
 * Copyright (C) 2005-2021 SSAB EMEA AB.
 *
 * This file is part of ProviewR.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ProviewR. If not, see <http://www.gnu.org/licenses/>
 *
 * Linking ProviewR statically or dynamically with other modules is
 * making a combined work based on ProviewR. Thus, the terms and
 * conditions of the GNU General Public License cover the whole
 * combination.
 *
 * In addition, as a special exception, the copyright holders of
 * ProviewR give you permission to, from the build function in the
 * ProviewR Configurator, combine ProviewR with modules generated by the
 * ProviewR PLC Editor to a PLC program, regardless of the license
 * terms of these modules. You may copy and distribute the resulting
 * combined work under the terms of your choice, provided that every
 * copy of the combined work is accompanied by a complete copy of
 * the source code of ProviewR (the version used to produce the
 * combined work), being distributed under the terms of the GNU
 * General Public License plus this exception.
 */

/*  rt_simul_sim.c */

#include <float.h>
#include <math.h>
#include "simul.h"

/*_*
  Sim_SignalGeneratorFo

  @aref sim_signalgeneratorfo
  @aref sim_signalgeneratorfo Sim_SignalGeneratorFo
*/
void Sim_SignalGeneratorFo_init(pwr_sClass_Sim_SignalGeneratorFo* o)
{
  pwr_tDlid dlid;
  pwr_tStatus sts;

  sts = gdh_DLRefObjectInfoAttrref(
      &o->PlcConnect, (void**)&o->PlcConnectP, &dlid);
  if (EVEN(sts))
    o->PlcConnectP = 0;
  else {
    if ( o->BiasP != &o->Bias)
      ((pwr_sClass_Sim_SignalGenerator *)o->PlcConnectP)->BiasConnected = 1;
  }
}

void Sim_SignalGeneratorFo_exec(plc_sThread* tp, pwr_sClass_Sim_SignalGeneratorFo* o)
{
  pwr_sClass_Sim_SignalGenerator* co = (pwr_sClass_Sim_SignalGenerator*)o->PlcConnectP;
  if (!co)
    return;

  pwr_tFloat32 value = co->Bias;


  if ( co->BiasConnected)
    o->Bias = co->Bias = *o->BiasP;
 
  switch ( co->Type) {
  case pwr_eSim_SignalGeneratorType_Straight:
    break;
  case pwr_eSim_SignalGeneratorType_Sine:
    if ( co->Period < FLT_MIN)
      break;
    co->Accum += *o->ScanTime;
    if ( co->Accum > M_PI * 1000)
      co->Accum -= M_PI * 1000;

    value += co->Amplitude * sinf(co->Accum / co->Period * M_PI * 2);
    break;
  case pwr_eSim_SignalGeneratorType_HalfSine:
    if ( co->Period < FLT_MIN)
      break;

    co->Accum += *o->ScanTime;
    if ( co->Accum > M_PI * 1000)
      co->Accum -= M_PI * 1000;

    value += co->Amplitude * fabs(sinf(co->Accum / co->Period  * M_PI * 2));
    break;
  case pwr_eSim_SignalGeneratorType_Square:
    if ( co->Period < FLT_MIN)
      break;

    co->Accum += *o->ScanTime;
    if ( co->Accum / co->Period > (int)(1000.0f / co->Period))
      co->Accum -= co->Period * (int)(1000.0f / co->Period);
    
    if ( co->Accum / co->Period - (int)(co->Accum / co->Period) <= 
	 co->PulseWidth/100)
      value += co->Amplitude;
    break;
  case pwr_eSim_SignalGeneratorType_SawTooth:
    if ( co->Period < FLT_MIN)
      break;

    co->Accum += *o->ScanTime;
    if ( co->Accum / co->Period > (int)(1000.0f / co->Period))
      co->Accum -= co->Period * (int)(1000.0f / co->Period);
    
    value += co->Amplitude * (co->Accum / co->Period - (int)(co->Accum / co->Period));
    if ( value > co->Bias + co->Amplitude)
      value -= co->Amplitude;
    break;
  case pwr_eSim_SignalGeneratorType_Triangular: {
    if ( co->Period < FLT_MIN)
      break;

    co->Accum += *o->ScanTime;
    if ( co->Accum / co->Period > (int)(1000.0f / co->Period))
      co->Accum -= co->Period * (int)(1000.0f / co->Period);
    
    float p = co->Accum / co->Period - (int)(co->Accum / co->Period);
    if ( p <= co->PulseWidth/100)
      value += co->Amplitude * p / (co->PulseWidth/100);
    else
      value += co->Amplitude * (1 - p) / (1 - (co->PulseWidth/100));

    break;
  }
  case pwr_eSim_SignalGeneratorType_StepPyramid: {
    if ( co->Period < FLT_MIN)
      break;

    co->Accum += *o->ScanTime;
    if ( co->Accum / co->Period > (int)(1000.0f / co->Period))
      co->Accum -= co->Period * (int)(1000.0f / co->Period);
    
    float p = co->Accum / co->Period - (int)(co->Accum / co->Period);
    int steps = (int)(1.0f / (co->PulseWidth/100));
    if (ODD(steps))
      steps -= 1;
    int current = (int)(p * steps);
    int height = steps/2;
    if ( current <= steps/2 - 1)
      value += co->Amplitude / height * (current + 1);
    else  if (current < steps - 1)
      value += co->Amplitude / height * (steps - current - 1);

    break;
  }
  }

  if ( co->FilterTime > 0.001f) {
    float a = 1.f - 1.f / ( 1.f + tp->f_scan_time / co->FilterTime);
    value = a * value + (1.f - a) * o->ActualValue;
  }

  if ( co->Noise > 0.01f) {
    value += (float)rand() / RAND_MAX * co->Noise * 2 - co->Noise;    
  }

  if (co->RampUp != 0.0f && value - o->ActualValue > co->RampUp * tp->f_scan_time)
    o->ActualValue += co->RampUp * tp->f_scan_time;
  else if (co->RampDown != 0.0f && value - o->ActualValue < -co->RampDown * tp->f_scan_time)
    o->ActualValue -= co->RampDown * tp->f_scan_time;
  else
    o->ActualValue = value;
  co->ActualValue = o->ActualValue;
}

/*_*
  Sim_CylinderTankFo

  @aref sim_cylindertankfo
  @aref sim_cylindertankfo Sim_CylinderTankFo
*/
void Sim_CylinderTankFo_init(pwr_sClass_Sim_CylinderTankFo* o)
{
  pwr_tDlid dlid;
  pwr_tStatus sts;

  sts = gdh_DLRefObjectInfoAttrref(
      &o->PlcConnect, (void**)&o->PlcConnectP, &dlid);
  if (EVEN(sts))
    o->PlcConnectP = 0;
}

void Sim_CylinderTankFo_exec(plc_sThread* tp, pwr_sClass_Sim_CylinderTankFo* o)
{
  pwr_sClass_Sim_CylinderTank* co = (pwr_sClass_Sim_CylinderTank*)o->PlcConnectP;
  if (!co)
    return;

  o->InFlow = *o->InFlowP;
  o->OutFlow = *o->OutFlowP;

  float area = co->Radius * co->Radius * M_PI;
  o->Level += (*o->InFlowP - *o->OutFlowP) * *o->ScanTime / area;
  if ( o->Level > co->MaxLevel)
    o->Level = co->MaxLevel;
  if ( o->Level < co->MinLevel)
    o->Level = co->MinLevel;
  o->Volume = o->Level * area;
  co->Level = o->Level;
  co->Volume = o->Volume;
  co->InFlow = o->InFlow;
  co->OutFlow = o->OutFlow;
}

/*_*
  Sim_FurnaceFo

  @aref sim_furnacefo
  @aref sim_furnacefo Sim_FurnaceFo
*/
void Sim_FurnaceFo_init(pwr_sClass_Sim_FurnaceFo* o)
{
  pwr_tDlid dlid;
  pwr_tStatus sts;

  sts = gdh_DLRefObjectInfoAttrref(
      &o->PlcConnect, (void**)&o->PlcConnectP, &dlid);
  if (EVEN(sts))
    o->PlcConnectP = 0;
}

void Sim_FurnaceFo_exec(plc_sThread* tp, pwr_sClass_Sim_FurnaceFo* o)
{
  pwr_sClass_Sim_Furnace* co = (pwr_sClass_Sim_Furnace*)o->PlcConnectP;
  if (!co)
    return;

  o->Power = *o->PowerP;

  o->Temperature += (*o->PowerP / co->ThermalCapacity - (o->Temperature - co->EnvTemperature) / co->ThermalResistance) * (*o->ScanTime);
  if ( o->Temperature > co->MaxTemperature)
    o->Temperature = co->MaxTemperature;
  if ( o->Temperature < co->MinTemperature)
    o->Temperature = co->MinTemperature;
  co->Temperature = o->Temperature;
  co->Power = *o->PowerP;
}
